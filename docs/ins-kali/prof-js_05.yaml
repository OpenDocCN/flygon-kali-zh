- en: '*Chapter 5*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*'
- en: Modular JavaScript
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化JavaScript
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Import and export functions and objects in JavaScript for code reusability
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JavaScript中导入和导出函数和对象以实现代码的可重用性
- en: Use JavaScript ES6 classes to reduce code complexity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaScript ES6类来减少代码复杂性
- en: Implement object-oriented programming concepts in JavaScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JavaScript中实现面向对象编程概念
- en: Create private variables for an object using encapsulation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用封装为对象创建私有变量
- en: Convert ES6 to generic JavaScript using Babel
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Babel将ES6转换为通用JavaScript
- en: Create and publish an npm package in JavaScript
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JavaScript中创建和发布npm包
- en: Combine modules using composability and strategies to create higher-level modules
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组合性和策略结合模块创建更高级的模块。
- en: In this chapter, we will learn about the importance of reusable code in modern
    JavaScript and how ES6 has introduced syntax for easily creating and using modules.
    We will create a JavaScript module that can be imported and used by different
    endpoints of our API.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习现代JavaScript中可重用代码的重要性，以及ES6如何引入了用于轻松创建和使用模块的语法。我们将创建一个JavaScript模块，可以被API的不同端点导入和使用。
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we built an API using Node.js and Express. We talked
    about designing the API structure, HTTP methods, and **JSON Web Token** (**JWT**)
    authentication. In this chapter, we'll be looking at various aspects of JavaScript
    modules and module-based design.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用Node.js和Express构建了一个API。我们讨论了设计API结构、HTTP方法和**JSON Web Token**（**JWT**）身份验证。在本章中，我们将研究JavaScript模块和基于模块的设计的各个方面。
- en: Modules are important for programming productivity, breaking software into reusable
    modules. The modular design encourages developers to build software out of small,
    single-focus components. You may be familiar with popular UI libraries, such as
    Bootstrap, Material-UI, and jQuery UI. These are all sets of components – minimal
    graphical elements purposefully built so that they can be used in many situations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模块对于编程生产力很重要，将软件分解为可重用的模块。模块化设计鼓励开发人员将软件构建成小的、单一焦点的组件。您可能熟悉流行的UI库，如Bootstrap、Material-UI和jQuery
    UI。这些都是一组组件 - 专门构建的最小图形元素，可以在许多情况下使用。
- en: Due to the extensive use of external libraries for both graphical elements and
    programming aspects, most developers are already familiar with the use of modules.
    That said, it is much easier to use a module than to create one or to write your
    application in a modular way.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于广泛使用外部库来处理图形元素和编程方面，大多数开发人员已经熟悉了模块的使用。也就是说，使用模块比创建模块或以模块化方式编写应用程序要容易得多。
- en: Note Components, Modules, and ES6 Modules
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意组件、模块和ES6模块
- en: There are various opinions as to the exact usage and relation of these terms.
    In this chapter, we refer to components as visual widgets that can be used on
    a website.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些术语的确切用法和关系有各种不同的观点。在本章中，我们将组件称为可以在网站上使用的视觉小部件。
- en: We'll refer to a module as a source code that is written in one file to be imported
    and used in another. As most components exist as reusable code, often imported
    by a script tag, we'll consider them modules. Of course, when you import the Bootstrap
    library, for example, you import all the components. That said, most libraries
    offer the ability to compile and import the specific components that are needed
    – for example, [https://getbootstrap.com/docs/3.4/customize/](https://getbootstrap.com/docs/3.4/customize/).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把一个模块称为在一个文件中编写的源代码，以便在另一个文件中导入和使用。由于大多数组件都存在为可重用代码，通常通过脚本标签导入，我们将把它们视为模块。当然，当您导入Bootstrap库时，您导入了所有组件。也就是说，大多数库都提供了编译和导入所需的特定组件的能力
    - 例如，[https://getbootstrap.com/docs/3.4/customize/](https://getbootstrap.com/docs/3.4/customize/)。
- en: When we refer to ES6 modules, we're talking about the specific syntax added
    to JavaScript in ES6 that allows for exporting a module in one file and importing
    it in another. While ES6 modules are part of the ES6 standard, it's important
    to remember that they're not currently supported by browsers. Making use of them
    requires a pre-compile step, which we will cover in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到ES6模块时，我们指的是ES6中添加的特定语法，允许在一个文件中导出一个模块，并在另一个文件中导入它。虽然ES6模块是ES6标准的一部分，但重要的是要记住它们目前不受浏览器支持。使用它们需要一个预编译步骤，我们将在本章中介绍。
- en: The recent explosion in the popularity and productivity of JavaScript is in
    part due to the **node package manager** (**npm**) ecosystem. Whether doing frontend
    or backend development with JavaScript, you're bound to use npm at some point.
    Hundreds of useful packages are made available to developers through the simple
    `npm install` command.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的受欢迎程度和生产力的最近爆炸部分原因是**node包管理器**（**npm**）生态系统。无论是使用JavaScript进行前端还是后端开发，您都可能在某个时候使用npm。通过简单的`npm
    install`命令，开发人员可以获得数百个有用的包。
- en: npm has become the largest source of modularized code on the internet, out of
    any programming language. npm now contains nearly a half a billion packages.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: npm现在已成为互联网上模块化代码的最大来源，超过任何编程语言。npm现在包含了将近50亿个包。
- en: All packages on npm are, at their core, modules. By grouping related functions
    as a module, we make that functionality reusable across multiple projects or multiple
    aspects of a single project.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: npm上的所有包本质上都是模块。通过将相关函数分组为一个模块，我们使得该功能可以在多个项目或单个项目的多个方面中重复使用。
- en: All great packages on npm have been built in a way that makes reuse across many
    projects easy. A good datetime picker widget, for example, can be used across
    thousands of projects, saving many hours of development time and likely yielding
    a better end product.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在npm上的优秀包都是以一种使其在许多项目中易于重用的方式构建的。例如，一个很好的日期时间选择器小部件可以在成千上万个项目中使用，节省了许多开发时间，并且可能产生更好的最终产品。
- en: In this section, we'll look at modular JavaScript and how we can improve our
    code by writing JavaScript in a modular way. This includes the basic syntax of
    exporting and importing, but, beyond that, there are several patterns and techniques
    that can be used to write better modules, such as concepts from object-oriented
    programming that are useful in module development. However, JavaScript is technically
    prototype-oriented, which is a specific style of object-oriented programming that
    differs from the classic object-oriented style in its use of prototypes as opposed
    to classes. We'll discuss prototypes and classes later in the chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论模块化的JavaScript以及如何通过以模块化的方式编写JavaScript来改进我们的代码。这包括导出和导入的基本语法，但除此之外，还有几种模式和技术可用于编写更好的模块，例如在模块开发中有用的面向对象编程的概念。然而，JavaScript在技术上是原型导向的，这是一种与经典面向对象风格不同的特定风格的面向对象编程，它使用原型而不是类。我们将在本章后面讨论原型和类。
- en: Dependencies and Security
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖关系和安全性
- en: While modules are a powerful technique, they can also get out of hand if not
    used with care. Each package added to a `node.js` project, for example, contains
    its own dependencies. So, it's important to keep an eye on the packages you're
    using to make sure you don't import anything malicious. There is a useful tool
    at the website [http://npm.broofa.com](http://npm.broofa.com), where you can upload
    a `package.json` file and get a visualization of the dependencies.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是一种强大的技术，但如果不小心使用，它们也可能失控。例如，添加到`node.js`项目中的每个包都包含自己的依赖关系。因此，重要的是要密切关注您正在使用的包，以确保您不会导入任何恶意内容。在网站[http://npm.broofa.com](http://npm.broofa.com)上有一个有用的工具，您可以在那里上传`package.json`文件并获得依赖关系的可视化。
- en: 'If we take the `package.json` file from *Exercise 1, Creating an Express Project
    with an Index Route*, in *Chapter 4, RESTful APIs with Node.js*, as an example,
    it contained only four `dependencies`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以*第1章练习1，使用Express创建项目并添加索引路由*中的`package.json`文件为例，它只包含四个`dependencies`：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Yet, when we upload this `package.json` file, we can see that our 4 dependencies
    balloon out to over 60 when accounting for sub-dependencies:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们上传这个`package.json`文件时，我们可以看到我们的4个依赖项在考虑子依赖时激增到了60多个：
- en: '![](Images/C14587_05_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/C14587_05_01.jpg)'
- en: 'Figure 5.1: 61 dependencies in package.json'
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.1：package.json中的61个依赖项
- en: This highlights the risk associated with module-based design and the need for
    thoughtful design when making and using modules. Badly written packages or modules
    can have unintended consequences. In recent years, there have been stories of
    widely used packages becoming malicious. For example, the `event-stream` package
    was downloaded over 8 million times in 2.5 months in 2018\. It was found that
    the once-legitimate module had been updated in an attempt to steal cryptocurrency
    from users' machines. Aside from security risks and bugs, there is also the risk
    of polluting the global namespace or lowering the performance of the parent project.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这突显了基于模块的设计所带来的风险，以及在制作和使用模块时需要深思熟虑的设计。糟糕编写的包或模块可能会产生意想不到的后果。近年来，有关广泛使用的包变得恶意的报道。例如，`event-stream`包在2018年的2.5个月内被下载了800多万次。发现这个曾经合法的模块已经更新，试图从用户的机器中窃取加密货币。除了安全风险和错误之外，还存在污染全局命名空间或降低父项目性能的风险。
- en: Note npm audit
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意npm audit
- en: As a response to cases of malicious dependencies or sub-dependencies, npm added
    an `audit` command, which can be used to check a package's dependencies for modules
    known to be malicious. Run `npm audit` in the directory of a Node.js project to
    check your project's dependencies. The command also runs automatically as part
    of `npm install` when you're installing projects downloaded from places such as
    GitHub.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对恶意依赖或子依赖的情况的回应，npm添加了一个`audit`命令，可以用来检查包的依赖关系，以查看已知为恶意的模块。在Node.js项目的目录中运行`npm
    audit`来检查项目的依赖关系。当您安装从GitHub等地方下载的项目时，该命令也会自动作为`npm install`的一部分运行。
- en: Other Costs of Modularity
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块化的其他成本
- en: 'Other costs associated with modular design include:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与模块化设计相关的其他成本包括：
- en: The cost of loading multiple parts
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载多个部分的成本
- en: The cost of bad modules (security and performance)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坏模块的成本（安全性和性能）
- en: A quick increase in the total amount of modules used
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的模块总量迅速增加
- en: Overall, these costs are generally acceptable, but caution should be used. When
    it comes to the overhead associated with loading many modules, pre-compilers such
    as `webpack` and `babel` can help by converting your whole program to a single
    file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这些成本通常是可以接受的，但应该谨慎使用。当涉及到加载许多模块所带来的开销时，预编译器（如`webpack`和`babel`）可以通过将整个程序转换为单个文件来帮助。
- en: 'A few things to bear in mind when you''re creating a module or importing one
    are the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建模块或导入模块时需要牢记以下几点：
- en: Does using a module hide significant complexity or save a significant amount
    of work?
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块是否隐藏了重要的复杂性或节省了大量的工作？
- en: Is the module from a trusted source?
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块是否来自可信任的来源？
- en: Does it have a lot of sub-dependencies?
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否有很多子依赖？
- en: 'Take the npm package, `isarray`, for example. The package contains a single
    function, which simply runs:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以npm包`isarray`为例。该包包含一个简单的函数，只是运行：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is an example where the answer to the first question, "Does using a module
    hide significant complexity?", is no. The second question – "Is it a trusted source?"
    Not particularly. Finally, in answer to the last question about sub-dependencies,
    it does not – and this is a good thing. Given the simplicity of this module, it
    is recommended to just write your own function based on the preceding single line.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，第一个问题的答案是“使用模块是否隐藏了重要的复杂性？”不是。第二个问题 - “它是来自可信任的来源吗？”并不特别。最后，对于关于子依赖的最后一个问题的回答是不是
    - 这是一件好事。鉴于这个模块的简单性，建议根据前面的单行编写自己的函数。
- en: Carelessly installing packages that add little benefit while increasing the
    complexity of the project should be avoided. If you consider the three points
    mentioned, you likely won't find it worth it to import packages such as `isarray`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 应避免随意安装增加项目复杂性而几乎没有好处的包。如果您考虑到了提到的三点，您可能不会觉得值得导入诸如`isarray`之类的包。
- en: Reviewing Imports and Exports
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 审查进口和出口
- en: 'In the last section, we made use of importing and exporting without going into
    depth on the topic. Whenever we created a new route, we made sure to put it in
    its own file in the `routes` folder. If you recall, all of our route files ended
    with a line exporting a `router` object:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用了导入和导出，但没有深入讨论这个主题。每当我们创建一个新的路由时，我们都会确保将其放在`routes`文件夹中的自己的文件中。如果您还记得，我们所有的路由文件都以导出`router`对象的行结束：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We also made use of our routes using the built-in `require` function from Node.js:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了Node.js内置的`require`函数来使用我们的路由：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Separation of Concerns
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关注点分离
- en: 'When it comes to designing a module, one of the key concepts is the **separation
    of concerns**. Separation of concerns means we should separate our software into
    parts that deal with a single concern of the program. A good module will focus
    on doing a single aspect of functionality well. Popular examples include:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计模块时，关键概念之一是**关注点分离**。关注点分离意味着我们应该将软件分成处理程序的单个关注点的部分。一个好的模块将专注于很好地执行单个功能方面。流行的例子包括：
- en: MySQL – A package with several methods for connecting to and using MySQL databases
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL - 一个具有多种方法连接和使用MySQL数据库的包
- en: Lodash – A package for efficiently parsing and working with arrays, objects,
    and strings
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lodash - 一个用于高效解析和处理数组、对象和字符串的包
- en: Moment – A popular package for working with dates and times
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Moment - 一个用于处理日期和时间的流行包
- en: Within these packages or within our own projects, there is often a further separation
    into sub-modules.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些包或我们自己的项目中，通常还会进一步分成子模块。
- en: Note ES6
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意ES6
- en: We've already used some ES6 features in prior chapters, but, as a reminder,
    ES6, or the longer ECMAScript, is short for European Computer Manufacturer's Association
    Script. ECMA is the organization responsible for the standardization of standards,
    including the new version of JavaScript, which was standardized in 2015.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们已经使用了一些ES6的特性，但是作为提醒，ES6，或者更长的ECMAScript，是欧洲计算机制造商协会脚本的缩写。ECMA是负责标准化标准的组织，包括2015年标准化的新版本JavaScript。
- en: ES6 Modules
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ES6模块
- en: When writing JavaScript with Node.js, the ability to import modules using the
    built-in `require()` function has long been used. As this feature was useful,
    many frontend developers began making use of it by pre-processing their JavaScript
    with compilers such as Babel. A JavaScript pre-compiler processes code that normally
    wouldn't work on most browsers and generates a new JavaScript file that is compatible.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Node.js编写JavaScript时，长期以来一直使用内置的`require()`函数来导入模块的能力。由于这个功能很有用，许多前端开发人员开始利用它，通过使用诸如Babel之类的编译器对他们的JavaScript进行预处理。JavaScript预编译器处理通常无法在大多数浏览器上运行的代码，并生成一个兼容的新JavaScript文件。
- en: As there was a large demand for an import style function in JavaScript, it was
    eventually added to the language in the ES6 version. At the time of writing, the
    latest version of most browsers is almost completely ES6 compatible. Yet the use
    of `import` can't be taken for granted, as many devices will continue to run older
    versions for years.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript中对导入样式函数的需求很大，它最终被添加到了ES6版本的语言中。在撰写本文时，大多数浏览器的最新版本几乎完全兼容ES6。然而，不能认为使用`import`是理所当然的，因为许多设备将继续运行多年前的旧版本。
- en: The rapid standardization of ES6 shows us that, going forward, ES6 imports will
    be the most popular method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ES6的快速标准化告诉我们，未来，ES6的导入将是最流行的方法。
- en: 'In the last chapter, we made use of the Node.js `require` method for importing
    a module. For example, take this line:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了Node.js的`require`方法来导入模块。例如，看看这一行：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The ES6 `import` function, on the other hand, has the following syntax:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，ES6的`import`函数具有以下语法：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The ES6 `import` function also allows you to import a subsection of a module,
    rather than importing the whole thing. This is one capability ES6''s `import`
    has over Node.js'' `require` function. Importing single components helps to save
    memory in your application. If we wanted to use just the `button` component from
    the React version of Bootstrap, for example, we could import just that:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ES6的`import`函数还允许您导入模块的子部分，而不是整个模块。这是ES6的`import`相对于Node.js的`require`函数的一个能力。导入单个组件有助于节省应用程序中的内存。例如，如果我们只想使用React版本的Bootstrap中的`button`组件，我们可以只导入那个：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we want to import additional components, we just add them to the list:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要导入额外的组件，我们只需将它们添加到列表中：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note React
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意React
- en: You've probably seen this style of importing if you've ever used the popular
    frontend framework React. The framework is known for its focus on modularity.
    It takes interactive frontend elements and packages them as components.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经使用过流行的前端框架React，您可能已经看到过这种导入方式。该框架以模块化为重点而闻名。它将交互式前端元素打包为组件。
- en: In traditional vanilla JavaScript/HTML, projects are often split into HTML/CSS/JavaScript
    with various components spread out across those files. React instead packages
    the related HTML/CSS/JavaScript of an element into a single file. That component
    is then imported into another React file and used as an element in the application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的纯JavaScript/HTML中，项目通常被分成HTML/CSS/JavaScript，各种组件分散在这些文件中。相反，React将元素的相关HTML/CSS/JavaScript打包到单个文件中。然后将该组件导入到另一个React文件中，并在应用程序中用作元素。
- en: 'Exercise 22: Writing a Simple ES6 Module'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习22：编写一个简单的ES6模块
- en: Note
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter has a starting point directory, which can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/start](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/start).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有一个起始点目录，可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/start](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/start)找到。
- en: The finished code for this exercise can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise22](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise22).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的完成代码可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise22](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise22)找到。
- en: 'In this exercise, we''ll export and import a module using ES6 syntax:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用ES6语法导出和导入一个模块：
- en: Change directories to `/Lesson_05/start/`; we'll use this as our starting point.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`/Lesson_05/start/`目录；我们将使用这个作为起点。
- en: Install project dependencies using `npm install`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm install`安装项目依赖项。
- en: 'Create the `js/light.js` file with the following code:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`js/light.js`文件，其中包含以下代码：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open the file called `js/viewer.js`. This is the JavaScript that will run on
    our page. At the top of the file, add:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开名为`js/viewer.js`的文件。这是将在我们页面上运行的JavaScript。在文件顶部添加：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At the bottom of `js/viewer.js`, add:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`js/viewer.js`的底部，添加：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`js/viewer.js` is already being included in `index.html`, so we can now start
    the program with `npm start`.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`js/viewer.js`已经包含在`index.html`中，所以现在我们可以使用`npm start`启动程序。'
- en: With the server running, open a web browser and go to `localhost:8000`. Once
    there, press *F12* to open the developer tools.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器运行时，打开一个Web浏览器，转到`localhost:8000`。一旦到达那里，按下*F12*打开开发者工具。
- en: 'If you''ve done everything right, you should see our object being logged in
    the Google Chrome console:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您做得没错，您应该在Google Chrome控制台中看到我们的对象被记录：
- en: '![Figure 5.2: Object logged in the Google Chrome console'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2：在Google Chrome控制台中记录的对象'
- en: '](Images/C14587_05_02.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_05_02.jpg)'
- en: 'Figure 5.2: Object logged in the Google Chrome console'
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.2：在Google Chrome控制台中记录的对象
- en: Objects in JavaScript
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript中的对象
- en: If you've been writing JavaScript for even a short time, you'll quickly come
    across the `object` type. JavaScript is designed using prototypes, a type of object-based
    programming. An object in JavaScript is a variable that can contain multiple properties.
    These properties can point to values, sub-objects, or even functions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经写了一段时间的JavaScript，您很快就会遇到`object`类型。JavaScript是使用原型设计的，这是一种基于对象的编程类型。JavaScript中的对象是一个可以包含多个属性的变量。这些属性可以指向值、子对象，甚至函数。
- en: Every variable in a JavaScript program is either an object or a primitive. A
    primitive is a more basic type that contains only a single piece of information,
    with no properties or methods. What complicates JavaScript and makes objects even
    more important is that even most basic types such as strings and numbers are wrapped
    in an object once assigned to a variable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript程序中的每个变量都是对象或原始值。原始值是一种更基本的类型，只包含单个信息片段，没有属性或方法。使JavaScript变得更加复杂并使对象变得更加重要的是，即使是最基本的类型，如字符串和数字，一旦分配给变量，也会被包装在对象中。
- en: 'For example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code shows that even a basic string variable in JavaScript has
    properties and methods.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示，即使在JavaScript中，基本的字符串变量也具有属性和方法。
- en: 'A true primitive has no properties or methods. For example, numbers declared
    directly are primitives:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的原始值没有属性或方法。例如，直接声明的数字是原始值：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Prototypes
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原型
- en: 'As mentioned earlier, JavaScript is a prototype-oriented language. This is
    a variation on object-oriented programming where prototypes are used instead of
    classes. A prototype is an object that is used as a starting point for another.
    For example, in the last section, we looked at a simple string variable:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，JavaScript是一种基于原型的语言。这是面向对象编程的一种变体，其中使用原型而不是类。原型是另一个对象作为另一个对象的起点。例如，在上一节中，我们看了一个简单的字符串变量：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we saw in the last section, `myString` comes with some built-in functions,
    such as `toUpperCase()`, and attributes, such as `length`. Behind the scenes,
    `myString` is an object that is being created from the string prototype. This
    means that all the properties and functions that exist in the string prototype
    also exist in `myString`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中看到的，`myString`带有一些内置函数，比如`toUpperCase()`，以及属性，比如`length`。在幕后，`myString`是从字符串原型创建的对象。这意味着字符串原型中存在的所有属性和函数也存在于`myString`中。
- en: 'JavaScript objects contain a special attribute called `__proto__` property,
    which contains the parent prototype for an object. To look at this, let''s run
    `console.dir(myString)` in the Google Chrome Developer Console:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对象包含一个名为`__proto__`属性的特殊属性，该属性包含对象的父原型。为了查看这一点，让我们在Google Chrome开发者控制台中运行`console.dir(myString)`：
- en: '![Figure 5.3: Prototypes in JavaScript (String)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3：JavaScript中的原型（字符串）'
- en: '](Images/C14587_05_03.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_05_03.jpg)'
- en: 'Figure 5.3: Prototypes in JavaScript (String)'
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.3：JavaScript中的原型（字符串）
- en: 'Running the command returns `String`, an object that contains several methods.
    The built-in `String` object itself has a prototype. Next, run `console.dir(myString.__proto__.__proto__)`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该命令返回`String`，一个包含多个方法的对象。内置的`String`对象本身具有原型。接下来，运行`console.dir(myString.__proto__.__proto__)`：
- en: '![Figure 5.4: Prototypes in JavaScript (Object)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4：JavaScript中的原型（对象）'
- en: '](Images/C14587_05_04.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_05_04.jpg)'
- en: 'Figure 5.4: Prototypes in JavaScript (Object)'
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.4：JavaScript中的原型（对象）
- en: 'Running it again with an additional `__proto__` property will return `null`.
    All prototypes in JavaScript eventually lead to `null`, which is the only prototype
    that itself does not have a prototype:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行带有附加`__proto__`属性的命令将返回`null`。JavaScript中的所有原型最终都指向`null`，这是唯一一个本身没有原型的原型：
- en: '![Figure 5.5: Additional _proto_ returning null'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.5：附加_proto_返回null'
- en: '](Images/C14587_05_05.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_05_05.jpg)'
- en: 'Figure 5.5: Additional _proto_ returning null'
  id: totrans-119
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.5：附加_proto_返回null
- en: 'This relationship, where one prototype leads to another and so on, is referred
    to as the prototype chain:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这种一个原型导致另一个原型，依此类推的关系被称为原型链：
- en: '![Figure 5.6: Prototype chain'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6：原型链'
- en: '](Images/C14587_05_06.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_05_06.jpg)'
- en: 'Figure 5.6: Prototype chain'
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.6：原型链
- en: Whenever you use an attribute of a variable in JavaScript, it starts at the
    current object, and, if it doesn't find it, it looks in the parent prototype.
    So, when we run `myString.toUpperCase()`, it first looks in `myString`. After
    not finding a method of that name, it checks `String`, where it finds the method.
    In the case that `String` did not contain the method, it would check the `Object`
    prototype, and then it would reach `null`, at which point a `not found error`
    is returned.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，当你使用变量的属性时，它从当前对象开始查找，如果找不到，就会在父原型中查找。因此，当我们运行`myString.toUpperCase()`时，它首先在`myString`中查找。在那里找不到该名称的方法后，它会检查`String`，在那里找到该方法。如果`String`中没有包含该方法，它将检查`Object`原型，然后达到`null`，此时会返回`not
    found error`。
- en: 'JavaScript provides the syntax to redefine the behavior of any prototype function,
    whether built-in or user defined. This can be done using the following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript提供了重新定义任何原型函数行为的语法，无论是内置的还是用户定义的。可以使用以下命令来实现：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the next exercise, we'll modify the built-in `Number` prototype to give it
    some extra functionality. Remember that this technique can be applied to both
    built-in and custom-built prototypes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将修改内置的`Number`原型，以赋予它一些额外的功能。请记住，这种技术可以应用于内置和自定义的原型。
- en: 'Exercise 23: Extending the Number Prototype'
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习23：扩展Number原型
- en: 'In this exercise, we''ll look at an example of extending one of JavaScript''s
    built-in prototypes, `Number`, to include some additional functions. After *step
    1*, see whether you can come up with the second solution yourself:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看一个例子，扩展JavaScript的内置原型`Number`，以包含一些额外的函数。在*步骤1*之后，看看你是否能自己想出第二个解决方案：
- en: double (returns the value multiplied by two)
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: double（返回值乘以二）
- en: square (returns the number multiplied by itself)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: square（返回数字乘以自身）
- en: Fibonacci (returns `n` in Fibonacci sequence, where each number is the sum of
    the previous two numbers)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fibonacci（返回斐波那契序列中的`n`，其中每个数字是前两个数字的和）
- en: factorial (returns the result of multiplying all numbers between 1 and `n`)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阶乘（返回1和`n`之间所有数字的乘积的结果）
- en: 'Here are the steps to follow:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要遵循的步骤：
- en: 'In a new folder, create a file called `number.js`. We''ll start by adding a
    `double` function to the `Number` prototype. Notice the use of `this.valueOf()`
    to retrieve the value of the number:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的文件夹中，创建一个名为`number.js`的文件。我们将首先向`Number`原型添加一个`double`函数。注意使用`this.valueOf()`来检索数字的值：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, following the same pattern, we''ll add a solution for the square of any
    number:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按照相同的模式，我们将为任意数字的平方添加一个解决方案：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Again, we''ll follow the same pattern, though the solution to this one is a
    bit trickier, as it uses recursion with memorization, and the use of the `BigInt`
    prototype:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们将遵循相同的模式，尽管这个问题的解决方案有点棘手，因为它使用了记忆递归，并且使用了`BigInt`原型：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note BigInt (Big Integer)
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意BigInt（大整数）
- en: You'll notice in the preceding step that we used the `BigInt` keyword. `BigInt`,
    like `Number`, is another prototype built into JavaScript. It was the first new
    primitive in ES6\. The main difference is that `BigInt` is safe for dealing with
    very large numbers. The `Number` prototype starts to fail with any value greater
    than `9007199254740991`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，你会注意到我们使用了`BigInt`关键字。`BigInt`和`Number`一样，是JavaScript内置的另一个原型。它是ES6中的第一个新的原始类型。主要区别在于`BigInt`可以安全处理非常大的数字。`Number`原型在大于`9007199254740991`的值时开始失败。
- en: A number can be converted to `BigInt` either by wrapping it with `BigInt()`
    or by appending `n`; notice the use of `0n` and `1n`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数字可以通过用`BigInt()`包装它或附加`n`来转换为`BigInt`；注意使用`0n`和`1n`。
- en: 'Next, we''ll add a solution for the factorial using the same pattern and `BigInt`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用相同的模式和`BigInt`添加阶乘的解决方案：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To demonstrate, define a number and call the functions:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示，定义一个数字并调用函数：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the script using Node.js:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Node.js运行脚本：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should get back a similar result to the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到类似以下的结果：
- en: '![Figure 5.7: Output after extending JavaScript’s built-in prototype'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.7：扩展JavaScript内置原型后的输出'
- en: '](Images/C14587_05_07.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_05_07.jpg)'
- en: 'Figure 5.7: Output after extending JavaScript''s built-in prototype'
  id: totrans-153
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.7：扩展JavaScript内置原型后的输出
- en: ES6 Classes
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES6类
- en: As mentioned earlier, one of the key differences between prototype-based languages
    and classic object-oriented languages is the use of prototypes instead of classes.
    However, ES6 has introduced built-in classes. We will start by comparing and creating
    an object using prototype syntax to ES6 class syntax by creating a `Vehicle` prototype/class
    and a `Car` prototype/class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，基于原型的语言和经典面向对象语言之间的关键区别之一是使用原型而不是类。然而，ES6引入了内置类。我们将通过创建`Vehicle`原型/类和`Car`原型/类，比较并使用原型语法和ES6类语法创建对象。
- en: 'First, the prototype way:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是原型的方式：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, the same thing with ES6 classes:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用ES6类做同样的事情：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The ES6 syntax for class syntax allows us to write code in an object-oriented
    way. At a lower level in the language, classes are simply syntactic styling for
    creating prototypes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ES6类语法允许我们以面向对象的方式编写代码。在语言的较低级别上，类只是用于创建原型的语法样式。
- en: In the coming section, we'll discuss programming in an object-oriented style
    using ES6 classes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将讨论使用ES6类以面向对象的方式进行编程。
- en: Object-Oriented Programming (OOP)
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）
- en: It is important to make a clear distinction between JavaScript objects and **object-oriented
    programming** (**OOP**). These are two very different things. The JavaScript object
    is simply a key-value pair that contains properties and methods. OOP, on the other
    hand, is a set of principles that can be used to write more organized and efficient
    code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要清楚地区分JavaScript对象和面向对象编程（OOP）。这是两个非常不同的东西。JavaScript对象只是一个包含属性和方法的键值对。另一方面，面向对象编程是一组原则，可以用来编写更有组织和高效的代码。
- en: OOP is not required for modular JavaScript, but it contains many concepts relevant
    to modular JavaScript. The use of classes is an essential aspect of OOP that allows
    us to reuse code by creating classes and subclasses.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化JavaScript并不需要面向对象编程，但它包含许多与模块化JavaScript相关的概念。类的使用是面向对象编程的一个基本方面，它允许我们通过创建类和子类来重用代码。
- en: It teaches us to group related aspects of a program in a way that makes maintenance
    and debugging easier. It has a focus on classes and subclasses that makes reusing
    code more practical.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 它教导我们以使维护和调试更容易的方式对程序的相关方面进行分组。它侧重于类和子类，使得代码重用更加实际。
- en: Historically, OOP became a popular way to deal with spaghetti code (messy, hard-to-read
    code) that was being commonly written in procedural code. Often, unorganized procedural
    code became fragile and rigid due to the interdependence of functions. A change
    in one aspect of the program may cause completely unrelated bugs to appear.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，面向对象编程成为处理过程代码中常见的混乱、难以阅读的代码（意思不明确的代码）的一种流行方式。通常，无组织的过程代码由于函数之间的相互依赖而变得脆弱和僵化。程序的某一方面的变化可能会导致完全不相关的错误出现。
- en: Imagine we're fixing a car and changing the headlight caused a problem with
    the engine. We would consider this to be bad architecture on the part of the designer
    of the car. Modular programming embraces the grouping of common aspects of a program.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们正在修理一辆汽车，更换前灯导致发动机出现问题。我们会认为这是汽车设计者的糟糕架构。模块化编程拥抱程序的共同方面的分组。
- en: 'There are four core concepts of OOP:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程有四个核心概念：
- en: Abstraction
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象
- en: Encapsulation
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Inheritance
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Polymorphism
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态
- en: Throughout this chapter, we'll look at these four principles and how they can
    be used in the JavaScript programming language using ES6 syntax. We'll try to
    focus on practical application in this chapter but relate back to the core concepts
    above.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看这四个原则以及如何使用ES6语法在JavaScript编程语言中使用它们。在本章中，我们将尝试专注于实际应用，但与上述核心概念相关。
- en: Abstraction
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象
- en: 'Abstraction is a high-level concept used throughout programming and is the
    foundation of OOP. It allows us to create complex systems by not having to deal
    with the specific implementation. When we use JavaScript, many things are abstracted
    by default. For example, consider the following array and the use of the built-in
    `includes()` function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象是编程中使用的高级概念，也是面向对象编程的基础。它允许我们通过不必处理具体实现来创建复杂系统。当我们使用JavaScript时，许多东西默认被抽象化。例如，考虑以下数组和内置的`includes()`函数的使用：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We don't need to know the algorithm or code that is used when we run `includes()`.
    All we need to know is that it will return `true` if the `car` is in the array
    and `false` if it is not. This is an example of abstraction. It is possible that
    as versions of JavaScript change, the inner workings of the algorithm for `include()`
    may change. It may get faster or smarter in some way, but because it has been
    abstracted, we don't need to worry about the program breaking. We simply have
    to know the condition upon which it will return `true` or `false`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要知道在运行`includes()`时使用的算法或代码。我们只需要知道如果数组中包含`car`，它将返回`true`，如果不包含则返回`false`。这是一个抽象的例子。随着JavaScript版本的更改，`include()`的内部工作方式可能会发生变化。它可能变得更快或更智能，但因为它已经被抽象化，我们不需要担心程序会出错。我们只需要知道它将返回`true`或`false`的条件。
- en: We don't need to consider how our computer converts binary to visuals on the
    screen, or how pressing a key creates an event in our browser. Even the keywords
    that make up the JavaScript language are themselves code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要考虑计算机如何将二进制转换为屏幕上的图像，或者按下键盘如何在浏览器中创建事件。甚至构成JavaScript语言的关键字本身也是代码。
- en: It is possible to look at the lower-level code that executes when we use built-in
    JavaScript functions, which will differ between browser engines. With `JSON.stringify()`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看在使用内置JavaScript函数时执行的低级代码，这些代码在浏览器引擎之间会有所不同。使用`JSON.stringify()`。
- en: Let's take a moment to think about what an abstract object is. Consider an apple
    on your desk sitting next to you; this is a specific apple. It's an instance of
    the idea or classification of an apple. We can also talk about the idea of the
    apple and what makes an apple an apple; what attributes are common in apples and
    which are required to make an apple.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一点时间思考抽象对象是什么。想象一下你桌子上的一个苹果，这是一个具体的苹果。它是苹果的一个实例或分类的概念。我们也可以谈论苹果的概念以及什么使苹果成为苹果；哪些属性在苹果中是共同的，哪些是必需的。
- en: When I say the word *apple*, a picture of the fruit comes into your mind. The
    exact details of how you imagine the apple is based on your mind's version of
    the idea of an apple. When we define an apple class in a computer program, we
    are defining how the program defines the class of an apple. As in our imagination,
    an idea of a thing can be as specific or unspecific as we desire. It may contain
    only a few factors, such as shape and color, or dozens, including weight, origin,
    and flavor.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说“苹果”这个词时，你脑海中会浮现出水果的图片。你想象中的苹果的确切细节取决于你对苹果概念的理解。当我们在计算机程序中定义一个苹果类时，我们正在定义程序如何定义苹果类。就像我们的想象力一样，一个事物的概念可以是具体的或不具体的。它可能只包含一些因素，比如形状和颜色，也可能包含几十个因素，包括重量、产地和口味。
- en: Classes and Constructors
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类和构造函数
- en: In the first exercise, we created a light module. While it is a module, it isn't
    object-oriented. In this section, we'll go about redesigning that module in an
    object-oriented way.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个练习中，我们创建了一个灯模块。虽然它是一个模块，但它不是面向对象的。在本节中，我们将以面向对象的方式重新设计该模块。
- en: 'One of the most essential aspects of a class is its constructor. The constructor
    is a built-in function that is called when an instance of a class is created.
    Often, the constructor is used to define the attributes of an object. For example,
    you''ll often see something like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 类最重要的一个方面是它的构造函数。构造函数是在创建类的实例时调用的内置函数。通常，构造函数用于定义对象的属性。例如，您经常会看到类似于这样的东西：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The passed arguments are saved to the instance for later use. You also might
    add some additional attributes not based on the passed arguments. For example,
    say we want to give our apple a birthdate by attaching a datetime stamp. We could
    add a third line inside our constructor:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 传递的参数将保存到实例中以供以后使用。您还可以根据传递的参数添加一些额外的属性。例如，假设我们想通过附加日期时间戳来给我们的苹果一个出生日期。我们可以在我们的构造函数内添加第三行：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Or we may want to call some other function within the light module. Imagine
    a game where every apple that enters the world has a 1 in 10 chance of being rotten:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可能想在灯模块中调用一些其他函数。想象一下，每个进入世界的苹果都有1/10的机会是腐烂的：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our class would need to contain a `checkIfRotten` function, which would set
    the `isRotten` attribute to `true` 1 out of 10 times:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类需要包含一个`checkIfRotten`函数，该函数将`isRotten`属性设置为10次中的1次为`true`：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Exercise 24: Converting a Light Module to a Class'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习24：将灯模块转换为类
- en: Note
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: This exercise uses the end product of *Exercise 22, Writing a Simple ES6 Module*
    of this chapter, as a starting point. The state of the code after completing this
    exercise can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise24](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise24).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习使用本章*练习22，编写一个简单的ES6模块*的最终产品作为起点。完成此练习后的代码状态可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise24](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise24)找到。
- en: Let's return to our light example from *Exercise 22, Writing a Simple ES6 Module,*
    of this chapter. We'll take the attributes defined in the previous chapter for
    the light module and assign them at creation. In addition, we'll write functions
    that check the format of the light attributes. If a light was created with an
    invalid attribute value, we'll set it to a default value.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到本章*练习22，编写一个简单的ES6模块*中的灯示例。我们将使用在上一章中为灯模块定义的属性，并在创建时进行分配。此外，我们将编写函数来检查灯属性的格式。如果使用无效的属性值创建了灯，我们将将其设置为默认值。
- en: 'The following are the steps to perform the exercise:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 执行练习的步骤如下：
- en: Open up `js/light.js` and delete the code from the previous exercise.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`js/light.js`并删除上一个练习中的代码。
- en: 'Create a class declaration for our `Light` class:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的`Light`类创建一个类声明：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the `constructor` function to the class and set the attributes from the
    arguments as well as a `datetime` attribute. Instead of setting `state` and `brightness`
    directly, we''ll first pass arguments to two functions to check the correct format.
    The logic for these functions will be written in the following steps:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向类添加`constructor`函数，并从参数中设置属性以及`datetime`属性。我们将首先将参数传递给两个函数以检查正确的格式，而不是直接设置`state`和`brightness`。这些函数的逻辑将在以下步骤中编写：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the `checkStateFormat` and `checkBrightnessFormat` functions to the class
    declaration:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`checkStateFormat`和`checkBrightnessFormat`函数添加到类声明中：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add a `toggle` function and a `test` function, which we''ll use for debugging.
    Both of these functions should also be within the class declaration. The `toggle`
    function will simply turn the light''s state to the opposite of its current state;
    for example, on to off, and vice versa:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`toggle`函数和一个`test`函数，我们将用于调试。这两个函数也应该在类声明内。`toggle`函数将简单地将灯的状态转换为当前状态的相反状态；例如，从开到关，反之亦然：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In `js/lightBulb.js`, below your class declaration, add a module export as
    we did in the previous exercise:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`js/lightBulb.js`中，在类声明下面，添加一个模块导出，就像我们在上一个练习中所做的那样：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Open `js/viewer.js` and replace the `light()` line we wrote in *Exercise 22,
    Writing a Simple ES6 Module*, with a variable containing an instance of the `Light`
    class:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`js/viewer.js`，并用包含`Light`类实例的变量替换我们在*练习22，编写一个简单的ES6模块*中编写的`light()`行：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Below the preceding line in `js/viewer.js`, add the following code. This code
    connects the source of the image to `state`, and the opacity of the image to `brightness`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`js/viewer.js`中的前一行下面，添加以下代码。此代码将图像的源连接到`state`，并将图像的不透明度连接到`brightness`：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Return to the project directory and run `npm start`. With the project running,
    open `localhost:8000` in your browser. You should see a new picture for the light
    indicating that it''s on:![Figure 5.8: Light with a state of true'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回项目目录并运行`npm start`。项目运行后，在浏览器中打开`localhost:8000`。您应该看到灯的新图片，指示它是开启的：![图5.8：状态为true的灯
- en: '](Images/C14587_05_08.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_05_08.jpg)'
- en: 'Figure 5.8: Light with a state of true'
  id: totrans-214
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.8：状态为true的灯
- en: With the page open, click the image and ensure that doing so causes the image
    to change. Also, notice the input slider at the bottom of the page. Try changing
    the value to confirm that doing so updates the opacity of the image.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 打开页面后，单击图像并确保这样做会导致图像更改。还要注意页面底部的输入滑块。尝试更改值以确认这样做是否会更新图像的不透明度。
- en: Note Naming Convention of Classes
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类的命名约定
- en: 'In the preceding code, we created a `Light` class. Notice that we''re using
    a capital "L" rather than the usual camelcase used in JavaScript. It is common
    practice to capitalize the names of classes; refer to Google''s JavaScript styling
    guide for more details on naming conventions: [https://google.github.io/styleguide/javascriptguide.xml#Naming](https://google.github.io/styleguide/javascriptguide.xml#Naming).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了一个`Light`类。请注意，我们使用的是大写的“L”，而不是JavaScript中通常使用的驼峰命名法。将类的名称大写是一种常见的做法；有关命名约定的更多详细信息，请参阅Google的JavaScript样式指南：[https://google.github.io/styleguide/javascriptguide.xml#Naming](https://google.github.io/styleguide/javascriptguide.xml#Naming)。
- en: Camelcase is the most popular naming style in JavaScript. Other styles include
    snake_case, kebab-case, and PascalCase.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Camelcase是JavaScript中最流行的命名风格。其他风格包括snake_case、kebab-case和PascalCase。
- en: Default Attributes
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认属性
- en: 'One of the most common things you''ll want to make use of with classes is default
    attribute values. Often, you want to create an instance of your class but don''t
    care about the specifics of the attributes – without specifying arguments, for
    example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类时，您最常用的功能之一是默认属性值。通常，您希望创建类的实例，但不关心属性的具体值-例如，不指定参数：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Both `state` and `brightness` will default to `undefined`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`state`和`brightness`都将默认为`undefined`。'
- en: 'With the code we''ve written, calling `light` without attributes won''t raise
    an error because we''ve written `checkStateFormat` and `checkBrightnessFormat`
    to account for all invalid values. However, in many cases, you can simplify your
    code by providing default values in the constructor as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们编写的代码，调用没有属性的`light`不会引发错误，因为我们编写了`checkStateFormat`和`checkBrightnessFormat`来处理所有无效值。然而，在许多情况下，您可以通过在构造函数中提供默认值来简化代码，如下所示：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding syntax isn't specific to the class `constructor` and can be used
    to set the default arguments of any function, assuming you're using ES6, ES2015,
    or a newer version of JavaScript. Default parameters are not available in versions
    before ES2015.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语法不是特定于类`constructor`，可以用于设置任何函数的默认参数，假设您使用的是ES6、ES2015或更新版本的JavaScript。默认参数在ES2015之前的版本中不可用。
- en: Encapsulation
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 封装
- en: 'Encapsulation is the idea that modules should only make object properties available
    for consumption when necessary. Furthermore, properties should be accessed and
    modified using functions rather than directly. As an example, let''s go back to
    our light module. Inside the `constructor` function, we made sure that we first
    ran the values through state checkers:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是模块只在必要时才公开对象属性的想法。此外，应该使用函数而不是直接访问和修改属性。例如，让我们回到我们的灯模块。在`constructor`函数内部，我们确保首先通过状态检查器运行值：
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s say you develop the preceding module and release it to be used by your
    colleagues. You don''t have to worry about them initializing the class with the
    wrong values, because if they do, `checkBrightnessFormat()` will automatically
    correct the value. However, once an instance of our class exists, nothing is stopping
    others from modifying that value directly:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您开发了前面的模块并发布供同事使用。您不必担心他们使用错误的值初始化类，因为如果他们这样做，`checkBrightnessFormat()`将自动更正该值。但是，一旦我们的类的实例存在，其他人就可以直接修改该值，没有任何阻止：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In a single command, our `Light` class's `checkBrightnessFormat` function has
    been sidestepped and we have a light with a `brightness` value of `hello`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个命令中，我们绕过了`Light`类的`checkBrightnessFormat`函数，并且我们有了一个`brightness`值为`hello`的灯。
- en: Encapsulation is the idea of writing our code in a way that makes this impossible.
    Languages such as C# and Java make encapsulation easy. Unfortunately, even with
    the ES6 update, the use of encapsulation in JavaScript is not obvious. There are
    a few ways to do this; one of the most popular takes advantage of the built-in
    `WeakMap` object type, which is also new to ES6.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是以使这种情况不可能的方式编写我们的代码的想法。诸如C#和Java之类的语言使封装变得容易。不幸的是，即使在ES6更新后，JavaScript中使用封装也不明显。有几种方法可以做到这一点；其中最受欢迎的方法之一是利用内置的`WeakMap`对象类型，这也是ES6的新功能之一。
- en: WeakMap
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WeakMap
- en: The **WeakMap** object is a key-value pair collection where a key is an object.
    WeakMap has a special characteristic where, if an object that is a key in WeakMap
    is removed from the program and no reference exists to it, WeakMap removes the
    associated pair from its collection. This process of removing the pair is known
    as garbage collection. Thus, the element is particularly useful in cases where
    the use of a map could cause a memory leak.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**WeakMap**对象是一个键值对集合，其中键是对象。WeakMap具有一个特殊的特性，即如果WeakMap中的键对象被从程序中移除并且没有对它的引用存在，WeakMap将从其集合中删除关联的键值对。这个删除键值对的过程称为垃圾回收。因此，在使用映射可能导致内存泄漏的情况下，该元素特别有用。'
- en: An example where WeakMap would be used over Map is that of a script that keeps
    track of each element in a dynamically changing HTML page. Say that each element
    in the DOM is iterated and we create some extra data about each element in our
    Map. Then, as time goes on, elements are added and removed from the DOM. With
    Map, all the old DOM elements will continue to be referenced, causing the memory
    used to increase over time, by storing useless information relating to deleted
    DOM elements. With WeakMap, the deletion of the DOM element (which is the key
    object in the collection) causes the associated entry in the collection to be
    removed during garbage collection.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: WeakMap比Map更适合的一个例子是，一个脚本跟踪动态变化的HTML页面中的每个元素。假设DOM中的每个元素都被迭代，我们在Map中创建了一些关于每个元素的额外数据。然后，随着时间的推移，元素被添加到DOM中并从中删除。使用Map，所有旧的DOM元素将继续被引用，导致存储与已删除的DOM元素相关的无用信息，从而导致随着时间的推移内存使用量增加。使用WeakMap，DOM元素的删除（它是集合中的键对象）会导致在垃圾回收期间删除集合中的关联条目。
- en: 'Here, we will make use of `WeakMap()`. First, we create an empty `map` variable,
    and then create a `light` object with some attributes. Then, we associate the
    object itself with a string, `kitchen light`. This isn''t a case of adding a property
    to `light`; rather, we are using the object as if it was a property name in the
    map:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用`WeakMap()`。首先，我们创建一个空的`map`变量，然后创建一个带有一些属性的`light`对象。然后，我们将对象本身与一个字符串`kitchen
    light`关联起来。这不是向`light`添加属性的情况；相反，我们使用对象就像它是地图中的属性名称一样：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Also, it''s important to note that the key object is based on the specific
    reference to the object. If we create a second light with the same attribute values,
    that counts as a new key:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，需要注意的是，键对象是基于对对象的特定引用。如果我们创建具有相同属性值的第二个灯，那将算作一个新的键：
- en: '[PRE40]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we update the properties of an object, that doesn''t change the mapping:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更新对象的属性，那不会改变映射：
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The mapping will exist until the key object goes out of scope, or until it
    is set to null and garbage collected; for example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 映射将存在，直到键对象超出范围，或者直到它被设置为null并进行垃圾回收；例如：
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Exercise 25: WeakMap for Encapsulation'
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习25：封装的WeakMap
- en: Note
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: This exercise uses the end product of *Exercise 24, Converting a Light Module
    to a Class*, of this chapter as a starting point. The state of the code after
    completing this exercise can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise25](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise25).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习以本章的*练习24，将灯模块转换为类*的最终产品为起点。完成此练习后的代码状态可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise25](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise25)找到。
- en: 'In this exercise, we will use `WeakMap` to create private variables that can''t
    be accessed directly from outside a module. Perform the following steps to complete
    the exercise:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`WeakMap`来创建无法直接从模块外部访问的私有变量。执行以下步骤完成练习：
- en: 'Open `js/light.js` and, at the very top of the file, add a `WeakMap` object
    called `privateVars`:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`js/light.js`，并在文件顶部添加一个名为`privateVars`的`WeakMap`对象：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In `js/light.js`, modify the `constructor` function so that the object properties
    are saved to `privateVars` using the `set` method, instead of directly on the
    object:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`js/light.js`中，修改`constructor`函数，使得对象属性通过`set`方法保存到`privateVars`中，而不是直接在对象上：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, in `js/light.js`, modify the `toggle` function so that we''re getting
    state info from our `WeakMap` object named `privateVars`. Notice that when we
    set the variable, we are sending back an object that contains all info, not just
    `state`. In our example, each instance of `light` has a single `info` object associated
    with `WeakMap`:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`js/light.js`中，修改`toggle`函数，以便我们从名为`privateVars`的`WeakMap`对象获取状态信息。请注意，当我们设置变量时，我们发送回一个包含所有信息而不仅仅是`state`的对象。在我们的示例中，每个`light`实例都与`WeakMap`关联的单个`info`对象：
- en: '[PRE45]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We also need to modify the `test` function in `js/light.js` in a similar way.
    We''ll change the source of `state` that is sent to the user in an alert to `WeakMap`:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要以类似的方式修改`js/light.js`中的`test`函数。我们将改变发送给用户的`state`的来源，以便在警报中使用`WeakMap`：
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Since encapsulation takes away the ability to change state and brightness directly,
    we need to add methods that allow for this. We''ll start by adding a `setState`
    function in `js/light.js`. Notice that it is almost identical to our `toggle`
    function:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于封装夺走了直接更改状态和亮度的能力，我们需要添加允许这样做的方法。我们将从在`js/light.js`中添加`setState`函数开始。请注意，它几乎与我们的`toggle`函数相同：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, add the getter method in `js/light.js`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`js/light.js`中添加getter方法：
- en: '[PRE48]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Follow the pattern from the last two steps to add getter and setter functions
    for the `brightness` property in `js/light.js`:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照最后两个步骤的模式，在`js/light.js`中为`brightness`属性添加getter和setter函数：
- en: '[PRE49]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The last change we need to make is in `js/viewer.js`. Below where the variables
    are declared, change each reference to light brightness and state to use the getter
    methods we created:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的最后一个更改是在`js/viewer.js`中。在变量声明下面，将每个对光亮度和状态的引用更改为使用我们创建的getter方法：
- en: '[PRE50]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Run the code with `npm start` and view the page project in your browser at
    `localhost:8000`. Check to make sure clicking the image works, as well as changing
    brightness using the input slider:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm start`运行代码，并在浏览器中查看`localhost:8000`上的页面项目。检查确保单击图像有效，以及使用输入滑块更改亮度有效：
- en: '![Figure 5.9: Correctly rendering the site with click and slider functions'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.9：使用单击和滑块功能正确呈现网站'
- en: '](Images/C14587_05_09.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_05_09.jpg)'
- en: 'Figure 5.9: Correctly rendering the site with click and slider functions'
  id: totrans-267
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.9：使用单击和滑块功能正确呈现网站
- en: Getters and Setters
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取器和设置器
- en: 'When using encapsulation, most objects will end up having getter and setter
    functions for some or all of their properties, since we no longer allow users
    to access properties directly:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用封装时，由于我们不再允许用户直接访问属性，大多数对象最终将具有一些或全部属性的getter和setter函数：
- en: '[PRE51]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Instead, we specifically create functions that allow getting and setting the
    property. These are known as getters and setters, and they are a popular design
    pattern, especially in languages such as Java and C++. If you completed step 7
    in the last exercise, you should have added setters and getters for `brightness`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们专门创建允许获取和设置属性的函数。这些被称为getter和setter，它们是一种流行的设计模式，特别是在诸如Java和C++等语言中。如果您在上一个练习中完成了第7步，应该已经为`brightness`添加了setter和getter：
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Inheritance
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承
- en: Inheritance is the concept of having one class inherit the properties and methods
    of another class. A class that inherits from another is known as a subclass, and
    a class that is inherited from is known as a superclass.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是一个类继承另一个类的属性和方法的概念。从另一个类继承的类称为子类，被继承的类称为超类。
- en: It's from the term **superclass** that we get the built-in `super()` function,
    which can be used to call the constructor of a subclass's superclass. We'll use
    `super()` later in this chapter to make our own subclass.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 正是从术语**超类**中，我们得到了内置的`super()`函数，它可以用于调用子类的超类的构造函数。我们将在本章后面使用`super()`来创建自己的子类。
- en: It should be noted that a class can be both a subclass and a superclass. For
    example, say we have a program that simulates different types of animals. In our
    program, we have a mammal class, which is a subclass of animal class and a superclass
    to the dog class.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，一个类既可以是子类，也可以是超类。例如，假设我们有一个模拟不同类型动物的程序。在我们的程序中，我们有一个哺乳动物类，它是动物类的子类，也是狗类的超类。
- en: 'By organizing our program this way, we can put properties and methods that
    are relevant to all animals in the animal class. The mammal subclass contains
    methods relevant to mammals, but not reptiles; for example:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式组织我们的程序，我们可以将所有动物相关的属性和方法放在动物类中。哺乳动物子类包含哺乳动物相关的方法，但不包括爬行动物；例如：
- en: '![Figure 5.10: Inheritance in JavaScript'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.10：JavaScript中的继承'
- en: '](Images/C14587_05_10.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_05_10.jpg)'
- en: 'Figure 5.10: Inheritance in JavaScript'
  id: totrans-280
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.10：JavaScript中的继承
- en: This may sound complex at first, but it often saves a significant amount of
    coding. Without the use of classes, we would end up copying and pasting methods
    from one animal to another. With that comes the difficulty of having to update
    a function in multiple places.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '这一开始可能听起来很复杂，但通常可以节省大量的编码工作。如果不使用类，我们将不得不将方法从一个动物复制并粘贴到另一个动物中。这就带来了在多个地方更新函数的困难。 '
- en: Going back to our smart house scenario, say we have received a new colored lightbulb
    device. We want our colored lightbulb to have all the attributes and functions
    that are contained in a lightbulb. In addition, the colored light should have
    an extra attribute of `color`, containing a hex color code, a color format checker,
    and functions related to changing color.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的智能家居场景，假设我们收到了一个新的彩色灯泡设备。我们希望我们的彩色灯泡具有灯泡中包含的所有属性和函数。此外，彩色灯应该有一个额外的`color`属性，包含一个十六进制颜色代码，一个颜色格式检查器和与改变颜色相关的函数。
- en: Our code should also be written in a way that if we make changes to the underlying
    `Light` class, the colored lightbulb will automatically gain any added functionality.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码也应该以一种方式编写，如果我们对底层的`Light`类进行更改，彩色灯泡将自动获得任何添加的功能。
- en: 'Exercise 26: Extending a Class'
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习26：扩展一个类
- en: Note
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: This exercise uses the end product of *Exercise 25, WeakMap for Encapsulation*,
    as a starting point. The state of the code after completing this exercise can
    be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise26](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise26).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习使用*练习25，封装的WeakMap*的最终产品作为起点。完成此练习后的代码状态可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise26](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise26)找到。
- en: 'To extend the `Light` class written in the previous exercise, we will create
    a new `ColorLight` class:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展上一个练习中编写的`Light`类，我们将创建一个新的`ColorLight`类：
- en: 'Create a new file at `/js/colorLight.js`. On the first line, we''ll import
    `./light.js`, which we''ll use as a starting point:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/js/colorLight.js`中创建一个新文件。在第一行，我们将导入`./light.js`，这将作为起点：
- en: '[PRE53]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, we''ll create `WeakMap` for private variables. Then, we''ll create a
    class statement for our `ColorLight` class, and use the `extends` keyword to tell
    JavaScript that it will use `Light` as a starting point:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为私有变量创建`WeakMap`。然后，我们将为我们的`ColorLight`类创建一个类语句，并使用`extends`关键字告诉JavaScript它将使用`Light`作为起点：
- en: '[PRE54]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Inside the `ColorLight` class statement, we''ll create a new `constructor`
    that uses the built-in `super()` function, which runs the `constructor()` function
    of our base class, `Light`:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ColorLight`类语句内部，我们将创建一个新的`constructor`，它使用内置的`super()`函数，运行我们基类`Light`的`constructor()`函数：
- en: '[PRE55]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Notice in the preceding constructor that we make a call to `checkColorFormat()`,
    a function that will check that the color value provided is a valid hex value.
    If not, we''ll set the value to the hex value of white (#FFFFFF). The function
    should be inside the `ColorLight` class statement:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意在上述构造函数中，我们调用了`checkColorFormat()`，这是一个检查提供的颜色值是否是有效十六进制值的函数。如果不是，我们将把值设置为白色的十六进制值(#FFFFFF)。该函数应该在`ColorLight`类语句内部：
- en: '[PRE56]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add getter and setter functions, like we did in the later exercise:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加getter和setter函数，就像我们在后面的练习中所做的那样：
- en: '[PRE57]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'At the bottom of `js/colorLight.js`, add an `export` statement to make the
    module available for import:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`js/colorLight.js`的底部，添加一个`export`语句以使模块可供导入：
- en: '[PRE58]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Open `js/viewer.js` at the top of the file and switch the `Light` import with
    one for `ColorLight`. Below that, we will import a pre-written script called `changeColor.js`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部打开`js/viewer.js`，并将`Light`导入切换为`ColorLight`。在下面，我们将导入一个预先编写的名为`changeColor.js`的脚本：
- en: '[PRE59]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Further below, in `js/viewer.js`, find the line where we initialize the `light`
    variable and replace it with this:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`js/viewer.js`中更下面，找到初始化`light`变量的行，并将其替换为以下内容：
- en: '[PRE60]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'At the bottom of `js/viewer.js`, add the following:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`js/viewer.js`的底部，添加以下内容：
- en: '[PRE61]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Start the program again using `npm start` and go to `localhost:8000` in your
    browser:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`npm start`启动程序，并在浏览器中转到`localhost:8000`：
- en: 'If you''ve followed the instructions correctly, you should now see the light
    in a light green color, as demonstrated in the following diagram. Try opening
    `js/viewer.js` and changing the hex value; doing so should result in a different
    color for the light image:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照说明正确操作，现在应该看到灯泡呈浅绿色，如下图所示。尝试打开`js/viewer.js`并更改十六进制值；这样做应该会导致灯泡图像显示不同的颜色：
- en: '![Figure 5.11: The change-color function applying a CSS filter to make the
    lightbulb green'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.11：change-color函数应用CSS滤镜使灯泡变绿'
- en: '](Images/C14587_05_11.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_05_11.jpg)'
- en: 'Figure 5.11: The change-color function applying a CSS filter to make the lightbulb
    green'
  id: totrans-310
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.11：change-color函数应用CSS滤镜使灯泡变绿
- en: Polymorphism
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多态
- en: Polymorphism is simply overriding the default behavior of a parent class. In
    strongly typed languages such as Java and C#, polymorphism can take a bit of effort.
    With JavaScript, polymorphism is straightforward. You simply overwrite a function.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性就是简单地覆盖父类的默认行为。在Java和C#等强类型语言中，多态性可能需要花费一些精力。而在JavaScript中，多态性是直接的。你只需要重写一个函数。
- en: For example, in the previous exercise, we took `Light` and extended it with
    the `ColorLight` class. Say we wanted to take the `test()` function that was written
    in `Light` and override it so that instead of alerting the state of the light,
    we alert the current color value of the light.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在上一个练习中，我们将`Light`和`ColorLight`类扩展了。假设我们想要获取在`Light`中编写的`test()`函数，并覆盖它，以便不是弹出灯的状态，而是弹出灯的当前颜色值。
- en: 'So, our `js/light.js` file would contain this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`js/light.js`文件将包含以下内容：
- en: '[PRE62]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Exercise 27: LightBulb Builder'
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习27：LightBulb Builder
- en: Note
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: This exercise uses the end product of *Exercise 26, Extending a Class*, as a
    starting point. The state of the code after completing this exercise can be found
    at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise27](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise27).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习使用*Exercise 26, Extending a Class*的最终产品作为起点。完成这个练习后的代码状态可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise27](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise27)找到。
- en: 'In this exercise, we will use the concepts we''ve learned so far to enhance
    our example project. Instead of having a single lightbulb, we will modify the
    project to allow us to create unlimited instances of the `lightbulb` class, choosing
    the color, brightness, and state:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将运用到目前为止学到的概念来增强我们的示例项目。我们将修改项目，使我们能够创建无限个`lightbulb`类的实例，选择颜色、亮度和状态：
- en: 'Open `js/light.js` and add two values for the image source just below the `WeakMap`
    reference:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`js/light.js`，并在`WeakMap`引用的下面添加两个图像源的值：
- en: '[PRE63]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, in `js/light.js`, below where the `info` variable is defined, add the
    following:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`js/light.js`中，在`info`变量定义的下面，添加以下内容：
- en: '[PRE64]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the last step in `js/light.js`, we made a reference to `this.createDiv`.
    In this step, we''ll create that function below the constructor in `js/light.js`.
    This function creates HTML for every instance of the `Light` class:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`js/light.js`的最后一步中，我们引用了`this.createDiv`。在这一步中，我们将在`js/light.js`的构造函数下面创建该函数。该函数为`Light`类的每个实例创建HTML：
- en: '[PRE65]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, in `js/light.js`, find the `setState` function and add the following
    line within the function:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`js/light.js`中，找到`setState`函数，并在函数内添加以下行：
- en: '[PRE66]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Add the same line to the `toggle` function in `js/light.js`:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`js/light.js`的`toggle`函数中添加相同的行：
- en: '[PRE67]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Similarly, we will update the `setBrightness` function in `js/light.js` to
    set the opacity of the image based on brightness:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样地，我们将更新`js/light.js`中的`setBrightness`函数，以根据亮度设置图像的不透明度：
- en: '[PRE68]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The last change in `js/light.js` is to add a getter function for the `img`
    HTML object. We will place it between the `getBrightness` and `toggle` functions:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`js/light.js`中的最后一个更改是为`img` HTML对象添加一个getter函数。我们将它放在`getBrightness`和`toggle`函数之间：'
- en: '[PRE69]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In `js/colorLight.js`, we''ll import the pre-built `colorChange` function.
    This should go with your imports just under the `Light` import:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`js/colorLight.js`中，我们将导入预先构建的`colorChange`函数。这应该放在你的导入下面的位置，就在`Light`导入的下面：
- en: '[PRE70]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, in `js/colorLight.js`, we''re going to update the constructor by adding
    the following lines:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`js/colorLight.js`中，我们将通过添加以下行来更新构造函数：
- en: '[PRE71]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In `js/viewer.js`, delete all the code and replace it with the following:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`js/viewer.js`中，删除所有代码并替换为以下内容：
- en: '[PRE72]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The final change is `index.html`; remove the `img` and `input` tags and replace
    them with the following:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的更改是`index.html`；删除`img`和`input`标签，并替换为以下内容：
- en: '[PRE73]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'With all the changes made, run `npm start` and open your browser to `localhost:8000`.
    If you''ve done everything correctly, hitting the `build` button should add a
    new element to the page based on the color chosen:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成所有更改后，运行`npm start`并在浏览器中打开`localhost:8000`。如果一切都做对了，点击`build`按钮应该根据所选的颜色向页面添加一个新元素：
- en: '![Figure 5.12: Creating multiple instances of the lightclub class'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.12：创建多个lightclub类的实例'
- en: '](Images/C14587_05_12.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_05_12.jpg)'
- en: 'Figure 5.12: Creating multiple instances of the lightclub class'
  id: totrans-345
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.12：创建多个lightclub类的实例
- en: As you can see, classes really start to come in handy once you're creating many
    instances of a single thing. In the next section, we'll look at npm packages and
    how we can export our `Light` class as one.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一旦你创建了许多相同的实例，类就真的开始变得非常有用了。在下一节中，我们将看看npm包以及如何将我们的`Light`类导出为一个。
- en: npm Package
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: npm包
- en: An **npm package** is a JavaScript module that has been packaged and uploaded
    to the npm server. Once a module has been uploaded to npm, it can quickly be installed
    and used by anyone.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**npm包**是一个已经打包并上传到npm服务器的JavaScript模块。一旦模块被上传到npm，任何人都可以快速安装和使用它。'
- en: This probably isn't new to you, as anyone who has used Node.js quickly ends
    up installing a package. What is less commonly done and known about is how to
    create and upload a package. It's easy to spend years as a developer without having
    the need to publish a public module, yet it is something worth knowing. It will
    help not only when you want to export your own module, but when you want to read
    and understand the packages that your project uses.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你可能不是新鲜事，因为任何使用Node.js的人很快就会安装一个包。不太常见的是如何创建和上传一个包。作为开发人员，很容易花费数年的时间而不需要发布一个公共模块，但了解这一点是值得的。这不仅有助于当你想要导出自己的模块时，还有助于阅读和理解你的项目使用的包。
- en: The first step in creating an npm module is making sure you have a complete
    `package.json` file. When running a project locally, it is normal to not worry
    much about fields such as **author** and **description**. It's a different story
    when you prepare a module for public use. You should take the time to fill out
    all fields relevant to your package.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 创建npm模块的第一步是确保您有一个完整的`package.json`文件。在本地运行项目时，通常不必过多担心诸如**author**和**description**之类的字段。但是，当您准备将模块用于公共使用时情况就不同了。您应该花时间填写与您的软件包相关的所有字段。
- en: The following is a table that includes the common properties recommended by
    npm. Many of these are optional. For more information and a complete list, refer
    to [https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是包括npm推荐的常见属性的表格。其中许多是可选的。有关更多信息和完整列表，请参阅[https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json)。
- en: 'At the very minimum, metadata should include a name, version, and description.
    In addition, most packages will need a `dependencies` property; however, this
    should be generated automatically by using the `--save` or `-s` option whenever
    installing a dependency using `npm install`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，元数据应包括名称、版本和描述。此外，大多数软件包将需要一个`dependencies`属性；但是，这应该通过在使用`npm install`安装依赖项时自动生成使用`--save`或`-s`选项：
- en: '![Figure 5.13: npm properties table'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.13：npm属性表'
- en: '](Images/C14587_05_13.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_05_13.jpg)'
- en: 'Figure 5.13: npm properties table'
  id: totrans-355
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.13：npm属性表
- en: 'The following table shows some more properties of npm:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了npm的一些更多属性：
- en: '![Figure 5.14: npm properties table continued'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.14：npm属性表续'
- en: '](Images/C14587_05_14.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_05_14.jpg)'
- en: 'Figure 5.14: npm properties table continued'
  id: totrans-359
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.14：npm属性表续
- en: npm Link Command
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: npm链接命令
- en: 'Once you have your `package.json` complete, and the first version of your package
    that you want to test, you can make use of the `npm link` command. The link command
    will associate your local npm project with a namespace. For example, first navigate
    to the project folder where you want to use a local `npm` package:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 完成`package.json`并且您想要测试的软件包的第一个版本后，您可以使用`npm link`命令。链接命令将将您的本地npm项目与命名空间关联起来。例如，首先导航到要使用本地`npm`软件包的项目文件夹：
- en: '[PRE74]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, go into another project folder where you want to make use of that package,
    and run `npm link helloWorld`, where `helloWorld` is the name of the package you
    are testing:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，进入另一个项目文件夹，您想要使用该软件包，并运行`npm link helloWorld`，其中`helloWorld`是您正在测试的软件包的名称：
- en: '[PRE75]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: These two steps will allow you to work as if you had installed `helloWorld`
    using `npm install helloWorld`. By doing this, you can ensure that your package
    is working locally when used in another project.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个步骤将使您能够像使用`npm install helloWorld`安装`helloWorld`一样工作。通过这样做，您可以确保在另一个项目中使用时，您的软件包在本地工作。
- en: Npm Publish Command
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Npm发布命令
- en: Once you are satisfied with the results of testing your package locally, you
    can easily upload it to npm with the `npm publish` command. To make use of the
    `publish` command, you will first need to create an account at [https://www.npmjs.com/](https://www.npmjs.com/).
    Once you have an account, you can log in to it locally by running `npm login`
    on your command line.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您对在本地测试软件包的结果感到满意，您可以使用`npm publish`命令轻松将其上传到npm。要使用`publish`命令，您首先需要在[https://www.npmjs.com/](https://www.npmjs.com/)上创建一个帐户。一旦您拥有帐户，您可以通过在命令行上运行`npm
    login`来本地登录。
- en: 'Once logged in, it is very simple to publish your package. Simply navigate
    to your `project` folder and run `npm publish`. Here is an example of a package
    being successfully uploaded to npm for others to use:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，发布软件包非常简单。只需导航到您的`project`文件夹并运行`npm publish`。以下是成功上传到npm供他人使用的软件包的示例：
- en: '![Figure 5.15: Example of an npm package published'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.15：已发布的npm软件包示例'
- en: '](Images/C14587_05_15.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_05_15.jpg)'
- en: 'Figure 5.15: Example of an npm package published'
  id: totrans-371
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.15：已发布的npm软件包示例
- en: ESM versus CommonJS
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ESM与CommonJS
- en: ESM is short for ECMAScript Modules, which is the standard used for modules
    in ES6\. So, you may hear "ES6 Modules" referred to as ESM. This is due to the
    fact that the ESM standard has been in development before ES6 was a standard.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ESM是ECMAScript模块的缩写，这是ES6中模块的标准。因此，您可能会听到将“ES6模块”称为ESM。这是因为ESM标准在ES6成为标准之前就已经在开发中。
- en: 'You''ve likely seen the CommonJS format that was used in the previous chapter:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经看到了在上一章中使用的CommonJS格式：
- en: '[PRE76]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The same code in the ES6 module style would be like this:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: ES6模块样式中的相同代码将是这样的：
- en: '[PRE77]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: ES6 modules are great because they give JavaScript developers more control over
    their imports. However, it is important to note that, currently, JavaScript is
    in a transition period. ES6 has given a definite standard as to how ES6 modules
    should work. While most browsers have implemented it, npm is still using its own
    standard CommonJS.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ES6模块非常棒，因为它们使JavaScript开发人员对其导入有更多控制。但是，重要的是要注意，目前JavaScript正处于过渡期。ES6已经明确规定了ES6模块应该如何工作的标准。尽管大多数浏览器已经实现了它，但npm仍在使用自己的标准CommonJS。
- en: That said, the introduction of ES6 is being quickly accepted. npm now ships
    with an experimental flag, `--experimental-modules`, which allows the use of ES6-style
    modules. However, use of this flag is not recommended, as it adds unneeded complexity,
    such as having to change your file extensions from `.js` to `.mjs`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，ES6的引入正在迅速得到接受。npm现在附带一个实验性标志，`--experimental-modules`，允许使用ES6样式模块。但是，不建议使用此标志，因为它增加了不必要的复杂性，例如必须将文件扩展名从`.js`更改为`.mjs`。
- en: Babel
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Babel
- en: The more common and recommended way to use ES6 modules with Node.js is to run
    a JavaScript compiler. The most popular compiler is `Babel.js`, which takes ES6
    code and compiles it down to older versions of JavaScript that can run anywhere.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ES6模块与Node.js的更常见和推荐的方法是运行JavaScript编译器。最流行的编译器是`Babel.js`，它将ES6代码编译为可以在任何地方运行的较旧版本的JavaScript。
- en: Babel is a widely used tool in the Node.js ecosystem. Often, projects use starter
    templates that have Babel and other bundling tools, such as webpack, built in.
    These starter projects allow developers to start using ES6 imports without thinking
    about the fact that a compile step is required. For example, there's Facebook's
    create-react-app, which compiles and displays your application every time a change
    is made to a file.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Babel是Node.js生态系统中广泛使用的工具。通常，项目使用具有Babel和其他捆绑工具（如webpack）的起始模板。这些起始项目允许开发人员开始使用ES6导入，而无需考虑是否需要编译步骤。例如，有Facebook的create-react-app，它会在文件更改时编译和显示您的应用程序。
- en: 'React is one of the largest communities pushing ES6\. In the React ecosystem,
    the standard import used is ES6\. The following is taken from the React documentation
    on creating a component:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: React是推动ES6的最大社区之一。在React生态系统中，标准导入使用的是ES6。以下内容摘自React关于创建组件的文档：
- en: '[PRE78]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note the similarity between the preceding code and what we've been working on.
    It's an example of inheritance, where `Button` inherits the properties of `Component`,
    just like `ColorLight` inherited those of `Light`. React is a component-based
    framework that makes heavy use of ES6 features such as imports and classes.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面的代码与我们一直在进行的工作之间的相似之处。这是继承的一个例子，其中`Button`继承了`Component`的属性，就像`ColorLight`继承了`Light`的属性一样。React是一个基于组件的框架，大量使用ES6功能，如导入和类。
- en: webpack
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: webpack
- en: Another common JavaScript compiler is webpack. webpack takes multiple JavaScript
    files and compiles them into a single bundled file. In addition, webpack can take
    steps to improve performance, such as minifying code to reduce the total size.
    webpack is particularly useful when using modules, as each separate file loaded
    into an HTML site increases load time due to making an extra HTTP call.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的JavaScript编译器是webpack。webpack接受多个JavaScript文件并将它们编译成单个捆绑文件。此外，webpack可以采取步骤来提高性能，例如缩小代码以减少总大小。在使用模块时，webpack特别有用，因为每个加载到HTML站点中的单独文件都会增加加载时间，因为会产生额外的HTTP调用。
- en: 'With webpack, we can very simply specify the entry point for the JavaScript
    we want to compile, and it will automatically merge any referenced files. For
    example, if we want to compile the code from our last exercise, we would create
    a `webpack.config.js` file to specify the entry point:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 使用webpack，我们可以非常简单地指定要编译的JavaScript的入口点，并且它将自动合并任何引用的文件。例如，如果我们想要编译上一个练习中的代码，我们将创建一个`webpack.config.js`文件来指定入口点：
- en: '[PRE79]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Notice where `entry` is defined above; this would be the starting point of our
    program from where webpack will automatically find all referenced files. The other
    important value to take note of is `output`. This defines the location and filename
    of the resulting bundled JavaScript file created by the compiler.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上面定义的`entry`；这将是我们程序的起点，webpack将自动找到所有引用的文件。另一个重要的值要注意的是`output`。这定义了编译器创建的结果捆绑JavaScript文件的位置和文件名。
- en: In the next exercise, we'll make use of Babel to convert our code from ES6 to
    generic JavaScript. Once we've converted our JavaScript, we'll use webpack to
    compile the resulting files into a single bundled JavaScript file.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将使用Babel将我们的代码从ES6转换为通用JavaScript。一旦我们转换了我们的JavaScript，我们将使用webpack将生成的文件编译成一个捆绑的JavaScript文件。
- en: 'Exercise 28: Converting ES6 and Packages with webpack and Babel'
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习28：使用webpack和Babel转换ES6和包
- en: Note
  id: totrans-393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: This exercise uses the end product of *Exercise 27, LightBulb Builder*, as a
    starting point. The state of the code after completing this exercise can be found
    at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise28](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise28).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习使用*练习27，LightBulb Builder*的最终产品作为起点。完成此练习后的代码状态可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise28](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson05/Exercise28)找到。
- en: 'In this exercise, we will use Babel to convert our ES6 to generic JavaScript
    that is compatible with older browsers such as Internet Explorer. The second thing
    we''ll do is run webpack to compile all our JavaScript files into a single file:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用Babel将我们的ES6转换为与旧浏览器（如Internet Explorer）兼容的通用JavaScript。我们要做的第二件事是运行webpack将所有JavaScript文件编译成单个文件：
- en: 'Create two new folders in the base of your project, one called `build` and
    the other `src`:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的基础上创建两个新文件夹，一个名为`build`，另一个名为`src`：
- en: '[PRE80]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Move the `images`, `index.html`, and `js` folders into the new `src` folder.
    The source folder will be used to generate the contents of the `build` folder
    later:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`images`，`index.html`和`js`文件夹移动到新的`src`文件夹中。源文件夹将用于稍后生成`build`文件夹的内容：
- en: '[PRE81]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Install `babel-cli` and `babel preset` as developer dependencies:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`babel-cli`和`babel preset`作为开发人员依赖项：
- en: '[PRE82]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Add a file called `.babelrc` to the root directory. In it, we will tell Babel
    to use the preset settings:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录下添加一个名为`.babelrc`的文件。在其中，我们将告诉Babel使用预设设置：
- en: '[PRE83]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Add a webpack configuration file at `webpack.config.js` in the root directory:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录中添加一个名为`webpack.config.js`的webpack配置文件：
- en: '[PRE84]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'To generate the contents of the `build` folder from `src`, we need to add a
    new script command to our project. Open up `package.json` and look for the section
    that lists scripts. In that section, we''ll add a `build` command that runs Babel
    and webpack and copies our `image` files to the `build` folder. We will also modify
    the `start` command to reference our `build` folder, so we can test it after building:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从`src`生成`build`文件夹的内容，我们需要向项目添加一个新的脚本命令。打开`package.json`，查找列出脚本的部分。在该部分，我们将添加一个`build`命令，该命令运行Babel和webpack，并将我们的`image`文件复制到`build`文件夹中。我们还将修改`start`命令以引用我们的`build`文件夹，以便在构建后进行测试：
- en: '[PRE85]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Note
  id: totrans-408
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'Windows users should use the following command:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户应使用以下命令：
- en: '`"build": "babel src -d build && copy src build && webpack --config webpack.config.js"`'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`"build": "babel src -d build && copy src build && webpack --config webpack.config.js"`'
- en: 'To make sure the command has been added properly, run `npm run build` on the
    command line. You should see output like this:![Figure 5.16: npm run build output'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保命令已经正确添加，运行命令行上的`npm run build`。你应该会看到这样的输出：![图5.16：npm run build输出
- en: '](Images/C14587_05_16.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_05_16.jpg)'
- en: 'Figure 5.16: npm run build output'
  id: totrans-413
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.16：npm run build输出
- en: 'Next, open up `build/index.html` and change the `script` tag to import our
    newly created file, `bundle.js`:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`build/index.html`并将`script`标签更改为导入我们新创建的文件`bundle.js`：
- en: '[PRE86]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'To test, run `npm start` and open `localhost:8000` in the browser. You should
    see the same website as the last exercise. Press the `build` button a few times
    to ensure that it is working as expected:![Figure 5.17: Test run using the build
    button'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试，运行`npm start`并在浏览器中打开`localhost:8000`。你应该会看到与上次练习相同的网站。按几次`build`按钮以确保它按预期工作：![图5.17：使用构建按钮进行测试运行
- en: '](Images/C14587_05_17.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_05_17.jpg)'
- en: 'Figure 5.17: Test run using the build button'
  id: totrans-418
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.17：使用构建按钮进行测试运行
- en: 'To double check that everything has compiled correctly, go to `localhost:8000/bundle.js`
    in the browser. You should see a large file that contains the compiled version
    of all our JavaScript source files:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了双重检查一切是否编译正确，去浏览器中输入`localhost:8000/bundle.js`。你应该会看到一个包含所有我们的JavaScript源文件编译版本的大文件：
- en: '![Figure 5.18: A complied version of all our JavaScript source files'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.18：所有我们的JavaScript源文件的编译版本'
- en: '](Images/C14587_05_18.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_05_18.jpg)'
- en: 'Figure 5.18: A complied version of all our JavaScript source files'
  id: totrans-422
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.18：所有我们的JavaScript源文件的编译版本
- en: If you've done everything right, you should have a `bundle.js` file that contains
    all our JavaScript code compiled into a single file.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做的一切都正确，你应该有一个包含所有我们的JavaScript代码编译成单个文件的`bundle.js`文件。
- en: Composability and Strategies for Combining Modules
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可组合性和组合模块的策略
- en: We've seen how a module can be an extension of another, as `ColorLight` was
    to `Light`. Another common strategy when a project grows is to have modules that
    are themselves made up of multiple sub-modules.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到模块如何成为另一个模块的扩展，就像`ColorLight`是`Light`的扩展一样。当项目增长时，另一个常见的策略是有模块本身由多个子模块组成。
- en: The use of sub-modules is a simple as importing a module in the module file
    itself. For example, say we wanted to improve the brightness slider in our light
    modules. It may be that if we created a new `Slider` module, we could use it in
    multiple cases besides just the `Light` class. This is the kind of situation where
    it would be advised to make our "advanced slider input" a sub-module.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 使用子模块就像在模块文件本身导入模块一样简单。例如，假设我们想要改进我们灯模块中的亮度滑块。也许如果我们创建一个新的`Slider`模块，我们可以在除了`Light`类之外的多种情况下使用它。这是一种情况，我们建议将我们的“高级滑块输入”作为子模块。
- en: If, on the other hand, you think your new slider will only ever be used in the
    `Light` class, then adding it is a new class will only create more overhead. Don't
    fall into the trap of over-modularizing simply because you can. The key factor
    here is reusability and utility.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你认为你的新滑块只会在`Light`类中使用，那么将它添加为一个新类只会增加更多的开销。不要陷入过度模块化的陷阱。关键因素在于可重用性和实用性。
- en: 'Activity 6: Creating a Lightbulb with a Flash Mode'
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动6：创建带有闪光模式的灯泡
- en: The lightbulb company you work for has asked you to work on a version of their
    product. They want a lightbulb with a special "flash mode" that can be used at
    events and concerts. The flash mode light should allow people to put the light
    in flash mode and have it automatically turned on and off at a given time interval.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 你工作的灯泡公司要求你为他们的产品工作。他们想要一个带有特殊“闪光模式”的灯泡，可以在活动和音乐会上使用。闪光模式的灯允许人们将灯置于闪光模式，并在给定的时间间隔内自动打开和关闭。
- en: Create a `FlashingLight` class that extends `Light`. The class should be the
    same as `Light`, except it has a property called `flashMode`. If `flashMode` is
    on, then the value of the state should switch every five seconds.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`FlashingLight`类，它扩展了`Light`。该类应该与`Light`相同，只是有一个名为`flashMode`的属性。如果`flashMode`打开，则状态的值应该每五秒切换一次。
- en: Once you've created this new component, add it to the package exports in `js/index.js`
    and compile the project using Babel.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了这个新组件后，将其添加到`js/index.js`中的包导出，并使用Babel编译项目。
- en: 'Perform the following steps to complete the activity:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成活动：
- en: Install the `babel-cli` and `babel` presets as developer dependencies.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`babel-cli`和`babel`预设为开发人员依赖项。
- en: Add `.babelrc` to tell Babel to use `preset-env`.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`.babelrc`告诉Babel使用`preset-env`。
- en: Add a webpack configuration file that specifies the mode, entry, and output
    location.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个webpack配置文件，指定模式、入口和输出位置。
- en: Create a new file called `js/flashingLight.js`; it should start as a blank ES6
    component that extends `Light`.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`js/flashingLight.js`的新文件；它应该作为一个空的ES6组件开始，扩展`Light`。
- en: At the top of the file, add a `privateVars` variable of the `weakMap` type.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部，添加一个`weakMap`类型的`privateVars`变量。
- en: In the constructor, set the `flashMode` property and save it to `privateVars`
    within the constructor.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，设置`flashMode`属性并将其保存到构造函数中的`privateVars`中。
- en: Add a setter method for the `FlashingLight` object.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`FlashingLight`对象添加一个setter方法。
- en: Add a getter method for the `FlashingLight` object.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`FlashingLight`对象添加一个getter方法。
- en: On line 2, add an empty variable that will keep track of the flashing timer
    at the global level of the class.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第2行，添加一个空变量，用于在类的全局级别跟踪闪烁计时器。
- en: Create a `startFlashing` function that references the parent class's `lightSwitch()`
    function. This step is tricky because we have to bind it to `setInterval`.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个引用父类的`lightSwitch()`函数的`startFlashing`函数。这一步很棘手，因为我们必须将它绑定到`setInterval`。
- en: Create a `stopFlashing` function that can be used to turn off the timer.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`stopFlashing`函数，用于关闭计时器。
- en: In the constructor, check whether `flashMode` is true, and, if it is, run `startFlashing`.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，检查`flashMode`是否为true，如果是，则运行`startFlashing`。
- en: Also, check `flashMode` when setting `mode` – if true, `startFlashing`; or else,
    `stopFlashing`.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置`mode`时，还要检查`flashMode` - 如果为true，则`startFlashing`；否则，`stopFlashing`。
- en: Import and export the new component in `index.js`.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.js`中导入和导出新组件。
- en: Compile the code by running our `build` function with npm.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用npm运行我们的`build`函数来编译代码。
- en: '**Expected output**:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '**预期输出**：'
- en: '![Figure 5.19: Lightbulb with flash mode'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.19：带闪光模式的灯泡'
- en: '](Images/C14587_05_19.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_05_19.jpg)'
- en: 'Figure 5.19: Lightbulb with flash mode'
  id: totrans-451
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.19：带闪光模式的灯泡
- en: Note
  id: totrans-452
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 599.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第599页找到。
- en: Summary
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've explored concepts of modular design, ES6 modules, and
    their use with node. The principles of object-oriented design can be useful when
    designing programs that have several layers of modules composed as a complex system.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了模块化设计的概念，ES6模块以及它们在node中的使用。面向对象设计原则在设计由多个模块层组成的复杂系统的程序时非常有用。
- en: ES6 classes allow us to create classes much more easily than previous versions
    of JavaScript. These classes can be built by using the `extends` keyword. This
    allows for layers of complexity where more complex objects can be built on top
    of simple ones and so on.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: ES6类允许我们比以前的JavaScript版本更轻松地创建类。这些类可以使用`extends`关键字构建。这允许在更复杂的对象之上构建更复杂的对象等等。
- en: We also saw how the new ES6 `WeakMap` type allows us to create private variables.
    This pattern limits the number of errors in modules that will be used by others.
    For example, by requiring properties to be changed, we can check the format and
    value before allowing the change. This was the case with the light example, where
    we wanted to check that `state` was a Boolean value before allowing it to be set.
    We did this by creating getter and setter methods for each private variable that
    we wanted to make available to other parts of our code.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了新的ES6 `WeakMap`类型如何允许我们创建私有变量。这种模式限制了将被其他人使用的模块中的错误数量。例如，通过要求更改属性，我们可以在允许更改之前检查格式和值。这就是灯泡示例的情况，我们希望检查`state`在允许设置之前是否为布尔值。我们通过为我们想要向我们代码的其他部分公开的每个私有变量创建getter和setter方法来实现这一点。
- en: After that, we talked about how ES6 modules aren't currently supported natively
    in Node.js, even though big-name projects such as Facebook-backed React make use
    of them extensively. As a solution to this limitation, we installed Babel, an
    ES6-to-JavaScript compiler, and used it to convert our `src` folder to the final
    build code.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们谈到了ES6模块目前在Node.js中没有得到原生支持，尽管像Facebook支持的React这样的知名项目广泛使用它们。作为解决这一限制的方法，我们安装了Babel，一个ES6到JavaScript的编译器，并用它将我们的`src`文件夹转换为最终的构建代码。
- en: We also talked about how, once you have a project working locally, you can convert
    it to an npm package that can be shared and updated via npm. This process involved
    testing locally using `npm link`. Then, once satisfied with how the package works,
    publish it using `npm publish`.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还谈到了一旦在本地使项目工作，就可以将其转换为可以通过npm共享和更新的npm包。这个过程涉及使用`npm link`在本地进行测试。然后，一旦满意包的工作方式，使用`npm
    publish`进行发布。
- en: In the next chapter, we will look at code quality and how automated testing
    can be implemented to defend against regression as we update our code.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论代码质量以及如何实施自动化测试来防御回归，因为我们更新我们的代码。
