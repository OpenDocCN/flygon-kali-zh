- en: RESTful Web Services Using Spring Boot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Boot创建RESTful Web服务
- en: 'In this chapter, we are going to cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下示例：
- en: Creating a simple Spring Boot application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的Spring Boot应用程序
- en: Interacting with the database
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数据库交互
- en: Creating a RESTful web service
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个RESTful web服务
- en: Creating multiple profiles for Spring Boot
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Spring Boot创建多个配置文件
- en: Deploying RESTful web services to Heroku
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将RESTful web服务部署到Heroku
- en: Containerizing the RESTful web service using Docker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker将RESTful web服务容器化
- en: Monitoring the Spring Boot 2 application using Micrometer and Prometheus
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Micrometer和Prometheus监控Spring Boot 2应用程序
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In recent years, the drive for microservice-based architectures has gained wide
    adoption, thanks to the simplicity and ease of maintenance it provides when done
    the right way. A lot of companies, such as Netflix and Amazon, have moved from
    monolithic systems to more focused and lighter systems, all talking with each
    other via RESTful web services. The advent of RESTful web services and its straightforward
    approach to creating web services using the known HTTP protocol has made it easier
    for communication between applications than the older SOAP-based web services.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，基于微服务架构的推动已经得到了广泛的采用，这要归功于它在正确的方式下提供的简单性和易于维护性。许多公司，如Netflix和Amazon，已经从单片系统转移到了更专注和轻量级的系统，它们之间通过RESTful
    web服务进行通信。RESTful web服务的出现及其使用已知的HTTP协议创建web服务的简单方法，使得应用程序之间的通信比旧的基于SOAP的web服务更容易。
- en: In this chapter, we will look at the **Spring Boot** framework, which provides
    a convenient way to create production-ready microservices using Spring libraries.
    Using Spring Boot, we will develop a simple RESTful web service and deploy it
    to the cloud.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍**Spring Boot**框架，它提供了一种方便的方式来使用Spring库创建可投入生产的微服务。使用Spring Boot，我们将开发一个简单的RESTful
    web服务并将其部署到云端。
- en: Creating a simple Spring Boot application
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的Spring Boot应用程序
- en: Spring Boot helps in creating production-ready, Spring-based applications easily.
    It provides support for working with almost all Spring libraries, without any
    need to configure them explicitly. There are auto-configuration classes provided
    for easy integration with most commonly-used libraries, databases, and message
    queues.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot有助于轻松创建可投入生产的基于Spring的应用程序。它支持几乎所有Spring库的工作，而无需显式配置它们。提供了自动配置类，以便轻松集成大多数常用的库、数据库和消息队列。
- en: In this recipe, we will look at creating a simple Spring Boot application with
    a controller that prints a message when opened in the browser.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将介绍如何创建一个简单的Spring Boot应用程序，其中包含一个在浏览器中打开时打印消息的控制器。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Spring Boot supports Maven and Gradle as its build tools, and we will be using
    Maven in our recipes. The following URL, [http://start.spring.io/](http://start.spring.io/),
    provides a convenient way to create an empty project with the required dependencies.
    We will use it to download an empty project. Follow these steps to create and
    download an empty Spring Boot-based project:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot支持Maven和Gradle作为其构建工具，我们将在我们的示例中使用Maven。以下URL，[http://start.spring.io/](http://start.spring.io/)，提供了一种方便的方式来创建一个带有所需依赖项的空项目。我们将使用它来下载一个空项目。按照以下步骤创建并下载一个基于Spring
    Boot的空项目：
- en: 'Navigate to [http://start.spring.io/](http://start.spring.io/) to see something
    similar to the following screenshot:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到[http://start.spring.io/](http://start.spring.io/)，您将看到类似以下截图的内容：
- en: '![](img/b5e3a855-cad8-4f41-9ebb-850abb91ce31.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5e3a855-cad8-4f41-9ebb-850abb91ce31.png)'
- en: You can select the dependency-management and build tool, selecting the appropriate
    option in the dropdown after the **Generate a** text.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以选择依赖管理和构建工具，通过在**Generate a**文本后的下拉菜单中选择适当的选项。
- en: Spring Boot supports Java, Kotlin, and Groovy. You can choose the language by
    changing the dropdown after the **with** text.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Boot支持Java、Kotlin和Groovy。您可以通过更改**with**文本后的下拉菜单来选择语言。
- en: Select the Spring Boot version by choosing its value from the dropdown after
    the and Spring Boot text. For this recipe, we'll use the latest stable edition
    of Spring Boot 2, that is 2.0.4.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**and Spring Boot**文本后的下拉菜单中选择其值来选择Spring Boot版本。对于本示例，我们将使用Spring Boot 2的最新稳定版本，即2.0.4。
- en: On the left-hand side, under Project Metadata, we have to provide Maven-related
    information, that is, the group ID and artifact ID. We'll use Group as `com.packt`
    and Artifact as `boot_demo`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的项目元数据下，我们需要提供与Maven相关的信息，即组ID和artifact ID。我们将使用Group作为`com.packt`，Artifact作为`boot_demo`。
- en: On the right-hand side, under Dependencies, you can search for the dependencies
    you want to add. For this recipe, we need web and Thymeleaf dependencies. This
    means that we want to create a web application that uses Thymeleaf UI templates
    and would want all the dependencies, such as Spring MVC and Embedded Tomcat, to
    be part of the application.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧的依赖项下，您可以搜索要添加的依赖项。对于本示例，我们需要web和Thymeleaf依赖项。这意味着我们想要创建一个使用Thymeleaf UI模板的web应用程序，并且希望所有依赖项，如Spring
    MVC和嵌入式Tomcat，都成为应用程序的一部分。
- en: Click on the Generate Project button to download the empty project. You can
    load this empty project in any IDE of your choice, just like any other Maven project.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击生成项目按钮以下载空项目。您可以将此空项目加载到您选择的任何IDE中，就像加载任何其他Maven项目一样。
- en: At this point, you will have your empty project loaded into an IDE of your choice
    and will be ready to explore further. In this recipe, we will make use of the
    Thymeleaf template engine to define our web pages and create a simple controller
    to render the web page.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您将在您选择的任何IDE中加载您的空项目，并准备进一步探索。在本示例中，我们将使用Thymeleaf模板引擎来定义我们的网页，并创建一个简单的控制器来呈现网页。
- en: The complete code for this recipe can be found at `Chapter09/1_boot_demo`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的完整代码可以在`Chapter09/1_boot_demo`中找到。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: If you have followed the group ID and artifact ID naming convention as mentioned
    in the *Getting ready* section, you will have a package structure, `com.packt.boot_demo`,
    and a `BootDemoApplication.java` main class already created for you. There will
    be an equivalent package structure and a `BootDemoApplicationTests.java` main
    class under the `tests` folder.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您按照“准备就绪”部分提到的组ID和工件ID命名约定进行了跟随，您将拥有一个包结构`com.packt.boot_demo`，以及一个`BootDemoApplication.java`主类已经为您创建。在`tests`文件夹下将有一个等效的包结构和一个`BootDemoApplicationTests.java`主类。
- en: 'Create a new class, `SimpleViewController`, under the `com.packt.boot_demo`
    package, with the following code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packt.boot_demo`包下创建一个名为`SimpleViewController`的新类，其中包含以下代码：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a web page, `message.html`, under `src/main/resources/templates`, with
    the following code:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/resources/templates`下创建一个名为`message.html`的网页，其中包含以下代码：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the command prompt, navigate to the project root folder and issue the `mvn
    spring-boot:run` command; you'll see the application being launched. Once it completes
    the initialization and starts, it will be running on the default port, `8080`.
    Navigate to `http://localhost:8080/message` to see the message.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令提示符中，导航到项目根文件夹，并发出`mvn spring-boot:run`命令；您将看到应用程序正在启动。一旦完成初始化并启动，它将在默认端口`8080`上运行。导航到`http://localhost:8080/message`以查看消息。
- en: We are using Spring Boot's Maven plugin, which provides us with convenient tools
    to launch the application during development. But for production, we will create
    a fat JAR, that is, a JAR comprising all the dependencies, and deploy it as a
    Linux or Windows service. We can even run the fat JAR using the `java -jar` command.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Spring Boot的Maven插件，它为我们提供了方便的工具来在开发过程中启动应用程序。但是对于生产环境，我们将创建一个fat JAR，即一个包含所有依赖项的JAR，并将其部署为Linux或Windows服务。我们甚至可以使用`java
    -jar`命令运行这个fat JAR。
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: We will not go into the working of Spring Boot or the other Spring libraries.
    Spring Boot creates an embedded Tomcat running on the default port, that is, `8080`.
    It then registers all the controllers, components, and services that are available
    in the packages and sub-packages of the class with the `@SpringBootApplication` annotation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入讨论Spring Boot或其他Spring库的工作原理。Spring Boot创建了一个嵌入式Tomcat，运行在默认端口`8080`上。然后，它注册了所有被`@SpringBootApplication`注解的类所在包及其子包中可用的控制器、组件和服务。
- en: In our recipe, the `BootDemoApplication` class in the `com.packt.boot_demo`
    package is annotated with `@SpringBootApplication`. So, all the classes that are
    annotated with `@Controller`, `@Service`, `@Configuration`, and `@Component` get
    registered with the Spring framework as beans and are managed by it. Now, these
    can be injected into the code by using the `@Autowired` annotation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`com.packt.boot_demo`包中的`BootDemoApplication`类被注解为`@SpringBootApplication`。因此，所有被注解为`@Controller`、`@Service`、`@Configuration`和`@Component`的类都会被Spring框架注册为bean，并由其管理。现在，这些可以通过使用`@Autowired`注解注入到代码中。
- en: 'There are two ways we can create a web controller:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式创建一个web控制器：
- en: Annotating with `@Controller`
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@Controller`进行注解
- en: Annotating with `@RestController`
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@RestController`进行注解
- en: 'In the first approach, we create a controller that can serve both raw data
    and HTML data (generated by template engines such as Thymeleaf, Freemarker, and
    JSP). In the second approach, the controller supports endpoints that can only
    serve raw data in the form of JSON or XML. In our recipe, we used the former approach,
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种方法中，我们创建了一个既可以提供原始数据又可以提供HTML数据（由模板引擎如Thymeleaf、Freemarker和JSP生成）的控制器。在第二种方法中，控制器支持只能提供JSON或XML形式的原始数据的端点。在我们的示例中，我们使用了前一种方法，如下所示：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can annotate the class with `@RequestMapping` , say, `@RequestMapping("/api")`.
    In this case, any HTTP endpoints exposed in the controller are prepended by `/api`.
    There is a specialized annotation mapping for the HTTP `GET`, `POST`, `DELETE`,
    and `PUT` methods, which are `@GetMapping`, `@PostMapping`, `@DeleteMapping`,
    and `@PutMapping`, respectively. We can also rewrite our controller class as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`@RequestMapping`注解类，比如`@RequestMapping("/api")`。在这种情况下，控制器中暴露的任何HTTP端点都会以`/api`开头。对于HTTP的`GET`、`POST`、`DELETE`和`PUT`方法，有专门的注解映射，分别是`@GetMapping`、`@PostMapping`、`@DeleteMapping`和`@PutMapping`。我们也可以将我们的控制器类重写如下：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can modify the port by providing `server.port = 9090` in the `application.properties`
    file. This file can be found in `src/main/resources/application.properties`. There
    is a whole set of properties ([http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html](http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html))
    that we can use to customize and connect with different components.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`application.properties`文件中提供`server.port = 9090`来修改端口。这个文件可以在`src/main/resources/application.properties`中找到。有一整套属性（[http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html](http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html)）可以用来自定义和连接不同的组件。
- en: Interacting with the database
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数据库交互
- en: In this recipe, we will look at how to integrate with a database to create,
    read, modify, and delete the data. For this, we will set up a MySQL database with
    the required table. Subsequently, we will update the data in a table from our
    Spring Boot application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看看如何与数据库集成，以创建、读取、修改和删除数据。为此，我们将设置一个带有所需表的MySQL数据库。随后，我们将从我们的Spring
    Boot应用程序中更新表中的数据。
- en: We will be using Windows as the development platform for this recipe. You can
    perform a similar action on Linux as well, but you would first have to set up
    your MySQL database.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Windows作为这个示例的开发平台。您也可以在Linux上执行类似的操作，但首先必须设置您的MySQL数据库。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Before we start integrating our application with the database, we need to set
    up the database locally on our development machines. In the subsequent sections,
    we will download and install MySQL tools and then create a sample table with some
    data, which we will use with our application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始将应用程序与数据库集成之前，我们需要在开发机器上本地设置数据库。在接下来的几节中，我们将下载和安装MySQL工具，然后创建一个带有一些数据的示例表，我们将在应用程序中使用。
- en: Installing MySQL tools
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装MySQL工具
- en: 'First, download the MySQL installer from [https://dev.mysql.com/downloads/windows/installer/5.7.html](https://dev.mysql.com/downloads/windows/installer/5.7.html).
    This MySQL bundle is for Windows only. Follow the onscreen instructions to successfully
    install MySQL along with other tools such as MySQL Workbench. To confirm that
    the MySQL daemon (`mysqld`) is running, open the task manager and you should be
    able to see a process similar to the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从[https://dev.mysql.com/downloads/windows/installer/5.7.html](https://dev.mysql.com/downloads/windows/installer/5.7.html)下载MySQL安装程序。这个MySQL捆绑包只适用于Windows。按照屏幕上的说明成功安装MySQL以及其他工具，如MySQL
    Workbench。要确认MySQL守护程序（`mysqld`）正在运行，打开任务管理器，你应该能够看到一个类似以下的进程：
- en: '![](img/8d1a7d2a-8bae-412a-8268-7448d9872d33.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d1a7d2a-8bae-412a-8268-7448d9872d33.png)'
- en: You should remember the password you set for the root user.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记住你为root用户设置的密码。
- en: 'Let''s run the MySQL workbench; on starting up, you should be able to see something
    similar to the following screenshot, among other things provided by the tool:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行MySQL Workbench；启动时，你应该能够看到类似以下截图的东西，以及工具提供的其他内容：
- en: '![](img/07d591cd-63f0-4f83-afff-9e73c07bf04e.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07d591cd-63f0-4f83-afff-9e73c07bf04e.png)'
- en: 'If you don''t find a connection like in the preceding image, you can add one
    using the (+) sign. When you click on (+), you will see the following dialog.
    Fill it in and click on Test Connection to get a success message:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在前面的图像中找不到连接，你可以使用(+)号添加一个。当你点击(+)时，你将看到以下对话框。填写它并点击测试连接以获得成功消息：
- en: '![](img/558a654f-24cf-42bc-9e5c-063e240daea3.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/558a654f-24cf-42bc-9e5c-063e240daea3.png)'
- en: 'A successful Test Connection will result in the following message:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的测试连接将导致以下消息：
- en: '![](img/92db869d-b0c8-40a0-ad8d-a3b63206221c.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92db869d-b0c8-40a0-ad8d-a3b63206221c.png)'
- en: Double-click on the connection to connect to the database, and you should see
    a list of DBs on the left-hand side, an empty area on the right-hand side, and
    a menu and toolbars on the top. From the File menu, click on New Query Tab, or
    press *Ctrl* + *T* to get a new query window. Here, we will write our queries
    to create a database and create a table within that database.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 双击连接到数据库，你应该能够在左侧看到一个DB列表，在右侧看到一个空白区域，在顶部看到一个菜单和工具栏。从文件菜单中，点击新查询选项卡，或按*Ctrl*
    + *T*获得一个新的查询窗口。在这里，我们将编写我们的查询来创建一个数据库，并在该数据库中创建一个表。
- en: The bundled installer downloaded from [https://dev.mysql.com/downloads/windows/installer/5.7.html](https://dev.mysql.com/downloads/windows/installer/5.7.html)
    is for Windows only. Linux users have to download the MySQL Server and MySQL Workbench
    (GUI for interacting with DB) separately.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://dev.mysql.com/downloads/windows/installer/5.7.html](https://dev.mysql.com/downloads/windows/installer/5.7.html)下载的捆绑安装程序仅适用于Windows。Linux用户必须单独下载MySQL服务器和MySQL
    Workbench（与DB交互的GUI）。
- en: The MySQL server can be downloaded from [https://dev.mysql.com/downloads/mysql/](https://dev.mysql.com/downloads/mysql/).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL服务器可以从[https://dev.mysql.com/downloads/mysql/](https://dev.mysql.com/downloads/mysql/)下载。
- en: The MySQL Workbench can be downloaded from [https://dev.mysql.com/downloads/workbench/](https://dev.mysql.com/downloads/workbench/).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Workbench可以从[https://dev.mysql.com/downloads/workbench/](https://dev.mysql.com/downloads/workbench/)下载。
- en: Creating a sample database
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个示例数据库
- en: 'Run the following SQL statement to create a database:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下SQL语句创建数据库：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating a person table
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个人员表
- en: 'Run the following SQL statements to use the newly created database and create
    a simple person table:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下SQL语句使用新创建的数据库并创建一个简单的人员表：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Populating sample data
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充示例数据
- en: 'Let''s go ahead and insert some sample data in the table we just created:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在我们刚刚创建的表中插入一些示例数据：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we have our database ready, we will go ahead and download the empty
    Spring Boot project from [http://start.spring.io/](http://start.spring.io/) with
    the following options:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的数据库准备好了，我们将继续从[http://start.spring.io/](http://start.spring.io/)下载空的Spring
    Boot项目，选项如下：
- en: '![](img/6f336164-f3e0-4bb5-8fe4-439252c7baf0.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f336164-f3e0-4bb5-8fe4-439252c7baf0.png)'
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a model class, `com.packt.boot_db_demo.Person`, to represent a person.
    We will make use of Lombok annotations to generate the getters and setters for
    us:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个模型类`com.packt.boot_db_demo.Person`，代表一个人。我们将使用Lombok注解为我们生成getter和setter：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create `com.packt.boot_db_demo.PersonMapper` to map the data from the database
    into our model class, `Person`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`com.packt.boot_db_demo.PersonMapper`将数据库中的数据映射到我们的模型类`Person`：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s add a method to get all the rows from the table. Note that the next
    few methods will be written inside the `PersonMapper` interface:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个方法来获取表中的所有行。请注意，接下来的几个方法将写在`PersonMapper`接口内：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Another method to get the details of a single person identified by ID is as
    follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过ID标识的单个人的详细信息的另一种方法如下：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The method to create a new row in the table is as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表中创建新行的方法如下：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The method to update an existing row in the table, identified by the ID, is
    as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新表中现有行的方法，通过ID标识：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The method to delete a row from the table, identified by the ID, is as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从表中删除行的方法，通过ID标识：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s create a `com.packt.boot_db_demo.PersonController` class, which we will
    use to write our web endpoints:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个`com.packt.boot_db_demo.PersonController`类，我们将用它来编写我们的web端点：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s create an endpoint to list all the entries in the `person` table:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个端点来列出`person`表中的所有条目：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s create an endpoint to add a new row in the `person` table:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个端点来在`person`表中添加一个新行：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s create an endpoint to add a new row or edit an existing row in the `person`
    table:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个端点来在`person`表中添加一个新行或编辑一个现有行：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s create an endpoint to delete a row from the `person` table:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个端点来从`person`表中删除一行：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Update the `src/main/resources/application.properties` file to provide the
    configuration related to our data source, that is, our MySQL database:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`src/main/resources/application.properties`文件，提供与我们的数据源（即MySQL数据库）相关的配置：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can run the application from the command line using `mvn spring-boot:run`.
    This application starts up on the default port, that is, `8080`. Navigate to `http://localhost:8080/persons`
    in your browser.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`mvn spring-boot:run`命令行运行应用程序。该应用程序在默认端口`8080`上启动。在浏览器中导航到`http://localhost:8080/persons`。
- en: The complete code for this recipe can be found at `Chapter09/2_boot_db_demo`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的完整代码可以在`Chapter09/2_boot_db_demo`找到。
- en: 'On visiting `http://localhost:8080/persons`, this is what you will find:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`http://localhost:8080/persons`，您会看到以下内容：
- en: '![](img/db4bfc97-92cf-41ab-80a7-00fd37217a9f.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db4bfc97-92cf-41ab-80a7-00fd37217a9f.png)'
- en: 'On clicking on **New Person**, you''ll get the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**新建人员**，您会得到以下内容：
- en: '![](img/4f5cf0ca-3c12-435a-9fb2-64c2891729fd.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f5cf0ca-3c12-435a-9fb2-64c2891729fd.png)'
- en: 'On clicking on **Edit**, you''ll get the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**编辑**，你会得到以下内容：
- en: '![](img/afe20954-24b9-43f5-b76b-1f4b171e1666.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/afe20954-24b9-43f5-b76b-1f4b171e1666.png)'
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Firstly, `com.packt.boot_db_demo.PersonMapper` annotated with `org.apache.ibatis.annotations.Mapper`
    knows how to execute the query provided within the `@Select`, `@Update`, and `@Delete`
    annotations and to return relevant results. This is all managed by the MyBatis
    and Spring Data libraries.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`com.packt.boot_db_demo.PersonMapper`使用`org.apache.ibatis.annotations.Mapper`注解知道如何执行`@Select`、`@Update`和`@Delete`注解中提供的查询，并返回相关结果。这一切都由MyBatis和Spring
    Data库管理。
- en: You must be wondering how the connection to the database was achieved. One of
    the Spring Boot auto-configuration classes, `DataSourceAutoConfiguration`, does
    the work of setting up by making use of the `spring.datasource.*` properties defined
    in your `application.properties` file to give us an instance of `javax.sql.DataSource`.
    This `javax.sql.DataSource` object is then used by the MyBatis library to provide
    you with an instance of `SqlSessionTemplate`, which is what is used by our `PersonMapper`
    under the hood.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定想知道如何实现与数据库的连接。Spring Boot的一个自动配置类`DataSourceAutoConfiguration`通过使用`application.properties`文件中定义的`spring.datasource.*`属性来设置连接，从而为我们提供了`javax.sql.DataSource`的实例。然后MyBatis库使用这个`javax.sql.DataSource`对象为我们提供了`SqlSessionTemplate`的实例，这就是我们的`PersonMapper`在后台使用的。
- en: Then, we make use of `com.packt.boot_db_demo.PersonMapper` by injecting it into
    the `com.packt.boot_db_demo.PersonController` class by using `@AutoWired`. The
    `@AutoWired` annotation looks for any Spring managed beans, which are either instances
    of the exact type or its implementation. Take a look at the *Creating a simple
    Spring Boot application* recipe in this chapter to understand the `@Controller`
    annotation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过`@AutoWired`将`com.packt.boot_db_demo.PersonMapper`注入到`com.packt.boot_db_demo.PersonController`类中。`@AutoWired`注解寻找任何Spring管理的bean，这些bean要么是确切类型的实例，要么是其实现。查看本章中的*创建一个简单的Spring
    Boot应用程序*食谱，了解`@Controller`注解。
- en: With very little configuration, we have been able to quickly set up simple CRUD
    operations. This is the flexibility and agility that Spring Boot provides to developers!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借极少的配置，我们已经能够快速设置简单的CRUD操作。这就是Spring Boot为开发人员提供的灵活性和敏捷性！
- en: Creating a RESTful web service
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建RESTful Web服务
- en: In our previous recipe, we interacted with data using web forms. In this recipe,
    we will see how to interact with data using RESTful web services. These web services
    are a means to interact with other applications using the known HTTP protocol
    and its methods, namely GET, POST, and PUT. The data can be exchanged in the form
    of XML, JSON, or even plain text. We will be using JSON in our recipe.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个食谱中，我们使用Web表单与数据进行交互。在这个食谱中，我们将看到如何使用RESTful Web服务与数据进行交互。这些Web服务是使用已知的HTTP协议及其方法（即GET、POST和PUT）与其他应用程序进行交互的一种方式。数据可以以XML、JSON甚至纯文本的形式交换。我们将在我们的食谱中使用JSON。
- en: So, we will create RESTful APIs to support retrieving data, creating new data,
    editing data, and deleting data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将创建RESTful API来支持检索数据、创建新数据、编辑数据和删除数据。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As usual, download the starter project from [http://start.spring.io/](http://start.spring.io/) by
    selecting the dependencies shown in the following screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，通过选择以下截图中显示的依赖项从[http://start.spring.io/](http://start.spring.io/)下载起始项目：
- en: '![](img/90cb2683-ac4e-49f1-bd9d-78582636818c.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90cb2683-ac4e-49f1-bd9d-78582636818c.png)'
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Copy the `Person` class from the previous recipe:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一个食谱中复制`Person`类：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will do the `PersonMapper` part in a different way. We will write all our
    SQL queries in a mapper XML file and then refer to them from the `PersonMapper`
    interface. We will place the mapper XML under the `src/main/resources/mappers`
    folder. We'll set the value of the `mybatis.mapper-locations` property to `classpath*:mappers/*.xml`.
    This way, the `PersonMapper` interface can discover the SQL queries corresponding
    to its methods.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将以不同的方式完成`PersonMapper`部分。我们将在一个mapper XML文件中编写所有的SQL查询，然后从`PersonMapper`接口中引用它们。我们将把mapper
    XML放在`src/main/resources/mappers`文件夹下。我们将`mybatis.mapper-locations`属性的值设置为`classpath*:mappers/*.xml`。这样，`PersonMapper`接口就可以发现与其方法对应的SQL查询。
- en: 'Create the `com.packt.boot_rest_demo.PersonMapper` interface:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`com.packt.boot_rest_demo.PersonMapper`接口：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create the SQL in `PersonMapper.xml`. Make sure that the `namespace` attribute
    of the `<mapper>` tag is the same as the fully qualified name of the `PersonMapper`
    mapper interface:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PersonMapper.xml`中创建SQL。确保`<mapper>`标签的`namespace`属性与`PersonMapper`映射接口的完全限定名称相同：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Define the application properties in the `src/main/resources/application.properties`
    file:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/resources/application.properties`文件中定义应用程序属性：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create an empty controller for the REST APIs. This controller will be marked
    with the `@RestController` annotation because all the APIs in it are going to
    deal solely with data:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为REST API创建一个空的控制器。这个控制器将被标记为`@RestController`注解，因为其中的所有API都将专门处理数据：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add an API to list all the rows in the `person` table:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个API来列出`person`表中的所有行：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add an API to get the details of a single person:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个API来获取单个人的详细信息：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add an API to add new data to the table:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个API来向表中添加新数据：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add an API to edit the data in the table:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个API来编辑表中的数据：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add an API to delete the data in the table:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个API来删除表中的数据：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can find the complete code at `Chapter09/3_boot_rest_demo`. You can launch
    the application by using `mvn spring-boot:run` from the project folder. Once the
    application has started, navigate to `http://localhost:8080/api/persons` to view
    all the data in the person table.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Chapter09/3_boot_rest_demo`找到完整的代码。您可以通过在项目文件夹中使用`mvn spring-boot:run`来启动应用程序。应用程序启动后，导航到`http://localhost:8080/api/persons`以查看person表中的所有数据。
- en: To test the other APIs, we will make use of the Postman REST client app for
    Google Chrome.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试其他API，我们将使用Google Chrome的Postman REST客户端应用程序。
- en: 'This is what adding a new person looks like. Look at the request body, that
    is, the person detail specified in JSON:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是添加新人的样子。看一下请求体，也就是在JSON中指定的人的详细信息：
- en: '![](img/f79bf64e-58f7-4c15-b37e-2e8e8acfc231.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f79bf64e-58f7-4c15-b37e-2e8e8acfc231.png)'
- en: 'This is how we edit a person''s details:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们编辑一个人的详细信息的方式：
- en: '![](img/b66cfed2-0bea-475f-a514-ddbd7126ec02.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b66cfed2-0bea-475f-a514-ddbd7126ec02.png)'
- en: 'This is what deleting a person looks like:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是删除一个人的样子：
- en: '![](img/0cd04988-3536-48af-b94d-7cb0c1ec1eb9.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0cd04988-3536-48af-b94d-7cb0c1ec1eb9.png)'
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, let's look at how the `PersonMapper` interface discovers the SQL statements
    to execute. If you look at `src/main/resources/mappers/PersonMapper.xml`, you
    will find that the `<mapper>` `namespace` attribute is `org.packt.boot_rest_demo.PersonMapper`.
    This is a requirement that the value of the `namespace` attribute should be the
    fully qualified name of the mapper interface, which, in our case, is `org.packt.boot_rest_demo.PersonMapper`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下`PersonMapper`接口是如何发现要执行的SQL语句的。如果您查看`src/main/resources/mappers/PersonMapper.xml`，您会发现`<mapper>`的`namespace`属性是`org.packt.boot_rest_demo.PersonMapper`。这是一个要求，即`namespace`属性的值应该是mapper接口的完全限定名称，在我们的例子中是`org.packt.boot_rest_demo.PersonMapper`。
- en: Next, the `id` attributes of the individual SQL statements defined within `<select>`,
    `<insert>`, `<update>`, and `<delete>` should match the name of the method in
    the mapper interface. For example, the `getPersons()` method in the `PersonMapper`
    interface looks for a SQL statement with `id="getPersons"`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`<select>`、`<insert>`、`<update>`和`<delete>`中定义的各个SQL语句的`id`属性应该与mapper接口中方法的名称匹配。例如，`PersonMapper`接口中的`getPersons()`方法寻找一个`id="getPersons"`的SQL语句。
- en: Now, the MyBatis library discovers the location of this mapper XML by reading
    the value of the `mybatis.mapper-locations` property.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，MyBatis库通过读取`mybatis.mapper-locations`属性的值来发现mapper XML的位置。
- en: Coming to the controller, we have introduced a new annotation, `@RestController`.
    This special annotation indicates, in addition to it being a web controller, that
    all the methods defined in the class return a response that is sent via the HTTP
    response body; so do all the REST APIs. They just work with the data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 关于控制器，我们引入了一个新的注解`@RestController`。这个特殊的注解表示，除了它是一个web控制器之外，类中定义的所有方法都返回通过HTTP响应体发送的响应；所有的REST
    API都是如此。它们只是处理数据。
- en: As usual, you can launch your Spring Boot application either by using the Maven
    Spring Boot plugin, `mvn spring-boot:run`, or by executing the JAR created by
    the Maven package, `java -jar my_jar_name.jar`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您可以通过使用Maven Spring Boot插件`mvn spring-boot:run`或者执行Maven包创建的JAR`java -jar
    my_jar_name.jar`来启动Spring Boot应用程序。
- en: Creating multiple profiles for Spring Boot
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Spring Boot创建多个配置文件
- en: Generally, web applications are deployed on different environments – first,
    they are run locally on a developer's machine, then deployed on test servers,
    and finally deployed on production servers. We would have the application interacting
    with components located in different places for each environment. The best approach
    for this is to maintain different profiles for each environment. One way to do
    this is by creating different versions of the `application.properties` file, that
    is, different versions of the file that stores the application-level properties.
    These property files in Spring Boot can also be YML files, such as `application.yml`.
    Even if you create different versions, you need a mechanism to tell your applications
    to pick the relevant version of the file, based on the environment it has been
    deployed to.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Web应用程序在不同的环境上部署 - 首先在开发人员的机器上本地运行，然后部署在测试服务器上，最后部署在生产服务器上。对于每个环境，我们希望应用程序与位于不同位置的组件进行交互。这种情况下的最佳方法是为每个环境维护不同的配置文件。其中一种方法是创建不同版本的`application.properties`文件，即存储应用程序级属性的文件的不同版本。Spring
    Boot中的这些属性文件也可以是YML文件，比如`application.yml`。即使您创建了不同的版本，您也需要一种机制来告诉您的应用程序选择与其部署的环境相关的文件的相关版本。
- en: Spring Boot provides amazing support for such a feature. It allows you to have
    multiple configuration files, each representing a specific profile, and then,
    you can launch your application in different profiles, depending on the environment
    it is being deployed to. Let's see this in action, and then we will explain how
    it works.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot为这样的功能提供了令人惊叹的支持。它允许您拥有多个配置文件，每个文件代表一个特定的配置文件，然后，您可以根据部署的环境在不同的配置文件中启动应用程序。让我们看看它是如何运作的，然后我们将解释它是如何工作的。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, there are two options to host another instance of your MySQL
    database:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，有两种选项来托管另一个实例的MySQL数据库：
- en: Use a cloud provider such as AWS and use its Amazon **Relational Database Service**
    (**RDS**) ([https://aws.amazon.com/rds/](https://aws.amazon.com/rds/)). They have
    a certain free usage limit.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用云服务提供商，比如AWS，并使用其Amazon **关系型数据库服务**（**RDS**）([https://aws.amazon.com/rds/](https://aws.amazon.com/rds/))。它们有一定的免费使用限制。
- en: Use a cloud provider such as DigitalOcean ([https://www.digitalocean.com/](https://www.digitalocean.com/))
    to purchase a droplet (that is, a server) for as little as $5 per month. Install
    the MySQL server on it.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用云服务提供商，比如DigitalOcean ([https://www.digitalocean.com/](https://www.digitalocean.com/))，以每月5美元的价格购买一个droplet（即服务器）。在其上安装MySQL服务器。
- en: Use VirtualBox to install Linux on your machine, assuming we are using Windows,
    or vice versa if you are using Linux. Install the MySQL server on it.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用VirtualBox在您的机器上安装Linux，假设我们使用Windows，或者如果您使用Linux，则反之。在其上安装MySQL服务器。
- en: 'The options are much more, right from hosted database services to servers,
    which give you complete root access to install the MySQL server. For this recipe,
    we did the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 选项非常多，从托管数据库服务到服务器，都可以让您完全控制MySQL服务器的安装。对于这个配方，我们做了以下工作：
- en: We purchased a basic droplet from DigitalOcean.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从DigitalOcean购买了一个基本的droplet。
- en: We installed MySQL using `sudo apt-get install mysql-server-5.7` with a password
    for the root user.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`sudo apt-get install mysql-server-5.7`安装了MySQL，并为root用户设置了密码。
- en: 'We created another user, `springboot`, so that we can use this user to connect
    from our RESTful web service application:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了另一个用户`springboot`，以便我们可以使用这个用户从我们的RESTful Web服务应用程序进行连接：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We modified the MySQL configuration file so that the MySQL allows remote connections.
    This can be done by editing the `bind-address` property in the `/etc/mysql/mysql.conf.d/mysqld.cnf`
    file for the IP of the server.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们修改了MySQL配置文件，以便MySQL允许远程连接。这可以通过编辑`/etc/mysql/mysql.conf.d/mysqld.cnf`文件中的`bind-address`属性来完成。
- en: From the MySQL workbench, we added the new MySQL connection by using `IP = <Digital
    Ocean droplet IP>`, `username = springboot`, and `password = springboot`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从MySQL Workbench中，我们通过使用`IP = <Digital Ocean droplet IP>`，`username = springboot`和`password
    = springboot`添加了新的MySQL连接。
- en: 'The  location for the MySQL configuration file in Ubuntu OS is `/etc/mysql/mysql.conf.d/mysqld.cnf`.
    One way to find out the location of a configuration file specific to your OS is
    to do the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu OS中，MySQL配置文件的位置是`/etc/mysql/mysql.conf.d/mysqld.cnf`。找出特定于您的操作系统的配置文件位置的一种方法是执行以下操作：
- en: Run `mysql --help`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`mysql --help`。
- en: In the output, search for `Default options are read from the following files
    in the given order:`. What follows is the possible locations for the MySQL configuration
    file.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输出中，搜索`Default options are read from the following files in the given order:`。接下来是MySQL配置文件的可能位置。
- en: 'We will create the required table and populate some data. But before that,
    we will create the `sample` database as `root` and grant all privileges on it
    to the `springboot` user:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建所需的表并填充一些数据。但在此之前，我们将以`root`身份创建`sample`数据库，并授予`springboot`用户对其的所有权限：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let''s connect to the database as the `springboot` user, create the required
    table, and populate it with some sample data:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以`springboot`用户的身份连接到数据库，创建所需的表，并填充一些示例数据：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, we have our cloud instance of the MySQL DB ready. Let's look at how to
    manage the information of two different connections based on the profile the application
    is running in.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了云实例的MySQL数据库准备就绪。让我们看看如何根据应用程序运行的配置文件管理两个不同连接的信息。
- en: The initial sample app required for this recipe can be found at `Chapter09/4_boot_multi_profile_incomplete`.
    We will convert this app to make it run on different environments.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`Chapter09/4_boot_multi_profile_incomplete`中找到此配方所需的初始示例应用程序。我们将转换此应用程序，使其在不同的环境中运行。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: In the `src/main/resources/application.properties` file, add a new `springboot`
    property, `spring.profiles.active = local`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/resources/application.properties`文件中，添加一个新的`springboot`属性，`spring.profiles.active
    = local`。
- en: Create a new file, `application-local.properties`, in `src/main/resources/`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/resources/`中创建一个新文件`application-local.properties`。
- en: 'Add the following properties to `application-local.properties` and remove them
    from the `application.properties` file:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到`application-local.properties`中，并从`application.properties`文件中删除它们：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Create another file, `application-cloud.properties`, in `src/main/resources/`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/resources/`中创建另一个文件`application-cloud.properties`。
- en: 'Add the following properties to `application-cloud.properties`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到`application-cloud.properties`中：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The complete code for the complete application can be found at `Chapter09/4_boot_multi_profile_incomplete`**.** You
    can run the application using the `mvn spring-boot:run` command. Spring Boot reads
    the `spring.profiles.active` property from the `application.properties` file and
    runs the application in a local profile. Open the `http://localhost:8080/api/persons` URL
    in the browser to find the following data:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序代码可以在`Chapter09/4_boot_multi_profile_incomplete`中找到。您可以使用`mvn spring-boot:run`命令运行应用程序。Spring
    Boot从`application.properties`文件中读取`spring.profiles.active`属性，并在本地配置文件中运行应用程序。在浏览器中打开`http://localhost:8080/api/persons`URL，以查看以下数据：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, run the application on the cloud profile by using the `mvn spring-boot:run
    -Dspring.profiles.active=cloud` command. Then, open `http://localhost:8080/api/persons`
    in the browser to find the following data:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`mvn spring-boot:run -Dspring.profiles.active=cloud`命令在云配置文件上运行应用程序。然后，在浏览器中打开`http://localhost:8080/api/persons`，以查看以下数据：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can see that there is a different set of data returned by the same API
    and the preceding data was inserted in our MySQL database running on the cloud.
    So, we have been able to successfully run the app in two different profiles: local
    and cloud.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到相同API返回了不同的数据集，并且之前的数据是插入到我们在云上运行的MySQL数据库中的。因此，我们已成功地在两个不同的配置文件中运行了应用程序：本地和云端。
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'There are multiple ways Spring Boot can read the configuration for the application.
    Some significant ones are listed here in the order of their relevance (the property
    defined in the earlier source overrides the property defined in the later sources):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot可以以多种方式读取应用程序的配置。以下是一些重要的方式，按其相关性顺序列出（在较早的源中定义的属性会覆盖在后来的源中定义的属性）：
- en: From the command line. The properties are specified using the `-D` option, like
    we did while launching the app in the cloud profile, `mvn spring-boot:run -Dspring.profiles.active=cloud`.
    Or, if you are using JAR, it would be `java -Dspring.profiles.active=cloud -jar
    myappjar.jar`.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行。属性使用`-D`选项指定，就像我们在云配置文件中启动应用程序时所做的那样，`mvn spring-boot:run -Dspring.profiles.active=cloud`。或者，如果您使用JAR，它将是`java
    -Dspring.profiles.active=cloud -jar myappjar.jar`。
- en: From the Java system properties, using `System.getProperties()`.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Java系统属性，使用`System.getProperties()`。
- en: OS environment variables.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统环境变量。
- en: Profile-specific application properties, `application-{profile}.properties`,
    or the `application-{profile}.yml` files, outside of the packaged JAR.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定配置文件，`application-{profile}.properties`或`application-{profile}.yml`文件，打包在JAR之外。
- en: Profile-specific application properties, the `application-{profile}.properties`
    or `application-{profile}.yml` files, packaged within the JAR.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定配置文件，`application-{profile}.properties`或`application-{profile}.yml`文件，打包在JAR中。
- en: Application properties, `application.properties`, or `application.yml` defined
    outside of the packaged JAR.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序属性，`application.properties`或`application.yml`定义在打包的JAR之外。
- en: Application properties, `application.properties`, or `application.yml` packaged
    within the JAR.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序属性，`application.properties`或`application.yml`打包在JAR中。
- en: Configuration classes (that is, annotated with `@Configuration`) serving as
    property sources (annotated with `@PropertySource`).
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置类（即使用`@Configuration`注释）作为属性源（使用`@PropertySource`注释）。
- en: Spring Boot's default properties.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot的默认属性。
- en: 'In our recipe, we specified all the generic properties, such as the following,
    in the `application.properties` file, and any profile-specific properties were
    specified in the profile-specific application properties file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们在`application.properties`文件中指定了所有通用属性，例如以下属性，并且任何特定配置文件中的特定配置属性都在特定配置文件中指定：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: From the preceding list, we can find that the `application.properties` or `application-{profile}.properties`
    file can be defined outside the application JAR. There are default locations where
    Spring Boot will search for the properties file, and one such path is the `config`
    subdirectory of the current directory the app is running from.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的列表中，我们可以发现`application.properties`或`application-{profile}.properties`文件可以在应用程序JAR之外定义。Spring
    Boot将搜索属性文件的默认位置，其中一个路径是应用程序正在运行的当前目录的`config`子目录。
- en: The complete list of Spring Boot-supported application properties can be found
    at [http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html](http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html).
    In addition to these, we can create our own properties, which will be required
    for our application.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot支持的应用程序属性的完整列表可以在[http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html](http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html)找到。除了这些，我们可以创建自己的属性，这些属性将为我们的应用程序所需。
- en: The complete code for this recipe can be found at `Chapter09/4_boot_multi_profile_complete`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整代码可以在`Chapter09/4_boot_multi_profile_complete`找到。
- en: There's more...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can create a configuration server using Spring Boot, which will act as a
    repository for all the properties for all the apps in all the profiles. The client
    apps can then connect with the configuration server to read the relevant properties
    based on the app name and the app profile.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Spring Boot创建一个配置服务器，它将作为所有应用程序在所有配置文件中的所有属性的存储库。然后客户端应用程序可以连接到配置服务器，根据应用程序名称和应用程序配置读取相关属性。
- en: In the configuration server, the application properties can be read from the
    filesystem using the classpath or a GitHub repository. The advantage of using
    a GitHub repository is that the property files can be versioned. The property
    files in the configuration server can be updated, and these updates can be pushed
    to the client apps by setting up a message queue to relay the changes downstream.
    Another way is to use the `@RefreshScope` beans and then invoke the `/refresh`
    API whenever we need the client apps to pull the configuration changes.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置服务器中，可以使用类路径或GitHub存储库从文件系统读取应用程序属性。使用GitHub存储库的优势是属性文件可以进行版本控制。配置服务器中的属性文件可以更新，并且可以通过设置消息队列将这些更新推送到客户端应用程序的下游。另一种方法是使用`@RefreshScope`
    bean，然后在需要客户端应用程序拉取配置更改时调用`/refresh` API。
- en: Deploying RESTful web services to Heroku
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将RESTful web服务部署到Heroku
- en: '**Platform as a Service** (**Paas**) is one of the cloud computing models (the
    other two being **Software as a Service** (**SaaS**) and **Infrastructure as a
    Service** (**IaaS**)) where the cloud computing provider provides managed computing
    platforms, which includes OS, programming language runtime, database, and other
    add-ons such as queues, log management, and alerting. They also provide you with
    tools to ease the deployment and dashboards to monitor your applications.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**平台即服务**（**PaaS**）是云计算模型之一（另外两个是**软件即服务**（**SaaS**）和**基础设施即服务**（**IaaS**）），其中云计算提供商提供托管的计算平台，包括操作系统、编程语言运行时、数据库和其他附加组件，如队列、日志管理和警报。他们还为您提供工具来简化部署和监视应用程序的仪表板。'
- en: Heroku is one of the earliest players in the field of PaaS providers. It supports
    the following programming languages: Ruby, Node.js, Java, Python, Clojure, Scala,
    Go, and PHP. Heroku supports multiple data stores, such as MySQL, MongoDB, Redis,
    and Elastic search. It provides integration with logging tools, network utilities,
    email services, and monitoring tools.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku是PaaS提供商领域中最早的参与者之一。它支持以下编程语言：Ruby、Node.js、Java、Python、Clojure、Scala、Go和PHP。Heroku支持多个数据存储，如MySQL、MongoDB、Redis和Elasticsearch。它提供与日志记录工具、网络实用程序、电子邮件服务和监视工具的集成。
- en: Heroku provides a command-line tool called heroku-cli ([cli.heroku.com](http://cli.heroku.com)),
    which can be used to create Heroku applications, deploy, monitor, add resources,
    and more. The functionality provided by their web dashboard is supported by the
    CLI as well. It uses Git to store the application's source code. So, when you
    push the application code to Heroku's Git repository, it triggers a build, based
    on the build pack you are using. Then, it either uses the default way to spawn
    the application or `ProcFile` to execute your application.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku提供了一个名为heroku-cli（[cli.heroku.com](http://cli.heroku.com)）的命令行工具，可用于创建Heroku应用程序，部署，监视，添加资源等。其Web仪表板提供的功能也受到CLI的支持。它使用Git存储应用程序的源代码。因此，当您将应用程序代码推送到Heroku的Git存储库时，它会触发一个构建，根据您使用的构建包进行构建。然后，它要么使用默认方式生成应用程序，要么使用`ProcFile`来执行您的应用程序。
- en: In this recipe, we will deploy our Spring Boot-based RESTful web service to
    Heroku. We will continue to use the database we created on another cloud provider
    in the previous recipe, *Creating multiple profiles for Spring Boot*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将把基于Spring Boot的RESTful Web服务部署到Heroku。我们将继续使用我们在上一个示例“为Spring Boot创建多个配置文件”中在另一个云提供商上创建的数据库。
- en: Getting ready
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we proceed with deploying our sample application on Heroku, we need to
    sign up for a Heroku account and install its tools, which will enable us to work
    from the command line. In the subsequent sections, we will guide you through the
    signup process, creating a sample app via the web UI, and via the Heroku **command-line
    interface** (**CLI**).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续在Heroku上部署我们的示例应用程序之前，我们需要注册Heroku帐户并安装其工具，这将使我们能够从命令行工作。在接下来的章节中，我们将指导您完成注册过程，通过Web
    UI创建示例应用程序，以及通过Heroku命令行界面（CLI）。
- en: Setting up a Heroku account
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Heroku账户
- en: 'Visit [http://www.heroku.com](http://www.heroku.com) and sign up if you don''t
    have an account. If you have an account, you can log in. To sign up, visit [https://signup.heroku.com](https://signup.heroku.com):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[http://www.heroku.com](http://www.heroku.com)并注册账户。如果您已经有账户，可以登录。要注册，请访问[https://signup.heroku.com](https://signup.heroku.com)：
- en: '![](img/0adec601-5151-4e7f-9284-f2aa214d06b3.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0adec601-5151-4e7f-9284-f2aa214d06b3.png)'
- en: 'To log in, the URL is [https://id.heroku.com/login](https://id.heroku.com/login):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要登录，URL是[https://id.heroku.com/login](https://id.heroku.com/login)：
- en: '![](img/7628a737-18d7-4b89-8687-eb40e6609e82.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7628a737-18d7-4b89-8687-eb40e6609e82.png)'
- en: 'Once you log in successfully, you will see a dashboard with the list of apps,
    if you have any:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 成功登录后，您将看到一个仪表板，列出了应用程序的列表，如果有的话：
- en: '![](img/778b9c57-33dd-4792-8caf-cae817772c6b.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/778b9c57-33dd-4792-8caf-cae817772c6b.png)'
- en: Creating a new app from the UI
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从UI创建新应用
- en: 'Click on New | Create new app, fill in the details, and click on Create App:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 单击New | Create new app，填写详细信息，然后单击Create App：
- en: '![](img/f73432fd-4370-4bf1-aa8a-98407d34d47c.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f73432fd-4370-4bf1-aa8a-98407d34d47c.png)'
- en: Creating a new app from the CLI
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从CLI创建新应用程序
- en: 'Perform the following steps to create a new app from the CLI:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤从CLI创建一个新应用程序：
- en: Install the Heroku CLI from [https://cli.heroku.com](https://cli.heroku.com).
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://cli.heroku.com](https://cli.heroku.com)安装Heroku CLI。
- en: Once installed, Heroku should be in your system's `PATH` variable.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装后，Heroku应该在系统的`PATH`变量中。
- en: 'Open a command prompt and run `heroku create`. You will see an output similar
    to the following:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符并运行`heroku create`。您将看到类似以下的输出：
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The app name is generated dynamically and a remote Git repository is created.
    You can specify the app name and region (as done via the UI) by running the following
    command:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序名称是动态生成的，并创建了一个远程Git存储库。您可以通过运行以下命令指定应用程序名称和区域（与UI中所做的一样）：
- en: '[PRE39]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The deployment to Heroku is done via `git push` to the remote Git repository
    created on Heroku. We will see this in the next section.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`git push`将部署到Heroku的代码推送到远程Git存储库。我们将在下一节中看到这一点。
- en: We have the source code for the app at `Chapter09/5_boot_on_heroku`. So, copy
    this application and go ahead and deploy on Heroku.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Chapter09/5_boot_on_heroku`中有应用程序的源代码。因此，复制此应用程序，然后继续在Heroku上部署。
- en: You have to log into the Heroku account before running any of the commands in
    Heroku's cli. You can log in by running the `heroku login` command.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行Heroku的cli中的任何命令之前，您必须登录Heroku帐户。您可以通过运行`heroku login`命令来登录。
- en: How to do it...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Run the following command to create a Heroku application:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令创建一个Heroku应用程序：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Initialize the Git repository in the project folder:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件夹中初始化Git存储库：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add the Heroku Git repository as a remote to your local Git repository:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Heroku Git存储库添加为本地Git存储库的远程存储库：
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Push the source code, that is, the master branch, to the Heroku Git repository:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将源代码，即主分支，推送到Heroku Git存储库：
- en: '[PRE43]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When the code is pushed to the Heroku Git repository, it triggers a build.
    As we are using Maven, it runs the following command:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当代码推送到Heroku Git存储库时，会触发构建。由于我们使用Maven，它运行以下命令：
- en: '[PRE44]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Once the code has completed the build and deployed, you can open the application
    by using the `heroku open` command. This will open the application in a browser.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码完成构建和部署后，您可以使用`heroku open`命令在浏览器中打开应用程序。
- en: You can monitor the logs of the application using the `heroku logs --tail` command.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`heroku logs --tail`命令监视应用程序的日志。
- en: 'Once the app has been successfully deployed, and after you run the `heroku
    open` command, you should see the URL being loaded by the browser:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序成功部署后，并且在运行`heroku open`命令后，您应该看到浏览器加载的URL：
- en: '![](img/661af9df-5c65-4418-9727-ba2d9c7d00c5.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/661af9df-5c65-4418-9727-ba2d9c7d00c5.png)'
- en: 'Clicking on the Persons link will display the following information:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 单击`Persons`链接将显示以下信息：
- en: '[PRE45]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The interesting thing here is that we have our app running on Heroku, which
    is connecting to a MySQL database on a DigitalOcean server. We can even provision
    a database along with the Heroku app and connect to that database. Check out how
    to do this in the *There's more...* section.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们的应用程序正在Heroku上运行，它正在连接到DigitalOcean服务器上的MySQL数据库。我们甚至可以为Heroku应用程序提供数据库并连接到该数据库。在*还有更多...*部分了解如何执行此操作。
- en: There's more...
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Add a new DB add-on to the application:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向应用程序添加新的DB附加组件：
- en: '[PRE46]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, `addons:create` takes the add-on name and the service plan name, both
    separated by a colon (`:`). You can learn more about the add-on details and plans
    at [https://elements.heroku.com/addons/jawsdb-maria](https://elements.heroku.com/addons/jawsdb-maria).
    Also, the Heroku CLI command to add the add-on to your application is given toward
    the end of the add-on details page for all add-ons.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`addons:create`接受附加组件名称和服务计划名称，两者用冒号(`:`)分隔。您可以在[https://elements.heroku.com/addons/jawsdb-maria](https://elements.heroku.com/addons/jawsdb-maria)上了解有关附加组件详细信息和计划的更多信息。此外，所有附加组件的附加组件详细信息页面末尾都提供了向应用程序添加附加组件的Heroku
    CLI命令。
- en: 'Open the DB dashboard to view the connection details, such as URL, username,
    password, and the database name:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开DB仪表板以查看连接详细信息，如URL、用户名、密码和数据库名称：
- en: '[PRE47]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `jawsdb` dashboard looks something similar to the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`jawsdb`仪表板看起来与以下类似：'
- en: '![](img/6677a63b-02f6-4c51-8144-2aafa8f92507.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6677a63b-02f6-4c51-8144-2aafa8f92507.png)'
- en: 'You can even get the MySQL connection string from the `JAWSDB_URL` configuration
    property. You can list the configuration for your app by using the following command:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 甚至可以从`JAWSDB_URL`配置属性中获取MySQL连接字符串。您可以使用以下命令列出应用程序的配置：
- en: '[PRE48]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Copy the connection details, create a new connection in MySQL Workbench, and
    connect to this connection. The database name is also created by the add-on. Run
    the following SQL statements after connecting to the database:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制连接详细信息，在MySQL Workbench中创建一个新连接，并连接到此连接。数据库名称也是由附加组件创建的。连接到数据库后运行以下SQL语句：
- en: '[PRE49]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a new properties file for the Heroku profile, `application-heroku.properties`,
    at  `src/main/resources`, with the following properties:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/resources`中为Heroku配置文件创建一个新的属性文件，名为`application-heroku.properties`，包含以下属性：
- en: '[PRE50]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can find the connection-related details in the add-on dashboard.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在附加仪表板中找到与连接相关的详细信息。
- en: Update the `src/main/resources/application.properties` file to replace the value
    of the `spring.profiles.active` property to `heroku`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`src/main/resources/application.properties`文件，将`spring.profiles.active`属性的值替换为`heroku`。
- en: 'Commit and push the changes to the Heroku remote:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更改提交并推送到Heroku远程：
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Once the deployment succeeds, run the `heroku open` command. Once the page
    loads in the browser, click on the Persons link. This time, you will see a different
    set of data, the one we entered in our Heroku add-on:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署成功后，运行`heroku open`命令。页面在浏览器中加载后，单击`Persons`链接。这次，您将看到一组不同的数据，这是我们在Heroku附加组件中输入的数据：
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: With this, we have integrated with a database that we created in Heroku.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经与在Heroku中创建的数据库集成。
- en: Containerizing the RESTful web service using Docker
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker对RESTful Web服务进行容器化
- en: We have advanced a lot from the time when an app would be installed across servers,
    to each server being virtualized and the app then being installed on these smaller
    virtual machines. Scalability issues for the applications were resolved by adding
    more virtual machines, with the app running to the load balancer.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从将应用程序安装在服务器上的时代发展到每个服务器都被虚拟化，然后应用程序安装在这些较小的虚拟机上。通过添加更多虚拟机来解决应用程序的可扩展性问题，使应用程序运行到负载均衡器上。
- en: In virtualization, a large server is divided into multiple virtual machines
    by allocating the computing power, memory, and storage among the multiple virtual
    machines. This way, each of the virtual machines is in itself capable of all those
    things that a server was, albeit on a smaller scale. With this virtualization
    has helped us a lot in judiciously making use of the server's computing, memory,
    and storage resources.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟化中，通过在多个虚拟机之间分配计算能力、内存和存储来将大型服务器划分为多个虚拟机。这样，每个虚拟机本身都能够像服务器一样完成所有这些任务，尽管规模较小。通过虚拟化，我们可以明智地利用服务器的计算、内存和存储资源。
- en: However, virtualization needs some setup, that is, you need to create the virtual
    machine, install the required dependencies, and then run the app. Moreover, you
    may not be 100% sure if the app would run successfully. The reason for failure
    may be due to the incompatible OS versions or even due to some configuration missed
    while setting up or some missing dependency. This setup also leads to some difficulty
    in horizontal scaling because there is some time spent in the provisioning of
    the virtual machine and then deploying the app.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虚拟化需要一些设置，即您需要创建虚拟机，安装所需的依赖项，然后运行应用程序。此外，您可能无法100%确定应用程序是否能够成功运行。失败的原因可能是由于不兼容的操作系统版本，甚至是由于在设置过程中遗漏了一些配置或缺少了一些依赖项。这种设置还会导致水平扩展方面的一些困难，因为在虚拟机的配置和部署应用程序方面需要花费一些时间。
- en: Using tools such as Puppet and Chef does help in provisioning, but then the
    setting up of the app can often result in issues that might be due to a missing
    or incorrect configuration. This led to the introduction of another concept, called
    containerization.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Puppet和Chef等工具确实有助于配置，但是应用程序的设置往往会导致由于缺少或不正确的配置而出现问题。这导致了另一个概念的引入，称为容器化。
- en: 'In the world of virtualization, we have the host OS and then the virtualization
    software, that is, the hypervisor. We then end up creating multiple machines,
    where each machine has its own OS on which apps are deployed. However, in containerization,
    we don''t divide the resources of the server. Instead, we have the server with
    its host OS, and above that, we have a containerization layer which is a software
    abstraction layer. We package apps as containers, where a container is packaged
    with just enough OS functions required to run the app, the software dependencies
    for the app, and then the app itself. The following image, taken from [https://docs.docker.com/get-started/#container-diagram](https://docs.docker.com/get-started/#containers-vs-virtual-machines),
    best depicts this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟化世界中，我们有主机操作系统，然后是虚拟化软件，也就是hypervisor。然后我们会创建多个机器，每台机器都有自己的操作系统，可以在上面部署应用程序。然而，在容器化中，我们不会划分服务器的资源。相反，我们有带有主机操作系统的服务器，然后在其上方有一个容器化层，这是一个软件抽象层。我们将应用程序打包为容器，其中容器只打包了运行应用程序所需的足够操作系统功能、应用程序的软件依赖项，以及应用程序本身。以下图片最好地描述了这一点：[https://docs.docker.com/get-started/#container-diagram](https://docs.docker.com/get-started/#containers-vs-virtual-machines)。
- en: '![](img/70fd5b75-23b5-4275-b212-bb5b974061dc.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70fd5b75-23b5-4275-b212-bb5b974061dc.png)'
- en: 'The preceding image illustrates a typical architecture of virtualization systems.
    The following image illustrates a typical architecture of containerization systems:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图片说明了典型的虚拟化系统架构。以下图片说明了典型的容器化系统架构：
- en: '![](img/0601180f-dc65-4c35-95b1-08f08095ce22.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0601180f-dc65-4c35-95b1-08f08095ce22.png)'
- en: The biggest advantage of containerization is that you bundle all the dependencies
    of the app into a container image. This image is then run on the containerization
    platform, leading to the creation of a container. We can have multiple containers
    running simultaneously on the server. If there is a need to add more instances,
    we can just deploy the image, and this deployment can be automated to support
    high scalability in an easy way.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化的最大优势在于将应用程序的所有依赖项捆绑到一个容器映像中。然后在容器化平台上运行此映像，从而创建一个容器。我们可以在服务器上同时运行多个容器。如果需要添加更多实例，我们只需部署映像，这种部署可以自动化以支持高可伸缩性。
- en: Docker is one of the popular software-containerization platform. In this recipe,
    we will package our sample app found at the location `Chapter09/6_boot_with_docker` into
    a Docker image and run the Docker image to launch our application.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一种流行的软件容器化平台。在本示例中，我们将把位于`Chapter09/6_boot_with_docker`位置的示例应用程序打包成Docker映像，并运行Docker映像以启动我们的应用程序。
- en: Getting ready
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will use a Linux server running Ubuntu 16.04.2 x64:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，我们将使用运行Ubuntu 16.04.2 x64的Linux服务器：
- en: 'Download the latest `.deb` file from [https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/](https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/).
    For other Linux distros, you can find the packages at [https://download.docker.com/linux/](https://download.docker.com/linux/):'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/](https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/)下载最新的`.deb`文件。对于其他Linux发行版，您可以在[https://download.docker.com/linux/](https://download.docker.com/linux/)找到软件包：
- en: '[PRE53]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Install the Docker package using the `dpkg` package manager:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`dpkg`软件包管理器安装Docker软件包：
- en: '[PRE54]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The name of the package will vary based on the version you have downloaded.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 包的名称将根据您下载的版本而变化。
- en: 'After successful installation, the Docker service starts running. You can verify
    this by using the `service` command:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装成功后，Docker服务开始运行。您可以使用`service`命令验证这一点：
- en: '[PRE55]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The application to be dockerized is available at `Chapter09/6_boot_with_docker`,
    in the source code downloaded for this book.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要docker化的应用程序位于`Chapter09/6_boot_with_docker`，在下载本书的源代码时可获得。
- en: How to do it...
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create `Dockerfile` at the root of the application with the following content:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的根目录创建`Dockerfile`，内容如下：
- en: '[PRE56]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Run the following command to build a Docker image using the `Dockerfile` we
    created in the preceding step:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令使用我们在前面步骤中创建的`Dockerfile`构建Docker映像：
- en: '[PRE57]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can view the images that were installed by using the following command:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下命令查看已安装的映像：
- en: '[PRE58]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You will see that there are OpenJDK and Ubuntu images as well. These were downloaded
    to build the image for our app, which is listed first.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到还有OpenJDK和Ubuntu映像。这些是下载用于构建我们应用程序的映像的。首先列出的是我们的应用程序。
- en: 'Run the image to create a container that contains our running application:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行映像以创建包含我们正在运行的应用程序的容器：
- en: '[PRE59]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The large string printed after the `run` command is the identifier of the container.
    You can use the initial few characters to uniquely identify the container. Alternatively,
    you can use the container name, `restapp`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在`run`命令之后打印的长字符串是容器的标识符。您可以使用前几个字符来唯一标识容器。或者，您可以使用容器名称`restapp`。
- en: 'The app will have already started. You can view the logs by running the following
    command:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序已经启动。您可以通过运行以下命令查看日志：
- en: '[PRE60]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You can view the Docker containers created by using the following command:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下命令查看已创建的Docker容器：
- en: '[PRE61]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output for the preceding command looks similar to the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出类似于以下内容：
- en: '![](img/bf9fa9e9-2603-47ff-93ca-65a4a13ba499.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf9fa9e9-2603-47ff-93ca-65a4a13ba499.png)'
- en: 'You can manage the container by using the following command:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下命令管理容器：
- en: '[PRE62]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Once the app is running, open `http://<hostname>:8090/api/persons`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运行后，打开`http://<hostname>:8090/api/persons`。
- en: How it works...
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You define the container structure and its contents by defining `Dockerfile`.
    `Dockerfile` follows a structure, where each line is of the `INSTRUCTION arguments` form.
    There is a predefined set of instructions, namely `FROM`, `RUN`, `CMD`, `LABEL`,
    `ENV`, `ADD`, and `COPY`. A complete list can be found at [https://docs.docker.com/engine/reference/builder/#from](https://docs.docker.com/engine/reference/builder/#from).
    Let''s look at our defined `Dockerfile`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义`Dockerfile`来定义容器结构和其内容。`Dockerfile`遵循一种结构，其中每一行都是`INSTRUCTION arguments`的形式。有一组预定义的指令，即`FROM`、`RUN`、`CMD`、`LABEL`、`ENV`、`ADD`和`COPY`。完整的列表可以在[https://docs.docker.com/engine/reference/builder/#from](https://docs.docker.com/engine/reference/builder/#from)上找到。让我们看看我们定义的`Dockerfile`：
- en: '[PRE63]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The first two lines, using the `FROM` instruction, specified the base image
    for our Docker image. We use the Ubuntu OS image as the base image and then combine
    it with the OpenJDK 9 image. The `VOLUME` instruction is used to specify the mount
    point for the image. This is usually a path in the host OS.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`FROM`指令的前两行指定了我们的Docker镜像的基础镜像。我们使用Ubuntu OS镜像作为基础镜像，然后将其与OpenJDK 9镜像结合在一起。`VOLUME`指令用于指定镜像的挂载点。这通常是主机操作系统中的路径。
- en: The `ADD` instruction is used to copy the file from the source to the destination
    directory under the working directory. The `ENV` instruction is used to define
    the environment variables.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD`指令用于将文件从源复制到工作目录下的目标目录。`ENV`指令用于定义环境变量。'
- en: The `ENTRYPOINT` instruction is used to configure the container to run as an
    executable. For this instruction, we pass an array of arguments, which we would
    otherwise have executed directly from the command line. In our scenario, we are
    using the bash shell to run `java -$JAVA_OPTS -jar <jar name>`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`指令用于配置容器以作为可执行文件运行。对于此指令，我们传递一个参数数组，否则我们将直接从命令行执行。在我们的场景中，我们使用bash
    shell来运行`java -$JAVA_OPTS -jar <jar name>`。'
- en: Once we have defined `Dockerfile`, we instruct the Docker tool to build an image
    using `Dockerfile`. We also provide a name for the image using the `--tag` option.
    When building our app image, it will download the required base images, which,
    in our case, are the Ubuntu and OpenJDK images. So, if you list the Docker images,
    you will see the base images along with our app image.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了`Dockerfile`，我们就指示Docker工具使用`Dockerfile`构建一个镜像。我们还使用`--tag`选项为镜像提供一个名称。构建我们的应用程序镜像时，它将下载所需的基础镜像，这在我们的情况下是Ubuntu和OpenJDK镜像。因此，如果列出Docker镜像，您将看到基础镜像以及我们的应用程序镜像。
- en: This Docker image is a reusable entity. If we need more instances of the app,
    we spawn a new container using the `docker run` command. When we run the Docker
    image, we have multiple options, where one of them is a `-p` option, which maps
    the ports from within the container to the host OS. In our case, we map the `8080`
    port of our Spring Boot app to `8090` of the host OS.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Docker镜像是一个可重用的实体。如果我们需要更多的应用程序实例，我们可以使用`docker run`命令生成一个新的容器。当我们运行Docker镜像时，有多个选项，其中一个是`-p`选项，它将容器内的端口映射到主机操作系统。在我们的情况下，我们将Spring
    Boot应用程序的`8080`端口映射到主机操作系统的`8090`端口。
- en: Now, to check the status of our running app, we can check the logs using `docker
    logs restapp`. Apart from this, the `docker` tool supports multiple commands.
    It's highly recommended to run `docker help` and explore the commands that are
    supported.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要检查我们运行的应用程序的状态，我们可以使用`docker logs restapp`来检查日志。除此之外，`docker`工具支持多个命令。强烈建议运行`docker
    help`并探索支持的命令。
- en: Docker, the company behind Docker containerization platform, has created a set
    of base images, which can be used to create containers. There are images for MySQL
    DB, Couchbase, Ubuntu, and other operating systems. You can explore the packages
    at [https://store.docker.com/](https://store.docker.com/).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是Docker容器化平台背后的公司，它创建了一组基础镜像，可以用来创建容器。有用于MySQL DB、Couchbase、Ubuntu和其他操作系统的镜像。您可以在[https://store.docker.com/](https://store.docker.com/)上探索这些软件包。
- en: Monitoring the Spring Boot 2 application using Micrometer and Prometheus
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Micrometer和Prometheus监控Spring Boot 2应用程序
- en: Monitoring and collecting performance metrics is an important part of application
    development and maintenance. One would be interested in metrics such as memory
    usage, response time of the various endpoints, CPU usage, load on the machine,
    garbage-collection frequency, and pauses. There are different ways to enable capturing
    metrics, such as using Dropwizard Metrics ([https://metrics.dropwizard.io/4.0.0/](https://metrics.dropwizard.io/4.0.0/)[)](https://metrics.dropwizard.io/4.0.0/)
    or Spring Boot's metrics framework.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 监控和收集性能指标是应用程序开发和维护的重要部分。人们对内存使用情况、各个端点的响应时间、CPU使用情况、机器负载、垃圾收集频率和暂停等指标感兴趣。有不同的方法来启用捕获指标，例如使用Dropwizard
    Metrics（[https://metrics.dropwizard.io/4.0.0/](https://metrics.dropwizard.io/4.0.0/)）或Spring
    Boot的度量框架。
- en: The instrumentation of code in Spring Boot 2 onward is done using a library
    called Micrometer ([https://micrometer.io/](https://micrometer.io/)). Micrometer
    provides a vendor-neutral code-instrumentation so that you can use any monitoring
    tool and have Micrometer provide the metrics data in the format understood by
    the tool. This is like SLF4J for logging. It is a facade over the metrics endpoints
    that produces output in a vendor-neutral way.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 2及更高版本中的代码仪器是使用一个名为Micrometer的库（[https://micrometer.io/](https://micrometer.io/)）来完成的。Micrometer提供了一个供应商中立的代码仪器，这样您就可以使用任何监控工具，并且Micrometer以工具理解的格式提供度量数据。这就像SLF4J用于日志记录一样。它是对以供应商中立方式产生输出的度量端点的外观。
- en: Micrometer supports tools such as Prometheus ([https://prometheus.io/](https://prometheus.io/)),
    Netflix Atlas ([https://github.com/Netflix/atlas](https://github.com/Netflix/atlas)),
    Datadog ([https://www.datadoghq.com/](https://www.datadoghq.com/)) and upcoming
    support for InfluxDB ([https://www.influxdata.com/](https://www.influxdata.com/)),
    statsd ([https://github.com/etsy/statsd](https://github.com/etsy/statsd)), and
    Graphite ([https://graphiteapp.org/](https://graphiteapp.org/)). Applications
    using earlier version of Spring Boot, such as 1.5, can also make use of this new
    instrumentation library, as shown in the *There's more...* section.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Micrometer支持诸如Prometheus ([https://prometheus.io/](https://prometheus.io/))、Netflix
    Atlas ([https://github.com/Netflix/atlas](https://github.com/Netflix/atlas))、Datadog
    ([https://www.datadoghq.com/](https://www.datadoghq.com/))以及即将支持的InfluxDB ([https://www.influxdata.com/](https://www.influxdata.com/))、statsd
    ([https://github.com/etsy/statsd](https://github.com/etsy/statsd))和Graphite ([https://graphiteapp.org/](https://graphiteapp.org/))等工具。使用早期版本的Spring
    Boot，如1.5，的应用程序也可以使用这个新的仪表化库，如*还有更多...*部分所示。
- en: In this recipe, we will use Micrometer to instrument our code and ship the metrics
    to Prometheus. So, first, we will start by setting up Prometheus in the *Getting
    ready* section.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用Micrometer来为我们的代码进行仪表化，并将指标发送到Prometheus。因此，首先，我们将从*准备工作*部分开始设置Prometheus。
- en: Getting ready
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Prometheus ([https://prometheus.io/](https://prometheus.io/)) is a monitoring
    system and time-series database that allows us to store time-series data, which
    includes the metrics of an application over time, a simple way to visualize the
    metrics, or setting up alerts on different metrics.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus ([https://prometheus.io/](https://prometheus.io/))是一个监控系统和时间序列数据库，允许我们存储时间序列数据，其中包括应用程序随时间变化的指标，一种简单的可视化指标的方法，或者在不同指标上设置警报。
- en: 'Let''s perform the following steps to get Prometheus running on our machines
    (in our case, we will be running on Windows. Similar steps will be applicable
    for Linux as well):'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤在我们的机器上运行Prometheus（在我们的情况下，我们将在Windows上运行。类似的步骤也适用于Linux）：
- en: Download the Prometheus distribution from [https://github.com/prometheus/prometheus/releases/download/v2.3.2/prometheus-2.3.2.windows-amd64.tar.gz](https://github.com/prometheus/prometheus/releases/download/v2.3.2/prometheus-2.3.2.windows-amd64.tar.gz).
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://github.com/prometheus/prometheus/releases/download/v2.3.2/prometheus-2.3.2.windows-amd64.tar.gz](https://github.com/prometheus/prometheus/releases/download/v2.3.2/prometheus-2.3.2.windows-amd64.tar.gz)下载Prometheus分发版。
- en: Extract it using 7-Zip ([https://www.7-zip.org/](https://www.7-zip.org/)) on
    Windows to a location that we will call `PROMETHEUS_HOME`.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows上使用7-Zip ([https://www.7-zip.org/](https://www.7-zip.org/))将其提取到一个我们将称为`PROMETHEUS_HOME`的位置。
- en: Add `%PROMETHEUS_HOME%` to your PATH variables (on Linux, it would be `$PROMETHEUS_HOME`
    to the PATH variable).
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`%PROMETHEUS_HOME%`添加到您的PATH变量（在Linux上，它将是`$PROMETHEUS_HOME`到PATH变量）。
- en: 'Run Prometheus using the `prometheus --config "%PROMETHEUS_HOME%/prometheus.yml"` command.
    You will see the following output:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`prometheus --config "%PROMETHEUS_HOME%/prometheus.yml"`命令运行Prometheus。您将看到以下输出：
- en: '![](img/804808bc-52af-40a7-be2c-1ea1286bcde8.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](img/804808bc-52af-40a7-be2c-1ea1286bcde8.png)'
- en: 'Open `http://localhost:9090` in your browser to see the Prometheus console.
    Enter `go_gc_duration_seconds` in the empty text box and click on the Execute
    button to show the metrics captured. You can switch the tab to a Graph version
    to visualize the data:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开`http://localhost:9090`，以查看Prometheus控制台。在空文本框中输入`go_gc_duration_seconds`，然后单击执行按钮以显示捕获的指标。您可以切换到图形版本的选项卡以可视化数据：
- en: '![](img/7a5e02c6-6401-4eb0-be61-01832f3f8fc4.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a5e02c6-6401-4eb0-be61-01832f3f8fc4.png)'
- en: 'The preceding metrics are for Prometheus itself. You can navigate to `http://localhost:9090/targets`
    to find out the targets monitored by  the Promethues shown as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的指标是用于Prometheus本身的。您可以导航到`http://localhost:9090/targets`以查找Promethues监视的目标，如下所示：
- en: '![](img/f07d688a-c972-46fc-9fbb-63bb1da19831.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f07d688a-c972-46fc-9fbb-63bb1da19831.png)'
- en: When you open the `http://localhost:9090/metrics` in your browser, you will
    see the metric value at the current time instant. It's difficult to understand
    without visualization. Such metrics are helpful when collected over time and visualized
    using graphs.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在浏览器中打开`http://localhost:9090/metrics`时，您将看到当前时间点的指标值。没有可视化很难理解。这些指标在随时间收集并使用图表可视化时非常有用。
- en: Now, we have Prometheus up and running. Let's enable the Micrometer and metrics
    publishing in the format understood by Prometheus. For this, we will be reusing
    the code used in the *Interacting with the database* recipe in this chapter. This
    recipe is available at `Chapter09/2_boot_db_demo`. So, we will just copy the same
    code into `Chapter09/7_boot_micrometer` and then enhance parts to add support
    for Micrometer and Prometheus, as seen in the next section.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经启动并运行了Prometheus。让我们启用Micrometer和以Prometheus理解的格式发布指标。为此，我们将重用本章中*与数据库交互*食谱中使用的代码。此食谱位于`Chapter09/2_boot_db_demo`。因此，我们将只需将相同的代码复制到`Chapter09/7_boot_micrometer`，然后增强部分以添加对Micrometer和Prometheus的支持，如下一节所示。
- en: How to do it...
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Update `pom.xml` to include the Spring boot actuator and Micrometer Prometheus
    registry dependencies:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`pom.xml`以包括Spring boot执行器和Micrometer Prometheus注册表依赖项：
- en: '[PRE64]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In Spring Boot 2 onwards, Micrometer comes configured with actuator, so we just
    need to add actuator as the dependency and then the `micrometer-registry-prometheus`
    dependency produces a metrics representation that is understood by Prometheus.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Boot 2及更高版本中，Micrometer已配置了执行器，因此我们只需要将执行器作为依赖项添加，然后`micrometer-registry-prometheus`依赖项会生成一个Prometheus理解的指标表示。
- en: 'When we run the application (one of the ways is to run `mvn spring-boot:run`) 
    and open the actuator endpoint, by default it will be `<root_url>/actuator`. We
    will find that there are few actuator endpoints available by default, but the
    Prometheus metrics endpoint is not part of it:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行应用程序（一种方式是运行`mvn spring-boot:run`）并打开执行器端点时，默认情况下将是`<root_url>/actuator`。我们会发现默认情况下有一些执行器端点可用，但Prometheus指标端点不是其中的一部分：
- en: '![](img/02e97a6b-0504-47fb-bbc7-93e9c63e2a59.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02e97a6b-0504-47fb-bbc7-93e9c63e2a59.png)'
- en: 'To enable the Prometheus endpoint in actuator, we need to add the following
    property in the `src/main/resources/application.properties` file:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在执行器中启用Prometheus端点，我们需要在`src/main/resources/application.properties`文件中添加以下属性：
- en: '[PRE65]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Restart the app and browse to `http://localhost:8080/actuator/`. Now, you will
    see that only the Prometheus endpoint is available:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动应用程序并浏览`http://localhost:8080/actuator/`。现在，您会发现只有Prometheus端点可用：
- en: '![](img/ddf35ffd-8415-47d6-bd39-15c400d80707.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ddf35ffd-8415-47d6-bd39-15c400d80707.png)'
- en: 'Open `http://localhost:8080/actuator/prometheus` to see the metrics in a format
    understood by Prometheus:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`http://localhost:8080/actuator/prometheus`以查看Prometheus理解的格式中的指标：
- en: '![](img/07b55bf4-6d26-4cd8-88d4-bbfda24bbb31.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07b55bf4-6d26-4cd8-88d4-bbfda24bbb31.png)'
- en: 'Configure Prometheus to call `http://localhost:8080/actuator/prometheus` at
    a specific frequency, which can be configured. This can be done by updating the
    `%PROMETHEUS_HOME%/prometheus.yml` configuration file with a new job under the `scrape_configs`
    property:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Prometheus以在特定频率下调用`http://localhost:8080/actuator/prometheus`，可以进行配置。这可以通过在`%PROMETHEUS_HOME%/prometheus.yml`配置文件中在`scrape_configs`属性下更新新作业来完成：
- en: '[PRE66]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You will see that, by default, there is a job to scrap the Prometheus metrics
    itself.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到，默认情况下，有一个作业来抓取Prometheus指标本身。
- en: 'Restart Prometheus server and visit `http://localhost:9090/targets`. You will
    see a new section, `spring_apps`, with the target we have added:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动Prometheus服务器并访问`http://localhost:9090/targets`。您将看到一个新的部分`spring_apps`，其中包含我们添加的目标：
- en: '![](img/83686243-24fd-45a4-a616-2473f8fc4249.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83686243-24fd-45a4-a616-2473f8fc4249.png)'
- en: 'We can plot a metric from the metrics captured by visiting `http://localhost:9090/graph`,
    typing `jvm_memory_max_bytes` in the text box, and clicking on Execute to get
    a graph:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过访问`http://localhost:9090/graph`，在文本框中输入`jvm_memory_max_bytes`，然后单击执行来绘制从指标捕获的指标的图表：
- en: '![](img/92e2a62a-ac7d-4d2c-a45f-717c9058a108.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92e2a62a-ac7d-4d2c-a45f-717c9058a108.png)'
- en: So, we have finally set up the ingestion of metrics in Prometheus and creating
    charts on Prometheus out of the metric values.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们最终设置了在Prometheus中摄取指标并根据指标值创建图表。
- en: How it works...
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Spring Boot provides a library called actuator with features to help you monitor
    and manage the application when deployed to production. This out-of-the-box functionality
    doesn't require any setup from the developers' side. So you get auditing, health
    checks, and metrics-gathering all without any work.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot提供了一个名为执行器的库，具有在部署到生产环境时帮助您监视和管理应用程序的功能。这种开箱即用的功能不需要开发人员进行任何设置。因此，您可以在没有任何工作的情况下进行审计、健康检查和指标收集。
- en: 'As mentioned before, actuator uses Micrometer to instrument and capture different
    metrics from the code, such as:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，执行器使用Micrometer从代码中进行仪表化和捕获不同的指标，例如：
- en: JVM memory usage
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM内存使用情况
- en: Connection-pooling information
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接池信息
- en: Response time of different HTTP endpoints in the app
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中不同HTTP端点的响应时间
- en: Frequency of invocation of different HTTP endpoints
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同HTTP端点调用的频率
- en: 'To enable your application to have these production-ready features, you need
    to add the following dependency to your `pom.xml` if you are using Maven (there
    is an equivalent for Gradle):'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 要使应用程序具有这些生产就绪的功能，如果您使用Maven，需要将以下依赖项添加到您的`pom.xml`中（Gradle也有相应的依赖项）：
- en: '[PRE67]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'By default, actuator is available at the `/actuator` endpoint, but this can
    be configured by overriding the `management.endpoints.web.base-path` property
    in the `src/main/resources/application.properties` file with a different value,
    as shown here:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，执行器位于`/actuator`端点，但可以通过在`src/main/resources/application.properties`文件中覆盖`management.endpoints.web.base-path`属性来配置不同的值，如下所示：
- en: '[PRE68]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'All the endpoints available for monitoring and auditing the application are
    enabled by default except for the `/shutdown` endpoint, which is disabled by default.
    This endpoint is used to shut down the application. Here are some of the endpoints
    that are available:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，除了`/shutdown`端点之外，所有用于监视和审计应用程序的端点都是默认启用的。默认情况下禁用此端点。此端点用于关闭应用程序。以下是一些可用的端点：
- en: '| `auditevents` | Exposes audit events information for the current application
    |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `auditevents` | 公开当前应用程序的审计事件信息 |'
- en: '| `beans` | Displays a complete list of all the Spring beans in your application
    |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| `beans` | 显示应用程序中所有Spring bean的完整列表 |'
- en: '| `env` | Exposes properties from Spring’s `ConfigurableEnvironment` |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| `env` | 公开Spring的`ConfigurableEnvironment`中的属性 |'
- en: '| `health` | Shows application health information |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| `health` | 显示应用程序健康信息 |'
- en: '| `info` | Displays arbitrary application info |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| `info` | 显示任意应用程序信息 |'
- en: '| `metrics` | Shows metrics information for the current application |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| `metrics` | 显示当前应用程序的指标信息 |'
- en: '| `mappings` | Displays a collated list of all `@RequestMapping` paths |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| `mappings` | 显示所有`@RequestMapping`路径的汇总列表 |'
- en: '| `prometheus` | Exposes metrics in a format that can be scraped by a Prometheus
    server |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| `prometheus` | 以Prometheus服务器可以抓取的格式公开指标 |'
- en: You can see that these are very sensitive endpoints that need to be secured.
    The good thing is that Spring Boot actuator integrates well with Spring Security
    to secure these endpoints. So if Spring Security is on the classpath, it secures
    these endpoints by default.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现这些是非常敏感的端点，需要进行安全保护。好消息是，Spring Boot执行器与Spring Security很好地集成，以保护这些端点。因此，如果Spring
    Security在类路径上，它将默认安全地保护这些端点。
- en: 'These endpoints can be accessed by JMX or via the web. Not all of the actuator
    endpoints are enabled for access by the web by default instead they are enabled
    by default for access using JMX. Only the following properties are enabled for
    access by default from the web:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这些端点可以通过JMX或通过Web访问。默认情况下，并非所有执行器端点都启用了Web访问，而是默认情况下启用了使用JMX访问。默认情况下，只有以下属性可以通过Web访问：
- en: '`health`'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`health`'
- en: '`info`'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info`'
- en: 'And this is the reason we had to add the following configuration property to
    make the Prometheus endpoint, along with health, information, and metrics, available
    on the web:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们不得不添加以下配置属性的原因，以便在Web上提供Prometheus端点，以及健康、信息和指标：
- en: '[PRE69]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Even if we enable Prometheus, we need to have the `micrometer-registry-prometheus`
    library on our classpath. Only then will we be able to view the metrics in the
    Prometheus format. So, we added the following dependency to our pom:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们启用了Prometheus，我们也需要在类路径上有`micrometer-registry-prometheus`库。只有这样，我们才能以Prometheus的格式查看指标。因此，我们将以下依赖项添加到我们的pom中：
- en: '[PRE70]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The output format processed by Prometheus is simple: it takes in `<property_name
    value>` with each property in a new line. Spring Boot actuator doesn''t push the
    metrics to Prometheus; instead, we configure Prometheus to pull the metrics from
    a given URL at a frequency defined in its configuration. The default configuration
    of Prometheus, which is available in its home directory, is as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus处理的输出格式很简单：它以`<property_name value>`的形式接收，每个属性都在新的一行中。Spring Boot执行器不会将指标推送到Prometheus；相反，我们配置Prometheus以在其配置中定义的频率从给定URL拉取指标。Prometheus的默认配置，可在其主目录中找到，如下所示：
- en: '[PRE71]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'So it is configured with default values for intervals at which Prometheus will
    fetch the metrics and for intervals at which it will evaluate the rules defined
    under `rule_files`. Scrape is the activity of pulling the metrics from different
    targets defined under the `scrape_configs` option, and evaluate is the act of
    evaluating different rules defined in `rule_files`. To enable Prometheus to scrap
    the metrics from our Spring Boot app, we add a new job under `scrape_configs`
    by providing the job name, the path of the metrics relative to the application
    URL, and the URL of the application:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它配置了Prometheus将获取指标的间隔和评估`rule_files`下定义的规则的间隔的默认值。Scrape是从`scrape_configs`选项下定义的不同目标中拉取指标的活动，而evaluate是评估`rule_files`中定义的不同规则的行为。为了使Prometheus能够从我们的Spring
    Boot应用程序中抓取指标，我们通过提供作业名称、相对于应用程序URL的指标路径和应用程序的URL，在`scrape_configs`下添加了一个新的作业：
- en: '[PRE72]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We also saw how we can view the values of these metrics from `http://localhost:9090/graph`
    and how these can be visualized using the simple graph support provided by Prometheus.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何从`http://localhost:9090/graph`查看这些指标的值，以及如何使用Prometheus提供的简单图形支持来可视化这些指标。
- en: There's more
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: Alerting can be enabled in Prometheus by configuring another service, called
    Alertmanager ([https://prometheus.io/docs/alerting/alertmanager/](https://prometheus.io/docs/alerting/alertmanager/)).
    This service can be used to send alerts to emails, pagers, and so on.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置另一个名为Alertmanager的服务（[https://prometheus.io/docs/alerting/alertmanager/](https://prometheus.io/docs/alerting/alertmanager/)），可以在Prometheus中启用警报。该服务可用于向电子邮件、寻呼机等发送警报。
- en: The graphing support in Prometheus is naive. You can use Grafana ([https://grafana.com/](https://grafana.com/)),
    which is one of the leading open source software in analyzing time-series data,
    such as the one stored in Prometheus. This way you can configure Grafana to read
    the time-series data from Prometheus and build dashboards with predefined metrics
    plotted on different types of charts.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus中的图形支持是天真的。您可以使用Grafana（[https://grafana.com/](https://grafana.com/)），这是一种领先的开源软件，用于分析时间序列数据，例如存储在Prometheus中的数据。通过这种方式，您可以配置Grafana从Prometheus读取时间序列数据，并构建具有预定义指标的不同类型图表的仪表板。
