- en: Database Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库编程
- en: This chapter explains how to write Java code that can manipulate—insert, read,
    update, delete—data in a database. It also provides a short introduction to the
    SQL language and basic database operations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍如何编写Java代码，可以操作数据库中的数据——插入、读取、更新、删除。它还提供了SQL语言和基本数据库操作的简要介绍。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is **Java Database Connectivity** (**JDBC**)?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是**Java数据库连接**（**JDBC**）？
- en: How to create/delete a database
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建/删除数据库
- en: Short overview of **Structured Query Language** (**SQL**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构化查询语言**（**SQL**）简要概述'
- en: How to create/delete/modify a database table
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建/删除/修改数据库表
- en: '**Create, read, update, and delete** (**CRUD**) database data'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建、读取、更新和删除**（**CRUD**）数据库数据'
- en: Exercise – Selecting unique first names
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习-选择唯一的名字
- en: What is Java Database Connectivity (JDBC)?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Java数据库连接（JDBC）？
- en: '**Java Database Connectivity** (**JDBC**) is Java functionality that allows
    us to access and modify data in a database. It is supported by the JDBC API (the `java.sql`, `javax.sql`,
    and `java.transaction.xa` packages) and the database-specific implementation of
    an interface for the database access (called a database driver) provided by each
    database vendor.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java数据库连接**（**JDBC**）是Java功能，允许我们访问和修改数据库中的数据。它由JDBC API（`java.sql`、`javax.sql`和`java.transaction.xa`包）和数据库特定的接口实现（称为数据库驱动程序）支持，每个数据库供应商都提供了与数据库访问的接口。'
- en: When people say they are using JDBC, it means they write code that manages data
    in a database using the interfaces and classes of the JDBC API and a database-specific
    driver that knows how to connect the application with the particular database.
    Using this connection, an application can then issue requests written in **Structured
    Query Language** (**SQL**). Naturally, we are talking here only about the databases
    that understand SQL. They are called relational (or tabular) and compose the vast
    majority of the currently used databases, although some alternatives—a navigational
    database and NoSql, for example—are used too.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们说他们正在使用JDBC时，这意味着他们编写代码，使用JDBC API的接口和类以及知道如何将应用程序与特定数据库连接的数据库特定驱动程序来管理数据库中的数据。使用此连接，应用程序可以发出用**结构化查询语言**（**SQL**）编写的请求。当然，我们这里只谈论了理解SQL的数据库。它们被称为关系（或表格）数据库，并且占当前使用的数据库的绝大多数，尽管也使用一些替代方案——如导航数据库和NoSql。
- en: The `java.sql` and `javax.sql` packages are included in the Java Platform Standard
    Edition (Java SE). Historically, the `java.sql` package belonged to Java core,
    while the `javax.sql` package was considered a core extension. But later, the `javax.sql` package
    was included in the core too and the name was not changed to avoid breaking the
    existing application that used it. The `javax.sql` package contains the `DataSource`
    interface that supports the statement's pooling, distributed transactions, and
    rowsets. We will discuss each of these features in greater details in the following
    sections of this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.sql`和`javax.sql`包包含在Java平台标准版（Java SE）中。从历史上看，`java.sql`包属于Java核心，而`javax.sql`包被认为是核心扩展。但后来，`javax.sql`包也被包含在核心中，名称没有更改，以避免破坏使用它的现有应用程序。`javax.sql`包包含支持语句池、分布式事务和行集的`DataSource`接口。我们将在本章的后续部分更详细地讨论这些功能。'
- en: 'Working with a database includes eight steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库一起工作包括八个步骤：
- en: Install the database by following the vendor instructions.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照供应商的说明安装数据库。
- en: Create a database user, a database, and the database schema – tables, views,
    stored procedures, and so on.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数据库用户、数据库和数据库模式——表、视图、存储过程等。
- en: Add the dependency to the application on a `.jar` with the database-specific
    driver.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序上添加对`.jar`的依赖项，其中包含特定于数据库的驱动程序。
- en: Connect to the database from the application.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从应用程序连接到数据库。
- en: Construct a SQL statement.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造SQL语句。
- en: Execute a SQL statement.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行SQL语句。
- en: Use the result of the execution.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用执行结果。
- en: Release (close) the database connection and other resources opened in the process.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放（关闭）在过程中打开的数据库连接和其他资源。
- en: Steps 1-3 are done only once, at the database setup before the application is
    run. Steps 4-8 are performed by the application repeatedly as needed. Steps 5-7
    can be repeated multiple times with the same database connection.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤1-3只在应用程序运行之前的数据库设置时执行一次。步骤4-8根据需要由应用程序重复执行。步骤5-7可以重复多次使用相同的数据库连接。
- en: Connecting to the database
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'Here is the code fragment to connect to the database:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是连接到数据库的代码片段：
- en: '```java'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String URL = "jdbc:postgresql://localhost/javaintro";
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: String URL = "jdbc:postgresql://localhost/javaintro";
- en: Properties prop = new Properties( );
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 属性prop = new Properties（）;
- en: //prop.put( "user", "java" );
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: //prop.put（"user"，“java”）;
- en: //prop.put( "password", "secretPass123" );
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: //prop.put（"password"，“secretPass123”）;
- en: try {
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试{
- en: Connection conn = DriverManager.getConnection(URL, prop);
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Connection conn = DriverManager.getConnection（URL，prop）;
- en: '} catch(SQLException ex){'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch（SQLException ex）{'
- en: ex.printStackTrace();
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace（）;
- en: '}'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The commented lines show how you can set a user and password for your connection
    using the `java.util.Properties` class. The preceding is just an example of how to
    get a connection using the `DriverManger` class directly. Many keys for the passed-in
    properties are the same for all major databases, but some of them are database-specific.
    So, read your database vendor documentation for such details.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注释行显示了如何使用`java.util.Properties`类为连接设置用户和密码。上述只是一个示例，说明如何直接使用`DriverManger`类获取连接。传入属性的许多键对于所有主要数据库都是相同的，但其中一些是特定于数据库的。因此，请阅读您的数据库供应商文档以获取此类详细信息。
- en: Alternatively, for passing user and password only, we could use an overloaded
    version, `DriverManager.getConnection(String url, String user, String password)`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，仅传递用户和密码，我们可以使用重载版本`DriverManager.getConnection（String url，String user，String
    password）`。
- en: It is a good practice to keep the password encrypted. We are not going to show
    you how to do it, but there are plenty of guides available on the internet.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 保持密码加密是一个好的做法。我们不会告诉你如何做，但是互联网上有很多指南可用。
- en: 'Another way of connecting to a database is to use the `DataSource` interface.
    Its implementation is included in the same `.jar` with the database driver. In
    the case of PostgreSQL, there are two classes that implemented the `DataSource`
    interface: `org.postgresql.ds.PGSimpleDataSource` and `org.postgresql.ds.PGConnectionPoolDataSource`.
    We can use them instead of `DriverManager`. The following is an example of creating
    a database connection using the `org.postgresql.ds.PGSimpleDataSource` class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种连接到数据库的方法是使用`DataSource`接口。它的实现包含在与数据库驱动程序相同的`.jar`中。在PostgreSQL的情况下，有两个实现了`DataSource`接口的类：`org.postgresql.ds.PGSimpleDataSource`和`org.postgresql.ds.PGConnectionPoolDataSource`。我们可以使用它们来代替`DriverManager`。以下是使用`org.postgresql.ds.PGSimpleDataSource`类创建数据库连接的示例：
- en: '```java'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: PGSimpleDataSource source = new PGSimpleDataSource();
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: PGSimpleDataSource source = new PGSimpleDataSource();
- en: source.setServerName("localhost");
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: source.setServerName("localhost");
- en: source.setDatabaseName("javaintro");
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: source.setDatabaseName("javaintro");
- en: source.setLoginTimeout(10);
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: source.setLoginTimeout(10);
- en: Connection conn = source.getConnection();
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Connection conn = source.getConnection();
- en: '```'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'To connect to the database using the `org.postgresql.ds.PGConnectionPoolDataSource` class,
    we only need to replace the first line in the preceding code with the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`org.postgresql.ds.PGConnectionPoolDataSource`类连接到数据库，我们只需要用以下内容替换前面代码中的第一行：
- en: '```java'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: PGConnectionPoolDataSource source = new PGConnectionPoolDataSource();
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: PGConnectionPoolDataSource source = new PGConnectionPoolDataSource();
- en: '```'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Using the `PGConnectionPoolDataSource` class allows us to create a pool of `Connection`
    objects in-memory. It is a preferred way because creating a `Connection` object
    takes time. The pooling allows us to do it up-front and then reuse the already
    created objects as needed. The pool size and other parameters can be set in the `postgresql.conf` file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PGConnectionPoolDataSource`类允许我们在内存中创建一个`Connection`对象池。这是一种首选的方式，因为创建`Connection`对象需要时间。池化允许我们提前完成这个过程，然后根据需要重复使用已经创建的对象。池的大小和其他参数可以在`postgresql.conf`文件中设置。
- en: But whatever method of creating a database connection is used, we are going
    to hide it inside the `getConnection()` method and use it in all our code examples
    in the same way.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但无论使用何种方法创建数据库连接，我们都将把它隐藏在`getConnection()`方法中，并在所有的代码示例中以相同的方式使用它。
- en: With the object of the `Connection` class acquired, we can now access the database
    to add, read, delete, or modify the stored data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`Connection`类的对象，我们现在可以访问数据库来添加、读取、删除或修改存储的数据。
- en: Closing the database connection
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭数据库连接
- en: Keeping a database connection alive requires a significant amount of resources
    memory and CPU—so it is a good idea to close the connection and release the allocated
    resources as soon as you do not need them anymore. In the case of the pooling,
    the `Connection` object, when closed, is returned to the pool and consumes fewer
    resources.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 保持数据库连接活动需要大量的资源内存和CPU-因此关闭连接并释放分配的资源是一个好主意，一旦你不再需要它们。在池化的情况下，`Connection`对象在关闭时会返回到池中，消耗更少的资源。
- en: 'Before Java 7, the way to close a connection was by invoking the `close()` method
    in a `finally`-block with or without a catch-block:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7之前，关闭连接的方法是通过在`finally`块中调用`close()`方法，无论是否有catch块：
- en: '```java'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Connection conn = getConnection();
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Connection conn = getConnection();
- en: try {
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试 {
- en: //use object conn here
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: //在这里使用conn对象
- en: '} finally {'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '} 最后 {'
- en: if(conn != null){
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: if(conn != null){
- en: conn.close();
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: conn.close();
- en: '}'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The code inside the `finally`-block is always executed, whether the exception
    inside the try-block was thrown or not. But since Java 7, the `try...with...resources` construct
    does the job just fine on any object that implements the `java.lang.AutoCloseable` or `java.io.Closeable` interfaces. Since
    the `java.sql.Connection` object implements `AutoCloseable`, we can rewrite the
    previous code snippet as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`块中的代码总是会被执行，无论try块中的异常是否被抛出。但自Java 7以来，`try...with...resources`结构可以很好地处理实现了`java.lang.AutoCloseable`或`java.io.Closeable`接口的任何对象。由于`java.sql.Connection`对象实现了`AutoCloseable`，我们可以将上一个代码片段重写如下：'
- en: '```java'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: try (Connection conn = getConnection()) {
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试 (Connection conn = getConnection()) {
- en: //use object conn here
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: //在这里使用conn对象
- en: '}'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: catch(SQLException ex) {
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获(SQLException ex) {
- en: ex.printStackTrace();
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace();
- en: '}'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The catch-clause is necessary because the auto-closeable resource throws `java.sql.SQLException`.
    One can argue that it does not save much in the way of typing. But the `close()` method of
    the `Connection` class can throw `SQLException` too, so the code with `finally`-block
    should be written more defensively:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获子句是必要的，因为可自动关闭的资源会抛出`java.sql.SQLException`。有人可能会说，这样做并没有节省多少输入。但是`Connection`类的`close()`方法也可能会抛出`SQLException`，所以带有`finally`块的代码应该更加谨慎地编写：
- en: '```java'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Connection conn = getConnection();
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Connection conn = getConnection();
- en: try {
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试 {
- en: //use object conn here
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: //在这里使用conn对象
- en: '} finally {'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '} 最后 {'
- en: if(conn != null){
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: if(conn != null){
- en: try {
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试 {
- en: conn.close();
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: conn.close();
- en: '} catch(SQLException ex){'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '} 捕获(SQLException ex){'
- en: //do here what has to be done
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: //在这里做必须要做的事情
- en: '}'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The preceding block already looks definitely like a more boilerplate code.
    Yet, even more, if we take into account that usually inside the `try`-block, some
    other code can throw `SQLException` too, then the preceding code should look as
    follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块看起来确实像是更多的样板代码。更重要的是，如果考虑到通常在`try`块内，一些其他代码也可能抛出`SQLException`，那么前面的代码应该如下所示：
- en: '```java'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Connection conn = getConnection();
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Connection conn = getConnection();
- en: try {
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试 {
- en: //use object conn here
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: //在这里使用conn对象
- en: '} catch(SQLException ex) {'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '} 捕获(SQLException ex) {'
- en: ex.printStackTrace();
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace();
- en: '} finally {'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '} 最后 {'
- en: if(conn != null){
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: if(conn != null){
- en: try {
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试 {
- en: conn.close();
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: conn.close();
- en: '} catch(SQLException ex){'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '} 捕获(SQLException ex){'
- en: //do here what has to be done
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: //在这里做必须要做的事情
- en: '}'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The boilerplate code grows, doesn''t it? And that is not the end of the story.
    In the next sections, you will learn that to send a database request, you also
    need to create a `java.sql.Statement`, which throws `SQLException` and has to
    be closed too. Then the preceding code grows even more:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 样板代码增加了，不是吗？这还不是故事的结束。在接下来的章节中，您将了解到，要发送数据库请求，还需要创建一个`java.sql.Statement`，它会抛出`SQLException`，也必须关闭。然后前面的代码会变得更多：
- en: '```java'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Connection conn = getConnection();
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Connection conn = getConnection（）;
- en: try {
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试{
- en: Statement statement = conn.createStatement();
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Statement statement = conn.createStatement（）;
- en: try{
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试{
- en: //use statement here
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: //在这里使用语句
- en: '} catch(SQLException ex){'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch(SQLException ex){'
- en: //some code here
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: //这里有一些代码
- en: '} finally {'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '} finally {'
- en: if(statement != null){
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: if(statement != null){
- en: try {
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试{
- en: '} catch (SQLException ex){'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (SQLException ex){'
- en: //some code here
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: //这里有一些代码
- en: '}'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '} catch(SQLException ex) {'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch(SQLException ex) {'
- en: ex.printStackTrace();
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace（）;
- en: '} finally {'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '} finally {'
- en: if(conn != null){
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: if(conn != null){
- en: try {
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试{
- en: conn.close();
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: conn.close（）;
- en: '} catch(SQLException ex){'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch(SQLException ex){'
- en: //do here what has to be done
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: //在这里做必须做的事情
- en: '}'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Now we can appreciate the `try...with...resources` construct in its full glory,
    especially if we take into account that it allows us to include multiple auto-closeable
    resources in the same clause:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以充分欣赏`try...with...resources`结构的优势，特别是考虑到它允许我们在同一个子句中包含多个可自动关闭的资源：
- en: '```java'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: try (Connection conn = getConnection();
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试（Connection conn = getConnection（）;
- en: Statement statement = conn.createStatement()) {
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Statement statement = conn.createStatement（）{
- en: //use statement here
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: //在这里使用语句
- en: '} catch(SQLException ex) {'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch(SQLException ex) {'
- en: ex.printStackTrace();
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace（）;
- en: '}'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And since Java 9, we can make it even simpler:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java 9以来，我们甚至可以使其更简单：
- en: '```java'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Connection conn = getConnection();
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Connection conn = getConnection（）;
- en: try (conn; Statement statement = conn.createStatement()) {
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试（conn; Statement statement = conn.createStatement（））{
- en: //use statement here
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: //在这里使用语句
- en: '} catch(SQLException ex) {'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch(SQLException ex) {'
- en: ex.printStackTrace();
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace（）;
- en: '}'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Now it is clear that the `try...with...resources` construct is a hands-down
    winner.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很明显，`try...with...resources`结构是一个无可争议的赢家。
- en: Structured Query Language (SQL)
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化查询语言（SQL）
- en: SQL is a rich language, and we do not have enough space to cover all its features.
    We just would like to enumerate a few of the most popular ones, so you become
    aware of their existence and can look them up as needed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: SQL是一种丰富的语言，我们没有足够的空间来涵盖其所有特性。我们只想列举一些最受欢迎的特性，以便您了解它们的存在，并在需要时查找它们。
- en: Similar to a Java statement, there is a SQL statement that expresses a database
    request like a complete sentence in the English language. Every statement can
    be executed either in a database console or by Java code using the JDBC connection.
    Programmers often test a SQL statement in a console before using it in the Java
    code because the turnaround in a console is much faster. One does not need to
    compile and execute a program while using a console.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java语句类似，SQL语句表达了像英语句子一样的数据库请求。每个语句都可以在数据库控制台中执行，也可以通过使用JDBC连接在Java代码中执行。程序员通常在控制台中测试SQL语句，然后再在Java代码中使用它，因为在控制台中的反馈速度要快得多。在使用控制台时，无需编译和执行程序。
- en: There are SQL statements that create and delete a user and database. We will
    see the examples of such statements in the next section. There are also other
    statements related to a database as a whole, that are outside the scope of this
    book.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有SQL语句可以创建和删除用户和数据库。我们将在下一节中看到此类语句的示例。还有其他与整个数据库相关的语句，超出了本书的范围。
- en: 'After a database is created, the following three SQL statements allow us to
    build and change the database structure – a table, function, constraint, or another
    database entity:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数据库后，以下三个SQL语句允许我们构建和更改数据库结构 - 表、函数、约束或其他数据库实体：
- en: '`CREATE`: This statement creates a database entity'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE`：此语句创建数据库实体'
- en: '`ALTER`: This statement changes a database entity'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ALTER`：此语句更改数据库实体'
- en: '`DROP`: This statement deletes a database entity'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DROP`：此语句删除数据库实体'
- en: There are also various SQL statements that allow us to enquire about each database
    entity, which are outside the scope of this book too.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 还有各种SQL语句，允许我们查询每个数据库实体的信息，这也超出了本书的范围。
- en: 'And there are four kinds of SQL statements that manipulate the data in the
    database:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 并且有四种SQL语句可以操作数据库中的数据：
- en: '`INSERT`: This statement adds data to the database'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSERT`：此语句向数据库添加数据'
- en: '`SELECT`: This statement reads data from the database'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT`：此语句从数据库中读取数据'
- en: '`UPDATE`: This statement changes data in the database'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPDATE`：此语句更改数据库中的数据'
- en: '`DELETE`: This statement deletes data from the database'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：此语句从数据库中删除数据'
- en: One or several various clauses can be added to the preceding statements that
    identify the data requested (`WHERE`-clause), the order in which the results have
    to be returned (`ORDER`-clause), and similar.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 可以向前述语句添加一个或多个不同的子句，用于标识请求的数据（`WHERE`-子句）、结果返回的顺序（`ORDER`-子句）等。
- en: 'The JDBC connection allows to wrap one or a combination of the preceding SQL
    statements in one of the three classes that provide a different functionality
    on the database side:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC连接允许将前述SQL语句中的一个或多个组合包装在提供数据库端不同功能的三个类中：
- en: '`java.sql.Statement`: Just sends the statement to the database server for an
    execution'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.sql.Statement`：只是将语句发送到数据库服务器以执行'
- en: '`java.sql.PreparedStatement`: Caches the statement within a certain execution
    path on the database server, allowing it to be executed multiple times with different
    parameters in an efficient manner'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.sql.PreparedStatement`：在数据库服务器上的某个执行路径中缓存语句，允许以高效的方式多次执行具有不同参数的语句'
- en: '`java.sql.CallableStatement`: Executes a stored procedure in the database'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.sql.CallableStatement`：在数据库中执行存储过程'
- en: We will start our demonstration with the statements that create and delete a
    database and its user.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建和删除数据库及其用户的语句开始我们的演示。
- en: Creating a database and its structure
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库及其结构
- en: Look up how to download and install your preferred database server. A database
    server is a software system that maintains and manages the database. For our demonstrations,
    we are going to use PostgreSQL, a free, open source database server.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 查找如何下载和安装您喜欢的数据库服务器。数据库服务器是一个维护和管理数据库的软件系统。对于我们的演示，我们将使用PostgreSQL，一个免费的开源数据库服务器。
- en: After the database server is installed, we'll use its console for creating a
    database and its user with the corresponding permissions. There are many ways
    to structure the data store and the system of users with different levels of access.
    In this book, we will introduce only the basic approach, which allows us to demonstrate
    the main JDBC capabilities.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 安装数据库服务器后，我们将使用其控制台来创建数据库及其用户，并赋予相应的权限。有许多方法可以构建数据存储和具有不同访问级别的用户系统。在本书中，我们只介绍基本方法，这使我们能够演示主要的JDBC功能。
- en: CREATE and DROP the database and its user
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和删除数据库及其用户
- en: 'Read the database instructions and create, first, a `java` user and a `javaintro` database
    (or select any other name you prefer and use them instead in the provided code
    examples). Here is how we did it for PostgreSQL:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读数据库说明，并首先创建一个`java`用户和一个`javaintro`数据库（或选择任何其他您喜欢的名称，并在提供的代码示例中使用它们）。以下是我们在PostgreSQL中的操作方式：
- en: '```java'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: CREATE USER java SUPERUSER;
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: CREATE USER java SUPERUSER;
- en: CREATE DATABASE javaintro OWNER java;
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: CREATE DATABASE javaintro OWNER java;
- en: '```'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If you made a mistake and decide to start anew, you can delete the created
    user and database using the following statements:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您犯了一个错误并决定重新开始，您可以使用以下语句删除创建的用户和数据库：
- en: '```java'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: DROP USER java;
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: DROP USER java;
- en: DROP DATABASE javaintro;
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: DROP DATABASE javaintro;
- en: '```'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We selected the `SUPERUSER` role for our user, but a good security practice
    recommends assigning such a powerful role to an administrator only. For an application,
    it is recommended to create a user who cannot create or change the database itself—its
    tables and constraints—but can only manage data. Also, it is a good practice to
    create another logical layer, called **schema**, that can have its own set of
    users and permissions. This way, several schemas in the same database could be
    isolated and each user (one of them is your application) can access only certain
    schemas. On an enterprise level, the common practice is to create synonyms for
    the database schema so that no application can access the original structure directly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的用户选择了`SUPERUSER`角色，但是良好的安全实践建议只将这样一个强大的角色分配给管理员。对于应用程序，建议创建一个用户，该用户不能创建或更改数据库本身——其表和约束——但只能管理数据。此外，创建另一个逻辑层，称为**模式**，该模式可以具有自己的一组用户和权限，也是一个良好的实践。这样，同一数据库中的几个模式可以被隔离，每个用户（其中一个是您的应用程序）只能访问特定的模式。在企业级别上，通常的做法是为数据库模式创建同义词，以便没有应用程序可以直接访问原始结构。
- en: But, as we have mentioned already, for the purpose of this book, it is not needed,
    so we leave it to the database administrators who establish rules and guidelines
    suitable for the particular working conditions of each enterprise.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如我们已经提到的，对于本书的目的，这是不需要的，所以我们把它留给数据库管理员，他们为每个企业的特定工作条件建立规则和指导方针。
- en: Now we can connect our application to the database.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将我们的应用程序连接到数据库。
- en: CREATE, ALTER, and DROP table
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建、修改和删除表
- en: 'The standard SQL statement for the table creation looks like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 表的标准SQL语句如下：
- en: '```java'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: CREATE TABLE tablename (
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: CREATE TABLE tablename (
- en: column1 type1,
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: column1 type1，
- en: column2 type2,
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: column2 type2，
- en: column3 type3,
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: column3 type3，
- en: '....'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '....'
- en: );
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The limitations for a table name, column names, and types of values that can
    be used depend on the particular database.  Here is an example of a command that
    creates table person in PostgreSQL:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 表名、列名和可以使用的值类型的限制取决于特定的数据库。以下是在PostgreSQL中创建表person的命令示例：
- en: '```java'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: CREATE TABLE person (
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 创建表person (
- en: id SERIAL PRIMARY KEY,
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: id SERIAL PRIMARY KEY,
- en: first_name VARCHAR NOT NULL,
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: first_name VARCHAR NOT NULL，
- en: last_name VARCHAR NOT NULL,
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: last_name VARCHAR NOT NULL，
- en: dob DATE NOT NULL
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: dob DATE NOT NULL
- en: );
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see, we have made the `dob` (date of birth) column not nullable.
    That imposes a constraint on our `Person` Java class that is going to represent
    the records of this table: its `dob` field cannot be `null`. And that was what
    we have done, you may recall, in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Objects Construction*, when we created our `Person` class, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们已经将`dob`（出生日期）列设置为不可为空。这对我们的`Person` Java类施加了约束，该类将表示此表的记录：其`dob`字段不能为`null`。这正是我们在[第6章](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml)中所做的，当时我们创建了我们的`Person`类，如下所示：
- en: '```java'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class Person {
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: class Person {
- en: private String firstName, lastName;
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: private String firstName, lastName;
- en: private LocalDate dob;
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: private LocalDate dob;
- en: public Person(String firstName, String lastName, LocalDate dob) {
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: public Person(String firstName, String lastName, LocalDate dob) {
- en: 'this.firstName = firstName == null ? "" : firstName;'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'this.firstName = firstName == null ? "" : firstName;'
- en: 'this.lastName = lastName == null ? "" : lastName;'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 'this.lastName = lastName == null ? "" : lastName;'
- en: if(dob == null){
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: if(dob == null){
- en: throw new RuntimeException("Date of birth is null");
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: throw new RuntimeException("Date of birth is null");
- en: '}'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: this.dob = dob;
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: this.dob = dob;
- en: '}'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String getFirstName() { return firstName; }
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: public String getFirstName() { return firstName; }
- en: public String getLastName() { return lastName; }
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: public String getLastName() { return lastName; }
- en: public LocalDate getDob() { return dob; }
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: public LocalDate getDob() { return dob; }
- en: '}'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We did not set the size of the columns of the `VARCHAR` type, thus allowing
    those columns to store values of any length, while the integer type allows them
    to store numbers from 4,713 BC to 5,874,897 AD. `NOT NULL` was added because by
    default the column would be nullable, while we would like to make sure that all
    the columns are populated for each record. And our `Person` class supports it
    by setting first and last names to empty `String` values if they are `null`, as
    the parameters of the `Person` constructor.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有设置`VARCHAR`类型的列的大小，因此允许这些列存储任意长度的值，而整数类型允许它们存储从公元前4713年到公元5874897年的数字。添加了`NOT
    NULL`，因为默认情况下列将是可空的，而我们希望确保每条记录的所有列都被填充。我们的`Person`类通过将名字和姓氏设置为空的`String`值来支持它，如果它们是`null`，作为`Person`构造函数的参数。
- en: 'We also identified the `id` column as `PRIMARY KEY`, which indicates that this
    column uniquely identifies the record. The `SERIAL` keyword means that we ask
    the database to generate the next integer value every time a new record is added,
    so each record will have a unique integer number. Alternatively, we could make `PRIMARY
    KEY` from the combination of `first_name`, `last_name`, and `dob`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`id`列标识为`PRIMARY KEY`，这表示该列唯一标识记录。`SERIAL`关键字表示我们要求数据库在添加新记录时生成下一个整数值，因此每条记录将有一个唯一的整数编号。或者，我们可以从`first_name`、`last_name`和`dob`的组合中创建`PRIMARY
    KEY`：
- en: '```java'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: CREATE TABLE person (
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: CREATE TABLE person (
- en: first_name VARCHAR NOT NULL,
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: first_name VARCHAR NOT NULL,
- en: last_name VARCHAR NOT NULL,
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: last_name VARCHAR NOT NULL,
- en: dob DATE NOT NULL,
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: dob DATE NOT NULL,
- en: PRIMARY KEY (first_name, last_name, dob)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: PRIMARY KEY (first_name, last_name, dob)
- en: );
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'But there is a chance that there are two people who have the same name and
    who were born on the same day, so we decided not to do it and added another field
    and constructor to the `Person` class:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 但有可能有两个人有相同的名字，并且出生在同一天，所以我们决定不这样做，并添加了`Person`类的另一个字段和构造函数：
- en: '```java'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class Person {
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: public class Person {
- en: private String firstName, lastName;
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: private String firstName, lastName;
- en: private LocalDate dob;
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: private LocalDate dob;
- en: private int id;
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: private int id;
- en: public Person(int id, String firstName,
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: public Person(int id, String firstName,
- en: String lastName, LocalDate dob) {
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: String lastName, LocalDate dob) {
- en: this(firstName, lastName, dob);
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: this(firstName, lastName, dob);
- en: this.id = id;
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: this.id = id;
- en: '}'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public Person(String firstName, String lastName, LocalDate dob) {
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: public Person(String firstName, String lastName, LocalDate dob) {
- en: 'this.firstName = firstName == null ? "" : firstName;'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 'this.firstName = firstName == null ? "" : firstName;'
- en: 'this.lastName = lastName == null ? "" : lastName;'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 'this.lastName = lastName == null ? "" : lastName;'
- en: if(dob == null){
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: if(dob == null){
- en: throw new RuntimeException("Date of birth is null");
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: throw new RuntimeException("Date of birth is null");
- en: '}'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: this.dob = dob;
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: this.dob = dob;
- en: '}'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String getFirstName() { return firstName; }
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: public String getFirstName() { return firstName; }
- en: public String getLastName() { return lastName; }
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: public String getLastName() { return lastName; }
- en: public LocalDate getDob() { return dob; }
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: public LocalDate getDob() { return dob; }
- en: '}'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We will use the constructor that accepts `id` for constructing an object based
    on the record in a database, while the other constructor will be used to create
    an object before inserting a new record.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用接受`id`的构造函数来基于数据库中的记录构建对象，而另一个构造函数将用于在插入新记录之前创建对象。
- en: 'We run the preceding SQL statement in a database console and create this table:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在数据库控制台中运行上述SQL语句并创建这个表：
- en: '![](img/00af477d-66c8-4e49-941b-8a8ddbaf76f0.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00af477d-66c8-4e49-941b-8a8ddbaf76f0.png)'
- en: 'If necessary, the table can be deleted by the `DROP` command:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必要，可以通过`DROP`命令删除表：
- en: '```java'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: DROP table person;
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: DROP table person;
- en: '```'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The existing table can be changed using the `ALTER` command. For example, we
    can add an `address` column:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`ALTER`命令更改现有表。例如，我们可以添加一个`address`列：
- en: '```java'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: ALTER table person add column address VARCHAR;
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ALTER table person add column address VARCHAR;
- en: '```'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If you are not sure whether such a column exists already, you can add IF EXISTS
    or IF NOT EXISTS:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定这样的列是否已经存在，可以添加IF EXISTS或IF NOT EXISTS：
- en: '```java'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: ALTER table person add column IF NOT EXISTS address VARCHAR;
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ALTER table person add column IF NOT EXISTS address VARCHAR;
- en: '```'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But this possibility exists only since PostgreSQL 9.6.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种可能性只存在于PostgreSQL 9.6之后。
- en: 'Another important consideration of the database table creation is whether an
    index has to be added. An index is a data structure that helps to accelerate the
    data search in the table without having to check every table record. An index
    can include one or more columns of a table. For example, an index for a primary
    key is created automatically. If you bring up the description of the table we
    have created already, you will see:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库表创建的另一个重要考虑因素是是否必须添加索引。索引是一种数据结构，可以加速表中的数据搜索，而无需检查每条表记录。索引可以包括一个或多个表的列。例如，主键的索引会自动生成。如果您已经创建了表的描述，您将看到：
- en: '![](img/b447b61b-1d4f-4578-a9be-778d1c6c8ec9.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b447b61b-1d4f-4578-a9be-778d1c6c8ec9.png)'
- en: 'We can also add any index ourselves if we think (and have proven it through
    the experimentation) it will help the application''s performance. For example,
    we can allow case-insensitive search by first and last name by adding the following
    index:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们认为（并通过实验已经证明）它将有助于应用程序的性能，我们也可以自己添加任何索引。例如，我们可以通过添加以下索引来允许不区分大小写的搜索名字和姓氏：
- en: '```java'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: CREATE INDEX idx_names ON person ((lower(first_name), lower(last_name));
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: CREATE INDEX idx_names ON person ((lower(first_name), lower(last_name));
- en: '```'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If the search speed improves, we leave the index in place. If not, it can be
    removed:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果搜索速度提高，我们会保留索引。如果没有，可以删除它：
- en: '```java'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: drop index idx_names;
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: drop index idx_names;
- en: '```'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We remove it because an index has an overhead of additional writes and storage
    space.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们删除它，因为索引会增加额外的写入和存储空间开销。
- en: 'And we can remove a column from a table too:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从表中删除列：
- en: '```java'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: ALTER table person DROP column address;
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ALTER table person DROP column address;
- en: '```'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In our examples, we followed the naming convention of PostgreSQL. If you use
    a different database, we suggest you look up its naming convention and follow
    it, so the names you create align with those created automatically.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们遵循了PostgreSQL的命名约定。如果您使用不同的数据库，建议您查找其命名约定并遵循，以便您创建的名称与自动创建的名称对齐。
- en: Create, read, update, and delete (CRUD) data
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建，读取，更新和删除（CRUD）数据
- en: So far, we have used a console to send SQL statements to the database. The same
    statements could be executed from Java code using the JDBC API, but tables are
    created only once, so there is not much sense in writing a program for a one-time
    execution.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用控制台将SQL语句发送到数据库。可以使用JDBC API从Java代码执行相同的语句，但是表只创建一次，因此没有必要为一次性执行编写程序。
- en: 'But managing data is another matter. That is the primary purpose of a program
    we are going to write now. In order to do that, first, we add the following dependency
    to the `pom.xml` file because we have installed PostgreSQL 9.6:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 但是管理数据是另一回事。这是我们现在要编写的程序的主要目的。为了做到这一点，首先我们将以下依赖项添加到`pom.xml`文件中，因为我们已经安装了PostgreSQL
    9.6：
- en: '```java'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: <dependency>
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: <dependency>
- en: <groupId>org.postgresql</groupId>
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: <groupId>org.postgresql</groupId>
- en: <artifactId>postgresql</artifactId>
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: <artifactId>postgresql</artifactId>
- en: <version>42.2.2</version>
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: <version>42.2.2</version>
- en: </dependency>
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: </dependency>
- en: '```'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: INSERT statement
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: INSERT语句
- en: 'The SQL statement that creates (populates) data in the database has the following
    format:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中创建（填充）数据的SQL语句具有以下格式：
- en: '```java'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: INSERT INTO table_name (column1,column2,column3,...)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: INSERT INTO table_name（column1，column2，column3，...）
- en: VALUES (value1,value2,value3,...);
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: VALUES（value1，value2，value3，...）;
- en: '```'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'When several tables records have to be added, it looks like this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当必须添加多个表记录时，它看起来像这样：
- en: '```java'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: INSERT INTO table_name (column1,column2,column3,...)
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: INSERT INTO table_name（column1，column2，column3，...）
- en: VALUES (value1,value2,value3,...), (value11,value21,value31,...), ...;
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: VALUES（value1，value2，value3，...），（value11，value21，value31，...），...;
- en: '```'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Before writing a program, let''s test our `INSERT` statement:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写程序之前，让我们测试我们的`INSERT`语句：
- en: '![](img/c87f8461-b463-4dcb-a806-01b2bac288c7.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: ！[]（img/c87f8461-b463-4dcb-a806-01b2bac288c7.png）
- en: 'It worked without an error and returned the number of inserted rows as 1, so
    we are going to create the following method:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有错误，返回的插入行数为1，所以我们将创建以下方法：
- en: '```java'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void executeStatement(String sql){
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: void executeStatement（String sql）{
- en: Connection conn = getConnection();
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Connection conn = getConnection（）;
- en: try (conn; Statement st = conn.createStatement()) {
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试（conn; Statement st = conn.createStatement（））{
- en: st.execute(sql);
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: st.execute（sql）;
- en: '} catch (SQLException ex) {'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch（SQLException ex）{'
- en: ex.printStackTrace();
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace（）;
- en: '}'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We can execute the preceding method and insert another row:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行前面的方法并插入另一行：
- en: '```java'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: executeStatement("insert into person (first_name, last_name, dob)" +
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: executeStatement（"insert into person（first_name，last_name，dob）"+
- en: '" values (''Bill'', ''Grey'', ''1980-01-27'')");'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: “值（'Bill'，'Grey'，'1980-01-27'）”
- en: '```'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We will see the result of this and previous `INSERT`-statement execution in
    the next section, when we demonstrate `SELECT`-statement.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中看到此前`INSERT`语句执行的结果以及`SELECT`语句的演示。
- en: 'Meanwhile, we would like to discuss the most popular methods of the `java.sql.Statement`
    interface:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我们想讨论`java.sql.Statement`接口的最受欢迎的方法：
- en: '`boolean execute(String sql)`: It returns `true` if the executed statement
    returns data (as a `java.sql.ResultSet` object) that can be retrieved using the `ResultSet
    getResultSet()` method of the `java.sql.Statement` interface. It returns `false`
    if the executed statement does not return data (the SQL statement was probably
    updating or inserting some rows) and the subsequent call to the `int getUpdateCount()` method
    of the `java.sql.Statement` interface returns the number of the affected rows.
    For example, if we have added the print statements to our `executeStatement()`
    method, we would see the following results after inserting a row:'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean execute（String sql）`：如果执行的语句返回数据（作为`java.sql.ResultSet`对象），则返回`true`，可以使用`java.sql.Statement`接口的`ResultSet
    getResultSet（）`方法检索数据。如果执行的语句不返回数据（SQL语句可能正在更新或插入某些行），则返回`false`，并且随后调用`java.sql.Statement`接口的`int
    getUpdateCount（）`方法返回受影响的行数。例如，如果我们在`executeStatement（）`方法中添加了打印语句，那么在插入一行后，我们将看到以下结果：'
- en: '```java'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void executeStatement(String sql){
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: void executeStatement（String sql）{
- en: Connection conn = getConnection();
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Connection conn = getConnection();
- en: try (conn; Statement st = conn.createStatement()) {
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试（conn; Statement st = conn.createStatement（））{
- en: 'System.out.println(st.execute(sql));      //prints: false'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（st.execute（sql））; //打印：false
- en: 'System.out.println(st.getResultSet());    //prints: null'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（st.getResultSet（））; //打印：null
- en: 'System.out.println(st.getUpdateCount());  //prints: 1'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（st.getUpdateCount（））; //打印：1
- en: '} catch (SQLException ex) {'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch（SQLException ex）{'
- en: ex.printStackTrace();
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace（）;
- en: '}'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '`ResultSet executeQuery(String sql)`: It returns data as a `java.sql.ResultSet` object
    (the executed SQL statement is expected to be `SELECT`-statement). The same data
    can be also retrieved by the subsequent call to the `ResultSet getResultSet()` method
    of the `java.sql.Statement` interface. The `int getUpdateCount()` method of the `java.sql.Statement` interface
    returns `-1`. For example, if we change our `executeStatement()` method and use `executeQuery()`,
    the results of `executeStatement("select first_name from person")` would be:'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResultSet executeQuery（String sql）`：它将数据作为`java.sql.ResultSet`对象返回（预计执行的SQL语句是`SELECT`语句）。可以通过随后调用`java.sql.Statement`接口的`ResultSet
    getResultSet（）`方法检索相同的数据。`java.sql.Statement`接口的`int getUpdateCount（）`方法返回`-1`。例如，如果我们更改我们的`executeStatement（）`方法并使用`executeQuery（）`，则`executeStatement（"select
    first_name from person"）`的结果将是：'
- en: '```java'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void executeStatement(String sql){
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: void executeStatement（String sql）{
- en: Connection conn = getConnection();
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Connection conn = getConnection();
- en: try (conn; Statement st = conn.createStatement()) {
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试（conn; Statement st = conn.createStatement（））{
- en: 'System.out.println(st.executeQuery(sql)); //prints: ResultSet'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（st.executeQuery（sql））; //打印：ResultSet
- en: 'System.out.println(st.getResultSet());    //prints: ResultSet'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（st.getResultSet（））; //打印：ResultSet
- en: 'System.out.println(st.getUpdateCount());  //prints: -1'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（st.getUpdateCount（））; //打印：-1
- en: '} catch (SQLException ex) {'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (SQLException ex) {'
- en: ex.printStackTrace();
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace();
- en: '}'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '`int executeUpdate(String sql)`: It returns the number of the affected rows
    (the executed SQL statement is expected to be `UPDATE`-statement). The same number
    returns the subsequent call to the `int getUpdateCount()` method of the `java.sql.Statement` 
    interface. The subsequent call to the `ResultSet getResultSet()` method of the `java.sql.Statement` interface
    returns `null`. For example, if we change our `executeStatement()` method and
    use `executeUpdate()`, the results of `executeStatement("update person set first_name
    = ''Jim'' where last_name = ''Adams''")` would be:'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int executeUpdate(String sql)`: 它返回受影响的行数（执行的SQL语句预期为`UPDATE`语句）。`java.sql.Statement`接口的`int
    getUpdateCount()`方法的后续调用返回相同的数字。`java.sql.Statement`接口的`ResultSet getResultSet()`方法的后续调用返回`null`。例如，如果我们更改我们的`executeStatement()`方法并使用`executeUpdate()`，`executeStatement("update
    person set first_name = ''Jim'' where last_name = ''Adams''")`的结果将是：'
- en: '```java'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void executeStatement4(String sql){
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: void executeStatement4(String sql){
- en: Connection conn = getConnection();
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Connection conn = getConnection();
- en: try (conn; Statement st = conn.createStatement()) {
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: try (conn; Statement st = conn.createStatement()) {
- en: 'System.out.println(st.executeUpdate(sql));//prints: 1'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(st.executeUpdate(sql));//prints: 1'
- en: 'System.out.println(st.getResultSet());    //prints: null'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(st.getResultSet());    //prints: null'
- en: 'System.out.println(st.getUpdateCount());  //prints: 1'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(st.getUpdateCount());  //prints: 1'
- en: '} catch (SQLException ex) {'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (SQLException ex) {'
- en: ex.printStackTrace();
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace();
- en: '}'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: SELECT-statement
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SELECT语句
- en: 'The `SELECT`-statement has the following format:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT`语句的格式如下：'
- en: '```java'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: SELECT column_name, column_name
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT column_name, column_name
- en: FROM table_name WHERE some_column = some_value;
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: FROM table_name WHERE some_column = some_value;
- en: '```'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'When all the columns have to be selected, it looks like this:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要选择所有列时，格式如下：
- en: '```java'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: SELECT * FROM table_name WHERE some_column=some_value;
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT * FROM table_name WHERE some_column=some_value;
- en: '```'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Here is a more general definition of `WHERE`-clause:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`WHERE`子句的更一般的定义：
- en: '```java'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: WHERE column_name operator value
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: WHERE column_name operator value
- en: 'Operator:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符：
- en: =   Equal
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: =   等于
- en: <>  Not equal. In some versions of SQL, !=
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: <>  不等于。在某些版本的SQL中，!=
- en: Greater than
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大于
- en: <   Less than
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: <   小于
- en: '>=  Greater than or equal'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '>=  大于或等于'
- en: <=  Less than or equal
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: <=  小于或等于
- en: IN  Specifies multiple possible values for a column
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: IN  指定列的多个可能值
- en: LIKE  Specifies the search pattern
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: LIKE  指定搜索模式
- en: BETWEEN  Specifies the inclusive range of vlaues in a column
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: BETWEEN  指定列中值的包含范围
- en: '```'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `column_name` operator value constructs can be combined using the `AND`
    and `OR` logical operator and grouped by brackets, `( )`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`column_name` operator value构造可以使用`AND`和`OR`逻辑运算符组合，并用括号`( )`分组。'
- en: 'In the previous statement, we have executed a `select first_name from person` SELECT-statement that
    returns all the first names recorded in the `person` table. Let''s now execute
    it again and print out the results:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的语句中，我们执行了一个`select first_name from person`的`SELECT`语句，返回了`person`表中记录的所有名字。现在让我们再次执行它并打印出结果：
- en: '```java'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Connection conn = getConnection();
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: Connection conn = getConnection();
- en: try (conn; Statement st = conn.createStatement()) {
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: try (conn; Statement st = conn.createStatement()) {
- en: ResultSet rs = st.executeQuery("select first_name from person");
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: ResultSet rs = st.executeQuery("select first_name from person");
- en: while (rs.next()){
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: while (rs.next()){
- en: 'System.out.print(rs.getString(1) + " "); //prints: Jim Bill'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.print(rs.getString(1) + " "); //prints: Jim Bill'
- en: '}'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '} catch (SQLException ex) {'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (SQLException ex) {'
- en: ex.printStackTrace();
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace();
- en: '}'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `getString(int position)` method of the `ResultSet` interface extracts the `String`
    value from position `1` (the first in the list of columns in the `SELECT`-statement).
    There are similar getters for all primitive types, such as `getInt()` and `getByte()`.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultSet`接口的`getString(int position)`方法从位置`1`（`SELECT`语句中列的第一个）提取`String`值。对于所有原始类型，如`getInt()`和`getByte()`，都有类似的获取器。'
- en: 'It is also possible to extract the value from the `ResultSet` object by column
    name. In our case, it would be `getString("first_name")`. It is especially useful
    when the `SELECT`-statement looks like the following:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过列名从`ResultSet`对象中提取值。在我们的情况下，它将是`getString("first_name")`。当`SELECT`语句如下时，这是特别有用的：
- en: '```java'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: select * from person;
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: select * from person;
- en: '```'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But bear in mind that extracting values from the `ResultSet` object by the column
    name is less efficient. The difference in performance is very small and becomes
    important only when the operation happens many times. Only the actual measuring
    and testing can tell if the difference is significant for your application or
    not. Extracting values by column name is especially attractive because it provides
    better code readability, which pays well in a long time during the application
    maintenance.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，通过列名从`ResultSet`对象中提取值效率较低。性能差异非常小，只有在操作发生多次时才变得重要。只有实际的测量和测试才能告诉您这种差异对您的应用程序是否重要。通过列名提取值尤其有吸引力，因为它提供更好的代码可读性，在应用程序维护期间可以得到很好的回报。
- en: There are many other useful methods in the `ResultSet` interface. If your application
    reads data from a database, we highly recommend you read the documentation of
    the `SELECT`-statement and the `ResultSet` interface.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultSet`接口中还有许多其他有用的方法。如果您的应用程序从数据库中读取数据，我们强烈建议您阅读`SELECT`语句和`ResultSet`接口的文档。'
- en: UPDATE-statement
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UPDATE语句
- en: 'The data can be changed by the `UPDATE`-statement:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以通过`UPDATE`语句更改：
- en: '```java'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: UPDATE table_name SET column1=value1,column2=value2,... WHERE-clause;
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE table_name SET column1=value1,column2=value2,... WHERE-clause;
- en: '```'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We have used such a statement to change the first name in one of the records
    from the original value `John` to a new value, `Jim`:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用这样的语句来改变记录中的名字，将原始值`John`改为新值`Jim`：
- en: '```java'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: update person set first_name = 'Jim' where last_name = 'Adams'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: update person set first_name = 'Jim' where last_name = 'Adams'
- en: '```'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Later, using the `SELECT`-statement, we will prove that the change was successful. Without
    the `WHERE`-clause, all the records of the table would be affected.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，使用`SELECT`语句，我们将证明更改是成功的。没有`WHERE`子句，表的所有记录都将受到影响。
- en: DELETE-statement
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DELETE语句
- en: 'The data can be deleted by the `DELETE`-statement:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以通过`DELETE`语句删除：
- en: '```java'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: DELETE FROM table_name WHERE-clause;
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: DELETE FROM table_name WHERE-clause;
- en: '```'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Without the `WHERE`-clause, all the records of the table are deleted. In the
    case of the `person` table, we can delete all the records using the `delete from
    person` SQL statement. The following statement deletes all the records with first
    name Jim from the `person` table:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`WHERE`子句，表的所有记录都将被删除。在`person`表的情况下，我们可以使用`delete from person` SQL语句删除所有记录。以下语句从`person`表中删除所有名为Jim的记录：
- en: '```java'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: delete from person where first_name = 'Jim';
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: delete from person where first_name = 'Jim';
- en: '```'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Using the PreparedStatement class
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PreparedStatement类
- en: An object of `PreparedStatement` —a sub-interface of the `Statement` interface—is
    designed to be cached in the database and then used to efficiently execute the
    SQL statement multiple times for different input values. Similar to an object
    of `Statement` (created by the `createStatement()` method), it can be created
    by the `prepareStatement()` method of the same `Connection` object.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreparedStatement`对象——`Statement`接口的子接口——旨在被缓存在数据库中，然后用于有效地多次执行SQL语句，以适应不同的输入值。与`Statement`对象类似（由`createStatement()`方法创建），它可以由同一`Connection`对象的`prepareStatement()`方法创建。'
- en: 'The same SQL statement that was used to generate the `Statement` object can
    be used to generate the `PreparedStatement` object, too. In fact, it is a good
    idea to consider using `PreparedStatement` for any SQL statement that is called
    multiple times because it performs better than `Statement`. To do it, all we need
    to change are these two lines in our preceding sample code:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 生成`Statement`对象的相同SQL语句也可以用于生成`PreparedStatement`对象。事实上，考虑使用`PreparedStatement`来调用多次的任何SQL语句是一个好主意，因为它的性能优于`Statement`。要做到这一点，我们只需要更改前面示例代码中的这两行：
- en: '```java'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: try (conn; Statement st = conn.createStatement()) {
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: try (conn; Statement st = conn.createStatement()) {
- en: ResultSet rs = st.executeQuery(sql);
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: ResultSet rs = st.executeQuery(sql);
- en: '```'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Alternatively, we can use the `PreparedStatement` class the same way:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以以同样的方式使用`PreparedStatement`类：
- en: '```java'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: try (conn; PreparedStatement st = conn.prepareStatement(sql)) {
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: try (conn; PreparedStatement st = conn.prepareStatement(sql)) {
- en: ResultSet rs = st.executeQuery();
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: ResultSet rs = st.executeQuery();
- en: '```'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'But the true usefulness of `PreparedStatement` shines because of its ability
    to accept parameters – the input values that substitute (in the order of their
    appearance) the `?` symbol. For example, we can create the following method:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`PreparedStatement`的真正用处在于它能够接受参数-替换（按照它们出现的顺序）`?`符号的输入值。例如，我们可以创建以下方法：
- en: '```java'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Person> selectPersonsByFirstName(String sql, String searchValue){
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> selectPersonsByFirstName(String sql, String searchValue){
- en: List<Person> list = new ArrayList<>();
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> list = new ArrayList<>();
- en: Connection conn = getConnection();
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: Connection conn = getConnection();
- en: try (conn; PreparedStatement st = conn.prepareStatement(sql)) {
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: try (conn; PreparedStatement st = conn.prepareStatement(sql)) {
- en: st.setString(1, searchValue);
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: st.setString(1, searchValue);
- en: ResultSet rs = st.executeQuery();
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: ResultSet rs = st.executeQuery();
- en: while (rs.next()){
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: while (rs.next()){
- en: list.add(new Person(rs.getInt("id"),
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(new Person(rs.getInt("id"),
- en: rs.getString("first_name"),
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: rs.getString("first_name"),
- en: rs.getString("last_name"),
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: rs.getString("last_name"),
- en: rs.getDate("dob").toLocalDate()));
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: rs.getDate("dob").toLocalDate()));
- en: '}'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '} catch (SQLException ex) {'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (SQLException ex) {'
- en: ex.printStackTrace();
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace();
- en: '}'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return list;
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: return list;
- en: '}'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We can use the preceding method to read those records form the `person` table
    that match the `WHERE`-clause. For example, we can find all the records that have
    the first name `Jim`:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面的方法从`person`表中读取与`WHERE`子句匹配的记录。例如，我们可以找到所有名为`Jim`的记录：
- en: '```java'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String sql = "select * from person where first_name = ?";
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: String sql = "select * from person where first_name = ?";
- en: List<Person> list = selectPersonsByFirstName(sql, "Jim");
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> list = selectPersonsByFirstName(sql, "Jim");
- en: 'for(Person person: list){'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 'for(Person person: list){'
- en: System.out.println(person);
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(person);
- en: '}'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result will be:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是：
- en: '```java'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person{firstName='Jim', lastName='Adams', dob=1999-08-23, id=1}
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: Person{firstName='Jim', lastName='Adams', dob=1999-08-23, id=1}
- en: '```'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The `Person` object is printed this way because we have added the following `toString()` method:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`对象以这种方式打印，因为我们添加了以下`toString()`方法：'
- en: '```java'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '@Override'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public String toString() {
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: public String toString() {
- en: return "Person{" +
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: return "Person{" +
- en: '"firstName=''" + firstName + ''\'''' +'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '"firstName=''" + firstName + ''\'''' +'
- en: '", lastName=''" + lastName + ''\'''' +'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '", lastName=''" + lastName + ''\'''' +'
- en: '", dob=" + dob +'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '", dob=" + dob +'
- en: '", id=" + id +'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '", id=" + id +'
- en: '''}'';'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '''}'';'
- en: '}'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The same result we would get from running the following code:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下代码获得相同的结果：
- en: '```java'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String sql = "select * from person where last_name = ?";
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: String sql = "select * from person where last_name = ?";
- en: List<Person> list = selectPersonsByFirstName(sql, "Adams");
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> list = selectPersonsByFirstName(sql, "Adams");
- en: 'for(Person person: list){'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 'for(Person person: list){'
- en: System.out.println(person);
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(person);
- en: '}'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It is not a bad idea to always use prepared statements for CRUD operations.
    They might be a little slower if executed only once, but you can test to see whether
    this is the price you're willing to pay. What you get with prepared statements
    is consistent (better readable) code, more security (prepared statements are not
    vulnerable to SQL injection attack), and one fewer decision to make – just reuse
    the same code everywhere.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用准备好的语句进行CRUD操作并不是一个坏主意。如果只执行一次，它们可能会慢一点，但您可以测试看看这是否是您愿意支付的代价。使用准备好的语句可以获得一致的（更易读的）代码、更多的安全性（准备好的语句不容易受到SQL注入攻击的影响）以及少做一个决定-只需在任何地方重用相同的代码。
- en: Exercise – Selecting unique first names
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习-选择唯一的名字
- en: 'Write an SQL statement that selects all the names from the person table without
    duplicates. For example, assume that there are three records in the `person` table
    that have these first names: `Jim`, `Jim`, and `Bill`. The SQL statement you write
    must return `Jim` and `Bill`, without repeating the name `Jim` twice.'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个SQL语句，从人员表中选择所有的名字，而不重复。例如，假设人员表中有三条记录，这些记录有这些名字：`Jim`，`Jim`和`Bill`。您编写的SQL语句必须返回`Jim`和`Bill`，而不重复两次的`Jim`。
- en: We did not explain how to do it; you have to read the SQL documentation to find
    out how to select unique values.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有解释如何做; 您必须阅读SQL文档，以找出如何选择唯一的值。
- en: Answer
  id: totrans-507
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Use the `distinct` keyword. The following SQL statement returns unique first
    names:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`distinct`关键字。以下SQL语句返回唯一的名字：
- en: '```java'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: select distinct first_name from person;
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 从人员表中选择不同的名字;
- en: '```'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Summary
  id: totrans-512
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explained how to write Java code that can manipulate—insert, read,
    update, delete—data in a database. It also provided a short introduction to the
    SQL language and basic database operations. The reader has learned what JDBC is,
    how to create and delete a database and a table, and how to write a program that
    manages data in a table.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何编写能够操作数据库中的数据的Java代码。它还对SQL语言和基本数据库操作进行了简要介绍。读者已经学会了JDBC是什么，如何创建和删除数据库和表，以及如何编写一个管理表中数据的程序。
- en: In the next chapter, the reader will learn the concept of functional programming.
    We will provide an overview of functional interfaces that come with JDK, explain
    how to use them in lambda expressions, and look at how to use lambda expressions
    in datastream processing.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，读者将学习函数式编程的概念。我们将概述JDK附带的功能接口，解释如何在lambda表达式中使用它们，并了解如何在数据流处理中使用lambda表达式。
