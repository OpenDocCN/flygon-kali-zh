- en: Chapter 7. Sharing Data with Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。与容器共享数据
- en: 'Do one thing at a time and do it well, is one of the successful mantras of
    the information technology (IT) sector for quite a long time now. This widely
    used tenet fits nicely with the building and exposing of Docker containers too
    and is being prescribed as one of the best practices to avail the originally envisaged
    benefits of the Docker-inspired containerization paradigm. That is, inscribe a
    single application along with its direct dependencies and libraries inside a Docker
    container in order to ensure the container''s independence, self-sufficiency,
    and maneuverability. Let''s see why containers are that important:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一次只做一件事，并且做好，是信息技术（IT）部门长期以来的成功口头禅之一。这个广泛使用的原则也很好地适用于构建和暴露Docker容器，并被规定为实现最初设想的Docker启发式容器化范式的最佳实践之一。也就是说，将单个应用程序以及其直接依赖项和库放在Docker容器中，以确保容器的独立性、自给自足性和可操纵性。让我们看看为什么容器如此重要：
- en: '**The temporal nature of containers**: The container typically lives as long
    as the application lives and vice versa. However, this has some negative implications
    for the application data. It is natural that applications go through a variety
    of changes in order to accommodate both businesses, as well as technical changes,
    even in their production environments. There are other causes, such as application
    malfunction, version changes, application maintenance, and so on, for applications
    to be updated and upgraded consistently. In the case of a general-purpose computing
    model, even when an application dies for any reason, the persistent data associated
    with this application would be preserved in the filesystem. However, in the case
    of the container paradigm, the application upgrades are usually performed by crafting
    a new container with the newer version of the application, by discarding the old
    one. Similarly, when an application malfunctions, a new container needs to be
    launched and the old one has to be discarded. To sum it up, containers are temporal
    in nature.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的临时性质：容器通常存在的时间与应用程序存在的时间一样长。然而，这对应用程序数据有一些负面影响。应用程序自然会经历各种变化，以适应业务和技术变化，甚至在其生产环境中也是如此。还有其他原因，比如应用程序故障、版本更改、应用程序维护等，导致应用程序需要不断更新和升级。在通用计算模型的情况下，即使应用程序因任何原因而死亡，与该应用程序关联的持久数据也会保存在文件系统中。然而，在容器范式的情况下，应用程序升级通常是通过创建一个具有较新版本应用程序的新容器来完成的，然后丢弃旧容器。同样，当应用程序发生故障时，需要启动一个新容器，并丢弃旧容器。总之，容器具有临时性质。
- en: '**The need for business continuity**: In the container landscape, the complete
    execution environment, including its data files are usually bundled and encapsulated
    inside the container. For any reason, when a container gets discarded, the application
    data files also perish along with the container. However, in order to provide
    a seamless service, these application data files must be preserved outside the
    container and passed on to the container that will be continuing with the service.
    Some application data files, such as the log files, need to be accessed outside
    the container for various posterior-analyses. The Docker technology addresses
    this file persistence issue very innovatively through a new building block called
    data volume.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业连续性的需求：在容器环境中，完整的执行环境，包括其数据文件通常被捆绑和封装在容器内。无论出于何种原因，当一个容器被丢弃时，应用程序数据文件也会随着容器一起消失。然而，为了提供无缝的服务，这些应用程序数据文件必须在容器外部保留，并传递给将继续提供服务的容器。一些应用程序数据文件，如日志文件，需要在容器外部进行各种后续分析。Docker技术通过一个称为数据卷的新构建块非常创新地解决了这个文件持久性问题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Data volume
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据卷
- en: Sharing host data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享主机数据
- en: Sharing data between containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器之间共享数据
- en: The avoidable common pitfalls
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可避免的常见陷阱
- en: The data volume
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据卷
- en: The data volume is the fundamental building block of data sharing in the Docker
    environment. Before getting into the details of data sharing, it is imperative
    to gain a good understanding of the Data Volume concept. Until now, all the files
    that we created in an image or a container are part and parcel of the Union filesystem.
    However, the data volume is part of the Docker host filesystem, and it simply
    gets mounted inside the container.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 数据卷是Docker环境中数据共享的基本构建块。在深入了解数据共享的细节之前，必须对数据卷概念有很好的理解。到目前为止，我们在镜像或容器中创建的所有文件都是联合文件系统的一部分。然而，数据卷是Docker主机文件系统的一部分，它只是在容器内部挂载。
- en: 'A data volume can be inscribed in a Docker image using the `VOLUME` instruction
    of the `Dockerfile`. Also, it can be prescribed during the launch of a container
    using the `-v` option of the `docker run` subcommand. Here, in the following example,
    the implication of the `VOLUME` instruction in the `Dockerfile` is illustrated
    in detail, in the following steps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 数据卷可以使用`Dockerfile`的`VOLUME`指令在Docker镜像中进行刻录。此外，可以在启动容器时使用`docker run`子命令的`-v`选项进行指定。在下面的示例中，将详细说明在`Dockerfile`中使用`VOLUME`指令的含义，具体步骤如下：
- en: 'Create a very simple `Dockerfile` with the instruction of the base image (`ubuntu:14.04`)
    and the data volume (`/MountPointDemo`):'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个非常简单的`Dockerfile`，其中包含基础镜像（`ubuntu:14.04`）和数据卷（`/MountPointDemo`）的指令：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Build the image with the name `mount-point-demo` using the `docker build` subcommand:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker build`子命令构建名称为`mount-point-demo`的镜像：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Having built the image, let''s quickly inspect the image for our data volume
    using the `docker inspect` subcommand:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建完镜像后，让我们使用`docker inspect`子命令快速检查我们的数据卷：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Evidently, in the preceding output, the data volume is inscribed in the image
    itself.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在前面的输出中，数据卷是直接刻录在镜像中的。
- en: 'Now, let''s launch an interactive container using the `docker run` subcommand
    from the earlier crafted image, as shown in the following command:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用先前创建的镜像启动一个交互式容器，如下命令所示：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'From the container''s prompt, let''s check the presence of the data volume
    using the `ls -ld` command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从容器的提示符中，使用`ls -ld`命令检查数据卷的存在：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As mentioned earlier, the data volume is part of the Docker host filesystem
    and it gets mounted, as shown in the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，数据卷是Docker主机文件系统的一部分，并且会被挂载，如下命令所示：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this section, we inspected the image to find out about the data volume declaration
    in the image. Now that we have launched the container, let''s inspect the container''s
    data volume using the `docker inspect` subcommand with the container ID as its
    argument in a different terminal. We created a few containers previously and for
    this purpose, let''s take the container ID `8d22f73b5b46` directly from the container''s
    prompt:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本节中，我们检查了镜像，以了解镜像中的数据卷声明。现在我们已经启动了容器，让我们在另一个终端中使用`docker inspect`子命令和容器ID作为参数来检查容器的数据卷。我们之前创建了一些容器，为此，让我们直接从容器的提示符中获取容器ID`8d22f73b5b46`：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Apparently, here, the data volume is mapped to a directory in the Docker host,
    and the directory is mounted in read-write mode. This directory is created by
    the Docker engine automatically during the container launch time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在这里，数据卷被映射到Docker主机中的一个目录，并且该目录以读写模式挂载。这个目录是由Docker引擎在容器启动时自动创建的。
- en: 'So far, we have seen the implication of the `VOLUME` instruction in the `Dockerfile`,
    and how Docker manages the data volume. Like the `VOLUME` instruction of the `Dockerfile`,
    we can use the `–v <container mount point path>` option of the `docker run` subcommand,
    as shown in the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了`Dockerfile`中`VOLUME`指令的含义，以及Docker如何管理数据卷。像`Dockerfile`中的`VOLUME`指令一样，我们可以使用`docker
    run`子命令的`-v <容器挂载点路径>`选项，如下面的命令所示：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Having launched the container, we encourage you to try the `ls -ld /MountPointDemo`
    and `mount` commands in the newly launched container, and then also, inspect the
    container, as shown in the preceding step, step 5.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 启动容器后，我们鼓励您尝试在新启动的容器中使用`ls -ld /MountPointDemo`和`mount`命令，然后也像前面的步骤5中所示那样检查容器。
- en: 'In both the scenarios described here, the Docker engine automatically creates
    the directory under `/var/lib/docker/vfs/` and mounts it to the container. When
    a container is removed using the `docker rm` subcommand, the Docker engine does
    not remove the directory that was automatically created during the container launch
    time. This behavior is innately designed to preserve the state of the container''s
    application that was stored in the directory. If you want to remove the directory
    that was automatically created by the Docker engine, you can do so while removing
    the container by providing a `-v` option to the `docker rm` subcommand, on an
    already stopped container:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里描述的两种情况中，Docker引擎会自动在`/var/lib/docker/vfs/`目录下创建目录，并将其挂载到容器中。当使用`docker rm`子命令删除容器时，Docker引擎不会删除在容器启动时自动创建的目录。这种行为本质上是为了保留存储在目录中的容器应用程序的状态。如果您想删除Docker引擎自动创建的目录，可以在删除容器时使用`docker
    rm`子命令提供`-v`选项来执行，前提是容器已经停止：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If the container is still running, then you can remove the container as well
    as the auto-generated directory by adding a `-f` option to the previous command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器仍在运行，则可以通过在上一个命令中添加`-f`选项来删除容器以及自动生成的目录：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have taken you through the techniques and tips to auto-generate a directory
    in the Docker host and mount it to the data volume in the container. However,
    with the `-v` option of the `docker run` subcommand, a user-defined directory
    can be mounted to the data volume. In such cases, the Docker engine would not
    auto-generate any directory.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了在Docker主机中自动生成目录并将其挂载到容器数据卷的技术和提示。然而，使用`docker run`子命令的`-v`选项可以将用户定义的目录挂载到数据卷。在这种情况下，Docker引擎不会自动生成任何目录。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The system-generated directory has a caveat of directory leak. In other words,
    if you forget to delete the system-generated directories, you may face some unwanted
    issues. For further information, you can read the *Avoiding common pitfalls* section
    in this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 系统生成的目录存在目录泄漏的问题。换句话说，如果您忘记删除系统生成的目录，可能会遇到一些不必要的问题。有关更多信息，您可以阅读本章节中的*避免常见陷阱*部分。
- en: Sharing host data
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享主机数据
- en: 'Earlier, we described the steps towards creating a data volume in a Docker
    image using the `VOLUME` instruction in the `Dockerfile`. However, Docker does
    not provide any mechanism to mount the host directory or file during the build
    time in order to ensure the Docker images are portable. The only provision Docker
    provides is to mount the host directory or file to a container''s data volume
    during the container''s launch time. Docker exposes the host directory or file
    mounting facility through the `-v` option of the `docker run` subcommand. The
    `–v` option has three different formats enumerated as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们描述了在Docker镜像中使用`Dockerfile`中的`VOLUME`指令创建数据卷的步骤。然而，Docker没有提供任何机制在构建时挂载主机目录或文件，以确保Docker镜像的可移植性。Docker提供的唯一规定是在容器启动时将主机目录或文件挂载到容器的数据卷上。Docker通过`docker
    run`子命令的`-v`选项公开主机目录或文件挂载功能。`-v`选项有三种不同的格式，如下所列：
- en: '`-v <container mount path>`'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: -v <容器挂载路径>
- en: '`-v <host path>/<container mount path>`'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-v <host path>/<container mount path>`'
- en: '`-v <host path>/<container mount path>:<read write mode>`'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-v <host path>/<container mount path>:<read write mode>`'
- en: The `<host path>` is an absolute path in the Docker host, `<container mount
    path>` is an absolute path in the container filesystem, and `<read write mode>`
    can be either read-only (`ro`) or read-write (`rw`) mode. The first `-v <container
    mount path>` format has already been explained in the *Data Volume* section in
    this chapter, as a method to create a mount point during the container launch
    time. The second and third options enable us to mount a file or directory from
    the Docker host to the container mount point.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`<host path>`是Docker主机上的绝对路径，`<container mount path>`是容器文件系统中的绝对路径，`<read write
    mode>`可以是只读（`ro`）或读写（`rw`）模式。第一个`-v <container mount path>`格式已经在本章的*数据卷*部分中解释过，作为在容器启动时创建挂载点的方法。第二和第三个选项使我们能够将Docker主机上的文件或目录挂载到容器的挂载点。'
- en: We would like to dig deeper to gain a better understanding of the host's data
    sharing through a couple of examples. In the first example, we will demonstrate
    how to share a directory between the Docker host and the container, and in the
    second example, we will demonstrate file sharing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过几个例子深入了解主机数据共享。在第一个例子中，我们将演示如何在Docker主机和容器之间共享一个目录，在第二个例子中，我们将演示文件共享。
- en: 'Here, in the first example, we mount a directory from the Docker host to a
    container, perform a few basic file operations on the container, and verify these
    operations from the Docker host, as detailed in the following steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们将一个目录从Docker主机挂载到一个容器中，在容器上执行一些基本的文件操作，并从Docker主机验证这些操作，详细步骤如下：
- en: 'First, let''s launch an interactive container with the `–v` option of the `docker
    run` subcommand to mount `/tmp/hostdir` of the Docker host directory to `/MountPoint`
    of the container:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用`docker run`子命令的`-v`选项启动一个交互式容器，将Docker主机目录`/tmp/hostdir`挂载到容器的`/MountPoint`：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If `/tmp/hostdir` is not found on the Docker host, the Docker engine will create
    the directory itself. However, the problem is that the system-generated directory
    cannot be deleted using the `-v` option of the `docker rm` subcommand.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在Docker主机上找不到`/tmp/hostdir`，Docker引擎将自行创建该目录。然而，问题在于系统生成的目录无法使用`docker rm`子命令的`-v`选项删除。
- en: 'Having successfully launched the container, we can check the presence of `/MountPoint`
    using the `ls` command:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功启动容器后，我们可以使用`ls`命令检查`/MountPoint`的存在：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we can proceed to checking the mount details using the `mount` command:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以继续使用`mount`命令检查挂载细节：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we are going to validate `/MountPoint`, change to the `/MountPoint` directory
    using the `cd` command, create a few files using the `touch` command, and list
    the files using the `ls` command, as shown in the following script:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将验证`/MountPoint`，使用`cd`命令切换到`/MountPoint`目录，使用`touch`命令创建一些文件，并使用`ls`命令列出文件，如下脚本所示：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It might be worth the effort to verify the files in the `/tmp/hostdir` Docker
    host directory using the `ls` command on a new terminal, as our container is running
    in an interactive mode on the existing terminal:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能值得努力使用新终端上的`ls`命令验证`/tmp/hostdir` Docker主机目录中的文件，因为我们的容器正在现有终端上以交互模式运行：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we can see the same set of files, as we can see in step 4\. However, you
    might have noticed the difference in the time stamp of the files. This time difference
    is due to the time-zone difference between the Docker host and the container.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到与第4步中相同的一组文件。但是，您可能已经注意到文件的时间戳有所不同。这种时间差异是由于Docker主机和容器之间的时区差异造成的。
- en: 'Finally, let''s run the `docker inspect` subcommand with the container ID `4a018d99c133`
    as an argument to see whether the directory mapping is set up between the Docker
    host and the container mount point, as shown in the following command:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们运行`docker inspect`子命令，以容器ID`4a018d99c133`作为参数，查看Docker主机和容器挂载点之间是否设置了目录映射，如下命令所示：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Apparently, in the preceding output of the `docker inspect` subcommand, the
    `/tmp/hostdir` directory of the Docker host is mounted on the `/MountPoint` mount
    point of the container.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在`docker inspect`子命令的先前输出中，Docker主机的`/tmp/hostdir`目录被挂载到容器的`/MountPoint`挂载点上。
- en: 'For the second example, we can mount a file from the Docker host to a container,
    update the file from the container, and verify these operations from the Docker
    host, as detailed in the following steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个示例，我们可以将文件从Docker主机挂载到容器中，从容器中更新文件，并从Docker主机验证这些操作，详细步骤如下：
- en: 'In order to mount a file from the Docker host to the container, the file must
    preexist in the Docker host. Otherwise, the Docker engine will create a new directory
    with the specified name, and mount it as a directory. We can start by creating
    a file on the Docker host using the `touch` command:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将文件从Docker主机挂载到容器中，文件必须在Docker主机上预先存在。否则，Docker引擎将创建一个具有指定名称的新目录，并将其挂载为目录。我们可以通过使用`touch`命令在Docker主机上创建一个文件来开始：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Launch an interactive container with the `–v` option of the `docker run` subcommand
    to mount the `/tmp/hostfile.txt` Docker host file to the container as `/tmp/mntfile.txt`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker run`子命令的`-v`选项启动交互式容器，将`/tmp/hostfile.txt` Docker主机文件挂载到容器上，作为`/tmp/mntfile.txt`：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Having successfully launched the container, now let''s check the presence of
    `/mountedfile.txt` using the `ls` command:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功启动容器后，现在让我们使用`ls`命令检查`/mountedfile.txt`的存在：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, proceed to check the mount details using the `mount` command:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，继续使用`mount`命令检查挂载细节：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, update some text to `/mountedfile.txt` using the `echo` command:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`echo`命令更新`/mountedfile.txt`中的一些文本：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Meanwhile, switch to a different terminal in the Docker host, and print the
    `/tmp/hostfile.txt` Docker host file using the `cat` command:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，在Docker主机中切换到另一个终端，并使用`cat`命令打印`/tmp/hostfile.txt` Docker主机文件：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, run the `docker inspect` subcommand with the container ID `d23a15527eeb`
    as it''s argument to see the file mapping between the Docker host and the container
    mount point:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行`docker inspect`子命令，以容器ID`d23a15527eeb`作为参数，查看Docker主机和容器挂载点之间的文件映射：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: From the preceding output, it is evident that the `/tmp/hostfile.txt` file from
    the Docker host is mounted as `/mountedfile.txt` inside the container.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出可以看出，来自Docker主机的`/tmp/hostfile.txt`文件被挂载为容器内的`/mountedfile.txt`。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the case of file sharing between the Docker host and container, the file
    must exist before launching the container. However, in the case of directory sharing,
    if the directory does not exist in the Docker host, then the Docker engine would
    create a new directory in the Docker host, as explained earlier.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker主机和容器之间共享文件的情况下，文件必须在启动容器之前存在。然而，在目录共享的情况下，如果Docker主机中不存在该目录，则Docker引擎会在Docker主机中创建一个新目录，如前面所述。
- en: The practicality of host data sharing
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机数据共享的实用性
- en: 'In the previous chapter, we launched an `HTTP` service in a Docker container.
    However, if you remember correctly, the log file for the `HTTP` service is still
    inside the container, and it cannot be accessed directly from the Docker host.
    Here, in this section, we elucidate the procedure of accessing the log files from
    the Docker host in a step-by-step manner:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在Docker容器中启动了一个`HTTP`服务。然而，如果你记得正确的话，`HTTP`服务的日志文件仍然在容器内，无法直接从Docker主机访问。在这里，在本节中，我们逐步阐述了从Docker主机访问日志文件的过程：
- en: 'Let''s begin with launching an Apache2 HTTP service container by mounting the
    `/var/log/myhttpd` directory of the Docker host to the `/var/log/apache2` directory
    of the container, using the `–v` option of the `docker run` subcommand. In this
    example, we are leveraging the `apache2` image, which we had built in the previous
    chapter, by invoking the following command:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始启动一个Apache2 HTTP服务容器，将Docker主机的`/var/log/myhttpd`目录挂载到容器的`/var/log/apache2`目录，使用`docker
    run`子命令的`-v`选项。在这个例子中，我们正在利用我们在上一章中构建的`apache2`镜像，通过调用以下命令：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you recall the `Dockerfile` in [Chapter 6](ch06.html "Chapter 6. Running
    Services in a Container"), *Running Services in a Container*, the `APACHE_LOG_DIR`
    environment variable is set to the `/var/log/apache2` directory, using the `ENV`
    instruction. This would make the Apache2 HTTP service route all log messages to
    the `/var/log/apache2` data volume.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得[第6章](ch06.html "第6章。在容器中运行服务")中的`Dockerfile`，*在容器中运行服务*，`APACHE_LOG_DIR`环境变量被设置为`/var/log/apache2`目录，使用`ENV`指令。这将使Apache2
    HTTP服务将所有日志消息路由到`/var/log/apache2`数据卷。
- en: 'Once the container is launched, we can change the directory to `/var/log/myhttpd`
    on the Docker host:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器启动后，我们可以在Docker主机上切换到`/var/log/myhttpd`目录：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Perhaps, a quick check of the files present in the `/var/log/myhttpd` directory
    is appropriate here:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也许，在这里适当地快速检查`/var/log/myhttpd`目录中存在的文件：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, the `access.log` contains all the access requests handled by the Apache2
    HTTP server. The `error.log` is a very important log file, where our HTTP server
    records the errors it encounters while processing any HTTP requests. The `other_vhosts_access.log`
    file is the virtual host log, which will always be empty in our case.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`access.log`包含了Apache2 HTTP服务器处理的所有访问请求。`error.log`是一个非常重要的日志文件，我们的HTTP服务器在处理任何HTTP请求时记录遇到的错误。`other_vhosts_access.log`文件是虚拟主机日志，在我们的情况下始终为空。
- en: 'We can display the content of all the log files in the `/var/log/myhttpd` directory
    using the `tail` command with the `–f` option:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`tail`命令和`-f`选项显示`/var/log/myhttpd`目录中所有日志文件的内容：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `tail -f` command will run continuously and display the content of the files,
    as soon as they get updated. Here, both `access.log` and `other_vhosts_access.log`
    are empty, and there are a few error messages on the `error.log` file. Apparently,
    these error logs are generated by the HTTP service running inside the container.
    The logs are then stocked in the Docker host directory, which is mounted during
    the launch time of the container.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail -f` 命令将持续运行并显示文件的内容，一旦它们被更新。在这里，`access.log` 和 `other_vhosts_access.log`
    都是空的，并且 `error.log` 文件上有一些错误消息。显然，这些错误日志是由容器内运行的HTTP服务生成的。然后，这些日志被储存在Docker主机目录中，在容器启动时被挂载。'
- en: 'As we continue to run `tail –f *`, let''s connect to the HTTP service from
    a web browser running inside the container, and observe the log files:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们继续运行 `tail –f *` 时，让我们从容器内运行的Web浏览器连接到HTTP服务，并观察日志文件：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The HTTP service updates the `access.log` file, which we can manipulate from
    the host directory mounted through the `–v` option of the `docker run` subcommand.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP服务更新 `access.log` 文件，我们可以通过 `docker run` 子命令的 `–v` 选项挂载的主机目录进行操作。
- en: Sharing data between containers
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器之间共享数据
- en: In the previous section, we learnt how seamlessly the Docker engine enables
    data sharing between the Docker host and the container. Even though it is a very
    effective solution, it tightly couples the container to the host filesystem. These
    directories might leave a nasty footprint because the user has to manually remove
    them once their purpose is met. So, the Docker's prescription to solve this issue
    is to create data-only containers as a base container, and then mount the Data
    Volume of that container to other containers using the `--volume-from` option
    of the `docker run` subcommand.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们了解了Docker引擎如何在Docker主机和容器之间无缝地实现数据共享。尽管这是一个非常有效的解决方案，但它将容器紧密耦合到主机文件系统。这些目录可能会留下不好的印记，因为用户必须在它们的目的达到后手动删除它们。因此，Docker解决这个问题的建议是创建数据专用容器作为基础容器，然后使用
    `docker run` 子命令的 `--volume-from` 选项将该容器的数据卷挂载到其他容器。
- en: Data-only containers
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据专用容器
- en: 'The prime responsibility of a data-only container is to preserve the data.
    Creating a data-only container is very similar to the method illustrated in the
    data volume section. In addition, the containers are named explicitly for other
    containers to mount the data volume using the container''s name. The container''s
    data volumes are accessible from other containers even when the data-only containers
    are in the stopped state. The data-only containers can be created in two ways,
    as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 数据专用容器的主要责任是保存数据。创建数据专用容器与数据卷部分所示的方法非常相似。此外，容器被明确命名，以便其他容器使用容器的名称挂载数据卷。即使数据专用容器处于停止状态，其他容器也可以访问数据专用容器的数据卷。数据专用容器可以通过以下两种方式创建：
- en: During the container's launch time by configuring the data volume and container's
    name.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器启动时通过配置数据卷和容器名称。
- en: The data volume can also be inscribed with `Dockerfile` during the image-building
    time, and later the container can be named during the container's launch time.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据卷也可以在构建镜像时通过 `Dockerfile` 进行编写，然后在容器启动时命名容器。
- en: 'In the following example, we are launching a data-only container by configuring
    the container launch with the `–v` and `--name` options of the `docker run` subcommand,
    as shown here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们通过配置 `docker run` 子命令的 `–v` 和 `--name` 选项来启动一个数据专用容器，如下所示：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, the container is launched from the `busybox` image, which is widely used
    for its smaller footprint. Here, we choose to execute the `/bin/true` command
    because we don't intend to do any operations on the container. Therefore, we named
    the container `datavol` using the `--name` option and created a new `/DataMount`
    data volume using the `-v` option of the `docker run` subcommand. The `/bin/true`
    command exits immediately with the exit status `0`, which in turn will stop the
    container and continue to be in the stopped state.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，容器是从`busybox`镜像启动的，该镜像因其较小的占用空间而被广泛使用。在这里，我们选择执行`/bin/true`命令，因为我们不打算对容器进行任何操作。因此，我们使用`--name`选项命名了容器`datavol`，并使用`docker
    run`子命令的`-v`选项创建了一个新的`/DataMount`数据卷。`/bin/true`命令立即以退出状态`0`退出，这将停止容器并继续停留在停止状态。
- en: Mounting data volume from other containers
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从其他容器挂载数据卷
- en: The Docker engine provides a nifty interface to mount (share) the data volume
    from one container to another. Docker makes this interface available through the
    `--volumes-from` option of the `docker run` subcommand. The `--volumes-from` option
    takes a container name or container ID as its input and automatically mounts all
    the data volumes available on the specified container. Docker allows you to mount
    multiple containers with the data volume using the `--volumes-from` option multiple
    times.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Docker引擎提供了一个巧妙的接口，可以将一个容器的数据卷挂载（共享）到另一个容器。Docker通过`docker run`子命令的`--volumes-from`选项提供了这个接口。`--volumes-from`选项以容器名称或容器ID作为输入，并自动挂载指定容器上的所有数据卷。Docker允许您多次使用`--volumes-from`选项来挂载多个容器的数据卷。
- en: Here is a practical example that demonstrates how to mount the data volume from
    another container and showcases the data volume mount process, step by step.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实际的示例，演示了如何从另一个容器挂载数据卷，并逐步展示数据卷挂载过程。
- en: 'We begin with launching an interactive Ubuntu container by mounting the data
    volume from the data-only container (`datavol`), which we launched in the previous
    section, as explained here:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先启动一个交互式Ubuntu容器，通过挂载数据专用容器（`datavol`）中的数据卷来进行操作，如前述所述：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now from the container''s prompt, let''s verify the data volume mounts using
    the `mount` command:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在从容器的提示符中，让我们使用`mount`命令验证数据卷挂载：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we successfully mounted the data volume from the `datavol` data-only container.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们成功地从`datavol`数据专用容器中挂载了数据卷。
- en: 'Next, we need to inspect the data volume of this container from another terminal
    using the `docker inspect` subcommand:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用`docker inspect`子命令从另一个终端检查该容器的数据卷：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Evidently, the data volume from the `datavol` data-only container is mounted
    as if they were mounted directly on to this container.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，来自`datavol`数据专用容器的数据卷被挂载，就好像它们直接挂载到了这个容器上一样。
- en: 'We can mount a data volume from another container and also showcase the mount
    points. We can make the mounted data volume work by sharing data between containers
    using the data volume, as demonstrated here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从另一个容器挂载数据卷，并展示挂载点。我们可以通过使用数据卷在容器之间共享数据来使挂载的数据卷工作，如下所示：
- en: 'Let''s reuse the container that we launched in the previous example and create
    a `/DataMount/testfile` file in the data volume `/DataMount` by writing some text
    to the file, as shown here:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重用在上一个示例中启动的容器，并通过向数据卷`/DataMount`写入一些文本来创建一个`/DataMount/testfile`文件，如下所示：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Just spin off a container to display the text that we wrote in the previous
    step, using the `cat` command:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需将一个容器分离出来，以显示我们在上一步中编写的文本，使用`cat`命令：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following is the typical output of the preceding command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述命令的典型输出：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Evidently, the preceding output `Data Sharing between Container` of our newly
    containerized `cat` command is the text that we have written in `/DataMount/testfile`
    of the `datavol` container in step 1.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们新容器化的`cat`命令的前面输出`容器之间的数据共享`是我们在步骤1中写入`/DataMount/testfile`的`datavol`容器中的文本。
- en: 'Cool, isn''t it? You can share data seamlessly between containers by sharing
    the data volumes. Here, in this example, we used data-only containers as the base
    container for data sharing. However, Docker allows us to share any type of data
    volumes and to mount data volumes one after another, as depicted here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，不是吗？您可以通过共享数据卷在容器之间无缝共享数据。在这个例子中，我们使用数据专用容器作为数据共享的基础容器。然而，Docker允许我们共享任何类型的数据卷，并且可以依次挂载数据卷，如下所示：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, in the `vol1` container, we can mount the data volume from the `datavol`
    container.Then, in the `vol2` container,we mounted the data volume from the `vol1`
    container, which is originally from the `datavol` container.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在`vol1`容器中，我们可以挂载来自`datavol`容器的数据卷。然后，在`vol2`容器中，我们挂载了来自`vol1`容器的数据卷，这些数据卷最初来自`datavol`容器。
- en: The practicality of data sharing between containers
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器之间数据共享的实用性
- en: 'Earlier, in this chapter, we learnt the mechanism of accessing the log files
    of the Apache2 HTTP service from the Docker host. Although it was fairly convenient
    to share data by mounting the Docker host directory to a container, later we came
    to realise that data can be shared between containers by just using the data volumes.
    So here, we are bringing in a twist to the method of the Apache2 HTTP service
    log handling by sharing data between containers. To share log files between containers,
    we will spin off the following containers as enlisted in the following steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们学习了从Docker主机访问Apache2 HTTP服务的日志文件的机制。虽然通过将Docker主机目录挂载到容器中方便地共享数据，但后来我们意识到可以通过仅使用数据卷在容器之间共享数据。因此，在这里，我们通过在容器之间共享数据来改变Apache2
    HTTP服务日志处理的方法。为了在容器之间共享日志文件，我们将按照以下步骤启动以下容器：
- en: First, a data-only container that would expose the data volume to other containers.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，一个仅用于数据的容器，将向其他容器公开数据卷。
- en: Then, an Apache2 HTTP service container leveraging the data volume of the data-only
    container.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，一个利用数据专用容器的数据卷的Apache2 HTTP服务容器。
- en: A container to view the log files generated by our Apache2 HTTP service.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个用于查看我们Apache2 HTTP服务生成的日志文件的容器。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'NOTE: If you are running any HTTP service on the port number `80` of your Docker
    host machine, pick any other unused port number for the following example. If
    not, first stop the HTTP service, then proceed with the example in order to avoid
    any port conflict.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您在Docker主机机器的端口号`80`上运行任何HTTP服务，请为以下示例选择任何其他未使用的端口号。如果没有，请先停止HTTP服务，然后按照示例进行操作，以避免任何端口冲突。
- en: 'Now, we meticulously walk you through the steps to craft the respective images
    and launch the containers to view the log files, as illustrated here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将逐步为您介绍如何制作相应的镜像并启动容器以查看日志文件，如下所示：
- en: 'Here, we begin with crafting a `Dockerfile` with the `/var/log/apache2` data
    volume using the `VOLUME` instruction. The /`var/log/apache2` data volume is a
    direct mapping to `APACHE_LOG_DIR`, the environment variable set in the `Dockerfile`
    in [Chapter 6](ch06.html "Chapter 6. Running Services in a Container"), *Running
    Services in a Container*, using the `ENV` instruction:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们首先使用`VOLUME`指令使用`/var/log/apache2`数据卷来制作`Dockerfile`。`/var/log/apache2`数据卷是对`Dockerfile`中[第6章](ch06.html
    "第6章。在容器中运行服务")中设置的环境变量`APACHE_LOG_DIR`的直接映射，使用`ENV`指令：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Since this `Dockerfile` is crafted to launch data-only containers, the default
    execution command is set to `/bin/true`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个`Dockerfile`是用来启动数据仅容器的，所以默认的执行命令被设置为`/bin/true`。
- en: 'We will continue to build a Docker image with the name `apache2log` from the
    preceding `Dockerfile` using `docker build`, as presented here:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续使用`docker build`从上述`Dockerfile`构建一个名为`apache2log`的Docker镜像，如下所示：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Launch a data-only container from the `apache2log` image using the `docker
    run` subcommand and name the resulting container `log_vol`, using the `--name`
    option:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker run`子命令从`apache2log`镜像启动一个仅数据的容器，并将生成的容器命名为`log_vol`，使用`--name`选项：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Acting on the preceding command, the container will create a data volume in
    `/var/log/apache2` and move it to a stop state.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述命令，容器将在`/var/log/apache2`中创建一个数据卷并将其移至停止状态。
- en: 'Meanwhile, you can run the `docker ps` subcommand with the `-a` option to verify
    the container''s state:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与此同时，您可以使用`-a`选项运行`docker ps`子命令来验证容器的状态：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As per the output, the container exits with the exit value `0`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 根据输出，容器以退出值`0`退出。
- en: 'Launch the Apache2 HTTP service using the `docker run` subcommand. Here, we
    are reusing the `apache2` image we crafted in [Chapter 6](ch06.html "Chapter 6. Running
    Services in a Container"), *Running Services in a Container*. In this container,
    we will mount the `/var/log/apache2` data volume from `log_vol`, the data-only
    container that we launched in step 3, using the `--volumes-from` option:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker run`子命令启动Apache2 HTTP服务。在这里，我们重用了我们在[第6章](ch06.html "第6章。在容器中运行服务")中制作的`apache2`镜像，*在容器中运行服务*。在这个容器中，我们将使用`--volumes-from`选项从我们在第3步中启动的数据仅容器`log_vol`挂载`/var/log/apache2`数据卷：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With the successful launch of the Apache2 HTTP service with the `/var/log/apache2`
    data volume mounted from `log_vol`, we can access the log files using transient
    containers.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 成功启动了从`log_vol`挂载的`/var/log/apache2`数据卷的Apache2 HTTP服务后，我们可以使用临时容器访问日志文件。
- en: 'Here, we are listing the files stored by the Apache2 HTTP service using a transient
    container. This transient container is spun off by mounting the `/var/log/apache2`
    data volume from `log_vol`,and the files in `/var/log/apache2` are listed using
    the `ls` command. Further, the `--rm` option of the `docker run` subcommand is
    used to remove the container once it is done executing the `ls` command:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用临时容器列出了Apache2 HTTP服务存储的文件。这个临时容器是通过从`log_vol`挂载`/var/log/apache2`数据卷而产生的，并且使用`ls`命令列出了`/var/log/apache2`中的文件。此外，`docker
    run`子命令的`--rm`选项用于在执行完`ls`命令后删除容器：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, the error log produced by the Apache2 HTTP service is accessed using
    the `tail` command, as highlighted in the following command:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过使用`tail`命令访问Apache2 HTTP服务生成的错误日志，如下命令所示：
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Avoiding common pitfalls
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免常见陷阱
- en: Till now, we discussed how effectively data volumes can be used to share data
    between the Docker host and the containers as well as between containers. Data
    sharing using data volumes is turning out to be a very powerful and essential
    tool in the Docker paradigm. However, it does carry a few pitfalls that are to
    be carefully identified and eliminated. In this section, we make an attempt to
    list out a few common issues associated with data sharing and the ways and means
    to overcome them.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了如何有效地使用数据卷在Docker主机和容器之间以及容器之间共享数据。使用数据卷进行数据共享正在成为Docker范式中非常强大和必不可少的工具。然而，它确实存在一些需要仔细识别和消除的缺陷。在本节中，我们尝试列出与数据共享相关的一些常见问题以及克服这些问题的方法和手段。
- en: Directory leaks
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录泄漏
- en: 'Earlier in the data volume section, we learnt that the Docker engine automatically
    creates directories based on the `VOLUME` instruction in `Dockerfile` as well
    as the `-v` option of the `docker run` subcommand. We also understood that the
    Docker engine does not automatically delete these auto-generated directories in
    order to preserve the state of the application(s) run inside the container. We
    can force Docker to remove these directories using the `–v` option of the `docker
    rm` subcommand. This process of manual deletion poses two major challenges enumerated
    as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据卷部分，我们了解到Docker引擎会根据`Dockerfile`中的`VOLUME`指令以及`docker run`子命令的`-v`选项自动创建目录。我们也明白Docker引擎不会自动删除这些自动生成的目录，以保留容器内运行的应用程序的状态。我们可以使用`docker
    rm`子命令的`-v`选项强制Docker删除这些目录。手动删除的过程会带来以下两个主要挑战：
- en: '**Undeleted directories:** There could be scenarios where you may intentionally
    or unintentionally choose not to remove the generated directory while removing
    the container.'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**未删除的目录：** 可能会出现这样的情况，您可能有意或无意地选择不删除生成的目录，而删除容器。'
- en: '**Third-party images:** Quite often, we leverage third-party Docker images
    that could have been built with the `VOLUME` instruction. Likewise, we might also
    have our own Docker images with `VOLUME` inscribed in it. When we launch containers
    using such Docker images, the Docker engine will auto-generate the prescribed
    directories. Since we are not aware of the data volume creation, we may not call
    the `docker rm` subcommand with the -v option to delete the auto-generated directory.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**第三方镜像：** 我们经常利用第三方Docker镜像，这些镜像可能已经使用了`VOLUME`指令进行构建。同样，我们可能也有自己的Docker镜像，其中包含了`VOLUME`。当我们使用这些Docker镜像启动容器时，Docker引擎将自动生成指定的目录。由于我们不知道数据卷的创建，我们可能不会使用`-v`选项调用`docker
    rm`子命令来删除自动生成的目录。'
- en: 'In the previously mentioned scenarios, once the associated container is removed,
    there is no direct way to identify the directories whose containers were removed.
    Here are a few recommendations on how to avoid this pitfall:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面提到的情况中，一旦相关的容器被移除，就没有直接的方法来识别那些容器被移除的目录。以下是一些建议，可以避免这种问题：
- en: Always inspect the Docker images using the `docker inspect` subcommand and check
    whether any data volume is inscribed in the image or not.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终使用`docker inspect`子命令检查Docker镜像，查看镜像中是否有数据卷。
- en: Always run the `docker rm` subcommand with the `-v` option to remove any data
    volume (directory) created for the container. Even if the data volume is shared
    by multiple containers, it is still safe to run the `docker rm` subcommand with
    the `-v` option because the directory associated with the data volume will be
    deleted only when the last container sharing that data volume is removed.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终使用`docker rm`子命令的`-v`选项来删除为容器创建的任何数据卷（目录）。即使数据卷被多个容器共享，仍然可以安全地使用`docker rm`子命令的`-v`选项，因为只有当共享该数据卷的最后一个容器被移除时，与数据卷关联的目录才会被删除。
- en: For any reason, if you choose to preserve the auto-generated directory, you
    must keep a clear record so that you can remove them at a later point of time.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论出于何种原因，如果您选择保留自动生成的目录，您必须保留清晰的记录，以便以后可以删除它们。
- en: Implement an audit framework that will audit and find out the directories that
    do not have any container association.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施一个审计框架，用于审计并找出没有任何容器关联的目录。
- en: The undesirable effect of data volume
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据卷的不良影响
- en: As mentioned earlier, Docker enables us to etch data volumes in a Docker image
    using the `VOLUME` instruction during the build time. Nonetheless, the data volumes
    should never be used to store any data during the build time, otherwise it will
    result in an unwanted effect.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Docker允许我们在构建时使用`VOLUME`指令将数据卷刻录到Docker镜像中。然而，在构建过程中不应该使用数据卷来存储任何数据，否则会产生不良影响。
- en: 'In this section, we will demonstrate the undesirable effect of using the data
    volume during the build time by crafting a `Dockerfile`, and then showcase the
    implication by building this `Dockerfile`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过制作一个`Dockerfile`来演示在构建过程中使用数据卷的不良影响，然后通过构建这个`Dockerfile`来展示其影响：
- en: 'The following are the details of `Dockerfile`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Dockerfile`的详细信息：
- en: 'Build the image using `Ubuntu 14.04` as the base image:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Ubuntu 14.04`作为基础镜像构建镜像：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a `/MountPointDemo` data volume using the `VOLUME` instruction:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`VOLUME`指令创建一个`/MountPointDemo`数据卷：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create a file in the `/MountPointDemo` data volume using the `RUN` instruction:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`RUN`指令在`/MountPointDemo`数据卷中创建一个文件：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Display the file in the `/MountPointDemo` data volume using the `RUN` instruction:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`RUN`指令显示`/MountPointDemo`数据卷中的文件：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Proceed to build an image from this `Dockerfile` using the `docker build` subcommand,
    as shown here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用`docker build`子命令从这个`Dockerfile`构建一个镜像，如下所示：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding output of the `docker build` subcommand, you would have noticed
    that the build fails at step 3 because it cannot find the file created in step
    2\. Apparently, the file that was created in step 2 vanishes when it reaches step
    3\. This undesirable effect is due to the approach Docker uses to build its images.
    An understanding of the Docker image-building process would unravel the mystery.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在`docker build`子命令的先前输出中，您会注意到构建在第3步失败，因为它找不到在第2步创建的文件。显然，在第3步时创建的文件在第2步时消失了。这种不良影响是由Docker构建其镜像的方法造成的。了解Docker镜像构建过程将揭开这个谜团。
- en: 'In the build process, for every instruction in a `Dockerfile`, the following
    steps are followed:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，对于`Dockerfile`中的每个指令，按照以下步骤进行：
- en: Create a new container by translating the `Dockerfile` instruction to an equivalent
    `docker run` subcommand
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`Dockerfile`指令转换为等效的`docker run`子命令来创建一个新的容器
- en: Commit the newly-created container to an image
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的容器提交为镜像
- en: Repeat step 1 and step 2, by treating the newly-created image as the base image
    for step 1.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将新创建的镜像视为第1步的基础镜像，重复执行第1步和第2步。
- en: When a container is committed, it saves the container's filesystem and, deliberately,
    does not save the data volume's filesystem. Therefore, any data stored in the
    data volume will be lost in this process. So never use a data volume as storage
    during the build process.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器被提交时，它保存容器的文件系统，并故意不保存数据卷的文件系统。因此，在此过程中存储在数据卷中的任何数据都将丢失。因此，在构建过程中永远不要使用数据卷作为存储。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: For enterprise-scale distributed applications to be distinct in their operations
    and outputs, data is the most important instrument and ingredient. With IT containerization,
    the journey takes off in a brisk and bright fashion. IT as well as business software
    solutions are intelligently containerized through the smart leverage of the Docker
    engine. However, the original instigation is the need for a faster and flawless
    realization of application-aware Docker containers, and hence, the data is tightly
    coupled with the application within the container. However, this closeness brings
    in some real risks. If the application collapses, then the data is also gone.
    Also, multiple applications might depend on the same data and hence, data has
    to be shared across.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于企业规模的分布式应用来说，数据是其运营和产出中最重要的工具和成分。通过IT容器化，这个旅程以迅速和明亮的方式开始。通过巧妙利用Docker引擎，IT和业务软件解决方案都被智能地容器化。然而，最初的动机是更快速、无缺陷地实现应用感知的Docker容器，因此，数据与容器内的应用紧密耦合。然而，这种紧密性带来了一些真正的风险。如果应用程序崩溃，那么数据也会丢失。此外，多个应用程序可能依赖于相同的数据，因此数据必须进行共享。
- en: In this chapter, we discussed the capabilities of the Docker engine in facilitating
    the seamless data sharing between the Docker host and container as well as between
    containers. The data volume is being prescribed as the foundational building block
    for enabling data sharing among the constituents of the growing Docker ecosystem.
    In the next chapter, we will explain the concept behind the container orchestration,
    and see how this complicated aspect gets simplified through a few automated tools.
    Orchestration is indispensable for realizing composite containers.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Docker引擎在促进Docker主机和容器之间以及容器之间无缝数据共享方面的能力。数据卷被规定为实现不断增长的Docker生态系统中各组成部分之间数据共享的基础构件。在下一章中，我们将解释容器编排背后的概念，并看看如何通过一些自动化工具简化这个复杂的方面。编排对于实现复合容器至关重要。
