["```java\nif ( problem.size() > DEFAULT_SIZE) {\n    divideTasks();\n    executeTask();\n    taskResults=joinTasksResult();\n    return taskResults;\n} else {\n    taskResults=solveBasicProblem();\n    return taskResults;\n}\n```", "```java\n10000202,rabona:23.039285705435507,1979:8.09314752937111,argentina:7.953798614698405,la:5.440565539075689,argentine:4.058577338363469,editor:3.0401515284855267,spanish:2.9692083275217134,image_size:1.3701158713905104,narrator:1.1799670194306195,budget:0.286193223652206,starring:0.25519156764102785,cast:0.2540127604060545,writer:0.23904044207902764,distributor:0.20430284744786784,cinematography:0.182583823735518,music:0.1675671228903468,caption:0.14545085918028047,runtime:0.127767002869991,country:0.12493801913495534,producer:0.12321749670640451,director:0.11592975672109682,links:0.07925582303812376,image:0.07786973207561361,external:0.07764427108746134,released:0.07447174080087617,name:0.07214163435745059,infobox:0.06151153983466272,film:0.035415118094854446\n```", "```java\npublic class VocabularyLoader {\n\n    public static Map<String, Integer> load (Path path) throws IOException {\n        int index=0;\n        HashMap<String, Integer> vocIndex=new HashMap<String, Integer>();\n        try(BufferedReader reader = Files.newBufferedReader(path)){\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                vocIndex.put(line,index );\n                index++;\n            }\n        }\n        return vocIndex;\n\n    }\n}\n```", "```java\npublic boolean setCluster(DocumentCluster cluster) {\n    if (this.cluster == cluster) {\n        return false;\n    } else {\n        this.cluster = cluster;\n        return true;\n    }\n}\n```", "```java\npublic static Document[] load(Path path, Map<String, Integer> vocIndex) throws IOException{\n    List<Document> list = new ArrayList<Document>();\n    try(BufferedReader reader = Files.newBufferedReader(path)) {\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            Document item = processItem(line, vocIndex);\n            list.add(item);\n        }\n    }\n    Document[] ret = new Document[list.size()];\n    return list.toArray(ret);\n\n}\n```", "```java\nprivate static Document processItem(String line,Map<String, Integer> vocIndex) {\n\n    String[] tokens = line.split(\",\");\n    int size = tokens.length - 1;\n\n    Document document = new Document(tokens[0], size);\n    Word[] data = document.getData();\n\n    for (int i = 1; i < tokens.length; i++) {\n        String[] wordInfo = tokens[i].split(\":\");\n        Word word = new Word();\n        word.setIndex(vocIndex.get(wordInfo[0]));\n        word.setTfidf(Double.parseDouble(wordInfo[1]));\n        data[i - 1] = word;\n    }\n    Arrays.sort(data);\n    return document;\n}\n```", "```java\npublic class DistanceMeasurer {\n\n    public static double euclideanDistance(Word[] words, double[] centroid) {\n        double distance = 0;\n\n        int wordIndex = 0;\n        for (int i = 0; i < centroid.length; i++) {\n            if ((wordIndex < words.length) (words[wordIndex].getIndex() == i)) {\n                distance += Math.pow( (words[wordIndex].getTfidf() - centroid[i]), 2);\n                wordIndex++;\n            } else {\n                distance += centroid[i] * centroid[i];\n            }\n        }\n\n        return Math.sqrt(distance);\n    }\n}\n```", "```java\npublic void calculateCentroid() {\n\n    Arrays.fill(centroid, 0);\n\n    for (Document document : documents) {\n        Word vector[] = document.getData();\n\n        for (Word word : vector) {\n            centroid[word.getIndex()] += word.getTfidf();\n        }\n    }\n\n    for (int i = 0; i < centroid.length; i++) {\n        centroid[i] /= documents.size();\n    }\n}\n```", "```java\npublic void initialize(Random random) {\n    for (int i = 0; i < centroid.length; i++) {\n        centroid[i] = random.nextDouble();\n    }\n}\n```", "```java\npublic class SerialKMeans {\n\n    public static DocumentCluster[] calculate(Document[] documents, int clusterCount, int vocSize, int seed) {\n        DocumentCluster[] clusters = new DocumentCluster[clusterCount];\n\n        Random random = new Random(seed);\n        for (int i = 0; i < clusterCount; i++) {\n            clusters[i] = new DocumentCluster(vocSize);\n            clusters[i].initialize(random);\n        }\n```", "```java\n        boolean change = true;\n\n        int numSteps = 0;\n        while (change) {\n            change = assignment(clusters, documents);\n            update(clusters);\n            numSteps++;\n        }\n        System.out.println(\"Number of steps: \"+numSteps);\n        return clusters;\n    }\n```", "```java\nprivate static boolean assignment(DocumentCluster[] clusters, Document[] documents) {\n\n    boolean change = false;\n\n    for (DocumentCluster cluster : clusters) {\n        cluster.clearClusters();\n    }\n\n    int numChanges = 0;\n    for (Document document : documents) {\n        double distance = Double.MAX_VALUE;\n        DocumentCluster selectedCluster = null;\n        for (DocumentCluster cluster : clusters) {\n            double curDistance = DistanceMeasurer.euclideanDistance(document.getData(), cluster.getCentroid());\n            if (curDistance < distance) {\n                distance = curDistance;\n                selectedCluster = cluster;\n            }\n        }\n        selectedCluster.addDocument(document);\n        boolean result = document.setCluster(selectedCluster);\n        if (result)\n            numChanges++;\n    }\n    System.out.println(\"Number of Changes: \" + numChanges);\n    return numChanges > 0;\n}\n```", "```java\n    private static void update(DocumentCluster[] clusters) {\n        for (DocumentCluster cluster : clusters) {\n            cluster.calculateCentroid();\n        }\n\n    }\n\n}\n```", "```java\npublic class SerialMain {\n\n    public static void main(String[] args) {\n        Path pathVoc = Paths.get(\"data\", \"movies.words\");\n\n        Map<String, Integer> vocIndex=VocabularyLoader.load(pathVoc);\n        System.out.println(\"Voc Size: \"+vocIndex.size());\n\n        Path pathDocs = Paths.get(\"data\", \"movies.data\");\n        Document[] documents = DocumentLoader.load(pathDocs, vocIndex);\n        System.out.println(\"Document Size: \"+documents.length);\n```", "```java\n    if (args.length != 2) {\n        System.err.println(\"Please specify K and SEED\");\n        return;\n    }\n    int K = Integer.valueOf(args[0]);\n    int SEED = Integer.valueOf(args[1]);\n}\n```", "```java\n        Date start, end;\n        start=new Date();\n        DocumentCluster[] clusters = SerialKMeans.calculate(documents, K ,vocIndex.size(), SEED);\n        end=new Date();\n        System.out.println(\"K: \"+K+\"; SEED: \"+SEED);\n        System.out.println(\"Execution Time: \"+(end.getTime()- start.getTime()));\n        System.out.println(\n            Arrays.stream(clusters).map (DocumentCluster::getDocumentCount).sorted (Comparator.reverseOrder())\n                        .map(Object::toString).collect( Collectors.joining(\", \", \"Cluster sizes: \", \"\")));\n    }\n}\n```", "```java\nprotected void compute() {\n    if (end - start <= maxSize) {\n        for (int i = start; i < end; i++) {\n            ConcurrentDocument document = documents[i];\n            double distance = Double.MAX_VALUE;\n            ConcurrentDocumentCluster selectedCluster = null;\n            for (ConcurrentDocumentCluster cluster : clusters) {\n                double curDistance = DistanceMeasurer.euclideanDistance (document.getData(), cluster.getCentroid());\n                if (curDistance < distance) {\n                    distance = curDistance;\n                    selectedCluster = cluster;\n                }\n            }\n            selectedCluster.addDocument(document);\n            boolean result = document.setCluster(selectedCluster);\n            if (result) {\n                numChanges.incrementAndGet();\n            }\n\n        }\n```", "```java\n    } else {\n        int mid = (start + end) / 2;\n        AssignmentTask task1 = new AssignmentTask(clusters, documents, start, mid, numChanges, maxSize);\n        AssignmentTask task2 = new AssignmentTask(clusters, documents, mid, end, numChanges, maxSize);\n\n        invokeAll(task1, task2);\n    }\n}\n```", "```java\n@Override\nprotected void compute() {\n    if (end - start <= maxSize) {\n        for (int i = start; i < end; i++) {\n            ConcurrentDocumentCluster cluster = clusters[i];\n            cluster.calculateCentroid();\n        }\n```", "```java\n    } else {\n        int mid = (start + end) / 2;\n        UpdateTask task1 = new UpdateTask(clusters, start, mid, maxSize);\n        UpdateTask task2 = new UpdateTask(clusters, mid, end, maxSize);\n\n        invokeAll(task1, task2);\n    }\n}\n```", "```java\npublic class ConcurrentKMeans {\n\n    public static ConcurrentDocumentCluster[] calculate(ConcurrentDocument[] documents int numberCluster int vocSize, int seed, int maxSize) {\n        ConcurrentDocumentCluster[] clusters = new ConcurrentDocumentCluster[numberClusters];\n\n        Random random = new Random(seed);\n        for (int i = 0; i < numberClusters; i++) {\n            clusters[i] = new ConcurrentDocumentCluster(vocSize);\n            clusters[i].initialize(random);\n        }\n```", "```java\n        boolean change = true;\n        ForkJoinPool pool = new ForkJoinPool();\n\n        int numSteps = 0;\n        while (change) {\n            change = assignment(clusters, documents, maxSize, pool);\n            update(clusters, maxSize, pool);\n            numSteps++;\n        }\n        pool.shutdown();\n        System.out.println(\"Number of steps: \"+numSteps); return clusters;\n    }\n```", "```java\n    private static boolean assignment(ConcurrentDocumentCluster[] clusters, ConcurrentDocument[] documents, int maxSize, ForkJoinPool pool) {\n\n        boolean change = false;\n\n        for (ConcurrentDocumentCluster cluster : clusters) {\n            cluster.clearDocuments();\n        }\n```", "```java\n        AtomicInteger numChanges = new AtomicInteger(0);\n        AssignmentTask task = new AssignmentTask(clusters, documents, 0, documents.length, numChanges, maxSize);\n\n```", "```java\n        pool.execute(task);\n        task.join();\n```", "```java\n        System.out.println(\"Number of Changes: \" + numChanges);\n        return numChanges.get() > 0;\n    }\n```", "```java\n    private static void update(ConcurrentDocumentCluster[] clusters, int maxSize, ForkJoinPool pool) {\n        UpdateTask task = new UpdateTask(clusters, 0, clusters.length, maxSize, ForkJoinPool pool);\n         pool.execute(task);\n         task.join();\n    }\n}\n```", "```java\npublic class SerialSearch {\n\n    public static CensusData findAny (CensusData[] data, List<FilterData> filters) {\n        int index=0;\n        for (CensusData censusData : data) {\n            if (Filter.filter(censusData, filters)) {\n                System.out.println(\"Found: \"+index);\n                return censusData;\n            }\n            index++;\n        }\n\n        return null;\n    }\n```", "```java\n    public static List<CensusData> findAll (CensusData[] data, List<FilterData> filters) {\n        List<CensusData> results=new ArrayList<CensusData>();\n\n        for (CensusData censusData : data) {\n            if (Filter.filter(censusData, filters)) {\n                results.add(censusData);\n            }\n        }\n        return results;\n    }\n}\n```", "```java\npublic class SerialMain {\n    public static void main(String[] args) {\n        Path path = Paths.get(\"data\",\"census-income.data\");\n\n        CensusData data[]=CensusDataLoader.load(path);\n        System.out.println(\"Number of items: \"+data.length);\n\n        Date start, end;\n```", "```java\n        List<FilterData> filters=new ArrayList<>();\n        FilterData filter=new FilterData();\n        filter.setIdField(32);\n        filter.setValue(\"Dominican-Republic\");\n        filters.add(filter);\n        filter=new FilterData();\n        filter.setIdField(31);\n        filter.setValue(\"Dominican-Republic\");\n        filters.add(filter);\n        filter=new FilterData();\n        filter.setIdField(1);\n        filter.setValue(\"Not in universe\");\n        filters.add(filter);\n        filter=new FilterData();\n        filter.setIdField(14);\n        filter.setValue(\"Not in universe\");\n        filters.add(filter);\n        start=new Date();\n        CensusData result=SerialSearch.findAny(data, filters);\n        System.out.println(\"Test 1 - Result: \"+result.getReasonForUnemployment());\n        end=new Date();\n        System.out.println(\"Test 1- Execution Time: \"+(end.getTime()-start.getTime()));\n```", "```java\npublic class TaskManager {\n\n    private Set<RecursiveTask> tasks;\n    private AtomicBoolean cancelled;\n\n    public TaskManager() {\n        tasks = ConcurrentHashMap.newKeySet();\n        cancelled = new AtomicBoolean(false);\n    }\n```", "```java\n    public void addTask(RecursiveTask task) {\n        tasks.add(task);\n    }\n\n    public void cancelTasks(RecursiveTask sourceTask) {\n\n        if (cancelled.compareAndSet(false, true)) {\n            for (RecursiveTask task : tasks) {\n                if (task != sourceTask) {\n                    if(cancelled.get()) {\n                        task.cancel(true);\n                    } \n                    else {\n                        tasks.add(task);\n                    }\n                }\n            }\n        }\n    }\n\n    public void deleteTask(RecursiveTask task) {\n        tasks.remove(task);\n    }\n```", "```java\n    private CensusData[] data;\n    private int start, end, size;\n    private TaskManager manager;\n    private List<FilterData> filters;\n\n    public IndividualTask(CensusData[] data, int start, int end, TaskManager manager, int size, List<FilterData> filters) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n        this.manager = manager;\n        this.size = size;\n        this.filters = filters;\n    }\n    ```", "```java\nif (end - start <= size) {\n    for (int i = start; i < end && ! Thread.currentThread().isInterrupted(); i++) {\n        CensusData censusData = data[i];\n        if (Filter.filter(censusData, filters)) {\n            System.out.println(\"Found: \" + i);\n            manager.cancelTasks(this);\n            return censusData;\n            }\n        }\n        return null;\n    }\n```", "```java\n        } else {\n            int mid = (start + end) / 2;\n            IndividualTask task1 = new IndividualTask(data, start, mid, manager, size, filters);\n            IndividualTask task2 = new IndividualTask(data, mid, end, manager, size, filters);\n```", "```java\n            manager.addTask(task1);\n            manager.addTask(task2);\n            manager.deleteTask(this);\n```", "```java\n            task1.fork();\n            task2.fork();\n            task1.quietlyJoin();\n            task2.quietlyJoin();\n```", "```java\n            manager.deleteTask(task1);\n            manager.deleteTask(task2);\n```", "```java\n        try {\n            CensusData res = task1.join();\n            if (res != null)\n                return res;\n                manager.deleteTask(task1);\n        } catch (CancellationException ex) {\n        }\n        try {\n            CensusData res = task2.join();\n            if (res != null)\n                return res;\n            manager.deleteTask(task2);\n        } catch (CancellationException ex) {\n        }\n        return null;\n    }\n}\n```", "```java\n@Override\nprotected List<CensusData> compute() {\n    List<CensusData> ret = new ArrayList<CensusData>();\n    if (end - start <= size) {\n        for (int i = start; i < end; i++) {\n            CensusData censusData = data[i];\n            if (Filter.filter(censusData, filters)) {\n                ret.add(censusData);\n            }\n        }\n```", "```java\n        int mid = (start + end) / 2;\n        ListTask task1 = new ListTask(data, start, mid, manager, size, filters);\n        ListTask task2 = new ListTask(data, mid, end, manager, size, filters);\n```", "```java\n        manager.addTask(task1);\n        manager.addTask(task2);\n        manager.deleteTask(this);\n```", "```java\n        task1.fork();\n        task2.fork();\n        task2.quietlyJoin();\n        task1.quietlyJoin();\n```", "```java\n        manager.deleteTask(task1);\n        manager.deleteTask(task2);\n```", "```java\n   try {\n    List<CensusData> tmp = task1.join();\n    if (tmp != null)\n     ret.addAll(tmp);\n    manager.deleteTask(task1);\n   } catch (CancellationException ex) {\n   }\n   try {\n    List<CensusData> tmp = task2.join();\n    if (tmp != null)\n     ret.addAll(tmp);\n    manager.deleteTask(task2);\n   } catch (CancellationException ex) {\n   }\n```", "```java\npublic class ConcurrentSearch {\n\n    public static CensusData findAny (CensusData[] data, List<FilterData> filters, int size) {\n        TaskManager manager=new TaskManager();\n        IndividualTask task=new IndividualTask(data, 0, data.length, manager, size, filters);\n        ForkJoinPool.commonPool().execute(task);\n        try {\n            CensusData result=task.join();\n            if (result!=null) {\n                System.out.println(\"Find Any Result: \"+result.getCitizenship());\n            return result;\n        } catch (Exception e) {\n            System.err.println(\"findAny has finished with an error: \"+task.getException().getMessage());\n        }\n\n        return null;\n    }\n```", "```java\n    public static CensusData[] findAll (CensusData[] data, List<FilterData> filters, int size) {\n        List<CensusData> results;\n        TaskManager manager=new TaskManager();\n        ListTask task=new ListTask(data,0,data.length,manager, size,filters);\n        ForkJoinPool.commonPool().execute(task);\n        try {\n            results=task.join();\n\n            return results;\n        } catch (Exception e) {\n            System.err.println(\"findAny has finished with an error: \" + task.getException().getMessage());\n        }\n        return null;\n    }\n```", "```java\n    public int compareTo(AmazonMetaData other) {\n        return Long.compare(this.getSalesrank(), other.getSalesrank());\n    }\n```", "```java\npublic void mergeSort (Comparable data[], int start, int end) {\n    if (end-start < 2) { \n        return;\n    }\n    int middle = (end+start)>>>1;\n    mergeSort(data,start,middle);\n    mergeSort(data,middle,end);\n    merge(data,start,middle,end);\n}\n```", "```java\n    private void merge(Comparable[] data, int start, int middle, int end) {\n        int length=end-start+1;\n        Comparable[] tmp=new Comparable[length];\n        int i, j, index;\n        i=start;\n        j=middle;\n        index=0;\n        while ((i<middle) && (j<end)) {\n            if (data[i].compareTo(data[j])<=0) {\n                tmp[index]=data[i];\n                i++;\n            } else {\n                tmp[index]=data[j];\n                j++;\n            }\n            index++;\n        }\n\n        while (i<middle) {\n            tmp[index]=data[i];\n            i++;\n            index++;\n        }\n\n        while (j<end) {\n            tmp[index]=data[j];\n            j++;\n            index++;\n        }\n\n        for (index=0; index < (end-start); index++) {\n            data[index+start]=tmp[index];\n        }\n    }\n}\n```", "```java\npublic class SerialMetaData {\n\n    public static void main(String[] args) {\n    for (int j=0; j<10; j++) {\n        Path path = Paths.get(\"data\",\"amazon-meta.csv\");\n\n        AmazonMetaData[] data = AmazonMetaDataLoader.load(path);\n        AmazonMetaData data2[] = data.clone();\n```", "```java\n        Date start, end;\n\n        start = new Date();\n        Arrays.sort(data);\n        end = new Date();\n        System.out.println(\"Execution Time Java Arrays.sort(): \" + (end.getTime() - start.getTime()));\n```", "```java\n        SerialMergeSort mySorter = new SerialMergeSort();\n        start = new Date();\n        mySorter.mergeSort(data2, 0, data2.length);\n        end = new Date();\n        System.out.println(\"Execution Time Java SerialMergeSort: \" + (end.getTime() - start.getTime()));\n```", "```java\n        for (int i = 0; i < data.length; i++) {\n            if (data[i].compareTo(data2[i]) != 0) {\n                System.err.println(\"There's a difference is position \" + i);\n                System.exit(-1);\n            }\n        }\n        System.out.println(\"Both arrays are equal\");\n    }\n}\n}\n```", "```java\npublic class MergeSortTask extends CountedCompleter<Void> {\n\n    private Comparable[] data;\n    private int start, end;\n    private int middle;\n\n    public MergeSortTask(Comparable[] data, int start, int end,\n            MergeSortTask parent) {\n        super(parent);\n\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n```", "```java\n    @Override\n    public void compute() {\n        if (end - start >= 1024) {\n                middle = (end+start)>>>1;\n            MergeSortTask task1 = new MergeSortTask(data, start, middle, this);\n            MergeSortTask task2 = new MergeSortTask(data, middle, end, this);\n            addToPendingCount(1);\n            task1.fork();\n            task2.fork();\n        } else {\n            new SerialMergeSort().mergeSort(data, start, end);\n            tryComplete();\n        }\n```", "```java\n    @Override\n    public void onCompletion(CountedCompleter<?> caller) {\n        if (middle==0) {\n            return;\n        }\n        int length = end - start + 1;\n        Comparable tmp[] = new Comparable[length];\n        int i, j, index;\n        i = start;\n        j = middle;\n        index = 0;\n        while ((i < middle) && (j < end)) {\n            if (data[i].compareTo(data[j]) <= 0) {\n                tmp[index] = data[i];\n                i++;\n            } else {\n                tmp[index] = data[j];\n                j++;\n            }\n            index++;\n        }\n        while (i < middle) {\n            tmp[index] = data[i];\n            i++;\n            index++;\n        }\n        while (j < end) {\n            tmp[index] = data[j];\n            j++;\n            index++;\n        }\n        for (index = 0; index < (end - start); index++) {\n            data[index + start] = tmp[index];\n        }\n\n    }\n```", "```java\npublic class ConcurrentMergeSort {\n\n    public void mergeSort (Comparable data[], int start, int end) {\n\n        MergeSortTask task=new MergeSortTask(data, start, end,null);\n        ForkJoinPool.commonPool().invoke(task);\n\n    }\n}\n```", "```java\nif ( problem.size() > DEFAULT_SIZE) {\n    childTask1=new Task();\n    childTask2=new Task();\n    childTask1.fork();\n    childTask2.fork();\n    childTaskResults1=childTask1.join();\n    childTaskResults2=childTask2.join();\n    taskResults=makeResults(childTaskResults1, childTaskResults2);\n    return taskResults;\n} else {\n    taskResults=solveBasicProblem();\n    return taskResults;\n}\n```"]