- en: Chapter 2. Evolution of C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。C#的演变
- en: In this chapter, we look back at the entire history of C#, leading up to the
    latest version. We will not be able to cover everything, but we will touch on
    the major features, especially the ones which are historically relevant. Each
    release brought unique features that would serve as the building blocks for innovations
    in versions yet to come.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们回顾了整个C#的历史，直到最新版本。我们可能无法涵盖所有内容，但我们将涉及主要特性，特别是那些在历史上具有重要意义的特性。每个版本都带来了独特的功能，这些功能将成为未来版本创新的基石。
- en: C# 1.0 – in the beginning
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 1.0 - 起初
- en: 'When C# was introduced, Microsoft wanted to take the best features of many
    other languages and runtimes. It was an object oriented language, with a runtime
    that actively manages memory for you. Some of the features of this language (and
    framework) are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当引入C#时，微软希望借鉴许多其他语言和运行时的最佳特性。它是一种面向对象的语言，具有主动管理内存的运行时。这种语言（和框架）的一些特性包括：
- en: Object oriented
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象
- en: Managed memory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管内存
- en: Rich base class library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丰富的基类库
- en: Common Language Runtime
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共语言运行时
- en: Type safety
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型安全
- en: Regardless of your technology background, there was something in C# that you
    could relate to.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您的技术背景如何，C#中都有一些您可以相关的东西。
- en: Runtime
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时
- en: It is impossible to talk about C#, without first talking about the runtime,
    called the **Common Language Runtime** (**CLR**). One of the major underpinnings
    of the CLR was the ability to interoperate with multiple languages, which meant
    that you would be able to write your program in a number of different languages,
    and it would run on the same runtime. This interoperability was accomplished by
    agreeing to a common set of data types, referred to as the **common type system**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 谈论C#时不可能不先谈论运行时，称为**公共语言运行时**（**CLR**）。CLR的一个主要基础是能够与多种语言进行互操作，这意味着您可以使用多种不同的语言编写程序，并且它将在相同的运行时上运行。这种互操作性是通过同意一组共同的数据类型来实现的，称为**公共类型系统**。
- en: Before the .NET Framework, there was really no clear mechanism for different
    languages to talk to each other. A string in one environment may not match the
    concept of a string in another language and would they be null terminated? Are
    they encoded in ASCII? How is that number represented? There was simply no way
    to know, because each language did its own thing. Of course people tried to come
    up with solutions to this problem.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Framework之前，不同语言之间没有清晰的机制进行交流。一个环境中的字符串可能与另一种语言中的字符串概念不匹配，它们是否以空字符结尾？它们是否以ASCII编码？数字如何表示？没有办法知道，因为每种语言都有自己的特点。当然，人们试图想出解决这个问题的办法。
- en: In the Windows world, the most well-known solution was to use the **Component
    Object Model** (**COM**), which used a type library to describe the types contained
    therein. By exporting this type library, a program could talk to other processes
    that may or may not have been written using another technology, because you were
    sharing details about how to communicate. However this was not without complexity,
    as anyone who wrote COM libraries using Visual Basic 6 could tell you. Not only
    was the process generally somewhat opaque because the tool abstracted out the
    underlying technology, but deployment was a nightmare. There was even a well-known
    phrase for working with it, DLL Hell.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows世界中，最著名的解决方案是使用**组件对象模型**（**COM**），它使用类型库来描述其中包含的类型。通过导出此类型库，程序可以与可能使用另一种技术编写的其他进程进行通信，因为您共享了如何通信的细节。然而，这并不是没有复杂性的，因为任何使用Visual
    Basic 6编写COM库的人都可以告诉您。不仅是因为工具抽象了底层技术，过程通常相当不透明，而且部署是一场噩梦。甚至有一个为处理它而知名的短语，DLL地狱。
- en: The .NET Framework was, in part, a response to this problem. It introduces the
    common type system into the picture, which are rules that every language running
    on the CLR needs to adhere to, including common data types such as strings and
    numeric types, the way object inheritance works, and type visibility.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework在某种程度上是对这个问题的回应。它引入了公共类型系统的概念，这些规则是CLR上运行的每种语言都需要遵守的规则，包括常见的数据类型，如字符串和数字类型，对象继承的方式以及类型可见性。
- en: For maximum flexibility, instead of compiling directly to native binary code,
    an intermediate representation of program code is used as the actual binary image,
    which is distributed and executed, called **MSIL** . This MSIL is then compiled
    the first time you run the program, so that optimizations can be put in place
    for the specific processor architecture that the program is being run on (the
    **Just-In-Time** (**JIT**) compiler). This means that a program that runs on the
    server and on a desktop could have different performance characteristics based
    on the hardware. In the past, you would have had to compile two different versions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大的灵活性，不直接编译成本机二进制代码，而是使用程序代码的中间表示作为实际的二进制映像，该映像被分发和执行，称为**MSIL**。然后第一次运行程序时编译此MSIL，以便为正在运行的特定处理器架构放置优化（**即时**（**JIT**）编译器）。这意味着在服务器和桌面上运行的程序可能具有不同的性能特征，这取决于硬件。在过去，您将不得不编译两个不同的版本。
- en: '![Runtime](img/6761EN_02_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Runtime](img/6761EN_02_01.jpg)'
- en: 'Another benefit of inherent, multilingual support, is that it served as a migration
    strategy. A number of different languages came out at the same time as C#. Companies
    that had an existing codebase in various languages could easily convert their
    program to a .NET friendly version, which was CLR compatible, and subsequently
    use it from other .NET languages such as C#. Some of the languages include the
    following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 固有的多语言支持的另一个好处是它作为迁移策略。与C#同时推出了许多不同的语言。拥有现有代码库的公司可以轻松地将其程序转换为与.NET兼容的版本，该版本与CLR兼容，并随后可以从其他.NET语言（如C#）中使用。其中一些语言包括以下内容：
- en: '**VB.NET**: This is the natural successor to the popular Visual Basic 6.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VB.NET**：这是流行的Visual Basic 6的自然继承者。'
- en: '**J#**: This is a version of the Java language for .NET.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**J#**：这是用于.NET的Java语言的一个版本。'
- en: '**Managed extensions for C++**: With a flag, and a few new keywords and syntax,
    you could take an existing C++ application, and compile it to a version compatible
    with the CLR.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C++的托管扩展**：通过一个标志，以及一些新的关键字和语法，你可以将现有的C++应用程序编译成与CLR兼容的版本。'
- en: While a number of these languages shipped, and were pitched as fully supported,
    these days the only ones that really remain of the original languages that shipped
    are VB.Net and C#, and to a lesser degree, C++/CLI. Many new languages such as
    F#, IronPython, and IronRuby have sprung up on the CLR over the years, and they
    remain active in development, with vibrant communities.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多这些语言都已经发布，并且被宣传为得到充分支持，但如今真正留存下来的只有VB.Net和C#，而C++/CLI则略有些。许多新的语言，如F#、IronPython和IronRuby，多年来都在CLR上涌现，并且它们仍然在开发中，拥有活跃的社区。
- en: Memory management
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: The Common Language Runtime provides a **garbage collector** , which means that
    memory will be collected automatically when an object is no longer referenced
    by other objects. This was not a new concept of course; many languages such as
    JavaScript and Visual Basic support garbage collection. Unmanaged languages, on
    the other hand, let you manually allocate memory on the heap if you so choose.
    And although this ability gives you way more power when it comes to the kinds
    of low-level solutions you can implement, it also gives you more opportunities
    to make mistakes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 公共语言运行时提供了**垃圾收集器**，这意味着当一个对象不再被其他对象引用时，内存将被自动回收。当然，这并不是一个新概念；许多语言，如JavaScript和Visual
    Basic都支持垃圾收集。另一方面，非托管语言允许你手动在堆上分配内存。虽然这种能力在实现低级解决方案时给了你更多的权力，但也给了你更多犯错误的机会。
- en: 'The following are the two kinds of data types that the CLR allows for:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是CLR允许的两种数据类型：
- en: '**Value types**: These data types are created using the `struct` keyword'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值类型**：这些数据类型是使用`struct`关键字创建的'
- en: '**Reference types**: These data types are created using the `class` keyword'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用类型**：这些数据类型是使用`class`关键字创建的'
- en: Every primitive data type in C#, such as `int` and `float`, is `struct`, while
    every class is a reference type. There are some semantics around how these types
    are allocated internally (stack versus heap), but for day-to-day use those differences
    are usually not important.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的每种原始数据类型，如`int`和`float`，都是`struct`，而每个类都是引用类型。关于这些类型在内部分配的语义学有一些细微差别（栈与堆），但在日常使用中，这些差异通常并不重要。
- en: 'You can of course create your own custom types of both kinds. For example,
    the following is a simple value type:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然你也可以创建自己的自定义类型。例如，以下是一个简单的值类型：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'By changing a single keyword, you can change this object to a reference type
    as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改一个关键字，你可以将这个对象更改为引用类型，如下所示：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are two major differences between `struct` instances and `class` instances.
    Firstly, a `struct` instance cannot inherit, or be inherited from. The `class`
    instances, however, are the primary vehicles for creating object oriented hierarchies.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct`实例和`class`实例之间有两个主要区别。首先，`struct`实例不能继承，也不能被继承。而`class`实例则是创建面向对象层次结构的主要工具。'
- en: 'Secondly, `class` instances participate in the garbage collection process,
    while `struct` instances do not, at least not directly. Many discussions on the
    Internet tend to generalize the memory allocation strategy of value types as being
    allocated on the stack, while reference types are allocated on the heap (see the
    following diagram), but that is not the whole story:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`class`实例参与垃圾回收过程，而`struct`实例则不参与，至少不是直接参与。互联网上的许多讨论往往将值类型的内存分配策略概括为在栈上分配，而引用类型在堆上分配（见下图），但这并不是全部故事：
- en: '![Memory management](img/6761EN_02_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![内存管理](img/6761EN_02_02.jpg)'
- en: There is generally some truth to this, because when you instantiate `class`
    in a method, it will always go on the heap, while creating a value type such as
    an `int` instance will go on the stack. But if the value type is wrapped in a
    reference type, for example, when the value type is a field in a `class` instance,
    then it will be allocated on the heap along with the rest of the class data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这种说法总是有一些道理的，因为当你在一个方法中实例化`class`时，它总是会在堆上，而创建一个值类型，比如`int`实例会在栈上。但是如果值类型被包装在引用类型中，例如，当值类型是`class`实例中的一个字段时，它将与类数据的其余部分一起分配在堆上。
- en: Syntax features
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法特性
- en: The name C# is a cheeky reference to the C language, just as C++ was C (plus
    some stuff), C# too is largely similar in syntax to C and C++, though with some
    obvious changes. Unlike C, C# is an object oriented language, but with a few interesting
    features that make it easier and more efficient to write than other object oriented
    languages.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: C#这个名字是对C语言的一个俏皮的引用，就像C++是C（加上一些东西），C#在语法上也与C和C++大致相似，尽管有一些明显的变化。与C不同，C#是一种面向对象的语言，但它有一些有趣的特性，使得它比其他面向对象的语言更容易和更高效。
- en: 'One example of this is the property getters and setters. In other languages,
    if you want to control how you expose access and modifications to the data of
    a `class` instance, you would have to make the field private so an outsider could
    not change it directly. Then you would make two methods, one prefixed with `get`
    to retrieve the value, and one prefixed with `set` to the value. In C#, the compiler
    takes care of generating those method pairs for you. Look at the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个例子是属性的getter和setter。在其他语言中，如果你想控制如何公开对`class`实例的数据的访问和修改，你必须将字段设置为私有，这样外部人员就不能直接更改它。然后你会创建两个方法，一个以`get`为前缀来检索值，另一个以`set`为前缀来设置值。在C#中，编译器会为你生成这些方法对。看下面的代码：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Another interesting innovation is how C# provides first class event support.
    In other languages such as Java, they approximated events by, for example, having
    a method called `setOnClickListener(OnClickListener listener)` . To use it, you
    have to define a new class that implements the `OnClickListener` interface and
    pass it in. This technique definitely works, but can be kind of verbose. With
    C#, you can define what is called a **delegate** to represent a method as a proper,
    self-contained object as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的创新是C#如何提供一流的事件支持。在其他语言中，比如Java，他们通过，例如，有一个名为`setOnClickListener(OnClickListener
    listener)`的方法来近似事件。要使用它，你必须定义一个实现`OnClickListener`接口的新类并将其传递进去。这种技术确实有效，但可能有点冗长。在C#中，你可以定义所谓的**delegate**来表示一个方法作为一个适当的、独立的对象，如下所示：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This `delegate` can then be used as an event on a class as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个`delegate`可以作为类的事件使用，如下所示：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To register for notification when the event is raised, you can just create
    the delegate and use the `+=` syntax to add it to the delegate list as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册在事件被触发时收到通知，你只需创建委托并使用`+=`语法将其添加到委托列表中，如下所示：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The language will automatically add the delegate to a list of delegates, which
    will be notified whenever the event is raised. In Java, that kind of behavior
    would have to be implemented manually.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 语言将自动将委托添加到委托列表中，每当事件被触发时，委托列表都会收到通知。在Java中，这种行为必须手动实现。
- en: There were many other interesting syntactic features when C# was launched, such
    as the way exceptions worked, the using statement, and others. But in the interest
    of brevity, let's move on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当C#推出时，还有许多其他有趣的语法特性，比如异常的工作方式、使用语句等。但为了简洁起见，让我们继续。
- en: Base Class Library
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基类库
- en: 'By default, C# comes with a rich and vast framework called the **Base Class
    Library** (**BCL**). The BCL provides a wide array of functionality as shown in
    the next diagram:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，C#带有一个称为**基类库**（**BCL**）的丰富而广泛的框架。BCL提供了各种功能，如下图所示：
- en: '![Base Class Library](img/6761EN_02_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![基类库](img/6761EN_02_03.jpg)'
- en: The diagram shows a few of the namespaces that are included in the base class
    library (emphasis on a few). While there are a large number of other namespaces,
    these are a few of the most important ones, which provide the infrastructure for
    many of the features and libraries that have been released by Microsoft and third
    parties.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了包含在基类库中的一些命名空间（重点是一些）。虽然还有许多其他命名空间，但这些是一些最重要的命名空间之一，为许多由微软和第三方发布的功能和库提供了基础设施。
- en: One of the data structure types you discover when learning how to program is
    the one that deals with collection of information. Typically, you learn to write
    most of the programs and algorithms using arrays. With an array though, you have
    to know the size of the collection ahead of time. The `System.Collections` namespace
    comes with a set of collection of data structures that make it easy to handle
    an unknown amount of data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习编程时，你会发现处理信息集合的数据结构类型之一。通常，你会学会使用数组来编写大多数程序和算法。不过，使用数组时，你必须提前知道集合的大小。`System.Collections`命名空间提供了一组处理未知数量数据的数据结构集合，使其易于处理。
- en: 'In the very first program I ever wrote (described briefly in the previous chapter),
    I used an array that was pre-allocated. To keep things simple, the array was allocated
    with an arbitrarily large number of elements so that I would not run out of spaces
    in the array. Of course, that would never work in a non-trivial program written
    professionally because you will either run out of space if you encounter a larger
    than expected set of data, or it will be wasteful of memory. Here, we can use
    one of the most basic collection types, the `ArrayList` collection, to overcome
    that problem, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我写的第一个程序中（在上一章中简要描述），我使用了一个预先分配的数组。为了保持简单，数组是用任意大的元素数量分配的，这样我就不会在数组中用完空间。当然，在专业编写的非平凡程序中，这是行不通的，因为如果遇到比预期更大的数据集，你要么会用完空间，要么会浪费内存。在这里，我们可以使用最基本的集合类型之一，`ArrayList`集合，来解决这个问题，如下所示：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, an instance of the `ArrayList` collection was created, but no
    size was specified. This is because collection types manage their sizes internally.
    This abstraction relieves you of the size responsibility so you can worry about
    bigger things.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，创建了一个`ArrayList`集合的实例，但没有指定大小。这是因为集合类型在内部管理它们的大小。这种抽象解除了你对大小的责任，所以你可以担心更重要的事情。
- en: 'Some of the other collection types that are available are as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可用的一些集合类型如下：
- en: '`HashTable`: This type allows you to provide a lookup key and a value. It is
    often used to create very simple in-memory databases.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HashTable`：这种类型允许你提供查找键和值。它通常用于创建非常简单的内存数据库。'
- en: '`Stack`: This is a first in, last out data structure.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stack`：这是一种后进先出的数据结构。'
- en: '`Queue`: This is a first in, first out data structure.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Queue`：这是一种先进先出的数据结构。'
- en: Looking at the concrete collection, classes do not really tell the whole story
    though. If you follow the inheritance chain, you will notice that every collection
    implements an interface called `IEnumerable`. This will come to be one of the
    most important interfaces in the whole language so getting familiar with it early
    on is important.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 查看具体的集合类并不能完全说明问题。如果你跟踪继承链，你会注意到每个集合都实现了一个名为`IEnumerable`的接口。这将成为整个语言中最重要的接口之一，所以早期熟悉它是很重要的。
- en: '`IEnumerable`, and the sister class, `IEnumerator` , abstract the concept of
    enumeration over a collection of items. You will always see these interfaces used
    in tandem, and they are very simple. You can see this as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable`和它的姊妹类`IEnumerator`抽象了对项目集合的枚举概念。你总是会看到这些接口一起使用，它们非常简单。你可以看到这一点，如下所示：'
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At first glance, you may wonder why collections implement `IEnumerable`, which
    has a single method that returns an `IEnumerator`, rather than just implementing
    `IEnumerator` directly. The enumerator is responsible for enumerating through
    a collection. But there is a good reason for this. If the collection itself was
    the enumerator, then you would not be able to iterate over the same collection
    concurrently. So each call to `GetEnumerator()` will generally return a separate
    enumerator, though that is by no means a requirement.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，你可能会想为什么集合实现`IEnumerable`，它有一个返回`IEnumerator`的方法，而不直接实现`IEnumerator`。枚举器负责枚举集合。但这样做是有原因的。如果集合本身是枚举器，那么你就无法同时迭代同一个集合。因此，每次调用`GetEnumerator()`通常会返回一个单独的枚举器，尽管这并不是必须的。
- en: 'Although the interface is very simple, it turns out that having this abstraction
    is very powerful. C# implements a nice shorthand syntax for iterating over a collection
    without having to do the regular `for` loop using an index variable that you have
    to pass in. This is explained in the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管接口非常简单，但事实证明，拥有这种抽象是非常强大的。C#实现了一个很好的简写语法，可以在不使用索引变量的情况下迭代集合。这在下面的代码中有解释：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `foreach` syntax works because it is shorthand for the code the compiler
    will actually generate. It will generate code to interact with the enumerable
    behind the scenes. So the loop in the previous example will look like the compiled
    MSIL, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`语法之所以有效，是因为它是编译器实际生成的代码的简写。它将生成与枚举器的交互的代码。因此，前面示例中的循环将看起来像编译后的MSIL，如下所示：'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once again, we have an example of the C# compiler generating code, that is different
    from what you have actually written. This will be the key in the evolution of
    C# to make the common patterns of code that you write easier to express, allowing
    you to be more efficient and productive.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们有一个例子，C#编译器生成的代码与你实际编写的代码不同。这将是C#演变的关键，使你更容易表达你编写的常见代码模式，从而让你更高效、更有生产力。
- en: To some developers, C# was a cheap imitation of Java when it first came out.
    But to developers like me, it was a breath of fresh air, offering performance
    improvements over interpreted languages such as VBScript, extra safety and simplicity
    from languages such as C++, and more low level power than languages such as JavaScript.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些开发人员来说，C#在刚开始时是Java的廉价模仿。但对于像我这样的开发人员来说，它是一股清新的空气，提供了比VBScript等解释性语言更好的性能改进，比C++等语言更多的安全性和简单性，以及比JavaScript等语言更多的低级功能。
- en: C# 2.0
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 2.0
- en: The first major update of the C# language, Runtime, and .NET Framework was a
    big one. This release focused on making the language more concise and easier to
    write.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: C#语言、Runtime和.NET Framework的第一个重大更新是一个大事件。这个版本的重点是使语言更简洁、更容易编写。
- en: Syntax updates
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法更新
- en: 'The first update added a small capability to the property syntax. In 1.0, if
    you wanted a read only property, your only choice was to exclude the setter, as
    follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个更新为属性语法添加了一个小功能。在1.0中，如果你想要一个只读属性，你的唯一选择就是排除setter，如下所示：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'All internal logic had to interact with the `_value` member directly. In many
    cases this was fine, except for cases where you needed to have some sort of logic
    governing when and how you were allowed to change that value. Or similarly, if
    you needed to raise an event, you would have to create a private method as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内部逻辑都必须直接与`_value`成员交互。在许多情况下这是可以的，除了需要有一些逻辑来控制何时以及如何允许更改该值的情况。或者类似地，如果需要触发事件，你必须创建一个私有方法，如下所示：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Well no more in C# 2.0, as you can now create a private setter as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 2.0中不再需要这样做，因为现在可以创建一个私有的setter，如下所示：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A small feature, but it increased consistency because separate getter and setter
    methods were one of the things that C# tried to get rid of from the first version.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小功能，但它增加了一致性，因为分开的getter和setter方法是C#试图摆脱的第一个版本的东西之一。
- en: 'Another interesting addition is that of **nullable** types. With value types,
    the compiler will not allow you to set them to a null value, however, you now
    have a new key character that you can use to signify a nullable value type as
    follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的补充是**可空**类型。对于值类型，编译器不允许你将它们设置为null值，然而，现在你有一个新的关键字符，可以用来表示可空值类型，如下所示：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Just by adding the question mark, the value type is marked as nullable, and
    you can use the `.HasValue` and `.Value` properties to make decisions on what
    to do in the case of null.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 只需添加问号，值类型就被标记为可空，你可以使用`.HasValue`和`.Value`属性来决定在空值的情况下该做什么。
- en: Anonymous methods
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名方法
- en: 'Delegates are a great addition to C# over other languages. They are the building
    blocks of the event systems. One drawback, however, in the way they were implemented
    in C# 1.0 is that they make reading code a bit more difficult, because the code
    that executes when the event is raised is actually written elsewhere. Continuing
    the trend of code simplification, **anonymous methods** let you write the code
    inline. For example, given the following delegate definition:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 委托是C#相对于其他语言的一个很好的补充。它们是事件系统的构建块。然而，C# 1.0中实现的一个缺点是，它们使得阅读代码变得更加困难，因为当事件被触发时执行的代码实际上是在其他地方编写的。继续简化代码的趋势，**匿名方法**让你可以内联编写代码。例如，给定以下委托定义：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can create an instance of the delegate using an anonymous method as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用匿名方法创建委托的实例，如下所示：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This code is inline, short, and easy to understand. It also allows you to use
    delegates much like first-class functions in other languages such as JavaScript.
    But it goes beyond simply being easier to read. If you wanted to pass a parameter
    to a delegate that did not accept a parameter in C# 1.0, you had to create a custom
    class to wrap both the method implementation and the stored value. This way, when
    the delegate is invoked (thus executing the target method), it has access to the
    value. Any early multi-threaded code was full of code like the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是内联的，简短且易于理解。它还允许您像JavaScript等其他语言中的一等函数一样使用委托。但它不仅仅是更容易阅读。如果您想要向不接受参数的委托传递参数，您必须创建一个自定义类来包装方法实现和存储的值。这样，当调用委托（从而执行目标方法）时，它就可以访问该值。任何早期的多线程代码都充满了以下代码：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This class accepts a value in the constructor and stores it in a private member.
    Then later when the delegate is invoked, the value can be used, as in this case
    using it to start a new thread. This is shown in the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类在构造函数中接受一个值并将其存储在一个私有成员中。然后稍后当调用委托时，该值可以被使用，就像在这种情况下使用它来启动一个新线程。这在以下代码中显示：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With anonymous delegates, the compiler can step in and greatly simplify the
    usage pattern mentioned previously as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用匿名委托，编译器可以介入并大大简化先前提到的使用模式：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This might look simple, but there is some serious compiler magic going on here.
    The compiler has analyzed the code, realized that the anonymous method requires
    the `value` variable in the method body, and automatically generated a class similar
    to the `CustomThreadStarter` that we would have had to create in C# 1.0\. The
    result is code that you can easily read because it is all there, right in context
    with the rest.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能很简单，但这里有一些严重的编译器魔法。编译器分析了代码，意识到匿名方法在方法体中需要`value`变量，并自动生成了一个类，类似于我们在C#
    1.0中必须创建的`CustomThreadStarter`。结果是您可以轻松阅读的代码，因为它就在那里，与其余部分上下文相关。
- en: Partial classes
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分类
- en: 'In C# 1.0, it was common practice to use code generators to automate things
    such as custom collections. When you wanted to add your own methods and properties
    to the generated code, you would generally have to inherit from the class, or
    in some cases, directly edit the generated file. This meant that you had to be
    very careful to avoid regenerating the code, or risk overwriting your custom logic.
    You will find a comment similar to the following one in many first generation
    tools:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 1.0中，使用代码生成器来自动化诸如自定义集合之类的事情是常见的做法。当您想要向生成的代码添加自己的方法和属性时，通常需要从该类继承，或者在某些情况下，直接编辑生成的文件。这意味着您必须非常小心，以避免重新生成代码，否则会有覆盖自定义逻辑的风险。您会在许多第一代工具中找到类似以下评论的注释：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'C# 2.0 adds an additional keyword to your arsenal, `partial`. With **partial**
    classes, you can break up your classes among multiple files. To see this in action,
    create the following class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: C# 2.0在您的工具库中添加了一个额外的关键字`partial`。使用**partial**类，您可以将类分解成多个文件。要查看这个过程，请创建以下类：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This represents the automatically generated code. Notice that the file contains
    `.generated` in the filename; this is a convention that was adopted, though is
    not necessary for this to work, it is just that both files are part of the same
    project. Then in a separate file, you can include the rest of the implementation
    as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了自动生成的代码。请注意，文件名中包含`.generated`；这是一种采用的约定，尽管这对于工作来说并非必需，只是这两个文件都是同一个项目的一部分。然后在另一个文件中，您可以包含其余的实现，如下所示：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All members would then be available on the resulting type at runtime, as the
    compiler takes care to stitch the class together. You are free to regenerate the
    first file at will, without the risk of overwriting your changes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后所有成员将在运行时对生成的类型可用，因为编译器会负责将类拼接在一起。您可以自由地随意重新生成第一个文件，而不必担心覆盖您的更改。
- en: Generics
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型
- en: The major feature addition of C# 2.0 is **generics**, which allows you to create
    classes that can be reused with multiple types of objects. In the past, this kind
    of programming could only be accomplished in two ways. You can use a common base
    class for the parameter, so that any object that inherits from that class can
    be passed in regardless of the concrete implementation. That works, sort of, but
    it becomes very limiting when you want to create a very general purpose data structure.
    The other method is really just a derivative of the first. Instead of using a
    base class of your own definition, go all the way up the inheritance tree and
    use `object` for your type parameter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: C# 2.0的主要特性增加是**泛型**，它允许您创建可以重复使用多种类型对象的类。过去，这种编程只能以两种方式实现。您可以使用参数的公共基类，以便从该类继承的任何对象都可以传递，而不管具体的实现方式如何。这种方法有点有效，但当您想要创建一个非常通用的数据结构时，它会变得非常有限。另一种方法实际上只是第一种方法的派生。而不是使用自己定义的基类，而是沿着继承树一直使用`object`作为类型参数。
- en: This works because all the types in .NET derive from `object`, so you can pass
    in anything. This is the method used by the original collection classes. But even
    this has problems, especially when it comes to passing in value types due to the
    effects of boxing. You also have to cast the type back out from object every single
    time.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为.NET中的所有类型都派生自`object`，因此您可以传入任何东西。这是原始集合类使用的方法。但即使这样也存在问题，特别是在传递值类型时，由于装箱的影响。您还必须每次都从对象中转换类型。
- en: 'Thankfully, all of these problems can be mitigated by using generics as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，所有这些问题都可以通过使用泛型来缓解：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this example, we have defined a **generic type parameter** called `T`. The
    actual name of the generic type parameter can be anything, `T` is just used as
    a convention. When you instantiate the `Message` class, you can specify the kind
    of object you want to store in the `Value` property using this syntax, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们定义了一个名为`T`的**泛型类型参数**。泛型类型参数的实际名称可以是任何名称，`T`只是一个约定的用法。当您实例化`Message`类时，可以使用以下语法指定要存储在`Value`属性中的对象的类型，如下所示：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So you can assign an integer to the field without worrying about performance,
    because the value will not be boxed. You also do not have to cast it when you
    want to use it, as you would if using object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以将整数分配给字段，而不必担心性能，因为该值不会被装箱。当您想要使用它时，您也不必进行转换，就像使用对象一样。
- en: 'Generics are super powerful, but they are not omnipotent. To highlight a key
    deficiency, we will go over one of the first things that just about every C# developer
    tried when 2.0 was first released—generic math. Developers of applications that
    are math heavy will likely be using a mathematical library for their domain. For
    example, game developers (or really, anyone doing anything that involves 2D or
    3D spatial calculations) will always need a good `Vector` structure as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型非常强大，但并非无所不能。为了突出一个关键的不足，我们将讨论几乎每个C#开发人员在2.0首次发布时尝试的第一件事情之一——泛型数学。数学密集型应用程序的开发人员可能会使用领域的数学库。例如，游戏开发人员（或者实际上是做任何涉及2D或3D空间计算的人）将始终需要一个良好的`Vector`结构，如下所示：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'But the problem is that it is using the `float` data type for calculations.
    If you wanted to generalize it and support other numeric types such as `int`,
    `double`, or `decimal`, what do you do? Upon first glance, you would think that
    you could use generics to support this scenario as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 但问题是它使用`float`数据类型进行计算。如果您想要将其泛化并支持其他数值类型，比如`int`、`double`或`decimal`，您该怎么办？乍一看，您可能会认为可以使用泛型来支持这种情况，如下所示：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Compiling this will result in an error, **Operator '+=' cannot be applied to
    operands of type 'T' and 'T'**. This is because, by default, only members from
    the `object` data type are available for the generic parameter, due to the fact
    that the compiler has no way of knowing what methods (and by extension, operations)
    are defined on the type you are using.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 编译将导致错误，**运算符'+='无法应用于类型'T'和'T'的操作数**。这是因为，默认情况下，由于编译器无法知道在使用的类型上定义了哪些方法（以及由此推断出的操作），因此仅`object`数据类型的成员可用于泛型参数。
- en: 'Thankfully, Microsoft anticipated this to some degree, and added something
    called **generic type constraints** . These constraints let you give the compiler
    a hint at what kind of types callers will be allowed to use, which in turn means
    that you can use the features that you constrain. For example, look at the following
    code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，微软在某种程度上预料到了这一点，并添加了一种称为**泛型类型约束**的东西。这些约束让您向编译器提示调用者将被允许使用的类型的种类，这反过来意味着您可以使用您约束的特性。例如，看看以下代码：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we have added a constraint that says that the type parameter `T` must
    be an `IEnumerable`. As a result, you can write the code and be safe in the knowledge
    that any caller that calls this method will only ever use a type that implements
    the `IEnumerable` interface as the type parameter. Some of the other parameter
    constraints you can use are as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个约束，即类型参数`T`必须是`IEnumerable`。因此，您可以编写代码，并确保任何调用此方法的调用者只会使用实现`IEnumerable`接口作为类型参数的类型。您可以使用的其他参数约束如下：
- en: '`class`: This says that the type parameter must be a reference type.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class`：这表示类型参数必须是引用类型。'
- en: '`struct`: This implies that only value types are allowed.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct`：这意味着只允许值类型。'
- en: '`new()`: There must be a public constructor without parameters on this type.
    It will allow you to use syntax like `T value = new T()` to create new instances
    of the type parameter. Otherwise, the only thing you can do is something like
    `T value = default(T)`, which will return null for reference types, and zero for
    numeric primitives.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new()`：此类型必须有一个无参数的公共构造函数。它将允许您使用类似`T value = new T()`的语法来创建类型参数的新实例。否则，您唯一能做的就是像`T
    value = default(T)`这样的事情，对于引用类型，它将返回null，对于数值原语，它将返回零。'
- en: '`<name of interface>`: This limits the type parameters to use the interface
    mentioned here, as shown with `IEnumerable` mentioned previously.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<接口名称>`：这限制了类型参数使用此处提到的接口，如前面提到的`IEnumerable`。'
- en: '`<name of class>`: Any type used with this constraint must be of this type,
    or inherit from this type at some point in the inheritance chain.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<类的名称>`：使用此约束的任何类型必须是此类型，或者在继承链中的某个时候继承自此类型。'
- en: Unfortunately, because numeric data structures are value types, they cannot
    inherit, and thus have no common type to use in a type constraint that will give
    you the mathematical operators needed to do math.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，因为数值数据结构是值类型，它们无法继承，因此没有通用类型可用于类型约束，以便为您提供执行数学运算所需的数学运算符。
- en: As a general rule of thumb, generics are most useful in "framework" style code,
    which is to say general infrastructure for your applications, or data structures
    such as collections. In fact, some great new collection types became available
    in C# 2.0.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，泛型在“框架”样式的代码中最有用，也就是说，对于应用程序的一般基础设施，或者诸如集合之类的数据结构。实际上，在C# 2.0中提供了一些很棒的新集合类型。
- en: Generic collections
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型集合
- en: 'Generics are perfect for collections because the collection itself doesn''t
    really have to interact with the objects that it contains; it just needs a place
    to put them. So with a collection, there are no constraints on the type parameter.
    All of the new generic collections can be found in the namespace as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型非常适合集合，因为集合本身实际上不必与其包含的对象进行交互；它只需要一个放置它们的地方。因此，在集合中，对类型参数没有约束。所有新的泛型集合都可以在以下命名空间中找到：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As we discussed earlier, the most basic collection type that was in C# 1.0
    was an `ArrayList` collection, which worked really well at the time. However,
    value types would be boxed as it used `object` as its payload type, and you had
    to cast the object out into your target object type every time you wanted to pull
    out a value. With generics, we now have `List<T>` as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的那样，C# 1.0 中最基本的集合类型是`ArrayList`集合，当时它的工作效果非常好。然而，由于它使用`object`作为其有效载荷类型，值类型将被装箱，并且每次想要取出一个值时，您都必须将对象转换为目标对象类型。有了泛型，我们现在有了`List<T>`如下：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The usage is practically identical to the `ArrayList` collection, but with
    the performance benefits of generics. Some of the other types available as generic
    classes are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方式与`ArrayList`集合几乎相同，但具有泛型的性能优势。一些其他可用的泛型类类型如下：
- en: '`Queue<T>`: This is the same as the non-generic `Queue`, **first in, first
    out** (**FIFO**).'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Queue<T>`：这与非泛型的`Queue`相同，**先进先出**（**FIFO**）。'
- en: '`Stack<T>`: There are no differences here from the non-generic version of the
    `Stack`, **last in, first out** (**LIFO**).'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stack<T>`：与非泛型版本的`Stack`没有区别，**后进先出**（**LIFO**）。'
- en: '`Dictionary<T, K>`: This takes the place of the `Hashtable` collection from
    C# 1.0\. It uses two generic parameters for the key and value of each dictionary
    item. This means that you can use a key other than a string.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dictionary<T, K>`：这取代了C# 1.0中的`Hashtable`集合。它使用两个泛型参数来表示每个字典项的键和值。这意味着您可以使用除字符串以外的键。'
- en: Iterator methods
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器方法
- en: 'Perhaps one of the more unique features to arrive in C# 2.0 was that of **iterator**
    methods. They are a way of having the compiler automatically generate a custom
    iteration over a sequence. That description is kind of abstract, admittedly, so
    the easiest way to explain it is with some code, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 也许在C# 2.0中出现的更独特的特性之一是**迭代器**方法。它们是一种让编译器自动生成对序列的自定义迭代的方法。这个描述有点抽象，不可否认，因此最容易解释的方法是通过一些代码，如下所示：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the previous method, you see a method that returns `IEnumerable<string>`.
    In the method body, however, there are simply four consecutive lines of code that
    use the `yield` keyword. This tells the compiler to generate a custom enumerator
    that breaks up the method into each individual part between the yields, so that
    it is executed when a caller enumerates the returned value. This is shown in the
    following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的方法中，您会看到一个返回`IEnumerable<string>`的方法。然而，在方法体中，只有四行连续的代码使用了`yield`关键字。这告诉编译器生成一个自定义的枚举器，将方法分解为每个`yield`之间的单个部分，以便在调用者枚举返回的值时执行。这在以下代码中显示：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There are a lot of different ways to approach and use iterators, but the highlight
    here is how the C# compiler is getting smarter in this release. It is able to
    take your code and expand it. This lets you write code at a higher level of abstraction,
    which is an ongoing theme in the evolution of C#.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的方法来处理和使用迭代器，但这里的重点是C#编译器在此版本中变得更加智能。它能够接受您的代码并扩展它。这使您能够以更高的抽象级别编写代码，这是C#演变中的一个持续主题。
- en: C# 3.0
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 3.0
- en: If you thought C# 2.0 was a big update, the 3.0 release was even bigger! It
    is difficult to do justice to it in a single chapter (let alone part of a chapter).
    So we are going to focus on the main features, especially as it relates to the
    evolution of C#.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为C# 2.0是一个重大更新，那么3.0版本的发布就更大了！在一个单独的章节（更不用说章节的一部分）中很难充分展现它。因此，我们将重点关注主要特性，特别是它与C#的演变相关的部分。
- en: 'First though, we should talk about the difference between C#, the CLR, and
    the .NET Framework. Up until now, they all mostly had the same version (that is
    C# 2.0, CLR 2.0, and .NET Framework 2.0), however, they released an update to
    the .NET Framework (3.0) that had no language or CLR changes. Then with .NET 3.5,
    they released C# 3.0\. The following diagram explains these differences:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，首先我们应该谈谈C#、CLR和.NET Framework之间的区别。直到现在，它们大多数版本都是相同的（即C# 2.0、CLR 2.0和.NET
    Framework 2.0），然而，他们发布了一个没有语言或CLR更改的.NET Framework（3.0）的更新。然后在.NET 3.5中，他们发布了C#
    3.0。以下图表解释了这些差异：
- en: '![C# 3.0](img/6761EN_02_04.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![C# 3.0](img/6761EN_02_04.jpg)'
- en: Confusing, I know. Although both the C# language and the .NET Framework received
    an upgrade, the CLR remained unchanged. It is hard to believe, especially in light
    of all the new features, but it goes to show how forward thinking the developers
    of the CLR have been, and how well-engineered and extensible the C# language/compiler
    is that they were able to add new features without new runtime support.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 令人困惑，我知道。尽管C#语言和.NET Framework都进行了升级，但CLR保持不变。尤其是考虑到所有新特性，这很难相信，但这表明了CLR的开发人员的前瞻性思维，以及C#语言/编译器的良好工程化和可扩展性，他们能够在没有新运行时支持的情况下添加新特性。
- en: Syntax updates
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法更新
- en: 'As usual, we will begin reviewing the syntactic changes of the language for
    this release. First are properties, which as you will remember are already an
    improvement over the old school getter and setter methods. In C# 3.0, the compiler
    can automatically generate the backing field for simple getters and setters as
    follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们将开始审查此版本语言的语法更改。首先是属性，您会记得它们已经是对旧式的getter和setter方法的改进。在C# 3.0中，编译器可以自动生成简单getter和setter的后备字段，如下所示：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This feature alone cuts out many lines of code from classes that have many
    properties. Another nice feature introduced is that of **object initializers**
    . Take the following simple class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性单独就可以减少许多具有许多属性的类的代码行数。另一个引入的不错的特性是**对象初始化器**。看下面这个简单的类：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you want to create an instance and initialize it, you would normally have
    to write code as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建一个实例并对其进行初始化，通常需要编写以下代码：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'But with an object initializer, you can do this at the same time as object
    instantiation as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用对象初始化器，您可以在对象实例化的同时进行如下操作：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The compiler will actually generate pretty much the same code as before, so
    there is no semantic difference. But you can write your code in a much more concise
    and easy-to-read manner. Collections get a similar treatment as you can now initialize
    arrays with the following syntax:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器实际上会生成几乎与以前相同的代码，因此没有语义上的区别。但是你可以以更简洁和易读的方式编写你的代码。集合也得到了类似的处理，现在你可以使用以下语法初始化数组：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And dictionaries, which were notoriously verbose to initialize, can now be
    created very easily as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，以前初始化时非常冗长的字典现在可以非常容易地创建如下：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Each of these improvements makes the very act of typing code easier and quicker.
    But it seems that the C# language designers were not content to stop there. Every
    time you instantiated a new variable, you were forced to write out the entire
    type name, when you start getting to complex generic types this can add a lot
    of extra characters to your program. Fear not! You do not even need to do that
    in C# 3.0! Look at the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些改进使得编写代码的过程更加简单和快速。但是，C#语言设计者似乎并不满足于此。每次你实例化一个新变量时，都需要写出整个类型名称，当你开始使用复杂的泛型类型时，这可能会给你的程序增加很多额外的字符。不用担心！在C#
    3.0中甚至不需要这样做！看看下面的代码：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As long as it is clear what type is being assigned on the right side of the
    equation, the compiler can take care of figuring out the type on the left side.
    Astute readers will no doubt recognize the `var` keyword from JavaScript. Though
    it looks similar, it is not the same at all. C# is still statically typed, which
    means that every variable must be known at compile time. The following code will
    not compile:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 只要右侧的赋值清楚地指明了类型，编译器就可以负责确定左侧的类型。敏锐的读者无疑会认出`var`关键字来自JavaScript。虽然看起来相似，但实际上并不一样。C#仍然是静态类型的，这意味着每个变量必须在编译时知道。以下代码将无法编译：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So, in effect, this is just a shortcut to help you type fewer characters, the
    compiler is just really good at inferring these things. In fact, that is not the
    only thing it can infer. If there is enough context, it can also infer generic
    type parameters. For example, consider the following simple generic method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实际上这只是一个快捷方式，帮助你输入更少的字符，编译器非常擅长推断这些东西。事实上，它可以推断的不仅仅是这些。如果有足够的上下文，它还可以推断泛型类型参数。例如，考虑以下简单的泛型方法：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When you call it, rather than stating the type in the call, the compiler can
    look at the type of class that is being passed in, and simply assume that this
    is the type that should be used for the type parameter as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用它时，而不是在调用中声明类型，编译器可以查看被传递的类的类型，并简单地假定这是应该用于类型参数的类型，如下所示：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'At this point, I imagine someone on the C# language team said: "While we''re
    making existing syntax optional, why not do away with the need for class definitions
    entirely!" And it would seem they did just that. If you need a data type to hold
    a few fields, you can declare it inline as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我想象C#语言团队中的某个人说：“当我们让现有的语法变成可选时，为什么不完全摒弃对类定义的需求呢！”似乎他们确实这样做了。如果你需要一个数据类型来保存一些字段，你可以内联声明如下：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The compiler will automatically create a class that matches the type that you
    just created. There are a few limitations to this feature: you have to use the
    `var` keyword, and you cannot return an anonymous type from a method. Very useful
    when you are writing an algorithm and need a quick, yet complex data type.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将自动创建一个与你刚刚创建的类型匹配的类。这个特性有一些限制：你必须使用`var`关键字，并且不能从方法中返回匿名类型。当你编写算法并且需要一个快速但复杂的数据类型时非常有用。
- en: All of these little syntax changes add up and make the C# language a pleasure
    to write in. They also are a lead in for the next big feature we are going to
    talk about.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些小的语法改变都使得C#语言写起来更加愉快。它们也为我们接下来要讨论的下一个重要特性铺平了道路。
- en: LINQ
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LINQ
- en: '**Language Integrated Query**(**LINQ**) is the flagship feature of C# 3.0\.
    It acknowledges the fact that much of a modern day program revolves around querying
    for data in one way or another. LINQ is a set of diverse features that gives the
    language first class support for querying data from a multitude of sources. It
    does so by providing a strong abstraction around the concept of querying, and
    then adding language support.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**语言集成查询**（**LINQ**）是C# 3.0的旗舰特性。它承认了现代程序的很大一部分围绕着以某种方式查询数据。LINQ是一组多样化的特性，为语言提供了对从多种来源查询数据的一流支持。它通过在查询概念周围提供强大的抽象，然后添加语言支持来实现这一点。'
- en: The C# language team started with the premise that SQL was already a great syntax
    for working with set-based data. But, unfortunately, it was not a part of the
    language; it required a different runtime, such as SQL Server, and only worked
    in that context. LINQ requires no such context switch, so you can simply get a
    reference to your data source, and query away.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: C#语言团队从这样一个前提开始，即SQL已经是一个很好的用于处理基于集合的数据的语法。但不幸的是，它并不是语言的一部分；它需要不同的运行时，比如SQL
    Server，并且只能在那个上下文中工作。LINQ不需要这样的上下文切换，因此你可以简单地获取到你的数据源的引用，然后进行查询。
- en: 'Conceptually, there are the following, high level kind of operations that you
    can do with a set:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在概念上，你可以对集合进行以下高级别的操作：
- en: '**Filtering**: This is performed where you exclude items from a set based on
    some criteria'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤**：这是根据某些条件从集合中排除项目的操作'
- en: '**Aggregation**: This involves common aggregation actions such as grouping,
    and summation'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合**：这涉及到常见的聚合操作，比如分组和求和'
- en: '**Projection**: This is extracting or converting items from a set'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**投影**：这是从集合中提取或转换项目'
- en: 'The following is what a simple LINQ query looks like:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的LINQ查询的样子：
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It looks like SQL, kind of. There have been many questions over the years over
    why the syntax does not start with the select statement like it does in SQL, but
    the reason comes down to tooling. When you start typing, they want you to be able
    to get IntelliSense when typing every part of the query. By starting with the
    'from', you are essentially telling the compiler what type will be used in the
    rest of the query, which means it can give you type-time support.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像SQL，有点像。多年来一直有很多关于为什么语法不像SQL中的select语句一样开始的问题，但原因归结为工具。当您开始输入时，他们希望您能够在输入查询的每个部分时获得智能感知。通过从'from'开始，您基本上告诉编译器在查询的其余部分中将使用什么类型，这意味着它可以在编译时提供类型支持。
- en: 'One of the interesting things about LINQ is that it works for any `IEnumerable`.
    Think about that for a second, every single collection in your program is now
    easily searchable. And that is not all, you can aggregate and shape the output
    as well. For example, say you wanted to get a count of cities in each state as
    follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ的一个有趣之处在于它适用于任何`IEnumerable`。想一想，你的程序中的每个集合现在都很容易搜索。而且不仅如此，您还可以聚合和整理输出。例如，假设您想要按州获取每个州的城市数量，如下所示：
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This query uses the group by clause to group the values by a common key, in
    this case by state. The final output is also a new anonymous type that has two
    properties, the name, and the collection of cities in that state. Running this
    program will output this for Florida as **FL has 2 cities in this collection**.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询使用group by子句按公共键（在本例中为州）对值进行分组。最终输出还是一个新的匿名类型，其中包含两个属性，名称和该州的城市集合。运行此程序将为佛罗里达州输出**FL
    has 2 cities in this collection**。
- en: So far in these examples, we have been using what is called **query syntax**
    . This is nice because it is very familiar to those who know SQL. However, just
    as with SQL, more complex queries can sometimes get rather verbose and complicated
    to read. There is another way to write LINQ queries that, for some, can be much
    easier to read, and perhaps even slightly more flexible called the **LINQ method
    syntax**, it is built upon another new feature of the language.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这些示例中，我们一直在使用所谓的**查询语法**。这很好，因为对于了解SQL的人来说非常熟悉。然而，就像SQL一样，更复杂的查询有时可能会变得相当冗长和复杂。有另一种编写LINQ查询的方法，对于一些人来说可能更容易阅读，甚至可能更灵活，称为**LINQ方法语法**，它建立在语言的另一个新功能之上。
- en: Extension methods
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展方法
- en: 'Normally, the only way of extending functionality of a type is to inherit from
    the class and add the features to the subtype. All users have to use the new type
    to get the benefits of that new type. However, this may not always be an option,
    for example, if you are using a third-party library with value types (as you cannot
    inherit from a value type). Let us say we have the following `struct` in a third-party
    library, where we do not have access to modify the source code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，扩展类型功能的唯一方法是从类继承并将功能添加到子类型中。所有用户都必须使用新类型才能获得该新类型的好处。然而，这并不总是一个选择，例如，如果您正在使用具有值类型的第三方库（因为您无法从值类型继承）。假设我们在第三方库中有以下`struct`，我们无法访问修改源代码：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With extension methods, you have the capability to add new methods to this
    type as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展方法，您可以按以下方式向此类型添加新方法：
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Extension methods must be placed in a public static class. The method itself
    will be static, and will use the `this` keyword on the first parameter to signify
    the type to attach to. Using the previous method looks like the method has always
    been a part of the type as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法必须放在公共静态类中。方法本身将是静态的，并且将在第一个参数上使用`this`关键字来表示要附加到的类型。使用前面的方法看起来就像该方法一直是类型的一部分一样：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can add the extension methods to any type, whether value type, or reference
    type. Also interfaces and sealed classes can be extended. If you look at all of
    the changes in C# 3.0, you will notice that you are now writing less code because
    the compiler is generating more and more of it behind the scenes for you. The
    result is code that looks similar to some of the other dynamic languages such
    as JavaScript.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将扩展方法添加到任何类型，无论是值类型还是引用类型。接口和密封类也可以扩展。如果您查看C# 3.0中的所有更改，您会注意到您现在编写的代码更少，因为编译器正在为您在幕后生成越来越多的代码。结果是代码看起来类似于其他一些动态语言，如JavaScript。
- en: C# 4.0
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 4.0
- en: With the fourth iteration of the language, Microsoft tried to simplify the versioning
    confusion it created over the previous few releases by incrementing the version
    of every component to 4.0.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 随着语言的第四次迭代，微软试图通过将每个组件的版本号递增到4.0来简化之前几个版本所造成的版本混乱。
- en: '![C# 4.0](img/6761EN_02_05.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![C# 4.0](img/6761EN_02_05.jpg)'
- en: C# 4.0 brings more dynamic functionality into the language and continues the
    work of making C# a very powerful, yet agile language. Some of the features added
    are primarily to make interoperation with native platform code easier. Things
    such as covariance, contra variance, and optional parameters, simplify the process
    of doing things, calling the interop assemblies for interacting with Microsoft
    Word, for example. All in all, not very earth-shaking stuff, at least for your
    average day-to-day developer.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: C# 4.0将更多的动态功能引入语言，并继续努力使C#成为一个非常强大但灵活的语言。添加的一些功能主要是为了使与本地平台代码的交互更加容易。例如，协变、逆变和可选参数等功能简化了与Microsoft
    Word交互的Interop程序集的调用过程。总的来说，这些并不是非常惊人的东西，至少对于普通的开发人员来说不是。
- en: However, with a new keyword that was added, `dynamic`, C# takes a step closer
    to becoming a very dynamic language; or at the very minimum, inheriting many of
    the qualities of dynamic languages. Remember when generics were introduced, if
    you had a bare type parameter (that is, with no type constraints), it was treated
    as an object. The compiler had no additional information about what kind of methods
    and properties the type had access to at runtime, and as such you could only interact
    with it as an object.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过添加一个新关键字`dynamic`，C#更接近成为一种非常动态的语言；或者至少继承了许多动态语言的特性。还记得当引入泛型时，如果有一个裸类型参数（即没有类型约束），它被视为对象。编译器在运行时对类型有关的方法和属性没有额外的信息，因此您只能将其视为对象进行交互。
- en: 'In C# 4.0, you now have a way of writing code that can bind to the correct
    properties and methods at runtime. The following is a simple example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 4.0中，现在您可以编写可以在运行时绑定到正确属性和方法的代码。以下是一个简单的例子：
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Tip
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are migrating a project from an earlier version of the framework, make
    sure you add a reference to `Microsoft.CSharp.dll,` when using dynamic programming.
    You will receive a compilation error if this is not present.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在从较早版本的框架迁移项目，请确保在使用动态编程时添加对`Microsoft.CSharp.dll`的引用。如果没有这个引用，您将收到编译错误。
- en: In this hypothetical scenario, you have a method that returns a `string`. The
    variable that is receiving the return value of the `GetAString()` method is marked
    with the `dynamic` keyword. This means that every property and method that you
    call on that object will be dynamically evaluated at runtime. This lets C# easily
    interop with dynamic languages, such as IronPython and IronRuby, in addition to
    your own custom dynamic types.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个假设的场景中，您有一个返回`string`的方法。接收`GetAString()`方法返回值的变量标记有`dynamic`关键字。这意味着您在该对象上调用的每个属性和方法都将在运行时动态评估。这使得C#可以轻松地与动态语言（如IronPython和IronRuby）以及您自己的自定义动态类型进行交互。
- en: Does this mean that C# is no longer statically typed? No, quite the opposite;
    C# is still statically typed, just that in this case you have told the compiler
    to handle this code differently. It does this by rewriting your dynamic code to
    use the **Dynamic Language Runtime** (**DLR**), which actually compiles out expression
    trees of your code that are evaluated at runtime.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着C#不再是静态类型的？不，恰恰相反；C#仍然是静态类型的，只是在这种情况下，您已经告诉编译器以不同的方式处理这段代码。它通过重写您的动态代码来使用**动态语言运行时**（**DLR**）来实现这一点，实际上编译出您的代码的表达式树，在运行时进行评估。
- en: 'You can easily create your own dynamic objects by inheriting from the built-in
    class called `DynamicObject` as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过继承内置类`DynamicObject`轻松创建自己的动态对象，如下所示：
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In this simple example, we inherit from `DynamicObject` and override a few
    methods to get and set the member value. These values are stored internally in
    a dictionary so that you can pull out the correct value when the DLR asks for
    it. Using this class is very reminiscent of how flexible objects are in JavaScript.
    Look at the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，我们继承自`DynamicObject`并重写了一些方法来获取和设置成员值。这些值在内部存储在字典中，这样当DLR请求时，您可以取出正确的值。使用这个类非常像JavaScript中的灵活对象。看下面的代码：
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If you need to store a new value, simply set the property. And if you want to
    define a new method, you can use a delegate as the value for the member. Of course,
    you must realize that this will not be as fast as having a regular statically
    typed class, every value must be looked up at runtime, and because values are
    stored as objects internally, any value type will be boxed. But sometimes those
    drawbacks are completely acceptable, especially when it can simplify your code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要存储新值，只需设置属性。如果要定义新方法，可以使用委托作为成员的值。当然，您必须意识到这不会像拥有常规静态类型的类那样快，每个值必须在运行时查找，并且因为值在内部存储为对象，任何值类型都将被装箱。但有时这些缺点是完全可以接受的，特别是当它可以简化您的代码时。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: For me, it has been an amazing journey, watching C# evolve from the very first
    version until today. Each subsequent release was more powerful than the previous,
    and there was a very solid theme of code simplification throughout. The compiler
    itself has gotten better and better at generating code on your behalf, so that
    you can implement very powerful features in your programs without having the cognitive
    burden of verbosely implementing the infrastructure (generics, iterators, LINQ,
    and the DLR)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，观察C#从第一个版本发展到今天是一段令人惊奇的旅程。每个后续版本都比上一个版本更强大，而且在整个过程中都有一个非常坚实的代码简化主题。编译器本身在为您生成代码方面变得越来越好，这样您就可以在程序中实现非常强大的功能，而不必承担冗长实现基础设施（泛型、迭代器、LINQ和DLR）的认知负担。
- en: In this chapter we looked at some of the major features that were introduced
    in each version of C#
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一些C#每个版本引入的主要特性。
- en: '**C# 1.0**: Memory Management, Base Class Library, and syntax features such
    as properties and events.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C# 1.0**：内存管理，基类库和语法特性，如属性和事件。'
- en: '**C# 2.0**: Generics, iterator methods, partial classes, anonymous methods,
    and syntactic updates such as visibility modifiers on properties and nullable
    types.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C# 2.0**：泛型，迭代器方法，部分类，匿名方法和语法更新，如属性上的可见性修饰符和可空类型。'
- en: '**C# 3.0**: **Language Integrated Query** (**LINQ**), extension methods, automatic
    properties, object initializers, type inference (`var`), and anonymous types.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C# 3.0**：**语言集成查询**（**LINQ**），扩展方法，自动属性，对象初始化程序，类型推断（`var`）和匿名类型。'
- en: '**C# 4.0**: The **Dynamic Language Runtime** (**DLR**), and co- and contra
    variance'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C# 4.0**：**动态语言运行时**（**DLR**），协变和逆变'
- en: Now, we move to the latest release, C# 5.0.Iliquamet quae volor aut ium ea dolore
    doleseq uibusam, quiasped utem atet etur sus.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们转向最新版本，C# 5.0。Iliquamet quae volor aut ium ea dolore doleseq uibusam, quiasped
    utem atet etur sus。
