- en: Distributed Application Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式应用架构
- en: In the previous chapter, we discussed advanced tips, tricks, and concepts that
    are useful when containerizing complex distributed applications, or when using
    Docker to automate sophisticated tasks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了在容器化复杂的分布式应用程序或使用Docker自动化复杂任务时有用的高级技巧和概念。
- en: In this chapter, we'll introduce the concept of a distributed application architecture
    and discuss the various patterns and best practices that are required to run a
    distributed application successfully. Finally, we will discuss the additional
    requirements that need to be fulfilled to run such an application in production.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍分布式应用架构的概念，并讨论运行分布式应用所需的各种模式和最佳实践。最后，我们将讨论在生产环境中运行此类应用所需满足的额外要求。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the distributed application architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解分布式应用架构
- en: Patterns and best practices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式和最佳实践
- en: Running in production
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生产环境中运行
- en: 'After finishing this chapter, you will be able to do the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将能够做到以下事情：
- en: Name at least four characteristics of a distributed application architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少列出分布式应用架构的四个特征
- en: List three to four patterns that need to be implemented for a production-ready
    distributed application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出需要在生产环境中实施的三到四种模式
- en: Understanding the distributed application architecture
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解分布式应用架构
- en: In this section, we are going to explain what we mean when we talk about a distributed
    application architecture. First, we need to make sure that all words or acronyms
    we use have a meaning and that we are all talking the same language.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释当我们谈论分布式应用架构时的含义。首先，我们需要确保我们使用的所有单词或首字母缩写都有意义，并且我们都在说同样的语言。
- en: Defining the terminology
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义术语
- en: 'In this and subsequent chapters, we will talk about a lot about concepts that
    might not be familiar to everyone. To make sure we''re all talking the same language,
    let''s briefly introduce and describe the most important of these concepts or
    words:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和后续章节中，我们将谈论许多可能不为所有人熟悉的概念。为了确保我们都在说同样的语言，让我们简要介绍和描述这些概念或词语中最重要的：
- en: '| **Terminology** | **Explanation** |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: 术语 | 解释
- en: '| VM | The acronym for virtual machine. This is a virtual computer. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: 虚拟机 | 虚拟机的缩写。这是一台虚拟计算机。
- en: '| Node | An individual server used to run applications. This can be a physical server,
    often called bare-metal, or a VM. A can be a mainframe, supercomputer, standard business server,
    or even a Raspberry Pi. Nodes can be computers in a company''s own data center
    or in the cloud. Normally, a node is part of a cluster. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: 节点 | 用于运行应用程序的单个服务器。这可以是物理服务器，通常称为裸金属，也可以是虚拟机。可以是大型机、超级计算机、标准业务服务器，甚至是树莓派。节点可以是公司自己数据中心或云中的计算机。通常，节点是集群的一部分。
- en: '| Cluster | A group of nodes connected by a network that are used to run distributed
    applications. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: 集群 | 由网络连接的节点组成，用于运行分布式应用。
- en: '| Network | Physical and software-defined communication paths between individual
    nodes of a cluster and programs running on those nodes. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: 网络 | 集群中各个节点之间的物理和软件定义的通信路径，以及在这些节点上运行的程序。
- en: '| Port | A channel on which an application such as a web server listens for
    incoming requests. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: 端口 | 应用程序（如Web服务器）监听传入请求的通道。
- en: '| Service | This, unfortunately, is a very overloaded term and its real meaning
    depends on the context that it is used in. If we use the term *service *in the
    context of an application such as an application service, then it usually means
    that this is a piece of software that implements a limited set of functionality
    that is then used by other parts of the application. As we progress through this
    book, other types of services that have a slightly different definition will be
    discussed. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 服务 | 不幸的是，这是一个非常负载的术语，它的真正含义取决于它所使用的上下文。如果我们在应用程序的上下文中使用术语*服务*，那么通常意味着这是一个实现了一组有限功能的软件，然后被应用程序的其他部分使用。随着我们在本书中的进展，将讨论具有稍微不同定义的其他类型的服务。'
- en: 'Naively said, a distributed application architecture is the opposite of a monolithic
    application architecture, but it''s not unreasonable to look at this monolithic
    architecture first. Traditionally, most business applications have been written
    in such a way that the result can be seen as one single, tightly coupled program
    that runs on a named server somewhere in a data center. All its code is compiled
    into a single binary or a few very tightly coupled binaries that need to be co-located
    when running the application. The fact that the server, or more general host,
    that the application is running on has a well-defined name or static IP address
    is also important in this context. Let''s look at the following diagram to illustrate
    this type of application architecture a bit more clearly:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 天真地说，分布式应用架构是单片应用架构的反义词，但首先看看这种单片架构也并非不合理。传统上，大多数业务应用都是以这种方式编写的，结果可以看作是一个单一的、紧密耦合的程序，运行在数据中心的某个命名服务器上。它的所有代码都被编译成一个单一的二进制文件，或者几个非常紧密耦合的二进制文件，在运行应用程序时需要共同定位。服务器，或者更一般的主机，应用程序运行的这一事实具有明确定义的名称或静态IP地址，在这种情况下也是重要的。让我们看下面的图表，更清楚地说明这种类型的应用架构：
- en: '![](assets/56242555-ab5b-4055-8cb5-e3e4b2e3f83f.png)Monolithic application
    architecture'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/56242555-ab5b-4055-8cb5-e3e4b2e3f83f.png)单片应用架构'
- en: In the preceding diagram, we can see a **Server** named `blue-box-12a` with
    an **IP** address of `172.52.13.44` running an application called `pet-shop`,
    which is a monolith consisting of a main module and a few tightly coupled libraries.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们可以看到一个名为`blue-box-12a`的**服务器**，具有`172.52.13.44`的**IP**地址，运行一个名为`pet-shop`的应用程序，它是一个由主模块和几个紧密耦合的库组成的单片。
- en: 'Now, let''s look at the following diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下以下的图表：
- en: '![](assets/425c8d7b-efb8-48e3-8791-cb2d99ee8862.png)Distributed application
    architecture'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/425c8d7b-efb8-48e3-8791-cb2d99ee8862.png)分布式应用架构'
- en: Here, all of a sudden, we don't have only a single named server anymore; instead,
    we have a lot of them, and they don't have human-friendly names, but rather some
    unique IDs that can be something like a **Universal Unique Identifier** (**UUID**).
    The pet shop application, all of a sudden, also does not consist of a single monolithic
    block anymore, but rather a plethora of interacting, yet loosely coupled, services
    such as **pet-api**, **pet-web**, and **pet-inventory**. Furthermore, each service
    runs in multiple instances in this cluster of servers or hosts.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，突然之间，我们不再只有一个命名的服务器；相反，我们有很多服务器，它们没有人类友好的名称，而是一些可以是类似于**通用唯一标识符**（**UUID**）的唯一ID。突然之间，宠物商店应用程序也不再只是由一个单一的单片块组成，而是由许多相互作用但松散耦合的服务组成，例如**pet-api**、**pet-web**和**pet-inventory**。此外，每个服务在这个服务器或主机集群中运行多个实例。
- en: You might be wondering why we are discussing this in a book about Docker containers,
    and you are right to ask. While all the topics we're going to investigate apply
    equally to a world where containers do not (yet) exist, it is important to realize
    that containers and container orchestration engines help address all these problems
    in a much more efficient and straightforward way. Most of the problems that used
    to be very hard to solve in a distributed application architecture become quite
    simple in a containerized world.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么我们在一本关于Docker容器的书中讨论这个问题，你问得对。虽然我们要调查的所有主题同样适用于容器尚未存在的世界，但重要的是要意识到，容器和容器编排引擎可以以更高效和直接的方式解决所有这些问题。在容器化的世界中，以前在分布式应用架构中很难解决的大多数问题变得相当简单。
- en: Patterns and best practices
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式和最佳实践
- en: A distributed application architecture has many compelling benefits, but it
    also has one very significant drawback compared to a monolithic application architecture
    – the former is way more complex. To tame this complexity, the industry has come
    up with some important best practices and patterns. In the following sections,
    we are going to look into some of the most important ones in more detail.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式应用架构具有许多引人注目的好处，但与单片应用架构相比，它也有一个非常重要的缺点——前者要复杂得多。为了控制这种复杂性，该行业提出了一些重要的最佳实践和模式。在接下来的章节中，我们将更详细地研究其中一些最重要的内容。
- en: Loosely coupled components
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松散耦合的组件
- en: The best way to address a complex subject has always been to divide it into
    smaller subproblems that are more manageable. As an example, it would be insanely
    complex to build a house in one single step. It is much easier to build the house
    from simple parts that are then combined into the final result.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 解决复杂问题的最佳方法一直是将其分解为更易管理的较小子问题。举个例子，一步到位地建造一座房子将会非常复杂。将房子从简单的部件组合成最终结果会更容易。
- en: The same also applies to software development. It is much easier to develop
    a very complex application if we divide this application into smaller components
    that interoperate and make up the overall application. Now, it is much easier
    to develop these components individually if they are only loosely coupled to each
    other. What this means is that component A makes no assumptions about the inner
    workings of, say, components B and C, and is only interested in how it can communicate
    with those two components across a well-defined interface.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于软件开发。如果我们将这个应用程序分解成相互协作并构成整体应用程序的较小组件，那么开发一个非常复杂的应用程序就会变得更容易。现在，如果这些组件之间的耦合度较低，那么单独开发这些组件就会变得更容易。这意味着组件A不会对组件B和C的内部工作做任何假设，而只关心它如何通过明确定义的接口与这两个组件进行通信。
- en: If each component has a well-defined and simple public interface through which
    communication with the other components in the system and the outside world happens,
    then this enables us to develop each component individually, without implicit
    dependencies to other components. During the development process, other components
    in the system can easily be replaced by stubs or mocks to allow us to test our
    components.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个组件都有一个明确定义且简单的公共接口，通过该接口与系统中的其他组件和外部世界进行通信，那么这将使我们能够单独开发每个组件，而不会对其他组件产生隐式依赖。在开发过程中，系统中的其他组件可以很容易地被存根或模拟替换，以便我们测试我们的组件。
- en: Stateful versus stateless
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有状态与无状态
- en: Every meaningful business application creates, modifies, or uses data. In IT,
    a synonym for data is *state*. An application service that creates or modifies
    persistent data is called a stateful component. Typical stateful components are
    database services or services that create files. On the other hand, application
    components that do not create or modify persistent data are called stateless components.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个有意义的业务应用程序都会创建、修改或使用数据。在IT中，数据的同义词是“状态”。创建或修改持久数据的应用服务称为有状态组件。典型的有状态组件是数据库服务或创建文件的服务。另一方面，不创建或修改持久数据的应用组件称为无状态组件。
- en: In a distributed application architecture, stateless components are much simpler
    to handle than stateful components. Stateless components can be easily scaled
    up and down. Furthermore, they can be quickly and painlessly torn down and restarted
    on a completely different node of the cluster – all of this because they have
    no persistent data associated with them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式应用架构中，无状态组件比有状态组件更容易处理。无状态组件可以轻松地进行扩展和缩减。此外，它们可以快速而轻松地在集群的完全不同节点上关闭和重新启动，因为它们与持久数据没有关联。
- en: Given that fact, it is helpful to design a system in a way that most of the
    application services are stateless. It is best to push all the stateful components
    to the boundary of the application and limit their number. Managing stateful components
    is hard.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这一事实，有助于以大多数应用服务为无状态的方式设计系统。最好将所有有状态组件推到应用程序的边界并限制它们的数量。管理有状态组件很困难。
- en: Service discovery
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现
- en: As we build applications that consist of many individual components or services
    that communicate with each other, we need a mechanism that allows the individual
    components to find each other in the cluster. Finding each other usually means
    that you need to know on which node the target component is running and on which
    port it is listening for communication. Most often, nodes are identified by an
    IP address and a port, which is just a number in a well-defined range.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应用程序时，通常由许多个体组件或相互通信的服务组成，我们需要一种机制，允许个体组件在集群中找到彼此。找到彼此通常意味着您需要知道目标组件在哪个节点上运行，以及它在哪个端口上监听通信。大多数情况下，节点由IP地址和端口标识，端口只是一个在明确定义范围内的数字。
- en: 'Technically, we could tell **Service A**, which wants to communicate with a
    target, **Service B**, what the **IP** address and **port** of the target are.
    This could happen, for example, through an entry in a configuration file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们可以告诉想要与目标“服务B”通信的“服务A”，目标的IP地址和端口是什么。例如，这可以通过配置文件中的条目来实现。
- en: '![](assets/bd7fdc4f-ae7d-4b25-b313-76aede6e61ea.png)Components are hardwired'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是硬连线的
- en: While this might work very well in the context of a monolithic application that
    runs on one or only a few well-known and curated servers, it totally falls apart
    in a distributed application architecture. First of all, in this scenario, we
    have many components, and keeping track of them manually becomes a nightmare.
    This is definitely not scalable. Furthermore, **Service A** typically should or
    will never know on which node of the cluster the other components run. Their location
    may not even be stable as component B could be moved from node X to another node
    Y, due to various reasons external to the application. Thus, we need another way
    in which **Service A** can locate **Service B**, or any other service, for that
    matter. What is most commonly used is an external authority that is aware of the
    topology of the system at any given time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体应用程序的上下文中，这可能非常有效，该应用程序在一个或仅有几个知名和精心策划的服务器上运行，但在分布式应用程序架构中完全失效。首先，在这种情况下，我们有许多组件，手动跟踪它们变成了一场噩梦。这绝对不可扩展。此外，**服务A**通常不应该或永远不会知道其他组件在集群的哪个节点上运行。它们的位置甚至可能不稳定，因为组件B可能由于应用程序外部的各种原因从节点X移动到另一个节点Y。因此，我们需要另一种方式，**服务A**可以找到**服务B**，或者其他任何服务。最常用的是一个外部机构，它在任何给定时间都了解系统的拓扑结构。
- en: 'This external authority or service knows all the nodes and their IP addresses
    that currently pertain to the cluster; it knows about all the services that are
    running and where they are running. Often, this kind of service is called a **DNS
    service**, where **DNS** stands for **Domain Name System**. As we will see, Docker has a
    DNS service implemented as part of the underlying engine. Kubernetes – the number
    one container orchestration system, which we''ll discuss in [Chapter 12](27c0d9ce-fab6-4ce9-9034-4f2fb62931e8.xhtml),
    *Orchestrators* – also uses a **DNS service** to facilitate communication between
    components running in the cluster:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '这个外部机构或服务知道当前属于集群的所有节点和它们的IP地址；它知道所有正在运行的服务以及它们在哪里运行。通常，这种服务被称为**DNS服务**，其中**DNS**代表**域名系统**。正如我们将看到的，Docker实现了一个作为底层引擎的DNS服务。Kubernetes
    - 首要的容器编排系统，我们将在[第12章](27c0d9ce-fab6-4ce9-9034-4f2fb62931e8.xhtml)中讨论，*编排器* -
    也使用**DNS服务**来促进集群中运行的组件之间的通信。 '
- en: '![](assets/3aa74eff-0e86-46e9-bb4b-dd356a97a816.png)Components consulting an
    external locator service'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/3aa74eff-0e86-46e9-bb4b-dd356a97a816.png)组件咨询外部定位器服务'
- en: In the preceding diagram, we can see how **Service A** wants to communicate
    with **Service B**, but it can't do this directly. First, it has to query the external authority,
    a registry service (here, called a **DNS Service**), about the whereabouts of
    **Service B**. The registry service will answer with the requested information
    and hand out the IP address and port number that **Service A** can use to reach
    **Service B**. **Service** **A** then uses this information and establishes a
    communication with **Service B**. Of course, this is a naive picture of what's
    really happening on a low level, but it is a good picture to help us understand
    the architectural pattern of service discovery.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们可以看到**服务A**想要与**服务B**通信，但它无法直接做到这一点。首先，它必须查询外部机构，一个注册表服务（这里称为**DNS服务**），询问**服务B**的下落。注册表服务将回答所请求的信息，并提供**服务A**可以用来到达**服务B**的IP地址和端口号。**服务A**然后使用这些信息并与**服务B**建立通信。当然，这只是一个关于低级别实际发生情况的天真图像，但它是一个帮助我们理解服务发现架构模式的好图像。
- en: Routing
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: Routing is the mechanism of sending packets of data from a source component
    to a target component. Routing is categorized into different types. The so-called
    OSI model (see the reference to this in the *Further reading* section of this
    chapter for more information) is used to distinguish between different types of
    routing. In the context of containers and container orchestration, routing at
    layers 2, 3, 4, and 7 is relevant. We will dive into more detail about routing
    in subsequent chapters. Here, let's just say that layer 2 routing is the most
    low-level type of routing, which connects a MAC address to another MAC address,
    while layer 7 routing, which is also called application-level routing, is the
    most high-level one. The latter is, for example, used to route requests that have
    a target identifier, that is, a URL such as [https://acme.com/pets](https://acme.com/pets),
    to the appropriate target component in our system.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是将数据包从源组件发送到目标组件的机制。路由被分类为不同类型。所谓的OSI模型（有关更多信息，请参阅本章的*进一步阅读*部分中的参考资料）用于区分不同类型的路由。在容器和容器编排的上下文中，第2、3、4和7层的路由是相关的。我们将在后续章节中更详细地讨论路由。在这里，让我们只说第2层路由是最低级别的路由类型，它将MAC地址连接到另一个MAC地址，而第7层路由，也称为应用级路由，是最高级别的路由。后者例如用于将具有目标标识符（即URL）的请求路由到我们系统中的适当目标组件。
- en: Load balancing
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负载均衡
- en: 'Load balancing is used whenever **Service A** needs to communicate with **Service
    B**, say in a request-response pattern, but the latter is running in more than
    one instance, as shown in the following diagram:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡在服务A需要与服务B通信时使用，比如在请求-响应模式中，但后者运行在多个实例中，如下图所示：
- en: '![](assets/cee74fda-2b24-485d-b10f-ac9c17feedef.png)The request of Service
    A being load balanced to Service B'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 服务A的请求被负载均衡到服务B
- en: If we have multiple instances of a service such as **Service B** running in
    our system, we want to make sure that every one of those instances gets an equal
    amount of workload assigned to it. This task is a generic one, which means that we
    don't want the caller to have to do the load balancing, but rather an external
    service that intercepts the call and takes over the part of deciding which of
    the target service instances to forward the call to. This external service is
    called a load balancer. Load balancers can use different algorithms to decide
    how to distribute incoming calls to target service instances. The most common
    algorithm that's used is called round-robin. This algorithm just assigns requests
    in a repetitive way, starting with instance 1, then 2, until instance n. After
    the last instance has been served, the load balancer starts over with instance
    number 1.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的系统中运行着多个服务B的实例，我们希望确保每个实例都被分配了相等的工作负载。这是一个通用的任务，这意味着我们不希望调用者进行负载均衡，而是希望一个外部服务拦截调用并决定将调用转发给目标服务实例的部分。这个外部服务被称为负载均衡器。负载均衡器可以使用不同的算法来决定如何将传入的调用分发给目标服务实例。最常用的算法称为轮询。这个算法只是以重复的方式分配请求，从实例1开始，然后是2，直到实例n。在最后一个实例被服务后，负载均衡器重新从实例1开始。
- en: In the preceding example, a **load** **balancer** also facilitates high availability
    since a request from **service A** will be forwarded to a healthy instance of
    **Service B**. The **load balancer** also takes the role of periodically checking
    the health of each instance of B.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，负载均衡器还有助于高可用性，因为来自服务A的请求将被转发到健康的服务B实例。负载均衡器还承担定期检查B的每个实例健康状况的角色。
- en: Defensive programming
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防御性编程
- en: When developing a service for a distributed application, it is important to
    remember that this service is not going to be standalone and that it's dependent
    on other application services or even on external services provided by third parties,
    such as credit card validation services or stock information services, to just
    name two. All these other services are external to the service we are developing.
    We have no control over their correctness or their availability at any given time.
    Thus, when coding, we always need to assume the worst and hope for the best. Assuming
    the worst means that we have to deal with potential failures explicitly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发分布式应用程序的服务时，重要的是要记住这个服务不会是独立的，它依赖于其他应用程序服务，甚至依赖于第三方提供的外部服务，比如信用卡验证服务或股票信息服务，仅举两个例子。所有这些其他服务都是我们正在开发的服务的外部服务。我们无法控制它们的正确性或它们在任何给定时间的可用性。因此，在编码时，我们总是需要假设最坏的情况，并希望最好的结果。假设最坏的情况意味着我们必须明确处理潜在的故障。
- en: Retries
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重试
- en: When there is a possibility that an external service might be temporarily unavailable
    or not responsive enough, then the following procedure can be used. When the call
    to the other service fails or times out, the calling code should be structured
    in such a way that the same call is repeated after a short wait time. If the call
    fails again, the wait should be a bit longer before the next trial. The calls
    should be repeated up until a maximum number of times, each time increasing the
    wait time. After that, the service should give up and provide a degraded service,
    which could mean returning some stale cached data or no data at all, depending
    on the situation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当外部服务可能暂时不可用或响应不够及时时，可以使用以下程序。当对其他服务的调用失败或超时时，调用代码应以一种结构化的方式进行，以便在短暂的等待时间后重复相同的调用。如果再次失败，下一次尝试前等待时间应稍长。应重复调用，直到达到最大次数，每次增加等待时间。之后，服务应放弃并提供降级服务，这可能意味着返回一些陈旧的缓存数据或根据情况根本不返回数据。
- en: Logging
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: Important operations that are performed on a service should always be logged.
    Logging information needs to be categorized to be of any real value. A common
    list of categories includes debug, info, warning, error, and fatal. Logging information
    should be collected by a central log aggregation service and not be stored on
    an individual node of the cluster. Aggregated logs are easy to parse and filter
    for relevant information. This information is essential to quickly pinpoint the
    root cause of a failure or unexpected behavior in a distributed system consisting
    of many moving parts, running in production.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对服务执行的重要操作应始终记录。日志信息需要分类，才能具有真正的价值。常见的分类列表包括调试、信息、警告、错误和致命。日志信息应由中央日志聚合服务收集，而不应存储在集群的单个节点上。聚合日志易于解析和过滤相关信息。这些信息对于快速定位由许多运行在生产环境中的移动部件组成的分布式系统中的故障或意外行为的根本原因至关重要。
- en: Error handling
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: As we mentioned earlier, each application service in a distributed application
    is dependent on other services. As developers, we should always expect the worst
    and have appropriate error handling in place. One of the most important best practices
    is to fail fast. Code the service in such a way that unrecoverable errors are
    discovered as early as possible and, if such an error is detected, have the service
    fail immediately. But don't forget to log meaningful information to `STDERR` or
    `STDOUT`, which can be used by developers or system operators later to track malfunctions
    of the system. Also, return a helpful error to the caller, indicating as precisely
    as possible why the call failed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，分布式应用程序中的每个应用服务都依赖于其他服务。作为开发人员，我们应该始终预料到最坏的情况，并采取适当的错误处理措施。最重要的最佳实践之一是快速失败。以这样的方式编写服务，使得不可恢复的错误尽早被发现，如果检测到这样的错误，立即使服务失败。但不要忘记记录有意义的信息到`STDERR`或`STDOUT`，以便开发人员或系统操作员以后可以用来跟踪系统的故障。同时，向调用者返回有用的错误信息，尽可能准确地指出调用失败的原因。
- en: One sample of fail fast is to always check the input values provided by the
    caller. Are the values in the expected ranges and complete? If not, then do not
    try to continue processing; instead, immediately abort the operation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 快速失败的一个示例是始终检查调用者提供的输入值。这些值是否在预期范围内并且完整？如果不是，那么不要尝试继续处理；而是立即中止操作。
- en: Redundancy
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冗余
- en: A mission-critical system has to be available at all times, around the clock,
    365 days a year. Downtime is not acceptable since it might result in a huge loss
    of opportunities or reputation for the company. In a highly distributed application,
    the likelihood of a failure of at least one of the many involved components is
    non-neglectable. We can say that the question is not whether a component will
    fail, but rather when a failure will occur.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使命关键的系统必须全天候、全年无休地可用。停机是不可接受的，因为它可能导致公司机会或声誉的巨大损失。在高度分布式的应用程序中，至少有一个涉及的组件失败的可能性是不可忽视的。我们可以说问题不在于一个组件是否会失败，而在于失败将在何时发生。
- en: To avoid downtime when one of the many components in the system fails, each
    individual part of the system needs to be redundant. This includes the application
    components, as well as all infrastructure parts. What that means is that if we,
    say, have a payment service as part of our application, then we need to run this
    service redundantly. The easiest way to do that is to run multiple instances of
    this very service on different nodes of our cluster. The same applies, say, for
    an edge router or a load balancer. We cannot afford for this to ever go down.
    Thus, the router or load balancer must be redundant.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免系统中的许多组件之一出现故障时停机，系统的每个单独部分都需要是冗余的。这包括应用程序组件以及所有基础设施部分。这意味着，如果我们的应用程序中有一个支付服务，那么我们需要冗余地运行这个服务。最简单的方法是在集群的不同节点上运行这个服务的多个实例。同样，对于边缘路由器或负载均衡器也是如此。我们不能承受它出现故障的风险。因此，路由器或负载均衡器必须是冗余的。
- en: Health checks
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康检查
- en: We have mentioned various times that in a distributed application architecture,
    with its many parts, the failure of an individual component is highly likely and
    that it is only a matter of time until it happens. For that reason, we run every
    single component of the system redundantly. Proxy services then load balance the
    traffic across the individual instances of a service.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次提到，在分布式应用程序架构中，由于其许多部分，单个组件的故障是非常可能的，而且只是时间问题。因此，我们将系统的每个单个组件都运行冗余。代理服务然后在服务的各个实例之间平衡流量。
- en: But now, there is another problem. How does the proxy or router know whether
    a certain service instance is available? It could have crashed or it could be
    unresponsive. To solve this problem, we can use so-called health checks. The proxy,
    or some other system service on behalf of the proxy, periodically polls all the
    service instances and checks their health. The questions are basically, Are you
    still there? Are you healthy? The answer to each service is either Yes or No,
    or the health check times out if the instance is not responsive anymore.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，又出现了另一个问题。代理或路由器如何知道某个服务实例是否可用？它可能已经崩溃或者无响应。为了解决这个问题，我们可以使用所谓的健康检查。代理或代理的其他系统服务定期轮询所有服务实例并检查它们的健康状况。基本上问题是，你还在吗？你健康吗？对每个服务的答案要么是是，要么是否，或者如果实例不再响应，则健康检查超时。
- en: If the component answers with No or a timeout occurs, then the system kills
    the corresponding instance and spins up a new instance in its place. If all this
    happens in a fully automated way, then we say that we have an auto-healing system
    in place.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件回答“否”或发生超时，那么系统将终止相应的实例并在其位置上启动一个新的实例。如果所有这些都是以完全自动化的方式发生的，那么我们可以说我们有一个自愈系统。
- en: Instead of the proxy periodically polling the status of the components, responsibility
    can also be turned around. The components could be required to periodically send
    live signals to the proxy. If a component fails to send live signals over a predefined,
    extended period of time, it is assumed to be unhealthy or dead.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 代理定期轮询组件的状态的责任可以被转移。组件也可以被要求定期向代理发送活动信号。如果一个组件在预定义的延长时间内未能发送活动信号，就被认为是不健康或已死亡。
- en: There are situations where either of the described ways is more appropriate.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，上述的任一方式更为合适。
- en: Circuit breaker pattern
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器模式
- en: A circuit breaker is a mechanism that is used to avoid a distributed application going
    down due to the cascading failure of many essential components. Circuit breakers
    help to avoid one failing component tearing down other dependent services in a
    domino effect. Like circuit breakers in an electrical system, which protect a
    house from burning down due to the failure of a malfunctioning plugged-in appliance
    by interrupting the power line, circuit breakers in a distributed application
    interrupt the connection from **Service A** to **Service B **if the latter is
    not responding or is malfunctioning.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器是一种机制，用于避免分布式应用因许多重要组件的级联故障而崩溃。断路器有助于避免一个故障组件以多米诺效应拖垮其他依赖服务。就像电气系统中的断路器一样，它通过切断电源线来保护房屋免受由于插入式设备故障而导致的火灾，分布式应用中的断路器在**服务A**到**服务B**的连接中断，如果后者没有响应或者发生故障。
- en: 'This can be achieved by wrapping a protected service call in a circuit breaker
    object. This object monitors for failures. Once the number of failures reaches
    a certain threshold, the circuit breaker trips. All subsequent calls to the circuit
    breaker will return with an error, without the protected call being made at all:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过将受保护的服务调用包装在断路器对象中来实现。该对象监视故障。一旦故障次数达到一定阈值，断路器就会跳闸。所有随后对断路器的调用都将返回错误，而根本不会进行受保护的调用：
- en: '![](assets/7f511703-df7b-4e5c-af03-f8fc19876a73.png)Circuit breaker pattern'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/7f511703-df7b-4e5c-af03-f8fc19876a73.png)断路器模式'
- en: In the preceding diagram, we have a circuit breaker that tips over after the
    second timeout is received when calling **Service B**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们有一个断路器，在调用**服务B**时收到第二个超时后会跳闸。
- en: Running in production
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在生产中运行
- en: To successfully run a distributed application in production, we need to consider a
    few more aspects beyond the best practices and patterns presented in the preceding
    sections. One specific area that comes to mind is introspection and monitoring.
    Let's go through the most important aspects in detail.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功地在生产环境中运行分布式应用程序，我们需要考虑在前面部分介绍的最佳实践和模式之外的一些方面。一个特定的领域是内省和监控。让我们详细介绍最重要的方面。
- en: Logging
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: Once a distributed application is in production, it is not possible to live
    debug it. But how can we then find out what exactly is the root cause of the application
    malfunctioning? The solution to this problem is that the application produces
    abundant and meaningful logging information while running. Developers need to
    instrument their application services in such a way that they output helpful information,
    such as when an error happens or a potentially unexpected or unwanted situation
    is encountered. Often, this information is output to `STDOUT` and `STDERR`, where
    it is then collected by system daemons that write the information to local files
    or forward it to a central log aggregation service.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦分布式应用程序投入生产，就不可能进行实时调试。但是我们如何找出应用程序故障的根本原因呢？解决这个问题的方法是应用程序在运行时产生丰富而有意义的日志信息。开发人员需要以这样的方式对其应用程序服务进行工具化，以便输出有用的信息，例如发生错误时或遇到潜在的意外或不需要的情况时。通常，这些信息输出到`STDOUT`和`STDERR`，然后由系统守护进程收集并将信息写入本地文件或转发到中央日志聚合服务。
- en: If there is sufficient information in the logs, developers can use those logs
    to track down the root cause of the errors in the system.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果日志中有足够的信息，开发人员可以使用这些日志来追踪系统中错误的根本原因。
- en: In a distributed application architecture, with its many components, logging
    is even more important than in a monolithic application. The paths of execution
    of a single request through all the components of the application can be very
    complex. Also, remember that the components are distributed across a cluster of
    nodes. Thus, it makes sense to log everything of importance, and to add things
    to each log entry such as the exact time when it happened, the component in which
    it happened, and the node on which the component ran, to name just a few. Furthermore,
    the logging information should be aggregated in a central location so that it
    is readily available for developers and system operators to analyze.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式应用程序架构中，由于其许多组件，日志记录甚至比在单体应用程序中更为重要。单个请求通过应用程序的所有组件的执行路径可能非常复杂。还要记住，这些组件分布在一个节点集群中。因此，记录所有重要信息并向每个日志条目添加诸如发生时间、发生组件和运行组件的节点等信息是有意义的。此外，日志信息应聚合在一个中央位置，以便开发人员和系统操作员可以进行分析。
- en: Tracing
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪
- en: Tracing is used to find out how an individual request is funneled through a
    distributed application and how much time is spent overall for the request and
    in every individual component. This information, if collected, can be used as
    one of the sources for dashboards that shows the behavior and health of the system.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪用于查找单个请求如何通过分布式应用程序进行传递，以及请求总共花费多少时间以及每个单独组件的时间。如果收集了这些信息，可以将其用作显示系统行为和健康状况的仪表板的信息源之一。
- en: Monitoring
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控
- en: Operation engineers like to have dashboards showing live key metrics of the
    system, which show them the overall health of the application at a glance. These
    metrics can be non-functional metrics, such as memory and CPU usage, the number
    of crashes of a system or application component, and the health of a node, as
    well as functional and, hence, application-specific metrics, such as the number
    of checkouts in an ordering system or the number of items out of stock in an inventory
    service.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 运维工程师喜欢有仪表板，显示系统的关键指标，让他们一目了然地了解应用程序的整体健康状况。这些指标可以是非功能指标，如内存和CPU使用情况，系统或应用程序组件的崩溃次数，节点的健康状况，以及功能和因此特定于应用程序的指标，如订单系统中的结账次数或库存服务中缺货商品的数量。
- en: Most often, the base data that's used to aggregate the numbers that are used
    for a dashboard is extracted from logging information. This can either be system
    logs, which will mostly be used for non-functional metrics, or application-level
    logs, for functional metrics.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，用于聚合仪表板使用的基础数据是从日志信息中提取的。这可以是系统日志，主要用于非功能指标，或者应用程序级别的日志，用于功能指标。
- en: Application updates
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序更新
- en: One of the competitive advantages for a company is to be able to react in a
    timely manner to changing market situations. Part of this is to be able to quickly
    adjust an application to fulfill new and changed needs or to add new functionality.
    The faster we can update our applications, the better. Many companies these days
    roll out new or changed features multiple times per day.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 公司的竞争优势之一是能够及时对不断变化的市场情况做出反应。其中一部分是能够快速调整应用程序以满足新的和变化的需求，或者添加新的功能。我们更新应用程序的速度越快，越好。如今，许多公司每天都会推出新的或更改的功能多次。
- en: Since application updates are so frequent, these updates have to be non-disruptive.
    We cannot allow the system to go down for maintenance when upgrading. It all has
    to happen seamlessly and transparently.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序更新频繁，这些更新必须是非中断的。在升级时，我们不能允许系统进行维护而停机。所有这些都必须无缝、透明地进行。
- en: Rolling updates
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滚动更新
- en: One way of updating an application or an application service is to use rolling
    updates. The assumption here is that the particular piece of software that has
    to be updated runs in multiple instances. Only then can we use this type of update.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 更新应用程序或应用程序服务的一种方法是使用滚动更新。这里的假设是需要更新的特定软件运行在多个实例中。只有在这种情况下，我们才能使用这种类型的更新。
- en: What happens is that the system stops one instance of the current service and
    replaces it with an instance of the new service. As soon as the new instance is
    ready, it will be served traffic. Usually, the new instance is monitored for some
    time to see whether or not it works as expected and, if it does, the next instance
    of the current service is taken down and replaced with a new instance. This pattern
    is repeated until all the service instances have been replaced.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 系统停止当前服务的一个实例，并用新服务的实例替换它。一旦新实例准备就绪，它将提供流量服务。通常，新实例会被监视一段时间，以查看它是否按预期工作，如果是，那么当前服务的下一个实例将被关闭并替换为新实例。这种模式重复进行，直到所有服务实例都被替换。
- en: Since there are always a few instances running at any given time, current or
    new, the application is operational all the time. No downtime is needed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于总是有一些实例在任何给定时间运行，当前或新的，应用程序始终处于运行状态。不需要停机时间。
- en: Blue-green deployments
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝绿部署
- en: In blue-green deployments, the current version of the application service, called **blue**,
    handles all the application traffic. We then install the new version of the application
    service, called **green**, on the production system. The new service is not wired
    with the rest of the application yet.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝绿部署中，应用服务的**当前**版本称为**蓝色**，处理所有应用流量。然后我们在生产系统上安装应用服务的新版本，称为**绿色**。新服务尚未与其余应用程序连接。
- en: 'Once **green** is installed, we can execute **smoke tests** against this new
    service and, if those succeed, the router can be configured to funnel all traffic
    that previously went to **blue** to the new service, **green**. The behavior of
    **green** is then observed closely and, if all success criteria are met, **blue**
    can be decommissioned. But if, for some reason, **green** shows some unexpected
    or unwanted behavior, the router can be reconfigured to return all traffic to
    blue. Green can then be removed and fixed, and a new blue-green deployment can
    be executed with the corrected version:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了**绿色**，我们可以对这项新服务执行**烟雾测试**，如果测试成功，路由器可以配置为将以前发送到**蓝色**的所有流量引导到新服务**绿色**。然后密切观察**绿色**的行为，如果所有成功标准都得到满足，**蓝色**可以被废弃。但是，如果由于某种原因**绿色**显示出一些意外或不需要的行为，路由器可以重新配置以将所有流量返回到蓝色。然后可以移除绿色并修复，然后可以使用修正版本执行新的蓝绿部署：
- en: '![](assets/ec84720c-9431-4c3a-90fb-bcffe0d5eaac.png)Blue-green deployment'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝绿部署
- en: Next, let's look at canary releases.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看金丝雀发布。
- en: Canary releases
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 金丝雀发布
- en: Canary releases are releases where we have the current version of the application
    service and the new version installed on the system in parallel. As such, they
    resemble blue-green deployments. At first, all traffic is still routed through
    the current version. We then configure a router so that it funnels a small percentage,
    say 1%, of the overall traffic to the new version of the application service.
    Subsequently, the behavior of the new service is monitored closely to find out
    whether it works as expected. If all the criteria for success are met, then the
    router is configured to funnel more traffic, say 5% this time, through the new
    service. Again, the behavior of the new service is closely monitored and, if it
    is successful, more and more traffic is routed to it until we reach 100%. Once
    all the traffic has been routed to the new service and it has been stable for
    some time, the old version of the service can be decommissioned.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 金丝雀发布是指在系统中并行安装当前版本的应用服务和新版本的发布。因此，它们类似于蓝绿部署。起初，所有流量仍然通过当前版本路由。然后我们配置路由器，使其将整体流量的一小部分，比如1%，引导到应用服务的新版本。随后，密切监视新服务的行为，以找出它是否按预期工作。如果满足了所有成功标准，那么就配置路由器，使其通过新服务引导更多的流量，比如这次是5%。再次密切监视新服务的行为，如果成功，就会将更多的流量引导到它，直到达到100%。一旦所有流量都被引导到新服务，并且它已经稳定了一段时间，旧版本的服务就可以被废弃。
- en: Why do we call this a canary release? It is named after the coal miners who
    would use canary birds as an early warning system in the mines. Canary birds are
    particularly sensitive to toxic gas and if such a canary bird died, the miners
    knew they had to abandon the mine immediately.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们称之为金丝雀发布？这是以煤矿工人为名，他们会在矿井中使用金丝雀作为早期警报系统。金丝雀对有毒气体特别敏感，如果这样的金丝雀死亡，矿工们就知道他们必须立即离开矿井。
- en: Irreversible data changes
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可逆的数据更改
- en: 'If part of our update process is to execute an irreversible change in our state,
    such as an irreversible schema change in a backing relational database, then we
    need to address this with special care. It is possible to execute such changes
    without downtime if we use the right approach. It is important to recognize that,
    in such a situation, we cannot deploy the code changes that require the new data
    structure in the data store at the same time as the changes to the data. Rather,
    the whole update has to be separated into three distinct steps. In the first step,
    we roll out a backward-compatible schema and data change. If this is successful,
    then we roll out the new code in the second step. Again, if that is successful,
    we clean up the schema in the third step and remove the backward compatibility:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的更新过程中包括在我们的状态中执行不可逆转的更改，比如在支持关系数据库中执行不可逆转的模式更改，那么我们需要特别小心处理这个问题。如果我们采用正确的方法，就可以在没有停机时间的情况下执行这些更改。重要的是要认识到，在这种情况下，我们不能同时部署需要新数据结构的代码更改和数据更改。相反，整个更新必须分为三个不同的步骤。在第一步中，我们推出一个向后兼容的模式和数据更改。如果这成功了，那么我们在第二步中推出新代码。同样，如果这成功了，我们在第三步中清理模式并删除向后兼容性：
- en: '![](assets/987dac84-2498-490e-af50-2f9bb870d341.png)Rolling out an irreversible
    data or schema change'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/987dac84-2498-490e-af50-2f9bb870d341.png)推出不可逆转的数据或模式更改'
- en: The preceding diagram shows how the data and its structure are updated, then
    how the application code is updated, and finally, in the third step, how the data
    and data structure are cleaned up.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了数据及其结构的更新，然后是应用程序代码的更新，最后，在第三步中，数据和数据结构是如何清理的。
- en: Rollback
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回滚
- en: If we have frequent updates for our application services that run in production,
    sooner or later, there will be a problem with one of those updates. Maybe a developer,
    while fixing a bug, introduced a new one, which was not caught by all the automated,
    and maybe manual, tests, so the application is misbehaving and it is imperative
    that we roll back the service to the previous good version. In this regard, a
    rollback is a recovery from a disaster.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用服务在生产中运行并经常更新，迟早会出现其中一个更新的问题。也许开发人员在修复错误时引入了一个新错误，这个错误没有被所有自动化测试和可能的手动测试捕捉到，因此应用程序表现异常，迫切需要将服务回滚到之前的良好版本。在这方面，回滚是从灾难中恢复。
- en: Again, in a distributed application architecture, it is not a question of whether
    a rollback will ever be needed, but rather when a rollback will have to occur.
    Thus, we need to be absolutely sure that we can always roll back to a previous
    version of any service that makes up our application. Rollbacks cannot be an afterthought;
    they have to be a tested and proven part of our deployment process.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在分布式应用程序架构中，问题不是是否会需要回滚，而是何时需要回滚。因此，我们必须确保我们始终可以回滚到我们应用程序中组成的任何服务的先前版本。回滚不能是事后想到的，它们必须是我们部署过程中经过测试和证明的一部分。
- en: If we are using blue-green deployments to update our services, then rollbacks
    should be fairly simple. All we need to do is switch the router from the new green
    version of the service back to the previous blue version.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在使用蓝绿部署来更新我们的服务，那么回滚应该是相当简单的。我们所需要做的就是将路由器从新的绿色版本的服务切换回之前的蓝色版本。
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned what a distributed application architecture is and
    what patterns and best practices are helpful or needed to successfully run a distributed
    application. Lastly, we discussed what more is needed to run such an application
    in production.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了分布式应用程序架构是什么，以及哪些模式和最佳实践对于成功运行分布式应用程序是有帮助或需要的。最后，我们讨论了在生产中运行这样的应用程序还需要什么。
- en: In the next chapter, we will dive into networking limited to a single host.
    We're going to discuss how containers living on the same host can communicate
    with each other and how external clients can access containerized applications
    if necessary.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入讨论仅限于单个主机的网络。我们将讨论同一主机上的容器如何相互通信，以及外部客户端如何在必要时访问容器化应用程序。
- en: Questions
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Please answer the following questions to assess your understanding of this
    chapter''s content:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请回答以下问题，以评估您对本章内容的理解：
- en: When and why does every part in a distributed application architecture have
    to be redundant? Explain in a few short sentences.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分布式应用架构中的每个部分何时何地需要冗余？用几句话解释。
- en: Why do we need DNS services? Explain in three to five sentences.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们需要DNS服务？用三到五句话解释。
- en: What is a circuit breaker and why is it needed?
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是断路器，为什么需要它？
- en: What are some of the important differences between a monolithic application
    and a distributed or multi-service application?
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单体应用程序和分布式或多服务应用程序之间的一些重要区别是什么？
- en: What is a blue-green deployment?
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是蓝绿部署？
- en: Further reading
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following articles provide more in-depth information regarding what was
    covered in this chapter:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文章提供了关于本章内容的更深入信息：
- en: Circuit breakers: [http://bit.ly/1NU1sgW](https://bit.ly/2pBENyP)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器：[http://bit.ly/1NU1sgW](https://bit.ly/2pBENyP)
- en: The OSI model explained: [http://bit.ly/1UCcvMt](https://bit.ly/2BIRpJY)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OSI模型解释：[http://bit.ly/1UCcvMt](https://bit.ly/2BIRpJY)
- en: Blue-green deployments: [http://bit.ly/2r2IxNJ](http://bit.ly/2r2IxNJ)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝绿部署：[http://bit.ly/2r2IxNJ](http://bit.ly/2r2IxNJ)
