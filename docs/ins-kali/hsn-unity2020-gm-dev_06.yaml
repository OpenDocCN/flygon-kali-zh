- en: '*Chapter 6*: Materials and Effects with URP and Shader Graph'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：使用URP和着色器图的材质和效果'
- en: Welcome to the first chapter of *Part 2*! I am super excited that you have reached
    this part of the book because here we will dive deep into different graphics and
    audio systems of Unity to dramatically improve the look and feel of the game.
    We will start this part with this chapter, where we will be discussing what the
    Shader of a Material is and how to create our own Shaders to achieve several custom
    effects that couldn't be accomplished using default Unity Shaders. We will be
    creating a simple water animation effect to learn this new concept.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到*第2部分*的第一章！我非常激动，因为你已经到达了这本书的这一部分，因为在这里，我们将深入研究Unity的不同图形和音频系统，以显着改善游戏的外观和感觉。我们将从这一部分开始，本章将讨论材质的着色器是什么，以及如何创建我们自己的着色器来实现一些无法使用默认Unity着色器实现的自定义效果。我们将创建一个简单的水动画效果来学习这个新概念。
- en: 'In this chapter, we will examine the following Shader concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下着色器概念：
- en: Introduction to Shaders
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着色器介绍
- en: Creating Shaders with Shader Graph
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用着色器图创建着色器
- en: Introducing Shaders
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍着色器
- en: We created Materials in the previous chapter, but we never discussed how they
    internally work and why the Shader property is super important. In this first
    section of the chapter, we will be exploring the concept of a Shader as a way
    to program the video card to achieve custom visual effects.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了材质，但我们从未讨论过它们内部是如何工作的，以及为什么着色器属性非常重要。在本章的第一部分，我们将探讨着色器的概念，作为编程视频卡以实现自定义视觉效果的一种方式。
- en: 'In this section, we will cover the following concepts related to Shaders:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将涵盖与着色器相关的以下概念：
- en: Shader Pipeline
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着色器管道
- en: Render Pipeline and URP
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染管道和URP
- en: URP Built-in Shaders
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URP内置着色器
- en: Let's start by discussing how a Shader modifies the Shader Pipeline to achieve
    effects.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从讨论着色器如何修改着色器管道以实现效果开始。
- en: Shader Pipeline
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 着色器管道
- en: Whenever a video card renders a 3D model, it needs input data to process, such
    as a Mesh, Textures, the transform of the object (position, rotation, and scale),
    and lights that affect that object. With that data, the video card must output
    the pixels of the object into the Back-Buffer, the image where the video card
    will be drawing our objects. That image will be shown when Unity finishes rendering
    all objects (and some effects) to display the finished scene. Basically, the Back-Buffer
    is the image the video card renders step by step, showing it when the drawing
    has finished (at that moment, it becomes the Front-Buffer, swapping with the previous
    one).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每当显卡渲染3D模型时，它需要输入数据进行处理，例如网格、纹理、对象的变换（位置、旋转和缩放）以及影响该对象的光源。有了这些数据，显卡必须将对象的像素输出到后备缓冲区，即视频卡将绘制我们对象的图像的地方。当Unity完成渲染所有对象（和一些效果）以显示完成的场景时，将显示该图像。基本上，后备缓冲区是显卡逐步渲染的图像，在绘制完成时显示出来（此时，它变成前置缓冲区，与之前的缓冲区交换）。
- en: That's the usual way to render an object, but what happens between the input
    of the data and the output of the pixels can be handled through a myriad of different
    ways and techniques that depend on how you want your object to look; maybe you
    want it to be realistic or look like a hologram, maybe the object needs a disintegration
    effect or a toon effect—there are endless possibilities. The way to specify how
    our video card will handle the render of the object is through a Shader.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是渲染对象的常规方式，但在输入数据和像素输出之间发生的事情可以通过许多不同的方式和技术来处理，这取决于您希望对象的外观如何；也许您希望它看起来很逼真或看起来像全息图，也许对象需要一个解体效果或卡通效果——可能有无尽的可能性。指定我们的显卡将如何处理对象的渲染的方式是通过着色器。
- en: A Shader is a program coded in a specific video card language, such as CG, HLSL,
    or GLSL, that configures different stages of the render process, sometimes not
    only configuring them but also replacing them with completely custom code to achieve
    the exact effect we want. All of the stages of rendering form what we call the
    Shader Pipeline, a chain of modifications applied to the input data until it's
    transformed into pixels.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器是用特定的显卡语言编写的程序，例如CG、HLSL或GLSL，它配置渲染过程的不同阶段，有时不仅配置它们，还用完全自定义的代码替换它们，以实现我们想要的精确效果。渲染的所有阶段形成了我们所说的着色器管道，一系列应用于输入数据的修改，直到它被转换为像素。
- en: Important note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Sometimes, what we called the Shader Pipeline in this book can be also found
    in another bibliography as the Render Pipeline, and whereas the latter is also
    correct, in Unity, the term Render Pipeline refers to something different, so
    let's stick with this name.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在本书中我们所说的着色器管道也可以在其他文献中被称为渲染管道，而后者也是正确的，在Unity中，渲染管道这个术语指的是不同的东西，所以让我们坚持这个名字。
- en: 'Each stage of the pipeline is in charge of different modifications and depending
    on the video card Shader Model, this pipeline can vary a lot. In the next diagram,
    you can find a simplified Render Pipeline, skipping advanced/optional stages that
    are not important right now:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 管道的每个阶段负责不同的修改，根据显卡着色器模型的不同，这个管道可能会有很大的变化。在下一个图表中，您可以找到一个简化的渲染管道，跳过了现在不重要的高级/可选阶段：
- en: '![Figure 6.1 – Common Shader Pipeline'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 – 常见着色器管道'
- en: '](img/Figure_6.01_B14199.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.01_B14199.jpg)'
- en: Figure 6.1 – Common Shader Pipeline
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 常见着色器管道
- en: 'Let''s discuss each of the stages:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论每个阶段：
- en: '**Input Assembler**: Here is where all of the mesh data, such as the vertex
    position, UVs, and normals, are assembled to be prepared for the next stage. You
    can''t do much here; this process is almost always the same.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入组装器**：这里是所有网格数据的组装地方，例如顶点位置、UV和法线，准备好进行下一阶段。在这里你不能做太多事情；这个过程几乎总是一样的。'
- en: '**Vertex Shader**: In the past, this stage was limited to applying the transformation
    of the object, the position and perspective of the camera, and some simple but
    limited lighting calculations. With modern GPUs, you are in charge of doing whatever
    you want. This stage receives each one of the vertexes of the object to render
    and outputs a modified one, so basically, you have the chance to modify the geometry
    of the object here. The usual code here is basically the same as old video cards
    had, applying the transform of the object, but you can do several effects such
    as inflating the object along its normals to apply the old toon effect technique
    or apply some distortions to make a hologram effect (look at the hologram effect
    in *Death Stranding*). There''s also the opportunity to calculate data for the
    next stages, but we won''t be going that deep for now.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点着色器**：过去，这个阶段仅限于应用对象的变换、相机的位置和透视以及一些简单但有限的光照计算。使用现代GPU，您可以自行决定。这个阶段接收要渲染的对象的每一个顶点，并输出一个修改过的顶点，因此基本上您有机会在这里修改对象的几何形状。这里的通常代码基本上与旧视频卡的代码相同，应用对象的变换，但您可以进行多种效果，比如沿着法线膨胀对象以应用旧的卡通效果技术，或者应用一些扭曲效果以制作全息效果（看看*死亡搁浅*中的全息效果）。还有机会计算下一个阶段的数据，但我们暂时不会深入讨论。'
- en: '**Culling**: For most of the models you are going to render, you will never
    see the backside of the model''s face. Let''s take as an example a cube; there''s
    no way to look at the back or inner side of any of its sides because they will
    be automatically occluded by the other sides. Knowing that, rendering both sides
    of each face of the cube, even if the backside can''t be seen, makes no sense,
    and luckily this stage takes care of that. Culling will determine whether the
    face needs to be rendered based on the orientation of the face, saving lots of
    pixel calculation for occluded faces. You can change this to behave differently
    for specific cases; as an example, we can create a glass box that needs to be
    transparent to see all sides of the box.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**裁剪**：对于大多数要渲染的模型，您永远不会看到模型面的背面。以立方体为例；无论如何都无法看到任何一面的背面或内侧，因为它们会被其他面自动遮挡。因此，渲染立方体每个面的两面，即使看不到背面，也是没有意义的，幸运的是，这个阶段会处理这个问题。裁剪将根据面的方向确定是否需要渲染面，从而节省了遮挡面的大量像素计算。您可以根据特定情况更改这一行为；例如，我们可以创建一个需要透明的玻璃箱，以便看到箱子的所有侧面。'
- en: '**Rasterizer**: Now that we have the modified and visible geometry of our model
    calculated, it''s time to convert it into pixels. The Rasterizer creates all pixels
    for the triangles of our mesh. Lots of things happen here but again, we have very
    little control over that; the usual way to rasterize is just to create all pixels
    inside the edges of the mesh triangles. We have other modes that just render the
    pixels on the edges to see a wireframe effect, but this is usually used for debugging
    purposes:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光栅化器**：现在我们已经计算出了修改过的可见几何模型，是时候将其转换为像素了。光栅化器为我们的网格三角形创建所有像素。这里发生了很多事情，但我们对此几乎没有控制权；通常的光栅化方式是在网格三角形的边缘内创建所有像素。我们还有其他模式，只渲染边缘上的像素以实现线框效果，但这通常用于调试目的：'
- en: '![Figure 6.2 – Example of figures being rasterized'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 - 光栅化的图例'
- en: '](img/Figure_6.02_B14199.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.02_B14199.jpg)'
- en: Figure 6.2 – Example of figures being rasterized
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 - 光栅化的图例
- en: '**Fragment Shader**: This is one of the most customizable stages of all. Its
    purpose is simple: just determine the color of each one of the fragments (pixels)
    that the rasterizer has generated. Here, lots of things can happen, from simply
    outputting a plain color or sampling a texture to applying complex lighting calculations
    such as normal mapping and PBR. Also, you can use this stage to create special
    effects such as water animations, holograms, distortions, disintegrations, and
    other special effects that require you to modify what the pixels look like. We
    will explore how we can use this stage in the next sections of this chapter.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**片段着色器**：这是所有阶段中最可定制的阶段之一。它的目的很简单：确定光栅化器生成的每个片段（像素）的颜色。在这里，可以发生很多事情，从简单地输出纯色或对纹理进行采样到应用复杂的光照计算，比如法线贴图和PBR。此外，您还可以使用这个阶段创建特殊效果，比如水动画、全息图、扭曲、解体和其他需要修改像素外观的特殊效果。我们将在本章的后续部分探讨如何使用这个阶段。'
- en: '**Depth Testing**: Before given the pixel as finished, we need to check whether
    the pixel can be seen. This stage checks whether the pixel''s depth is behind
    or in front of the previously rendered pixel, guaranteeing that regardless of
    the rendering order of the objects, the nearest pixels to the camera are always
    being drawn on top of others. Again, usually, this stage is left in its default
    state, prioritizing pixels that are nearer to the camera, but some effects require
    different behavior. As an example, in the next screenshot, you can see an effect
    that allows you to see objects that are behind other objects, such as units and
    buildings in *Age of Empires*:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度测试**：在将像素视为完成之前，我们需要检查像素是否可见。这个阶段检查像素的深度是在之前渲染的像素的后面还是前面，确保无论对象的渲染顺序如何，相机最近的像素始终位于其他像素的顶部。同样，通常情况下，这个阶段保持默认状态，优先考虑靠近相机的像素，但有些效果需要不同的行为。例如，在下一个截图中，您可以看到一种效果，它允许您看到其他对象后面的对象，比如*帝国时代*中的单位和建筑：'
- en: '![Figure 6.3 – Rendering the occluded parts of the character'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 - 渲染角色的遮挡部分'
- en: '](img/Figure_6.03_B14199.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.03_B14199.jpg)'
- en: Figure 6.3 – Rendering the occluded parts of the character
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 - 渲染角色的遮挡部分
- en: '**Blending**: Once the color of the pixel is determined and we are sure the
    pixel is not occluded by a previous pixel, the final step is to put it in the
    Back-Buffer (the frame or image you are drawing). The usual way to do this is
    to just override whatever pixel was in that position (because our pixel is nearer
    to the camera), but if you think about transparent objects, we need to combine
    our pixel with the previous one to make the transparency effect. Transparencies
    have other things to take into account aside from the blending, but the main idea
    is that blending controls exactly how the pixel will be combined with the previously
    rendered pixel in the Back-Buffer.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合**：一旦确定了像素的颜色，并且我们确定像素没有被前一个像素遮挡，最后一步就是将其放入后备缓冲区（正在绘制的帧或图像）。通常的做法是覆盖该位置的任何像素（因为我们的像素更接近相机），但是如果考虑透明物体，我们需要将我们的像素与前一个像素结合起来，以产生透明效果。透明度除了混合之外还有其他要考虑的事情，但主要思想是混合控制像素将如何与后备缓冲区中先前渲染的像素结合。'
- en: Shader Pipelines is a subject that would require an entire book, but for the
    scope of this book, the previous description will give you a good idea of what
    a Shader does, and the possible effects that it can achieve. Now that we have
    discussed how a Shader renders a single object, it is worth discussing how Unity
    renders all objects using Render Pipelines.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器管线是一个需要整本书来讨论的主题，但在本书的范围内，前面的描述将让您对着色器的功能以及可能实现的效果有一个很好的了解。现在我们已经讨论了着色器如何渲染单个对象，值得讨论的是Unity如何使用渲染管线渲染所有对象。
- en: Render Pipelines and URP
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染管线和URP
- en: We have covered how the video card renders an object, but Unity is in charge
    of asking the video card to execute its Shader Pipeline per object. To do so,
    Unity needs to do lots of preparations and calculations to determine exactly how
    and when each Shader needs to be executed. The responsibility of doing this is
    given to what Unity calls a Render Pipeline.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了视频卡如何渲染对象，但Unity负责要求视频卡对每个对象执行其着色器管线。为此，Unity需要进行大量的准备和计算，以确定每个着色器需要何时以及如何执行。负责执行此操作的是Unity所谓的渲染管线。
- en: A Render Pipeline is a way to draw the objects of a scene. At first, it sounds
    like there should be just one simple way of doing this, such as just iterating
    over all objects in the scene and executing the Shader Pipeline with the Shader
    specified in each object's Material, but it can be more complex than that. Usually,
    the main difference between one Render Pipeline and another is the way in which
    lighting and some advanced effects are calculated, but they can differ in other
    ways.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染管线是绘制场景中对象的一种方式。起初，听起来似乎应该只有一种简单的方法来做到这一点，例如只需迭代场景中的所有对象，并使用每个对象材质中指定的着色器执行着色器管线，但实际上可能比这更复杂。通常，一个渲染管线与另一个之间的主要区别在于光照和一些高级效果的计算方式，但它们也可能在其他方面有所不同。
- en: In previous Unity versions, there was just one single Render Pipeline, which
    is now called the Built-in Render Pipeline. It was a Pipeline that had all of
    the possible features you would need for all kinds of projects, from mobile 2D
    graphics and simple 3D graphics to cutting-edge 3D graphics what ones you can
    find on consoles or high-end PCs. This sounds ideal, but actually, it isn't; having
    one single giant renderer that needs to be highly customizable to adapt to all
    possible scenarios generates lots of overhead and limitations that cause more
    headaches than creating a custom Render Pipeline. Luckily, the latest version
    of Unity introduced the **Scriptable Render Pipelin**e (SRP), a way to create
    Render Pipelines adapted for your project.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的Unity版本中，只有一个单一的渲染管线，现在称为内置渲染管线。它是一个具有您在各种项目中所需的所有可能功能的管线，从移动2D图形和简单3D图形到主机或高端PC上可以找到的尖端3D图形。这听起来很理想，但实际上并非如此；拥有一个单一的巨大渲染器，需要高度可定制以适应所有可能情况，会产生大量的开销和限制，导致比创建自定义渲染管线更头疼。幸运的是，Unity的最新版本引入了**可编程渲染管线**（SRP），一种为您的项目创建适用的渲染管线的方法。
- en: 'Thankfully, Unity doesn''t want you to create your own Render Pipeline for
    each project (a complex task), so it created two custom Pipelines for you that
    are ready to use: URP (formerly called LWRP), which stands for Universal Render
    Pipeline, and HDRP, which stands for High Definition Render Pipeline. The idea
    is that you must choose one or the other based on your project requirements (unless
    you really need to create your own). URP, the one we selected when creating the
    project for our game, is a Render Pipeline suitable for most games that don''t
    require lots of advanced graphics features, such as mobile games or simple PC
    games, while HDRP is packed with lots of advanced rendering features for high-quality
    games. The latter requires high-end hardware to run, while URP runs in almost
    every relevant target device. It is worth mentioning that you can switch between
    Built-in Renderer, HDRP, and URP whenever you want, including after creating the
    project (not recommended):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Unity不希望您为每个项目创建自己的渲染管线（这是一项复杂的任务），因此它为您创建了两个定制的管线，可以立即使用：URP（以前称为LWRP），代表通用渲染管线，以及HDRP，代表高清晰度渲染管线。其想法是您必须根据项目要求选择其中一个（除非您真的需要创建自己的）。URP是我们为游戏创建项目时选择的一个渲染管线，适用于大多数不需要大量高级图形功能的游戏，例如移动游戏或简单的PC游戏，而HDRP则具有许多高级渲染功能，适用于高质量游戏。后者需要高端硬件才能运行，而URP可以在几乎所有相关目标设备上运行。值得一提的是，您可以随时在内置渲染器、HDRP和URP之间切换，包括在创建项目后（不建议）：
- en: '![Figure 6.4 – Project wizard showing HDRP and URP templates'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 – 项目向导显示HDRP和URP模板'
- en: '](img/Figure_6.04_B14199.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.04_B14199.jpg)'
- en: Figure 6.4 – Project wizard showing HDRP and URP templates
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 项目向导显示HDRP和URP模板
- en: 'We can discuss how each one is implemented and the differences between each,
    but again, this can fill entire chapters; right now, the idea of this section
    is for you to know why we picked URP when we created our project because it has
    some restrictions we will encounter throughout this book that we will need to
    take into account, so it is good to know why we accepted those limitations (to
    run our game on all relevant hardware). Also, we need to know that we have chosen
    URP because it has support for Shader Graph, the Unity tool that we will be using
    in this chapter to create custom effects. Previous Unity Built-in Pipelines didn''t
    provide us with such a tool (aside from third-party plugins). Finally, another
    reason to introduce the concept of URP is that it comes with lots of built-in
    Shaders that we will need to know about before creating our own to avoid reinventing
    the wheel, and to adapt ourselves to those Shaders, because if you came from previous
    versions of Unity, the ones you know won''t work here, and actually this is exactly
    what we are going to discuss in the next section of this book: the differences
    between the different URP Built-in Shaders.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以讨论每个着色器是如何实现的以及它们之间的区别，但是这可能会填满整整一章；现在，这一部分的想法是让你知道为什么我们在创建项目时选择了URP，因为它有一些限制，我们将在本书中遇到这些限制，所以了解为什么我们接受了这些限制是很重要的（为了在所有相关的硬件上运行我们的游戏）。此外，我们需要知道我们选择了URP是因为它支持Shader
    Graph，这是Unity工具，我们将在本章中使用它来创建自定义效果。以前的Unity内置管线没有为我们提供这样的工具（除了第三方插件）。最后，介绍URP的概念的另一个原因是它带有许多内置的着色器，我们需要在创建自己的着色器之前了解这些着色器，以避免重复造轮子，并且要适应这些着色器，因为如果你来自以前的Unity版本，你所了解的着色器在这里不起作用，实际上这正是我们将在本书的下一部分讨论的内容：不同URP内置着色器之间的区别。
- en: URP Built-in Shaders
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URP内置着色器
- en: 'Now that we know the difference between URP and other pipelines, let''s discuss
    which Shaders come integrated into URP. Let''s briefly describe the three most
    important Shaders in this Pipeline:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了URP和其他管线之间的区别，让我们讨论一下哪些着色器集成到了URP中。让我们简要描述一下这个管线中最重要的三个着色器：
- en: '**Lit**: This is the replacement of the old Standard Shader. This Shader is
    useful when creating all kinds of realistic Physics Materials such as wood, rubber,
    metal, skin, and combinations of them (such as a character with skin and metal
    armor). It supports Normal Mapping, Occlusion, Metallic and Specular Workflow,
    and transparencies.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lit**：这是旧的Standard Shader的替代品。当创建各种真实的物理材料时，比如木头、橡胶、金属、皮肤以及它们的组合（比如皮肤和金属盔甲的角色）时，这个着色器非常有用。它支持法线贴图、遮挡、金属和高光工作流程以及透明度。'
- en: '**Simple Lit**: This is the replacement of the old Mobile/Diffuse Shader. As
    the name suggests, this Shader is a simpler version of Lit, meaning that its lighting
    calculations are simpler approximations of how light works, getting fewer features
    than its counterpart. Basically, when you have simple graphics without realistic
    lighting effects, this is the best choice.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Simple Lit**：这是旧的Mobile/Diffuse Shader的替代品。顾名思义，这个着色器是Lit的简化版本，意味着它的光照计算是光照工作的简化近似，比其对应物少了一些功能。基本上，当你有简单的图形而没有真实的光照效果时，这是最好的选择。'
- en: '**Unlit**: This is the replacement of the old Unlit/Texture Shader. Sometimes,
    you need objects without lighting whatsoever, and in that case, this is the Shader
    for you. No lighting doesn''t mean an absence of light or complete darkness; it
    actually means that the object has no shadows at all, and it''s fully visible
    without any shade. Some simplistic graphics can work with this, relying on shadowing
    being baked in the texture, meaning that the texture comes with the shadow. This
    is extremely performant, especially for low-end devices such as mobile phones.
    Also, you have other cases such as light tubes or screens, objects that can''t
    receive shadows because they emit light, so they will be seen in full color even
    in complete darkness. In the following screenshot, you can see a 3D model using
    an Unlit Shader. It looks like it''s being lit, but it''s just the texture of
    the model with lighter and darker colors being applied in different parts of the
    object:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unlit**：这是旧的Unlit/Texture Shader的替代品。有时，你需要没有任何光照的对象，在这种情况下，这就是适合你的着色器。没有光照并不意味着没有光或完全黑暗；实际上，这意味着对象根本没有阴影，并且完全可见而没有任何阴影。一些简单的图形可以使用这个，依赖于阴影被烘焙在纹理中，这意味着纹理带有阴影。这是非常高效的，特别是对于移动电话等低端设备。此外，你还有其他情况，比如光管或屏幕，这些对象不能接收阴影，因为它们发出光，所以即使在完全黑暗中也会以全彩色显示。在下面的截图中，你可以看到一个使用Unlit
    Shader的3D模型。它看起来像是被照亮了，但实际上只是模型的纹理在对象的不同部分应用了较浅和较深的颜色：'
- en: '![Figure 6.5 – Pod using an Unlit effect to simulate cheap lighting'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5 - 使用无光效果模拟廉价照明的Pod'
- en: '](img/Figure_6.05_B14199.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.05_B14199.jpg)'
- en: Figure 6.5 – Pod using an Unlit effect to simulate cheap lighting
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 - 使用无光效果模拟廉价照明的Pod
- en: 'Let''s do an interesting disintegration effect with the Simple Lit Shader to
    demonstrate its capabilities. You must do the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Simple Lit Shader做一个有趣的分解效果来展示它的能力。你必须做以下操作：
- en: Download and import a **Cloud Noise** Texture from any search engine:![Figure
    6.6 – Noise Texture
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从任何搜索引擎下载并导入**Cloud Noise**纹理：![图6.6 - 噪音纹理
- en: '](img/Figure_6.06_B14199.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.06_B14199.jpg)'
- en: Figure 6.6 – Noise Texture
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 - 噪音纹理
- en: Select the recently imported texture in the Project Panel.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中选择最近导入的纹理。
- en: In the Inspector, set the **Alpha Source** property to **From Gray Scale**.
    This will mean the alpha channel of the texture will be calculated based on the
    grayscale of the image:![Figure 6.7 – Generate Alpha from Grayscale Texture setting
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，将**Alpha Source**属性设置为**From Gray Scale**。这意味着纹理的alpha通道将根据图像的灰度计算：![图6.7
    - 从灰度纹理生成Alpha纹理设置
- en: '](img/Figure_6.07_B14199.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.07_B14199.jpg)'
- en: Figure 6.7 – Generate Alpha from Grayscale Texture setting
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 - 从灰度纹理生成Alpha纹理设置
- en: Important note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The alpha channel of a color is often associated with transparency, but you
    will notice that our object won't be transparent. The Alpha channel is extra color
    data that can be used for several purposes when doing effects. In this case, we
    will use it to determine which pixels are deintegrated first.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色的Alpha通道通常与透明度相关联，但您会注意到我们的物体不会是透明的。Alpha通道是额外的颜色数据，可以在进行效果时用于多种目的。在这种情况下，我们将使用它来确定哪些像素首先被解体。
- en: Create a Material by clicking on the **+** icon in the Project View and selecting
    **Material**:![Figure 6.8 – Material creation button
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击项目视图中的**+**图标并选择**Material**来创建一个材质：![图6.8 – 材质创建按钮
- en: '](img/Figure_6.08_B14199.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.08_B14199.jpg)'
- en: Figure 6.8 – Material creation button
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 材质创建按钮
- en: Create a cube with the **GameObject | 3d Object | Cube** option at the top menu
    of Unity:![Figure 6.9 – Cube primitive creation
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Unity顶部菜单中的**GameObject | 3d Object | Cube**选项创建一个立方体：![图6.9 – 创建立方体原语
- en: '](img/Figure_6.09_B14199.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.09_B14199.jpg)'
- en: Figure 6.9 – Cube primitive creation
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – 创建立方体原语
- en: Drag the created Material from the Project Window to the cube to apply the Material.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目窗口将创建的材质拖动到立方体上应用材质。
- en: Click in the drop-down menu at the right of the Shader property in the Inspector
    and look for the **Universal Render Pipeline | Simple Lit** option:![Figure 6.10
    – Simple Lit Shader selection
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击检查器中Shader属性右侧的下拉菜单，并搜索**Universal Render Pipeline | Simple Lit**选项：![图6.10
    – 简单光照着色器选择
- en: '](img/Figure_6.10_B14199.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.10_B14199.jpg)'
- en: Figure 6.10 – Simple Lit Shader selection
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 – 简单光照着色器选择
- en: Select the **Material** and in **Base Map,** set the recently downloaded Cloud
    Noise Texture.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Material**，在**Base Map**中设置最近下载的Cloud Noise Texture。
- en: Check the `0.5`:![Figure 6.11 Alpha Clipping Threshold Material slider
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`0.5`：![图6.11阿尔法剪裁阈值材质滑块
- en: '](img/Figure_6.11_B14199.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.11_B14199.jpg)'
- en: Figure 6.11 Alpha Clipping Threshold Material slider
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 Alpha Clipping阈值材质滑块
- en: You will see how as you move the Alpha Clipping slider, the object starts to
    disintegrate. Alpha Clipping discards pixels that have less Alpha intensity than
    the style value:![Figure 6.12 Disintegration effect with Alpha Clipping
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您移动Alpha Clipping滑块时，您会看到物体开始崩解。Alpha Clipping会丢弃比样式值具有更低Alpha强度的像素：![图6.12带有Alpha
    Clipping的崩解效果
- en: '](img/Figure_6.12_B14199.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.12_B14199.jpg)'
- en: Figure 6.12 Disintegration effect with Alpha Clipping
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 带有Alpha Clipping的崩解效果
- en: Finally, set **Render Face** to **Both** to turn off the **Culling Shader Stage**
    and see both sides of the cube's faces:![Figure 6.13 Double-sided Alpha Clipping
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将**Render Face**设置为**Both**以关闭**Culling Shader Stage**并查看立方体面的两侧：![图6.13
    双面Alpha Clipping
- en: '](img/Figure_6.13_B14199.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.13_B14199.jpg)'
- en: Figure 6.13 Double-sided Alpha Clipping
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13 双面Alpha Clipping
- en: Take into account that the artist that creates the texture can configure the
    Alpha channel manually instead of calculating it from the grayscale, just to control
    exactly how the disintegration effect must look regardless of the texture´s color
    distribution.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，创建纹理的艺术家可以手动配置Alpha通道，而不是从灰度计算，只是为了精确控制崩解效果的外观，而不考虑纹理的颜色分布。
- en: The idea of this section is not to give a comprehensive guide to all of the
    properties of all URP Shaders, but to give you an idea of what a Shader can do
    when properly configured and when to use each one of the integrated Shaders. Sometimes,
    you can achieve the effect you need just by using existing Shaders. In fact, you
    can probably do so for probably 99% of the cases in simple games, so try to stick
    to them as much as you can. But if you really need to create a custom Shader to
    create a very specific effect, the next section will teach you how to use the
    URP tool called Shader Graph.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目的不是全面介绍所有URP Shader的所有属性，而是让您了解当正确配置Shader时Shader可以做什么，以及何时使用每个集成Shader。有时，您可以通过使用现有的Shader来实现所需的效果。实际上，在简单的游戏中，您可能可以在99%的情况下使用现有的Shader。因此，请尽量坚持使用它们。但是，如果确实需要创建自定义Shader来创建非常特定的效果，下一节将教您如何使用名为Shader
    Graph的URP工具。
- en: Creating Shaders with Shader Graph
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Shader Graph创建Shader
- en: Now that we know how Shaders work and the existing Shaders in URP, we have a
    basic notion of when it is necessary to create a custom Shader and when it is
    not necessary. In case you really need to create one, this section will cover
    the basics of effects creation with Shader Graph, a tool to create effects using
    a visual node-based editor, being an easy tool to use when you are not used to
    coding.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了Shader的工作原理以及URP中现有的Shader，我们对何时需要创建自定义Shader以及何时不需要有了基本概念。如果确实需要创建一个，本节将介绍使用Shader
    Graph创建效果的基础知识，Shader Graph是一种使用可视化节点编辑器创建效果的工具，在您不习惯编码时使用起来非常方便。
- en: 'In this section, we will discuss the following concepts of the Shader Graph:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论Shader Graph的以下概念：
- en: Creating our first Shader Graph
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个Shader Graph
- en: Using Textures
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纹理
- en: Combining Textures
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合纹理
- en: Applying Transparency
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用透明度
- en: Let's start seeing how we can create and use a Shader Graph.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始看看如何创建和使用Shader Graph。
- en: Creating our first Shader Graph asset
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的第一个Shader Graph资产
- en: 'Shader Graph is a tool that allows us to create custom effects using a node-based
    system. An effect in Shader Graph can look like the following screenshot, where
    you can see the nodes needed to create a hologram effect:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Shader Graph是一种工具，允许我们使用基于节点的系统创建自定义效果。Shader Graph中的效果可能看起来像以下截图，您可以看到创建全息效果所需的节点：
- en: '![Figure 6.14 Shader Graph with nodes to create a custom effect'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.14带有节点的Shader Graph以创建自定义效果'
- en: '](img/Figure_6.14_B14199.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.14_B14199.jpg)'
- en: Figure 6.14 Shader Graph with nodes to create a custom effect
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 Shader Graph带有节点以创建自定义效果
- en: We will discuss later what those nodes do and will do a step-by-step effect
    example, but in the screenshot, you can see how the author created and connected
    several nodes, which are those interconnected boxes, each one doing a specific
    process to achieve the effect. The idea of creating effects with Shader Graph
    is to learn which specific nodes you need and how to connect them properly, to
    create an "algorithm" or a series of ordered steps to achieve a specific result.
    This is similar to the way we code the gameplay of the game, but this Graph is
    adapted and simplified just for effect purposes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将讨论这些节点的作用，并进行逐步的效果示例，但在屏幕截图中，您可以看到作者创建并连接了几个节点，这些节点是相互连接的框，每个节点都执行特定的过程以实现效果。使用Shader
    Graph创建效果的想法是学习您需要哪些特定节点以及如何正确连接它们，以创建一个“算法”或一系列有序的步骤来实现特定的结果。这类似于我们编写游戏玩法的方式，但这个图表是专门为效果目的而调整和简化的。
- en: 'To create and edit our first Shader Graph asset, do the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和编辑我们的第一个Shader Graph资产，请执行以下操作：
- en: In the Project Window, click the **+** icon and find the **Shader | PBR Graph**
    option. This will create a Shader Graph using PBR mode, meaning that this Shader
    will support lighting effects (unlike Unlit Graphs):![Figure 6.15 PBR Shader Graph
    creation
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目窗口中，单击**+**图标，然后找到**Shader | PBR Graph**选项。这将使用PBR模式创建一个Shader Graph，这意味着这个Shader将支持照明效果（不像Unlit
    Graphs）:![图6.15 PBR Shader Graph创建
- en: '](img/Figure_6.15_B14199.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.15_B14199.jpg)'
- en: Figure 6.15 PBR Shader Graph creation
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 PBR Shader Graph创建
- en: Name it `WaterGraph`. If you lose the opportunity to rename the asset, remember
    that you can select the asset, right-click, and select **Rename**:![Figure 6.16
    Shader Graph Asset
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`WaterGraph`。如果您错过了重命名资产的机会，请记住您可以选择资产，右键单击，然后选择**重命名**：![图6.16 Shader
    Graph资产
- en: '](img/Figure_6.16_B14199.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.16_B14199.jpg)'
- en: Figure 6.16 Shader Graph Asset
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 Shader Graph资产
- en: Create a new Material called `WaterMaterial` and set **Shader** to **Shader
    Graphs/Water**. If for some reason Unity doesn't allow you to do that, try right-clicking
    **WaterGraph** and clicking **Reimport**. As you can see, the created Shader Graph
    asset now appears as a Shader in the Material, meaning that we have already created
    a custom Shader:![Figure 6.17 Setting a Shader Graph as a Material Shader
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`WaterMaterial`的新材质，并将**Shader**设置为**Shader Graphs/Water**。如果由于某种原因Unity不允许您这样做，请尝试右键单击**WaterGraph**，然后单击**Reimport**。正如您所看到的，创建的Shader
    Graph资产现在显示为材质中的Shader，这意味着我们已经创建了一个自定义Shader:![图6.17 将Shader Graph设置为材质Shader
- en: '](img/Figure_6.17_B14199.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.17_B14199.jpg)'
- en: Figure 6.17 Setting a Shader Graph as a Material Shader
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 将Shader Graph设置为材质Shader
- en: Create a Plane with the **GameObject | 3d Object | Plane** option.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**GameObject | 3d Object | Plane**选项创建一个平面。
- en: Drag the **Material** to the **Plane** to apply it.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**材质**拖动到**平面**上应用它。
- en: 'Now, you have created your first custom Shader and applied it to a Material.
    So far, it doesn''t look interesting at all—it''s just a gray effect, but now
    it''s time to edit the graph to unlock its full potential. As the name of the
    Graph suggests, we will be creating a water effect in this chapter to illustrate
    several nodes of the Shader Graph toolset and how to connect them, so let''s start
    by discussing the Master node. When you open the graph by double-clicking it,
    you will see the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，您已经创建了您的第一个自定义Shader并将其应用于材质。到目前为止，它看起来一点也不有趣——它只是一个灰色的效果，但现在是时候编辑图表以释放其全部潜力了。正如图表的名称所暗示的，本章中我们将创建一个水效果，以说明Shader
    Graph工具集的几个节点以及如何连接它们，因此让我们从讨论主节点开始。当您双击打开图表时，您将看到以下内容:'
- en: '![Figure 6.18 Master node with all of the properties needed to calculate object
    appearance'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.18 具有计算对象外观所需的所有属性的主节点'
- en: '](img/Figure_6.18_B14199.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.18_B14199.jpg)'
- en: Figure 6.18 Master node with all of the properties needed to calculate object
    appearance
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18 具有计算对象外观所需的所有属性的主节点
- en: All nodes will have input pins, the data they need to work, and output pins,
    which are the results of its process. As an example, in a sum operation, we will
    have two input numbers and an output number, the result of the sum. In this case,
    you can see that the Master node just has inputs, and that's because all data
    that enters the Master node will be used by Unity to calculate the Rendering and
    Lighting of the object, things such as the desired object color or texture (the
    Albedo input pin), how smooth it is (the Smoothness input pin), or how much metal
    it contains (the Metallic input pin), so they are all of the properties that will
    affect how the lighting will be applied to the object. In a sense, the input of
    this node is the output data of the entire graph and the ones we need to fill.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所有节点都有输入引脚，它们需要的数据，以及输出引脚，这是其过程的结果。例如，在求和运算中，我们将有两个输入数字和一个输出数字，即求和的结果。在这种情况下，您可以看到主节点只有输入，这是因为进入主节点的所有数据将被Unity用于计算对象的渲染和照明，诸如所需的对象颜色或纹理（反照率输入引脚），它有多光滑（光滑度输入引脚），或者它含有多少金属（金属输入引脚），因此它们都是将影响照明如何应用于对象的属性。在某种意义上，这个节点的输入是整个图的输出数据，也是我们需要填充的数据。
- en: 'Let''s start exploring how we can change that output data by doing the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们开始探索如何通过以下方式更改输出数据:'
- en: Double-click **Shader Graph** to open its editor window.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**Shader Graph**以打开其编辑窗口。
- en: Click in the gray rectangle to the left of the **Albedo** input pin:![Figure
    6.19 Albedo Master node input pin
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Albedo**输入引脚左侧的灰色矩形:![图6.19 反照率主节点输入引脚
- en: '](img/Figure_6.19_B14199.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.19_B14199.jpg)'
- en: Figure 6.19 Albedo Master node input pin
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19 反照率主节点输入引脚
- en: In the color picker, select a light blue color, like water. Select the bluish
    part of the circle around the picker and then a shade of that color in the middle
    rectangle:![Figure 6.20 Color picker
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在颜色选择器中，选择浅蓝色，就像水一样。选择选择器周围的蓝色部分，然后在中间矩形中选择该颜色的一种色调:![图6.20 颜色选择器
- en: '](img/Figure_6.20_B14199.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.20_B14199.jpg)'
- en: Figure 6.20 Color picker
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20 颜色选择器
- en: Set `0.9`:![Figure 6.21 Smoothness PBR Master node input pin
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`0.9`：![图6.21 光滑度PBR主节点输入引脚
- en: '](img/Figure_6.21_B14199.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.21_B14199.jpg)'
- en: Figure 6.21 Smoothness PBR Master node input pin
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21光滑度PBR主节点输入引脚
- en: Click the **Save Asset** button at the top-left of the window:![Figure 6.22
    Shader Graph saving options
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击窗口左上角的**保存资源**按钮：![图6.22 Shader Graph保存选项
- en: '](img/Figure_6.22_B14199.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.22_B14199.jpg)'
- en: Figure 6.22 Shader Graph saving options
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.22 Shader Graph保存选项
- en: 'Go back to the Scene View and check the plane is light blue and with the sun
    reflected on it:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到场景视图，检查平面是否为浅蓝色，并且有太阳的反射：
- en: '![Figure 6.23 Initial Shader Graph results'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.23初始Shader Graph结果'
- en: '](img/Figure_6.23_B14199.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.23_B14199.jpg)'
- en: Figure 6.23 Initial Shader Graph results
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.23初始Shader Graph结果
- en: As you can see, the behavior of the Shader varies according to the properties
    you set in the Master node, but so far, doing this is no different than creating
    an Unlit Shader and setting up its properties; the real power of Shader Graph
    is when you use nodes that do specific calculations as inputs of the Master node.
    We will start seeing the texturing nodes, which allow us to apply Textures to
    our model.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，着色器的行为根据您在主节点中设置的属性而变化，但到目前为止，这与创建无光着色器并设置其属性没有什么不同；Shader Graph的真正威力在于当您使用执行特定计算的节点作为主节点的输入时。我们将开始看到纹理节点，它们允许我们将纹理应用到我们的模型上。
- en: Using Textures
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纹理
- en: 'The idea of using Textures is to have an image applied to the model in a way
    that means we can paint different parts of the model with different colors. Remember
    that the model has the UV map, which allows Unity to know which part of the Texture
    will be applied to which part of the model:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纹理的想法是以一种方式将图像应用于模型，这意味着我们可以用不同的颜色涂抹模型的不同部分。请记住，模型有UV映射，这使得Unity知道纹理的哪个部分将应用于模型的哪个部分：
- en: '![Figure 6.24 On the left, a face texture; on the right, the same texture applied
    to a face mesh'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.24左侧是面部纹理；右侧是应用于面部网格的相同纹理'
- en: '](img/Figure_6.24_B14199.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.24_B14199.jpg)'
- en: Figure 6.24 On the left, a face texture; on the right, the same texture applied
    to a face mesh
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.24左侧是面部纹理；右侧是应用于面部网格的相同纹理
- en: 'We have several nodes to do this task, one of them being Sample Texture 2D,
    a node that has two main inputs. First, it asks us for the texture to sample or
    apply to the model and then the UV. You can see it in the following screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几个节点来执行此任务，其中之一是Sample Texture 2D，这是一个具有两个主要输入的节点。首先，它要求我们提供要对模型进行采样或应用的纹理，然后是UV。您可以在以下截图中看到它：
- en: '![Figure 6.25 Sample Texture node'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.25 Sample Texture节点'
- en: '](img/Figure_6.25_B14199.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.25_B14199.jpg)'
- en: Figure 6.25 Sample Texture node
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.25 Sample Texture节点
- en: 'As you can see, the default value of the Texture input node is **None**, so
    there''s no texture by default, and we need to manually specify that. For UV,
    the default value is UV0, meaning that, by default, the node will use the main
    UV channel of the model, and yes, a model can have several UVs set, but for now,
    we will stick with the main one. Let''s try this node, doing the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，纹理输入节点的默认值为**None**，因此默认情况下没有纹理，我们需要手动指定。对于UV，默认值为UV0，这意味着默认情况下，节点将使用模型的主UV通道，是的，一个模型可以设置多个UV，但现在我们将坚持使用主要的UV。让我们尝试这个节点，执行以下操作：
- en: Download and import a **Tileable Water Texture** from the internet:![Figure
    6.26 Water tileable Texture
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从互联网上下载并导入**可平铺的水纹理**：![图6.26可平铺的水纹理
- en: '](img/Figure_6.26_B14199.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.26_B14199.jpg)'
- en: Figure 6.26 Water tileable Texture
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.26可平铺的水纹理
- en: Select the Texture and be sure that the **Wrap Mode** property of the Texture
    is on **Repeat**, which will allow us to repeat the Texture as we did in the terrain,
    because the idea is to use this Shader to cover large water areas:![Figure 6.27
    Texture Repeat mode
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择纹理，并确保纹理的**包裹模式**属性为**重复**，这将允许我们像在地形中那样重复纹理，因为想法是使用此着色器覆盖大水域：![图6.27纹理重复模式
- en: '](img/Figure_6.27_B14199.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.27_B14199.jpg)'
- en: Figure 6.27 Texture Repeat mode
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.27纹理重复模式
- en: In the **Water Shader Graph**, right-click in an empty area of the **Shader
    Graph** and select **Create Node**:![Figure 6.28 Shader Graph Create Node option
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**水着色器图**中，在**Shader Graph**的空白区域右键单击并选择**创建节点**：![图6.28 Shader Graph创建节点选项
- en: '](img/Figure_6.28_B14199.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.28_B14199.jpg)'
- en: Figure 6.28 Shader Graph Create Node option
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.28 Shader Graph创建节点选项
- en: In the Search box, write `Sample texture` and all of the sample nodes will show
    up. Select **Sample Texture 2D** double clicking it:![Figure 6.29 Sample texture
    node search
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中，写入`Sample texture`，所有的示例节点都会显示出来。双击选择**Sample Texture 2D**：![图6.29 Sample
    texture节点搜索
- en: '](img/Figure_6.29_B14199.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.29_B14199.jpg)'
- en: Figure 6.29 Sample texture node search
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.29 Sample texture节点搜索
- en: Click in the circle to the left of the Texture input pin of the Sample Texture
    2D node. It will allow us to pick a Texture to sample—just select the water one.
    You can see that the Texture can be previewed in the bottom part of the node:![Figure
    6.30 Sample Texture node with a Texture in its input pin
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击Sample Texture 2D节点的纹理输入引脚左侧的圆圈。这将允许我们选择要采样的纹理—只需选择水纹理。您可以看到纹理可以在节点的底部部分预览：![图6.30带有输入引脚中纹理的Sample
    Texture节点
- en: '](img/Figure_6.30_B14199.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.30_B14199.jpg)'
- en: Figure 6.30 Sample Texture node with a Texture in its input pin
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.30带有输入引脚中纹理的Sample Texture节点
- en: Drag the output pin **RGBA** from the **Sample Texture 2D** node to the **Albedo**
    input pin of the Master node:![Figure 6.31 Connecting the results of a Texture
    sampling with the Albedo pin of the Master node
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Sample Texture 2D**节点的**RGBA**输出引脚拖动到主节点的**Albedo**输入引脚：![图6.31连接纹理采样的结果与主节点的反照率引脚
- en: '](img/Figure_6.31_B14199.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.31_B14199.jpg)'
- en: Figure 6.31 Connecting the results of a Texture sampling with the Albedo pin
    of the Master node
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.31 连接纹理采样的结果与主节点的反照率引脚
- en: 'Click the **Save Asset** button at the top-left part of the Shader Graph editor
    and see the changes in the scene view:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击Shader Graph编辑器左上角的**保存资源**按钮，查看场景视图中的更改：
- en: '![Figure 6.32 Results of applying a Texture in our Shader Graph'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.32应用纹理在我们的Shader Graph中的结果'
- en: '](img/Figure_6.32_B14199.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.32_B14199.jpg)'
- en: Figure 6.32 Results of applying a Texture in our Shader Graph
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.32 应用纹理在我们的着色器图中的结果
- en: 'As you can see, the texture is properly applied to the model, but if you take
    into account that the default plane has a size of 10x10 meters, the ripples of
    the water seem too big, so let''s tile the Texture! To do that, we need to change
    the UVs of the model, making them bigger. Bigger UVs sounds like the Texture should
    also get bigger, but take into account that we are not making the object bigger;
    we are just modifying the UV, so the same object size will read more of the texture,
    meaning that the bigger texture sample area will make repetitions of the texture
    and put them in the same object size, so that will be compressed inside the model
    area. To do so, follow the next steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，纹理已经正确应用到了模型，但是如果考虑到默认平面的大小是10x10米，水波似乎太大了，所以让我们平铺纹理！为此，我们需要改变模型的UV，使它们变大。更大的UV听起来意味着纹理也应该变大，但要考虑到我们并没有使物体变大；我们只是修改了UV，所以相同的物体大小将读取更多的纹理，这意味着更大的纹理采样区域将使纹理重复，并将它们放在相同的物体大小内，因此将被压缩在模型区域内。为此，请按照以下步骤进行：
- en: Right-click in any empty space area and click **New Node** to search the UV
    node:![Figure 6.33 Searching for the UV node
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击任何空白区域，然后单击**新建节点**来搜索UV节点：![图6.33 寻找UV节点
- en: '](img/Figure_6.33_B14199.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.33_B14199.jpg)'
- en: Figure 6.33 Searching for the UV node
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.33 寻找UV节点
- en: Using the same method create a **Multiply** node.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的方法创建一个**乘以**节点。
- en: Set the `4`,`4`,`4`,`4`):![Figure 6.34 Multiplying the UVs by 4
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`4`,`4`,`4`,`4`):![图6.34 将UV乘以4
- en: '](img/Figure_6.34_B14199.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.34_B14199.jpg)'
- en: Figure 6.34 Multiplying the UVs by 4
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.34 将UV乘以4
- en: Drag the **Out** pin of the UV node to the **A** pin of the **Multiply** node
    to connect them.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将UV节点的**Out**引脚拖动到**乘以**节点的**A**引脚上连接它们。
- en: Drag the **Out** pin of the **Multiply** node to the **UV** pin of the **Sample
    Texture 2D** node to connect them:![Figure 6.35 Using the multiplied UVs to sample
    the Texture
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**乘以**节点的**Out**引脚拖动到**采样纹理2D**节点的**UV**引脚上连接它们：![图6.35 使用乘以后的UV来采样纹理
- en: '](img/Figure_6.35_B14199.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.35_B14199.jpg)'
- en: Figure 6.35 Using the multiplied UVs to sample the Texture
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.35 使用乘以后的UV来采样纹理
- en: 'If you save the graph and go back to the Scene View, you can see that now the
    ripples are smaller, because we have tiled the UVs of our model. You can also
    see that in the preview of the **Sampler Texture 2D** node:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你保存了图表并返回到场景视图，你会看到现在涟漪变小了，因为我们已经平铺了模型的UV。你还可以在**采样纹理2D**节点的预览中看到：
- en: '![ Figure 6.36 Results of the model''s UV multiplication'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.36 模型UV乘法的结果'
- en: '](img/Figure_6.36_B14199.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.36_B14199.jpg)'
- en: Figure 6.36 Results of the model's UV multiplication
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.36 模型UV乘法的结果
- en: 'Another interesting effect we can do now is to apply an Offset to the Texture
    to move it. The idea is that even if the plane is not actually moving, we will
    simulate the flow of the water through it, moving just the Texture. Remember,
    the responsibility of determining the part of the Texture to apply to each part
    of the model belongs to the UV, so if we add values to the UV coordinates, we
    will be moving them, generating a Texture sliding effect. To do so, let''s do
    the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以做另一个有趣的效果，就是对纹理应用偏移来移动它。即使平面实际上并没有移动，我们也会通过移动纹理来模拟水流动，只是移动纹理。记住，确定纹理的哪一部分应用到模型的哪一部分的责任属于UV，所以如果我们给UV坐标添加值，我们将移动它们，产生纹理滑动效果。为此，让我们按照以下步骤进行：
- en: Create an **Add** node to the right of the **Multiply** node.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**乘以**节点的右侧创建一个**Add**节点。
- en: Connect the **Out** pin of the UV to the **A** pin of the **Add** node:![Figure
    6.37 Adding values to the UVs
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将UV的**Out**引脚连接到**Add**节点的**A**引脚：![图6.37 给UV添加值
- en: '](img/Figure_6.37_B14199.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.37_B14199.jpg)'
- en: Figure 6.37 Adding values to the UVs
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.37 给UV添加值
- en: Create a **Time** node at the left of the **Add** node.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Add**节点的左侧创建一个**Time**节点。
- en: Connect the **Time** node to the **B** pin of the **Add** node:![Figure 6.38
    Adding time to the UVs
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Time**节点连接到**Add**节点的**B**引脚：![图6.38 给UV添加时间
- en: '](img/Figure_6.38_B14199.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.38_B14199.jpg)'
- en: Figure 6.38 Adding time to the UVs
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.38 给UV添加时间
- en: Connect the **Out** pin of the **Add** node to the **A** input pin of the **Multiply**
    node:![Figure 6.39 Added and multiplied UVs as an input of the Sample Texture
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Add**节点的**Out**引脚连接到**乘以**节点的**A**输入引脚：![图6.39 添加和乘以UV作为采样纹理的输入
- en: '](img/Figure_6.39_B14199.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.39_B14199.jpg)'
- en: Figure 6.39 Added and multiplied UVs as an input of the Sample Texture
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.39 添加和乘以UV作为采样纹理的输入
- en: Save and see the water moving in the Scene View.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并在场景视图中看到水流动。
- en: If you feel the water is moving too fast, try to use the multiplication node
    to make the time a smaller value. I recommend you try it by yourself before looking
    at the next screenshot, which has the answer:![Figure 6.40 Multiplication of time
    to move it faster
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你觉得水流动得太快，尝试使用乘法节点使时间变小。我建议你在查看下一个屏幕截图之前自己尝试一下，那里有答案：![图6.40 时间乘法以加快移动速度
- en: '](img/Figure_6.40_B14199.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.40_B14199.jpg)'
- en: Figure 6.40 Multiplication of time to move it faster
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.40 时间乘法以加快移动速度
- en: 'If you feel the graph is starting to get bigger, try to hide some of the node
    previews by clicking on the up arrow that appears on the preview when you move
    the mouse over it:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你觉得图表开始变得更大，尝试通过点击预览上出现的上箭头来隐藏一些节点的预览：
- en: '![ Figure 6.41 Hiding the preview and unused pins from the graph nodes'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.41 隐藏图表节点的预览和未使用的引脚'
- en: '](img/Figure_6.41_B14199.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.41_B14199.jpg)'
- en: Figure 6.41 Hiding the preview and unused pins from the graph nodes
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.41 隐藏图表节点的预览和未使用的引脚
- en: So, to recap, first we added the time to the UV to move it and then multiplied
    the result of the moved UV to make it bigger to tile the Texture. It is worth
    mentioning that there's a Tiling and Offset node that does all of this for us,
    but I wanted to show you how a simple multiplication to scale the UV and an add
    operation to move it generated a nice effect; you can't imagine all of the possible
    effects you can achieve with other simple mathematical nodes! Actually, let's
    explore other usages of mathematical nodes to combine Textures in the next section.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简而言之，首先我们将时间添加到UV中以移动它，然后将移动后的UV的结果乘以使其变大以平铺纹理。值得一提的是，有一个平铺和偏移节点可以为我们完成所有这些工作，但我想向您展示一个简单的乘法来缩放UV和一个加法操作来移动它是如何产生一个不错的效果的；您无法想象使用其他简单数学节点可以实现的所有可能效果！实际上，让我们在下一节中探索数学节点的其他用途，以组合纹理。
- en: Combining Textures
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合纹理
- en: 'Even though we have used nodes, we haven''t created anything that can''t be
    created using regular Shaders, but that''s about to change. So far, we can see
    the water moving but it still look static, and that''s because the ripples are
    always the same. We have several techniques to generate ripples, and the simplest
    one would be to combine two water Textures moving in different directions to mix
    their ripples, and actually, we can simply use the same Texture, just flipped,
    to save some memory. To combine the Textures, we will sum them and then divide
    them by 2, so basically, we are calculating the average of the textures! Let''s
    do that by doing the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '尽管我们使用了节点，但我们并没有创建任何不能使用常规着色器创建的东西，但这将发生改变。到目前为止，我们可以看到水在移动，但它看起来仍然是静态的，这是因为涟漪总是相同的。我们有几种生成涟漪的技术，最简单的一种是将两个以不同方向移动的水纹理组合在一起以混合它们的涟漪，实际上，我们可以简单地使用相同的纹理，只是翻转了一下，以节省一些内存。为了组合这些纹理，我们将它们相加，然后除以2，所以基本上，我们正在计算纹理的平均值！让我们通过以下方式来做到这一点:'
- en: Select all of the nodes between **Time** and **Sampler 2D** (including them),
    creating a selection rectangle by clicking in any empty space in the graph, holding
    and dragging the click, and then releasing when all target nodes are covered:![Figure
    6.42 Selecting several nodes
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**时间**和**采样器2D**之间的所有节点（包括它们），通过单击图表中的任何空白处创建一个选择矩形，按住并拖动单击，然后在所有目标节点都被覆盖时释放:![图6.42
    选择多个节点
- en: '](img/Figure_6.42_B14199.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.42_B14199.jpg)'
- en: Figure 6.42 Selecting several nodes
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.42 选择多个节点
- en: Right-click and select **Copy**, and then again right-click and select **Paste**,
    or use the classic *Ctrl* + *C*, *Ctrl* + *V* commands (*command* + *C*, *command*
    + *V* in Mac), or just *Ctrl* + *D* (*command* + *D*).
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并选择**复制**，然后再次右键单击并选择**粘贴**，或使用经典的*Ctrl* + *C*，*Ctrl* + *V*命令（Mac中为*command*
    + *C*，*command* + *V*），或只需*Ctrl* + *D*（*command* + *D*）。
- en: Move the copied nodes below the original ones:![Figure 6.43 Duplication of nodes
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将复制的节点移动到原始节点下方:![图6.43 节点的复制
- en: '](img/Figure_6.43_B14199.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.43_B14199.jpg)'
- en: Figure 6.43 Duplication of nodes
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.43 节点的复制
- en: For the copied nodes, set the `-4`,`-4`,`-4`,`-4`). You can see that that flipped
    the texture.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于复制的节点，设置为`-4`,`-4`,`-4`,`-4`)。您可以看到纹理已经翻转了。
- en: Also, set the `-0.1`:![Figure 6.44 Multiplication of values
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要设置为`-0.1`:![图6.44 值的乘法
- en: '](img/Figure_6.44_B14199.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.44_B14199.jpg)'
- en: Figure 6.44 Multiplication of values
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.44 值的乘法
- en: Create an **Add** node at the right of both Sampler Texture 2D nodes and connect
    the outputs of those nodes as the **A** and **B** input pins of the **Add** node:![Figure
    6.45 Adding two Textures
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个采样器纹理2D节点的右侧创建一个**加法**节点，并将这些节点的输出连接到**加法**节点的**A**和**B**输入引脚:![图6.45 添加两个纹理
- en: '](img/Figure_6.45_B14199.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.45_B14199.jpg)'
- en: Figure 6.45 Adding two Textures
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.45 添加两个纹理
- en: You can see that the resulting combination is too bright because we have summed
    up the intensity of both textures, so let's fix that by multiplying the `0.5,0.5,0.5,0.5`),
    which will divide each resulting color channel by 2, averaging the color:![Figure
    6.46 Dividing the sum of two Textures to get the average
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以看到，由于我们对两种纹理的强度进行了求和，所以得到的组合太亮了，让我们通过乘以`0.5,0.5,0.5,0.5`来修复这个问题，这将把每个结果颜色通道除以2，从而平均颜色:![图6.46
    将两个纹理的总和除以得到平均值
- en: '](img/Figure_6.46_B14199.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.46_B14199.jpg)'
- en: Figure 6.46 Dividing the sum of two Textures to get the average
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.46 将两个纹理的总和除以得到平均值
- en: Connect the **Out** pin of the **Multiply** node to the **Albedo** pin of the
    Master node to apply all of those calculations as the color of the object.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**乘法**节点的**输出**引脚连接到主节点的**反照率**引脚，以将所有这些计算应用为对象的颜色。
- en: 'Save the **Asset** and see the results in the Scene View:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '保存**资产**并在场景视图中查看结果:'
- en: '![Figure 6.47 Results of texture blending'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.47 纹理混合的结果'
- en: '](img/Figure_6.47_B14199.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.47_B14199.jpg)'
- en: Figure 6.47 Results of texture blending
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.47 纹理混合的结果
- en: You can keep adding nodes to make the effect more diverse, such as using Sinus
    nodes to apply non-linear movements and so on, but I will let you learn that by
    experimenting with this by yourself. For now, we will stop here. As always, this
    topic deserves a full book, and the intention of this chapter is to give you a
    small taste of this powerful Unity tool. I recommend you look for other Shader
    Graphs examples on the internet to learn other usages of the same nodes and, of
    course, new nodes. One thing to consider here is that everything we just did is
    basically applied to the Fragment Shader stage of the Shader Pipeline we discussed
    earlier. Now, let's use the Blending Shader stage to apply some transparency to
    the water.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以继续添加节点以使效果更加多样化，例如使用正弦节点应用非线性运动等，但我会让您自己通过实验来学习。现在，我们就到这里。一如既往，这个主题值得一本完整的书，本章的目的是让您对这个强大的Unity工具有一个初步了解。我建议您在互联网上寻找其他Shader
    Graph示例，以了解相同节点的其他用法，当然还有新节点。需要考虑的一件事是，我们刚刚做的一切基本上都应用于我们之前讨论的Shader Pipeline的片段着色器阶段。现在，让我们使用混合着色器阶段为水应用一些透明度。
- en: Applying transparency
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用透明度
- en: 'Before declaring our effect finished, a little addition we can do is to make
    the water a little bit transparent. Remember that the Shader Pipeline has this
    Blending stage, which has the responsibility of blending each pixel of our model
    into the image being rendered in this frame. The idea is to make our Shader Graph
    modify that stage to apply an Alpha Blending, a blending that combines our model
    and the previous rendered models based on the Alpha value of our model. To get
    that effect, do the following steps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在宣布我们的效果完成之前，我们可以做一个小小的添加，让水变得稍微透明一点。记住，Shader Pipeline有一个混合阶段，负责将我们模型的每个像素混合到当前帧渲染的图像中。我们的Shader
    Graph的想法是修改这个阶段，应用Alpha混合，根据我们模型的Alpha值将我们的模型与先前渲染的模型进行混合。为了实现这个效果，执行以下步骤：
- en: Click the wheel at the top-right part of the Master node.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击主节点右上角的轮子。
- en: Set **Surface property** to **Transparent**.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**表面属性**设置为**透明**。
- en: Set the **Blend** property to **Alpha** if it isn't already at that value:![Figure
    6.48 PBR Master node settings
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果**Blend**属性不是Alpha，请将其设置为**Alpha**：![图6.48 PBR主节点设置
- en: '](img/Figure_6.48_B14199.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.48_B14199.jpg)'
- en: Figure 6.48 PBR Master node settings
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.48 PBR主节点设置
- en: Set the `0.5`:![Figure 6.49 Setting the Alpha of the Master node
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“0.5”设置为：![图6.49 设置主节点的Alpha
- en: '](img/Figure_6.49_B14199.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.49_B14199.jpg)'
- en: Figure 6.49 Setting the Alpha of the Master node
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.49 设置主节点的Alpha
- en: Save the graph and see the transparency being applied in the Scene View. If
    you can't see the effect, just put a cube in the water to make the effect more
    evident:![Figure 6.50 Shadows from the water being applied to a cube
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存图表，查看透明度在场景视图中的应用。如果你看不到效果，只需在水中放一个立方体，使效果更加明显：![图6.50 水的阴影应用到立方体上
- en: '](img/Figure_6.50_B14199.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.50_B14199.jpg)'
- en: Figure 6.50 Shadows from the water being applied to a cube
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.50 水的阴影应用到立方体上
- en: You can see the shadows that the water is casting on our cube. That's because
    Unity doesn't detect that the object is transparent, so it thinks that it must
    cast shadows, so let's disable them. Click on the water plane and look for the
    Mesh Renderer component in the Inspector.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以看到水投射在我们立方体上的阴影。这是因为Unity没有检测到对象是透明的，所以它认为必须投射阴影，所以让我们禁用它们。点击水平面，在检视器中查找Mesh
    Renderer组件。
- en: 'In the **Lighting** section, set **Cast Shadows** to **Off**; this will disable
    shadow casting from the Plane:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**照明**部分，将**投射阴影**设置为**关闭**；这将禁用平面的阴影投射：
- en: '![Figure 6.51 Disabling shadow casting'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.51 禁用投射阴影'
- en: '](img/Figure_6.51_B14199.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.51_B14199.jpg)'
- en: Figure 6.51 Disabling shadow casting
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.51 禁用投射阴影
- en: 'Adding transparency is a simple process but has its caveats, such as the shadow
    problem, and in more complex scenarios, it can have other problems, so I would
    suggest that you avoid using transparency unless it is necessary. Actually, our
    water can live without transparency, especially when we apply this water to the
    river basin around the base, because we don''t need to see what''s under the water,
    but the idea is for you to know all of your options. In the next screenshot, you
    can see how we have put a giant plane with this effect below our base, big enough
    to cover the entire basin:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 添加透明度是一个简单的过程，但也有其注意事项，比如阴影问题，在更复杂的场景中可能会有其他问题，所以我建议除非必要，否则避免使用透明度。实际上，我们的水可以不透明，特别是当我们将这种水应用到基地周围的河盆时，因为我们不需要看到水下的东西，但是我希望你知道所有的选择。在下一个截图中，你可以看到我们在基地下方放了一个巨大的平面，足够大以覆盖整个盆地：
- en: '![Figure 6.52 Using our water in the main scene'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.52 在主场景中使用我们的水'
- en: '](img/Figure_6.52_B14199.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.52_B14199.jpg)'
- en: Figure 6.52 Using our water in the main scene
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.52 在主场景中使用我们的水
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed how a Shader works using a GPU and how to create
    our first simple Shader to achieve a nice water effect. Using Shaders is a complex
    and interesting job, and in a team, there are usually one or more people in charge
    of creating all of these effects, in a position called technical artist; so, as
    you can see, this topic can expand up to become a whole career. Remember, the
    intention of this book is to give you a small taste of all the possible roles
    you can take in the industry, so if you really liked this role, I suggest you
    start reading Shader-exclusive books. You have a long but super-interesting road
    in front of you.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Shader如何利用GPU工作，以及如何创建我们的第一个简单Shader来实现一个漂亮的水效果。使用Shader是一项复杂而有趣的工作，在团队中通常有一名或多名负责创建所有这些效果的人，这个职位被称为技术艺术家；所以，你可以看到，这个话题可以扩展成一个完整的职业。请记住，本书的目的是让你对行业中可能承担的各种角色有一点点了解，所以如果你真的喜欢这个角色，我建议你开始阅读专门讨论Shader的书籍。你面前有一条漫长但非常有趣的道路。
- en: But enough Shaders, for now—let's move to the next topic about improving graphics
    and creating visual effects with particle systems!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在先不谈Shader了，让我们转到下一个话题，讨论如何通过粒子系统改善图形并创建视觉效果！
