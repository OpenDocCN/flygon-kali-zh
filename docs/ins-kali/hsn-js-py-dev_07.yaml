- en: 'Hello World! and Beyond: Your First Application'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 'Hello World! and Beyond: Your First Application'
- en: Ah, the venerable "Hello World!" script. While very simple, it's a good first
    test of any language. Let's do a little more than just saying hello, though; let's
    work with several small applications that we'll use to get our hands dirty. After
    all, there's more to programming than just theory. We'll take a look at a common
    problem presented in coding challenges, as well as understand *how *our programs
    are working.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，那个古老的“Hello World!”脚本。虽然非常简单，但它是对任何语言的一个很好的第一次测试。不过，让我们做得更多一点，不仅仅是说hello；让我们用几个小应用程序来动手。毕竟，编程不仅仅是理论。我们将看一下编码挑战中提出的一个常见问题，以及*我们的程序是如何工作的。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: I/O with the console and alert messages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制台和警报消息的I/O
- en: Working with input in a function
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数中处理输入
- en: Using objects as a datastore
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象作为数据存储
- en: Understanding scope
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解作用域
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Clone or download the repository for this book from [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers)
    and prepare to look through the `Chapter-5` material.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers)克隆或下载本书的存储库，并准备查看`Chapter-5`的材料。
- en: I/O with the console and alert messages
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制台和警报消息的I/O
- en: 'So far, we''ve seen how JavaScript can output information to the user. Consider
    the following code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了JavaScript如何向用户输出信息。考虑以下代码：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, if we execute `Riker.sayHello()`, we will see the following in the console:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们执行`Riker.sayHello()`，我们将在控制台中看到以下内容：
- en: '![](assets/31e31351-b7e6-4a17-86a6-6c02c9132141.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/31e31351-b7e6-4a17-86a6-6c02c9132141.png)'
- en: Figure 5.1 – Console output
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 - 控制台输出
- en: 'Take a look for yourself in the `chapter-5` directory in the repository: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/console.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/console.html).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库的`chapter-5`目录中自己看一看：[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/console.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/console.html)。
- en: 'OK, great. We have some console output, but that''s not a very efficient way
    to get output, as users don''t typically have the console open. There is a convenient
    method for output that, while not practical for a fully fledged web application,
    is useful for testing and debugging purposes: `alert()`. Here''s an example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，太好了。我们有一些控制台输出，但这不是一个很有效的输出方式，因为用户通常不会打开控制台。有一种方便的输出方法，虽然不适用于完整的网络应用程序，但对于测试和调试目的很有用：`alert()`。以下是一个例子：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Try running the preceding code from [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/alert.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/alert.html)
    . What do you see?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/alert.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/alert.html)运行上述代码。你看到了什么？
- en: '![](assets/1c244f86-7b66-4680-9d48-0782961ced06.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1c244f86-7b66-4680-9d48-0782961ced06.png)'
- en: Figure 5.2 – Alert message
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 - 警报消息
- en: Wonderful! We have one of those little annoying popups that you may have seen
    around the web. While they can be annoying when used improperly, they can be very
    handy when used appropriately.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们有一个那种你可能在网上见过的烦人的小弹出框。当使用不当时，它们可能很烦人，但在适当的时候，它们可以非常有用。
- en: 'Let''s take a look at something similar that will give us *input* from the
    user ([https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/prompt.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/prompt.html)):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个类似的东西，它将从用户那里得到*输入*([https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/prompt.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-5/alerts-and-prompts/prompt.html))：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you load the page, you will see a pop-up box with the input field. Enter
    `name`, `rank`, or `posting` to see the result. If you refresh and enter something
    other than those options, you should get a response of Value not found.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你加载页面时，你会看到一个带有输入字段的弹出框。输入`name`、`rank`或`posting`，然后查看结果。如果刷新并输入除这些选项之外的内容，你应该会得到一个值未找到的响应。
- en: 'Ah! But let''s also take a look at the following line:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 啊！但让我们也看看以下一行：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since this is frontend JavaScript, we don't know exactly what the user will
    enter, so we should plan for slight misformats. Data sanitization is a whole other
    topic, so for now, let's just agree that we can lowercase the whole string to
    match the expected values.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是前端JavaScript，我们不知道用户会输入什么，所以我们应该考虑轻微的格式错误。数据净化是另一个话题，所以现在，让我们同意我们可以将整个字符串转换为小写以匹配预期的值。
- en: So far, so good. Now, let's take a look at how `answer` is used.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很好。现在，让我们看看`answer`是如何使用的。
- en: Working with input in a function
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在函数中处理输入
- en: 'If we take a look at the preceding object, we''ll see the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下前面的对象，我们会看到以下内容：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since we're dealing with arbitrary input, the first thing we're doing is checking
    against our array of answers to see whether the property requested exists. If
    it does not, a simple error message is alerted. If it *is* found, then we can
    alert the value. If you remember from [Chapter 3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml),
    *Nitty-Gritty Grammar*, object properties can be accessed via **dot notation**
    and **bracket notation**. In this case, we're working with a variable as the key,
    so we *can't* do this because it would be interpreted as the key. Thus, we use
    bracket notation to access the proper object value.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理任意输入，我们首先要做的是检查我们的答案数组，看看所请求的属性是否存在。如果不存在，就会弹出一个简单的错误消息。如果找到了，那么我们可以弹出该值。如果你还记得[第3章](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml)中的内容，*Nitty-Gritty
    Grammar*，对象属性可以通过**点表示法**和**括号表示法**来访问。在这种情况下，我们正在使用一个变量作为键，所以我们*不能*这样做，因为它会被解释为键。因此，我们使用括号表示法来访问正确的对象值。
- en: Exercise – Fibonacci sequence
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习-斐波那契数列
- en: For this exercise, construct a function to take a number. The end result should
    be the sum of numbers in the Fibonacci sequence ([https://en.wikipedia.org/wiki/Fibonacci_number](https://en.wikipedia.org/wiki/Fibonacci_number))
    up to the specified number you entered. The first few numbers of the sequence
    are `[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]`. Each number is the sum of the previous
    two numbers; for example, `f[6] = 13` because `f[5] = 8` and `f[4] = 5`, and thus
    `f[6] = 8+5 = 13`. You can use the starter code at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/fibonacci/starter-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/fibonacci/starter-code).
    Don't worry too much about the most efficient algorithms for calculating the number;
    just be sure not to hardcode values and instead rely on the input variables and
    the formula.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，构建一个函数来接受一个数字。最终结果应该是斐波那契数列([https://en.wikipedia.org/wiki/Fibonacci_number](https://en.wikipedia.org/wiki/Fibonacci_number))中到指定数字的数字之和。序列的前几个数字是`[1,
    1, 2, 3, 5, 8, 13, 21, 34, 55, 89]`。每个数字都是前两个数字的和；例如，`f[6] = 13`，因为`f[5] = 8`，`f[4]
    = 5`，因此`f[6] = 8+5 = 13`。你可以在[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/fibonacci/starter-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/fibonacci/starter-code)找到起始代码。不要太担心计算数字的最有效算法；只需确保不要硬编码值，而是依赖输入变量和公式。
- en: Fibonacci sequence solution
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 斐波那契数列解决方案
- en: 'Let''s dissect one possible solution:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解剖一个可能的解决方案：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's take a look at the lines outside of the function first. All we're doing
    is simply asking the user for the point in the sequence up to which they'd like
    to calculate. The `response` variable is then fed into the `alert()` statement
    as a parameter to `fibonacci`, which takes the argument of `num`. From that point
    forward, the `while()` loop executes on `num`, decrementing `num` as the value
    of `b` is incremented according to the algorithm, and then finally returns into
    our alert message.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看函数外的行。我们所做的只是简单地询问用户想要计算到序列的哪个点。然后，`response`变量被传递到`alert()`语句作为`fibonacci`的参数，`fibonacci`接受`num`作为参数。从那时起，`while()`循环在`num`上执行，将`num`递减，而`b`的值则根据算法递增，最后返回到我们的警报消息中。
- en: So that's really all there is to it! Now, let's try a variant because we never
    know what our user will input. What happens if they enter a string instead of
    a number? We should accommodate this and at the very least present an error message.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样了！现在，让我们尝试一个变体，因为我们永远不知道我们的用户会输入什么。如果他们输入的是一个字符串而不是一个数字会发生什么？我们应该适应这一点，至少呈现一个错误消息。
- en: 'Let''s take a look at this solution:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个解决方案：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can find the solution on GitHub at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/fibonacci/solution-code-number-check](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/fibonacci/solution-code-number-check).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到解决方案，网址是[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/fibonacci/solution-code-number-check](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/fibonacci/solution-code-number-check)。
- en: If we dive into the `while()` loop, we'll see our type-matching magic. First
    of all, since `response` inherently comes in a string, we decide we don't want
    to trust type coercion, which is what our previous solution is doing. We use the
    `parseInt()` method to cast `response` directly into a number. Great! But that
    doesn't give us the security that our user entered an integer to begin with. Remember,
    JavaScript doesn't have a conception of `int` versus `float`, so we have to make
    some manipulations to ensure our input is an integer by using the negation of
    the `Number.isInteger` method. This ensures that our input is a valid integer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进入`while()`循环，我们会看到我们的类型匹配魔法。首先，由于`response`本质上是一个字符串，我们决定不要相信类型强制转换，这就是我们之前的解决方案在做的事情。我们使用`parseInt()`方法将`response`直接转换为一个数字。太好了！但这并不能确保我们的用户一开始输入的是一个整数。记住，JavaScript没有`int`和`float`的概念，所以我们必须进行一些操作，以确保我们的输入是一个整数，方法是使用`Number.isInteger`方法的否定。这确保了我们的输入是一个有效的整数。
- en: As a prelude to heavier work with JSON, let's take a look at how we can use
    objects as a datastore.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在更深入地使用JSON之前，让我们看看如何将对象用作数据存储。
- en: Using objects as a datastore
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对象作为数据存储
- en: Here's an interesting problem that I've seen in programming interviews, as well
    as the most efficient way to solve it. It has an expensive input time, but an
    O(1) *retrieval* time, which is generally considered a metric of success for algorithmic
    complexities when you can expect more reads than writes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我在编程面试中见过的有趣问题，以及解决它的最有效方法。它具有昂贵的输入时间，但具有O(1)的*检索*时间，这通常被认为是算法复杂性成功的度量标准，当你可以预期读取的次数比写入的次数多时。
- en: Exercise – multiplication
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习-乘法
- en: 'Consider the following code ([https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/matrix/starter-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/matrix/starter-code)):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码（[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/matrix/starter-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/matrix/starter-code)）：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, what's the solution within the paradigm of using an object? Let's take a
    look, break it down, and then reverse-engineer our use of objects as a data store
    (*spoiler alert:* have you heard of NoSQL?).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在使用对象的范例中，解决方案是什么？让我们来看看，分解一下，然后逆向工程我们使用对象作为数据存储的用法（*剧透警告：*你听说过NoSQL吗？）。
- en: Multiplication solution
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 乘法解决方案
- en: 'Before we begin, let''s break down the problem into two steps: given two arrays,
    we will first compute the products of each item in the arrays and store them in
    an object. Then, we will write a function to retrieve the product of two given
    numbers from the arrays. Let''s take a look.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们将问题分解为两个步骤：给定两个数组，我们首先计算数组中每个项目的乘积，并将它们存储在一个对象中。然后，我们将编写一个函数来检索数组中给定两个数字的乘积。让我们来看看。
- en: Step 1 – computing and storing
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一步 - 计算和存储
- en: 'First of all, our `makeProducts` function will take the two arrays as its parameters.
    Using the `.forEach()` method of arrays, we''ll iterate over each item in the
    first array, naming the values `multiplicant`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的`makeProducts`函数将以两个数组作为参数。使用数组的`.forEach()`方法，我们将遍历第一个数组中的每个项目，将值命名为`multiplicant`：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, our end goal is to have an object that will tell us "the product of *x*
    and *y* is *z*." If we abstract this into using an object as a data store, we
    could arrive at a structure like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的最终目标是有一个对象告诉我们“*x*和*y*的乘积是*z*”。如果我们将这个抽象成使用对象作为数据存储，我们可以得到这样的结构：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this object structure, all we need to do to retrieve our calculation is
    specify `x.y`, which will be `z`. We also don''t want to assume an order, so we
    do the reverse as well: `y.z`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个对象结构中，我们只需要指定`x.y`来检索我们的计算，它将是`z`。我们也不想假设一个顺序，所以我们也做相反的：`y.z`。
- en: 'So, how do we construct this data object? Remember that we can use **bracket
    notation** with objects if we''re not calling the literal key; here, we''re using
    a variable:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何构建这个数据对象呢？记住，如果我们不是调用文字键，我们可以使用**方括号表示法**与对象；在这里，我们使用一个变量：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our first step is to check whether the `multiplicant` key exists in our object
    (`x`, in our previous theoretical discussion). If it doesn't, set it to a new
    object.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是检查我们的对象中是否存在`multiplicant`键（在我们之前的理论讨论中是`x`）。如果不存在，将其设置为一个新对象。
- en: 'Now, in our inner loop, let''s do the same for the multiplier:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的内部循环中，让我们对乘数做同样的事情：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Great! We have our keys set up for both `x` and `y`. Now, we just compute the
    product and store it in both locations, like so:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们已经为`x`和`y`都设置了键。现在，我们只需计算乘积并将其存储在两个位置，如下所示：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Notice the decision to assign the reverse key value to the obverse key''s
    value, as opposed to recalculating the product*. Why would we do that? In fact,
    why are we going to all this trouble for a simple mathematical operation? Here''s
    the reason: what if, instead of simple multiplication, we''re doing a calculation
    *far* more complex? Maybe a calculation so complex it takes a full second or more
    to return? Now we can see that we want to reduce our time so that we only do the
    calculation once and then can read it repeatedly for optimal performance.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意决定将反向键值分配给正向键的值，而不是重新计算乘积*。为什么我们要这样做？事实上，为什么我们要为一个简单的数学运算费这么大劲？原因是：如果我们不是做简单的乘法，而是做一个*远远*更复杂的计算呢？也许一个如此复杂以至于需要一秒或更长时间才能返回的计算？现在我们可以看到，我们希望减少我们的时间，这样我们只需要做一次计算，然后可以重复读取它以获得最佳性能。'
- en: 'After constructing this function, we would execute it on our arrays:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 构建了这个函数之后，我们将在我们的数组上执行它：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is easy enough to invoke!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易调用！
- en: Step 2 – retrieval
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二步 - 检索
- en: 'Now, let''s write our retrieval function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写我们的检索函数：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we look at this logic, first we ensure the first key exists. If it exists,
    we return either `x.y` or `null` if `y` does not exist. Objects are picky in that
    if you try to refer to a *value* of a *key* that doesn''t exist, you''ll get an
    error. Thus, we first need to existence-check our key. If the key exists *and*
    the key/value pair exists, return the computed value; otherwise, we return `null`.
    Notice the `return products[a][b] || null` short-circuit: this is an efficient
    way of saying "return the value or something else." If `products[a][b]` does not
    exist, it will respond with a falsy value, and the `OR` operation will take over.
    Efficient!'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看这个逻辑，首先我们确保第一个键存在。如果存在，我们返回`x.y`或者如果`y`不存在则返回`null`。对象很挑剔，如果你试图引用一个不存在的*键*的*值*，你会得到一个错误。因此，我们首先需要存在性检查我们的键。如果键存在*并且*键/值对存在，返回计算出的值；否则，我们返回`null`。注意`return
    products[a][b] || null`的短路：这是一种有效的方式来表示“返回值或其他东西”。如果`products[a][b]`不存在，它将响应一个假值，然后`OR`操作将接管。高效！
- en: Take a look at the solution code for the answer to the bonus question. The same
    principles of existence-checking and calculation apply.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下奖励问题的答案的解决方案代码。存在检查和计算的相同原则适用。
- en: Understanding scope
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解范围
- en: 'Let''s discuss scope for a while before we build a larger application. Simply
    put, scope defines when and where we can use a variable or a function. Scope in
    JavaScript is broken down into two discrete categories: local and global. If we
    look at our previous multiplication program, we can see that there are three variables
    outside any functions; they''re hanging out at the root level of our program:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建一个更大的应用程序之前，让我们讨论一下范围。简而言之，范围定义了我们何时何地可以使用变量或函数。JavaScript中的范围被分为两个离散的类别：局部和全局。如果我们看看我们之前的乘法程序，我们可以看到有三个变量在任何函数之外；它们挂在我们程序的根级别：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The variables in question are on lines 1, 2, and 6: `a`, `b`, and `products`,
    respectively. Great! That means that we can use them anywhere, such as on lines
    10, 11, 14, 15, and more, as long as we use them after they''re defined. Now,
    if we look closer, we also see we have some functions in the global scope: `makeProducts`
    and `getProducts`. Likewise, we can use them anywhere as long as they''ve already
    been defined.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 问题中的变量分别在第1、2和6行：`a`、`b`和`products`。太好了！这意味着我们可以在任何地方使用它们，比如第10、11、14、15行，以及更多地方，只要我们在它们被定义之后使用它们。现在，如果我们仔细看，我们还会看到我们在全局作用域中有一些函数：`makeProducts`和`getProducts`。同样，只要它们已经被定义，我们可以在任何地方使用它们。
- en: OK, great—that makes sense since JavaScript is read top to bottom. But wait!
    If you remember from [Chapter 3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml), *Nitty-Gritty
    Grammar,* a function declaration is hoisted to the top and thus can be used anywhere.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，太好了——这是有道理的，因为JavaScript是从上到下读取的。但等等！如果你还记得[第3章](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml)中的内容，*Nitty-Gritty
    Grammar*，函数声明被提升到顶部，因此可以在任何地方使用。
- en: 'Let''s refactor our program to utilize hoisting and abstract our math to be
    the theoretical long-running process. We''ll also be using `Promises` as a great
    introduction to the concept. Before we go too far into it, it may be useful to
    read up on using `Promises`: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构我们的程序，利用提升和抽象我们的数学来成为理论上的长时间运行的过程。我们还将使用`Promises`作为一个很好的概念介绍。在我们深入研究之前，阅读使用`Promises`可能会有所帮助：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises)。
- en: Take a look at `index.js` in [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/matrix-refactored](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/matrix-refactored).
    We'll be breaking this down step by step.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/matrix-refactored](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-5/matrix-refactored)中查看`index.js`。我们将一步一步地分解这个过程。
- en: 'First, open `index.html` in a browser. Make sure your console is open. After
    2 seconds, you will see a simple message in the console: 9 x 2 = 18. If you look
    at line 44 in `index.js`, you''ll see that it''s using `getProducts` to calculate
    the product of `a[4]` and `b[0]`, which are `9` and `2`, respectively. Great!
    So far, our functionality is the same with the addition of a perceived delay.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在浏览器中打开`index.html`。确保你的控制台是打开的。2秒后，你会在控制台中看到一个简单的消息：9 x 2 = 18。如果你看一下`index.js`中的第44行，你会看到它在使用`getProducts`来计算`a[4]`和`b[0]`的乘积，它们分别是`9`和`2`。太棒了！到目前为止，我们的功能与添加了一个感知延迟是一样的。
- en: 'Let''s start at the beginning:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从头开始：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: OK, so far we have the same code. Now, what about our `makeProducts` function?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有相同的代码。那么我们的`makeProducts`函数呢？
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Hmm. OK, we have a few of the same pieces, but a few new pieces. First of all,
    let''s consider **`async`**. This keyword, when used with a function, implies
    that the consumer of this function is to expect *asynchronous behavior* as opposed
    to JavaScript''s generally top-down behavior. Before we dive into breaking down
    the new lines, 19–21, let''s look at *why* this function is asynchronous by checking
    out our `calculation` function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯。好的，我们有一些相同的部分，但也有一些新的部分。首先，让我们考虑**`async`**。当与一个函数一起使用时，这个关键字意味着这个函数的使用者应该期望*异步行为*，而不是JavaScript通常的自上而下的行为。在我们深入研究新的19-21行之前，让我们看一下我们的`calculation`函数为什么是异步的：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here''s `async` again on line 37, and now we see a new keyword on line 38:
    `await`. `async` and `await` are one way to specify that we can work asynchronously:
    on line 38, we specify that we''re waiting for this `promise` to **resolve** before
    continuing. What is our `promise` doing? Well, as it turns out, not a whole lot!
    It''s simply using `setTimeout` to delay by 2,000 milliseconds. This delay is
    intended to simulate a long-running process, such as an Ajax call or a complex
    process that takes 2 seconds to complete (or even an indeterminate amount of time).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里又是第37行的`async`，现在我们在第38行看到一个新的关键字：`await`。`async`和`await`是指定我们可以异步工作的一种方式：在第38行，我们指定我们在继续之前正在等待这个`promise`**解析**。我们的`promise`在做什么？嗯，事实证明，并不多！它只是使用`setTimeout`延迟2,000毫秒。这个延迟旨在模拟一个长时间运行的过程，比如一个Ajax调用或者一个需要2秒才能完成的复杂过程（甚至是一个不确定的时间量）。
- en: 'OK, great. So far, we''ve basically tricked the program into expecting a 2-second
    delay before continuing. Let''s look at line 9: a new array called `promises`.
    Now, to get back to our idea of *scope*, you can notice that our array is defined
    *within* `makeProducts`. That means the variable only exists within the local
    scope of the function. As opposed to products, we can''t access promises from
    outside this function. That''s OK—we don''t really need to. As a matter of fact,
    it''s considered best practice to keep the number of variables defined in the
    global scope to a minimum.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，太好了。到目前为止，我们基本上是在欺骗程序，让它期望在继续之前有2秒的延迟。让我们看看第9行：一个名为`promises`的新数组。现在，回到我们关于*作用域*的想法，你可以注意到我们的数组是在`makeProducts`内部定义的。这意味着这个变量只存在于函数的局部作用域内。与products相反，我们无法从这个函数的外部访问promises。没关系——我们真的不需要。事实上，最好的做法是尽量减少在全局作用域中定义的变量数量。
- en: 'Now, let''s look at line 19, which looks a little more nuanced:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下第19行，看起来更加微妙：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we dissect this, we first see something familiar: we''re pushing something
    onto our `promises` array. What we''re pushing is a new `Promise`, similar to
    line 38, but in this case, we''re not waiting for it in-line, but rather just
    saying "resolve this `promise` with the value of `calculation()` — whenever it
    happens." So far, so good. How about the next part?'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分解一下，首先我们看到了一些熟悉的东西：我们正在将一些东西推到我们的`promises`数组中。我们正在推送的是一个新的`Promise`，类似于第38行，但在这种情况下，我们不是在行内等待它，而是只是说“用`calculation()`的值解析这个`promise`——无论何时发生”。到目前为止，一切都很好。下一部分呢？
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, here''s where some syntactic sugar comes into play: now that we have our
    `promise` in our array of `promises`, we access it with `[promises.length - 1]`
    because `length` returns the full length, starting from `1`. The `.then()` clause
    is our magic: it says that once the `promise` is done, do something with the result.
    In this case, our *something* is to assign `val` to both variants of the product.
    Finally, on line 25, we return the array of `promises`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一些语法糖就出现了：现在我们在`promises`数组中有了我们的`promise`，我们可以使用`[promises.length - 1]`来访问它，因为`length`返回的是从`1`开始的完整长度。`.then()`子句是我们的魔法：它表示一旦`promise`完成，就对结果进行处理。在这种情况下，我们的*处理*是将`val`分配给产品的两个变体。最后，在第25行，我们返回`promises`数组。
- en: 'Our `getProducts` function hasn''t changed at all! The complexity of our retrieval
    function remains the same: efficient.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`getProducts`函数一点都没有改变！我们的检索函数的复杂性保持不变：高效。
- en: How about this?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个怎么样？
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We've seen `.then` before, so it's getting as its parameter the return value
    of `makeProducts`, which is the array of `promises`. Then, we can use `.all()`
    before `.then` to effectively say "when all the `promises` in `arrOfPromises`
    have resolved, then do the next function." That next function is to log our answer.
    You can add additional product checks after line 44; they will all return at the
    same time as line 44, as the delay in our "calculation" has already occurred.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前见过`.then`，所以它的参数是`makeProducts`的返回值，即`promises`数组。然后，我们可以在`.then`之前使用`.all()`来有效地表示“当`arrOfPromises`中的所有`promises`都已解决时，然后执行下一个函数”。下一个函数是记录我们的答案。你可以在第44行之后添加额外的产品检查；它们将与第44行同时返回，因为我们的“计算”中的延迟已经发生。
- en: Scope chains and scope trees
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域链和作用域树
- en: 'Diving further into scope, we have the idea of **scope chains** and **scope
    trees**. Let''s consider the following example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步深入作用域，我们有**作用域链**和**作用域树**的概念。让我们考虑以下例子：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What variable(s) does `someFunc` have access to? What does `zip` have access
    to? If you guessed that `someFunc` has access to `outerVar` but `zip` has access
    to both `innerVar` and `outerVar`, you're correct. That's because both variables
    exist in the scope chain of `zip`, but only `outerVar` exists in the scope of
    `someFunc`. Clear as mud? Great. Let's look at some diagrams.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`someFunc`有哪些变量可以访问？`zip`有哪些变量可以访问？如果你猜到`someFunc`可以访问`outerVar`，但`zip`可以访问`innerVar`和`outerVar`，那么你是正确的。这是因为这两个变量存在于`zip`的作用域链中，但只有`outerVar`存在于`someFunc`的作用域中。清楚了吗？太好了。让我们看一些图表。'
- en: 'Take a look at the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can diagram a **scope tree** of our function from a top-down construction:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从上到下构建一个函数的**作用域树**的图表：
- en: '![](assets/ddbada90-b172-4f3f-9773-c44ecc76904b.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ddbada90-b172-4f3f-9773-c44ecc76904b.png)'
- en: Figure 5.3 – Scope tree
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 - 作用域树
- en: 'What does this tell us? `quux` kind of lives off in its own little world inside
    `someFunc`. It would have access to `someFunc`''s variables, but *not* to `zip`
    or `foo`. We can also look at it in the reverse with a **scope chain** to understand
    it from the bottom up:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们什么？`quux`似乎独立存在于`someFunc`内部的小世界中。它可以访问`someFunc`的变量，但*不能*访问`zip`或`foo`。我们也可以通过**作用域链**从下到上来理解它：
- en: '![](assets/3346d996-15a3-4f99-81c7-b4813235bfe6.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3346d996-15a3-4f99-81c7-b4813235bfe6.png)'
- en: Figure 5.4 – Scope chain
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 - 作用域链
- en: In this example, we're taking a look at what `foo` has access to. From the bottom
    up, we can see its relationship to the other parts of the code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看一下`foo`可以访问什么。从下到上，我们可以看到它与代码其他部分的关系。
- en: Closures
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: 'Now, we''ll get into **closures**, which is apparently a scary topic in JavaScript.
    However, the basic concept is approachable: a closure is simply a function inside
    another function with access to the scope chain of its parent function. In this case,
    it has three scope chains: its own, with variables defined within itself; global,
    with all the variables in the global scope accessible to it; and the parent function''s
    scope.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进入**闭包**，这显然是JavaScript中一个可怕的话题。然而，基本概念是可以理解的：一个闭包就是一个函数，它在另一个函数内部，可以访问其父函数的作用域链。在这种情况下，它有三个作用域链：自己的作用域链，其中定义了自己的变量；全局的作用域链，其中可以访问全局作用域中的所有变量；以及父函数的作用域。
- en: 'Here''s an example that we''ll dissect:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们将解剖的例子：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Which variables are accessible to which functions? Here''s a diagram:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些变量可以被哪些函数访问？这里有一个图表：
- en: '![](assets/6c9bc35d-24cb-4992-8095-a1804e39a5de.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6c9bc35d-24cb-4992-8095-a1804e39a5de.png)'
- en: Figure 5.5 – Closures
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 - 闭包
- en: Starting from the bottom up, `foo` has access to `beep` and `bar`, whereas `zip`
    has access only to `bar`. So far, so good, right? Closures are just a way to describe
    the scope that each nested function has available to it. There's nothing inherently
    scary about them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从下到上，`foo`可以访问`beep`和`bar`，而`zip`只能访问`bar`。到目前为止，一切都好，对吧？闭包只是一种描述每个嵌套函数可用作用域的方式。它们本身并不可怕。
- en: A basic example of a closure in practice
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个闭包在实践中的基本例子
- en: 'Take a look at the following function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下函数：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'First, let''s look at this interesting construction: `sayHello(''Alice'')()`.
    Since our `sayAlert()` function is the return value of `sayHello`, we first invoke
    `sayHello` with one pair of parentheses with our argument and then invoke its
    return value (the `sayAlert` function) with the second pair of parentheses. Notice
    how `greeting` is within the scope of `sayHello`, and when we invoke our function,
    we''ll have an alert of Hello Alice. However, if we try to alert `greeting` by
    itself, we''ll get an error. Only `sayAlert` has access to `greeting`. Likewise,
    if we tried to access `name` from outside the function, we''d get an error.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看这个有趣的构造：`sayHello('Alice')()`。由于我们的`sayAlert()`函数是`sayHello`的返回值，我们首先用一个括号对调用`sayHello`，并带上我们的参数，然后用第二对括号调用它的返回值（`sayAlert`函数）。注意`greeting`在`sayHello`的作用域内，当我们调用我们的函数时，我们会得到一个Hello
    Alice的警报。然而，如果我们尝试单独警报`greeting`，我们会得到一个错误。只有`sayAlert`可以访问`greeting`。同样，如果我们试图从函数外部访问`name`，我们会得到一个错误。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In order for our programs to be useful, they usually depend on input from the
    user or other functions. By scaffolding our programs to be flexible, we also need
    to keep in mind the idea of scope: when and where we can use a function or variable.
    We also took a look at how objects can be used to store data efficiently for retrieval.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的程序有用，它们通常依赖于用户或其他函数的输入。通过搭建我们的程序以使其灵活，我们还需要牢记作用域的概念：何时何地可以使用函数或变量。我们还看了一下对象如何用于有效存储数据以便检索。
- en: Let's not forget closures, the seemingly complicated concept that is, in practice,
    just a way of describing scope.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不要忘记闭包，这个看似复杂的概念实际上只是一种描述作用域的方式。
- en: In the next chapter, we'll explore the frontend more as we get into using the
    **Document Object Model** (**DOM**) and manipulating information on the page instead
    of only interacting with alerts and the console.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，随着我们开始使用**文档对象模型**（**DOM**）并操纵页面上的信息，而不仅仅是与警报和控制台交互，我们将更多地探索前端。
- en: Questions
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Consider the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How would you get an alert of Hello Bob?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何获得警报 Hello Bob？
- en: '`sayHello()(''Bob'')`'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sayHello()(''Bob'')`'
- en: '`sayHello(''Bob'')()`'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sayHello(''Bob'')()`'
- en: '`sayHello(''Bob'')`'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sayHello(''Bob'')`'
- en: '`someFunc()(sayHello(''Bob''))`'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`someFunc()(sayHello(''Bob''))`'
- en: What will `alert(greeting)` do in the preceding code?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码中，`alert(greeting)`会做什么？
- en: Alert greeting.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 警报问候语。
- en: Alert Hello Alice.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 警报 你好 Alice。
- en: Throw an error.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抛出错误。
- en: None of the above.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是。
- en: How would we get an alert message of 1?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何获得警报消息1？
- en: '`someFunc()()`'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`someFunc()()`'
- en: '`sayHello().sayZip()`'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sayHello().sayZip()`'
- en: '`alert(someFunc.bar)`'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`alert(someFunc.bar)`'
- en: '`sayZip()`'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sayZip()`'
- en: How would we get an alert message of 2?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何获得警报消息2？
- en: '`someFunc().foo()`.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`someFunc().foo()`.'
- en: '`someFunc()().beep`.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`someFunc()().beep`。'
- en: We can't because it's not in the scope.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不能，因为它不在作用域内。
- en: We can't because it's not defined.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不能，因为它没有定义。
- en: How can we change `someFunc` to alert 1 1 2 ?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何将`someFunc`更改为警报1 1 2？
- en: We can't.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不能。
- en: Add `return foo` after `return zip`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`return zip`后添加`return foo`。
- en: Change `return zip` to `return foo`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`return zip`更改为`return foo`。
- en: Add `return foo` after the `foo` declaration.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo`声明后添加`return foo`。
- en: Given a correct solution to the preceding question, how would we actually get
    three alerts of 1, 1, 2 ?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定前面问题的正确解决方案，我们如何实际获得三个警报1、1、2？
- en: '`someFunc()()()`'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`someFunc()()()`'
- en: '`someFunc()().foo()`'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`someFunc()().foo()`'
- en: '`someFunc.foo()`'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`someFunc.foo()`'
- en: '`alert(someFunc)`'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`alert(someFunc)`'
- en: Further reading
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: MDN – closures: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MDN - 闭包：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)
- en: '*Understand JavaScript Closures with Ease*: [http://javascriptissexy.com/understand-javascript-closures-with-ease/](http://javascriptissexy.com/understand-javascript-closures-with-ease/)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*轻松理解JavaScript闭包*：[http://javascriptissexy.com/understand-javascript-closures-with-ease/](http://javascriptissexy.com/understand-javascript-closures-with-ease/)'
