["```java\npublic class Word implements Comparable<Word> {\n```", "```java\n    private String word;\n    private int tf;\n    private int df;\n    private double tfIdf;\n```", "```java\n    public void setDf(int df, int N) {\n        this.df = df;\n        tfIdf = tf * Math.log(Double.valueOf(N) / df);\n    }\n```", "```java\n    @Override\n    public int compareTo(Word o) {\n        return Double.compare(o.getTfIdf(), this.getTfIdf());\n    }\n}\n```", "```java\npublic class Keyword implements Comparable<Keyword> {\n```", "```java\n    private String word;\n    private int df;\n```", "```java\n    @Override\n    public int compareTo(Keyword o) {\n\n        return Integer.compare(o.getDf(), this.getDf());\n    }\n}\n```", "```java\npublic class Document {\n    private String fileName;\n    private HashMap <String, Word> voc;\n```", "```java\n    public void addWord(String string) {\n        voc.computeIfAbsent(string, k -> new Word(k)).addTf();\n    }\n}\n```", "```java\npublic class DocumentParser {\n\n    public static Document parse(String path) {\n        Document ret = new Document();\n        Path file = Paths.get(path);\n        ret.setFileName(file.toString());\n\n        try (BufferedReader reader = Files.newBufferedReader(file)) {\n            for(String line : Files.readAllLines(file)) {\n                parseLine(line, ret);\n            }\n        } catch (IOException x) {\n            x.printStackTrace();\n        }\n        return ret;\n\n    }\n```", "```java\n    private static void parseLine(String line, Document ret) {\n\n        // Clean string\n        line = Normalizer.normalize(line, Normalizer.Form.NFKD);\n        line = line.replaceAll(\"[^\\\\p{ASCII}]\", \"\");\n        line = line.toLowerCase();\n```", "```java\n    private static void parseLine(String line, Document ret) {\n\n        // Clean string\n        line = Normalizer.normalize(line, Normalizer.Form.NFKD);\n        line = line.replaceAll(\"[^\\\\p{ASCII}]\", \"\");\n        line = line.toLowerCase();\n\n        // Tokenizer\n\n        for(String w: line.split(\"\\\\W+\")) {\n              ret.addWord(w);\n        }\n    }\n\n}\n```", "```java\npublic class SerialKeywordExtraction {\n\n    public static void main(String[] args) {\n\n        Date start, end;\n\n        File source = new File(\"data\");\n        File[] files = source.listFiles();\n        HashMap<String, Word> globalVoc = new HashMap<>();\n        HashMap<String, Integer> globalKeywords = new HashMap<>();\n        int totalCalls = 0;\n        int numDocuments = 0;\n\n        start = new Date();\n```", "```java\n        if(files == null) {\n            System.err.println(\"Unable to read the 'data' folder\");\n            return;\n        }\n        for (File file : files) {\n\n            if (file.getName().endsWith(\".txt\")) {\n                Document doc = DocumentParser.parse (file.getAbsolutePath());\n                for (Word word : doc.getVoc().values()) {\n                    globalVoc.merge(word.getWord(), word, Word::merge);\n                }\n                numDocuments++;\n            }\n        }\n        System.out.println(\"Corpus: \" + numDocuments + \" documents.\");\n```", "```java\n        for (File file : files) {\n            if (file.getName().endsWith(\".txt\")) {\n                Document doc = DocumentParser.parse(file.getAbsolutePath());\n                List<Word> keywords = new ArrayList<>( doc.getVoc().values());\n\n                int index = 0;\n                for (Word word : keywords) {\n                      Word globalWord = globalVoc.get(word.getWord());\n                      word.setDf(globalWord.getDf(), numDocuments);\n                }\n```", "```java\n                Collections.sort(keywords);\n\n                int counter = 0;\n\n                for (Word word : keywords) {\n                      addKeyword(globalKeywords, word.getWord());\n                      totalCalls++;\n                }\n            }\n        }\n```", "```java\n        List<Keyword> orderedGlobalKeywords = new ArrayList<>();\n        for (Entry<String, Integer> entry : globalKeywords.entrySet()) {\n          Keyword keyword = new Keyword();\n          keyword.setWord(entry.getKey());\n          keyword.setDf(entry.getValue());\n          orderedGlobalKeywords.add(keyword);\n        }\n\n        Collections.sort(orderedGlobalKeywords);\n\n        if (orderedGlobalKeywords.size() > 100) {\n            orderedGlobalKeywords = orderedGlobalKeywords.subList(0, 100);\n        }\n        for (Keyword keyword : orderedGlobalKeywords) {\n            System.out.println(keyword.getWord() + \": \" + keyword.getDf());\n        }\n```", "```java\n        end = new Date();\n        System.out.println(\"Execution Time: \" + (end.getTime() - start.getTime()));\n        System.out.println(\"Vocabulary Size: \" + globalVoc.size());\n        System.out.println(\"Keyword Size: \" + globalKeywords.size());\n        System.out.println(\"Number of Documents: \" + numDocuments);\n        System.out.println(\"Total calls: \" + totalCalls);\n\n    }\n```", "```java\n    private static void addKeyword(Map<String, Integer> globalKeywords, String word) {\n        globalKeywords.merge(word, 1, Integer::sum);\n    }\n\n}\n```", "```java\npublic class KeywordExtractionTask implements Runnable {\n\n    private ConcurrentHashMap<String, Word> globalVoc;\n    private ConcurrentHashMap<String, Integer> globalKeywords;\n\n    private ConcurrentLinkedDeque<File> concurrentFileListPhase1;\n    private ConcurrentLinkedDeque<File> concurrentFileListPhase2;\n\n    private Phaser phaser;\n\n    private String name;\n    private boolean main;\n\n    private int parsedDocuments;\n    private int numDocuments;\n\n    public KeywordExtractionTask(\n            ConcurrentLinkedDeque<File> concurrentFileListPhase1,\n            ConcurrentLinkedDeque<File> concurrentFileListPhase2,\n            Phaser phaser, ConcurrentHashMap<String, Word> globalVoc,\n            ConcurrentHashMap<String, Integer> globalKeywords,\n            int numDocuments, String name, boolean main) {\n        this.concurrentFileListPhase1 = concurrentFileListPhase1;\n        this.concurrentFileListPhase2 = concurrentFileListPhase2;\n        this.globalVoc = globalVoc;\n        this.globalKeywords = globalKeywords;\n        this.phaser = phaser;\n        this.main = main;\n        this.name = name;\n        this.numDocuments = numDocuments;\n    }\n```", "```java\n    @Override\n    public void run() {\n        File file;\n\n        // Phase 1\n        phaser.arriveAndAwaitAdvance();\n        System.out.println(name + \": Phase 1\");\n        while ((file = concurrentFileListPhase1.poll()) != null) {\n            Document doc = DocumentParser.parse(file.getAbsolutePath());\n            for (Word word : doc.getVoc().values()) {\n                globalVoc.merge(word.getWord(), word, Word::merge);\n            }\n            parsedDocuments++;\n        }\n\n        System.out.println(name + \": \" + parsedDocuments + \" parsed.\");\n        phaser.arriveAndAwaitAdvance();\n```", "```java\n        // Phase 2\n        System.out.println(name + \": Phase 2\");\n        while ((file = concurrentFileListPhase2.poll()) != null) {\n\n            Document doc = DocumentParser.parse(file.getAbsolutePath());\n            List<Word> keywords = new ArrayList<>(doc.getVoc().values());\n\n            for (Word word : keywords) {\n              Word globalWord = globalVoc.get(word.getWord());\n              word.setDf(globalWord.getDf(), numDocuments);\n            }\n            Collections.sort(keywords);\n\n            if(keywords.size() > 10) keywords = keywords.subList(0, 10);\n            for (Word word : keywords) {\n              addKeyword(globalKeywords, word.getWord());\n            }\n        }\n        System.out.println(name + \": \" + parsedDocuments + \" parsed.\");\n```", "```java\n        if (main) {\n            phaser.arriveAndAwaitAdvance();\n\n            Iterator<Entry<String, Integer>> iterator = globalKeywords.entrySet().iterator();\n            Keyword orderedGlobalKeywords[] = new Keyword[globalKeywords.size()];\n            int index = 0;\n            while (iterator.hasNext()) {\n                Entry<String, AtomicInteger> entry = iterator.next();\n                Keyword keyword = new Keyword();\n                keyword.setWord(entry.getKey());\n                keyword.setDf(entry.getValue().get());\n                orderedGlobalKeywords[index] = keyword;\n                index++;\n            }\n\n            System.out.println(\"Keyword Size: \" + orderedGlobalKeywords.length);\n\n            Arrays.parallelSort(orderedGlobalKeywords);\n            int counter = 0;\n            for (int i = 0; i < orderedGlobalKeywords.length; i++){\n\n                Keyword keyword = orderedGlobalKeywords[i];\n                System.out.println(keyword.getWord() + \": \" + keyword.getDf());\n                counter++;\n                if (counter == 100) {\n                    break;\n                }\n            }\n        }\n        phaser.arriveAndDeregister();\n\n        System.out.println(\"Thread \" + name + \" has finished.\");\n    }\n```", "```java\npublic class ConcurrentKeywordExtraction {\n\n    public static void main(String[] args) {\n\n        Date start, end;\n\n        ConcurrentHashMap<String, Word> globalVoc = new ConcurrentHashMap<>();\n        ConcurrentHashMap<String, Integer> globalKeywords = new ConcurrentHashMap<>();\n\n        start = new Date();\n        File source = new File(\"data\");\n\n        File[] files = source.listFiles(f -> f.getName().endsWith(\".txt\"));\n        if (files == null) {\n            System.err.println(\"The 'data' folder not found!\");\n            return;\n        }\n        ConcurrentLinkedDeque<File> concurrentFileListPhase1 = new ConcurrentLinkedDeque<>(Arrays.asList(files));\n        ConcurrentLinkedDeque<File> concurrentFileListPhase2 = new ConcurrentLinkedDeque<>(Arrays.asList(files));\n\n        int numDocuments = files.length();\n        int factor = 1;\n        if (args.length > 0) {\n            factor = Integer.valueOf(args[0]);\n        }\n\n        int numTasks = factor * Runtime.getRuntime().availableProcessors();\n        Phaser phaser = new Phaser();\n\n        Thread[] threads = new Thread[numTasks];\n        KeywordExtractionTask[] tasks = new KeywordExtractionTask[numTasks];\n```", "```java\n        for (int i = 0; i < numTasks; i++) {\n            tasks[i] = new KeywordExtractionTask(concurrentFileListPhase1, concurrentFileListPhase2, phaser, globalVoc, globalKeywords, concurrentFileListPhase1.size(), \"Task\" + i, i==0);\n            phaser.register();\n            System.out.println(phaser.getRegisteredParties() + \" tasks arrived to the Phaser.\");\n        }\n```", "```java\n        for (int i = 0; i < numTasks; i++) {\n            threads[i] = new Thread(tasks[i]);\n            threads[i].start();\n        }\n\n        for (int i = 0; i < numTasks; i++) {\n            try {\n                threads[i].join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n```", "```java\n        System.out.println(\"Is Terminated: \" + phaser.isTerminated());\n\n        end = new Date();\n        System.out.println(\"Execution Time: \" + (end.getTime() - start.getTime()));\n        System.out.println(\"Vocabulary Size: \" + globalVoc.size());\n        System.out.println(\"Number of Documents: \" + numDocuments);\n\n    }\n\n}\n```", "```java\npublic class Individual implements Comparable<Individual> {\n    private Integer[] chromosomes;\n    private int value;\n```", "```java\n    public Individual(int size) {\n        chromosomes=new Integer[size];\n    }\n\n    public Individual(Individual other) {\n        chromosomes = other.getChromosomes().clone();\n\n    }\n```", "```java\n    @Override\n    public int compareTo(Individual o) {\n          return Integer.compare(this.getValue(), o.getValue());\n    }\n```", "```java\n    private int[][] distanceMatrix;\n\n    private int numberOfGenerations;\n    private int numberOfIndividuals;\n\n    private int size;\n\n    public SerialGeneticAlgorithm(int[][] distanceMatrix,\n            int numberOfGenerations, int numberOfIndividuals) {\n        this.distanceMatrix = distanceMatrix;\n        this.numberOfGenerations = numberOfGenerations;\n        this.numberOfIndividuals = numberOfIndividuals;\n        size = distanceMatrix.length;\n    }\n```", "```java\n    public Individual calculate() {\n        Individual best;\n\n        Individual[] population = GeneticOperators.initialize(\n                numberOfIndividuals, size);\n        GeneticOperators.evaluate(population, distanceMatrix);\n\n        best = population[0];\n```", "```java\n        for (int i = 1; i <= numberOfGenerations; i++) {\n            Individual[] selected = GeneticOperators.selection(population);\n            population = GeneticOperators.crossover(selected, numberOfIndividuals, size);\n            GeneticOperators.evaluate(population, distanceMatrix);\n            if (population[0].getValue() < best.getValue()) {\n                best = population[0];\n            }\n\n        }\n\n        return best;\n    }\n```", "```java\npublic class SerialMain {\n\n    public static void main(String[] args) {\n\n        Date start, end;\n\n        int generations = Integer.valueOf(args[0]);\n        int individuals = Integer.valueOf(args[1]);\n```", "```java\n    for (String name : new String[] { \"lau15_dist\", \"kn57_dist\" }) {\n        int[][] distanceMatrix = DataLoader.load(Paths.get(\"data\", name + \".txt\"));\n        SerialGeneticAlgorithm serialGeneticAlgorithm = new SerialGeneticAlgorithm(distanceMatrix, generations, individuals);\n            start = new Date();\n            Individual result = serialGeneticAlgorithm.calculate();\n            end = new Date();\n        System.out.println (\"=======================================\");\n        System.out.println(\"Example:\"+name);\n        System.out.println(\"Generations: \" + generations);\n        System.out.println(\"Population: \" + individuals);\n        System.out.println(\"Execution Time: \" + (end.getTime() - start.getTime()));\n        System.out.println(\"Best Individual: \" + result);\n        System.out.println(\"Total Distance: \" + result.getValue());\n        System.out.println (\"=======================================\");\n    }\n```", "```java\npublic class SharedData {\n\n    private Individual[] population;\n    private Individual selected[];\n    private AtomicInteger index;\n    private Individual best;\n    private int[][] distanceMatrix;\n}\n```", "```java\npublic class GeneticPhaser extends Phaser {\n\n    private SharedData data;\n\n    public GeneticPhaser(int parties, SharedData data) {\n        super(parties);\n        this.data=data;\n    }\n```", "```java\n    protected boolean onAdvance(int phase, int registeredParties) {\n        int realPhase=phase%3;\n        if (registeredParties>0) {\n            switch (realPhase) {\n            case 0:\n            case 1:\n                data.getIndex().set(0);\n                break;\n            case 2:\n                Arrays.sort(data.getPopulation());\n                if (data.getPopulation()[0].getValue() < data.getBest().getValue()) {\n                    data.setBest(data.getPopulation()[0]);\n                }\n                break;\n            }\n            return false;\n        }\n        return true;\n    }\n```", "```java\npublic class ConcurrentGeneticTask implements Runnable {\n    private GeneticPhaser phaser;\n    private SharedData data;\n    private int numberOfGenerations;\n    private boolean main;\n\n    public ConcurrentGeneticTask(GeneticPhaser phaser, int numberOfGenerations, boolean main) {\n        this.phaser = phaser;\n        this.numberOfGenerations = numberOfGenerations;\n        this.main = main;\n        this.data = phaser.getData();\n    }\n```", "```java\n    @Override\n    public void run() {\n\n        Random rm = new Random(System.nanoTime());\u2029\n\t\tfor (int i = 0; i < numberOfGenerations; i++) {\n            if (main) {\n                data.setSelected(GeneticOperators.selection(data\n                        .getPopulation()));\n            }\n            phaser.arriveAndAwaitAdvance();\n```", "```java\n            // Crossover\n            int individualIndex;\n            do {\n                individualIndex = data.getIndex().getAndAdd(2);\n                if (individualIndex < data.getPopulation().length) {\n                    int secondIndividual = individualIndex++;\n\n                    int p1Index = rm.nextInt (data.getSelected().length);\n                    int p2Index;\n                    do {\n                        p2Index = rm.nextInt (data.getSelected().length);\n                    } while (p1Index == p2Index);\n\n                    Individual parent1 = data.getSelected() [p1Index];\n                    Individual parent2 = data.getSelected() [p2Index];\n                    Individual individual1 = data.getPopulation() [individualIndex];\n                    Individual individual2 = data.getPopulation() [secondIndividual];\n\n                    GeneticOperators.crossover(parent1, parent2, individual1, individual2);\n                }\n            } while (individualIndex < data.getPopulation().length);\n            phaser.arriveAndAwaitAdvance();\n```", "```java\n            // Evaluation\n            do {\n                individualIndex = data.getIndex().getAndIncrement();\n                if (individualIndex < data.getPopulation().length) {\n                    GeneticOperators.evaluate(data.getPopulation() [individualIndex], data.getDistanceMatrix());\n                }\n            } while (individualIndex < data.getPopulation().length);\n            phaser.arriveAndAwaitAdvance();\n\n        }\n\n        phaser.arriveAndDeregister();\n    }\n```", "```java\npublic class ConcurrentGeneticAlgorithm {\n\n    private int numberOfGenerations;\n    private int numberOfIndividuals;\n    private int[][] distanceMatrix;\n    private int size;\n\n    public ConcurrentGeneticAlgorithm(int[][] distanceMatrix, int numberOfGenerations, int numberOfIndividuals) {\n        this.distanceMatrix=distanceMatrix;\n        this.numberOfGenerations=numberOfGenerations;\n        this.numberOfIndividuals=numberOfIndividuals;\n        size=distanceMatrix.length;\n    }\n```", "```java\n    public Individual calculate() {\n\n        Individual[] population= GeneticOperators.initialize(numberOfIndividuals,size);\n        GeneticOperators.evaluate(population,distanceMatrix);\n\n        SharedData data=new SharedData();\n        data.setPopulation(population);\n        data.setDistanceMatrix(distanceMatrix);\n        data.setBest(population[0]);\n```", "```java\n        int numTasks=Runtime.getRuntime().availableProcessors();\n        GeneticPhaser phaser=new GeneticPhaser(numTasks,data);\n\n        ConcurrentGeneticTask[] tasks=new ConcurrentGeneticTask[numTasks];\n        Thread[] threads=new Thread[numTasks];\n\n        tasks[0]=new ConcurrentGeneticTask(phaser, numberOfGenerations, true);\n        for (int i=1; i< numTasks; i++) {\n            tasks[i]=new ConcurrentGeneticTask(phaser, numberOfGenerations, false);\n        }\n```", "```java\n        for (int i=0; i<numTasks; i++) {\n            threads[i]=new Thread(tasks[i]);\n            threads[i].start();\n        }\n\n        for (int i=0; i<numTasks; i++) {\n            try {\n                threads[i].join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        return data.getBest();\n    }\n}\n```"]