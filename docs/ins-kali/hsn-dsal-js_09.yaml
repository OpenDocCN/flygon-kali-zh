- en: Micro-Optimizations and Memory Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微优化和内存管理
- en: In this chapter, we will cover some of the basic concepts of HTML, CSS, JavaScript,
    and the browser in which we expect all of these to run in union. We always have,
    and always will, code in a certain style, which is natural. However, how did we
    develop this style? Is it good or can it get better? How do we get to decide what
    we should and should not ask others to follow? These are some of the questions
    that we will try and answer in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍HTML、CSS、JavaScript和我们期望所有这些内容在其中运行的浏览器的一些基本概念。我们一直以来都以某种风格编码，这是自然的。然而，我们是如何形成这种风格的？它是好的还是可以变得更好？我们如何决定我们应该和不应该要求其他人遵循什么？这些是我们将在本章中尝试回答的一些问题。
- en: 'In this chapter, we will discuss the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下内容：
- en: Importance of best practices and take a look at some of the examples.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践的重要性，以及一些示例。
- en: Exploring different kinds of HTML, CSS, and JavaScript optimizations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索不同类型的HTML、CSS和JavaScript优化
- en: Delve into the internal working of some of the features of Chrome.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解Chrome一些功能的内部工作。
- en: Best practices
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Best practices is a relative term for obvious reasons. What is considered best
    is rather dependent on the team in which you work and what version of JavaScript
    you work with. In this section, we will try to cast a wide net over some of these
    best practices, and get an understanding of what some of the practices look like
    so that we can adapt and use them as well.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 出于明显的原因，最佳实践是一个相对的术语。什么被认为是最佳的，更多取决于你所在的团队以及你使用的JavaScript版本。在本节中，我们将尝试广泛涵盖一些最佳实践，并了解一些实践看起来是什么样子，以便我们也可以适应并使用它们。
- en: Best practices for HTML
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML的最佳实践
- en: Let's approach this section top-down and address the best practices for each
    of the sections within an HTML file.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从上到下来处理HTML文件中每个部分的最佳实践。
- en: Declaring the correct DOCTYPE
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明正确的DOCTYPE
- en: Have you ever wondered why we have `<!DOCTYPE html>` at the top of our page?
    We can clearly leave it out, and still the page seems to work. Then, why exactly
    do we need this? The answer is **a****voiding backward compatibility**—if we do
    not specify the DOCTYPE, the browser that is interpreting and rendering our HTML
    goes into quirks mode, which is a technique to support really old websites that
    were built with outdated versions and markups of HTML, CSS, and JS. Quirks mode
    emulates a lot of bugs that existed in the older versions of the browsers, and
    we do not want to deal with those.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经想过为什么我们在页面顶部有“<!DOCTYPE html>”？我们显然可以不写它，页面似乎仍然可以工作。那么，我们为什么需要这个？答案是**避免向后兼容性**——如果我们不指定DOCTYPE，解释和呈现我们的HTML的浏览器将进入怪癖模式，这是一种支持使用过时版本和标记的HTML、CSS和JS构建的非常旧的网站的技术。怪癖模式模拟了旧版本浏览器中存在的许多错误，我们不想处理这些错误。
- en: Adding the correct meta-information to the page
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向页面添加正确的元信息
- en: 'Any web page, when rendered, needs some meta-information. Although this information
    does not get rendered on the page, it''s critical to render the page correctly.
    The following are some of the good practices for adding the meta-information:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 任何网页在呈现时都需要一些元信息。虽然这些信息不会在页面上呈现，但对于正确呈现页面至关重要。以下是一些添加元信息的良好实践：
- en: 'Adding the right `lang` attribute to your `html` tag to comply with w3c''s
    internationalization standards:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“html”标签中添加正确的“lang”属性，以符合w3c的国际化标准：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Declaring the correct `charset` to support special characters on your web page:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明正确的“charset”以支持网页上的特殊字符：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the correct `title` and `description` tags to support search engine optimization:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加正确的“title”和“description”标签以支持搜索引擎优化：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the appropriate `base` URL to avoid providing absolute URLs everywhere:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加适当的“base” URL以避免在各处提供绝对URL：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Dropping unnecessary attributes
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除不必要的属性
- en: 'This might seem obvious, but is still largely used. When we add a `link` tag
    to download a `stylesheet`, our browser already knows that it is a `stylesheet`.
    There is no reason to specify the type of that link:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很明显，但仍然被广泛使用。当我们添加一个“link”标签来下载样式表时，我们的浏览器已经知道它是一个样式表。没有理由指定该链接的类型：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Making your app mobile ready
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使您的应用程序适用于移动设备
- en: 'Have you ever seen one of those websites that look exactly the same on desktop
    and mobile and wonder why they would build it like that? In the new age of web
    development, why would someone not leverage the responsiveness provided by the
    latest HTML and CSS versions? This could happen to anyone; we have all the right
    breakpoints defined and are using media queries as expected, but nothing happens.
    This is usually because we forgot to include the `viewport`, the `meta` tag; including
    the `meta` tag for `viewport` fixes all our problems:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经见过那些在桌面和移动设备上看起来完全相同的网站，并想知道为什么他们要这样构建？在新时代的网页开发中，为什么有人不利用最新的HTML和CSS版本提供的响应性？这可能发生在任何人身上；我们已经定义了所有正确的断点，并且按预期使用媒体查询，但什么都没有发生。这通常是因为我们忘记了包括“viewport”，“meta”标签；包括“viewport”的“meta”标签可以解决我们所有的问题：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `viewport` is basically the total viewable area for a user, which will be
    smaller in a mobile and larger in a desktop; the `meta` tag defines how the browser
    should render the website, based on the size of the `viewport`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: “视口”基本上是用户可见区域的总和，在移动设备上较小，在桌面上较大；“meta”标签定义了浏览器根据“视口”的大小来呈现网站的方式。
- en: Loading style sheets in the <head>
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在<head>中加载样式表
- en: This is a matter of preference and choice. Can we load the style sheets at the
    end of the page load? Sure we can, but we want to avoid it so that our users do
    not see unstyled page flashing before it picks up the correct styles. Our browsers,
    when provided with CSS and HTML, create a **CSS Object Model** (**CSSOM**) and
    **Document Object Model** (**DOM**). When a DOM is being constructed, the browser
    looks up the CSSOM to check whether there are any styles corresponding to that
    node of the DOM. Hence, we want to make sure that the CSSOM is constructed and
    ready for the DOM to render.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个偏好和选择的问题。我们可以在页面加载的末尾加载样式表吗？当然可以，但我们希望避免这样做，以便我们的用户在捕捉到正确的样式之前不会看到未经样式化的页面闪烁。当浏览器提供CSS和HTML时，它们创建一个**CSS对象模型**（**CSSOM**）和**文档对象模型**（**DOM**）。在构建DOM时，浏览器查找CSSOM，以检查是否有任何与DOM节点对应的样式。因此，我们希望确保CSSOM已经构建并准备好供DOM渲染。
- en: An alternative is to load only the basic styles first in the head tag of the
    page, and the rest of the styles can be requested at the end of the body. That
    means our page can be rendered a little faster, but it is worth noting that this
    may not be worth the effort sometimes, depending on your application size and
    use case.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个替代方法是首先在页面的头部标签中只加载基本样式，其余的样式可以在body的末尾请求。这意味着我们的页面可以渲染得更快一些，但值得注意的是，这有时可能不值得，这取决于您的应用程序大小和用例。
- en: Avoiding inline styles
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免内联样式
- en: 'Using inline styles by providing them directly on the element in an HTML file
    is bad for multiple reasons:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在HTML文件中直接提供内联样式来使用它们是不好的，原因有很多：
- en: We cannot reuse the styles applied to one element
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法重用应用于一个元素的样式
- en: Our HTML is flooded with CSS, making it very noisy
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的HTML充斥着CSS，变得非常嘈杂
- en: We cannot leverage pseudo elements, such as `before` and `after`
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法利用伪元素，比如`before`和`after`
- en: Using semantic markup
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用语义标记
- en: 'With HTML5, we no longer have to worry about using a `<div>` tag for everything.
    We have been gifted with a more robust set of semantic tags, which help us construct
    our templates in a more meaningful fashion:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有了HTML5，我们不再需要担心为所有内容使用`<div>`标签。我们得到了一组更强大的语义标签，这些标签帮助我们以更有意义的方式构建我们的模板：
- en: '![](assets/dd8cb81c-7052-4a20-afb6-c694e977c20d.png)A point worth noting is
    that these new tags only provide meaning to our template but no styling. If we
    want it to look a certain way, we will need to style the elements as we want them
    to look. Also, the new HTML5 tags are not available in browsers older than IE9,
    so we need to prepare for fallbacks such as HTML5shiv.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/dd8cb81c-7052-4a20-afb6-c694e977c20d.png)值得注意的是，这些新标签只为我们的模板提供了含义，而没有样式。如果我们希望它看起来某种方式，我们需要根据我们希望它们看起来的样子来设计元素。此外，新的HTML5标签在IE9之前的浏览器中不可用，因此我们需要准备一些备用方案，如HTML5shiv。'
- en: Using Accessible Rich Internet Applications (ARIA) attributes
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可访问的丰富互联网应用程序（ARIA）属性
- en: 'Whenever we are developing a web application, we will need to ensure that our
    applications are compatible with screen readers to support users with disabilities:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们开发一个网络应用程序时，我们都需要确保我们的应用程序与屏幕阅读器兼容，以支持残障用户：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This information does not collide with any of the existing information on the
    screen, and it enables the screen readers to pick up and process this information.
    Of course, all of this is possible only if the HTML renderer supports ARIA, which
    is available in all the latest browsers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息不会与屏幕上的任何现有信息发生冲突，并且使屏幕阅读器能够捕捉和处理这些信息。当然，只有在HTML渲染器支持ARIA时，所有这些才是可能的，这在所有最新的浏览器中都是可用的。
- en: Loading scripts at the end
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在末尾加载脚本
- en: The heart of any application lives in the JavaScript files that are defined
    by the developers. Hence, we will need to pay extra attention while we try to
    load and execute these files, which can be significantly larger than that of their
    counterpart HTML and CSS files. When we try to load external JS files using a
    script tag, the browser first downloads them and then executes them (after parsing
    and compiling). We will need to make sure that our application is loaded and executed
    at the right time. What that means for us is that if our application logic is
    reliant on the DOM, we need to ensure that the DOM is rendered before the script
    is executed. This makes it a pretty good reason for us to load the scripts at
    the end of the body tag within our application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序的核心都存在于开发人员定义的JavaScript文件中。因此，当我们尝试加载和执行这些文件时，我们需要格外注意，因为它们的大小可能比它们的HTML和CSS文件的大小要大得多。当我们尝试使用脚本标签加载外部JS文件时，浏览器首先下载然后执行它们（在解析和编译之后）。我们需要确保我们的应用程序在正确的时间加载和执行。对我们来说，这意味着如果我们的应用逻辑依赖于DOM，我们需要确保DOM在脚本执行之前被渲染。这就是为什么我们需要在应用程序的body标签末尾加载脚本的一个很好的理由。
- en: Even if we do not rely on the DOM in our JavaScript, we would still want to
    load our scripts at the end because the script tags are render blocking by default,
    that is, if your browser encounters your script tag in the head (for example),
    it begins to download and execute the JS files and does not render the rest of
    the page until the execution is complete. Also, if we have too many JS files,
    then the page appears to have hung and does not render the UI completely to our
    end user until all the JS files have been downloaded and executed successfully.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的JavaScript不依赖于DOM，我们仍然希望在末尾加载我们的脚本，因为脚本标签默认是渲染阻塞的，也就是说，如果您的浏览器在头部（例如）遇到您的脚本标签，它开始下载和执行JS文件，并且在执行完成之前不渲染页面的其余部分。此外，如果我们有太多的JS文件，那么页面似乎已经挂起，并且在所有JS文件都已成功下载和执行之前，不会完全渲染UI给我们的最终用户。
- en: There is one workaround if you still want to add the script tags along with
    the link tag to download the style sheets. You can add the `defer` or `async`
    attribute to the script tag. `Defer` lets you download the file parallel to the
    DOM rendering and executes the script once the render is complete. The `async`
    downloads the file parallel to the DOM render and pauses rendering for execution
    and then resumes after execution. Use them wisely.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍然希望添加脚本标签以及链接标签以下载样式表，则有一个解决方法。您可以向脚本标签添加`defer`或`async`属性。`Defer`允许您在DOM渲染时并行下载文件，并在渲染完成后执行脚本。`async`在DOM渲染时并行下载文件，并在执行时暂停渲染，然后在执行后恢复。明智地使用它们。
- en: CSS best practices
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS最佳实践
- en: The list of CSS best practices is not as long as that of HTML. Also, a lot of
    potential issues can be subsided significantly by the use of a preprocessing language,
    such as **Sassy CSS** (**SCSS**). Let's assume that you cannot use SCSS for some
    reason and discuss good and bad of plain old CSS.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: CSS最佳实践的列表不像HTML那么长。此外，通过使用预处理语言，如**Sassy CSS**（**SCSS**），许多潜在问题可以得到显著缓解。假设由于某种原因您不能使用SCSS，并讨论纯粹的CSS的优缺点。
- en: Avoiding inline styles
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免内联样式
- en: This is important enough to be part of both HTML's and CSS's best practices.
    Just do not do apply inline styles.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这足够重要，以至于成为HTML和CSS最佳实践的一部分。不要应用内联样式。
- en: Do not use !important
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要使用!important
- en: Easy to say, hard to do. Using `!important` is one of the easiest workarounds
    available to make your styles apply to an element. However, this comes at a price
    of its own. CSS or Cascading Style Sheets rely on the fact that the styles will
    be cascaded based on the priority of the application (ID, class, and element tag)
    or the order in which they appear. Using `!important` messes that up, and if you
    have multiple CSS files, then it becomes a big mess to correct. It's better to
    avoid such a practice and do it the right way from the get-go.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 说起来容易，做起来难。使用`!important`是使样式应用于元素的最简单的解决方法之一。然而，这也有其代价。CSS或层叠样式表依赖于样式根据应用程序的优先级（ID、类和元素标签）或它们出现的顺序进行级联。使用`!important`会破坏这一点，如果您有多个CSS文件，那么纠正它将变得非常混乱。最好避免这样的做法，从一开始就用正确的方法做。
- en: Arranging styles within a class alphabetically
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在类中按字母顺序排列样式
- en: 'This does not sound like a big deal, does it? Well, if all you have is one
    CSS file with a couple of classes, then maybe it is okay. However, when you have
    big files with a complex hierarchy, the last thing you want is to commit a small
    mistake which costs you a lot of time. Take a look at the following example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来不像什么大不了的事，对吧？如果您只有一个带有几个类的CSS文件，那也许还可以。但是，当您有一个包含复杂层次结构的大文件时，您最不希望的是犯一个小错误，这会花费您大量的时间。看看以下示例：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note in the preceding code that we added conflicting styles for the background
    property of the element, and now when rendered, it is all red. This could have
    been easily caught, but because of the ordering of the properties within the class,
    it got lost.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上述代码中，我们为元素的背景属性添加了冲突的样式，现在在渲染时，它全部是红色的。这本来很容易被发现，但由于类内属性的顺序，它被忽略了。
- en: Defining the media queries in an ascending order
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按升序定义媒体查询
- en: 'Defining media queries is another area which gets confusing as the size of
    the application grows. When defining the media queries, always define them in
    an increasing order so that you can isolate your styles and leave an open upper
    bound, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 定义媒体查询是另一个随着应用程序规模增长而变得混乱的领域。在定义媒体查询时，始终按递增顺序定义它们，以便您可以隔离您的样式并留下一个开放的上限，如下所示：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note in the preceding code that we have left the last media query to apply for
    all screens that are `1200px` and more in size, which would cover monitors, TVs,
    and so on. This would not have worked well if we were doing it the other way,
    in which we set the styles based on the max-width of the screen size. What would
    happen if we open it on a projector? It will certainly not work like you hoped
    it would.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上述代码中，我们将最后一个媒体查询留给了适用于所有屏幕尺寸为`1200px`及以上的情况，这将涵盖显示器、电视等。如果我们按照屏幕尺寸的最大宽度设置样式，那么这样做就不会奏效。如果我们在投影仪上打开它会发生什么？它肯定不会像您希望的那样工作。
- en: Best practices for JavaScript
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript最佳实践
- en: There is no start and end to this topic. There are a lot of opinions regarding
    how things should be done in JavaScript, and it turns out that most of them are
    correct (depending on your background, experience, and use case). Let's take a
    look at some of the most commonly discussed best practices for JavaScript (ES5).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个话题没有开始和结束。关于JavaScript应该如何完成任务，有很多不同的观点，结果是大多数都是正确的（取决于您的背景、经验和用例）。让我们来看看一些关于JavaScript（ES5）最常讨论的最佳实践。
- en: Avoiding polluting the global scope
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免污染全局范围
- en: Do not add properties or methods to the global scope. These will bloat your
    window object and make your page slow and stuttery. Instead, always create a variable
    within a method, which will be taken care of when the method is destroyed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不要向全局范围添加属性或方法。这将使您的窗口对象膨胀，并使您的页面变得缓慢和不稳定。相反，总是在方法内创建一个变量，在方法被销毁时会被处理。
- en: Using 'use strict'
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用'use strict'
- en: It's a one-line change, which can go a long way when it comes to catching code
    smells and any code irregularities, such as deleting a variable. The `use strict`
    clause throws an error when an illegal action is performed at the runtime, so
    it doesn't necessarily prevent our app from breaking, but we can catch and fix
    issues before they are deployed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个一行的改变，当涉及捕捉代码异味和任何代码不规则性时，可以走很长的路，比如删除一个变量。`use strict`子句在运行时执行非法操作时会抛出错误，因此它并不一定防止我们的应用程序崩溃，但我们可以在部署之前捕捉并修复问题。
- en: Strict checking (== vs ===)
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 严格检查（== vs ===）
- en: JavaScript can be a fairly tricky language when coming to typecasting or type
    conversions. The fact that there are no data types does not make this any simpler.
    Using a ==forces an implicit typecasting as compared to ===**. **So, it is advisable
    to always use === unless you want 12== 12 to be true.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到类型转换时，JavaScript可能是一门相当棘手的语言。没有数据类型使得这一过程变得更加复杂。使用==会强制进行隐式类型转换，而===则不会。因此，建议始终使用===，除非你想让12==
    12成立。
- en: For more details on understanding why it works the way it does, refer to the
    Abstract Equality Comparison Algorithm, found at [https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3](https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解它为什么会这样工作的更多细节，请参考抽象相等比较算法，网址为[https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3](https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3)。
- en: Using ternary operators and Boolean || or &&
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用三元运算符和布尔||或&&
- en: 'It is always suggested to keep your code readable but, when warranted, use
    the ternary operators to make your code concise and readable:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 建议始终保持代码可读，但在必要时，使用三元运算符使代码简洁易读：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For example, the preceding code can be condensed as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，上述代码可以简化如下：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Setting default values can also be achieved easily as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 设置默认值也可以轻松实现如下：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Modularization of code
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码的模块化
- en: When we create a script, it is obvious that we want it to do multiple things,
    for example, if we have a login page, the script for the login page should handle
    login (obviously), reset a password, and signup. All of these operations would
    require the email validation. Keeping validation part of each of these operations
    in its own method is known as Modularization. It helps us keep our methods small,
    readable, and makes unit testing a lot easier.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个脚本时，很明显我们希望它能做多种事情，例如，如果我们有一个登录页面，登录页面的脚本应该处理登录（显然），重置密码和注册。所有这些操作都需要电子邮件验证。将验证作为每个操作的一部分放入自己的方法中被称为模块化。它帮助我们保持方法小，可读，并且使单元测试变得更容易。
- en: Avoiding pyramid of doom
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免金字塔式的厄运
- en: 'Pyramid of doom is a classic scenario where we have tons of nesting or branching.
    This makes the code overly complex and the unit testing a very complex job:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 金字塔式的厄运是一个经典场景，我们有大量的嵌套或分支。这使得代码过于复杂，单元测试变得非常复杂：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Instead, do the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是，做以下事情：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Keeping DOM access to a minimum
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尽量减少DOM访问
- en: DOM access is an expensive operation, and we need to reduce it as much as we
    can to avoid our page from dying. Try caching the DOM elements once they are accessed
    in some local variables or leverage virtual DOM, which is more efficient, as it
    batches all the DOM changes and dispatches them all together.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: DOM访问是一个昂贵的操作，我们需要尽量减少它，以避免页面崩溃。尝试在访问DOM元素后将它们缓存到一些本地变量中，或者利用虚拟DOM，它更有效，因为它批处理所有DOM更改并一起分派它们。
- en: Validating all data
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证所有数据
- en: Registering a new user? Ensure that all the fields entered are validated on
    both the UI and the backend. Doing it in both the places makes it twice as good,
    and validations on the UI help get the error message to the user a lot quicker
    than that of server-side validation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注册新用户？确保所有输入的字段在UI和后端都经过验证。在两个地方都这样做会使它变得两倍好，UI上的验证帮助用户更快地获得错误消息，而不是服务器端验证。
- en: Do not reinvent the wheel
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要重复造轮子
- en: JavaScript community is very generous when it comes to open source software
    and projects. Leverage them; do not rewrite something that is already available
    someplace else. It is not worth the time and effort to rewrite some of the community-tested
    software that is freely available. If a software does only 90% of what you need,
    consider contributing the remaining 10% of that functionality yourself to the
    open source project.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到开源软件和项目时，JavaScript社区非常慷慨。利用它们；不要重写已经在其他地方可用的东西。重写一些经过社区测试的免费可用软件不值得时间和精力。如果一个软件只满足你需求的90%，考虑为开源项目贡献剩下的10%功能。
- en: HTML optimizations
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML优化
- en: As web developers, we are well versed in creating templates. In this section,
    we will explore ways in which we can make this process as efficient as possible.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 作为网页开发者，我们对创建模板非常熟悉。在这一部分，我们将探讨如何尽可能地提高这个过程的效率。
- en: DOM structuring
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM结构
- en: 'As obvious as this might seem, DOM structuring can make quite a big difference
    when it comes to rendering the UI. For an HTML template to become DOM, it goes
    through a series of steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的是，DOM结构在渲染UI时会产生很大的差异。要使HTML模板成为DOM，需要经历一系列步骤：
- en: '**Template Parsing** : Parser reads the HTML file'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模板解析**：解析器读取HTML文件'
- en: '**Tokenization**: Parser identifies the tokens, such as `html` and `body`'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**标记化**：解析器识别标记，比如`html`和`body`'
- en: '**Lexing**: Parser converts the tokens to tags, such as `<html>` and `<body>`'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**词法分析**：解析器将标记转换为标签，比如`<html>`和`<body>`'
- en: '**DOM Construction**: This is the last step where the browser converts the
    tags into a tree while applying the applicable styles and rules for the element'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**DOM构建**：这是最后一步，浏览器将标记转换为树，同时应用适用的样式和规则给元素'
- en: With that in mind, it becomes important that we do not nest our elements unnecessarily.
    Try to apply styles to elements rather than nest them in other elements. With
    that being said, one might wonder, how much does this really matter? The browsers
    are pretty good at doing this, so would it really matter if I have an extra element
    in my DOM? Truthfully, no, it would not matter if you do have an extra element.
    However, think about all the different browsers that are out there. Also, how
    many places you are adding this additional element; consider the precedent that
    such a practice would set. Over time, your overhead is going to start to matter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，重要的是我们不要不必要地嵌套我们的元素。尽量对元素应用样式，而不是将它们嵌套在其他元素中。话虽如此，人们可能会想，这到底有多重要？浏览器在这方面做得相当不错，所以如果我的DOM中有一个额外的元素，真的会有多大关系吗？事实上，不会，如果你的DOM中有一个额外的元素并不会有关系。然而，想想所有不同的浏览器。还有，你添加这个额外元素的地方有多少；考虑这样一个做法会设定什么样的先例。随着时间的推移，你的开销会开始变得重要起来。
- en: Prefetching and preloading resources
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预取和预加载资源
- en: Some of the lesser-known properties of the `<link>` tag are the `rel=prefetch`
    and `rel=preload` options. They allow the browser to preload some of the content
    that will be required in the subsequent or, sometimes, even the current page.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`<link>`标签的一些较少为人知的属性是`rel=prefetch`和`rel=preload`选项。它们允许浏览器预加载一些在随后或者有时甚至是当前页面中需要的内容。'
- en: <link rel=prefetch >
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <link rel=prefetch >
- en: 'Let''s discuss a rather simple example to understand prefetching: loading images.
    Loading images is one of the most common actions a web page performs. We decide
    which image we want to load using either an `img` tag in the HTML template or
    the `background-image` property in CSS.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一个非常简单的例子来理解预取：加载图像。加载图像是网页执行的最常见操作之一。我们决定加载哪个图像，可以使用HTML模板中的`img`标签或CSS中的`background-image`属性。
- en: Either way, the image does not get loaded until the element is parsed. Also,
    let's say that your image is very large and takes a lot of time to download, then
    you would have to rely on a bunch of fallbacks, such as providing the image dimension
    so that the page does not flicker or using the `alt` attribute in case the download
    fails.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，直到元素被解析，图像都不会被加载。另外，假设你的图像非常大，需要很长时间才能下载，那么你将不得不依赖于一堆备用方案，比如提供图像尺寸，以便页面不会闪烁，或者在下载失败时使用`alt`属性。
- en: 'One possible solution is to prefetch your resources that will be needed in
    the near future. That way, you can avoid downloading the resources until the user
    lands on that page. A simple example  would look as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是预取将来需要的资源。这样，你可以避免在用户登陆到该页面之前下载资源。一个简单的例子如下：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are intentionally delaying the load of the `img` tag until the prefetch is
    done. Ideally, you would prefetch the resources needed for the next page, but
    this accomplishes the same.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有意延迟了`img`标签的加载，直到预取完成。理想情况下，你会预取下一页所需的资源，但这样也能达到同样的效果。
- en: 'Once we run this page, we can see the requests for the image as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行这个页面，我们可以看到对图像的请求如下：
- en: '![](assets/321a0a8d-d618-4f88-b00b-2a4180924181.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/321a0a8d-d618-4f88-b00b-2a4180924181.png)'
- en: This sounds too good to be true, right? Right, as useful as this feature is,
    there are issues that we run into when dealing with prefetch across multiple browsers.
    Firefox only prefetches when it is idle; some browsers are capable of pausing
    the download if the user triggers another action and then redownload the rest
    of the image when the browser is idle again, but again that depends on how the
    server is serving the cacheable content (that is, server needs to support serving
    multipart file). Then, there are browsers which can, and will, abandon the prefetch
    because the network is too slow.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来太好了，对吧？是的，尽管这个功能很有用，但在处理跨多个浏览器的预取时会遇到问题。Firefox只在空闲时预取；一些浏览器可以在用户触发其他操作后暂停下载，然后在浏览器再次空闲时重新下载剩余的图像，但这取决于服务器如何提供可缓存内容（即服务器需要支持提供多部分文件）。然后，有些浏览器可以且会放弃预取，因为网络太慢。
- en: <link rel=preload >
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <link rel=preload >
- en: Preload is very similar to prefetch, with the difference that the browser does
    not have a choice to abandon the download for any reason at any point once the
    resource download is triggered.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 预加载与预取非常相似，不同之处在于一旦资源下载被触发，浏览器就没有放弃下载的选择。
- en: 'The syntax is also very similar, except that we define the type of the resource
    that we are trying to preload:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 语法也非常相似，只是我们定义了我们试图预加载的资源的类型：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Prefetching and preloading are also a very common choice when it comes to downloading
    fonts and font families because the request to load fonts is not triggered until
    both the CSSOM and DOM are ready to go.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 预取和预加载在下载字体和字体系列时也是一个非常常见的选择，因为加载字体的请求直到CSSOM和DOM都准备好才会被触发。
- en: Layout and layering of HTML
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML的布局和分层
- en: Coming up with an HTML template for rendering your elements on the UI is one
    of the simplest tasks of being a web developer. In this section, we will talk
    about how Chrome handles the template and renders it onto the UI. There are two
    crucial parts of the HTML template, layout and layers, and we will take a look
    at examples of each of these and how they affect the page performance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为UI渲染元素设计HTML模板是作为Web开发人员最简单的任务之一。在本节中，我们将讨论Chrome如何处理模板并将其渲染到UI上。HTML模板有两个关键部分，布局和层，我们将看一些例子，以及它们如何影响页面性能。
- en: The HTML layout
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML布局
- en: 'Let''s start with an extremely simple web page and take a look at how chrome
    handles rendering this page:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的网页开始，看看Chrome如何处理渲染这个页面：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once we load the page, we will use Chrome **Developer tools** (**DevTools**)
    to generate the performance snapshot of this templates load. To do so, navigate
    to the CDT on your Chrome browser (Settings -> More tools -> Developer tools).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们加载页面，我们将使用Chrome**开发者工具**（**DevTools**）生成这个模板加载的性能快照。要这样做，导航到Chrome浏览器上的CDT（设置->更多工具->开发者工具）。
- en: 'Once we are there, let''s record a new snapshot by clicking on the record button
    on the top-left corner of the panel that just opened. Once your page loads, stop
    the recording and let the snapshot load in the panel. The result of that would
    look as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们到达那里，让我们通过点击打开面板左上角的记录按钮来记录一个新的快照。一旦你的页面加载完成，停止录制，让快照在面板中加载。结果如下：
- en: '![](assets/54f8d076-62e1-4693-a568-296d544c0175.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/54f8d076-62e1-4693-a568-296d544c0175.png)'
- en: Incomprehensible, right? Well, let's break this down into small pieces that
    we can understand. Our main focus will be on the `main` section (expanded in the
    screenshot). Let's zoom into that a bit to take a look at what the events are
    from left to right.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 难以理解，对吧？好吧，让我们把它分解成我们可以理解的小块。我们的主要关注点将是`main`部分（在截图中展开）。让我们放大一下，看看从左到右的事件是什么。
- en: 'First, we will see the beforeunload event:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看到beforeunload事件：
- en: '![](assets/51ace852-0b26-492b-aacc-79bda81c73ee.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/51ace852-0b26-492b-aacc-79bda81c73ee.png)'
- en: 'Next, we will see the update layer tree (which we will discuss later):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到更新图层树（我们稍后会讨论）：
- en: '![](assets/266d1ed6-7cc7-4da3-b92c-0deb63079235.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/266d1ed6-7cc7-4da3-b92c-0deb63079235.png)'
- en: 'We now note a Minor GC, which is a browser-specific event (we will discuss
    this in a later section):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们注意到一个Minor GC，这是一个特定于浏览器的事件（我们将在后面的部分讨论这个）：
- en: '![](assets/581f7229-dd5a-432e-af44-fcffb4d37f11.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/581f7229-dd5a-432e-af44-fcffb4d37f11.png)'
- en: 'Then, we will note the  `DOMContentLoaded` event followed by the `Recalculate
    Style` event, which is when our page is ready to be interacted with:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将注意`DOMContentLoaded`事件，然后是`Recalculate Style`事件，这是当我们的页面准备好进行交互时发生的事件：
- en: '![](assets/a171491a-16f2-49a4-bf80-949a8d0e8009.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a171491a-16f2-49a4-bf80-949a8d0e8009.png)'
- en: Pretty cool, right? This syncs exactly with what we have heard about browsers
    before. They load the page, then `DOMContentLoaded` gets triggered when everything
    is ready. However, notice that, there is another event called Minor GC which is
    being triggered too. We can ignore this, as it is internally handled by the browser
    and has very little to do with the way our code is structured.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，对吧？这与我们之前听说的浏览器完全一致。它们加载页面，然后在一切准备就绪时触发`DOMContentLoaded`。然而，请注意，还有另一个被触发的事件叫做Minor
    GC。我们可以忽略这个，因为它是由浏览器内部处理的，与我们的代码结构几乎没有关系。
- en: Once the DOM is loaded, we note that we have another event being triggered called
    `Recalculate Style`, which is exactly what it sounds like. The DOM is ready, and
    the browser checks and applies any and all styles that need to be applied to this
    element. However, you may wonder, we did not add any styles to our template, right?
    Then, what styles are we talking about? By default, all browsers apply styles
    to all the elements they render, and these are known as User Agent Stylesheets.
    The browser still has to add the user agent style sheet styles to the CSSOM.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦DOM加载完成，我们注意到另一个被触发的事件叫做`Recalculate Style`，这正是它听起来的样子。DOM已经准备好了，浏览器会检查并应用需要应用到这个元素的所有样式。然而，你可能会想，我们没有向我们的模板添加任何样式，对吧？那么，我们在谈论什么样式呢？默认情况下，所有浏览器都会向它们渲染的所有元素应用样式，这些被称为用户代理样式表。浏览器仍然需要将用户代理样式表样式添加到CSSOM中。
- en: We still haven't really discussed what `Layout` is, apart from it being the
    geometrical structure in which the browser will arrange the elements including,
    but not limited to, their size, shape, and position on the page. `Layout` is also
    an event, which will be recorded by the CDT, to show you how long the browser
    is spending in trying to rearrange your layout. It is very important that we try
    to keep the layout event to a minimum. Why? Because `Layout` is not an isolated
    event. It is chained by a sequence of other events (such as updating the layer
    tree and painting the UI), which are required to complete the arrangement of the
    elements on the UI.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了它是浏览器将安排元素的几何结构之外，我们还没有真正讨论`Layout`是什么，包括但不限于它们在页面上的大小、形状和位置。`Layout`也是一个事件，将被CDT记录下来，以显示浏览器在尝试重新排列布局时花费了多长时间。我们尽量将布局事件保持在最小范围内非常重要。为什么？因为`Layout`不是一个孤立的事件。它是由一系列其他事件（例如更新图层树和绘制UI）链接在一起的，这些事件需要完成UI上元素的排列。
- en: 'Another important thing to consider is that the `Layout` event is triggered
    for all the elements that are effected on the page, that is, even when one deeply
    nested element is changed, your entire element (or event surrounding elements
    based on the change) is re-laid out. Let''s take a look at an example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事情要考虑的是，`Layout`事件会为页面上受影响的所有元素触发，也就是说，即使一个深度嵌套的元素被改变，你的整个元素（或者根据改变而改变的周围元素）都会被重新布局。让我们看一个例子：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It is pretty straightforward; we have one page with a very small parent consisting
    of four child elements. We have a button which sets the height of all elements
    to `100px`. Let''s now run this page and track the performance when we click on
    the button `update height` to change the height of the elements we see the following
    on the UI:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单；我们有一个包含四个子元素的非常小的父元素的页面。我们有一个按钮，它将所有元素的高度设置为`100px`。现在让我们运行这个页面，并跟踪当我们点击按钮`update
    height`来改变元素的高度时的性能，我们在UI上看到以下内容：
- en: '![](assets/f79f82f7-c9ed-4cd4-a22f-d6a6312d30a3.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f79f82f7-c9ed-4cd4-a22f-d6a6312d30a3.png)'
- en: We can see from preceding screenshot that once the click event starts, it triggers
    our function, which then sets off a chain of events, including `Layout` that takes
    0.23ms. However, one might wonder, why do we have a `Recalculate Style` event
    in between the `Function` and the `Layout`? Remember our old friend User Agent
    Stylesheet? It sets a few styles on the button when it is active, which triggers
    the `Recalculate Style` event.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从前面的截图中看到，一旦点击事件开始，它触发了我们的函数，然后触发了一系列事件，包括`Layout`，用时0.23毫秒。然而，你可能会想，为什么在`Function`和`Layout`之间有一个`Recalculate
    Style`事件？还记得我们的老朋友用户代理样式表吗？它在按钮激活时设置了一些样式，这触发了`Recalculate Style`事件。
- en: If you want to remove all the styles of an element (such as a button in the
    case described earlier), you can do so by applying the `all:unset`; property to
    the element of your choice. This will completely un-style the element. However,
    it will reduce the `Recalculate Style` event to a fraction of what it is with
    the User Agent Styles applied.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要删除元素的所有样式（例如在前面描述的按钮中），您可以通过将“all:unset”属性应用于您选择的元素来这样做。这将完全取消元素的样式。但是，它将减少“Recalculate
    Style”事件的时间，使其成为应用用户代理样式的一小部分。
- en: 'Let''s now change the JavaScript function to only change the style of the first
    child element instead of all the elements on the page and take a look at how that
    affects the `Layout` events execution in our case:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将JavaScript函数更改为仅更改页面上的第一个子元素的样式，而不是所有元素，并看看这如何影响我们的情况下“Layout”事件的执行：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, when we run the page and profile the execution of the click method, we
    will see the following in the profiler:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行页面并分析点击方法的执行时，我们将在分析器中看到以下内容：
- en: '![](assets/572fd447-4897-46b1-9042-c17a91bf5378.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/572fd447-4897-46b1-9042-c17a91bf5378.png)'
- en: As you can see in the preceding screenshot, it still takes 0.21ms to layout
    the entire page, which is not very different from our previous value. In our preceding
    example, we have five more elements. However, in a production application, this
    can, and will, scale to 1000s of elements, and, for a smooth transition, we want
    to keep our `Layout` event under 16ms (60fps).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的屏幕截图中看到的，整个页面的布局仍然需要0.21毫秒，这与我们先前的值并没有太大不同。在我们先前的示例中，我们有五个更多的元素。但是，在生产应用程序中，这可能会扩展到数千个元素，并且为了平稳过渡，我们希望保持我们的“Layout”事件在16毫秒以下（60fps）。
- en: In all probability, you may not ever come across this issue, but if you do,
    the simplest way to handle it would be to first check that you are using the latest
    layout model supported by your browser. In most of the browsers, it would be flexbox
    or grid, so prefer that over floats, percentages, or positioning.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，您可能永远不会遇到这个问题，但如果您遇到了，处理它的最简单方法是首先检查您的浏览器是否支持最新的布局模型。在大多数浏览器中，它将是flexbox或grid，因此最好选择它而不是浮动、百分比或定位。
- en: HTML layers
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML图层
- en: As we have seen in the earlier example, once the element is re-laid out, we
    `Paint` the element, that is, fill the pixels with the color, which is supposed
    to be a part of the element at the given position (determined by `Layout`).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的示例中所看到的，一旦元素重新布局，我们就会“Paint”元素，也就是说，用颜色填充像素，这应该是元素在给定位置的一部分（由“Layout”确定）。
- en: Once the `Paint` event is complete, the browser then performs `Composition`,
    which is basically our browser putting together all the parts of the page. The
    lesser these parts, the faster the page load will be. Also, if a certain section
    of the `Composition` takes too long, then the entire page load is delayed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦“Paint”事件完成，浏览器就会执行“Composition”，基本上是我们的浏览器将页面的所有部分放在一起。部分越少，页面加载速度就越快。此外，如果“Composition”的某个部分花费太长时间，那么整个页面加载就会延迟。
- en: How do we handle these operations which take too long? We can handle it by promoting
    them to their own layer. There are certain CSS operations that we can perform
    on elements, which will promote them to their own layer. What does that mean for
    us? These promoted elements will be now deferred and executed on the GPU as textures.
    We no longer have to worry about our browser triggering the `Layout` or `Paint`
    event for these promoted elements, and we are only concerned with the `Composition`
    of the element.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理这些花费太长时间的操作？我们可以通过将它们提升到它们自己的图层来处理。有一些CSS操作，我们可以对元素执行，这将使它们提升到它们自己的图层。这对我们意味着什么？这些提升的元素现在将被延迟并在GPU上作为纹理执行。我们不再需要担心我们的浏触发这些提升元素的“Layout”或“Paint”事件，我们只关心元素的“Composition”。
- en: 'From the example earlier, so far we have established the first four steps of
    the flow of any change as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中，到目前为止，我们已经确定了任何更改流程的前四个步骤如下：
- en: JavaScript file gets executed
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript文件被执行
- en: Recalculation of styles
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 样式重新计算
- en: The `Layout` event
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “Layout”事件
- en: The `Paint` event
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “Paint”事件
- en: 'Now, to that list, we can add the following steps to completely render the
    element on the UI:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将以下步骤添加到列表中，以完全在UI上呈现元素：
- en: 5\. `Composition`
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 5. “Composition”
- en: 6\. Multithread Rasterization
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 多线程光栅化
- en: '*Step 6* merely renders our pixels onto the UI, which can be batched and run
    on parallel threads. Let''s create a simple HTML and take a look at how it renders
    onto a single layer on the UI:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤6*仅仅是将我们的像素渲染到UI上，可以批处理并在并行线程上运行。让我们创建一个简单的HTML并看看它如何渲染到UI上的单个图层：'
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can access the Layers from the DevTool by navigating to the Settings option
    and then selecting More tools and Layers. On loading the page shown previously,
    we will see the following in the Layers:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过导航到“设置”选项，然后选择“更多工具”和“图层”来从DevTool中访问图层。在加载先前显示的页面时，我们将在图层中看到以下内容：
- en: '![](assets/22386b4f-25e5-4522-b94b-f2382afa915b.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/22386b4f-25e5-4522-b94b-f2382afa915b.png)'
- en: 'When we profile the preceding page, we can see, as expected, that the page
    loads and renders the UI on the `Main` thread:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对前面的页面进行分析时，我们可以看到，如预期的那样，页面在“Main”线程上加载和呈现UI：
- en: '![](assets/4d72a23b-6be1-4df8-8512-2d1153d50d58.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4d72a23b-6be1-4df8-8512-2d1153d50d58.png)'
- en: 'Let''s now change this example to load onto its own layer so that we can completely
    skip both the `Layout` and the `Paint` sections altogether. To load an element
    onto a layer of its own, all we need to do is either give it a CSS transform or
    set the `will-change` property to transform:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '现在让我们将此示例更改为加载到自己的图层上，以便我们可以完全跳过“Layout”和“Paint”部分。要将元素加载到自己的图层上，我们只需要给它一个CSS变换或将“will-change”属性设置为transform:'
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following is an updated example template, which uses the CSS3 `transform`
    property:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个更新后的示例模板，它使用CSS3“transform”属性：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, we added a very small animation, which will infinitely
    rotate the element. When we reload the page, we can see that it has been added
    to its own layer:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了一个非常小的动画，它将无限旋转元素。当我们重新加载页面时，我们可以看到它已被添加到自己的图层中：
- en: '![](assets/c948a949-970a-4661-ba96-c92d1f7e34ca.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c948a949-970a-4661-ba96-c92d1f7e34ca.png)'
- en: 'Not just that, when we record the performance of our modified template, we
    can see something quite interesting:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，当我们记录修改模板的性能时，我们会看到一些非常有趣的东西：
- en: '![](assets/67735520-b4cb-47f3-9140-4f49d5a87138.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/67735520-b4cb-47f3-9140-4f49d5a87138.png)'
- en: As we can see in the preceding screenshot, the browser completely defers the
    `Layer` onto the GPU as a new texture, and, from then on, the GPU handles the
    rendering/updating of the element and not the browser.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的截图中看到的，浏览器完全将“层”推迟到GPU作为新的纹理，从那时起，GPU处理元素的渲染/更新，而不是浏览器。
- en: Okay, so, does that mean we load each element onto its own `Layer` and then
    let the GPU take it from there? No, certainly not, because each `Layer` internally
    requires memory, and loading 1,000s of elements onto each Layer would be counterproductive.
    For example, the only time when we should intentionally promote elements to their
    own `Layer` is when an element is taking too long during `Composition` and is
    choking operations, such as scroll or swipe. Another use case could be when you
    have a single element performing multiple changes, such as animating height, width,
    and background color. This will continuously invoke all the steps of the rendering
    process (from `Layout` to Rasterization), and we do not really need to do all
    of that if we know that it is limited to these few changes. We can simply promote
    this element to its own layer and be done with it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这是否意味着我们将每个元素加载到自己的“层”上，然后让GPU接管？当然不是，因为每个“层”在内部都需要内存，并且将成千上万的元素加载到每个“层”上将是适得其反的。例如，我们有意将元素提升到自己的“层”的唯一时间是当元素在“合成”期间花费太长时间，并且正在阻碍操作，例如滚动或滑动时。另一个用例可能是当您有一个单一元素执行多个更改时，例如动画高度、宽度和背景颜色。这将不断调用渲染过程的所有步骤（从“布局”到光栅化），如果我们知道它仅限于这些少量更改，那么我们实际上不需要做所有这些。我们可以简单地将此元素提升到自己的层并完成。
- en: CSS optimizations
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS优化
- en: 'CSS optimizations are extremely easy and kind of obvious if you have experience
    developing with any preprocessor frameworks, such as SCSS/LESS. When we discuss
    CSS optimization, we are really talking about two different yet dependent things:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有使用任何预处理器框架（如SCSS/LESS）的开发经验，那么CSS优化非常容易并且显而易见。当我们讨论CSS优化时，我们实际上在谈论两个不同但又相关的事情：
- en: Loading the style sheets
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载样式表
- en: Rendering and applying styles
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染和应用样式
- en: Coding practices
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码实践
- en: There are a number of coding practices that we can adapt and learn to make our
    application perform better. Most of them might seem insignificant, but they do
    matter when scaled to a large application. We will discuss a few of these techniques
    with examples.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多编码实践可以适应和学习，以使我们的应用程序表现更好。其中大多数可能看起来微不足道，但当扩展到大型应用程序时确实很重要。我们将用示例讨论其中一些技术。
- en: Using smaller values for common ENUM
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对常见的ENUM使用较小的值
- en: 'As we are talking about reducing the page load time, one quick way to do so
    is by removing redundancies in the CSS file itself:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在讨论减少页面加载时间，因此一种快速的方法是通过删除CSS文件本身中的冗余来实现：
- en: Using `#FFFFFF` ? Switch to `#FFF`, which is the same RGB value represented
    in short.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`#FFFFFF`？改用`#FFF`，这是相同的RGB值，用简短表示。
- en: Do not add `px` after a properties value if the value is `0`.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值为“0”，则不要在属性值后添加“px”。
- en: Use minification if not being used already. This concatenates all the CSS files
    in use and removes all the whitespace and newlines.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果尚未使用，请使用缩小。这会将所有正在使用的CSS文件连接起来，并删除所有空格和换行符。
- en: Use GZip to compress the minified file while transferring it over the network.
    It is very easy, and browsers are very good at unzipping the files efficiently.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在通过网络传输时使用GZip压缩已经被缩小的文件。这很容易，浏览器非常擅长高效地解压文件。
- en: 'Be aware of browser-specific optimizations at hand. For example, in case of
    Chrome, we do not have to apply styles in the `rgba(x,y,z,a)` format. We can apply
    it as `rgba` during dev and extract the corresponding HEX value using the DevTool.
    Simply, inspect the element in question and click on the small rectangle while
    pressing *Shift*:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意手头的特定于浏览器的优化。例如，在Chrome的情况下，我们不必以“rgba(x,y,z,a)”格式应用样式。我们可以在开发过程中应用它为“rgba”，并使用DevTool提取相应的HEX值。简单地检查相关元素，同时按下*Shift*点击小矩形：
- en: '![](assets/e80a8814-de08-45cf-a14c-b60e7b7ee381.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e80a8814-de08-45cf-a14c-b60e7b7ee381.png)'
- en: Using shorthand properties
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用简写属性
- en: Using shorthand properties is one way in which the page load can be sped up.
    As obvious as it may sound, sometimes, we take the browser and network for granted
    when we are working on our cozy laptop, and we forget to take into consideration
    the poor 3G-based devices. So, the next time you want to style the background
    or border of an element, ensure that they are all collapsed and written using
    shorthand.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简写属性是加快页面加载速度的一种方法。尽管听起来很明显，但有时候当我们在舒适的笔记本电脑上工作时，我们会认为浏览器和网络是理所当然的，而忘记考虑那些使用3G设备的用户。因此，下次您想要为元素设置背景或边框样式时，请确保它们都被折叠并使用简写方式编写。
- en: 'Sometimes, you may run into a situation where you want to override only one
    property of a certain element''s style. For example, if you want to apply border
    on three sides of an element, use the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能会遇到这样的情况，您只想覆盖某个元素样式的一个属性。例如，如果您想在元素的三个边上应用边框，请使用以下方法：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Avoiding complex CSS selectors
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免复杂的CSS选择器
- en: Whenever you are creating your CSS styles, it is imperative to understand that there
    is a cost associated with the browser to apply these styles to any element. We
    can analyze our CSS selectors the same way we do our JavaScript and come up with
    the best and worst case runtime performance of each of the styles we apply.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您创建CSS样式时，都必须了解将这些样式应用于任何元素对浏览器都有成本。我们可以像分析JavaScript一样分析我们的CSS选择器，并得出我们应用的每种样式的最佳和最坏情况运行时性能。
- en: 'For instance, consider that we have a style as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑我们有以下样式：
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The complexity of this would be much higher than simply creating a class and
    assigning it directly to the element itself:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这种复杂性要比简单地创建一个类并直接分配给元素本身要高得多：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Our browser no longer has to check whether each and every element falls into
    the hierarchy of the style defined previously. A technique developed out of this
    concept is called  **Block-Element-Modifier** (**BEM**), which is quite easy to
    understand. Give a single class name to your elements, and try not to nest them:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的浏览器不再需要检查每个元素是否完全符合先前定义的样式层次结构。基于这个概念发展出的一种技术称为**块-元素-修饰符**（**BEM**），这是非常容易理解的。给您的元素一个单一的类名，并尽量不要嵌套它们：
- en: 'So, consider that your template looks as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，假设您的模板如下所示：
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You could apply styles using BEM as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用BEM应用样式，如下所示：
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you ever need to add a custom styling to an element, you can either create
    a new class and apply it directly, or you can combine the nesting with the current
    level:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要为元素添加自定义样式，可以创建一个新类并直接应用，或者可以将嵌套与当前级别结合起来：
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Understanding the browser
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解浏览器
- en: Similar to HTML rendering, CSS parsing and rendering are also complex processes,
    which browsers very effortlessly hide. It is always good to know what we can avoid
    to make things better for us. Let's take the same example as HTML and discuss
    how Chrome handles these.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与HTML渲染类似，CSS解析和渲染也是复杂的过程，浏览器非常轻松地隐藏了这些过程。了解我们可以避免什么总是有好处的。让我们以与HTML相同的示例为例，讨论Chrome如何处理这些问题。
- en: Avoiding repaint and reflow
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免重绘和回流
- en: 'Let''s first briefly talk about what a repaint and reflow are:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先简要讨论一下重绘和回流是什么：
- en: '**Repaint**: An action performed by the browser when the non-geometric properties
    of an element change, for example, background color, text color, and so on.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**重绘**：浏览器在元素的非几何属性发生变化时执行的操作，例如背景颜色、文本颜色等。'
- en: '**Reflow**: An action performed by the browser because of the geometric change
    to an element (or its parent) directly or via a computed property. This process
    is same as the `Layout` discussed earlier.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**回流**：浏览器执行的操作，因为元素（或其父元素）的几何变化，直接或通过计算属性。这个过程与之前讨论的`Layout`相同。'
- en: While we cannot completely prevent Repaint and Reflow events completely, we
    can certainly play our part in minimizing the changes that trigger these operations.
    Almost all DOM `read` operations (such as `offsetWidth` and `getClientRects`) trigger
    a `Layout` event because the values of such read operations are done on demand,
    and the browser does not care about their values until explicitly requested. Also,
    anytime we modify the DOM, the `Layout` is invalidated and it will have to be
    recalculated if we need to read the DOM elements properties the next time.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们无法完全防止重绘和回流事件，但我们肯定可以在最小化触发这些操作的更改中发挥作用。几乎所有DOM `read`操作（例如`offsetWidth`和`getClientRects`）都会触发`Layout`事件，因为这些读操作的值是按需进行的，浏览器在明确请求之前不关心它们的值。此外，每当我们修改DOM时，`Layout`都会失效，如果我们需要下次读取DOM元素属性，它将不得不重新计算。
- en: Critical rendering path (CRP)
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键渲染路径（CRP）
- en: So far, we have seen how to optimize the page load (reducing payload, size,
    and so on), and then we talked about the things which we will need to account
    for to keep the page performant once it is rendered. Critical rendering path is
    the technique of optimizing the initial load of the page above the fold (that
    is, the top part of the page that shows up on the initial load prior to any scroll).
    This is also known as **time to interact** (**TTI**) or **time to first byte**
    (**TTFB**), which we want to reduce to keep the page load fast.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何优化页面加载（减少负载、大小等），然后我们谈到了渲染后需要考虑的事情。关键渲染路径是优化页面加载的技术，即在折叠线之上（即在任何滚动之前显示的页面顶部部分）的初始加载。这也被称为**交互时间**（**TTI**）或**首字节时间**（**TTFB**），我们希望减少以保持页面加载速度。
- en: 'Technically, CRP includes the following steps:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，CRP包括以下步骤：
- en: Receive and start parsing HTML.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收并开始解析HTML。
- en: Download and construct CSSOM.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并构建CSSOM。
- en: Download and execute JS.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并执行JS。
- en: Finish constructing DOM.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成构建DOM。
- en: Create Render Tree.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建渲染树。
- en: 'So if we want our TTI to be low, it''s quite obvious that we will need to have
    our DOM and CSSOM constructed as quickly as possible without any render-blocking
    CSS or parser-blocking JS files. One of the indications for our TTI to be low
    is that our `DOMContentLoaded` event fires quickly because DCL is fired only when
    DOM and CSSOM are ready. Let''s take the following example template:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们希望我们的TTI低，很明显，我们需要尽快构建我们的DOM和CSSOM，而不需要任何阻塞渲染的CSS或阻塞解析器的JS文件。我们的TTI低的一个指标是我们的`DOMContentLoaded`事件快速触发，因为DCL仅在DOM和CSSOM准备就绪时触发。让我们看下面的示例模板：
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can see that it is pretty lean and does not even load any external styles
    or scripts. This is pretty unusual for a web page, but it serves as a good example.
    When we run this page and open the Network tab, we can see the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它非常简洁，甚至没有加载任何外部样式或脚本。这对于网页来说非常不寻常，但它作为一个很好的例子。当我们运行这个页面并打开网络选项卡时，我们可以看到以下内容：
- en: '![](assets/1bb2c85f-d936-4678-b647-c3e2c7ffe398.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1bb2c85f-d936-4678-b647-c3e2c7ffe398.png)'
- en: 'However, the HTML we mentioned is pretty unusual. In all possibility, we will
    have more than one external CSS and JS file being loaded into our page. In situations
    like that, our DCL event gets delayed. Let''s add blank CSS and JS files to be
    loaded in our `blank.html` file:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们提到的HTML是非常不寻常的。很可能，我们将加载多个外部CSS和JS文件到我们的页面中。在这种情况下，我们的DCL事件会被延迟。让我们在`blank.html`文件中添加空白的CSS和JS文件以加载：
- en: '![](assets/a2b4363a-4909-4a4f-b2fb-b0a217c6fc6a.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a2b4363a-4909-4a4f-b2fb-b0a217c6fc6a.png)'
- en: 'Here, we can see that, even though there isn''t much to be loaded, the DCL
    event has been pushed until the browser downloads and runs the JS file because
    the JS files fetching and execution are render blocking operations. Our goal is
    now much clearer: we will need to reduce the DCL to a minimum, and, from what
    we have seen so far, we will need to load the HTML ASAP while everything else
    can be loaded once the initial page is rendered (or at least is being rendered).
    Earlier we have seen that we can use the `async` keywords along with the script
    tags to make the JavaScript load and execute asynchronously. Let''s use the same
    now to make our page load faster:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，即使没有太多要加载，DCL 事件也被推迟，直到浏览器下载并运行 JS 文件，因为 JS 文件的获取和执行是渲染阻塞操作。我们的目标现在更加明确：我们需要将
    DCL 减少到最低限度，并且从目前我们已经看到的情况来看，我们需要尽快加载 HTML，而其他所有内容可以在初始页面被渲染后（或者至少正在被渲染时）加载。之前我们已经看到，我们可以使用
    `async` 关键字和脚本标签一起使 JavaScript 异步加载和执行。现在让我们使用相同的方法来使我们的页面加载更快：
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, when we run this page with the Network tab open, we will see the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们打开网络选项卡运行这个页面时，我们会看到以下内容：
- en: '![](assets/45273501-86bf-46b9-9d2e-0fbfbb2431a1.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/45273501-86bf-46b9-9d2e-0fbfbb2431a1.png)'
- en: We can see that the DCL (represented by the blue vertical line under the *waterfall*
    tab) occurs way before the CSS and JS files are downloaded and executed. Another
    advantage of using the `async` attribute is that the `async` attribute indicates
    that the JavaScript is not dependent on CSSOM, and hence it does not have to be
    blocked by the CSSOM construction.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 DCL（在 *瀑布* 选项卡下表示为蓝色垂直线）发生在 CSS 和 JS 文件被下载和执行之前。使用 `async` 属性的另一个优势是，`async`
    属性表示 JavaScript 不依赖于 CSSOM，因此不需要被 CSSOM 构建阻塞。
- en: JavaScript optimizations
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 优化
- en: There are tons of resources available online to discuss the various optimizations
    that can be applied to JavaScript. In this section, we will take a look at some
    of these micro-optimizations and determine how we can take small steps toward
    making our JavaScript more performant.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量的在线资源可以讨论可以应用于 JavaScript 的各种优化。在本节中，我们将看一些这些微优化，并确定我们如何采取小步骤使我们的 JavaScript
    更高效。
- en: Truthy/falsy comparisons
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真值/假值比较
- en: 'We have all, at some point, written if conditions or assigned default values
    by relying on the truthy or falsy nature of the JavaScript variables. As helpful
    as it is most of the times, we will need to consider the impact that such an operation
    would cause on our application. However, before we jump into the details, let''s
    discuss how any condition is evaluated in JavaScript, specifically an `if` condition
    in this case. As a developer, we tend to do the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都曾经在某个时候编写过 if 条件或者依赖于 JavaScript 变量的真值或假值来分配默认值。尽管大多数时候这很有帮助，但我们需要考虑这样一个操作对我们的应用程序会造成什么影响。然而，在我们深入细节之前，让我们讨论一下在
    JavaScript 中如何评估任何条件，特别是在这种情况下的 if 条件。作为开发者，我们倾向于做以下事情：
- en: '[PRE30]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This works for most of the cases, unless the number is 0, in which case it
    gets evaluated to false. That is a very common edge case, and most of us catch
    it anyway. However, what does the JavaScript engine have to do to evaluate this
    condition? How does it know whether the objOrNumber evaluates to true or false?
    Let''s return to our ECMA262 specs and pull out the IF condition spec ([https://www.ecma-international.org/ecma-262/5.1/#sec-12.5](https://www.ecma-international.org/ecma-262/5.1/#sec-12.5)).
    The following is an excerpt of the same:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这对大多数情况都适用，除非数字是 0，这种情况下会被评估为 false。这是一个非常常见的边缘情况，我们大多数人都会注意到。然而，JavaScript
    引擎为了评估这个条件需要做些什么呢？它如何知道 objOrNumber 评估为 true 还是 false？让我们回到我们的 ECMA262 规范并提取 IF
    条件规范 ([https://www.ecma-international.org/ecma-262/5.1/#sec-12.5](https://www.ecma-international.org/ecma-262/5.1/#sec-12.5))。以下是同样的摘录：
- en: Semantics
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 语义
- en: The production IfStatement : If (Expression) Statement else Statement
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: The production IfStatement : If (Expression) Statement else Statement
- en: 'Statement is evaluated as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Statement 的评估如下：
- en: Let exprRef be the result of evaluating Expression.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让 exprRef 成为评估 Expression 的结果。
- en: If ToBoolean(GetValue(exprRef)) is true, then
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 ToBoolean(GetValue(exprRef)) 是 true，那么
- en: Return the result of evaluating the first Statement.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回评估第一个 Statement 的结果。
- en: Else,
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，
- en: Return the result of evaluating the second Statement.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回评估第二个 Statement 的结果。
- en: 'Now, we note that whatever expression we pass goes through the following three
    steps:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们注意到我们传递的任何表达式都经历以下三个步骤：
- en: Getting the `exprRef` from `Expression`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Expression` 获取 `exprRef`。
- en: '`GetValue` is called on `exprRef`.'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetValue` 在 `exprRef` 上调用。'
- en: '`ToBoolean` is called as the result of *step 2*.'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ToBoolean` 被作为 *步骤2* 的结果调用。'
- en: '*Step 1* does not concern us much at this stage; think of it this way—an expression
    can be something like `a == b` or something like the `shouldIEvaluateTheIFCondition()`
    method call, that is, something that evaluates your condition.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤1* 在这个阶段并不关心我们太多；可以这样想——一个表达式可以是像 `a == b` 这样的东西，也可以是像 `shouldIEvaluateTheIFCondition()`
    方法调用这样的东西，也就是说，它是用来评估你的条件的东西。'
- en: '*Step 2* extracts the value of the `exprRef`, that is, 10, true, undefined.
    In this step, we differentiate how the value is extracted based on the type of
    the `exprRef`. You can refer to the details of `GetValue` at [https://www.ecma-international.org/ecma-262/5.1/#sec-8.7.1](https://www.ecma-international.org/ecma-262/5.1/#sec-8.7.1).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤2* 提取了 `exprRef` 的值，也就是 10、true、undefined。在这一步中，我们根据 `exprRef` 的类型区分了值是如何提取的。你可以参考
    [https://www.ecma-international.org/ecma-262/5.1/#sec-8.7.1](https://www.ecma-international.org/ecma-262/5.1/#sec-8.7.1)
    中 `GetValue` 的详细信息。'
- en: '*Step 3* then converts the value extracted from *Step 2* into a Boolean value
    based on the following table (taken from [https://www.ecma-international.org/ecma-262/5.1/#sec-9.2](https://www.ecma-international.org/ecma-262/5.1/#sec-9.2)):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤3* 然后根据以下表格（取自 [https://www.ecma-international.org/ecma-262/5.1/#sec-9.2](https://www.ecma-international.org/ecma-262/5.1/#sec-9.2)）将从
    *步骤2* 中提取的值转换为布尔值：'
- en: '![](assets/3c9cc47e-b91e-414d-80ab-ef45d24f106b.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3c9cc47e-b91e-414d-80ab-ef45d24f106b.png)'
- en: At each step, you can see that it is always beneficial if we are able to provide
    the direct boolean value instead of a truthy or falsy value.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一步，您可以看到，如果我们能够提供直接的布尔值而不是真值或假值，那么总是有益的。
- en: Looping optimizations
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环优化
- en: 'We can do a deep-down dive into the for loop, similar to what we did with the
    if condition earlier ([https://www.ecma-international.org/ecma-262/5.1/#sec-12.6.3](https://www.ecma-international.org/ecma-262/5.1/#sec-12.6.3)),
    but there are easier and more obvious optimizations which can be applied when
    it comes to loops. Simple changes can drastically affect the quality and performance
    of the code; consider this for example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以深入研究for循环，类似于我们之前对if条件所做的（[https://www.ecma-international.org/ecma-262/5.1/#sec-12.6.3](https://www.ecma-international.org/ecma-262/5.1/#sec-12.6.3)），但是在循环方面可以应用更简单和更明显的优化。简单的更改可以极大地影响代码的质量和性能；例如：
- en: '[PRE31]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding code can be changed as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以更改如下：
- en: '[PRE32]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'What is even better is to run the loops in reverse, which is even faster than
    what we have seen previously:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是以相反的方式运行循环，这比我们之前看到的更快：
- en: '[PRE33]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The conditional function call
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件函数调用
- en: 'Some of the features that we have within our applications are conditional.
    For example, logging or analytics fall into this category. Some of the applications
    may have logging turned off for some time and then turned back on. The most obvious
    way of achieving this is to wrap the method for logging within an if condition.
    However, since the method could be triggered a lot of times, there is another
    way in which we can make the optimization in this case:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中的一些功能是有条件的。例如，日志记录或分析属于这一类。一些应用程序可能会在某段时间内关闭日志记录，然后重新打开。实现这一点最明显的方法是将日志记录方法包装在if条件中。但是，由于该方法可能被触发多次，我们可以以另一种方式进行优化：
- en: '[PRE34]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Instead of the preceding approach, we can instead try to do something, which
    is only slightly different but allows V8-based engines to optimize the way the
    code is executed:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 不是前面的方法，我们可以尝试做一些稍微不同的事情，这样V8引擎可以优化代码的执行方式：
- en: '[PRE35]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, the preceding implementation is a double-edged sword. The reason for that
    is very simple. JavaScript engines employ a technique called **inline caching**
    (**IC**), which means that any previous lookup for a certain method performed
    by the JS engine will be cached and reused when triggered the next time; for example,
    if we have an object that has a nested method, a.b.c, the method a.b.c will be
    only looked up once and stored on cache (IC); if a.b.c is called the next time,
    it will be picked up from IC, and the JS engine will not parse the whole chain
    again. If there are any changes to the a.b.c chain, then the IC gets invalidated
    and a new dynamic lookup is performed the next time instead of being retrieved
    from the IC.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前面的实现是一把双刃剑。原因很简单。JavaScript引擎采用一种称为**内联缓存**（**IC**）的技术，这意味着JS引擎对某个方法的任何先前查找都将被缓存并在下次触发时重用；例如，如果我们有一个具有嵌套方法的对象a.b.c，方法a.b.c只会被查找一次并存储在缓存中（IC）；如果下次调用a.b.c，它将从IC中获取，并且JS引擎不会再次解析整个链。如果a.b.c链有任何更改，那么IC将被使无效，并且下次将执行新的动态查找，而不是从IC中检索。
- en: So, from our previous example, when we have `noOp` assigned to the `trackUserAnalytics()`
    method, the method path gets tracked and saved within IC, but it internally removes
    this function call as it is a call to an empty method. However, when it is applied
    to an actual function with some logic in it, IC points it directly to this new
    method. So, if we keep calling our `toggleUserAnalytics()` method multiple times,
    it keeps invalidating our IC, and our dynamic method lookup has to happen every
    time until the application state stabilizes (that is, `toggleUserAnalytics()`
    is no longer called).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从我们之前的例子中，当我们将`noOp`分配给`trackUserAnalytics()`方法时，该方法路径被跟踪并保存在IC中，但它在内部删除了这个函数调用，因为它是对一个空方法的调用。但是，当它应用于具有一些逻辑的实际函数时，IC直接指向这个新方法。因此，如果我们多次调用我们的`toggleUserAnalytics()`方法，它将不断使我们的IC失效，并且我们的动态方法查找必须每次发生，直到应用程序状态稳定下来（也就是说，不再调用`toggleUserAnalytics()`）。
- en: Image and font optimizations
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像和字体优化
- en: When it comes to image and font optimizations, there are no limits to the types
    and the scale of optimization that we can perform. However, we need to keep in
    mind our target audience, and we need to tailor our approach based on the problem
    at hand.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像和字体优化方面，我们可以进行各种类型和规模的优化。但是，我们需要牢记我们的目标受众，并根据手头的问题调整我们的方法。
- en: With both images and fonts, the first and foremost important thing is that we
    do not overserve, that is, we request and send only the data that is necessary
    by determining the dimensions of the device that our application is running on.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图像和字体，首要重要的是我们不要过度提供，也就是说，我们只请求和发送应用程序运行设备的尺寸所需的数据。
- en: The simplest way to do this is by adding a cookie for your device size and sending
    it to the server along with each of the request. Once the server receives the
    request for the image, it can then retrieve the image based on the dimension of
    the image that was sent to the cookie. Most of the time these images are something
    like a user avatar or a list of people who commented on a certain post. We can
    agree that the thumbnail images do not need to be of the same size as that of
    the profile page, and we can save some of the bandwidth while transmitting a smaller
    image based on the image.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是为设备大小添加一个cookie，并将其与每个请求一起发送到服务器。一旦服务器收到图像的请求，它可以根据发送到cookie的图像尺寸检索图像。大多数时候，这些图像是用户头像或评论某篇帖子的人员列表之类的东西。我们可以同意缩略图图像不需要与个人资料页面的大小相同，我们可以在传输基于图像的较小图像时节省一些带宽。
- en: Since screens these days have very high **Dots Per Inch** (**DPI**), the media
    that we serve to screens needs to be worthy of it. Otherwise, the application
    looks bad and the images look all pixelated. This can be avoided using Vector
    images or `SVGs`, which can be GZipped over the wire, thus reducing the payload
    size.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在的屏幕具有非常高的**每英寸点数**（**DPI**），我们为屏幕提供的媒体需要值得。否则，应用程序看起来很糟糕，图像看起来都是像素化的。这可以通过使用矢量图像或`SVGs`来避免，这些图像可以通过网络进行GZip压缩，从而减小负载大小。
- en: Another not so obvious optimization is changing the image compression type.
    Have you ever loaded a page in which the image loads from the top to bottom in
    small, incremental rectangles? By default, the images are compressed using a baseline
    technique, which is a default method of compressing the image from top to bottom.
    We can change this to be progressive compression using libraries such as `imagemin`.
    This would load the entire image first as blurred, then semi blurred, and so on
    until the entire image is uncompressed and displayed on the screen. Uncompressing
    a progressive JPEG might take a little longer than that of the baseline, so it
    is important to measure before making such optimizations.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不那么明显的优化是更改图像压缩类型。您是否曾经加载过一个页面，其中图像从顶部到底部以小的增量矩形加载？默认情况下，图像使用基线技术进行压缩，这是一种自上而下压缩图像的默认方法。我们可以使用诸如`imagemin`之类的库将其更改为渐进式压缩。这将首先以模糊的方式加载整个图像，然后是半模糊，依此类推，直到整个图像未经压缩地显示在屏幕上。解压渐进式JPEG可能需要比基线更长的时间，因此在进行此类优化之前进行测量非常重要。
- en: Another extension based on this concept is a Chrome-only format of an image
    called `WebP`. This is a highly effective way of serving images, which serves
    a lot of companies in production and saved almost 30% on bandwidth. Using `WebP`
    is almost as simple as the progressive compression as discussed previously. We
    can use the `imagemin-webp` node module, which can convert a JPEG image into a
    `webp` image, thus reducing the image size to a great extent.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一概念的另一个扩展是一种仅适用于Chrome的图像格式，称为`WebP`。这是一种非常有效的图像服务方式，在生产中为许多公司节省了近30%的带宽。使用`WebP`几乎和之前讨论的渐进式压缩一样简单。我们可以使用`imagemin-webp`节点模块，它可以将JPEG图像转换为`webp`图像，从而大大减小图像大小。
- en: Web fonts are a little different than that of images. Images get downloaded
    and rendered onto the UI on demand, that is, when the browser encounters the image
    either from the HTML 0r CSS files. However, the fonts, on the other hand, are
    a little different. The font files are only requested when the Render Tree is
    completely constructed. That means that the CSSOM and DOM have to be ready by
    the time request is dispatched for the fonts. Also, if the fonts files are being
    served from the server and not locally, then there are chances that we may see
    the text without the font applied first (or no text at all) and then we see the
    font applied, which may cause a flashing effect of the text.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Web字体与图像有些不同。图像会按需下载并呈现到UI上，也就是说，当浏览器从HTML或CSS文件中遇到图像时。然而，字体则有些不同。字体文件只有在渲染树完全构建时才会被请求。这意味着在发出字体请求时，CSSOM和DOM必须准备就绪。此外，如果字体文件是从服务器而不是本地提供的，那么我们可能会看到未应用字体的文本（或根本没有文本），然后我们看到应用了字体，这可能会导致文本的闪烁效果。
- en: 'There are multiple simple techniques to avoid this problem:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种简单的技术可以避免这个问题：
- en: 'Download, serve, and preload the font files locally:'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地下载、提供和预加载字体文件：
- en: '[PRE36]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Specify the unicode-range in the font-face so that browsers can adapt and improvise
    on the character set and glyphs that are actually expected by the browser:'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在字体中指定unicode范围，以便浏览器可以根据实际期望的字符集和字形进行适应和改进：
- en: '[PRE37]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'So far, we have seen that we can get the unstyled text to be loaded on to the
    UI and the get styled as we expected it to be; this can be changed using the font
    loading API, which allows us to load and render the font using JavaScript:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到我们可以将未经样式化的文本加载到UI上，并且按照我们期望的方式进行样式化；这可以通过使用字体加载API来改变，该API允许我们使用JavaScript加载和呈现字体：
- en: '[PRE38]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Garbage collection in JavaScript
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中的垃圾回收
- en: Let's take a quick look at what **garbage collection** (**GC**) is and how we
    can handle it in JavaScript. A lot of low-level languages provide explicit capabilities
    to developers to allocate and free memory in their code. However, unlike those
    languages, JavaScript automatically handles the memory management, which is both
    a good and bad thing. Good because we no longer have to worry about how much memory
    we need to allocate, when we need to do so, and how to free the assigned memory.
    The bad part about the whole process is that, to an uninformed developer, this
    can be a recipe for disaster and they can end up with an application that might
    hang and crash.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下**垃圾回收**（**GC**）是什么，以及我们如何在JavaScript中处理它。许多低级语言为开发人员提供了在其代码中分配和释放内存的显式能力。然而，与这些语言不同，JavaScript自动处理内存管理，这既是好事也是坏事。好处是我们不再需要担心需要分配多少内存，何时需要这样做，以及如何释放分配的内存。整个过程的坏处是，对于一个不了解的开发人员来说，这可能是一场灾难，他们可能最终得到一个可能会挂起和崩溃的应用程序。
- en: 'Luckily for us, understanding the process of GC is quite easy and can be very
    easily incorporated into our coding style to make sure that we are writing optimal
    code when it comes to memory management. Memory management has three very obvious
    steps:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，理解GC的过程非常容易，并且可以很容易地融入到我们的编码风格中，以确保在内存管理方面编写最佳代码。内存管理有三个非常明显的步骤：
- en: 'Assign the memory to variables:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将内存分配给变量：
- en: '[PRE39]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use the variables to read or write from the memory:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用变量从内存中读取或写入：
- en: '[PRE40]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Free the memory when it's no longer needed.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当不再需要时，释放内存。
- en: 'Now, this is the part that is not explicit. How does the browser know when
    we are done with the variable `a` and it is ready to be garbage collected? Let''s
    wrap this inside a function before we continue this discussion:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是不明显的部分。浏览器如何知道我们何时完成变量`a`并且它已准备好进行垃圾回收？在我们继续讨论之前，让我们将其包装在一个函数中：
- en: '[PRE41]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We have a very simple function, which just adds to our variable `a` and returns
    the result and finishes the execution. However, there is actually one more step,
    which will happen after the execution of this method called **mark and sweep **(not
    immediately after, sometimes this can also happen after a batch of operations is completed
    on the main thread**)**. When the browser performs mark and sweep, it's dependent
    on the total memory the application consumes and the speed at which the memory
    is being consumed.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个非常简单的函数，它只是将我们的变量`a`相加并返回结果，然后执行结束。然而，实际上还有一步，这将在这个方法执行后发生，称为**标记和清除**（不是立即发生，有时也会在主线程上完成一批操作后发生）。当浏览器执行标记和清除时，它取决于应用程序消耗的总内存和内存消耗的速度。
- en: Mark and sweep algorithm
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记和清除算法
- en: Since there is no accurate way to determine whether the data at a particular
    memory location is going to be used or not in the future, we will need to depend
    on alternatives which can help us make this decision. In JavaScript, we use the
    concept of a **reference** to determine whether a variable is still being used
    or not—if not, it can be garbage collected.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有准确的方法来确定特定内存位置的数据将来是否会被使用，我们将需要依赖于可以帮助我们做出这个决定的替代方法。在JavaScript中，我们使用**引用**的概念来确定变量是否仍在使用，如果不是，它可以被垃圾回收。
- en: 'The concept of mark and sweep is very straightforward: what all memory locations
    are reachable from all the known active memory locations? If something is not
    reachable, collect it, that is, free the memory. That''s it, but what are the
    known active memory locations? It still needs a starting point, right? In most
    of the browsers, the GC algorithm keeps a list of the `roots` from which the mark
    and sweep process can be started. All the `roots` and their children are marked
    as active, and any variable that can be reached from these `roots` are also marked
    as active. Anything that cannot be reached can be marked as unreachable and thus
    collected. In most of the cases, the `roots` consist of the window object.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 标记和清除的概念非常简单：从所有已知的活动内存位置到达哪些内存位置？如果有些地方无法到达，就收集它，也就是释放内存。就是这样，但是已知的活动内存位置是什么？它仍然需要一个起点，对吧？在大多数浏览器中，GC算法会保留一个`roots`列表，从这些`roots`开始标记和清除过程。所有`roots`及其子代都被标记为活动，可以从这些`roots`到达的任何变量也被标记为活动。任何无法到达的东西都可以标记为不可到达，因此可以被收集。在大多数情况下，`roots`包括window对象。
- en: 'So, we will go back to our previous example:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们将回到之前的例子：
- en: '[PRE42]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Our variable a is local to the `test()` method. As soon as the method is executed,
    there is no way to access that variable anymore, that is, no one holds any reference
    to that variable, and that is when it can be marked for garbage collection so
    that the next time GC runs, the `var a` will be swept and the memory allocated
    to it can be freed.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的变量a是局部的`test()`方法。一旦方法执行，就无法再访问该变量，也就是说，没有人持有该变量的引用，这时它可以被标记为垃圾回收，这样下次GC运行时，`var
    a`将被清除，分配给它的内存可以被释放。
- en: Garbage collection and V8
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收和V8
- en: When it comes to V8, the process of garbage collection is extremely complex
    (as it should be). So, let's briefly discuss how V8 handles it.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在V8中，垃圾回收的过程非常复杂（应该是这样）。因此，让我们简要讨论一下V8是如何处理的。
- en: In V8, the memory (heap) is divided into two main generations, which are the
    **new-space** and **old-space**. Both new-space and old-space are assigned some
    memory (between *1 MB* and *20 MB*). Most of the programs and their variables
    when created are assigned within the new-space. As and when we create a new variable
    or perform an operation, which consumes memory, it is by default assigned from
    the new-space, which is optimized for memory allocation. Once the total memory
    allocated to the new-space is almost completely consumed, the browser triggers
    a **Minor GC**, which basically removes the variables that are no longer being
    referenced and marks the variables that are still being referenced and cannot
    be removed yet. Once a variable survives two or more **Minor GC**s, then it becomes
    a candidate for old-space where the GC cycle is not run as frequently as that
    of the new-space. A Major GC is triggered when the old-space is of a certain size,
    all of this is driven by the heuristics of the application, which is very important
    to the whole process. So, well-written programs move fewer objects into the old-space
    and thus have less Major GC events being triggered.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在V8中，内存（堆）分为两个主要代，即**新生代**和**老生代**。新生代和老生代都分配了一些内存（在*1MB*和*20MB*之间）。大多数程序和它们的变量在创建时都分配在新生代中。每当我们创建一个新变量或执行一个消耗内存的操作时，默认情况下会从新生代分配内存，这对内存分配进行了优化。一旦分配给新生代的总内存几乎被完全消耗，浏览器就会触发一个**Minor
    GC**，它基本上会删除不再被引用的变量，并标记仍然被引用且暂时不能被删除的变量。一旦一个变量经历了两次或更多次**Minor GC**，那么它就成为了老生代的候选对象，老生代的GC周期不像新生代那样频繁。当老生代达到一定大小时，会触发一个Major
    GC，所有这些都由应用程序的启发式驱动，这对整个过程非常重要。因此，编写良好的程序会将更少的对象移动到老生代，从而触发更少的Major GC事件。
- en: Needless to say that this is a very high-level overview of what V8 does for
    garbage collection, and since this process keeps changing over time, we will switch
    gears and move on to the next topic.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 毋庸置疑，这只是对V8垃圾回收的一个非常高层次的概述，由于这个过程随着时间的推移不断变化，我们将转变方向，继续下一个主题。
- en: Avoiding memory leaks
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免内存泄漏
- en: Well, now that we know on a high level what garbage collection is in JavaScript
    and how it works, let's take a look at some common pitfalls which prevent us from
    getting our variables marked for GC by the browser.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经大致了解了JavaScript中垃圾回收的工作原理，让我们来看一些常见的陷阱，这些陷阱会阻止浏览器标记我们的变量进行垃圾回收。
- en: Assigning variables to global scope
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将变量分配给全局范围
- en: This should be pretty obvious by now; we discussed how the GC mechanism determines
    a root (which is the window object) and treats everything on the root and its
    children as active and never marks them for garbage collection.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这应该是显而易见的了；我们讨论了GC机制如何确定根（即window对象）并将根及其子对象视为活动对象，永远不会标记它们进行垃圾回收。
- en: 'So, the next time you forget to add a `var` to your variable declarations,
    remember that the global variable that you are creating will live forever and
    never get garbage collected:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，下次当你忘记在变量声明中添加`var`时，请记住你创建的全局变量将永远存在，永远不会被垃圾回收：
- en: '[PRE43]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Removing DOM elements and references
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除DOM元素和引用
- en: 'It''s imperative that we keep our DOM references to a minimum, so a well-known
    step that we like to perform is caching the DOM elements in our JavaScript so
    that we do not have to query any of the DOM elements over and over. However, once
    the DOM elements are removed, we will need to make sure that these methods are
    removed from our cache as well, otherwise, they will never get GC''d:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是，我们要尽量减少对DOM的引用，因此我们喜欢执行的一个众所周知的步骤是在我们的JavaScript中缓存DOM元素，这样我们就不必一遍又一遍地查询任何DOM元素。然而，一旦DOM元素被移除，我们需要确保这些方法也从我们的缓存中移除，否则它们永远不会被GC回收：
- en: '[PRE44]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The code shown previously removes the `row` from the DOM but the variable cache
    still refers to the DOM element, hence preventing it from being garbage collected.
    Another interesting thing to note here is that even when we remove the table that
    was containing the `row`, the entire table would remain in the memory and not
    get GC'd because the row, which is in cache internally refers to the table.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 先前显示的代码从DOM中删除了`row`，但变量cache仍然引用DOM元素，因此阻止它被垃圾回收。这里还有一件有趣的事情需要注意，即使我们删除了包含`row`的表，整个表仍将保留在内存中，并且不会被GC回收，因为在内部引用表的cache中的`row`仍然指向表。
- en: Closures edge case
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包边缘情况
- en: 'Closures are amazing; they help us deal with a lot of problematic scenarios
    and also provide us with ways in which we can simulate the concept of private
    variables. Well, all that is good, but sometimes we tend to overlook the potential
    downsides that are associated with the closures. Here is what we do know and use:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包很棒；它们帮助我们处理很多棘手的情况，还为我们提供了模拟私有变量概念的方法。好吧，这一切都很好，但有时我们倾向于忽视与闭包相关的潜在缺点。这就是我们所知道和使用的。
- en: '[PRE45]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When we run this script in the browser and then profile it, we see as expected
    that the method consumes a constant amount of memory and then is GC''d and restored
    to the baseline memory consumed by the script:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中运行这个脚本，然后对其进行分析，我们会看到预期的结果，即该方法消耗了恒定的内存量，然后被GC回收，并恢复到脚本消耗的基线内存：
- en: '![](assets/ff54858d-f532-4323-85de-f1c5c9b62ee8.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ff54858d-f532-4323-85de-f1c5c9b62ee8.png)'
- en: 'Now, let''s zoom into one of these spikes and take a look at the call tree
    to determine what all events are bring triggered around the time of the spikes:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们放大到其中一个峰值，并查看调用树，以确定在峰值时触发了哪些事件：
- en: '![](assets/6de48c89-3b37-43ef-834c-80fd809b704c.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6de48c89-3b37-43ef-834c-80fd809b704c.png)'
- en: We can see that everything happens as per our expectation here; first, our `setInterval()`
    is triggered, which calls `myGoodFunc()`, and once the execution is done, there
    is a GC, which collects the data and hence the spike, as we can see from the preceding
    screenshots.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一切都按照我们的预期发生；首先，我们的`setInterval()`被触发，调用`myGoodFunc()`，一旦执行完成，就会有一个GC，它收集数据，因此会有一个峰值，正如我们从前面的截图中所看到的。
- en: 'Now, this was the expected flow or the happy path when dealing with closures.
    However, sometimes our code is not as simple and we end up performing multiple
    things within one closure, and sometimes even end up nesting closures:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是处理闭包时预期的流程或正常路径。然而，有时我们的代码并不那么简单，我们最终会在一个闭包中执行多个操作，有时甚至会嵌套闭包：
- en: '[PRE46]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can note in the preceding code that we extended our method to contain two
    closures now: `closure1` and `closure2`. Although `closure1` still performs the
    same operation as before, `closure2` will run forever because we have it running
    at 1/10th of the frequency of the parent function. Also, since both the closure
    methods share the parent closure scope, in this case the variable a, it will never
    get GC''d and thus cause a huge memory leak, which can be seen from the profile
    as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到在前面的代码中，我们扩展了我们的方法以包含两个闭包：`closure1`和`closure2`。尽管`closure1`仍然执行与以前相同的操作，但`closure2`将永远运行，因为我们将其运行频率设置为父函数的1/10。此外，由于两个闭包方法共享父闭包作用域，在这种情况下变量a，它永远不会被GC回收，从而导致巨大的内存泄漏，可以从以下的分析中看到：
- en: '![](assets/81fb9ed7-2efd-4b8c-ba7e-d6da22d66fc4.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/81fb9ed7-2efd-4b8c-ba7e-d6da22d66fc4.png)'
- en: 'On a closer look, we can see that the GC is being triggered but because of
    the frequency at which the methods are being called, the memory is slowly leaking
    (lesser memory is collected than being created):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，我们可以看到GC正在被触发，但由于方法被调用的频率，内存正在慢慢泄漏（收集的内存少于创建的内存）：
- en: '![](assets/34a5a920-3ea6-4e32-bab8-ab8fb0c6fc57.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/34a5a920-3ea6-4e32-bab8-ab8fb0c6fc57.png)'
- en: Well, that was an extreme edge case, right? It's way more theoretical than practical—why
    would anyone have two nested `setInterval()` methods with closures. Let's take
    a look at another example in which we no longer nest multiple `setInterval()`,
    but it is driven by the same logic.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这是一个极端的边缘情况，对吧？这比实际更理论化——为什么会有人有两个嵌套的`setInterval()`方法和闭包。让我们看看另一个例子，其中我们不再嵌套多个`setInterval()`，但它是由相同的逻辑驱动的。
- en: 'Let''s assume that we have a method that creates closures:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个创建闭包的方法：
- en: '[PRE47]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A simple fix to solve this problem is obvious, as we have said ourselves that
    the previous value of the object `something` doesn''t get garbage collected as
    it refers to the `previousValue` from the previous iteration. So, the solution
    to this would be to clear out the value of the `previousValue` at the end of each
    iteration, thus leaving nothing for `something` to refer once it is unloaded,
    hence the memory profiling can be seen to change:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个简单方法是显而易见的，因为我们自己已经说过，对象 `something` 的先前值不会被垃圾回收，因为它引用了上一次迭代的 `previousValue`。因此，解决这个问题的方法是在每次迭代结束时清除
    `previousValue` 的值，这样在卸载时 `something` 就没有任何东西可引用，因此可以看到内存分析的变化：
- en: '![](assets/8c92b433-689b-4d11-b436-c1c08ad66748.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8c92b433-689b-4d11-b436-c1c08ad66748.png)'
- en: 'The preceding image changes as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图片变化如下：
- en: '![](assets/603b37ed-b4ce-4155-9da2-be22cc8452a9.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/603b37ed-b4ce-4155-9da2-be22cc8452a9.png)'
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored ways in which the code performance can be improved
    by making optimizations to HTML, CSS, and JavaScript that we write for our applications.
    It is very important to understand that these are something that may, or may not,
    benefit you, based on the application that you are trying to build. The main takeaway
    from this chapter should be the ability to open up the browser's insides and not
    be scared to dissect and take a look at how the browsers handle our code. Also,
    be wary that the ECMA specification guide keeps changing, but it takes time for
    the browsers to catch up with the changes. Also, last but not the least, never
    over-optimize or optimize too early. If you run into issues, then measure first
    and then decide what the bottlenecks are before coming up with a plan for optimization.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了通过对我们为应用程序编写的 HTML、CSS 和 JavaScript 进行优化来改善代码性能的方法。非常重要的是要理解，这些优化可能对你有益，也可能没有，这取决于你尝试构建的应用程序。本章的主要收获应该是能够打开浏览器的内部，并且不害怕解剖和查看浏览器如何处理我们的代码。此外，要注意
    ECMA 规范指南不断变化，但浏览器需要时间来跟上这些变化。最后但同样重要的是，不要过度优化或过早优化。如果遇到问题，首先进行测量，然后再决定瓶颈在哪里，然后再制定优化计划。
- en: What's next?
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: 'With this, we conclude the book. We hope that you had a great learning experience
    and that you benefit from these techniques on a day-to-day basis. JavaScript,
    being the way it is, is ever growing. Things are changing at a rapid pace, and
    it gets tough to keep track of things. Here are some suggestions, which you can
    explore and modify as you try them out:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这一点，我们结束了这本书。我们希望你有一个很棒的学习经验，并且能够从这些技术中受益。JavaScript，就像它现在的样子，一直在不断发展。事情正在以快速的速度发生变化，跟上这些变化变得很困难。以下是一些建议，你可以尝试并修改：
- en: Identify your area of interests. By now, you know that JavaScript exists (and
    rocks) in a lot of things beyond the browser. Are you more of a UI person? Do
    you love APIs and scalable microservice? Do you dig building sensors which count
    how many coffees you consume every day? Find your passion and apply your newly
    learned JavaScript concepts there. The concepts are same, the applications are
    different.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定你感兴趣的领域。到现在为止，你已经知道 JavaScript 存在（并且在浏览器之外的很多东西中都很棒）。你更喜欢用户界面吗？你喜欢 API 和可扩展的微服务吗？你喜欢构建传感器来计算你每天消耗了多少咖啡吗？找到你的热情所在，并将你新学到的
    JavaScript 概念应用到那里。概念是相同的，应用是不同的。
- en: Subscribe to newsletters and mailing lists from areas of interests. You will
    be amazed by the amount of information you get from each of these emails on a
    daily or weekly basis. It helps you to keep on your toes, and you can stay up
    to date on the latest technologies.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅来自你感兴趣领域的新闻简报和邮件列表。你会惊讶于每封邮件每天或每周都能获取到的信息量。这有助于你保持警惕，你可以及时了解最新的技术。
- en: Write a blog (or even a StackOverflow answer) for what you know and learn. It
    always helps when you write down what you learn. Someday, you can even use that
    for your own reference.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一篇博客（甚至是 StackOverflow 的回答）来分享你所知道和学到的东西。当你把学到的东西写下来时，总是会有帮助的。有一天，你甚至可以用它来作为自己的参考。
