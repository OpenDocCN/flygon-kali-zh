- en: Streams and Pipelines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流和管道
- en: 'In Java 8 and 9, the collections API got a major facelift with the introduction
    of streams and internal iteration by leveraging lambda expressions. In Java 10
    (JDK 18.3), new methods—`List.copyOf`, `Set.copyOf`, and `Map.copyOf`—were added
    that allow us to create a new immutable collection from existing instances. Also,
    new methods—  `toUnmodifiableList`, `toUnmodifiableSet`, and `toUnmodifiableMap`—were
    added to the `Collectors` class in the `java.util.stream` package, allowing the
    elements of `Stream` to be collected into an immutable collection. This chapter
    shows you how to use the streams and chain multiple operations to create a pipeline.
    Also, the reader will learn how these operations can be done in parallel. The
    list of recipes includes the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8和9中，通过引入流和利用lambda表达式进行内部迭代，集合API得到了重大改进。在Java 10（JDK 18.3）中，添加了新方法`List.copyOf`、`Set.copyOf`和`Map.copyOf`，允许我们从现有实例创建新的不可变集合。此外，在`java.util.stream`包的`Collectors`类中添加了新方法`toUnmodifiableList`、`toUnmodifiableSet`和`toUnmodifiableMap`，允许将`Stream`的元素收集到不可变集合中。本章将向您展示如何使用流并链接多个操作来创建管道。此外，读者将学习如何并行进行这些操作。示例包括以下内容：
- en: Create immutable collections using the `of()` and `copyOf()` factory methods
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`of()`和`copyOf()`工厂方法创建不可变集合
- en: Create and operating on streams
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和操作流
- en: Use numeric streams for arithmetic operations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数字流进行算术运算
- en: Complete streams by producing collections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过生成集合来完成流
- en: Complete streams by producing maps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过生成映射来完成流
- en: Complete streams by grouping stream elements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过对流元素进行分组来完成流
- en: Create a stream operation pipeline
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建流操作管道
- en: Processing a stream in parallel
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行处理流
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Lambda expressions described and demonstrated in the previous chapter were introduced
    in Java 8\. Together with functional interfaces, they added the functional programming
    capability to Java, allowing the passing of behavior (functions) as parameters
    to the libraries optimized for the performance of data processing. This way, an
    application programmer can concentrate on the business aspects of the developed
    system, leaving performance aspects to the specialists—the authors of the library.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中引入的lambda表达式在上一章中有所描述和演示。它们与函数接口一起，为Java增加了函数式编程能力，允许将行为（函数）作为参数传递给专为数据处理性能优化的库。这样，应用程序员可以专注于开发系统的业务方面，将性能方面留给专家-库的作者。
- en: One example of such a library is the `java.util.stream` package, which is going
    to be the focus of this chapter. This package allows you to have a declarative
    presentation of the procedures that can be subsequently applied to the data, also
    in parallel; these procedures are presented as streams, which are objects of the `Stream` interface. For
    a better transition from the traditional collections to streams, two default methods
    (`stream()` and `parallelStream()`) were added to the `java.util.Collection` interface,
    along with the addition of new factory methods of the stream generation to the `Stream` interface.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的库的一个例子是`java.util.stream`包，它将成为本章的重点。该包允许您以声明性的方式呈现随后可以应用于数据的过程，也可以并行进行；这些过程被呈现为流，是`Stream`接口的对象。为了更好地从传统集合过渡到流，`java.util.Collection`接口添加了两个默认方法（`stream()`和`parallelStream()`），并向`Stream`接口添加了新的流生成工厂方法。
- en: This approach takes advantage of the power of aggregation, as discussed in [Chapter
    2](db468cc9-60fa-4966-890a-872bef36ff01.xhtml), *Fast Track to OOP - Classes and
    Interfaces*. Together with other design principles—encapsulation, interface, and
    polymorphism—it facilitates a highly extensible and flexible design, while lambda
    expressions allow you to implement it in a concise and succinct manner.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法利用了聚合的强大功能，如[第2章](db468cc9-60fa-4966-890a-872bef36ff01.xhtml)中所讨论的那样，*OOP快速通道-类和接口*。结合其他设计原则-封装、接口和多态性-它促进了高度可扩展和灵活的设计，而lambda表达式允许您以简洁和简洁的方式实现它。
- en: Today, when the machine learning requirements of massive data processing and
    the fine-tuning of operations have become ubiquitous, these new features reinforce
    the position of Java among a few modern programming languages of choice.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，随着机器学习对大规模数据处理和操作的需求变得普遍，这些新功能加强了Java在少数现代编程语言中的地位。
- en: Creating immutable collections using the of() and copyOf() factory methods
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`of()`和`copyOf()`工厂方法创建不可变集合
- en: In this recipe, we will revisit traditional methods of creating collections
    and compare them with the `List.of()`, `Set.of()`, `Map.of()`, and `Map.ofEntries()` factory
    methods that came with Java 9, and the `List.copyOf()`, `Set.copyOf()`, and `Map.copyOf()` methods
    that came with Java 10.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将重新审视创建集合的传统方法，并将它们与Java 9中引入的`List.of()`、`Set.of()`、`Map.of()`和`Map.ofEntries()`工厂方法，以及Java
    10中引入的`List.copyOf()`、`Set.copyOf()`和`Map.copyOf()`方法进行比较。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before Java 9, there were several ways to create collections. Here is the most
    popular way that was used to create a `List`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9之前，有几种创建集合的方式。以下是创建`List`最流行的方式：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we run the preceding code, we get this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述代码，将得到以下结果：
- en: '![](img/97a3612f-48c9-423e-9155-16cc369dc50d.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97a3612f-48c9-423e-9155-16cc369dc50d.png)'
- en: 'The shorter way of creating the `List` collection is by starting with an array:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`List`集合的更简洁方式是通过使用数组开始：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/378ce09a-1858-4ddb-9424-44f2f1179348.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/378ce09a-1858-4ddb-9424-44f2f1179348.png)'
- en: 'The `Set` collection used to be created similarly:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Set`集合的方式类似：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, we can build `Set` by starting with an array:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过使用数组来构建`Set`：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here''s an illustration of the results of the last two examples:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最后两个示例的结果的示例：
- en: '![](img/0e8f0748-76b5-43bf-ab84-a53ada4ad9bc.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e8f0748-76b5-43bf-ab84-a53ada4ad9bc.png)'
- en: Notice that, unlike `List`, the order of elements in `Set` is not preserved.
    It depends on the hash code implementation and can change from computer to computer.
    But the order remains the same between the runs on the same computer. Please take
    note of this last fact, because we will come back to it later.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与`List`不同，`Set`中元素的顺序不是固定的。它取决于哈希码的实现，并且可能因计算机而异。但是在同一台计算机上的多次运行中，顺序保持不变。请注意这一点，因为我们稍后会回到这个问题。
- en: 'And this is how we used to create `Map` before Java 9:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Java 9之前创建`Map`的方法：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '![](img/069d62ab-e65a-4550-a366-cafb7e8d7fbf.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/069d62ab-e65a-4550-a366-cafb7e8d7fbf.png)'
- en: Although the preceding output preserves the order of the elements, it is not
    guaranteed for `Map` since it is based on the keys that are collected in `Set`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的输出保留了元素的顺序，但对于`Map`来说并不是保证的，因为它是基于在`Set`中收集的键。
- en: Those who had to create collections that way often appreciated the JDK enhancement-Proposal
    269 *Convenience Factory Methods for Collections* (JEP 269) that stated,
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 那些经常以这种方式创建集合的人赞赏JDK增强提案269 *集合的便利工厂方法*（JEP 269）的声明，
- en: '"*Java is often criticized for its verbosity*" and its goal was to "*Provide
    static factory methods on the collection interfaces that will create compact,
    unmodifiable collection instances*."'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '"*Java经常因其冗长而受到批评*"，它的目标是"*在集合接口上提供静态工厂方法，用于创建紧凑的、不可修改的集合实例*。"'
- en: 'In response to the criticism and the proposal, Java 9 introduced 12 `of()` static
    factory methods for each of the 3 interfaces—`List`, `Set`, and `Map`. The following
    are the factory methods of `List`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对批评和提案的回应，Java 9为3个接口——`List`、`Set`和`Map`引入了12个`of()`静态工厂方法。以下是`List`的工厂方法：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 10 overloaded factory methods with a fixed number of elements are optimized
    for performance, and as stated in JEP 269 ([http://openjdk.java.net/jeps/269](http://openjdk.java.net/jeps/269)),
    these methods
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 具有固定数量元素的10个重载工厂方法被优化为性能，并且正如JEP 269所述（[http://openjdk.java.net/jeps/269](http://openjdk.java.net/jeps/269)），这些方法
- en: '"*avoid array allocation, initialization, and garbage collection overhead that
    is incurred by* *varargs calls.**"*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '"*避免了由* *varargs调用引起的数组分配、初始化和垃圾回收开销。**"*'
- en: 'Using the `of()` factory methods makes the code much more compact:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`of()`工厂方法使代码更加紧凑：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `System.out.println()` statement was added to inject a line break between
    the results:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.println()`语句被添加以在结果之间插入换行：'
- en: '![](img/d60ff266-9bf0-4ad4-bcc0-dba9c10badb5.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d60ff266-9bf0-4ad4-bcc0-dba9c10badb5.png)'
- en: 'One of the 12 static factory methods in the `Map` interface is different from
    the other `of()` methods:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`接口中的12个静态工厂方法之一与其他`of()`方法不同：'
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is an example of its usage:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是其用法示例：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It produces the following output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它产生了以下输出：
- en: '![](img/5541fd5e-21ac-4d8c-97fb-9a1d9bcdc4d1.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5541fd5e-21ac-4d8c-97fb-9a1d9bcdc4d1.png)'
- en: And there is no `Map.of()` factory method for an unlimited number of elements.
    One has to use `Map.ofEntries()` when creating a map with more than 10 elements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 并且没有`Map.of()`工厂方法用于无限数量的元素。当创建一个包含超过10个元素的映射时，必须使用`Map.ofEntries()`。
- en: In Java 10, the `List.copyOf()`, `Set.copyOf()`, and `Map.copyOf()` methods
    were introduced. They allow us to convert any collection into an immutable collection
    of the corresponding type.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 10中，引入了`List.copyOf()`、`Set.copyOf()`和`Map.copyOf()`方法。它们允许我们将任何集合转换为相应类型的不可变集合。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: As we have mentioned already, the `Set.of()`, `Map.of()`, and `Map.ofEntries()`
    methods do not preserve the order of the collection elements. This is different
    from the previous (before Java 9) instances of the `Set` and `Map` behavior of
    preserving the same order while running on the same computer. The `Set.of()`, `Map.of()`,
    and `Map.ofEntries()` methods change the elements' order between runs even on
    the same computer. The order remains the same only during the same run, no matter
    how many times the collection is iterated. Changing the elements' order from one
    run to another on the same computer helps programmers avoid the unwarranted reliance
    on a certain order.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，`Set.of()`、`Map.of()`和`Map.ofEntries()`方法不保留集合元素的顺序。这与之前（Java 9之前）的`Set`和`Map`实例在同一台计算机上运行时保持相同顺序的行为不同。`Set.of()`、`Map.of()`和`Map.ofEntries()`方法会在同一台计算机上的多次运行中改变元素的顺序。顺序只在同一次运行中保持不变，无论集合被迭代多少次。在同一台计算机上从一次运行到另一次运行改变元素的顺序有助于程序员避免对特定顺序的不必要依赖。
- en: 'Another feature of the collections generated by the `of()` static method of
    the `List`, `Set`, and `Map` interfaces is their immutability. What does this
    mean? Consider the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`、`Set`和`Map`接口的`of()`静态方法生成的集合的另一个特性是它们是不可变的。这是什么意思？考虑以下代码：'
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, any attempt to add a new element or modify an existing element
    of a collection created using the `List.of()` method results in a `java.lang.UnsupportedOperationException` runtime
    exception.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，任何尝试向使用`List.of()`方法创建的集合中添加新元素或修改现有元素都会导致`java.lang.UnsupportedOperationException`运行时异常。
- en: 'In addition, the `List.of()` method does not accept a `null` element, so the
    following code throws a `java.lang.NullPointerException` runtime exception:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`List.of()`方法不接受`null`元素，因此以下代码会抛出`java.lang.NullPointerException`运行时异常：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The collections created by `Set.of()` and  `Map.of()` have the same behavior
    as the method `List.of()` described earlier:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set.of()`和`Map.of()`创建的集合与前面描述的`List.of()`方法的行为相同：'
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `List.copyOf()`, `Set.copyOf()`, and `Map.copyOf()` methods provide another
    way to create an immutable collection based on another collection:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`List.copyOf()`、`Set.copyOf()`和`Map.copyOf()`方法提供了另一种基于另一个集合创建不可变集合的方法：'
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice that the input parameter can be any collection that has elements of
    the same type or the type that extends the type of the elements of the passed-in
    collection:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输入参数可以是任何具有相同类型元素或扩展传入集合元素类型的类型的集合：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There's more...
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is not an accident that non-null values and immutability were enforced soon
    after lambda expressions and streams were introduced. As you will see in subsequent
    recipes, functional programming and stream pipelines encourage a fluent style
    of coding (using method chaining, as well as using the `forEach()` method in the
    examples of this recipe). Fluent style provides more compact and readable code.
    Removing the need for the check for the `null` value helps to keep it this way—compact
    and focused on the main processing procedures.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda表达式和流引入后不久，非空值和不可变性被强制执行并非偶然。正如您将在后续的示例中看到的，函数式编程和流管道鼓励一种流畅的编码风格（使用方法链式编程，以及在本示例中使用`forEach()`方法）。流畅的风格提供了更紧凑和可读的代码。消除了对`null`值的检查有助于保持这种方式——紧凑且专注于主要的处理过程。
- en: 'The immutability feature, in turn, aligns well with the *effectively final*
    concept for the variables used by lambda expressions. For example, a mutable collection
    allows us to work around this limitation:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性特性与lambda表达式使用的变量的*effectively final*概念相吻合。例如，可变集合允许我们绕过这个限制：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, the lambda expression used by the second `forEach()`
    operation maintains state in the third (with index 2) element of the original
    list. It makes it possible—intentionally or not—to introduce a state in a lambda
    expression and cause different outcomes of the same function in different contexts.
    This is especially dangerous in parallel processing because one cannot predict
    the state of each possible context. This is why immutability of a collection is
    a helpful addition that makes the code more robust and reliable.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，第二个`forEach()`操作使用的lambda表达式在原始列表的第三个（索引为2）元素中保持状态。这可能会有意或无意地在lambda表达式中引入状态，并导致在不同上下文中同一函数的不同结果。这在并行处理中尤其危险，因为无法预测每个可能上下文的状态。这就是为什么集合的不可变性是一个有用的补充，使代码更健壮和可靠。
- en: Creating and operating on streams
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和操作流
- en: In this recipe, we will describe how streams can be created and how the operations
    can be applied to the elements emitted by the streams. The discussion and examples
    are applicable for a stream of any type, including the specialized numeric streams:  `IntStream`, `LongStream`,
    and `DoubleStream`. The behavior specific to the numeric streams is not presented
    because it is described in the next recipe, *Using numeric streams for arithmetic
    operations*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将描述如何创建流以及如何对流发出的元素应用操作。讨论和示例适用于任何类型的流，包括专门的数值流：`IntStream`、`LongStream`和`DoubleStream`。数值流特有的行为没有呈现，因为它在下一个示例中描述，即*使用数值流进行算术操作*。
- en: Getting ready
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'There are many ways to create a stream:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多创建流的方法：
- en: The `stream()` and `parallelStream()` methods of the `java.util.Collection` 
    interface—this means that all the sub-interfaces, including `Set` and `List`,
    have these methods too
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream()`和`parallelStream()`方法属于`java.util.Collection`接口——这意味着所有的子接口，包括`Set`和`List`，也有这些方法'
- en: Two overloaded `stream()` methods of the `java.util.Arrays` class, which convert
    arrays and subarrays to streams
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Arrays`类的两个重载的`stream()`方法，将数组和子数组转换为流'
- en: The `of()`, `generate()`, and `iterate()` methods of the `java.util.stream.Stream` interface
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.stream.Stream`接口的`of()`、`generate()`和`iterate()`方法'
- en: The `Stream<Path> list()`, `Stream<String> lines()`, and `Stream<Path> find()` methods
    of the `java.nio.file.Files` class
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.nio.file.Files`类的`Stream<Path> list()`、`Stream<String> lines()`和`Stream<Path>
    find()`方法'
- en: The `Stream<String> lines()` method of the `java.io.BufferedReader` class
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.io.BufferedReader`类的`Stream<String> lines()`方法'
- en: 'After a stream is created, various methods (called operations) can be applied
    to its elements. A stream itself does not store data. Instead, it acquires data
    from the source (and provides or emits it to the operations) as needed. The operations
    can form a pipeline using the fluent style since many intermediate operations
    can return a stream too. Such operations are called *intermediate* operations.
    Examples of intermediate operations include the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建流后，可以对其元素应用各种方法（称为操作）。流本身不存储数据。相反，它根据需要从源获取数据（并将其提供或发出给操作）。操作可以使用流畅的风格形成管道，因为许多中间操作也可以返回流。这些操作称为*中间*操作。中间操作的示例包括以下内容：
- en: '`map()`: Transforms elements according to a function'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()`: 根据函数转换元素'
- en: '`flatMap()`: Transforms each element into a stream according to a function'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMap()`: 根据函数将每个元素转换为流'
- en: '`filter()`: Selects only elements matching a criterion'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter()`: 选择符合条件的元素'
- en: '`limit()`: Limits a stream to the specified number of elements'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit()`: 将流限制为指定数量的元素'
- en: '`sorted()`: Transforms an unsorted stream into a sorted one'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sorted()`: 将无序流转换为有序流'
- en: '`distinct()`: Removes duplicates'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinct()`: 移除重复项'
- en: Other methods of the `Stream` interface that return `Stream` too
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream`接口的其他返回`Stream`的方法'
- en: 'The pipeline ends with a **terminal operation**. The processing of the stream
    elements actually begins only when a terminal operation is being executed. Then,
    all the intermediate operations (if present) start processing and the stream closes
    and cannot be reopened until the terminal operation is finished with the execution.
    Examples of terminal operations are:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 管道以**终端操作**结束。实际上，只有在执行终端操作时，流元素的处理才会开始。然后，所有中间操作（如果存在）开始处理，流关闭并且在终端操作完成执行之前不能重新打开。终端操作的示例包括：
- en: '`forEach()`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach()`'
- en: '`findFirst()`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findFirst()`'
- en: '`reduce()`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce()`'
- en: '`collect()`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collect()`'
- en: Other methods of the `Stream` interface that do not return `Stream`
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream`接口的其他不返回`Stream`的方法'
- en: Terminal operations return a result or produce a side effect, but they do not
    return the `Stream` object.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 终端操作返回结果或产生副作用，但它们不返回`Stream`对象。
- en: All the `Stream` operations support parallel processing, which is especially
    helpful in the case of a large amount of data processed on a multicore computer. All
    the Java Stream API interfaces and classes are in the `java.util.stream` package.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`Stream`操作都支持并行处理，在多核计算机上处理大量数据时尤其有帮助。所有Java Stream API接口和类都在`java.util.stream`包中。
- en: In this recipe, we are going to demonstrate sequential streams. Parallel-streams
    processing is not much different. One just has to watch that the processing pipeline
    does not use a context state that can vary across different processing environments. We
    will discuss parallel processing in another recipe later in this chapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将演示顺序流。并行流处理并没有太大的不同。只需注意处理管道不使用在不同处理环境中可能变化的上下文状态。我们将在本章后面的另一个示例中讨论并行处理。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'In this section of the recipe, we will present methods to create a stream.
    Each class that implements the `Set` interface or the `List` interface has the `stream()` method
    and the `parallelStream()` method, which returns an instance of the `Stream` interface:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍创建流的方法。实现`Set`接口或`List`接口的每个类都有`stream()`方法和`parallelStream()`方法，它们返回`Stream`接口的实例：
- en: 'Consider the following examples of stream creation:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下流创建的示例：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We used the fluent style to make the code more compact and interjected `System.out.println()`
    in order to start a new line in the output.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了流畅的风格使代码更加简洁，并插入了`System.out.println()`以便在输出中开始新的一行。
- en: 'Run the preceding example and you should see the following result:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行上述示例，你应该会看到以下结果：
- en: '![](img/936e8f84-eacb-4d72-b5bc-04e165a78f25.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/936e8f84-eacb-4d72-b5bc-04e165a78f25.png)'
- en: Notice that, `List` preserves the order of the elements, while the order of
    the `Set` elements changes at every run. The latter helps to uncover the defects
    based on the reliance on a certain order when the order is not guaranteed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`List`保留了元素的顺序，而`Set`元素的顺序在每次运行时都会改变。后者有助于发现基于对特定顺序的依赖而未能保证顺序时的缺陷。
- en: 'Look at the Javadoc of the `Arrays` class. It has two `stream()` overloaded
    static methods:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看`Arrays`类的Javadoc。它有两个重载的静态`stream()`方法：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Write an example of the usage of the last two methods:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写出最后两种方法的用法示例：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run it and see the result:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行它并查看结果：
- en: '![](img/3c9d5ca8-f851-446c-a7e2-8f4eb2260372.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c9d5ca8-f851-446c-a7e2-8f4eb2260372.png)'
- en: Notice that in the second example, only the first two elements—with indexes
    `0` and `1`—were selected to be included in the stream, as it was intended.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，注意只有第一个和第二个元素，即索引为`0`和`1`的元素被选中并包含在流中，这正是预期的结果。
- en: 'Open the Javadoc of the `Stream` interface and see the `of()`, `generate()`,
    and `iterate()` static factory methods:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Stream`接口的Javadoc并查看`of()`、`generate()`和`iterate()`静态工厂方法：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first two methods are simple, so we skip their demo and start with the third
    method,  `of()`. It can accept either an array or comma-delimited elements.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种方法很简单，所以我们跳过它们的演示，直接从第三种方法`of()`开始。它可以接受数组或逗号分隔的元素。
- en: 'Write the example as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将示例写成如下形式：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run it and observe the output:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行它并观察输出：
- en: '![](img/89515668-5eb9-44d4-a2be-a3abf325b39c.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89515668-5eb9-44d4-a2be-a3abf325b39c.png)'
- en: 'Write the examples of the usage of the `generate()` and `iterate()` methods
    as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式写出`generate()`和`iterate()`方法的用法示例：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We had to put a limit on the size of the streams generated by the first two
    examples. Otherwise, they would be infinite. The third example accepts a predicate
    that provides the criterion for when the iteration has to stop.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须对前两个示例生成的流的大小进行限制，否则它们将是无限的。第三个示例接受一个提供迭代何时停止的条件的谓词。
- en: 'Run the examples and observe the results:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例并观察结果：
- en: '![](img/64c9332d-924f-46c9-a8f6-ff57b57517c9.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64c9332d-924f-46c9-a8f6-ff57b57517c9.png)'
- en: 'Let''s look at the example of the `Files.list(Path dir)` method, which returns
    `Stream<Path>` of all the entries of the directory:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看一下`Files.list(Path dir)`方法的示例，它返回目录中所有条目的`Stream<Path>`：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is from the JDK API:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容来自JDK API：
- en: '*"This method must be used within a try-with-resources statement or similar
    control structure to ensure that the stream''s open directory is closed promptly
    after the stream''s operations are completed*."'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*"必须在try-with-resources语句或类似的控制结构中使用此方法，以确保在流操作完成后及时关闭流的打开目录。"*'
- en: And this is what we did; we used a try-with-resources statement. Alternatively,
    we could use a try-catch-finally construct, close the stream in the finally block,
    and the result would not change.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所做的；我们使用了try-with-resources语句。或者，我们可以使用try-catch-finally结构，在finally块中关闭流，结果不会改变。
- en: 'Run the preceding examples and observe the output:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行上述示例并观察输出：
- en: '![](img/9faf4c8d-cc86-43ce-9bcc-d116b5953269.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9faf4c8d-cc86-43ce-9bcc-d116b5953269.png)'
- en: Not all streams have to be closed explicitly, although the `Stream` interface
    extends `AutoCloseable` and one would expect that all streams have to be closed
    automatically using the try-with-resources statement. But that is not the case.
    The Javadoc for the `Stream` interface ([https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)) says,
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有流都必须显式关闭，尽管`Stream`接口扩展了`AutoCloseable`，人们可能期望所有流都必须使用try-with-resources语句自动关闭。但事实并非如此。`Stream`接口的Javadoc（[https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)）中说道：
- en: '"Streams have a `BaseStream.close()` method and implement `AutoCloseable`.
    Most stream instances do not actually need to be closed after use, as they are
    backed by collections, arrays, or generating functions, which require no special
    resource management. Generally, only streams whose source is an I/O channel, such
    as those returned by `Files.lines(Path)`, will require closing."'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: “流具有`BaseStream.close()`方法并实现`AutoCloseable`。大多数流实例实际上在使用后不需要关闭，因为它们由集合、数组或生成函数支持，不需要特殊的资源管理。通常，只有其源是I/O通道的流，例如`Files.lines(Path)`返回的流，才需要关闭。”
- en: This means that a programmer has to know the source of the stream, so make sure
    that the stream is closed if the API for the source requires it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着程序员必须知道流的来源，因此请确保如果源的API要求关闭流，则关闭流。
- en: 'Write an example of the `Files.lines()` method''s usage:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一个`Files.lines()`方法的使用示例：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The intent of the preceding example was to read the first three lines of the
    specified file and print non-empty lines with an indentation of three spaces.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子的目的是读取指定文件的前三行，并打印缩进三个空格的非空行。
- en: 'Run the preceding example and see the result:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行上面的例子并查看结果：
- en: '![](img/05f2f40a-65c6-48cf-9e2f-7d674d05efda.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05f2f40a-65c6-48cf-9e2f-7d674d05efda.png)'
- en: 'Write the code that uses the `Files.find()` method:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写使用`Files.find()`方法的代码：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Similar to the previous case, a stream generated by the `Files.find()` method
    has to be closed explicitly too. The `Files.find()` method walks the file tree
    rooted at a given starting file and at the requested depth and returns the paths
    to the files that match the predicate (which includes file attributes). Write
    the following code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与前面的情况类似，`Files.find()`方法生成的流也必须显式关闭。`Files.find()`方法遍历以给定起始文件为根的文件树，并返回与谓词匹配的文件的路径（包括文件属性）。写下以下代码：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the preceding example and you''ll get the following output:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行上面的例子，你会得到以下输出：
- en: '![](img/186d2a93-23ed-480f-b4e7-37fa6bbc3e44.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186d2a93-23ed-480f-b4e7-37fa6bbc3e44.png)'
- en: If necessary, `FileVisitorOption.FOLLOW_LINKS` could be included as the last
    parameter of the `Files.find()` method if we need to perform a search that would
    follow all symbolic links it might encounter.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，`FileVisitorOption.FOLLOW_LINKS`可以作为`Files.find()`方法的最后一个参数包含，如果我们需要执行一个会遵循它可能遇到的所有符号链接的搜索。
- en: The requirements for using the `BufferedReader.lines()` method, which returns
    `Stream<String>` of lines read from a file, is a little bit different. According to
    Javadoc ([https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html)),
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`BufferedReader.lines()`方法的要求有点不同，它返回从文件中读取的行的`Stream<String>`。根据Javadoc（[https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html)），
- en: '"The reader must not be operated on during the execution of the terminal stream
    operation. Otherwise, the result of the terminal stream operation is undefined."'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: “在终端流操作执行期间，不能对读取器进行操作。否则，终端流操作的结果是未定义的。”
- en: There are many other methods in the JDK that produce streams. But they are more
    specialized, and we will not demonstrate them here because of the shortage of
    space.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: JDK中有许多其他生成流的方法。但它们更加专业化，由于空间不足，我们将不在这里演示它们。
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Throughout the preceding examples, we have demonstrated several stream operations
    already—methods of the `Stream` interface. We used `forEach()` most often and `limit()`
    a few times. The first one is a terminal operation and the second one is an intermediate
    one. Let's look at other methods of the `Stream` interface now.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们已经演示了几个流操作，即`Stream`接口的方法。我们最常使用`forEach()`，有时使用`limit()`。第一个是终端操作，第二个是中间操作。现在让我们看看`Stream`接口的其他方法。
- en: 'Here are the intermediate operations—methods that return `Stream` and can be
    connected in a fluent style:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是中间操作，即返回`Stream`并可以以流畅的方式连接的方法：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The signatures of the preceding methods typically include `"? super T"` for
    an input parameter and `"? extends R"` for the result (see the Javadoc for the
    formal definition). We simplified them by removing these notations in order to
    provide a better overview of the variety and commonality of the methods. To compensate,
    we would like to recap the meaning of the related generic notations since they
    are used extensively in the Stream API and might be the source of confusion.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 前面方法的签名通常包括`“? super T”`作为输入参数和`“? extends R”`作为结果（请参阅Javadoc以获取正式定义）。我们通过删除这些标记来简化它们，以便更好地概述这些方法的多样性和共性。为了弥补这一点，我们想简要回顾相关泛型标记的含义，因为它们在Stream
    API中被广泛使用，可能会引起混淆。
- en: 'Let''s look at the formal definition of the `flatMap()` method because it has
    all of them:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`flatMap()`方法的正式定义，因为它包含了所有这些内容：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `<R>` symbol in front of the method indicates to the compiler that it is
    a generic method (the one with its own type parameters). Without it, the compiler
    would be looking for the definition of the `R` type. The `T` type is not listed
    in front of the method because it is included in the `Stream<T>` interface definition
    (look at the top of the page where the interface is declared). The `? super T`
    notation means that the `T` type or its superclass is allowed here. The `? extends
    R` notation means that the `R` type or its subclass is allowed here. The same
    applies to `? extends Stream<...>`: the `Stream` type or its subclass is allowed
    here.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 方法前面的`<R>`符号表示给编译器它是一个通用方法（具有自己的类型参数）。没有它，编译器将寻找`R`类型的定义。`T`类型没有列在方法前面，因为它包含在`Stream<T>`接口定义中（查看接口声明的页面顶部）。`?
    super T`表示`T`类型或其超类在此处允许。`? extends R`表示`R`类型或其子类在此处允许。`? extends Stream<...>`也是一样的：`Stream`类型或其子类在此处允许。
- en: 'Now, let''s get back to our (simplified) list of intermediate operations. We
    have broken them into several groups by similarity:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们（简化的）中间操作列表。我们根据相似性将它们分成了几个组：
- en: 'The first group contains only one `peek()` method, which allows you to apply
    the `Consumer` function to each of the stream elements without affecting the element
    because the `Consumer` function does not return anything. It is typically used
    for debugging:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一组中只包含一个`peek()`方法，它允许您对每个流元素应用`Consumer`函数，而不影响元素，因为`Consumer`函数不返回任何内容。它通常用于调试：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you execute the preceding code, the result will be as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您执行上述代码，结果将如下所示：
- en: '![](img/c805401d-0eff-4b09-b9e4-cadfb5c23d9a.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c805401d-0eff-4b09-b9e4-cadfb5c23d9a.png)'
- en: 'In the second group of intermediate operations listed above, the first three—`distinct()`, 
    `skip()`, `limit()`—are self-explanatory. The `filter(Predicate p)` method is
    one of the most often used. It does what its name suggests—it removes from the
    stream those elements that do not match the criterion passed in as the `Predicate`
    function. We saw an example of its usage in the previous snippet of code: only
    the odd numbers were allowed to flow through the filter. The `dropWhile()` method
    discards the elements as long as the criterion is met (then allows the rest of
    the stream elements to flow to the next operation). The `takeWhile()` method does
    the opposite—it allows the elements to flow as long as the criterion is met (then
    discards the rest of the elements). Here is an example of these operations'' usage:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上面列出的第二组中间操作中，前三个——`distinct()`、`skip()`、`limit()`——都是不言自明的。`filter(Predicate
    p)`方法是最常用的方法之一。它做的就是它的名字所暗示的——从流中删除不符合作为`Predicate`函数传递的标准的元素。我们在前面的代码片段中看到了它的使用示例：只有奇数才能通过过滤器。`dropWhile()`方法丢弃元素，只要标准得到满足（然后允许流的其余元素流向下一个操作）。`takeWhile()`方法则相反——只要标准得到满足（然后丢弃其余的元素）。以下是这些操作的使用示例：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code reads the file where the preceding code is stored. We want it to print
    `"Files.lines().dropWhile().takeWhile():"` first, then print all the preceding
    lines except the last three. So, the preceding code discards all the first lines
    of the file that do not have the `dropWhile().takeWhile()` substring, then allows
    all the lines to flow until the `} catch` substring is found.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码读取存储上述代码的文件。我们希望它首先打印`"Files.lines().dropWhile().takeWhile():"`，然后打印除最后三行之外的所有前面的行。因此，上述代码丢弃文件中不包含`dropWhile().takeWhile()`子字符串的所有第一行，然后允许所有行流动，直到找到`"}
    catch`子字符串为止。
- en: Notice that we had to write `"} catc" + "h"` instead of  `"} catch"`. Otherwise,
    the code would find `contains(" catch")` and would not go further.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须写`"} catc" + "h"`而不是`"} catch"`。否则，代码会找到`contains(" catch")`，并且不会继续执行。
- en: 'The result of the preceding code in as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果如下：
- en: '![](img/31315eab-c83a-4822-a762-baadf73b4b4e.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31315eab-c83a-4822-a762-baadf73b4b4e.png)'
- en: 'The group of `map()` operations is pretty straightforward too. Such an operation
    transforms each element of the stream by applying to it a function that was passed
    in as a parameter. We have already seen an example of the usage of the `mapToInt()`
    method. Here is another example of the `map()` operation:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()`操作组也非常简单。这样的操作通过将作为参数传递的函数应用于流的每个元素来转换流的每个元素。我们已经看到了`mapToInt()`方法的使用示例。以下是`map()`操作的另一个示例：'
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this example, we transform `String` literals into `boolean`. The result
    is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`String`文字转换为`boolean`。结果如下：
- en: '![](img/514474c8-0a6c-4f97-9c78-74174d928e3b.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/514474c8-0a6c-4f97-9c78-74174d928e3b.png)'
- en: 'The next group of intermediate operations, called `flatMap()`, provides more
    complex processing. A `flatMap()` operation applies the passed-in function (which
    returns a stream) to each of the elements so that the operation can produce a
    stream composed of the streams extracted from each of the elements. Here''s an
    example of `flatMap()` usage:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一组中间操作称为`flatMap()`，提供更复杂的处理。`flatMap()`操作将传入的函数（返回流）应用于每个元素，以便操作可以生成由从每个元素提取的流组成的流。以下是`flatMap()`的使用示例：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code selects from the stream elements only literals that contain
    `Th` and converts them into a stream of characters, which are then printed out
    by `forEach()`. The result of this is as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码从流元素中仅选择包含`Th`的文字，并将它们转换为字符流，然后由`forEach()`打印出来。其结果如下：
- en: '![](img/d98ba1f7-0686-4ad3-8ac5-15eb4f80b2f7.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d98ba1f7-0686-4ad3-8ac5-15eb4f80b2f7.png)'
- en: 'The `concat()` method creates a stream from two input streams so that all the
    elements of the first stream are followed by all the elements of the second stream.
    Here''s an example of this functionality:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concat()`方法从两个输入流创建一个流，以便第一个流的所有元素后跟第二个流的所有元素。以下是此功能的示例：'
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The result is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/a374487c-d5a2-4ee3-86cc-54f05d75f8c1.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a374487c-d5a2-4ee3-86cc-54f05d75f8c1.png)'
- en: 'In the case there are more than two stream concatenations, one can write the
    following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有两个以上的流连接，可以编写如下内容：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The result is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/b4687d8d-f14e-49b3-896c-7736483e1d18.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4687d8d-f14e-49b3-896c-7736483e1d18.png)'
- en: Notice that, in the preceding code, `Function.identity()` is a function that
    returns its input argument. We use it because we do not need to transform the
    input streams but just pass them as is to the resulting stream. Without using
    this `flatMap()` operation, the stream would consist of the `Stream` objects,
    not of their elements, and the output would show `java.util.stream.ReferencePipeline$Head@548b7f67java.util.stream.ReferencePipeline$Head@7ac7a4e4
    java.util.stream.ReferencePipeline$Head@6d78f375`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上述代码中，`Function.identity()`是一个返回其输入参数的函数。我们使用它是因为我们不需要转换输入流，而只是将它们原样传递给生成的流。如果不使用这个`flatMap()`操作，流将由`Stream`对象组成，而不是它们的元素，输出将显示`java.util.stream.ReferencePipeline$Head@548b7f67java.util.stream.ReferencePipeline$Head@7ac7a4e4
    java.util.stream.ReferencePipeline$Head@6d78f375`。
- en: The last group of intermediate operations is composed of the `sorted()` methods
    that sort the stream elements in a natural order (if they are of the `Comparable` type)
    or according to the passed-in `Comparator` object. It is a stateful operation
    (as well as `distinct()`, `limit()`, and `skip()`) that yields a non-deterministic
    result in the case of parallel processing (that is the topic of the recipe *Processing
    stream in parallel* below).
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间操作的最后一组由`sorted()`方法组成，该方法按自然顺序（如果它们是`Comparable`类型）或根据传入的`Comparator`对象对流元素进行排序。它是一个有状态的操作（以及`distinct()`、`limit()`和`skip()`），在并行处理的情况下会产生非确定性结果（这是下面*在并行中处理流*主题的食谱）。
- en: 'Now, let''s look at terminal operations (we simplified their signature too
    by removing `? super T` and `? extends R`):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看终端操作（我们通过删除`? super T`和`? extends R`来简化它们的签名）：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first four groups are self-explanatory, but we need to say a few words about `Optional`.
    The Javadoc ([https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html))
    defines it as,
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 前四组操作都不言自明，但是我们需要对`Optional`说几句话。Javadoc（[https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html)）将其定义为，
- en: '"A container object which may or may not contain a non-null value. If a value
    is present, `isPresent()` returns `true` and `get()` returns the value."'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: “可能包含非空值的容器对象。如果存在值，则`isPresent()`返回`true`，`get()`返回该值。”
- en: 'It allows you to avoid `NullPointerException` or check for `null` (well, you
    have to call `isPresent()` instead anyway). It has its own methods—`map()`, `filter()`,
    and `flatMap()`. In addition, `Optional` has methods that include the `isPresent()`
    check implicitly:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许您避免`NullPointerException`或检查`null`（无论如何，您都必须调用`isPresent()`）。它有自己的方法——`map()`、`filter()`和`flatMap()`。此外，`Optional`还有一些包含`isPresent()`检查的方法：
- en: '`ifPresent(Consumer<T> action)`: Performs the action with the value if present,
    otherwise does nothing'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifPresent(Consumer<T> action)`: 如果存在值，则执行该操作，否则不执行任何操作'
- en: '`ifPresentOrElse(Consumer<T> action, Runnable emptyAction)`: Performs the provided
    action with the value if present, otherwise performs the provided empty-based
    action'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifPresentOrElse(Consumer<T> action, Runnable emptyAction)`: 如果存在值，则执行提供的操作，否则执行提供的基于空的操作'
- en: '`or(Supplier<Optional<T>> supplier)`: Returns an `Optional` class describing
    the value if present, otherwise returns an `Optional` class produced by the provided
    function'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`or(Supplier<Optional<T>> supplier)`: 如果存在值，则返回描述该值的`Optional`类，否则返回由提供的函数产生的`Optional`类'
- en: '`orElse(T other)`: Returns the value if present, otherwise returns the provided `other` object'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orElse(T other)`: 如果存在值，则返回该值，否则返回提供的`other`对象'
- en: '`orElseGet(Supplier<T> supplier)`: Returns the value if present, otherwise
    returns the result produced by the provided function'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orElseGet(Supplier<T> supplier)`: 如果存在值，则返回该值，否则返回由提供的函数产生的结果'
- en: '`orElseThrow(Supplier<X> exceptionSupplier)`: Returns the value if present,
    otherwise throws an exception produced by the provided function'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orElseThrow(Supplier<X> exceptionSupplier)`: 如果存在值，则返回该值，否则抛出由提供的函数产生的异常'
- en: 'Note that `Optional` is used as a return value in cases when `null` is a possible
    result. Here is an example of its usage. We reimplemented the stream-concatenating
    code using the `reduce()` operation that returns `Optional`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Optional`在可能返回`null`的情况下用作返回值。以下是其用法示例。我们使用`reduce()`操作重新实现了流连接代码，该操作返回`Optional`：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The result is the same as in the previous implementation with the `flatMap()` method:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`flatMap()`方法的结果与以前的实现相同：
- en: '![](img/ca8a1a49-61ac-43cd-94b1-2385161bf443.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca8a1a49-61ac-43cd-94b1-2385161bf443.png)'
- en: 'The next group of terminal operations is referred to as `forEach()`. These
    operations guarantee that the given function will be applied to each element of
    the stream. But `forEach()` does not say anything about the order, which might
    be changed for better performance. By contrast, `forEachOrdered()` guarantees not
    only the processing of all the elements of the stream, but also doing this in
    the order specified by its source, regardless of whether the stream is sequential
    or parallel. Here are a couple of examples of this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下一组终端操作称为`forEach()`。这些操作保证给定的函数将应用于流的每个元素。但是`forEach()`对顺序没有任何要求，这可能会改变以获得更好的性能。相比之下，`forEachOrdered()`保证不仅处理流的所有元素，而且无论流是顺序还是并行，都会按照其源指定的顺序进行处理。以下是几个示例：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The result is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/62fc8016-1719-485e-9767-68ada906d7f5.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62fc8016-1719-485e-9767-68ada906d7f5.png)'
- en: 'As you can see, in the case of parallel processing, `forEach()` does not guarantee
    the order, while `forEachOrdered()` does. Here is another example of using both `Optional`
    and `forEach()`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在并行处理的情况下，`forEach()`不能保证顺序，而`forEachOrdered()`可以。以下是使用`Optional`和`forEach()`的另一个示例：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We could not use `Optional.of()` and used `Optional.ofNullable()` instead because
    `Optional.of()` would throw `NullPointerException` on `null`. In such a case, `Optional.ofNullable()`
    just returns `Optional` empty. The result is as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法使用`Optional.of()`，而是使用`Optional.ofNullable()`，因为`Optional.of()`在`null`上会抛出`NullPointerException`。在这种情况下，`Optional.ofNullable()`只会返回空的`Optional`。结果如下：
- en: '![](img/062c4c7d-21e1-4ad9-8e69-c21ec4476bb5.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/062c4c7d-21e1-4ad9-8e69-c21ec4476bb5.png)'
- en: Now, let's talk about the next group of terminal operations, called `reduce()`.
    Each of the three overloaded methods returns a single value after processing all
    the stream elements. Among the most simple examples are finding a sum of the stream
    elements in case they are numbers, or max, min, and similar. But a more complex
    result can be constructed for a stream of objects of any type.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈下一组终端操作，称为`reduce()`。这三个重载方法中的每一个在处理所有流元素后返回单个值。最简单的例子包括找到流元素的和（如果它们是数字），或者最大值、最小值等。但是对于任何类型的对象流，也可以构造更复杂的结果。
- en: 'The first method, `Optional<T> reduce(BinaryOperator<T> accumulator)`, returns
    the `Optional<T>` object because it is the responsibility of the provided accumulator
    function to calculate the result, and the authors of the JDK implementation cannot
    guarantee that it will always contain a non-null value:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法`Optional<T> reduce(BinaryOperator<T> accumulator)`返回`Optional<T>`对象，因为由提供的累加器函数负责计算结果，JDK实现的作者无法保证它总是包含非空值：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The passed-in function receives the result of the previous execution of the
    same function (as the first parameter, `p`) and the next element of the stream
    (as the second parameter, `e`). For the very first element, `p` gets its value,
    while `e` is the second element. You can print the `p` value as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 传入的函数接收相同函数之前执行的结果（作为第一个参数`p`）和流的下一个元素（作为第二个参数`e`）。对于第一个元素，`p`获得其值，而`e`是第二个元素。您可以按如下方式打印`p`的值：
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '![](img/51f1c284-f957-449d-af72-1eae5e35d77c.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51f1c284-f957-449d-af72-1eae5e35d77c.png)'
- en: 'To avoid the extra step with `Optional`, the second method, `T reduce(T identity,
    BinaryOperator<T> accumulator)`, returns the value provided as the first parameter, `identity`,
    of the `T` type (which is the type of the elements of `Stream<T>`) in case the
    stream is empty. This parameter has to comply with the for all `t`, as `accumulator.apply(identity,
    t)` is equal to the `t` requirement (from Javadoc). In our case, it has to be
    `0` for it to comply with `0 + e == e`. Here is an example of how to use the second
    method:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免使用`Optional`的额外步骤，第二种方法`T reduce(T identity, BinaryOperator<T> accumulator)`在流为空的情况下返回作为第一个参数`identity`的值，类型为`T`（即`Stream<T>`的元素类型）。该参数必须符合对于所有`t`的要求，因为`accumulator.apply(identity,
    t)`等于`t`的要求（来自Javadoc）。在我们的例子中，它必须为`0`，以符合`0 + e == e`。以下是如何使用第二种方法的示例：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The result is the same as with the first `reduce()` method.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与第一个`reduce()`方法相同。
- en: 'The third method, `U reduce(U identity, BiFunction<U,T,U> accumulator, BinaryOperator<U>
    combiner)`, converts the value of the `T` type into a value of the `U` type with
    the help of the `BiFunction<U,T,U>` function. `BiFunction<U,T,U>` is used as an
    accumulator so that the result (the `U` type) of its application to the previous
    element (the `T` type) becomes an input into the function along with the current
    element of the stream. Here is a code example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法`U reduce(U identity, BiFunction<U,T,U> accumulator, BinaryOperator<U>
    combiner)`，使用`BiFunction<U,T,U>`函数将`T`类型的值转换为`U`类型的值。`BiFunction<U,T,U>`用作累加器，使得其应用于前一个元素（`T`类型）的结果（`U`类型）成为函数的输入，同时与流的当前元素一起成为函数的输入。以下是一个代码示例：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'One naturally expects to see the result as `1,2,3`. Instead, we see the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地期望看到结果为`1,2,3`。但实际上我们看到的是：
- en: '![](img/64da187d-c5b8-4c95-9ac9-d47990d7dd77.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64da187d-c5b8-4c95-9ac9-d47990d7dd77.png)'
- en: 'The reason for the preceding result is that the combiner was used because the
    stream was sequential. But let''s make the stream parallel now:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 前面结果的原因是使用了组合器，因为流是顺序的。但现在让流并行化：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The result of the preceding code execution will be as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码执行结果将如下所示：
- en: '![](img/012b5675-5bff-4cec-ac3d-9f36597dde57.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/012b5675-5bff-4cec-ac3d-9f36597dde57.png)'
- en: 'This means that the combiner is called only for parallel processing in order
    to assemble (combine) the results of different sub-streams processed in parallel.
    This is the only deviation we have noticed so far from the declared intent of
    providing the same behavior for sequential and parallel streams. But there are
    many ways to accomplish the same result without using this third version of `reduce()`.
    For example, consider the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着组合器仅在并行处理时才会被调用，以组装（合并）并行处理的不同子流的结果。这是我们迄今为止从声明意图提供顺序和并行流相同行为的唯一偏差。但是有许多方法可以在不使用`reduce()`的第三个版本的情况下实现相同的结果。例如，考虑以下代码：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It produces the same result as the previous example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 它产生与前一个示例相同的结果：
- en: '![](img/2619716a-1f9f-4782-8a21-9e330b1f5494.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2619716a-1f9f-4782-8a21-9e330b1f5494.png)'
- en: 'Now let''s change it to a parallel stream:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将其改为并行流：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The result remains the same: `1,2,3`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 结果保持不变：`1,2,3`。
- en: 'The next group of intermediate operations, called `collect()`, consists of
    two methods:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 下一组中间操作称为`collect()`，包括两种方法：
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The first one accepts `Collector<T,A,R>` as a parameter. It is much more popular
    than the second one because it is backed up by the `Collectors` class, which provides
    a wide variety of implementations of the `Collector` interface. We encourage you
    to go through the Javadoc of the `Collectors` class and see what it offers.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种接受`Collector<T,A,R>`作为参数。它比第二种更受欢迎，因为它由`Collectors`类支持，该类提供了`Collector`接口的多种实现。我们鼓励您查看`Collectors`类的Javadoc并了解其提供的功能。
- en: 'Let''s discuss a few examples of using the `Collectors` class. First, we''ll
    create a small demo class called `Thing`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些使用`Collectors`类的示例。首先，我们将创建一个名为`Thing`的小型演示类：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we can use it to demonstrate a few collectors:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以用它来演示一些收集器：
- en: '[PRE46]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The result will be as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/c86fc553-23f1-4679-aa5e-e41571816ee9.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c86fc553-23f1-4679-aa5e-e41571816ee9.png)'
- en: The joining collector is a source of joy for any programmer who has ever had
    to write code that checks whether the added element is the first, the last, or
    removes the last character (like we did in the example of the `reduce()` operation).
    The collector produced by the `joining()` method does this behind the scenes.
    All the programmer has to provide is the delimiter, prefix, and suffix.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 连接收集器对于任何曾经不得不编写代码来检查添加的元素是否是第一个、最后一个或删除最后一个字符的程序员来说都是一种乐趣的来源（就像我们在`reduce()`操作的示例中所做的那样）。`joining()`方法生成的收集器在幕后执行此操作。程序员唯一需要提供的是分隔符、前缀和后缀。
- en: Most programmers will never need to write a customs collector. But in the case
    there is a need, one can use the second method, `collect()`, of `Stream`, and
    provide the functions that compose the collector or use one of the two `Collector.of()` static
    methods that generate a collector that can be reused.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序员永远不需要编写自定义收集器。但是如果有需要，可以使用`Stream`的第二种方法`collect()`，并提供组成收集器的函数，或者使用两种`Collector.of()`静态方法之一来生成可以重复使用的收集器。
- en: If you compare the `reduce()` and `collect()` operations, you'll notice that
    the primary purpose of `reduce()` is to operate on immutable objects and primitives.
    The result of `reduce()` is one value that is typically (but not exclusively)
    of the same type as the elements of the stream. `collect()`, by contrast, produces
    the result of a different type wrapped in a mutable container. The most popular
    usage of `collect()` is centered around producing `List`, `Set`, or `Map` objects
    using the corresponding `Collectors.toList()`, `Collectors.toSet()`, or `Collectors.toMap()` collector.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果比较`reduce()`和`collect()`操作，您会注意到`reduce()`的主要目的是对不可变对象和原始类型进行操作。`reduce()`的结果通常是一个值，通常（但不一定）与流的元素类型相同。相比之下，`collect()`产生了一个不同类型的结果，包装在一个可变容器中。`collect()`的最常见用法是使用相应的`Collectors.toList()`、`Collectors.toSet()`或`Collectors.toMap()`收集器生成`List`、`Set`或`Map`对象。
- en: 'The last group of terminal operations consists of two `toArray()` methods:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一组终端操作包括两个`toArray()`方法：
- en: '[PRE47]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The first returns `Object[]`, the second, an array of the specified type. Let''s
    look at the examples of their usage:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个返回`Object[]`，第二个返回指定类型的数组。让我们看一下它们的使用示例：
- en: '[PRE48]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output of these examples is as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例的输出如下：
- en: '![](img/fa432b46-098d-4fbe-b97d-1646a94aafbe.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa432b46-098d-4fbe-b97d-1646a94aafbe.png)'
- en: 'The first example is quite straightforward. It is worth noting that we cannot
    write the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例非常简单。值得注意的是，我们不能写以下内容：
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is because `toArray()` is a terminal operation and the stream is closed
    automatically after it. That's why we have to open a new stream in the second
    line of our preceding code example.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`toArray()`是一个终端操作，流在执行后会自动关闭。这就是为什么我们必须在前面代码示例的第二行中打开一个新的流。
- en: The second example—with the overloaded `A[] toArray(IntFunction<A[]> generator)`
    method—is more complicated. The Javadoc ([https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html))
    says,
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例——使用重载的`A[] toArray(IntFunction<A[]> generator)`方法——更加复杂。Javadoc ([https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html))中说，
- en: '"The generator function takes an integer, which is the size of the desired
    array, and produces an array of the desired size."'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: “生成函数接受一个整数，这个整数是所需数组的大小，并生成所需大小的数组。”
- en: This means that the method reference to a `toArray(String[]::new)` constructor
    in the last example is a shorter version of `toArray(size -> new String[size])`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在最后一个示例中对`toArray(String[]::new)`构造函数的方法引用是`toArray(size -> new String[size])`的缩写版本。
- en: Using numeric streams for arithmetic operations
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数字流进行算术运算
- en: In addition to the `Stream` interface, the `java.util.stream` package also provides
    specialized interfaces—`IntStream`, `DoubleStream`, and `LongStream`—that are
    optimized for processing streams of corresponding primitive types. They are very
    convenient to use, and have numeric operations, such as `max()`, `min()`, `average()`, `sum()`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Stream`接口之外，`java.util.stream`包还提供了专门的接口——`IntStream`、`DoubleStream`和`LongStream`——专门用于处理相应原始类型的流。它们非常方便使用，并且具有数字操作，如`max()`、`min()`、`average()`、`sum()`。
- en: The numeric interfaces have methods similar to the methods of the Stream interface,
    which means that everything we have talked about in the previous recipe, *Creating
    and operating on streams*, applies to numeric streams too. That is why, in this
    section, we will only talk about the methods that are not present in the `Stream` interface.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 数字接口具有类似于`Stream`接口的方法，这意味着我们在前面的*创建和操作流*中讨论的所有内容也适用于数字流。这就是为什么在本节中，我们只会讨论`Stream`接口中不存在的方法。
- en: Getting ready
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In addition to the methods described in the *Creating and operating on streams* recipe,
    the following methods can be used to create a numeric stream:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 除了*创建和操作流*中描述的方法之外，还可以使用以下方法创建数字流：
- en: The `range(int startInclusive, int endInclusive)` and `rangeClosed(int startInclusive,
    int endInclusive)` methods of the `IntStream` and `LongStream` interfaces
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream`和`LongStream`接口的`range(int startInclusive, int endInclusive)`和`rangeClosed(int
    startInclusive, int endInclusive)`方法'
- en: Six overloaded `stream()` methods of the `java.util.Arrays` class, which convert
    arrays and subarrays to numeric streams
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Arrays`类的六个重载的`stream()`方法，将数组和子数组转换为数字流'
- en: 'The list of intermediate operations specific to numeric streams includes the
    following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 特定于数字流的中间操作列表包括以下内容：
- en: '`boxed()`: Converts a numeric stream of a primitive type to a stream of the
    corresponding wrapping type'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boxed()`: 将原始类型的数字流转换为相应包装类型的流'
- en: '`mapToObj(mapper)`: Converts a numeric stream of a primitive type to a stream
    of objects using the provided function mapper'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapToObj(mapper)`: 使用提供的函数映射器将原始类型的数字流转换为对象流'
- en: '`asDoubleStream()` of the `LongStream` interface: Converts `LongStream` to
    `DoubleStream`'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asDoubleStream()`的`LongStream`接口：将`LongStream`转换为`DoubleStream`'
- en: '`asLongStream()` and `asDoubleStream()` of the `IntStream` interface: Converts `IntStream`
    to the corresponding numeric stream'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asLongStream()`和`asDoubleStream()`的`IntStream`接口：将`IntStream`转换为相应的数字流'
- en: 'The list of terminal arithmetic operations specific to numeric streams includes
    the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 特定于数字流的终端算术操作列表包括以下内容：
- en: '`sum()`: Calculates a sum of the numeric stream elements'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum()`: 计算数字流元素的总和'
- en: '`average()`: Calculates an average of the numeric stream elements'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`average()`: 计算数字流元素的平均值'
- en: '`summaryStatistics()`: Creates an object with various summary data about the
    elements of the stream'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`summaryStatistics()`：创建一个包含有关流元素的各种摘要数据的对象'
- en: How to do it...
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Experiment with the `range(int startInclusive, int endInclusive)` and `rangeClosed(int
    startInclusive, int endInclusive)` methods of the  `IntStream` and `LongStream` interfaces:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用`IntStream`和`LongStream`接口的`range(int startInclusive, int endInclusive)`和`rangeClosed(int
    startInclusive, int endInclusive)`方法：
- en: '[PRE50]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As you can see, the difference between the `range()` and `rangeClosed()` methods
    is the exclusion or inclusion of the value passed in as the second parameter.
    This also leads to the following results in the case where both parameters have
    the same value:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`range()`和`rangeClosed()`方法之间的区别在于第二个参数的排除或包含。这也导致了在两个参数具有相同值的情况下产生以下结果：
- en: '[PRE51]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding examples, the `range()` method does not emit any element, while
    the `rangeClosed()` method emits only one element.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`range()`方法不会发出任何元素，而`rangeClosed()`方法只会发出一个元素。
- en: 'Please notice that neither of these methods generates an error when the first
    parameter is bigger than the second parameter. They just emit nothing and the
    following statements produce no output:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当第一个参数大于第二个参数时，这些方法都不会生成错误。它们只是不发出任何内容，随后的语句也不会产生输出：
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If you do not need the values of stream elements to be sequential, you can
    create an array of the values first and then generate a stream using one of six
    overloaded `stream()` static methods of the `java.util.Arrays` class:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您不需要流元素的值是顺序的，可以首先创建一个值的数组，然后使用`java.util.Arrays`类的六个重载的`stream()`静态方法之一生成流：
- en: '[PRE53]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here are the examples of the usage of the `Arrays.stream()` method:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Arrays.stream()`方法的使用示例：
- en: '[PRE54]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The last two pipelines can be improved to print out the elements of `DoubleStream` in
    a more human-friendly format by using the joining collector we discussed in the
    previous recipe, *Creating and operating on streams*:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个流水线可以通过使用我们在上一篇文章中讨论的joining收集器来改进，以更加人性化的格式打印`DoubleStream`的元素：
- en: '[PRE55]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Since the `Collector<CharSequence, ?, String>` joining collector accepts `CharSequence`
    as an input type, we had to convert the number into `String` using an intermediate
    operation, `mapToObj()`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Collector<CharSequence, ?, String>` joining收集器接受`CharSequence`作为输入类型，我们必须使用中间操作`mapToObj()`将数字转换为`String`。
- en: Use the `mapToObj(mapper)` intermediate operation to convert a primitive type
    element to a reference type. We saw an example of its usage in step 2\. The mapper
    function can be as simple or as complex as it needs to be in order to achieve
    the necessary transformation.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`mapToObj(mapper)`中间操作将原始类型元素转换为引用类型。我们在第2步中看到了它的使用示例。mapper函数可以简单也可以复杂，以便实现必要的转换。
- en: 'There is also a specialized operation, `boxed()`, without parameters that convert
    elements of a primitive numeric type to the corresponding wrapping type—`int`
    value to `Integer` value, `long` value to `Long` value, and `double` value to
    `Double` value. We can use it, for example, to achieve the same results as the
    last two examples of the usage of the `mapToObj(mapper)` operation:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个专门的操作`boxed()`，没有参数，可以将原始数值类型的元素转换为相应的包装类型——`int`值转换为`Integer`值，`long`值转换为`Long`值，`double`值转换为`Double`值。例如，我们可以使用它来实现与`mapToObj(mapper)`操作的最后两个示例相同的结果：
- en: '[PRE56]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'There are also intermediate operations that convert an element of a numeric
    stream from one primitive type to another numeric primitive type: `asLongStream()` and `asDoubleStream()` in
    the `IntStream` interface, and `asDoubleStream()` in the `LongStream` interface.
    Let''s look at examples of their usage:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一些中间操作，可以将数值流的元素从一个原始类型转换为另一个原始类型：`IntStream`接口中的`asLongStream()`和`asDoubleStream()`，以及`LongStream`接口中的`asDoubleStream()`。让我们看看它们的使用示例：
- en: '[PRE57]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You may have noticed that these operations are possible only for the widening
    primitive conversion: from the `int` type to `long` and `double`, and from `long`
    to `double`.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，这些操作仅适用于扩展原始转换：从`int`类型到`long`和`double`，以及从`long`到`double`。
- en: 'The terminal arithmetic operations specific to numeric streams are pretty straightforward.
    Here are examples of the `sum()` and `average()` operations with `IntStream`:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特定于数值流的终端算术操作非常简单。以下是`IntStream`的`sum()`和`average()`操作的示例：
- en: '[PRE58]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, the `average()` operation returns `OptionalDouble`. It is interesting
    to consider why the authors decided to return `OptionalDouble` for `average()`
    but not for `sum()`. This decision was probably made to map an empty stream to
    an empty `OptionalDouble`, but then the decision to return `0` when `sum()` applies
    to an empty stream seems inconsistent.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`average()`操作返回`OptionalDouble`。有趣的是考虑为什么作者决定为`average()`返回`OptionalDouble`，但对于`sum()`却没有。这个决定可能是为了将空流映射到空的`OptionalDouble`，但是当`sum()`应用于空流时返回`0`的决定似乎是不一致的。
- en: 'These operations behave the same way for `LongStream` and `DoubleStream`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作对`LongStream`和`DoubleStream`的行为方式相同：
- en: '[PRE59]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `summaryStatistics()` terminal operation collects various summary data
    about the elements of the stream:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`summaryStatistics()`终端操作收集有关流元素的各种摘要数据：'
- en: '[PRE60]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The printouts added as comments to the preceding printing lines come from the `toString()`
    method of the `IntSummaryStatistics`, `LongSummaryStatistics`, or `DoubleSummaryStatistics` objects, correspondingly.
    Other methods of these objects include `getCount()`, `getSum()`, `getMin()`, `getAverage()`,
    and `getMax()`, which allow access to a particular aspect of the collected statistics.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到前面打印行的注释来自`IntSummaryStatistics`、`LongSummaryStatistics`或`DoubleSummaryStatistics`对象的`toString()`方法。这些对象的其他方法包括`getCount()`、`getSum()`、`getMin()`、`getAverage()`和`getMax()`，允许访问收集统计的特定方面。
- en: 'Notice that in the case of an empty stream, the min (max) value is the smallest
    (biggest) possible value of the corresponding Java type:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在空流的情况下，最小值（最大值）是相应Java类型的最小（最大）可能值：
- en: '[PRE61]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Only `DoubleSummaryStatistics` shows `Infinity` and `-Infinity` as min and max
    values, instead of the actual numbers shown here. According to the Javadoc of
    these methods, `getMax()` returns "the maximum recorded value, `Double.NaN` if
    any recorded value was `NaN` or `Double.NEGATIVE_INFINITY` if no values were recorded"
    and `getMin()` returns "the minimum recorded value, `Double.NaN` if any recorded
    value was `NaN` or `Double.POSITIVE_INFINITY` if no values were recorded."
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`DoubleSummaryStatistics`显示`Infinity`和`-Infinity`作为最小和最大值，而不是这里显示的实际数字。根据这些方法的Javadoc，`getMax()`返回“记录的最大值，如果任何记录的值为`NaN`，则返回`Double.NaN`，如果没有记录值，则返回`Double.NEGATIVE_INFINITY`”，`getMin()`返回“记录的最小值，如果任何记录的值为`NaN`，则返回`Double.NaN`，如果没有记录值，则返回`Double.POSITIVE_INFINITY`”。
- en: Also, please notice that in contrast with the `average()` terminal stream operation,
    the `getAverage()` method of any of the preceding summary statistics returns the
    arithmetic mean of streamed values, or zero if there were no values emitted from
    the stream, not the `Optional` object.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，与`average()`终端流操作相比，前述摘要统计的`getAverage()`方法返回流数值的算术平均值，如果从流中没有发出值，则返回零，而不是`Optional`对象。
- en: There's more...
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `IntSummaryStatistics`, `LongSummaryStatistics`, and `DoubleSummaryStatistics` objects
    can be created not only by the `summaryStatistics()` numeric stream terminal operation.
    Such an object can also be created by the `collect()` terminal operation applied
    to any `Stream` object, not just `IntStream`, `LongStream`, or `DoubleStream`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntSummaryStatistics`、`LongSummaryStatistics`和`DoubleSummaryStatistics`对象不仅可以通过`summaryStatistics()`数字流终端操作创建。这样的对象也可以通过应用于任何`Stream`对象的`collect()`终端操作来创建，而不仅仅是`IntStream`、`LongStream`或`DoubleStream`。'
- en: Each of the summary statistics objects has the `accept()` and `combine()` methods,
    which allow us to create a `Collector` object that can be passed into the `collect()` operation
    and produce the corresponding summary statistics object. We will demonstrate this
    possibility by creating the `IntSummaryStatistics` object. The `LongSummaryStatistics` and `DoubleSummaryStatistics` objects
    can be created similarly.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 每个摘要统计对象都有`accept()`和`combine()`方法，允许我们创建一个可以传递到`collect()`操作并产生相应摘要统计对象的`Collector`对象。我们将通过创建`IntSummaryStatistics`对象来演示这种可能性。`LongSummaryStatistics`和`DoubleSummaryStatistics`对象可以类似地创建。
- en: 'The `IntSummaryStatistics` class has the following two methods:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntSummaryStatistics`类有以下两种方法：'
- en: 'void accept (int value): Includes a new value into statistics summary'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: void accept(int value)：将新值包含到统计摘要中
- en: 'void combine (`IntSummaryStatistics` other): Adds the collected statistics
    of the provided `other` object to the current one'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: void combine(`IntSummaryStatistics` other)：将提供的`other`对象的收集统计信息添加到当前对象中
- en: 'These methods allow us to use the overloaded version of the `R collect(Supplier<R>
    supplier, BiConsumer<R,? super T> accumulator, BiConsumer<R,R> combiner)` operation
    on any `Stream` object, as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法允许我们在任何`Stream`对象上使用`R collect(Supplier<R> supplier, BiConsumer<R,? super
    T> accumulator, BiConsumer<R,R> combiner)`操作的重载版本，如下所示：
- en: '[PRE62]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As you can see, the stream is not one of the specialized numeric streams. It
    just has numeric elements of the same type as the created summary statistics object.
    Nevertheless, we were able to create an object of the `IntSummaryStatistics` class.
    Similarly, it is possible to create objects of the `LongSummaryStatistics` and `DoubleSummaryStatistics` classes.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，该流不是专门的数字流。它只有与创建的摘要统计对象相同类型的数值元素。尽管如此，我们仍然能够创建一个`IntSummaryStatistics`类的对象。同样，也可以创建`LongSummaryStatistics`和`DoubleSummaryStatistics`类的对象。
- en: 'Please notice that the third parameter, `combiner`, is used only for parallel
    stream processing—it combines the results of sub-streams that are processed in
    parallel. To demonstrate this, we can change the preceding example as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第三个参数`combiner`仅用于并行流处理——它将并行处理的子流的结果合并起来。为了演示这一点，我们可以将前面的示例更改如下：
- en: '[PRE63]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `Combining...` line is not printing. Let''s change the stream to a parallel
    one:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`Combining...`行没有打印。让我们将流更改为并行流：'
- en: '[PRE64]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If you run the preceding code now, you will see the `Combining...` line.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行前面的代码，您将看到`Combining...`行。
- en: 'Another way to collect statistics is to use a `Collector` object created by
    one of the following methods of the `Collectors` class:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 收集统计信息的另一种方法是使用`Collectors`类的以下方法之一创建的`Collector`对象：
- en: '[PRE65]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Again, we will use the first of the preceding methods to create the `IntSummaryStatistics`
    object. Let''s assume we have the following `Person` class:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将使用前述方法中的第一个来创建`IntSummaryStatistics`对象。假设我们有以下`Person`类：
- en: '[PRE66]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If there is a stream of `Person` class objects, we can collect statistics of
    the age of the persons (stream elements) as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个`Person`类对象的流，我们可以按如下方式收集人的年龄（流元素）的统计信息：
- en: '[PRE67]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see, we were able to collect statistics only on the field of an object
    that matches the type of the collected statistics. Neither the stream nor its
    elements are numeric.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们只能收集与收集统计信息类型匹配的对象字段的统计信息。流及其元素都不是数字。
- en: Look in the Javadoc of the `java.util.stream.Collectors` class to see what other
    functionality it provides before trying to create a custom `Collector` object.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试创建自定义的`Collector`对象之前，查看`java.util.stream.Collectors`类的Javadoc，看看它提供了哪些其他功能。
- en: Completing streams by producing collections
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过生成集合完成流
- en: You will learn and practice how to use the `collect()` terminal operation to
    repackage stream elements to a target collection structure.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习并练习如何使用`collect()`终端操作将流元素重新打包到目标集合结构中。
- en: Getting ready
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'There are two overloaded versions of the `collect()` terminal operation that
    allow us to create a collection of the stream elements:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`collect()`终端操作有两个重载版本，允许我们创建流元素的集合：'
- en: '`R collect(Supplier<R> supplier, BiConsumer<R,T> accumulator, BiConsumer<R,R>
    combiner)`: Produces the `R` result using the passed-in functions applied to the
    stream elements of the `T` type. The provided supplier and accumulator work together
    as follows:'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R collect(Supplier<R> supplier, BiConsumer<R,T> accumulator, BiConsumer<R,R>
    combiner)`: 使用传入的函数应用于`T`类型的流元素产生`R`结果。提供的供应商和累加器一起工作如下：'
- en: '[PRE68]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The provided combiner is used only for the processing of a parallel stream.
    It combines the results of the sub-streams processed in parallel.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的组合器仅用于并行流的处理。它合并并行处理的子流的结果。
- en: '`R collect(Collector<T, A, R> collector)`: Produces the `R` result using the
    passed-in `Collector` object applied to the stream elements of the `T` type. The `A` type
    is an intermediate accumulation type of `Collector`. The `Collector` object can
    be built using the `Collector.of()` factory method, but we are not going to discuss
    it in this recipe because there are many factory methods available in the `java.util.stream.Collectors` class
    that cover the majority of the needs. Besides, after you learn how to use the `Collectors`
    class, you will be able to use the `Collector.of()` method too.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R collect(Collector<T, A, R> collector)`: 使用传入的`Collector`对象应用于`T`类型的流元素产生`R`结果。`A`类型是`Collector`的中间累积类型。`Collector`对象可以使用`Collector.of()`工厂方法构建，但我们不打算在本教程中讨论它，因为`java.util.stream.Collectors`类中有许多可用的工厂方法可以满足大部分需求。此外，学会如何使用`Collectors`类后，您也将能够使用`Collector.of()`方法。'
- en: 'In this recipe, we are going to demonstrate how to use the following methods
    of the `Collectors` class:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将演示如何使用`Collectors`类的以下方法：
- en: '`Collector<T, ?, List<T>> toList()`: Creates a `Collector` object that collects
    the stream elements of the `T` type into a `List<T>` object'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T, ?, List<T>> toList()`: 创建一个`Collector`对象，将`T`类型的流元素收集到一个`List<T>`对象中'
- en: '`Collector<T, ?, Set<T>> toSet()`: Creates a `Collector` object that collects
    the stream elements of the `T` type into a `Set<T>` object'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T, ?, Set<T>> toSet()`: 创建一个`Collector`对象，将`T`类型的流元素收集到一个`Set<T>`对象中'
- en: '`Collector<T, ?, C> toCollection(Supplier<C> collectionFactory)`: Creates a `Collector` object
    that collects the stream elements of the `T` type into a `Collection` of the C
    type produced by the `collectionFactor` supplier'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T, ?, C> toCollection(Supplier<C> collectionFactory)`: 创建一个`Collector`对象，将`T`类型的流元素收集到由`collectionFactor`供应商产生的`C`类型的`Collection`中'
- en: '`Collector<T, ?, List<T>> toUnmodifiableList()`: Creates a `Collector` object
    that collects the stream elements of the `T` type into an immutable `List<T>` object'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T, ?, List<T>> toUnmodifiableList()`: 创建一个`Collector`对象，将`T`类型的流元素收集到一个不可变的`List<T>`对象中'
- en: '`Collector<T, ?, Set<T>> toUnmodifiableSet()`: Creates a `Collector` object
    that collects the stream elements of the `T` type into an immutable `Set<T>` object'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T, ?, Set<T>> toUnmodifiableSet()`: 创建一个`Collector`对象，将`T`类型的流元素收集到一个不可变的`Set<T>`对象中'
- en: 'For our demonstrations, we are going to use the following `Person` class:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的演示，我们将使用以下`Person`类：
- en: '[PRE69]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: How to do it...
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will walk you through the sequence of practical steps that demonstrate how
    to use the preceding methods and classes:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将带您完成一系列实际步骤，演示如何使用前面的方法和类：
- en: 'Write an example of the usage of the `R collect(Supplier<R> supplier, BiConsumer<R,T>
    accumulator, BiConsumer<R,R> combiner)` operation of the `Stream<T>` interface
    that produces the `List<T>` object:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写使用`Stream<T>`接口的`R collect(Supplier<R> supplier, BiConsumer<R,T> accumulator,
    BiConsumer<R,R> combiner)`操作产生`List<T>`对象的用法示例：
- en: '[PRE70]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the preceding example, the comments to the accumulator and the combiner demonstrate
    how these functions can be presented as lambda expressions instead of just method
    references.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，累加器和组合器的注释演示了如何将这些函数表示为lambda表达式，而不仅仅是方法引用。
- en: The first parameter, `Supplier<R>`, returns the container for the result. In
    our case, we have defined it as a constructor of the `ArrayList<Person>` class
    because it implements the `List<Person>` interface—the type of the object we would
    like to construct.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`Supplier<R>`返回结果的容器。在我们的例子中，我们将其定义为`ArrayList<Person>`类的构造函数，因为它实现了`List<Person>`接口，这是我们想要构造的对象类型。
- en: The accumulator takes the current result, `a` (which is going to be of the `List<Person>` type
    in our case), and adds to it the next stream element, `p` (the `Person` object
    in our case). The output of the example is shown as the last comment line.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 累加器接受当前结果`a`（在我们的例子中将是`List<Person>`类型），并将下一个流元素`p`（在我们的例子中是`Person`对象）添加到其中。示例的输出显示为最后一行注释。
- en: 'The combiner combines the results of the sub-streams processed in parallel. It
    takes the first result, `r` (of any sub-stream that has finished processing first),
    and adds to it another result, `r1`, and so on. This means that the combiner is
    used for parallel processing only. To demonstrate this, let''s modify the preceding
    code as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 组合器将并行处理的子流的结果合并。它获取第一个结果`r`（任何第一个完成处理的子流的结果），并添加另一个结果`r1`，依此类推。这意味着组合器仅用于并行处理。为了证明这一点，让我们修改前面的代码如下：
- en: '[PRE71]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If you run the preceding example, you will not see the `Combining...` line printed
    out because `combiner` is not used for sequential stream processing.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行前面的示例，您将看不到打印出`Combining...`行，因为`combiner`在顺序流处理中未被使用。
- en: 'Now, let''s convert the stream into a parallel one:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将流转换为并行流：
- en: '[PRE72]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If you run the preceding code, the `Combining...` line will be displayed.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行前面的代码，将显示`Combining...`行。
- en: Nothing prevents you from modifying the provided functions any way you need
    to, as long as the input and return types of each function remain the same.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 只要每个函数的输入和返回类型保持不变，就可以根据需要修改提供的函数。
- en: 'The `Set<Person>` object can be created the same way:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set<Person>`对象可以以相同的方式创建：'
- en: '[PRE73]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The created `List` or a `Set` object can be modified at any time:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的`List`或`Set`对象可以随时修改：
- en: '[PRE74]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We have mentioned it to contrast this behavior with the behavior of immutable
    collections, which we are going to discuss shortly.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到它是为了与不可变集合的行为进行对比，我们很快就会讨论。
- en: 'Write an example of the usage of the `R collect(Collector<T, A, R> collector)` operation
    of the `Stream<T>` interface with the collector created by the `Collector<T, ?,
    List<T>> Collectors.toList()` and  `Collector<T, ?, Set<T>> Collectors.toSet()` methods:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写使用由`Collector<T, ?, List<T>> Collectors.toList()`和`Collector<T, ?, Set<T>>
    Collectors.toSet()`方法创建的收集器的`R collect(Collector<T, A, R> collector)`操作的`Stream<T>`接口的用法示例：
- en: '[PRE75]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As was expected, `Set` does not allow duplicate elements defined by the `equals()` method
    implementation. In the case of the `Person` class, the `equals()` method compares
    both age and name, so a difference in any of these properties makes two `Person`
    objects not equal.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，`Set`不允许由`equals()`方法实现定义的重复元素。在`Person`类的情况下，`equals()`方法比较年龄和姓名，因此这些属性的任何差异都会使两个`Person`对象不相等。
- en: 'Write an example of the usage of the `R collect(Collector<T, A, R> collector)` operation
    of the `Stream<T>` interface with the collector created by the `Collector<T, ?,
    C> Collectors.toCollection(Supplier<C> collectionFactory)` method. The advantage
    of this collector is that it collects stream elements not just in `List` or `Set`,
    but in any object that implements a `Collection` interface. The target object
    that collects the stream elements of the `T` type is produced by the `collectionFactor` supplier:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写使用由`Collector<T, ?, C> Collectors.toCollection(Supplier<C> collectionFactory)`方法创建的收集器的`R
    collect(Collector<T, A, R> collector)`操作的`Stream<T>`接口的用法示例。这个收集器的优点是它不仅可以收集流元素到`List`或`Set`中，而且可以收集到实现`Collection`接口的任何对象中。收集`T`类型的流元素的目标对象由`collectionFactor`供应商生成：
- en: '[PRE76]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Write an example of the usage of the `R collect(Collector<T, A, R> collector)` operation
    of the `Stream<T>` interface with the collector created by the `Collector<T, ?,
    List<T>> Collectors.toUnmodifiableList()` and  `Collector<T, ?, Set<T>> Collectors.toUnmodifiableSet()` methods:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写使用由`Collector<T, ?, List<T>> Collectors.toUnmodifiableList()`和`Collector<T,
    ?, Set<T>> Collectors.toUnmodifiableSet()`方法创建的收集器的`R collect(Collector<T, A,
    R> collector)`操作的`Stream<T>`接口的用法示例：
- en: '[PRE77]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: As you can see from the comments in the preceding code, the objects created
    using collectors generated by the `Collector<T, ?, List<T>> Collectors.toUnmodifiableList()` and  `Collector<T,
    ?, Set<T>> Collectors.toUnmodifiableSet()` methods create immutable objects. Such
    objects are very helpful when used in lambda expressions because this way we are
    guaranteed that they cannot be modified, so the same the expression—even if passed
    around and executed in different contexts—will produce the result that depends
    only on its input parameters and will not have unexpected side-effects caused
    by the modification of the `List` or `Set` object it uses.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面代码中的注释中可以看出，使用由`Collector<T, ?, List<T>> Collectors.toUnmodifiableList()`和`Collector<T,
    ?, Set<T>> Collectors.toUnmodifiableSet()`方法生成的收集器创建的对象是不可变的。当在lambda表达式中使用时，这样的对象非常有用，因为这样我们可以保证它们不会被修改，因此相同的表达式即使在不同的上下文中传递和执行，也只会产生依赖于其输入参数的结果，并且不会由于修改它使用的`List`或`Set`对象而产生意外的副作用。
- en: 'For example:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE78]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The filter we have created in the preceding example can be used anywhere to
    select `Person` objects that belong to the provided set.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中创建的过滤器可以在任何地方使用，以选择属于提供的集合的`Person`对象。
- en: Completing streams by producing maps
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过生成映射来完成流
- en: You will learn and practice how to use the `collect()` terminal operation to
    repackage stream elements to target the `Map` structure. While discussing collectors,
    we will not include collectors that use grouping because they will be presented
    in the next recipe.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习并练习如何使用`collect()`终端操作将流元素重新打包到目标`Map`结构中。在讨论收集器时，我们不会包括使用分组的收集器，因为它们将在下一篇中介绍。
- en: Getting ready
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As we mentioned in the previous recipe, there are two overloaded versions of
    the `collect()` terminal operation, which allow us to create a collection of the
    stream elements:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一篇中提到的，`collect()`终端操作有两个重载版本，允许我们创建流元素的集合：
- en: '`R collect(Supplier<R> supplier, BiConsumer<R,T> accumulator, BiConsumer<R,R>
    combiner)`: Produces the `R` result using the passed-in functions applied to the
    stream elements of the `T` type'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R collect(Supplier<R> supplier, BiConsumer<R,T> accumulator, BiConsumer<R,R>
    combiner)`: 使用应用于`T`类型的流元素的传入函数生成`R`结果'
- en: '`R collect(Collector<T, A, R> collector)`: Produces the `R` result using the
    passed-in `Collector` object applied to the stream elements of the `T` type'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R collect(Collector<T, A, R> collector)`: 使用应用于`T`类型的流元素的传入`Collector`对象生成`R`结果'
- en: These operations can be also used to create a `Map` object, and in this recipe,
    we are going to demonstrate how to do so.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作也可以用来创建`Map`对象，在本篇中，我们将演示如何做到这一点。
- en: 'In support of the second of the preceding versions of the `collect()` operation,
    the `Collectors` class provides four groups of factory methods that create the `Collector`
    object. The first group includes the factory methods very similar to those that
    create the `Collector` object for collecting stream elements into `List` or `Set` discussed
    and demonstrated in the previous recipe:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 支持前述`collect()`操作的第二个版本，`Collectors`类提供了四组工厂方法，用于创建`Collector`对象。第一组包括与前一篇中讨论和演示的将流元素收集到`List`或`Set`中的`Collector`对象非常相似的工厂方法：
- en: '`Collector<T,?,Map<K,U>> toMap(Function<T,K> keyMapper, Function<T,U> valueMapper)`:
    Creates a `Collector` object that collects the stream elements of the `T` type
    into a `Map<K,U>` object using the provided functions (mappers) that produce a
    key and value from a stream element as an input parameter.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,Map<K,U>> toMap(Function<T,K> keyMapper, Function<T,U> valueMapper)`:
    创建一个`Collector`对象，使用提供的函数（映射器）将`T`类型的流元素收集到`Map<K,U>`对象中，这些函数从流元素作为输入参数产生键和值。'
- en: '`Collector<T,?,Map<K,U>> toMap(Function<T,K> keyMapper, Function<T,U> valueMapper,
    BinaryOperator<U> mergeFunction)`: Creates a `Collector` object that collects
    the stream elements of the `T` type into a `Map<K,U>` object using the provided
    functions (mappers) that produce a key and value from a stream element as an input
    parameter. The provided `mergeFunction` is used only for parallel stream processing;
    it merges the results of the sub-streams into the one final result—the `Map<K,U>`
    object.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,Map<K,U>> toMap(Function<T,K> keyMapper, Function<T,U> valueMapper,
    BinaryOperator<U> mergeFunction)`: 创建一个`Collector`对象，使用提供的函数（映射器）将`T`类型的流元素收集到一个`Map<K,U>`对象中，这些函数从流元素中产生一个键和一个值作为输入参数。提供的`mergeFunction`仅用于并行流处理；它将子流的结果合并为最终结果——`Map<K,U>`对象。'
- en: '`Collector<T,?,M> toMap(Function<T,K> keyMapper, Function<T,U> valueMapper,
    BinaryOperator<U> mergeFunction, Supplier<M> mapFactory)`: Creates a `Collector` object
    that collects the stream elements of the `T` type into a `Map<K,U>` object using
    the provided functions (mappers) that produce a key and value from a stream element
    as an input parameter. The provided `mergeFunction` is used only for parallel
    stream processing; it merges the results of the sub-streams into the one final
    result—the `Map<K,U>` object. The provided `mapFactory` supplier creates an empty `Map<K,U>` object
    into which the results will be inserted.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,M> toMap(Function<T,K> keyMapper, Function<T,U> valueMapper,
    BinaryOperator<U> mergeFunction, Supplier<M> mapFactory)`: 创建一个`Collector`对象，使用提供的函数（映射器）将`T`类型的流元素收集到一个`Map<K,U>`对象中，这些函数从流元素中产生一个键和一个值作为输入参数。提供的`mergeFunction`仅用于并行流处理；它将子流的结果合并为最终结果——`Map<K,U>`对象。提供的`mapFactory`供应商创建一个空的`Map<K,U>`对象，结果将被插入其中。'
- en: '`Collector<T,?,Map<K,U>> toUnmodifiableMap(Function<T,K> keyMapper, Function<T,U>
    valueMapper)`: Creates a `Collector` object that collects the stream elements
    of the `T` type into an *immutable* `Map<K,U>` object using the provided functions
    (mappers) that produce a key and value from a stream element as an input parameter.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,Map<K,U>> toUnmodifiableMap(Function<T,K> keyMapper, Function<T,U>
    valueMapper)`: 创建一个`Collector`对象，使用提供的函数（映射器）将`T`类型的流元素收集到一个*不可变*的`Map<K,U>`对象中，这些函数从流元素中产生一个键和一个值作为输入参数。'
- en: '`Collector<T,?,Map<K,U>> toUnmodifiableMap(Function<T,K> keyMapper, Function<T,U>
    valueMapper, BinaryOperator<U> mergeFunction)`: Creates a `Collector` object that
    collects the stream elements of the `T` type into an *immutable* `Map<K,U>` object
    using the provided functions (mappers) that produce a key and value from a stream
    element as an input parameter. The provided `mergeFunction` is used only for parallel
    stream processing; it merges the results of the sub-streams into the one final
    result—an immutable `Map<K,U>` object.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,Map<K,U>> toUnmodifiableMap(Function<T,K> keyMapper, Function<T,U>
    valueMapper, BinaryOperator<U> mergeFunction)`: 创建一个`Collector`对象，使用提供的函数（映射器）将`T`类型的流元素收集到一个*不可变*的`Map<K,U>`对象中，这些函数从流元素中产生一个键和一个值作为输入参数。提供的`mergeFunction`仅用于并行流处理；它将子流的结果合并为最终结果——一个不可变的`Map<K,U>`对象。'
- en: 'The second group includes three factory methods similar to the three `toMap()` methods
    we just listed. The only difference is that the collectors created by the `toConcurrentMap()` methods
    collect stream elements in a `ConcurrentMap` object:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组包括三个工厂方法，类似于我们刚刚列出的三个`toMap()`方法。唯一的区别是，由`toConcurrentMap()`方法创建的收集器将流元素收集到`ConcurrentMap`对象中：
- en: '`Collector<T,?,ConcurrentMap<K,U>> toConcurrentMap(Function<T,K> keyMapper,
    Function<T,U> valueMapper)`: Creates a `Collector` object that collects the stream
    elements of the `T` type into a `ConcurrentMap<K,U>` object using the provided
    functions (mappers) that produce a key and value from a stream element as an input
    parameter.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,ConcurrentMap<K,U>> toConcurrentMap(Function<T,K> keyMapper,
    Function<T,U> valueMapper)`: 创建一个`Collector`对象，使用提供的函数（映射器）将`T`类型的流元素收集到一个`ConcurrentMap<K,U>`对象中，这些函数从流元素中产生一个键和一个值作为输入参数。'
- en: '`Collector<T,?,ConcurrentMap<K,U>> toConcurrentMap(Function<T,K> keyMapper,
    Function<T,U> valueMapper, BinaryOperator<U> mergeFunction)`: Creates a `Collector` object
    that collects the stream elements of the `T` type into a `ConcurrentMap<K,U>` object
    using the provided functions (mappers) that produce a key and value from a stream
    element as an input parameter. The provided `mergeFunction` is used only for parallel
    stream processing; it merges the results of the sub-streams into the one final
    result—the `ConcurrentMap<K,U>` object.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,ConcurrentMap<K,U>> toConcurrentMap(Function<T,K> keyMapper,
    Function<T,U> valueMapper, BinaryOperator<U> mergeFunction)`: 创建一个`Collector`对象，使用提供的函数（映射器）将`T`类型的流元素收集到一个`ConcurrentMap<K,U>`对象中，这些函数从流元素中产生一个键和一个值作为输入参数。提供的`mergeFunction`仅用于并行流处理；它将子流的结果合并为最终结果——`ConcurrentMap<K,U>`对象。'
- en: '`Collector<T,?,M> toConcurrentMap(Function<T,K> keyMapper, Function<T,U> valueMapper,
    BinaryOperator<U> mergeFunction, Supplier<M> mapFactory)`: Creates a `Collector` object
    that collects the stream elements of the `T` type into a `ConcurrentMap<K,U>` object
    using the provided functions (mappers) that produce a key and value from a stream
    element as an input parameter. The provided `mergeFunction` is used only for parallel
    stream processing; it merges the results of the sub-streams into the one final
    result—the  `ConcurrentMap<K,U>` object. The provided `mapFactory` supplier creates
    an empty `ConcurrentMap<K,U>` object into which the results will be inserted.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,M> toConcurrentMap(Function<T,K> keyMapper, Function<T,U> valueMapper,
    BinaryOperator<U> mergeFunction, Supplier<M> mapFactory)`: 创建一个`Collector`对象，使用提供的函数（映射器）将`T`类型的流元素收集到一个`ConcurrentMap<K,U>`对象中，这些函数从流元素中产生一个键和一个值作为输入参数。提供的`mergeFunction`仅用于并行流处理；它将子流的结果合并为最终结果——`ConcurrentMap<K,U>`对象。提供的`mapFactory`供应商创建一个空的`ConcurrentMap<K,U>`对象，结果将被插入其中。'
- en: The need for this second group of factory methods arises from the fact that, for
    a parallel stream, the merging results of different sub-streams is an expensive
    operation. It is especially heavy when the results have to be merged into the
    resulting `Map` in the encountered order—that is what the collectors created by
    the `toMap()` factory methods do. These collectors create multiple intermediate
    results and then merge them by calling the collector's supplier and combiner multiple
    times.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 对于并行流，需要第二组工厂方法的原因是，合并不同子流的结果是一项昂贵的操作。当结果必须按照遇到的顺序合并到结果`Map`中时，这种操作尤其繁重——这就是`toMap()`工厂方法创建的收集器所做的。这些收集器创建多个中间结果，然后通过多次调用收集器的供应商和组合器来合并它们。
- en: When the order of the results-merging is not important, the collectors created by
    the `toConcurrentMap()` methods can be used as less heavy because they call the
    supplier only once, insert the elements in the *shared* resulting container, and
    never call the combiner.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当结果合并的顺序不重要时，由`toConcurrentMap()`方法创建的收集器可以用作较轻量级的，因为它们只调用一次供应商，在*共享*结果容器中插入元素，并且从不调用组合器。
- en: So, the difference between the `toMap()` and `toConcurrentMap()` collectors
    manifest only during parallel stream processing. That's why it is often recommended
    to use the `toMap()` collectors for serial stream processing, and the `toConcurrentMap()`
    collectors for parallel stream processing (if the order of collecting the stream
    elements is not important).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`toMap()`和`toConcurrentMap()`收集器之间的区别只在并行流处理期间显现。这就是为什么通常建议对于串行流处理使用`toMap()`收集器，对于并行流处理使用`toConcurrentMap()`收集器（如果收集流元素的顺序不重要）。
- en: The third group includes three `groupingBy()` factory methods, which we are
    going to discuss in the next recipe.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 第三组包括三个`groupingBy()`工厂方法，我们将在下一个示例中讨论。
- en: The fourth group includes three `groupingByConcurrent()` factory methods, which
    we are going to discuss in the next recipe, too.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 第四组包括三个`groupingByConcurrent()`工厂方法，我们也将在下一个示例中讨论。
- en: 'For our demonstrations, we are going to use the same `Person` class we used
    to create collections in the previous recipe:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的演示，我们将使用与上一个示例中创建集合时相同的`Person`类：
- en: '[PRE79]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: How to do it...
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will walk you through the sequence of practical steps that demonstrate how
    to use the preceding methods and classes:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将带你走过一系列实际步骤，演示如何使用前面的方法和类：
- en: 'Write an example of the usage of the `R collect(Supplier<R> supplier, BiConsumer<R,T>
    accumulator, BiConsumer<R,R> combiner)` operation of the `Stream<T>` interface
    that produces the `Map` object. Create `Map<String, Person>` with a person''s
    name as the key:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Stream<T>`接口的`R collect(Supplier<R> supplier, BiConsumer<R,T> accumulator,
    BiConsumer<R,R> combiner)`操作的用法示例，生成`Map`对象。创建`Map<String, Person>`，以人名作为键：
- en: '[PRE80]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Or, to avoid redundant data in the resulting `Map`, we can use age field as
    the `Map` value:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为了避免结果`Map`中的冗余数据，我们可以使用年龄字段作为`Map`的值：
- en: '[PRE81]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The combiner is called only for a parallel stream, as it is used to combine
    the results of different sub-stream processing. To prove it, we have replaced
    the method reference `Map::putAll` with the code block that prints the message `Combining...`:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 组合器仅在并行流中调用，因为它用于组合不同子流处理的结果。为了证明这一点，我们已经用打印消息`Combining...`的代码块替换了方法引用`Map::putAll`：
- en: '[PRE82]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The `Combining...` message will be displayed only if the conversion to a parallel
    stream is not commented out.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在未注释掉转换为并行流时，才会显示`Combining...`消息。
- en: 'If we add another `Person` object with the same name, one of them is going
    to be overwritten in the resulting `Map`:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加另一个具有相同名称的`Person`对象，其中一个将在结果`Map`中被覆盖：
- en: '[PRE83]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'If such a behavior is not desirable and we need to see all the values of all
    duplicate keys, we can change the resulting `Map` to have a `List` object as a
    value, so that in this list we can collect all the values that have the same key:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种行为不可取，并且我们需要查看所有重复键的所有值，我们可以将结果`Map`更改为具有`List`对象作为值，这样在这个列表中我们可以收集所有具有相同键的值：
- en: '[PRE84]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: As you can see, we did not inline the `BiConsumer` function in the `collect()` operation
    as a parameter because it is a multiline code now and is easier to read this way.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们没有将`BiConsumer`函数内联到`collect()`操作中作为参数，因为现在它是多行代码，这样阅读起来更容易。
- en: 'Another way to collect multiple values for the same key, in this case, would
    be to create `Map` with a `String` value as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，收集相同键的多个值的另一种方法是创建具有`String`值的`Map`，如下所示：
- en: '[PRE85]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Write an example of the usage of the `R collect(Collector<T, A, R> collector)` operation
    of the `Stream<T>` interface with the collector created by the `Collector<T, ?,
    Map<K,U>> Collectors.toMap(Function<T,K> keyMapper, Function<T,U> valueMapper)` method:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Stream<T>`接口的`R collect(Collector<T, A, R> collector)`操作的用法示例，使用`Collector<T,
    ?, Map<K,U>> Collectors.toMap(Function<T,K> keyMapper, Function<T,U> valueMapper)`方法创建的收集器：
- en: '[PRE86]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The preceding solution works fine as long as there is no duplicate key encountered,
    as in the following case:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 只要没有遇到重复键，前面的解决方案就能正常工作，就像下面的情况一样：
- en: '[PRE87]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The preceding code throws `IllegalStateException` with the `Duplicate key John`
    (attempted merging values 30 and 15) message and there is no way for us to add
    a check for a duplicate key, as we have done before. So, if there is a chance
    for a duplicate key, one has to use the overloaded version of the `toMap()` method.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码抛出了`IllegalStateException`，并显示了`Duplicate key John`（尝试合并值30和15）的消息，我们无法为重复键添加检查，就像之前做的那样。因此，如果存在重复键的可能性，就必须使用`toMap()`方法的重载版本。
- en: 'Write an example of the usage of the `R collect(Collector<T, A, R> collector)` operation
    of the `Stream<T>` interface with the collector created by the `Collector<T, ?,
    Map<K,U>> Collectors.toMap(Function<T,K> keyMapper, Function<T,U> valueMapper,
    BinaryOperator<U> mergeFunction)` method:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Stream<T>`接口的`R collect(Collector<T, A, R> collector)`操作的用法示例，使用`Collector<T,
    ?, Map<K,U>> Collectors.toMap(Function<T,K> keyMapper, Function<T,U> valueMapper,
    BinaryOperator<U> mergeFunction)`方法创建的收集器：
- en: '[PRE88]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'That is the purpose of the `mergeFunction`—to combine values for a duplicate
    key. Instead of `List<Integer>`, we can also collect the values of a duplicate
    key in a `String` object:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`mergeFunction`的目的——合并重复键的值。我们还可以将重复键的值收集到一个`String`对象中，而不是`List<Integer>`：
- en: '[PRE89]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Write an example of the usage of the `R collect(Collector<T, A, R> collector)` operation
    of the `Stream<T>` interface with the collector created by the `Collector<T, ?,
    M> Collectors.toMap(Function<T,K> keyMapper, Function<T,U> valueMapper, BinaryOperator<U>
    mergeFunction, Supplier<M> mapFactory)` method:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Stream<T>`接口的`R collect(Collector<T, A, R> collector)`操作的用法示例，使用`Collector<T,
    ?, M> Collectors.toMap(Function<T,K> keyMapper, Function<T,U> valueMapper, BinaryOperator<U>
    mergeFunction, Supplier<M> mapFactory)`方法创建的收集器：
- en: '[PRE90]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: As you can see, this version of the `toMap()` method allows us to specify the
    desired `Map` interface implementation (the `LinkedHashMap` class, in this case)
    instead of using the default one.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个`toMap()`方法的版本允许我们指定所需的`Map`接口实现（在这种情况下是`LinkedHashMap`类），而不是使用默认的实现。
- en: 'Write an example of the usage of the `R collect(Collector<T, A, R> collector)` operation
    of the `Stream<T>` interface with the collector created by the `Collector<T, ?,
    Map<K,U>> Collectors.toUnmodifiableMap(Function<T,K> keyMapper, Function<T,U> valueMapper)` method:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Stream<T>`接口的`R collect(Collector<T, A, R> collector)`操作的用法示例，使用`Collector<T,
    ?, Map<K,U>> Collectors.toUnmodifiableMap(Function<T,K> keyMapper, Function<T,U>
    valueMapper)`方法创建的收集器：
- en: '[PRE91]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: As you can see, the collector created by the `toUnmpdifiableMap()` method behaves
    the same as the collector created by the `Collector<T, ?, Map<K,U>> Collectors.toMap(Function<T,K>
    keyMapper, Function<T,U> valueMapper)` method, except that it produces an immutable
    `Map` object.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，由`toUnmpdifiableMap()`方法创建的收集器的行为与由`Collector<T, ?, Map<K,U>> Collectors.toMap(Function<T,K>
    keyMapper, Function<T,U> valueMapper)`方法创建的收集器相同，只是它生成一个不可变的`Map`对象。
- en: 'Write an example of the usage of the `R collect(Collector<T, A, R> collector)` operation
    of the `Stream<T>` interface with the collector created by the `Collector<T, ?,
    Map<K,U>> Collectors.toUnmodifiableMap(Function<T,K> keyMapper, Function<T,U>
    valueMapper, BinaryOperator<U> mergeFunction)` method:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Stream<T>`接口的`R collect(Collector<T, A, R> collector)`操作的用法示例，使用`Collector<T,
    ?, Map<K,U>> Collectors.toUnmodifiableMap(Function<T,K> keyMapper, Function<T,U>
    valueMapper, BinaryOperator<U> mergeFunction)`方法创建的收集器：
- en: '[PRE92]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The collector created by the `toUnmpdifiableMap()` method behaves the same
    as the collector created by the  `Collector<T, ?, Map<K,U>> Collectors.toMap(Function<T,K>
    keyMapper, Function<T,U> valueMapper, BinaryOperator<U> mergeFunction)` method,
    except that it produces an immutable `Map` object. Its purpose is to handle the
    case of duplicate keys. The following is another way to combine the values of
    duplicate keys:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 由`toUnmpdifiableMap()`方法创建的收集器的行为与由`Collector<T, ?, Map<K,U>> Collectors.toMap(Function<T,K>
    keyMapper, Function<T,U> valueMapper, BinaryOperator<U> mergeFunction)`方法创建的收集器相同，只是它生成一个不可变的`Map`对象。它的目的是处理重复键的情况。以下是另一种组合重复键值的方法：
- en: '[PRE93]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Write an example of the usage of the `R collect(Collector<T, A, R> collector)` operation
    of the `Stream<T>` interface with the collector created by the `Collector<T, ?
    ,ConcurrentMap<K,U>> Collectors.toConcurrentMap(Function<T,K> keyMapper, Function<T,U>
    valueMapper)` method:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Stream<T>`接口的`R collect(Collector<T, A, R> collector)`操作的用法示例，使用`Collector<T,
    ? ,ConcurrentMap<K,U>> Collectors.toConcurrentMap(Function<T,K> keyMapper, Function<T,U>
    valueMapper)`方法创建的收集器：
- en: '[PRE94]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: As you can see, the collector created by the `toConcurrentMap()` method behaves
    the same as the collector created by the `Collector<T, ?, Map<K,U>> Collectors.toMap(Function<T,K>
    keyMapper, Function<T,U> valueMapper)` and `Collector<T, ?, Map<K,U>> Collectors.toUnmodifiableMap(Function<T,K>
    keyMapper, Function<T,U> valueMapper)` methods, except that it produces a mutable `Map` object
    and, when the stream is parallel, shares between sub-streams the resulting `Map`.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，由`toConcurrentMap()`方法创建的收集器的行为与由`Collector<T, ?, Map<K,U>> Collectors.toMap(Function<T,K>
    keyMapper, Function<T,U> valueMapper)`和`Collector<T, ?, Map<K,U>> Collectors.toUnmodifiableMap(Function<T,K>
    keyMapper, Function<T,U> valueMapper)`方法创建的收集器相同，只是它生成一个可变的`Map`对象，并且在流是并行的时候，在子流之间共享结果`Map`。
- en: 'Write an example of the usage of the `R collect(Collector<T, A, R> collector)` operation
    of the `Stream<T>` interface with the collector created by the `Collector<T, ?,
    ConcurrentMap<K,U>> Collectors.toConcurrentMap(Function<T,K> keyMapper, Function<T,U>
    valueMapper, BinaryOperator<U> mergeFunction)` method:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Stream<T>`接口的`R collect(Collector<T, A, R> collector)`操作的用法示例，使用`Collector<T,
    ?, ConcurrentMap<K,U>> Collectors.toConcurrentMap(Function<T,K> keyMapper, Function<T,U>
    valueMapper, BinaryOperator<U> mergeFunction)`方法创建的收集器：
- en: '[PRE95]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'As you can see, the collector created by the `toConcurrentMap()` method behaves
    the same as the collector created by the `Collector<T, ?, Map<K,U>> Collectors.toMap(Function<T,K>
    keyMapper, Function<T,U> valueMapper, BinaryOperator<U> mergeFunction)` and `Collector<T,
    ?, Map<K,U>> Collectors.toUnmodifiableMap(Function<T,K> keyMapper, Function<T,U> valueMapper,
    BinaryOperator<U> mergeFunction)` methods, except that it produces a mutable `Map` object
    and, when the stream is parallel, shares the resulting `Map` between sub-streams. The
    following is another way to combine the values of duplicate keys:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，由`toConcurrentMap()`方法创建的收集器的行为与由`Collector<T, ?, Map<K,U>> Collectors.toMap(Function<T,K>
    keyMapper, Function<T,U> valueMapper, BinaryOperator<U> mergeFunction)`和`Collector<T,
    ?, Map<K,U>> Collectors.toUnmodifiableMap(Function<T,K> keyMapper, Function<T,U>
    valueMapper, BinaryOperator<U> mergeFunction)`方法创建的收集器相同，只是它生成一个可变的`Map`对象，并且在流是并行的时候，在子流之间共享结果`Map`。以下是另一种组合重复键值的方法：
- en: '[PRE96]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Write an example of the usage of the `R collect(Collector<T, A, R> collector)` operation
    of the `Stream<T>` interface with the collector created by the `Collector<T, ?,
    M> Collectors.toConcurrentMap(Function<T,K> keyMapper, Function<T,U> valueMapper,
    BinaryOperator<U> mergeFunction, Supplier<M> mapFactory)` method:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Stream<T>`接口的`R collect(Collector<T, A, R> collector)`操作的用法示例，使用`Collector<T,
    ?, M> Collectors.toConcurrentMap(Function<T,K> keyMapper, Function<T,U> valueMapper,
    BinaryOperator<U> mergeFunction, Supplier<M> mapFactory)`方法创建的收集器：
- en: '[PRE97]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: As you can see, this version of the `toConcurrentMap()` method allows us to
    specify the desired `Map` interface implementation (the `ConcurrentSkipListMap` class,
    in this case) instead of using the default one.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个`toConcurrentMap()`方法的版本允许我们指定所需的`Map`接口实现（在本例中是`ConcurrentSkipListMap`类），而不是使用默认的实现。
- en: The collector created by the `toConcurrentMap()` method behaves the same as
    the collector created by the `Collector<T, ?, Map<K,U>> Collectors.toMap(Function<T,K>
    keyMapper, Function<T,U> valueMapper, BinaryOperator<U> mergeFunction, Supplier<M>
    mapFactory)` method, but when the stream is parallel, it shares between sub-streams
    the resulting `Map`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`toConcurrentMap()`方法创建的收集器与`Collector<T, ?, Map<K,U>> Collectors.toMap(Function<T,K>
    keyMapper, Function<T,U> valueMapper, BinaryOperator<U> mergeFunction, Supplier<M>
    mapFactory)`方法创建的收集器行为相同，但在流并行时，它在子流之间共享结果`Map`。'
- en: Completing streams by producing maps using grouping collectors
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过使用分组收集器生成地图来完成流
- en: In this recipe, you will learn about and practice how to use the `collect()` terminal
    operation to group elements by a property and store the result in a `Map` instance
    using a collector.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将学习并练习如何使用`collect()`终端操作来按属性对元素进行分组，并使用收集器将结果存储在`Map`实例中。
- en: Getting ready
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There are two sets of collectors that use grouping—similar to the *group by* functionality
    of SQL statements—to present stream data as a `Map` object. The first set includes
    three overloaded `groupingBy()` factory methods:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 有两组收集器使用分组功能，类似于SQL语句的*group by*功能，将流数据呈现为`Map`对象。第一组包括三个重载的`groupingBy()`工厂方法：
- en: '`Collector<T, ?, Map<K,List<T>>> groupingBy(Function<T,K> classifier)`: Creates
    a `Collector` object that collects the stream elements of the `T` type into a `Map<K,List<T>>` object
    using the provided `classifier` function to map the current element to the key
    in the resulting map.'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T, ?, Map<K,List<T>>> groupingBy(Function<T,K> classifier)`: 创建一个`Collector`对象，使用提供的`classifier`函数将`T`类型的流元素收集到`Map<K,List<T>>`对象中，将当前元素映射到结果地图中的键。'
- en: '`Collector<T,?,Map<K,D>> groupingBy(Function<T,K> classifier, Collector<T,A,D>
    downstream)`: Creates a `Collector` object that collects the stream elements of
    the `T` type into a `Map<K,D>` object using the provided `classifier` function
    to map the current element to the key in the intermediate map `Map<K,List<T>>`.
    It then uses the `downstream` collector to convert the values of the intermediate
    map into the values of the resulting map, `Map<K,D`.'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,Map<K,D>> groupingBy(Function<T,K> classifier, Collector<T,A,D>
    downstream)`: 创建一个`Collector`对象，使用提供的`classifier`函数将`T`类型的流元素收集到`Map<K,D>`对象中，将当前元素映射到中间地图`Map<K,List<T>>`中的键。然后使用`downstream`收集器将中间地图的值转换为结果地图`Map<K,D>`的值。'
- en: '`Collector<T, ?, M> groupingBy(Function<T,K> classifier, Supplier<M> mapFactory,
    Collector<T,A,D> downstream)`: Creates a `Collector` object that collects the
    stream elements of the `T` type into the `M` map object using the provided `classifier` function
    to map the current element to the key in the `Map<K,List<T>>` intermediate map.
    It then uses the `downstream` collector to convert the values of the intermediate
    map into the values of the resulting map of the type provided by the `mapFactory`
    supplier.'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T, ?, M> groupingBy(Function<T,K> classifier, Supplier<M> mapFactory,
    Collector<T,A,D> downstream)`: 创建一个`Collector`对象，使用提供的`classifier`函数将`T`类型的流元素收集到`M`地图对象中，将当前元素映射到`Map<K,List<T>>`中的键。然后使用`downstream`收集器将中间地图的值转换为`mapFactory`供应商提供的类型的结果地图的值。'
- en: 'The second set of collectors includes three `groupingByConcurrent()` factory
    methods, which are created for concurrency handling during parallel stream processing.
    These collectors take the same arguments as the corresponding overloaded versions
    of the `groupingBy()` collectors listed earlier. The only difference is that the
    return type of the `groupingByConcurrent()` collectors are the instances of the
    `ConcurrentHashMap` class or its subclass:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组收集器包括三个`groupingByConcurrent()`工厂方法，用于在并行流处理期间处理并发。这些收集器接受与前面列出的`groupingBy()`收集器的相应重载版本相同的参数。唯一的区别是`groupingByConcurrent()`收集器的返回类型是`ConcurrentHashMap`类或其子类的实例：
- en: '`Collector<T, ?, ConcurrentMap<K,List<T>>> groupingByConcurrent(Function<T,K>
    classifier)` : Creates a `Collector` object that collects the stream elements
    of the `T` type into a `ConcurrentMap<K,List<T>>` object using the provided `classifier` function
    to map the current element to the key in the resulting map.'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T, ?, ConcurrentMap<K,List<T>>> groupingByConcurrent(Function<T,K>
    classifier)`: 创建一个`Collector`对象，使用提供的`classifier`函数将`T`类型的流元素收集到`ConcurrentMap<K,List<T>>`对象中，将当前元素映射到结果地图中的键。'
- en: '`Collector<T, ?, ConcurrentMap<K,D>> groupingByConcurrent(Function<T,K> classifier,
    Collector<T,A,D> downstream)`: Creates a `Collector` object that collects the
    stream elements of the `T` type into a `ConcurrentMap<K,D>` object using the provided `classifier` function
    to map the current element to the key in the `ConcurrentMap<K,List<T>>` intermediate
    map. It then uses the `downstream` collector to convert the values of the intermediate
    map into the values of the resulting map, `ConcurrentMap<K,D>`.'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T, ?, ConcurrentMap<K,D>> groupingByConcurrent(Function<T,K> classifier,
    Collector<T,A,D> downstream)`: 创建一个`Collector`对象，使用提供的`classifier`函数将`T`类型的流元素收集到`ConcurrentMap<K,D>`对象中，将当前元素映射到`ConcurrentMap<K,List<T>>`中的键。然后使用`downstream`收集器将中间地图的值转换为结果地图`ConcurrentMap<K,D>`的值。'
- en: '`Collector<T, ?, M> groupingByConcurrent(Function<T,K> classifier, Supplier<M>
    mapFactory, Collector<T,A,D> downstream)`: Creates a `Collector` object that collects
    the stream elements of the `T` type into the `M` map object using the provided `classifier` function
    to map the current element to the key in the `ConcurrentMap<K,List<T>>` intermediate
    map. It then uses the `downstream` collector to convert the values of the intermediate
    map into the values of the resulting map of the type provided by the `mapFactory`
    supplier.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T, ?, M> groupingByConcurrent(Function<T,K> classifier, Supplier<M>
    mapFactory, Collector<T,A,D> downstream)`: 创建一个`Collector`对象，使用提供的`classifier`函数将`T`类型的流元素收集到`M`地图对象中，将当前元素映射到`ConcurrentMap<K,List<T>>`中的键。然后使用`downstream`收集器将中间地图的值转换为由`mapFactory`供应商提供的结果地图的值类型。'
- en: 'For our demonstrations, we are going to use the same `Person` class we used
    to create maps in the previous recipe:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的演示，我们将使用在上一个示例中创建地图时使用的相同`Person`类：
- en: '[PRE98]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We will also use the `Person2` class:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`Person2`类：
- en: '[PRE99]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The `Person2` class is different from the `Person` class as it has an additional
    field—city. It will be used to demonstrate the power of the grouping functionality.
    And the `Person2` class variation—the `Person3` class—will be used to demonstrate
    how to create the `EnumMap` object. The `Person3` class uses `enum City` as the
    value type for its `city` property:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person2`类不同于`Person`类，因为它有一个额外的字段——城市。它将用于展示分组功能的强大功能。`Person2`类的变体`Person3`类将用于演示如何创建`EnumMap`对象。`Person3`类使用`enum
    City`作为其`city`属性的值类型：'
- en: '[PRE100]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'To make the examples less verbose, we are going to use the following methods
    to generate test streams:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使示例更简洁，我们将使用以下方法生成测试流：
- en: '[PRE101]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: How to do it...
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will walk you through the sequence of practical steps that demonstrate how
    to use the preceding methods and classes:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将带您逐步演示如何使用前面的方法和类：
- en: 'Write an example of the usage of the `R collect(Collector<T, A, R> collector)` operation
    of the `Stream<T>` interface with the collector created by the `Collector<T, ?,
    Map<K,List<T>>> groupingBy(Function<T,K> classifier)` method:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Stream<T>`接口的`R collect(Collector<T, A, R> collector)`操作的用法示例，使用由`Collector<T,
    ?, Map<K,List<T>>> groupingBy(Function<T,K> classifier)`方法创建的收集器：
- en: '[PRE102]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This is the simplest version of the `Collector` object. You just define what
    is going to be the key of the resulting map, and the collector will add all the
    stream elements that have the same key value to the list of elements associated
    with that key in the resulting map.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Collector`对象的最简单版本。您只需定义结果地图的键是什么，收集器将把具有相同键值的所有流元素添加到结果地图中与该键关联的元素列表中。
- en: 'Here is another example:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个例子：
- en: '[PRE103]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'If the stream elements have to be grouped by a combination of properties, you
    can create a class that can contain the necessary combination. The object of this
    class will serve as a complex key. For example, let''s read the stream of the `Person2`
    elements and group them by age and name. This means that need a class that can
    carry two values. For example, here is such a class, called `TwoStrings`:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果流元素必须按属性组合分组，可以创建一个可以包含必要组合的类。这个类的对象将作为复杂键。例如，让我们读取`Person2`元素的流，并按年龄和姓名对它们进行分组。这意味着需要一个可以携带两个值的类。例如，这是一个这样的类，叫做`TwoStrings`：
- en: '[PRE104]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We had to implement the `equals()` and `hashCode()` methods because an object
    of the `TwoStrings` class will be used as a key and its value has to be specific
    for each combination of the two values. We can use it now as follows:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须实现`equals()`和`hashCode()`方法，因为`TwoStrings`类的对象将被用作键，其值必须对于两个值的每个组合是特定的。现在我们可以这样使用它：
- en: '[PRE105]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Write an example of the usage of the `R collect(Collector<T, A, R> collector)` operations
    of the `Stream<T>` interface with the collector created by the `Collector<T,?,Map<K,D>> groupingBy(Function<T,K>
    classifier, Collector<T,A,D> downstream)` method:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Stream<T>`接口的`R collect(Collector<T, A, R> collector)`操作的用法示例，使用由`Collector<T,?,Map<K,D>>
    groupingBy(Function<T,K> classifier, Collector<T,A,D> downstream)`方法创建的收集器：
- en: '[PRE106]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: As you can see, the `List<Person>` values of the map produced by the `Collectors.groupingBy(Person::getName)` collector
    were later (downstream) changed to a set by the `Collectors.toSet()` collector.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，由`Collectors.groupingBy(Person::getName)`收集器产生的地图的`List<Person>`值后来（下游）被`Collectors.toSet()`收集器更改为集合。
- en: 'Alternatively, each `List<Person>` value can be converted to just a count of
    the list elements, as follows:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，每个`List<Person>`值可以转换为列表元素的计数，如下所示：
- en: '[PRE107]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'To count how many of the same `Person` objects (those that are equal according
    to the `equals()` method) are in the stream, we can use the identity function,
    which is defined as returning the input unchanged. For example:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算流中相同的`Person`对象（根据`equals()`方法相等的对象）的数量，我们可以使用identity函数，它被定义为返回不变的输入。例如：
- en: '[PRE108]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Using this function, we can count the number of same persons, as follows:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，我们可以计算相同人的数量，如下所示：
- en: '[PRE109]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'We can also calculate an average age in each group of persons (a group is defined
    as having the same the resulting key value):'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以计算每个人群中的平均年龄（一个群体被定义为具有相同的结果键值）：
- en: '[PRE110]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'To list all the values of the age of the persons with the same name, we can
    use the downstream collector created by the `Collector<T, ?, R> Collectors.mapping
    (Function<T,U> mapper, Collector<U,A,R> downstream)` method:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出具有相同名称的人的年龄的所有值，我们可以使用由`Collector<T, ?, R> Collectors.mapping (Function<T,U>
    mapper, Collector<U,A,R> downstream)`方法创建的下游收集器：
- en: '[PRE111]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Another variation of this solution is the following example, where for each
    age, a comma-delimited list of names is created:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案的另一个变化是下面的例子，对于每个年龄，创建一个逗号分隔的名称列表：
- en: '[PRE112]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'And, finally, to demonstrate another technique, we can use the nested `groupingBy()`
    collectors to create a map that contains age as a key and a map of person''s names
    to their cities as values:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了演示另一种技术，我们可以使用嵌套的`groupingBy()`收集器创建一个包含年龄作为键和人名到他们所在城市的地图：
- en: '[PRE113]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Please note that we used the `Person2` stream in the preceding example.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的例子中我们使用了`Person2`流。
- en: 'Write an example of the usage of the `R collect(Collector<T, A, R> collector)` operation
    of the `Stream<T>` interface with the collector created by the `Collector<T, ?,
    M> groupingBy(Function<T,K> classifier, Supplier<M> mapFactory, Collector<T,A,D>
    downstream)` method:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一个使用`Stream<T>`接口的`R collect(Collector<T, A, R> collector)`操作的示例，该操作使用`Collector<T,
    ?, M> groupingBy(Function<T,K> classifier, Supplier<M> mapFactory, Collector<T,A,D>
    downstream)`方法创建的收集器：
- en: '[PRE114]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The code in the preceding example counts how many times each name is encountered
    in the stream of the `Person` objects and places the result in the container (`LinkedHashMap`
    in this case) defined by the `mapFactory` function (the second parameter of the
    `groupingBy()` method).
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例中的代码计算了在`Person`对象流中遇到每个名称的次数，并将结果放在由`mapFactory`函数（`groupingBy()`方法的第二个参数）定义的容器中（在本例中是`LinkedHashMap`）。
- en: 'The following examples demonstrate how to tell the collector to use `EnumMap` based
    on `enum City` as a container of the final result:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何告诉收集器基于`enum City`作为最终结果的容器使用`EnumMap`：
- en: '[PRE115]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Please notice that we used the `Person3` stream in the preceding examples.
    To simplify the result (to avoid displaying a city twice for the same result)
    and to group the persons by age (for each city), we can use the nested `groupingBy()`
    collector again:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的例子中我们使用了`Person3`流。为了简化结果（避免在同一结果中重复显示城市）并且按年龄（对于每个城市）对人员进行分组，我们可以再次使用嵌套的`groupingBy()`收集器：
- en: '[PRE116]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'As examples of the second set of collectors, those created by the `groupingByConcurrent()` methods, all
    the preceding code snippets (except the last two with `EnumMap`) can be used by
    just replacing `groupingBy()` with `groupingByConcurrent()`  and the resulting  `Map` with
    the `ConcurrentMap` class or its subclass. For example:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第二组收集器的示例，那些由`groupingByConcurrent()`方法创建的收集器，所有前面的代码片段（最后两个使用`EnumMap`的除外）都可以通过将`groupingBy()`替换为`groupingByConcurrent()`和将结果的`Map`替换为`ConcurrentMap`类或其子类来使用。例如：
- en: '[PRE117]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: As we have mentioned before, the `groupingByConcurrent()` collectors can process
    sequential streams too, but they are designed to be used to process parallel stream
    data, so we have converted the preceding streams to parallel ones. The returned
    result is of the `ConcurrentHashMap` type or a subclass of it.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，`groupingByConcurrent()`收集器也可以处理顺序流，但它们设计用于处理并行流数据，因此我们已将前面的流转换为并行流。返回的结果是`ConcurrentHashMap`类型或其子类。
- en: There's more...
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Collectors` class also provides two collectors generated by the `partitioningBy()` method,
    which are specialized versions of the `groupingBy()` collectors:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collectors`类还提供了由`partitioningBy()`方法生成的两个收集器，这些收集器是`groupingBy()`收集器的专门版本：'
- en: '`Collector<T, ?, Map<Boolean,List<T>>> partitioningBy(Predicate<T> predicate)`:
    Creates a `Collector` object that collects the stream elements of the `T` type
    into a `Map<Boolean,List<T>>` object using the provided `predicate` function to
    map the current element to the key in the resulting map.'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T, ?, Map<Boolean,List<T>>> partitioningBy(Predicate<T> predicate)`:
    使用提供的`predicate`函数将`T`类型的流元素收集到`Map<Boolean,List<T>>`对象中，创建一个`Collector`对象。'
- en: '`Collector<T, ?, Map<Boolean,D>> partitioningBy(Predicate<T> predicate, Collector<T,A,D>
    downstream)` : Creates a `Collector` object that collects the stream elements
    of the `T` type into a `Map<Boolean,D>` object using the provided `predicate` function
    to map the current element to the key in the `Map<K,List<T>>` intermediate map.
    It then uses the `downstream` collector to convert the values of the intermediate
    map into the values of the resulting map, `Map<Boolean,D>`.'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T, ?, Map<Boolean,D>> partitioningBy(Predicate<T> predicate, Collector<T,A,D>
    downstream)`：创建一个`Collector`对象，使用提供的`predicate`函数将`T`类型的流元素收集到`Map<Boolean,D>`对象中，将当前元素映射到`Map<K,List<T>>`中的键。然后使用`downstream`收集器将中间映射的值转换为结果映射的值，`Map<Boolean,D>`。'
- en: 'Let''s look at some examples. Here is how the first of the preceding methods
    can be used to collect the `Person` stream elements into two groups—one with names
    that contain the letter `i` and another with names that don''t contain the letter
    `i`:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些例子。以下是如何使用前面的方法之一将`Person`流元素收集到两个组中的示例——一个组包含包含字母`i`的名称，另一个组包含不包含字母`i`的名称：
- en: '[PRE118]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'To demonstrate the usage of the second method, we can convert each `List<Person>` value
    of the map created in the preceding example to the list size:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示第二种方法的使用，我们可以将在前面示例中创建的地图中的每个`List<Person>`值转换为列表大小：
- en: '[PRE119]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The same result can be achieved using collectors created by the `groupingBy()` methods:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`groupingBy()`方法也可以实现相同的结果：
- en: '[PRE120]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The collectors created by the `partitioningBy()` methods are considered a specialization
    of the collectors created by the `groupingBy()` methods, and are expected to allow
    us to write less code when stream elements are broken into two groups and stored
    in a map with Boolean keys. But, as you can see from the preceding code, that's
    not always the case. The `partitioningBy()` collectors in our examples require
    us to write exactly the same amount of code as the `groupingBy()` collectors.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 由`partitioningBy()`方法创建的收集器被认为是`groupingBy()`方法创建的收集器的一个特殊版本，并且预计允许我们在流元素被分成两组并存储在具有布尔键的地图中时编写更少的代码。但是，正如您从前面的代码中看到的那样，并非总是如此。我们的示例中的`partitioningBy()`收集器要求我们编写与`groupingBy()`收集器完全相同数量的代码。
- en: Creating stream operation pipeline
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建流操作管道
- en: In this recipe, you will learn how to build a pipeline from the `Stream` operations.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何从`Stream`操作构建管道。
- en: Getting ready
  id: totrans-519
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In the previous chapter, [Chapter 4](69c0640b-9b2e-4515-bda6-8a481206da19.xhtml),
    *Going Functional*, while creating a lambda-friendly API, we ended up with the
    following API method:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章，[第4章](69c0640b-9b2e-4515-bda6-8a481206da19.xhtml)，*函数式编程*中，当创建一个lambda友好的API时，我们最终得到了以下API方法：
- en: '[PRE121]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The specified number of `TrafficUnit` instances were produced inside the `speedAfterStart()`
    method. They were limited by the `limitTrafficAndSpeed` function and were processed
    according to the `speedModel` function inside the `speedAfterStart()` method.
    The results were formatted by the `printResults` function.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 指定数量的`TrafficUnit`实例是在`speedAfterStart()`方法中生成的。它们受到`limitTrafficAndSpeed`函数的限制，并根据`speedModel`函数在`speedAfterStart()`方法中进行处理。结果由`printResults`函数格式化。
- en: It is a very flexible design that allows for quite a range of experimentation
    via the modification of functions that are passed to the API. In reality, though,
    especially during the early stages of data analysis, creating an API requires
    more code writing. It pays back only in the long run and only if the design flexibility
    allows us to accommodate new requirements with zero or very few code changes.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常灵活的设计，可以通过修改传递给API的函数来进行各种实验。但实际上，在数据分析的早期阶段，创建API需要更多的代码编写。这只有在长期内并且设计的灵活性允许我们在零或非常少的代码更改的情况下才能回报。
- en: The situation radically changes during the research phase. When new algorithms
    are developed or when the need for processing a large amount of data presents
    its own challenges, transparency across all the layers of the developed system
    becomes a foundational requirement. Without it, many of today's successes in the
    analysis of big data would be impossible.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究阶段，情况发生了根本性的变化。当新算法被开发或者需要处理大量数据时，系统的各个层面之间的透明度成为基本要求。没有它，今天在大数据分析方面的许多成功将是不可能的。
- en: Streams and the pipelines address the problem of transparency and minimize the overhead
    of writing infrastructural code.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 流和管道解决了透明度问题，并最小化了编写基础设施代码的开销。
- en: How to do it...
  id: totrans-526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s recall how a user called the lambda-friendly API:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下用户如何调用lambda-friendly API：
- en: '[PRE122]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: As we have already noticed, such an API may not cover all the possible ways
    the model can evolve, but it is a good starting point that allows us to construct
    the stream and the pipeline of operations with more transparency and flexibility
    of experimentation.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经注意到的，这样的API可能无法涵盖模型可能发展的所有可能方式，但它是一个很好的起点，可以让我们以更透明和灵活的实验方式构建操作流和管道。
- en: 'Now, let''s look at the API''s implementation:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下API的实现：
- en: '[PRE123]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'We can convert the `for` loop into a stream of traffic units and apply the
    same functions directly to the elements of the stream. But first, we can request
    the traffic-generating system to supply us with a `Stream` instead of a `List`
    of data. It allows us to avoid storing all the data in memory:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`for`循环转换为交通单位的流，并直接将相同的函数应用于流的元素。但首先，我们可以要求交通生成系统向我们提供一个`Stream`，而不是数据的`List`。这样可以避免将所有数据存储在内存中：
- en: '[PRE124]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: We can now process an endless number of traffic units without storing in the
    memory more than one unit at a time. In the demo code, we still use `List`, so
    the streaming does not save us memory. But in real systems, such as those that
    collect data from various sensors, using streams helps to decrease or completely
    avoid memory-usage concerns.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以处理无限数量的交通单位，而不需要一次存储超过一个单位的内存。在演示代码中，我们仍然使用`List`，因此流式处理并不能节省我们的内存。但在真实系统中，例如从各种传感器收集数据的系统中，使用流可以帮助减少或完全避免内存使用方面的问题。
- en: 'We will also create a convenience method:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个便利的方法：
- en: '[PRE125]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'With this, we can write the following:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以写下以下内容：
- en: '[PRE126]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'We mapped (transform) `TrafficUnit` to `Vehicle`, then mapped `Vehicle` to
    `speed`, and then used the current `TrafficUnit` instance and the calculated `speed`
    to limit the traffic and print results. If you have this code in a modern editor,
    you will notice that it does not compile because, after the first map, the current
    `TrafficUnit` element is not accessible anymore—it is replaced by `Vehicle`. This
    means we need to carry the original elements and add new values along the way.
    To accomplish this, we need a container—some kind of traffic-unit wrapper. Let''s
    create one:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`TrafficUnit`映射（转换）为`Vehicle`，然后将`Vehicle`映射为`speed`，然后使用当前的`TrafficUnit`实例和计算出的`speed`来限制交通并打印结果。如果您在现代编辑器中有这段代码，您会注意到它无法编译，因为在第一个映射之后，当前的`TrafficUnit`元素不再可访问——它被`Vehicle`替换了。这意味着我们需要携带原始元素，并在途中添加新值。为了实现这一点，我们需要一个容器——一种交通单位包装器。让我们创建一个：
- en: '[PRE127]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Now, we can build a pipeline that works:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建一个有效的管道：
- en: '[PRE128]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The code looks a bit verbose, especially the `Vehicle` and `SpeedModel` settings.
    We can hide this plumbing by moving them to the `TrafficUntiWrapper` class:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来有点冗长，特别是`Vehicle`和`SpeedModel`的设置。我们可以通过将它们移动到`TrafficUntiWrapper`类中来隐藏这些细节：
- en: '[PRE129]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Notice how we return `this` from the `setSpeedModel()` and `setSpeed()` methods.
    This allows us to preserve the fluent style. Now, the pipeline looks much cleaner:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们从`setSpeedModel()`和`setSpeed()`方法中返回`this`。这使我们能够保持流畅的风格。现在，管道看起来更加清晰：
- en: '[PRE130]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'If there is no need to keep the formula for the speed calculations easily accessible,
    we can move it to the `TrafficUnitWrapper` class by changing the `setSpeed()`
    method to `calcSpeed()`:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要轻松访问速度计算的公式，我们可以通过将其移动到`TrafficUnitWrapper`类中，将`setSpeed()`方法更改为`calcSpeed()`：
- en: '[PRE131]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'So, the pipeline becomes even less verbose:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，管道变得更加简洁：
- en: '[PRE132]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Based on this technique, we can now create a method that calculates traffic
    density—the count of vehicles in each lane of a multilane road for the given speed
    limit in each of the lanes:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这种技术，我们现在可以创建一个计算交通密度的方法——在多车道道路的每条车道上，根据每条车道的速度限制计算车辆的数量：
- en: '[PRE133]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The private `CountByLane` class used by the preceding method looks as follows:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 前面方法使用的私有`CountByLane`类如下所示：
- en: '[PRE134]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'And here is how the private `TrafficUnitWrapper` class looks:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是私有`TrafficUnitWrapper`类的样子：
- en: '[PRE135]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The code of the `countByLane()` private method is as follows:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '`countByLane()`私有方法的代码如下：'
- en: '[PRE136]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: In [Chapter 14](402d6438-f308-4ae7-b637-8e60a1215bc4.xhtml), *Testing*, we will
    discuss this method of the `TrafficDensity` class in more detail and revisit this
    implementation to allow for better unit testing. This is why writing a unit test
    parallel to the code development brings higher productivity; it eliminates the
    need to change the code afterward. It also results in more testable (better-quality)
    code.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第14章](402d6438-f308-4ae7-b637-8e60a1215bc4.xhtml)中，*测试*，我们将更详细地讨论`TrafficDensity`类的这种方法，并重新审视这个实现以便更好地进行单元测试。这就是为什么在代码开发的同时编写单元测试会带来更高的生产力；它消除了之后改变代码的需要。它还会产生更可测试（更高质量）的代码。
- en: There's more...
  id: totrans-560
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'The pipeline allows the easy addition of another filter, or any other operation
    for that matter:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 管道允许轻松添加另一个过滤器，或者任何其他操作：
- en: '[PRE137]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: It is especially important when many types of data have to be processed. It's
    worth mentioning that having a filter before the calculations are the best way
    to improve performance because it allows you to avoid unnecessary calculations.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要处理多种类型的数据时，这一点尤为重要。值得一提的是，在进行计算之前进行过滤是提高性能的最佳方式，因为它可以避免不必要的计算。
- en: Another major advantage of using a stream is that the process can be made parallel
    without extra coding. All you need to do is change the first line of the pipeline
    to `getTrafficUnitStream(trafficUnitsNumber).parallel()` (assuming the source
    does not generate the parallel stream, which can be identified by the `.isParallel()`
    operation). We will talk about parallel processing in more detail in the next
    recipe.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 使用流的另一个主要优势是可以在不额外编码的情况下使流程并行化。你只需要将管道的第一行改为`getTrafficUnitStream(trafficUnitsNumber).parallel()`（假设源不生成并行流，可以通过`.isParallel()`操作来识别）。我们将在下一个示例中更详细地讨论并行处理。
- en: Processing streams in parallel
  id: totrans-565
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行处理流
- en: In the previous recipes, we demonstrated some of the techniques of parallel
    stream-processing. In this recipe, we will discuss processing in greater detail,
    and share the best practices and solutions for common problems.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们演示了一些并行流处理的技术。在这个示例中，我们将更详细地讨论处理，并分享常见问题的最佳实践和解决方案。
- en: Getting ready
  id: totrans-567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: It is tempting to just set up all the streams to be parallel and not think about
    it again. Unfortunately, parallelism does not always provide an advantage. In
    fact, it incurs an overhead because of the worker threads' coordination. Besides,
    some stream sources are sequential in nature and some operations may share the
    same (synchronized) resource. Even worse, the usage of a stateful operation in
    parallel processing can lead to an unpredictable result. It does not mean one
    cannot use a stateful operation for a parallel stream, but it requires careful
    planning and a clear understanding of how the state is shared between the sub-streams
    of parallel processing.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 很诱人的是将所有流都设置为并行，然后不再考虑它。不幸的是，并行并不总是有利的。事实上，它会因为工作线程的协调而产生开销。此外，一些流源是顺序的，一些操作可能共享相同的（同步的）资源。更糟糕的是，在并行处理中使用有状态的操作可能导致不可预测的结果。这并不意味着不能在并行流中使用有状态的操作，但它需要仔细规划和清晰理解在并行处理的子流之间如何共享状态。
- en: How to do it...
  id: totrans-569
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: As was mentioned in the previous recipe, a parallel stream can be created by
    the `parallelStream()` method of a collection or the `parallel()` method applied
    to a stream. Conversely, the existing parallel stream can be converted into a
    sequential one by using the `sequential()` method.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的示例中提到的，可以通过集合的`parallelStream()`方法或应用于流的`parallel()`方法来创建并行流。相反，可以使用`sequential()`方法将现有的并行流转换为顺序流。
- en: As the first best practice, one should use a sequential stream by default and
    start thinking about the parallel one only if necessary and possible. The need
    usually comes up if the performance is not good enough and a large amount of data
    has to be processed. The possibilities are limited by the nature of the stream
    source and operations. For example, reading from a file is sequential and a file-based
    stream does not perform better in parallel. Any blocking operation also negates
    performance improvement in parallel.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，应该默认使用顺序流，并且只有在必要和可能的情况下才考虑并行流。通常情况下，如果性能不够好并且需要处理大量数据，才会出现这种需求。流源和操作的性质限制了可能性。例如，从文件中读取是顺序的，基于文件的流在并行中表现并不更好。任何阻塞操作也会抵消并行的性能提升。
- en: 'One of the areas where sequential and parallel streams are different is ordering.
    Here is an example:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序流和并行流不同的一个领域是顺序。这里有一个例子：
- en: '[PRE138]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The result is as follows:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/f3c994e3-4ae8-4123-b7d8-8c13afe401a2.png)'
  id: totrans-575
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3c994e3-4ae8-4123-b7d8-8c13afe401a2.png)'
- en: As you can see, `List` preserves the order of the elements but does not keep
    it in the case of parallel processing.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`List`保留了元素的顺序，但在并行处理的情况下不保持顺序。
- en: In the *Creating and operating on streams* recipe, we demonstrated that with
    the `reduce()` and `collect()` operations, a combiner is called only for a parallel
    stream. So, the combiner is not needed for a sequential stream processing, but
    it must be present while operating on a parallel one. Without it, the results
    of multiple workers are not correctly aggregated.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在*创建和操作流*的示例中，我们演示了对于`reduce()`和`collect()`操作，组合器只会在并行流中被调用。因此，在顺序流处理时不需要组合器，但在并行流操作时必须存在。没有组合器，多个工作线程的结果就无法正确聚合。
- en: We have also demonstrated that the `sorted()`, `distinct()`, `limit()`, and
    `skip()` stateful operations yield non-deterministic results in the case of parallel
    processing.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还演示了在并行处理的情况下，`sorted()`、`distinct()`、`limit()`和`skip()`这些有状态的操作会产生非确定性的结果。
- en: If the order is important, we have shown that you can rely on the `forEachOrdered()` 
    operation. It guarantees not only the processing of all the elements of the stream
    but also doing it in the order specified by its source, regardless of whether
    the stream is sequential or parallel.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 如果顺序很重要，我们已经证明您可以依赖`forEachOrdered()`操作。它不仅保证处理流的所有元素，而且按照其源指定的顺序进行处理，无论流是顺序的还是并行的。
- en: 'A parallel stream can be created by the `parallelStream()` method or by the `parallel()` method.
    Once created, it uses a `ForkJoin` framework during processing: the original stream
    is broken into segments (sub-streams) that are then given to different worker
    threads for processing, then all the results (of each sub-stream processing) are
    aggregated and presented as the final results of the original stream processing.
    On a computer with only one processor, such an implementation does not have an
    advantage because the processor is shared. But on a multicore computer, worker
    threads can be executed by different processors. Even more, if one worker becomes
    idle, it can *steal* a part of the job from a busy one. The results are then collected
    from all the workers and aggregated for the terminal operation completion (that
    is when a combiner of a collect operation becomes busy).'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 并行流可以通过`parallelStream()`方法或`parallel()`方法创建。一旦创建，它在处理过程中使用`ForkJoin`框架：原始流被分成段（子流），然后分配给不同的工作线程进行处理，然后所有结果（每个子流处理的结果）被聚合并呈现为原始流处理的最终结果。在只有一个处理器的计算机上，这样的实现没有优势，因为处理器是共享的。但在多核计算机上，工作线程可以由不同的处理器执行。更重要的是，如果一个工作线程变得空闲，它可以从忙碌的工作线程那里*偷取*一部分工作。然后从所有工作线程收集结果，并为终端操作的完成（即收集操作的组合器变得繁忙时）进行聚合。
- en: 'Generally speaking, if there is a resource that is not safe for concurrent
    access, it is not safe to use during parallel stream-processing either. Consider
    these two examples (`ArrayList` is not known to be thread-safe):'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果有一个资源在并发访问时不安全，那么在并行流处理期间使用它也是不安全的。考虑这两个例子（`ArrayList`不被认为是线程安全的）：
- en: '[PRE139]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'If run several times, this code may produce the following result:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行多次，此代码可能会产生以下结果：
- en: '![](img/85352637-6444-46ab-a438-087e3d601812.png)'
  id: totrans-584
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85352637-6444-46ab-a438-087e3d601812.png)'
- en: The `Collectors.toList()` method always generates the same list, which consists
    of `is` and `Stream.of(literals)`, while `forEach()` misses either `is` or `Stream.of(literals)`
    once in a while.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collectors.toList()`方法总是生成相同的列表，其中包括`is`和`Stream.of(literals)`，而`forEach()`偶尔会漏掉`is`或`Stream.of(literals)`。'
- en: If possible, try using collectors constructed by the `Collectors` class first
    and avoid shared resource during parallel computations.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，首先尝试使用`Collectors`类构造的收集器，并避免在并行计算期间使用共享资源。
- en: Overall, using stateless functions is your best bet for parallel stream pipelines.
    If in doubt, test your code and, most importantly, run the same test many times
    to check whether the result is stable.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，使用无状态函数是并行流管道的最佳选择。如果有疑问，请测试您的代码，最重要的是多次运行相同的测试，以检查结果是否稳定。
