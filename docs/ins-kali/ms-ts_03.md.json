["```ts\ninterface IComplexType {\n    id: number;\n    name: string;\n}\n\nvar complexType : IComplexType = \n    { id: 1, name: \"firstObject\" };\nvar complexType_2: IComplexType = \n    { id: 2, description: \"myDescription\"};\n\nif (complexType == complexType_2) {\n    console.log(\"types are equal\");\n}\n```", "```ts\nerror TS2012: Build: Cannot convert \n'{ id: number; description: string; }' to 'IComplexType':\n\n```", "```ts\nvar complexType_2: IComplexType = {\n    id: 2,\n    name: \"secondObject\",\n    description: \"myDescription\"\n};\n```", "```ts\ninterface IComplexType {\n    id: number;\n    name: string;\n    print(): string;\n}\nclass ComplexType implements IComplexType {\n    id: number;\n    name: string;\n    print(): string {\n        return \"id:\" + this.id + \" name:\" + this.name;\n    }\n}\n\nvar complexType: ComplexType = new ComplexType();\ncomplexType.id = 1;\ncomplexType.name = \"complexType\";\nvar complexType_2: ComplexType = new ComplexType();\ncomplexType_2.id = 2;\ncomplexType_2.name = \"complexType_2\";\n\nwindow.onload = () => {\n    console.log(complexType.print());\n    console.log(complexType_2.print());\n}\n```", "```ts\nid:1 name:complexType\nid:2 name:complexType_2\n\n```", "```ts\nvar complexType = new ComplexType(1, \"complexType\");\n```", "```ts\nclass ComplexType implements IComplexType {\n    id: number;\n    name: string;\n    constructor(idArg: number, nameArg: string) {\n        this.id = idArg;\n        this.name = nameArg;\n    }\n    print(): string {\n        return \"id:\" + this.id + \" name:\" + this.name;\n    }\n}\n```", "```ts\nclass ComplexType implements IComplexType {\n    id: number;\n    name: string;\n    constructor(idArg: number, nameArg: string);\n    constructor(idArg: string, nameArg: string);\n    constructor(idArg: any, nameArg: any) {\n        this.id = idArg;\n        this.name = nameArg;\n    }\n    print(): string {\n        return \"id:\" + this.id + \" name:\" + this.name;\n    }\n    usingTheAnyKeyword(arg1: any): any {\n        this.id = arg1;\n    }\n    usingOptionalParameters(optionalArg1?: number) {\n        if (optionalArg1) {\n            this.id = optionalArg1;\n        }\n    }\n    usingDefaultParameters(defaultArg1: number = 0) {\n        this.id = defaultArg1;\n    }\n    usingRestSyntax(...argArray: number []) {\n        if (argArray.length > 0) {\n            this.id = argArray[0];\n        }\n    }\n    usingFunctionCallbacks( callback: (id: number) => string  ) {\n        callback(this.id);\n    }\n\n}\n```", "```ts\nvar complexType: ComplexType = new ComplexType(1, \"complexType\");\nvar complexType_2: ComplexType = new ComplexType(\"1\", \"1\");\nvar complexType_3: ComplexType = new ComplexType(true, true);\n```", "```ts\ncomplexType.usingTheAnyKeyword(true);\ncomplexType.usingTheAnyKeyword({id: 1, name: \"test\"});\n```", "```ts\ncomplexType.usingOptionalParameters(1);\ncomplexType.usingOptionalParameters();\n```", "```ts\ncomplexType.usingDefaultParameters(2);\ncomplexType.usingDefaultParameters();\n```", "```ts\ncomplexType.usingRestSyntax(1, 2, 3);\ncomplexType.usingRestSyntax(1, 2, 3, 4, 5);\n```", "```ts\nfunction myCallbackFunction(id: number): string {\n    return id.toString();\n}\ncomplexType.usingFunctionCallbacks(myCallbackFunction);\n```", "```ts\ninterface IComplexType {\n    id: number;\n    name: string;\n    print(): string;\n    usingTheAnyKeyword(arg1: any): any;\n    usingOptionalParameters(optionalArg1?: number);\n    usingDefaultParameters(defaultArg1?: number);\n    usingRestSyntax(...argArray: number []);\n    usingFunctionCallbacks(callback: (id: number) => string);\n}\n```", "```ts\ninterface IComplexType {\n\n    constructor(arg1: any, arg2: any);\n\n}\n```", "```ts\nTypes of property 'constructor' of types 'ComplexType' and 'IComplexType' are incompatible\n\n```", "```ts\ninterface IBase {\n    id: number;\n}\n\ninterface IDerivedFromBase extends IBase {\n    name: string;\n}\n\nclass DerivedClass implements IDerivedFromBase {\n    id: number;\n    name: string;\n}\n```", "```ts\nclass BaseClass implements IBase {\n    id : number;\n}\n\nclass DerivedFromBaseClass \n    extends BaseClass \n    implements IDerivedFromBase \n{\n    name: string;\n}\n```", "```ts\nclass BaseClassWithConstructor {\n    private _id: number;\n    constructor(id: number) {\n        this._id = id;\n    }\n}\n\nclass DerivedClassWithConstructor extends BaseClassWithConstructor {\n    private _name: string;\n    constructor(id: number, name: string) {\n        this._name = name;\n        super(id);\n    }\n}\n```", "```ts\nclass BaseClassWithConstructor {\n    private _id: number;\n    constructor(id: number) {\n        this._id = id;\n    }\n    getProperties(): string {\n        return \"_id:\" + this._id;\n    }\n}\n\nclass DerivedClassWithConstructor extends BaseClassWithConstructor {\n    private _name: string;\n    constructor(id: number, name: string) {\n        this._name = name;\n        super(id);\n    }\n    getProperties(): string {\n        return \"_name:\" + this._name + \",\" + super.getProperties();\n    }\n}\n```", "```ts\nwindow.onload = () => {\n    var myDerivedClass = new DerivedClassWithConstructor(1, \"name\");\n    console.log(\n        myDerivedClass.getProperties()\n    );\n}\n```", "```ts\n_name:name,_id:1\n\n```", "```ts\nfunction TestClosure(value) {\n    this._value = value;\n    function printValue() {\n        console.log(this._value);\n    }\n    return printValue;\n}\n\nvar myClosure = TestClosure(12);\nmyClosure();\n```", "```ts\nvar BaseClassWithConstructor = (function () {\n    function BaseClassWithConstructor(id) {\n        this._id = id;\n    }\n    BaseClassWithConstructor.prototype.getProperties = function () {\n        return \"_id:\" + this._id;\n    };\n    return BaseClassWithConstructor;\n})();\n```", "```ts\ninterface IPerson {\n    getPersonCategory(): string;\n    canSignContracts(): boolean;\n    getDateOfBirth(): string;\n}\n```", "```ts\nclass Person {\n    _dateOfBirth: Date\n    constructor(dateOfBirth: Date) {\n        this._dateOfBirth = dateOfBirth;\n    }\n    getDateOfBirth(): string {\n        return this._dateOfBirth.toDateString();\n    }\n}\n```", "```ts\nclass Infant extends Person implements IPerson {\n    getPersonCategory(): string {\n        return \"Infant\";\n    }\n    canSignContracts() { return false; }\n}\n\nclass Child extends Person implements IPerson {\n    getPersonCategory(): string {\n        return \"Child\";\n    }\n    canSignContracts() { return false; }\n}\n\nclass Adult extends Person implements IPerson\n{\n    getPersonCategory(): string {\n        return \"Adult\";\n    }\n    canSignContracts() { return true; }\n}\n```", "```ts\nclass PersonFactory {\n    getPerson(dateOfBirth: Date): IPerson {\n        var dateNow = new Date();\n        var dateTwoYearsAgo = new Date(dateNow.getFullYear()-2,\n            dateNow.getMonth(), dateNow.getDay());\n        var dateEighteenYearsAgo = new Date(dateNow.getFullYear()-18,\n            dateNow.getMonth(), dateNow.getDay());\n\n        if (dateOfBirth >= dateTwoYearsAgo) {\n            return new Infant(dateOfBirth);\n        }\n        if (dateOfBirth >= dateEighteenYearsAgo) {\n            return new Child(dateOfBirth);\n        }\n        return new Adult(dateOfBirth);\n    }\n}\n```", "```ts\nwindow.onload = () => {\n    var personFactory = new PersonFactory();\n\n    var personArray: IPerson[] = new Array();\n    personArray.push(personFactory.getPerson(\n        new Date(2014, 09, 29))); // infant\n    personArray.push(personFactory.getPerson(\n       new Date(2000, 09, 29))); // child\n    personArray.push(personFactory.getPerson(\n       new Date(1950, 09, 29))); // adult\n\n    for (var i = 0; i < personArray.length; i++) {\n        console.log(\" A person with a birth date of :\"\n            + personArray[i].getDateOfBirth()\n            + \" is categorised as : \"\n            + personArray[i].getPersonCategory()\n            + \" and can sign : \"\n            + personArray[i].canSignContracts());\n    }\n}\n```", "```ts\nclass ClassWithModifiers {\n    private _id: number;\n    private _name: string;\n    constructor(id: number, name: string) {\n        this._id = id;\n        this._name = name;\n    }\n    modifyId(id: number) {\n        this._id = id;\n        this.updateNameFromId();\n    }\n    private updateNameFromId() {\n        this._name = this._id.toString() + \"_name\";\n    }\n}\n\nvar myClass = new ClassWithModifiers(1, \"name\");\nmyClass.modifyId(2);\nmyClass._id = 2;\nmyClass.updateNameFromId();\n```", "```ts\nerror TS2107: Build: 'ClassWithModifiers._id' is inaccessible.\nerror TS2107: Build: 'ClassWithModifiers.updateNameFromId' is inaccessible.\n\n```", "```ts\nclass ClassWithAutomaticProperties {\n    constructor(public id: number, private name: string) {\n    }\n    print(): void {\n        console.log(\"id:\" + this.id + \" name:\" + this.name);\n    }\n}\n\nvar myAutoClass = new ClassWithAutomaticProperties(1, \"name\");\nmyAutoClass.id = 2;\nmyAutoClass.name = \"test\";\n```", "```ts\nerror TS2107: Build: 'ClassWithAutomaticProperties.name' is inaccessible.\n\n```", "```ts\nclass SimpleClass {\n    public id: number;\n}\n\nvar mySimpleClass = new SimpleClass();\nmySimpleClass.id = 1;\n```", "```ts\nclass SimpleClassWithAccessors {\n    private _id: number;\n    get id() {\n        return this._id;\n    }\n    set id(value: number) {\n        this._id = value;\n    }\n}\n\nvar mySimpleAccClass = new SimpleClassWithAccessors();\nmySimpleClass.id = 1;\nconsole.log(\"id has the value of \" + mySimpleClass.id);\n```", "```ts\nclass ClassWithFunction {\n    printOne() {\n        console.log(\"1\");\n    }\n}\n\nvar myClassWithFunction = new ClassWithFunction();\nmyClassWithFunction.printOne();\n```", "```ts\nclass StaticClass {\n    static printTwo() {\n        console.log(\"2\");\n    }\n}\n\nStaticClass.printTwo();\n```", "```ts\nif (value === \"Infant\") {\n    // do something with an infant.\n}\n```", "```ts\nclass PersonType {\n    static INFANT: string = \"Infant\";\n    static CHILD: string = \"Child\";\n    static ADULT: string = \"Adult\";\n}\n```", "```ts\nif (value === PersonType.INFANT) {\n    // do something with an infant.\n}\n```", "```ts\nclass Concatenator< T > {\n    concatenateArray(inputArray: Array< T >): string {\n        var returnString = \"\";\n\n        for (var i = 0; i < inputArray.length; i++) {\n            if (i > 0)\n                returnString += \",\";\n            returnString += inputArray[i].toString();\n        }\n        return returnString;\n    }\n}\n```", "```ts\nvar stringConcatenator = new Concatenator<string>();\nvar numberConcatenator = new Concatenator<number>();\nvar personConcatenator = new Concatenator<IPerson>();\n```", "```ts\nvar stringArray: string[] = [\"first\", \"second\", \"third\"];\nvar numberArray: number[] = [1, 2, 3];\nvar stringResult = stringConcatenator.concatenateArray(stringArray);\nvar numberResult = numberConcatenator.concatenateArray(numberArray);\nvar stringResult2 = stringConcatenator.concatenateArray(numberArray);\nvar numberResult2 = numberConcatenator.concatenateArray(stringArray);\n```", "```ts\nTypes of property 'pop' of types 'string[]' and 'number[]' are incompatible.\nTypes of property 'pop' of types 'number[]' and 'string[]' are incompatible.\n\n```", "```ts\nclass Concatenator< T > {\n    concatenateArray(inputArray: Array< T >): string {\n        var returnString = \"\";\n\n        for (var i = 0; i < inputArray.length; i++) {\n            if (i > 0)\n                returnString += \",\";\n            returnString += inputArray[i].toString();\n        }\n        return returnString;\n    }\n}\n```", "```ts\nclass MyClass {\n    private _name: string;\n    constructor(arg1: number) {\n        this._name = arg1 + \"_MyClass\";\n    }\n}\nvar myArray: MyClass[] = [new MyClass(1), new MyClass(2), new MyClass(3)];\nvar myArrayConcatentator = new Concatenator<MyClass>();\nvar myArrayResult = myArrayConcatentator.concatenateArray(myArray);\nconsole.log(myArrayResult);\n```", "```ts\n[object Object],[object Object],[object Object]\n\n```", "```ts\nclass MyClass {\n    private _name: string;\n    constructor(arg1: number) {\n        this._name = arg1 + \"_MyClass\";\n    }\n    toString(): string {\n        return this._name;\n    }\n}\n```", "```ts\n1_MyClass,2_MyClass,3_MyClass\n\n```", "```ts\nclass PersonPrinter< T extends IPerson> {\n    print(arg: T) {\n        console.log(\"Person born on \"\n            + arg.getDateOfBirth()\n            + \" is a \"\n            + arg.getPersonCategory()\n            + \" and is \" +\n            this.getPermissionString(arg)\n            + \"allowed to sign.\"\n        );\n    }\n    getPermissionString(arg: T) {\n        if (arg.canSignContracts())\n            return \"\";\n        return \"NOT \";\n    }\n}\n```", "```ts\nwindow.onload = () => {\n    var personFactory = new PersonFactory();\n    var personPrinter = new PersonPrinter<IPerson>();\n\n    var child = personFactory.getPerson(new Date(2010, 0, 21));\n    var adult = personFactory.getPerson(new Date(1969, 0, 21));\n    var infant = personFactory.getPerson(new Date(2014, 0, 21));\n\n    console.log(personPrinter.print(adult));\n    console.log(personPrinter.print(child));\n    console.log(personPrinter.print(infant));\n}\n```", "```ts\ninterface IPersonPrinter<T extends IPerson> {\n    print(arg: T) : void;\n    getPermissionString(arg: T): string;\n}\n```", "```ts\nclass PersonPrinter<T extends IPerson> implements IPersonPrinter<T> {\n\n}\n```", "```ts\nclass PersonPrinter<T> implements IPersonPrinter<T> {\n\n}\n```", "```ts\nType 'T' does not satisfy the constraint 'IPerson' for type parameter 'T extends IPerson'.\n\n```", "```ts\nclass FirstClass {\n    id: number;\n}\n\nclass SecondClass {\n    name: string;\n}\n\nclass GenericCreator< T > {\n    create(): T {\n        return new T();\n    }\n}\n\nvar creator1 = new GenericCreator<FirstClass>();\nvar firstClass: FirstClass = creator1.create();\n\nvar creator2 = new GenericCreator<SecondClass>();\nvar secondClass : SecondClass = creator2.create();\n```", "```ts\nerror TS2095: Build: Could not find symbol 'T'.\n\n```", "```ts\nclass GenericCreator< T > {\n    create(arg1: { new(): T }) : T {\n        return new arg1();\n    }\n}\n```", "```ts\nvar creator1 = new GenericCreator<FirstClass>();\nvar firstClass: FirstClass = creator1.create(FirstClass);\n\nvar creator2 = new GenericCreator<SecondClass>();\nvar secondClass : SecondClass = creator2.create(SecondClass);\n```", "```ts\nclass TcBaseClass {\n    id: number;\n    constructor(idArg: number) {\n        this.id = idArg;\n    }\n}\n```", "```ts\nclass TcDerivedClass extends TcBaseClass {\n    name: string;\n    constructor(idArg: number, nameArg: string) {\n        super(idArg);\n        this.name = name;\n    }\n    print() {\n        console.log(this.id + \" \" + this.name);\n    }\n}\n```", "```ts\nvar base = new TcBaseClass(1);\nvar derived = new TcDerivedClass(2, \"second\");\n```", "```ts\nconsole.log(\"typeof base: \" + typeof base);\nconsole.log(\"typeof derived: \" + typeof derived);\n```", "```ts\ntypeof base: object\ntypeof derived: object\n\n```", "```ts\nconsole.log(\"base instance of TcBaseClass : \" + (base instanceof TcBaseClass));\nconsole.log(\"derived instance of TcBaseClass: \" + (derived instanceof TcBaseClass));\n```", "```ts\nbase instance of TcBaseClass : true\nderived instance of TcBaseClass: true\n\n```", "```ts\nconsole.log(\"typeof base.id: \" +  typeof base.id);\nconsole.log(\"typeof derived.name: \" +  typeof derived.name);\nconsole.log(\"typeof derived.print: \" + typeof derived.print);\n```", "```ts\n typeof base.id: number\n typeof derived.name: string\n typeof derived.print: function\n\n```", "```ts\ninterface IBasicObject {\n    id: number;\n    name: string;\n    print(): void;\n}\n\nclass BasicObject implements IBasicObject {\n    id: number;\n    name: string;\n    constructor(idArg: number, nameArg: string) {\n        this.id = idArg;\n        this.name = nameArg;\n    }\n    print() {\n        console.log(\"id:\" + this.id + \", name\" + this.name);\n    }\n}\n```", "```ts\nvar BasicObject = (function () {\n    function BasicObject(idArg, nameArg) {\n        this.id = idArg;\n        this.name = nameArg;\n    }\n    BasicObject.prototype.print = function () {\n        console.log(\"id:\" + this.id + \", name\" + this.name);\n    };\n    return BasicObject;\n})();\n```", "```ts\nclass FunctionChecker {\n    static implementsFunction(\n    objectToCheck: any, functionName: string): boolean\n    {\n        return (objectToCheck[functionName] != undefined &&\n            typeof objectToCheck[functionName] == 'function');\n    }\n}\n```", "```ts\nvar myClass = new BasicObject(1, \"name\");\nvar isValidFunction = FunctionChecker.implementsFunction(\n    myClass, \"print\");\nconsole.log(\"myClass implements the print() function :\" + isValidFunction);\nisValidFunction = FunctionChecker.implementsFunction(\n    myClass, \"alert\");\nconsole.log(\"myClass implements the alert() function :\" + isValidFunction);\n```", "```ts\nmyClass implements the print() function :true\nmyClass implements the alert() function :false\n\n```", "```ts\ninterface IInterfaceChecker {\n    methodNames?: string[];\n    propertyNames?: string[];\n}\n```", "```ts\nclass IIBasicObject implements IInterfaceChecker {\n    methodNames: string[] = [\"print\"];\n    propertyNames: string[] = [\"id\", \"name\"];\n}\n```", "```ts\nclass InterfaceChecker<T extends IInterfaceChecker> {\n    implementsInterface(\n        classToCheck: any,\n        t: { new (): T; }\n    ): boolean\n    {\n        var targetInterface = new t();\n        var i, len: number;\n        for (i = 0, len = targetInterface.methodNames.length; i < len; i++) {\n            var method: string = targetInterface.methodNames[i];\n            if (!classToCheck[method] ||\n                typeof classToCheck[method] !== 'function') {\n                console.log(\"Function :\" + method + \" not found\");\n                return false;\n            }\n        }\n        for (i = 0, len = targetInterface.propertyNames.length; i < len; i++) {\n            var property: string = targetInterface.propertyNames[i];\n            if (!classToCheck[property] ||\n                typeof classToCheck[property] == 'function') {\n                console.log(\"Property :\" + property + \" not found\");\n                return false;\n            }\n        }\n        return true;\n    }\n}\nvar myClass = new BasicObject(1, \"name\");\nvar interfaceChecker = new InterfaceChecker();\n\nvar isValid = interfaceChecker.implementsInterface(myClass, IIBasicObject);\n\nconsole.log(\"myClass implements the IIBasicObject interface :\" + isValid);\n```", "```ts\nmyClass implements the IIBasicObject interface :true\n\n```", "```ts\nvar noPrintFunction = { id: 1, name: \"name\" };\nisValid = interfaceChecker.implementsInterface(\n    noPrintFunction, IIBasicObject);\nconsole.log(\"noPrintFunction implements the IIBasicObject interface:\" + isValid);\n```", "```ts\nFunction :print not found\nnoPrintFunction implements the IIBasicObject interface :false\n\n```"]