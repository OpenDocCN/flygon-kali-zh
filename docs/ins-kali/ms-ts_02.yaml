- en: Chapter 2. Types, Variables and Function Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。类型，变量和函数技术
- en: TypeScript introduces strong typing to JavaScript through a simple syntax, referred
    to by Anders Hejlsberg as "syntactic sugar".
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript通过一种简单的语法引入了强类型到JavaScript，安德斯·海尔斯伯格称之为“语法糖”。
- en: This chapter is an introduction to the syntax used in the TypeScript language
    to apply strong typing to JavaScript. It is intended for readers that have not
    used TypeScript before, and covers the transition from standard JavaScript to
    TypeScript. If you already have experience with TypeScript, and have a good understanding
    of the topics listed below, then by all means have a quick read through, or skip
    to the next chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是对TypeScript语言中用于将强类型应用于JavaScript的语法的介绍。它适用于以前没有使用过TypeScript的读者，并涵盖了从标准JavaScript过渡到TypeScript的过程。如果您已经有了TypeScript的经验，并且对下面列出的主题有很好的理解，那么请快速阅读一下，或者跳到下一章。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: 'Basic types and type syntax: strings, numbers, and booleans'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本类型和类型语法：字符串、数字和布尔值
- en: Inferred typing and duck-typing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推断类型和鸭子类型
- en: Arrays and enums
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和枚举
- en: The any type and explicit casting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任意类型和显式转换
- en: Functions and anonymous functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和匿名函数
- en: Optional and default function parameters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选和默认函数参数
- en: Argument arrays
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数数组
- en: Function callbacks and function signatures
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数回调和函数签名
- en: Function scoping rules and overloads
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作用域规则和重载
- en: Basic types
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本类型
- en: JavaScript variables can hold a number of data types, including numbers, strings,
    arrays, objects, functions, and more. The type of an object in JavaScript is determined
    by its assignment – so if a variable has been assigned a string value, then it
    will be of type string. This can, however, introduce a number of problems in our
    code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript变量可以保存多种数据类型，包括数字、字符串、数组、对象、函数等。JavaScript中对象的类型由其赋值确定——因此，如果一个变量被赋予了字符串值，那么它将是字符串类型。然而，这可能会在我们的代码中引入许多问题。
- en: JavaScript is not strongly typed
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript没有强类型
- en: 'As we saw in [Chapter 1](ch01.html "Chapter 1. TypeScript – Tools and Framework
    Options"), *TypeScript – Tools and Framework Options*, JavaScript objects and
    variables can be changed or reassigned on the fly. As an example of this, consider
    the following JavaScript code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](ch01.html "第1章。TypeScript – 工具和框架选项")中看到的，*TypeScript – 工具和框架选项*，JavaScript对象和变量可以在运行时更改或重新分配。例如，考虑以下JavaScript代码：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We start by defining three variables, named `myString`, `myNumber` and `myBoolean`.
    The `myString` variable is set to a string value of `"test"`, and as such will
    be of type `string`. Similarly, `myNumber` is set to the value of `1`, and is
    therefore of type `number`, and `myBoolean` is set to `true`, making it of type
    `boolean`. Now let''s start assigning these variables to each other, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义三个变量，名为`myString`，`myNumber`和`myBoolean`。`myString`变量设置为字符串值`"test"`，因此将是`string`类型。同样，`myNumber`设置为值`1`，因此是`number`类型，`myBoolean`设置为`true`，因此是`boolean`类型。现在让我们开始将这些变量相互赋值，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We start by setting the value of `myString` to the value of `myNumber` (which
    is the numeric value of `1`). We then set the value of `myBoolean` to the value
    of `myString`, (which would now be the numeric value of `1`). Finally, we set
    the value of `myNumber` to the value of `myBoolean`. What is happening here, is
    that even though we started out with three different types of variables—a string,
    a number, and a boolean—we are able to reassign any of these variables to one
    of the other types. We can assign a number to a string, a string to boolean, or
    a boolean to a number.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`myString`的值设置为`myNumber`的值（即数字值`1`）。然后将`myBoolean`的值设置为`myString`的值（现在将是数字值`1`）。最后，我们将`myNumber`的值设置为`myBoolean`的值。这里发生的是，即使我们最初有三种不同类型的变量——字符串、数字和布尔值——我们仍然能够将其中任何一个重新分配给另一种类型。我们可以将数字赋给字符串，字符串赋给布尔值，或者布尔值赋给数字。
- en: While this type of assignment in JavaScript is legal, it shows that the JavaScript
    language is not strongly typed. This can lead to unwanted behaviour in our code.
    Parts of our code may be relying on the fact that a particular variable is holding
    a string, and if we inadvertently assign a number to this variable, our code may
    start to break in unexpected ways.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在JavaScript中这种赋值是合法的，但它表明JavaScript语言并不是强类型的。这可能导致我们的代码出现意外的行为。我们的代码的某些部分可能依赖于一个特定变量保存一个字符串的事实，如果我们无意中将一个数字赋给这个变量，我们的代码可能会以意想不到的方式开始出现问题。
- en: TypeScript is strongly typed
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript是强类型的
- en: TypeScript, on the other hand, is a strongly typed language. Once you have declared
    a variable to be of type `string`, you can only assign `string` values to it.
    All further code that uses this variable must treat it as though it has a type
    of `string`. This helps to ensure that code that we write will behave as expected.
    While strong typing may not seem to be of any use with simple strings and numbers—it
    certainly does become important when we apply the same rules to objects, groups
    of objects, function definitions and classes. If you have written a function that
    expects a `string` as the first parameter and a `number` as the second, you cannot
    be blamed, if someone calls your function with a `boolean` as the first parameter
    and something else as the second.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，TypeScript是一种强类型语言。一旦你声明一个变量为`string`类型，你只能给它赋`string`值。所有进一步使用这个变量的代码必须将其视为`string`类型。这有助于确保我们编写的代码会按预期运行。虽然强类型在处理简单的字符串和数字时似乎没有任何用处，但当我们将相同的规则应用于对象、对象组、函数定义和类时，它确实变得重要。如果你编写了一个函数，期望第一个参数是`string`，第二个参数是`number`，如果有人用`boolean`作为第一个参数，另一个东西作为第二个参数调用你的函数，你是无法责怪的。
- en: JavaScript programmers have always relied heavily on documentation to understand
    how to call functions, and the order and type of the correct function parameters.
    But what if we could take all of this documentation and include it within the
    IDE? Then, as we write our code, our compiler could point out to us—automatically—that
    we were using objects and functions in the wrong way. Surely this would make us
    more efficient, more productive programmers, allowing us to generating code with
    fewer errors?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript程序员一直严重依赖文档来理解如何调用函数，以及正确的函数参数的顺序和类型。但是，如果我们能够将所有这些文档包含在IDE中呢？然后，当我们编写代码时，我们的编译器可以自动指出我们错误地使用了对象和函数。这肯定会使我们更高效，更有生产力的程序员，使我们能够生成更少错误的代码。
- en: TypeScript does exactly that. It introduces a very simple syntax to define the
    type of a variable or a function parameter to ensure that we are using these objects,
    variables, and functions in the correct manner. If we break any of these rules,
    the TypeScript compiler will automatically generate errors, pointing us to the
    lines of code that are in error.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript确实做到了这一点。它引入了一种非常简单的语法来定义变量或函数参数的类型，以确保我们以正确的方式使用这些对象、变量和函数。如果我们违反了这些规则，TypeScript编译器将自动生成错误，指出我们代码中的错误行。
- en: This is how TypeScript got its name. It is JavaScript with strong typing - hence
    TypeScript. Let's take a look at this very simple language syntax that enables
    the "Type" in TypeScript.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是TypeScript得名的原因。它是带有强类型的JavaScript - 因此是TypeScript。让我们来看看这种非常简单的语言语法，它使TypeScript中的“类型”成为可能。
- en: Type syntax
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型语法
- en: 'The TypeScript syntax for declaring the type of a variable is to include a
    colon (`:`), after the variable name, and then indicate its type. Consider the
    following TypeScript code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 声明变量类型的TypeScript语法是在变量名后面加上冒号（`:`），然后指定其类型。考虑以下TypeScript代码：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code snippet is the TypeScript equivalent of our preceding JavaScript
    code, and shows an example of the TypeScript syntax for declaring a type for the
    `myString` variable. By including a colon and then the keyword `string` (`: string`),
    we are telling the compiler that the `myString` variable is of type `string`.
    Similarly, the `myNumber` variable is of type `number`, and the `myBoolean` variable
    is of type `boolean`. TypeScript has introduced the `string`, `number` and `boolean`
    keywords for each of these basic JavaScript types.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '这段代码片段是我们前面的JavaScript代码的TypeScript等价物，并展示了为`myString`变量声明类型的TypeScript语法的示例。通过包括冒号和关键字`string`（`:
    string`），我们告诉编译器`myString`变量是`string`类型。同样，`myNumber`变量是`number`类型，`myBoolean`变量是`boolean`类型。TypeScript为每种基本JavaScript类型引入了`string`、`number`和`boolean`关键字。'
- en: 'If we attempt to assign a value to a variable that is not of the same type,
    the TypeScript compiler will generate a compile-time error. Given the variables
    declared in the preceding code, the following TypeScript code will generate some
    compile errors:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试将一个不同类型的值赋给一个变量，TypeScript编译器将生成编译时错误。在前面代码中声明的变量的情况下，以下TypeScript代码将生成一些编译错误：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Type syntax](img/9665OS_02-01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![类型语法](img/9665OS_02-01.jpg)'
- en: TypeScript build errors when assigning incorrect types
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在分配不正确的类型时，TypeScript生成构建错误
- en: The TypeScript compiler is generating compile errors, because we are attempting
    to mix these basic types. The first error is generated by the compiler because
    we cannot assign a `number` value to a variable of type `string`. Similarly, the
    second compile error indicates that we cannot assign a `string` value to a variable
    of type `boolean`. Again, the third error is generated because we cannot assign
    a `boolean` value to a variable of type `number`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器正在生成编译错误，因为我们试图混合这些基本类型。第一个错误是由编译器生成的，因为我们不能将`number`值赋给`string`类型的变量。同样，第二个编译错误表示我们不能将`string`值赋给`boolean`类型的变量。同样，第三个错误是因为我们不能将`boolean`值赋给`number`类型的变量。
- en: The strong typing syntax that the TypeScript language introduces, means that
    we need to ensure that the types on the left-hand side of an assignment operator
    (`=`) are the same as the types on the right-hand side of the assignment operator.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript语言引入的强类型语法意味着我们需要确保赋值操作符（`=`）左侧的类型与赋值操作符右侧的类型相同。
- en: 'To fix the preceding TypeScript code, and remove the compile errors, we would
    need to do something similar to the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复前面的TypeScript代码并消除编译错误，我们需要做类似以下的事情：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our first line of code has been changed to call the `.toString()` function on
    the `myNumber` variable (which is of type `number`), in order to return a value
    that is of type `string`. This line of code, then, does not generate a compile
    error because both sides of the equal sign are of the same type.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一行代码已更改为在`myNumber`变量（类型为`number`）上调用`.toString()`函数，以返回一个`string`类型的值。这行代码不会生成编译错误，因为等号两边的类型相同。
- en: Our second line of code has also been changed so that the right hand side of
    the assignment operator returns the result of a comparison, `myString === "test"`,
    which will return a value of type `boolean`. The compiler will therefore allow
    this code, because both sides of the assignment resolve to a value of type `boolean`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二行代码也已更改，以便赋值操作符的右侧返回比较的结果，`myString === "test"`，这将返回一个`boolean`类型的值。因此，编译器将允许这段代码，因为赋值的两侧都解析为`boolean`类型的值。
- en: The last line of our code snippet has been changed to only assign the value
    `1` (which is of type `number`) to the `myNumber` variable, if the value of the
    `myBoolean` variable is `true`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码片段的最后一行已更改为仅在`myBoolean`变量的值为`true`时将值`1`（类型为`number`）赋给`myNumber`变量。
- en: Anders Hejlsberg describes this feature as "syntactic sugar". With a little
    sugar on top of comparable JavaScript code, TypeScript has enabled our code to
    conform to strong typing rules. Whenever you break these strong typing rules,
    the compiler will generate errors for your offending code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Anders Hejlsberg将这一特性描述为“语法糖”。通过在可比较的JavaScript代码上添加一些糖，TypeScript使我们的代码符合了强类型规则。每当你违反这些强类型规则时，编译器都会为你的有问题的代码生成错误。
- en: Inferred typing
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推断类型
- en: 'TypeScript also uses a technique called inferred typing, in cases where you
    do not explicitly specify the type of your variable. In other words, TypeScript
    will find the first usage of a variable within your code, figure out what type
    the variable is first initialized to, and then assume the same type for this variable
    in the rest of your code block. As an example of this, consider the following
    code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript还使用了一种叫做推断类型的技术，在你没有明确指定变量类型的情况下。换句话说，TypeScript会找到代码中变量的第一次使用，找出变量最初初始化的类型，然后假定在代码块的其余部分中该变量的类型相同。举个例子，考虑以下代码：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We start by declaring a variable named `myString`, and assign a string value
    to it. TypeScript identifies that this variable has been assigned a value of type
    `string`, and will, therefore, infer any further usages of this variable to be
    of type `string`. Our second variable, named `myNumber` has a number assigned
    to it. Again, TypeScript is inferring the type of this variable to be of type
    `number`. If we then attempt to assign the `myString` variable (of type `string`)
    to the `myNumber` variable (of type `number`) in the last line of code, TypeScript
    will generate a familiar error message:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明了一个名为`myString`的变量，并给它赋了一个字符串值。TypeScript确定这个变量被赋予了`string`类型的值，因此会推断出这个变量的任何进一步使用都是`string`类型。我们的第二个变量，名为`myNumber`，被赋予了一个数字。同样，TypeScript推断出这个变量的类型是`number`。如果我们尝试在代码的最后一行将`myString`变量（类型为`string`）赋给`myNumber`变量（类型为`number`），TypeScript将生成一个熟悉的错误消息：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This error is generated because of TypeScript's inferred typing rules.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误是由于TypeScript的推断类型规则所生成的。
- en: Duck-typing
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鸭子类型
- en: 'TypeScript also uses a method called duck-typing for more complex variable
    types. Duck-typing means that if it looks like a duck, and quacks like a duck,
    then it probably is a duck. Consider the following TypeScript code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript还对更复杂的变量类型使用了一种叫做鸭子类型的方法。鸭子类型意味着如果它看起来像鸭子，叫起来像鸭子，那么它很可能就是鸭子。考虑以下TypeScript代码：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We start with a variable named `complexType` that has been assigned a simple
    JavaScript object with a `name` and `id` property. On our second line of code,
    we can see that we are re-assigning the value of this `complexType` variable to
    another object that also has an `id` and a `name` property. The compiler will
    use duck-typing in this instance to figure out whether this assignment is valid.
    In other words, if an object has the same set of properties as another object,
    then they are considered to be of the same type.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个名为`complexType`的变量开始，它被赋予了一个包含`name`和`id`属性的简单JavaScript对象。在我们的第二行代码中，我们可以看到我们正在重新分配这个`complexType`变量的值给另一个也有`id`和`name`属性的对象。编译器将在这种情况下使用鸭子类型来判断这个赋值是否有效。换句话说，如果一个对象具有与另一个对象相同的属性集，那么它们被认为是相同类型的。
- en: 'To further illustrate this point, let''s see how the compiler reacts if we
    attempt to assign an object to our `complexType` variable that does not conform
    to this duck-typing:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明这一点，让我们看看编译器在我们尝试将一个不符合鸭子类型的对象分配给我们的`complexType`变量时的反应：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first line of this code snippet defines our `complexType` variable, and
    assigns to it an object that contains both an `id` and `name` property. From this
    point, TypeScript will use this inferred type on any value we attempt to assign
    to the `complexType` variable. On our second line of code, we are attempting to
    assign a value that has an `id` property but not the `name` property. On the third
    line of code, we again attempt to assign a value that has a `name` property, but
    does not have an `id` property. On the last line of our code snippet, we have
    completely missed the mark. Compiling this code will generate the following errors:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段的第一行定义了我们的`complexType`变量，并将一个包含`id`和`name`属性的对象赋给它。从这一点开始，TypeScript将在我们尝试分配给`complexType`变量的任何值上使用这个推断类型。在我们的第二行代码中，我们尝试分配一个具有`id`属性但没有`name`属性的值。在第三行代码中，我们再次尝试分配一个具有`name`属性但没有`id`属性的值。在代码片段的最后一行，我们完全错了。编译这段代码将生成以下错误：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see from the error messages, TypeScript is using duck-typing to ensure
    type safety. In each message, the compiler gives us clues as to what is wrong
    with the offending code – by explicitly stating what it is expecting. The `complexType`
    variable has both an `id` and a `name` property. To assign a value to the `complexType`
    variable, then, this value will need to have both an `id` and a `name` property.
    Working through each of these errors, TypeScript is explicitly stating what is
    wrong with each line of code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从错误消息中我们可以看到，TypeScript使用鸭子类型来确保类型安全。在每条消息中，编译器都给出了关于有问题的代码的线索 - 明确说明了它期望的内容。`complexType`变量既有`id`属性，也有`name`属性。因此，要给`complexType`变量赋值，这个值将需要同时具有`id`和`name`属性。通过处理每一个错误，TypeScript都明确说明了每一行代码的问题所在。
- en: 'Note that the following code will not generate any error messages:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以下代码不会生成任何错误消息：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Again, our first line of code defines the `complexType` variable, as we have
    seen previously, with an `id` and a `name` property. Now, look at the second line
    of this example. The object we are using actually has three properties: `name`,
    `id`, and `address`. Even though we have added a new `address` property, the compiler
    will only check to see if our new object has both an `id` and a `name`. Because
    our new object has these properties, and will therefore match the original type
    of the variable, TypeScript will allow this assignment through duck-typing.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们的第一行代码定义了 `complexType` 变量，就像我们之前看到的那样，具有 `id` 和 `name` 属性。现在，看一下这个例子的第二行。我们正在使用的对象实际上有三个属性：`name`、`id`
    和 `address`。即使我们添加了一个新的 `address` 属性，编译器只会检查我们的新对象是否同时具有 `id` 和 `name`。因为我们的新对象具有这些属性，因此将匹配变量的原始类型，TypeScript
    将允许通过鸭子类型进行此赋值。
- en: Inferred typing and duck-typing are powerful features of the TypeScript language
    – bringing strong typing to our code, without the need to use explicit typing,
    that is, a colon `:` and then the type specifier syntax.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 推断类型和鸭子类型是 TypeScript 语言的强大特性——为我们的代码带来了强类型，而无需使用显式类型，即冒号 `:` 然后是类型说明符语法。
- en: Arrays
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'Besides the base JavaScript types of string, number, and boolean, TypeScript
    has two other data types: Arrays and enums. Let''s look at the syntax for defining
    arrays.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的 JavaScript 类型字符串、数字和布尔值之外，TypeScript 还有两种其他数据类型：数组和枚举。让我们看一下定义数组的语法。
- en: 'An array is simply marked with the `[]` notation, similar to JavaScript, and
    each array can be strongly typed to hold a specific type as seen in the code below:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 数组只是用 `[]` 符号标记，类似于 JavaScript，并且每个数组可以被强类型化以保存特定类型，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: On the first line of this code snippet, we are defining an array named `arrayOfNumbers`,
    and further specify that each element of this array must be of type `number`.
    The second line then reassigns this array to hold some different numerical values.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段的第一行，我们定义了一个名为 `arrayOfNumbers` 的数组，并进一步指定该数组的每个元素必须是 `number` 类型。然后，第二行重新分配了这个数组以保存一些不同的数值。
- en: 'The last line of this snippet, however, will generate the following error message:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个片段的最后一行将生成以下错误消息：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This error message is warning us that the variable `arrayOfNumbers` is strongly
    typed to only accept values of type `number`. Our code tries to assign an array
    of strings to this array of numbers, and is therefore, generating a compile error.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误消息警告我们，变量 `arrayOfNumbers` 的强类型只接受 `number` 类型的值。我们的代码试图将一个字符串数组赋给这个数字数组，因此会生成一个编译错误。
- en: The any type
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任意类型
- en: 'All this type checking is well and good, but JavaScript is flexible enough
    to allow variables to be mixed and matched. The following code snippet is actually
    valid JavaScript code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类型检查都很好，但 JavaScript 足够灵活，允许变量混合使用。以下代码片段实际上是有效的 JavaScript 代码：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our first line of code assigns an object with an `id` property and a `name`
    property to the variable `item1`. The second line then re-assigns this variable
    to an object that has an `id` property but not a `name` property. Unfortunately,
    as we have seen previously, TypeScript will generate a compile time error for
    the preceding code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一行代码将一个具有 `id` 属性和 `name` 属性的对象分配给变量 `item1`。然后，第二行将这个变量重新分配给一个只有 `id` 属性而没有
    `name` 属性的对象。不幸的是，正如我们之前所见，TypeScript 会为前面的代码生成一个编译时错误：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'TypeScript introduces the `any` type for such occasions. Specifying that an
    object has a type of `any` in essence relaxes the compiler''s strict type checking.
    The following code shows how to use the `any` type:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 为这种情况引入了 `any` 类型。在本质上，指定对象的类型为 `any` 会放宽编译器的严格类型检查。以下代码显示了如何使用 `any`
    类型：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note how our first line of code has changed. We specify the type of the variable
    `item1` to be of type `: any` so that our code will compile without errors. Without
    the type specifier of `: any`, the second line of code, would normally generate
    an error.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '注意我们的第一行代码已经改变。我们指定变量 `item1` 的类型为 `: any`，这样我们的代码就可以编译而不会出错。没有类型说明符 `: any`，第二行代码通常会生成一个错误。'
- en: Explicit casting
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式转换
- en: As with any strongly typed language, there comes a time where you need to explicitly
    specify the type of an object. This concept will be expanded upon more thoroughly
    in the next chapter, but it is worthwhile to make a quick note of explicit casting
    here. An object can be cast to the type of another by using the `< >` syntax.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何强类型语言一样，总有一个时刻需要明确指定对象的类型。这个概念将在下一章中更加详细地展开，但在这里快速记录显式转换是值得的。可以使用 `< >` 语法将一个对象转换为另一个对象的类型。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is not a cast in the strictest sense of the word; it is more of an assertion
    that is used at runtime by the TypeScript compiler. Any explicit casting that
    you use will be compiled away in the resultant JavaScript and will not affect
    the code at runtime.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是严格意义上的转换；它更像是 TypeScript 编译器在运行时使用的断言。您使用的任何显式转换都将在生成的 JavaScript 中被编译掉，并且不会影响运行时的代码。
- en: 'Let''s modify our previous code snippet to use explicit casting:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改之前的代码片段来使用显式转换：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that on the first line of this snippet, we have now replaced the `: any`
    type specifier on the left hand side of the assignment, with an explicit cast
    of `<any>` on the right hand side. This snippet of code is telling the compiler
    to explicitly cast, or to explicitly treat the `{ id: 1, name: "item 1" }` object
    on the right-hand side as a type of `any`. So the `item1` variable, therefore,
    also has the type of `any` (due to TypeScript''s inferred typing rules). This
    then allows us to assign an object with only the `{ id: 2 }` property to the variable
    `item1` on the second line of code. This technique of using the `< >` syntax on
    the right hand side of an assignment, is called explicit casting.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，在这段代码片段的第一行，我们现在已经用右边的`<any>`显式转换替换了赋值左边的`: any`类型指定符。这段代码片段告诉编译器显式地转换，或者显式地将右边的`{
    id: 1, name: "item 1" }`对象作为`any`类型处理。因此，`item1`变量也因此具有`any`类型（由于TypeScript的推断类型规则）。这样就允许我们在代码的第二行将只有`{
    id: 2 }`属性的对象赋值给变量`item1`。在赋值的右边使用`< >`语法的这种技术称为显式转换。'
- en: 'While the `any` type is a necessary feature of the TypeScript language – its
    usage should really be limited as much as possible. It is a language shortcut
    that is necessary to ensure compatibility with JavaScript, but over-use of the
    `any` type will quickly lead to coding errors that will be difficult to find.
    Rather than using the type `any`, try to figure out the correct type of the object
    you are using, and then use this type instead. We use an acronym within our programming
    teams: **S.F.I.A.T.** (pronounced sviat or sveat). **Simply Find an Interface
    for the Any Type**. While this may sound silly – it brings home the point that
    the `any` type should always be replaced with an interface – so simply find it.
    An interface is a way of defining custom types in TypeScript, and we will cover
    interfaces in the next chapter. Just remember that by actively trying to define
    what an object''s type should be, we are building strongly typed code, and therefore
    protecting ourselves from future coding errors and bugs.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`any`类型是TypeScript语言的一个必要特性，但它的使用应尽可能受到限制。它是一种确保与JavaScript兼容性的语言快捷方式，但过度使用`any`类型会很快导致难以发现的编码错误。与其使用`any`类型，不如尝试找出你正在使用的对象的正确类型，然后使用这种类型。我们在编程团队内使用一个缩写：**S.F.I.A.T.**（读作sviat或sveat）。**Simply
    Find an Interface for the Any Type**。虽然这听起来有些愚蠢，但它强调了`any`类型应该总是被接口替换，所以只需找到它。接口是在TypeScript中定义自定义类型的一种方式，我们将在下一章中介绍接口。只需记住，通过积极尝试定义对象的类型应该是什么，我们正在构建强类型代码，因此保护自己免受未来的编码错误和错误的影响。
- en: Enums
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: 'Enums are a special type that has been borrowed from other languages such as
    C#, and provide a solution to the problem of special numbers. An enum associates
    a human-readable name for a specific number. Consider the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是从其他语言（如C#）借鉴过来的一种特殊类型，它提供了解决特殊数字问题的解决方案。枚举将人类可读的名称与特定数字关联起来。考虑以下代码：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this code snippet, we have defined an `enum` called `DoorState` to represent
    the state of a door. Valid values for this door state are `Open`, `Closed`, or
    `Ajar`. Under the hood (in the generated JavaScript), TypeScript will assign a
    numeric value to each of these human-readable enum values. In this example, the
    `DoorState.Open` enum value will equate to a numeric value of `0`. Likewise, the
    enum value `DoorState.Closed` will be equate to the numeric value of `1`, and
    the `DoorState.Ajar` enum value will equate to `2`. Let''s have a quick look at
    how we would use these enum values:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，我们定义了一个名为`DoorState`的`enum`，用于表示门的状态。这个门状态的有效值是`Open`、`Closed`或`Ajar`。在底层（在生成的JavaScript中），TypeScript将为这些人类可读的枚举值分配一个数值。在这个例子中，`DoorState.Open`的枚举值将等于数值`0`。同样，枚举值`DoorState.Closed`将等于数值`1`，而`DoorState.Ajar`的枚举值将等于`2`。让我们快速看一下我们将如何使用这些枚举值：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first line within the `window.onload` function creates a variable named
    `myDoor`, and sets its value to `DoorState.Open`. The second line simply logs
    the value of `myDoor` to the console. The output of this `console.log` function
    would be:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.onload`函数中的第一行创建了一个名为`myDoor`的变量，并将其值设置为`DoorState.Open`。第二行只是将`myDoor`的值记录到控制台。这个`console.log`函数的输出将是：'
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This clearly shows that the TypeScript compiler has substituted the enum value
    of `DoorState.Open` with the numeric value `0`. Now let''s use this enum in a
    slightly different way:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地显示了TypeScript编译器已经用数值`0`替换了`DoorState.Open`的枚举值。现在让我们以稍微不同的方式使用这个枚举：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code snippet uses a string value of "Closed" to lookup the `enum` type,
    and assign the resulting enum value to the `openDoor` variable. The output of
    this code would be:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段使用字符串值"Closed"来查找`enum`类型，并将结果的枚举值赋给`openDoor`变量。这段代码的输出将是：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This sample clearly shows that the enum value of `DoorState.Closed` is the
    same as the enum value of `DoorState["Closed"]`, because both variants resolve
    to the numeric value of `1`. Finally, let''s have a look at what happens when
    we reference an enum using an array type syntax:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例清楚地显示了`DoorState.Closed`的枚举值与`DoorState["Closed"]`的枚举值相同，因为两种变体都解析为`1`的数值。最后，让我们看看当我们使用数组类型语法引用枚举时会发生什么：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we assign the variable `openDoor` to an enum value based on the 2nd index
    value of the `DoorState` enum. The output of this code, though, is surprising:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将变量`openDoor`赋值为基于`DoorState`枚举的第二个索引值的枚举值。然而，这段代码的输出令人惊讶：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You may have been expecting the output to be simply `2`, but here we are getting
    the string `"Ajar"` – which is a string representation of our original enum name.
    This is actually a neat little trick – allowing us to access a string representation
    of our enum value. The reason that this is possible is down to the JavaScript
    that has been generated by the TypeScript compiler. Let''s have a look, then,
    at the closure that the TypeScript compiler has generated:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能期望输出只是`2`，但这里我们得到的是字符串`"Ajar"` - 这是我们原始枚举名称的字符串表示。这实际上是一个巧妙的小技巧 - 允许我们访问枚举值的字符串表示。这种可能性的原因在于TypeScript编译器生成的JavaScript。让我们看一下TypeScript编译器生成的闭包：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This strange looking syntax is building an object that has a specific internal
    structure. It is this internal structure that allows us to use this enum in the
    various ways that we have just explored. If we interrogate this structure while
    debugging our JavaScript, we will see the internal structure of the `DoorState`
    object is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种看起来很奇怪的语法正在构建一个具有特定内部结构的对象。正是这种内部结构使我们能够以刚刚探索的各种方式使用这个枚举。如果我们在调试JavaScript时查询这个结构，我们将看到`DoorState`对象的内部结构如下：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `DoorState` object has a property called `"0"`, which has a string value
    of `"Open"`. Unfortunately, in JavaScript the number `0` is not a valid property
    name, so we cannot access this property by simply using `DoorState.0`. Instead,
    we must access this property using either `DoorState[0]` or `DoorState["0"]`.
    The `DoorState` object also has a property named `Open`, which is set to the numeric
    value `0`. The word `Open` IS a valid property name in JavaScript, so we can access
    this property using `DoorState["Open"]`, or simply `DoorState.Open`, which equate
    to the same property in JavaScript.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoorState`对象有一个名为`"0"`的属性，其字符串值为`"Open"`。不幸的是，在JavaScript中，数字`0`不是有效的属性名称，因此我们不能简单地使用`DoorState.0`来访问此属性。相反，我们必须使用`DoorState[0]`或`DoorState["0"]`来访问此属性。`DoorState`对象还有一个名为`Open`的属性，其值设置为数字`0`。在JavaScript中，`Open`是一个有效的属性名称，因此我们可以使用`DoorState["Open"]`或简单地`DoorState.Open`来访问此属性，这在JavaScript中等同于同一个属性。'
- en: While the underlying JavaScript can be a little confusing, all we need to remember
    about enums is that they are a handy way of defining an easily remembered, human-readable
    name to a special number. Using human-readable enums, instead of just scattering
    various special numbers around in our code, also makes the intent of the code
    clearer. Using an application wide value named `DoorState.Open` or `DoorState.Closed`
    is far simpler than remembering to set a value to `0` for `Open`, `1` for `Closed`,
    and `3` for `ajar`. As well as making our code more readable, and more maintainable,
    using enums also protects our code base whenever these special numeric values
    change – because they are all defined in one place.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管底层的JavaScript可能有点令人困惑，但我们需要记住的是，枚举是一种方便的方式，可以为特殊数字定义一个易于记忆和人类可读的名称。使用易于阅读的枚举，而不是在代码中散布各种特殊数字，也使代码的意图更加清晰。使用应用程序范围的值`DoorState.Open`或`DoorState.Closed`比记住为`Open`设置值为`0`，`Closed`设置值为`1`，`ajar`设置值为`3`要简单得多。除了使我们的代码更易读、更易维护外，使用枚举还可以在这些特殊数字值发生变化时保护我们的代码库，因为它们都在一个地方定义了。
- en: 'One last note on enums – we can set the numeric value manually, if needs be:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 关于枚举的最后一点说明 - 如果需要，我们可以手动设置数值：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we have overridden the default values of the enum to set `DoorState.Open`
    to `3`, `DoorState.Closed` to `7`, and `DoorState.Ajar` to `10`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经覆盖了枚举的默认值，将`DoorState.Open`设置为`3`，`DoorState.Closed`设置为`7`，`DoorState.Ajar`设置为`10`。
- en: Const enums
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Const枚举
- en: 'With the release of TypeScript 1.4, we are also able to define `const` enums
    as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 随着TypeScript 1.4的发布，我们还可以定义`const`枚举如下：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'These types of enums have been introduced largely for performance reasons,
    and the resultant JavaScript will not contain the full closure definition for
    the `DoorStateConst` enum as we saw previously. Let''s have a quick look at the
    JavaScript that is generated from this `DoorStateConst` enum:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的枚举主要是出于性能原因引入的，由此产生的JavaScript将不包含我们之前看到的`DoorStateConst`枚举的完整闭包定义。让我们快速看一下从这个`DoorStateConst`枚举生成的JavaScript：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note how we do not have a full JavaScript closure for the `DoorStateConstenum`
    at all. The compiler has simply resolved the `DoorStateConst.Open` enum to its
    internal value of `0`, and removed the `const enum` definition entirely.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们根本没有完整的JavaScript闭包`DoorStateConstenum`。编译器只是将`DoorStateConst.Open`枚举解析为其内部值`0`，并完全删除了`const
    enum`定义。
- en: 'With const enums, we therefore cannot reference the internal string value of
    an enum, as we did in our previous code sample. Consider the following example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用const枚举时，我们无法引用枚举的内部字符串值，就像我们在之前的代码示例中所做的那样。考虑以下示例：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first `console.log` statement will now generate a compile time error –
    as we do not have the full closure available with the property of `[0]` for our
    const enum. The second usage of this `const` enum is valid, however, and will
    generate the following JavaScript:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`console.log`语句现在将生成一个编译时错误 - 因为我们没有完整的闭包可用于我们的const枚举的`[0]`属性。然而，这个`const`枚举的第二个用法是有效的，并将生成以下JavaScript：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When using const enums, just keep in mind that the compiler will strip away
    all enum definitions and simply substitute the numeric value of the enum directly
    into our JavaScript code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用const枚举时，只需记住编译器将剥离所有枚举定义，并直接将枚举的数值替换到我们的JavaScript代码中。
- en: Functions
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'JavaScript defines functions using the `function` keyword, a set of braces,
    and then a set of curly braces. A typical JavaScript function would be written
    as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript使用`function`关键字、一组大括号，然后是一组花括号来定义函数。典型的JavaScript函数将被编写如下：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code snippet is fairly self-explanatory; we have defined a function named
    `addNumbers` that takes two variables and returns their sum. We then invoke this
    function, passing in the values of `1` and `2`. The value of the variable `result`
    would then be `1` + `2`, which is `3`. Now have a look at the last line of code.
    Here, we are invoking the `addNumbers` function, passing in two strings as arguments,
    instead of numbers. The value of the variable `result2` would then be a string,
    `"12"`. This string value seems like it may not be the desired result, as the
    name of the function is `addNumbers`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很容易理解；我们定义了一个名为`addNumbers`的函数，它接受两个变量并返回它们的和。然后我们调用这个函数，传入`1`和`2`的值。变量`result`的值将是`1`
    + `2`，即`3`。现在看看代码的最后一行。在这里，我们调用`addNumbers`函数，传入两个字符串作为参数，而不是数字。变量`result2`的值将是一个字符串`"12"`。这个字符串值似乎可能不是期望的结果，因为函数的名称是`addNumbers`。
- en: 'Copying the preceding code into a TypeScript file would not generate any errors,
    but let''s insert some type rules to the preceding JavaScript to make it more
    robust:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码复制到一个TypeScript文件中不会生成任何错误，但让我们在前面的JavaScript中插入一些类型规则，使其更加健壮：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this TypeScript code, we have added a `:number` type to both of the parameters
    of the `addNumbers` function (`a` and `b`), and we have also added a `:number`
    type just after the `( )` braces. Placing a type descriptor here means that the
    return type of the function itself is strongly typed to return a value of type
    `number`. In TypeScript, the last line of code, however, will cause a compilation
    error:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个TypeScript代码中，我们为`addNumbers`函数的两个参数`a`和`b`添加了`:number`类型，并且在`( )`括号后面也添加了`:number`类型。在这里放置类型描述符意味着函数本身的返回类型被强制类型化为返回一个`number`类型的值。然而，在TypeScript中，代码的最后一行将导致编译错误：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This error message is generated because we have explicitly stated that the function
    should accept only numbers for both of the arguments `a` and `b`, but in our offending
    code, we are passing two strings. The TypeScript compiler, therefore, cannot match
    the signature of a function named `addNumbers` that accepts two arguments of type
    `string`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误消息是由于我们明确声明了函数应该只接受`number`类型的两个参数`a`和`b`，但在我们的错误代码中，我们传递了两个字符串。因此，TypeScript编译器无法匹配一个名为`addNumbers`的函数的签名，该函数接受两个`string`类型的参数。
- en: Anonymous functions
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数
- en: 'The JavaScript language also has the concept of anonymous functions. These
    are functions that are defined on the fly and don''t specify a function name.
    Consider the following JavaScript code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript语言也有匿名函数的概念。这些是在定义时即时定义的函数，不指定函数名称。考虑以下JavaScript代码：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This code snippet defines a function that has no name and adds two values. Because
    the function does not have a name, it is known as an anonymous function. This
    anonymous function is then assigned to a variable named `addVar`. The `addVar`
    variable, then, can then be invoked as a function with two parameters, and the
    return value will be the result of executing the anonymous function. In this case,
    the variable `result` will have a value of `3`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个没有名称的函数，它添加了两个值。因为这个函数没有名称，所以它被称为匿名函数。然后将这个匿名函数分配给一个名为`addVar`的变量。然后，`addVar`变量可以作为一个函数调用，带有两个参数，并且返回值将是执行匿名函数的结果。在这种情况下，变量`result`将具有值`3`。
- en: 'Let''s now rewrite the preceding JavaScript function in TypeScript, and add
    some type syntax, in order to ensure that the function only accepts two arguments
    of type `number`, and returns a value of type `number`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用TypeScript重写前面的JavaScript函数，并添加一些类型语法，以确保函数只接受两个`number`类型的参数，并返回一个`number`类型的值：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this code snippet, we have created an anonymous function that accepts only
    arguments of type `number` for the parameters `a` and `b`, and also returns a
    value of type `number`. The types for both the `a` and `b` parameters, as well
    as the return type of the function, are now using the `:number` syntax. This is
    another example of the simple "syntactic sugar" that TypeScript injects into the
    language. If we compile this code, TypeScript will reject the code on the last
    line, where we try to call our anonymous function with two string parameters:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们创建了一个匿名函数，它只接受类型为`number`的参数`a`和`b`，并且返回类型为`number`的值。现在`a`和`b`参数的类型，以及函数的返回类型，都使用了`:number`语法。这是TypeScript注入到语言中的另一个简单的“语法糖”的例子。如果我们编译这段代码，TypeScript将拒绝最后一行的代码，在这里我们尝试用两个字符串参数调用我们的匿名函数：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Optional parameters
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选参数
- en: 'When we call a JavaScript function that has is expecting parameters, and we
    do not supply these parameters, then the value of the parameter within the function
    will be `undefined`. As an example of this, consider the following JavaScript
    code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用一个期望参数的JavaScript函数，并且我们没有提供这些参数时，函数内部的参数值将是`undefined`。作为这一点的例子，考虑以下JavaScript代码：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we have defined a function called `concatStrings` that takes three parameters,
    `a`, `b`, and `c`, and simply returns the sum of these values. If we call this
    function with all three parameters, as seen in the second last line of this snipped,
    we will end up with the string `"abc"` logged to the console. If, however, we
    only supply two parameters, as seen in the last line of this snippet, the string
    `"abundefined"` will be logged to the console. Again, if we call a function and
    do not supply a parameter, then this parameter, `c` in our case, will be simply
    `undefined`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`concatStrings`的函数，它接受三个参数`a`、`b`和`c`，并简单地返回这些值的总和。如果我们使用所有三个参数调用这个函数，就像在这个片段的倒数第二行中看到的那样，我们将在控制台中得到字符串`"abc"`。然而，如果我们只提供两个参数，就像在这个片段的最后一行中看到的那样，将在控制台中得到字符串`"abundefined"`。再次，如果我们调用一个函数并且不提供参数，那么这个参数，在我们的例子中是`c`，将简单地是`undefined`。
- en: 'TypeScript introduces the question mark `?` syntax to indicate optional parameters.
    Consider the following TypeScript function definition:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript引入了问号`?`语法来表示可选参数。考虑以下TypeScript函数定义：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is a strongly typed version of the original `concatStrings` JavaScript
    function that we were using previously. Note the addition of the `?` character
    in the syntax for the third parameter: `c?: string`. This indicates that the third
    parameter is optional, and therefore, all of the preceding code will compile cleanly,
    except for the last line. The last line will generate an error:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '这是原始`concatStrings` JavaScript函数的强类型版本，我们之前使用过。请注意在第三个参数的语法中添加了`?`字符：`c?: string`。这表示第三个参数是可选的，因此，除了最后一行之外，所有前面的代码都将编译成功。最后一行将生成一个错误：'
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This error is generated because we are attempting to call the `concatStrings`
    function with only a single parameter. Our function definition, though, requires
    at least two parameters, with only the third parameter being optional.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误是因为我们试图用只有一个参数调用`concatStrings`函数。然而，我们的函数定义要求至少有两个参数，只有第三个参数是可选的。
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The optional parameters must be the last parameters in the function definition.
    You can have as many optional parameters as you want, as long as non-optional
    parameters precede the optional parameters.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数必须是函数定义中的最后一个参数。只要非可选参数在可选参数之前，你可以有任意数量的可选参数。
- en: Default parameters
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认参数
- en: 'A subtle variant on the optional parameter function definition, allows us to
    specify the default value of a parameter if it is not passed in as an argument
    from the calling code. Let''s modify our preceding function definition to use
    an optional parameter:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数函数定义的微妙变体允许我们指定参数的默认值，如果它没有从调用代码中作为参数传递进来。让我们修改前面的函数定义来使用可选参数：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This function definition has now dropped the `?` optional parameter syntax,
    but instead has assigned a value of `"c"` to the last parameter: `c:string = "c"`.
    By using default parameters, if we do not supply a value for the final parameter
    named `c`, the `concatStrings` function will substitute the default value of `"c"`
    instead. The argument `c`, therefore, will not be `undefined`. The output of the
    last two lines of code will both be `"abc"`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数定义现在已经去掉了`?`可选参数的语法，而是给最后一个参数赋了一个值："c:string = "c"。通过使用默认参数，如果我们没有为最后一个参数命名为`c`提供一个值，`concatStrings`函数将会用默认值"c"来替代。因此参数`c`将不会是`undefined`。最后两行代码的输出都将是"abc"。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that using the default parameter syntax will automatically make the parameter
    optional.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用默认参数语法将自动使参数变为可选。
- en: The arguments variable
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数变量
- en: 'The JavaScript language allows a function to be called with a variable number
    of arguments. Every JavaScript function has access to a special variable, named
    `arguments`, that can be used to retrieve all arguments that have been passed
    into the function. As an example of this, consider the following JavaScript code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript语言允许一个函数被调用时带有可变数量的参数。每个JavaScript函数都可以访问一个特殊的变量，名为`arguments`，它可以用来检索传递给函数的所有参数。例如，考虑以下JavaScript代码：
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In this code snippet, we have defined a function name `testParams` that does
    not have any named parameters. Note, though, that we can use the special variable,
    named `arguments`, to test whether the function was called with any arguments.
    In our sample, we can simply loop through the `arguments` array, and log the value
    of each argument to the console, by using an array indexer : `arguments[i]`. The
    output of the console.log calls are as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们定义了一个名为`testParams`的函数，没有任何命名参数。但请注意，我们可以使用特殊变量`arguments`来测试函数是否被调用了任何参数。在我们的示例中，我们可以简单地遍历`arguments`数组，并通过使用数组索引器`arguments[i]`将每个参数的值记录到控制台中。console.log调用的输出如下：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'So, how do we express a variable number of function parameters in TypeScript?
    The answer is to use what are called rest parameters, or the three dots (`…`)
    syntax. Here is the equivalent `testParams` function, expressed in TypeScript:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在TypeScript中如何表示可变数量的函数参数呢？答案是使用所谓的剩余参数，或者三个点(`…`)的语法。下面是用TypeScript表达的等价`testParams`函数：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Note the use of the `…argArray: number[]` syntax for our `testParams` function.
    This syntax is telling the TypeScript compiler that the function can accept any
    number of arguments. This means that our usages of this function, i.e. calling
    the function with either `testParams(1)` or `testParams(1,2,3,4)`, will both compile
    correctly. In this version of the `testParams` function, we have added two `console.log`
    lines, just to show that the `arguments` array can be accessed by either the named
    rest parameter, `argArray[i]`, or through the normal JavaScript array, `arguments[i]`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意我们的`testParams`函数使用了`…argArray: number[]`的语法。这个语法告诉TypeScript编译器函数可以接受任意数量的参数。这意味着我们对这个函数的使用，即用`testParams(1)`或`testParams(1,2,3,4)`调用函数，都将正确编译。在这个版本的`testParams`函数中，我们添加了两个`console.log`行，只是为了展示`arguments`数组可以通过命名的剩余参数`argArray[i]`或通过普通的JavaScript数组`arguments[i]`来访问。'
- en: The last line in this sample will, however, generate a compile error, as we
    have defined the rest parameter to only accept numbers, and we are attempting
    to call the function with strings.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，最后一行将会生成一个编译错误，因为我们已经定义了剩余参数只接受数字，而我们正试图用字符串调用这个函数。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The the subtle difference between using `argArray` and `arguments` is the inferred
    type of the argument. Since we have explicitly specified that `argArray` is of
    type `number`, TypeScript will treat any item of the `argArray` array as a number.
    However, the internal `arguments` array does not have an inferred type, and so
    will be treated as the `any` type.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`argArray`和`arguments`的微妙差异在于参数的推断类型。由于我们明确指定了`argArray`的类型为`number`，TypeScript将把`argArray`数组的任何项都视为数字。然而，内部的`arguments`数组没有推断类型，因此将被视为`any`类型。
- en: 'We can also combine normal parameters along with rest parameters in a function
    definition, as long as the rest parameters are the last to be defined in the parameter
    list, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在函数定义中结合普通参数和剩余参数，只要剩余参数是参数列表中的最后一个定义，如下所示：
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we have two normal parameters named `arg1` and `arg2` and then an `argArray`
    rest parameter. Mistakenly placing the rest parameter at the beginning of the
    parameter list will generate a compile error.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个名为`arg1`和`arg2`的普通参数，然后是一个`argArray`剩余参数。错误地将剩余参数放在参数列表的开头将生成一个编译错误。
- en: Function callbacks
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数回调
- en: 'One of the most powerful features of JavaScript–and in fact the technology
    that Node was built on–is the concept of callback functions. A callback function
    is a function that is passed into another function. Remember that JavaScript is
    not strongly typed, so a variable can also be a function. This is best illustrated
    by having a look at some JavaScript code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript最强大的特性之一，事实上也是Node技术构建的基础，就是回调函数的概念。回调函数是传递到另一个函数中的函数。请记住JavaScript不是强类型的，所以变量也可以是一个函数。通过查看一些JavaScript代码来最好地说明这一点：
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here, we have a function named `myCallBack` that takes a parameter and logs
    its value to the console. We then define a function named `callingFunction` that
    takes two parameters: `initialText` and `callback`. The first line of this funciton
    simply logs `"inside CallingFunction"` to the console. The second line of the
    `callingFunction` is the interesting bit. It assumes that the `callback` argument
    is in fact a function, and invokes it. It also passes the `initialText` variable
    to the `callback` function. If we run this code, we will get two messages logged
    to the console, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个名为`myCallBack`的函数，它接受一个参数并将其值记录到控制台。然后我们定义了一个名为`callingFunction`的函数，它接受两个参数：`initialText`和`callback`。这个函数的第一行只是将`"inside
    CallingFunction"`记录到控制台。`callingFunction`的第二行是有趣的部分。它假设`callback`参数实际上是一个函数，并调用它。它还将`initialText`变量传递给`callback`函数。如果我们运行这段代码，将会得到两条消息记录到控制台，如下所示：
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'But what happens if we do not pass a function as a callback? There is nothing
    in the preceding code that signals to us that the second parameter of `callingFunction`
    must be a function. If we inadvertently called the `callingFunction` function
    with a string, instead of a function as the second parameter, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们不将函数作为回调传递会发生什么？在前面的代码中没有任何信号告诉我们`callingFunction`的第二个参数必须是一个函数。如果我们无意中使用字符串而不是函数作为第二个参数调用`callingFunction`函数，如下所示：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We would get a JavaScript runtime error:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到一个JavaScript运行时错误：
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Defensive minded programmers, however, would first check whether the `callback`
    parameter was in fact a function before invoking it, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，防御性的程序员首先会检查`callback`参数是否实际上是一个函数，然后再调用它，如下所示：
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note the third line of this code snippet, where we check the type of the `callback`
    variable before invoking it. If it is not a function, we then log a message to
    the console. On the last line of this snippet, we are executing the `callingFunction`,
    but this time passing a string as the second parameter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意此代码片段的第三行，我们在调用之前检查`callback`变量的类型。如果它不是一个函数，我们就会在控制台上记录一条消息。在此片段的最后一行，我们正在执行`callingFunction`，但这次将一个字符串作为第二个参数传递。
- en: 'The output of the code snippet would be:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段的输出将是：
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When using function callbacks, then, JavaScript programmers need to do two things;
    firstly, understand which parameters are in fact callbacks and secondly, code
    around the invalid use of callback functions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当使用函数回调时，JavaScript程序员需要做两件事；首先，了解哪些参数实际上是回调，其次，编写无效使用回调函数的代码。
- en: Function signatures
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数签名
- en: The TypeScript "syntactic sugar" that enforces strong typing, is not only intended
    for variables and types, but for function signatures as well. What if we could
    document our JavaScript callback functions in code, and then warn users of our
    code when they are passing the wrong type of parameter to our functions ?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript强制类型的“语法糖”不仅适用于变量和类型，还适用于函数签名。如果我们能够在代码中记录JavaScript回调函数，然后在用户传递错误类型的参数给我们的函数时警告他们，那该多好啊？
- en: 'TypeScript does this through function signatures. A function signature introduces
    a fat arrow syntax, `() =>`, to define what the function should look like. Let''s
    re-write the preceding JavaScript sample in TypeScript:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript通过函数签名来实现这一点。函数签名引入了一个`() =>`的箭头语法，来定义函数的外观。让我们用TypeScript重新编写前面的JavaScript示例：
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Our first function definition, `myCallBack` now strongly types the `text` parameter
    to be of type `string`. Our `callingFunction` function has two parameters; `initialText`,
    which is of type `string`, and `callback`, which now has the new function signature
    syntax. Let''s look at this function signature more closely:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个函数定义`myCallBack`现在将`text`参数强制类型为`string`类型。我们的`callingFunction`函数有两个参数；`initialText`是`string`类型，`callback`现在具有新的函数签名语法。让我们更仔细地看一下这个函数签名：
- en: '[PRE52]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: What this function definition is saying, is that the `callback` argument is
    typed (by the `:` syntax) to be a function, using the fat arrow syntax `() =>`.
    Additionally, this function takes a parameter named `text` that is of type `string`.
    To the right of the fat arrow syntax, we can see a new TypeScript basic type,
    called `void`. Void is a keyword to denote that a function does not return a value.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数定义的意思是，`callback`参数被类型化（通过`:`语法）为一个函数，使用箭头语法`() =>`。此外，这个函数接受一个名为`text`的参数，类型为`string`。在箭头语法的右边，我们可以看到一个新的TypeScript基本类型，称为`void`。Void是一个关键字，用于表示函数不返回值。
- en: 'So, the `callingFunction` function will only accept, as its second argument,
    a function that takes a single string parameter and returns nothing. Compiling
    the preceding code will correctly highlight an error in the last line of the code
    snippet, where we passing a string as the second parameter, instead of a callback
    function:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`callingFunction`函数只会接受一个函数作为其第二个参数，该函数接受一个字符串参数并且不返回任何值。编译前面的代码将正确地突出显示代码片段的最后一行中的错误，即我们将一个字符串作为第二个参数传递，而不是一个回调函数：
- en: '[PRE53]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Given the preceding function signature for the callback function, the following
    code would also generate compile time errors:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于回调函数的前面函数签名，以下代码也会生成编译时错误：
- en: '[PRE54]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, we are defining a function named `myCallBackNumber`, that takes a number
    as its only parameter. When we attempt to compile this code, we will get an error
    message indicating that the `callback` parameter, which is our `myCallBackNumber`
    function, also does not have the correct function signature:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`myCallBackNumber`的函数，它以一个数字作为唯一参数。当我们尝试编译这段代码时，我们将收到一个错误消息，指示`callback`参数，也就是我们的`myCallBackNumber`函数，也没有正确的函数签名。
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The function signature of `myCallBackNumber` would actually be `(arg1:number)
    => void`, instead of the required `(text: string) => void`, hence the error.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`myCallBackNumber`的函数签名实际上应该是`(arg1:number) => void`，而不是所需的`(text: string)
    => void`，因此会出现错误。'
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In function signatures, the parameter name (`arg1` or `text`) does not need
    to be the same. Only the number of parameters, their types, and the return type
    of the function need to be the same.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数签名中，参数名（`arg1`或`text`）不需要相同。只需要函数的参数数量、它们的类型和函数的返回类型相同。
- en: This is a very powerful feature of TypeScript — defining in code what the signatures
    of functions should be, and warning users when they do not call a function with
    the correct parameters. As we saw in our introduction to TypeScript, this is most
    significant when we are working with third-party libraries. Before we are able
    to use third-party functions, classes, or objects in TypeScript, we need to define
    what their function signatures are. These function definitions are put into a
    special type of TypeScript file, called a declaration file, and saved with a `.d.ts`
    extension. We will take an in-depth look at declaration files in [Chapter 4](ch04.html
    "Chapter 4. Writing and Using Declaration Files"), *Writing and Using Declaration
    Files*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是TypeScript的一个非常强大的特性——在代码中定义函数的签名，并在用户调用函数时警告他们是否使用了正确的参数。正如我们在TypeScript介绍中看到的，当我们使用第三方库时，这一点尤为重要。在我们能够在TypeScript中使用第三方函数、类或对象之前，我们需要定义它们的函数签名。这些函数定义被放入一种特殊类型的TypeScript文件中，称为声明文件，并以`.d.ts`扩展名保存。我们将在[第4章](ch04.html
    "第4章。编写和使用声明文件")中深入了解声明文件，*编写和使用声明文件*。
- en: Function callbacks and scope
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数回调和作用域
- en: 'JavaScript uses lexical scoping rules to define the valid scope of a variable.
    This means that the value of a variable is defined by its location within the
    source code. Nested functions have access to variables that are defined in their
    parent scope. As an example of this, consider the following TypeScript code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript使用词法作用域规则来定义变量的有效作用域。这意味着变量的值由它在源代码中的位置来定义。嵌套函数可以访问在其父作用域中定义的变量。作为这一点的例子，考虑以下TypeScript代码：
- en: '[PRE56]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This code snippet defines a function named `testScope`. The variable `testVariable`
    is defined within this function. The `print` function is a child function of `testScope`,
    so it has access to the `testVariable` variable. The last line of the code, however,
    will generate a compile error, because it is attempting to use the variable `testVariable`,
    which is lexically scoped to be valid only inside the body of the `testScope`
    function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段定义了一个名为`testScope`的函数。变量`testVariable`在这个函数内部定义。`print`函数是`testScope`的子函数，因此它可以访问`testVariable`变量。然而，代码的最后一行将生成一个编译错误，因为它试图使用`testVariable`变量，而这个变量在`testScope`函数体内部是有效的。
- en: '[PRE57]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Simple, right? A nested function has access to variables depending on its location
    within the source code. This is all well and good, but in large JavaScript projects,
    there are many different files and many areas of the code are designed to be re-usable.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 简单吧？嵌套函数可以访问源代码中的变量，取决于它在源代码中的位置。这一切都很好，但在大型JavaScript项目中，有许多不同的文件，代码的许多部分都设计为可重用。
- en: 'Let''s take a look at how these scoping rules can become a problem. For this
    sample, we will use a typical callback scenario—using jQuery to execute an asynchronous
    call to fetch some data. Consider the following TypeScript code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些作用域规则如何成为一个问题。对于这个示例，我们将使用一个典型的回调场景——使用jQuery执行异步调用来获取一些数据。考虑以下TypeScript代码：
- en: '[PRE58]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In this code snippet, we are defining a variable named `testVariable` and setting
    its value. We then define a function called `getData`. The `getData` function
    sets another variable called `testVariable_2`, and then calls the jQuery `$.ajax`
    function. The `$.ajax` function is configured with three properties: `url`, `success`,
    and `error`. The `url` property is a simple string that points to a `sample_json.json`
    file in our project directory. The `success` property is an anonymous function
    callback, that simply logs the values of `testVariable` and `testVariable_2` to
    the console. Finally, the `error` property is also an anonymous function callback,
    that simply pops up an alert.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，我们定义了一个名为`testVariable`的变量并设置了它的值。然后我们定义了一个名为`getData`的函数。`getData`函数设置了另一个名为`testVariable_2`的变量，然后调用了jQuery的`$.ajax`函数。`$.ajax`函数配置了三个属性：`url`、`success`和`error`。`url`属性是一个简单的字符串，指向项目目录中的`sample_json.json`文件。`success`属性是一个匿名函数回调，简单地将`testVariable`和`testVariable_2`的值记录到控制台中。最后，`error`属性也是一个匿名函数回调，简单地弹出一个警告。
- en: 'This code runs as expected, and the success function will log the following
    results to the console:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码按预期运行，成功函数将把以下结果记录到控制台中：
- en: '[PRE59]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'So far so good. Now, let''s assume that we are trying to refactor the preceding
    code, as we are doing quite a few similar `$.ajax` calls, and want to reuse the
    `success` callback function elsewhere. We can easily switch out this anonymous
    function, and create a named function for our `success` callback, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切都很好。现在，假设我们正在尝试重构前面的代码，因为我们正在做一些类似的`$.ajax`调用，并希望在其他地方重用`success`回调函数。我们可以很容易地切换掉这个匿名函数，并为我们的`success`回调创建一个命名函数，如下所示：
- en: '[PRE60]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In this sample, we have created a new function named `successCallback` with
    the same parameters as our previous anonymous function. We have also modified
    the `$.ajax` call to simply pass this function in, as a callback function for
    the `success` property: `success: successCallback`. If we were to compile this
    code now, TypeScript would generate an error, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个示例中，我们创建了一个名为`successCallback`的新函数，参数与之前的匿名函数相同。我们还修改了`$.ajax`调用，只需将这个函数作为`success`属性的回调函数传递进去：`success:
    successCallback`。如果我们现在编译这段代码，TypeScript会生成一个错误，如下所示：'
- en: '[PRE61]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Since we have changed the lexical scope of our code, by creating a named function,
    the new `successCallback` function no longer has access the variable `testVariable_2`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们改变了代码的词法作用域，通过创建一个命名函数，新的`successCallback`函数不再可以访问变量`testVariable_2`。
- en: Note
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is fairly easy to spot this sort of error in a trivial example, but in larger
    projects, and when using third-party libraries, these sorts of errors become more
    difficult to track down. It is, therefore, worth mentioning that when using callback
    functions, we need to understand this lexical scope. If your code expects a property
    to have a value, and it does not have one after a callback, then remember to have
    a look at the context of the calling code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个简单的示例中很容易发现这种错误，但在更大的项目中，以及在使用第三方库时，这些错误变得更难追踪。因此，值得一提的是，在使用回调函数时，我们需要理解词法作用域。如果你的代码期望一个属性有一个值，在回调之后它没有一个值，那么记得查看调用代码的上下文。
- en: Function overloads
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数重载
- en: 'As JavaScript is a dynamic language, we can often call the same function with
    different argument types. Consider the following JavaScript code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript是一种动态语言，我们经常可以用不同的参数类型调用同一个函数。考虑以下JavaScript代码：
- en: '[PRE62]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here, we are defining a simple `add` function that returns the sum of its two
    parameters, `x` and `y`. The last three lines of this code snippet simply log
    the result of the `add` function with different types: two numbers, two strings,
    and two boolean values. If we run this code, we will see the following output:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个简单的`add`函数，返回其两个参数`x`和`y`的和。这段代码片段的最后三行只是记录了`add`函数的不同类型的结果：两个数字、两个字符串和两个布尔值。如果我们运行这段代码，将会看到以下输出：
- en: '[PRE63]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'TypeScript introduces a specific syntax to indicate multiple function signatures
    for the same function. If we were to replicate the preceding code in TypeScript,
    we would need to use the function overload syntax:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript引入了一种特定的语法来表示同一个函数的多个函数签名。如果我们要在TypeScript中复制上述代码，我们需要使用函数重载语法：
- en: '[PRE64]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The first line of this code snippet specifies a function overload signature
    for the `add` function that accepts two strings and returns a `string`. The second
    line specifies another function overload that uses numbers, and the third line
    uses booleans. The fourth line contains the actual body of the function and uses
    the type specifier of `any`. The last three lines of this snippet show how we
    would use these function signatures, and are similar to the JavaScript code that
    we have been using previously.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段的第一行指定了一个`add`函数的函数重载签名，接受两个字符串并返回一个`string`。第二行指定了另一个使用数字的函数重载，第三行使用布尔值。第四行包含了函数的实际体，并使用了`any`类型说明符。片段的最后三行展示了我们如何使用这些函数签名，与我们之前使用的JavaScript代码类似。
- en: There are three points of interest in the preceding code snippet. Firstly, none
    of the function signatures on the first three lines of the snippet actually have
    a function body. Secondly, the final function definition uses the type specifier
    of `any` and eventually includes the function body. The function overload syntax
    must follow this structure, and the final function signature, that includes the
    body of the function must use the `any` type specifier, as anything else will
    generate compile-time errors.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中有三个值得注意的地方。首先，片段的前三行中的函数签名实际上都没有函数体。其次，最终的函数定义使用了`any`类型说明符，并最终包括了函数体。函数重载的语法必须遵循这个结构，包括函数体的最终函数签名必须使用`any`类型说明符，因为其他任何类型都会生成编译时错误。
- en: 'The third point to note, is that we are limiting the `add` function, by using
    these function overload signatures, to only accept two parameters that are of
    the same type. If we were to try and mix our types; for example, if we call the
    function with a `boolean` and a `string`, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第三点需要注意的是，我们通过使用这些函数重载签名，限制了`add`函数只接受两个相同类型的参数。如果我们尝试混合类型；例如，如果我们用一个`boolean`和一个`string`调用函数，如下所示：
- en: '[PRE65]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'TypeScript would generate compile errors:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript会生成编译错误：
- en: '[PRE66]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This seems to contradict our final function definition though. In the original
    TypeScript sample, we had a function signature that accepted `(arg1: any, arg2:
    any)`; so, in theory, this should be called when we try to add a `boolean` and
    a `number`. The TypeScript syntax for function overloads, however, does not allow
    this. Remember that the function overload syntax must include the use of the `any`
    type for the function body, as all overloads eventually call this function body.
    However, the inclusion of the function overloads above the function body indicates
    to the compiler that these are the only signatures that should be available to
    the calling code.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '这似乎与我们最终的函数定义相矛盾。在原始的TypeScript示例中，我们有一个接受`(arg1: any, arg2: any)`的函数签名；因此，理论上当我们尝试将一个`boolean`和一个`number`相加时，应该调用这个函数。然而，TypeScript的函数重载语法不允许这样做。请记住，函数重载的语法必须包括对函数体的`any`类型的使用，因为所有的重载最终都会调用这个函数体。然而，在函数体之上包含函数重载的部分告诉编译器，这些是调用代码可用的唯一签名。'
- en: Union types
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联合类型
- en: 'With the release of TypeScript 1.4, we now have the ability to combine one
    or two types using the pipe symbol (`|`) to denote a Union Type. We can, therefore,
    rewrite our `add` function overrides in the previous code snippet as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 随着TypeScript 1.4的发布，我们现在可以使用管道符(`|`)来表示联合类型，将一个或两个类型组合起来。因此，我们可以将前面代码片段中的`add`函数重写为以下形式：
- en: '[PRE67]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This function, named `addWithUnion` has two arguments, `arg1` and `arg2`. These
    arguments are are now using the union type syntax to specify that these arguments
    can be either `string,` `number`, or `boolean`. Notice too that our return type
    for the function is again using union types, meaning that the function will return
    one of these types as well.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名为`addWithUnion`的函数有两个参数，`arg1`和`arg2`。这些参数现在使用联合类型语法来指定这些参数可以是`string`、`number`或`boolean`。还要注意，我们函数的返回类型再次使用联合类型，这意味着函数也将返回其中的一个类型。
- en: Type guards
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型保护
- en: Within the body of the `addWithUnion` function in the preceding code snippet,
    we check whether the type of the `arg1` argument is a string, with the statement
    `typeof arg1 === "string"`. This is known as a type guard and means that the type
    of `arg1` will be treated as a `string` within the `if` statement block. Within
    the body of the next `if` statement, the type of `arg1` will be treated as a number,
    allowing us to add `10` to its value, and in the body of the last if statement,
    the type will be treated as a `boolean` by the compiler.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码片段的`addWithUnion`函数体内，我们检查`arg1`参数的类型是否为字符串，语句为`typeof arg1 === "string"`。这被称为类型保护，意味着`arg1`的类型将在`if`语句块内被视为`string`类型。在下一个`if`语句的函数体内，`arg1`的类型将被视为数字，允许我们将`10`添加到它的值，在最后一个if语句的函数体内，编译器将把类型视为`boolean`。
- en: Type aliases
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型别名
- en: 'We are also able to define an alias for a type, a union type, or a function
    definition. Type aliases are denoted by using the `type` keyword. We can, therefore,
    write our preceding `add` function as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为类型、联合类型或函数定义定义别名。类型别名使用`type`关键字表示。因此，我们可以将前面的`add`函数写成如下形式：
- en: '[PRE68]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, we have defined a type alias named `StringNumberOrBoolean` that is a type
    union of the `string`, `number`, and `boolean` types.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`StringNumberOrBoolean`的类型别名，它是`string`、`number`和`boolean`类型的联合类型。
- en: 'Type aliases can also be used for function signatures as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名也可以用于函数签名，如下所示：
- en: '[PRE69]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here, we have defined a type alias named `CallbackWithString` that is a function
    that takes a single `string` parameter and returns a `void`. Our `usingCallback`
    function accepts this type alias within the function signature as the type for
    the `callback` argument.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`CallbackWithString`的类型别名，它是一个接受单个`string`参数并返回`void`的函数。我们的`usingCallback`函数在函数签名中接受这个类型别名作为`callback`参数的类型。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have discussed TypeScript's basic types, variables, and
    function techniques. We saw how TypeScript introduces "syntactic sugar" on top
    of normal JavaScript code, to ensure strongly typed variables and function signatures.
    We also saw how TypeScript uses duck-typing and explicit casting, and finished
    up with a discussion on TypeScript functions, function signatures, and overloading.
    In the next chapter, we will build on this knowledge and see how TypeScript extends
    these strongly typed rules into interfaces, classes and generics.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了TypeScript的基本类型、变量和函数技术。我们看到TypeScript如何在普通JavaScript代码的基础上引入了“语法糖”，以确保强类型的变量和函数签名。我们还看到TypeScript如何使用鸭子类型和显式转换，并以TypeScript函数、函数签名和重载结束。在下一章中，我们将在此基础上继续学习，看看TypeScript如何将这些强类型规则扩展到接口、类和泛型中。
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为Bentham Chang准备，Safari ID bentham@gmail.com 用户编号：2843974 © 2015 Safari Books
    Online，LLC。此下载文件仅供个人使用，并受到服务条款的约束。任何其他用途均需版权所有者的事先书面同意。未经授权的使用、复制和/或分发严格禁止并违反适用法律。保留所有权利。
