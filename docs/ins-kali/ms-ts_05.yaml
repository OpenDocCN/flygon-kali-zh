- en: Chapter 5. Third Party Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。第三方库
- en: Our TypeScript development environment would not amount to much if we were not
    able to re-use the myriad of existing JavaScript libraries, frameworks and general
    goodness. As we have seen, however, in order to use a particular third party library
    with TypeScript, we will first need a matching definition file.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法重用现有的JavaScript库、框架和其他好东西，那么我们的TypeScript开发环境就不会有多大作用。然而，正如我们所看到的，为了在TypeScript中使用特定的第三方库，我们首先需要一个匹配的定义文件。
- en: Soon after TypeScript was released, Boris Yankov set up a github repository
    to house TypeScript definition files for third party JavaScript libraries. This
    repository, named DefinitelyTyped ([https://github.com/borisyankov/DefinitelyTyped](https://github.com/borisyankov/DefinitelyTyped))
    quickly became very popular, and is currently the place to go for high-quality
    definition files. DefinitelyTyped currently has over 700 definition files, built
    up over time from hundreds of contributors from all over the world. If we were
    to measure the success of TypeScript within the JavaScript community, then the
    DefinitelyTyped repository would be a good indication of how well TypeScript has
    been adopted. Before you go ahead and try to write your own definition files,
    check the DefinitelyTyped repository to see if there is one already available.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript发布后不久，Boris Yankov建立了一个github存储库，用于存放第三方JavaScript库的TypeScript定义文件。这个名为DefinitelyTyped的存储库（[https://github.com/borisyankov/DefinitelyTyped](https://github.com/borisyankov/DefinitelyTyped)）迅速变得非常受欢迎，目前是获取高质量定义文件的地方。DefinitelyTyped目前拥有超过700个定义文件，这些文件是来自世界各地数百名贡献者多年来建立起来的。如果我们要衡量TypeScript在JavaScript社区中的成功，那么DefinitelyTyped存储库将是TypeScript被采用程度的一个很好指标。在尝试编写自己的定义文件之前，先检查DefinitelyTyped存储库，看看是否已经有可用的文件。
- en: 'In this chapter, we will have a closer look at using these definition files,
    and cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将更仔细地研究如何使用这些定义文件，并涵盖以下主题：
- en: Downloading definition files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载定义文件
- en: Using NuGet within Visual Studio
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Visual Studio中使用NuGet
- en: Using TypeScript Definition manager (TSD)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TypeScript Definition manager (TSD)
- en: Choosing a JavaScript Framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个JavaScript框架
- en: Using TypeScript with Backbone
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Backbone的TypeScript
- en: Using TypeScript with Angular
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular的TypeScript
- en: Using TypeScript with ExtJs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ExtJs的TypeScript
- en: Downloading definition files
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载定义文件
- en: The simplest method of including a definition file within your TypeScript project
    is to download the matching `.d.ts` file from DefinitelyTyped. This is a simple
    matter of finding the relevant file, and downloading the raw content. Let's assume
    that we wanted to start using jQuery within our project. We have found and downloaded
    the jQuery JavaScript library (v2.1.1), and included the relevant files within
    our project, under a directory named `lib`. To download the declaration file,
    simply browse to the `jquery` directory on DefinitelyTyped ([https://github.com/borisyankov/DefinitelyTyped/tree/master/jquery](https://github.com/borisyankov/DefinitelyTyped/tree/master/jquery)),
    and then click on the `jquery.d.ts` file. This will open up a GitHub page with
    an editor view of the file. On the menu bar of this editor view, click on the
    **Raw** button. This will download the `jquery.d.ts` file, and allow you to save
    it within your project directory structure. Create a new directory under the **lib**
    folder called **typings**, and save the **jquery.d.ts** file there.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript项目中包含定义文件的最简单方法是从DefinitelyTyped下载匹配的`.d.ts`文件。这只是简单地找到相关文件，并下载原始内容。假设我们想要在项目中开始使用jQuery。我们已经找到并下载了jQuery
    JavaScript库（v2.1.1），并在项目中的一个名为`lib`的目录下包含了相关文件。要下载声明文件，只需浏览到DefinitelyTyped上的`jquery`目录（[https://github.com/borisyankov/DefinitelyTyped/tree/master/jquery](https://github.com/borisyankov/DefinitelyTyped/tree/master/jquery)），然后点击`jquery.d.ts`文件。这将打开一个GitHub页面，显示文件的编辑器视图。在这个编辑器视图的菜单栏上，点击**Raw**按钮。这将下载`jquery.d.ts`文件，并允许您将其保存在项目目录结构中。在**lib**文件夹下创建一个名为**typings**的新目录，并将**jquery.d.ts**文件保存在其中。
- en: 'Your project file should look something like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目文件应该看起来像这样：
- en: '![Downloading definition files](img/9665OS_05_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![下载定义文件](img/9665OS_05_01.jpg)'
- en: Visual Studio project structure with a downloaded jquery.d.ts file
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 带有下载的jquery.d.ts文件的Visual Studio项目结构
- en: 'We can now modify our `index.html` file to include the `jquery` JavaScript
    file, and begin writing TypeScript code that targets the jQuery library. Our `index.html`
    file will need to be modified as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以修改我们的`index.html`文件，包含`jquery` JavaScript文件，并开始编写针对jQuery库的TypeScript代码。我们的`index.html`文件需要修改如下：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first `<script>` tag of this `index.html` file now includes a link to `jquery-2.1.1.min.js`,
    and the second `<script>` tag includes a link to the TypeScript generated `app.js`.
    Open up the `app.ts` TypeScript file, delete the exiting source, and replace it
    with the following jQuery code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`index.html`文件的第一个`<script>`标签现在包含了一个指向`jquery-2.1.1.min.js`的链接，第二个`<script>`标签包含了一个指向TypeScript生成的`app.js`的链接。打开`app.ts`
    TypeScript文件，删除现有的源代码，并用以下jQuery代码替换它：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This snippet starts by defining an anonymous function to execute on the jQuery
    event of `document.ready`. The `document.ready` function is similar to the `window.onload`
    function we have been using previously, and will execute once jQuery has initialized.
    The second line of this snippet simply gets a handle to the DOM element named
    `content` using jQuery selector syntax, and then calls the `html` function to
    set its HTML value.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先定义了一个匿名函数，在jQuery的`document.ready`事件上执行。`document.ready`函数类似于我们之前使用的`window.onload`函数，它会在jQuery初始化后执行。这段代码的第二行简单地使用jQuery选择器语法获取名为`content`的DOM元素的句柄，然后调用`html`函数设置其HTML值。
- en: The `jquery.d.ts` file that we downloaded is providing us with the relevant
    module declarations that we need in order to compile jQuery within TypeScript.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下载的`jquery.d.ts`文件为我们提供了在TypeScript中编译jQuery所需的相关模块声明。
- en: Using NuGet
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NuGet
- en: NuGet is a popular package management platform that will download required external
    libraries, and automatically include them in within your Visual Studio or WebMatrix
    project. It can be used for external libraries that are packaged as DLLs – such
    as StructureMap – or it can be used for JavaScript libraries and declaration files.
    NuGet is also available as a command-line utility.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: NuGet是一个流行的包管理平台，可以下载所需的外部库，并自动包含在您的Visual Studio或WebMatrix项目中。它可用于打包为DLL的外部库，例如StructureMap，也可用于JavaScript库和声明文件。NuGet也可用作命令行实用程序。
- en: Using the Extension Manager
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用扩展管理器
- en: 'To use the NuGet package manager dialog within Visual Studio, select the **Tools**
    option on the main toolbar, then select **NuGet Package Manager**, and finally
    select **Manage NuGet Packages for Solution**. This brings up the NuGet package
    manager dialog. On the left-hand side of the dialog, click on **Online**. The
    NuGet dialog will then query the NuGet website and show a list of available packages.
    At the top right of the screen is a **search** box. Click within the **search**
    box, and type `jquery` to show all packages available within NuGet for jQuery,
    as shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Visual Studio中使用NuGet包管理器对话框，请在主工具栏上选择**工具**选项，然后选择**NuGet包管理器**，最后选择**管理解决方案的NuGet包**。这将打开NuGet包管理器对话框。在对话框的左侧，单击**在线**。NuGet对话框将查询NuGet网站并显示可用包的列表。屏幕右上方有一个**搜索**框。单击**搜索**框，并输入`jquery`，以显示NuGet中为jQuery提供的所有包，如下图所示：
- en: '![Using the Extension Manager](img/9665OS_05_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![使用扩展管理器](img/9665OS_05_02.jpg)'
- en: NuGet Package manager dialog with results from a query on jQuery
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: NuGet包管理器对jQuery查询的对话框
- en: Each package will have an **Install** button highlighted when you select the
    package in the **search results** panel. When a package is selected, the right-hand
    pane will show more details about the NuGet package in question. Note that the
    project details panel also shows the Version of the package that you are about
    to install. Clicking on the **Install** button will download relevant files –
    as well as any dependencies – and include them automatically within your project.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在**搜索结果**面板中选择包时，每个包都将有一个突出显示的**安装**按钮。选择包后，右侧窗格将显示有关所讨论的NuGet包的更多详细信息。请注意，项目详细信息面板还显示了您即将安装的包的版本。单击**安装**按钮将自动下载相关文件以及任何依赖项，并将它们自动包含在您的项目中。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The installation directory that NuGet uses for JavaScript files is in fact called
    `Scripts` – and not the `lib` directory that we created earlier. NuGet uses the
    `Scripts` directory as a standard, so any packages that contain JavaScript will
    install the relevant JavaScript files into the `Scripts` directory.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: NuGet用于JavaScript文件的安装目录实际上称为`Scripts`，而不是我们之前创建的`lib`目录。NuGet使用`Scripts`目录作为标准，因此任何包含JavaScript的包都将安装相关的JavaScript文件到`Scripts`目录中。
- en: Installing declaration files
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装声明文件
- en: You will find that most declaration files that are found on the DefinitelyTyped
    GitHub repository have a corresponding NuGet package. These packages are named
    `<library>`.`TypeScript.DefinitelyTyped`, as a standard naming convention. If
    we type `jquery typescript` into the search box, we will see a list of these DefinitelyTyped
    packages returned. The NuGet package we are looking for is named **jquery.TypeScript.DefinitelyTyped**,
    created by **Jason Jarret**, and is, at the time of writing, at version 1.4.0.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现在DefinitelyTyped GitHub存储库上找到的大多数声明文件都有相应的NuGet包。这些包的命名约定是`<library>`.`TypeScript.DefinitelyTyped`。如果我们在搜索框中输入`jquery
    typescript`，我们将看到返回的这些DefinitelyTyped包的列表。我们要找的NuGet包的名称是**jquery.TypeScript.DefinitelyTyped**，由**Jason
    Jarret**创建，在撰写本文时，版本为1.4.0。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The DefinitelyTyped packages have their own internal version number, and these
    version numbers do not necessarily match the version of the JavaScript library
    that you are using. For example, the jQuery package is at version 2.1.1, but the
    corresponding TypeScript definition package shows a version number of 1.4.0.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: DefinitelyTyped包有它们自己的内部版本号，这些版本号不一定与您使用的JavaScript库的版本匹配。例如，jQuery包的版本为2.1.1，但相应的TypeScript定义包显示的版本号为1.4.0。
- en: Installing the `jQuery.TypeScript.DefinitelyTyped` package will create a `typings`
    directory under the `Scripts` directory, and then include the `jquery.d.ts` definition
    file. This directory naming standard has been adopted by the various NuGet package
    authors.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`jQuery.TypeScript.DefinitelyTyped`包将在`Scripts`目录下创建一个`typings`目录，然后包含`jquery.d.ts`定义文件。这种目录命名标准已被各种NuGet包作者采用。
- en: Using the Package Manager Console
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用包管理器控制台
- en: Visual Studio also has a command-line version of the NuGet package manager available
    as a console application, and is also integrated into Visual Studio. Clicking
    on **Tools**, then **NuGet Package Manager**, and finally on **Package Manager
    Console**, will bring up a new Visual Studio window, and initialize the NuGet
    command line interface. The command line version of NuGet has a number of features
    that are not included in the GUI version. Type `get-help NuGet` to see the list
    of top-level command line arguments that are available.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio还有一个命令行版本的NuGet包管理器，可以作为控制台应用程序使用，也集成到了Visual Studio中。单击**工具**，然后**NuGet包管理器**，最后**包管理器控制台**，将打开一个新的Visual
    Studio窗口，并初始化NuGet命令行界面。NuGet的命令行版本具有一些在GUI版本中不包括的功能。输入`get-help NuGet`以查看可用的顶级命令行参数列表。
- en: Installing packages
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装包
- en: 'To install a NuGet package from the console command line, simply type `install-package
    <packageName>`. As an example, to install the `jquery.TypeScript.DefinitelyTyped`
    package, simply type:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要从控制台命令行安装NuGet包，只需输入`install-package <packageName>`。例如，要安装`jquery.TypeScript.DefinitelyTyped`包，只需输入：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command will connect to the NuGet server, and download and install the
    package into your project.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将连接到NuGet服务器，并下载并安装包到您的项目中。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On the toolbar of the **Package Manager Console** window are two dropdown lists,
    **Package Source** and **Default Project**. If your Visual Studio solution has
    multiple projects, you will need to select the correct project for NuGet to install
    the package into from the **Default Project** dropdown.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在**包管理器控制台**窗口的工具栏上有两个下拉列表，**包源**和**默认项目**。如果您的Visual Studio解决方案有多个项目，您需要从**默认项目**下拉列表中选择正确的项目，以便NuGet将包安装到其中。
- en: Searching for package names
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索包名称
- en: 'Searching for package names from the command line is accomplished with the
    `Get-Package –ListAvailable` command. This command takes a `–Filter` parameter
    which acts as the search criteria. As an example, to find available packages that
    include the `definitelytyped` search string, run the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行搜索包名称是通过`Get-Package –ListAvailable`命令完成的。此命令使用`–Filter`参数作为搜索条件。例如，要查找包含`definitelytyped`搜索字符串的可用包，请运行以下命令：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Installing a specific version
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装特定版本
- en: 'There are some JavaScript libraries that are not compatible with jQuery version
    2.x, and will require a version of jQuery that is in the 1.x range. To install
    a specific version of a NuGet package, we will need to specify the `-Version`
    parameter from the command line. To install the `jquery v1.11.1` package, as an
    example, run the following from the command line:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些JavaScript库与jQuery 2.x版本不兼容，需要使用1.x范围内的jQuery版本。要安装特定版本的NuGet包，我们需要从命令行指定`-Version`参数。例如，要安装`jquery
    v1.11.1`包，请从命令行运行以下命令：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: NuGet will either upgrade or downgrade the version of the package you are installing,
    if it finds another version already installed within your project. In the preceding
    example, we had already installed the latest version of jQuery (2.1.1) within
    our project, so NuGet will first remove `jQuery 2.1.1` before installing `jQuery
    1.11.1`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果NuGet发现您的项目中已经安装了另一个版本的包，它将升级或降级要安装的包的版本。在上面的示例中，我们已经在项目中安装了最新版本的jQuery（2.1.1），因此NuGet将首先删除`jQuery
    2.1.1`，然后安装`jQuery 1.11.1`。
- en: Using TypeScript Definition Manager
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TypeScript Definition Manager
- en: If you are using Node as your TypeScript development environment, then you may
    consider using the **TypeScript Definition Manager** for DefinitelyTyped (**TSD**
    at [http://definitelytyped.org/tsd/](http://definitelytyped.org/tsd/)). TSD offers
    similar functionality to the NuGet Package Manager, but is specifically geared
    towards TypeScript definitions that are part of the DefinitelyTyped GitHub repository.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Node作为TypeScript开发环境，那么您可能考虑使用**TypeScript Definition Manager**来获取DefinitelyTyped的TypeScript定义（**TSD**位于[http://definitelytyped.org/tsd/](http://definitelytyped.org/tsd/)）。TSD提供类似于NuGet包管理器的功能，但专门针对DefinitelyTyped
    GitHub存储库中的TypeScript定义。
- en: 'To install TSD, use `npm` as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装TSD，请使用以下`npm`命令：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will install `tsd prerelease v0.6.x`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装`tsd prerelease v0.6.x`。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, you will need v0.6.x and up in order to use the install
    keyword from the command line. If you simply type `npm install tsd –g`, then npm
    will `install v0.5.x`, which does not include the `install` keyword.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，您需要v0.6.x及更高版本才能从命令行使用`install`关键字。如果您只是输入`npm install tsd –g`，那么npm将安装v0.5.x，其中不包括`install`关键字。
- en: Querying for packages
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询包
- en: 'TSD allows for querying the package repository using the `query` keyword. To
    search for the `jquery` definition files, type the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: TSD允许使用`query`关键字查询包存储库。要搜索`jquery`定义文件，输入以下内容：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding command will search the `DefinitelyTyped` repository for any
    definition files named `jquery.d.ts`. Since there is only one, the results returned
    from the search would be:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在`DefinitelyTyped`存储库中搜索任何名为`jquery.d.ts`的定义文件。由于只有一个，搜索返回的结果将是：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using wildcards
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用通配符
- en: 'TSD also allows for the use of the asterisk `*` as a wildcard. To search for
    `DefinitelyTyped` declaration files that start with `jquery`, type the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: TSD还允许使用星号`*`作为通配符。要搜索以`jquery`开头的`DefinitelyTyped`声明文件，输入以下内容：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This `tsd` command will search through the repository, and return results for
    declaration files that start with jQuery.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`tsd`命令将搜索存储库，并返回以jQuery开头的声明文件的结果。
- en: Installing definition files
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装定义文件
- en: 'To install a definition file, use the `install` keyword as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装定义文件，请使用以下`install`关键字：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This command will download the `jquery.d.ts` file into the following directory:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将下载`jquery.d.ts`文件到以下目录：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: TSD will create the `\typings` directory based on the current directory where
    tsd was run, so make sure that you navigate to the same base directory in your
    project whenever you use TSD from the command line.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: TSD将基于运行tsd的当前目录创建`\typings`目录，因此请确保每当您从命令行使用TSD时，都要导航到项目中的相同基本目录。
- en: Using third party libraries
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方库
- en: In this section of the chapter, we will begin to explore some of the more popular
    third party JavaScript libraries, their declaration files, and how to write compatible
    TypeScript for each of these frameworks. We will compare Backbone, Angular, and
    ExtJs, which are all frameworks for building rich client-side JavaScript applications.
    During our discussion, we will see that some frameworks are highly compliant with
    the TypeScript language and its features, some are partially compliant, and some
    have very low compliance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们将开始探索一些更受欢迎的第三方JavaScript库，它们的声明文件以及如何为每个框架编写兼容的TypeScript。我们将比较Backbone、Angular和ExtJs，它们都是用于构建丰富的客户端JavaScript应用程序的框架。在我们的讨论中，我们将看到一些框架与TypeScript语言及其特性高度兼容，一些部分兼容，一些则兼容性很低。
- en: Choosing a JavaScript framework
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择JavaScript框架
- en: Choosing a JavaScript framework or library to develop Single Page Applications
    is a difficult and sometimes daunting task. It seems that there is a new framework
    appearing every other month, promising more and more functionality for less and
    less code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个JavaScript框架或库来开发单页应用程序是一个困难且有时令人望而生畏的任务。似乎每个月都会出现一个新的框架，承诺用更少的代码提供更多的功能。
- en: To help developers compare these frameworks, and make an informed choice, Addy
    Osmani wrote an excellent article, named *Journey Through the JavaScript MVC Jungle*.
    ([http://www.smashingmagazine.com/2012/07/27/journey-through-the-javascript-mvc-jungle/](http://www.smashingmagazine.com/2012/07/27/journey-through-the-javascript-mvc-jungle/)).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助开发人员比较这些框架，并做出明智的选择，Addy Osmani写了一篇名为*Journey Through the JavaScript MVC
    Jungle*的优秀文章。([http://www.smashingmagazine.com/2012/07/27/journey-through-the-javascript-mvc-jungle/](http://www.smashingmagazine.com/2012/07/27/journey-through-the-javascript-mvc-jungle/))。
- en: In essence, his advice is simple – it's a personal choice – so try some frameworks
    out, and see what best fits your needs, your programming mindset, and your existing
    skill set. The **TodoMVC** project ([http://todomvc.com](http://todomvc.com)),
    which Addy started, does an excellent job of implementing the same application
    in a number of MV* JavaScript frameworks. This really is a reference site for
    digging into a fully working application, and comparing for yourself the coding
    techniques and styles of different frameworks.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，他的建议很简单 - 这是一个个人选择 - 所以尝试一些框架，看看哪个最适合你的需求、编程思维方式和现有技能。Addy开始的**TodoMVC**项目([http://todomvc.com](http://todomvc.com))，在几种MV*
    JavaScript框架中实现了相同的应用程序，做得非常出色。这真的是一个参考站点，可以深入了解一个完全工作的应用程序，并比较不同框架的编码技术和风格。
- en: Again, depending on the JavaScript library that you are using within TypeScript,
    you may need to write your TypeScript code in a specific way. Bear this in mind
    when choosing a framework – if it is difficult to use with TypeScript, then you
    may be better off looking at another framework with better integration. If it
    is easy and natural to work with the framework in TypeScript, then your productivity
    and overall development experience will be much better.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，取决于你在TypeScript中使用的JavaScript库，你可能需要以特定的方式编写你的TypeScript代码。在选择框架时要记住这一点 -
    如果在TypeScript中使用起来很困难，那么你可能最好看看另一个集成更好的框架。如果在TypeScript中使用这个框架很容易和自然，那么你的生产力和整体开发体验将会更好。
- en: In this section, we will look at some of the popular JavaScript libraries, along
    with their declaration files, and see how to write compatible TypeScript. The
    key thing to remember is that TypeScript generates JavaScript – so if you are
    battling to use a third party library, then crack open the generated JavaScript
    and see what the JavaScript code looks like that TypeScript is emitting. If the
    generated JavaScript matches the JavaScript code samples in the library's documentation,
    then you are on the right track. If not, then you may need to modify your TypeScript
    until the compiled JavaScript starts matching up with the samples.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一些流行的JavaScript库，以及它们的声明文件，并了解如何编写兼容的TypeScript。要记住的关键是TypeScript生成JavaScript
    - 所以如果你在使用第三方库时遇到困难，那么打开生成的JavaScript，看看TypeScript生成的JavaScript代码是什么样子的。如果生成的JavaScript与库的文档中的JavaScript代码示例匹配，那么你就在正确的轨道上。如果不匹配，那么你可能需要修改你的TypeScript，直到编译后的JavaScript与示例相匹配。
- en: When trying to write TypeScript code for a third party JavaScript framework
    – particularly if you are working off the JavaScript documentation – your initial
    foray may just be one of trial and error. Along the way, you may find that you
    need to write your TypeScript in a specific way in order to match this particular
    third party library. The rest of this chapter shows how three different libraries
    require different ways of writing TypeScript.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试为第三方JavaScript框架编写TypeScript代码时 - 特别是如果你是根据JavaScript文档进行工作 - 你的初始尝试可能只是试错。在这个过程中，你可能会发现你需要以特定的方式编写你的TypeScript，以匹配特定的第三方库。本章的其余部分展示了三种不同的库需要不同的TypeScript编写方式。
- en: Backbone
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Backbone
- en: Backbone is a popular JavaScript library that gives structure to web applications
    by providing models, collections and views, amongst other things. Backbone has
    been around since 2010, and has gained a very large following, with a wealth of
    commercial websites using the framework. According to [Infoworld.com](http://Infoworld.com),
    Backbone has over 1,600 Backbone related projects on GitHub that rate over 3 stars
    – meaning that it has a vast ecosystem of extensions and related libraries.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone是一个流行的JavaScript库，通过提供模型、集合和视图等内容，为Web应用程序提供结构。Backbone自2010年以来一直存在，并且拥有大量的追随者，许多商业网站都在使用这个框架。根据[Infoworld.com](http://Infoworld.com)的报道，Backbone在GitHub上有超过1600个与Backbone相关的项目，评分超过3星，这意味着它拥有庞大的扩展生态系统和相关库。
- en: Let's take a quick look at Backbone written in TypeScript.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下用TypeScript编写的Backbone。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To follow along with the code in your own project, you will need to install
    the following NuGet packages: `backbone.js` ( currently at v1.1.2), and `backbone.TypeScript.DefinitelyTyped`
    (currently at version 1.2.3).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要在自己的项目中跟着代码进行，你需要安装以下NuGet包：`backbone.js`（当前版本为v1.1.2），和`backbone.TypeScript.DefinitelyTyped`（当前版本为1.2.3）。
- en: Using inheritance with Backbone
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Backbone中使用继承
- en: 'From the Backbone documentation, we find an example of creating a `Backbone.Model`
    in JavaScript as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从Backbone的文档中，我们找到了在JavaScript中创建`Backbone.Model`的示例如下：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This code shows a typical usage of Backbone in JavaScript. We start by creating
    a variable named `Note` that extends (or derives from) `Backbone.Model`. This
    can be seen with the `Backbone.Model.extend` syntax. The Backbone `extend` function
    uses JavaScript object notation to define an object within the outer curly braces
    `{ … }`. In the preceding code, this object has four functions: `initialize`,
    `author`, `coordinates` and `allowedToEdit`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了JavaScript中Backbone的典型用法。我们首先创建一个名为`Note`的变量，它扩展（或派生自）`Backbone.Model`。这可以通过`Backbone.Model.extend`语法看出。Backbone的`extend`函数使用JavaScript对象表示法在外部花括号`{
    ... }`中定义一个对象。在前面的代码中，这个对象有四个函数：`initialize`，`author`，`coordinates`和`allowedToEdit`。
- en: 'According to the Backbone documentation, the `initialize` function will be
    called once a new instance of this class is created. In our preceding sample,
    the `initialize` function simply creates an **alert** to indicate that the function
    was called. The `author` and `coordinates` functions are blank at this stage,
    with only the `allowedToEdit` function actually doing something: `return true`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Backbone文档，`initialize`函数将在创建此类的新实例时被调用一次。在我们之前的示例中，`initialize`函数只是创建一个**警报**来指示该函数被调用。`author`和`coordinates`函数在这个阶段是空的，只有`allowedToEdit`函数实际上做了一些事情：`return
    true`。
- en: 'If we were to simply copy and paste the above JavaScript into a TypeScript
    file, we would generate the following compile error:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是简单地将上面的JavaScript复制粘贴到一个TypeScript文件中，我们将生成以下编译错误：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When working with a third party library, and a definition file from DefinitelyTyped,
    our first port of call should be to see if the definition file may be in error.
    After all, the JavaScript documentation says that we should be able to use the
    `extend` method as shown, so why is this definition file causing an error? If
    we open up the `backbone.d.ts` file, and then search to find the definition of
    the class `Model`, we will find the cause of the compilation error:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用第三方库和来自DefinitelyTyped的定义文件时，我们首先应该看看定义文件是否有错误。毕竟，JavaScript文档说我们应该能够像示例中那样使用`extend`方法，那么为什么这个定义文件会导致错误呢？如果我们打开`backbone.d.ts`文件，然后搜索找到`Model`类的定义，我们会找到编译错误的原因：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This declaration file snippet shows some of the definition of the Backbone
    `Model` class. Here, we can see that the `extend` function is defined as `private
    static`, and as such, it will not be available outside the Model class itself.
    This, however, seems contradictory to the JavaScript sample that we saw in the
    documentation. In the preceding comment on the `extend` function definition, we
    find the key to using Backbone in TypeScript: prefer TypeScript''s extend functionality.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明文件片段显示了Backbone `Model`类的一些定义。在这里，我们可以看到`extend`函数被定义为`private static`，因此它在Model类本身之外不可用。然而，这似乎与我们在文档中看到的JavaScript示例相矛盾。在`extend`函数定义的前面评论中，我们找到了在TypeScript中使用Backbone的关键：更喜欢TypeScript的extend功能。
- en: 'This comment indicates that the declaration file for Backbone is built around
    TypeScript''s `extends` keyword – thereby allowing us to use natural TypeScript
    inheritance syntax to create Backbone objects. The TypeScript equivalent to this
    code, therefore, must use the `extends` TypeScript keyword to derive a class from
    the base class `Backbone.Model`, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个评论表明Backbone的声明文件是围绕TypeScript的`extends`关键字构建的，因此我们可以使用自然的TypeScript继承语法来创建Backbone对象。因此，这段代码的TypeScript等价物必须使用`extends`
    TypeScript关键字从基类`Backbone.Model`派生一个类，如下所示：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are now creating a class definition named `Note` that `extends` the `Backbone.Model`
    base class. This class then has the functions `initialize`, `author`, `coordinates`
    and `allowedToEdit`, similar to the previous JavaScript version. Our Backbone
    sample will now compile and run correctly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在创建一个名为`Note`的类定义，它`extends`了`Backbone.Model`基类。这个类然后有`initialize`，`author`，`coordinates`和`allowedToEdit`函数，与之前的JavaScript版本类似。我们的Backbone示例现在将正确编译和运行。
- en: 'With either of these versions, we can create an instance of the `Note` object
    by including the following script within an HTML page:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个版本中的任何一个，我们都可以通过在HTML页面中包含以下脚本来创建`Note`对象的实例：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This JavaScript sample simply waits for the jQuery `document.ready` event to
    be fired, and then creates an instance of the `Note` class. As documented earlier,
    the `initialize` function will be called when an instance of the class is constructed,
    so we would see an alert box appear when we run this in a browser.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JavaScript示例只是等待jQuery的`document.ready`事件被触发，然后创建一个`Note`类的实例。如前所述，当类的实例被构造时，`initialize`函数将被调用，因此当我们在浏览器中运行时，我们会看到一个警报框出现。
- en: All of Backbone's core objects are designed with inheritance in mind. This means
    that creating new Backbone collections, views and routers will use the same `extends`
    syntax in TypeScript. Backbone, therefore, is a very good fit for TypeScript,
    because we can use natural TypeScript syntax for inheritance to create new Backbone
    objects.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone的所有核心对象都是以继承为设计基础的。这意味着创建新的Backbone集合、视图和路由器将在TypeScript中使用相同的`extends`语法。因此，Backbone非常适合TypeScript，因为我们可以使用自然的TypeScript语法来继承创建新的Backbone对象。
- en: Using interfaces
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用接口
- en: 'As Backbone allows us to use TypeScript inheritance to create objects, we can
    just as easily use TypeScript interfaces with any of our Backbone objects as well.
    Extracting an interface for the `Note` class above would be as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Backbone允许我们使用TypeScript继承来创建对象，因此我们也可以轻松地在任何Backbone对象中使用TypeScript接口。提取上面`Note`类的接口将如下所示：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now update our `Note` class definition to implement this interface as
    follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更新我们的`Note`类定义来实现这个接口，如下所示：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our class definition now implements the `INoteInterface` TypeScript interface.
    This simple change protects our code from being modified inadvertently, and also
    opens up the ability to work with core Backbone objects in standard object-oriented
    design patterns. We could, if we needed to, apply the Factory Pattern described
    in [Chapter 3](ch03.html "Chapter 3. Interfaces, Classes and Generics"), *Interfaces,
    Classes and Generics*, to return a particular type of Backbone Model – or any
    other Backbone object for that matter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类定义现在实现了`INoteInterface` TypeScript接口。这个简单的改变保护了我们的代码不会被无意中修改，并且还打开了使用标准面向对象设计模式与核心Backbone对象一起工作的能力。如果需要的话，我们可以应用[第3章](ch03.html
    "第3章。接口、类和泛型")中描述的工厂模式，*接口、类和泛型*，来返回特定类型的Backbone模型 - 或者其他任何Backbone对象。
- en: Using generic syntax
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用泛型语法
- en: 'The declaration file for Backbone has also added generic syntax to some class
    definitions. This brings with it further strong typing benefits when writing TypeScript
    code for Backbone. Backbone collections (surprise, surprise) house a collection
    of Backbone models, allowing us to define collections in TypeScript as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone的声明文件还为一些类定义添加了泛型语法。这在为Backbone编写TypeScript代码时带来了更强的类型化好处。Backbone集合（惊喜，惊喜）包含一组Backbone模型，允许我们在TypeScript中定义集合如下：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we have a `NoteCollection` that derives from, or `extends` a `Backbone.Collection`,
    but also uses generic syntax to constrain the collection to handle only objects
    of type `Note`. This means that any of the standard collection functions such
    as `at()` or `pluck()` will be strongly typed to return `Note` models, further
    enhancing our type safety and Intellisense.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`NoteCollection`，它派生自`Backbone.Collection`，但也使用泛型语法来限制集合只处理`Note`类型的对象。这意味着任何标准的集合函数，比如`at()`或`pluck()`，都将被强类型化为返回`Note`模型，进一步增强了我们的类型安全和智能感知。
- en: 'Note the syntax used to assign a type to the internal `model` property of the
    collection class on the second line. We cannot use the standard TypeScript syntax
    `model: Note`, as this causes a compile time error. We need to assign the `model`
    property to a the class definition, as seen with the `model=Note` syntax, or we
    can use the `{ new(): Note }` syntax as seen on the last line.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意第二行用于将类型分配给集合类的内部`model`属性的语法。我们不能使用标准的TypeScript语法`model: Note`，因为这会导致编译时错误。我们需要将`model`属性分配给类定义，就像`model=Note`语法所示，或者我们可以使用`{
    new(): Note }`语法，就像最后一行所示。'
- en: Using ECMAScript 5
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ECMAScript 5
- en: 'Backbone also allows us to use ECMAScript 5 capabilities to define getters
    and setters for `Backbone.Model` classes, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone还允许我们使用ECMAScript 5的能力来为`Backbone.Model`类定义getter和setter，如下所示：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this snippet, we have defined an interface with two properties, named `ISimpleModel`.
    We then define a `SimpleModel` class that derives from `Backbone.Model`, and also
    implements the `ISimpleModel` interface. We then have ES 5 getters and setters
    for our `Name` and `Id` properties. Backbone uses class attributes to store model
    values, so our getters and setters simply call the underlying `get` and `set`
    methods of `Backbone.Model`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们定义了一个具有两个属性的接口，名为`ISimpleModel`。然后我们定义了一个`SimpleModel`类，它派生自`Backbone.Model`，并且还实现了`ISimpleModel`接口。然后我们为我们的`Name`和`Id`属性定义了ES
    5的getter和setter。Backbone使用类属性来存储模型值，所以我们的getter和setter只是调用了`Backbone.Model`的底层`get`和`set`方法。
- en: Backbone TypeScript compatibility
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Backbone TypeScript兼容性
- en: As we have seen, Backbone allows us to use all of TypeScript's language features
    within our code. We can use classes, interfaces, inheritance, generics and even
    ECMAScript 5 properties. All of our classes also derive from base Backbone objects.
    This makes Backbone a highly compatible library for building web applications
    with TypeScript. We will explore more of the Backbone framework in later chapters.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Backbone允许我们在我们的代码中使用TypeScript的所有语言特性。我们可以使用类、接口、继承、泛型，甚至是ECMAScript
    5属性。我们所有的类也都派生自基本的Backbone对象。这使得Backbone成为了一个非常兼容TypeScript的构建Web应用程序的库。我们将在后面的章节中更多地探索Backbone框架。
- en: Angular
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular
- en: AngularJs (or just Angular) is also a very popular JavaScript framework, and
    is maintained by Google. Angular takes a completely different approach to building
    JavaScript SPA's, introducing an HTML syntax that the running Angular application
    understands. This provides the application with two-way data binding capabilities,
    which automatically synchronizes models, views and the HTML page. Angular also
    provides a mechanism for **Dependency Injection** (**DI**), and uses services
    to provide data to your views and models.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJs（或者只是Angular）也是一个非常流行的JavaScript框架，由Google维护。Angular采用了完全不同的方法来构建JavaScript
    SPA，引入了一个HTML语法，运行中的Angular应用程序可以理解。这为应用程序提供了双向数据绑定的能力，自动同步模型、视图和HTML页面。Angular还提供了**依赖注入**（**DI**）的机制，并使用服务来为视图和模型提供数据。
- en: 'Let''s take a look at a sample from the Angular Tutorial, found in step 2,
    where we start to build a controller named `PhoneListCtrl`. The example provided
    in the tutorial shows the following JavaScript:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下Angular教程中的一个示例，该示例位于第2步，我们开始构建一个名为`PhoneListCtrl`的控制器。教程中提供的示例显示了以下JavaScript：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This code snippet is typical of Angular JavaScript syntax. We start by creating
    a variable named `phonecatApp`, and register this as an Angular module by calling
    the `module` function on the `angular` global instance. The first argument to
    the `module` function is a global name for the Angular module, and the empty array
    is a place-holder for other modules that will be injected via Angular's Dependency
    Injection routines.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段是典型的Angular JavaScript语法。我们首先创建一个名为`phonecatApp`的变量，并通过在`angular`全局实例上调用`module`函数将其注册为一个Angular模块。`module`函数的第一个参数是Angular模块的全局名称，空数组是其他模块的占位符，这些模块将通过Angular的依赖注入机制注入。
- en: We then call the `controller` function on the newly created `phonecatApp` variable
    with two arguments. The first argument is the global name of the controller, and
    the second argument is a function that accepts a specially named Angular variable
    named `$scope`. Within this function, the code sets the `phones` object of the
    `$scope` variable to be an array of JSON objects, each with a `name` and `snippet`
    property.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用新创建的`phonecatApp`变量上的`controller`函数，带有两个参数。第一个参数是控制器的全局名称，第二个参数是一个接受名为`$scope`的特殊命名的Angular变量的函数。在这个函数中，代码将`$scope`变量的`phones`对象设置为一个JSON对象数组，每个对象都有`name`和`snippet`属性。
- en: 'If we continue reading through the tutorial, we find a unit test that shows
    how the `PhoneListCtrl` controller is used:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续阅读教程，我们会发现一个单元测试，展示了`PhoneListCtrl`控制器的使用方式：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first two lines of this code snippet use a global function called `describe`,
    and within this function another function called `it`. These two functions are
    part of a unit testing framework named Jasmine. We will cover unit testing in
    our next chapter, but for the time being, lets' focus on the rest of the code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段的前两行使用了一个名为`describe`的全局函数，以及在这个函数内部另一个名为`it`的函数。这两个函数是单元测试框架Jasmine的一部分。我们将在下一章讨论单元测试，但目前让我们专注于代码的其余部分。
- en: We declare a variable named `scope` to be an empty JavaScript object, and then
    a variable named `ctrl` that uses the `new` keyword to create an instance of our
    `PhoneListCtrl` class. The `new PhoneListCtrl(scope)` syntax shows that Angular
    is using the definition of the controller just like we would use a normal class
    in TypeScript.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个名为`scope`的变量，它是一个空的JavaScript对象，然后声明了一个名为`ctrl`的变量，它使用`new`关键字来创建我们`PhoneListCtrl`类的一个实例。`new
    PhoneListCtrl(scope)`语法表明Angular正在使用控制器的定义，就像我们在TypeScript中使用普通类一样。
- en: 'Building the same object in TypeScript would allow us to use TypeScript classes,
    as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中构建相同的对象将允许我们使用TypeScript类，如下所示：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our first line is the same as in our previous JavaScript sample. We then, however,
    use the TypeScript class syntax to create a class named `PhoneListCtrl`. By creating
    a TypeScript class, we can now use this class as shown in our Jasmine test code:
    `ctrl = new PhoneListCtrl(scope)`. The `constructor` function of our `PhoneListCtrl`
    class now acts as the anonymous function seen in the original JavaScript sample:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一行与之前的JavaScript示例相同。然而，我们使用了TypeScript类语法来创建一个名为`PhoneListCtrl`的类。通过创建一个TypeScript类，我们现在可以像在Jasmine测试代码中所示的那样使用这个类：`ctrl
    = new PhoneListCtrl(scope)`。我们`PhoneListCtrl`类的`constructor`函数现在充当了原始JavaScript示例中看到的匿名函数：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Angular classes and $scope
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular类和$scope
- en: 'Let''s expand our `PhoneListCtrl` class a little further, and have a look at
    what it would look like when completed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步扩展我们的`PhoneListCtrl`类，并看看完成后会是什么样子：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first thing to note in this class, is that we are defining a variable named
    `myScope`, and storing the `$scope` argument that is passed in via the constructor,
    into this internal variable. This is again because of JavaScript's lexical scoping
    rules. Note the call to `_.bindAll` at the end of the constructor. This Underscore
    utility function will ensure that whenever the `GetPhonesSuccess` function is
    called, it will use the variable `this` in the context of the class instance,
    and not in the context of the calling code. We will discuss the usage of `_.bindAll`
    in detail in a later chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中需要注意的第一件事是，我们正在定义一个名为`myScope`的变量，并将通过构造函数传入的`$scope`参数存储在这个内部变量中。这是因为JavaScript的词法作用域规则。请注意构造函数末尾的`_.bindAll`调用。这个Underscore实用函数将确保每当调用`GetPhonesSuccess`函数时，它将在类实例的上下文中使用变量`this`，而不是在调用代码的上下文中。我们将在后面的章节中详细讨论`_.bindAll`的用法。
- en: The `GetPhonesSuccess` function uses the `this.myScope` variable within its
    implementation. This is why we needed to store the initial `$scope` argument in
    an internal variable.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetPhonesSuccess`函数在其实现中使用了`this.myScope`变量。这就是为什么我们需要将初始的`$scope`参数存储在内部变量中的原因。'
- en: 'Another thing we notice from this code, is that the `myScope` variable is typed
    to an interface named `IScope`, which will need to be defined as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中我们注意到的另一件事是，`myScope`变量被类型化为一个名为`IScope`的接口，需要定义如下：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This `IScope` interface just contains an array of objects of type `IPhone` (pardon
    the unfortunate name of this interface – it can hold Android phones as well).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`IScope`接口只包含了一个`IPhone`类型的对象数组（请原谅这个接口的不幸命名 - 它也可以包含安卓手机）。
- en: What this means is that we don't have a standard interface or TypeScript type
    to use when dealing with `$scope` objects. By its nature, the `$scope` argument
    will change its type depending on when and where the Angular runtime calls it,
    hence our need to define an `IScope` interface, and strongly type the `myScope`
    variable to this interface.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们在处理`$scope`对象时没有标准的接口或TypeScript类型可用。由于其性质，`$scope`参数的类型会根据Angular运行时调用它的时间和位置而改变，因此我们需要定义一个`IScope`接口，并将`myScope`变量强类型化为这个接口。
- en: Another interesting thing to note on the constructor function of the `PhoneListCtrl`
    class is the type of the `$http` argument. It is set to be of type `ng.IHttpService`.
    This `IHttpService` interface is found in the declaration file for Angular. In
    order to use TypeScript with Angular variables such as `$scope` or `$http`, we
    need to find the matching interface within our declaration file, before we can
    use any of the Angular functions available on these variables.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`PhoneListCtrl`类的构造函数中另一个有趣的事情是`$http`参数的类型。它被设置为`ng.IHttpService`类型。这个`IHttpService`接口在Angular的声明文件中找到。为了在TypeScript中使用Angular变量（如`$scope`或`$http`），我们需要在声明文件中找到匹配的接口，然后才能使用这些变量上可用的任何Angular函数。'
- en: 'The last point to note in this constructor code is the final argument, named
    `Phone`. It does not have a TypeScript type assigned to it, and so automatically
    becomes of type `any`. Let''s take a quick look at the implementation of this
    `Phone` service, which is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个构造函数代码中要注意的最后一个参数是名为`Phone`的参数。它没有分配给它的TypeScript类型，因此自动变成了`any`类型。让我们快速看一下这个`Phone`服务的实现，如下所示：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first line of this code snippet again creates a global variable named `phonecatServices`,
    using the `angular.module` global function. We then call the `factory` function
    available on the `phonecatServices` variable, in order to define our `Phone` resource.
    This `factory` function uses a string named `'Phone'` to define the `Phone` resource,
    and then uses Angular's dependency injection syntax to inject a `$resource` object.
    Looking through this code, we can see that we cannot easily create standard TypeScript
    classes for Angular to use here. Nor can we use standard TypeScript interfaces
    or inheritance on this Angular service.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段的第一行再次使用`angular.module`全局函数创建了一个名为`phonecatServices`的全局变量。然后我们调用`phonecatServices`变量上可用的`factory`函数，以定义我们的`Phone`资源。这个`factory`函数使用一个名为`'Phone'`的字符串来定义`Phone`资源，然后使用Angular的依赖注入语法来注入一个`$resource`对象。通过查看这段代码，我们可以看到我们不能轻松地为Angular在这里使用标准的TypeScript类。也不能在这个Angular服务上使用标准的TypeScript接口或继承。
- en: Angular TypeScript compatibility
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular TypeScript兼容性
- en: When writing Angular code with TypeScript, we are able to use classes in certain
    instances, but must rely on the underlying Angular functions such as `module`
    and `factory` to define our objects in other cases. Also, when using standard
    Angular services, such as `$http` or `$resource`, we will need to specify the
    matching declaration file interface in order to use these services. We can therefore
    describe the Angular library as having medium compatibility with TypeScript.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用TypeScript编写Angular代码时，我们可以在某些情况下使用类，但在其他情况下必须依赖于底层的Angular函数（如`module`和`factory`）来定义我们的对象。此外，当使用标准的Angular服务（如`$http`或`$resource`）时，我们需要指定匹配的声明文件接口才能使用这些服务。因此，我们可以描述Angular库与TypeScript的兼容性为中等。
- en: Inheritance – Angular versus Backbone
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承 - Angular与Backbone
- en: Inheritance is a very powerful feature of object-oriented programming, and is
    also a fundamental concept when using JavaScript frameworks. Using a Backbone
    controller or an Angular controller within each framework relies on certain characteristics,
    or functions being available. We have seen, however, that each framework implements
    inheritance in a different way.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是面向对象编程的一个非常强大的特性，也是在使用JavaScript框架时的一个基本概念。在每个框架中使用Backbone控制器或Angular控制器都依赖于某些特性或可用的功能。然而，我们已经看到，每个框架以不同的方式实现继承。
- en: As JavaScript does not have the concept of inheritance, each framework needs
    to find a way to implement it, so that the framework can allow us to extend base
    classes and their functionality. In Backbone, this inheritance implementation
    is via the `extend` function of each Backbone object. As we have seen, the TypeScript
    `extends` keyword follows a similar implementation to Backbone, allowing the framework
    and language to dovetail each other.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript没有继承的概念，每个框架都需要找到一种实现方式，以便框架可以允许我们扩展基类及其功能。在Backbone中，这种继承实现是通过每个Backbone对象的`extend`函数来实现的。正如我们所见，TypeScript的`extends`关键字与Backbone的实现方式类似，允许框架和语言相互配合。
- en: Angular, on the other hand, uses its own implementation of inheritance, and
    defines functions on the angular global namespace to create classes (that is `angular.module`).
    We can also sometimes use the instance of an application (that is `<appName>.controller`)
    to create modules or controllers. We have found, though, that Angular uses controllers
    in a very similar way to TypeScript classes, and we can therefore simply create
    standard TypeScript classes that will work within an Angular application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Angular使用自己的继承实现，并在angular全局命名空间上定义函数来创建类（即`angular.module`）。我们有时也可以使用应用程序的实例（即`<appName>.controller`）来创建模块或控制器。不过，我们发现Angular与TypeScript类似地使用控制器，因此我们可以简单地创建标准的TypeScript类，这些类将在Angular应用程序中起作用。
- en: So far, we have only skimmed the surface of both the Angular TypeScript syntax
    and the Backbone TypeScript syntax. The point of this exercise was to try and
    understand how TypeScript can be used within each of these two third party frameworks.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是浅尝辄止了Angular TypeScript语法和Backbone TypeScript语法。这个练习的目的是尝试理解如何在这两个第三方框架中使用TypeScript。
- en: Be sure to visit [http://todomvc.com](http://todomvc.com), and have a look at
    the full source-code for the Todo application written in TypeScript for both Angular
    and Backbone. They can be found on the **Compile-to-JS** tab in the example section.
    These running code samples, combined with the documentation on each of these sites,
    will prove to be an invaluable resource when trying to write TypeScript syntax
    with an external third party library such as Angular or Backbone.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要访问[http://todomvc.com](http://todomvc.com)，并查看用TypeScript编写的Angular和Backbone的Todo应用程序的完整源代码。它们可以在示例部分的**Compile-to-JS**选项卡中找到。这些运行的代码示例，结合这些网站上的文档，将在尝试在外部第三方库（如Angular或Backbone）中编写TypeScript语法时，证明是一个宝贵的资源。
- en: Angular 2.0
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2.0
- en: The Microsoft TypeScript team and the Google Angular team have just completed
    a months long partnership, and have announced that the upcoming release of Angular,
    named Angular 2.0, will be built using TypeScript. Originally, Angular 2.0 was
    going to use a new language named AtScript for Angular development. During the
    collaboration work between the Microsoft and Google teams, however, the features
    of AtScript that were needed for Angular 2.0 development have now been implemented
    within TypeScript. This means that the Angular 2.0 library will be classed as
    highly compatible with TypeScript, once the Angular 2.0 library, and the 1.5 edition
    of the TypeScript compiler are available.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 微软TypeScript团队和谷歌Angular团队刚刚完成了数月的合作，并宣布即将发布的名为Angular 2.0的Angular版本将使用TypeScript构建。最初，Angular
    2.0将使用一种名为AtScript的新语言进行Angular开发。然而，在微软和谷歌团队的合作工作期间，AtScript的功能已经在TypeScript中实现，这是Angular
    2.0开发所需的。这意味着一旦Angular 2.0库和TypeScript编译器的1.5版可用，Angular 2.0库将被归类为与TypeScript高度兼容。
- en: ExtJs
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ExtJs
- en: ExtJs is a popular JavaScript library that has a wide variety of widgets, grids,
    graphing components, layout components and more. With release 4.0, ExtJs incorporated
    a model, view, controller style of application architecture into their libraries.
    Although it is free for open-source development, ExtJs requires a license for
    commercial use. It is popular with development teams that are building web-enabled
    desktop replacements, as its look and feel is comparable to normal desktop applications.
    ExtJs, by default, ensures that each application or component will look and feel
    exactly the same, no matter which browser it is run in, and it requires little
    or no need for CSS or HTML.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ExtJs是一个流行的JavaScript库，拥有各种各样的小部件、网格、图形组件、布局组件等。在4.0版中，ExtJs将模型、视图、控制器式的应用程序架构整合到他们的库中。虽然它对于开源开发是免费的，但对于商业用途需要许可证。它受到开发团队的欢迎，这些团队正在构建基于Web的桌面替代品，因为它的外观和感觉与普通的桌面应用程序相当。ExtJs默认确保每个应用程序或组件在任何浏览器中运行时看起来和感觉都完全相同，并且几乎不需要CSS或HTML。
- en: The ExtJs team, however, has not released an official TypeScript declaration
    file for ExtJs, despite much community pressure. Thankfully, the wider JavaScript
    community has come to the rescue, beginning with Mike Aubury. He wrote a small
    utility program to generate declaration files from the ExtJs documentation ([https://github.com/zz9pa/extjsTypescript](https://github.com/zz9pa/extjsTypescript)).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管社区施加了很大压力，ExtJs团队尚未发布官方的TypeScript声明文件。幸运的是，更广泛的JavaScript社区已经出手相助，首先是Mike
    Aubury。他编写了一个小型实用程序，从ExtJs文档中生成声明文件（[https://github.com/zz9pa/extjsTypescript](https://github.com/zz9pa/extjsTypescript)）。
- en: Whether this work influenced the current version of the ExtJs definitions on
    DefinitelyTyped or not, remains to be seen, but the original definitions from
    Mike Aubury and the current version from brian428 on DefinitelyTyped are very
    similar.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这项工作是否影响了DefinitelyTyped上当前版本的ExtJs定义，还有待观察，但Mike Aubury的原始定义和DefinitelyTyped上brian428的当前版本非常相似。
- en: Creating classes in ExtJs
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在ExtJs中创建类
- en: ExtJs is a JavaScript library that does things in its own way. If we were to
    categorize Backbone, Angular and ExtJs, we might say that Backbone is a highly
    compliant TypeScript library. In other words, the language features of classes
    and inheritance within TypeScript are highly compliant with Backbone.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ExtJs是一个以自己的方式做事的JavaScript库。如果我们要对Backbone、Angular和ExtJs进行分类，我们可能会说Backbone是一个高度兼容的TypeScript库。换句话说，TypeScript中的类和继承语言特性与Backbone高度兼容。
- en: Angular in this case would be a partially compliant library, with some elements
    of Angular objects complying with the TypeScript language features. ExtJs, on
    the other hand, would be a minimally compliant library, with little or no TypeScript
    language features applicable to the library.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Angular将是一个部分兼容的库，其中一些Angular对象的元素符合TypeScript语言特性。另一方面，ExtJs将是一个最低限度兼容的库，几乎没有适用于该库的TypeScript语言特性。
- en: 'Let''s take a look at a sample ExtJs 4.0 application written in TypeScript.
    Consider the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个用TypeScript编写的示例ExtJs 4.0应用程序。考虑以下代码：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We start by creating an ExtJs application by calling the `application` function
    on the `Ext` global instance. The `application` function then uses a JavaScript
    object, enclosed within the first and last curly braces `{ }` to define properties
    and functions. This ExtJs application sets the `name` property to be `SampleApp`,
    the `appFolder` property to be `/code/sample`, and the `controllers` property
    to be an array with a single entry: `''SampleController''`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过在`Ext`全局实例上调用`application`函数来创建一个ExtJs应用程序。然后，`application`函数使用一个JavaScript对象，在第一个和最后一个大括号`{
    }`中定义属性和函数。这个ExtJs应用程序将`name`属性设置为`SampleApp`，`appFolder`属性设置为`/code/sample`，`controllers`属性设置为一个包含一个条目的数组：`'SampleController'`。
- en: We then define a `launch` property, which is an anonymous function. This `launch`
    function then uses the `create` function on the global `Ext` instance to create
    a class. The `create` function uses the `"Ext.container.Viewport"` name to create
    an instance of the `Ext.container.Viewport` class, which has the properties `layout`
    and `items`. The `layout` property can only contain one of a specific set of values,
    for example `'fit'`, `'auto'` or `'table'`. The `items` array contains further
    ExtJs specific objects, which are created depending on what their `xtype` property
    suggests.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义了一个`launch`属性，这是一个匿名函数。这个`launch`函数然后使用全局`Ext`实例上的`create`函数来创建一个类。`create`函数使用`"Ext.container.Viewport"`名称来创建`Ext.container.Viewport`类的一个实例，该类具有`layout`和`items`属性。`layout`属性只能包含特定一组值之一，例如`'fit'`、`'auto'`或`'table'`。`items`数组包含进一步的ExtJs特定对象，这些对象根据它们的`xtype`属性创建。
- en: ExtJs is one of those libraries that is not intuitive. As a programmer, you
    will need to have one browser window open with the library documentation at all
    times, and use it to figure out what each property means for each type of available
    class. It also has a lot of magic strings – in the preceding sample, the `Ext.create`
    function would fail if we miss-typed the `'Ext.container.Viewport'` string, or
    simply forgot to capitalize it in the right places. To ExtJs, `'viewport'` is
    different to `'ViewPort'`. Remember that one of our solutions to magic strings
    within TypeScript is to use enums. Unfortunately, the current version of the ExtJs
    declaration file does not have a set of enums for these class types.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ExtJs是那种不直观的库之一。作为程序员，你需要随时打开一个浏览器窗口，查看库文档，并用它来弄清楚每个属性对于每种可用类的含义。它还有很多魔术字符串
    - 在前面的示例中，如果我们错写了`'Ext.container.Viewport'`字符串，或者在正确的位置忘记了大写，`Ext.create`函数将会失败。对于ExtJs来说，`'viewport'`和`'ViewPort'`是不同的。记住，我们在TypeScript中解决魔术字符串的一个方法是使用枚举。不幸的是，当前版本的ExtJs声明文件没有一组枚举来表示这些类类型。
- en: Using type casting
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类型转换
- en: 'We can, however, use the TypeScript language feature of type casting to help
    with writing ExtJs code. If we know what type of ExtJs object we are trying to
    create, we can cast the JavaScript object to this type, and then use TypeScript
    to check whether the properties we are using are correct for that type of ExtJs
    object. To help with this concept, let''s just take the outer definition of the
    `Ext.application` into account. Stripped of the inner code, the call to the `application`
    function on the `Ext` global object would be reduced to this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用TypeScript的类型转换语言特性来帮助编写ExtJs代码。如果我们知道我们要创建的ExtJs对象的类型，我们可以将JavaScript对象转换为这种类型，然后使用TypeScript来检查我们使用的属性是否适用于该类型的ExtJs对象。为了帮助理解这个概念，让我们只考虑`Ext.application`的外部定义。去掉内部代码后，对`Ext`全局对象上的`application`函数的调用将被简化为这样：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Using the TypeScript declaration files, type casting, and a healthy dose of
    ExtJs documentation, we know that the inner JavaScript object should be of type
    `Ext.app.IApplication`, and we can therefore cast this object as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TypeScript声明文件、类型转换和大量的ExtJs文档，我们知道内部JavaScript对象应该是`Ext.app.IApplication`类型，因此我们可以将这个对象转换为如下形式：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The second line of this code snippet now uses the TypeScript type casting syntax,
    to cast the JavaScript object between the curly braces `{ }` to a type of `Ext.app.IApplication`.
    This gives us strong type checking, and Intellisense, as shown in the following
    screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段的第二行现在使用了TypeScript类型转换语法，将大括号`{ }`之间的JavaScript对象转换为`Ext.app.IApplication`类型。这给我们提供了强类型检查和智能感知，如下图所示：
- en: '![Using type casting](img/9665OS_05_03.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![使用类型转换](img/9665OS_05_03.jpg)'
- en: Visual Studio intellisense for an ExtJs configuration block
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio对ExtJs配置块的智能感知
- en: In a similar manner, these explicit type casts can be used on any JavaScript
    object that is being used to create ExtJs classes. The declaration file for ExtJs
    currently on DefinitelyTyped uses the same names for its object definitions as
    the ExtJs documentation uses, so finding the correct type should be rather simple.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，这些显式类型转换也可以用于创建ExtJs类的任何JavaScript对象。目前在DefinitelyTyped上的ExtJs声明文件使用与ExtJs文档相同的对象定义名称，因此找到正确的类型应该相当简单。
- en: The preceding technique of using explicit type casting is just about the only
    language feature of TypeScript that we can use with the ExtJs library – but this
    still highlights how strong typing of objects can assist us in our development
    experience, making our code more robust and resistant to errors.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 上述显式类型转换的技术几乎是我们可以在ExtJs库中使用的唯一的TypeScript语言特性 - 但这仍然突显了对象的强类型化如何在开发过程中帮助我们，使我们的代码更加健壮，更加抗错误。
- en: ExtJs specific TypeScript compiler
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ExtJs特定的TypeScript编译器
- en: If you are using ExtJs on a regular basis, then you may want to take a look
    at the work done by Gareth Smith, Fabio Parra dos Santos and their team at [https://github.com/fabioparra/TypeScript](https://github.com/fabioparra/TypeScript).
    This project is a fork of the TypeScript compiler that will emit ExtJs classes
    from standard TypeScript classes. Using this version of the compiler turns the
    tables on normal ExtJs development, allowing for natural TypeScript class syntax,
    the use of inheritance via the `extends` keyword, as well as natural module naming,
    without the need for magic strings. The work done by this team shows that because
    the TypeScript compiler is open-source, it can be extended and modified to emit
    JavaScript in a specific way, or to target a specific library. Hats off to Gareth,
    Fabio and their team for their ground-breaking work in this area.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经常使用ExtJs，那么你可能会想看看Gareth Smith、Fabio Parra dos Santos及其团队在[https://github.com/fabioparra/TypeScript](https://github.com/fabioparra/TypeScript)上的工作。这个项目是TypeScript编译器的一个分支，它将从标准的TypeScript类中生成ExtJs类。使用这个版本的编译器可以改变正常的ExtJs开发方式，允许使用自然的TypeScript类语法，通过`extends`关键字使用继承，以及自然的模块命名，而不需要魔术字符串。这个团队的工作表明，由于TypeScript编译器是开源的，它可以被扩展和修改以特定的方式生成JavaScript，或者针对特定的库。向Gareth、Fabio和他们的团队致敬，因为他们在这个领域做出了开创性的工作。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have had a look at third party JavaScript libraries and
    how they can be used within a TypeScript application. We started by looking at
    the various ways of including community released versions of TypeScript declaration
    files within our projects, from downloading the raw files, to using package managers
    like NuGet and TSD. We then looked at three types of third party libraries, and
    discussed how to integrate these libraries with TypeScript. We explored Backbone,
    which can be categorized as a highly compliant third party library, Angular, which
    is a partially compliant library, and ExtJs which is a minimally compliant library.
    We saw how various features of the TypeScript language can co-exist with these
    libraries, and showed what TypeScript equivalent code would look like in each
    of these cases. In the next chapter, we will look at Test Driven Development,
    and explore some of the libraries that are available for unit testing, integration
    testing, and automated acceptance testing.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看过第三方JavaScript库以及它们如何在TypeScript应用程序中使用。我们首先看了包括社区发布的TypeScript声明文件在内的各种包含方式，从下载原始文件到使用NuGet和TSD等包管理器。然后，我们看了三种类型的第三方库，并讨论了如何将这些库与TypeScript集成。我们探讨了Backbone，它可以被归类为高度兼容的第三方库，Angular是一个部分兼容的库，而ExtJs是一个最低限度兼容的库。我们看到了TypeScript语言的各种特性如何与这些库共存，并展示了在这些情况下TypeScript等效代码会是什么样子。在下一章中，我们将看看测试驱动开发，并探讨一些可用于单元测试、集成测试和自动验收测试的库。
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为Bentham Chang准备，Safari ID bentham@gmail.com 用户编号：2843974 © 2015 Safari Books
    Online，LLC。此下载文件仅供个人使用，并受到服务条款的约束。任何其他用途均需著作权所有者的事先书面同意。未经授权的使用、复制和/或分发严格禁止并违反适用法律。保留所有权利。
