["```cs\npublic static (int, string) FindOddEvenBySingleNumber(int number) \n{ \n   string oddOrEven = IsOddNumber(number) ? \"Odd\" :\"Even\"; \n   return (number, oddOrEven);//tuple literal \n} \nFindOddEvenBySingleNumber is returning multiple values, which tells us whether a number is odd or even. See the return statement return (number, oddOrEven) of the preceding code: here, we are simply returning two different variables. Now, how are these values accessible from the caller method? In this case, we are returning a tuple value and the caller method will receive a tuple with these values, which are nothing but elements or items of a tuple. In this case, the number will be available as Item1 and oddOrEven as Item2 for the caller method. The following is from the caller method:\n```", "```cs\nvar result = OddEven.FindOddEvenBySingleNumber(Convert.ToInt32(number); \nConsole.WriteLine($\"Number:{result.Item1} is {result.Item2}\"); \nresult.Item1 represents number and result.Item2 represents oddOrEven. This is fine when someone knows the representation of these tuple items/elements. But think of a scenario where we have numerous tuple elements and the developer who is writing the caller method is not aware of the representation of these items/elements. In that case, it is bit complex to consume these tuple items/elements. To overcome this problem, we can give a name to these tuple items. We call these named tuple items/elements. Let us modify our method FindOddEvenBySingleNumber to return named tuple items:\n```", "```cs\npublic static (int number, string oddOrEvent) FindOddEvenBySingleNumber (int number) \n{ \n   string result = IsOddNumber(number) ? \"Odd\" : \"Even\"; \n   return (number:number, oddOrEvent: result);//returning\n   named tuple element in tuple literal \n} \n```", "```cs\nvar result = OddEven.FindOddEvenBySingle(Convert.ToInt32(number)); \nConsole.WriteLine($\"Number:{result.number} is {result.oddOrEvent}\"); \n```", "```cs\npublic static bool CompareToTuple(int number) \n{ \n   var oddEvenValueTuple =\n   FindOddEvenBySingleNumber(number); \n   var differentTupleValue =\n   FindOddEvenBySingleNumberNamedElement(number + 1); \n   var res =\n   oddEvenValueTuple.CompareTo(differentTupleValue); \n   return res == 0; // 0 if other is a ValueTuple instance\n   and 1 if other is null \n} \npublic static bool CompareToTuple1(int number) \n{ \n    var oddEvenValueTuple =\n    FindOddEvenBySingleNumber(number); \n    var sameTupleValue =\n    FindOddEvenBySingleNumberNamedElement(number); \n    var res = oddEvenValueTuple.CompareTo(sameTupleValue); \n    return res == 0;// 0 if other is a ValueTuple instance\n    and 1 if other is null \n} \n```", "```cs\nConsole.Clear(); \nConsole.Write(\"Enter number: \"); \nvar num = Console.ReadLine(); \nvar resultNum = OddEven.FindOddEvenBySingleNumberNamedElement(Convert.ToInt32(num)); \nConsole.WriteLine($\"Number:{resultNum.number} is {resultNum.oddOrEven}.\"); \nConsole.WriteLine(); \nvar comp = OddEven.CompareToTuple(Convert.ToInt32(num)); \nConsole.WriteLine($\"Comparison of two Tuple objects having different value is:{comp}\"); \nvar comp1 = OddEven.CompareToTuple1(Convert.ToInt32(num)); \nConsole.WriteLine($\"Comparison of two Tuple objects having same value is:{comp1}\"); \n```", "```cs\npublic static bool EqualToTuple(int number) \n{ \n   var oddEvenValueTuple =\n   FindOddEvenBySingleNumber(number); \n   var sameTupleValue =\n   FindOddEvenBySingleNumberNamedElement(number); \n   var res = oddEvenValueTuple.Equals(sameTupleValue); \n   return res;//true if obj is a ValueTuple instance;\n   otherwise, false. \n} \n```", "```cs\nvar num1 = Console.ReadLine(); \nvar namedElement = OddEven.FindOddEvenBySingleNumberNamedElement(Convert.ToInt32(num1)); \nConsole.WriteLine($\"Number:{namedElement.number} is {namedElement.oddOrEven}.\"); \nConsole.WriteLine(); \nvar equalToTuple = OddEven.EqualToTuple(Convert.ToInt32(num1)); \nConsole.WriteLine($\"Equality of two Tuple objects is:{equalToTuple}\"); \nvar equalToObject = OddEven.EqualToObject(Convert.ToInt32(num1)); \nConsole.WriteLine($\"Equality of one Tuple object with other non tuple object is:{equalToObject}\"); \n```", "```cs\npublic static ValueTuple CreateValueTuple() => ValueTuple.Create();\n```", "```cs\npublic static ValueTuple<int> CreateValueTupleSingleton(int number) => ValueTuple.Create(number); \npublic static ValueTuple<int, int, int, int, int, int, int, ValueTuple<int,string>> OctupleUsingCreate() => ValueTuple.Create(1, 2, 3, 4, 5, 6, 7, ValueTuple.Create(8, IsOddNumber(8) ? \"Odd\" : \"Even\")); \n```", "```cs\npublic static string ExplicitlyTypedDeconstruction(int num) \n{ \n   (int number, string evenOdd) =\n   FindOddEvenBySingleNumber(num); \n   return $\"Entered number:{number} is {evenOdd}.\"; \n} \n```", "```cs\npublic static string ImplicitlyTypedDeconstruction(int num) \n{ \n   var (number, evenOdd) =\n   FindOddEvenBySingleNumber(num); \n   //Following deconstruct is also valid \n   //(int number, var evenOdd) =\n   FindOddEvenBySingleNumber(num); \n   return $\"Entered number:{number} is {evenOdd}.\"; \n} \n```", "```cs\npublic static string UserDefinedTypeDeconstruction(int num) \n{ \n   var customModel = new UserDefinedModel(num,\n   IsOddNumber(num) ? \"Odd\" : \"Even\"); \n   var (number,oddEven) = customModel; \n   return $\"Entered number:{number} is {oddEven}.\"; \n} \n```", "```cs\nvar oddNumber = (3, \"Odd\"); //Unnamed tuple \n```", "```cs\nvar oddNumber = (number: 3, oddOrEven: \"Odd\"); //Named Tuple \n```", "```cs\nConsole.Write(\"Enter first number: \"); \nvar userInputFirst = Console.ReadLine(); \nConsole.Write(\"Enter second number: \"); \nvar userInputSecond = Console.ReadLine(); \nvar noNamed = OddEven.FindOddEvenBySingleNumber(Convert.ToInt32(userInputFirst)); \nvar named = OddEven.FindOddEvenBySingleNumberNamedElement(Convert.ToInt32(userInputSecond)); \nConsole.WriteLine($\"First Number:{noNamed.Item1} is {noNamed.Item2} using noNamed tuple.\"); \nConsole.WriteLine($\"Second Number:{named.number} is {named.oddOrEven} using Named tuple.\"); \n\nConsole.WriteLine(\"Assigning 'Named' to 'NoNamed'\"); \n                        noNamed = named; \nConsole.WriteLine($\"Number:{noNamed.Item1} is {named.Item2} after assignment.\"); \nConsole.Write(\"Enter third number: \"); \nvar userInputThird = Console.ReadLine(); \nvar noNamed2 = OddEven.FindOddEvenBySingleNumber(Convert.ToInt32(userInputThird)); \nConsole.WriteLine($\"Third Number:{noNamed2.Item1} is {noNamed2.Item2} using second noNamed tuple.\"); \nConsole.WriteLine(\"Assigning 'second NoNamed' to 'Named'\"); \nnamed = noNamed2; \nConsole.WriteLine($\"Second Number:{named.number} is {named.oddOrEven} after assignment.\"); \n```", "```cs\npublic static string MatchingPatterUsingIs(object character) \n{ \n   if (character is null) \n   return $\"{nameof(character)} is null. \"; \n   if (character is char) \n   { \n      var isVowel = IsVowel((char) character) ? \"is a\n      vowel\" : \"is a consonent\"; \n      return $\"{character} is char and {isVowel}. \"; \n   } \n   if (character is string) \n   { \n      var chars = ((string) character).ToArray(); \n      var stringBuilder = new StringBuilder(); \n      foreach (var c in chars) \n      { \n         if (!char.IsWhiteSpace(c)) \n         { \n         var isVowel = IsVowel(c) ? \"is a vowel\" : \"is a\n         consonent\"; \n         stringBuilder.AppendLine($\"{c} is char of string\n         '{character}' and {isVowel}.\"); \n         } \n       } \n\n       return stringBuilder.ToString(); \n     } \n     throw new ArgumentException(\n     \"character is not a recognized data type.\", \n     nameof(character)); \n} \n```", "```cs\nif (character is string str) \n{ \n    var chars = str.ToArray(); \n    var stringBuilder = new StringBuilder(); \n    foreach (var c in chars) \n    { \n        if (!char.IsWhiteSpace(c)) \n        { \n            var isVowel = IsVowel(c) ? \"is a vowel\" : \"is\n            a consonent\"; \n            stringBuilder.AppendLine($\"{c} is char of\n            string '{character}' and {isVowel}.\"); \n        } \n    } \n\n    return stringBuilder.ToString(); \n} \n```", "```cs\nif (character is int number) \nreturn $\"{nameof(character)} is int {number}.\"; \n```", "```cs\nprivate static IEnumerable<char> Vowels => new[] {'a', 'e', 'i', 'o', 'u'}; \n\npublic static string MatchingPatterUsingIs(object character) \n{ \n    if (character is null) \n    return $\"{nameof(character)} is null. \"; \n    if (character is char) \n    { \n        var isVowel = IsVowel((char) character) ? \"is a \n        vowel\" : \"is a consonent\"; \n        return $\"{character} is char and {isVowel}. \"; \n    } \n    if (character is string str) \n    { \n        var chars = str.ToArray(); \n        var stringBuilder = new StringBuilder(); \n        foreach (var c in chars) \n        { \n            if (!char.IsWhiteSpace(c)) \n            { \n                var isVowel = IsVowel(c) ? \"is a vowel\" :\n                \"is a consonent\"; \n                stringBuilder.AppendLine($\"{c} is char of\n                string '{character}' and {isVo \n            } \n        } \n\n        return stringBuilder.ToString(); \n    } \n\n    if (character is int number) \n    return $\"{nameof(character)} is int {number}.\"; \n\n    throw new ArgumentException( \n    \"character is not a recognized data type.\", \n    nameof(character)); \n} \n\nprivate static bool IsVowel(char character) => Vowels.Contains(char.ToLower(character));\n```", "```cs\npublic static string ConstantPatternUsingSwitch(params char[] inputChar) \n{ \n    switch (inputChar.Length) \n    { \n\n        case 0: \n            return $\"{nameof(inputChar)} contains no\n            elements.\"; \n        case 1: \n            return $\"'{inputChar[0]}' and\n            {VowelOrConsonent(inputChar[0])}.\"; \n        case 2: \n            var sb = new\n            StringBuilder().AppendLine($\"'{inputChar[0]}'\n            and {VowelOrConsonent(inputChar[0])}.\"); \n            sb.AppendLine($\"'{inputChar[1]}' and\n            {VowelOrConsonent(inputChar[1])}.\"); \n            return sb.ToString(); \n        case 3: \n            var sb1 = new\n            StringBuilder().AppendLine($\"'{inputChar[0]}'\n            and {VowelOrConsonent(inputChar[0])}.\"); \n            sb1.AppendLine($\"'{inputChar[1]}' and\n            {VowelOrConsonent(inputChar[1])}.\"); \n            sb1.AppendLine($\"'{inputChar[2]}' and\n            {VowelOrConsonent(inputChar[2])}.\"); \n            return sb1.ToString(); \n        case 4: \n            var sb2 = new\n            StringBuilder().AppendLine($\"'{inputChar[0]}'\n            and {VowelOrConsonent(inputChar[0])}.\"); \n            sb2.AppendLine($\"'{inputChar[1]}' and\n            {VowelOrConsonent(inputChar[1])}.\"); \n            sb2.AppendLine($\"'{inputChar[2]}' and\n            {VowelOrConsonent(inputChar[2])}.\"); \n            sb2.AppendLine($\"'{inputChar[3]}' and\n            {VowelOrConsonent(inputChar[3])}.\"); \n            return sb2.ToString(); \n        case 5: \n            var sb3 = new\n            StringBuilder().AppendLine($\"'{inputChar[0]}'\n            and {VowelOrConsonent(inputChar[0])}.\"); \n            sb3.AppendLine($\"'{inputChar[1]}' and\n            {VowelOrConsonent(inputChar[1])}.\"); \n            sb3.AppendLine($\"'{inputChar[2]}' and\n            {VowelOrConsonent(inputChar[2])}.\"); \n            sb3.AppendLine($\"'{inputChar[3]}' and\n            {VowelOrConsonent(inputChar[3])}.\"); \n            sb3.AppendLine($\"'{inputChar[4]}' and\n            {VowelOrConsonent(inputChar[4])}.\"); \n            return sb3.ToString(); \n            default: \n            return $\"{inputChar.Length} exceeds from\n            maximum input length.\"; \n    } \n} \n```", "```cs\npublic static string TypePatternUsingSwitch(IEnumerable<object> inputObjects) \n{ \n    var message = new StringBuilder(); \n    foreach (var inputObject in inputObjects) \n    switch (inputObject) \n        { \n            case char c: \n                message.AppendLine($\"{c} is char and\n                {VowelOrConsonent(c)}.\"); \n                break; \n            case IEnumerable<object> listObjects: \n                foreach (var listObject in listObjects)\n\n                message.AppendLine(MatchingPatterUsingIs(\n                listObject)); \n                break; \n            case null: \n                break; \n        } \n    return message.ToString(); \n} \n```", "```cs\npublic static string TypePatternWhenInCaseUsingSwitch(IEnumerable<object> inputObjects) \n{ \n    var message = new StringBuilder(); \n    foreach (var inputObject in inputObjects) \n    switch (inputObject) \n        { \n            case char c: \n                message.AppendLine($\"{c} is char and\n                {VowelOrConsonent(c)}.\"); \n                break; \n            case IEnumerable<object> listObjects when\n                listObjects.Any(): \n                foreach (var listObject in listObjects) \n                message.AppendLine(MatchingPatterUsingIs\n                (listObject)); \n                break; \n            case IEnumerable<object> listInlist: \n                break; \n            case null: \n                break; \n        } \n    return message.ToString(); \n} \n```", "```cs\npublic static string FindOddEvenBySingleNumber(int number) => IsOddNumber(number) ? \"Odd\" : \"Even\";\n```", "```cs\nprivate static bool IsOddNumber(int number) => number >= 1 && number % 2 != 0; \n```", "```cs\npublic string FindOddEvenBySingleNumberUsingLocalFunction(int someInput) \n{ \n    //Local function, scoped within\n    FindOddEvenBySingleNumberUsingLocalFunction \n    bool IsOddNumber(int number) \n    { \n        return number >= 1 && number % 2 != 0; \n    } \n\n    return IsOddNumber(someInput) ? \"Odd\" : \"Even\"; \n} \n```", "```cs\n//Binary literals\npublic const int Nineteen = 0b00010011; \npublic const int Ten = 0b00001010; \npublic const int Four = 0b0100; \npublic const int Eight = 0b1000; \n```", "```cs\n//Digit separator - Binary numbers \npublic const int Hundred = 0b0110_0100; \npublic const int Fifty = 0b0011_0010; \npublic const int Twenty = 0b0001_0100; \n//Numeric separator \npublic const long Billion = 100_000_0000; \n\n```", "```cs\nstatic Task Main()\n{\n    //stuff goes here\n}\nstatic Task<int> Main()\n{\n    //stuff goes here\n}\nstatic Task Main(string[] args)\n{\n    //stuff goes here\n}\nstatic Task<int> Main(string[] args)\n{\n    //stuff goes here\n}\n```", "```cs\npublic static void Main()\n{\n    NewMain().GetAwaiter().GetResult();\n}\nprivate static async Task NewMain()\n{\n    //async stuff goes here\n}\n```", "```cs\nprivate static void Main(string[] args)\n{\n    //stuff goes here\n}\n```", "```cs\ndefault:\n```", "```cs\n//Code removed\ncase 8:\n    Clear();\n    WriteLine(\"C# 7.1 feature: default expression\");\n    int thisIsANewDefault = default;\n    var thisIsAnOlderDefault = default(int);\n    WriteLine($\"New default:{thisIsANewDefault}. Old\n    default:{thisIsAnOlderDefault}\");\n    PressAnyKey();\n    break;\n//Code removed\n```", "```cs\nint thisIsANewDefault = default;\nint thisIsAnOlderDefault = default(int);\nvar thisIsAnOlderDefaultAndStillValid = default(int);\nvar thisIsNotValid = default; //Not valid, as we cannot assign default to implicit-typed variable\n```", "```cs\nconst int thisIsANewDefaultConst = default; //valid\nconst int thisIsAnOlderDefaultCont = default(int); //valid\nconst int? thisIsInvalid = default; //Invalid, as nullable cannot be declared const\n```", "```cs\npublic static void InferTupleNames(int num1, int num2)\n{\n    (int, int) noNamed = (num1, num2);\n    (int, int) IgnoredName = (A:num1, B:num2);\n    (int a, int b) typeNamed = (num1, num2);\n    var named = (num1, num2);\n    var noNamedVariation = (num1, num1);\n    var explicitNaming = (n: num1, num1);\n    var partialnamed = (num1, 5);\n}\n```", "```cs\npublic static void InferTupleNames(int num1, int num2)\n{\n    (int, int) noNamed = (num1, num2);\n    Console.WriteLine($\"NoNamed:{noNamed.Item1},\n    {noNamed.Item2}\");\n    (int, int) ignoredName = (A:num1, B:num2);\n    Console.WriteLine($\"IgnoredName:{ignoredName.Item1}\n    ,{ignoredName.Item2}\");\n    (int a, int b) typeNamed = (num1, num2);\n    Console.WriteLine($\"typeNamed using default member-\n    names:{typeNamed.Item1}\n    {typeNamed.Item2}\");\n    Console.WriteLine($\"typeNamed:{typeNamed.a},\n    {typeNamed.b}\");\n    var named = (num1, num2);\n    Console.WriteLine($\"named using default member-names\n    :{named.Item1},{named.Item2}\");\n    Console.WriteLine($\"named:{named.num1},{named.num2}\");\n    var noNamedVariation = (num1, num1);\n    Console.WriteLine($\"noNamedVariation:\n    {noNamedVariation.Item1},{noNamedVariation.Item2}\");\n    var explicitNaming = (n: num1, num1);\n    Console.WriteLine($\"explicitNaming:{explicitNaming.n},\n    {explicitNaming.num1}\");\n    var partialnamed = (num1, 5);\n    Console.WriteLine($\"partialnamed:{partialnamed.num1},\n    {partialnamed.Item2}\");\n}\n```", "```cs\npublic class employee\n{\npublic Guid EmplId { get; set; }\npublic String First { get; set; }\npublic string Last { get; set; }\npublic char Sex { get; set; }\npublic string DepartmentId { get; set; }\npublic string Designation { get; set; }\n}\n```"]