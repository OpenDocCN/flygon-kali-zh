- en: JVM Processes and Garbage Collection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM进程和垃圾回收
- en: This chapter allows readers to look under the hood of JVM and learn about its
    processes. The structure and behavior of JVM is more complex than just an executor
    of a sequence of instructions according to the coded logic. JVM finds and loads
    into the memory the `.class` files requested by the application, verifies them,
    interprets the bytecodes (translates them into platform-specific binary code),
    and passes the resulting machine code to the central processor (or processors)
    for execution, using several service threads in addition to the application threads.
    One of the service threads, called garbage collection, performs the important
    mission of releasing the memory from unused objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使读者能够深入了解JVM并了解其进程。 JVM的结构和行为比仅仅按照编码逻辑执行一系列指令的执行器更复杂。 JVM会找到并加载应用程序请求的`.class`文件到内存中，对其进行验证，解释字节码（将其转换为特定平台的二进制代码），并将生成的机器代码传递给中央处理器（或处理器）进行执行，除了应用程序线程外，还使用几个服务线程。其中一个名为垃圾回收的服务线程执行重要任务，即释放未使用对象的内存。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What are JVM processes?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM进程是什么？
- en: JVM architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM架构
- en: Garbage collection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Threads
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程
- en: Exercise – Monitoring JVM while running an application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习-在运行应用程序时监视JVM
- en: What are JVM processes?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM进程是什么？
- en: As we have established already in [Chapter 1](40b2d539-5f9c-4923-87ac-803c281a5ba7.xhtml),
    *Java Virtual Machine (JVM) on Your Computer*, JVM does not know anything about
    the Java language and source code. It only knows how to read Byte Code. It reads
    the bytecodes and other information from `.class` files, interprets it (transforms
    it into the sequence of binary code instructions specific to a particular microprocessor,
    where JVM is running), and passes the result to the computer that executes it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](40b2d539-5f9c-4923-87ac-803c281a5ba7.xhtml)中已经确定的那样，*计算机上的Java虚拟机（JVM）*，JVM对Java语言和源代码一无所知。
    它只知道如何读取字节码。 它从`.class`文件中读取字节码和其他信息，解释它（将其转换为特定微处理器的二进制代码序列），并将结果传递给执行它的计算机。
- en: While talking about it, programmers often refer to JVM as *JVM instance* or
    *process*. This is because every time a `java` command is executed, a new *instance*
    of JVM is launched, dedicated to running the particular application in a separate
    process with the allocated memory size (default or passed in as the command option).
    Inside this JVM process, multiple threads are running, each with their own allocated
    memory; some are service threads created by the JVM, while others are application
    threads created and controlled by the application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论它时，程序员经常将JVM称为* JVM实例*或*进程*。 这是因为每次执行`java`命令时，都会启动一个新的JVM *实例*，专门用于在单独的进程中运行特定应用程序，并分配内存大小（默认或作为命令选项传递）。
    在这个JVM进程内部，多个线程正在运行，每个线程都有自己分配的内存； 一些是JVM创建的服务线程，而其他是应用程序创建和控制的应用程序线程。
- en: Threads are lightweight processes that require less resource allocation than
    the JVM execution process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是轻量级进程，需要比JVM执行进程更少的资源分配。
- en: That is the big picture of JVM executing the compiled code. But if you look
    closer and read the JVM Specification, you will discover that the word process
    in relation to JVM is overloaded many times. The JVM Specification identifies
    several other processes running inside the JVM that are usually not mentioned
    by programmers, except maybe the class loading process.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是JVM执行编译代码的大局观。 但是，如果您仔细观察并阅读JVM规范，您会发现与JVM相关的“进程”一词被重复使用了很多次。 JVM规范确定了JVM内部运行的其他几个进程，程序员通常不提及它们，除了可能是类加载过程。
- en: That is so because, most of the time, one can successfully write and execute
    Java programs without knowing more than that about JVM. But once in a while, some
    general understanding of JVM's internal workings helps to identify the root cause
    of certain related issues. That is why, in this section, we will provide a short
    overview of all the processes that happen inside JVM. Then, in the following sections,
    we will discuss JVM's memory structure and some other aspects of JVM functionality
    that may be useful to a programmer in more detail.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为大多数情况下，人们可以成功地编写和执行Java程序，而无需了解JVM的更多信息。 但是偶尔，对JVM内部工作原理的一些一般了解有助于确定某些相关问题的根本原因。
    这就是为什么在本节中，我们将简要概述JVM内部发生的所有进程。 然后，在接下来的几节中，我们将更详细地讨论JVM的内存结构和JVM功能的其他一些方面，这可能对程序员有用。
- en: 'There are two subsystems that run all the JVM internal processes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个子系统运行所有JVM内部进程：
- en: 'Classloader, which reads `.class` files and populates method areas in JVM memory
    with the class-related data:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类加载器，读取`.class`文件并使用类相关数据填充JVM内存中的方法区域：
- en: Static fields
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态字段
- en: Method bytecodes
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法字节码
- en: Class metadata that describes the class
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述类的类元数据
- en: 'Execution engine, which executes the bytecodes using:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行引擎，使用以下内容执行字节码：
- en: Heap area for object instantiation
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆区用于对象实例化
- en: Java and native method stacks for keeping track of the methods called
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java和本地方法堆栈用于跟踪调用的方法
- en: A garbage collection process to reclaim the memory
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收过程以回收内存
- en: 'The list of the processes that run inside the main JVM process includes:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在主JVM进程内部的进程列表包括：
- en: 'Processes performed by the classloader:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类加载器执行的进程：
- en: Class loading
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类加载
- en: Class linking
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类链接
- en: Class initialization
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类初始化
- en: 'Processes performed by the execution engine:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行引擎执行的进程：
- en: Class instantiation
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类实例化
- en: Method execution
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法执行
- en: Garbage collection
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Application termination
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序终止
- en: 'The JVM architecture can be described as having two subsystems—the classloader
    and the execution engine—that run the service processes and application threads
    using runtime data memory areas: method area, heap, and application thread stacks.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: JVM架构可以描述为具有两个子系统 - 类加载器和执行引擎 - 它们使用运行时数据内存区域运行服务进程和应用程序线程：方法区域，堆和应用程序线程堆栈。
- en: The preceding list may give you the impression that these processes are executed
    sequentially. To some degree, this is true, if we talk about one class only. It
    is not possible to do anything with a class before loading. Аn execution of a
    method can begin only after all the previous processes are completed. However,
    the garbage collection, for example, doesn't happen immediately after the object
    stops being used (see the following section, *Garbage collection*). Also, an application
    can exit any time when an unhandled exception or some other error happens.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表可能会让你觉得这些过程是按顺序执行的。在某种程度上，如果我们只谈论一个类的话，这是正确的。在加载之前无法对类做任何操作。只有在完成所有先前的过程之后，方法的执行才能开始。然而，例如垃圾回收并不会在对象停止使用后立即发生（请参阅下一节，*垃圾回收*）。此外，应用程序可能在发生未处理的异常或其他错误时随时退出。
- en: Only the classloader processes are regulated by the JVM specification. The execution
    engine's implementation is largely at the discretion of each vendor. It is based
    on the language semantics and the performance goals set by the implementation
    authors.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: JVM规范只对类加载器进程进行了规定。执行引擎的实现在很大程度上取决于每个供应商。它基于语言语义和实现作者设定的性能目标。
- en: The processes of the execution engine are not regulated by the JVM Specification.
    There is common sense, tradition, known and proven solutions, and the Java language
    specification that can guide a JVM vendor's implementation decisions, but there
    is no single regulatory document. The good news is that the most popular JVMs
    use similar solutions or, at least, that's how it looks from a high level of an
    introductory course. For vendor-specific details, see *Comparison of Java virtual
    machines* on Wikipedia ([https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines](https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines))
    and other sources available on the internet.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 执行引擎的过程不受JVM规范的约束。有常识、传统、已知和经过验证的解决方案，以及Java语言规范可以指导JVM供应商的实现决策，但没有单一的监管文件。好消息是，最流行的JVM使用类似的解决方案，或者至少从入门课程的高层来看是这样的。有关特定供应商的详细信息，请参阅维基百科上的*Java虚拟机比较*（[https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines](https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines)）和其他互联网上可用的来源。
- en: With this in mind, let's describe each of the seven processes listed previously
    in more detail.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个理解，让我们更详细地描述之前列出的七个过程中的每一个。
- en: Loading
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载
- en: According to JVM Specification, the loading phase encompasses finding the `.class`
    file by its name and creating its representation in the memory.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 根据JVM规范，加载阶段包括通过其名称找到`.class`文件并在内存中创建其表示。
- en: The first class to be loaded is the one passed in the command line, with the
    method `main(String[])` in it. We previously described it in [Chapter 4](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml),
    *Your First Java Project*. The classloader reads the `.class` file, parses it according
    to the internal data structure, and populates the method area with static fields
    and method bytecodes. It also creates an instance of `java.lang.Class` that describes
    the class. Then, the classloader links (see section *Linking*) and initializes
    (see section *Initialization*) the class and passes it to the execution engine
    for running its bytecodes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载的第一个类是在命令行中传递的带有`main(String[])`方法的类。我们之前在[第4章](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml)中描述过它，*你的第一个Java项目*。类加载器读取`.class`文件，根据内部数据结构解析它，并用静态字段和方法字节码填充方法区。它还创建了描述该类的`java.lang.Class`的实例。然后，类加载器链接（见*链接*部分）和初始化（见*初始化*部分）该类，并将其传递给执行引擎以运行其字节码。
- en: In the first project in [Chapter 4](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml), *Your
    First Java Project*, the `main(String[])` method did not use any other methods
    or classes. But in a real-life application, the `main(String[])` method is an
    entrance door into the application. If it calls a method of another class, that
    class has to be found on the classpath and read, parsed, and initialized; only
    then can its method be executed too. And so on. That is how a Java application
    starts and gets going.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml)中的第一个项目，*你的第一个Java项目*中，`main(String[])`方法没有使用任何其他方法或类。但在实际应用程序中，`main(String[])`方法是应用程序的入口。如果它调用另一个类的方法，那么必须在类路径上找到该类并读取、解析和初始化；只有这样它的方法才能被执行。依此类推。这就是Java应用程序的启动和运行方式。
- en: In the following section, *How to execute the main(String[]) method*, we will
    show several ways a Java application can be started, including using an executable
    `.jar` file with a manifest.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分*如何执行main(String[])方法*中，我们将展示Java应用程序可以启动的几种方式，包括使用带有清单的可执行`.jar`文件。
- en: Every class is allowed to have a `main(String[])` method and often does. Such
    a method is used to run the class independently as a standalone application for
    testing or demo purposes. The presence of such a method does not make the class
    main. The class becomes main only if it's identified as such in the `java` command
    line or in a `.jar` file manifest.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都允许有一个`main(String[])`方法，通常也有。这样的方法用于独立运行类作为独立应用程序进行测试或演示。这样的方法的存在并不使类成为主类。只有在`java`命令行或`.jar`文件清单中标识为主类时，该类才成为主类。
- en: That said, let's continue with the discussion of the loading process.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这些，让我们继续讨论加载过程。
- en: If you look in the API of `java.lang.Class`, you will not see a public constructor
    there. The classloader creates its instance automatically and, by the way, is
    the same instance that is returned by the `getClass()` method that you can invoke
    on any object. It does not carry the class static data (that is maintained in
    the method area) or the state (they are in an object, created during the execution).
    It does not contain method bytecodes either (that is stored in the method area,
    too). Instead, the `Class` instance provides metadata that describes the class—its
    name, package, fields, constructors, method signatures, and so on. That is why
    it can be useful not only for JVM but also for application code, as we have seen
    in some examples already.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查看`java.lang.Class`的API，你不会在那里看到公共构造函数。类加载器会自动创建它的实例，并且顺便说一句，这是由`getClass()`方法返回的相同实例，你可以在任何对象上调用该方法。它不携带类的静态数据（这些数据在方法区中维护）或状态（它们在执行期间创建的对象中）。它也不包含方法的字节码（这也存储在方法区中）。相反，`Class`实例提供描述类的元数据
    - 其名称、包、字段、构造函数、方法签名等。这就是为什么它不仅对JVM有用，对应用程序代码也有用，正如我们已经在一些示例中看到的。
- en: All the data created by the classloader in the memory and maintained by the
    execution engine is called a binary representation of the type.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器在内存中创建并由执行引擎维护的所有数据称为类型的二进制表示。
- en: If the `.class` file has errors or does not adhere to a certain format, the
    process is terminated. This means that some validation of the loaded class format
    and its bytecodes is performed by the loading process. But more verification follows
    at the beginning of the next process, called **linking**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`.class`文件存在错误或不符合特定格式，该过程将被终止。这意味着加载过程会对加载的类格式及其字节码进行一些验证。但更多的验证将在下一个称为**链接**的过程开始时进行。
- en: 'Here is the high-level description of the loading process.  It performs three
    tasks:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是加载过程的高级描述。它执行三项任务：
- en: Finds and reads the `.class` file
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找并读取`.class`文件
- en: Parses it according to the internal data structure into the method area
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据内部数据结构将其解析到方法区
- en: Creates an instance of `java.lang.Class` that carries the class metadata
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个携带类元数据的`java.lang.Class`的实例
- en: Linking
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接
- en: According to the JVM Specification, the linking is resolving the references
    of the loaded class, so the methods of the class can be executed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 根据JVM规范，链接是解析已加载类的引用，以便执行类的方法。
- en: 'Although JVM can reasonably expect that the `.class` file was produced by 
    the Java compiler and all the instructions satisfy the constraints and requirements
    of the language, there is no guarantee that the loaded file was produced by the
    known compiler implementation or a compiler at all. That is why the first step
    of the linking process is *verification*, which makes sure that the binary representation
    of the class is structurally correct: that the arguments of each method invocation
    are compatible with the method descriptor, that the return instruction matches
    its method''s return type, and so on.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JVM可以合理地期望`.class`文件是由Java编译器生成的，并且所有指令都满足语言的约束和要求，但无法保证加载的文件是由已知的编译器实现或根本没有编译器生成的。这就是为什么链接过程的第一步是*验证*，以确保类的二进制表示在结构上是正确的：每个方法调用的参数与方法描述符兼容，返回指令与其方法的返回类型匹配，依此类推。
- en: After verification is successfully completed, the next step—*preparation—*follows. The
    interface or class (static) variables are created in the method area and initialized
    to the default values of their types. The other kinds of initializations – the
    explicit assignments specified by a programmer and static initialization blocks
    – are deferred to the process called **initialization** (see the next section, *Initialization*).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 验证成功完成后，下一步是*准备*。接口或类（静态）变量在方法区中创建，并初始化为其类型的默认值。其他类型的初始化（由程序员指定的显式赋值和静态初始化块）被推迟到称为**初始化**的过程中（请参阅下一节*初始化*）。
- en: If the loaded bytecodes refer other methods, interfaces, or classes, the symbolic
    references are resolved into concrete references that point to the method area,
    which is done by the *resolution* process. If the referred interfaces and classes
    are not loaded yet, the classloader finds them and loads them as needed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加载的字节码引用其他方法、接口或类，则符号引用将被解析为指向方法区的具体引用，这是通过*解析*过程完成的。如果所引用的接口和类尚未加载，类加载器会找到它们并根据需要加载它们。
- en: 'Here is the high-level description of the linking process.  It performs three
    tasks:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是链接过程的高级描述。它执行三项任务：
- en: Verification of the binary representation of a class or an interface
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证类或接口的二进制表示
- en: Preparation of static fields in the method area
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法区中准备静态字段
- en: Resolution of symbolic references into concrete references that point to the
    method area
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将符号引用解析为指向方法区的具体引用
- en: Initialization
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化
- en: According to JVM Specification, the initialization is accomplished by executing
    the class initialization methods.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 根据JVM规范，初始化是通过执行类初始化方法来完成的。
- en: That is when the programmer-defined initialization (in static blocks and static
    assignments) is performed, unless the class was already initialized at the request
    of another class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序员定义的初始化（在静态块和静态赋值中）进行的时候，除非类已经在另一个类的请求下进行了初始化。
- en: The last part of this statement is an important one because the class may be
    requested several times by different (already loaded) methods, and also because
    JVM processes are executed by different threads (see the definition of threads
    in the section *Threads*) and may access the same class concurrently. So, coordination
    (also called synchronization) between different threads is required, which substantially
    complicates JVM implementation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个陈述的最后一部分很重要，因为该类可能会被不同（已加载）方法多次请求，并且因为JVM进程由不同线程执行（参见*线程*部分中线程的定义），可能会同时访问同一个类。因此，需要在不同线程之间进行协调（也称为同步），这大大复杂了JVM的实现。
- en: Instantiation
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化
- en: 'Technically, an instantiation process, triggered by the operator `new`, is
    the first step of the execution, and this section might not exist. But if the
    `main(String[])` method (which is static) uses only static methods of other classes,
    the instantiation never happens.  That''s why it is reasonable to identify this
    process as separate from the execution. Besides, this activity has very specific
    tasks:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，由`new`操作符触发的实例化过程是执行的第一步，这一部分可能不存在。但是，如果`main(String[])`方法（静态方法）只使用其他类的静态方法，实例化就永远不会发生。这就是为什么将这个过程与执行分开是合理的。此外，这个活动有非常具体的任务：
- en: Allocating memory for the object (its state) in the heap area
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在堆区为对象（其状态）分配内存
- en: Initialization of the instance fields to the default values
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将实例字段初始化为默认值
- en: Creating thread stacks for Java and native methods
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Java和本地方法创建线程堆栈
- en: Execution starts when the first method—not a constructor—is ready to be executed. For
    every application thread, a dedicated runtime stack is created, where every method
    call is captured in a stack frame. If an exception happens, we get data from the
    current stack frames when we call the method `printStackTrace()`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 执行从第一个方法（不是构造函数）准备执行开始。为每个应用程序线程创建一个专用的运行时堆栈，在其中捕获每个方法调用的堆栈帧。如果发生异常，我们可以从当前堆栈帧中调用`printStackTrace()`方法获取数据。
- en: Execution
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行
- en: The first application thread (called the *main* thread) is created when the `main(String[])`
    method starts executing. It can create other application threads. The execution
    engine reads the bytecodes, interprets them, and sends the binary code to the
    microprocessor for execution. It also maintains a count of how many times and
    how often each method was called. If the count exceeds a certain threshold, the
    execution engine uses a compiler, called JIT compiler, which compiles the method
    bytecodes into a native code. The next time the method is called, it will be ready
    without an interpretation. It substantially improves code performance.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当`main(String[])`方法开始执行时，将创建第一个应用程序线程（称为*主*线程）。它可以创建其他应用程序线程。执行引擎读取字节码，解释它们，并将二进制代码发送到微处理器执行。它还维护了每个方法被调用的次数和频率的计数。如果计数超过一定阈值，执行引擎将使用一个称为JIT编译器的编译器，将方法的字节码编译成本地代码。下次调用该方法时，它将准备好而无需解释。这大大提高了代码的性能。
- en: The instruction currently being executed and the address of the next instruction
    are maintained in the **P****rogram Counter** (**PC**) registers. Each thread
    has its own dedicated PC registers. It also improves performance and keeps track
    of the execution.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当前正在执行的指令和下一条指令的地址都保存在**程序计数器**（**PC**）寄存器中。每个线程都有自己专用的PC寄存器。这也提高了性能并跟踪执行情况。
- en: Garbage collection
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾收集
- en: The **garbage collector** (**GC**) runs the process that identifies the objects
    that are not referenced anymore and so can be removed from the memory. There is
    a Java static method, `System.gc()`, that can be used programmatically to trigger
    the garbage collection, but the immediate execution is not guaranteed. Every GC
    cycle affects the application performance, so the JVM has to maintain a balance
    between the memory availability and the ability to execute the bytecodes quickly
    enough.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**垃圾收集器**（**GC**）运行的过程是识别不再被引用的对象，因此可以从内存中删除。有一个Java静态方法`System.gc()`，可以通过编程方式触发垃圾收集，但不能保证立即执行。每次GC循环都会影响应用程序的性能，因此JVM必须在内存可用性和执行字节码的速度之间保持平衡。'
- en: Application termination
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序终止
- en: 'There are several ways an application can be terminated (and the JVM stopped)
    programmatically:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以通过多种方式（以及通过编程方式）终止（并停止JVM）：
- en: Normal termination without an error status code
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常终止而没有错误状态码
- en: Abnormal termination because of an unhandled exception or a forced programmatic
    exit with or without an error status code
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于未处理的异常或强制的编程方式退出而导致的异常终止，无论是否带有错误状态码
- en: If there are no exceptions and infinite loops, the `main(String[])` method completes
    with a `return` statement or after its last statement is executed. As soon as
    it happens, the main application thread returns the control flow to the JVM and
    the JVM stops executing, too.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有异常和无限循环，`main(String[])`方法将通过`return`语句或在执行其最后一条语句后完成。一旦发生这种情况，主应用程序线程将控制流返回给JVM，JVM也停止执行。
- en: That is the happy ending, and many applications enjoy it in real-life. Most
    of our examples, except those when we have demonstrated exceptions or infinite
    loops, have ended successfully, too.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个幸福的结局，许多应用程序在现实生活中也享受着这种结局。除了我们展示了异常或无限循环的例外情况，大多数示例也都成功结束了。
- en: However, there are other ways a Java application can exit, some of them quite
    graceful too. Others – not as much.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Java应用程序还有其他退出方式，其中一些方式也相当优雅。其他方式则不那么优雅。
- en: If the main application thread created child threads or, in other words, a programmer
    has written code that generates other threads, even the graceful exit may not
    be as easy. It all depends on the kind of the child threads created. If any of
    them is a `user` thread (the default), then the JVM instance continues to run
    even after the main thread exits.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主应用程序线程创建了子线程，或者换句话说，程序员编写了生成其他线程的代码，即使优雅地退出也可能不那么容易。这完全取决于创建的子线程的类型。如果其中任何一个是`用户`线程（默认情况下），那么即使主线程退出后，JVM实例也会继续运行。
- en: Only after all `user` threads are completed does the JVM instance stop. It is
    possible for the main thread to request that the child `user` thread complete
    (we will talk about this in the following section, *Threads*). But until it exits,
    the JVM continues running, and this means that the application is still running
    too.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在所有`用户`线程完成后，JVM实例才会停止。主线程可以请求子`用户`线程完成（我们将在下一节*线程*中讨论这一点）。但在退出之前，JVM会继续运行，这意味着应用程序仍在运行。
- en: But if all child threads are `daemon` threads (see the following section, *Threads*)
    or there are no child threads running, the JVM instance stops running as soon
    as the main application thread exits.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果所有子线程都是`守护`线程（请参阅下一节*线程*），或者没有正在运行的子线程，那么一旦主应用程序线程退出，JVM实例就会停止运行。
- en: Without forced termination, the JVM instance continues running until the main
    application thread and all child `user` threads are completed. In the absence
    of child `user` threads or in the case where all the child threads are `daemon`,
    the JVM stops running as soon as the main application thread exits.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有强制终止的情况下，JVM实例会继续运行，直到主应用程序线程和所有子`用户`线程完成。如果没有子`用户`线程或者所有子线程都是`守护`线程，那么一旦主应用程序线程退出，JVM就会停止运行。
- en: How the application exits in the case of an exception depends on the code design.
    We touched on it in the previous chapter while discussing the best practices of
    exception handling. If the thread captures all the exceptions in a `try...catch`
    block in `main(String[])` or a similarly high-level method, then the control flow
    is returned back to the application code and it is up to the application (and
    the programmer who wrote the code) how to proceed – to try to recover, to log
    the error and continue, or to exit.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在异常情况下应用程序如何退出取决于代码设计。我们在上一章讨论异常处理的最佳实践时已经提到过。如果线程在`main(String[])`或类似高级方法中的`try...catch`块中捕获了所有异常，那么控制流将返回到应用程序代码，并由应用程序（以及编写代码的程序员）决定如何继续——尝试恢复、记录错误并继续，或者退出。
- en: 'If, on the other hand, the exception remains unhandled and propagates into
    the JVM code, the thread (where the exception happened) stops executing and exits.
    Then, one of the following will occur:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果异常仍未处理并传播到JVM代码中，那么发生异常的线程将停止执行并退出。然后，将发生以下情况之一：
- en: If there are no other threads, the JVM stops executing and returns an error
    code and the stack trace
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有其他线程，则JVM停止执行并返回错误代码和堆栈跟踪
- en: If the thread with an unhandled exception was not the main one, other threads
    (if present) continue running
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果出现未处理的异常的线程不是主线程，则其他线程（如果存在）会继续运行
- en: If the main thread has thrown an unhandled exception and the child threads (if
    present) are daemon, they exit too
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果主线程抛出未处理的异常，并且子线程（如果存在）是守护线程，则它们也会退出
- en: If there is at least one user child thread, the JVM continues running until
    all user threads exit
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果至少有一个用户子线程，JVM会继续运行，直到所有用户线程退出
- en: 'There are also ways to programmatically force the application to stop:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些编程方法可以强制应用程序停止：
- en: '`System.exit(0);`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.exit(0);`'
- en: '`Runtime.getRuntime().exit(0);`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Runtime.getRuntime().exit(0);`'
- en: '`Runtime.getRuntime().halt(0);`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Runtime.getRuntime().halt(0);`'
- en: 'All of the preceding methods force the JVM to stop executing any thread and
    exit with a status code passed in as the parameter (0, in our examples):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前述方法都会强制JVM停止执行任何线程，并以作为参数传递的状态代码（在我们的示例中为0）退出：
- en: Zero indicates normal termination
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零表示正常终止
- en: The nonzero value indicates abnormal termination
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非零值表示异常终止
- en: If the Java command was launched by some script or another system, the value
    of the status code can be used for the automation of the decision making about
    the next step. But that is already outside the application and Java code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Java命令是由某个脚本或其他系统启动的，则状态代码的值可用于自动化决定下一步的操作。但这已经超出了应用程序和Java代码的范围。
- en: 'The first two methods have identical functionality, because here is how `System.exit()`
    is implemented:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种方法具有相同的功能，因为`System.exit()`的实现方式如下：
- en: '```java'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public static void exit(int status) {
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: public static void exit(int status) {
- en: Runtime.getRuntime().exit(status);
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Runtime.getRuntime().exit(status);
- en: '}'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: To see the source code in IDE, just click on the method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要在IDE中查看源代码，只需单击该方法。
- en: The Java Virtual Machine exits when some thread invokes the `exit()` method
    of the `Runtime` or `System` class, or the `halt()` method of the `Runtime` class,
    and the exit or halt operation is permitted by the security manager.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当某个线程调用`Runtime`或`System`类的`exit()`方法，或者`Runtime`类的`halt()`方法，并且退出或中止操作被安全管理器允许时，Java虚拟机退出。
- en: The difference between `exit()` and `halt()` is that `halt()` forces JVM to
    exit immediately, while `exit()` performs additional actions that can be set using
    the `Runtime.addShutdownHook()` method.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`exit()`和`halt()`之间的区别在于`halt()`会立即强制JVM退出，而`exit()`会执行可以使用`Runtime.addShutdownHook()`方法设置的附加操作。'
- en: But all these options are rarely used in mainstream programming, so we are already
    stepping way beyond the scope of this book.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但所有这些选项在主流编程中很少使用，因此我们已经超出了本书的范围。
- en: JVM architecture
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM架构
- en: JVM architecture can be described in terms of the runtime data structure in
    the memory and in terms of the two subsystems that use the runtime data – the
    classloader and execution engine.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: JVM架构可以用内存中的运行时数据结构和使用运行时数据的两个子系统——类加载器和执行引擎来描述。
- en: Runtime data areas
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时数据区
- en: 'Each of the runtime data areas of JVM memory belong to one of two categories:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: JVM内存的每个运行时数据区都属于两个类别之一：
- en: 'Shared areas, which include the following:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享区域，包括以下内容：
- en: '**Method area**: Class metadata, static fields, methods bytecodes'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法区**：类元数据，静态字段，方法字节码'
- en: '**Heap area**: Objects (state)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆区**：对象（状态）'
- en: 'Not shared areas, dedicated to each application thread, which include the following:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不共享区域，专门为每个应用程序线程而设，包括以下内容：
- en: '**Java stack**: Current and caller frames, each frame keeping the state of
    Java (not native) method invocation:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java堆栈**：当前和调用者帧，每个帧保持Java（非本地）方法调用的状态：'
- en: Values of local variables
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地变量的值
- en: Method parameters values
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法参数值
- en: Values of operands for intermediate calculations (operand stack)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间计算的操作数的值（操作数栈）
- en: Method return value (if any)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法返回值（如果有）
- en: '**Program Counter (PC) register**: Next instruction to execute'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序计数器（PC）寄存器**：下一条要执行的指令'
- en: '**Native method stack**: The state of native method invocations'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地方法堆栈**：本地方法调用的状态'
- en: We have already discussed that a programmer has to be careful while using reference
    types to not modify the object itself unless it needs to be done. In a multithreaded
    application, if a reference to an object can be passed between threads, one has
    to be extra careful because of the possibility of the concurrent modification
    of the same data.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过，程序员在使用引用类型时必须小心，不要修改对象本身，除非需要这样做。在多线程应用程序中，如果对象的引用可以在线程之间传递，就必须特别小心，因为可能会同时修改相同的数据。
- en: On the bright side, such a shared area can be and often is used as the means
    of communication between threads. We will talk about this in the upcoming *Threads* section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 光明的一面是，这样的共享区域可以并且经常被用作线程之间的通信手段。我们将在即将到来的*Threads*部分讨论这个问题。
- en: Classloader
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类加载器
- en: 'The classloader performs the following three functions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器执行以下三个功能：
- en: Reads the `.class` file
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取`.class`文件
- en: Populates the method area
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充方法区
- en: Initializes static fields not initialized by a programmer
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化程序员未初始化的静态字段
- en: Execution engine
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行引擎
- en: 'The execution engine does the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 执行引擎执行以下操作：
- en: Instantiates objects in the heap area
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在堆区实例化对象
- en: Initializes static and instance fields, using initializers written by programmers
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用程序员编写的初始化器初始化静态和实例字段
- en: Adds/removes frames to/from Java stack
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向Java堆栈添加/删除帧
- en: Updates the PC register with the next instruction to execute
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新PC寄存器以执行下一条指令
- en: Maintains the native method stack
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护本地方法堆栈
- en: Keeps counts of method calls and compiles popular ones
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持方法调用的计数并编译流行的方法
- en: Finalizes objects
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成对象
- en: Runs garbage collection
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行垃圾回收
- en: Terminates the application
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止应用程序
- en: Threads
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程
- en: As we have mentioned already, the main application thread can create other -
    child - threads and let them run in parallel, either sharing the same core via
    time slicing or having a dedicated CPU for each thread. It can be done using the
    class `java.lang.Thread`, which implements the functional interface `Runnable`.
    The interface is called functional if it has only one abstract method (we will
    discuss functional interfaces in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambda
    Expressions and Functional Programming*). The `Runnable` interface contains one
    method, `run()`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们已经提到的，主应用程序线程可以创建其他 - 子 - 线程，并让它们并行运行，无论是通过时间切片共享同一个核心，还是为每个线程分配一个专用的CPU。可以使用实现了功能接口`Runnable`的类`java.lang.Thread`来实现。如果接口只有一个抽象方法，就称为功能接口（我们将在[第17章](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml)中讨论功能接口，*Lambda表达式和函数式编程*）。`Runnable`接口包含一个方法`run()`。 '
- en: 'There are two ways to create a new thread:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法创建新线程：
- en: Extend the `Thread` class
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展`Thread`类
- en: Implement the `Runnable` interface and pass the object of the implementation
    into the constructor of the class `Thread`
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`Runnable`接口，并将实现的对象传递到类`Thread`的构造函数中
- en: Extending the Thread class
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Thread类
- en: 'Whatever method is used, we end up with a `Thread` class object that has the
    method `start()`. This method call starts the thread execution. Let''s look at
    an example. Let''s create a class called `AThread` that extends `Thread` and overrides
    its `run()` method:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用什么方法，最终我们都会得到一个具有`start()`方法的`Thread`类对象。这个方法调用开始线程执行。让我们看一个例子。让我们创建一个名为`AThread`的类，它扩展了`Thread`并重写了它的`run()`方法：
- en: '```java'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class AThread extends Thread {
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: public class AThread extends Thread {
- en: int i1, i2;
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: int i1, i2;
- en: public AThread(int i1, int i2) {
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: public AThread(int i1, int i2) {
- en: this.i1 = i1;
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: this.i1 = i1;
- en: this.i2 = i2;
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: this.i2 = i2;
- en: '}'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void run() {
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: public void run() {
- en: for (int i = i1; i <= i2; i++) {
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = i1; i <= i2; i++) {
- en: 'System.out.println("child thread " + (isDaemon() ? "daemon" : "user") + " "
    + i);'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("child thread " + (isDaemon() ? "daemon" : "user") + " "
    + i);'
- en: try {
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: try {
- en: TimeUnit.SECONDS.sleep(1);
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: TimeUnit.SECONDS.sleep(1);
- en: '} catch (InterruptedException e) {'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (InterruptedException e) {'
- en: e.printStackTrace();
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: e.printStackTrace();
- en: '}'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Overriding the `run()` method is important because otherwise, the thread will
    do nothing. The `Thread` class implements the `Runnable` interface and has the `run()` method''s
    implementation, but it looks as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重写`run()`方法很重要，否则线程将不执行任何操作。`Thread`类实现了`Runnable`接口，并且有`run()`方法的实现，但它看起来如下：
- en: '```java'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public void run() {
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: public void run() {
- en: if (target != null) {
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: if (target != null) {
- en: target.run();
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: target.run();
- en: '}'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The variable `target` holds the value passed in the constructor:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`target`保存在构造函数中传递的值：
- en: '```java'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public Thread(Runnable target) {
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: public Thread(Runnable target) {
- en: init(null, target, "Thread-" + nextThreadNum(), 0);
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: init(null, target, "Thread-" + nextThreadNum(), 0);
- en: '}'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But our `AThread` class does not pass any value to the parent class `Target`;
    the variable target is `null`, so the `run()` method in the `Thread` class does
    not do anything.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们的`AThread`类没有向父类`Target`传递任何值；变量target是`null`，所以`Thread`类中的`run()`方法不执行任何操作。
- en: Now let's use our newly created thread. We expect it to increment variable `i`
    from `i1` to `i2` (these are parameters passed via the constructor) and print
    its value along with the Boolean value returned by the `isDaemon()` method, then
    wait (sleep) for 1 second and increment variable `i` again.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用我们新创建的线程。我们期望它将变量`i`从`i1`增加到`i2`（这些是通过构造函数传递的参数），并打印其值以及`isDaemon()`方法返回的布尔值，然后等待（休眠）1秒并再次增加变量`i`。
- en: What is daemon?
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是守护进程？
- en: 'The word daemon has an ancient Greek origin, meaning a divinity or supernatural
    being of a nature between gods and humans and an inner or attendant spirit or
    inspiring force. But in computer science, this term has more mundane usage and
    is applied to a computer program that runs as a background process, rather than
    being under the direct control of an interactive user. That is why there are two
    types of threads in Java:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: “守护”一词源自古希腊语，意思是介于神和人之间的神性或超自然存在，以及内在或随从精神或激励力量。但在计算机科学中，这个术语有更加平凡的用法，用于指代作为后台进程运行的计算机程序，而不是受交互式用户直接控制。这就是为什么Java中有两种类型的线程：
- en: User thread (default), initiated by an application (the main thread is one such
    example)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户线程（默认），由应用程序发起（主线程就是这样的一个示例）
- en: Daemon threads that work in the background in support of user thread activity
    (garbage collection is an example of a daemon thread)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在支持用户线程活动的后台运行的守护线程（垃圾收集是守护线程的一个示例）
- en: That is why all daemon threads exit immediately after the last user thread exits
    or is terminated by JVM after an unhandled exception.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么所有守护线程在最后一个用户线程退出或JVM在未处理的异常后终止之后立即退出。
- en: Running threads extending Thread
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展线程运行
- en: 'Let''s use our new class, `AThread`, to demonstrate the behavior we have described.
    Here is the code we are going to run first:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们的新类`AThread`来演示我们所描述的行为。这是我们首先要运行的代码：
- en: '```java'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Thread thr1 = new AThread(1, 4);
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Thread thr1 = new AThread（1,4）;
- en: thr1.start();
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: thr1.start（）;
- en: Thread thr2 = new AThread(11, 14);
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Thread thr2 = new AThread（11,14）;
- en: thr2.setDaemon(true);
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: thr2.setDaemon（true）;
- en: thr2.start();
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: thr2.start（）;
- en: try {
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试 {
- en: TimeUnit.SECONDS.sleep(1);
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: TimeUnit.SECONDS.sleep（1）;
- en: '} catch (InterruptedException e) {'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '} 捕获（InterruptedException e）{'
- en: e.printStackTrace();
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: e.printStackTrace（）;
- en: '}'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: System.out.println("Main thread exists");
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“主线程存在”）;
- en: '```'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In the preceding code, we create and immediately start two threads – a user
    thread, `thr1`, and a daemon thread, `thr2`. Actually, there is a user thread
    called `main` too, so we run two user threads and one daemon thread. Each of the
    child threads is going to print the incremented number four times, pausing for
    1 second after each print. This means that each thread will be running for 4 seconds.
    The main thread will pause for 1 second too, but one time only, so it will run
    for approximately 1 second. Then, it prints `Main thread exists` and exists. If
    we run this code, we will see the following output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建并立即启动了两个线程-用户线程`thr1`和守护线程`thr2`。实际上，还有一个名为`main`的用户线程，所以我们运行了两个用户线程和一个守护线程。每个子线程将打印递增的数字四次，每次打印后暂停1秒。这意味着每个线程将运行4秒。主线程也会暂停1秒，但只有一次，所以它将运行大约1秒。然后，它打印“主线程存在”并退出。如果我们运行此代码，将看到以下输出：
- en: '![](img/42afcacb-82d0-414b-afd4-e5d36be0c2d5.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: ！[]（img / 42afcacb-82d0-414b-afd4-e5d36be0c2d5.png）
- en: We execute this code on one shared CPU, so, although all three threads are running
    concurrently, they can only use CPU sequentially. Therefore, they cannot be run
    in parallel. On a multicore computer, each thread may be executed on a different
    CPU and the output may be slightly different, but not by much. In any case, you
    would see that the main thread exits first (after approximately 1 second) and
    the child threads run until completion, each for approximately 4 seconds in total.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个共享的CPU上执行此代码，因此，尽管所有三个线程都在同时运行，但它们只能顺序使用CPU。因此，它们不能并行运行。在多核计算机上，每个线程可以在不同的CPU上执行，输出可能略有不同，但差别不大。无论如何，您会看到主线程首先退出（大约1秒后），子线程运行直到完成，每个线程总共运行大约4秒。
- en: 'Let''s make user thread run for only 2 seconds:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让用户线程只运行2秒：
- en: '```java'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Thread thr1 = new AThread(1, 2);
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Thread thr1 = new AThread（1,2）;
- en: thr1.start();
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: thr1.start（）;
- en: '```'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result is:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '![](img/ab8a6642-440f-4a0b-af2e-1589b74c8613.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: ！[]（img / ab8a6642-440f-4a0b-af2e-1589b74c8613.png）
- en: As you can see, the daemon thread did not run the full course. It managed to
    print 13, probably only because it had sent the message to the output device before
    the JVM responded to the last user thread exit.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，守护线程没有完全运行。它成功打印了13，可能仅因为它在JVM响应最后一个用户线程退出之前已将消息发送到输出设备。
- en: Implementing Runnable
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Runnable
- en: 'The second way to create a thread is to use a class that implements `Runnable`.
    Here is an example of such a class that has almost exactly the same functionality
    as class `AThread`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 创建线程的第二种方法是使用实现`Runnable`的类。以下是一个几乎与类`AThread`具有完全相同功能的类的示例：
- en: '```java'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class ARunnable implements Runnable {
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: public class ARunnable implements Runnable {
- en: int i1, i2;
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: int i1，i2;
- en: public ARunnable(int i1, int i2) {
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: public ARunnable（int i1，int i2）{
- en: this.i1 = i1;
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: this.i1 = i1;
- en: this.i2 = i2;
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: this.i2 = i2;
- en: '}'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void run() {
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: public void run（）{
- en: for (int i = i1; i <= i2; i++) {
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: for（int i = i1; i <= i2; i ++）{
- en: System.out.println("child thread "  + i);
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“子线程”+ i）;
- en: try {
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试 {
- en: TimeUnit.SECONDS.sleep(1);
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: TimeUnit.SECONDS.sleep（1）;
- en: '} catch (InterruptedException e) {'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '} 捕获（InterruptedException e）{'
- en: e.printStackTrace();
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: e.printStackTrace（）;
- en: '}'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The only difference is that there is no `isDaemon()` method in the `Runnable` interface,
    so we cannot print whether the thread is daemon or not.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是`Runnable`接口中没有`isDaemon（）`方法，因此我们无法打印线程是否为守护线程。
- en: Runing threads implementing Runnable
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行实现Runnable的线程
- en: 'And here is how this class can be used to create two child threads—one user
    thread and another a daemon thread—exactly as we have done before:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用此类创建两个子线程-一个用户线程和另一个守护线程-与我们之前所做的完全相同：
- en: '```java'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Thread thr1 = new Thread(new ARunnable(1, 4));
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Thread thr1 = new Thread（new ARunnable（1,4））;
- en: thr1.start();
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: thr1.start（）;
- en: Thread thr2 = new Thread(new ARunnable(11, 14));
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Thread thr2 = new Thread（new ARunnable（11,14））;
- en: thr2.setDaemon(true);
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: thr2.setDaemon（true）;
- en: thr2.start();
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: thr2.start（）;
- en: try {
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试 {
- en: TimeUnit.SECONDS.sleep(1);
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: TimeUnit.SECONDS.sleep（1）;
- en: '} catch (InterruptedException e) {'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '} 捕获（InterruptedException e）{'
- en: e.printStackTrace();
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: e.printStackTrace（）;
- en: '}'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: System.out.println("Main thread exists");
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“主线程存在”）;
- en: '```'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: If we run the preceding code, the result will be the same as running threads
    based on a class that extends `Thread`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，结果将与基于扩展`Thread`类的线程运行相同。
- en: Extending Thread vs implementing Runnable
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Thread与实现Runnable
- en: 'Implementing `Runnable` has the advantage (and in some cases, the only possible
    option) of allowing the implementation to extend another class. It is particularly
    helpful when you would like to add thread-like behavior to an existing class:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`Runnable`的优点（在某些情况下，也是唯一可能的选项）是允许实现扩展另一个类。当您想要向现有类添加类似线程的行为时，这是特别有帮助的。
- en: '```java'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class BRunnable extends SomeClass implements Runnable {
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: public class BRunnable extends SomeClass implements Runnable {
- en: int i;
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: int i;
- en: BRunnable(int i, String s) {
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: BRunnable(int i, String s) {
- en: super(s);
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: super(s);
- en: this.i = i;
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: this.i = i;
- en: '}'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int calculateSomething(double x) {
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: public int calculateSomething(double x) {
- en: //calculate result
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: //计算结果
- en: return result;
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 返回结果;
- en: '}'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void run() {
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: public void run() {
- en: //any code you need goes here
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: //您需要的任何代码都在这里
- en: '}'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'You can even invoke the method `run()` directly, without passing the object
    into the Thread constructor:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以直接调用方法`run()`，而不将对象传递到Thread构造函数中：
- en: '```java'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: BRunnable obj = new BRunnable(2, "whatever");
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: BRunnable obj = new BRunnable(2, "whatever");
- en: int i = obj.calculateSomething(42d);
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: int i = obj.calculateSomething(42d);
- en: obj.run();
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: obj.run();
- en: Thread thr = new Thread (obj);
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Thread thr = new Thread (obj);
- en: thr.start();
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: thr.start();
- en: '```'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In the preceding code snippet, we have shown many different ways to execute
    the methods of the class that implements `Runnable`. So, implementing `Runnable`
    allows more flexibility in usage. But otherwise, there is no difference in functionality
    comparing to the extending of `Thread`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们展示了执行实现`Runnable`的类的方法的许多不同方式。因此，实现`Runnable`允许更灵活地使用。但是，与扩展`Thread`相比，在功能上没有区别。
- en: The `Thread` class has several constructors that allow setting the thread name
    and the group it belongs to. Grouping of threads helps to manage them in the case
    of many threads running in parallel. The `Thread` class also has several methods
    that provide information about the thread's status and properties and allow us
    to control its behavior.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类有几个构造函数，允许设置线程名称和它所属的组。对线程进行分组有助于在许多线程并行运行的情况下对其进行管理。`Thread`类还有几种方法，提供有关线程状态和属性的信息，并允许我们控制其行为。'
- en: Threads—and any objects for that matter—can also talk to each other using the
    methods `wait()`, `notify()`, and `notifyAll()` of the base class `java.lang.Object`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 线程——以及任何对象——也可以使用基类`java.lang.Object`的`wait()`、`notify()`和`notifyAll()`方法相互通信。
- en: But all that is already outside the scope of the introductory course.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 但所有这些都已经超出了入门课程的范围。
- en: How to execute the main(String[]) method
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行main(String[])方法
- en: 'Before diving into the garbage collection process, we would like to review
    and summarize how to run an application from a command line. In Java, the following
    statements are used as synonyms:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论垃圾收集过程之前，我们想要回顾并总结如何从命令行运行应用程序。在Java中，以下语句用作同义词：
- en: Run/execute main class
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行/执行主类
- en: Run/execute/start application
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行/执行/启动应用程序
- en: Run/execute/start main method
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行/执行/启动主方法
- en: Run/execute/start/launch JVM or Java process
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行/执行/启动/启动JVM或Java进程
- en: The reason for that is that each of the listed actions happens every time you
    execute one of them. There are also several ways to do it. We have already shown
    you how to run the `main(String[])` method using IntelliJ IDEA and the `java`
    command line. Now, we will just repeat some of what has been said already and
    add other variations that might be helpful for you.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为列出的每个操作都会在执行其中一个操作时发生。还有几种方法可以做到这一点。我们已经向您展示了如何使用IntelliJ IDEA和`java`命令行运行`main(String[])`方法。现在，我们将重复已经说过的一些内容，并添加其他可能对您有帮助的变体。
- en: Using IDE
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IDE
- en: 'Any IDE allows running the main method. In IntelliJ IDEA, it can be done in
    three ways:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 任何IDE都允许运行主方法。在IntelliJ IDEA中，有三种方法可以做到这一点：
- en: By clicking on the green arrow next to the method name
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过单击方法名称旁边的绿色箭头
- en: 'By selecting the class name from the drop-down menu (at the top line, to the
    left of the green arrow) and clicking the green arrow to the right of the menu:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从下拉菜单中选择类名（在顶部行的左侧，绿色箭头的左侧）并单击菜单右侧的绿色箭头：
- en: '![](img/47ecc693-bded-4567-b5f6-2fea2f282d4b.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47ecc693-bded-4567-b5f6-2fea2f282d4b.png)'
- en: 'By using the Run menu and selecting the name of the class:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过单击运行菜单并选择类的名称：
- en: '![](img/90dbb360-a4a9-435d-82de-6f2c4d56b72c.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90dbb360-a4a9-435d-82de-6f2c4d56b72c.png)'
- en: 'In the preceding screenshot, you can also see the option Edit configurations.
    We have used it already to set the parameters that can be passed to the main method
    at the start. But there are more settings possible there:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，您还可以看到选项“编辑配置”。我们已经使用它来设置可以在启动时传递给主方法的参数。但是还有更多的设置可能：
- en: '![](img/3a7dc463-e2f3-4594-9549-0f64f3460763.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a7dc463-e2f3-4594-9549-0f64f3460763.png)'
- en: 'As you can see, it is possible to also set:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，还可以设置：
- en: 'VM options: The Java command options (we will do this in the next section)'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VM选项：Java命令选项（我们将在下一节中进行）
- en: 'Environment variables: The way to set some parameters that can be read not
    only in the main method but anywhere in the application, using the `System.getenv()` method'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量：设置一些参数，不仅可以在主方法中读取，还可以在应用程序的任何地方使用`System.getenv()`方法
- en: 'For example, look at the following screenshot:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看以下截图：
- en: '![](img/1e093c7a-d9fd-49ef-9bff-c3a8dd3b08fa.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e093c7a-d9fd-49ef-9bff-c3a8dd3b08fa.png)'
- en: 'We have set the `java` command option `-Xlog:gc` and the environment variable
    `myprop1=whatever`. The IDE will use these settings to form the following `java`
    command:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了`java`命令选项`-Xlog:gc`和环境变量`myprop1=whatever`。IDE将使用这些设置来形成以下`java`命令：
- en: '```java'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: java -Xlog:gc -Dmyprop1=whatever com.packt.javapath.ch04demo.MyApplication 2
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: java -Xlog:gc -Dmyprop1=whatever com.packt.javapath.ch04demo.MyApplication 2
- en: '```'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The option `-Xlog:gc` tells JVM to display log messages from the garbage collection
    process. We will use this option in the next section to demonstrate how garbage
    collection works. The value of the variable `myprop1` can be retrieved anywhere
    in the application using the following statement:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 选项`-Xlog:gc`告诉JVM显示来自垃圾回收过程的日志消息。我们将在下一节中使用此选项来演示垃圾回收的工作原理。可以使用以下语句在应用程序的任何位置检索变量`myprop1`的值：
- en: '```java'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'String myprop = System.getenv("myprop1");     //returns: "whatever"'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: String myprop = System.getenv("myprop1");     //返回："whatever"
- en: '```'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And we have already seen how parameter 2 can be read in the main method as
    follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到参数2如何在主方法中读取：
- en: '```java'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public static void main(String[] args) {
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: 'String p1 = args[0];          //returns: "2"'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: String p1 = args[0];          //返回："2"
- en: '}'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Command line with classes on classpath
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有类路径上的类的命令行
- en: 'Let''s use the first program we created in [Chapter 4](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml),
    *Your First Java Project*, to demonstrate how to use the command line. Here is
    the program we wrote then:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们在[第4章](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml)中创建的第一个程序，*Your First
    Java Project*，来演示如何使用命令行。以下是我们当时编写的程序：
- en: '```java'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: package com.packt.javapath.ch04demo;
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: package com.packt.javapath.ch04demo;
- en: import com.packt.javapath.ch04demo.math.SimpleMath;
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: import com.packt.javapath.ch04demo.math.SimpleMath;
- en: public class MyApplication {
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyApplication {
- en: public static void main(String[] args) {
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: int i = Integer.parseInt(args[0]);
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: int i = Integer.parseInt(args[0]);
- en: SimpleMath simpleMath = new SimpleMath();
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleMath simpleMath = new SimpleMath();
- en: int result = simpleMath.multiplyByTwo(i);
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: int result = simpleMath.multiplyByTwo(i);
- en: System.out.println(i + " * 2 = " + result);
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i + " * 2 = " + result);
- en: '}'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'To run it from a command line, it has to be compiled first using the `javac`
    command. An IDE that uses Maven places the `.class` file in the directory `target/classes`.
    If you go into the root directory of your project or just click Terminal (bottom
    left corner in IntelliJ IDEA), you can run the following command:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命令行运行它，必须首先使用`javac`命令对其进行编译。使用Maven的IDE将`.class`文件放在目录`target/classes`中。如果进入项目的根目录或单击Terminal（IntelliJ
    IDEA左下角），可以运行以下命令：
- en: '```java'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: java -cp target/classes com.packt.javapath.ch04demo.MyApplication 2
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: java -cp target/classes com.packt.javapath.ch04demo.MyApplication 2
- en: '```'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The result should be displayed as `2 * 2 = 4`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应显示为`2 * 2 = 4`。
- en: Command line with a .jar file on classpath
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有类路径上的.jar文件的命令行
- en: 'To create a `.jar` file with the compiled application code, go to the project
    root directory and run the following commands:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个带有编译应用程序代码的`.jar`文件，转到项目根目录并运行以下命令：
- en: '```java'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: cd target/classes
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: cd target/classes
- en: jar -cf myapp.jar com/packt/javapath/ch04demo/**
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: jar -cf myapp.jar com/packt/javapath/ch04demo/**
- en: '```'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'A `.jar` file with the classes `MyApplication` and `SimpleMath` is created.
    Now we can put it on the classpath and run the application again:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个带有类`MyApplication`和`SimpleMath`的`.jar`文件。现在我们可以将其放在类路径上并再次运行应用程序：
- en: '```java'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: java -cp myapp.jar com.packt.javapath.ch04demo.MyApplication 2
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: java -cp myapp.jar com.packt.javapath.ch04demo.MyApplication 2
- en: '```'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The result will be displayed the same; `2 * 2 = 4`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将显示相同；`2 * 2 = 4`。
- en: Command line with an executable .jar file
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有可执行.jar文件的命令行
- en: 'It is possible to avoid specifying the main class in the command line. Instead,
    one can create an "executable" `.jar` file. It can be accomplished by placing
    the name of the main class—the one you need to run and that contains the main
    method—into the manifest file. Here are the steps:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 可以避免在命令行中指定主类。相反，可以创建一个“可执行”的`.jar`文件。可以通过将主类的名称（需要运行的类，包含主方法的类）放入清单文件中来实现。以下是步骤：
- en: 'Create a text file, `manifest.txt` (the name actually does not matter, but
    it makes the intent clear) that contains the following one line: `Main-Class:
    com.packt.javapath.ch04demo.MyApplication`. There has to be a space after the
    colon (`:`) and there has to be an invisible new line symbol at the end, so make
    sure you have pressed the *Enter* key and the cursor has jumped to the beginning
    of the next line.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '创建一个文本文件`manifest.txt`（实际名称并不重要，但它可以清楚地表达意图），其中包含以下一行：`Main-Class: com.packt.javapath.ch04demo.MyApplication`。冒号（`:`）后必须有一个空格，并且末尾必须有一个不可见的换行符号，因此请确保您按下了*Enter*键并且光标已跳转到下一行的开头。'
- en: Execute the command `cd target/classes` and go into the directory `classes`.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行命令`cd target/classes`并进入目录`classes`。
- en: 'Execute the following command: `jar -cfm myapp.jar  manifest.txt  com/packt/javapath/ch04demo/**`.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行以下命令：`jar -cfm myapp.jar  manifest.txt  com/packt/javapath/ch04demo/**`。
- en: Notice the sequence of `jar` command options `fm` and the sequence of the following
    files; `myapp.jar  manifest.txt`. They have to be the same, because `f` stands
    for the file the `jar` command is going to create and `m` stands for the manifest
    source. If you put the options as `mf`, then the files have to be listed as `manifest.txt
    myapp.jar`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`jar`命令选项`fm`的顺序和以下文件的顺序；`myapp.jar manifest.txt`。它们必须相同，因为`f`代表`jar`命令将要创建的文件，`m`代表清单源。如果将选项放置为`mf`，则文件必须列为`manifest.txt
    myapp.jar`。
- en: 'Now, run the following command:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下命令：
- en: '```java'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: java -jar  myapp.jar  2
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: java -jar  myapp.jar  2
- en: '```'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The result will be `2 * 2 = 4` again.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将再次显示为`2 * 2 = 4`。
- en: Equipped with the knowledge of how to run an application, we can now continue
    to the next section, where it is going to be needed.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 具备运行应用程序的知识后，我们现在可以继续到下一节，那里将需要它。
- en: Garbage collection
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Automatic memory management is an important aspect of JVM that relieves the
    programmer from the need to do it programmatically. In Java, the process that
    cleans up memory and allows you to reuse it is called **Garbage Collection** (**GC**).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 自动内存管理是JVM的一个重要方面，它使程序员无需以编程方式进行内存管理。在Java中，清理内存并允许您重用它的过程称为**垃圾回收**（**GC**）。
- en: Responsiveness, throughput, and stop-the-world
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应性、吞吐量和停顿时间
- en: The effectiveness of GC affects two major application characteristics – responsiveness
    and throughput. Responsiveness is measured by how quickly an application responds
    (brings necessary data) to the request. For example, how quickly a website returns
    a page, or how quickly a desktop application responds to an event. The smaller
    the response time, the better the user experience. Throughput, on the other hand,
    indicates the amount of work an application can do in a unit of time. For example,
    how many requests a web application can serve, or how many transactions a database
    can support. The bigger the number, the more value the application can potentially
    generate and the more user requests it can support.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集的有效性影响着两个主要应用程序特征 - 响应性和吞吐量。响应性是指应用程序对请求的快速响应（提供必要数据）的度量。例如，网站返回页面的速度，或者桌面应用程序对事件的快速响应。响应时间越短，用户体验就越好。另一方面，吞吐量表示应用程序在单位时间内可以完成的工作量。例如，一个Web应用程序可以提供多少请求，或者一个数据库可以支持多少交易。数字越大，应用程序可能产生的价值就越大，可以支持的用户请求也就越多。
- en: Meanwhile, GC needs to move data around, which is impossible to accomplish while
    allowing data processing because the references are going to change. That's why
    GC needs to stop application threads from executing once in a while for a period
    of time called stop-the-world. The longer these periods are, the quicker GC does
    its job, and the longer an application freeze lasts, which can eventually grow
    big enough to affect both the application's responsiveness and throughput. Fortunately,
    it is possible to tune the GC behavior using `java` command options, but that
    is outside the scope of this book, which is more about introduction than solving
    complex problems. So, we will concentrate on a high-level view of the main activity
    of a GC; inspecting objects in the heap and removing those that don't have references
    in any thread stack.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，垃圾收集器需要移动数据，这在允许数据处理的同时是不可能完成的，因为引用将会发生变化。这就是为什么垃圾收集器需要偶尔停止应用程序线程的执行一段时间，这段时间被称为停顿时间。这些停顿时间越长，垃圾收集器完成工作的速度就越快，应用程序冻结的时间也就越长，最终可能会足够大以至于影响应用程序的响应性和吞吐量。幸运的是，可以使用`java`命令选项来调整垃圾收集器的行为，但这超出了本书的范围，本书更多地是介绍而不是解决复杂问题。因此，我们将集中讨论垃圾收集器主要活动的高层视图；检查堆中的对象并删除那些在任何线程堆栈中没有引用的对象。
- en: Object age and generations
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象年龄和代
- en: 'The basic GC algorithm determines how old each object is. The term age refers
    to the number of collection cycles the object has survived. When JVM starts, the
    heap is empty and is divided into three sections: young generation, old or tenured
    generation, and humongous regions for holding the objects that are 50% the size
    of a standard region or larger.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的垃圾收集算法确定了每个对象的年龄。年龄指的是对象存活的收集周期数。当JVM启动时，堆是空的，并被分为三个部分：年轻代、老年代或终身代，以及用于容纳大小为标准区域的50%或更大的对象的巨大区域。
- en: The young generation has three areas, an Eden space and two survivor spaces,
    such as Survivor 0 (*S0*) and Survivor 1 (*S1*).  The newly created objects are
    placed in Eden. When it is filling up, a minor GC process starts. It removes the
    un-referred and circular referred objects and moves others to the *S1* area. At
    the next minor collection, *S0* and *S1* switch roles. The referenced objects
    are moved from Eden and *S1* to *S0*.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 年轻代有三个区域，一个伊甸园空间和两个幸存者空间，如幸存者0（*S0*）和幸存者1（*S1*）。新创建的对象被放置在伊甸园中。当它填满时，会启动一个次要的垃圾收集过程。它会移除无引用和循环引用的对象，并将其他对象移动到*S1*区域。在下一次次要收集时，*S0*和*S1*会交换角色。引用对象会从伊甸园和*S1*移动到*S0*。
- en: At each of the minor collections, the objects that have reached a certain age
    are moved to the old generation. As the result of this algorithm, the old generation
    contains objects that are older than a certain age. This area is bigger than the
    young generation, and, because of that, the garbage collection here is more expensive
    and doesn't happen as often as in the young generation. But it is checked eventually
    (after several minor collections); the un-referenced objects are removed from
    there and the memory is defragmented. This cleaning of the old generation is considered
    a major collection.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次次要收集时，已经达到一定年龄的对象会被移动到老年代。由于这个算法的结果，老年代包含了比一定年龄更老的对象。这个区域比年轻代要大，因此垃圾收集在这里更昂贵，不像在年轻代那样频繁。但最终会进行检查（经过几次次要收集）；无引用的对象将从那里删除，并且内存会被整理。这种老年代的清理被认为是一次主要收集。
- en: When stop-the-world is unavoidable
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当无法避免停顿时间时
- en: 'Some collections of objects in the old generation are done concurrently and
    some are done using stop-the-world pauses. The steps include:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 老年代中的一些对象收集是并发进行的，而另一些则使用停顿时间进行。具体步骤包括：
- en: Initial marking of survivor regions (root regions) that may have references
    to objects in the old generation, done using stop-the-world pause
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对可能在老年代中引用对象的幸存者区域（根区域）进行初始标记，使用停顿时间进行
- en: Scanning of survivor regions for references into the old generation, done concurrently,
    while the application continues to run
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描幸存者区域以查找对老年代的引用，与此同时应用程序继续运行
- en: Concurrent marking of live objects over the entire heap, done concurrently,
    while the application continues to run
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发标记整个堆中的活动对象，与此同时应用程序继续运行
- en: Remark – completes the marking of live objects, done using stop-the-world pause
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记 - 完成对活动对象的标记，使用停顿时间进行
- en: Cleanup – calculates the age of live objects and frees regions (using stop-the-world)
    and returns them to the free list (concurrently)
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理 - 计算活动对象的年龄并释放区域（使用停顿时间），并将其返回到空闲列表（并发进行）
- en: The preceding sequence might be interspersed with the young generation evacuations
    because most of the objects are short-lived and it is easier to free a lot of
    memory by scanning the young generation more often. There is also a mixed phase
    (when G1 collects the regions already marked as mostly garbage in both the young
    and the old generations) and humongous allocation (where large objects are moved
    to or evacuated from humongous regions).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的序列可能会与年轻一代的疏散交错，因为大多数对象的生命周期很短，通过更频繁地扫描年轻一代来释放大量内存更容易。还有一个混合阶段（当G1收集已标记为大部分垃圾的区域，既在年轻一代又在旧一代）和巨大分配（将大对象移动到或从巨大区域疏散）。
- en: 'To demonstrate how GC works, let''s create a program that produces more garbage
    than our usual examples:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示GC的工作原理，让我们创建一个产生比我们通常的示例更多垃圾的程序：
- en: '```java'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class GarbageCollectionDemo {
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: public class GarbageCollectionDemo {
- en: public static void main(String... args) {
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String... args) {
- en: int max = 99888999;
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: int max = 99888999;
- en: List<Integer> list = new ArrayList<>();
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: List<Integer> list = new ArrayList<>();
- en: for(int i = 1; i < max; i++){
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: for(int i = 1; i < max; i++){
- en: list.add(Integer.valueOf(i));
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(Integer.valueOf(i));
- en: '}'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This program generates close to 100,000,000 objects that take a chunk of heap
    and force GC to move them around from Eden, to S0, S1, and so on. As we have mentioned
    already, to see the log messages from GC, the option `-Xlog:gc` has to be included
    in the `java` command. We chose to use IDE for that, as we described in the previous
    section:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序生成接近100,000,000个占用大量堆空间的对象，并迫使GC将它们从Eden移动到S0、S1等。正如我们已经提到的，要查看GC的日志消息，必须在`java`命令中包含选项`-Xlog:gc`。我们选择使用IDE，正如我们在上一节中描述的那样：
- en: '![](img/c73265ab-f907-43e7-855d-8e04e98394a9.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c73265ab-f907-43e7-855d-8e04e98394a9.png)'
- en: 'Then, we had run the program `GarbageCollectionDemo` and got the following
    output (we show only its beginning):'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们运行了程序`GarbageCollectionDemo`并得到了以下输出（我们只显示了其开头）：
- en: '![](img/173896b1-0e47-4fc2-ac88-4e8e33db9032.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![](img/173896b1-0e47-4fc2-ac88-4e8e33db9032.png)'
- en: 'As you can see, the GC process goes through cycles and moves the objects as
    needed, pausing for a short time. We hope you got an idea of how GC works. The
    only thing we would like to mention is that there are a few occasions when full
    GC is performed, using stop-the-world pause:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，GC过程经过循环，并根据需要移动对象，暂停一小段时间。我们希望您了解了GC的工作原理。我们唯一想提到的是，在几个场合下会执行完全GC，使用停止-世界暂停：
- en: '**Concurrent failure**: If during the marking phase the old generation gets
    full.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发故障：如果在标记阶段旧一代变满。
- en: '**Promotion failure**: If during the mixed phase the old generation runs out
    of space.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提升失败**：如果在混合阶段旧一代空间不足。'
- en: '**Evacuation failure**: When the collector cannot promote objects to the survivor
    space and the old generation.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**疏散失败**：当收集器无法将对象提升到幸存者空间和旧一代时。'
- en: '**Humongous allocation**: When an application tries to allocate a very big
    object. If tuned properly, your applications should avoid full GC.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**巨大分配**：当应用程序尝试分配一个非常大的对象时。如果调整正确，您的应用程序应该避免完全GC。'
- en: To help with GC tuning, the JVM provides platform-dependent default selections
    for the garbage collector, heap size, and runtime compiler.  But fortunately,
    the JVM vendors improve and tune GC process all the time, so most of the applications
    work just fine with the default GC behavior.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助GC调优，JVM提供了平台相关的默认选择，用于垃圾收集器、堆大小和运行时编译器。但幸运的是，JVM供应商一直在改进和调优GC过程，因此大多数应用程序都可以很好地使用默认的GC行为。
- en: Exercise – Monitoring JVM while running an application
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习-在运行应用程序时监视JVM
- en: Read the Java official documentation and name a few tools that come with JDK
    installation that can be used to monitor JVM and the Java application.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读Java官方文档，并命名几个随JDK安装提供的工具，可用于监视JVM和Java应用程序。
- en: Answer
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Jcmd, Java VisualVM, and JConsole, for example. Jcmd is particularly helpful
    as it is easy to remember and gives you the list of all Java processes that are
    currently running. Just type `jcmd` in the terminal window. That is an indispensable
    tool in case you are experimenting with several Java applications and some of
    them may not exit, whether because of a defect or because of such an intended
    design. Jcmd displays a **Process ID** (**PID**) for each running Java process,
    which you can use to stop it if need be by typing the command `kill -9 <PID>`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 例如Jcmd、Java VisualVM和JConsole。Jcmd特别有帮助，因为它易于记忆，并为您列出当前正在运行的所有Java进程。只需在终端窗口中键入`jcmd`。这是一个不可或缺的工具，因为您可能正在尝试运行几个Java应用程序，其中一些可能因为缺陷或故意设计而无法退出。Jcmd为每个正在运行的Java进程显示一个**进程ID**（**PID**），您可以使用该ID通过键入命令`kill
    -9 <PID>`来停止它。
- en: Summary
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned about the main Java processes that support
    any application's execution, the steps of a program's execution, and the main
    components of JVM architecture that compose the execution environment; runtime
    data areas, classloader, and execution engine. You have also learned about the
    lightweight processes called threads and how they can be used for concurrent processing.
    The summary of ways to run a Java application and the main features of the garbage
    collection process concluded the discussion about JVM.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解了支持任何应用程序执行的主要Java进程，程序执行的步骤以及组成执行环境的JVM架构的主要组件；运行时数据区域，类加载器和执行引擎。您还了解了称为线程的轻量级进程以及它们如何用于并发处理。有关运行Java应用程序的方法总结以及垃圾收集过程的主要特点结束了有关JVM的讨论。
- en: In the next chapter, we will walk through several often used libraries – both
    standard (that come with JDK) and external open-source libraries. Pretty soon,
    you will know most of them very well, but to get there you need to start, and
    we will help you with our comments and examples.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍几个经常使用的库-标准库（随JDK一起提供）和外部开源库。很快，您将非常了解它们中的大部分，但要到达那里，您需要开始，我们将在评论和示例中帮助您。
