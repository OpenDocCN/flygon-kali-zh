- en: Chapter 4. Thread Carefully
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。小心操作
- en: '|   | *"Premature optimization is the root of all evil."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"过早优化是万恶之源。"* |   |'
- en: '|   | --*-Donald Knuth* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*-Donald Knuth* |'
- en: 'We covered a very important concept in the previous chapter: content provider.
    We progressed in a step-by-step manner, covering essential questions such as how
    to create a content provider and how to use an existing system with a content
    provider in detail. We also covered how to use the content provider we created
    by means of creating a test application to access it.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们涵盖了一个非常重要的概念：内容提供程序。我们以一步一步的方式进行了进展，详细介绍了如何创建内容提供程序以及如何使用现有系统与内容提供程序。我们还介绍了如何通过创建一个测试应用程序来访问我们创建的内容提供程序。
- en: In this chapter, we will explore how to use loaders, in particular, a loader
    called cursor loader. We will look at how to interact with a content provider
    asynchronously with the help of an example. We will discuss the important topic
    of security in the Android database and how we can ensure that data is secured
    in an Android model. Last but not least, we will also see some code snippets that
    will cover topics such as how to upgrade a database and how to ship a preloaded
    database with our application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用加载器，特别是一种名为游标加载器的加载器。我们将通过一个示例来了解如何异步与内容提供程序进行交互。我们将讨论安卓数据库中的重要安全主题，以及如何确保数据在安卓模型中得到保护。最后但并非最不重要的是，我们还将看到一些代码片段，涵盖了如何升级数据库以及如何在应用程序中预装数据库。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Loading data with CursorLoader
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CursorLoader加载数据
- en: Data security
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据安全
- en: General tips and libraries
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般提示和库
- en: Loading data with CursorLoader
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CursorLoader加载数据
- en: '`CursorLoader` is part of the loader family. Before we dive deep into an example
    explaining how to use `CursorLoader`, we will explore a bit about loaders and
    why it is important in the current scenario.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`CursorLoader`是加载器家族的一部分。在我们深入探讨如何使用`CursorLoader`的示例之前，我们将稍微探讨一下加载器以及为什么它在当前情况下很重要。'
- en: Loaders
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载器
- en: 'Introduced in HoneyComb (API level 11), **loaders** serve the purpose of asynchronously
    serving data in an activity or fragment. The need to have loaders arose from many
    things: calls to various time-consuming methods on the main UI thread in order
    to fetch data that leads to a clunky UI, and even in some cases, the dreaded ANR
    box. This is demonstrated in the following screenshot:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在HoneyComb（API级别11）中引入，**加载器**的作用是在活动或片段中异步提供数据。需要加载器的原因有很多：在主UI线程上调用各种耗时方法以获取数据导致界面笨重，甚至在某些情况下出现可怕的ANR对话框。这在以下截图中有所展示：
- en: '![Loaders](img/2951OS_04_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![加载器](img/2951OS_04_01.jpg)'
- en: For example, the `managedQuery()` method, which was deprecated in API 11, was
    a wrapper around the `ContentResolver'squery()` method.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`managedQuery()`方法在API 11中已被弃用，它是`ContentResolver'squery()`方法的包装器。
- en: In the previous chapter, while highlighting how to fetch data from a content
    provider inside the query method, we used `getContentResolver.query()` instead
    of `managedQuery()`. Using deprecated methods can lead to problems with future
    releases and should be avoided.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在强调如何在查询方法中从内容提供程序中获取数据时，使用了`getContentResolver.query()`而不是`managedQuery()`。使用弃用的方法可能会导致未来版本出现问题，应该避免使用。
- en: Loaders provide asynchronous loading of data for an activity of fragment on
    a non-UI thread. The loader or the subclasses of a loader perform their work in
    a separate thread and deliver their results to the main thread. The segregation
    of calls from the main thread and the posting of results on the main thread while
    working in a separate thread ensure that we have a responsive application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器为活动或片段在非UI线程上异步加载数据。加载器或加载器的子类在单独的线程中执行其工作，并将结果传递到主线程。在单独的线程中工作时，从主线程中调用和在主线程上发布结果的分离确保我们拥有一个响应迅速的应用程序。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Post the loader era, we were faced with problems such as when an activity should
    be recreated due to a configuration change, for instance, rotation of a device's
    orientation. We had to worry about data and refetch data while creating a new
    instance. But with loaders, we don't have to worry about all these as loaders
    automatically reconnect to the last loader's cursor when being recreated after
    a device configuration change and refetch the data. As an added bonus, loaders
    monitor the data source and deliver new results when the content changes. In other
    words, loaders automatically get updated, and hence, there is no need to requery
    the cursor. Read more about keeping your Android application responsive and avoiding
    **application not responding** (**ANR**) messages at the Android developer website,
    [http://developer.android.com/training/articles/perf-anr.html](http://developer.android.com/training/articles/perf-anr.html).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载器时代之后，我们面临着诸如当活动由于配置更改而需要重新创建时的问题，例如，设备方向的旋转。我们必须在创建新实例时担心数据和重新获取数据。但是有了加载器，我们不必担心所有这些，因为加载器在设备配置更改后重新创建时会自动重新连接到上一个加载器的游标并重新获取数据。作为额外的奖励，加载器监视数据源，并在内容更改时提供新的结果。换句话说，加载器会自动更新，因此无需重新查询游标。在安卓开发者网站上阅读更多关于保持您的安卓应用程序响应迅速并避免**应用程序无响应**（**ANR**）消息的内容，网址为[http://developer.android.com/training/articles/perf-anr.html](http://developer.android.com/training/articles/perf-anr.html)。
- en: Loader API's summary
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载器API摘要
- en: 'Let''s look at the loader API that consists of various classes and interfaces.
    In this section, we will look at the implementation aspect of loader API''s classes/interfaces:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看由各种类和接口组成的加载器API。在本节中，我们将看一下加载器API类/接口的实现方面：
- en: '| Class/interface | Description |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 类/接口 | 描述 |'
- en: '| --- | --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `LoaderManager` | This is an abstract class associated with an activity or
    fragment to manage a loader. Although there can be one or more loader instances,
    only one instance of `LoaderManager` per activity or fragment is permitted. It
    is responsible for dealing with the activity or fragment''s life cycle and particularly
    helpful when running long-running tasks. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `LoaderManager` | 这是与活动或片段关联的抽象类，用于管理加载器。虽然可以有一个或多个加载器实例，但每个活动或片段只允许一个`LoaderManager`实例。它负责处理活动或片段的生命周期，特别是在运行长时间任务时非常有帮助。'
- en: '| `LoaderManager.LoaderCallbacks` | This is a callback interface we must implement
    to interact with `LoaderManager`. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `LoaderManager.LoaderCallbacks` | 这是一个回调接口，我们必须实现以与`LoaderManager`交互。'
- en: '| `Loader` | This is the base class for a loader. It''s an abstract class that
    performs asynchronous loading of data. We can implement our own subclass instead
    of using subclasses such as `CursorLoader`. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `Loader` | 这是加载器的基类。它是一个执行数据异步加载的抽象类。我们可以实现自己的子类，而不是使用诸如`CursorLoader`之类的子类。'
- en: '| `AsyncTaskLoader` | This is an abstract loader that provides `AsyncTask`
    to perform the work in the background, that is, on a separate thread; however,
    the result is delivered on the main thread. According to the documentation, it
    is advised to subclass `AsyncTaskLoader` instead of directly subclassing the `Loader`
    class. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `AsyncTaskLoader` | 这是一个抽象的加载器，提供`AsyncTask`在后台执行工作，也就是在单独的线程上；然而，结果是在主线程上传递的。根据文档，建议子类化`AsyncTaskLoader`而不是直接子类化`Loader`类。'
- en: '| `CursorLoader` | This is a subclass of `AsyncTaskLoader` that queries `ContentResolver`
    on the background thread in a non-blocking manner and returns a cursor. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `CursorLoader` | 这是`AsyncTaskLoader`的子类，它在后台线程上以非阻塞方式查询`ContentResolver`并返回游标。'
- en: Using CursorLoader
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CursorLoader
- en: Loaders provide us with a lot of handy features; one of them is that once our
    activity or fragment implements a loader, it need not worry about refreshing the
    data. A loader monitors the data source for us, reflects any changes, and even
    performs new loads; all of this is done asynchronously. Hence, we do not need
    to take care of implementing and managing threads, offloading queries on the background
    thread, and retrieving results once the query is completed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器为我们提供了许多方便的功能；其中之一是一旦我们的活动或片段实现了加载器，就不需要担心刷新数据。加载器为我们监视数据源，反映任何更改，甚至执行新的加载；所有这些都是异步完成的。因此，我们不需要关心实现和管理线程，将查询卸载到后台线程，并在查询完成后检索结果。
- en: 'A loader can be in any one of the following three distinct states:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器可以处于以下三种不同状态之一：
- en: '**Started state**: Once started, loaders remain in this state until stopped
    or reset. It executes loads, monitors any change, and reflects the same to the
    listeners.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动状态**：一旦启动，加载器将保持在此状态，直到停止或重置。它执行加载，监视任何更改，并将其反映给监听器。'
- en: '**Stopped state**: Here, loaders continue to monitor changes but do not pass
    the result to the clients.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止状态**：在这里，加载器继续监视更改，但不将结果传递给客户端。'
- en: '**Reset state**: In this state, loaders release any resources they have held
    and do not perform the process of executing, loading, or monitoring data.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重置状态**：在此状态下，加载器释放其持有的任何资源，并不执行执行、加载或监视数据的过程。'
- en: We will now relook at our personal contact manager application and make the
    corresponding changes to implement `CursorLoader` in our application. `CursorLoader`,
    as the name suggests, is a loader that queries `ContentResolver` and returns a
    cursor. This is a subclass of `AsyncTaskLoader` and performs the cursor query
    on the background thread so that it does not block the application's UI. In the
    diagram, you can see the various methods of a loader callback and how they communicate
    with `CursorLoader` and `CursorAdapter`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将重新查看我们的个人联系人管理应用程序，并对我们的应用程序实现`CursorLoader`进行相应的更改。`CursorLoader`，顾名思义，是一个查询`ContentResolver`并返回游标的加载器。这是`AsyncTaskLoader`的子类，并在后台线程上执行游标查询，以便不阻塞应用程序的UI。在图表中，您可以看到加载器回调的各种方法以及它们如何与`CursorLoader`和`CursorAdapter`进行通信。
- en: '![Using CursorLoader](img/2951OS_04_07.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![使用CursorLoader](img/2951OS_04_07.jpg)'
- en: 'For implementing a cursor loader, we need to perform the following steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现游标加载器，我们需要执行以下步骤：
- en: 'To begin with, we need to implement the `LoaderManager.LoaderCallbacks<Cursor>`
    interface:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要实现`LoaderManager.LoaderCallbacks<Cursor>`接口：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, implement the methods that reflect the distinct states of a loader: `onCreateLoader()`,
    `onLoadFinished()`, and `onLoaderReset()`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，实现反映加载器不同状态的方法：`onCreateLoader()`，`onLoadFinished()`和`onLoaderReset()`。
- en: 'To initiate a query, we will make a call to the `LoaderManager.initLoader()`
    method; this initializes the background framework:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发起查询，我们将调用`LoaderManager.initLoader()`方法；这将初始化后台框架。
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `CUR_LOADER` value is passed on to the `onCreateLoader()` method, which
    acts as an ID for the loader. A call to `initloader()` invokes `onCreateLoader()`,
    passing the ID we used to call `initloader()`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`CUR_LOADER`值传递给`onCreateLoader()`方法，它充当加载器的ID。对`initloader()`的调用会调用`onCreateLoader()`，传递我们用于调用`initloader()`的ID：'
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We use a switch case to take the loader based on its ID and return `null` for
    an invalid ID. We create a URI object `contentUri` and pass it as a parameter
    to the `CursorLoader` constructor. A point to note is that we can implement a
    cursor loader using either this constructor or an empty unspecified cursor loader,
    `CursorLoader(Context context)`. Also, we can set values via methods such as `setUri(Uri)`,
    `setSelection(String)`, `setSelectionArgs(String[])`, `setSortOrder(String)`,
    and `setProjection(St``ring[])`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用switch case根据其ID获取加载器，并对于无效的ID返回`null`。我们创建一个URI对象`contentUri`并将其作为参数传递给`CursorLoader`构造函数。需要注意的是，我们可以使用此构造函数或空的未指定的游标加载器`CursorLoader(Context
    context)`来实现游标加载器。此外，我们可以通过方法设置值，例如`setUri(Uri)`，`setSelection(String)`，`setSelectionArgs(String[])`，`setSortOrder(String)`和`setProjection(String[])`：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following are the parameters of the previous code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的参数：
- en: '`context`: This is the parent activity context.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context`：这是父活动的上下文。'
- en: '`uri`: We employ `contentURI`, using the `content://` scheme, to retrieve the
    content. It can be based on an ID or directory.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uri`：我们使用`contentURI`，采用`content://`方案，来检索内容。它可以基于ID或目录。'
- en: '`projection`: This is a list of columns to be returned as we are prepared with
    the column names. Passing `null` will return all the columns.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`projection`：这是要返回的列的列表，因为我们已经准备好了列名。传递`null`将返回所有列。'
- en: '`selection`: This is formatted as a SQL `WHERE` clause, excluding the `WHERE`
    itself, acting as a filter declaring which rows to return.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selection`：这被格式化为SQL的`WHERE`子句，不包括`WHERE`本身，作为一个过滤器声明要返回哪些行。'
- en: '`selectionArgs`: We may include question marks in the selection, which will
    be replaced by the values bound as a string from `selectionArgs`, and they will
    appear in the order of their selection.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selectionArgs`：我们可以在选择中包含问号，这些问号将被`selectionArgs`中绑定的字符串值替换，并按照它们的选择顺序出现。'
- en: '`sortOrder`: This tells us how to order rows, formatted as a SQL `ORDER BY`
    clause. A null value will use the default sort order.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sortOrder`：这告诉我们如何对行进行排序，格式为SQL的`ORDER BY`子句。空值将使用默认排序顺序。'
- en: '`onCreateLoader` starts the query in the background, and when the query is
    finished, the cursor loader object is passed to the background''s framework, which
    calls `onLoadFinished()`, where we provide our adapter instance with the cursor
    object data:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onCreateLoader`在后台启动查询，当查询完成时，游标加载器对象被传递给后台的框架，框架调用`onLoadFinished()`，我们在这里提供游标对象数据给我们的适配器实例：'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The adapter is a subclass of `CursorAdapter`. Instead of the traditional `getView()`
    method, which we get by extending `BaseAdapter`, we have the `bindView()` and
    `newView()` methods. We inflate our listview row layout in the view object in
    `newView`, and in bind view, we perform an action similar to the `getView()` method.
    We define our layout elements and associate theme with the relevant data:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适配器是`CursorAdapter`的子类。我们不再使用传统的通过扩展`BaseAdapter`获得的`getView()`方法，而是使用`bindView()`和`newView()`方法。我们在`newView`中填充我们的列表视图行布局，而在bind
    view中，我们执行类似于`getView()`方法的操作。我们定义我们的布局元素，并将其与相关数据关联起来：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This method is invoked when the cursor loader is being reset. We clear out
    any reference to the cursor by passing `null` to the `changeCursor()` method.
    Whenever the data associated with a cursor changes, the cursor loader calls this
    method before it reruns the query to clear any past references, thereby preventing
    memory leaks. Once `onLoaderReset()` is set, the cursor loader will rerun its
    query:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当游标加载器被重置时，将调用此方法。我们通过向`changeCursor()`方法传递`null`来清除对游标的任何引用。每当与游标相关的数据发生更改时，游标加载器在重新运行查询之前调用此方法，以清除任何过去的引用，从而防止内存泄漏。一旦设置了`onLoaderReset()`，游标加载器将重新运行其查询。
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we move on to our content provider where we have to make small changes
    to ensure that any changes we make to the database are reflected in our application''s
    list view:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们转向我们的内容提供程序，在那里我们必须进行一些小的更改，以确保我们对数据库所做的任何更改都反映在我们应用程序的列表视图中：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We need to register `observer` in `ContentResolver` through the cursor in the
    query method of `ContentProvider`. We do this to watch the content URI for any
    changes, which can be the URI of a specific data row or table in our case:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`ContentProvider`的查询方法中通过游标在`ContentResolver`中注册`observer`。我们这样做是为了监视内容URI的任何更改，这可以是特定数据行或表的URI：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the `insert()` method, we use the `notifyChange()` method to inform registered
    observers that a row was updated. By default, the `CursorAdapter` objects will
    get this notification. So, now when we add a new row of data by inserting a new
    contact in our application, the `insert()` method of `contentProvider` is invoked
    via a call:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`insert()`方法中，我们使用`notifyChange()`方法通知已注册的观察者行已更新。默认情况下，`CursorAdapter`对象将收到此通知。因此，现在当我们通过在我们的应用程序中插入新联系人来添加新的数据行时，将通过调用`contentProvider`的`insert()`方法：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A similar action needs to be performed for the `delete()` and `update()` methods,
    both of which have been left as an exercise for the reader as most of the boilerplate
    code is present. Implementing a loader is simple and saves us from a lot of headache
    when it comes to threading, and a jarring UI is highly recommended to perform
    this task.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`delete()`和`update()`方法，需要执行类似的操作，这两种方法都留给读者作为练习，因为大部分样板代码都已经存在。实现加载器是简单的，可以节省我们很多线程方面的麻烦，强烈建议在执行此任务时避免令人不悦的UI。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`loadInBackground()` is another important method; this returns a cursor instance
    for a load operation and is called on the worker thread. Ideally, `loadInBackground`
    `()`should not directly return the result of the load operation, but we can achieve
    this by overriding the `deliverResult(D)` method. To cancel, we need to check
    the value of `isLoadInBackgroundCanceled()` as we do in the case of `AsyncTask`,
    where we check `isCancelled()`periodically.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadInBackground()`是另一个重要的方法；这返回一个用于加载操作的游标实例，并在工作线程上调用。理想情况下，`loadInBackground()`不应直接返回加载操作的结果，但我们可以通过重写`deliverResult(D)`方法来实现这一点。要取消，我们需要检查`isLoadInBackgroundCanceled()`的值，就像在`AsyncTask`中检查`isCancelled()`一样，定期检查。'
- en: Data security
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据安全
- en: Security is the latest buzzword in town. The Android ecosystem ensures that
    our database is exposed to prying eyes; however, a rooted device can leave our
    database exposed, as we saw in [Chapter 2](ch02.html "Chapter 2. Connecting the
    Dots"), *Connecting the Dots*. With the help of a rooted device, an emulator and
    the `adb pull` command in our case, we pulled our database for inspection with
    the SQLite manager tool. Another important aspect is content providers; we need
    to be careful while setting permissions. We should make the process of applying
    appropriate permissions compulsory in order to inform users about the control
    that an app establishes over data, using the `contract` class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 安全是当今的热门词。Android生态系统确保我们的数据库不会暴露给窥探的眼睛；然而，一个rooted设备可能会暴露我们的数据库，就像我们在[第2章](ch02.html
    "第2章.连接点")*连接点*中看到的那样。借助rooted设备，模拟器和`adb pull`命令，在我们的情况下，我们拉取了我们的数据库以便使用SQLite管理工具进行检查。另一个重要的方面是内容提供程序；在设置权限时，我们需要小心。我们应该强制执行适当权限的申请过程，以便告知用户应用程序对数据的控制，使用`contract`类。
- en: ContentProvider and permissions
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ContentProvider和权限
- en: 'In [Chapter 3](ch03.html "Chapter 3. Sharing is Caring"), *Sharing is Caring*,
    we briefly covered the topic of permissions in the *Adding a provider to a manifest*
    section. Let''s elaborate a little more on this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章.分享是关心")*分享是关心*中，我们简要介绍了*将提供者添加到清单*部分中的权限主题。让我们再详细介绍一下：
- en: 'As mentioned earlier, while adding the content provider to the manifest, we
    will also add our custom permissions. This will ensure two things, namely, stop
    an unauthorized action in an application and inform the users about permissions:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，在将内容提供程序添加到清单时，我们还将添加我们的自定义权限。这将确保两件事，即阻止应用程序中的未经授权的操作，并告知用户权限：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Additionally, we will add the `permissions` tag to the manifest to indicate
    the set of permissions that other applications will require:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们将在清单中添加`permissions`标签，以指示其他应用程序将需要的权限集：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, in the application in which we want to access the content provider we
    use the `permission` tag, in our case, `Ch4-TestApp` in code bundle:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们想要访问内容提供程序的应用程序中，我们使用`permission`标签，在我们的情况下，在代码包中使用`Ch4-TestApp`：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When users install this application, they will get our custom permission message
    along with other permissions required by the application. For this step, instead
    of directly running the application from Eclipse, export an apk and install it:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户安装此应用程序时，他们将收到我们的自定义权限消息以及应用程序所需的其他权限。在这一步中，不要直接从Eclipse运行应用程序，而是导出一个apk并安装它：
- en: '![ContentProvider and permissions](img/2951OS_04_02.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![ContentProvider和权限](img/2951OS_04_02.jpg)'
- en: 'If you have not defined the permission in the application and if the application
    tries to access the content provider, it will get the `SecurityException: Permission
    Denial` message.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您没有在应用程序中定义权限，并且应用程序尝试访问内容提供程序，它将收到`SecurityException: Permission Denial`消息。'
- en: If the content provider we created is not meant to be shared, we will need to
    change the `android:exported="true"` property to `false`. This will make our content
    provider secure, and if someone tries to run a malicious query on it, they will
    encounter a security exception.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建的内容提供程序不打算共享，我们需要将`android:exported="true"`属性更改为`false`。这将使我们的内容提供程序更安全，如果有人试图对其运行恶意查询，他们将遇到安全异常。
- en: If we want to share data only between our applications, Android provides a solution;
    we can use `android:protectionLevel` and set the permission to `signature` instead
    of `normal`. For this, both the apps, the one that implements the content provider
    and the one that wants to access it, have to be signed by the same key while they
    are exported. This is because a bonus signature permission does not require user
    confirmation. This does not confuse the user as it is done internally and also
    does not obstruct the user experience.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想在我们的应用程序之间共享数据，Android提供了一个解决方案；我们可以使用`android:protectionLevel`并将权限设置为`signature`而不是`normal`。为此，实现内容提供程序和想要访问它的应用程序都必须在导出时由相同的密钥签名。这是因为奖励签名权限不需要用户确认。这不会让用户感到困惑，因为它是在内部完成的，也不会影响用户体验。
- en: Encrypting critical data
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加密关键数据
- en: We have already discussed what kind of access rights other applications have
    on our database and how to efficiently share our content providers, and we also
    briefly discussed why we should not believe that the system is foolproof. In the
    most foolproof method, sensitive data will not be kept on the device but on the
    server instead, and it will use tokens to give access. If you have to store the
    data on the device's database, use encryption. Use a user-defined key to encrypt
    and decrypt sensitive data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了其他应用程序对我们的数据库有什么样的访问权限，以及如何有效地共享我们的内容提供程序，我们也简要讨论了为什么我们不应该相信系统是绝对安全的。在最安全的方法中，敏感数据不会保存在设备上，而是保存在服务器上，并且它将使用令牌来授予访问权限。如果必须将数据存储在设备的数据库中，请使用加密。使用用户定义的密钥来加密和解密敏感数据。
- en: We will explore a way to use an encrypted database, which will not be readable
    if someone is able to extract it via means of a root or via exploiting backups.
    If someone tries to read it using SQLite Manager or some other tool, they will
    receive a friendly message, such as the one shown in the following screenshot;
    this is the database file that we will create in a moment with a library known
    as SQLCipher.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨一种使用加密数据库的方法，如果有人能够通过root或利用备份的手段提取它，那么它将是不可读的。如果有人试图使用SQLite Manager或其他工具来读取它，他们将收到友好的消息，就像下面截图中显示的那样；这是我们将用一个名为SQLCipher的库在一会儿创建的数据库文件。
- en: '![Encrypting critical data](img/2951OS_04_03.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![加密关键数据](img/2951OS_04_03.jpg)'
- en: 'SQLCipher is an open source extension to SQLite that provides a transparent
    256-bit AES encryption of database files, as mentioned on their website. It is
    very easy to deploy SQLCipher. Now we''ll look at the steps to build a sample
    application:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: SQLCipher是SQLite的一个开源扩展，提供了数据库文件的透明256位AES加密，正如他们的网站上所提到的。部署SQLCipher非常容易。现在我们将看一下构建一个示例应用程序的步骤：
- en: First, we will download the necessary files from [http://sqlcipher.net/open-source](http://sqlcipher.net/open-source).
    Here, they have listed a community edition of the Android-based SQLCipher; download
    it.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从[http://sqlcipher.net/open-source](http://sqlcipher.net/open-source)下载所需的文件。在这里，他们列出了基于Android的SQLCipher的社区版；下载它。
- en: Now we will create a new Android project in our eclipse environment.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在我们的eclipse环境中创建一个新的Android项目。
- en: Inside the downloaded folder, we will find the `libs` folder; inside it, are
    a set of jars that we will need to work with SQLCipher. We will also notice that
    folders are named as `armeabi`, `armeabi-v7a`, and `x86`, and all of these contain
    the `.so` files. If you are familiar with Android NDK, this will not seem new.
    The `.so` file is a shared object file, which is a component of dynamic libraries.
    For different architectures, we require different `.so` files, hence the three
    folders. If you are running an x86 emulator, you will need the `x86` folder in
    your `libs` folder. For simplicity, we will copy all the folders to the `libs`
    folder. Copy the `asset` folder's content into our project's `asset` folder and
    navigate to the project's properties. It will look something like the following
    screenshot. You can also see these JAR files in the project's class path. The
    initial setup for this project is now complete.![Encrypting critical data](img/2951OS_04_04.jpg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下载的文件夹中，我们会找到`libs`文件夹；里面是一组我们需要与SQLCipher一起使用的jar文件。我们还会注意到文件夹被命名为`armeabi`，`armeabi-v7a`和`x86`，所有这些文件夹都包含`.so`文件。如果您熟悉Android
    NDK，这不会是新鲜事。`.so`文件是共享对象文件，是动态库的组成部分。对于不同的架构，我们需要不同的`.so`文件，因此有三个文件夹。如果您正在运行x86模拟器，则需要在`libs`文件夹中使用`x86`文件夹。为简单起见，我们将所有文件夹复制到`libs`文件夹中。将`asset`文件夹的内容复制到我们项目的`asset`文件夹中，并导航到项目的属性。它看起来像以下截图。您还可以在项目的类路径中看到这些JAR文件。此项目的初始设置现在已经完成。![加密关键数据](img/2951OS_04_04.jpg)
- en: 'After completing the necessary setup part, let''s move to writing code to make
    a small test application:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 完成必要的设置后，让我们开始编写代码来制作一个小型测试应用程序：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code has two main methods: `InitializeSQLCipher()` and `runQuery()`.
    Inside `InitializeSQLCipher()`, we load our `.so` library files by invoking the
    `loadLibs()` method.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码有两个主要方法：`InitializeSQLCipher()`和`runQuery()`。在`InitializeSQLCipher()`中，我们通过调用`loadLibs()`方法加载我们的`.so`库文件。
- en: Now we find the absolute path to the database and create a missing parent folder
    if any. With `openOrCreateDatabase()`, we will make a call to open an existing
    database or create one if the database is nonexistent. We will execute standard
    database calls to create a table with columns `a` and `b` and insert values in
    a row.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们找到数据库的绝对路径，并创建缺少的父文件夹。通过`openOrCreateDatabase()`，我们将调用打开现有数据库或者如果数据库不存在则创建一个。我们将执行标准的数据库调用来创建一个具有列`a`和`b`的表，并在一行中插入值。
- en: 'Now we will perform a simple query to fetch the values back to the `runQuery()`
    method. You will notice that apart from loading the library, all the core methods
    we used are pretty much standard, so where is the major change? Go to the `Ch4-PersonalContactManager`
    example in the code bundle and notice the packages we have used:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将执行一个简单的查询，将值取回到`runQuery()`方法。您会注意到，除了加载库之外，我们使用的所有核心方法基本上都是标准的，那么主要的变化在哪里呢？转到代码包中的`Ch4-PersonalContactManager`示例，注意我们使用的包：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have SQLCipher packages:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有SQLCipher包：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The implementation is simple, familiar, and easy to implement. If you pull
    the database out and try to read it, you will find the error message, as we displayed
    earlier in a screenshot. The user will find no change, and even our app''s logic
    remains the same. In the screenshot, you can see the application screen we just
    built which encrypts the database:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 实现简单，熟悉且易于实现。如果您将数据库取出并尝试读取它，您将会发现错误消息，就像我们之前在截图中显示的那样。用户将不会发现任何变化，甚至我们应用程序的逻辑仍然保持不变。在截图中，您可以看到我们刚刚构建的应用程序屏幕，它加密了数据库：
- en: '![Encrypting critical data](img/2951OS_04_05.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![加密关键数据](img/2951OS_04_05.jpg)'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**OAuth** is an open standard for authorization. It provides client applications
    with a *secure delegated access* to server resources on behalf of a resource owner.
    It specifies a process for resource owners to authorize third-party access to
    their server resources without sharing their credentials, as explained in Wikipedia;
    read more about OAuth at [http://oauth.net/2/](http://oauth.net/2/).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**OAuth**是授权的开放标准。它为客户端应用程序提供了*安全的委托访问*，以代表资源所有者访问服务器资源。它规定了资源所有者授权第三方访问其服务器资源而不共享其凭据的过程，如维基百科所述；在[http://oauth.net/2/](http://oauth.net/2/)了解更多关于OAuth的信息。'
- en: General tips and libraries
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般提示和库
- en: We will cover some general and not so general workarounds and practices, which
    can be put to good use depending on the situation. For instance, in some cases,
    we need to have a prepopulated database of values that we will make use of in
    our Android application or upgrading a database, which seems trivial but can break
    our application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖一些一般和不那么一般的解决方法和实践，这取决于情况。例如，在某些情况下，我们需要拥有一个预填充的值数据库，我们将在我们的Android应用程序中使用，或者升级一个数据库，这似乎微不足道，但可能会破坏我们的应用程序。
- en: Upgrading a database
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级数据库
- en: 'In [Chapter 2](ch02.html "Chapter 2. Connecting the Dots"), *Connecting the
    Dots*, we used `onUpgrade()` to show how a database is updated. If we go back
    to the example, you will notice that it executes a `Drop Table` command. What
    will happen here is that the original table will be dropped and a new table will
    be created by the call, `onCreate()`. This will lead to a loss of the existing
    data and hence is not suitable if we need to alter our database. The `onUpgrade()`
    function can be defined as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。连接点")中，*连接点*，我们使用`onUpgrade()`来展示数据库如何更新。如果我们回到这个例子，您会注意到它执行了`Drop
    Table`命令。这里将发生的是原始表将被删除，并且通过`onCreate()`调用将创建一个新表。这将导致现有数据的丢失，因此不适合我们需要修改数据库的情况。`onUpgrade()`函数可以定义如下：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: One more challenge is to identify the version we are using here. The user might
    be running older versions of the application, so we have to keep in mind the different
    versions that an application has and whether those versions would bring about
    any changes in the database. For a new user, we need not worry because if the
    database does not exist, `onCreate()` will be called.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个挑战是确定我们在这里使用的版本。用户可能正在运行应用程序的旧版本，因此我们必须记住应用程序具有的不同版本以及这些版本是否会对数据库带来任何更改。对于新用户，我们不需要担心，因为如果数据库不存在，将调用`onCreate()`。
- en: 'To make sure we have a proper upgrade, we will use the `DB_VERSION` constant
    in our `CustomSQLiteOpenHelper` class to tell our `onUpgrade()` method about the
    action to be taken:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们有一个适当的升级，我们将在我们的`CustomSQLiteOpenHelper`类中使用`DB_VERSION`常量，告诉我们的`onUpgrade()`方法要采取的操作：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will change the `DB_VERSION` constant to `3` to reflect the upgrade:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把`DB_VERSION`常量更改为`3`以反映升级：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The constructor will take care of the rest:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数会处理其余的事情：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When the super class constructor is run, it compares the `DB_VERSION` constant
    of the stored SQLite `.db` file against the `DB_VERSION` we passed as a parameter
    and calls the `onUpgrade()` method if needed:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行超类构造函数时，它会将存储的SQLite`.db`文件的`DB_VERSION`常量与我们作为参数传递的`DB_VERSION`进行比较，并在需要时调用`onUpgrade()`方法：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Inside our `onUpgrade()` method, we have a switch case to make changes. Notice
    that we do not use the `break` statement because the user can be on an older version
    and may not have updated the application, as explained earlier. For instance,
    let's consider that a user is on a particular version of an application that is
    running `DB_VERSION =1` and he or she skips the next update that contained `DB_VERSION
    =2`, and eventually, a new version of the application with `DB_VERSION =3` is
    released. Now, we have a case where the user is still using an older version of
    the application and has not installed the new updates we have released. So, in
    this case, when the user installs the application, the `onUpgrade()` method will
    first execute `case 1` and then go to `case 2` to install updates that the user
    missed; finally, the user will install the updates of the third version, ensuring
    that all the database changes are reflected. Notice that there is no `break` statement.
    This is because we want to run all the cases where the `switch` statement obtains
    the value `1` and the last two statements where the switch case obtains the value
    `2`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`onUpgrade()`方法中，我们有一个switch case来进行更改。请注意，我们不使用`break`语句，因为用户可能使用旧版本，并且可能没有更新应用程序，如前面所述。例如，假设用户正在运行`DB_VERSION
    =1`的应用程序的特定版本，并且跳过了包含`DB_VERSION =2`的下一个更新，最终发布了一个具有`DB_VERSION =3`的新版本的应用程序。现在，我们有一个情况，用户仍在使用旧版本的应用程序，并且尚未安装我们发布的新更新。因此，在这种情况下，当用户安装应用程序时，`onUpgrade()`方法将首先执行`case
    1`，然后转到`case 2`以安装用户错过的更新；最后，用户将安装第三个版本的更新，确保所有数据库更改都得到反映。请注意，这里没有`break`语句。这是因为我们希望运行`switch`语句获得值`1`的所有情况以及`switch`语句获得值`2`的最后两个语句。
- en: 'Alternatively, we can also use the `if` statement. This will also behave as
    we intended as our test `DB_VERSION` constant was `1`, which will satisfy both
    the conditions and reflect the changes:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用`if`语句。这也会按照我们的意图进行，因为我们的测试`DB_VERSION`常量是`1`，这将满足两个条件并反映出更改：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Database minus SQL statements
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无需SQL语句的数据库
- en: In most parts of the book, we looked around for nooks and corners of Android
    and SQLite. For some, writing SQL statements would be just another day in the
    office, while for some, it will come across as a roller-coaster ride. This section
    will cover a library that enables us to save and retrieve SQLite database records
    without writing a single SQL statement. **ActiveAndroid** is an active record-style
    SQLite persistence for Android. According to the documentation, each database
    record is wrapped neatly into a class with methods such as `save()` and `delete()`.
    We will be using the example in the ActiveAndroid documentation and build a working
    sample based on it. Let's look at the steps required to get it up and running.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的大部分内容中，我们寻找了Android和SQLite的各个角落。对于一些人来说，编写SQL语句可能只是在办公室的另一天，而对于一些人来说，这可能是一次过山车之旅。本节将介绍一个库，它使我们能够在不编写任何SQL语句的情况下保存和检索SQLite数据库记录。**ActiveAndroid**是用于Android的活动记录风格的SQLite持久化。根据文档，每个数据库记录都被整洁地包装到一个具有`save()`和`delete()`等方法的类中。我们将使用ActiveAndroid文档中的示例，并基于此构建一个可工作的示例。让我们看看启动和运行所需的步骤。
- en: Have a look at the official site, [http://www.activeandroid.com/](http://www.activeandroid.com/),
    for an overview and download the files from [http://goo.gl/oW2kod](http://goo.gl/oW2kod).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 查看官方网站[http://www.activeandroid.com/](http://www.activeandroid.com/)，了解概述并从[http://goo.gl/oW2kod](http://goo.gl/oW2kod)下载文件。
- en: Once you download the file, run `ant` on the root folder to build the JAR file.
    Once you run `ant`, you will find your JAR file in the `dist` folder. In Eclipse,
    make a new project, add the JAR file to the `libs` folder of the project, and
    then add the JAR file to the **Java Build Path** in the project properties.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下载文件后，在根文件夹上运行`ant`来构建JAR文件。运行`ant`后，您将在`dist`文件夹中找到您的JAR文件。在Eclipse中，创建一个新项目，将JAR文件添加到项目的`libs`文件夹中，然后将JAR文件添加到项目属性中的**Java
    Build Path**中。
- en: 'ActiveAndroid looks out for some global settings configured by performing the
    following steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ActiveAndroid会查找通过执行以下步骤配置的一些全局设置：
- en: 'We will start by creating a class, extending the application class:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个类，扩展应用程序类：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we will add this application class to our manifest file and add metadata
    corresponding to our application:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将把这个应用程序类添加到我们的清单文件中，并添加与我们的应用程序对应的元数据：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With this basic setup complete, we will now proceed on to creating our data
    model. The ActiveAndroid library supports annotation and we will use it in the
    following model classes:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成了这个基本设置后，我们现在将继续创建我们的数据模型。ActiveAndroid库支持注释，我们将在以下模型类中使用它：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to explore annotations and use them in your project and reduce
    boilerplate code, you can check out the following libraries for Android: Android
    Annotations, Square''s Dagger, and ButterKnife.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想探索注释并在项目中使用它们并减少样板代码，您可以查看以下Android库：Android Annotations，Square's Dagger和ButterKnife。
- en: 'To add a new category or item, we need to make a call to `save()`. In the code
    segment, we can see that an item object is created and associated with a particular
    category, and in the end, `save()` is called:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加新的类别或项目，我们需要调用`save()`。在代码段中，我们可以看到创建了一个项目对象并与特定类别关联，并且最后调用了`save()`：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To delete an item, we can call `item.delete()`. Similarly, to fetch values,
    we have relevant methods as well. The following is a call to fetch all of the
    data for a particular category:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除项目，我们可以调用`item.delete()`。同样，要获取值，我们也有相关的方法。以下是调用特定类别的所有数据的调用：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There is lot more to be explored in ActiveAndroid. They have schema migration
    and type serialization; in addition to this, you can ship a prepopulated database
    by placing the database in the `asset` folder, and you can use content providers
    as well. In short, it is a well-built library for people looking for indirect
    ways to communicate with the database and perform database operations. It helps
    in accessing the database in the familiar form of Java methods instead of preparing
    SQL statements to perform the same action. The complete sample code is bundled
    in the `chapter 4` code bundle.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在ActiveAndroid中还有很多可以探索的内容。他们有模式迁移和类型序列化；除此之外，您还可以通过将数据库放在`asset`文件夹中来提供预填充数据库，并且还可以使用内容提供程序。简而言之，这是一个为寻求间接与数据库通信并执行数据库操作的人构建的良好库。它有助于以熟悉的Java方法形式访问数据库，而不是准备SQL语句来执行相同的操作。完整的示例代码捆绑在`第4章`的代码包中。
- en: Shipping with a prepopulated database
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用预填充数据库
- en: 'We will build a database and put it inside our `asset` folder, which is a read-only
    directory. At runtime, we will check whether a database exists. If not, we will
    copy our database from the `asset` folder to `/data/data/yourpackage/databases`.
    In [Chapter 2](ch02.html "Chapter 2. Connecting the Dots"), *Connecting the Dots*,
    we used a tool called SQLite Manager; have a look at the third screenshot of the
    chapter. We are going to use the same tool to build our database now. If you pull
    your database as explained in that section or look at that screenshot, you will
    notice a few more tables along with your database table:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个数据库并将其放入我们的`asset`文件夹中，这是一个只读目录。在运行时，我们将检查数据库是否存在。如果不存在，我们将从`asset`文件夹复制我们的数据库到`/data/data/yourpackage/databases`。在[第2章](ch02.html
    "第2章。连接点")中，我们使用了一个名为SQLite Manager的工具；看一下该章的第三个屏幕截图。我们现在将使用相同的工具来构建我们的数据库。如果您按照该部分中解释的方式提取数据库或查看该屏幕截图，您将注意到除了您的数据库表之外还有一些其他表：
- en: '![Shipping with a prepopulated database](img/2951OS_04_06.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![使用预填充数据库](img/2951OS_04_06.jpg)'
- en: 'The steps to be followed to create a prepopulated database are as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 创建预填充数据库的步骤如下：
- en: 'To make a prepopulated database, we need to create a table named `android_metadata`
    apart from the table we require. Using the SQLite Manager tool, we will create
    a new database named `contact`, then we will create the `android_metdata` table:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个预填充的数据库，我们需要创建一个名为`android_metadata`的表，除了我们需要的表。使用SQLite Manager工具，我们将创建一个名为`contact`的新数据库，然后我们将创建`android_metdata`表：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will insert a row in the table:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在表中插入一行：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we will create the tables we require, in our case, `contact_table` using
    the SQL query we used in [Chapter 2](ch02.html "Chapter 2. Connecting the Dots"),
    *Connecting the Dots*. In the `DatabaseManager` class, we will just replace the
    constants with the actual values:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将使用我们在[第2章](ch02.html "第2章。连接点")中使用的SQL查询来创建我们需要的表，即`contact_table`。在`DatabaseManager`类中，我们将只需用实际值替换常量：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It is necessary to rename the primary ID field of our tables to `_id` if it
    is not already defined. This helps Android in identifying where to bind the ID
    field of our tables.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未定义，有必要将我们表的主ID字段重命名为`_id`。这有助于Android识别我们表的ID字段绑定位置。
- en: Let us fill a few rows of data. We can do this by running the `Insert` query
    or manually typing in the values using the tool. Now, copy the database file into
    the `asset` folder.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们填写一些数据行。我们可以通过运行`Insert`查询或使用该工具手动输入值来完成。现在，将数据库文件复制到`asset`文件夹中。
- en: Now, in our original personal contact manager, we will modify our `DatabaseManager`
    class. The good part is that this is the only class we need to modify and the
    rest of the system will work as intended.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们原始的个人联系人管理器中，我们将修改我们的`DatabaseManager`类。好处是这是我们唯一需要修改的类，系统的其余部分将按预期工作。
- en: 'When the application runs and creates a new `DatabaseManager` class by passing
    the context, we will make a call to `createDatabase()` in which first of all we
    will check whether the database already exists:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序运行并通过传递上下文创建一个新的`DatabaseManager`类时，我们将调用`createDatabase()`，首先我们将检查数据库是否已经存在：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If it doesn''t, we will create an empty database that we will replace with
    our database, which we copied into our `asset` folder. After copying the database
    from the `asset` folder, we will create a new `SQLiteDatabase` object:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有，我们将创建一个空数据库，然后将其替换为我们从`asset`文件夹中复制的数据库。从`asset`文件夹复制数据库后，我们将创建一个新的`SQLiteDatabase`对象：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Another point to note is that the `onCreate()` method of our `CustomSQLiteOpenHelper`
    class will be empty as we are not creating a database and tables, but we are copying
    one. The sample code is bundled in the `chapter 4` code bundle. If this process
    looks tedious, don't worry; the Android developers' community has a solution for
    you. SQLiteAssetHelper is an Android library that will help you in managing database
    creation and version management, using an application's raw asset files.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要注意的是，我们的`CustomSQLiteOpenHelper`类的`onCreate()`方法将是空的，因为我们不是在创建数据库和表，而是在复制一个。示例代码捆绑在`第4章`的代码包中。如果这个过程看起来很繁琐，不用担心；Android开发者社区为您提供了解决方案。SQLiteAssetHelper是一个Android库，将帮助您管理数据库的创建和版本管理，使用应用程序的原始资产文件。
- en: 'To implement this, we have to follow a few simple steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们必须遵循一些简单的步骤：
- en: Copy the JAR file into our project's `libs` folder.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将JAR文件复制到我们项目的`libs`文件夹中。
- en: Add a library to Java Build Path.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将库添加到Java构建路径中。
- en: Copy our zipped database file into the `asset` folder of `projectassets/databases/your_database.db.zip`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的压缩数据库文件复制到`projectassets/databases/your_database.db.zip`的`asset`文件夹中。
- en: The ZIP file should contain only one `db` file.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ZIP文件应该只包含一个`db`文件。
- en: Instead of extending the framework's `SQLiteOpenHelper` class, we will extend
    the `SQLiteAssetHelper` class.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要扩展框架的`SQLiteOpenHelper`类，而是扩展`SQLiteAssetHelper`类。
- en: They also provide you with assistance to upgrade the database file, which needs
    to be placed in `assets/databases/<database_name>_upgrade_<from_version>-<to_version>.sql`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们还为您提供升级数据库文件的帮助，该文件需要放在`assets/databases/<database_name>_upgrade_<from_version>-<to_version>.sql`中。
- en: The library, documentation, and its corresponding sample can be found at [http://goo.gl/8XSSmR](http://goo.gl/8XSSmR).
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该库、文档及其相应的示例可在[http://goo.gl/8XSSmR](http://goo.gl/8XSSmR)找到。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We covered a myriad of advanced topics in this chapter, ranging from loaders
    to the security of data. We implemented our cursor loader to understand how a
    loader works magic for our applications, and we delved into securing our database
    and understanding the concept of permissions while exposing our content provider
    to other applications. We also covered some tips such as shipping with a prepopulated
    database, upgrading a database without breaking the system, and using database
    queries without using SQL commands. This is in no way the only set of things we
    can achieve with database and Android. This chapter only serves as a nudge towards
    the vast programming possibilities out there.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了许多高级主题，从加载程序到数据安全性。我们实现了我们的游标加载程序，以了解加载程序如何为我们的应用程序带来魔力，并深入了解了如何保护我们的数据库以及在向其他应用程序公开内容提供程序时理解权限的概念。我们还介绍了一些技巧，比如使用预填充数据库进行发货，升级数据库而不破坏系统，以及在不使用SQL命令的情况下使用数据库查询。这绝不是我们可以通过数据库和Android实现的唯一一组事物。本章只是对广阔的编程可能性的一个推动。
