- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Applying a Microservice Architecture to Your Enterprise Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将微服务架构应用于企业应用程序
- en: This chapter is dedicated to describing highly scalable architectures based
    on small modules called microservices. The microservices architecture allows for
    fine-grained scaling operations where every single module can be scaled as required
    without it affecting the remainder of the system. Moreover, they allow for better
    **Continuous Integration/Continuous Deployment** (**CI/CD**) by permitting every
    system subpart to evolve and be deployed independently of the others.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门描述基于称为微服务的小模块的高度可扩展架构。微服务架构允许进行细粒度的扩展操作，每个模块都可以根据需要进行扩展，而不会影响系统的其他部分。此外，它们还允许更好的持续集成/持续部署（CI/CD），因为每个系统子部分都可以独立演进和部署，而不受其他部分的影响。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What are microservices?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: When do microservices help?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么时候使用微服务有帮助？
- en: How does .NET deal with microservices?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET如何处理微服务？
- en: Which tools are needed to manage microservices?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理微服务所需的工具有哪些？
- en: By the end of this chapter, you will have learned how to implement a single
    microservice in .NET. *Chapter 6*, *Azure Service Fabric*, and *Chapter 7*, *Azure
    Kubernetes Service*, also explain how to deploy, debug, and manage a whole microservices-based
    application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，您将学会如何在.NET中实现单个微服务。第6章“Azure Service Fabric”和第7章“Azure Kubernetes Service”还介绍了如何部署、调试和管理基于微服务的整个应用程序。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, you will require the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将需要以下内容：
- en: Visual Studio 2019 free Community edition or better with all the database tools
    installed.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了所有数据库工具的Visual Studio 2019免费社区版或更高版本。
- en: A free Azure account. The *Creating an Azure account* section in *Chapter 1*,
    *Understanding the Importance of Software Architecture*, explains how to create
    one.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个免费的Azure账户。第1章“理解软件架构的重要性”中的“创建Azure账户”部分解释了如何创建账户。
- en: Docker Desktop for Windows if you want to debug Docker containerized microservices
    in Visual Studio ([https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想在Visual Studio中调试Docker容器化的微服务，需要Windows版Docker Desktop（[https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)）。
- en: What are microservices?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: Microservice architectures allow each module that makes up a solution to be
    scaled independently from the others to achieve the maximum throughput with minimal
    cost. In fact, scaling whole systems instead of their current bottlenecks inevitably
    results in a remarkable waste of resources, so fine-grained control of subsystem
    scaling has a considerable impact on the system's overall cost.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构允许将解决方案的每个模块独立于其他模块进行扩展，以实现最大吞吐量和最小成本。事实上，对整个系统进行扩展而不是当前瓶颈部分必然会导致资源的明显浪费，因此对子系统扩展的细粒度控制对系统的整体成本有着重要影响。
- en: However, microservices are more than scalable components – they are software
    building blocks that can be developed, maintained, and deployed independently
    of each other. Splitting development and maintenance among modules that can be
    independently developed, maintained, and deployed improves the overall system's
    CI/CD cycle (the CI/CD concept was explained in more detail in the *Organizing
    your work using Azure DevOps* section in *Chapter 3*, *Documenting Requirements
    with Azure DevOps*).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，微服务不仅仅是可扩展的组件-它们是可以独立开发、维护和部署的软件构建块。将开发和维护分割成可以独立开发、维护和部署的模块，可以改善整个系统的CI/CD周期（CI/CD概念在第3章的“使用Azure
    DevOps组织工作”部分和“使用Azure DevOps记录需求”部分中有更详细的解释）。
- en: 'The CI/CD improvement is due to microservice *independence* because it enables
    the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务的“独立性”，CI/CD的改进是可能的，因为它实现了以下功能：
- en: Scaling and distributing microservices on different types of hardware.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同类型的硬件上进行微服务的扩展和分布。
- en: Since each microservice is deployed independently from the others, there can't
    be binary compatibility or database structure compatibility constraints. Therefore,
    there is no need to align the versions of the different microservices that compose
    the system. This means that each of them can evolve, as needed, without being
    constrained by the others.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每个微服务都是独立部署的，因此不存在二进制兼容性或数据库结构兼容性约束。因此，不需要对组成系统的不同微服务的版本进行对齐。这意味着每个微服务可以根据需要进行演进，而不受其他微服务的限制。
- en: Assigning their development to completely separate smaller teams, thus simplifying
    job organization and reducing all the inevitable coordination inefficiencies that
    arise when handling large teams.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将开发任务分配给完全独立的小团队，从而简化工作组织并减少处理大型团队时不可避免的协调低效问题。
- en: Implementing each microservice with more adequate technologies and in a more
    adequate environment, since each microservice is an independent deployment unit.
    This means choosing tools that best fit your requirements and an environment that
    minimizes development efforts and/or maximizes performance.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更合适的技术和更合适的环境来实现每个微服务，因为每个微服务都是一个独立的部署单元。这意味着选择最适合您需求的工具和最大程度减少开发工作和/或最大程度提高性能的环境。
- en: Since each microservice can be implemented with different technologies, programming
    languages, tools, and operating systems, enterprises can use all available human
    resources by matching environments with developers' competencies. For instance,
    underused Java developers can also be involved in .NET projects if they implement
    microservices in Java with the same required behavior.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每个微服务可以使用不同的技术、编程语言、工具和操作系统来实现，企业可以通过将环境与开发人员的能力匹配来利用所有可用的人力资源。例如，如果使用Java实现微服务并具有相同的所需行为，那么未充分利用的Java开发人员也可以参与.NET项目。
- en: Legacy subsystems can be embedded in independent microservices, thus enabling
    them to cooperate with newer subsystems. This way, companies may reduce the time
    to market of new system versions. Moreover, this way, legacy systems can evolve
    slowly toward more modern systems with an acceptable impact on costs and the organization.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遗留子系统可以嵌入独立的微服务中，从而使它们能够与新的子系统合作。这样，公司可以减少新系统版本的上市时间。此外，这样，遗留系统可以逐渐向更现代的系统演进，对成本和组织的影响可接受。
- en: The next subsection explains how the concept of microservices was conceived.
    Then, we will continue this introductory section by exploring basic microservice
    design principles and analyzing why microservices are often designed as Docker
    containers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节解释了微服务的概念是如何构思的。然后，我们将继续通过探索基本的微服务设计原则并分析为什么微服务通常被设计为Docker容器来继续介绍本章节。
- en: Microservices and the evolution of the concept of modules
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务和模块概念的演变
- en: 'For a better understanding of the advantages of microservices, as well as their
    design techniques, we must keep the two-folded nature of software modularity,
    and of software modules, in mind:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解微服务的优势以及它们的设计技术，我们必须牢记软件模块化和软件模块的双重性质：
- en: Code modularity refers to code organization that makes it easy for us to modify
    a chunk of code without affecting the remainder of the application. It is usually
    enforced with object-oriented design, where modules can be identified with classes.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码模块化是指使我们能够修改一块代码而不影响应用程序其余部分的代码组织。通常，它是通过面向对象设计来实现的，其中模块可以用类来标识。
- en: '**Deployment modularity** depends on what your deployment units are and which
    properties they have. The simplest deployment units are executable files and libraries.
    Thus, for instance, **dynamic link libraries** (**DLLs**) are, for sure, more
    modular than static libraries since they must not be linked with the main executable
    before being deployed.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署模块化**取决于部署单元是什么以及它们具有哪些属性。最简单的部署单元是可执行文件和库。因此，例如，动态链接库（DLL）肯定比静态库更模块化，因为它们在部署之前不需要与主要可执行文件链接。'
- en: While the fundamental concepts of code modularity have reached stasis, the concept
    of deployment modularity is still evolving and microservices are currently state
    of the art along this evolution path.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码模块化的基本概念已经达到了稳定状态，但部署模块化的概念仍在不断发展，微服务目前是这一演变路径上的最新技术。
- en: As a short review of the main milestones on the path that led to microservices,
    we can say that, first, monolithic executables were broken into static libraries.
    Later on, DLLs replaced static libraries.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对导致微服务发展的主要里程碑的简要回顾，我们可以说，首先，将单体可执行文件拆分为静态库。随后，动态链接库（DLL）取代了静态库。
- en: A great change took place when .NET (and other analogous frameworks, such as
    Java) improved the modularity of executables and libraries. In fact, with .NET,
    they can be deployed on different hardware and on different operating systems
    since they are deployed in an intermediary language that's compiled when the library
    is executed for the first time. Moreover, they overcome some versioning issues
    of previous DLLs since any executable brings with it a DLL with a version that
    differs from the version of the same DLL that is installed in the operating system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当.NET（以及其他类似的框架，如Java）改进了可执行文件和库的模块化时，发生了巨大的变化。实际上，使用.NET，它们可以部署在不同的硬件和不同的操作系统上，因为它们部署在第一次执行库时编译的中间语言中。此外，它们克服了以前DLL的一些版本问题，因为任何可执行文件都会带有一个与安装在操作系统中的相同DLL版本不同的版本的DLL。
- en: 'However, .NET can''t accept two referenced DLLs – let''s say, *A* and *B* –
    using two different versions of a common dependency – let''s say, *C*. For instance,
    suppose there is a newer version of *A* with a lot of new features we would like
    to use that, in turn, rely on a newer version of *C* that''s not supported by
    *B*. In this situation, we should renounce the newer version of *A* because of
    the incompatibility of *C* with *B*. This difficulty has led to two important
    changes:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，.NET不能接受两个引用的DLL - 假设为*A*和*B* - 使用共同依赖项的两个不同版本 - 假设为*C*。例如，假设有一个新版本的*A*，具有许多我们想要使用的新功能，反过来依赖于*B*不支持的*C*的新版本。在这种情况下，由于*C*与*B*的不兼容性，我们应该放弃*A*的新版本。这个困难导致了两个重要的变化：
- en: The development world moved from DLLs and/or single files to package management
    systems such as NuGet and npm, which automatically check version compatibility
    with the help of semantic versioning.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发世界从DLL和/或单个文件转向了包管理系统，如NuGet和npm，这些系统可以通过语义化版本控制自动检查版本兼容性。
- en: '**Service-Oriented Architecture** (**SOA**). Deployment units started being
    implemented as SOAP and then as REST web services. This solves the version compatibility
    problem since each web service runs in a different process and can use the most
    adequate version of each library with no risk of causing incompatibilities with
    other web services. Moreover, the interface that''s exposed by each web service
    is platform-agnostic, that is, web services can connect with applications using
    any framework and run on any operating system since web service protocols are
    based on universally accepted standards. SOAs and protocols will be discussed
    in more detail in *Chapter 14*, *Applying Service-Oriented Architectures with
    .NET Core*.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向服务的架构**（SOA）。部署单元开始被实现为SOAP，然后是REST Web服务。这解决了版本兼容性问题，因为每个Web服务在不同的进程中运行，并且可以使用最合适的每个库的版本，而不会导致与其他Web服务不兼容的风险。此外，每个Web服务公开的接口是平台无关的，也就是说，Web服务可以与使用任何框架的应用程序连接并在任何操作系统上运行，因为Web服务协议基于普遍接受的标准。SOA和协议将在*第14章*《使用.NET
    Core应用面向服务的架构》中详细讨论。'
- en: Microservices are an evolution of SOA and add more features and more constraints
    that improve the scalability and the modularity of services to improve the overall
    CI/CD cycle. It's sometimes said that *microservices are SOA done well*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是SOA的演变，并增加了更多功能和约束，以改善服务的可伸缩性和模块化，以改善整体的CI/CD周期。有时人们说*微服务是SOA做得好*。
- en: Microservices design principles
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务设计原则
- en: To sums things up, the microservice architecture is an SOA that maximizes independence
    and fine-grained scaling. Now that we've clarified all the advantages of microservice
    independence and fine-grained scaling, as well as the very nature of independence,
    we are in a position to look at microservice design principles.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，微服务架构是最大程度地实现独立性和细粒度扩展的SOA。现在我们已经澄清了微服务独立性和细粒度扩展的所有优势，以及独立性的本质，我们可以看看微服务设计原则。
- en: Let's start with principles that arise from the independence constraint. We
    will discuss them each in a separate subsection.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从独立性约束产生的原则开始。我们将在单独的小节中讨论它们。
- en: The independence of design choices
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计选择的独立性
- en: The design of each microservice must not depend on the design choices that were
    made in the implementation of other microservices. This principle enables the
    full independence of each microservice CI/CD cycle and leaves us with more technological
    choices on how to implement each microservice. This way, we can choose the best
    available technology to implement each microservice.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务的设计不能依赖于在其他微服务实现中所做的设计选择。这个原则使得每个微服务的CI/CD周期完全独立，并让我们在如何实现每个微服务上有更多的技术选择。这样，我们可以选择最好的可用技术来实现每个微服务。
- en: Another consequence of this principle is that different microservices can't
    connect to the same shared storage (database or filesystem) since sharing the
    same storage also means sharing all the design choices that determined the structure
    of the storage subsystem (database table design, database engine, and so on).
    Thus, either a microservice has its own data storage or it has no storage at all
    and communicates with other microservices that take care of handling storage.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则的另一个结果是，不同的微服务不能连接到相同的共享存储（数据库或文件系统），因为共享相同的存储也意味着共享决定存储子系统结构的所有设计选择（数据库表设计，数据库引擎等）。因此，要么一个微服务有自己的数据存储，要么根本没有存储，并与负责处理存储的其他微服务进行通信。
- en: Here, having dedicated data storage doesn't mean that the physical database
    is distributed within the process boundary of the microservice itself, but that
    the microservice has exclusive access to a database or set of database tables
    that are handled by an external database engine. In fact, for performance reasons,
    database engines must run on dedicated hardware and with OS and hardware features
    that are optimized for their storage functionalities.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，拥有专用的数据存储并不意味着物理数据库分布在微服务本身的进程边界内，而是微服务具有对由外部数据库引擎处理的数据库或一组数据库表的独占访问权限。事实上，出于性能原因，数据库引擎必须在专用硬件上运行，并具有针对其存储功能进行优化的操作系统和硬件功能。
- en: Usually, *independence of design choices* is interpreted in a lighter form by
    distinguishing between logical and physical microservices. More specifically,
    a logical microservice is implemented with several physical microservices that
    use the same data storage but that are load-balanced independently. That is, the
    logical microservice is designed as a logical unit and then split into more physical
    microservices to achieve better load balance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，*设计选择的独立性*以更轻的形式解释，通过区分逻辑和物理微服务。更具体地说，逻辑微服务是由使用相同数据存储但独立负载平衡的多个物理微服务实现的。也就是说，逻辑微服务被设计为一个逻辑单元，然后分割成更多的物理微服务以实现更好的负载平衡。
- en: Independence from the deployment environment
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 独立于部署环境
- en: Microservices are scaled out on different hardware nodes and different microservices
    can be hosted on the same node. Therefore, the less a microservice relies on the
    services offered by the operating system and on other installed software, the
    more available hardware nodes it can be deployed on. More node optimization can
    also be performed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务在不同的硬件节点上进行扩展，并且不同的微服务可以托管在同一节点上。因此，微服务越少依赖操作系统提供的服务和其他安装的软件，它就可以部署在更多的硬件节点上。还可以进行更多的节点优化。
- en: This is the reason why microservices are usually containerized and use Docker.
    Containers will be discussed in more detail in the *Containers and Docker* subsection
    of this chapter, but basically, containerization is a technique that allows each
    microservice to bring its dependencies with it so that it can run anywhere.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么微服务通常是容器化并使用Docker的原因。容器将在本章的*容器和Docker*小节中更详细地讨论，但基本上，容器化是一种技术，允许每个微服务携带其依赖项，以便它可以在任何地方运行。
- en: Loose coupling
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 松散耦合
- en: Each microservice must be loosely coupled with all the other microservices.
    This principle has a two-fold nature. On the one hand, this means that, according
    to object-oriented programming principles, the interface that's exposed by each
    microservice must not be too specific, but as general as possible. However, it
    also means that communications among microservices must be minimized in order
    to reduce communication costs since microservices don't share the same address
    space and run on different hardware nodes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务必须与所有其他微服务松散耦合。这个原则具有双重性质。一方面，这意味着，根据面向对象编程原则，每个微服务公开的接口不能太具体，而应尽可能通用。然而，这也意味着微服务之间的通信必须最小化，以减少通信成本，因为微服务不共享相同的地址空间，运行在不同的硬件节点上。
- en: No chained requests/responses
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要有链接的请求/响应
- en: When a request reaches a microservice, it must not cause a recursive chain of
    nested requests/responses to other microservices since a similar chain would result
    in an unacceptable response time. Chained requests/responses can be avoided if
    the private data models of all the microservices synchronize with push notifications
    each time they change. In other words, as soon as the data that's handled by a
    microservice changes, those changes are sent to all the microservices that may
    need them to serve their requests. This way, each microservice has all the data
    it needs to serve all its incoming requests in its private data storage, with
    no need to ask other microservices for the data that it lacks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求到达微服务时，它不能引起对其他微服务的递归链式请求/响应，因为类似的链式请求/响应会导致无法接受的响应时间。如果所有微服务的私有数据模型在每次更改时都与推送通知同步，就可以避免链式请求/响应。换句话说，一旦由微服务处理的数据发生变化，这些变化就会发送到可能需要这些数据来处理其请求的所有微服务。这样，每个微服务都在其私有数据存储中拥有处理所有传入请求所需的所有数据，无需向其他微服务请求缺少的数据。
- en: In conclusion, every microservice must contain all the data it needs to serve
    incoming requests and ensure fast responses. To keep their data models up to date
    and ready for incoming requests, microservices must communicate their data changes
    as soon as they take place. These data changes should be communicated through
    asynchronous messages since synchronous nested messages cause unacceptable performance
    because they block all the threads involved in the call tree until a result is
    returned.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，每个微服务必须包含其所需的所有数据，以提供传入请求并确保快速响应。为了使其数据模型保持最新并准备好处理传入请求，微服务必须在数据发生变化时立即通知其它微服务。这些数据变化应通过异步消息进行通信，因为同步嵌套消息会导致不可接受的性能问题，因为它们会阻塞所有涉及调用树的线程，直到返回结果。
- en: It is worth pointing out that the *Independence of design choices* principle
    is substantially the bounded context principle of domain-driven design, which
    we will talk about in detail in *Chapter 12*, *Understanding the Different Domains
    in Software Solutions*. In this chapter, we will see that, often, a full domain-driven
    design approach is useful for the *update* subsystem of each microservice.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，“设计选择的独立性”原则实际上是领域驱动设计中的有界上下文原则，我们将在《第12章：理解软件解决方案中的不同领域》中详细讨论。在本章中，我们将看到，通常情况下，完整的领域驱动设计方法对于每个微服务的“更新”子系统非常有用。
- en: It's not trivial that, in general, all systems that have been developed according
    to the bounded context principle are better implemented with a microservice architecture.
    In fact, once a system has been decomposed into several completely independent
    and loosely coupled parts, it is very likely that these different parts will need
    to be scaled independently because of different traffic and different resource
    requirements.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，按照有界上下文原则开发的所有系统通常都更适合使用微服务架构来实现。实际上，一旦将系统分解为几个完全独立且松耦合的部分，由于不同的流量和不同的资源需求，这些不同的部分很可能需要独立扩展。
- en: At the preceding constraints, we must also add some best practices for building
    a reusable SOA. More details on these best practices will be given in *Chapter
    14*, *Applying Service-Oriented Architectures with .NET Core*, but nowadays, most
    SOA best practices are automatically enforced by tools and frameworks that are
    used to implement web services.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述约束，我们还必须添加一些构建可重用SOA的最佳实践。关于这些最佳实践的更多细节将在《第14章：使用.NET Core应用面向服务的架构》中给出，但是现在，大多数SOA最佳实践都是由用于实现Web服务的工具和框架自动强制执行的。
- en: Fine-grained scaling requires that microservices are small enough to isolate
    well-defined functionalities, but this also requires a complex infrastructure
    that takes care of automatically instantiating microservices, allocating instances
    on various hardware computational resources, commonly called **nodes**, and scaling
    them as needed. These kinds of structures will be introduced in the *Which tools
    are needed to manage microservices?* section of this chapter, and discussed in
    detail in *Chapter 6*, *Azure Service Fabric*, and *Chapter 7*, *Azure Kubernetes*
    *Service*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 细粒度的扩展要求微服务足够小，以便隔离明确定义的功能，但这也需要一个复杂的基础架构来自动实例化微服务，将实例分配到各种硬件计算资源上，通常称为“节点”，并根据需要进行扩展。这些结构将在本章的“需要哪些工具来管理微服务？”部分中介绍，并在《第6章：Azure
    Service Fabric》和《第7章：Azure Kubernetes Service》中详细讨论。
- en: Moreover, fine-grained scaling of distributed microservices that communicate
    through asynchronous communication requires each microservice to be resilient.
    In fact, communication that's directed to a specific microservice instance may
    fail due to a hardware fault or for the simple reason that the target instance
    was killed or moved to another node during a load balancing operation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过异步通信进行通信的细粒度扩展的分布式微服务要求每个微服务具有弹性。实际上，由于硬件故障或在负载平衡操作期间目标实例被终止或移动到另一个节点的简单原因，针对特定微服务实例的通信可能会失败。
- en: Temporary failures can be overcome with exponential retries. This is where we
    retry the same operation after each failure with a delay that increases exponentially
    until a maximum number of attempts is reached. For instance, first, we would retry
    after 10 milliseconds, and if this retry operation results in a failure, a new
    attempt is made after 20 milliseconds, then after 40 milliseconds, and so on.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 临时故障可以通过指数级重试来克服。这意味着在每次失败后，我们会延迟指数级地重试相同的操作，直到达到最大尝试次数。例如，首先，我们会在10毫秒后重试，如果这次重试操作失败，那么在20毫秒后进行新的尝试，然后是40毫秒，依此类推。
- en: 'On the other hand, long-term failures often cause an explosion of retry operations
    that may saturate all system resources in a way that is similar to a denial-of-service
    attack. Therefore, usually, exponential retries are used together with a *circuit
    break strategy*: after a given number of failures, a long-term failure is assumed
    and access to the resource is prevented for a given time by returning an immediate
    failure without attempting the communication operation.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，长期故障通常会导致重试操作的激增，可能会使所有系统资源饱和，类似于拒绝服务攻击。因此，通常会将指数级重试与“断路器策略”一起使用：在一定数量的失败之后，假定存在长期故障，并且通过返回立即失败而不尝试通信操作来阻止对资源的访问一段时间。
- en: 'It is also fundamental that the congestion of some subsystems, due to either
    failure or to a requests peak, does not propagate to other system parts, in order
    to prevent overall system congestion. **Bulkhead isolation** avoids congestion
    propagation in the following ways:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是，某些子系统的拥塞，无论是由于故障还是请求高峰，都不会传播到其他系统部分，以防止整体系统拥塞。**隔离舱壁**通过以下方式避免拥塞传播：
- en: Only a maximum number of similar simultaneous outbound requests are allowed;
    let's say, 10\. This is similar to putting an upper bound on thread creation.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只允许一定数量的类似的同时出站请求；比如说，10。这类似于对线程创建设置上限。
- en: Requests exceeding the previous bound are queued.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超过先前限制的请求将被排队。
- en: If the maximum queue length is reached, any further requests result in exceptions
    being thrown to abort them.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果达到最大队列长度，任何进一步的请求都会导致抛出异常以中止它们。
- en: Retry policies may make it so that the same message is received and processed
    several times because the sender has received no confirmation that the message
    has been received or simply because it has timed-out the operation, while the
    receiver actually received the message. The only possible solution to this problem
    is designing all messages so that they're idempotent, that is, designing messages
    in such a way that processing the same message several times has the same effect
    as processing it once.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 重试策略可能导致同一消息被接收和处理多次，因为发送方未收到消息已被接收的确认，或者因为操作超时，而接收方实际上已接收了消息。这个问题的唯一可能解决方案是设计所有消息都是幂等的，也就是说，设计消息的处理多次与处理一次具有相同的效果。
- en: 'Updating a database table field to a value, for instance, is an idempotent
    operation since repeating it once or twice has exactly the same effect. However,
    incrementing a decimal field is not an idempotent operation. Microservice designers
    should make an effort to design the overall application with as many idempotent
    messages as possible. The remaining non-idempotent messages must be transformed
    into idempotent ones in the following way, or with some other similar techniques:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将数据库表字段更新为一个值是幂等操作，因为重复一次或两次会产生完全相同的效果。然而，递增十进制字段不是幂等操作。微服务设计者应该努力设计整个应用程序，尽可能多地使用幂等消息。剩下的非幂等消息必须以以下方式或其他类似技术转换为幂等消息：
- en: Attach both a time and some identifier that uniquely identify each message.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附上时间和一些唯一标识符，以唯一标识每条消息。
- en: Store all the messages that have been received in a dictionary that's been indexed
    by the unique identifier attached to the message mentioned in the previous point.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有已接收的消息存储在一个字典中，该字典已由附加到前一点提到的消息的唯一标识符进行索引。
- en: Reject old messages.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝旧消息。
- en: When a message that may be a duplicate is received, verify whether it's contained
    in the dictionary. If it is, then it has already been processed, so reject it.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当接收到可能是重复的消息时，请验证它是否包含在字典中。如果是，则已经被处理，因此拒绝它。
- en: Since old messages are rejected, they can be periodically removed from the dictionary
    to avoid it growing exponentially.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于旧消息被拒绝，它们可以定期从字典中删除，以避免指数级增长。
- en: We will use this technique in the example at the end of *Chapter 6*, *Azure
    Service Fabric*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第6章*的示例中使用这种技术，*Azure Service Fabric*。
- en: It is worth pointing out that some message brokers, such as Azure Service Bus,
    offer facilities for implementing the technique described previously. Azure Service
    Bus is discussed in the *.NET communication facilities* subsection.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，一些消息代理（如Azure Service Bus）提供了实施先前描述的技术的设施。Azure Service Bus在“.NET通信设施”子部分中进行了讨论。
- en: In the next subsection, we will talk about microservice containerization based
    on Docker.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将讨论基于Docker的微服务容器化。
- en: Containers and Docker
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器和Docker
- en: 'We''ve already discussed the advantages of having microservices that don''t
    depend on the environment where they run: better hardware usage, the ability to
    mix legacy software with newer modules, the ability to mix several development
    stacks in order to use the best stack for each module implementation, and so on.
    Independence from the hosting environment can be easily achieved by deploying
    each microservice with all its dependencies on a private virtual machine.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了具有不依赖于运行环境的微服务的优势：更好的硬件使用、能够将旧软件与新模块混合使用、能够混合使用多个开发堆栈以使用最佳堆栈来实现每个模块等。通过在私有虚拟机上部署每个微服务及其所有依赖项，可以轻松实现与托管环境的独立性。
- en: However, starting a virtual machine with its private copy of the operating system
    takes a lot of time, and microservices must be started and stopped quickly to
    reduce load balancing and fault recovery costs. In fact, new microservices may
    be started either to replace faulty ones or because they were moved from one hardware
    node to another to perform load balancing. Moreover, adding a whole copy of the
    operating system to each microservice instance would be an excessive overhead.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，启动具有其操作系统私有副本的虚拟机需要很长时间，而微服务必须快速启动和停止，以减少负载平衡和故障恢复成本。事实上，新的微服务可能会启动以替换故障的微服务，或者因为它们从一个硬件节点移动到另一个硬件节点以执行负载平衡。此外，为每个微服务实例添加整个操作系统副本将是一个过度的开销。
- en: 'Luckily, microservices can rely on a lighter form of technology: containers.
    Containers are a kind of light virtual machine. They do not virtualize a full
    machine – they just virtualize the OS filesystem level that sits on top of the
    OS kernel. They use the OS of the hosting machine (kernel, DLLs, and drivers)
    and rely on the OS''s native features to isolate processes and resources to ensure
    an isolated environment for the images they run.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，微服务可以依赖一种更轻量级的技术：容器。容器是一种轻量级虚拟机。它们不会虚拟化整个机器-它们只是虚拟化位于操作系统内核之上的操作系统文件系统级别。它们使用托管机器的操作系统（内核、DLL和驱动程序），并依赖于操作系统的本机功能来隔离进程和资源，以确保运行的图像的隔离环境。
- en: As a consequence, containers are tied to a specific operating system, but they
    don't suffer the overhead of copying and starting a whole OS in each container
    instance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，容器与特定的操作系统绑定，但它们不会遭受在每个容器实例中复制和启动整个操作系统的开销。
- en: On each host machine, containers are handled by a runtime that takes care of
    creating them from *images* and creating an isolated environment for each of them.
    The most famous container runtime is Docker, which is a *de facto* standard for
    containerization.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在每台主机机器上，容器由运行时处理，该运行时负责从*图像*创建容器，并为每个容器创建一个隔离的环境。最著名的容器运行时是Docker，它是容器化的*事实上的*标准。
- en: Images are files that specify what is put in each container and which container
    resources, such as communication ports, to expose outside the container. Images
    need not to explicitly specify their full content, but they can be layered. This
    way, images are built by adding new software and configuration information on
    top of existing images.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图像是指定放入每个容器的内容以及要在容器外部公开的容器资源（如通信端口）的文件。图像不需要显式指定其完整内容，但可以分层。这样，通过在现有图像之上添加新的软件和配置信息来构建图像。
- en: For instance, if you want to deploy a .NET application as a Docker image, it
    is enough to just add your software and files to your Docker image and then reference
    an already existing .NET Docker image.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想将.NET应用程序部署为Docker镜像，只需将软件和文件添加到Docker镜像中，然后引用已经存在的.NET Docker镜像即可。
- en: 'To allow for easy image referencing, images are grouped into registries that
    may be either public or private. They are similar to NuGet or npm registries.
    Docker offers a public registry ([https://hub.docker.com/_/registry](https://hub.docker.com/_/registry))
    where you can find most of the public images you may need to reference in your
    own images. However, each company can define private registries. For instance,
    Azure offers Microsoft Container Registry, where you can define your private container
    registry service: [https://azure.microsoft.com/en-us/services/container-registry/](https://azure.microsoft.com/en-us/services/container-registry/).
    There, you can also find most of the .NET related images you might need to reference
    in your code.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便图像引用，图像被分组到可能是公共或私有的注册表中。它们类似于NuGet或npm注册表。Docker提供了一个公共注册表（[https://hub.docker.com/_/registry](https://hub.docker.com/_/registry)），您可以在其中找到大多数您可能需要在自己的图像中引用的公共图像。然而，每个公司都可以定义私有注册表。例如，Azure提供了Microsoft容器注册表，您可以在其中定义您的私有容器注册表服务：[https://azure.microsoft.com/en-us/services/container-registry/](https://azure.microsoft.com/en-us/services/container-registry/)。在那里，您还可以找到大多数与.NET相关的图像，您可能需要在您的代码中引用它们。
- en: Before instantiating each container, the Docker runtime must solve all the recursive
    references. This cumbersome job is not performed each time a new container is
    created since the Docker runtime has a cache where it stores the fully assembled
    images that correspond to each input image and that it's already processed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化每个容器之前，Docker运行时必须解决所有递归引用。这个繁琐的工作不是每次创建新容器时都执行的，因为Docker运行时有一个缓存，它存储与每个输入图像对应的完全组装的图像。
- en: 'Since each application is usually composed of several modules to be run in
    different containers, Docker also allows `.yml` files, also known as composition
    files, that specify the following information:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个应用程序通常由几个模块组成，这些模块在不同的容器中运行，Docker还允许使用称为`.yml`文件的组合文件，指定以下信息：
- en: Which images to deploy.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署哪些图像。
- en: How the internal resources that are exposed by each image must be mapped to
    the physical resources of the host machine. For instance, how communication ports
    that are exposed by Docker images must be mapped to the ports of the physical
    machine.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将每个图像公开的内部资源映射到主机机器的物理资源。例如，如何将Docker图像公开的通信端口映射到物理机器的端口。
- en: We will analyze Docker images and `.yml` files in the *How does .NET deal with
    microservices?* section of this chapter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的* .NET如何处理微服务？*部分中分析Docker图像和`.yml`文件。
- en: The Docker runtime handles images and containers on a single machine but, usually,
    containerized microservices are deployed and load-balanced on clusters that are
    composed of several machines. Clusters are handled by pieces of software called
    **orchestrators**. Orchestrators will be introduced in the *Which tools are needed
    to manage microservices?* section of this chapter, and described in detail in
    *Chapter 6*, *Azure Service Fabric*, and *Chapter 7*, *Azure Kubernetes Service*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Docker运行时处理单个机器上的图像和容器，但通常，容器化的微服务是部署和负载均衡在由多台机器组成的集群上的。集群由称为**编排器**的软件组成。编排器将在本章的*需要哪些工具来管理微服务？*部分中介绍，并在*第6章*，*Azure服务织物*和*第7章*，*Azure
    Kubernetes服务*中详细描述。
- en: Now that we have understood what microservices are, what problems they can solve,
    and their basic design principles, we are ready to analyze when and how to use
    them in our system architecture. The next section analyzes when we should use
    them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了微服务是什么，它们可以解决什么问题以及它们的基本设计原则，我们准备分析何时以及如何在我们的系统架构中使用它们。下一节将分析我们应该何时使用它们。
- en: When do microservices help?
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务何时有帮助？
- en: 'The answer to this question requires us to understand the roles microservices
    play in modern software architectures. We will look at this in the following two
    subsections:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 回答这个问题需要我们理解微服务在现代软件架构中的作用。我们将在以下两个小节中进行讨论：
- en: Layered architectures and microservices
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层架构和微服务
- en: When is it worth considering microservice architectures?
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么时候考虑微服务架构是值得的？
- en: Let's start with a detailed look at layered architectures and microservices.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解分层架构和微服务。
- en: Layered architectures and microservices
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分层架构和微服务
- en: Enterprise systems are usually organized in logical independent layers. The
    first layer is the one that interacts with the user and is called the presentation
    layer, while the last layer takes care of storing/retrieving data and is called
    the data layer. Requests originate in the presentation layer and pass through
    all the layers until they reach the data layer, and then come back, traversing
    all the layers in reverse until they reach the presentation layer, which takes
    care of presenting the results to the user/client. Layers can't be *jumped*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 企业系统通常以逻辑独立的层组织。第一层是与用户交互的层，称为表示层，而最后一层负责存储/检索数据，称为数据层。请求起源于表示层，并通过所有层传递，直到达到数据层，然后返回，反向穿过所有层，直到达到表示层，表示层负责向用户/客户端呈现结果。层不能“跳过”。
- en: Each layer takes data from the previous layer, processes it, and passes it to
    the next layer. Then, it receives the results from its next layer and sends them
    back to its previous layer. Also, thrown exceptions can't jump layers – each layer
    must take care of intercepting all the exceptions and either *solving them* somehow
    or transforming them into other exceptions that are expressed in the language
    of its previous layer. The layer architecture ensures the complete independence
    of the functionalities of each layer from the functionalities of all the other
    layers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个层从前一层获取数据，处理数据，并将其传递给下一层。然后，它从下一层接收结果并将其发送回前一层。此外，抛出的异常不能跨越层 - 每个层必须负责拦截所有异常并解决它们，或将它们转换为以其前一层语言表达的其他异常。层架构确保每个层的功能与所有其他层的功能完全独立。
- en: For instance, we can change the database engine without affecting all the layers
    that are above the data layer. In the same way, we can completely change the user
    interface, that is, the presentation layer, without affecting the remainder of
    the system.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以更改数据库引擎而不影响数据层以上的所有层。同样，我们可以完全更改用户界面，即表示层，而不影响系统的其余部分。
- en: Moreover, each layer implements a different kind of system specification. The
    data layer takes care of what the system *must remember*, the presentation layer
    takes care of the system-user interaction protocol, and all the layers that are
    in the middle implement the domain rules, which specify how data must be processed
    (for instance, how an employee paycheck must be computed). Typically, the data
    and presentation layers are separated by just one domain rule layer, called the
    business or application layer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个层实现了不同类型的系统规范。数据层负责系统“必须记住”的内容，表示层负责系统用户交互协议，而中间的所有层实现了领域规则，指定数据如何处理（例如，如何计算员工工资）。通常，数据层和表示层之间只有一个领域规则层，称为业务或应用层。
- en: 'Each layer *speaks* a different language: the data layer *speaks* the language
    of the chosen storage engine, the business layer speaks the language of domain
    experts, and the presentation layer speaks the language of users. So, when data
    and exceptions pass from one layer to another, they must be translated into the
    language of the destination layer.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个层都“说”不同的语言：数据层“说”所选择的存储引擎的语言，业务层“说”领域专家的语言，表示层“说”用户的语言。因此，当数据和异常从一层传递到另一层时，它们必须被转换为目标层的语言。
- en: A detailed example of how to build a layered architecture will be given in the
    *Use case – understanding the domains of the use case* section in *Chapter 12*,
    *Understanding the Different Domains in Software Solutions*, which is dedicated
    to domain-driven design.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何构建分层架构的详细示例将在《第12章》《理解软件解决方案中的不同领域》的《用例 - 理解用例的领域》部分中给出，该部分专门讨论领域驱动设计。
- en: That being said, how do microservices fit into a layered architecture? Are they
    adequate for the functionalities of all the layers or just some layers? Can a
    single microservice span several layers?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，微服务如何适应分层架构？它们是否适用于所有层的功能还是只适用于某些层？单个微服务是否可以跨越多个层？
- en: 'The last question is the easiest to answer: yes! In fact, we''ve already stated
    that microservices should store the data they need within their logical boundaries.
    Therefore, there are microservices that span the business and data layers. Some
    others take care of encapsulating shared data and remain confined in the data
    layer. Thus, we may have business layer microservices, data layer microservices,
    and microservices that span both layers. So, what about the presentation layer?'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题最容易回答：是的！实际上，我们已经说过微服务应该在其逻辑边界内存储所需的数据。因此，有些微服务跨越业务和数据层。其他一些微服务负责封装共享数据并保持在数据层中。因此，我们可能有业务层微服务、数据层微服务以及跨越两个层的微服务。那么，表示层呢？
- en: The presentation layer
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表示层
- en: The presentation layer can also fit into a microservice architecture if it is
    implemented on the server side. Single-page applications and mobile applications
    run the presentation layer on the client machine, so they either connect directly
    to the business microservices layer or, more often, to an *API gateway* that exposes
    the public interface and takes care of routing requests to the right microservices.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在服务器端实现，表示层也可以适应微服务架构。单页应用程序和移动应用程序在客户端机器上运行表示层，因此它们要么直接连接到业务微服务层，要么更常见地连接到公共接口并负责将请求路由到正确的微服务的API网关。
- en: In a microservices architecture, when the presentation layer is a website, it
    can be implemented with a set of microservices. However, if it requires heavy
    web servers and/or heavy frameworks, containerizing them may not be convenient.
    This decision must also consider the loss of performance that happens when containerizing
    the web server and the possible need for hardware firewalls between the web server
    and the remainder of the system.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，如果表示层是一个网站，可以使用一组微服务来实现。然而，如果它需要重型的Web服务器和/或重型的框架，将它们容器化可能不方便。这个决定还必须考虑到容器化Web服务器和系统其余部分之间可能需要硬件防火墙的性能损失。
- en: ASP.NET is a lightweight framework that runs on the light Kestrel web server,
    so it can be containerized efficiently and used in a microservice for intranet
    applications. However, public high-traffic websites require dedicated hardware/software
    components that prevent them from being deployed together with other microservices.
    In fact, while Kestrel is an acceptable solution for an intranet website, public
    websites need a more complete web server such as IIS, Apache, or NGINX. In this
    case, security and load balancing requirements are more compelling and require
    dedicated hardware/software nodes and components. Accordingly, architectures based
    on microservices usually offer specialized components that take care of interfacing
    with the outside world. For instance, in *Chapter 7*, *Azure Kubernetes Service*,
    we will see that in **Kubernetes** clusters, this role is played by the so-called
    **ingresses**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET是一个轻量级的框架，运行在轻量级的Kestrel Web服务器上，因此可以高效地容器化，并用于内部网络应用的微服务。然而，公共高流量的网站需要专用的硬件/软件组件，阻止它们与其他微服务一起部署。实际上，虽然Kestrel对于内部网络网站是一个可接受的解决方案，但公共网站需要更完整的Web服务器，如IIS、Apache或NGINX。在这种情况下，安全性和负载均衡要求更加紧迫，需要专用的硬件/软件节点和组件。因此，基于微服务的架构通常提供专门的组件来处理与外部世界的接口。例如，在第7章《Azure
    Kubernetes服务》中，我们将看到在Kubernetes集群中，这个角色由所谓的“入口”扮演。
- en: Monolithic websites can be easily broken into load-balanced smaller subsites
    without microservice-specific technologies, but a microservice architecture can
    bring all the advantages of microservices into the construction of a single HTML
    page. More specifically, different microservices may take care of different areas
    of each HTML page. Unfortunately, at the time of writing, a similar scenario is
    not easy to implement with the available .NET technology.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 单体网站可以轻松地分解为负载均衡的较小子网站，而无需使用微服务特定的技术，但是微服务架构可以将所有微服务的优势带入单个HTML页面的构建中。更具体地说，不同的微服务可以负责每个HTML页面的不同区域。不幸的是，在撰写本文时，使用现有的.NET技术很难实现类似的场景。
- en: 'A proof of concept that implements a website with ASP.NET-based microservices
    that cooperate in the construction of each HTML page can be found here: [https://github.com/Particular/Workshop/tree/master/demos/asp-net-core](https://github.com/Particular/Workshop/tree/master/demos/asp-net-core).
    The main limit of this approach is that microservices cooperate just to generate
    the data that''s needed to generate the HTML page and not to generate the actual
    HTML page. Instead, this is handled by a monolithic gateway. In fact, at the time
    of writing, frameworks such as ASP.NET MVC don''t provide any facilities for the
    distribution of HTML generation. We will return to this example in *Chapter 15*,
    *Presenting ASP.NET Core MVC*.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在这里找到一个使用基于ASP.NET的微服务实现每个HTML页面构建的网站的概念验证：[https://github.com/Particular/Workshop/tree/master/demos/asp-net-core](https://github.com/Particular/Workshop/tree/master/demos/asp-net-core)。这种方法的主要限制是微服务仅合作生成生成HTML页面所需的数据，而不是生成实际的HTML页面。相反，这由一个单体网关处理。实际上，在撰写本文时，诸如ASP.NET
    MVC之类的框架并不提供任何用于分发HTML生成的功能。我们将在第15章《展示ASP.NET Core MVC》中回到这个例子。
- en: Now that we've clarified which parts of a system can benefit from the adoption
    of microservices, we are ready to state the rules when it comes to deciding how
    they're adopted.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经澄清了系统的哪些部分可以从采用微服务中受益，我们准备好陈述在决定如何采用微服务时的规则了。
- en: When is it worth considering microservice architectures?
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么时候值得考虑微服务架构？
- en: 'Microservices can improve the implementation of both the business and data
    layer, but their adoption has some costs:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以改进业务层和数据层的实现，但是它们的采用也有一些成本：
- en: Allocating instances to nodes and scaling them has a cost in terms of cloud
    fees or internal infrastructures and licenses.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为节点分配实例并对其进行扩展会产生云费用或内部基础设施和许可证的成本。
- en: Splitting a unique process into smaller communicating processes increases communication
    costs and hardware needs, especially if the microservices are containerized.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个独特的进程分解为更小的通信进程会增加通信成本和硬件需求，特别是如果微服务被容器化。
- en: Designing and testing software for a microservice requires more time and increases
    engineering costs, both in time and complexity. In particular, making microservices
    resilient and ensuring that they adequately handle all possible failures, as well
    as verifying these features with integration tests, can increase the development
    time by more than one order of magnitude.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为微服务设计和测试软件需要更多的时间，并增加了工程成本，无论是时间还是复杂性。特别是，使微服务具有弹性并确保它们充分处理所有可能的故障，以及使用集成测试验证这些功能，可能会将开发时间增加一个数量级以上。
- en: So, when are microservices worth the cost of using them? Are there functionalities
    that must be implemented as microservices?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么时候微服务的成本值得使用？有哪些功能必须实现为微服务？
- en: 'A rough answer to the second question is: yes, when the application is big
    enough in terms of traffic and/or software complexity. In fact, as an application
    grows in complexity and its traffic increases, it''s recommended that we pay the
    costs connected to scaling it since this allows for more scaling optimization
    and better handling when it comes to the development team. The costs we pay for
    these would soon exceed the cost of microservice adoption.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个问题的粗略答案是：是的，当应用程序在流量和/或软件复杂性方面足够大时。实际上，随着应用程序的复杂性增加和流量增加，我们建议支付与其扩展相关的成本，因为这样可以进行更多的扩展优化，并在开发团队方面更好地处理。我们为此支付的成本很快就会超过采用微服务的成本。
- en: Thus, if fine-grained scaling makes sense for our application, and if we are
    able to estimate the savings that fine-grained scaling and development give us,
    we can easily compute an overall application throughput limit that makes the adoption
    of microservices convenient.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果细粒度的扩展对我们的应用程序有意义，并且我们能够估计细粒度扩展和开发带来的节省，我们可以轻松计算出一个整体应用程序吞吐量限制，从而使采用微服务变得方便。
- en: Microservice costs can also be justified by the increase in the market value
    of our products/services. Since the microservice architecture allows us to implement
    each microservice with a technology that has been optimized for its use, the quality
    that's added to our software may justify all or part of the microservice costs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的成本也可以通过增加我们产品/服务的市场价值来证明。由于微服务架构允许我们使用针对其使用进行优化的技术来实现每个微服务，因此增加到我们的软件中的质量可能会证明所有或部分微服务的成本。
- en: However, scaling and technology optimizations are not the only parameters to
    consider. Sometimes, we are forced to adopt a microservice architecture without
    being able to perform a detailed cost analysis.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，扩展和技术优化并不是唯一需要考虑的参数。有时候，我们被迫采用微服务架构，无法进行详细的成本分析。
- en: If the size of the team that takes care of the CI/CD of the overall system grows
    too much, the organization and coordination of this big team cause difficulties
    and inefficiencies. In this type of situation, it is desirable to move to an architecture
    that breaks the whole CI/CD cycle into independent parts that can be taken care
    of by smaller teams.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果负责整个系统的CI/CD的团队规模增长过大，这个大团队的组织和协调会导致困难和低效。在这种情况下，最好将整个CI/CD周期分解为可以由较小团队负责的独立部分的架构。
- en: Moreover, since these development costs are only justified by a high volume
    of requests, we probably have high traffic being processed by independent modules
    that have been developed by different teams. Therefore, scaling optimizations
    and the need to reduce interaction between development teams make the adoption
    of a microservice architecture very convenient.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于这些开发成本只能通过大量请求来证明，我们可能有高流量由不同团队开发的独立模块正在处理。因此，扩展优化和减少开发团队之间的交互的需求使得采用微服务架构非常方便。
- en: From this, we may conclude that, if the system and the development team grows
    too much, it is necessary to split the development team into smaller teams, each
    working on an efficient bounded context subsystem. It is very likely that, in
    a similar situation, a microservices architecture is the only possible option.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个可以得出结论，如果系统和开发团队增长过快，就需要将开发团队分成较小的团队，每个团队负责一个高效的有界上下文子系统。在类似的情况下，微服务架构很可能是唯一可行的选择。
- en: Another situation that forces the adoption of a microservice architecture is
    the integration of newer subparts with legacy subsystems based on different technologies
    since containerized microservices are the only way to implement an efficient interaction
    between the legacy system and the new subparts in order to gradually replace the
    legacy subparts with newer ones. Similarly, if our team is composed of developers
    with experience in different development stacks, an architecture based on containerized
    microservices may become a *must*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种迫使采用微服务架构的情况是将新的子部分与基于不同技术的遗留子系统集成，因为容器化的微服务是实现遗留系统与新的子部分之间高效交互的唯一方式，以逐步用新的子部分替换遗留子部分。同样，如果我们的团队由具有不同开发堆栈经验的开发人员组成，基于容器化的微服务架构可能成为必需。
- en: In the next section, we will analyze building blocks and tools that are available
    so that we can implement .NET-based microservices.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将分析可用的构建块和工具，以便我们可以实现基于.NET的微服务。
- en: How does .NET deal with microservices?
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET如何处理微服务？
- en: .NET was conceived as a multi-platform framework that was light and fast enough
    to implement efficient microservices. In particular, ASP.NET is the ideal tool
    for implementing text-REST and binary gRPC APIs to communicate with a microservice,
    since it can run efficiently with light web servers such as Kestrel and is itself
    light and modular.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: .NET被设计为一个多平台框架，足够轻量级和快速，以实现高效的微服务。特别是，ASP.NET是实现文本REST和二进制gRPC API与微服务通信的理想工具，因为它可以在轻量级Web服务器（如Kestrel）上高效运行，并且本身也是轻量级和模块化的。
- en: The whole .NET framework evolved with microservices as a strategic deployment
    platform in mind and has facilities and packages for building efficient and light
    HTTP and gRPC communication to ensure service resiliency and to handle long-running
    tasks. The following subsections describe some of the different tools or solutions
    that we can use to implement a .NET-based microservice architecture.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 整个.NET框架在设计时就考虑了微服务作为战略部署平台，并提供了用于构建高效轻量级HTTP和gRPC通信的工具和包，以确保服务的弹性和处理长时间运行的任务。下面的小节描述了一些可以用来实现基于.NET的微服务架构的不同工具或解决方案。
- en: .NET communication facilities
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET通信设施
- en: Microservices need two kinds of communication channels.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务需要两种类型的通信渠道。
- en: The first is a communication channel to receive external requests, either directly
    or through an API gateway. HTTP is the usual protocol for external communication
    due to available web service standards and tools. .NET's main HTTP/gRPC communication
    facility is ASP.NET since it's a lightweight HTTP/gRPC framework, which makes
    it ideal for implementing Web APIs in small microservices. We will describe ASP.NET
    apps in detail in *Chapter 14*, *Applying Service-Oriented Architectures with
    .NET Core*, which is dedicated to HTTP and gRPC services. .NET also offers an
    efficient and modular HTTP client solution that is able to pool and reuse heavy
    connection objects. Also, the `HttpClient` class will be described in more detail
    in *Chapter 14*, *Applying Service-Oriented Architectures with .NET Core*.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种是用于接收外部请求的通信渠道，可以直接接收或通过API网关接收。由于可用的Web服务标准和工具，HTTP是外部通信的常用协议。.NET的主要HTTP/gRPC通信工具是ASP.NET，因为它是一个轻量级的HTTP/gRPC框架，非常适合在小型微服务中实现Web
    API。我们将在*第14章*的*使用.NET Core应用服务导向架构*中详细介绍ASP.NET应用程序，该章节专门介绍HTTP和gRPC服务。.NET还提供了一种高效且模块化的HTTP客户端解决方案，能够池化和重用重型连接对象。此外，`HttpClient`类将在*第14章*的*使用.NET
    Core应用服务导向架构*中详细介绍。
- en: The second is a different type of communication channel to push updates to other
    microservices. In fact, we have already mentioned that intra-microservice communication
    cannot be triggered by an on-going request since a complex tree of blocking calls
    to other microservices would increase request latency to an unacceptable level.
    As a consequence, updates must not be requested immediately before they're used
    and should be pushed whenever state changes take place. Ideally, this kind of
    communication should be asynchronous to achieve acceptable performance. In fact,
    synchronous calls would block the sender while they are waiting for the result,
    thus increasing the idle time of each microservice. However, synchronous communication
    that just puts the request in a processing queue and then returns confirmation
    of the successful communication instead of the final result is acceptable if communication
    is fast enough (low communication latency and high bandwidth). A publisher/subscriber
    communication would be preferable since, in this case, the sender and receiver
    don't need to know each other, thus increasing the microservices' independence.
    In fact, all the receivers that are interested in a certain type of communication
    merely need to register to receive a specific *event*, while senders just need
    to publish those events. All the wiring is performed by a service that takes care
    of queuing events and dispatching them to all the subscribers. The publisher/subscriber
    pattern will be described in more detail in *Chapter 11*, *Design Patterns and
    .NET 5 Implementation*, along with other useful patterns.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种是一种不同类型的通信渠道，用于向其他微服务推送更新。实际上，我们已经提到过，由于对其他微服务的阻塞调用形成了复杂的阻塞调用树，因此无法通过正在进行的请求触发微服务之间的通信，这将增加请求的延迟时间，达到不可接受的水平。因此，在使用更新之前不应立即请求更新，并且应在状态发生变化时推送更新。理想情况下，这种通信应该是异步的，以实现可接受的性能。实际上，同步调用会在等待结果时阻塞发送者，从而增加每个微服务的空闲时间。然而，如果通信足够快（低通信延迟和高带宽），那么只将请求放入处理队列然后返回成功通信的确认而不是最终结果的同步通信是可以接受的。发布者/订阅者通信将是首选，因为在这种情况下，发送者和接收者不需要彼此了解，从而增加了微服务的独立性。实际上，对某种类型的通信感兴趣的所有接收者只需要注册以接收特定的*事件*，而发送者只需要发布这些事件。所有的连接工作由一个负责排队事件并将其分发给所有订阅者的服务执行。发布者/订阅者模式将在*第11章*的*设计模式和.NET
    5实现*中详细描述，以及其他有用的模式。
- en: While .NET doesn't directly offer tools that may help in asynchronous communication
    or client/server tools that implement publisher/subscriber communication, Azure
    offers a similar service with *Azure Service Bus*. Azure Service Bus handles both
    queued asynchronous communication through Azure Service Bus *queues* and publisher/subscriber
    communication through Azure Service Bus *topics*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然.NET没有直接提供可帮助实现异步通信或实现发布者/订阅者通信的客户端/服务器工具，但Azure提供了一个类似的服务，即*Azure Service
    Bus*。Azure Service Bus通过Azure Service Bus *队列*处理队列异步通信和通过Azure Service Bus *主题*处理发布者/订阅者通信。
- en: Once you've configured Azure Service Bus on the Azure portal, you can connect
    to it in order to send messages/events and to receive messages/events through
    a client contained in the `Microsoft.Azure.ServiceBus` NuGet package.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在Azure门户上配置了Azure Service Bus，您就可以通过`Microsoft.Azure.ServiceBus` NuGet包中的客户端连接到它，以便发送消息/事件和接收消息/事件。
- en: 'Azure Service Bus has two types of communication: queue-based and topic-based.
    In queue-based communication, each message that''s placed in the queue by a sender
    is removed from the queue by the first receiver that pulls it from the queue.
    Topic-based communication, on the other hand, is an implementation of the publisher/subscriber
    pattern. Each topic has several subscriptions and a different copy of each message
    sent to a topic can be pulled from each topic subscription.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Service Bus有两种类型的通信：基于队列和基于主题。在基于队列的通信中，发送者放入队列的每个消息都会被第一个从队列中拉取的接收者从队列中删除。另一方面，基于主题的通信是发布者/订阅者模式的一种实现。每个主题都有多个订阅，可以从每个主题订阅中拉取发送到主题的每个消息的不同副本。
- en: 'The design flow is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 设计流程如下：
- en: Define an Azure Service Bus private namespace.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义Azure Service Bus的私有命名空间。
- en: Get the root connection strings that were created by the Azure portal and/or
    define new connection strings with fewer privileges.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取由Azure门户创建的根连接字符串和/或定义具有较少权限的新连接字符串。
- en: Define queues and/or topics where the sender will send their messages in binary
    format.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义队列和/或主题，发送者将以二进制格式发送其消息。
- en: For each topic, define names for all the required subscriptions.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个主题定义所需订阅的名称。
- en: In the case of queue-based communication, the sender sends messages to a queue
    and the receivers pull messages from the same queue. Each message is delivered
    to one receiver. That is, once a receiver gains access to the queue, it reads
    and removes one or more messages.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基于队列的通信中，发送者将消息发送到一个队列，接收者从同一个队列中拉取消息。每个消息被传递给一个接收者。也就是说，一旦接收者获得对队列的访问权，它就会读取并删除一个或多个消息。
- en: In the case of topic-based communication, each sender sends messages to a topic,
    while each receiver pulls messages from the private subscription associated with
    that topic.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基于主题的通信中，每个发送者将消息发送到一个主题，而每个接收者从与该主题关联的私有订阅中拉取消息。
- en: 'There are also other commercial alternatives to Azure Service Bus, such as
    NServiceBus, MassTransit, Brighter, and ActiveMQ. There is also a free open source
    option: RabbitMQ. RabbitMQ can be installed locally, on a virtual machine, or
    in a Docker container. Then, you can connect with it through the client contained
    in the `RabbitMQ.Client` NuGet package.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Service Bus还有其他商业替代品，如NServiceBus、MassTransit、Brighter和ActiveMQ。还有一个免费的开源选项：RabbitMQ。RabbitMQ可以在本地、虚拟机或Docker容器中安装。然后，您可以通过`RabbitMQ.Client`
    NuGet包中的客户端与其连接。
- en: The functionalities of RabbitMQ are similar to the ones offered by Azure Service
    Bus but you have to take care of all the implementation details, confirmations
    of performed operations, and so on, while Azure Service Bus takes care of all
    the low-level operations and offers you a simpler interface. Azure Service Bus
    and RabbitMQ will be described alongside publisher/subscriber-based communication
    in *Chapter 11*, *Design Patterns and .NET 5 Implementation*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ的功能与Azure Service Bus提供的功能类似，但您必须处理所有实现细节、执行操作的确认等，而Azure Service Bus会处理所有低级操作并为您提供一个更简单的接口。Azure
    Service Bus和RabbitMQ将在第11章“设计模式和.NET 5实现”中与基于发布者/订阅者的通信一起进行描述。
- en: If microservices are published to Azure Service Fabric, which will be described
    in the next chapter (*Chapter 6*, *Azure Service Fabric*), we can use built-in
    reliable binary communication.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果微服务发布到Azure Service Fabric中，将在下一章（第6章“Azure Service Fabric”）中描述，我们可以使用内置的可靠二进制通信。
- en: Communication is resilient since communication primitives automatically use
    a retry policy. This communication is synchronous, but this is not a big limitation
    since microservices in Azure Service Fabric have built-in queues; thus, once the
    receiver has received a message, they can just put it in a queue and return it
    immediately, without blocking the sender.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通信是弹性的，因为通信原语自动使用重试策略。这种通信是同步的，但这不是一个大的限制，因为Azure Service Fabric中的微服务具有内置队列；因此，一旦接收者接收到消息，他们可以将其放入队列中并立即返回，而不会阻塞发送者。
- en: The messages in the queue are then processed by a separate thread. The main
    limitation of this built-in communication is that it is not based on the publisher/subscriber
    pattern; the senders and receivers must know each other. When this is not acceptable,
    you should use Azure Service Bus. We will learn how to use Service Fabric's built-in
    communication in *Chapter 6*, *Azure Service Fabric*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，队列中的消息由一个单独的线程处理。这种内置通信的主要限制是它不基于发布者/订阅者模式；发送者和接收者必须相互了解。当这种情况不可接受时，应该使用Azure
    Service Bus。我们将在第6章“Azure Service Fabric”中学习如何使用Service Fabric的内置通信。
- en: Resilient task execution
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹性任务执行
- en: Resilient communication and, in general, resilient task execution can be implemented
    easily with the help of a .NET library called Polly, whose project is a member
    of the .NET Foundation. Polly is available through the Polly NuGet package.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性通信和一般情况下的弹性任务执行可以通过一个名为Polly的.NET库轻松实现，该项目是.NET基金会的成员之一。Polly可以通过Polly NuGet包获得。
- en: 'In Polly, you define policies, and then execute tasks in the context of those
    policies, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Polly中，您定义策略，然后在这些策略的上下文中执行任务，如下所示：
- en: '[PRE0]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first part of each policy specifies the exceptions that must be handled.
    Then, you specify what to do when one of those exceptions is captured. In the
    preceding code, the `Execute` method is retried up to three times if a failure
    is reported either by an `HttpRequestException` exception or by an `OperationCanceledException`
    exception.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每个策略的第一部分指定了必须处理的异常。然后，您指定在捕获其中一个异常时要执行的操作。在上述代码中，如果由`HttpRequestException`异常或`OperationCanceledException`异常报告了失败，则`Execute`方法将重试最多三次。
- en: 'The following is the implementation of an exponential retry policy:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是指数重试策略的实现：
- en: '[PRE1]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first argument of `WaitAndRetry` specifies that a maximum of six retries
    is performed in the event of failure. The lambda function passed as the second
    argument specifies how much time to wait before the next attempt. In this specific
    example, this time grows exponentially with the number of the attempt by a power
    of 2 (2 seconds for the first retry, 4 seconds for the second retry, and so on).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`WaitAndRetry`的第一个参数指定在失败的情况下最多执行六次重试。作为第二个参数传递的lambda函数指定下一次尝试之前等待的时间。在这个具体的例子中，这个时间随着尝试次数的增加呈指数增长（第一次重试2秒，第二次重试4秒，依此类推）。'
- en: 'The following is a simple circuit breaker policy:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的断路器策略：
- en: '[PRE2]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After six failures, the task can't be executed for 1 minute since an exception
    is returned.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在六次失败之后，由于返回了异常，任务将在1分钟内无法执行。
- en: 'The following is the implementation of the Bulkhead Isolation policy (see the
    *Microservices design principles* section for more information):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Bulkhead隔离策略的实现（有关更多信息，请参见“微服务设计原则”部分）：
- en: '[PRE3]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A maximum of 10 parallel executions is allowed in the `Execute` method. Further
    tasks are inserted in an execution queue. This has a limit of 15 tasks. If the
    queue limit is exceeded, an exception is thrown.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Execute`方法允许最多10个并行执行。进一步的任务被插入到执行队列中。这个队列有一个15个任务的限制。如果超过队列限制，将抛出异常。'
- en: For the Bulkhead Isolation policy to work properly and, in general, for every
    strategy to work properly, task executions must be triggered through the same
    policy instance; otherwise, Polly is unable to count how many executions of a
    specific task are active.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Bulkhead隔离策略正常工作，以及为了使每个策略正常工作，必须通过相同的策略实例触发任务执行；否则，Polly无法计算特定任务的活动执行次数。
- en: 'Policies can be combined with the `Wrap` method:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 策略可以与`Wrap`方法结合使用：
- en: '[PRE4]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Polly offers several more options, such as generic methods for tasks that return
    a specific type, timeout policies, task result caching, the ability to define
    custom policies, and so on. It is also possible to configure Polly as part of
    an `HttPClient` definition in the dependency injection section of any ASP.NET
    and .NET application. This way, it is quite immediate to define resilient clients.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Polly提供了更多选项，例如用于返回特定类型的任务的通用方法、超时策略、任务结果缓存、定义自定义策略等等。还可以将Polly配置为任何ASP.NET和.NET应用程序的依赖注入部分的`HttPClient`定义的一部分。这样，定义弹性客户端就非常简单。
- en: The link to the official Polly documentation is in the *Further reading* section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 官方Polly文档的链接在*进一步阅读*部分中。
- en: Using generic hosts
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用通用主机
- en: Each microservice may need to run several independent threads, each performing
    a different operation on requests received. Such threads need several resources,
    such as database connections, communication channels, specialized modules that
    perform complex operations, and so on. Moreover, all processing threads must be
    adequately initialized when the microservice is started and gracefully stopped
    when the microservice is stopped as a consequence of either load balancing or
    errors.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务可能需要运行多个独立的线程，每个线程对接收到的请求执行不同的操作。这些线程需要多个资源，例如数据库连接、通信通道、执行复杂操作的专用模块等等。此外，当微服务由于负载平衡或错误而停止时，必须适当地初始化所有处理线程，并在停止时优雅地停止。
- en: All of these needs led the .NET team to conceive and implement *hosted services*
    and *hosts*. A host creates an adequate environment for running several tasks,
    known as **hosted services**, and provides them with resources, common settings,
    and graceful start/stop.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些需求促使.NET团队构思和实现*托管服务*和*主机*。主机为运行多个任务（称为**托管服务**）提供了适当的环境，并为它们提供资源、公共设置和优雅的启动/停止。
- en: The concept of a web host was mainly conceived to implement the ASP.NET Core
    web framework, but, with effect from .NET Core 2.1, the host concept was extended
    to all .NET applications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Web主机的概念主要是为了实现ASP.NET Core Web框架，但是从.NET Core 2.1开始，主机概念扩展到了所有.NET应用程序。
- en: At the time of writing this book, a `Host` is automatically created for you
    in any ASP.NET Core or Blazor project, so you have to add it manually only in
    other project types.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，在任何ASP.NET Core或Blazor项目中，都会自动为您创建一个`Host`，因此您只需要在其他项目类型中手动添加它。
- en: All features related to the concept of a `Host` are contained in the `Microsoft.Extensions.Hosting`
    NuGet package.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Host`概念相关的所有功能都包含在`Microsoft.Extensions.Hosting` NuGet包中。
- en: 'First, you need to configure the host with a fluent interface, starting with
    a `HostBuilder` instance. The final step of this configuration is calling the
    `Build` method, which assembles the actual host with all the configuration information
    we provided:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要使用流畅的接口配置主机，从一个`HostBuilder`实例开始。此配置的最后一步是调用`Build`方法，该方法使用我们提供的所有配置信息组装实际的主机：
- en: '[PRE5]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Host configuration includes defining the common resources, defining the default
    folder for files, loading the configuration parameters from several sources (JSON
    files, environment variables, and any arguments that are passed to the application),
    and declaring all the hosted services.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 主机配置包括定义公共资源、定义文件的默认文件夹、从多个来源加载配置参数（JSON文件、环境变量和传递给应用程序的任何参数）以及声明所有托管服务。
- en: It is worth pointing out that ASP.NET Core and Blazor projects use methods that
    perform a pre-configuration of the `Host` that include several of the tasks listed
    previously.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，ASP.NET Core和Blazor项目使用执行`Host`的预配置方法，其中包括前面列出的几个任务。
- en: 'Then, the host can be started, which causes all the hosted services to be started:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以启动主机，这将导致所有托管服务启动：
- en: '[PRE6]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The program remains blocked on the preceding instruction until the host is shut
    down. The host can be shut down either by one of the hosted services or externally
    by calling `awaithost.StopAsync(timeout)`. Here, `timeout` is a time span defining
    the maximum time to wait for the hosted services to stop gracefully. After this
    time, all the hosted services are aborted if they haven't been terminated.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在前面的指令上保持阻塞，直到主机关闭。主机可以通过其中一个托管服务或通过调用`awaithost.StopAsync(timeout)`来关闭。这里，`timeout`是一个时间段，定义了等待托管服务正常停止的最长时间。在此时间之后，如果托管服务尚未终止，所有托管服务都将被中止。
- en: Often, the fact that a microservice is being shut down is signaled by a `cancellationToken`
    being passed when the microservice is started by the orchestrator. This happens
    when microservices are hosted in Azure Service Fabric.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，微服务关闭的事实是通过在协调器启动微服务时传递的`cancellationToken`来表示的。当微服务托管在Azure Service Fabric中时，就会发生这种情况。
- en: 'Therefore in most cases, instead of using `host.Start()`, we can use the `RunAsync`
    or `Run` method, possibly passing it a `cancellationToken` that we received from
    the orchestrator or from the operating system:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在大多数情况下，我们可以使用`RunAsync`或`Run`方法，而不是使用`host.Start()`，可能会传递一个从协调器或操作系统中获取的`cancellationToken`：
- en: '[PRE7]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This way of shutting down is triggered as soon as the `cancellationToken` enters
    a canceled state. By default, the host has a 5-second timeout for shutting down;
    that is, it waits 5 seconds before exiting once a shutdown has been requested.
    This time can be changed within the `ConfigureServices` method, which is used
    to declare *hosted services* and other resources:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关闭方式在`cancellationToken`进入取消状态时立即触发。默认情况下，主机在关闭时有5秒的超时时间，即一旦请求关闭，它会等待5秒钟然后退出。这个时间可以在`ConfigureServices`方法中进行更改，该方法用于声明*托管服务*和其他资源：
- en: '[PRE8]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: However, increasing the host timeout doesn't increase the orchestrator timeout,
    so if the host waits too long, the whole microservice is killed by the orchestrator.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，增加主机超时时间不会增加编排器超时时间，因此如果主机等待时间过长，编排器将终止整个微服务。
- en: If no cancellation token is explicitly passed to `Run` or `RunAsync`, a cancellation
    token is automatically generated and is automatically signaled when the operating
    system informs the application it is going to kill it. This cancellation token
    is passed to all hosted services to give them the opportunity to stop gracefully.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`Run`或`RunAsync`中没有显式传递取消令牌，则会自动生成一个取消令牌，并在操作系统通知应用程序即将终止时自动发出信号。这个取消令牌将传递给所有托管服务，以便它们有机会优雅地停止。
- en: Hosted services are implementations of the `IHostedService` interface, whose
    only methods are `StartAsync(cancellationToken)` and `StopAsync(cancellationToken)`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 托管服务是`IHostedService`接口的实现，其唯一的方法是`StartAsync(cancellationToken)`和`StopAsync(cancellationToken)`。
- en: Both methods are passed a `cancellationToken`. The `cancellationToken` in the
    `StartAsync` method signals that a shutdown was requested. The `StartAsync` method
    periodically checks this `cancellationToken` while performing all operations needed
    to start the host, and if it is signaled, the host start process is aborted. On
    the other hand, the `cancellationToken` in the `StopAsync` method signals that
    the shutdown timeout expired.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法都传递了一个`cancellationToken`。`StartAsync`方法中的`cancellationToken`表示请求了关闭。`StartAsync`方法在执行启动主机所需的所有操作时定期检查这个`cancellationToken`，如果它被触发，主机启动过程将被中止。另一方面，`StopAsync`方法中的`cancellationToken`表示关闭超时已过期。
- en: 'Hosted services can be declared in the same `ConfigureServices` method that''s
    used to define host options, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 托管服务可以在用于定义主机选项的同一个`ConfigureServices`方法中声明，如下所示：
- en: '[PRE9]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, some project templates, like the ASP.NET Core project template, define
    a `ConfigureServices` method in a different class. This works fine if this method
    receives the same `services` parameter that is available in the `HostBuilder.ConfigureServices`
    method.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些项目模板（如ASP.NET Core项目模板）在不同的类中定义了一个`ConfigureServices`方法。如果这个方法接收与`HostBuilder.ConfigureServices`方法中可用的`services`参数相同的参数，那么这将正常工作。
- en: 'Most declarations inside `ConfigureServices` require the addition of the following
    namespace:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigureServices`内的大多数声明需要添加以下命名空间：'
- en: '[PRE10]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Usually, the `IHostedService` interface isn't implemented directly but can be
    inherited from the `BackgroundService` abstract class, which exposes the easier-to-implement
    `ExecuteAsync(CancellationToken)` method, which is where we can place the whole
    logic of the service. A shutdown is signaled by passing `cancellationToken` as
    an argument, which is easier to handle. We will look at an implementation of `IHostedService`
    in the example at the end of *Chapter 6*, *Azure Service Fabric*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，不直接实现`IHostedService`接口，而是可以从`BackgroundService`抽象类继承，该抽象类公开了更容易实现的`ExecuteAsync(CancellationToken)`方法，我们可以在其中放置整个服务的逻辑。通过将`cancellationToken`作为参数传递，可以更容易地处理关闭。我们将在*第6章*的示例中查看`IHostedService`的实现，*Azure
    Service Fabric*。
- en: 'To allow a hosted service to shut down the host, we need to declare an `IApplicationLifetime`
    interface as its constructor parameter:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许托管服务关闭主机，我们需要将`IApplicationLifetime`接口声明为其构造函数参数：
- en: '[PRE11]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the hosted service is created, it is automatically passed an implementation
    of `IHostApplicationLifetime`, whose `StopApplication` method will trigger the
    host shutdown. This implementation is handled automatically, but we can also declare
    custom resources whose instances will be automatically passed to all the host
    service constructors that declare them as parameters. Therefore, say we define
    a constructor like this one:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建托管服务时，它会自动传递一个`IHostApplicationLifetime`的实现，其中的`StopApplication`方法将触发主机关闭。这个实现是自动处理的，但我们也可以声明自定义资源，其实例将自动传递给所有声明它们为参数的主机服务构造函数。因此，假设我们定义了如下构造函数：
- en: '[PRE12]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are several ways to define the resources needed by the preceding constructor:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以定义上述构造函数所需的资源：
- en: '[PRE13]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When we use `AddTransient`, a different instance is created and passed to all
    the constructors that require an instance of that type. On the other hand, with
    `AddSingleton`, a unique instance is created and passed to all the constructors
    that require the declared type. The overload with two generic types allows you
    to pass an interface and a type that implements that interface. This way, a constructor
    requires the interface and is decoupled from the specific implementation of that
    interface.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`AddTransient`时，会创建一个不同的实例，并将其传递给所有需要该类型实例的构造函数。另一方面，使用`AddSingleton`时，会创建一个唯一的实例，并将其传递给所有需要声明类型的构造函数。带有两个泛型类型的重载允许您传递一个接口和实现该接口的类型。这样，构造函数需要接口，并与该接口的具体实现解耦。
- en: If resource constructors contain parameters, they will be automatically instantiated
    with the types declared in `ConfigureServices` in a recursive fashion. This pattern
    of interaction with resources is called **dependency injection** (**DI**) and
    will be discussed in detail in *Chapter 11*, *Design Patterns and .NET 5 Implementation*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资源的构造函数包含参数，则这些参数将以递归方式使用在`ConfigureServices`中声明的类型进行自动实例化。这种与资源的交互模式称为**依赖注入**（**DI**），将在*第11章*的*设计模式和.NET
    5实现*中详细讨论。
- en: '`HostBuilder` also has a method we can use to define the default folder, that
    is, the folder used to resolve all relative paths mentioned in all .NET methods:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`HostBuilder`还有一个方法，我们可以用来定义默认文件夹，也就是用来解析所有.NET方法中提到的所有相对路径的文件夹：'
- en: '[PRE14]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It also has methods that we can use to add logging targets:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有一些方法，我们可以用来添加日志记录目标：
- en: '[PRE15]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The previous example shows a console-based logging source, but we can also log
    into Azure targets with adequate providers. The *Further reading* section contains
    links to some Azure logging providers that can work with microservices that have
    been deployed in Azure Service Fabric. Once you've configured logging, you can
    enable your hosted services and log custom messages by adding an `ILoggerFactory`
    or an `ILogger<T>` parameter in their constructors.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例显示了一个基于控制台的日志记录源，但我们也可以使用适当的提供程序记录到Azure目标。*进一步阅读*部分包含了一些可以与部署在Azure Service
    Fabric中的微服务一起使用的Azure日志记录提供程序的链接。一旦您配置了日志记录，您可以通过在它们的构造函数中添加`ILoggerFactory`或`ILogger<T>`参数来启用托管服务并记录自定义消息。
- en: 'Finally, `HostBuilder` has methods we can use to read configuration parameters
    from various sources:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`HostBuilder`有一些方法，我们可以用来从各种来源读取配置参数：
- en: '[PRE16]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The way parameters can be used from inside the application will be explained
    in more detail in *Chapter 15*, *Presenting ASP.NET Core MVC*, which is dedicated
    to ASP.NET.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序内部如何使用参数将在*第15章* *介绍ASP.NET Core MVC*中更详细地解释，该章节专门讨论ASP.NET。
- en: Visual Studio support for Docker
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio对Docker的支持
- en: Visual Studio offers support for creating, debugging, and deploying Docker images.
    Docker deployment requires us to install *Docker Desktop for Windows* on our development
    machine so that we can run Docker images. The download link can be found in the
    *Technical requirements* section at the beginning of this chapter. Before we start
    any development activity, we must ensure it is installed and running (you should
    see a Docker icon in the window notification bar when the Docker runtime is running).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio支持创建、调试和部署Docker图像。Docker部署要求我们在开发机器上安装*Windows Docker桌面*，以便我们可以运行Docker图像。下载链接可以在本章开头的*技术要求*部分找到。在开始任何开发活动之前，我们必须确保它已安装并运行（当Docker运行时运行时，您应该在窗口通知栏中看到一个Docker图标）。
- en: 'Docker support will be described with a simple ASP.NET MVC project. Let''s
    create one. To do so, follow these steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Docker支持将以一个简单的ASP.NET MVC项目来描述。让我们创建一个。要做到这一点，请按照以下步骤：
- en: Name the project `MvcDockerTest`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为`MvcDockerTest`。
- en: For simplicity, disable authentication, if not already disabled.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为简单起见，如果尚未禁用身份验证，请禁用身份验证。
- en: You are given the option to add Docker support when you create the project,
    but please don't check the Docker support checkbox. You can test how Docker support
    can be added to any project after it has been created.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建项目时，您可以选择添加Docker支持，但请不要勾选Docker支持复选框。您可以测试如何在创建项目后添加Docker支持。
- en: Once you have your ASP.NET MVC application scaffolded and running, right-click
    on its project icon in **Solution Explorer** and select **Add** and then **Container
    Orchestrator Support** | **Docker Compose**.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的ASP.NET MVC应用程序脚手架和运行，右键单击**解决方案资源管理器**中的项目图标，然后选择**添加**，然后选择**容器编排器支持**
    | **Docker Compose**。
- en: You'll get a dialog asking you to pick what operating system your container
    should use; pick the same one you chose when installing *Docker Desktop for Windows*.
    This will enable not only the creation of a Docker image but also the creation
    of a Docker Compose project, which helps you configure Docker Compose files so
    that they run and deploy several Docker images simultaneously. In fact, if you
    add another MVC project to the solution and enable container orchestrator support
    for it, the new Docker image will be added to the same Docker Compose file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您将会看到一个对话框，询问您选择容器应该使用的操作系统；选择与安装*Windows Docker桌面*时选择的相同的操作系统。这将不仅启用Docker图像的创建，还将创建一个Docker
    Compose项目，帮助您配置Docker Compose文件，以便它们同时运行和部署多个Docker图像。实际上，如果您向解决方案添加另一个MVC项目并为其启用容器编排器支持，新的Docker图像将被添加到相同的Docker
    Compose文件中。
- en: The advantage of enabling Docker Compose instead of just `Docker` is that you
    can manually `configure` how the image is run on the development machine, as well
    as how Docker image ports are mapped to external ports by editing the Docker Compose
    files that are added to the solution.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 启用Docker Compose而不仅仅是`Docker`的优势在于，您可以手动`配置`图像在开发机器上的运行方式，以及通过编辑添加到解决方案中的Docker
    Compose文件来映射Docker图像端口到外部端口。
- en: If your Docker runtime has been installed properly and is running, you should
    be able to run the Docker image from Visual Studio.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的Docker运行时已经正确安装并运行，您应该能够从Visual Studio运行Docker图像。
- en: Analyzing the Docker file
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析Docker文件
- en: 'Let''s analyze the Docker file that was created by Visual Studio. It is a sequence
    of image creation steps. Each step enriches an existing image with something else
    with the help of the `From` instruction, which is a reference to an already existing
    image. The following is the first step:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下由Visual Studio创建的Docker文件。这是一系列的图像创建步骤。每个步骤都是通过`From`指令来丰富现有的图像，这是一个对已经存在的图像的引用。以下是第一步：
- en: '[PRE17]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first step uses the `mcr.microsoft.com/dotnet/aspnet:x.x` ASP.NET (Core)
    runtime that was published by Microsoft in the Docker public repository (where
    `x.x` is the ASP.NET (Core) version that was selected in your project).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步使用了由Microsoft在Docker公共存储库中发布的`mcr.microsoft.com/dotnet/aspnet:x.x` ASP.NET（Core）运行时（其中`x.x`是您项目中选择的ASP.NET（Core）版本）。
- en: 'The `WORKDIR` command creates the directory that follows the command within
    the image that is going to be created. If the directory doesn''t exist yet, it
    is created in the image. The two `EXPOSE` commands declare which ports of the
    image ports will be exposed outside the image and mapped to the actual hosting
    machine. Mapped ports are decided in the deployment stage either as command-line
    arguments of a Docker command or within a Docker Compose file. In our case, there
    are two ports: one for HTTP (80) and another for HTTPS (443).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: “WORKDIR”命令在将要创建的图像中创建了随后的目录。如果目录尚不存在，则在图像中创建它。两个“EXPOSE”命令声明了图像端口将被暴露到图像外部并映射到实际托管机器的端口。映射的端口在部署阶段通过Docker命令的命令行参数或Docker
    Compose文件中决定。在我们的例子中，有两个端口：一个用于HTTP（80），另一个用于HTTPS（443）。
- en: This intermediate image is cached by Docker, which doesn't need to recompute
    it since it doesn't depend on the code we write but only on the selected version
    of the ASP.NET (Core) runtime.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个中间图像由Docker缓存，它不需要重新计算，因为它不依赖于我们编写的代码，而只依赖于所选的ASP.NET（Core）运行时版本。
- en: 'The second step produces a different image that will not be used to deploy.
    Instead, it will be used to create application-specific files that will be deployed:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步生成一个不同的图像，不用于部署，而是用于创建将被部署的特定应用程序文件：
- en: '[PRE18]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This step starts from the ASP.NET SDK image, which contains parts we don't need
    to add for deployment; these are needed to process the project code. The new `src`
    directory is created in the `build` image and makes the current image directory.
    Then, the project file is copied into `/src/MvcDockerTest`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤从包含我们不需要添加到部署的ASP.NET SDK图像开始；这些是用于处理项目代码的。在“构建”图像中创建了新的“src”目录，并使其成为当前图像目录。然后，将项目文件复制到“/src/MvcDockerTest”中。
- en: The `RUN` command executes an operating system command on the image. In this
    case, it calls the `dotnet` runtime, asking it to restore the NuGet packages that
    were referenced by the previously copied project file.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: “RUN”命令在图像上执行操作系统命令。在这种情况下，它调用“dotnet”运行时，要求其恢复先前复制的项目文件引用的NuGet包。
- en: Then, the `COPY..` command copies the whole project file tree into the `src`
    image directory. Finally, the project directory is made the current directory
    and the `dotnet` runtime is asked to build the project in release mode and copy
    all the output files into the new `/app/build` directory. Finally, the `dotnet
    publish` task is executed in a new image called `publish`, outputting the published
    binaries into `/app/publish`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，“COPY..”命令将整个项目文件树复制到“src”图像目录中。最后，将项目目录设置为当前目录，并要求“dotnet”运行时以发布模式构建项目并将所有输出文件复制到新的“/app/build”目录中。最后，在名为“publish”的新图像中执行“dotnet
    publish”任务，将发布的二进制文件输出到“/app/publish”中。
- en: 'The final step starts from the image that we created in the first step, which
    contains the ASP.NET (Core) runtime, and adds all the files that were published
    in the previous step:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步从我们在第一步中创建的图像开始，其中包含ASP.NET（Core）运行时，并添加在上一步中发布的所有文件：
- en: '[PRE19]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `ENTRYPOINT` command specifies the operating system command that's needed
    to execute the image. It accepts an array of strings. In our case, it accepts
    the `dotnet` command and its first command-line argument, that is, the DLL we
    need to execute.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: “ENTRYPOINT”命令指定执行图像所需的操作系统命令。它接受一个字符串数组。在我们的例子中，它接受“dotnet”命令及其第一个命令行参数，即我们需要执行的DLL。
- en: Publishing the project
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布项目
- en: 'If we right-click on our project and click **Publish**, we are presented with
    several options:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们右键单击项目并单击“发布”，将显示几个选项：
- en: Publish the image to an existing or new web app (automatically created by Visual
    Studio)
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图像发布到现有或新的Web应用程序（由Visual Studio自动创建）
- en: Publish to one of several Docker registries, including a private Azure Container
    Registry that, if it doesn't already exist, can be created from within Visual
    Studio
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布到多个Docker注册表之一，包括私有Azure容器注册表，如果尚不存在，可以从Visual Studio内部创建
- en: Docker Compose support allows you to run and publish a multi-container application
    and add further images, such as a containerized database that is available everywhere.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose支持允许您运行和发布多容器应用程序，并添加其他图像，例如可在任何地方使用的容器化数据库。
- en: 'The following Docker Compose file adds two ASP.NET applications to the same
    Docker image:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Docker Compose文件将两个ASP.NET应用程序添加到同一个Docker图像中：
- en: '[PRE20]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code references existing Docker files. Any environment-dependent
    information is placed in the `docker-compose.override.yml` file, which is merged
    with the `docker-compose.yml` file when the application is launched from Visual
    Studio:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码引用了现有的Docker文件。任何与环境相关的信息都放在“docker-compose.override.yml”文件中，当从Visual Studio启动应用程序时，该文件与“docker-compose.yml”文件合并：
- en: '[PRE21]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For each image, the file defines some environment variables, which will be defined
    in the image when the application is launched, the port mappings, and some host
    files.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个图像，该文件定义了一些环境变量，当应用程序启动时，这些变量将在图像中定义，还定义了端口映射和一些主机文件。
- en: The files in the host are directly mapped into the images. Each declaration
    contains the path in the host, how the path is mapped in the image, and the desired
    access rights. In our case, `volumes` are used to map the self-signed HTTPS certificate
    that's used by Visual Studio.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 主机中的文件直接映射到图像中。每个声明包含主机中的路径，路径在图像中的映射方式以及所需的访问权限。在我们的例子中，使用“volumes”来映射Visual
    Studio使用的自签名HTTPS证书。
- en: 'Now, suppose we want to add a containerized SQL Server instance. We would need
    something like the following instructions split between `docker-compose.yml` and
    `docker-compose.override.yml`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要添加一个容器化的SQL Server实例。我们需要像下面这样的指令，分别在“docker-compose.yml”和“docker-compose.override.yml”之间进行拆分：
- en: '[PRE22]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, the preceding code specifies the properties of the SQL Server container,
    as well as the SQL server''s configuration and installation parameters. More specifically,
    the preceding code contains the following information:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，前面的代码指定了SQL Server容器的属性，以及SQL Server的配置和安装参数。更具体地说，前面的代码包含以下信息：
- en: '`sql.data` is the name that''s given to the container.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql.data`是给容器命名的名称。'
- en: '`image` specifies where to take the image from. In our case, the image is contained
    in a public Docker registry.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`指定从哪里获取图像。在我们的例子中，图像包含在公共Docker注册表中。'
- en: '`environment` specifies the environment variables that are needed by SQL Server,
    that is, the administrator password and the acceptance of a SQL Server license.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment`指定SQL Server所需的环境变量，即管理员密码和接受SQL Server许可证。'
- en: As usual, `ports` specifies the port mappings.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如往常一样，`ports`指定了端口映射。
- en: '`docker-compose.override.yml` is used to run the images from within Visual
    Studio.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose.override.yml`用于在Visual Studio中运行图像。'
- en: 'If you need to specify parameters for either the production environment or
    the testing environment, you can add further `docker-compose-xxx.override.yml`
    files, such as `docker-compose-staging.override.yml` and `docker-compose-production.override.yml`,
    and then launch them manually in the target environment with something like the
    following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要为生产环境或测试环境指定参数，可以添加更多的`docker-compose-xxx.override.yml`文件，例如`docker-compose-staging.override.yml`和`docker-compose-production.override.yml`，然后在目标环境中手动启动它们，类似以下代码：
- en: '[PRE23]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, you can destroy all the containers with the following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用以下代码销毁所有容器：
- en: '[PRE24]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: While `docker-compose` has a limited capability when it comes to handling node
    clusters, it is mainly used in testing and development environments. For production
    environments, more sophisticated tools are needed, as we will see later in this
    chapter (in the *Which tools are needed to manage microservices?* section).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`docker-compose`在处理节点集群时的能力有限，但主要用于测试和开发环境。对于生产环境，需要更复杂的工具，我们将在本章后面的*需要哪些工具来管理微服务？*部分中看到。
- en: Azure and Visual Studio support for microservice orchestration
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure和Visual Studio对微服务编排的支持
- en: Visual Studio has specific project templates for microservice applications based
    on the Service Fabric platform, where you can define various microservices, configure
    them, and deploy them to Azure Service Fabric, which is a microservice orchestrator.
    Azure Service Fabric will be described in more detail in *Chapter 6*, *Azure Service
    Fabric*.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio具有基于Service Fabric平台的微服务应用程序的特定项目模板，您可以在其中定义各种微服务，配置它们，并将它们部署到Azure
    Service Fabric，这是一个微服务编排器。Azure Service Fabric将在*第6章*，*Azure Service Fabric*中详细介绍。
- en: Visual Studio also has specific project templates for defining microservices
    to be deployed in Azure Kubernetes, and has extensions for debugging a single
    microservice while it communicates with other microservices deployed in Azure
    Kubernetes.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio还具有特定的项目模板，用于定义要部署在Azure Kubernetes中的微服务，并且具有用于调试单个微服务的扩展，同时与部署在Azure
    Kubernetes中的其他微服务进行通信。
- en: Also available are tools for testing and debugging several communicating microservices
    in the development machine with no need to install any Kubernetes software, and
    for deploying them automatically on Azure Kubernetes with just minimal configuration
    information.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 还提供了用于在开发机器上测试和调试多个通信微服务的工具，无需安装任何Kubernetes软件，并且可以使用最少的配置信息自动部署到Azure Kubernetes上。
- en: All Visual Studio tools for Azure Kubernetes will be described in *Chapter 7*,
    *Azure Kubernetes Service*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于Azure Kubernetes的Visual Studio工具将在*第7章*，*Azure Kubernetes Service*中进行描述。
- en: Which tools are needed to manage microservices?
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要哪些工具来管理微服务？
- en: 'Effectively handling microservices in your CI/CD cycles requires both a private
    Docker image registry and a state-of-the-art microservice orchestrator that''s
    capable of doing the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在CI/CD周期中有效地处理微服务需要一个私有的Docker镜像注册表和一个先进的微服务编排器，该编排器能够执行以下操作：
- en: Allocating and load-balancing microservices on available hardware nodes
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可用的硬件节点上分配和负载均衡微服务
- en: Monitoring the health state of services and replacing faulty services if hardware/software
    failures occur
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视服务的健康状态，并在发生硬件/软件故障时替换故障服务
- en: Logging and presenting analytics
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录和展示分析数据
- en: Allowing the designer to dynamically change requirements such as hardware nodes
    allocated to a cluster, the number of service instances, and so on
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许设计师动态更改要分配给集群的硬件节点、服务实例数量等要求
- en: The following subsection describes the Azure facilities we can use to store
    Docker images. The microservices orchestrators available in Azure are each described
    in a dedicated chapter, namely, *Chapter 6*, *Azure Service Fabric*, and *Chapter
    7*, *Azure Kubernetes Service*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的小节描述了我们可以使用的Azure设施来存储Docker镜像。Azure中可用的微服务编排器在各自的章节中进行了描述，即*第6章*，*Azure
    Service Fabric*和*第7章*，*Azure Kubernetes Service*。
- en: Defining your private Docker registry in Azure
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Azure中定义您的私有Docker注册表
- en: Defining your private Docker registry in Azure is easy. Just type `Container
    registries` into the Azure search bar and select **Container registries**. On
    the page that appears, click on the **Add** button.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure中定义您的私有Docker注册表很容易。只需在Azure搜索栏中键入`Container registries`，然后选择**Container
    registries**。在出现的页面上，点击**Add**按钮。
- en: 'The following form will appear:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 将出现以下表单：
- en: '![](img/B16756_05_01.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_05_01.png)'
- en: 'Figure 5.1: Creating an Azure private Docker registry'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：创建Azure私有Docker注册表
- en: 'The name you select is used to compose the overall registry URI: `<name>.azurecr.io`.
    As usual, you can specify the subscription, resource group, and location. The
    **SKU** dropdown lets you choose from various levels of offerings that differ
    in terms of performance, available memory, and a few other auxiliary features.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您选择的名称用于组成整体注册表URI：<name>.azurecr.io。与往常一样，您可以指定订阅、资源组和位置。**SKU**下拉菜单可让您选择不同级别的服务，这些服务在性能、可用内存和一些其他辅助功能方面有所不同。
- en: 'Whenever you mention image names in Docker commands or in a Visual Studio publish
    form, you must prefix them with the registry URI: `<name>.azurecr.io/<my imagename>`.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时在Docker命令或Visual Studio发布表单中提到图像名称，都必须在注册表URI前加上前缀：<name>.azurecr.io/<my
    imagename>。
- en: If images are created with Visual Studio, then they can be published by following
    the instructions that appear once you've published the project. Otherwise, you
    must use `docker` commands to push them into your registry.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用Visual Studio创建了图像，则可以按照发布项目后出现的说明进行发布。否则，您必须使用`docker`命令将它们推送到您的注册表中。
- en: 'The easiest way to use Docker commands that interact with the Azure registry
    is by installing the Azure CLI on your computer. Download the installer from [https://aka.ms/installazurecliwindows](https://aka.ms/installazurecliwindows)
    and execute it. Once the Azure CLI has been installed, you can use the `az` command
    from Windows Command Prompt or PowerShell. In order to connect with your Azure
    account, you must execute the following login command:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与Azure注册表交互的Docker命令的最简单方法是在计算机上安装Azure CLI。从[https://aka.ms/installazurecliwindows](https://aka.ms/installazurecliwindows)下载安装程序并执行它。安装了Azure
    CLI后，您可以从Windows命令提示符或PowerShell使用`az`命令。为了连接到您的Azure帐户，您必须执行以下登录命令：
- en: '[PRE25]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This command should start your default browser and should drive you through
    the manual login procedure.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令应启动您的默认浏览器，并引导您完成手动登录过程。
- en: 'Once logged into your Azure account, you can log in to your private registry
    by typing the following command:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到Azure帐户后，您可以通过输入以下命令登录到私有注册表：
- en: '[PRE26]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s say you have a Docker image in another registry. As a first step,
    let''s pull the image on your local computer:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您在另一个注册表中有一个Docker镜像。作为第一步，让我们在本地计算机上拉取镜像：
- en: '[PRE27]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If there are several versions of the preceding image, the latest will be pulled
    since no version was specified. The version of the image can be specified as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有几个版本的前面的图像，则将拉取最新版本，因为没有指定版本。可以按如下方式指定图像的版本：
- en: '[PRE28]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Using the following command, you should see `myimage` within the list of local
    images:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令，您应该在本地图像列表中看到`myimage`：
- en: '[PRE29]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, tag the image with the path you want to assign in the Azure registry:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用您想要在Azure注册表中分配的路径为图像打上标签：
- en: '[PRE30]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Both the name and destination tag may have versions (`:<version name>`).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 名称和目标标签都可以有版本（`:<version name>`）。
- en: 'Finally, push it to your registry with the following command:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用以下命令将其推送到您的注册表中：
- en: '[PRE31]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this case, you can specify a version; otherwise, the latest version is pushed.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以指定一个版本；否则，将推送最新版本。
- en: 'By doing this, you can remove the image from your local computer using the
    following command:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令，您可以使用以下命令从本地计算机中删除图像：
- en: '[PRE32]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we described what microservices are and how they have evolved
    from the concept of a module. Then, we talked about the advantages of microservices
    and when it is worth using them, as well as general criteria for their design.
    We also explained what Docker containers are and analyzed the strong connection
    between containers and microservice architectures.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了什么是微服务以及它们是如何从模块的概念演变而来的。然后，我们讨论了微服务的优势以及何时值得使用它们，以及它们的设计的一般标准。我们还解释了Docker容器是什么，并分析了容器与微服务架构之间的紧密联系。
- en: Then, we took on a more practical implementation by describing all the tools
    that are available in .NET so that we can implement microservice-based architectures.
    We also described infrastructures that are needed by microservices and how the
    Azure cluster offers Azure Kubernetes Service and Azure Service Fabric.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过描述在.NET中可用的所有工具来进行更实际的实现，以便我们可以实现基于微服务的架构。我们还描述了微服务所需的基础设施以及Azure集群如何提供Azure
    Kubernetes服务和Azure Service Fabric。
- en: The next chapter discusses the Azure Service Fabric orchestrator in detail.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章详细讨论了Azure Service Fabric编排器。
- en: Questions
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the two-fold nature of the module concept?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块概念的双重性质是什么？
- en: Is scaling optimization the only advantage of microservices? If not, list some
    further advantages.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缩放优化是微服务的唯一优势吗？如果不是，请列出一些其他优势。
- en: What is Polly?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Polly是什么？
- en: What Docker support is offered by Visual Studio?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio提供了哪些对Docker的支持？
- en: What is an orchestrator and what orchestrators are available on Azure?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是编排器，Azure上有哪些编排器可用？
- en: Why is publisher/subscriber-based communication so important in microservices?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么基于发布者/订阅者的通信在微服务中如此重要？
- en: What is RabbitMQ?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是RabbitMQ？
- en: Why are idempotent messages so important?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么幂等消息如此重要？
- en: Further reading
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following are links to the official documentation for Azure Service Bus
    and RabbitMQ, two event bus technologies:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Azure Service Bus和RabbitMQ两种事件总线技术的官方文档链接：
- en: '**Azure Service Bus**: [https://docs.microsoft.com/en-us/azure/service-bus-messaging/](https://docs.microsoft.com/en-us/azure/service-bus-messaging/)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Service Bus**：[https://docs.microsoft.com/en-us/azure/service-bus-messaging/](https://docs.microsoft.com/en-us/azure/service-bus-messaging/)'
- en: '**RabbitMQ**: [https://www.rabbitmq.com/getstarted.html](https://www.rabbitmq.com/getstarted.html)'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RabbitMQ**：[https://www.rabbitmq.com/getstarted.html](https://www.rabbitmq.com/getstarted.html)'
- en: 'The documentation for Polly, a tool for reliable communication/tasks, can be
    found here: [https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly).'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Polly是一种可靠通信/任务工具，其文档可以在这里找到：[https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly)。
- en: 'More information on Docker can be found on Docker''s official website: [https://docs.docker.com/](https://docs.docker.com/).'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Docker的更多信息可以在Docker的官方网站上找到：[https://docs.docker.com/](https://docs.docker.com/)。
- en: 'The official documentation for Kubernetes and `.yaml` files can be found here:
    [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/).'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes和`.yaml`文件的官方文档可以在这里找到：[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)。
- en: 'The official documentation for Azure Kubernetes can be found here: [https://docs.microsoft.com/en-US/azure/aks/](https://docs.microsoft.com/en-US/azure/aks/).'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Kubernetes的官方文档可以在这里找到：[https://docs.microsoft.com/en-US/azure/aks/](https://docs.microsoft.com/en-US/azure/aks/)。
- en: 'The official documentation for Azure Service Fabric can be found here: [https://docs.microsoft.com/en-US/azure/service-fabric/](https://docs.microsoft.com/en-US/azure/service-fabric/).'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Service Fabric的官方文档可以在此处找到：[https://docs.microsoft.com/zh-cn/azure/service-fabric/](https://docs.microsoft.com/zh-cn/azure/service-fabric/)。
- en: 'The official documentation for Azure Service Fabric''s reliable services can
    be found here: [https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-services-introduction](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-services-introduction).'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Service Fabric可靠服务的官方文档可以在此处找到：[https://docs.microsoft.com/zh-cn/azure/service-fabric/service-fabric-reliable-services-introduction](https://docs.microsoft.com/zh-cn/azure/service-fabric/service-fabric-reliable-services-introduction)。
