- en: Chapter 2. Thread Synchronization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。线程同步
- en: 'In this chapter, we will describe some of the common techniques of working
    with shared resources from multiple threads. You will learn about:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将描述一些处理多个线程共享资源的常见技术。您将了解：
- en: Performing basic atomic operations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行基本的原子操作
- en: Using the Mutex construct
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mutex构造
- en: Using the SemaphoreSlim construct
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SemaphoreSlim构造
- en: Using the AutoResetEvent construct
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AutoResetEvent构造
- en: Using the ManualResetEventSlim construct
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ManualResetEventSlim构造
- en: Using the CountDownEvent construct
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CountDownEvent构造
- en: Using the Barrier construct
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Barrier构造
- en: Using the ReaderWriterLockSlim construct
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ReaderWriterLockSlim构造
- en: Using the SpinWait construct
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SpinWait构造
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: As we saw in [Chapter 1](ch01.html "Chapter 1. Threading Basics"), *Threading
    Basics*, it is problematic to use a shared object simultaneously from several
    threads. It is very important to synchronize those threads so that they perform
    operations on that shared object in a proper sequence. In a multithreaded counter
    recipe, we met a problem called the race condition. It happened because the execution
    of those multiple threads were not synchronized properly. When one thread performs
    the increment and decrement operations, the other threads must wait for their
    turn. This general problem is often referred to as **thread synchronization**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](ch01.html "第1章。线程基础") *线程基础*中看到的那样，同时从多个线程使用共享对象是有问题的。非常重要的是同步这些线程，以便它们按适当的顺序对共享对象执行操作。在多线程计数器示例中，我们遇到了一个称为竞争条件的问题。这是因为多个线程的执行没有得到适当的同步。当一个线程执行增量和减量操作时，其他线程必须等待它们的轮到。这个一般问题通常被称为**线程同步**。
- en: There are several ways to achieve thread synchronization. First, if there is
    no shared object, there is no need for synchronization at all. Surprisingly, it
    is very often that we can get rid of complex synchronization constructs by just
    redesigning your program and removing a shared state. If it's possible, just avoid
    using a single object from several threads.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以实现线程同步。首先，如果没有共享对象，就根本不需要同步。令人惊讶的是，我们经常可以通过重新设计程序并消除共享状态来摆脱复杂的同步构造。如果可能的话，尽量避免多个线程使用单个对象。
- en: If we must have a shared state, the second approach is to use only **atomic**
    operations. This means that an operation takes a single quantum of time and completes
    at once, so no other thread can perform another operation until the first operation
    is complete. Therefore, there is no need to make other threads wait for this operation
    to complete and there is no need to use locks; this in turn excludes the situation
    of a deadlock.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须有共享状态，第二种方法是只使用**原子**操作。这意味着一个操作需要一个时间量并立即完成，因此在第一个操作完成之前，没有其他线程可以执行另一个操作。因此，没有必要让其他线程等待此操作完成，也没有必要使用锁；这反过来排除了死锁的情况。
- en: If this is not possible and the program's logic is more complicated, then we
    have to use different constructs to coordinate threads. One group of those constructs
    puts a waiting thread into a **blocked** state. In a blocked state, a thread uses
    as little CPU time as possible. However, this means that it will include at least
    one so-called **context switch**—the thread scheduler of an operating system—that
    will save the waiting thread's state, and switch to another thread, restoring
    its state by turn. This takes a considerable amount of resources; however, if
    the thread is going to be suspended for a long time, it is good. These kinds of
    constructs are also called **kernel-mode** constructs because only the kernel
    of an operating system is able to stop a thread from using CPU time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不可能，程序逻辑更复杂，那么我们必须使用不同的构造来协调线程。其中一组构造将等待线程置于**阻塞**状态。在阻塞状态下，线程使用尽可能少的CPU时间。然而，这意味着它将至少包括一个所谓的**上下文切换**
    - 操作系统的线程调度程序将保存等待线程的状态，并切换到另一个线程，轮流恢复其状态。这需要大量资源；但是，如果线程将被暂停很长时间，这是好的。这些构造也被称为**内核模式**构造，因为只有操作系统的内核能够阻止线程使用CPU时间。
- en: In case we have to wait for a short period of time, it is better to simply wait
    than switch the thread to a blocked state. This will save us the context switch
    at the cost of some CPU time wasted while the thread is waiting. Such constructs
    are referred to as **user-mode** constructs. They are very lightweight and fast,
    but they waste a lot of CPU time in case a thread has to wait for long.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须等待很短的时间，最好是简单地等待而不是将线程切换到阻塞状态。这将节省我们上下文切换的开销，但会浪费一些CPU时间，因为线程在等待时会浪费一些CPU时间。这些构造被称为**用户模式**构造。它们非常轻量级和快速，但在线程必须长时间等待时会浪费大量CPU时间。
- en: To use the best of both the worlds, there are **hybrid** constructs; these try
    to use the user-mode waiting first, and then if a thread waits long enough, it
    switches to a blocked state, saving CPU resources.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了兼顾两者的优点，有**混合**构造；这些构造首先尝试使用用户模式等待，然后如果线程等待足够长的时间，它将切换到阻塞状态，节省CPU资源。
- en: In this chapter, we will look through the aspects of thread synchronization.
    We will cover how to perform atomic operations and how to use the existing synchronization
    constructs included in the .NET framework.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究线程同步的各个方面。我们将介绍如何执行原子操作以及如何使用.NET框架中包含的现有同步构造。
- en: Performing basic atomic operations
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行基本的原子操作
- en: This recipe will show you how to perform basic atomic operations on an object
    to prevent the race condition without blocking threads.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将向您展示如何对对象执行基本的原子操作，以防止竞争条件而不阻塞线程。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe could be found at `7644_Code\Chapter2\Recipe1`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过本示例，您需要Visual Studio 2012\. 没有其他先决条件。此示例的源代码可以在`7644_Code\Chapter2\Recipe1`中找到。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand the basic atomic operations, perform the following steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解基本的原子操作，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Below the `Main` method, add the following code snippet:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方，添加以下代码片段：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside the `Main` method, add the following code snippet:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中，添加以下代码片段：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the program.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the program runs, it creates three threads that will execute a code in
    the `TestCounter` method. This method runs a sequence of increment/decrement operations
    on an object. Initially, the `Counter` object is not thread-safe and we get a
    race condition here. So in the first case, a counter value is not deterministic.
    We could get a zero value; however, if you run the program several times, you
    will eventually get some incorrect nonzero result.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，它会创建三个线程，这些线程将执行`TestCounter`方法中的代码。该方法在对象上运行一系列的增量/减量操作。最初，`Counter`对象是不安全的，我们在这里遇到了竞争条件。因此，在第一种情况下，计数器值是不确定的。我们可能会得到一个零值；然而，如果你多次运行程序，最终会得到一些不正确的非零结果。
- en: In [Chapter 1](ch01.html "Chapter 1. Threading Basics"), *Threading Basics*,
    we resolved this problem by locking our object, causing other threads to block
    while one thread gets the old counter value, then computes and assigns a new value
    to the counter. However, if we execute this operation in such a way, it cannot
    be stopped midway; we would achieve the proper result without any locking with
    the help of the `Interlocked` construct. It provides the atomic methods `Increment`,
    `Decrement`, and `Add` for basic math, and it helps us to write the `Counter`
    class without the use of locking.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。线程基础")中，*线程基础*，我们通过锁定对象来解决了这个问题，导致其他线程在一个线程获取旧计数器值时被阻塞，然后计算并将新值分配给计数器。然而，如果我们以这种方式执行这个操作，它是无法在中途停止的；我们可以在没有任何锁定的情况下使用`Interlocked`构造来实现正确的结果。它提供了原子方法`Increment`、`Decrement`和`Add`用于基本数学运算，并帮助我们编写`Counter`类而不使用锁定。
- en: Using the Mutex construct
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mutex构造
- en: This recipe will describe how to synchronize two separate programs using a `Mutex`
    construct. `Mutex` is a primitive synchronization that grants exclusive access
    of the shared resource to only one thread.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将描述如何使用`Mutex`构造同步两个独立的程序。`Mutex`是一种原始同步，它只允许一个线程独占共享资源。
- en: Getting ready
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe could be found at `7644_Code\Chapter2\Recipe2`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这个示例，你需要Visual Studio 2012。没有其他先决条件。这个示例的源代码可以在`7644_Code\Chapter2\Recipe2`中找到。
- en: How to do it...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand the synchronization of two separate programs using the `Mutex`
    construct, perform the following steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解如何使用`Mutex`构造同步两个独立的程序，执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inside the `Main` method, add the following code snippet:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中，添加以下代码片段：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the program.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the main program starts, it defines a mutex with a specific name, providing
    the `initialOwner` flag as `false`. This allows the program to acquire a mutex
    if it is already created. Then, if no mutex was acquired, the program simply displays
    **Running**, and waits for any key to be pressed to release the mutex and exit.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它使用特定名称定义了一个互斥体，并将`initialOwner`标志设置为`false`。这允许程序在互斥体已经创建时获取互斥体。然后，如果没有获取到互斥体，程序将简单地显示**Running**，并等待按下任意键来释放互斥体并退出。
- en: If we start a second copy of the program, it will wait for 5 seconds, trying
    to acquire the mutex. If we press any key in the first copy of a program, the
    second one will start executing. However, if we keep waiting for 5 seconds, the
    second copy of the program will fail to acquire the mutex.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启动程序的第二个副本，它将等待5秒，尝试获取互斥体。如果我们在程序的第一个副本中按下任意键，第二个副本将开始执行。然而，如果我们继续等待5秒，程序的第二个副本将无法获取互斥体。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Please note that a named mutex is a global operating system object! Always close
    the mutex properly; the best choice is to wrap a mutex object using a block.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，命名的互斥体是一个全局操作系统对象！始终正确关闭互斥体；最好的选择是使用块来包装互斥体对象。
- en: This makes it possible to synchronize threads in different programs, which could
    be useful in a large number of scenarios.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得在不同程序中同步线程成为可能，这在许多场景下都是有用的。
- en: Using the SemaphoreSlim construct
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SemaphoreSlim构造
- en: This recipe will show how to `SemaphoreSlim` is a lightweight version of `Semaphore`;
    it limits the number of threads that can access a resource concurrently.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将展示如何`SemaphoreSlim`是`Semaphore`的轻量级版本；它限制了可以同时访问资源的线程数量。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe could be found at `BookSamples\Chapter2\Recipe3`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这个示例，你需要Visual Studio 2012。没有其他先决条件。这个示例的源代码可以在`BookSamples\Chapter2\Recipe3`中找到。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand limiting a multithreaded access to a resource with the help of
    the `SemaphoreSlim` construct, perform the following steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解如何使用`SemaphoreSlim`构造限制对资源的多线程访问，执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file add the following `using` directives:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中添加以下`using`指令：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Below the `Main` method, add the following code snippet:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方，添加以下代码片段：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Inside the `Main` method, add the following code snippet:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中，添加以下代码片段：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the program.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the main program starts, it creates a `SemaphoreSlim` instance, specifying
    the number of concurrent threads allowed in its constructor. Then it starts six
    threads with different names and start times to run.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它创建了一个`SemaphoreSlim`实例，在其构造函数中指定了允许的并发线程数。然后启动六个具有不同名称和启动时间的线程来运行。
- en: Every thread is trying to acquire an access to a database, but we restrict the
    number of concurrent accesses to a database by four threads with the help of a
    semaphore. When four threads get an access to a database, the other two threads
    wait until one of the previous threads finishes its work and signals by calling
    the `_semaphore.Release` method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都试图访问数据库，但我们通过信号量限制了对数据库的并发访问数量为四个线程。当四个线程访问数据库时，其他两个线程将等待，直到先前的一个线程完成其工作并通过调用`_semaphore.Release`方法发出信号。
- en: There's more…
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here we use a hybrid construct, which allows us to save a context switch in
    cases where the wait time is less. However, there is an older version of this
    construct called `Semaphore`. This version is a pure, kernel-time construct. There
    is no sense in using it, except in one very important scenario; we can create
    a named semaphore like a named mutex and use it to synchronize threads in different
    programs. `SemaphoreSlim` does not use Windows kernel semaphores and does not
    support interprocess synchronization, so use `Semaphore` in this case.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一个混合构造，它允许我们在等待时间较短的情况下节省上下文切换。然而，这个构造的旧版本称为`Semaphore`。这个版本是一个纯的内核时间构造。除了一个非常重要的场景之外，没有使用它的意义；我们可以创建一个命名信号量，就像创建一个命名互斥体一样，并且用它来同步不同程序中的线程。`SemaphoreSlim`不使用Windows内核信号量，也不支持进程间同步，因此在这种情况下使用`Semaphore`。
- en: Using the AutoResetEvent construct
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AutoResetEvent构造
- en: In this recipe, there is an example of how to send notifications from one thread
    to another with the help of an `AutoResetEvent` construct. `AutoResetEvent` notifies
    a waiting thread that an event has occurred.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，有一个示例，说明如何使用`AutoResetEvent`构造从一个线程向另一个线程发送通知。`AutoResetEvent`通知等待的线程事件已发生。
- en: Getting ready
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe could be found at `7644_Code\Chapter2\Recipe4`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照本教程进行操作，您需要Visual Studio 2012。没有其他先决条件。本教程的源代码可以在`7644_Code\Chapter2\Recipe4`中找到。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand how to send notifications from one thread to another with the
    help of the `AutoResetEvent` construct, perform the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解如何使用`AutoResetEvent`构造从一个线程向另一个线程发送通知，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file add the following `using` directives:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中添加以下`using`指令：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Below the `Main` method, add the following code snippet:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面，添加以下代码片段：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside the `Main` method, add the following code snippet:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部，添加以下代码片段：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the program.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the main program starts, it defines two `AutoResetEvent` instances. One
    of them is for signaling from the second thread to the main thread, and the second
    one will be signaling from the main thread to the second thread. We provide `false`
    to the `AutoResetEvent` constructor, specifying the initial sate of both the instances
    as `unsignaled`. This means that any thread calling the `WaitOne` method of one
    of these objects will be blocked until we call the `Set` method. If we initialize
    the event state to `true`, it becomes `signaled` and the thirst thread calling
    `WaitOne` would proceed immediately. The event state then becomes `unsignaled`
    automatically, so we need to call the `Set` method once again to let the other
    threads calling the `WaitOne` method on this instance to continue.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它定义了两个`AutoResetEvent`实例。其中一个是从第二个线程向主线程发出信号的，另一个是从主线程向第二个线程发出信号的。我们在`AutoResetEvent`构造函数中提供`false`，指定了这两个实例的初始状态为`未发出信号`。这意味着调用这些对象中的一个的`WaitOne`方法的任何线程都将被阻塞，直到我们调用`Set`方法。如果我们将事件状态初始化为`true`，它将变为`发出信号`，然后第三个调用`WaitOne`的线程将立即继续。然后事件状态会自动变为`未发出信号`，因此我们需要再次调用`Set`方法，以便让其他线程调用这个实例上的`WaitOne`方法继续。
- en: Then we create a second thread, which will execute the first operation for 10
    seconds and wait for the signal from the second thread. The signal means that
    the first operation is completed. Now the second thread is waiting for a signal
    from the main thread. We do some additional work on the main thread and send a
    signal by calling the `_mainEvent.Set` method. Then we wait for another signal
    from the second thread.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个第二个线程，它将执行第一个操作10秒，并等待来自第二个线程的信号。信号意味着第一个操作已完成。现在第二个线程正在等待来自主线程的信号。我们在主线程上做一些额外的工作，并通过调用`_mainEvent.Set`方法发送一个信号。然后我们等待来自第二个线程的另一个信号。
- en: '`AutoResetEvent` is a kernel-time construct, so if the wait time is not significant,
    it is better to use the next recipe with `ManualResetEventslim`, which is a hybrid
    construct.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoResetEvent`是一个内核时间构造，因此如果等待时间不重要，最好使用下一个使用`ManualResetEventslim`的教程，这是一个混合构造。'
- en: Using the ManualResetEventSlim construct
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ManualResetEventSlim构造
- en: This recipe will describe how to make signaling between threads more flexible
    with the `ManualResetEventSlim` construct.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将描述如何使用`ManualResetEventSlim`构造使线程之间的信号更加灵活。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe could be found at `BookSamples\Chapter2\Recipe5`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照本教程进行操作，您需要Visual Studio 2012。没有其他先决条件。本教程的源代码可以在`BookSamples\Chapter2\Recipe5`中找到。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand the use of the `ManualResetEventSlim` construct, perform the
    following steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`ManualResetEventSlim`构造的使用，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Below the `Main` method, add the following code:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方，添加以下代码：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Inside the `Main` method, add the following code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中，添加以下代码：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the program.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the main program starts, it first creates an instance of the `ManualResetEventSlim`
    construct. Then we start three threads that will wait for this event to signal
    them to continue the execution.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，首先创建`ManualResetEventSlim`构造的实例。然后我们启动三个线程，它们将等待此事件发出信号以继续执行。
- en: The whole process of working with this construct is like letting people pass
    through a gate. The `AutoResetEvent` event that we looked at in the previous recipe
    works like a turnstile, allowing only one person to pass at a time. `ManualResetEventSlim`,
    which is a hybrid version of `ManualResetEvent`, stays open until we manually
    call the `Reset` method. Going back to the code, when we call `_mainEvent.Set`,
    we open it and allow the threads that are ready to accept this signal and continue
    working. However, thread number three is still sleeping and does not make it in
    time. We call `_mainEvent.Reset` and we thus close it. The last thread is now
    ready to go on, but it has to wait for the next signal, which will happen a few
    seconds later.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此构造的整个过程就像让人们通过一个大门。我们在上一个示例中看到的`AutoResetEvent`事件就像一个旋转门，一次只允许一个人通过。`ManualResetEventSlim`是`ManualResetEvent`的混合版本，直到我们手动调用`Reset`方法之前都保持打开。回到代码，当我们调用`_mainEvent.Set`时，我们打开它并允许准备接受此信号并继续工作的线程。然而，第三个线程仍在休眠，来不及。我们调用`_mainEvent.Reset`，因此关闭它。最后一个线程现在准备好继续，但必须等待下一个信号，这将在几秒钟后发生。
- en: There's more…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As in one of the previous recipes, we use a hybrid construct that lacks the
    possibility to work at the operating system level. If we need to have a global
    event, we should use the `EventWaitHandle` construct, which is the base class
    for `AutoResetEvent` and `ManualResetEvent`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的某个示例一样，我们使用了一个混合构造，它缺乏在操作系统级别工作的可能性。如果我们需要全局事件，我们应该使用`EventWaitHandle`构造，它是`AutoResetEvent`和`ManualResetEvent`的基类。
- en: Using the CountDownEvent construct
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CountDownEvent构造
- en: This recipe will describe how to use a `CountdownEvent` signaling construct
    to wait until a certain number of operations complete.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例将描述如何使用`CountdownEvent`信号构造等待直到某个操作完成。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe could be found at `BookSamples\Chapter2\Recipe6`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此示例，您需要Visual Studio 2012。没有其他先决条件。此示例的源代码可以在`BookSamples\Chapter2\Recipe6`中找到。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand the use of the `CountDownEvent` construct, perform the following
    steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`CountDownEvent`构造的使用，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Below the `Main` method, add the following code:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方，添加以下代码：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Inside the `Main` method, add the following code:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中，添加以下代码：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the program.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the main program starts, we create a new `CountdownEvent` instance, specifying
    that we want it to signal when two operations complete in its constructor. Then
    we start two threads that signal to the event when they complete. As soon as the
    second thread is complete, the main thread returns from waiting on `CountdownEvent`
    and proceeds further. Using this construct, it is very convenient to wait for
    multiple asynchronous operations to complete.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，我们创建一个新的`CountdownEvent`实例，在其构造函数中指定我们希望在两个操作完成时发出信号。然后我们启动两个线程，在完成时向事件发出信号。一旦第二个线程完成，主线程就会从等待`CountdownEvent`中返回并继续进行。使用此构造，非常方便等待多个异步操作完成。
- en: However, there is a significant disadvantage; `_countdown.Wait()` will wait
    forever if we fail to call `_countdown.Signal()` the required number of times.
    Please make sure that all your threads complete with the `Signal` method call
    when using `CountdownEvent`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个重大缺点；如果我们未能调用所需次数的`_countdown.Signal()`，`_countdown.Wait()`将永远等待。在使用`CountdownEvent`时，请确保所有线程都使用`Signal`方法调用完成。
- en: Using the Barrier construct
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用屏障构造
- en: This recipe illustrates another interesting synchronization construct called
    `Barrier`. The `Barrier` construct helps to organize several threads to meet at
    some point in time, providing a callback that will be executed each time the threads
    have called the `SignalAndWait` method.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例说明了另一个有趣的同步构造，称为`Barrier`。`Barrier`构造有助于组织多个线程在某个时间点相遇，并提供一个回调，每当线程调用`SignalAndWait`方法时都会执行。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe could be found at `BookSamples\Chapter2\Recipe7`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此示例，您需要Visual Studio 2012。没有其他先决条件。此示例的源代码可以在`BookSamples\Chapter2\Recipe7`中找到。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand the use of the `Barrier` construct, perform the following steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`Barrier`构造的使用，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Below the `Main` method, add the following code:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方，添加以下代码：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inside the `Main` method, add the following code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中，添加以下代码：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Run the program.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We create a `Barrier` construct, specifying that we want to synchronize two
    threads, and after each of those two threads have called the `_barrier.SignalAndWait`
    method, we need to execute a callback that will print out the number of phases
    completed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个“Barrier”构造，指定我们要同步两个线程，并且在这两个线程中的每个调用了“_barrier.SignalAndWait”方法后，我们需要执行一个回调，打印出完成的阶段数。
- en: Each thread is going to send a signal to `Barrier` twice, so we will have two
    phases. Every time both the threads call the `SignalAndWait` method, `Barrier`
    will execute the callback. It is useful for working with multithreaded iteration
    algorithms, to execute some calculations on each iteration end. The end of iteration
    is reached when the last thread calls the `SignalAndWait` method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程将向“Barrier”发送信号两次，因此我们将有两个阶段。每当两个线程都调用“SignalAndWait”方法时，“Barrier”将执行回调。这对于使用多线程迭代算法进行工作很有用，以在每次迭代结束时执行一些计算。当最后一个线程调用“SignalAndWait”方法时，迭代结束。
- en: Using the ReaderWriterLockSlim construct
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“ReaderWriterLockSlim”构造
- en: This recipe will describe how to create a thread-safe mechanism to read and
    write to a collection from multiple threads using a `ReaderWriterLockSlim` construct.
    `ReaderWriterLockSlim` represents a lock that is used to manage access to a resource,
    allowing multiple threads for reading or exclusive access for writing.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将描述如何使用“ReaderWriterLockSlim”构造创建一个线程安全的机制，以从多个线程读取和写入集合。“ReaderWriterLockSlim”表示用于管理对资源的访问的锁，允许多个线程进行读取或独占访问进行写入。
- en: Getting ready
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe could be found at `BookSamples\Chapter2\Recipe8`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行本教程，您将需要Visual Studio 2012。没有其他先决条件。本教程的源代码可以在“BookSamples\Chapter2\Recipe8”中找到。
- en: How to do it...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand how to create a thread-safe mechanism to read and write to a
    collection from multiple threads using the `ReaderWriterLockSlim` construct, perform
    the following steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何创建一个线程安全的机制，以使用“ReaderWriterLockSlim”构造从多个线程读取和写入集合。
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Program.cs”文件中，添加以下“using”指令：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Below the `Main` method, add the following code:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Main”方法下面，添加以下代码：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Inside the `Main` method, add the following code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Main”方法中，添加以下代码：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run the program.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the main program starts, it simultaneously runs three threads that read
    data from a dictionary and two threads that write some data into this dictionary.
    To achieve thread safety, we use the `ReaderWriterLockSlim` construct, which was
    designed especially for such scenarios.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它同时运行三个从字典中读取数据的线程和两个向该字典中写入一些数据的线程。为了实现线程安全，我们使用了专为这种情况设计的“ReaderWriterLockSlim”构造。
- en: 'It has two kinds of locks: a read lock that allows multiple threads reading
    and a write lock that blocks every operation from other threads until this write
    lock is released. There is also an interesting scenario when we obtain a read
    lock, read some data from the collection, and depending on that data, decide to
    obtain a write lock and change the collection. If we get the write locks at once,
    too much time is spent not allowing our readers to read the data, because the
    collection is blocked when we get a write lock. To minimize this time, there are
    `EnterUpgradeableReadLock`/`ExitUpgradeableReadLock` methods. We get a read lock
    and read the data; if we find that we have to change the underlying collection,
    we just upgrade our lock using the `EnterWriteLock` method, then perform a write
    operation quickly, and release a write lock using `ExitWriteLock`.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 它有两种锁：读取锁允许多个线程读取，写入锁阻止其他线程的每个操作，直到释放此写入锁。还有一个有趣的场景，当我们获取读取锁，从集合中读取一些数据，并根据该数据决定获取写入锁并更改集合。如果我们立即获得写锁，会花费太多时间，不允许我们的读取器读取数据，因为当我们获取写锁时，集合被阻塞。为了最小化这段时间，有“EnterUpgradeableReadLock”/“ExitUpgradeableReadLock”方法。我们获取读取锁并读取数据；如果我们发现我们必须更改底层集合，我们只需使用“EnterWriteLock”方法升级我们的锁，然后快速执行写操作，并使用“ExitWriteLock”释放写锁。
- en: In our case, we get a random number; we then get a read lock and check if this
    number exists in the dictionary keys collection. If not, we upgrade our lock to
    a write lock and then add this new key to a dictionary. It is a good practice
    to use `try`/`finally` blocks to make sure we always release locks after acquiring
    them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们得到一个随机数；然后我们获取一个读取锁，并检查该数字是否存在于字典键集合中。如果不存在，我们将升级我们的锁为写锁，然后将这个新键添加到字典中。最好使用“try”/“finally”块来确保我们在获取锁后始终释放锁。
- en: All our threads have been created as background threads and after waiting for
    30 seconds, the main thread as well as all the background threads complete.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有线程都已创建为后台线程，并在等待30秒后，主线程以及所有后台线程都完成。
- en: Using the SpinWait construct
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SpinWait构造
- en: This recipe will describe how to wait on a thread without involving kernel-mode
    constructs. In addition, we introduce `SpinWait`, a hybrid synchronization construct,
    which is designed to wait in user mode for some time, and then switch to the kernel
    mode to save CPU time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将描述如何在不涉及内核模式构造的情况下等待线程。此外，我们介绍了“SpinWait”，这是一种混合同步构造，旨在在用户模式下等待一段时间，然后切换到内核模式以节省CPU时间。
- en: Getting ready
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe could be found at `BookSamples\Chapter2\Recipe9`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行本教程，您将需要Visual Studio 2012。没有其他先决条件。本教程的源代码可以在“BookSamples\Chapter2\Recipe9”中找到。
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand waiting on a thread without involving kernel-mode constructs,
    perform the following steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 了解在不涉及内核模式构造的情况下等待线程，执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Below the `Main` method, add the following code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面，添加以下代码：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Inside the `Main` method, add the following code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中，添加以下代码：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Run the program.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the main program starts, it defines a thread that will execute an endless
    loop for 20 milliseconds until the main thread sets the `_isCompleted` variable
    to `true`. We could experiment and run this cycle for 20-30 seconds instead, measuring
    the CPU load with the Windows task manager. It will show a significant amount
    of processor time, depending on how many cores the CPU has.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它定义了一个线程，该线程将执行一个无限循环，每20毫秒一次，直到主线程将`_isCompleted`变量设置为`true`。我们可以尝试将这个循环运行20-30秒，使用Windows任务管理器来测量CPU负载。这将显示出相当大量的处理器时间，取决于CPU有多少个核心。
- en: We use the `volatile` keyword to declare the `_isCompleted` static field. The
    `volatile` keyword indicates that a field might be modified by multiple threads
    executing at the same time. Fields that are declared `volatile` are not subject
    to compiler and processor optimizations that assume access by a single thread.
    This ensures that the most up-to-date value is present in the field at all times.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`volatile`关键字来声明`_isCompleted`静态字段。`volatile`关键字表示一个字段可能会被多个线程同时修改。声明为`volatile`的字段不受编译器和处理器优化的影响，这些优化假定只有一个线程访问。这确保了字段中始终存在最新的值。
- en: Then we use a `SpinWait` version, which on each iteration prints a special flag
    that shows us whether a thread is going to switch to a blocked state. We run this
    thread for 5 milliseconds to see that. In the beginning, `SpinWait` tries to stay
    in user mode, and after about nine iterations, it begins to switch the thread
    to a blocked state. If we try to measure the CPU load with this version, we will
    not see any CPU usage in the Windows task manager.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`SpinWait`版本，每次迭代都打印一个特殊的标志，显示线程是否将切换到阻塞状态。我们运行这个线程5毫秒来观察。在开始时，`SpinWait`试图保持在用户模式下，大约经过九次迭代后，它开始将线程切换到阻塞状态。如果我们尝试使用这个版本来测量CPU负载，我们将在Windows任务管理器中看不到任何CPU使用率。
