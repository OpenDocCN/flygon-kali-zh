- en: Serverless Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器Java
- en: In recent years, the concept of microservices, which we've already looked at,
    has swept across the industry, quickly displacing the battle-tested application
    server with something smaller and leaner. Right on the heels of microservices
    comes a new concept--Functions as a Service, more commonly called **serverless**.
    In this chapter, you'll learn more about this new deployment model and build an
    application to demonstrate how to use it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，我们已经看到了微服务的概念，迅速取代了经过考验的应用服务器，变得更小更精简。紧随微服务之后的是一个新概念--函数即服务，通常称为**无服务器**。在本章中，您将了解更多关于这种新的部署模型，并构建一个应用程序来演示如何使用它。
- en: 'The application will be a simple notification system using the following technologies:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用将是一个简单的通知系统，使用以下技术：
- en: Amazon Web Services
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊网络服务
- en: Amazon Lambda
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊Lambda
- en: Amazon **Identity and Access Management** (**IAM**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊**身份和访问管理**（**IAM**）
- en: Amazon **Simple Notification System** (**SNS**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊**简单通知系统**（**SNS**）
- en: Amazon **Simple Email System** (**SES**)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊**简单邮件系统**（**SES**）
- en: Amazon DynamoDB
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊DynamoDB
- en: JavaFX
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX
- en: The options offered by cloud providers can be quite vast, and Amazon Web Services
    is no exception. In this chapter, we will attempt to use just enough of what AWS
    has to offer to help us build a compelling application as we wade into cloud-native
    application development.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云服务提供商提供的选项可能非常广泛，亚马逊网络服务也不例外。在本章中，我们将尝试充分利用AWS所提供的资源，帮助我们构建一个引人注目的应用程序，进入云原生应用程序开发。
- en: Getting started
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'Before we get to our application, we should spend some time getting a better
    understanding of the term **Function as a Service** (**FaaS**). The term itself
    is a continuation of the **blank** as a service trend we''ve seen for a few years
    now. There is a host of such terms and offerings, but the big three are **Infrastructure
    as a Service** (**IaaS**), **Platform as a Service** (**PaaS**), and **Software
    as a Service** (**SaaS**). Oftentimes, these three build on each other as seen
    in the following diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始应用之前，我们应该花一些时间更好地理解**函数作为服务**（**FaaS**）这个术语。这个术语本身是我们几年来看到的**作为服务**趋势的延续。有许多这样的术语和服务，但最重要的三个是**基础设施即服务**（**IaaS**）、**平台即服务**（**PaaS**）和**软件即服务**（**SaaS**）。通常情况下，这三者相互依赖，如下图所示：
- en: '![](img/d275ceea-af69-4cb5-92c3-ec49407acaca.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d275ceea-af69-4cb5-92c3-ec49407acaca.png)'
- en: The lowest level of the cloud computing offerings, Infrastructure as a Service
    providers, offers infrastructure-related assets **in the cloud**. Typically, this
    can be as simple as file storage, but usually means virtual machines. By using
    an Infrastructure as a Service provider, clients need not worry about buying,
    maintaining, or replacing hardware, as that is handled by the provider. Clients
    are billed, instead, only on resources used.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算提供商的最低级别是基础设施即服务提供商，提供**云中的**基础设施相关资产。通常情况下，这可能只是文件存储，但通常意味着虚拟机。通过使用基础设施即服务提供商，客户无需担心购买、维护或更换硬件，因为这些都由提供商处理。客户只需按使用的资源付费。
- en: Moving up the stack, Platform as a Service providers offer cloud-hosted application
    execution environments. This may include things such as an application server,
    a database server, a web server, and so on. The details of the physical environment
    are abstracted away, with customers specifying storage and RAM requirements. Some
    providers also allow the customer to choose the operating system, as this can
    have implications on the application stack, support tools, and more.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在平台作为服务提供商中，提供云托管的应用程序执行环境。这可能包括应用服务器、数据库服务器、Web服务器等。物理环境的细节被抽象化，客户可以指定存储和内存需求。一些提供商还允许客户选择操作系统，因为这可能会对应用程序堆栈、支持工具等产生影响。
- en: Software as a Service is a higher-level abstraction that doesn't focus on the
    hardware at all but, instead, offers hosted software that customers subscribe
    to, typically per user, and typically on a monthly or yearly basis. This is often
    seen in complicated business software, such as financial systems or human resource
    applications, but it is also seen with simpler systems, such as blogging software.
    The user simply subscribes and uses the software, leaving the installation and
    maintenance, including upgrades, to the provider. While this can reduce flexibility
    for the user (for example, it is often not possible to customize the software),
    it also reduces operational costs by pushing maintenance costs to the provider
    as well as guaranteeing, in most cases, access to the latest version of the software.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 软件即服务是一个更高级的抽象，根本不关注硬件，而是提供订阅的托管软件，通常按用户订阅，通常按月或年计费。这通常出现在复杂的商业软件中，如财务系统或人力资源应用程序，但也出现在更简单的系统中，如博客软件。用户只需订阅并使用软件，安装和维护（包括升级）都由提供商处理。虽然这可能会减少用户的灵活性（例如，通常无法定制软件），但它也通过将维护成本推给提供商以及在大多数情况下保证访问最新版本的软件来降低运营成本。
- en: There are several other variations on this type of service, such as **Mobile
    Backend as a Service** (**MBaas**) and **Database as a Service** (**DBaaS**).
    As the market continues to gain confidence in cloud computing, and as the internet
    speeds up while the prices go down, we are likely to see more and more of these
    types of systems developed, which brings us to our topic in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的服务还有几种其他变体，比如**移动后端作为服务**（**MBaas**）和**数据库作为服务**（**DBaaS**）。随着市场对云计算的信心增强，互联网速度加快，价格下降，我们很可能会看到更多这类系统的开发，这也是本章的主题所在。
- en: Function as a Service, or **serverless** computing, is the deployment of a small
    piece of code, very literally a function, that can be called from other applications,
    usually via some sort of trigger. Use cases include things such as image conversion,
    log analysis, and, as we will build in this chapter, notification systems.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 函数即服务，或者**无服务器**计算，是部署一个小段代码，非常字面上的一个函数，可以被其他应用程序调用，通常通过某种触发器。使用案例包括图像转换、日志分析，以及我们将在本章中构建的通知系统。
- en: Despite what the name **serverless** implies, there is actually a server involved,
    which only stands to reason; however, you, as an application developer, need not
    think about the server too deeply. In fact, as we'll see in this chapter, the
    only thing we need to worry about is how much memory our function will need. Everything
    else about the server is completely handled by the Function as a Service provider--the
    operating system, storage, networking, even starting and stopping the virtual
    machine are all handled for us by the provider.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管**无服务器**这个名字暗示着没有服务器，实际上确实有一个服务器参与其中，这是理所当然的；然而，作为应用程序开发人员，你不需要深入思考服务器。事实上，正如我们将在本章中看到的，我们唯一需要担心的是我们的函数需要多少内存。关于服务器的其他一切都完全由服务提供商处理--操作系统、存储、网络，甚至虚拟机的启动和停止都由提供商为我们处理。
- en: With that basic understanding of serverless, we need to pick a provider. As
    can be expected, there are a number of options--Amazon, Oracle, IBM, Red Hat,
    and more. Unfortunately, currently, there is no standardized means by which we
    can write a serverless system and deploy it to an arbitrary provider, so that
    means our solution will be necessarily tied to a specific provider, which will
    be **Amazon Web Services** (**AWS**), the dominant provider of cloud computing
    services. As mentioned in the introduction to this chapter, we use a number of
    AWS offerings, but the centerpiece will be AWS Lambda, Amazon's serverless computing
    offering.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有了对无服务器的基本理解，我们需要选择一个提供商。可以预料到，有许多选择--亚马逊、甲骨文、IBM、红帽等。不幸的是，目前还没有标准化的方式可以编写一个无服务器系统并将其部署到任意提供商，因此我们的解决方案将必然与特定的提供商绑定，这将是**亚马逊网络服务**（**AWS**），云计算服务的主要提供商。正如在本章的介绍中提到的，我们使用了许多AWS的产品，但核心将是AWS
    Lambda，亚马逊的无服务器计算产品。
- en: Let's jump in.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Planning the application
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划应用程序
- en: 'The application we will build is a very simple **cloud notification** service.
    In a nutshell, our function will **listen** for messages, then forward those messages
    to email addresses and phone numbers registered in the system. While our system
    will be somewhat contrived and certainly very simple, hopefully the more practical
    use cases are clear:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建的应用程序是一个非常简单的**云通知**服务。简而言之，我们的函数将**监听**消息，然后将这些消息转发到系统中注册的电子邮件地址和电话号码。虽然我们的系统可能有些牵强，当然非常简单，但希望更实际的用例是清楚的：
- en: Our system reminds students and/or parents about upcoming events
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的系统提醒学生和/或家长即将到来的事件
- en: Parents are notified when children enter or leave certain geographic boundaries
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当孩子进入或离开某些地理边界时，家长会收到通知
- en: Systems administrators are notified of certain events as they occur
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统管理员在发生某些事件时会收到通知
- en: 'The possibilities are quite vast. For our purposes here, we''ll develop not
    only the cloud-based system, but also a simple desktop application to simulate
    these types of scenarios. We''ll start where the fun is: in the cloud.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可能性非常广泛。对于我们在这里的目的，我们将开发不仅基于云的系统，还将开发一个简单的桌面应用程序来模拟这些类型的场景。我们将从有趣的地方开始：在云中。
- en: Building your first function
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建你的第一个函数
- en: The heart of Functions as a Service is, of course, the function. In Amazon Web
    Services, these are deployed using the service AWS Lambda. That's not the only
    AWS feature we'll use, as we've already mentioned. Once we have a function, we
    need a way to execute it. This is done via one or more triggers, and the function
    itself has tasks it needs to perform, so we'll demonstrate more service usage
    via API calls when we finally write the function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为服务的功能的核心当然是函数。在亚马逊网络服务中，这些函数是使用AWS Lambda服务部署的。这并不是我们将使用的唯一的AWS功能，正如我们已经提到的。一旦我们有了一个函数，我们需要一种执行它的方式。这是通过一个或多个触发器来完成的，函数本身有它需要执行的任务，所以当我们最终编写函数时，我们将通过API调用来演示更多的服务使用。
- en: 'It might be helpful at this point, given that our application is structured
    significantly differently than anything else we''ve looked at, to look at a system
    diagram:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，鉴于我们的应用程序的结构与我们所看到的任何其他东西都有很大不同，看一下系统图可能会有所帮助：
- en: '![](img/ef4a0f18-7a3b-4f35-9524-5b140ff96666.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef4a0f18-7a3b-4f35-9524-5b140ff96666.png)'
- en: 'Here''s the rough flow:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是大致的流程：
- en: A message is published to a topic in the Simple Notification System
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条消息将被发布到简单通知系统的主题中
- en: Once the permissions of the caller have been verified, the message is delivered
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦验证了呼叫者的权限，消息就会被传送
- en: Upon message delivery, a trigger is fired, delivering the message from the topic
    to our function
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息传送后，将触发一个触发器，将主题中的消息传送到我们的函数
- en: Inside the function, we'll query Amazon's **DynamoDB** to get the list of recipients
    that have signed up, providing either an email address, cell phone number, or
    both
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内部，我们将查询亚马逊的**DynamoDB**，获取已注册的收件人列表，提供电子邮件地址、手机号码，或两者都提供
- en: All of the cell phone numbers will be sent a text message via **Simple Notification
    System**
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的手机号码都将通过**简单通知系统**收到一条短信
- en: All the email addresses will be sent an email via **Simple Email Service**
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的电子邮件地址都将通过**简单电子邮件服务**发送电子邮件
- en: To start building the function, we need to create a Java project. Like many
    of our other projects, this will be a multi-module Maven project. In NetBeans,
    click on File | New Project | Maven | POM Project. We'll call the `CloudNotice`
    project.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建函数，我们需要创建一个Java项目。和我们的其他项目一样，这将是一个多模块的Maven项目。在NetBeans中，点击文件 | 新建项目 |
    Maven | POM项目。我们将称之为`CloudNotice`项目。
- en: The project will have three modules--one for the function, one for a test/demo
    client, and one for a shared API. To create the function module, right-click on
    the `Modules` node in the project explorer and select Create new module. In the
    window, select Maven | Java Application, click on Next, and set the project name
    to `function`. Repeat those steps and create a module called `api`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目将有三个模块--一个用于函数，一个用于测试/演示客户端，一个用于共享API。要创建函数模块，请在项目资源管理器中右键单击`Modules`节点，然后选择创建新模块。在窗口中，选择Maven
    | Java Application，然后单击下一步，将项目名称设置为`function`。重复这些步骤，创建一个名为`api`的模块。
- en: 'Before we go any further, we have to address the fact that, at the time of
    writing, AWS does not support Java 9\. We must, therefore, target Java 8 (or earlier)
    for anything we will ship to Lambda. To do that, we need to modify our `pom.xml`
    file like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们必须解决一个事实，即在撰写本文时，AWS不支持Java 9。因此，我们必须将我们将要交付给Lambda的任何东西都定位到Java 8（或更早）。为此，我们需要修改我们的`pom.xml`文件，如下所示：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Modify the POM for both `api` and `function`. Hopefully, AWS will support Java
    9 as quickly as possible after its release. Until then, we'll just have to target
    JDK 8.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`api`和`function`的POM。希望AWS在发布后尽快支持Java 9。在那之前，我们只能针对JDK 8。
- en: 'With our project configured, we''re ready to write our function. AWS Lambdas
    are implemented as `RequestHandler` instances:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好项目后，我们准备编写我们的函数。AWS Lambdas被实现为`RequestHandler`实例：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Ultimately, we want our function to be triggered when a message is delivered
    to an SNS topic, so we specify `SNSEvent` as the input type. We also specify `Context`.
    There are several things we can get from the `Context`, such as the request ID,
    memory limit, and others, but all we're interested in is getting a `LambdaLogger`
    instance. We could just write to standard out and standard error, and those messages
    would be saved in Amazon CloudWatch, but `LambdaLogger` allows us to respect system
    permissions and the container configuration.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们希望我们的函数在将消息传递到SNS主题时被触发，因此我们将`SNSEvent`指定为输入类型。我们还指定`Context`。我们可以从`Context`中获取几件事情，比如请求ID，内存限制等，但我们只对获取`LambdaLogger`实例感兴趣。我们可以直接写入标准输出和标准错误，这些消息将保存在Amazon
    CloudWatch中，但`LambdaLogger`允许我们尊重系统权限和容器配置。
- en: 'To make this compile, we need to add some dependencies to our application,
    so we add the following lines to `pom.xml`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其编译，我们需要向我们的应用程序添加一些依赖项，因此我们将以下行添加到`pom.xml`中：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can now start implementing the method as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始实现该方法了：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have a couple of new classes to look at, but to recap this code first, we
    will get a list of `Recipient` instances, which represents the numbers and email
    addresses that have been subscribed to our service. We then create a stream from
    the list, filtering for each recipient type, `SMS` or `Email`, extracting the
    value via `map()`, then collecting them in a `List`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些新的类要看，但首先要总结一下这段代码，我们将获得一个`Recipient`实例列表，它代表了已订阅我们服务的号码和电子邮件地址。然后我们从列表中创建一个流，过滤每个接收者类型，`SMS`或`Email`，通过`map()`提取值，然后将它们收集到一个`List`中。
- en: 'We will get to `CloudNoticeDAO` and `Recipient` in a moment, but let''s finish
    up with our function first. Once we have our lists, we can then send the messages
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们马上就会看到`CloudNoticeDAO`和`Recipient`，但首先让我们先完成我们的函数。一旦我们有了我们的列表，我们就可以像下面这样发送消息：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have encapsulated two more AWS APIs behind our own client classes, `SesClient`
    and `SnsClient`. This may seem a bit excessive, but these types of things tend
    to grow, and this approach puts us in a good position to manage that.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在自己的客户端类`SesClient`和`SnsClient`后面封装了另外两个AWS API。这可能看起来有点过分，但这些类型的东西往往会增长，这种方法使我们处于一个很好的位置来管理它。
- en: 'That leaves us with three APIs to look at: DynamoDB, Simple Email Service,
    and Simple Notification Service. We''ll take them in order.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们有三个API要看：DynamoDB，简单邮件服务和简单通知服务。我们将按顺序进行。
- en: DynamoDB
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DynamoDB
- en: Amazon DynamoDB is a NoSQL database, very much like MongoDB, which we looked
    at in [Chapter 9](../Text/50fd66f8-4865-4bc4-afdc-39f8cd5bf4f0.xhtml), *Taking
    Notes with Monumentum*, though DynamDB supports both document and key-value store
    models. A thorough comparison of the two, as well as a recommendation as to which
    to choose, is well outside the scope of our work here. We chose DynamoDB here,
    since it is already provisioned in the Amazon Web Service, and, thus, easily configured
    for our application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon DynamoDB是一个NoSQL数据库，非常类似于我们在[第9章](../Text/50fd66f8-4865-4bc4-afdc-39f8cd5bf4f0.xhtml)中看到的MongoDB，*使用Monumentum进行笔记*，尽管DynamoDB支持文档和键值存储模型。对这两者进行彻底比较，以及推荐选择哪一个，远远超出了我们在这里的工作范围。我们选择了DynamoDB，因为它已经在亚马逊网络服务中预配，因此很容易为我们的应用程序进行配置。
- en: 'To get started with the DynamoDB API, we need to add some dependencies to our
    application. In the `api` module, add this to the `pom.xml` file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用DynamoDB API，我们需要向我们的应用程序添加一些依赖项。在`api`模块中，将其添加到`pom.xml`文件中：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before we start writing our DAO class, let''s define our simple model. The
    DynamoDB API provides an object-relational mapping facility, much like the Java
    Persistence API or Hibernate, which will require a POJO and just a few annotations
    as we see here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写DAO类之前，让我们先定义我们的简单模型。DynamoDB API提供了一个对象关系映射工具，非常类似于Java Persistence
    API或Hibernate，它将需要一个POJO和一些注释，就像我们在这里看到的那样：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In our POJO, we declared three properties, `id`, `type`, and `address`, then
    annotated the getters with `@DyanoDBAttribute` to help the library understand
    how to map the object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的POJO中，我们声明了三个属性，`id`，`type`和`address`，然后用`@DyanoDBAttribute`注释了getter，以帮助库理解如何映射对象。
- en: Note that, while most of the property names match the field names in the table,
    you can override the property-to-field name mapping as we did with `id`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然大多数属性名称与表中的字段名称匹配，但您可以覆盖属性到字段名称的映射，就像我们在`id`中所做的那样。
- en: Before we can do anything with our data, we need to declare our table. Remember
    that DynamoDB is a NoSQL database, and we will use it as a document store just
    as we did with MongoDB. However, before we can store any data, we have to define
    **where** to put it. In MongoDB, we would create a collection. DynamoDB, though,
    still refers to this as a table, and, while it is technically schemaless, we do
    need to define a primary key, which is made up of a partition key and an optional
    sort key.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对数据进行任何操作之前，我们需要声明我们的表。请记住，DynamoDB是一个NoSQL数据库，我们将像在MongoDB中一样将其用作文档存储。然而，在我们存储任何数据之前，我们必须定义**放置**数据的位置。在MongoDB中，我们会创建一个集合。然而，DynamoDB仍然将其称为表，虽然它在技术上是无模式的，但我们确实需要定义一个主键，由分区键和可选的排序键组成。
- en: 'We create the table through the console. Once you''ve logged on to the AWS
    DynamoDB console, you will click on the Create Table button, which will bring
    you to a screen like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过控制台创建表。一旦您登录到AWS DynamoDB控制台，您将点击“创建表”按钮，这将带您到一个类似这样的屏幕：
- en: '![](img/f7632622-3d2a-490d-b1e1-bfba3ee7c75b.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7632622-3d2a-490d-b1e1-bfba3ee7c75b.png)'
- en: We will name our table `recipients`, and specify `_id` as the partition key.
    Click on the Create Table button and give AWS time to create the table.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将表命名为`recipients`，并指定`_id`为分区键。点击“创建表”按钮，让AWS创建表。
- en: 'We are now ready to start writing our DAO. In the API module, create a class
    called `CloudNoticeDAO`, to which we''ll add this constructor:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备开始编写我们的DAO。在API模块中，创建一个名为`CloudNoticeDAO`的类，我们将添加这个构造函数：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The local property is used to determine whether or not to use a local DynamoDB
    instance. This is here to support testing (as is the call to `verifyTables`),
    which we will explore in a moment. In production, our code will call `AmazonDynamoDBClientBuilder.defaultClient()`
    to acquire an instance of `AmazonDynamoDB`, which talks to the Amazon-hosted instance.
    Finally, we create an instance of `DynamoDBMapper`, which we'll use for our object
    mapping.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`local`属性用于确定是否使用本地DynamoDB实例。这是为了支持测试（就像调用`verifyTables`一样），我们将在下面探讨。在生产中，我们的代码将调用`AmazonDynamoDBClientBuilder.defaultClient()`来获取`AmazonDynamoDB`的实例，它与托管在亚马逊的实例进行通信。最后，我们创建了一个`DynamoDBMapper`的实例，我们将用它进行对象映射。'
- en: 'To facilitate creating a new `Recipient`, we will add this method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便创建一个新的`Recipient`，我们将添加这个方法：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This method will either create a new entry in the database, or update an existing
    one if the primary key already exists. In some scenarios, it might make sense
    to have separate save and update methods, but our use case is so simple that we
    don't need to worry about that. All we need to do is create the key value if it's
    missing. We do so by creating a random UUID, which helps us avoid key collisions
    should there be more than one process or application writing to the database.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法要么在数据库中创建一个新条目，要么在主键已经存在的情况下更新现有条目。在某些情况下，可能有必要有单独的保存和更新方法，但我们的用例非常简单，所以我们不需要担心这个。我们只需要在缺失时创建键值。我们通过创建一个随机UUID来实现这一点，这有助于我们避免在有多个进程或应用程序写入数据库时出现键冲突。
- en: 'Deleting a `Recipient` instance or getting a list of all of the `Recipient`
    instances in the database is just as simple:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`Recipient`实例或获取数据库中所有`Recipient`实例的列表同样简单：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Before we leave our DAO, let's take a quick look at how we can test it. Earlier,
    we noted the `local` parameter and the `verifyTables()` method, which exist for
    testing.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开DAO之前，让我们快速看一下我们如何测试它。之前，我们注意到了`local`参数和`verifyTables()`方法，这些方法存在于测试中。
- en: Generally speaking, most people will frown, and rightfully so, on adding methods
    to production classes just for testing. There's a difference between writing a
    class that is testable, and adding test methods to a class. I would agree that
    adding methods to a class just for testing is something that should be avoided,
    but I am violating that principle a little here for the sake of simplicity and
    brevity.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，大多数人都会对在生产类中添加方法进行测试感到不满，这是正确的。编写一个可测试的类和向类添加测试方法是有区别的。我同意为了简单和简洁起见，为了测试而向类添加方法是应该避免的，但我在这里违反了这个原则。
- en: 'The `verifyTables()` method checks to see if the table exists; if the table
    doesn''t, we call another method that will create it for us. While we manually
    created the production table using the preceding console, we could also let this
    method create that table for us. What approach you use is completely up to you.
    Be aware that there will be performance and permissions issues that will need
    to be addressed. That said, that method looks something like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`verifyTables()`方法检查表是否存在；如果表不存在，我们调用另一个方法来为我们创建它。虽然我们手动使用前面的控制台创建了生产表，但我们也可以让这个方法为我们创建那个表。您使用哪种方法完全取决于您。请注意，这将涉及需要解决的性能和权限问题。也就是说，该方法看起来像这样：'
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With the call to the `describeTable()` method, we can check to see if the table
    exists. In our test, this will fail every time, which will cause the table to
    be created. In production, should you use this method to create the table, this
    call will fail only on the first invocation. In `createRecipientTable()`, we can
    see how a table is created programmatically. We also wait until the table is active
    to make sure our reads and writes won't fail while the table is being created.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`describeTable()`方法，我们可以检查表是否存在。在我们的测试中，这将每次失败，这将导致表被创建。在生产中，如果您使用此方法创建表，这个调用只会在第一次调用时失败。在`createRecipientTable()`中，我们可以看到如何通过编程方式创建表。我们还等待表处于活动状态，以确保在创建表时我们的读写不会失败。
- en: 'Our tests, then, are very simple. For example, consider the following code
    snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的测试非常简单。例如，考虑以下代码片段：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This test helps us verify that our model mapping is correct, and that our DAO
    methods function as expected. You can see additional testing in the `CloudNoticeDaoTest`
    class, in the source bundle.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试帮助我们验证我们的模型映射是否正确，以及我们的DAO方法是否按预期工作。您可以在源代码包中的`CloudNoticeDaoTest`类中看到其他测试。
- en: Simple Email Service
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单邮件服务
- en: To send emails, we will use the Amazon Simple Email Service, or SES, which we
    will wrap in the `SesClient` class in the `api` module.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送电子邮件，我们将使用亚马逊简单电子邮件服务（SES），我们将在“api”模块的“SesClient”类中封装它。
- en: '**IMPORTANT**: Before you can send an email, you have to verify either your
    sending/from address or domain. The verification process is fairly simple, but
    how to do that is probably best left to Amazon''s documentation, which you can
    read here: [http://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html](http://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要**：在发送电子邮件之前，您必须验证发送/来自地址或域。验证过程非常简单，但如何做到这一点可能最好留给亚马逊的文档，您可以在这里阅读：[http://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html](http://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html)。'
- en: 'The Simple Email Service API is quite simple. We need to create a `Destination`,
    which tells the system to whom to send the emails; a `Message` that describes
    the message itself, including subject, body, and recipients; and a `SendEmailRequest`
    that ties everything together:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 简单电子邮件服务API非常简单。我们需要创建一个“Destination”，告诉系统要发送电子邮件给谁；一个描述消息本身的“Message”，包括主题、正文和收件人；以及将所有内容联系在一起的“SendEmailRequest”：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There is an important caveat though, which is in the preceding bolded code.
    SES limits the number of recipients per message to 50, so we need to take our
    list of email addresses and process them 50 at a time. We will do that using the
    `getChunkedEmailList()` method:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一个重要的警告，就是在前面加粗的代码中。SES将每封邮件的收件人数量限制为50，因此我们需要每次处理50个电子邮件地址的列表。我们将使用“getChunkedEmailList()”方法来做到这一点：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To find the number of groups, we divide the number of addresses by 50 and round
    up (for example, 254 addresses would get us 6 groups--5 of 50 and 1 of 4). Then,
    using an `IntStream` to count from 0 to the number of groups (exclusive), we extract
    sublists from the original list. Each of these lists is then collected into yet
    another `List`, giving us the nested `Collection` instances we see in the method
    signature.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到组的数量，我们将地址的数量除以50并四舍五入（例如，254个地址将得到6个组--50个中的5个和4个中的1个）。然后，使用“IntStream”从0到组数（不包括）进行计数，我们从原始列表中提取子列表。然后，将这些列表中的每一个收集到另一个“List”中，从而得到我们在方法签名中看到的嵌套的“Collection”实例。
- en: '**Design note**: Many developers will avoid using nested `Collection` instances
    like this, as it can quickly become difficult to understand what exactly the variable
    represents. It is considered by many to be a best practice in situations like
    this to create a new type to hold the nested data. For example, if we were to
    follow that advice here, we could create, perhaps, a new `Group` class that had
    a `List<String>` property to hold the group''s email addresses. We have not done
    so for the sake of brevity, but that would definitely be a good enhancement to
    this code.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计说明**：许多开发人员会避免像这样使用嵌套的“Collection”实例，因为很快就会变得难以理解变量到底代表什么。在这种情况下，许多人认为最好的做法是创建一个新类型来保存嵌套数据。例如，如果我们在这里遵循这个建议，我们可以创建一个新的“Group”类，它具有一个“List<String>”属性来保存组的电子邮件地址。出于简洁起见，我们没有这样做，但这绝对是对这段代码的一个很好的增强。'
- en: Once we've **chunked** our list, we can send the same `Message` to each group,
    and thus fulfill the API contract.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对列表进行了分块，我们可以将相同的“Message”发送给每个组，从而满足API合同。
- en: Simple Notification Service
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单通知服务
- en: 'We''ve already seen the Simple Notification System at work, at least in theory,
    as that is what delivers the outbound message to our function: a client of some
    sort publishes a message in a specific SNS topic. We have a subscription to that
    topic (I''ll show you how to create that later) that calls our method with the
    message for us to deliver. We will use the SNS API now to send text (or SMS) messages
    to the users who have subscribed a phone number to the system.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在理论上看到了简单通知系统的工作，至少是这样，因为它将出站消息传递给我们的函数：某种客户端在特定的SNS主题中发布消息。我们订阅了该主题（我将向您展示如何创建它），并调用我们的方法传递消息以便我们传递。我们现在将使用SNS
    API向已经订阅了电话号码的用户发送文本（或短信）消息。
- en: 'With SNS, to send a message to more than one phone number you must do so through
    a topic to which each number is subscribed. What we''ll do then is follow these
    steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SNS，要向多个电话号码发送消息，必须通过每个号码都订阅的主题来实现。然后，我们将按照以下步骤进行：
- en: Create a topic.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建主题。
- en: Subscribe all of the phone numbers.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅所有电话号码。
- en: Publish the message to the topic.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将消息发布到主题。
- en: Delete the topic.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除主题。
- en: 'If we use a persistent topic, we will likely get unpredictable results if we
    have more than one instance of the function running simultaneously. The method
    that orchestrates all of this work looks like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用持久主题，如果我们同时运行多个函数实例，可能会得到不可预测的结果。负责所有这些工作的方法看起来像这样：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To create a topic, we have the following method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建主题，我们有以下方法：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To subscribe the numbers to the topic, we have this method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要订阅主题中的数字，我们有这个方法：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Publishing a message is equally simple, as we see here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 发布消息同样简单，如下所示：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And finally, you can delete the topic with this simple method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用这个简单的方法删除主题：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All of these methods are clearly very simple, so the calls to the SNS API could
    be made directly inline in the calling code, but this wrapper does provide us
    with a way to hide the details of the API from our business code. This is more
    important, for example, in `createTopic()`, where extra classes are needed, but,
    to be consistent, we'll encapsulate everything behind our own facade.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法显然都非常简单，因此可以直接在调用代码中内联调用SNS API，但这个包装器确实为我们提供了一种将API的细节隐藏在业务代码之后的方法。例如，在“createTopic()”中更重要，需要额外的类，但为了保持一致，我们将把所有东西封装在我们自己的外观后面。
- en: Deploying the function
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署函数
- en: 'We have now completed our function and we''re almost ready to deploy it. To
    do that, we need to package it. AWS allows us to upload either a ZIP or a JAR
    file. We''ll use the latter. However, we have some external dependencies, so we''ll
    use the **Maven Shade** plugin to build a fat jar with our function and all of
    its dependencies. In the `function` module, add the following piece of code to
    the `pom.xml` file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了我们的函数，几乎可以准备部署它了。为此，我们需要打包它。AWS允许我们上传ZIP或JAR文件。我们将使用后者。但是，我们有一些外部依赖项，因此我们将使用**Maven
    Shade**插件来构建一个包含函数及其所有依赖项的fat jar。在`function`模块中，向`pom.xml`文件添加以下代码：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, when we build the project, we'll get a large file (about 9MB) in the target
    directory. It is this file that we will upload.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们构建项目时，我们将在目标目录中得到一个大文件（约9MB）。就是这个文件我们将上传。
- en: Creating a role
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建角色
- en: 'Before we can upload the function, we need to prepare our AWS environment by
    creating the appropriate role. Log on to AWS and navigate to the Identity and
    Access Management Console ([https://console.aws.amazon.com/iam](https://console.aws.amazon.com/iam)).
    In the navigation pane on the left, click on Roles, then click on Create new role:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在上传函数之前，我们需要通过创建适当的角色来准备我们的AWS环境。登录到AWS并转到身份和访问管理控制台（[https://console.aws.amazon.com/iam](https://console.aws.amazon.com/iam)）。在左侧的导航窗格中，点击“角色”，然后点击“创建新角色”：
- en: '![](img/902f3791-0390-4254-9898-b8c656dde857.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/902f3791-0390-4254-9898-b8c656dde857.png)'
- en: 'When prompted to select a role, we want to select AWS Lambda. On the next page,
    we will attach the policies:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示选择角色时，我们要选择AWS Lambda。在下一页上，我们将附加策略：
- en: '![](img/22029503-fc48-4f3a-878c-1f7ecb97284b.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22029503-fc48-4f3a-878c-1f7ecb97284b.png)'
- en: Click on Next, set the name to `j9bp`, and click on Create role.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“下一步”，将名称设置为`j9bp`，然后点击“创建角色”。
- en: Creating a topic
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建主题
- en: To make creating the function and the associated trigger simpler, we will create
    our topic first. Navigate to the SNS console. Given that not all AWS functionality
    is always available in every region, we need to choose a specific region. We can
    do that in the upper-left corner of the web page. If the region does not say N.
    Virginia, select it--US East (N. Virginia)--from the drop-down menu before continuing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使创建函数和相关触发器更简单，我们将首先创建我们的主题。转到SNS控制台。鉴于并非所有AWS功能在每个区域都始终可用，我们需要选择特定的区域。我们可以在网页的左上角进行选择。如果区域不是N.
    Virginia，请在继续之前从下拉菜单中选择US East（N. Virginia）。
- en: 'Once the region is set correctly, click on Topics in the left navigation bar,
    then click on Create new topic and specify the name as `cloud-notice`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 设置区域正确后，点击左侧导航栏中的“主题”，然后点击“创建新主题”，并将名称指定为`cloud-notice`：
- en: '![](img/c5ad91e2-4387-498f-b031-94b3d2f67433.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5ad91e2-4387-498f-b031-94b3d2f67433.png)'
- en: Deploying the function
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署函数
- en: 'We can now navigate to the Lambda console and deploy our function. We will
    start by clicking on the Create a lambda function button. We''ll be asked to select
    a blueprint. The only option suitable for a Java-based function is Blank Function.
    Once we click on that option, we are presented with the Configure Triggers screen.
    When you click on the empty square, you will be presented with a drop-down menu,
    as seen in this screenshot from the AWS console:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以转到Lambda控制台并部署我们的函数。我们将首先点击“创建lambda函数”按钮。我们将被要求选择一个蓝图。适用于基于Java的函数的唯一选项是空白函数。一旦我们点击该选项，就会出现“配置触发器”屏幕。当您点击空白方块时，将会出现一个下拉菜单，如AWS控制台中的此屏幕截图所示：
- en: '![](img/e1d99251-e9a1-4944-bed6-a1a6ae1b4d7f.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1d99251-e9a1-4944-bed6-a1a6ae1b4d7f.png)'
- en: 'You can either scroll down to find SNS, or enter `SNS` in the filter box as
    in the preceding screenshot. Either way, when you click on SNS in the list, you
    will be asked to select the topic to which you want to subscribe:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向下滚动以找到SNS，或者在过滤框中输入`SNS`，如前面的屏幕截图所示。无论哪种方式，当您在列表中点击SNS时，都会要求您选择要订阅的主题：
- en: '![](img/ac237c0d-a24c-431e-95c6-787008c68f90.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac237c0d-a24c-431e-95c6-787008c68f90.png)'
- en: 'Click on Next. We now need to specify the details of our function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“下一步”。现在我们需要指定函数的详细信息：
- en: '![](img/90f63289-4ee5-4ba1-995b-2aa8bbc775c4.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90f63289-4ee5-4ba1-995b-2aa8bbc775c4.png)'
- en: 'Scrolling down the page, we also need to specify the Lambda function handler
    and role. The Handler is the fully-qualified class name, followed by two colons,
    and the method name:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动页面时，我们还需要指定Lambda函数处理程序和角色。处理程序是完全限定的类名，后跟两个冒号和方法名：
- en: '![](img/6b62cb07-215c-485f-8750-b8a0ac9a5240.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b62cb07-215c-485f-8750-b8a0ac9a5240.png)'
- en: We now need to select the function archive by clicking on the upload button
    and selecting the jar file created by our Maven build. Click on Next, verify the
    details of the function, and then click on Create function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要通过点击上传按钮并选择由Maven构建创建的jar文件来选择函数存档。点击“下一步”，验证函数的详细信息，然后点击“创建函数”。
- en: We now have a usable AWS Lambda function. We can test it using the Lambda Console,
    but instead we'll build a small JavaFX application to do that, which will simultaneously
    test all of the service integrations, as well as demonstrate how a production
    application would interact with the function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可用的AWS Lambda函数。我们可以使用Lambda控制台进行测试，但我们将构建一个小的JavaFX应用程序来进行测试，这将同时测试所有服务集成，并演示生产应用程序如何与函数交互。
- en: Testing the function
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试函数
- en: To help test and demonstrate the system, we'll create a new module, called `manager`,
    in the `CloudNotice` project. To do that, click on the modules node in the NetBeans
    project explorer, then click on Create New Module... | Maven | JavaFX Application.
    Call the project `Manager` and click on Finish.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助测试和演示系统，我们将在`CloudNotice`项目中创建一个名为`manager`的新模块。要做到这一点，点击NetBeans项目资源管理器中的模块节点，然后点击“创建新模块...
    | Maven | JavaFX应用程序”。将项目命名为`Manager`，然后点击“完成”。
- en: I have renamed `MainApp` to `CloudNoticeManager`, `FXMLController` to `CloudNoticeManagerController`,
    and `Scene.fxml` to `manager.fxml`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我已将`MainApp`重命名为`CloudNoticeManager`，`FXMLController`重命名为`CloudNoticeManagerController`，`Scene.fxml`重命名为`manager.fxml`。
- en: 'Our `Application` class will look a little different than in previous JavaFX
    applications. Some of the AWS client APIs require that they be shut down explicitly
    when you are finished with them. Failure to do so means that our application won''t
    fully quit, leaving behind **zombie** processes that must be killed. To make sure
    we properly shut down our AWS clients, we need to add a cleanup method to our
    controller, which we''ll call from the `stop()` method in our application:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Application`类将与以前的JavaFX应用程序有所不同。一些AWS客户端API要求在完成后明确关闭它们。未能这样做意味着我们的应用程序不会完全退出，留下必须被终止的**僵尸**进程。为了确保我们正确关闭AWS客户端，我们需要在我们的控制器中添加一个清理方法，并从我们的应用程序的`stop()`方法中调用它：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, regardless of whether the user clicks on File | Exit or clicks on the Close
    button on the window, our AWS clients can be cleaned up correctly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论用户是点击文件|退出还是点击窗口上的关闭按钮，我们的AWS客户端都可以正确地进行清理。
- en: 'In terms of layout, there''s nothing new to discuss, so we''ll not dwell on
    that aspect here. This is what our manager app will look like:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局方面，没有什么新的可讨论的，所以我们不会在这方面详细讨论。这就是我们的管理应用程序将会是什么样子：
- en: '![](img/c6a2fe65-aebb-4ccf-a83b-d30bec8c4ef8.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6a2fe65-aebb-4ccf-a83b-d30bec8c4ef8.png)'
- en: We have a list of the subscribed recipients on the left, an area for adding
    and editing a recipient at the top right, and an area for sending a test message
    at the bottom right. We do have some interesting bindings, so let's take a look
    at this.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧是订阅接收者的列表，右上方是添加和编辑接收者的区域，右下方是发送测试消息的区域。我们有一些有趣的绑定，让我们来看看这些。
- en: 'First, in `CloudNoticeManagerController`, we need to declare some containers
    for our data, so we declare a number of `ObservableList` instances:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`CloudNoticeManagerController`中，我们需要声明一些数据的容器，因此我们声明了一些`ObservableList`实例：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These three `ObservableList` instances will back the UI controls matching their
    names. We will populate two of those lists (`type` is hardcoded) in `initalize()`
    as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个`ObservableList`实例将支持与它们的名称匹配的UI控件。我们将在`initalize()`中填充其中两个列表（`type`是硬编码）如下：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using our DAO and SES client, we fetch any already subscribed recipients, as
    well as any topics configured in the account. This will get *every* topic, so
    if you have a lot, this may be a problem, but this is just a demonstration application,
    so that should be fine here. Once we have these two lists, we add them to the
    `ObservableList` instances we created earlier, then associate the `List` with
    the appropriate UI controls.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的DAO和SES客户端，我们获取已经订阅的接收者，以及帐户中配置的任何主题。这将获取*每个*主题，所以如果你有很多，这可能是一个问题，但这只是一个演示应用程序，所以在这里应该没问题。一旦我们有了这两个列表，我们将它们添加到之前创建的`ObservableList`实例中，然后将`List`与适当的UI控件关联起来。
- en: 'To make sure the `Recipient` list displays correctly, we need to create a `CellFactory`
    as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保`Recipient`列表正确显示，我们需要创建一个`CellFactory`，如下所示：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Remember that, if the cell is empty, we need to set the text to null to clear
    out any previous value. Failure to do that will result, at some point, in a `ListView`
    with **phantom** entries.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果单元格为空，我们需要将文本设置为null以清除任何先前的值。未能这样做将导致`ListView`在某个时候出现**幻影**条目。
- en: 'Next, we need to update the edit controls when the user clicks on a `Recipient`
    in the list. We do this by adding a listener to the `selectedItemProperty`, which
    is run every time the selected item changes:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当用户点击列表中的`Recipient`时，我们需要更新编辑控件。我们通过向`selectedItemProperty`添加监听器来实现这一点，每当选定的项目更改时运行：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If `newRecipient` is not null, we set the value of the controls to the appropriate
    value. Otherwise, we clear the values.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`newRecipient`不为空，我们将控件的值设置为适当的值。否则，我们清除值。
- en: We now need to add handlers for the various buttons--the Add and Remove buttons
    above the `Recipient` list, and the `Save` and `Cancel` buttons in the two **form**
    areas on the right.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为各种按钮添加处理程序--在`Recipient`列表上方的添加和删除按钮，以及右侧两个**表单**区域中的`Save`和`Cancel`按钮。
- en: 'The UI control''s `onAction` property can be bound to the method in the class
    by editing the FXML directly, as shown here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: UI控件的`onAction`属性可以通过直接编辑FXML来绑定到类中的方法，如下所示：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It can also be bound to the method by editing the property in Scene Builder,
    as shown in the following screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过在Scene Builder中编辑属性来将其绑定到方法，如下面的屏幕截图所示：
- en: '![](img/ba0fd788-85bb-46f1-9eef-c5a71cb3ea43.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba0fd788-85bb-46f1-9eef-c5a71cb3ea43.png)'
- en: 'Either way, the method will look like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，该方法将如下所示：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We're adding a `Recipient`, so we create a new one, add it to our `ObservableList`,
    then tell the `ListView` to select this entry. Finally, we ask the `type` control
    to request focus so the user can easily change the value with the keyboard, if
    so desired. The new Recipient isn't saved to DynamoDB until the user clicks on
    Save, which we will look at in a moment.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在添加一个`Recipient`，因此我们创建一个新的`Recipient`，将其添加到我们的`ObservableList`，然后告诉`ListView`选择此条目。最后，我们要求`type`控件请求焦点，以便用户可以轻松地使用键盘更改值。新的Recipient直到用户点击保存才保存到DynamoDB，我们将在稍后讨论。
- en: 'When we delete a `Recipient`, we need to remove it from the UI as well as from
    DynamoDB:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们删除一个`Recipient`时，我们需要将其从UI和DynamoDB中删除：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Saving is a bit more complicated, but not much:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 保存有点复杂，但不多：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since we're not binding the values of the edit controls to the selected item
    in the list, we need to get the reference to the item, then copy the values from
    the controls to the model. Once that's done, we save it to the database via our
    DAO, then ask `ListView` to refresh itself so that any model changes are reflected
    in the list.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有将编辑控件的值绑定到列表中的选定项目，所以我们需要获取项目的引用，然后将控件的值复制到模型中。完成后，我们将其保存到数据库通过我们的DAO，然后要求`ListView`刷新自身，以便列表中反映任何模型更改。
- en: We aren't binding the controls to the item in the list as that leads to a slightly
    confusing user experience. If we did bind, as the user made changes to the model
    `ListView` would reflect those changes. It is conceivable that the user would
    then assume that the changes are being saved to the database when, in fact, they
    are not. That doesn't happen until the user clicks on Save. To avoid this confusion,
    and the loss of data, we have *not* bound the controls and manage the data manually.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有将控件绑定到列表中的项目，因为这会导致用户体验稍微混乱。如果我们进行绑定，当用户对模型进行更改时，`ListView`将反映这些更改。用户可能会认为更改已保存到数据库，而实际上并没有。直到用户点击保存才会发生。为了避免这种混淆和数据丢失，我们*没有*绑定控件，而是手动管理数据。
- en: 'To cancel the change, all we need to do is get a reference to the unchanged
    model from `ListView`, and copy its values over those in the edit controls:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消更改，我们只需要从`ListView`获取对未更改模型的引用，并将其值复制到编辑控件中：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'That leaves us with the **send a message** section of the UI. Thanks to our
    SNS wrapper API, these methods are very simple:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这留下了我们的UI中的**发送消息**部分。由于我们的SNS包装API，这些方法非常简单：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: From our desktop application, we can now add, edit, and remove recipients, as
    well as send test messages.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的桌面应用程序，我们现在可以添加、编辑和删除收件人，以及发送测试消息。
- en: Configuring your AWS credentials
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置您的AWS凭证
- en: Those paying very close attention may be asking a very important question--How
    do the AWS client libraries know how to log on to our account? Clearly, we need
    to tell them, and we have a few options.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 非常关注的人可能会问一个非常重要的问题--AWS客户端库如何知道如何登录到我们的账户？显然，我们需要告诉它们，而且我们有几个选项。
- en: The AWS SDK, when run locally, will check three places for the credentials--environment
    variables (`AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`), system properties
    (`aws.accessKeyId` and `aws.secretKey`), and the default credentials profiles
    file (`$HOME/.aws/credentials`). What credentials you use is up to you, but I
    will show you here how to configure the profiles file.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当本地运行AWS SDK时，将检查三个位置的凭证--环境变量（`AWS_ACCESS_KEY_ID`和`AWS_SECRET_ACCESS_KEY`）、系统属性（`aws.accessKeyId`和`aws.secretKey`）和默认凭证配置文件（`$HOME/.aws/credentials`）。您使用哪些凭证取决于您，但我将在这里向您展示如何配置配置文件。
- en: Just like a Unix or Windows system, your AWS account has a `root` user that
    has complete access to your system. It would be extremely imprudent to run any
    client code connected as this user. To avoid that, we need to create a user, which
    we can do on the Identity and Access Management console ([https://console.aws.amazon.com/iam](https://console.aws.amazon.com/iam)).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Unix或Windows系统一样，您的AWS账户有一个具有对系统完全访问权限的`root`用户。以此用户身份运行任何客户端代码将是非常不慎重的。为了避免这种情况，我们需要创建一个用户，我们可以在身份和访问管理控制台上完成（[https://console.aws.amazon.com/iam](https://console.aws.amazon.com/iam)）。
- en: 'Once you''ve logged on, click on Users on the left, then Add user at the top,
    the result of which is shown in the following screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，点击左侧的“用户”，然后点击顶部的“添加用户”，结果如下截图所示：
- en: '![](img/cea72534-8eff-4149-bd1d-d768aaaeafa8.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cea72534-8eff-4149-bd1d-d768aaaeafa8.png)'
- en: 'Click on Next: Permissions and check the entry in the Group list for our role,
    `j9bp`. Click on Next: Review, then Create User. This will take you to the Add
    user screen, which should have a success message box. The important part is the
    user information listed toward the bottom of the screen. On the right side of
    this table, you should see the columns Access key ID and Secret access key. Click
    on Show on the access key to reveal the value. Make a note of both of these, as
    there is no way to retrieve the access key once you leave this page. If you lose
    it, you will have to generate a new set of keys, which will break any other application
    using the old credentials.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“下一步：权限”，并在组列表中检查我们角色`j9bp`的条目。点击“下一步：审阅”，然后创建用户。这将带您到添加用户屏幕，屏幕底部列出了用户信息。在表格的右侧，您应该看到访问密钥ID和秘密访问密钥列。点击访问密钥上的“显示”以显示值。记下这两个值，因为一旦离开此页面，就无法检索访问密钥。如果丢失，您将不得不生成新的密钥对，这将破坏使用旧凭证的任何其他应用程序。
- en: '![](img/2231a001-356f-41da-8b39-bedeed92c4b2.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2231a001-356f-41da-8b39-bedeed92c4b2.png)'
- en: 'In a text editor, we need to create the `~/.aws/credentials` file. On a Unix
    system, that may be `/home/jdlee/.aws`, and on a Windows machine that will be
    something like `C:\Users\jdlee\aws`. The credentials file should look something
    like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中，我们需要创建`~/.aws/credentials`文件。在Unix系统上，可能是`/home/jdlee/.aws`，在Windows机器上可能是`C:\Users\jdlee\aws`。凭证文件应该看起来像这样：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the same directory, we need to create another file called `config`. We''ll
    use this file to tell the SDK which region we want to work in:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个目录中，我们需要创建另一个名为`config`的文件。我们将使用这个文件告诉SDK我们想要在哪个地区工作：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When the AWS clients start up now, they will default to connecting as the `j9bp`
    user in the `us-east-1` region. Should you need to override that, you can either
    edit this file or set the environment variables or system properties noted above
    in the section, *Configuring your AWS Credentials*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当AWS客户端启动时，它们将默认连接到`us-east-1`地区的`j9bp`用户。如果需要覆盖这一点，您可以编辑此文件，或者设置上面“配置您的AWS凭证”部分中提到的环境变量或系统属性。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've done it! We've created, many of us, our very first AWS Lambda function,
    and it really wasn't all that difficult. It is a simple application, of course,
    but I hope you can see how this type of application could be very useful. Using
    this as a starting point, you can write systems, with the help of a mobile application,
    to help keep track of your family's location. Using embedded devices such as Raspberry
    PI, for example, you can build devices to track inventory as it is shipped across
    the country, reporting location, speed, environmental conditions, sudden drops
    or impacts, and so on. A piece of software running on a server could constantly
    report various metrics about the system, such as CPU temperature, free disk space,
    memory allocated, system load, and so on. Your options are limited only by your
    imagination.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做到了！我们中的许多人创建了我们的第一个AWS Lambda函数，而且真的并不那么困难。当然，这是一个简单的应用程序，但我希望你能看到这种类型的应用程序可能非常有用。以此为起点，你可以编写系统，借助移动应用程序，帮助跟踪你家人的位置。例如，你可以使用树莓派等嵌入式设备，构建设备来跟踪随着货物在全国范围内的运输情况，报告位置、速度、环境条件、突然的下降或冲击等。在服务器上运行的软件可以不断报告系统的各种指标，如CPU温度、空闲磁盘空间、分配的内存、系统负载等等。你的选择只受你的想象力限制。
- en: To wrap up, let's take a quick look back at what we've learned. We learned about
    some of the various **... as a service** systems that are being offered today,
    and what **serverless** really means and why it may appeal to us as application
    developers. We learned how to configure various Amazon Web Services offerings,
    including Identity and Access Management, Simple Notification System, Simple Email
    Service, and, of course Lambda, and we learned how to write an AWS Lambda function
    in Java and how to deploy it to the service. And finally, we learned how to configure
    triggers that would tie an SNS publish/subscribe topic to our Lambda function.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，让我们快速回顾一下我们学到的东西。我们了解了一些当今提供的各种“...作为服务”系统，以及“无服务器”到底意味着什么，以及为什么它可能吸引我们作为应用程序开发人员。我们学会了如何配置各种亚马逊网络服务，包括身份和访问管理、简单通知系统、简单电子邮件服务，当然还有Lambda，我们学会了如何用Java编写AWS
    Lambda函数以及如何部署它到服务上。最后，我们学会了如何配置触发器，将SNS发布/订阅主题与我们的Lambda函数联系起来。
- en: There's no denying that our application is somewhat simple, and there's no way
    in the space of a single chapter to make you an expert in all that Amazon Web
    Services or any other cloud provider has to offer. Hopefully, you have enough
    to get you going--and get you excited--about writing cloud-based applications
    using Java. For those wanting to go deeper, there are a number of great books,
    web pages, and so on to help you delve deeper into this rapidly changing and expanding
    area. In our next chapter, we'll return from the cloud and turn our attention
    to another great space for Java developers--your mobile phone.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，我们的应用程序有些简单，而在单一章节的空间内，无法让你成为亚马逊网络服务或任何其他云服务提供商所提供的所有内容的专家。希望你有足够的知识让你开始，并让你对使用Java编写基于云的应用程序感到兴奋。对于那些想要深入了解的人，有许多优秀的书籍、网页等可以帮助你更深入地了解这个快速变化和扩展的领域。在我们的下一章中，我们将离开云，把注意力转向另一个对Java开发人员来说非常重要的领域——你的手机。
