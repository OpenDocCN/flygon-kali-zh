- en: Chapter 3. Configuring Docker Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。配置Docker容器
- en: In the previous chapter, we saw all the different commands available in Docker.
    We took a look at examples covering how to pull images, run containers, attach
    images to containers, commit, and push an image to the repositories. We also learned
    how to write Dockerfiles to make building an image a repeatable process.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了Docker中所有可用的不同命令。我们看了一些示例，涵盖了如何拉取镜像、运行容器、将镜像附加到容器、提交并将镜像推送到存储库的过程。我们还学习了如何编写Dockerfile，使构建镜像成为一个可重复的过程。
- en: 'In this chapter, we will look closer at gaining control over how our containers
    run. Although Docker containers are sandboxed, this doesn''t prevent a stray rogue
    process in one of the containers from hogging the resources available to other
    containers, including the host. For instance, beware of this command (don''t run
    it):'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更仔细地了解如何控制容器的运行方式。尽管Docker容器被隔离，但这并不能阻止其中一个容器中的流浪进程占用其他容器（包括主机）可用的资源。例如，要小心这个命令（不要运行它）：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You would fork bomb the container as well as the host you run it on by running
    the preceding command.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行前面的命令，您将fork bomb容器以及运行它的主机。
- en: 'The Wikipedia definition of a *fork bomb* is as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*fork bomb*的维基百科定义如下：'
- en: '*"In computing, a fork bomb is a denial-of-service attack wherein a process
    continually replicates itself to deplete available system resources, causing resource
    starvation and slowing or crashing the system."*'
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"在计算机中，fork bomb是一种拒绝服务攻击，其中一个进程不断复制自身以耗尽可用的系统资源，导致资源匮乏并减慢或崩溃系统。"*'
- en: Since Docker is expected to be used in production, the possibility of one container
    stalling all others would be fatal. So there are mechanisms to limit the amount
    of resources that a container can take ownership of, which we will be looking
    at in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于预计Docker将用于生产，一个容器使所有其他容器停滞的可能性将是致命的。因此，有机制来限制容器可以拥有的资源量，我们将在本章中进行讨论。
- en: In the previous chapter, we had a basic introduction to volumes when we talked
    about the `docker` run. We will now explore volumes in more detail and discuss
    why they are important and how to use them best. We will also try to change the
    storage driver being used by the `docker` daemon.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当我们谈论`docker` run时，我们对卷进行了基本介绍。现在我们将更详细地探讨卷，并讨论它们为什么重要以及如何最好地使用它们。我们还将尝试更改`docker`守护程序使用的存储驱动程序。
- en: Another aspect is networking. While inspecting running containers, you might
    have noticed that Docker randomly chooses a subnet and allots an IP address (the
    default is usually the range 172.17.42.0/16). We will try to override this by
    setting our own subnet and explore other options available that help manage the
    networking aspects. In many scenarios, we will need to communicate between containers
    (imagine one container running your application and another running your database).
    Since IP addresses are not available at build time, we need a mechanism to dynamically
    discover the services running in other containers. We will be looking at ways
    to achieve this, both when the containers are running in the same host and when
    they are running in different hosts.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方面是网络。在检查运行中的容器时，您可能已经注意到Docker会随机选择一个子网并分配一个IP地址（默认通常是范围172.17.42.0/16）。我们将尝试通过设置自己的子网来覆盖这一点，并探索其他可用的帮助管理网络方面的选项。在许多情况下，我们需要在容器之间进行通信（想象一个容器运行您的应用程序，另一个容器运行您的数据库）。由于IP地址在构建时不可用，我们需要一种机制来动态发现在其他容器中运行的服务。我们将探讨实现这一点的方法，无论容器是在同一主机上运行还是在不同主机上运行。
- en: 'In short, in this chapter, we will be covering the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在本章中，我们将涵盖以下主题：
- en: Constraining resources
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制资源
- en: CPU
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU
- en: RAM
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAM
- en: Storage
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储
- en: Managing data in containers with volumes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用卷在容器中管理数据
- en: Configuring Docker to use a different storage driver
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Docker使用不同的存储驱动程序
- en: Configuring networking
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置网络
- en: Port forwarding
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口转发
- en: A custom IP address range
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义IP地址范围
- en: Linking containers
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接容器
- en: Linking within the same host using container links
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器链接在同一主机内进行链接
- en: Cross-host linking using ambassador containers
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用大使容器进行跨主机链接
- en: Constraining resources
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约束资源
- en: It is imperative for any tool that promises sandboxing capabilities to provide
    a mechanism to constrain resource allocation. Docker provides mechanisms to limit
    the amount of CPU memory and RAM that a container can use when it is being started.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何承诺提供沙箱功能的工具来说，提供一种约束资源分配的机制是至关重要的。Docker在容器启动时提供了限制CPU内存和RAM使用量的机制。
- en: Setting CPU share
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置CPU份额
- en: 'The amount of CPU share a container takes up can be controlled using the `-c`
    option in the `docker run` command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`docker run`命令中的`-c`选项来控制容器所占用的CPU份额：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The value, `10`, is the relative priority given to this container with respect
    to other containers. By default, all containers get the same priority, and hence
    the same ratio of CPU processing cycles, which you can check out by running `$
    cat /sys/fs/cgroup/cpu/docker/cpu.shares` (add SSH to the boot2Docker VM before
    doing this if you are on OS X or Windows). However, you can give your own priority
    values when you run containers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 值`10`是相对于其他容器给予该容器的优先级。默认情况下，所有容器都具有相同的优先级，因此具有相同的CPU处理周期比率，您可以通过运行`$ cat /sys/fs/cgroup/cpu/docker/cpu.shares`来检查（如果您使用的是OS
    X或Windows，请在执行此操作之前将SSH添加到boot2Docker VM）。但是，您可以在运行容器时提供自己的优先级值。
- en: Is it possible to set CPU shares when a container is already running? Yes. Edit
    the file at `/sys/fs/cgroup/cpu/docker/<container-id>/cpu.shares` and enter the
    priority you want to give it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器已经运行时设置CPU份额是否可能？是的。编辑`/sys/fs/cgroup/cpu/docker/<container-id>/cpu.shares`文件，并输入您想要给它的优先级。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the location mentioned doesn't exist, find out where `cpu` `cgroup` is mounted
    by running the command `$ grep -w cgroup /proc/mounts | grep -w cpu`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提到的位置不存在，请通过运行命令`$ grep -w cgroup /proc/mounts | grep -w cpu`找出`cpu` `cgroup`挂载的位置。
- en: However, this is a hack, and might change in the future if Docker decides to
    change the way CPU sharing is implemented.More information about this can be found
    at [https://groups.google.com/forum/#!topic/docker-user/-pP8-KgJJGg](https://groups.google.com/forum/#!topic/docker-user/-pP8-KgJJGg).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是一个hack，如果Docker决定改变CPU共享的实现方式，将来可能会发生变化。有关更多信息，请访问[https://groups.google.com/forum/#!topic/docker-user/-pP8-KgJJGg](https://groups.google.com/forum/#!topic/docker-user/-pP8-KgJJGg)。
- en: Setting memory limit
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置内存限制
- en: 'Similarly, the amount of RAM that a container is allowed to consume can also
    be limited while starting the container:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，容器被允许消耗的RAM量在启动容器时也可以受到限制：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `unit` can be `b`, `k`, `m`, or `g`, representing bytes, kilobytes, megabytes,
    and gigabytes, respectively).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`unit`可以是`b`、`k`、`m`或`g`，分别表示字节、千字节、兆字节和千兆字节。
- en: 'An example of a unit can be represented as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 单位的示例可以表示如下：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This sets a memory limit of 1 GB for the container.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这为容器设置了1GB的内存限制。
- en: 'As in the case with limiting CPU shares, you can check the default memory limit
    by running this line of code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与限制CPU份额一样，您可以通过运行以下代码来检查默认的内存限制：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As the filename states, the preceding code prints the limit in bytes. The value
    shown in the output corresponds to 1.8 x 1010 gigabytes, which practically means
    that there is no limit.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如文件名所示，前面的代码以字节为单位打印限制。输出中显示的值对应于1.8 x 1010千字节，这实际上意味着没有限制。
- en: Is it possible to set a memory limit when a container is already running?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器已经运行时设置内存限制是否可能？
- en: 'As with CPU shares, memory limit is enforced by the `cgroup` file, which means
    that we can change the limit on the fly by changing the value of the container''s
    `cgroup` memory file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与CPU份额一样，内存限制是通过`cgroup`文件强制执行的，这意味着我们可以通过更改容器的`cgroup`内存文件的值来动态更改限制：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the location of the `cgroup` file doesn't exist, find out where the file
    is mounted by running `$ grep -w cgroup /proc/mounts | grep -w memory`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`cgroup`文件的位置不存在，请通过运行`$ grep -w cgroup /proc/mounts | grep -w memory`找出文件的挂载位置。
- en: This is also a hack, and might change in the future if Docker decides to change
    the way memory limiting is internally implemented.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个黑客，如果Docker决定改变内部实现内存限制的方式，可能会在将来发生变化。
- en: More information about this can be found at [https://groups.google.com/forum/#!topic/docker-user/-pP8-KgJJGg](https://groups.google.com/forum/#!topic/docker-user/-pP8-KgJJGg).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此更多信息，请访问[https://groups.google.com/forum/#!topic/docker-user/-pP8-KgJJGg](https://groups.google.com/forum/#!topic/docker-user/-pP8-KgJJGg)。
- en: Setting a storage limit on the virtual filesystem (Devicemapper)
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在虚拟文件系统（Devicemapper）上设置存储限制
- en: Limiting disk usage can be a bit tricky. There is no direct way to limit the
    amount of disk space a container can use. The default storage driver, AUFS, doesn't
    support disk quotas, at least not without hacks (the difficulty is because AUFS
    does not have its own block device. Visit [http://aufs.sourceforge.net/aufs.html](http://aufs.sourceforge.net/aufs.html)
    for in-depth information on how AUFS works). At the time of writing this book,
    Docker users who need disk quota opt for the `devicemapper` driver, which will
    allow each container to use up to a certain amount of disk space. But a more generic
    mechanism that works across storage drivers is under progress and may be introduced
    in future releases.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 限制磁盘使用可能有点棘手。没有直接的方法来限制容器可以使用的磁盘空间的数量。默认存储驱动程序AUFS不支持磁盘配额，至少没有没有黑客（困难是因为AUFS没有自己的块设备。访问[http://aufs.sourceforge.net/aufs.html](http://aufs.sourceforge.net/aufs.html)以获取有关AUFS工作原理的深入信息）。在撰写本书时，需要磁盘配额的Docker用户选择`devicemapper`驱动程序，该驱动程序允许每个容器使用一定量的磁盘空间。但是，正在进行跨存储驱动程序的更通用机制，并且可能会在将来的版本中引入。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `devicemapper` driver is a Linux kernel framework used to map block devices
    to higher-level virtual block devices.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`devicemapper`驱动程序是用于将块设备映射到更高级虚拟块设备的Linux内核框架。'
- en: The `devicemapper` driver creates a `thin` pool of storage blocks based on two
    block devices (think of them as virtual disks), one for data and another for metadata.
    By default, these block devices are created by mounting sparse files as loopback
    devices.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`devicemapper`驱动程序基于两个块设备（将它们视为虚拟磁盘），一个用于数据，另一个用于元数据，创建一个存储块的`thin`池。默认情况下，这些块设备是通过将稀疏文件挂载为回环设备来创建的。'
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A **sparse file** is a file that contains mostly empty space. So a sparse file
    of 100 GB might actually just contain a few bytes in the beginning and the end
    (and occupy just these bytes on the disk), and yet be visible to an application
    as a 100 GB file. When reading sparse files, the filesystem transparently converts
    the empty blocks into real blocks filled with zero bytes at runtime. It tracks
    the location of the written and empty blocks through the file's metadata. In UNIX-like
    operating systems, a loopback device is a pseudo-device that makes a file accessible
    as a block device.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**稀疏文件**是一个文件，其中大部分是空白空间。因此，100 GB的稀疏文件实际上可能只包含一点字节在开头和结尾（并且只占据磁盘上的这些字节），但对应用程序来说，它可能是一个100
    GB的文件。在读取稀疏文件时，文件系统会在运行时将空块透明地转换为实际填充了零字节的实际块。它通过文件的元数据跟踪已写入和空块的位置。在类UNIX操作系统中，回环设备是一个伪设备，它使文件作为块设备可访问。'
- en: A `thin` pool is called so because it only marks storage blocks as used (from
    the pool) when you actually write to the blocks. Each container is provisioned
    a base thin device of a certain size, and the container is not allowed to accumulate
    data more than that size limit.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: “薄”池之所以被称为“薄”，是因为只有在实际写入块时，它才将存储块标记为已使用（来自池）。每个容器都被配置了一个特定大小的基础薄设备，容器不允许累积超过该大小限制的数据。
- en: What are the default limits? The default limit for the `thin` pool is 100 GB.
    But since the loopback device used for this pool is a sparse file, it will initially
    not take up this much space.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 默认限制是什么？“薄”池的默认限制为100 GB。但由于用于此池的回环设备是稀疏文件，因此最初不会占用这么多空间。
- en: The default size limit for the base device created for each container and image
    is 10 GB. Again, since this is sparse, it will not initially take up this much
    space on the physical disk. However, the amount of space it takes up increases
    with the increase in the size limit because, the larger the size of the block
    device, the greater is the (virtual) size of the sparse file, and the metadata
    it needs to store is more.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个容器和镜像创建的基础设备的默认大小限制为10 GB。同样，由于这是稀疏的，因此最初不会占用物理磁盘上的这么多空间。但是，随着大小限制的增加，它占用的空间也会增加，因为块设备的大小越大，稀疏文件的（虚拟）大小就越大，需要存储的元数据也越多。
- en: How can you change these default values? You can change these options using
    the `--storage-opts` option, which is available when running the `docker` daemon,
    with the `dm` (for `devicemapper`) prefix.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如何更改这些默认值？您可以在运行`docker`守护程序时使用`--storage-opts`选项更改这些选项，该选项带有`dm`（用于`devicemapper`）前缀。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before running any of the commands in this section, back up all your images
    with `docker save` and stop the `docker` daemon. It might also be wise to completely
    remove `/var/lib/docker` (the path where Docker stores image data).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行本节中的任何命令之前，请使用`docker save`备份所有镜像并停止`docker`守护程序。完全删除`/var/lib/docker`（Docker存储图像数据的路径）可能也是明智的。
- en: Devicemapper configurations
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Devicemapper配置
- en: 'The various configurations available are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的各种配置如下：
- en: '`dm.basesize`: This specifies the size of the base device, which is used by
    containers and images. By default, this is set to 10 GB. The device created is
    sparse, so it will not initially occupy 10 GB. Instead, it will fill up as and
    when data is written into it, until it reaches the 10 GB limit:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dm.basesize`：这指定了基础设备的大小，容器和镜像将使用它。默认情况下，这被设置为10 GB。创建的设备是稀疏的，因此最初不会占用10 GB。相反，它将随着数据写入而填满，直到达到10
    GB的限制。'
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`dm.loopdatasize`: This is the size of the `thin` pool. The default size is
    100 GB. It is to be noted that this file is sparse, so it will not initially take
    up this space; instead, it will fill up gradually as more and more data is written
    into it:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dm.loopdatasize`：这是“薄”池的大小。默认大小为100 GB。需要注意的是，这个文件是稀疏的，因此最初不会占用这个空间；相反，随着越来越多的数据被写入，它将逐渐填满：'
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`dm.loopmetadatasize`: As mentioned earlier, two block devices are created,
    one for data and another for metadata. This option specifies the size limit to
    use when creating this block device. The default size is 2 GB. This file is sparse
    too, so it will not initially take up the entire size. The recommended minimum
    size is 1 percent of the total pool size:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dm.loopmetadatasize`：如前所述，创建了两个块设备，一个用于数据，另一个用于元数据。此选项指定创建此块设备时要使用的大小限制。默认大小为2
    GB。这个文件也是稀疏的，因此最初不会占用整个大小。建议的最小大小是总池大小的1％：'
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`dm.fs`: This is the filesystem type to use for the base device. The `ext4`
    and `xfs` filesystems are supported, although `ext4` is taken by default:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dm.fs`：这是用于基础设备的文件系统类型。支持`ext4`和`xfs`文件系统，尽管默认情况下采用`ext4`：'
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`dm.datadev`: This specifies a custom block device to use (instead of loopback)
    for the `thin` pool. If you are using this option, it is recommended to specify
    block devices for both data and metadata to completely avoid using the loopback
    device:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dm.datadev`：这指定要使用的自定义块设备（而不是回环）用于`thin`池。如果您使用此选项，建议同时为数据和元数据指定块设备，以完全避免使用回环设备：'
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are more options available, along with a neat explanation of how all of
    this works at [https://github.com/docker/docker/tree/master/daemon/graphdriver/devmapper/README.md](https://github.com/docker/docker/tree/master/daemon/graphdriver/devmapper/README.md).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多选项可用，以及关于所有这些工作原理的清晰解释，请参阅[https://github.com/docker/docker/tree/master/daemon/graphdriver/devmapper/README.md](https://github.com/docker/docker/tree/master/daemon/graphdriver/devmapper/README.md)。
- en: Another great resource is a blog post on resizing containers by Docker contributor
    Jérôme Petazzoni at [http://jpetazzo.github.io/2014/01/29/docker-device-mapper-resize/](http://jpetazzo.github.io/2014/01/29/docker-device-mapper-resize/).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的资源是Docker贡献者Jérôme Petazzoni在[http://jpetazzo.github.io/2014/01/29/docker-device-mapper-resize/](http://jpetazzo.github.io/2014/01/29/docker-device-mapper-resize/)上发布的有关调整容器大小的博文。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you switch storage drivers, the older containers and images will no longer
    be visible.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果切换存储驱动程序，旧容器和图像将不再可见。
- en: 'At the beginning of this section, it was mentioned that there is a possibility
    to have quotas and still use AUFS through a hack. The hack involves creating a
    loopback filesystem based on the `ext4` filesystem on demand and bind mounting
    it as a volume specifically for the container:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开头提到了有可能通过一个黑客手段实现配额并仍然使用AUFS。这个黑客手段涉及根据需要创建基于`ext4`文件系统的回环文件系统，并将其作为容器的卷进行绑定挂载：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can now bind mount the `$DB_DIR` directory to the container with the `-v`
    option of the `docker run` command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用`docker run`命令的`-v`选项将`$DB_DIR`目录绑定到容器：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Managing data in containers with volumes
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用卷管理容器中的数据
- en: 'Some salient features of a volume in Docker are mentioned as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Docker卷的一些显着特点如下所述：
- en: A volume is a directory that is separated from the container's `root` filesystem.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷是与容器的`root`文件系统分开的目录。
- en: It is managed directly by the `docker` daemon and can be shared across containers.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它由`docker`守护程序直接管理，并可以在容器之间共享。
- en: A volume can also be used to mount a directory of the host system inside a container.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷还可以用于在容器内挂载主机系统的目录。
- en: Changes made to a volume will not be included when an image is updated from
    a running container.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对卷进行的更改不会在从运行中的容器更新图像时包含在内。
- en: Since a volume is outside the filesystem of the container, it doesn't have the
    concept of data layers or snapshots. Hence, reads and writes happen directly on
    the volume.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于卷位于容器文件系统之外，它没有数据层或快照的概念。因此，读取和写入直接在卷上进行。
- en: If multiple containers use the same volume, the volume persists until there
    is at least one container using it.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果多个容器使用相同的卷，则卷将持久存在，直到至少有一个容器使用它。
- en: 'Creating a volume is easy. Just start a container with the `-v` option:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建卷很容易。只需使用`-v`选项启动容器：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now note that volumes have no `ID` parameter, so you cannot exactly name a volume
    like you name a container or tag an image. However, the clause that says that
    a volume persists until at least one container uses it can be exploited, which
    introduces the concept of data-only containers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请注意，卷没有`ID`参数，因此您无法像命名容器或标记图像一样确切地命名卷。但是，可以利用一个容器使用它至少一次的条件来使卷持久存在，这引入了仅包含数据的容器的概念。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Since Docker version 1.1, if you so wish, you can bind mount the whole filesystem
    of the host to a container using the -v option, like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 自Docker版本1.1以来，如果您愿意，可以使用`-v`选项将主机的整个文件系统绑定到容器，就像这样：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: However, it is forbidden to mount to / of the container, so you cannot replace
    the `root` filesystem of the container, for security reasons.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，禁止挂载到容器的/，因此出于安全原因，您无法替换容器的`root`文件系统。
- en: Data-only container
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅数据容器
- en: A data-only container is a container that does nothing except exposing a volume
    that other data-accessing containers can use. Data-only containers are used to
    prevent volumes from being destroyed if containers accessing the volume stop or
    crash due to an accident.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 数据专用容器是一个除了公开其他数据访问容器可以使用的卷之外什么也不做的容器。数据专用容器用于防止容器访问卷停止或由于意外崩溃而被销毁。
- en: Using volumes from another container
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用另一个容器的卷
- en: Once we start a container with a `-v` option, we have created a volume. We can
    share the volumes created by a container with other containers using the `--volumes-from`
    option. Possible use cases of this option can be backing up databases, processing
    logs, performing operations on user data, and so on.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用`-v`选项启动容器，就创建了一个卷。我们可以使用`--volumes-from`选项与其他容器共享由容器创建的卷。此选项的可能用例包括备份数据库、处理日志、对用户数据执行操作等。
- en: Use case – MongoDB in production on Docker
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例 - 在Docker上生产中使用MongoDB
- en: As a use case, say you want to use **MongoDB** in your production environment,
    you would be running a MongoDB server as well as a `cron` job, backing up your
    database snapshots at regular intervals.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个用例，假设您想在生产环境中使用**MongoDB**，您将运行一个MongoDB服务器以及一个`cron`作业，定期备份数据库快照。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: MongoDB is a document database that provides high performance, high availability,
    and easy scalability. You can get more information about MongoDB at [http://www.mongodb.org](http://www.mongodb.org).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是一个文档数据库，提供高性能、高可用性和易扩展性。您可以在[http://www.mongodb.org](http://www.mongodb.org)获取有关MongoDB的更多信息。
- en: 'Let''s see how make the MongoDB setup using `docker` volumes:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`docker`卷设置MongoDB：
- en: 'Firstly, we need a data-only container. The task of this container is only
    to expose the volume where MongoDB stores the data:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一个数据专用容器。该容器的任务只是公开MongoDB存储数据的卷：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we need to run the MongoDB server, which uses the volume created by the
    data-only container:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要运行MongoDB服务器，该服务器使用数据专用容器创建的卷：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `mongod` command runs the MongoDB server and is usually run as a daemon/service.
    It is accessed through port `27017`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`mongod`命令运行MongoDB服务器，通常作为守护程序/服务运行。它通过端口`27017`访问。'
- en: 'Lastly, we will need to run the `backup` utility. In this case, we are just
    dumping the MongoDB data store to the current directory on the host:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要运行`backup`实用程序。在这种情况下，我们只是将MongoDB数据存储转储到主机上的当前目录：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is by no means an exhaustive example of setting up MongoDB in production.
    You might need a process that monitors the health of the MongoDB server. You will
    also need to make the MongoDB server container discoverable by your application
    containers (which we will learn in detail later).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝不是在生产中设置MongoDB的详尽示例。您可能需要一个监视MongoDB服务器健康状况的过程。您还需要使MongoDB服务器容器可以被您的应用程序容器发现（我们将在后面详细学习）。
- en: Configuring Docker to use a different storage driver
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Docker以使用不同的存储驱动程序
- en: Before using a different storage driver, back up all your images with `docker
    save` and stop the `docker` daemon. Once you have backed up all your important
    images, remove `/var/lib/docker`. Once you change the storage driver, you can
    restore the saved images.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用不同的存储驱动程序之前，使用`docker save`备份所有图像，并停止`docker`守护程序。一旦备份了所有重要图像，删除`/var/lib/docker`。更改存储驱动程序后，可以恢复保存的图像。
- en: We are now going to change our default storage driver, AUFS, to two alternative
    storage drivers – `devicemapper` and `btrfs`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将把默认存储驱动程序AUFS更改为两种备用存储驱动程序-devicemapper和btrfs。
- en: Using devicemapper as the storage driver
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用devicemapper作为存储驱动程序
- en: 'It is easy to switch to the `devicemapper` driver. Just start the `docker`
    daemon with the `-s` option:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到devicemapper驱动程序很容易。只需使用-s选项启动docker守护程序：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Additionally, you can provide various `devicemapper` driver options with the
    `--storage-opts` flag. The various available options and examples for the `devicemapper`
    drivers have been covered under the *Constraining resources storage* section of
    this chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用--storage-opts标志提供各种devicemapper驱动程序选项。devicemapper驱动程序的各种可用选项和示例已在本章的*限制资源存储*部分中介绍。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are running on RedHat/Fedora that doesn't have AUFS out of the box, Docker
    will have been using `devicemapper` driver, which is available.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在没有AUFS的RedHat/Fedora上运行，Docker将使用devicemapper驱动程序，该驱动程序可用。
- en: Once you have switched the storage driver, you can verify the change in it by
    running `docker info`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 切换存储驱动程序后，您可以通过运行docker info来验证更改。
- en: Using btrfs as the storage driver
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用btrfs作为存储驱动程序
- en: 'To use btrfs as the storage driver, you have to first set it up. This section
    assumes you are running it on an Ubuntu 14.04 operating system. The commands may
    vary according to the Linux distribution you are running. The following steps
    will set up a block device with the `btrfs` filesystem:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要将btrfs用作存储驱动程序，您必须首先设置它。本节假定您正在运行Ubuntu 14.04操作系统。根据您运行的Linux发行版，命令可能会有所不同。以下步骤将设置一个带有btrfs文件系统的块设备：
- en: 'Firstly, you need to install `btrfs` and its dependencies:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要安装btrfs及其依赖项：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, you need to create a block device of the `btrfs` filesystem type:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要创建一个btrfs文件系统类型的块设备：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now create the directory for Docker (you should have backed up all important
    images and cleaned `/var/lib/docker` by this point.):'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为Docker创建目录（到此时，您应该已经备份了所有重要的镜像并清理了/var/lib/docker）。
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then mount the btrfs block device at `/var/lib/docker`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在/var/lib/docker挂载btrfs块设备：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Check whether the mount is successful:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查挂载是否成功：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Source: [http://serverascode.com/2014/06/09/docker-btrfs.html](http://serverascode.com/2014/06/09/docker-btrfs.html).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[http://serverascode.com/2014/06/09/docker-btrfs.html](http://serverascode.com/2014/06/09/docker-btrfs.html)。
- en: 'Now you can start the `docker` daemon with the `-s` option:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用-s选项启动docker守护程序：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once you have switched the storage driver, you can verify the change in it by
    running the `docker info` command.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 切换存储驱动程序后，您可以通过运行docker info命令来验证其中的更改。
- en: Configuring Docker's network settings
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Docker的网络设置
- en: Docker creates a separate network stack for each container and a virtual bridge
    (`docker0`) to manage network communication within the container, between the
    container and the host, and between two containers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Docker为每个容器创建一个单独的网络堆栈和一个虚拟桥（docker0）来管理容器内部、容器与主机之间以及两个容器之间的网络通信。
- en: 'There are a few network configurations that can be set as arguments to the
    `docker run` command. They are as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些网络配置可以作为docker run命令的参数设置。它们如下：
- en: '`--dns`: A DNS server is what resolves a URL, such as [http://www.docker.io](http://www.docker.io),
    to the IP address of the server that is running the website.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --dns：DNS服务器是将URL（例如[http://www.docker.io](http://www.docker.io)）解析为运行网站的服务器的IP地址。
- en: '`--dns-search`: This allows you to set DNS search servers.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --dns-search：这允许您设置DNS搜索服务器。
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A DNS search server resolves `abc` to `abc.example.com` if `example.com` is
    set as the DNS search domain. This is useful if you have a lot of subdomains in
    your corporate website that you need to access frequently. It is too painful to
    repeatedly keep typing the entire URL. If you try to access a site that is not
    a fully qualified domain name (for example, `xyz.abc.com`.), it adds the search
    domains for the lookup. Source : [http://superuser.com/a/184366](http://superuser.com/a/184366).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将DNS搜索服务器解析`abc`为`abc.example.com`，则`example.com`设置为DNS搜索域。如果您有许多子域在您的公司网站中需要经常访问，这将非常有用。反复输入整个URL太痛苦了。如果您尝试访问一个不是完全合格的域名的站点（例如`xyz.abc.com`），它会为查找添加搜索域。来源：[http://superuser.com/a/184366](http://superuser.com/a/184366)。
- en: '`-h` or `--hostname`: This allows you to set the hostname. This will be added
    as an entry to the `/etc/hosts` path against the host-facing IP of the container.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-h`或`--hostname`：这允许您设置主机名。这将被添加为对容器的面向主机的IP的`/etc/hosts`路径的条目。'
- en: '`--link`: This is another option that can be specified while starting a container.
    It allows containers to communicate with other containers without needing to know
    their actual IP addresses.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--link`：这是另一个可以在启动容器时指定的选项。它允许容器与其他容器通信，而无需知道它们的实际IP地址。'
- en: '`--net`: This option allows you to set the network mode for the container.
    It can have four values:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--net`：此选项允许您为容器设置网络模式。它可以有四个值：'
- en: '`bridge` : This creates a network stack for the container on the docker bridge.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`桥接`：这为docker容器创建了一个网络堆栈。'
- en: '`none` : No networking stack will be created for this container. It will be
    completely isolated.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none`：不会为此容器创建任何网络堆栈。它将完全隔离。'
- en: '`container:<name|id>` : This uses another container''s network stack.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container:<name|id>`：这使用另一个容器的网络堆栈。'
- en: '`host` : This uses the host''s network stack.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host`：这使用主机的网络堆栈。'
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: These values have side effects such as the local system services being accessible
    from the container. This option is considered insecure.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值具有副作用，例如本地系统服务可以从容器中访问。此选项被认为是不安全的。
- en: '`--expose`: This exposes the container''s port without publishing it on the
    host.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--expose`：这将暴露容器的端口，而不在主机上发布它。'
- en: '`--publish-all`: This publishes all exposed ports to the host''s interfaces.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--publish-all`：这将所有暴露的端口发布到主机的接口。'
- en: '`--publish`: This publishes a container''s port to the host in the following
    format: `ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort
    | containerPort`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--publish`：这将以以下格式将容器的端口发布到主机：`ip:hostPort:containerPort | ip::containerPort
    | hostPort:containerPort | containerPort`。'
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If `--dns` or `--dns-search` is not given, then the `/etc/resolv.conf` file
    of the container will be the same as the `/etc/resolv.conf` file of the host the
    daemon is running on.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未给出`--dns`或`--dns-search`，则容器的`/etc/resolv.conf`文件将与守护程序正在运行的主机的`/etc/resolv.conf`文件相同。
- en: 'However, there are some configurations that can be given to the `docker` daemon
    process too when you run it. They are mentioned as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你运行它时，`docker`守护进程也可以给出一些配置。它们如下所述：
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These options can only be supplied when starting the `docker` daemon and cannot
    be tweaked once it is running. This means you must provide these arguments along
    with the `docker -d` command.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项只能在启动`docker`守护程序时提供，一旦运行就无法调整。这意味着您必须在`docker -d`命令中提供这些参数。
- en: '`--ip`: This option allows us to set the host''s IP address at the container-facing
    `docker0` interface. As a result, this will be the default IP address used when
    binding container ports. For example this option can be shown as follows:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--ip`：此选项允许我们在面向容器的`docker0`接口上设置主机的IP地址。因此，这将是绑定容器端口时使用的默认IP地址。例如，此选项可以显示如下：'
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`--ip-forward`: This is a `Boolean` option. If it is set to `false`, the host
    running the daemon will not forward the packets between containers or from the
    outside world to the container, completely isolating it (from a network perspective).'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--ip-forward`：这是一个`布尔`选项。如果设置为`false`，则运行守护程序的主机将不会在容器之间或从外部世界到容器之间转发数据包，从网络角度完全隔离它。'
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'This setting can be checked using the `sysctl` command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`sysctl`命令来检查此设置：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`--icc`: This is another `Boolean` option that stands for `inter-container
    communication`. If it is set to `false`, the containers will be isolated from
    each other, but will still be able to make general HTTP requests to package managers
    and so on.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--icc`：这是另一个`布尔`选项，代表`容器间通信`。如果设置为`false`，容器将彼此隔离，但仍然可以向包管理器等发出一般的HTTP请求。'
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: How do you enable communication only between those two containers you need?
    Through links. We will explore links in detail in the *Linking containers* section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如何只允许那两个容器之间的通信？通过链接。我们将在*链接容器*部分详细探讨链接。
- en: '`-b or --bridge`: You can make Docker use a custom bridge instead of `docker0`.
    (The creation of a bridge is out of the scope of this discussion. However, if
    you are curious, you can find more information at [http://docs.docker.com/articles/networking/#building-your-own-bridge](http://docs.docker.com/articles/networking/#building-your-own-bridge).)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-b或--bridge`：您可以让Docker使用自定义桥接而不是`docker0`。（创建桥接超出了本讨论的范围。但是，如果您感兴趣，可以在[http://docs.docker.com/articles/networking/#building-your-own-bridge](http://docs.docker.com/articles/networking/#building-your-own-bridge)找到更多信息。）'
- en: '`-H or --host`: This option can take multiple arguments. Docker has a RESTful
    API. The daemon acts as a server, and when you run client commands such as `run`
    and `ps`, it makes `GET` and `POST` requests to the server, which performs the
    necessary operations and returns a response. The `-H` flag is used to tell the
    `docker` daemon the channels it must listen to for client commands. The arguments
    can be as follows:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-H或--host`：此选项可以接受多个参数。Docker具有RESTful API。守护程序充当服务器，当您运行客户端命令（如`run`和`ps`）时，它会向服务器发出`GET`和`POST`请求，服务器执行必要的操作并返回响应。`-H`标志用于告诉`docker`守护程序必须监听哪些通道以接收客户端命令。参数可以如下：'
- en: TCP sockets, represented in the form of `tcp://<host>:<port>`
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`tcp://<host>:<port>`形式表示的TCP套接字
- en: UNIX socket in the form of `unix:///path/to/socket`
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unix:///path/to/socket`形式的UNIX套接字'
- en: Configuring port forwarding between container and host
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在容器和主机之间配置端口转发
- en: Containers can make connections to the outside world without any special configurations,
    but the outside world is not allowed to peek into them. This is a security measure
    and is fairly obvious, since the containers are all connected to the host through
    a virtual bridge, thus effectively placing them in a virtual network. But what
    if you were running a service in a container that you wanted to expose to the
    outside world?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 容器可以在没有任何特殊配置的情况下连接到外部世界，但外部世界不允许窥视它们。这是一项安全措施，显而易见，因为容器都通过虚拟桥连接到主机，从而有效地将它们放置在虚拟网络中。但是，如果您在容器中运行一个希望暴露给外部世界的服务呢？
- en: Port forwarding is the easiest way to expose services running in containers.
    It is always advisable to mention in the Dockerfile of an image the ports that
    need to be exposed. In earlier versions of Docker, it was possible to specify
    which host port the Dockerfile should be bound to in the Dockerfile itself, but
    this was dropped because sometimes, services already running in the host would
    interfere with the container. Now, you can still specify in a Dockerfile the ports
    that are intended to be exposed (with the `EXPOSE` instruction), but if you want
    to bind it to ports of your choice, you need to do this when starting the container.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 端口转发是暴露在容器中运行的服务的最简单的方法。在镜像的Dockerfile中提到需要暴露的端口是明智的。在早期版本的Docker中，可以在Dockerfile本身指定Dockerfile应绑定到的主机端口，但这样做是因为有时主机中已经运行的服务会干扰容器。现在，您仍然可以在Dockerfile中指定要暴露的端口（使用`EXPOSE`指令），但如果要将其绑定到您选择的端口，需要在启动容器时执行此操作。
- en: 'There are two ways to start a container and bind its ports to host ports. They
    are explained as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以启动容器并将其端口绑定到主机端口。它们的解释如下：
- en: '`-P or --publish-all`: Starting a container using `docker run` with the `-P`
    option will publish all the ports that were exposed using the `EXPOSE` instruction
    in the image''s Dockerfile. Docker will go through the exposed ports and bind
    them to a random port between `49000` and `49900`.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-P或--publish-all`：使用`docker run`启动容器，并使用`-P`选项将发布在镜像的Dockerfile中使用`EXPOSE`指令暴露的所有端口。Docker将浏览暴露的端口，并将它们绑定到`49000`到`49900`之间的随机端口。'
- en: '`-p or --publish`: This option allows you to explicitly tell Docker which port
    on which IP should be bound to a port on a container (of course, one of the interfaces
    in the host should have this IP). Multiple bindings can be done by using the option
    multiple times:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p或--publish`：此选项允许您明确告诉Docker应将哪个IP上的哪个端口绑定到容器上的端口（当然，主机中的一个接口应该具有此IP）。可以多次使用该选项进行多个绑定：'
- en: '`docker run -p ip:host_port:container_port`'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker run -p ip:host_port:container_port`'
- en: '`docker run -p ip::container_port`'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker run -p ip::container_port`'
- en: '`docker run -p host_port:container_port`'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker run -p host_port:container_port`'
- en: Custom IP address range
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义IP地址范围
- en: We've seen how to bind a container's port to a host's port, how to configure
    a container's DNS settings, and even how to set the host's IP address. But what
    if we wanted to set the subnet of the network between the containers and the host
    ourselves? Docker creates a virtual subnet in one of the available private ranges
    of IP addresses provided by RFC 1918.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何将容器的端口绑定到主机的端口，如何配置容器的DNS设置，甚至如何设置主机的IP地址。但是，如果我们想要自己设置容器和主机之间网络的子网怎么办？Docker在RFC
    1918提供的可用私有IP地址范围中创建了一个虚拟子网。
- en: 'Setting your own subnet range is marvelously easy. The `--bip` option of the
    `docker` daemon can be used to set the IP address of the bridge as well as the
    subnet in which it is going to create the containers:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 设置自己的子网范围非常容易。`docker`守护程序的`--bip`选项可用于设置桥接的IP地址以及它将创建容器的子网：
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this case, we have set the IP address of `192.168.0.1` to the `docker` daemon
    and mentioned that it has to assign IP addresses to the containers in the subnet
    range `192.168.0.0/24` (that is, from `192.168.0.2` to `192.168.0.254`, a total
    of 252 possible IP addresses).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们已将IP地址设置为`192.168.0.1`，并指定它必须将IP地址分配给子网范围`192.168.0.0/24`中的容器（即从`192.168.0.2`到`192.168.0.254`，共252个可能的IP地址）。
- en: That's it! There are more advanced network configurations and examples at [https://docs.docker.com/articles/networking/](https://docs.docker.com/articles/networking/).
    Be sure to check them out.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！在[https://docs.docker.com/articles/networking/](https://docs.docker.com/articles/networking/)上有更多高级网络配置和示例。一定要查看它们。
- en: Linking containers
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接容器
- en: Binding container ports to host ports is all okay if you just have a plain web
    server that you want to expose to the Internet. Most production systems, however,
    are made of lots of individual components that are constantly communicating with
    each other. Components such as the database servers must not be bound to publicly
    visible IPs, but the containers running the frontend applications still need to
    discover the database containers and connect to them. Hardcoding a container's
    IP addresses in the application is neither a clean solution nor will it work because
    IP addresses are randomly assigned to the containers. So how do we solve this
    problem? The answer is as follows.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只有一个普通的Web服务器想要暴露给互联网，那么将容器端口绑定到主机端口就可以了。然而，大多数生产系统由许多不断相互通信的单独组件组成。诸如数据库服务器之类的组件不应绑定到公开可见的IP，但运行前端应用程序的容器仍然需要发现数据库容器并连接到它们。在应用程序中硬编码容器的IP地址既不是一个干净的解决方案，也不会起作用，因为IP地址是随机分配给容器的。那么我们如何解决这个问题呢？答案如下。
- en: Linking containers within the same host
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在同一主机内链接容器
- en: 'A link can be specified when starting the container using the `--link` option:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在启动容器时使用`--link`选项指定链接：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How does this work? When a link option is given, Docker adds an entry to the
    container's `/etc/hosts` file, with the `ALIAS` command as the hostname and the
    IP address of the container named `CONTAINER_IDENTIFIER`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？当给出链接选项时，Docker会向容器的`/etc/hosts`文件添加一个条目，其中`ALIAS`命令作为主机名，容器命名为`CONTAINER_IDENTIFIER`的IP地址。
- en: Note
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `/etc/hosts` file can be used to override DNS definitions, that is, to point
    a hostname to a certain IP address. During hostname resolution, `/etc/hosts` is
    checked before making a request to a DNS server.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/hosts`文件可用于覆盖DNS定义，即将主机名指向特定的IP地址。在主机名解析期间，在向DNS服务器发出请求之前，将检查`/etc/hosts`。'
- en: 'For example the command line code is shown below:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面显示了命令行代码：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding command runs a PostgreSQL server (whose Dockerfile exposes port
    5432, PostgeSQL's default port) and the second container will link to it with
    the `postgres` alias.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的命令运行了一个PostgreSQL服务器（其Dockerfile公开了端口5432，PostgeSQL的默认端口），第二个容器将使用`postgres`别名链接到它。
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: PostgreSQL is a fully **ACID**-compliant, powerful open source object-relational
    database system.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL是一个完全符合**ACID**的功能强大的开源对象关系数据库系统。
- en: Cross-host linking using ambassador containers
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ambassador容器进行跨主机链接
- en: Linking containers works fine when all the containers are within the same host,
    but Docker's containers might often be spread across hosts, and linking in these
    cases fails because the IP address of a container running in a different host
    is not known by the `docker` daemon running in the current host. Besides, links
    are static. This means that if a container restarts, its IP address changes and
    all containers linked to it will lose the connection. A portable solution is to
    use ambassador containers.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有容器都在同一主机上时，链接容器可以正常工作，但是Docker的容器通常可能分布在不同的主机上，在这些情况下链接会失败，因为在当前主机上运行的`docker`守护程序不知道在不同主机上运行的容器的IP地址。此外，链接是静态的。这意味着如果容器重新启动，其IP地址将更改，并且所有链接到它的容器将失去连接。一个可移植的解决方案是使用ambassador容器。
- en: 'The following diagram displays the ambassador container:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了ambassador容器：
- en: '![Cross-host linking using ambassador containers](graphics/4787OS_03_02.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![使用ambassador容器进行跨主机链接](graphics/4787OS_03_02.jpg)'
- en: In this architecture, the database server in one host is exposed to the other.
    Here too, if the database container changes, only the ambassador container in
    the `host1` phase needs to be restarted.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种架构中，一个主机中的数据库服务器暴露给另一个主机。同样，如果数据库容器发生更改，只需要重新启动`host1`阶段的ambassador容器。
- en: Use case - a multi-host Redis environment
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用例 - 多主机Redis环境
- en: Let's set up a multi-host Redis environment using the `progrium/ambassadord`
    command. There are other images that can be used as ambassador containers as well.
    They can be searched for either using the `docker search` command or at [https://registry.hub.docker.com](https://registry.hub.docker.com).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`progrium/ambassadord`命令设置一个多主机Redis环境。还有其他可以用作大使容器的镜像。它们可以使用`docker search`命令搜索，或者在[https://registry.hub.docker.com](https://registry.hub.docker.com)上搜索。
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Redis is an open source, networked, in-memory, key-value data store with optional
    durability. It is known for its fast speed, both for reads and writes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是一个开源的、网络化的、内存中的、可选的持久性键值数据存储。它以快速的速度而闻名，无论是读取还是写入。
- en: In this environment, there are two hosts, `Host` `1` and `Host` `2`. `Host`
    `1` has an IP address of `192.168.0.100` and is private (not exposed to the public
    Internet). `Host` `2` is at 192.168.0.1 and is bound to a public IP. This is the
    host that runs your frontend web application.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个环境中，有两个主机，`Host` `1`和`Host` `2`。`Host` `1`的IP地址是`192.168.0.100`，是私有的（不暴露给公共互联网）。`Host`
    `2`在192.168.0.1，并绑定到一个公共IP。这是运行您的前端Web应用程序的主机。
- en: Note
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To try this example, start two virtual machines. If you use Vagrant, I suggest
    using an Ubuntu image with Docker installed. If you have Vagrant v1.5, you can
    use Phusion's Ubuntu image by running `$ vagrant init phusion/ubuntu-14.04-amd64`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个例子，启动两个虚拟机。如果您使用Vagrant，我建议使用安装了Docker的Ubuntu镜像。如果您有Vagrant v1.5，可以通过运行`$
    vagrant init phusion/ubuntu-14.04-amd64`来使用Phusion的Ubuntu镜像。
- en: Host 1
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主机1
- en: 'In the first host, run the following command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个主机上，运行以下命令：
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This command starts a Redis server and exposes port `6379` (which is the default
    port the Redis server runs at), but doesn't bind it to any host port.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令启动了一个Redis服务器，并暴露了端口`6379`（这是Redis服务器运行的默认端口），但没有将其绑定到任何主机端口。
- en: 'The following command starts an ambassador container, links to the Redis server
    and binds the port 6379 to port 6379 of its private network''s IP address (which
    in this case happens to be 192.168.0.100). This is still not public because the
    host is private (not exposed to public Internet):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令启动一个大使容器，链接到Redis服务器，并将端口6379绑定到其私有网络IP地址的6379端口（在这种情况下是192.168.0.100）。这仍然不是公开的，因为主机是私有的（不暴露给公共互联网）：
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Host 2
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主机2
- en: 'In another host (another VM if you are using Vagrant in development), run the
    following command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个主机（如果您在开发中使用Vagrant，则是另一个虚拟机），运行以下命令：
- en: '[PRE32]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This ambassador container listens to the port of the destination IP, which
    in this case is Host 1''s IP address. We have exposed port 6379 so that it can
    be now hooked to by our application container:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个大使容器监听目标IP的端口，这种情况下是主机1的IP地址。我们已经暴露了端口6379，这样它现在可以被我们的应用容器连接：
- en: '[PRE33]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This would be the container that would be exposed to the public on the Internet.
    As the Redis server is running in a private host, it cannot be attacked from outside
    the private network.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是在互联网上公开的容器。由于Redis服务器在私有主机上运行，因此无法从私有网络外部受到攻击。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw how to provision resources such as CPU, RAM, and storage
    in a Docker container. We also discussed how to use volumes and volume containers
    to manage persistent data produced by applications in containers. We realized
    what goes into switching storage drivers used by Docker and the various networking
    configurations and their relevant use cases. Lastly, we saw how to link containers
    both within a host and across hosts.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何在Docker容器中配置CPU、RAM和存储等资源。我们还讨论了如何使用卷和卷容器来管理容器中应用程序产生的持久数据。我们了解了切换Docker使用的存储驱动程序以及各种网络配置及其相关用例。最后，我们看到了如何在主机内部和跨主机之间链接容器。
- en: In the next chapter, we will look at the tools and approaches that will help
    when we are thinking about deploying our application using Docker. Some of the
    things we will be looking at are coordination of multiple services, service discovery,
    and Docker's remote API. We will also cover security considerations.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看哪些工具和方法可以帮助我们考虑使用Docker部署我们的应用程序。我们将关注的一些内容包括多个服务的协调、服务发现以及Docker的远程API。我们还将涵盖安全考虑。
