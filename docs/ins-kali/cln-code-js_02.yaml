- en: Setting the Scene
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设定场景
- en: 'JavaScript was created by Brendan Eich in 1995, with the goal of being a *glue
    language*. It was intended to help web designers and amateurs easily manipulate
    and derive behavior from their HTML. JavaScript was able to do this via the DOM
    API, a set of interfaces provided by the browser that would give access to the
    parsed representation of HTML. Soon after this, **DHTML** became the popular term,
    referring to the more dynamic user interfaces that JavaScript enabled: everything
    from animated rollover button states to client-side form validation. Eventually
    came the rise of Ajax, which enabled communication between the *client* and the
    *server*. This opened up a considerable fountain of potential applications. The
    web, previously purely the domain of documents, was now on the way to becoming
    a powerhouse of processor- and memory-intensive applications:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是由Brendan Eich于1995年创建的，旨在成为一种“粘合语言”。它旨在帮助网页设计师和业余爱好者轻松地操纵和从他们的HTML中派生行为。JavaScript能够通过DOM
    API实现这一点，DOM API是浏览器提供的一组接口，可以访问HTML的解析表示。不久之后，**DHTML**成为流行术语，指的是JavaScript实现的更动态的用户界面：从动画按钮状态到客户端表单验证等各种功能。最终出现了Ajax，它实现了*客户端*和*服务器*之间的通信。这为潜在应用程序开辟了一个巨大的可能性。以前纯粹是文档领域的网络，现在正在成为一个处理器和内存密集型应用程序的强大平台：
- en: '![](assets/1dcac593-43c4-4a3c-acc7-60ff6595b18b.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1dcac593-43c4-4a3c-acc7-60ff6595b18b.png)'
- en: In 1995, nobody could have predicted that JavaScript would one day be used to
    build complex web applications, program robots, query databases, write plugins
    for photo manipulation software, and be behind one of the most popular server
    runtimes in existence, Node.js.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 1995年，没有人能预测JavaScript有一天会被用来构建复杂的Web应用程序，编程机器人，查询数据库，为照片处理软件编写插件，并成为现存最受欢迎的服务器运行时之一，Node.js的背后。
- en: In 1997, not long after its creation, JavaScript was standardized by Ecma International
    under the name ECMAScript, and it is still undergoing frequent changes under the
    TC39 committee. Most recent versions of the language have been named according
    to the year of their release, such as ECMAScript 2020 (ES2020).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 1997年，JavaScript在创立后不久由Ecma International标准化，以ECMAScript的名字，它仍在TC39委员会的频繁变更中。语言的最新版本根据发布年份命名，比如ECMAScript
    2020（ES2020）。
- en: 'Due to its burgeoning capabilities, JavaScript has attracted a passionate community
    that drives its growth and ubiquity. And due to its considerable popularity, there
    are now countless different ways to do the same thing in JavaScript. There are
    thousands of popular frameworks, libraries, and utilities. The language too is
    changing on a near-constant basis in reaction to the increasing demands of its
    applications. This creates a great challenge: among all of this change, while
    being pushed and pulled in different directions, how can we know how to write
    the best possible code? Which frameworks should we use? What conventions should
    we employ? How should we test our code? How should we craft sensible abstractions?'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其不断增长的功能，JavaScript吸引了一个充满激情的社区，推动了它的增长和普及。由于它的相当受欢迎，现在有无数种不同的方法可以在JavaScript中完成相同的事情。有成千上万的流行框架、库和实用程序。语言本身也在不断变化，以应对其应用程序日益增长的需求。这带来了一个巨大的挑战：在所有这些变化中，当被推拉到不同的方向时，我们如何知道如何编写最佳的代码？我们应该使用哪些框架？我们应该采用什么约定？我们应该如何测试我们的代码？我们应该如何构建明智的抽象？
- en: 'To answer these questions, we need to briefly go back to basics. And that is
    the purpose of this chapter. We''ll be discussing the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这些问题，我们需要简要回顾基础知识。这就是本章的目的。我们将讨论以下内容：
- en: What the true purpose of the code is
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的真正目的是什么
- en: Who our users are and what problems they have
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的用户是谁，他们有什么问题
- en: What it means to write code for humans
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为人类编写代码意味着什么
- en: Why we write code
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么写代码
- en: At its simplest, we know that programming is about instructing computers, but
    what are we instructing them to do? And to what end? And what other purposes does
    code serve?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，我们知道编程是关于指导计算机，但我们在指导它们做什么？以及为了什么目的？代码还有什么其他用途？
- en: We can broadly say that code is a way of solving problems. By writing code,
    we are expressing a complex task or series of actions, distilling them into a
    singular process that can be easily utilized by a user. So we can say that the
    code is an expression of a problem domain. We can even say it is a form of communication,
    a way to relay information and intent. Understanding that code is a complex thing
    with many complementary purposes, such as problem-solving and communication, will
    enable us to use it to its fullest potential. Let's delve further into this complexity
    by exploring what we mean when we speak of code as a method of relaying intent.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以广泛地说，代码是解决问题的一种方式。通过编写代码，我们表达了一个复杂的任务或一系列操作，将它们浓缩成一个可以被用户轻松利用的单一过程。因此，我们可以说代码是问题领域的表达。我们甚至可以说它是一种沟通方式，一种传达信息和意图的方式。了解代码是一个具有许多互补目的的复杂事物，比如解决问题和沟通，将使我们能够充分发挥其潜力。让我们深入探讨一下这种复杂性，探索我们所说的代码作为传达意图的方法是什么意思。
- en: Code as intent
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码的意图
- en: We often think of code as simply a series of instructions that are executed
    by a computer. But in many ways, this misses the true magic of what we're doing
    when we write code. When we convey instructions, we are expressing our intent
    to the world; we are saying *These are the things that I want to occur.*
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常认为代码只是计算机执行的一系列指令。但在很多方面，这忽略了我们写代码时所做的真正魔力。当我们传达指令时，我们在向世界表达我们的意图；我们在说“这些是我想发生的事情”。
- en: 'Humans have been conveying instructions for as long as they''ve been around.
    One example of this is a simple cooking recipe:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 人类一直以来都在传达指令。一个简单的烹饪食谱就是一个例子：
- en: Cut about three hundred grams of butter (small cubes!)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 切大约300克黄油（小方块！）
- en: Take 185 grams dark chocolate
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 取185克黑巧克力
- en: Melt it with butter over a saucepan
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在平底锅上用黄油融化
- en: Break half dozen eggs, ideally large ones
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 打破半打鸡蛋，最好是大个的
- en: Mix them together with a few cups of sugar
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们与几杯糖混合在一起
- en: 'Instructions like these are quite easy to understand for a human, but you''ll
    notice they follow no strict specification. The measuring units are inconsistent,
    as is the punctuation and the wording. And some of the instructions are quite
    ambiguous and therefore open to misinterpretation by someone who hasn''t cooked
    before:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的指令对人类来说很容易理解，但您会注意到它们没有严格的规范。计量单位不一致，标点和措辞也不一致。一些指令非常模棱两可，因此对于以前没有做过饭的人来说，容易产生误解：
- en: What constitutes a large egg?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么构成一个大鸡蛋？
- en: When should I consider the butter fully melted?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时应该考虑黄油完全融化？
- en: How dark should the dark chocolate be?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深色巧克力应该有多深？
- en: How small is a *small cube* of butter?
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*小方块*黄油有多小？'
- en: What does *over a saucepan* mean?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在锅上*是什么意思？'
- en: Humans can usually muddle through such ambiguities with their initiative and
    experience, but machines aren't so adept. A machine must be instructed with enough
    specificity to carry out every step. What we wish to communicate to a machine
    is our intent, that is, *please do this thing*, but due to the nature of machines,
    we must be utterly specific. Thankfully, how we choose to write these instructions
    is up to us; there are many programming languages and approaches, and almost all
    of them were created with the goal of making it easier for humans to communicate
    their intent in a less burdensome way.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 人类通常可以通过他们的主动性和经验来应对这种模棱两可，但机器并不那么擅长。机器必须被指示具有足够的具体性来执行每一步。我们希望向机器传达的是我们的意图，也就是*请做这件事*，但由于机器的性质，我们必须非常具体。值得庆幸的是，我们选择如何编写这些指令取决于我们；有许多编程语言和方法，几乎所有这些方法都是为了让人类以更轻松的方式传达他们的意图而创建的。
- en: The distance between human capability and computing capability is quickly narrowing.
    The advent of machine learning, natural language processing, and highly specialized
    programs means that machines are far more flexible in the types of instructions
    they can carry out. However, code will continue to be useful for some time, as
    it allows us to communicate in a highly specific and standardized way. With this
    high level of specificity and consistency, we can have more faith that our instructions
    will be executed as intended, every time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 人类能力和计算能力之间的距离迅速缩小。机器学习、自然语言处理和高度专业化的程序的出现意味着机器在能够执行的指令类型上更加灵活。然而，代码将继续有用一段时间，因为它使我们能够以一种高度具体和标准化的方式进行沟通。通过这种高度的具体性和一致性，我们可以更有信心地相信我们的指令每次都会按照预期执行。
- en: Who is the user?
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谁是用户？
- en: No meaningful conversation about programming can occur without considering the
    user. The user, whether they are a fellow programmer or the end user of a UI,
    is at the core of what we do.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑用户时，没有关于编程的有意义的对话。用户，无论他们是其他程序员还是UI的最终用户，都是我们所做的核心。
- en: Let's imagine that we are tasked with validating user-inputted shipping addresses
    on a website. This particular website sells medication to hospitals around the
    world. We're in a bit of a rush and would prefer to use something that someone
    else has implemented. We find a publicly available package called `shipping_address_validator`and
    decide to use it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们的任务是验证网站上用户输入的送货地址。这个特定的网站向世界各地的医院销售药物。我们有点匆忙，宁愿使用别人已经实施的东西。我们找到了一个名为`shipping_address_validator`的公开可用的包，并决定使用它。
- en: 'If we had taken the time to check the code within the package, in its postal
    code validation file, we would have seen this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们花时间检查包中的代码，在其邮政编码验证文件中，我们会看到这样：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This `validatePostalCode` function happens to be using regular expressions (also
    known as **RegExp** and regex), delimited by forward slashes, to define a pattern
    of characters to match a string against. You can read more about these constructs
    in [Chapter 6](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml), *Primitive and Built-In
    Types*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`validatePostalCode`函数碰巧使用了正则表达式（也称为**RegExp**和regex），用斜杠分隔，以定义要与字符串匹配的字符模式。您可以在[第6章](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml)中阅读更多关于这些构造的内容，*原始和内置类型*。
- en: Unfortunately, due to our haste, we didn't question the functionality of the `shipping_address_validator`package.
    We assumed it did *what it says on the tin*. One week after releasing our code
    to production we get a bug report saying that some users are unable to enter their
    address information. We look at the code and realize, to our horror, that it only
    validates US ZIP codes, not all countries' postal codes (for example, it doesn't
    work on UK postcodes, such as GR82 5JY).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于我们的匆忙，我们没有质疑`shipping_address_validator`包的功能。我们假设它做了*罐头上说的那样*。发布代码到生产环境后一周，我们收到了一个错误报告，说一些用户无法输入他们的地址信息。我们查看代码后，惊恐地意识到它只验证美国的邮政编码，而不是所有国家的邮政编码（例如，它无法在英国邮政编码上运行，比如GR82
    5JY）。
- en: Through this unfortunate series of events, this piece of code is now responsible
    for blocking the shipment of vital medication to customers all over the world,
    numbering in the thousands. Fortunately, fixing it doesn't take too long.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一系列不幸的事件，这段代码现在负责阻止成千上万的全球客户的重要药物发货。幸运的是，修复它并不需要太长时间。
- en: 'Forgetting for a moment who is responsible for this mishap, I''d like to pose
    the following question: who are the users of this code?'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 暂且不论谁对这一失误负责，我想提出以下问题：这段代码的用户是谁？
- en: We, the programmers, who decided to use the `shipping_address_validator` package?
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们，程序员，决定使用`shipping_address_validator`包？
- en: The unwitting customers who are attempting to enter their addresses?
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那些试图输入他们地址的无意的客户？
- en: The patients in the hospitals who are left waiting for their medication?
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在医院等待他们药物的患者？
- en: There isn't a clear-cut answer to this question. When bugs appear in the code,
    we can see how there can be massive unfortunate downstream effects. Should the
    original programmer of the package be concerned with all these downstream dependencies?
    When a plumber is hired to fix a tap on a sink, should they only consider the
    function of the tap itself, or the sink into which it pours?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题没有明确的答案。当代码中出现错误时，我们可以看到可能会产生巨大的不幸的下游影响。原始程序包的程序员是否应该关心所有这些下游依赖关系？当聘请一名管子工来修理水槽上的水龙头时，他们只应该考虑水龙头本身的功能，还是倾倒进入其中的水槽？
- en: When we write code, we are defining an implicit specification. This specification
    is communicated by its name, its configuration options, its inputs, and its outputs.
    Anyone who uses our code has the right to expect it to work according to its specifications,
    so the more explicit we can be, the better. If we're writing code that only validates
    US ZIP codes, then we should name it accordingly. When people create software
    atop our code, we can't have any control over how they use it. But we can communicate
    explicitly about it, ensuring that its functionality is clear and expected.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写代码时，我们正在定义一个隐含的规范。这个规范通过它的名称、配置选项、输入和输出来传达。使用我们代码的任何人都有权期望它按照规范工作，所以我们越明确越好。如果我们正在编写只验证美国邮政编码的代码，那么我们应该相应地命名它。当人们在我们的代码之上创建软件时，我们无法控制他们如何使用它。但我们可以明确地传达关于它的信息，确保其功能清晰且符合预期。
- en: It's important to consider all use cases of our code, to imagine how it might
    be used and what expectations humans will have about it, programmers and end users
    alike. What we are responsible or accountable for is up for debate, and is as
    much a legal question as a technical one. But the question of who our users are
    is entirely up to us. In my experience, the better programmers consider the full
    gamut of users, aware that the software they write does not exist in a vacuum.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要考虑我们代码的所有用例，想象它可能被使用的方式以及人类对它的期望，包括程序员和最终用户。我们对什么负责或负有责任是值得讨论的，这既是一个法律问题，也是一个技术问题。但我们的用户是谁的问题完全取决于我们。根据我的经验，更好的程序员会考虑到所有用户，意识到他们编写的软件并不是在真空中存在的。
- en: What is the problem?
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题是什么？
- en: We've spoken about the importance of the user in programming, and how we must
    first understand what it is they wish to do if we are to have any hope of helping
    them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经谈到了用户在编程中的重要性，以及如果我们希望有帮助他们的希望，我们必须首先了解他们希望做什么。
- en: 'Only by understanding the problem can we begin to assemble requirements that
    our code will have to fulfill. In the exploration of the problem, it''s useful
    to ask yourself the following questions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 只有通过了解问题，我们才能开始组装我们的代码必须满足的要求。在探索问题时，有必要问自己以下问题：
- en: What problem is the user encountering?
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户遇到了什么问题？
- en: How do they currently carry out this task?
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们目前是如何执行这项任务的？
- en: What existing solutions are there and how do they work?
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有哪些现有解决方案，它们是如何工作的？
- en: When we have assembled a complete understanding of the problem, we can then
    begin ideating, planning, and writing code to solve it. At each step, often without
    realizing it, we will be modeling the problem in a way that makes sense to us.
    The way we think about the problem will have a drastic effect on the solution
    we end up creating. The model of the problem we create will dictate the code we
    end up writing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完全了解了问题后，我们就可以开始构思、规划和编写代码来解决它。在每一步，我们通常在不知不觉中会以对我们有意义的方式对问题进行建模。我们思考问题的方式将对我们最终创建的解决方案产生重大影响。我们创建的问题模型将决定我们最终编写的代码。
- en: '**What is the model of a problem?** A model or *conceptual model* is a schematic
    or representation that describes how something works. We create and adapt models
    all the time without realizing it. Over time, as you gain more information about
    a problem domain, your model will improve to better match reality.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题的模型是什么？** 模型或*概念模型*是描述事物运作方式的图表或表示。我们在不知不觉中一直在创建和调整模型。随着时间的推移，随着您对问题领域的了解增加，您的模型将得到改进，以更好地符合现实。'
- en: 'Let''s imagine for a moment that we are responsible for a note-taking application
    for students and are tasked with creating a solution to the following problem
    that a user has expressed:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们负责为学生设计一个笔记应用，并且被要求为用户表达的以下问题创建一个解决方案：
- en: '"I have many notes for my studies and so am finding it hard to organize them.
    Specifically, when trying to find a note on a given topic, I''ll try to use the
    Search feature but I rarely find what I''m looking for since I can''t always recall
    the specific text I wrote."'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: “我有很多学习笔记，所以发现很难对它们进行组织。具体来说，当试图找到有关某个主题的笔记时，我会尝试使用搜索功能，但很少能找到我要找的内容，因为我并不总是能回忆起我写的具体文字。”
- en: 'We''ve decided that this warrants changes to the software because we''ve heard
    similar things from other users. So, we sit down and try to come up with various
    ideas for how we could improve the organization of notes. There are a few options
    we could explore:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经决定这需要对软件进行更改，因为我们已经从其他用户那里听到了类似的事情。因此，我们坐下来尝试想出各种想法，看看我们如何改进笔记的组织。我们可以探索一些选项：
- en: '**Categories**: There would be a hierarchical folder structure for categories.
    A note on *Giraffes* might exist under studies/zoology. Categories can be easily
    navigated manually or via search.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分类**：将为分类创建一个分层文件夹结构。有关*长颈鹿*的笔记可能存在于学习/动物学下。分类可以通过手动或搜索轻松导航。'
- en: '**Tags**: There would be the ability to *tag* a note with one or more words
    or phrases. A note on *Giraffes* might be tagged with *mammal* and *long neck*.
    Tags can then be easily navigated manually or via search.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**：将能够使用一个或多个单词或短语对笔记进行*标记*。有关*长颈鹿*的笔记可能会被标记为*哺乳动物*和*长颈*。标签可以通过手动或搜索轻松导航。'
- en: '**Links**: Introduce a *linking* feature so notes can link to other notes that
    are related. A note on *Giraffes* might be linked to from another note, such as
    the one on *Animals with long necks.*'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接**：引入一个*链接*功能，使笔记可以链接到其他相关的笔记。例如，关于*长颈鹿*的笔记可能会被链接到另一篇笔记，比如*长颈动物*。'
- en: 'Each solution has its pros and cons, and there is also the possibility of implementing
    a combination of them. One thing that becomes immediately obvious is that each
    of these will quite drastically affect how users end up using the application.
    We can imagine how users exposed to these respective solutions would hold the
    model of *note-taking* in their minds:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个解决方案都有其利弊，也有可能实现它们的组合。显而易见的一点是，这些解决方案将极大地影响用户最终使用应用程序的方式。我们可以想象，用户接触到这些解决方案后，会在他们的脑海中形成“记笔记”的模型：
- en: '**Categories**: Notes I write have their place in my categorical hierarchy'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别**：我写的笔记在我的分类层次结构中有它们的位置'
- en: '**Tags**: Notes I write are about many different things'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**：我写的笔记涉及许多不同的事情'
- en: '**Links**: Notes I write are related to other notes I write'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接**：我写的笔记与我写的其他笔记相关'
- en: In this example, we're developing a UI, so we are sitting very close to the
    end user of the application. However, the modeling of problems is applicable to
    all of the work we do. If we were creating a pure REST API for note-keeping, exactly
    the same considerations would need to be made. Web programmers play a key part
    in deciding what models other people end up employing. We should not take this
    responsibility lightly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在开发一个UI，因此我们与应用程序的最终用户非常接近。然而，问题建模适用于我们所做的所有工作。如果我们为笔记保存创建一个纯粹的REST
    API，那么将需要做出完全相同的考虑。Web程序员在决定其他人最终采用的模型方面起着关键作用。我们不应该轻视这一责任。
- en: Truly understanding the problem domain
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真正理解问题领域
- en: The first point of failure is typically misunderstanding the problem. If we
    don't understand what users are truly trying to accomplish, and we have not received
    all requirements, then we will inevitably retain a bad model of the problem and
    thus end up implementing the wrong solutions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的失败点通常是对问题的误解。如果我们不了解用户真正想要实现什么，也没有收到所有的需求，那么我们将不可避免地保留问题的错误模型，从而实施错误的解决方案。
- en: 'Imagine that this scenario occurs at some point before the invention of the
    kettle:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在水壶发明之前的某个时刻发生了这种情况：
- en: '**Susanne (engineer)**: Matt, we''ve been asked to design a vessel that users
    can boil water with'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**苏珊娜（工程师）**：马特，我们被要求设计一个用户可以煮水的容器'
- en: '**Matthew (engineer)**: Understood; I will create a vessel that does exactly
    that'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**马修（工程师）**：明白了；我会创建一个完全符合要求的容器'
- en: 'Matthew asks no questions and immediately gets to work, excited at the prospect
    of putting his creativity to use. One day later he comes up with the following
    contraption:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 马修没有提出任何问题，立即开始工作，对能够将自己的创造力发挥出来感到兴奋。一天后，他想出了以下装置：
- en: '![](assets/93292fe1-22f3-4e7f-a054-a3ca4b1750d3.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/93292fe1-22f3-4e7f-a054-a3ca4b1750d3.png)'
- en: 'We can see, quite obviously, that Matthew has forgotten one key component.
    In his haste, he did not stop to ask Susanne for more information about the user,
    or about their problem, and so did not consider the eventuality that a user would
    need to pick up the boiling-hot vessel somehow. After receiving feedback, naturally,
    he designed and introduced a handle to the kettle:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，马修忘记了一个关键组成部分。在匆忙中，他没有停下来向苏珊娜询问有关用户或问题的更多信息，因此没有考虑到用户可能需要以某种方式拿起热气腾腾的容器。在收到反馈后，他自然而然地为水壶设计并引入了一个手柄：
- en: '![](assets/3c288c5c-13c9-448a-8dc4-e192a232a758.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3c288c5c-13c9-448a-8dc4-e192a232a758.png)'
- en: This needn't have occurred at all, though. Imagine this kettle scenario extrapolated
    to the complexity and length of a large software project spanning multiple months.
    Imagine the headaches and needless pain involved in such a misunderstanding. The
    key to designing a good solution to a problem requires, first and foremost, a
    correct and complete model of the problem. Without this, we'll fail before we
    even begin. This matters in the design of massive projects but also in the implementation
    of the smallest JavaScript utilities and components. In every line of code we
    write, in fact, we are utterly liable to failure if we do not first understand
    the problem domain.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这完全没有必要发生。想象一下，将这种水壶情景推广到跨越多个月的大型软件项目的复杂性和长度。想象一下在这样的误解中涉及的头痛和不必要的痛苦。解决问题的关键在于首先正确和完整地理解问题。如果没有这一点，我们甚至在开始之前就会失败。这在设计大型项目中很重要，但也在实现最小的JavaScript实用程序和组件中很重要。事实上，在我们编写的每一行代码中，如果我们不首先了解问题领域，我们都将完全有可能失败。
- en: The problem domain encapsulates not only the problem being encountered by the
    user but also the problem of meeting their needs via the technologies we have
    available. And so, the problem domain of writing JavaScript in the browser, for
    example, includes the complexity of HTTP, the browser object model, the DOM, CSS,
    and a litany of other details. A good JavaScript programmer has to be adept not
    only in these technologies but also in understanding new domains of problems encountered
    by their users.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 问题领域不仅包括用户遇到的问题，还包括通过我们可用的技术来满足他们需求的问题。因此，例如，在浏览器中编写JavaScript的问题领域包括HTTP的复杂性，浏览器对象模型，DOM，CSS以及其他一系列细节。一个优秀的JavaScript程序员不仅必须精通这些技术，还必须理解用户遇到的新问题领域。
- en: Writing code for humans
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为人类编写代码
- en: This entire book is concerned with teaching you how to write clean code in JavaScript.
    In the following chapters, we'll go into a lot of detail, with discussions of
    almost every construct within the language. Firstly, we need to establish a few
    key perspectives that'll be important when we think about what it means to write
    clean code for humans.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 整本书都致力于教你如何在JavaScript中编写干净的代码。在接下来的章节中，我们将详细讨论几乎语言中的每个构造。首先，我们需要确定几个重要的观点，在我们考虑为人类编写干净代码意味着什么时，这些观点将非常重要。
- en: Communicating intent
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 沟通意图
- en: 'We can say that writing code for humans is broadly about the clarity of intent.
    And writing code for machines is broadly about functionality. These needs do cross
    over, of course, but it''s vital to discern the difference. We can see the difference
    if we were writing code only for the machine, focusing purely on function, and
    forgetting the human audience. Here''s an example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，为人类编写代码在广义上是关于意图的清晰度。而为机器编写代码在广义上是关于功能性。当然，这些需求会交叉，但是区分这种差异是至关重要的。如果我们只为机器编写代码，只关注功能，忘记了人类的受众，我们就能看到这种区别。这里有一个例子：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Do you understand what this code is doing? You may be able to decipher what's
    going on in this code, but it is intent—its true meaning—will be almost impossible
    to discern.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你明白这段代码在做什么吗？你可能能够解释这段代码在做什么，但它的意图——它的真正含义——几乎不可能被理解。
- en: 'If we clearly express our intent then the preceding code would look something
    like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们清楚地表达我们的意图，那么前面的代码看起来会像这样：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From the preceding code, we can discern that this function is intended to calculate
    the number of times a heart has beaten since birth. There is no functional difference
    between these two pieces of code. However, the latter code better communicates
    the programmer's intentions, and thus is easier to understand and to maintain.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看出这个函数的意图是计算自出生以来心脏跳动的次数。这两段代码之间在功能上没有区别。然而，后一段代码更好地传达了程序员的意图，因此更容易理解和维护。
- en: 'The code we write is primarily for people. You may be building a brochure website,
    programming a web application, or crafting a complex utility function for a framework.
    All of these things are for people: people who are the end users of GUIs driven
    by our code or people who are the programmers making use of our abstractions and
    interfaces. Programmers are in the business of helping these people.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的代码主要是为了人类。你可能正在构建一个宣传网站，编写一个Web应用程序，或者为框架制作一个复杂的实用函数。所有这些都是为人类而做的：那些作为我们代码驱动的GUI的最终用户，或者那些使用我们抽象和接口的程序员。程序员的业务是帮助这些人。
- en: Even if you're writing code only for yourself, with no possibility of it being
    used in any way by anyone else, your future self will thank you if you write clear
    code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你只是为自己编写代码，没有任何可能被其他人以任何方式使用，如果你写出清晰的代码，你未来的自己会感谢你。
- en: Readability
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可读性
- en: When we write code, it's essential to consider how human brains will consume
    it. Fellow programmers will scan over your code, reading the pertinent parts,
    attempting to gain a running comprehension of its inner workings. Readability
    is the first hurdle that they must overcome. If they are unable to read and cognitively
    navigate the code you've written then they'll be less able to use it. This will
    drastically limit the utility and value of your code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写代码时，考虑人类大脑如何消化它是至关重要的。其他程序员会扫视你的代码，阅读相关部分，试图对其内部运作有一个运行的理解。可读性是他们必须克服的第一个障碍。如果他们无法阅读和认知地导航你写的代码，那么他们将更难使用它。这将严重限制你的代码的效用和价值。
- en: Programmers, in my experience, don't tend to like thinking of code in terms
    of aesthetic design, but the best programmers will appreciate that these concepts
    are intrinsically intertwined. The design of our code in a presentational or visual
    sense is as vital to its comprehensibility as its architectural design. Design,
    in the end, is about creating something in a way that optimally delivers a purpose
    for its users. For our fellow programmers, that purpose is comprehension. And
    so we must *design* our code to deliver that purpose.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，程序员不太喜欢以审美设计的方式思考代码，但是最好的程序员会欣赏到这些概念是内在联系的。我们代码的设计在呈现或视觉意义上与其架构设计一样重要。设计最终是关于以最佳方式为用户提供目的的创造。对于我们的同行程序员，这个目的是理解。因此，我们必须*设计*我们的代码来实现这个目的。
- en: 'Machines care purely about specifications and will parse valid code into its
    parts with little effort. Humans, however, are more complex. We are less capable
    in areas where machines excel, hence their existence, but we are also skillful
    in areas where machines may falter. Our highly evolved brains, among their many
    talents, have become incredibly skilled at spotting patterns and inconsistencies.
    We rely on difference, or contrast, to focus our attention. If a pattern is not
    being followed then it creates more work for our brains. For an example of such
    inconsistency, have a look at this code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 机器纯粹关心规范，并会轻松地将有效的代码解析成其部分。然而，人类更加复杂。我们在机器擅长的领域能力较弱，这也是它们存在的原因，但我们在机器可能失败的领域也很有技巧。我们高度进化的大脑，在其众多才能中，已经变得非常擅长发现模式和不一致之处。我们依赖差异或对比来集中我们的注意力。如果一个模式没有被遵循，那么对我们的大脑来说就会产生更多的工作。举个不一致的例子，看看这段代码：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You probably don't enjoy looking at this code. Its messiness is distracting
    and it appears to follow no particular pattern. The naming and spacing are inconsistent.
    Our brains struggle with this, and so reading the code, and building a full understanding
    of it, becomes more cognitively expensive.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不喜欢看这段代码。它的混乱让人分心，似乎没有遵循任何特定的模式。命名和间距是不一致的。我们的大脑在这方面很吃力，因此阅读代码，对其有一个完整的理解，变得更加认知昂贵。
- en: 'We might refactor the preceding code to be more consistent, like so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重构前面的代码，使其更加一致，如下所示：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we've used a single naming pattern and have employed consistent syntax
    and spacing in every statement.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了单一的命名模式，并在每个语句中采用了一致的语法和间距。
- en: 'Alternatively, perhaps we would like to declare all variables within a single `var` declaration
    and align the assignment (`=`) operators so that all values start along the same
    vertical axis:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也许我们想在单个`var`声明中声明所有变量，并对齐赋值（`=`）运算符，使所有值沿着相同的垂直轴开始：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You'll notice that these different styles are very subjective. Some people prefer
    one way. Other people prefer another way. And that's okay. I am not stating which
    approach is superior. Instead, I am pointing out that if we care about writing
    code for humans, then we should care, first and foremost, about its readability
    and presentation, and consistency is a key part of that.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这些不同的风格非常主观。有些人喜欢一种方式，其他人喜欢另一种方式。这都没问题。我并没有说哪种方法更优越。相反，我指出，如果我们关心为人类编写代码，那么我们应该首先关心其可读性和表现，而一致性是其中的关键部分。
- en: Meaningful abstractions
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有意义的抽象
- en: 'As we write code, we use and create abstractions constantly. Abstraction is
    what occurs when we take a piece of complexity and then present access to that
    complexity in a simpler way. By doing this, we enable people to have leverage
    over that complexity without having to wield a full understanding of it. This
    idea underpins most modern technology:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写代码时，我们不断使用和创建抽象。抽象是当我们将复杂性简化后提供对该复杂性的访问时发生的。通过这样做，我们使人们能够利用这种复杂性，而无需完全理解它。这个想法支撑着大多数现代技术：
- en: '![](assets/7abb032a-9e22-4a41-b548-d276c2cd1e9a.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7abb032a-9e22-4a41-b548-d276c2cd1e9a.png)'
- en: JavaScript, like many other high-level languages, presents an abstraction that
    enables us not to have to worry about the details of how a computer operates.
    We can, for example, ignore the problem of memory allocation. Even though we must
    be sensitive to the constraints of hardware, especially on mobile devices, we'll
    rarely ever think about it. The language doesn't require us to.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript，像许多其他高级语言一样，提供了一种抽象，使我们不必担心计算机的运行细节。例如，我们可以忽略内存分配的问题。即使我们必须对硬件的限制敏感，特别是在移动设备上，我们很少会考虑它。语言不要求我们这样做。
- en: The browser, too, is a famous abstraction. It provides a GUI that abstracts
    away, among many other things, the details of HTTP communication and HTML rendering.
    Users can easily browse the internet without ever having to worry about these
    mechanisms.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器也是一个著名的抽象。它提供了一个图形用户界面，抽象掉了HTTP通信和HTML渲染等许多细节。用户可以轻松地浏览互联网，而无需担心这些机制。
- en: 'In the following chapters of this book, we''ll learn more about what it takes
    to craft a good abstraction. For now, it''s enough to say this: in every line
    of code you write, you are using, creating, and communicating abstractions.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后续章节中，我们将学习更多关于如何打造良好抽象的知识。目前，可以说：在你写的每一行代码中，你都在使用、创建和传达抽象。
- en: The tower of abstraction
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象的塔
- en: 'The tower of abstraction is a way of looking at the complexity of technology.
    At the base layer, we have the hardware mechanisms depended upon in computation,
    such as transistors in the CPU and memory cells in RAM. Above that, we have integrated
    circuits. Above that, you have machine code, assembly, and the operating system.
    And above that, several layers up, you have the browser, and its JavaScript runtime.
    Each layer abstracts away complexity so that the layer above can leverage that
    complexity without too much effort:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象的塔是一种看待技术复杂性的方式。在基础层，我们有计算中依赖的硬件机制，如CPU中的晶体管和RAM中的存储单元。在上面，我们有集成电路。再上面，有机器码、汇编语言和操作系统。再上面，有几层，有浏览器和其JavaScript运行时。每一层都将复杂性抽象化，以便上面的层可以在不费太多力气的情况下利用这种复杂性：
- en: '![](assets/77a01dcf-ce28-45b6-985e-136495a0ce12.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/77a01dcf-ce28-45b6-985e-136495a0ce12.png)'
- en: When we write JavaScript for the browser, we are already operating on a very
    tall tower of abstraction. The higher this tower gets, the more precariously it
    operates. We are dependent on every individual part working as expected. It's
    a fragile system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为浏览器编写JavaScript时，我们已经在一个非常高的抽象塔上操作。这座塔越高，操作起来就越不稳定。我们依赖于每个部分都按预期工作。这是一个脆弱的系统。
- en: The tower of abstraction is a useful analogy when thinking about our users as
    well. When we write code, we are adding to this tower, building upon it layer
    by layer. Our users will always be situated above us on this tower, using the
    machinery we've crafted to drive their own ends. These users may be other programmers
    that utilize our code, building yet more layers of abstraction into the system.
    Alternatively, our users may be the *end *users of the software, typically sitting
    atop the tower and leveraging its vast complexity by a simplified GUI.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑我们的用户时，抽象的塔是一个有用的比喻。当我们编写代码时，我们正在为这座塔增添东西，一层又一层地建造。我们的用户总是位于这座塔的上方，利用我们精心打造的机制来实现他们自己的目标。这些用户可能是利用我们的代码的其他程序员，为系统增加更多的抽象层。或者，我们的用户可能是软件的最终用户，通常坐在塔顶，通过简化的图形用户界面利用其庞大的复杂性。
- en: The layers of clean code
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 干净代码的层次
- en: In the next part of the book, we will take the foundational concepts we've talked
    about in this chapter and build atop them with our own abstractions; these abstractions
    are the ones we, in the software industry, use to talk about what it means to
    write clean code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一部分中，我们将以本章讨论的基本概念为基础，并用我们自己的抽象来构建；这些抽象是我们在软件行业中用来谈论编写干净代码意味着什么的抽象。
- en: If we say that our software is reliable or usable, then we are employing abstract
    concepts. And these concepts must be delved into. We will also be unpicking the
    innards of JavaScript in later chapters, seeing what it means to deal with the
    individual pieces of syntax that power our programs. By the end of the book, we
    should be able to say that we have complete knowledge of multiple layers of clean
    code, from individually readable lines of code to well-designed and reliable architectures.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们说我们的软件是可靠的或可用的，那么我们正在运用抽象概念。这些概念必须被深入挖掘。在后面的章节中，我们还将剖析JavaScript的内部，看看处理支撑我们程序的语法的各个部分意味着什么。到本书结束时，我们应该能够说我们对从单独可读的代码行到设计良好且可靠的架构的多个层次的干净代码有完整的了解。
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have built ourselves a great foundation, exploring the very
    fundamentals that underpin all of the code we write. We have discussed how our
    code is an expression of intent, and how, in order to build that intent, we must
    have a sound understanding of what the user requires and the problem domain we
    are engaging in. We have also explored how we can write code that is clear and
    readable to humans, and how we can create clear abstractions that provide users
    with the ability to leverage complexity.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们已经为自己打下了良好的基础，探索了支撑我们所有编写的代码的基本原理。我们已经讨论了我们的代码如何表达意图，以及为了构建这种意图，我们必须对用户需求和我们所涉及的问题领域有深刻的理解。我们还探讨了如何编写对人类清晰易读的代码，以及如何创建清晰的抽象，为用户提供利用复杂性的能力。
- en: 'In the next chapter, we will build on this foundation with the specific tenets
    of clean code: reliability, efficiency, maintainability, and usability. These
    tenets will be lending us a vital perspective as we go on to study the many facets
    of JavaScript and how we can wield it in the service of clean code.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将以清晰代码的具体原则：可靠性、效率、可维护性和可用性，来进一步构建这一基础。这些原则将为我们提供重要的视角，因为我们将继续研究JavaScript的许多方面，以及我们如何运用它来服务于清晰的代码。
