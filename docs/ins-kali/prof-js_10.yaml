- en: '*Chapter 10*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*'
- en: Functional Programming with JavaScript
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaScript进行函数式编程
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Use pure functions in Redux reducers and selectors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Redux减速器和选择器中使用纯函数
- en: Solve advanced function testing situations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决高级函数测试情况
- en: Apply currying, partial application, and closures in modern JavaScript applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现代JavaScript应用程序中应用柯里化、部分应用和闭包
- en: Implement a compose function for use in a backend for frontend (BFF) built with
    micro
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为在使用微服务构建的前端后端（BFF）中使用组合函数
- en: Apply JavaScript built-ins to write in an immutable style specifically in a
    Redux application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用JavaScript内置函数以在Redux应用程序中以不可变的方式编写
- en: Implement a query and a mutation in the context of a BFF using GraphQL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在BFF的上下文中使用GraphQL实现查询和变异
- en: Select from three approaches to handle side effects in a React/Redux application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从三种方法中选择处理React/Redux应用程序中的副作用
- en: In this chapter, you will learn about the concepts of functional programming,
    how to apply them in JavaScript, and identify them "in the wild" in popular libraries
    such as React, Redux, and systems such as the GraphQL query language.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习函数式编程的概念，如何在JavaScript中应用它们，并在流行的库（如React、Redux）和系统（如GraphQL查询语言）中识别它们。
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: '**Functional programming** leans heavily on the mathematical definition of
    functions. Mathematical functions are defined through a declaration expression.
    The functional programming style is also declarative (as opposed to imperative
    programming) and promotes expressions over statements.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数式编程**在数学函数的定义上有很大依赖。数学函数是通过声明表达式定义的。函数式编程风格也是声明式的（与命令式编程相对），并且提倡表达式而不是语句。'
- en: JavaScript has functional programming constructs built into it. Unlocking the
    functional programming style in JavaScript is crucial to reaching a deeper understanding
    of the language and its ecosystem.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中内置了函数式编程构造。解锁JavaScript中的函数式编程风格对于更深入地理解语言及其生态系统至关重要。
- en: As part of each section, React, Redux, and DOM access and testing patterns in
    JavaScript will be used to illustrate pragmatic functional programming in JavaScript.
    More recent developments such as GraphQL and **backend for frontends** (**BFFs**)
    will also be included to show how functional programming permeates both the present
    and the future of the JavaScript programming language.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 作为每个部分的一部分，将使用React、Redux和JavaScript中的DOM访问和测试模式来说明JavaScript中实用的函数式编程。还将包括最近的发展，如GraphQL和**前端后端**（**BFFs**），以展示函数式编程如何渗透到JavaScript编程语言的现在和未来。
- en: Functional programming concepts can explain why Redux reducers and React render
    functions can't contain API calls. A lot of JavaScript patterns and best practices
    are enabled by functional constructs in the language; leveraging functional programming
    leads to more expressive, concise JavaScript programs that are easier to reason
    about, modify, and extend.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程概念可以解释为什么Redux减速器和React渲染函数不能包含API调用。很多JavaScript模式和最佳实践都是由语言中的函数式构造实现的；利用函数式编程可以实现更具表现力、简洁的JavaScript程序，更易于理解、修改和扩展。
- en: Functions – First-Class Citizens
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数-一流公民
- en: Functions being **first-class** means they are considered by the language to
    be like any other "value" type. This means that, in JavaScript, a function can
    be used just like a number, a string, a Boolean, an array, an object, and so on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 函数作为**一流**意味着它们被语言视为与任何其他“值”类型一样。这意味着在JavaScript中，函数可以像数字、字符串、布尔值、数组、对象等一样使用。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Now would probably be a good time to see how well-versed in JavaScript data
    types everyone is. The primitives are Boolean, Null, Undefined, Number, (BigInt),
    String, Symbol, Object à Array/Set/Map. They can be found under the Object data
    type.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能是时候看看每个人对JavaScript数据类型有多熟练了。原始数据类型包括布尔值、空值、未定义值、数字、（大整数）、字符串、符号、对象 à 数组/集合/映射。它们可以在对象数据类型下找到。
- en: First-Class Functions – Idiomatic JavaScript Building Blocks
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一流函数-成熟的JavaScript构建模块
- en: Another way to define first-class support is as "functions are first-class if
    they are regular values." That means that a function can be assigned (as a value)
    to a variable, passed into other functions as a parameter, and be the return value
    of another function. Let's try and understand the preceding concept with code
    examples.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一流支持的另一种方式是“如果函数是常规值，则函数是一流的”。这意味着函数可以被赋值（作为值）给一个变量，作为参数传递给其他函数，并且可以是另一个函数的返回值。让我们尝试用代码示例来理解前面的概念。
- en: 'A function can be assigned to a variable in JavaScript and applied to function
    expressions (as follows) and arrow functions. A variable can hold a reference
    to an already defined function or a function that''s been declared inline. The
    function can be named or anonymous:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数可以被赋值给变量，并应用于函数表达式（如下所示）和箭头函数。变量可以保存对已定义函数的引用，或者内联声明的函数。函数可以是命名的，也可以是匿名的：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A function can be set as a value in an Array:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以作为数组中的值：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A function can be set as a value in an object. This example uses ECMAScript
    6/2015 shorthand properties and methods. We also assert that the output of `Module.fn`
    is the same as the output of `fn`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以作为对象中的值。此示例使用ECMAScript 6/2015的简写属性和方法。我们还断言`Module.fn`的输出与`fn`的输出相同：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A function can be passed as an argument to another function:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可以作为参数传递给另一个函数：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Inversion of Control Using First-Class Functions
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用一流函数的控制反转
- en: Having first-class functions in JavaScript means that injecting a dependency
    can be as small as passing a function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中拥有一流函数意味着注入依赖可以像传递函数一样小。
- en: In languages where functions are not first-class, we might have to pass an object
    (instance of a class) into a constructor to be able to inject a dependency into
    the consumer of said dependency. In JavaScript, we can leverage the fact that
    functions are first-class citizens and simply inject a function implementation.
    The simplest example of this comes from the preceding `runner` function. It calls
    whatever function is passed into it as a parameter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数不是一等公民的语言中，我们可能需要将一个对象（类的实例）传递给构造函数，以便将依赖项注入到该依赖项的消费者中。在JavaScript中，我们可以利用函数是一等公民这一事实，简单地注入函数实现。这种情况的最简单示例来自前面的`runner`函数。它调用作为参数传递给它的任何函数。
- en: This type of dependency is very useful in JavaScript. Types are dynamic and
    tend to go unchecked. The benefit of class and class types such as checked errors
    and method overloading don't exist in JavaScript.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种依赖关系在JavaScript中非常有用。类型是动态的，往往不受检查。类和类类型的好处，比如检查错误和方法重载，在JavaScript中并不存在。
- en: JavaScript functions have a simple interface. They are called with zero or more
    parameters and cause side effects (network requests, file I/O) and/or output some
    data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript函数具有简单的接口。它们被调用时带有零个或多个参数，并引起副作用（网络请求、文件I/O）和/或输出一些数据。
- en: In a dependency injection scenario without types or type checks, passing a single
    function instead of a whole instance is very beneficial for the dependency's consumer
    (the code where the dependency is injected into).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有类型或类型检查的依赖注入场景中，传递单个函数而不是整个实例对于依赖项的消费者（依赖项注入的代码）非常有益。
- en: The following example illustrates a scenario where a JavaScript application
    can be run both on the client and the server. This is called a universal JavaScript
    application, that is, a JavaScript program that runs both in Node.js and in browsers.
    Universal JavaScript is usually achieved through a combination of build tools
    and patterns such as dependency injection.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了一种情景，即JavaScript应用程序可以在客户端和服务器上运行。这称为通用JavaScript应用程序，即在Node.js和浏览器中都运行的JavaScript程序。通用JavaScript通常通过构建工具和依赖注入等模式的组合来实现。
- en: In this case, when an HTTP call is made server-side, a header-based authorization
    mechanism is used. When the HTTP call is made from the client, a cookie-based
    authorization mechanism is used.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当服务器端进行HTTP调用时，使用基于头的授权机制。当从客户端进行HTTP调用时，使用基于cookie的授权机制。
- en: 'See the following function definition:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的函数定义：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Server-side code that consumes `getData` would look like the following, where
    an `axios` function instance is created to default the authorization header. This
    function instance is then passed as `transport` to `getData`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 消耗`getData`的服务器端代码如下所示，其中创建了一个`axios`函数实例来默认授权头。然后将此函数实例作为`transport`传递给`getData`：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Client-side code that consumes `getData` would look like the following. Again,
    an `axios` function instance is created, this time with the `withCredentials`
    option (which enables the sending/receiving of cookies) enabled:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 消耗`getData`的客户端代码如下所示。再次创建了一个`axios`函数实例，这次使用了`withCredentials`选项（启用了发送/接收cookie）：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding example shows how we can leverage first-class function support
    to share code between applications running in different JavaScript environments
    by delegating the implementation of the transport mechanism for the HTTP request.
    Passing a function as a parameter is the idiomatic JavaScript way to do dependency
    injection.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例展示了我们如何利用一等函数支持来在不同的JavaScript环境中运行的应用程序之间共享代码，方法是委托HTTP请求的传输机制的实现。将函数作为参数传递是JavaScript中依赖注入的惯用方式。
- en: Functions that Enable Asynchronous I/O and Event-Driven Programming in JavaScript
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在JavaScript中启用异步I/O和事件驱动编程的功能
- en: I/O, that is, non-blocking, and the JavaScript event loop are at the core of
    JavaScript's popularity both for browser-based applications and more recently
    server-side applications with Node.js. JavaScript is single-threaded, which means
    it is easy to reason about. Race conditions and deadlocks are nearly impossible
    to find in a JavaScript program.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: I/O，即非阻塞，以及JavaScript事件循环是JavaScript在基于浏览器的应用程序和最近的Node.js服务器端应用程序中受欢迎的核心。JavaScript是单线程的，这意味着很容易理解。在JavaScript程序中几乎不可能找到竞争条件和死锁。
- en: JavaScript's asynchronous programming model of non-blocking interactions with
    input and output mechanisms means that if a program is I/O-bound, JavaScript is
    a very efficient way to handle it. JavaScript doesn't wait for the I/O to finish;
    instead, it schedules for the code to resume execution when the I/O has completed
    using the event loop.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的异步编程模型是非阻塞交互的输入和输出机制，这意味着如果程序受到I/O限制，JavaScript是处理它的一种非常有效的方式。JavaScript不会等待I/O完成；相反，它会使用事件循环安排代码在I/O完成时恢复执行。
- en: For event-driven programming, the function is a lightweight container for logic
    that needs to be executed at a later point in time. Functions and event-driven
    programming in JavaScript have led to patterns such as the `addEventListener`
    Web API, the Node.js error-first callback, and the subsequent move to an A+ Promise-compliant
    specification in ECMAScript 6/ECMAScript 2015.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于事件驱动编程，函数是需要在以后执行的逻辑的轻量级容器。JavaScript中的函数和事件驱动编程导致了诸如`addEventListener` Web
    API、Node.js错误优先回调以及随后在ECMAScript 6/ECMAScript 2015中移动到A+ Promise兼容规范等模式。
- en: All the patterns here expose a function that accepts a function as one of its
    parameters.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的所有模式都公开了一个接受函数作为其参数之一的函数。
- en: 'The `addEventListener` Web API allows JavaScript programs running in the browser
    to execute a function when an event occurs on a DOM element; for example, we can
    listen to `scroll`, `click`, or keyboard events. The following example will print
    `Scrolling…` if you scroll. It should be run in a browser JavaScript environment:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`addEventListener` Web API允许在浏览器中运行的JavaScript程序在DOM元素上发生事件时执行函数；例如，我们可以监听`scroll`、`click`或键盘事件。以下示例将在滚动时打印`Scrolling…`。它应该在浏览器JavaScript环境中运行：'
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Node.js error-first callbacks are used in any I/O API it exposes. The following
    example shows how to handle errors from the Node.js filesystem module, `fs`. The
    callback that''s passed always has an error property as its first parameter. This
    error is `null` or `undefined` when there is no error and has an `Error` value
    if an error occurs:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 使用错误优先回调来处理其暴露的任何 I/O API。下面的例子展示了如何处理来自 Node.js 文件系统模块 `fs` 的错误。传递的回调始终具有一个错误属性作为其第一个参数。当没有错误时，此错误为
    `null` 或 `undefined`，如果发生错误，则具有一个 `Error` 值：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The Web Fetch API exposes an A+ Promise implementation. An A+ Promise is an
    object that encapsulates asynchronous logic and has `.then` and `.catch` functions,
    which accept a function as a parameter. Promises are a more recent and advanced
    way to abstract I/O in JavaScript compared to the error-first Node.js callback
    approach. The Fetch API is not available natively in Node.js; however, it is available
    as an npm module for use in Node.js. This means that the following code works
    in Node.js:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Web Fetch API 提供了 A+ Promise 实现。A+ Promise 是一个封装了异步逻辑并具有 `.then` 和 `.catch`
    函数的对象，这些函数接受一个函数作为参数。与 Node.js 的错误优先回调方法相比，Promise 是 JavaScript 中抽象 I/O 的一种更近期和更高级的方式。Fetch
    API 在 Node.js 中不是原生可用的；然而，它作为一个 npm 模块可用于在 Node.js 中使用。这意味着以下代码在 Node.js 中可用：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'More recent versions of Node.js (10+) expose a Promise interface for some of
    its APIs. The following is equivalent to the earlier filesystem access and error
    handling but using the Promise interface instead of error-first callbacks:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 更近期的 Node.js 版本（10+）为其一些 API 暴露了 Promise 接口。以下代码等同于之前的文件系统访问和错误处理，但使用了 Promise
    接口而不是错误优先回调：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: JavaScript Built-In Array Methods that Showcase First-Class Function Support
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript 内置的数组方法展示了一流函数的支持
- en: JavaScript comes with several built-in methods on the Array object. A lot of
    these methods showcase first-class function support.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 自带了一些数组对象的内置方法。其中许多方法展示了一流函数的支持。
- en: 'The `Array#map` function returns the array of the output of the function that''s
    passed and is applied to each element. The following example shows a common use
    case, which is to convert an array of objects into an array of primitive values
    by extracting a certain object key for each element. In this case, the `id` property
    of the objects is returned in a new array:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array#map` 函数返回传递的函数应用于每个元素后的输出数组。下面的例子展示了一个常见的用例，即通过提取每个元素的特定对象键将对象数组转换为原始值数组。在这种情况下，对象的
    `id` 属性在新数组中返回：'
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `Array#filter` function returns elements of the array for which the function
    passed as a parameter returns a truthy value. In the following case, we filter
    out any element that is less than or equal to 2:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array#filter` 函数返回数组中使得作为参数传递的函数返回真值的元素。在下面的例子中，我们过滤掉任何小于或等于 2 的元素：'
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Array#reduce` function takes a function parameter is called for each element
    with an accumulator and the current element value. `Reduce` returns the last output
    of the passed function parameter. It is used to change the shape of the array,
    for example, summing over each element in the array:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array#reduce` 函数接受一个函数参数，对每个元素使用累加器和当前元素值调用该函数。`reduce` 返回传递的函数参数的最后输出。它用于改变数组的形状，例如对数组中的每个元素求和：'
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `Array#flatMap` function returns the flattened output of the function that''s
    passed as a parameter and is applied to each of the elements in the array. The
    following example is a case where the new array is double the length of the initial
    one since we return a pair of values for `flatMap` to flatten into an array:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array#flatMap` 函数返回作为参数传递的函数应用于数组中每个元素后的扁平化输出。下面的例子中，新数组的长度是初始数组的两倍，因为我们为
    `flatMap` 返回了一对值，以便扁平化成一个数组：'
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`flatMap` is a stage 4 feature that''s works in Node.js 11+ and is supported
    natively in Chrome 69+, Firefox 62+, and Safari 12+.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap` 是一个第四阶段的特性，在 Node.js 11+ 中可用，并且在 Chrome 69+、Firefox 62+ 和 Safari
    12+ 中原生支持。'
- en: 'The `Array#forEach` function calls the function that''s passed as a parameter
    on each element of the array. It is equivalent to a for loop, except it can''t
    be broken. The function that''s passed will always be called on each element:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array#forEach` 函数对数组中的每个元素调用传递的函数。它相当于一个 for 循环，但无法中断。传递的函数将始终对每个元素调用：'
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Array#find` function calls the function that''s passed as a parameter
    on each element of the array until the function returns a truthy value, at which
    point it returns that value or there are no more elements to call it against,
    at which point it returns `undefined`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array#find` 函数对数组中的每个元素调用传递的函数，直到函数返回真值为止，此时返回该值，或者没有更多元素可以调用函数时返回 `undefined`：'
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `Array#findIndex` function calls the function that''s passed as a parameter
    on each element of the array until the function returns a truthy value, at which
    point it returns the index or there are no more elements to call it against, at
    which point it returns `-1`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array#findIndex` 函数对数组中的每个元素调用作为参数传递的函数，直到函数返回真值为止，此时返回该元素的索引，或者没有更多元素可以调用函数时返回
    `-1`：'
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `Array#every` function calls the function that''s passed as a parameter
    on each element of the array. At each iteration, if the passed function returns
    a `false` value, `.every` breaks and returns `false`. If `.every` gets to the
    end of the array without the function that''s being passed as the parameter returning
    a `false` value, it returns `true`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array#every` 函数对数组中的每个元素调用传递的函数。在每次迭代中，如果传递的函数返回 `false` 值，`.every` 将中断并返回
    `false`。如果 `.every` 在不让传递的函数返回 `false` 值的情况下到达数组末尾，它将返回 `true`：'
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `Array#some` function calls the function that''s passed as a parameter
    on each element of the array. At each iteration, if the passed function returns
    a truthy value, `.some` breaks and returns `true`. If `.some` gets to the end
    of the array without the function that''s being passed as the parameter returning
    a truthy value, it returns `false`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array#some` 函数在数组的每个元素上调用传递的函数。在每次迭代中，如果传递的函数返回一个真值，`.some` 就会中断并返回 `true`。如果
    `.some` 在不传递函数作为参数返回真值的情况下到达数组的末尾，它就会返回 `false`：'
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Array#sort` function calls the function that''s passed as a parameter
    to sort the array. The passed function is called with two elements of the array
    (which we will call `a` and `b`). If it returns a value greater than 0, `a` will
    appear before `b` in the sorted array. If the comparison function returns a value
    less than 0, `b` will appear before `a` in the sorted array. If the comparison
    function returns a value equal to 0, `a` and `b` will appear in the same order
    as in the original array, that is, relative to each other:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array#sort` 函数调用传递的函数来对数组进行排序。传递的函数会用数组的两个元素（我们将称之为 `a` 和 `b`）来调用。如果它返回大于
    0 的值，`a` 将出现在排序后的数组中的 `b` 之前。如果比较函数返回小于 0 的值，`b` 将出现在排序后的数组中的 `a` 之前。如果比较函数返回等于
    0 的值，`a` 和 `b` 将按照原始数组中的顺序出现，即相对于彼此：'
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are other Array methods, specifically ones that operate on non-function
    arguments. This is a good way to show how much more powerful the methods that
    support passing a function are.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他数组方法，特别是那些对非函数参数进行操作的方法。这是展示支持传递函数的方法有多么强大的好方法。
- en: 'Exercise 70: Re-Implementing includes, indexOf, and join with some, findIndex,
    and reduce'
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 70：使用 some、findIndex 和 reduce 重新实现 includes、indexOf 和 join
- en: In this exercise, you will reimplement `Array#includes`, `Array#indexOf`, and
    `Array#join` using the array methods `Array#some`, `Array#findIndex`, and `Array#reduce`
    by leveraging first-class function support. They are more powerful versions of
    their primitive-only counterparts.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用数组方法 `Array#some`、`Array#findIndex` 和 `Array#reduce` 来重新实现 `Array#includes`、`Array#indexOf`
    和 `Array#join`，利用一级函数支持。它们是原始方法的更强大版本。
- en: 'The final output of `npm run Exercise70` should have all the assertions passing.
    This means that we have now got `includes`, `indexOf`, and `join` functions that
    are compliant with the following assertions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run Exercise70` 的最终输出应该让所有断言都通过。这意味着我们现在有了符合以下断言的 `includes`、`indexOf`
    和 `join` 函数：'
- en: '`includes` should return true if the value is in array.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值在数组中，`includes` 应该返回 true。
- en: '`includes` should return false if the value is in array.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值在数组中，`includes` 应该返回 false。
- en: '`indexOf` should return the index if the value in the array.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值在数组中，`indexOf` 应该返回索引。
- en: '`indexOf` should return `-1` if value not in the array.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值不在数组中，`indexOf` 应该返回 `-1`。
- en: '`join` should work with no delimiter passed.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join` 应该不带分隔符工作。'
- en: '`join` should work with a comma delimiter.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join` 应该使用逗号作为分隔符。'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In this exercise, we will have tests and a skeleton for the methods in the starter
    file, `exercise-re-implement-array-methods-start.js`. The file can be run with
    `node exercise-re-implement-array-methods-start.js`. This command has been aliased
    with npm scripts to `npm run Exercise70`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在起始文件 `exercise-re-implement-array-methods-start.js` 中为这些方法编写测试和骨架。可以使用
    `node exercise-re-implement-array-methods-start.js` 运行这个文件。这个命令已经在 npm 脚本中别名为
    `npm run Exercise70`。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成这个练习：
- en: 'Change the current directory to `Lesson10`. This allows us to use pre-mapped
    commands to run our code. Now, run the `npm run Exercise70` command (or `node
    exercise-re-implement-array-methods-start.js`):'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前目录更改为 `Lesson10`。这样我们就可以使用预先映射的命令来运行我们的代码。现在，运行 `npm run Exercise70` 命令（或
    `node exercise-re-implement-array-methods-start.js`）：
- en: Note
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: npm scripts are defined in the `scripts` section of `package.json`. The working
    solution for this exercise can be run using the `npm run` `Exercise70.js`. `The`
    file on GitHub.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: npm 脚本是在 `package.json` 的 `scripts` 部分定义的。可以使用 `npm run` `Exercise70.js` 运行这个练习的工作解决方案。文件在
    GitHub 上。
- en: '![Figure 10.1: Initial output of npm run exercise1'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.1：运行 npm run exercise1 的初始输出'
- en: '](Images/C14587_10_01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_01.jpg)'
- en: 'Figure 10.1: Initial output of npm run Exercise70'
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.1：运行 npm run Exercise70 的初始输出
- en: These errors show that the tests that have been provided are currently failing
    because the implementations don't work as expected (since they currently do nothing).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误表明提供的测试当前失败，因为实现不符合预期（因为它们目前什么也不做）。
- en: 'Implement `includes` in `exercise-re-implement-array-methods-start.js`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `exercise-re-implement-array-methods-start.js` 中实现 `includes`：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There is an `includes` skeleton that we will replace. The function we can use
    to implement includes is `.some`. What we will do is check that any/some element
    of the array is equal to the `needle` parameter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个我们将替换的 `includes` 骨架。我们可以用来实现 includes 的函数是 `.some`。我们将检查数组的任何/一些元素是否等于 `needle`
    参数。
- en: 'Run `npm run Exercise70`. This should give the following output, which means
    that `includes` works as expected according to our two assertions (the assertion
    errors for `includes` are gone):![Figure 10.2: Output after implementing includes'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `npm run Exercise70`。这应该给出以下输出，这意味着 `includes` 按照我们的两个断言正常工作（`includes` 的断言错误已经消失）：![图
    10.2：实现 includes 后的输出
- en: '](Images/C14587_10_02.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_02.jpg)'
- en: 'Figure 10.2: Output after implementing includes'
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10.2：实现 includes 后的输出
- en: The `needle` is a primitive type, so doing `el === needle` is good enough if
    we need to compare something.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`needle` 是一个原始类型，所以如果我们需要比较某些东西，`el === needle` 就足够了。'
- en: 'Use `.findIndex` to implement `indexOf`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `.findIndex` 来实现 `indexOf`：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After this step, running `npm run Exercise70` should give the following output,
    which means that `indexOf` works as expected according to our two assertions (the
    assertion errors for `indexOf` are gone):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步之后，运行 `npm run Exercise70` 应该给出以下输出，这意味着 `indexOf` 按照我们的两个断言正常工作（`indexOf`
    的断言错误已经消失）：
- en: '![Figure 10.3: Output after implementing includes and indexOf'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.3：实现 includes 和 indexOf 后的输出'
- en: '](Images/C14587_10_03.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_03.jpg)'
- en: 'Figure 10.3: Output after implementing includes and indexOf'
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.3：实现包含和indexOf后的输出
- en: Finally, we will implement `join` using `.reduce`. This function is trickier
    to implement since `reduce` is a very generic traversal/accumulation operator.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用`.reduce`来实现`join`。这个函数更难实现，因为`reduce`是一个非常通用的遍历/累加运算符。
- en: 'Start by concatenating the accumulator with the current element:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '首先，将累加器与当前元素连接起来:'
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run `npm run Exercise70`. You will see that "should work with no delimiter
    passed" now passes:![Figure 10.4: Implementing includes, indexOf, and a naïve
    join'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `npm run Exercise70`。您将看到“不应传递分隔符”现在通过了:![图10.4：实现包含、indexOf和天真的连接
- en: '](Images/C14587_10_04.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_04.jpg)'
- en: 'Figure 10.4: Implementing includes, indexOf, and a naïve join'
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.4：实现包含、indexOf和天真的连接
- en: 'In addition to concatenating the accumulator with the current element, add
    the delimiter in between them:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '除了将累加器与当前元素连接起来，还要在它们之间添加分隔符:'
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Following is the output of the preceding code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '以下是前面代码的输出:'
- en: '![Figure 10.5: Final output of npm after running the exercise'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.5：运行练习后npm的最终输出'
- en: '](Images/C14587_10_05.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_05.jpg)'
- en: 'Figure 10.5: Final output of npm after running the exercise'
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.5：运行练习后npm的最终输出
- en: This exercise shows how functions that support passing another function into
    them are more powerful than their equivalents, which only receive primitive parameters.
    We have shown this by reimplementing the primitive parameter functions using their
    function-parameter counterparts.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习展示了支持将另一个函数传递给它们的函数比仅接收原始参数的函数更强大。我们通过使用函数参数的对应项重新实现了原始参数函数来证明这一点。
- en: In the next exercise, we will show you another JavaScript use case for Array
    functions that support function parameters.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将向您展示另一个JavaScript用例，用于支持函数参数的数组函数。
- en: 'Exercise 71: Computing the Price of a Basket Using Map and Reduce'
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习71：使用Map和Reduce计算购物篮的价格
- en: In this exercise, you will use the array's `map`, `filter`, and `reduce` functions
    to complete a simple transformation from a list of line items to a basket's total
    cost.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用数组的`map`、`filter`和`reduce`函数来完成从线项目列表到购物篮总成本的简单转换。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In this exercise, you will have tests and a skeleton for the methods in the
    starter file, `exercise-price-of-basket-start.js`. The file can be run with `node
    exercise-price-of-basket-start.js`. This command has been aliased with npm scripts
    to `npm run Exercise71`. The working solution for this exercise can be run using
    the `npm run Exercise71` file on GitHub.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将在起始文件`exercise-price-of-basket-start.js`中有测试和方法的框架。可以使用`node exercise-price-of-basket-start.js`运行该文件。这个命令已经被别名为npm脚本`npm
    run Exercise71`。可以在GitHub上使用`npm run Exercise71`文件运行这个练习的工作解决方案。
- en: 'Change the current directory to `Lesson10`. This allows us to use pre-mapped
    commands to run our code. Run `npm run Exercise71` (or `node exercise-price-of-basket-start.js`).
    You will see the following:![Figure 10.6: Initial output of npm run'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前目录更改为`Lesson10`。这样我们就可以使用预先映射的命令来运行我们的代码。运行 `npm run Exercise71`（或 `node
    exercise-price-of-basket-start.js`）。您将看到以下内容:![图10.6：npm运行的初始输出
- en: '](Images/C14587_10_06.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_06.jpg)'
- en: 'Figure 10.6: Initial output of npm run'
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.6：npm运行的初始输出
- en: 'The failing assertions show that our skeleton implementation doesn''t output
    what it is supposed to since the contents of `basket1` should tally to `5197`
    and the contents of `basket2` should tally to `897`. We can run this calculation
    manually: *1 * 199 + 2 * 2499* is *5197* and *2 * 199 + 1 * 499* is *897*.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的断言表明，我们的框架实现没有输出它应该输出的内容，因为`basket1`的内容应该合计为`5197`，`basket2`的内容应该合计为`897`。我们可以手动运行这个计算：*1
    * 199 + 2 * 2499* 是 *5197*，*2 * 199 + 1 * 499* 是 *897*。
- en: 'First, get the line item price, which is done by mapping over each item in
    `totalBasket` and multiplying `item.price` by `item.quantity`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '首先，获取行项目价格，这是通过在`totalBasket`中的每个项目上进行映射并将`item.price`乘以`item.quantity`来完成的:'
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Running `npm run Exercise71` should give you the following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '运行`npm run Exercise71`应该给出以下输出:'
- en: '![Figure 10.7: Output of npm run and totalBasket with line item calculation
    in a .map'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.7：npm运行和totalBasket的输出，包括在.map中计算行项目'
- en: '](Images/C14587_10_07.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_07.jpg)'
- en: 'Figure 10.7: Output of npm run and totalBasket with line item calculation in
    a .map'
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.7：npm运行和totalBasket的输出，包括在.map中计算行项目
- en: Note how the assertions are still failing since we're not adding the line item
    prices up; we're just returning an array of the line item price.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，断言仍然失败，因为我们没有将行项目价格相加；我们只是返回了一个行项目价格的数组。
- en: 'Next, use `reduce` to sum the accumulator and current line item price, and
    remove the `console.log`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '接下来，使用`reduce`来对累加器和当前行项目价格进行求和，并删除`console.log`:'
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The final output of `npm run Exercise71` should not have assertion errors:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run Exercise71`的最终输出不应该有断言错误:'
- en: '![Figure 10.8: Final output with totalBasket implemented'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.8：实现totalBasket的最终输出'
- en: '](Images/C14587_10_08.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_08.jpg)'
- en: 'Figure 10.8: Final output with totalBasket implemented'
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.8：实现totalBasket的最终输出
- en: 'Adding the `reduce` step sums over the line item prices that we calculated
    with the initial `map`. Now `totalBasket` returns the correct total price for
    both `basket1` and `basket2`, which is `5197` and `897`, respectively. Hence,
    the following assertions are now true:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '添加`reduce`步骤对我们用初始`map`计算的行项目价格进行求和。现在`totalBasket`返回了`basket1`和`basket2`的正确总价格，分别为`5197`和`897`。因此，以下断言现在为真:'
- en: '`basket1` should tally up to `5197`.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`basket1`应该合计为`5197`。'
- en: '`basket2` should tally up to `897`.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`basket2`应该合计为`897`。'
- en: This exercise shows how to use map and reduce to first transform an array of
    objects into an array of primitive values and then aggregate data from that intermediate
    array.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习展示了如何使用map和reduce首先将对象数组转换为原始值数组，然后从中间数组中聚合数据。
- en: Child-Parent Component Communication in React
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在React中进行子父组件通信
- en: The popular JavaScript user interface library React leverages the first-class
    nature of functions in JavaScript for its Component API interface.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的JavaScript用户界面库React利用JavaScript中函数的一流特性来实现其组件API接口。
- en: A Component only explicitly receives props from the component that is consuming
    it. This consumption of one Component by another in React is usually referred
    to as rendering since its own rendering is the only place where one component
    can use another.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 组件只能明确地从消费它的组件接收属性。在React中，一个组件被另一个组件消费的过程通常被称为渲染，因为它自己的渲染是唯一可以使用另一个组件的地方。
- en: 'In this situation, the parent component (the one that renders) can pass props
    to the child component (the one that is being rendered), like so:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，渲染的父组件（渲染的组件）可以将属性传递给正在渲染的子组件，如下所示：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In contrast to other popular user interface libraries such as Vue.js and Angular
    where there are two concepts for parent-child communication, in Vue.js, props
    are passed from parent to child and events are emitted from the child to the parent.
    In Angular, input binding is used for passing data from the parent to child. The
    parents listen to events that are emitted by the child and react to them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他流行的用户界面库（如Vue.js和Angular）不同，在Vue.js中，属性从父级传递到子级，事件从子级发出到父级。在Angular中，使用输入绑定将数据从父级传递到子级。父级监听子级发出的事件并对其做出反应。
- en: 'React does not expose a construct that allows data to be passed back to the
    parent; there are only props. To achieve child-parent communication, React champions
    a pattern whereby a function is passed as a prop to the child. The passed function
    is defined in the parent''s context and therefore can do what it wishes in that
    parent component, such as updating the state, triggering a Redux action, and so
    on:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: React没有公开的构造允许数据传递回父级；只有属性。为了实现子父通信，React提倡一种模式，即将一个函数作为属性传递给子级。传递的函数在父级上下文中定义，因此可以在父组件中执行其所需的操作，例如更新状态，触发Redux动作等：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This pattern also exposes one of the big problems of first-class functions
    in JavaScript. When mixing classes/instances and first-class functions, by default,
    the function on a class instance object is not automatically bound to it. In other
    words, we have the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式还暴露了JavaScript中一流函数的一个重大问题。当混合类/实例和一流函数时，默认情况下，类实例对象上的函数不会自动绑定到它。换句话说，我们有以下情况：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Callback props are core to any sort of child-parent communication in React since
    their props are the only way to communicate from parent to child and child to
    parent. The next activity aims to implement an `onCheckout` prop that the consumer
    of the `Basket` component can use to react when the Basket's checkout button is
    clicked.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 回调属性对于React中任何类型的子父通信都是核心的，因为它们的属性是从父级到子级和从子级到父级的唯一通信方式。下一个活动旨在实现一个`onCheckout`属性，使`Basket`组件的消费者在单击Basket的结账按钮时可以做出反应。
- en: 'Activity 15: onCheckout Callback Prop'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动15：onCheckout回调属性
- en: In this activity, we will implement an `onCheckout` prop to display the number
    of items in the shopping cart during checkout.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将实现一个`onCheckout`属性，以在结账时显示购物车中商品的数量。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Activity 15 comes with a preconfigured development server and a skeleton for
    the methods in the starter files, that is, `activity-on-checkout-prop-start.js`
    and `activity-on-checkout-prop-start.html`. The development server can be run
    with `npm run Activity15`. The working solution for this activity can be run using
    the npm run `Activity15` file on GitHub.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 活动15配备了一个预配置的开发服务器和起始文件中方法的框架，即`activity-on-checkout-prop-start.js`和`activity-on-checkout-prop-start.html`。可以使用`npm
    run Activity15`运行开发服务器。此活动的工作解决方案可以在GitHub上使用npm run `Activity15`文件运行。
- en: Change the current directory to `Lesson10` and run `npm install` if you haven't
    done so in this directory before. `npm install` downloads the dependencies that
    are required in order to run this activity (React and Parcel). This command is
    an alias of `npx parcel serve activity-on-checkout-prop-start.html`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您之前没有在此目录中执行过，将当前目录更改为`Lesson10`并运行`npm install`。`npm install`会下载运行此活动所需的依赖项（React和Parcel）。此命令是`npx
    parcel serve activity-on-checkout-prop-start.html`的别名。
- en: Go to `http://localhost:1234` (or whichever URL the start script output) to
    see the HTML page.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 `http://localhost:1234`（或者启动脚本输出的任何URL）以查看HTML页面。
- en: Click on the **Proceed to checkout** button. You will notice that nothing happens.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**继续结账**按钮。您会注意到什么都没有发生。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 625.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第625页找到。
- en: The next exercise will show you how to leverage state and props to add a product
    to our basket. This exercise's starting code isn't strictly the same as what we
    finished with after the activity. For example, the state was hoisted from the
    Basket component to the `App` component.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个练习将向您展示如何利用状态和属性将产品添加到我们的购物篮中。这个练习的起始代码并不严格与我们在活动结束后完成的代码相同。例如，状态是从Basket组件提升到了`App`组件。
- en: 'Exercise 72: Adding a Product to the Basket'
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习72：向购物篮添加产品
- en: In this exercise, we will modify the `addProduct` method to update the number
    of items in the basket when the `Add to basket` option is clicked.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将修改`addProduct`方法，以在单击`添加到购物篮`选项时更新购物篮中商品的数量。
- en: Note
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Exercise 72 comes with a preconfigured development server and a skeleton for
    the methods in the starter files, that is, `exercise-add-product-start.js` and
    `exercise-add-product-start.html`. The development server can be run with `npm
    run Exercise72`. This command is an alias of `npx parcel serve exercise-add-product-start.html`.
    The working solution for this exercise can be run using the `npm run Exercise72`
    file on GitHub.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 练习72配备了一个预配置的开发服务器和起始文件中方法的框架，即`exercise-add-product-start.js`和`exercise-add-product-start.html`。可以使用`npm
    run Exercise72`运行开发服务器。此命令是`npx parcel serve exercise-add-product-start.html`的别名。可以在GitHub上使用`npm
    run Exercise72`文件运行此练习的工作解决方案。
- en: 'Change the current directory to `Lesson10`. Run `npm install` if you haven''t
    done so in this directory before. Now, run `npm run Exercise 72`. You will see
    the application starting up, as follows:![Figure 10.9: Output of npm run Exe'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前目录更改为“Lesson10”。如果您以前没有在此目录中这样做，请运行“npm install”。现在运行“npm run Exercise 72”。您将看到应用程序启动，如下所示：![图10.9：运行npm
    run Exe
- en: '](Images/C14587_10_09.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_09.jpg)'
- en: 'Figure 10.9: Output of npm run Exercise 72'
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.9：运行npm run Exercise 72的输出
- en: For the development server to live-reload our changes and to avoid configuration
    issues, edit the `exercise-add-product-start.js` file directly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使开发服务器实时重新加载我们的更改并避免配置问题，请直接编辑“exercise-add-product-start.js”文件。
- en: 'Go to `http://localhost:1234` (or whichever URL the start script output). You
    should see the following HTML page:![Figure 10.10: Initial application in the
    browser'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`http://localhost:1234`（或者启动脚本输出的任何URL）。您应该看到以下HTML页面：![图10.10：浏览器中的初始应用程序
- en: '](Images/C14587_10_10.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_10.jpg)'
- en: 'Figure 10.10: Initial application in the browser'
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.10：浏览器中的初始应用程序
- en: When clicking of **Add to Basket**, the application crashes and shows a blank
    HTML page.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“添加到篮子”时，应用程序崩溃并显示空白HTML页面。
- en: Update `App#addProduct` to fix the crashes.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新“App＃addProduct”以修复崩溃。
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Instead of setting the basket value to `{}`, we use the JavaScript Array''s
    `concatenate` method to take the current items in the basket (`this.state.basket.items`)
    and add the passed-in `product` parameter with `quantity: 1`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是将篮子的值设置为`{}`，而是使用JavaScript数组的`concatenate`方法来获取篮子中的当前项目（`this.state.basket.items`）并添加传入的`product`参数，其数量为1。
- en: 'To find out what happens when we click **Add to Basket**, we need to find the
    `onClick` handler for the **Add to Basket** button and then diagnose the issue
    with the `this.addProduct()` call (basket being set to `{}`):'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找出单击“添加到篮子”时会发生什么，我们需要找到“添加到篮子”按钮的“onClick”处理程序，然后诊断“this.addProduct()”调用的问题（篮子被设置为`{}`）：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When we click the **Add to Basket** button, we will see the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们单击“添加到篮子”按钮时，我们将看到以下内容：
- en: '![Figure 10.11: Implemented Add to Basket after 1 click'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.11：单击后实现添加到篮子'
- en: '](Images/C14587_10_11.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_11.jpg)'
- en: 'Figure 10.11: Implemented Add to Basket after one click'
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.11：单击一次后实现添加到篮子
- en: 'When we click **Add to Basket** again, we will see the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次单击“添加到篮子”时，我们将看到以下内容：
- en: '![Figure 10.12: Implemented Add to Basket after 2 clicks'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.12：单击2次后实现添加到篮子'
- en: '](Images/C14587_10_12.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_12.jpg)'
- en: 'Figure 10.12: Implemented Add to Basket after two clicks'
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.12：单击两次后实现添加到篮子
- en: First-Class Functions in React Render Props
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: React中的一级函数渲染属性
- en: Render props are a React component pattern where a component delegates the rendering
    of a whole area to its parent.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染属性是一种React组件模式，其中组件将整个区域的呈现委托给其父组件。
- en: A render prop is a function that returns JSX (since it needs to be renderable).
    It tends to be called with child-specific data. That data is then used by the
    implementation of the prop to render JSX. This pattern is very popular with library
    authors since it means they can focus on implementing the logic of the component
    without having to worry about how to allow the user to override the rendered output
    (since it is all delegated back to the user).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染属性是一个返回JSX的函数（因为它需要可呈现）。它往往会使用特定于子级的数据进行调用。然后，实现属性的数据由于呈现JSX而使用。这种模式在库作者中非常受欢迎，因为这意味着他们可以专注于实现组件的逻辑，而不必担心如何允许用户覆盖呈现的输出（因为这一切都被委托给用户）。
- en: 'A very simple example of a render prop is to delegate the rendering to the
    parent component, but the action or data comes from the component that exposes
    a render prop. `ExitComponent` wraps the `window.close()` functionality but delegates
    render to its `renderExit` prop:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染属性的一个非常简单的例子是将呈现委托给父组件，但操作或数据来自公开渲染属性的组件。“ExitComponent”包装了“window.close（）”功能，但将呈现委托给其“renderExit”属性：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This means that, for example, our `ExitComponent` can be used for both the links
    and buttons on the exit page.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，例如，我们的“ExitComponent”可以用于退出页面上的链接和按钮。
- en: 'This is what the `ExitButton` code might look like:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是“ExitButton”代码可能看起来像的样子：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note how the actual page exit logic is not handled anywhere in the component;
    it is all left up to `ExitComponent` to implement. The rendering of the button
    is fully handled here; `ExitComponent` doesn't have to know about it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，实际页面退出逻辑在组件中没有处理；一切都由“ExitComponent”来实现。按钮的渲染完全在这里处理；“ExitComponent”不需要知道它。
- en: The following is how an `ExitLink` component might be implemented. Again, note
    how `ExitComponent` knows nothing about links and how `ExitLink` knows nothing
    about closing the window.;
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是“ExitLink”组件可能实现的方式。再次注意，“ExitComponent”对链接一无所知，“ExitLink”对关闭窗口一无所知。
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Exercise 73: Rendering Basket Contents with a Render Prop'
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习73：使用渲染属性呈现篮子内容
- en: In this exercise, we will use render props to render items to the shopping basket,
    thereby making a flexible Basket component.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用渲染属性将商品呈现到购物篮中，从而使得篮子组件更加灵活。
- en: Note
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Exercise 73 comes with a preconfigured development server and a skeleton for
    the methods in the starter files, that is, `exercise-render-prop-start.js` and
    `exercise-render-prop-start.html`. The development server can be run with `npm
    run Exercise73`. This command is an alias of `npx parcel serve exercise-render-prop-start.html`.
    The working solution for this exercise can be run using the `npm run Exercise73`
    file on GitHub.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 练习73配有预配置的开发服务器和起始文件中方法的骨架，即“exercise-render-prop-start.js”和“exercise-render-prop-start.html”。可以使用“npm
    run Exercise73”运行开发服务器。此命令是“npx parcel serve exercise-render-prop-start.html”的别名。可以在GitHub上使用“npm
    run Exercise73”文件运行此练习的工作解决方案。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: 'Change the current directory to `Lesson10` and run `npm install` if you haven''t
    done so in this directory before. `npm install` downloads the dependencies that
    are required in order to run this activity (React and Parcel). Now, run `npm run
    Exercise73`. You will see the application starting up, as follows:![Figure 10.13:
    Output after running the start file'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您以前没有在此目录中这样做，请将当前目录更改为`Lesson10`并运行`npm install`。`npm install`下载所需的依赖项，以便运行此活动（React和Parcel）。现在，运行`npm
    run Exercise73`。您将看到应用程序启动，如下所示：![图10.13：运行启动文件后的输出
- en: '](Images/C14587_10_13.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_13.jpg)'
- en: 'Figure 10.13: Output after running the start file'
  id: totrans-219
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.13：运行启动文件后的输出
- en: For the development server to live-reload our changes and to avoid configuration
    issues, edit the `exercise-render-prop-start.js` file directly.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使开发服务器实时重新加载我们的更改并避免配置问题，直接编辑`exercise-render-prop-start.js`文件。
- en: 'Go to `http://localhost:1234` (or whichever URL the starting script output).
    You should see the following HTML page:![Figure 10.14: Initial application in
    the browser'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`http://localhost:1234`（或者启动脚本输出的任何URL）。您应该看到以下HTML页面：![图10.14：浏览器中的初始应用程序
- en: '](Images/C14587_10_14.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_14.jpg)'
- en: 'Figure 10.14: Initial application in the browser'
  id: totrans-223
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.14：浏览器中的初始应用程序
- en: 'Find where `Basket` is being rendered and add a `renderItem` prop, which is
    a function from the item to JSX. This is the implementation of the render prop
    that `Basket` will use to render each basket item:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`Basket`被呈现的地方，并添加一个`renderItem`属性，这是从项目到JSX的函数。这是`Basket`将用于呈现每个篮子项目的渲染属性的实现：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Go to the `Basket#render` method and map over each `this.props.items`, using
    `this.props.renderItem` to render the item:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`Basket#render`方法，并映射每个`this.props.items`，使用`this.props.renderItem`来呈现项目：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To see our changes, we can go to the browser and see how the basket items are
    rendered:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们的更改，我们可以转到浏览器，看看篮子项目是如何呈现的：
- en: '![Figure 10.15: Rendering the basket items'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.15：渲染篮子项目'
- en: '](Images/C14587_10_15.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_15.jpg)'
- en: 'Figure 10.15: Rendering the basket items'
  id: totrans-231
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.15：渲染篮子项目
- en: Our `Basket` component now renders the items according to the function that's
    defined by the component rendering it. This makes `Basket` more powerful (it can
    render items) but still highly reusable. In different instances, we could use
    `Basket` with a `renderItem` prop that renders nothing, the breakdown of the item,
    or the line item price for the basket item, for example.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Basket`组件现在根据组件定义的函数呈现项目。这使得`Basket`更加强大（它可以呈现项目），但仍然非常可重用。在不同的实例中，我们可以使用具有`renderItem`属性的`Basket`，该属性不呈现任何内容，项目的分解，或者篮子项目的单价，例如。
- en: First-class functions and the patterns we have covered are crucial to writing
    idiomatic JavaScript. Another way we can leverage functional programming in JavaScript
    is by using pure functions.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第一类函数和我们所涵盖的模式对于编写符合惯用法的JavaScript至关重要。我们在JavaScript中利用函数式编程的另一种方式是使用纯函数。
- en: Pure Functions
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数
- en: '**Pure functions** are functions that don''t have side effects and for the
    same input, arguments will return the same output value(s). A side effect can
    be anything from mutating the value of an argument passed by reference (which
    in JavaScript mutates the original) to mutating the value of a local variable,
    or doing any sort of I/O.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**纯函数**是指没有副作用的函数，对于相同的输入，参数将返回相同的输出值。副作用可以是任何东西，从通过引用传递的参数的值的变异（在JavaScript中变异原始值）到变异本地变量的值，或执行任何类型的I/O。'
- en: A pure function can be thought of as a mathematical function. It only operates
    using input and only affects its own output.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数可以被认为是数学函数。它只使用输入并且只影响自己的输出。
- en: 'Here is a simple pure function, the `identity` function, which returns whatever
    is passed to it as a parameter:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的纯函数，`identity`函数，它返回传递给它的任何内容作为参数：
- en: '[PRE37]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice how there are no side effects and no mutation of parameters or creation
    of new variables. This function doesn't even have a body.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意没有副作用，也没有参数的变异或创建新变量。这个函数甚至没有主体。
- en: Pure functions have the advantage of being simple to reason about. They're also
    easy to test; there is usually no need to mock any dependencies out since any
    and all dependencies should be passed as arguments. Pure functions tend to operate
    on data since they're not allowed to have side effects if data is their only dependency.
    This reduces the testing surface area.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数的优势在于简单易于理解。它们也很容易测试；通常不需要模拟任何依赖关系，因为任何依赖关系都应该作为参数传递。纯函数倾向于操作数据，因为如果数据是它们唯一的依赖关系，它们是不允许有副作用的。这减少了测试表面积。
- en: The cons of pure functions are that pure functions technically can't do anything
    interesting such as I/O, which means no sending of HTTP requests and no database
    calls.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数的缺点是纯函数从技术上讲不能做任何有趣的事情，比如I/O，这意味着不能发送HTTP请求和数据库调用。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: An interesting gap in the definition of pure functions is JavaScript async functions.
    Technically they can still be pure if they don't contain side effects. In practice,
    an async function is likely to be used to run asynchronous operations with `await`
    such as accessing the filesystem, HTTP, or database requests. A good rule of thumb
    is that if a function is async, it likely uses `await` to do some sort of I/O
    and therefore it is not pure.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数定义中的一个有趣的空白是JavaScript异步函数。从技术上讲，如果它们不包含副作用，它们仍然可以是纯的。实际上，异步函数可能被用于使用`await`运行异步操作，例如访问文件系统、HTTP或数据库请求。一个很好的经验法则是，如果一个函数是异步的，它可能使用`await`来执行某种I/O，因此它不是纯的。
- en: Redux Reducers and Actions
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Redux减速器和操作
- en: Redux is a state management library. It imposes a few constraints on the user
    to improve the predictability of state updates and the long-term scalability of
    the codebase.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是一个状态管理库。它对用户施加了一些限制，以提高状态更新的可预测性和代码库的长期可扩展性。
- en: 'Let''s look at a simple Redux counter implementation to highlight some features:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的Redux计数器实现来突出一些特性：
- en: '[PRE38]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The store initializes its state to 0:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 商店将其状态初始化为0：
- en: '[PRE39]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The store''s internal state is only exposed through the read-only interface
    of `getState`. To update the state, an action needs to be dispatched. Calling
    `dispatch` with the `INCREMENT` and `DECREMENT` types show that the `counterReducer`
    works as expected and reduces the actions in the store:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 该商店的内部状态只通过`getState`的只读接口暴露出来。要更新状态，需要分派一个动作。调用`dispatch`与`INCREMENT`和`DECREMENT`类型表明`counterReducer`按预期工作，并减少存储中的动作：
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are three pillars of Redux, as per the Redux documentation: [https://redux.js.org/introduction/three-principles](https://redux.js.org/introduction/three-principles).'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Redux文档，Redux有三个支柱：[https://redux.js.org/introduction/three-principles](https://redux.js.org/introduction/three-principles)。
- en: The three pillars of Redux are illustrated in the preceding example. We have
    a system with a single store, the state is read-only (and accessed through `getState`),
    and changes are made by our reducer, which is a pure function. `counterReducer`
    takes state and an action and returns a new value without mutating `state` or
    `action`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Redux的三个支柱在上面的例子中有所体现。我们有一个具有单一存储的系统，状态是只读的（通过`getState`访问），并且更改是由我们的减速器进行的，它是一个纯函数。`counterReducer`接受状态和动作，并返回一个新值，而不会改变`state`或`action`。
- en: In exchange for following these rules, we get a predictable and performant state
    container for our JavaScript applications. A single store means there is no question
    as to where the state is stored; the read-only state forces updates to be done
    through dispatching actions and reducing them. Since reducers are pure functions,
    they're both easy to test and reason about since they will give the same output
    for the same input and will not cause side effects or unwanted mutations.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些规则，我们可以获得一个可预测且高性能的JavaScript应用程序状态容器。单一存储意味着不需要考虑状态存储在哪里；只读状态强制通过分派动作和减少它们来进行更新。由于减速器是纯函数，它们易于测试和推理，因为对于相同的输入它们将产生相同的输出，并且不会引起副作用或不需要的突变。
- en: Redux is used to manage the state. Up until now, we have been storing our data
    in a React state.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Redux用于管理状态。到目前为止，我们一直将数据存储在React状态中。
- en: 'Exercise 74: Redux Dispatching Actions and Reducing Them into State'
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习74：Redux分派动作并将其减少为状态
- en: In this exercise, we will move the state of our data into Redux in order to
    separate data manipulation and state updates from code that renders data to the
    page.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将把我们的数据状态移到Redux中，以便将数据操作和状态更新与呈现数据到页面的代码分离开来。
- en: Note
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Exercise 74 comes with a preconfigured development server and a skeleton for
    the methods in the starter files, that is, `exercise-redux-dispatch-start.js`
    and `exercise-redux-dispatch-start.html`. The development server can be run with
    `npm run Exercise74`. The working solution for this exercise can be run using
    the `npm run Exercise74` file on GitHub.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 练习74配备了一个预配置的开发服务器和起始文件中方法的骨架，即`exercise-redux-dispatch-start.js`和`exercise-redux-dispatch-start.html`。可以使用`npm
    run Exercise74`运行开发服务器。可以在GitHub上使用`npm run Exercise74`文件运行此练习的工作解决方案。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此练习：
- en: 'Change the current directory to `Lesson10` and run `npm install` if you haven''t
    done so in this directory before. This command is an alias of `npx parcel serve
    exercise-redux-dispatch-start.html`. Now, run `npm run Exercise74`. You will see
    the application starting up, as follows:![Figure 10.16: Output of npm run Exercise74](Images/C14587_10_16.jpg)'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您以前没有在此目录中执行过此操作，请将当前目录更改为`Lesson10`并运行`npm install`。此命令是`npx parcel serve
    exercise-redux-dispatch-start.html`的别名。现在，运行`npm run Exercise74`。您将看到应用程序启动，如下所示：![图10.16：npm
    run Exercise74的输出](Images/C14587_10_16.jpg)
- en: 'Figure 10.16: Output of npm run Exercise74'
  id: totrans-263
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.16：npm run Exercise74的输出
- en: 'Go to `http://localhost:1234` (or whichever URL the starting script output).
    You should see the following HTML page:![Figure 10.17: Initial Exercise74 application
    in the browser](Images/C14587_10_17.jpg)'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`http://localhost:1234`（或者起始脚本输出的任何URL）。您应该看到以下HTML页面：![图10.17：浏览器中的初始Exercise74应用程序](Images/C14587_10_17.jpg)
- en: 'Figure 10.17: Initial Exercise74 application in the browser'
  id: totrans-265
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.17：浏览器中的初始Exercise74应用程序
- en: Notice how clicking the buttons doesn't work.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意点击按钮没有起作用。
- en: 'Implement `App#continueShopping` by dispatching an action of the `CONTINUE_SHOPPING`
    type:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过分派`CONTINUE_SHOPPING`类型的动作来实现`App#continueShopping`：
- en: '[PRE41]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In `appReducer`, implement the corresponding state reduction. For `CONTINUE_SHOPPING`,
    we only need to change the `status` in the state since it is what we use to display
    the checkout view or the main product and basket view:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`appReducer`中，实现相应的状态减少。对于`CONTINUE_SHOPPING`，我们只需要更改状态中的`status`，因为这是我们用来显示结账视图或主产品和购物篮视图的内容：
- en: '[PRE42]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Implement `App#finish` by dispatching an action of the `DONE` type:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过分派`DONE`类型的动作来实现`App#finish`：
- en: '[PRE43]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In `appReducer`, implement the corresponding state reduction. We only need
    to change the `status` in state since it is what we use to display the `Done`
    view:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`appReducer`中，实现相应的状态减少。我们只需要更改状态中的`status`，因为这是我们用来显示`Done`视图的内容：
- en: '[PRE44]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Implement `handleCheckout` by dispatching an action of the `START_CHECKOUT`
    type:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过分派`START_CHECKOUT`类型的动作来实现`handleCheckout`：
- en: '[PRE45]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In `appReducer`, implement the corresponding state reduction. For `START_CHECKOUT`,
    we only need to change the `status` in the state since it is what we use to display
    the checkout view or the main product and basket view:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`appReducer`中，实现相应的状态减少。对于`START_CHECKOUT`，我们只需要更改状态中的`status`，因为这是我们用来显示结账视图或主产品和购物篮视图的内容：
- en: '[PRE46]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The `basket` object is not being reduced, so it can be omitted from the action
    at dispatch.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`basket`对象没有被减少，因此可以在分派时省略。'
- en: 'Implement `addProduct` by dispatching an action as follows. For `ADD_PRODUCT`,
    we need the `newProduct`, as well as the action type:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下方式分派一个动作来实现`addProduct`。对于`ADD_PRODUCT`，我们需要`newProduct`，以及动作类型：
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In `appReducer`, implement the corresponding state reduction, which takes the
    new product and adds it to the current basket of items:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`appReducer`中，实现相应的状态减少，将新产品添加到当前商品篮中：
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `appReducer`, in full, should now look as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`appReducer`完整的应该如下所示：'
- en: '[PRE49]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Go to `http://localhost:1234` (or whichever URL the starting script output).
    The application should now respond to clicks, as expected:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`http://localhost:1234`（或者启动脚本输出的任何URL）。应用现在应该如预期般响应点击：
- en: '![Figure 10.18: Application wo'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.18：应用程序wo'
- en: '](Images/C14587_10_18.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_18.jpg)'
- en: 'Figure 10.18: Application with clicks responding'
  id: totrans-290
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.18：具有响应点击的应用程序
- en: Adding items to baskets and navigating through the application (proceed to checkout,
    done, continue shopping) should behave as it did prior to the Redux store implementation.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 添加物品到购物篮并浏览应用程序（继续结账，完成，继续购物）应该与Redux存储实现之前的行为一样。
- en: Testing Pure Functions
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试纯函数
- en: Pure functions are easy to test since they are fully encapsulated. The only
    thing that can change is the output, that is, the return value. The only thing
    that can affect the output is the parameter/argument values. What's more, for
    the same set of inputs, the output of a pure function needs to be the same.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数很容易测试，因为它们是完全封装的。唯一可以改变的是输出，也就是返回值。唯一可以影响输出的是参数/参数值。而且，对于相同的输入集，纯函数的输出需要是相同的。
- en: 'Testing pure functions is as simple as calling them with different inputs and
    asserting on the outputs:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 测试纯函数就像使用不同的输入调用它们并断言输出一样简单：
- en: '[PRE50]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Redux reducers are pure functions, which means to test them, we can use the
    approach we just looked at in the previous example.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Redux减速器是纯函数，这意味着为了测试它们，我们可以使用我们在上一个示例中刚刚看到的方法。
- en: 'Exercise 75: Testing a Reducer'
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习75：测试减速器
- en: In this exercise, we will write tests for part of the reducer we used in the
    previous exercise, that is, the `ADD_PRODUCT` case of the `appReducer`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将为前一个练习中使用的减速器的一部分编写测试，即`appReducer`的`ADD_PRODUCT`情况。
- en: Note
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Exercise 75 comes with tests and a skeleton for the methods in the starter file,
    `exercise-reducer-test-start.js`. The file can be run with `node exercise-reducer-test-start.js`.
    This command has been aliased with npm scripts to `npm run Exercise75`. The working
    solution for this exercise can be run using the npm run exercise6 file on GitHub.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 练习75带有测试和起始文件中方法的框架，`exercise-reducer-test-start.js`。可以使用`node exercise-reducer-test-start.js`运行文件。这个命令已经被别名为npm脚本的`npm
    run Exercise75`。这个练习的工作解决方案可以在GitHub上使用npm run exercise6文件运行。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成这个练习：
- en: Change the current directory to `Lesson10`. This allows us to use pre-mapped
    commands to run our code.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前目录更改为`Lesson10`。这样我们可以使用预映射的命令来运行我们的代码。
- en: 'Now, run `npm run Exercise75` (or `node exercise-reducer-test-start.js`). You
    will see the following output:![Figure 10.19: Empty tests passing after running
    the start file'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行`npm run Exercise75`（或`node exercise-reducer-test-start.js`）。您将看到以下输出：![图10.19：运行启动文件后空测试通过
- en: '](Images/C14587_10_19.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_19.jpg)'
- en: 'Figure 10.19: Empty tests passing after running the start file'
  id: totrans-305
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.19：运行启动文件后空测试通过
- en: A simplified `appReducer` that only contains the `ADD_PRODUCT` action reduction
    is present in this starter file, along with a `test` function, which is where
    the new tests are going to be added. The output doesn't contain errors because
    we haven't created any tests yet.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这个起始文件中只包含`ADD_PRODUCT`动作减少的简化的`appReducer`，还有一个`test`函数，新的测试将会被添加到这里。输出中没有包含错误，因为我们还没有创建任何测试。
- en: Note
  id: totrans-307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: To get the output of `appReducer`, it should be called with a `state` object
    and the relevant `action`. In this case, the type should be `'ADD_PRODUCT'`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得`appReducer`的输出，它应该被调用与一个`state`对象和相关的`action`。在这种情况下，类型应该是`'ADD_PRODUCT'`。
- en: 'As in the previous examples, we will use `assert.deepStrictEqual`, which checks
    for the deep equality of two objects. We can write a failing test like so. We''re
    calling `appReducer` with `state` and the relevant `action`:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前的示例一样，我们将使用`assert.deepStrictEqual`，它检查两个对象的深度相等性。我们可以这样编写一个失败的测试。我们使用`state`和相关的`action`调用`appReducer`：
- en: '[PRE51]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If we run `npm run Exercise75`, we will see the following error. This is expected
    since `appReducer` doesn''t return an empty object as the state:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`npm run Exercise75`，我们将看到以下错误。这是预期的，因为`appReducer`不会返回一个空对象作为状态：
- en: '![Figure 10.20: Errors shown after executing the start file'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.20：执行启动文件后显示错误'
- en: '](Images/C14587_10_20.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_20.jpg)'
- en: 'Figure 10.20: Errors shown after executing the start file'
  id: totrans-314
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.20：执行启动文件后显示错误
- en: 'We should use `assert.deepStrictEqual` to ensure that `appReducer` adds the
    new product as expected. We will assign the expected value to an `expected` variable
    and the actual value to an `actual` variable. This will help keep the test more
    readable:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该使用`assert.deepStrictEqual`来确保`appReducer`按预期添加新产品。我们将预期值分配给`expected`变量，实际值分配给`actual`变量。这将有助于使测试更可读：
- en: '[PRE52]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output should now not be throwing any errors:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 输出现在不应该抛出任何错误：
- en: '![Figure 10.21: Test passed as no errors were found'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.21：测试通过，因为没有发现错误'
- en: '](Images/C14587_10_21.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_21.jpg)'
- en: 'Figure 10.21: Test passed as no errors were found'
  id: totrans-320
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.21：测试通过，因为没有发现错误
- en: 'The following is the output after we run the `node exercise-reducer-test.js`
    command:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`node exercise-reducer-test.js`命令后，以下是输出：
- en: '![Figure 10.22: Output showing assertion failing'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.22：显示断言失败的输出'
- en: '](Images/C14587_10_22.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_22.jpg)'
- en: 'Figure 10.22: Output showing assertion failing'
  id: totrans-324
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.22：显示断言失败的输出
- en: Redux Selectors
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Redux选择器
- en: Selectors are an additional Redux concept that means we can encapsulate internal
    store state shape with selectors. The consumer of a selector asks for what it
    wants; the selector is left to implement that with store state shape-specific
    knowledge. Selectors are pure functions; they take store state and return one
    or more sections of it.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器是Redux的另一个概念，这意味着我们可以使用选择器封装内部存储状态形状。选择器的使用者要求它想要的东西；选择器则留给使用存储状态形状特定知识来实现。选择器是纯函数；它们接受存储状态并返回一个或多个部分。
- en: Since selectors are pure functions, they are simple to implement. The following
    exercise shows us how to use selectors so that instead of putting messaging data
    in the render function or when passing props, we do it in a pure function.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 由于选择器是纯函数，它们很容易实现。下面的练习向我们展示了如何使用选择器，以便不是将消息数据放在渲染函数中或在传递props时，而是在一个纯函数中进行。
- en: 'Exercise 76: Implementing a Selector'
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习76：实现一个选择器
- en: In this exercise, we will use selectors and take advantage of their simplicity
    to render items to the shopping basket.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用选择器并利用它们的简单性来将项目呈现到购物篮中。
- en: Note
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Exercise 76 comes with a preconfigured development server and a skeleton for
    the methods in the starter files that is, `exercise-items-selector-start.js` and
    `exercise-items-selector-start.html`. The development server can be run with `npm
    run Exercise76`. The working solution for this exercise can be run using the npm
    run Exercise76 file on GitHub.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 练习76带有预配置的开发服务器和起始文件中方法的框架，即`exercise-items-selector-start.js`和`exercise-items-selector-start.html`。可以使用`npm
    run Exercise76`运行开发服务器。可以在GitHub上使用`npm run Exercise76`文件运行此练习的工作解决方案。
- en: Change the current directory to `Lesson10` and run `npm install` if you haven't
    done so in this directory before.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前目录更改为`Lesson10`，如果之前在此目录中尚未运行`npm install`，则运行它。
- en: 'Run `npx parcel serve exercise-items-selector-start.html` and execute `npm
    run Exercise76`. You will see the application starting up, as follows:![Figure
    10.23: Output after running the start html file'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npx parcel serve exercise-items-selector-start.html`并执行`npm run Exercise76`。您将看到应用程序启动，如下所示：![图10.23：运行起始html文件后的输出
- en: '](Images/C14587_10_23.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_23.jpg)'
- en: 'Figure 10.23: Output after running the start html file'
  id: totrans-335
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.23：运行起始html文件后的输出
- en: For the development server to live-reload our changes and to avoid configuration
    issues, edit the `exercise-items-selector-start.js` file directly.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使开发服务器能够实时重新加载我们的更改并避免配置问题，直接编辑`exercise-items-selector-start.js`文件。
- en: 'Go to `http://localhost:1234` (or whichever URL the starting script output).
    You should see the following HTML page:![Figure 10.24: Initial application in
    the browser'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`http://localhost:1234`（或者起始脚本输出的任何URL）。您应该看到以下HTML页面：![图10.24：浏览器中的初始应用程序
- en: '](Images/C14587_10_24.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_24.jpg)'
- en: 'Figure 10.24: Initial application in the browser'
  id: totrans-339
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.24：浏览器中的初始应用程序
- en: 'Note how no basket items are being rendered. This is because of the initial
    implementation of `selectBasketItems`. It returns an empty array:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 注意没有购物篮项目被呈现。这是因为`selectBasketItems`的初始实现。它返回一个空数组：
- en: '[PRE53]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Implement `selectBasketItems` by drilling down into the state with dot notation
    and short-circuiting. Default to `[]` if there is any issue with the state:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用点符号和短路来实现`selectBasketItems`。如果状态有任何问题，则默认为`[]`：
- en: '[PRE54]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The application should now work as expected again; the items will be displayed:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在应该再次按预期工作；项目将被显示：
- en: '![Figure 10.25: Application after implementing selectBasketItems'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.25：实现selectBasketItems后的应用程序'
- en: '](Images/C14587_10_25.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_25.jpg)'
- en: 'Figure 10.25: Application after implementing selectBasketItems'
  id: totrans-347
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.25：实现selectBasketItems后的应用程序
- en: The `selectBasketItems` selector takes the full state and returns a slice of
    it (the items). Selectors allow us to further abstract the internal shape of state
    inside the Redux store from how it is used in the React components.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectBasketItems`选择器获取完整状态并返回其切片（项目）。选择器允许我们进一步将Redux存储库内部状态的形状与在React组件中使用它的方式分离。'
- en: Selectors are a crucial part of a React/Redux application. As we have seen,
    they allow the React components to be decoupled from Redux's internal state shape.
    The following activity aims to give us the ability to write tests for selectors.
    This is a similar scenario to testing a reducer, which we did in a previous exercise.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器是React/Redux应用程序的重要组成部分。正如我们所见，它们允许React组件与Redux的内部状态形状解耦。以下活动旨在使我们能够为选择器编写测试。这与在先前的练习中测试reducer的情况类似。
- en: 'Activity 16: Testing a Selector'
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Activity 16：测试一个选择器
- en: 'In this activity, we will test the selector for various states of the items
    array and ensure that the selector returns an array corresponding to the items
    in the basket. Let''s get started:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将测试项目数组的各种状态的选择器，并确保选择器返回与购物篮中的项目对应的数组。让我们开始吧：
- en: Change the current directory to `Lesson10`. This allows us to use pre-mapped
    commands to run our code.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前目录更改为`Lesson10`。这样可以使用预映射命令来运行我们的代码。
- en: Note
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Activity 16 comes with tests and a skeleton for the methods in the starter file,
    `activity-items-selector-test-start.js`. This file can be run with `node activity-items-selector-test-start.js`.
    This command has been aliased with npm scripts to `npm run Activity16`. The working
    solution for this exercise can be run using the npm run Activity16 file on GitHub.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Activity 16带有测试和起始文件中方法的框架，即`activity-items-selector-test-start.js`。可以使用`node
    activity-items-selector-test-start.js`运行此文件。此命令已经被别名为npm脚本`npm run Activity16`。可以在GitHub上使用`npm
    run Activity16`文件运行此练习的工作解决方案。
- en: 'Inside the test function, using `assert.deepStrictEqual`, do the following:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试函数中，使用`assert.deepStrictEqual`，执行以下操作：
- en: Test that, for empty state(s), the selector returns `[].`
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试一下，对于空状态，选择器返回`[]`。
- en: Test that, for an empty basket object, the selector returns `[].`
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试一下，对于一个空的购物篮对象，选择器返回`[]`。
- en: Test that, if the `items` array is set but empty, the selector returns `[].`
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试一下，如果`items`数组已设置但为空，则选择器返回`[]`。
- en: Test that, if the items array is not empty and set, the selector returns it.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试一下，如果项目数组不为空并已设置，则选择器返回它。
- en: Note
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 626.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第626页找到。
- en: 'Pure functions are predictable, easy to test, and easy to reason about. Both
    first-class functions and pure functions tie into the next JavaScript functional
    programming concept: higher-order functions.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是可预测的，易于测试和易于理解的。一等函数和纯函数都与下一个JavaScript函数式编程概念相关联：高阶函数。
- en: Higher-Order Functions
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高阶函数
- en: A higher-order function is a function that either takes a function as a parameter
    or returns a function as a value.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是一个要么接受函数作为参数，要么返回函数作为值的函数。
- en: This builds on top of JavaScript's first-class function support. In a language
    that doesn't support first-class functions, it is difficult to implement higher-order
    functions.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这是建立在JavaScript的一级函数支持之上的。在不支持一级函数的语言中，实现高阶函数是困难的。
- en: Higher-order functions enable function composition patterns. In most instances,
    we use higher-order functions to augment an existing function.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数实现了函数组合模式。在大多数情况下，我们使用高阶函数来增强现有的函数。
- en: bind, apply, and call
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定、应用和调用
- en: 'There are a few JavaScript built-in methods on the `Function` object: `bind`,
    `apply` and `call`.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function`对象上有一些内置的JavaScript方法：`bind`、`apply`和`call`。'
- en: '`Function#bind` allows you to set the execution context for a function. When
    called, bind returns a new function with the first parameter to the call bound
    as the `this` context of the function. The following arguments to bind are used
    when the returned function is called. When the bound function is called, parameters
    can be supplied. These will appear in the argument list, after the parameters
    are set during the call to bind.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function#bind`允许你为一个函数设置执行上下文。当调用时，bind返回一个新的函数，其中第一个参数被绑定为函数的`this`上下文。bind后面的参数在返回的函数被调用时使用。当绑定的函数被调用时，可以提供参数。这些参数将出现在参数列表中，在调用bind时设置参数之后。'
- en: 'bind is used extensively in React code when passing functions as props that
    still need to access the current component''s `this` to do operations such as
    `setState` or to call other component methods:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在React代码中，当传递函数作为props时，经常使用bind来访问当前组件的`this`进行操作，比如`setState`或调用其他组件方法：
- en: '[PRE55]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `Function#bind` method can also be used when testing that a function is
    thrown in tests. For example, running the function would mean having to write
    a try/catch that somehow fails the test if the catch is not triggered. With bind
    and the `assert` module, this can be written in a much shorter form:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function#bind`方法也可以在测试中用于测试函数是否被抛出。例如，运行函数意味着必须编写一个try/catch，如果catch没有触发，则测试失败。使用bind和`assert`模块，可以以更简洁的形式编写：'
- en: '[PRE56]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`Function#apply` and `Function#call` allow you to call a function without using
    the `fn(param1, param2, [paramX])` syntax, as well as setting the `this` context
    in a similar way to `Function#bind`. The first parameter to `Function#apply` is
    the `this` context, while the second parameter is an array or array-like and contains
    the parameters the function expects. Similarly, the first parameter to `Function#call`
    is the `this` context; the difference in regards to `Function#apply` lies in the
    definition of parameters. In `Function#call`, they''re an argument list, just
    like when using `Function#bind`, as opposed to the array that `Function#apply`
    expects.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function#apply`和`Function#call`允许你调用一个函数，而不使用`fn(param1, param2, [paramX])`的语法，同时以类似`Function#bind`的方式设置`this`上下文。`Function#apply`的第一个参数是`this`上下文，第二个参数是一个数组或类数组，包含函数期望的参数。类似地，`Function#call`的第一个参数是`this`上下文；与`Function#apply`的区别在于参数的定义。在`Function#call`中，它们是一个参数列表，就像使用`Function#bind`时一样，而不是`Function#apply`期望的数组。'
- en: Note
  id: totrans-375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Array-like objects, also known as indexed collections, the most used of which
    are the arguments object in functions, and the NodeList Web API, are objects that
    follow part of the Array API (for example, implementing `.length`) without implementing
    it fully. Array functions can still be used on them with JavaScript's apply/call.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 类数组对象，也称为索引集合，其中最常用的是函数中的arguments对象和NodeList Web API，它们是实现了部分Array API（例如实现`.length`）但没有完全实现的对象。仍然可以使用JavaScript的apply/call在它们上面使用数组函数。
- en: '`Function#apply` and `Function#call` don''t strictly meet the higher-order
    function criteria. At a stretch, since they''re methods on function objects, we
    could say that they''re implicitly higher-order functions. The function object
    they''re called on is an implicit parameter to the apply/call method call. By
    reading from the function prototype, we can even use them like so:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function#apply`和`Function#call`严格来说不符合高阶函数的标准。在某种程度上，因为它们是函数对象的方法，我们可以说它们是隐式的高阶函数。它们被调用的函数对象是apply/call方法调用的隐式参数。通过从函数原型中读取，我们甚至可以这样使用它们：'
- en: '[PRE57]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this example, we show that apply and call are higher-order functions, but
    only in as far as they can be used with functions on other functions.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们展示了apply和call是高阶函数，但只能用于其他函数上的函数。
- en: '`Function#apply` and `Function#call` have historically converted array-like
    objects into Arrays. In ECMAScript 2015+ compliant environments, the `spread`
    operator can be used in a similar fashion.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function#apply`和`Function#call`在历史上将类似数组的对象转换为数组。在符合ECMAScript 2015+的环境中，可以使用`spread`操作符以类似的方式使用。'
- en: 'The three following functions allow you to convert Array-likes into Arrays
    using `Function#apply`, `Function#call`, and array spread, respectively:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个函数允许你使用`Function#apply`、`Function#call`和数组展开将类数组对象转换为数组：
- en: '[PRE58]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Currying and Partial Application
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 柯里化和部分应用
- en: A curried function is a function that, instead of taking the number of parameters
    it needs in one go, will accept one parameter at a time.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化函数是一个函数，它不是一次性接受它需要的参数数量，而是一次接受一个参数。
- en: For example, if a function takes two parameters, its curried equivalent will
    be called twice, with one parameter each time.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个函数接受两个参数，它的柯里化等价物将被调用两次，每次一个参数。
- en: 'Currying can, therefore, be expressed as taking an n-parameter function and
    turning it into a function that can be called n times with one parameter each
    time. The classic denomination for an n-parameter function is to call it n-ary.
    With that in mind, currying is the transformation from an n-ary function to an
    n-length set of unary function calls:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，柯里化可以被表达为将一个n参数函数转化为一个可以被调用n次的函数，每次只有一个参数。n参数函数的经典称呼是n元。因此，柯里化是将一个n元函数转化为n个一元函数调用的转换：
- en: '[PRE59]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Partial application and currying are often introduced together and conceptually,
    they go hand in hand.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用和柯里化经常一起介绍，概念上它们是相辅相成的。
- en: 'With a two-parameter function that is curried, it takes two calls with one
    parameter, with each doing the same work as the two-parameter un-curried function.
    When it is called once, it has half the necessary parameters fully applied. The
    function resulting from that first call is a partial application of the overall
    function:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 使用柯里化的两参数函数，需要两次调用，每次使用一个参数，每次都执行与两参数非柯里化函数相同的工作。当它被调用一次时，它有一半的必要参数完全应用。从第一次调用中得到的函数是整体函数的部分应用：
- en: '[PRE60]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In other words, a partial application is a way of expressing the transformation
    from the function that takes n parameters to a function that takes `n` – `m` parameters,
    where m is the number of parameters that have been partially applied.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，部分应用是一种表达从接受n个参数的函数到接受`n` - `m`个参数的函数的转换的方式，其中m是已部分应用的参数数量。
- en: Currying and partial application are useful if we want to be able to reuse generic
    functionality. The partial application doesn't require currying; currying is the
    case of turning a function into one that can be partially applied. The partial
    application can also be done using bind.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要能够重用通用功能，则柯里化和部分应用非常有用。部分应用不需要柯里化；柯里化是将函数转换为可以部分应用的函数。也可以使用bind进行部分应用。
- en: Currying and partial application allow you to start with a very generic function
    and turn it into a more specialized function with every application.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化和部分应用允许您从一个非常通用的函数开始，并在每次应用时将其转换为更专业的函数。
- en: Currying standardizes the number of parameters at each call. The partial application
    does not have such limitations. You can partially apply with more than one parameter
    at a time.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化在每次调用时标准化参数的数量。部分应用没有这样的限制。您可以一次部分应用多个参数。
- en: A unary function is simpler than a binary function, which is simpler than an
    N-ary (with N > 2) function.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 一元函数比二元函数更简单，二元函数比N元（其中N > 2）函数更简单。
- en: Also, currying is simpler if we only allow one parameter to be applied at any
    time. We can see the arbitrary n-parameter partial application with more runtime
    complexity since each function needs to run some logic on whether this call is
    the final call or not.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们只允许一次应用一个参数，那么柯里化会更简单。我们可以看到任意n参数部分应用具有更多的运行时复杂性，因为每个函数都需要在是否为最终调用上运行一些逻辑。
- en: 'A generic n-ary curry can be defined as follows in ES2015:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES2015中可以定义通用的n元柯里化如下：
- en: '[PRE61]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Leveraging Closures React Function Components
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用闭包React函数组件
- en: 'When defining a function, anything that''s in scope of the function at definition
    time will remain in scope at call/execution time. Historically, closures were
    used to create private variable scopes. The closure is this function and its remembered
    definition-time scope:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义函数时，函数定义时作用域中的任何内容在调用/执行时仍然保持在作用域中。历史上，闭包被用于创建私有变量作用域。闭包是这个函数及其记住的定义时作用域：
- en: '[PRE62]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We leverage this within React render functions to cache props and state in the
    local render scope.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在React渲染函数中利用这一点，以在本地渲染范围中缓存props和state。
- en: 'React function components also leverage closures, especially with hooks:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: React函数组件还利用闭包，特别是使用钩子：
- en: '[PRE63]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Function components are quite powerful since they're a bit simpler than class
    components.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组件非常强大，因为它们比类组件更简单。
- en: When using a state management solution such as Redux, most of the important
    state is in the Redux store. This means that we can write mainly stateless functional
    components since the store manages any stateful part of our application.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Redux等状态管理解决方案时，大部分重要状态都在Redux存储中。这意味着我们可以编写主要是无状态的功能组件，因为存储管理应用程序的任何有状态部分。
- en: Higher-order functions allow us to effectively deal with functions and augment
    them. Higher-order functions build on top of first-class function support and
    pure functions. Much in the same way, function composition builds on higher-order
    functions.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数使我们能够有效地处理函数并增强它们。高阶函数建立在一级函数支持和纯函数之上。同样，函数组合建立在高阶函数之上。
- en: Function Composition
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数组合
- en: Function composition is another concept that leaks over from mathematics.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合是从数学中泄漏出来的另一个概念。
- en: Given two functions, a and b, compose returns a new function that applies a
    to the output of b, which is then applied to a given set of parameters.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个函数a和b，compose返回一个新函数，该函数将a应用于b的输出，然后应用于给定的一组参数。
- en: Function composition is a way to create a complex function from a set of smaller
    ones.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合是一种从一组较小函数创建复杂函数的方法。
- en: This will mean you might end up with a bunch of simple functions that do one
    thing well. Functions with a single purpose are better at encapsulating their
    functionality and therefore help with separation of concerns.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您可能最终会得到一堆做一件事情的简单函数。具有单一目的的函数更擅长封装其功能，因此有助于关注点分离。
- en: 'Composing functions ties in with currying and the partial application of functions
    since currying/partial application is a technique that allows you to have specialized
    versions of generic functions, like so:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 组合函数与柯里化和函数的部分应用相结合，因为柯里化/部分应用是一种允许您拥有通用函数的专业版本的技术，就像这样：
- en: '[PRE64]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To explain the following code, it stands to reason that we have the following:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 要解释以下代码，我们可以得出以下结论：
- en: Doubling 2 and then adding 1 is 5 (4 + 1).
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将2加倍然后加1是5（4 + 1）。
- en: Adding 1 to 2 and then doubling is 6 (3 * 2).
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将1加到2然后加倍是6（3 * 2）。
- en: Adding 2 to 2 and then doubling is 8 (4 * 2).
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将2加到2然后加倍是8（4 * 2）。
- en: Doubling 2 and then adding 2 is 6 (4 + 2).
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将2加倍然后加2是6（4 + 2）。
- en: 'The following uses our already defined functions, `add1`, `add2`, and `double`,
    and shows how we would use `compose` to implement the preceding cases. Note that
    compose applies the rightmost parameter first:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 以下使用我们已经定义的函数`add1`，`add2`和`double`，并展示了如何使用`compose`来实现前面的情况。请注意，compose首先应用最右边的参数：
- en: '[PRE65]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: An alternative way to define `compose` is using a left-to-right traversal (with
    `reduce`). This has the benefit of allowing us to pass an arbitrary number of
    arguments when calling the output of composing. To this effect, we reduce from
    the first parameter to the last parameter, but the output of `reducing` is a function
    that supports any number of arguments and calls the previous output after the
    current function when called.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`compose`的另一种方法是使用从左到右的遍历（使用`reduce`）。这样做的好处是在调用组合输出时允许我们传递任意数量的参数。为此，我们从第一个参数减少到最后一个参数，但是`reducing`的输出是一个支持任意数量参数的函数，并在调用时在当前函数之后调用先前的输出。
- en: 'The following code uses parameter rest to allow for an arbitrary number of
    functions to be composed:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用参数rest来允许任意数量的函数进行组合：
- en: '[PRE66]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Then, it returns a function that takes a single parameter, `x` (hence, it's
    unary). When this second function is called, it will call all the functions that
    were passed as parameters to `composeManyUnary` from right to left (the function
    that was the last parameter will be called first). The first iteration of `reduceRight`
    will call the rightmost function with `x` as its parameter. Subsequent functions
    are called on the output of the previous function call. The second-to-last function
    in the parameter list is called with the output of the last function in the parameter
    list that's applied to `x`. The third-to-last function in the parameter list is
    called with the output of the second-to-last function and so on until there are
    no more functions to call.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它返回一个接受单个参数`x`（因此是一元的）的函数。当调用这个第二个函数时，它将从右到左调用传递给`composeManyUnary`的所有函数（最后一个参数的函数将首先被调用）。`reduceRight`的第一次迭代将使用`x`作为其参数调用最右边的函数。接下来的函数将在前一个函数调用的输出上调用。参数列表中倒数第二个函数将使用参数列表中最后一个函数的输出作为`x`的参数进行调用。参数列表中倒数第三个函数将使用倒数第二个函数的输出，依此类推，直到没有更多的函数可以调用。
- en: 'Exercise 77: A Binary to n-ary Compose Function'
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习77：一个二进制到n-ary组合函数
- en: In this exercise, we will implement an n-ary `compose` function can be used
    to compose an arbitrary number of functions.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现一个n-ary `compose`函数，可以用来组合任意数量的函数。
- en: Note
  id: totrans-428
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Exercise 77 comes with tests and a skeleton for the methods in the starter file,
    `exercise-2-to-n-compose-start.js`. The file can be run with `node exercise-2-to-n-compose-start.js`.
    This command has been aliased with npm scripts to `npm run Exercise77`. The working
    solution for this exercise can be run using the npm run Exercise77 file on GitHub.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 练习77带有测试和起始文件中方法的框架，`exercise-2-to-n-compose-start.js`。可以使用`node exercise-2-to-n-compose-start.js`运行该文件。该命令已经被别名为npm脚本`npm
    run Exercise77`。可以在GitHub上使用npm run Exercise77文件来运行这个练习的工作解决方案。
- en: Change the current directory to `Lesson10`. This allows us to use pre-mapped
    commands to run our code.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前目录更改为`Lesson10`。这样我们可以使用预先映射的命令来运行我们的代码。
- en: 'Now, run `npm run Exercise77` (or `node exercise-to-n-compose-start.js`). You
    will see the following output:![Figure 10.26: Running the start file of the exercise'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行`npm run Exercise77`（或`node exercise-to-n-compose-start.js`）。您将看到以下输出：![图10.26：运行练习的起始文件
- en: '](Images/C14587_10_26.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_26.jpg)'
- en: 'Figure 10.26: Running the start file of the exercise'
  id: totrans-433
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.26：运行练习的起始文件
- en: The assertions for `compose3`, `composeManyUnary`, and `composeManyReduce` are
    all failing, mainly because they're currently aliased to `compose2`.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`compose3`，`composeManyUnary`和`composeManyReduce`的断言都失败了，主要是因为它们当前被别名为`compose2`。'
- en: 'A `compose` for two functions is already implemented:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已经实现了两个函数的`compose`：
- en: '[PRE67]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '`compose3` is a naive three-parameter `compose` function that takes the third
    parameter, calls it first, then calls the second parameter on the output of the
    first call.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`compose3`是一个天真的三参数`compose`函数，它先取第三个参数，然后在第一次调用的输出上调用第二个参数。'
- en: 'Finally, it calls the first parameter on the output of the second parameter,
    like so:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它调用第一个参数在第二个参数的输出上，就像这样：
- en: '[PRE68]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note
  id: totrans-440
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The function that is the furthest to the right of the parameter definition is
    called first.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 参数定义中最右边的函数首先被调用。
- en: Considering the parameters as an array and that JavaScript has a `reduceRight`
    function (which traverses an array from right to left while also keeping an accumulator,
    much like `reduce`), there is a path forward forming.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑参数作为一个数组，并且JavaScript有一个`reduceRight`函数（它从右到左遍历数组，同时保持一个累加器，就像`reduce`一样），有一个形成的前进路径。
- en: 'After implementing `compose3`, we can run `npm run Exercise77` again and see
    that the assertion for `compose3` is not failing anymore:![Figure 10.27: Output
    after implementing compose3'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现`compose3`之后，我们可以再次运行`npm run Exercise77`，看到`compose3`的断言不再失败了：![图10.27：实现compose3后的输出
- en: '](Images/C14587_10_27.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_27.jpg)'
- en: 'Figure 10.27: Output after implementing compose3'
  id: totrans-445
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.27：实现compose3后的输出
- en: 'Use parameter rest to allow for an arbitrary number of functions to be composed:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用参数rest来允许任意数量的函数进行组合：
- en: '[PRE69]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'After implementing `composeManyUnary`, the corresponding failing assertion
    is now passing:![Figure 10.28: Output after implementing compose3 and composeManyUnary'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现`composeManyUnary`之后，相应的失败断言现在通过了：![图10.28：实现compose3和composeManyUnary后的输出
- en: '](Images/C14587_10_28.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_28.jpg)'
- en: 'Figure 10.28: Output after implementing compose3 and composeManyUnary'
  id: totrans-450
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.28：实现compose3和composeManyUnary后的输出
- en: 'Define that compose is using a left-to-right traversal (with `reduce`):'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`compose`使用从左到右的遍历（使用`reduce`）：
- en: '[PRE70]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We can `composeManyReduce` with three functions, that is, `f`, `g`, and `h`.
    Our implementation will start reducing through the functions. At the first iteration,
    it will return a function that will take however many arguments (`args`). When
    called, it will call `f(g(args))`. On the second iteration, it will return a function
    that takes an arbitrary number of arguments and returns `f(g(h(args))`. At this
    point, there are no more functions to iterate through, so the final output of
    a function that takes a set of arguments and returns `f(g(h(arguments)))` is the
    output of the `composeManyReduce` function.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用三个函数`f`，`g`和`h`来`composeManyReduce`。我们的实现将通过这些函数开始减少。在第一次迭代时，它将返回一个函数，该函数将接受任意数量的参数（`args`）。当调用时，它将调用`f(g(args))`。在第二次迭代中，它将返回一个接受任意数量参数并返回`f(g(h(args))`的函数。在这一点上，没有更多的函数可以迭代，因此接受一组参数并返回`f(g(h(arguments)))`的函数的最终输出是`composeManyReduce`函数的输出。
- en: 'After implementing `composeManyReduce`, the corresponding failing assertion
    is now passing:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了`composeManyReduce`之后，相应的失败断言现在通过了：
- en: '![Figure 10.29: Implementing compose3, composeManyUnary, and composeManyReduce'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.29：实现compose3、composeManyUnary和composeManyReduce'
- en: '](Images/C14587_10_29.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_29.jpg)'
- en: 'Figure 10.29: Implementing compose3, composeManyUnary, and composeManyReduce'
  id: totrans-457
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.29：实现compose3、composeManyUnary和composeManyReduce
- en: Function Composition in the Real World with a Simple BFF
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在现实世界中使用简单的BFF进行函数组合
- en: A BFF is a server-side component that wraps (API) functionality in a way that
    is specific to the user interface it serves. This is as opposed to an API that
    is designed to export general business logic. The backend for frontend might consume
    an upstream API or the backing service directly, depending on the architecture.
    A company might have a set of core services to implement business logic and then
    a BFF for their mobile application, another BFF for their web frontend, and a
    final BFF for their internal dashboard. Each of the BFFs will have different constraints
    and data shapes that make the most sense for their respective consumers.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: BFF是一个服务器端组件，以特定于其服务的用户界面的方式包装（API）功能。这与设计用于导出通用业务逻辑的API相对。前端后端可能会消耗上游API或直接使用后端服务，这取决于架构。公司可能有一组核心服务来实现业务逻辑，然后为其移动应用程序创建一个BFF，为其Web前端创建另一个BFF，并为其内部仪表板创建最终的BFF。每个BFF都将具有不同的约束和数据形状，这对于它们各自的消费者来说是最合理的。
- en: General-purpose APIs tend to have a larger surface area, are maintained by a
    different team, and have multiple consumers, which in turn leads to the API's
    shape evolving slowly. The API endpoints are not specific to the user interface,
    so the frontend application might have to make a lot of API requests just to load
    up a single screen. A backend for frontend alleviates these issues since each
    page or screen can have its own endpoint or dataset that it uses. The backend
    for a frontend will orchestrate the fetching of any relevant data.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 通用API往往具有更大的表面积，由不同的团队维护，并且有多个消费者，这反过来导致API的形状演变缓慢。API端点不特定于用户界面，因此前端应用程序可能必须进行大量的API请求才能加载单个屏幕。前端后端可以缓解这些问题，因为每个页面或屏幕可以有自己的端点或数据集。前端后端将协调获取任何相关数据。
- en: To implement the backend for frontend, `micro` will be used. micro is a library
    for "Asynchronous HTTP microservices" and was built by Zeit. It is very small
    compared to Express or Hapi. In order to do this, it leverages modern JavaScript
    features as async/await calls, and its composition model is based on function
    composition. That is, what would be a middleware in Express or Hapi is a higher-order
    function that takes a function as a parameter and returns a new function. This
    is a great opportunity to use `compose` since the interface of the functions that
    are being composed are function in as a parameter and function out as a return
    value.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现前端后端，将使用`micro`。micro是一个用于“异步HTTP微服务”的库，由Zeit构建。与Express或Hapi相比，它非常小。为了做到这一点，它利用了现代JavaScript特性，如async/await调用，其组合模型基于函数组合。也就是说，在Express或Hapi中的中间件是一个以函数作为参数并返回一个新函数的高阶函数。这是一个很好的使用`compose`的机会，因为被组合的函数的接口是以函数作为参数和以函数作为返回值。
- en: Note
  id: totrans-462
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The very brief documentation for micro can be found at [https://github.com/zeit/micro](https://github.com/zeit/micro).
    The library itself is barely a couple of hundred lines of JavaScript.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://github.com/zeit/micro](https://github.com/zeit/micro)找到micro的非常简要的文档。该库本身只有几百行JavaScript代码。
- en: 'A micro "Hello world" might look as follows. micro accepts a single HTTP handler
    function that can be async or not. Either way, it is await-ed. It doesn''t have
    a built-in router, which is one of the core APIs that''s exposed by Express or
    Hapi. The output of the handler is sent back as the HTTP response body with a
    200 status code:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 一个micro的“Hello world”可能如下所示。micro接受一个可以是异步的HTTP处理程序函数。无论哪种方式，都会被等待。它没有内置路由器，这是Express或Hapi公开的核心API之一。处理程序的输出作为HTTP响应主体发送回去，状态码为200：
- en: '[PRE71]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Adding request timer logging can be done with the built-in JavaScript `console.time`
    and `console.timeEnd` functions:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用内置的JavaScript `console.time`和`console.timeEnd`函数来添加请求计时器日志：
- en: '[PRE72]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Function composition is the frontend, while the center of micro is the API.
    Adding a more complex operation such as API key authentication doesn't make integration
    any more difficult.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合是前端，而micro的中心是API。添加诸如API密钥身份验证之类的更复杂操作并不会使集成变得更加困难。
- en: 'The `authenticate` function can have as much complexity as it wants. If it
    accepts a function parameter and returns a function that takes a `req` (request)
    and `res` (response) object, it will be compatible with other micro packages and
    handlers:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`authenticate`函数可以具有任意复杂性。如果它接受一个函数参数并返回一个接受`req`（请求）和`res`（响应）对象的函数，它将与其他micro包和处理程序兼容：'
- en: '[PRE73]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The micro library leverages function composition so that dependencies between
    each level of request handling are made obvious.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: micro库利用函数组合，以便使每个请求处理级别之间的依赖关系变得明显。
- en: 'Exercise 78: Leveraging Compose to Simplify the Micro Server Creation Step'
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习78：利用Compose简化微服务器创建步骤
- en: In this exercise, you will refactor the timer and authentication example from
    the previous section to use `compose`.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将重构前一节中的计时器和身份验证示例，以使用`compose`。
- en: Note
  id: totrans-474
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Exercise 78 comes with a preconfigured server and a run method alias in the
    starter files, that is, `exercise-micro-compose-start.js`. The server can be run
    with `npm run Exercise78`. The working solution for this exercise can be run using
    the npm run Exercise78 file on GitHub.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 练习78带有预配置的服务器和在起始文件中的run方法别名，即`exercise-micro-compose-start.js`。可以使用`npm run
    Exercise78`运行服务器。可以在GitHub上使用npm run Exercise78文件运行此练习的工作解决方案。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此练习：
- en: Change the current directory to `Lesson10` and run `npm install` if you haven't
    done so in this directory before.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前目录更改为`Lesson10`，如果之前没有在此目录中这样做，请运行`npm install`。
- en: 'First, run the `node exercise-micro-compose-start.js` command. Then run `npm
    run Exercise78`. You will see the application starting up, as follows:![Figure
    10.30: Running the start file of this exercise'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先运行`node exercise-micro-compose-start.js`命令。然后运行`npm run Exercise78`。您将看到应用程序启动，如下所示：![图10.30：运行此练习的start文件
- en: '](Images/C14587_10_30.jpg)'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_30.jpg)'
- en: 'Figure 10.30: Running the start file of this exercise'
  id: totrans-480
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.30：运行此练习的start文件
- en: 'Accessing the application with the following `curl` should yield an unauthorized
    response:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下`curl`访问应用程序应该会产生未经授权的响应：
- en: '[PRE74]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The following is the output of the preceding code:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 10.31: cURL of the micro application'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.31：微应用的cURL'
- en: '](Images/C14587_10_31.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_31.jpg)'
- en: 'Figure 10.31: cURL of the micro application'
  id: totrans-486
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.31：微应用的cURL
- en: Note that the compose function is pre-populated in this module.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，compose函数在此模块中预先填充。
- en: 'Instead of calling each function on the output of the previous one, we will
    use compose and call its output to create the server. This will replace the server-creation
    step:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用compose而不是在上一个函数的输出上调用每个函数，并调用其输出来创建服务器。这将替换服务器创建步骤：
- en: '[PRE75]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The server-creation step initially looked as follows, which is quite verbose
    and possibly difficult to read. The `compose` version clearly shows the pipeline
    that a request will have to come through:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的服务器创建步骤如下，这相当冗长，可能难以阅读。`compose`版本清楚地显示了请求将经过的管道：
- en: '[PRE76]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Restart the application for the changes to take place. Once `npm run Exercise78`
    is up and running, you should be able to `curl`:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动应用程序以使更改生效。一旦`npm run Exercise78`运行起来，您应该能够`curl`：
- en: '[PRE77]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Following is the output of the preceding code:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 10.32: cURL of the micro application with "compose"'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.32：使用“compose”的微应用的cURL'
- en: '](Images/C14587_10_32.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_32.jpg)'
- en: 'Figure 10.32: cURL of the micro application with compose'
  id: totrans-497
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.32：使用compose的微应用的cURL
- en: In this exercise, we saw that the `compose` refactor didn't affect the functionality
    of the application. It is possible to try different requests as per the response.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到`compose`的重构并没有影响应用程序的功能。可以根据响应尝试不同的请求。
- en: 'The preceding problem can be sorted with the following code:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码解决上述问题：
- en: '[PRE78]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The following requests will fail with a 401 error since we are not setting
    a valid authorization header:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 以下请求将因为我们没有设置有效的授权头而失败401错误：
- en: '[PRE79]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'For comparison, here is the equivalent BFF application using Express and its
    middleware-based composition model. It implements similar functionality to the
    micro BFF we finished this exercise with:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较，这里是使用Express及其基于中间件的组合模型的等效BFF应用程序。它实现了与我们完成此练习的微BFF类似的功能：
- en: '[PRE80]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Knowing about the possibilities that function composition brings will mean more
    reflection goes into the design of the function interface (inputs and outputs)
    so that, for example, `compose` can be leveraged. The next section covers immutability
    and side effects, which are necessary so that we can compose a set of partially
    applied or pure functions.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 了解函数组合带来的可能性将意味着更多的反思进入函数接口（输入和输出）的设计，以便例如可以利用`compose`。下一节涵盖了不可变性和副作用，这是必要的，以便我们可以组合一组部分应用或纯函数。
- en: Immutability and Side Effects
  id: totrans-506
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变性和副作用
- en: In a pure function context, the mutation of variables is considered a side effect
    and therefore a function where the mutation occurs, especially of variables that
    live beyond the execution of the function, is not pure.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯函数的上下文中，变量的突变被认为是副作用，因此发生变异的函数，特别是超出函数执行范围的变量，不是纯的。
- en: Immutability in JavaScript is hard to enforce but the language gives us good
    primitives to write in an immutable style. This style leans heavily on operators
    and functions that create a copy of data instead of mutating in place.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，不可变性很难强制执行，但语言为我们提供了良好的原语，以不可变的方式编写。这种风格严重依赖于操作符和函数，它们创建数据的副本，而不是就地突变。
- en: It is possible to write entire sections of applications without using side effects.
    Any data manipulation is possible without side effects. Most applications, however,
    need to load the data so that it is displayed from somewhere and possibly save
    some of the data somewhere as well. These are side effects that need to be managed.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在不使用副作用的情况下编写应用程序的整个部分。任何数据操作都可以在没有副作用的情况下进行。然而，大多数应用程序需要加载数据，以便从某个地方显示数据，并可能在某个地方保存一些数据。这些都是需要管理的副作用。
- en: A Look at Redux Action Creators
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Redux动作创建者的一瞥
- en: Action creators create Redux actions. They're useful to abstract the constants
    and centralize what actions the Redux store supports.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 动作创建者创建Redux动作。它们对于抽象常量并集中Redux存储支持的动作非常有用。
- en: 'Action creators always return a new action object. Creating and returning a
    new object is a good way to guarantee the immutability of the return value at
    least as far as the action creator is concerned. If the action creators returned
    some version of their parameters, it could make for surprising outputs:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 动作创建器总是返回一个新的动作对象。创建并返回一个新对象是保证返回值的不可变性的一种好方法，至少就动作创建器而言是这样。如果动作创建器返回其参数的某个版本，可能会产生令人惊讶的输出：
- en: '[PRE81]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Instead of calling `dispatch` with a manually marshaled object, it can be called
    with the output of an action creator:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 可以调用`dispatch`并手动编组对象，也可以调用动作创建器的输出：
- en: '[PRE82]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Exercise 79: Refactoring the React/Redux Application to Use Action Creators'
  id: totrans-516
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习79：重构React/Redux应用以使用动作创建器
- en: Action creators are a great way to abstract the action shape from the React
    component.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 动作创建器是将动作形状与React组件分离的好方法。
- en: Note
  id: totrans-518
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Exercise 79 comes with a preconfigured development server and a skeleton for
    the methods in the starter files, that is, `exercise--refactor-action-creators-start.js`
    and `exercise-refactor-action-creators-start.html`. The development server can
    be run with `npm run Exercise79`. The working solution for this exercise can be
    run using the npm run exercise10 file on GitHub.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 练习79带有一个预配置的开发服务器和起始文件中方法的骨架，即`exercise--refactor-action-creators-start.js`和`exercise-refactor-action-creators-start.html`。可以使用`npm
    run Exercise79`来运行开发服务器。可以在GitHub上使用`npm run exercise10`文件来运行这个练习的工作解决方案。
- en: In this exercise, you will go from using inline action definitions to using
    action creators.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将从使用内联动作定义转为使用动作创建器。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此练习：
- en: Change the current directory to `Lesson10` and run `npm install` if you haven't
    done so in this directory before. `npm install` downloads the dependencies that
    are required in order to run this activity (React, Redux, react-redux, and Parcel).
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前目录更改为`Lesson10`并运行`npm install`，如果您之前没有在此目录中执行过。`npm install`会下载运行此活动所需的依赖项（React、Redux、react-redux和Parcel）。
- en: 'First, run `npx parcel serve exercise-refactor-action-creators-start.html`.
    To see the application during development, run `npm run Exercise79`. You will
    see the application starting up, as follows:![Figure 10.33: Running the start
    file of this exercise'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先运行`npx parcel serve exercise-refactor-action-creators-start.html`。要在开发过程中查看应用程序，请运行`npm
    run Exercise79`。您将看到应用程序正在启动，如下所示：![图10.33：运行此练习的起始文件
- en: '](Images/C14587_10_33.jpg)'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_33.jpg)'
- en: 'Figure 10.33: Running the start file of this exercise'
  id: totrans-525
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.33：运行此练习的起始文件
- en: For the development server to live-reload our changes and to avoid configuration
    issues, edit the `exercise-refactor-action-creators-start.js` file directly.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使开发服务器实时重新加载我们的更改并避免配置问题，请直接编辑`exercise-refactor-action-creators-start.js`文件。
- en: 'Go to `http://localhost:1234` (or whichever URL the starting script output).
    You should see the following HTML page:![Figure 10.34: Initial application in
    the browser'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`http://localhost:1234`（或者起始脚本输出的任何URL）。您应该看到以下HTML页面：![图10.34：浏览器中的初始应用
- en: '](Images/C14587_10_34.jpg)'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_34.jpg)'
- en: 'Figure 10.34: Initial application in the browser'
  id: totrans-529
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.34：浏览器中的初始应用
- en: 'Implement the `startCheckout`, `continueShopping`, `done`, and `addProduct`
    action creators:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`startCheckout`、`continueShopping`、`done`和`addProduct`动作创建器：
- en: '[PRE83]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'These return the following action types, respectively: `START_CHECKOUT`, `CONTINUE_SHOPPING`,
    `DONE`, and `ADD_PRODUCT`.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分别返回以下动作类型：`START_CHECKOUT`、`CONTINUE_SHOPPING`、`DONE`和`ADD_PRODUCT`。
- en: 'Update `handleCheckout` to use the corresponding `startCheckout` action creator:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`handleCheckout`以使用相应的`startCheckout`动作创建器：
- en: '[PRE84]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Update `continueShopping` to use the corresponding `continueShopping` action
    creator:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`continueShopping`以使用相应的`continueShopping`动作创建器：
- en: '[PRE85]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Update `finish` to use the corresponding `done` action creator:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`finish`以使用相应的`done`动作创建器：
- en: '[PRE86]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Update `addProduct` to use the corresponding `addProduct` action creator:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`addProduct`以使用相应的`addProduct`动作创建器：
- en: '[PRE87]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Check that the application still behaves as expected:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查应用程序是否仍然按预期运行：
- en: '![Figure 10.35: Application after refactoring the action creators'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.35：重构动作创建器后的应用'
- en: '](Images/C14587_10_35.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_35.jpg)'
- en: 'Figure 10.35: Application after refactoring the action creators'
  id: totrans-544
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.35：重构动作创建器后的应用
- en: React-Redux mapStateToProps and mapDispatchToProps
  id: totrans-545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: React-Redux mapStateToProps和mapDispatchToProps
- en: The core proposition of react-redux is the connect function which, as its name
    suggests, connects components to the store. It has a signature of `connect(mapStateToProps,
    mapDispatchToProps) (component)` and returns a `connect` component.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: react-redux的核心命题是connect函数，正如其名称所示，它将组件连接到存储。它的签名是`connect(mapStateToProps,
    mapDispatchToProps) (component)`，并返回一个`connect`组件。
- en: 'In most examples, the `mapStateToProps` function has been `stated => state`,
    which makes sense in a small application where all the state is relevant for the
    connected component. In principle, selectors should be used in `mapStateToProps`
    to avoid passing too many props and therefore the component re-renders when data
    it doesn''t even use changes. The following is a small example of the `mapStateToProps`
    function:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数示例中，`mapStateToProps`函数都是`stated => state`，这在一个小应用程序中是有意义的，因为所有状态都与连接的组件相关。原则上，应该在`mapStateToProps`中使用选择器，以避免传递太多的props，因此当它不使用的数据发生变化时，组件重新渲染。以下是`mapStateToProps`函数的一个小例子：
- en: '[PRE88]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Let's complete an exercise using `mapStateToProps`.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`mapStateToProps`完成一个练习。
- en: 'Exercise 80: Abstracting State Management Using the mapDispatchToProps Function'
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习80：使用mapDispatchToProps函数抽象状态管理
- en: In this exercise, you will manage the state using a `mapDispatchToProps` function
    that leverages selectors to abstract the internal shape of the redux store.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用`mapDispatchToProps`函数来管理状态，该函数利用选择器来抽象redux存储的内部形状。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此练习：
- en: Change the current directory to `Lesson10` and run `npm install` if you haven't
    done so in this directory before.
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您之前没有在此目录中执行过`npm install`，请将当前目录更改为`Lesson10`并运行`npm install`。
- en: 'First, run `npx parcel serve exercise-map-to-props-start.html`. Then, during
    development, run `npm run Exercise80`. You will see the application starting up,
    as follows:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，运行`npx parcel serve exercise-map-to-props-start.html`。 然后，在开发过程中，运行`npm run
    Exercise80`。 您将看到应用程序启动，如下所示：
- en: Note
  id: totrans-555
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Exercise 80 comes with a preconfigured development server and a skeleton for
    the methods in the starter files, that is, `exercise-map-to-props-start.js` and
    `exercise-map-to-props-start.html`. The development server can be run with `npm
    run Exercise80`. The working solution for this exercise can be run using the npm
    run Exercise80 file on GitHub.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: Exercise 80带有预配置的开发服务器和起始文件中方法的框架，即`exercise-map-to-props-start.js`和`exercise-map-to-props-start.html`。
    可以使用`npm run Exercise80`运行开发服务器。 可以在GitHub上使用npm run Exercise80文件运行此练习的工作解决方案。
- en: '![Figure 10.36: Output of npm run Exercise80](Images/C14587_10_36.jpg)'
  id: totrans-557
  prefs: []
  type: TYPE_IMG
  zh: '![图10.36：npm run Exercise80的输出](Images/C14587_10_36.jpg)'
- en: 'Figure 10.36: Output of npm run Exercise80'
  id: totrans-558
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.36：npm run Exercise80的输出
- en: Go to `http://localhost:1234` (or whichever URL the starting script output).
    You should see a blank HTML page. This is due to `mapStateToProps` returning an
    empty state object.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`http://localhost:1234`（或起始脚本输出的任何URL）。 您应该看到一个空白的HTML页面。 这是因为`mapStateToProps`返回了一个空状态对象。
- en: Note
  id: totrans-560
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The audit explains which pieces of state (from the store) are used by the App
    component and how product, items, and status are the slices of state being used.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 审核解释了App组件使用的状态片段（来自存储）以及产品，项目和状态是正在使用的状态片段。
- en: 'Create a new selector for `status`:'
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`status`创建一个新的选择器：
- en: '[PRE89]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Create a new selector for `product`:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`product`创建一个新的选择器：
- en: '[PRE90]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In `mapStateToProps`, map `items`, `product`, and `status` to their corresponding
    selectors, which are applied to the state:'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mapStateToProps`中，将`items`，`product`和`status`映射到它们对应的选择器，这些选择器应用于状态：
- en: '[PRE91]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Take the functions that call `dispatch` in the App component and extract them
    to `mapDispatchToProps`, taking care to remove `this.props` from `this.props.dispatch`.
    Dispatch is the first parameter to `mapDispatchToProps`. Our code should now look
    as follows:'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将在App组件中调用`dispatch`的函数提取到`mapDispatchToProps`中，注意从`this.props.dispatch`中删除`this.props`。
    Dispatch是`mapDispatchToProps`的第一个参数。 我们的代码现在应该如下所示：
- en: '[PRE92]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Replace the references in `App#render` to `this.handleCheckout`. Instead, call
    `this.props.handleCheckout`:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换`App#render`中对`this.handleCheckout`的引用。 相反，调用`this.props.handleCheckout`：
- en: '[PRE93]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Replace the references in `App#render` to `this.continueShopping` and `this.finish`.
    Instead, call `this.props.continueShopping` and `this.props.finish`, respectively:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换`App#render`中对`this.continueShopping`和`this.finish`的引用。 相反，分别调用`this.props.continueShopping`和`this.props.finish`：
- en: '[PRE94]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Replace the references in `App#render` to `this.addProduct`. Instead, call
    `this.props.addProduct`:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换`App#render`中对`this.addProduct`的引用。 相反，调用`this.props.addProduct`：
- en: '[PRE95]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Open `http://localhost:1234`, to see that the application now behaves as expected.
    You can add products, go to the checkout, and finish or continue shopping:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`http://localhost:1234`，查看应用程序现在的预期行为。 您可以添加产品，转到结账，完成或继续购物：
- en: '![Figure 10.37: Application after mapStateToProps/mapDispatchToProps refactor'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.37：mapStateToProps/mapDispatchToProps重构后的应用程序'
- en: '](Images/C14587_10_37.jpg)'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_37.jpg)'
- en: 'Figure 10.37: Application after mapStateToProps/mapDispatchToProps refactor'
  id: totrans-579
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.37：mapStateToProps/mapDispatchToProps重构后的应用程序
- en: The application now works with the properly implemented `mapStateToProps` and
    `mapDispatchToProps` functions. React and Redux are further abstracted from each
    other. There is no more state in React components, nor are there direct calls
    to the store's `dispatch` method. This means that, in principle, another state
    management library could be used to replace Redux and the React code wouldn't
    change; only the glue code between the state manager and the React `App` component
    would change.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序现在使用正确实现的`mapStateToProps`和`mapDispatchToProps`函数工作。 React和Redux进一步从彼此抽象出来。
    React组件中不再有状态，也不再直接调用存储的`dispatch`方法。 这意味着原则上，可以使用另一个状态管理库来替换Redux，而React代码不会改变；
    只有状态管理器和React`App`组件之间的粘合代码会改变。
- en: Redux Reducers In Depth
  id: totrans-581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Redux Reducers In Depth
- en: 'Redux reducers should not mutate the Redux store state. As compared to first
    principles, pure functions are easier to test, and their outcome is easier to
    predict. As a state management solution, Redux has two roles: to keep the state
    as expected and to make sure updates are propagated efficiently and promptly.'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: Redux减速器不应该改变Redux存储状态。 与第一原则相比，纯函数更容易测试，其结果更容易预测。 作为状态管理解决方案，Redux有两个作用：保持状态如预期，并确保更新能够高效和及时地传播。
- en: Pure functions can help us achieve that goal by operating with immutability
    in mind. Returning copies helps with change detection. For example, it is costlier
    to detect that a large section of the keys within an object have been updated
    than to detect that an object has been replaced by a shallow copy of itself. In
    the first instance, an expensive deep comparison that walks through the whole
    object to detect differences in primitive values and/or structure would have to
    be done. In the shallow copy case, the fact that the object reference is different
    is all it takes to detect the change. This is trivial and has to do with the `===`
    JavaScript operator, which compares objects by reference.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数可以帮助我们通过考虑不可变性来实现这一目标。 返回副本有助于进行更改检测。 例如，检测对象内的大部分键已更新的成本更高，而检测对象已被其浅复制替换的成本更低。
    在第一种情况下，必须进行昂贵的深度比较，以遍历整个对象以检测原始值和/或结构的差异。 在浅复制情况下，仅需要检测对象引用不同即可检测到更改。 这是微不足道的，与`===`
    JavaScript运算符有关，该运算符通过引用比较对象。
- en: Changing JavaScript-Native Methods to an Immutable Functional Style
  id: totrans-584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将JavaScript-Native方法更改为不可变的函数式样式
- en: 'Map/filter/reduce do not mutate the initial array they operate on. Throughout
    the following snippet, the values for `initial` remain unchanged. `Array#map`
    returns a copy of the array so that it doesn''t mutate the array it is operating
    on. The same is true for `Array#reduce` and `Array#filter`; they''re both used
    on an array but don''t change any values in place. Instead, they create new objects:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: Map/filter/reduce不会改变它们操作的初始数组。在以下片段中，“initial”的值保持不变。`Array#map`返回数组的副本，因此不会改变它正在操作的数组。`Array#reduce`和`Array#filter`也是如此；它们都用于数组，但不会在原地更改任何值。相反，它们会创建新的对象：
- en: '[PRE96]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Object `rest` and `spread` syntax, which was introduced in ECMAScript 2018,
    is a great way to create shallow copies of objects and exclude/override keys.
    The following code combines `Array#map` and object rest/spread to create a shallow
    copy of the array (using `Array#map`) but also creates shallow copies of the objects
    inside the array using rest/spread:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的`rest`和`spread`语法是ECMAScript 2018中引入的，是创建对象的浅拷贝和排除/覆盖键的好方法。以下代码结合了`Array#map`和对象rest/spread来创建数组的浅拷贝（使用`Array#map`），但也使用rest/spread来创建数组中对象的浅拷贝：
- en: '[PRE97]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The array's `rest` and `spread` syntax predate the object's spread/rest since
    it was part of ECMAScript 2015 (also known as ES6). Much like its object counterpart,
    it is very useful for creating shallow copies. Another use case we have already
    seen is converting Array-like objects into fully-fledged Arrays. The same trick
    can also be used with iterrable such as `Set`.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的`rest`和`spread`语法早于对象的spread/rest，因为它是ECMAScript 2015（也称为ES6）的一部分。与其对象对应物一样，它非常有用于创建浅拷贝。我们已经看到的另一个用例是将类似数组的对象转换为完整的数组。相同的技巧也可以用于可迭代对象，如`Set`。
- en: 'In the following examples, Array spread is being used to create a copy of an
    array before sorting it and being used to convert a Set into an Array. Array spread
    is also being used to create a copy of all but the first element of an array:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，使用数组spread来创建数组的副本，然后对其进行排序，并使用它将Set转换为数组。数组spread还用于创建除第一个元素之外的所有元素的副本：
- en: '[PRE98]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '`Object.freeze` makes an object read-only if it''s running in strict mode.'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.freeze`使对象在严格模式下变为只读。'
- en: 'For example, the following snippets of code will use throw since we''re trying
    to add a property to a frozen object in strict mode:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段将使用throw，因为我们试图在严格模式下向冻结的对象添加属性：
- en: '[PRE99]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '`Object.freeze` is seldom used in practice. JavaScript, as a language designed
    to run in the browser, is built to be very permissive. Runtime errors exist but
    should be avoided, especially for something that is bound to be an application
    issue: writing to a property that is read-only.'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.freeze`在实践中很少使用。作为一种设计用于在浏览器中运行的语言，JavaScript被设计为非常宽松。运行时错误存在，但应该避免，特别是对于绑定为应用程序问题的事情：写入只读属性。'
- en: 'What''s more, `Object.freeze` only throws in non-strict mode. Take a look at
    the following example, where accessing and mutating properties on a frozen object
    is allowed because, by default, JavaScript runs in non-strict mode:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，`Object.freeze`只在非严格模式下抛出。看看以下示例，其中允许在冻结对象上访问和修改属性，因为默认情况下JavaScript在非严格模式下运行：
- en: '[PRE100]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Instead of enforcing immutability, engineering teams often choose to adhere
    to coding standards that embrace an immutable style.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 工程团队通常选择遵循支持不可变风格的编码标准，而不是强制不可变性。
- en: Note
  id: totrans-599
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: It is also possible to leverage libraries such as Immutable.js, which provides
    persistent immutable data structures that are implemented in an efficient manner.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以利用诸如Immutable.js之类的库，该库提供了以高效方式实现的持久不可变数据结构。
- en: Handling Side Effects in a React/Redux Application React Life Cycle Hooks
  id: totrans-601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在React/Redux应用程序中处理副作用React生命周期钩子
- en: The React component's `render()` method should be pure, so it does not support
    side effects. Being able to predict whether a component needs to re-render based
    on its inputs (props and state) means a lot of otherwise wasteful updates can
    be avoided. Since every state or prop update can cause a call to `render`, it
    is probably not the best spot to place API calls.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: React组件的`render()`方法应该是纯的，因此不支持副作用。能够根据其输入（props和state）来预测组件是否需要重新渲染意味着可以避免很多不必要的更新。由于每次状态或属性更新都可能导致调用`render`，这可能不是放置API调用的最佳位置。
- en: What the React documentation suggests is to use the `componentDidMount` life
    cycle method. `componentDidMount` runs after the component is mounted. In other
    words, it runs the first time the component is rendered on a page if it wasn't
    being rendered in the previous state of the React application.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: React文档建议使用`componentDidMount`生命周期方法。`componentDidMount`在组件挂载后运行。换句话说，如果在React应用程序的先前状态中未渲染组件，则它在页面上第一次渲染时运行。
- en: 'We can use `componentDidMount` to send the HTTP request with `fetch`. The `fetch`
    Promise''s `.then` can be used to update the state from the server response:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`componentDidMount`发送带有`fetch`的HTTP请求。`fetch` Promise的`.then`可以用于从服务器响应中更新状态：
- en: '[PRE101]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Handling Side Effects in a React/Redux Application React Hooks
  id: totrans-606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在React/Redux应用程序中处理副作用React Hooks
- en: As a recent addition to React, hooks allow function components to leverage all
    the features that used to be specific to class components.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 作为React的最新添加，钩子允许函数组件利用以前专门用于类组件的所有功能。
- en: 'The previous example can be refactored into a function component that uses
    the `useState` and `useEffect` hooks. `useState` is a way we can use state with
    React function components using a hook. React will re-render the function component
    when the state from `useState` changes. `useEffect` is a counterpart to `componentDidMount`
    and is called before the render of the component if the component wasn''t being
    rendered in the application''s previous state:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例可以重构为使用`useState`和`useEffect`钩子的函数组件。`useState`是我们可以使用钩子在React函数组件中使用状态的一种方式。当来自`useState`的状态发生变化时，React将重新渲染函数组件。`useEffect`是`componentDidMount`的对应物，在组件渲染之前调用，如果组件不是在应用程序的先前状态中渲染的：
- en: '[PRE102]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Handling Side Effects in a React/Redux Application Redux-Thunk
  id: totrans-610
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在React/Redux应用程序中处理副作用Redux-Thunk
- en: 'A thunk is a way to delay the evaluation of a function. It is a way to do lazy
    evaluation in languages that don''t support it out of the box:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: Thunk是延迟评估函数的一种方式。这是一种在不支持它的语言中进行惰性评估的方法：
- en: '[PRE103]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: It is also a way to encapsulate side effects. Since we have first-class functions,
    we pass the thunk around, which is allowed in pure functions (the thunk is just
    a function), although calling the thunk itself might have side effects.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一种封装副作用的方式。由于我们有一流函数，我们传递thunk，这在纯函数中是允许的（thunk只是一个函数），尽管调用thunk本身可能会有副作用。
- en: redux-thunk is quite simple; instead of passing an action creator that returns
    an object (with a type field and possibly a payload), the action creator returns
    a function that takes the store's dispatch and `getState` as parameters.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: redux-thunk非常简单；而不是传递返回对象的操作创建者（带有类型字段和可能的有效负载），操作创建者返回一个接受存储的分派和`getState`作为参数的函数。
- en: 'Inside the thunk, it is possible to access the current store state and dispatch
    actions, which will be reduced into the store. See the following example with
    Redux and redux-thunk:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在thunk中，可以访问当前存储状态并分派操作，这些操作将被减少到存储中。请参见以下使用Redux和redux-thunk的示例：
- en: '[PRE104]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Introduction to GraphQL Language Schemas and Queries
  id: totrans-617
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL语言模式和查询简介
- en: GraphQL is a query language. It exposes a typed schema to run queries against.
    The massive benefit of GraphQL is that the client requests what information it
    needs. This is a direct effect of having a typed schema.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL是一种查询语言。它公开了一个类型化的模式来运行查询。GraphQL的巨大好处是客户端请求所需的信息。这是有类型模式的直接效果。
- en: We will add GraphQL to our BFF using `express-graphql`, which is compatible
    with micro. We need to provide our GraphQL endpoint with a schema and resolvers
    so that it can respond to client requests. Such a server is provided in the Exercise
    12 start file (change the working directory to `Lesson10`, run `npm install` followed
    by `npm run Exercise81`, and navigate to `http://localhost:3000` to see it in
    action).
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`express-graphql`将GraphQL添加到我们的BFF，它与micro兼容。我们需要为我们的GraphQL端点提供模式和解析器，以便它可以响应客户端请求。在Exercise
    12开始文件中提供了这样的服务器（将工作目录更改为`Lesson10`，运行`npm install`，然后运行`npm run Exercise81`，并转到`http://localhost:3000`以查看其运行情况）。
- en: 'A sample GraphQL query that returns a basket can work within the following
    GraphQL schema definition. Note how we have three types, that is, `Query`, `basket,`
    and `basketItem`. A `basket` contains a list of `basketItems` under an `items`
    property. The `query` contains the top-level GraphQL query fields, which in this
    case is just `basket`. To query for `basketItems`, we must load the corresponding
    `basket` and expand the `items` field:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 一个返回篮子的示例GraphQL查询可以在以下GraphQL模式定义中工作。请注意我们有三种类型，即`Query`、`basket`和`basketItem`。`basket`在`items`属性下包含`basketItems`列表。`query`包含顶级GraphQL查询字段，这种情况下只是`basket`。要查询`basketItems`，我们必须加载相应的`basket`并展开`items`字段：
- en: '[PRE105]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: A tool that comes baked into Node.js GraphQL server components is GraphiQL.
    It is an interface for GraphQL that allows users to go through the schema and
    provides documentation of the schema.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js GraphQL服务器组件中内置的工具是GraphiQL。它是一个用于GraphQL的接口，允许用户浏览模式并提供模式的文档。
- en: 'The query that we entered reads as follows: load the `basket` top-level query
    field, expand its `items` field, and populate the `name`, `quantity`, and `price`
    of the `basketItem` elements in the basket''s `items` field:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输入的查询如下：加载`basket`顶级查询字段，展开其`items`字段，并填充篮子`items`字段中`basketItem`元素的`name`、`quantity`和`price`：
- en: '![Figure 10.38: GraphiQL user interface and a GraphQL query that fetches'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.38：GraphiQL用户界面和获取'
- en: fully expanded basket items
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 完全展开的篮子项目
- en: '](Images/C14587_10_38.jpg)'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_38.jpg)'
- en: 'Figure 10.38: GraphiQL user interface and a GraphQL query that fetches fully
    expanded basket items'
  id: totrans-627
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.38：GraphiQL用户界面和获取完全展开的篮子项目
- en: Running Updates with GraphQL Mutations and Resolvers
  id: totrans-628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用GraphQL变异和解析器进行运行更新
- en: In a query and schema world, one thing that's sorely missing is a way to run
    write operations. That is where GraphQL mutations come in. Mutations are structured
    update operations.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询和模式世界中，一个非常缺少的东西是运行写操作的方法。这就是GraphQL变异的作用。变异是结构化的更新操作。
- en: 'Resolvers are a server-side GraphQL implementation detail. A resolver is what
    resolves a GraphQL query. Resolvers run from the top to the bottom of the schema
    chain. When resolving a query, fields on an object are executed in parallel; when
    resolving a mutation, they''re resolved in sequence. The following is an example
    of a mutation being used:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器是服务器端GraphQL实现的细节。解析器是解析GraphQL查询的东西。解析器从模式链的顶部到底部运行。在解析查询时，对象上的字段并行执行；在解析变异时，它们按顺序解析。以下是使用变异的示例：
- en: '[PRE106]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Note
  id: totrans-632
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: More guides on GraphQL can be found at [https://graphql.org](https://graphql.org).
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 有关GraphQL的更多指南，请访问[https://graphql.org](https://graphql.org)。
- en: 'Exercise 81: Implementing a BFF Mutation with micro and GraphQL'
  id: totrans-634
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习81：使用micro和GraphQL实现BFF变异
- en: In this exercise, we will use micro and GraphQL to implement a BFF mutation.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用micro和GraphQL来实现BFF变异。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: Note
  id: totrans-637
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Exercise 81 comes with a preconfigured server and a skeleton for the methods
    in the starter file `exercise-graphql-micro-start.js`. The development server
    can be run with `npm run Exercise81`. The working solution for this exercise can
    be run using the `npm run Exercise81` file on GitHub.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 练习81包括一个预配置的服务器和起始文件`exercise-graphql-micro-start.js`中方法的框架。可以使用`npm run Exercise81`运行开发服务器。可以在GitHub上使用`npm
    run Exercise81`文件运行此练习的工作解决方案。
- en: Change the current directory to `Lesson10` and run `npm install` if you haven't
    done so in this directory before. `npm install` downloads the dependencies that
    are required so that we can run this activity (micro and `express-graphql`).
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您以前没有在此目录中执行过此操作，请将当前目录更改为`Lesson10`并运行`npm install`。`npm install`下载所需的依赖项，以便我们可以运行此活动（micro和`express-graphql`）。
- en: 'Run `node exercise-graphql-micro-start.js`. Then, during development, run `npm
    run Exercise81`. You will see the application starting up, as follows:![Figure
    10.39: Running the start file of this exercise'
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`node exercise-graphql-micro-start.js`。然后，在开发过程中，运行`npm run Exercise81`。您将看到应用程序启动，如下所示：![图10.39：运行此练习的起始文件
- en: '](Images/C14587_10_39.jpg)'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_39.jpg)'
- en: 'Figure 10.39: Running the start file of this exercise'
  id: totrans-642
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.39：运行此练习的起始文件
- en: 'Go to `http://localhost:3000` (or whichever URL the starting script output).
    You should see the following GraphiQL page:![Figure 10.40: Empty GraphiQL UI'
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`http://localhost:3000`（或者起始脚本输出的任何URL）。您应该看到以下GraphiQL页面：![图10.40：空的GraphiQL用户界面
- en: '](Images/C14587_10_40.jpg)'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_40.jpg)'
- en: 'Figure 10.40: Empty GraphiQL user interface'
  id: totrans-645
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.40：空的GraphiQL用户界面
- en: 'Add a `LineItemCost` constant, which is a field definition (plain JavaScript
    object):'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`LineItemCost`常量，它是一个字段定义（普通的JavaScript对象）：
- en: '[PRE107]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Our `LineItemCost` should have a `type` property set to `GraphQLInt` since
    the output of `LineItemCost` calculation is an integer. `LineItemCost` should
    also have an `args` field, which should be set to `{id: {type: GraphQLString}}`.
    In other words, our mutation takes an `id` argument that is a string (which is
    congruent with the sample data we have). For the mutation to return something,
    it needs a `resolve()` method. For now, it can return any integer. The `resolve`
    method of a mutations takes the root as the first parameter and the `args` as
    the second parameter.'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的`LineItemCost`应该有一个`type`属性设置为`GraphQLInt`，因为`LineItemCost`计算的输出是一个整数。`LineItemCost`还应该有一个`args`字段，应该设置为`{id:
    {type: GraphQLString}}`。换句话说，我们的mutation接受一个是字符串的`id`参数（这与我们的示例数据一致）。为了使mutation返回一些东西，它需要一个`resolve()`方法。目前，它可以返回任何整数。mutations的`resolve`方法将根作为第一个参数，`args`作为第二个参数。'
- en: 'Let''s implement the actual `resolve` method of `LineItemCost` now. First,
    we need to look up the item from `basketItems` by ID using `.find(el => el.id
    === args.id)`. Then, we can calculate the cost of the item (`item.price * item.quantity`),
    as follows:'
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们实现`LineItemCost`的实际`resolve`方法。首先，我们需要使用`.find(el => el.id === args.id)`从`basketItems`中查找ID查找项目。然后，我们可以计算项目的成本（`item.price
    * item.quantity`），如下所示：
- en: '[PRE108]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Create a mutation constant that's a `GraphQLObjectType`. See how the query is
    initialized; its name should be `Mutation:`
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`GraphQLObjectType`的mutation常量。查看查询如何初始化；其名称应为`Mutation:`
- en: '[PRE109]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Add `LineItemCost` to the mutation `fields()` return value. This means that
    `LineItemCost` is now a top-level mutation. It can be called if `mutation` exists
    on the GraphQL schema:'
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`LineItemCost`添加到`fields()`返回值的mutation中。这意味着`LineItemCost`现在是顶级mutation。如果在GraphQL模式上存在`mutation`，则可以调用它：
- en: '[PRE110]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Add `mutation` to the `GraphQLSchema` schema:'
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`mutation`添加到`GraphQLSchema`模式中：
- en: '[PRE111]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Send the following query to your server (through GraphiQL). Enter it on the
    left-hand side editor and click the **Play** button:'
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下查询发送到服务器（通过GraphiQL）。在左侧编辑器中输入并单击**播放**按钮：
- en: '[PRE112]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Note
  id: totrans-659
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: This mutation is using what are called GraphQL aliases since we can't run the
    mutation under the same name twice.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 这个mutation使用了所谓的GraphQL别名，因为我们不能两次使用相同的名称运行mutation。
- en: 'The output should be as follows:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 10.41: GraphiQL with LineItemCost aliased mutation queries for IDs
    "1" and "2"'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.41：带有LineItemCost别名的ID“1”和“2”的mutation查询的GraphiQL'
- en: '](Images/C14587_10_41.jpg)'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_41.jpg)'
- en: 'Figure 10.41: GraphiQL with LineItemCost aliased mutation queries for IDs "1"
    and "2"'
  id: totrans-664
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.41：带有LineItemCost别名的ID“1”和“2”的mutation查询的GraphiQL
- en: To make the basket example more realistic, we will load the initial basket data
    from the GraphQL BFF, using the GraphQL query, redux-thunk, to handle the side
    effect, and a new reducer to update the Redux store state. The aim of the next
    activity is to show you how we can integrate a GraphQL BFF with a React/Redux
    application with redux-thunk.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使购物篮示例更加真实，我们将使用GraphQL查询，redux-thunk来处理副作用，并使用新的reducer来更新Redux存储状态，从GraphQL
    BFF加载初始购物篮数据。下一个活动的目的是向您展示我们如何将GraphQL BFF与使用redux-thunk的React/Redux应用集成。
- en: 'Activity 17: Fetching the Current Basket From BFF'
  id: totrans-666
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动17：从BFF获取当前购物篮
- en: 'In this activity, we will fetch initial basket data from GraphQL BFF to re-render
    items to the shopping basket, thus updating the initial state of the basket. Let''s
    get started:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将从GraphQL BFF获取初始购物篮数据，以便重新渲染物品到购物篮，从而更新购物篮的初始状态。让我们开始吧：
- en: Note
  id: totrans-668
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Activity 17 comes with a preconfigured development server and a skeleton for
    the methods in the starter files, that is, `activity-app-start.js` and `activity-app-start.html`.
    The development server can be run with `npm run Activity17`. The working solution
    for this activity can be run using the npm run Activity17 file on GitHub.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 活动17配备了一个预配置的开发服务器和起始文件中方法的骨架，即`activity-app-start.js`和`activity-app-start.html`。可以使用`npm
    run Activity17`运行开发服务器。可以在GitHub上使用npm run Activity17文件运行此活动的工作解决方案。
- en: Change the current directory to `Lesson10` and run `npm install` if you haven't
    done so in this directory before.
  id: totrans-670
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果以前没有在此目录中这样做，请将当前目录更改为`Lesson10`并运行`npm install`。
- en: Run the BFF for Activity 17 and `npx parcel serve activity-app-start.html`.
    During development, run `npm run Activity17`.
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行活动17的BFF和`npx parcel serve activity-app-start.html`。在开发过程中，运行`npm run Activity17`。
- en: Go to `http://localhost:1234` (or whichever URL the starting script output)
    to check the HTML page.
  id: totrans-672
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`http://localhost:1234`（或者起始脚本输出的任何URL）以检查HTML页面。
- en: Write a query that will fetch basket items from the BFF. You can use the GraphQL
    UI at `http://localhost:3000` to experiment with this.
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个查询，从BFF获取购物篮中的物品。您可以使用`http://localhost:3000`上的GraphQL UI进行实验。
- en: Create a `requestBasket` (thunk) action creator that will call `fetchFromBff`
    with the query from the previous step.
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`requestBasket`（thunk）动作创建器，它将使用上一步的查询调用`fetchFromBff`。
- en: Chain a `.then` onto the `fetchFromBff()` call to dispatch a `REQUEST_BASKET_SUCCESS`
    action with the right `basket` payload.
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`fetchFromBff()`调用上链接一个`.then`，以使用正确的`basket`有效负载分派`REQUEST_BASKET_SUCCESS`动作。
- en: Add a case to the `appReducer` that will reduce a `REQUEST_BASKET_SUCCESS` action
    with a `basket` payload into the state.
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`appReducer`添加一个案例，将带有`basket`有效负载的`REQUEST_BASKET_SUCCESS`操作减少到状态中。
- en: Add `requestBasket` to `mapDispatchToProps`.
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`requestBasket`添加到`mapDispatchToProps`。
- en: Call `requestBasket`, which is mapped to `dispatch`, in `App#componentDidMount`.
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App#componentDidMount`中调用`requestBasket`，它被映射到`dispatch`。
- en: Note
  id: totrans-679
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 628.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第628页找到。
- en: Summary
  id: totrans-681
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: First-class functions are part and parcel of using a popular library such as
    React and its patterns. They also power any and every delegation of implementation,
    especially on built-ins such as Array. Another core tenet of functional programming
    is pure functions. Using pure functions for complex data manipulation logic or
    an abstraction layer around a data structure is a great pattern that was put forward
    by the popular Redux state management solution. Any side effects and/or dependencies
    that must be mocked make it that much harder to reason about a complex data manipulation.
    Higher-order functions and specific techniques such as currying and partial application
    are widespread in day-to-day JavaScript development. Currying and partial application
    is a way to design functions with an interface that makes each step of specialization
    "savable" since it is already a function that has already been applied with a
    certain number of parameters.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 头等函数是使用流行库（如React及其模式）的一部分。它们还为任何实现的委托提供动力，特别是在内置功能（如Array）上。函数式编程的另一个核心原则是纯函数。使用纯函数进行复杂数据操作逻辑或数据结构周围的抽象层是由流行的Redux状态管理解决方案提出的一个很好的模式。任何必须被模拟的副作用和/或依赖关系都会使复杂数据操作变得更加难以理解。高阶函数和特定技术，如柯里化和部分应用，在日常JavaScript开发中广泛使用。柯里化和部分应用是一种设计函数的方式，使得每个专门化步骤都是“可保存的”，因为它已经是一个已经应用了一定数量参数的函数。
- en: The composition can have real value if a function application pipeline has been
    spotted. For example, modeling HTTP services as pipelines makes quite a lot of
    sense. On the other hand, the Node.js HTTP server ecosystem leaders use a middleware-based
    composition model, micro, which exposes a function composition model. Writing
    JavaScript in an immutable style allows libraries to have a cheap way to check
    whether something has changed or not. Side effects in React and Redux are handled
    outside the regular flow of pure functions, that is, render functions and reducers.
    Redux-thunk is quite a functional solution to the problem, albeit at the cost
    of making functions valid actions. Pure Redux actions are JavaScript objects with
    a type of property.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现函数应用程序管道，则组合可以具有真正的价值。例如，将HTTP服务建模为管道非常有意义。另一方面，Node.js HTTP服务器生态系统领导者使用基于中间件的组合模型，micro暴露了一个函数组合模型。以不可变的方式编写JavaScript允许库以廉价的方式检查某些东西是否已更改。在React和Redux中，副作用是在纯函数的常规流程之外处理的，即渲染函数和reducer。Redux-thunk是解决这个问题的一个相当功能性的解决方案，尽管以使函数有效的行动为代价。纯Redux操作是具有类型属性的JavaScript对象。
- en: In this book, we've learned about various frameworks, including React, Angular,
    and related tools and libraries. It has taught us about the advanced concepts
    you need to know about to build modern applications. Then, we learned how to represent
    an HTML document in the Document Object Model (DOM). Later, we combined our knowledge
    of the DOM and Node.js to create a web scraper for practical situations.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们学习了包括React、Angular和相关工具和库在内的各种框架。它教会了我们构建现代应用程序所需的高级概念。然后，我们学习了如何在文档对象模型（DOM）中表示HTML文档。之后，我们结合了对DOM和Node.js的知识，为实际情况创建了一个网络爬虫。
- en: In the next part, we created a Node.js-based RESTful API using the Express library
    for Node.js. We had a look at how modular designs can be used for better reusability
    and collaboration with multiple developers on a single project. We also learned
    how to build unit tests that ensure that the core functionality of our program
    is not broken over time. We saw how constructors, async/await, and events can
    load our applications with high speed and performance. The final part of this
    book introduced you to functional programming concepts such as immutability, pure
    functions, and higher-order functions.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们使用Express库为Node.js创建了基于Node.js的RESTful API。我们看了看如何使用模块化设计来实现更好的可重用性，并与单个项目上的多个开发人员进行协作。我们还学习了如何构建单元测试，以确保我们程序的核心功能随着时间的推移不会出现问题。我们看到构造函数、async/await和事件如何可以使我们的应用程序具有高速和性能。本书的最后部分向您介绍了函数式编程概念，如不可变性、纯函数和高阶函数。
- en: '*Appendix*'
  id: totrans-686
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*附录*'
- en: About
  id: totrans-687
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于
- en: This section is included to assist the students to perform the activities in
    the book. It includes detailed steps that are to be performed by the students
    to achieve the objectives of the activities.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 本节旨在帮助学生完成书中的活动。它包括学生执行的详细步骤，以实现活动的目标。
- en: 'Chapter 1: JavaScript, HTML, and the DOM'
  id: totrans-689
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1章：JavaScript、HTML和DOM
- en: 'Activity 1: Extracting Data from a Page'
  id: totrans-690
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：从页面中提取数据
- en: '**Solution**:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: 'Initialize a variable to store the entire content of the CSV:'
  id: totrans-692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个变量来存储CSV的整个内容：
- en: '[PRE113]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Query the DOM to find all the elements that represent each product. Notice
    how we wrap the `HTMLCollection` instance returned in `Array.from` so that we
    can handle it like a normal array:'
  id: totrans-694
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询DOM以查找表示每个产品的所有元素。注意我们如何将返回的`HTMLCollection`实例包装在`Array.from`中，以便我们可以像处理普通数组一样处理它：
- en: '[PRE114]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Iterate over each element found:'
  id: totrans-696
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历找到的每个元素：
- en: '[PRE115]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Inside the closure, using the `product` element, query to find the price with
    the unit. Split the string using a slash:'
  id: totrans-698
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在闭包内，使用`product`元素，查询以找到带单位的价格。使用斜杠拆分字符串：
- en: '[PRE116]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Then query for the name:'
  id: totrans-700
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后查询名称：
- en: '[PRE117]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Append all information to the variable initialized in step 1, separating the
    values with commas. Don''t forget to add newline characters to each line you append
    to:'
  id: totrans-702
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有信息附加到步骤1中初始化的变量中，使用逗号分隔值。不要忘记为附加到每行的换行符添加：
- en: '[PRE118]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Print the variable containing the accumulated data using the `console.log`
    function:'
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`console.log`函数打印包含累积数据的变量：
- en: '[PRE119]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Paste the code in the Chrome **Console** tab; it should look like this:'
  id: totrans-706
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码粘贴到Chrome **控制台**选项卡中；它应该看起来像这样：
- en: '![Figure 1.62: Code ready to run in the Console tab'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.62：准备在控制台选项卡中运行的代码'
- en: '](Images/C14587_01_62.jpg)'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_01_62.jpg)'
- en: 'Figure 1.62: Code ready to run in the Console tab'
  id: totrans-709
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.62：准备在控制台选项卡中运行的代码
- en: 'After pressing *Enter* to execute the code, you should see the CSV printed
    in the console, as shown here:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Enter*执行代码后，您应该在控制台中看到打印的CSV，如下所示：
- en: '![Figure 1.63: The storefront with the code and output in the Console tab'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.63：带有代码和控制台选项卡输出的商店'
- en: '](Images/C14587_01_63.jpg)'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_01_63.jpg)'
- en: 'Figure 1.63: The storefront with the code and output in the Console tab'
  id: totrans-713
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.63：带有代码和控制台选项卡输出的商店
- en: 'Activity 2: Replacing the Tag Filter with a Web Component'
  id: totrans-714
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动2：用Web组件替换标签过滤器
- en: '**Solution**:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: Start by copying the code from `Exercise07` into a new folder.
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先将`Exercise07`中的代码复制到一个新文件夹中。
- en: 'Create a new file called `tags_holder.js` and in it add a class called `TagsHolder`
    that extends `HTMLElement`, then define a new custom component called `tags-holder`:'
  id: totrans-717
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`tags_holder.js`的新文件，并在其中添加一个名为`TagsHolder`的扩展`HTMLElement`的类，然后定义一个名为`tags-holder`的新自定义组件：
- en: '[PRE120]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Create two `render` methods: one to render the base state and one to render
    the tags or some text indicating that no tags are selected for filtering:'
  id: totrans-719
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个`render`方法：一个用于呈现基本状态，一个用于呈现标签或指示未选择任何标签进行过滤的文本：
- en: '[PRE121]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'In the constructor, call `w`, attach the component to the shadow root, initialize
    the list of selected tags, and call both `render` methods:'
  id: totrans-721
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，调用`w`，将组件附加到阴影根，初始化所选标签列表，并调用两个`render`方法：
- en: '[PRE122]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Create a getter to expose the list of selected tags:'
  id: totrans-723
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个getter来公开所选标签的列表：
- en: '[PRE123]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Create two trigger methods: one to trigger the changed event and one to trigger
    the `tag-clicked` event:'
  id: totrans-725
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个触发方法：一个用于触发更改事件，另一个用于触发`tag-clicked`事件：
- en: '[PRE124]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Create two `mutator` methods: `addTag` and `removeTag`. These methods receive
    the tag name and add a tag if not present, or remove tag if present, in the list
    of selected tags. If the list was modified, trigger the `changed` event and call
    the method to re-render the list of tags:'
  id: totrans-727
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个`mutator`方法：`addTag`和`removeTag`。这些方法接收标签名称，如果不存在，则添加标签，如果存在，则删除标签，从所选标签列表中。如果列表已修改，则触发`changed`事件并调用重新呈现标签列表的方法：
- en: '[PRE125]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'In the HTML, replace the existing code with the new component. Remove the following
    lines:'
  id: totrans-729
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML中，用新组件替换现有代码。删除以下行：
- en: '[PRE126]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Note
  id: totrans-731
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You can see the final HTML on GitHub at [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Activity02/dynamic_storefront.html](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Activity02/dynamic_storefront.html).
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上查看最终的HTML，网址为[https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Activity02/dynamic_storefront.html](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Activity02/dynamic_storefront.html)。
- en: 'In `filter_and_search.js`, do the following:'
  id: totrans-733
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`filter_and_search.js`中，执行以下操作：
- en: 'At the top, create a reference to the `tags-holder` component:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，创建对`tags-holder`组件的引用：
- en: '[PRE127]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Add event listeners to handle the `changed` and `tag-clicked` events:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 添加事件侦听器以处理`changed`和`tag-clicked`事件：
- en: '[PRE128]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Remove the following functions and all references to them: `createTagFilterLabel`
    and `updateTagFilterList`.'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 删除以下函数及其所有引用：`createTagFilterLabel`和`updateTagFilterList`。
- en: In the `filterByTags` function, replace `tagsToFilterBy` with `filterByTagElement.selectedTags`.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 在`filterByTags`函数中，用`filterByTagElement.selectedTags`替换`tagsToFilterBy`。
- en: In the `addTagFilter` method, replace the references to `tagsToFilterBy` with
    `filterByTagElement.addTag`.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addTagFilter`方法中，用`filterByTagElement.addTag`替换对`tagsToFilterBy`的引用。
- en: 'Chapter 2: Node.js and npm'
  id: totrans-741
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2章：Node.js和npm
- en: 'Activity 3: Creating a npm Package to Parse HTML'
  id: totrans-742
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动3：创建一个npm包来解析HTML
- en: '**Solution**:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: 'In an empty folder, use npm to create a new package. You can use all the default
    values for the options:'
  id: totrans-744
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在空文件夹中，使用npm创建一个新包。您可以使用所有选项的默认值：
- en: '[PRE129]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'To install `cheerio`, run `npm install`. Make sure that you type the name of
    the library incorrectly:'
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装`cheerio`，运行`npm install`。确保您错误地输入库的名称：
- en: '[PRE130]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Inside this folder, create a file called `index.js` and add the following to
    it:'
  id: totrans-748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹中，创建一个名为`index.js`的文件，并将以下内容添加到其中：
- en: '[PRE131]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Create a variable that stores the HTML from the sample code from GitHub ([https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Example/sample_001/sample-page.html](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Example/sample_001/sample-page.html)).
    When creating multiline strings, you can use backquotes:'
  id: totrans-750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量，存储来自GitHub示例代码（[https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Example/sample_001/sample-page.html](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Example/sample_001/sample-page.html)）的HTML。创建多行字符串时，可以使用反引号：
- en: '[PRE132]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Parse the HTML and pass it to cheerio. In cheerio''s examples, you are going
    to see that they name the parsed variable as "`$`" (dollar sign). That is an old
    convention that was used in the jQuery world. This is what it looks like:'
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析HTML并将其传递给cheerio。在cheerio的示例中，您将看到它们将解析的变量命名为“`$`”（美元符号）。这是jQuery世界中使用的一个旧约定。它看起来像这样：
- en: '[PRE133]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Now, we can use that variable to manipulate the HTML. To start, we will add
    a paragraph to the page with some text in it:'
  id: totrans-754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用该变量来操作HTML。首先，我们将向页面添加一个带有文本的段落：
- en: '[PRE134]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: We can also query the HTML, similar to what we did in *Chapter 1, JavaScript,
    HTML, and the DOM*, using CSS selectors. Let's query for all the paragraphs and
    print their content to the console. Notice that cheerio elements do not behave
    exactly like DOM elements, but they are very similar.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以查询HTML，类似于我们在*第1章JavaScript、HTML和DOM*中所做的，使用CSS选择器。让我们查询所有段落并将其内容打印到控制台。请注意，cheerio元素的行为与DOM元素并不完全相同，但它们非常相似。
- en: 'Use the `firstChild` attribute to find the first node of each paragraph and
    print its content, assuming it will be the text element:'
  id: totrans-757
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`firstChild`属性找到每个段落的第一个节点并打印其内容，假设它将是文本元素：
- en: '[PRE135]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Lastly, inside `index.js`, print the manipulated HTML to the console by calling
    the `html` function:'
  id: totrans-759
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`index.js`中，通过调用`html`函数将操作后的HTML打印到控制台：
- en: '[PRE136]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Now, you can run your application by calling it from Node.js:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过从Node.js调用它来运行您的应用程序：
- en: '![Figure 2.7: Calling the application from node.js'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7：从node.js调用应用程序'
- en: '](Images/C14587_02_07.jpg)'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_02_07.jpg)'
- en: 'Figure 2.7: Calling the application from Node.js'
  id: totrans-764
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.7：从Node.js调用应用程序
- en: 'Chapter 3: Node.js APIs and Web Scraping'
  id: totrans-765
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章：Node.js API和Web爬虫
- en: Activity 4 Scraping Products and Prices from Storefront
  id: totrans-766
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动4：从商店前端爬取产品和价格
- en: '**Solution**'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Start the dynamic server to serve the storefront application using the code
    from *Exercise 14, Serving Dynamic Content,* in this chapter:'
  id: totrans-768
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本章中*练习14，提供动态内容*中的代码启动动态服务器以提供商店前端应用程序：
- en: '[PRE137]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'In a new Terminal, create a new `npm` package, install `jsdom`, and create
    the `index.js` entry file:'
  id: totrans-770
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的终端中，创建一个新的`npm`包，安装`jsdom`，并创建`index.js`入口文件：
- en: '[PRE138]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Call the `require()` method to load all the modules you will need in the project:'
  id: totrans-772
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`require()`方法加载项目中需要的所有模块：
- en: '[PRE139]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Make an HTTP request to `http://localhost:3000`:'
  id: totrans-774
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`http://localhost:3000`发出HTTP请求：
- en: '[PRE140]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Ensure a successful response and collect the data from the body using the data
    event:'
  id: totrans-776
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保成功响应并使用数据事件从主体收集数据：
- en: '[PRE141]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'In the `close` event, parse the HTML using `JSDOM`:'
  id: totrans-778
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`close`事件中，使用`JSDOM`解析HTML：
- en: '[PRE142]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The preceding callback calls two functions: `extractProducts` and `writeCSV`.
    These functions are described in the upcoming steps.'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的回调调用了两个函数：`extractProducts`和`writeCSV`。这些函数将在接下来的步骤中描述。
- en: 'Use the `extractProducts` function to query the DOM and fetch product information
    from it. It stores all the products in an array, which is returned at the end:'
  id: totrans-781
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`extractProducts`函数查询DOM并从中获取产品信息。它将所有产品存储在一个数组中，并在最后返回：
- en: '[PRE143]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Use the `writeCSV` function, which opens the CSV file to write, ensuring that
    no error occurred:'
  id: totrans-783
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`writeCSV`函数打开CSV文件进行写入，确保没有发生错误：
- en: '[PRE144]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Now that the file is open, we can write the product data to the file:'
  id: totrans-785
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在文件已打开，我们可以将产品数据写入文件：
- en: '[PRE145]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'In the new Terminal, run the application:'
  id: totrans-787
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的终端中，运行应用程序：
- en: '[PRE146]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Chapter 4: RESTful APIs with Node.js'
  id: totrans-789
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章：使用Node.js构建RESTful API
- en: 'Activity 5: Creating an API Endpoint for a Keypad Door Lock'
  id: totrans-790
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动5：为键盘门锁创建API端点
- en: '**Solution**'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Create a new project folder and change the directories going to it to the following:'
  id: totrans-792
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目文件夹，并将目录更改为以下内容：
- en: '[PRE147]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Initialize an `npm` project and install `express`, `express-validator`, and
    `jwt-simple`. Then, make a directory for `routes`:'
  id: totrans-794
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个`npm`项目并安装`express`，`express-validator`和`jwt-simple`。然后，创建一个`routes`目录：
- en: '[PRE148]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Create a `config.js` file, just as you did in *Exercise 21, Setting Up an Endpoint
    that Requires Authentication*. This should contain a randomly generated secret
    value:'
  id: totrans-796
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`config.js`文件，就像在*练习21，设置需要身份验证的端点*中所做的那样。这应该包含一个随机生成的秘密值：
- en: '[PRE149]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Make the `routes/check-in.js` file in order to create a check-in route. This
    can be copied in whole from *Exercise 21, Setting Up an Endpoint that Requires
    Authentication*:'
  id: totrans-798
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`routes/check-in.js`文件以创建一个签到路由。这可以从*练习21，设置需要身份验证的端点*中完整复制：
- en: '[PRE150]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Create a second route file called `routes/lock.js`. Start the file off by importing
    the required libraries and modules, and create an empty array to hold our valid
    passcodes:'
  id: totrans-800
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`routes/lock.js`的第二个路由文件。首先导入所需的库和模块，创建一个空数组来保存我们的有效密码：
- en: '[PRE151]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Create a `GET` route for `/code` that requires a `name` value, which is continued
    after the code in the preceding step in the `routes/lock.js` file:'
  id: totrans-802
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`/code`创建一个`GET`路由，需要一个`name`值，在前面步骤中的`routes/lock.js`文件中继续：
- en: '[PRE152]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Create another route in `routes/lock.js`. This one will be for `/open` and
    requires a four-digit code that will be checked against the `passCodes` array
    to see whether it is valid. Below that route, make sure to export `router`, so
    that it can be used in `server.js`:'
  id: totrans-804
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`routes/lock.js`中创建另一个路由。这个路由将是`/open`，需要一个四位代码，将根据`passCodes`数组进行检查以查看它是否有效。在该路由下面，确保导出`router`，以便在`server.js`中使用：
- en: '[PRE153]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Create the main file where our routes will be used in `server.js`. Start by
    importing the libraries needed and setting URL encoding the JSON:'
  id: totrans-806
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建主文件，在其中使用我们的路由`server.js`。首先导入所需的库，并设置URL编码JSON：
- en: '[PRE154]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Next, in `server.js`, below the preceding code, import the two routes, implement
    a `404` catch-all, and tell the API to listen on port `3000`:'
  id: totrans-808
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`server.js`中，在前面的代码下面，导入两个路由，实现一个`404`捕获，并告诉API监听端口`3000`：
- en: '[PRE155]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Finally, we will test the API to ensure it was done correctly. Start by running
    your program:'
  id: totrans-810
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将测试API以确保它被正确完成。首先运行您的程序：
- en: '[PRE156]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'With the program running, open a second Terminal window and use the `/check-in`
    endpoint to get a JWT and save the value as `TOKEN`. Then, echo that value to
    ensure it was successful:'
  id: totrans-812
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序运行时，打开第二个终端窗口，并使用`/check-in`端点获取JWT并将值保存为`TOKEN`。然后，回显该值以确保成功：
- en: '[PRE157]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'You should get back a long string of letters and numbers like the following:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该收到一个包含字母和数字的长字符串，就像下面这样：
- en: '![Figure 4.24: Getting TOKEN from the check-in endpoint'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.24：从签到端点获取TOKEN'
- en: '](Images/C14587_04_24.jpg)'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_24.jpg)'
- en: 'Figure 4.24: Getting TOKEN from the check-in endpoint'
  id: totrans-817
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.24：从签到端点获取TOKEN
- en: 'Next, we will use our JWT to use the `/lock/code` endpoint to get a one-time
    passcode for Sarah:'
  id: totrans-818
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用我们的JWT使用`/lock/code`端点为Sarah获取一次性通行码：
- en: '[PRE158]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'You should get back an object containing a message and a four-digit code like
    in the following:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该收到一个包含消息和四位代码的对象，就像下面这样：
- en: '![Figure 4.25: A four-digit one-time code'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.25：一个四位一次性代码'
- en: '](Images/C14587_04_25.jpg)'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_25.jpg)'
- en: 'Figure 4.25: A four-digit one-time code'
  id: totrans-823
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.25：一个四位一次性代码
- en: 'To ensure the code works, send it to the `/lock/open` endpoint. We will send
    the following command once, expecting it to be successful. We will then send the
    same command a second time, expecting it to fail since each code is used only
    once. Run the following twice:'
  id: totrans-824
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保代码正常工作，将其发送到`/lock/open`端点。我们将发送以下命令一次，期望它成功。然后我们将发送相同的命令第二次，期望它失败，因为每个代码只能使用一次。运行以下命令两次：
- en: '[PRE159]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Running the preceding command twice should return something like the following:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 连续运行上述命令两次应该返回类似以下内容：
- en: '![Figure 4.26: Running the command twice results in an error'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.26：运行命令两次会导致错误'
- en: '](Images/C14587_04_26.jpg)'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_26.jpg)'
- en: 'Figure 4.26: Running the command twice results in an error'
  id: totrans-829
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.26：运行命令两次会导致错误
- en: If your result is the same as shown in the preceding figure, then you have successfully
    completed the activity.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的结果与前面的图像相同，那么你已成功完成了这个活动。
- en: 'Chapter 5: Modular JavaScript'
  id: totrans-831
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章：模块化JavaScript
- en: 'Activity 6: Creating a Lightbulb with a Flash Mode'
  id: totrans-832
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动6：创建带有闪光模式的灯泡
- en: '**Solution**:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: 'Install the `babel-cli` and `babel` preset as developer dependencies:'
  id: totrans-834
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`babel-cli`和`babel`预设为开发人员依赖项：
- en: '[PRE160]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Add a file called `.babelrc` to the root directory. In it, we will tell Babel
    to use the preset settings:'
  id: totrans-836
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录下添加一个名为`.babelrc`的文件。在其中，我们将告诉Babel使用预设设置：
- en: '[PRE161]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Add a webpack configuration file at `webpack.config.js` in the root directory:'
  id: totrans-838
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录下的`webpack.config.js`添加一个webpack配置文件：
- en: '[PRE162]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Create a new file called `js/flashingLight.js`. This should start as a blank
    ES6 component that extends `Light`. In the constructor, we will include `state`,
    `brightness`, and `flashMode`:'
  id: totrans-840
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`js/flashingLight.js`的新文件。这应该是一个空的ES6组件，扩展`Light`。在构造函数中，我们将包括`state`，`brightness`和`flashMode`：
- en: '[PRE163]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Add a setter method for the `FlashingLight` object, which will also trigger
    stop and start flash methods.
  id: totrans-842
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`FlashingLight`对象添加一个setter方法，这也将触发停止和开始闪光方法。
- en: '[PRE164]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Add a getter method for the `FlashingLight` object:'
  id: totrans-844
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`FlashingLight`对象添加一个getter方法：
- en: '[PRE165]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Create a `startFlashing` function that references the parent class''s `lightSwitch()`
    function. This step is tricky because we have to bind it to `setInterval`:'
  id: totrans-846
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`startFlashing`函数，引用父类的`lightSwitch()`函数。这一步很棘手，因为我们必须将它绑定到`setInterval`：
- en: '[PRE166]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Create a `stopFlashing` function that can be used to turn off the timer:'
  id: totrans-848
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`stopFlashing`函数，用于关闭定时器：
- en: '[PRE167]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'As the last part of `flashingLight.js`, close the class and export it:'
  id: totrans-850
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为`flashingLight.js`的最后部分，关闭类并导出它：
- en: '[PRE168]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Open `src/js/viewer.js` and modify the button to create a flashing light instead
    of a colored light:'
  id: totrans-852
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/js/viewer.js`并修改按钮以创建一个闪光灯而不是一个彩色灯：
- en: '[PRE169]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Compile the code by running our `build` function with npm:'
  id: totrans-854
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行我们的`build`函数使用npm编译代码：
- en: '[PRE170]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Open up `build/index.html` and set the script location as `bundle.js`:'
  id: totrans-856
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`build/index.html`并将脚本位置设置为`bundle.js`：
- en: '[PRE171]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'To test that everything is working as expected, run `npm start` and open `localhost:8000`
    in your browser. Hit the `build` button to create a full page of lights. If everything
    has been done correctly, you should see each light blink at 5-second intervals:'
  id: totrans-858
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试一切是否按预期工作，请运行`npm start`并在浏览器中打开`localhost:8000`。点击`build`按钮创建一个完整页面的灯。如果一切都做对了，你应该看到每盏灯在5秒的间隔内闪烁：
- en: '![Figure 5.20: Lightbulbs with flash mode'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.20：带有闪光模式的灯泡'
- en: '](Images/C14587_05_20.jpg)'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_05_20.jpg)'
- en: 'Figure 5.20: Lightbulbs with flash mode'
  id: totrans-861
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.20：带有闪光模式的灯泡
- en: 'Chapter 6: Code Quality'
  id: totrans-862
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章：代码质量
- en: 'Activity 7: Putting It All Together'
  id: totrans-863
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动7：将所有内容整合在一起
- en: '**Solution**'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Install the developer dependencies listed in the linting exercise (`eslint`,
    `prettier`, `eslint-config-airbnb-base`, `eslint-config-prettier`, `eslint-plugin-jest`,
    and `eslint-plugin-import`):'
  id: totrans-865
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装linting练习中列出的开发人员依赖项（`eslint`，`prettier`，`eslint-config-airbnb-base`，`eslint-config-prettier`，`eslint-plugin-jest`和`eslint-plugin-import`）：
- en: '[PRE172]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Add an `eslint` configuration file, `.eslintrc`, which contains the following:'
  id: totrans-867
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`eslint`配置文件`.eslintrc`，其中包含以下内容：
- en: '[PRE173]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Add a .`prettierignore` file:'
  id: totrans-869
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`.prettierignore`文件：
- en: '[PRE174]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Add a `lint` command to your `package.json` file:'
  id: totrans-871
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`package.json`文件中添加一个`lint`命令：
- en: '[PRE175]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Open the `assignment` folder and install the developer dependencies for using
    Puppeteer with Jest:'
  id: totrans-873
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`assignment`文件夹并安装使用Puppeteer与Jest的开发人员依赖项：
- en: '[PRE176]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Modify your `package.json` file by adding an option telling Jest to use the
    `jest-puppeteer` preset:'
  id: totrans-875
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加一个选项告诉Jest使用`jest-puppeteer`预设来修改你的`package.json`文件：
- en: '[PRE177]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Add a `test` script to `package.json` that runs `jest`:'
  id: totrans-877
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`package.json`中添加一个`test`脚本，运行`jest`：
- en: '[PRE178]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Create a `jest-puppeteer.config.js` file containing the following:'
  id: totrans-879
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下内容的`jest-puppeteer.config.js`文件：
- en: '[PRE179]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Create a test file at `__tests__/calculator.js` that contains the following:'
  id: totrans-881
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__tests__/calculator.js`创建一个测试文件，其中包含以下内容：
- en: '[PRE180]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Create a Husky file at `.huskyrc` that contains the following:'
  id: totrans-883
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下内容的`.huskyrc`文件：
- en: '[PRE181]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Install `husky` as a developer dependency by running `npm install --save-dev
    husky`:![Figure 6.19: Installing Husky'
  id: totrans-885
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`npm install --save-dev husky`安装`husky`作为开发人员依赖项：![图6.19：安装Husky
- en: '](Images/C14587_06_19.jpg)'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_06_19.jpg)'
- en: 'Figure 6.19: Installing Husky'
  id: totrans-887
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.19：安装Husky
- en: 'Ensure that tests are working correctly using the `npm test` command:'
  id: totrans-888
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保使用`npm test`命令正确运行测试：
- en: '[PRE182]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'This should return positive results for two tests, as shown in the following
    figure:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回两个测试的正面结果，如下图所示：
- en: '![Figure 6.20: Showing the positive result of two tests'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.20：显示两个测试的正面结果'
- en: '](Images/C14587_06_20.jpg)'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_06_20.jpg)'
- en: 'Figure 6.20: Showing the positive result of two tests'
  id: totrans-893
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.20：显示两个测试的正面结果
- en: Ensure the Git hook and linting is working by making a test commit.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进行测试提交来确保Git钩子和linting正常工作。
- en: 'Chapter 7: Advanced JavaScript'
  id: totrans-895
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章：高级JavaScript
- en: 'Activity 8: Creating a User Tracker'
  id: totrans-896
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动8：创建一个用户跟踪器
- en: '**Solution**'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Open the `Activity08.js` file and define `logUser`. It will add the user to
    the `userList` argument. Make sure no duplicates are added:'
  id: totrans-898
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Activity08.js`文件并定义`logUser`。它将把用户添加到`userList`参数中。确保不会添加重复项：
- en: '[PRE183]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Here, we used an `includes` method to check whether the user already exists.
    If they don't, they will be added to our list.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`includes`方法来检查用户是否已经存在。如果他们不存在，他们将被添加到我们的列表中。
- en: 'Define `userLeft`. It will remove the user from the `userList` argument. If
    the user doesn''t exist, it will do nothing:'
  id: totrans-901
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`userLeft`。它将从`userList`参数中移除用户。如果用户不存在，它将不执行任何操作：
- en: '[PRE184]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Here, we are using `indexOf` to get the current index of the user we want to
    remove. If the item doesn't exist, `indexOf` will `return –1`, so we are only
    using `splice` to remove the item if it exists.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`indexOf`来获取要移除的用户的当前索引。如果该项不存在，`indexOf`将`返回-1`，因此我们只在存在时使用`splice`来移除该项。
- en: 'Define `numUsers`, which returns the number of users currently inside the list:'
  id: totrans-904
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`numUsers`，返回当前列表中的用户数：
- en: '[PRE185]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Define a function called `runSite`. We will create a `users` array and call
    the function we declared previously to test our implementation. We will also invoke
    the function afterward:'
  id: totrans-906
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`runSite`的函数。我们将创建一个`users`数组，并调用我们之前声明的函数来测试我们的实现。之后我们也会调用该函数：
- en: '[PRE186]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'After defining the functions, running the preceding code will return the following
    output:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义函数之后，运行上述代码将返回以下输出：
- en: '![Figure 7.62: Output of running log_users.js'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.62：运行log_users.js的输出'
- en: '](Images/C14587_07_62.jpg)'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_62.jpg)'
- en: 'Figure 7.62: Output of running log_users.js'
  id: totrans-911
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.62：运行log_users.js的输出
- en: 'Activity 9: Creating a Student Manager Using JavaScript Arrays and Classes'
  id: totrans-912
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动9：使用JavaScript数组和类创建学生管理器
- en: '**Solution**'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Create a `School` class that includes all the student''s information:'
  id: totrans-914
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含所有学生信息的`School`类：
- en: '[PRE187]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: In the `School` constructor, we simply initialize a list of students. Later,
    we will add new students to this list.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 在`School`构造函数中，我们只是初始化了一个学生列表。稍后，我们将向此列表添加新学生。
- en: 'Create a `Student` class that includes all the relevant information about the
    student:'
  id: totrans-917
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Student`类，包括有关学生的所有相关信息：
- en: '[PRE188]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: In the student `constructor`, we are storing a list of courses, as well as the
    student's `age`, `name`, and `gradeLevel`.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 在学生`constructor`中，我们存储了课程列表，以及学生的`age`，`name`和`gradeLevel`。
- en: 'Create a `Course` class that will include information about the course''s `name`
    and `grade`:'
  id: totrans-920
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Course`类，其中包括有关课程的`name`和`grade`的信息：
- en: '[PRE189]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: The course constructor simply stores the name of the course and grade in the
    `object`.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 课程构造函数只是将课程的名称和成绩存储在`object`中。
- en: 'Create `addStudent` in the `School` class:'
  id: totrans-923
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`School`类中创建`addStudent`：
- en: '[PRE190]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Create `findByGrade` in the `School` class:'
  id: totrans-925
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`School`类中创建`findByGrade`：
- en: '[PRE191]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Create `findByAge` in the `School` class:'
  id: totrans-927
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`School`类中创建`findByAge`：
- en: '[PRE192]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'Create `findByName` in the `School` class:'
  id: totrans-929
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`School`类中创建`findByName`：
- en: '[PRE193]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'In the `Student` class, create a `calculateAverageGrade` method for calculating
    the average grade of the student:'
  id: totrans-931
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Student`类中，创建一个`calculateAverageGrade`方法来计算学生的平均成绩：
- en: '[PRE194]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: In the `calculateAverageGrade` method, we use array reduce to get the total
    grades of all the classes for our student. Then, we divide this by the number
    of courses in our courses list.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 在`calculateAverageGrade`方法中，我们使用数组reduce来获取学生所有课程的总成绩。然后，我们将其除以课程列表中的课程数。
- en: 'In the `Student` class, create a method called `assignGrade`, which will assign
    a number grade for a course the student is taking:'
  id: totrans-934
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Student`类中，创建一个名为`assignGrade`的方法，用于为学生正在上的课程分配数字成绩：
- en: '[PRE195]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'You should do your work in the `student_manager.js` file and modify the provided
    method template. You should see the **TEST PASSED** message if you implemented
    everything correctly:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在`student_manager.js`文件中进行工作，并修改提供的方法模板。如果您正确实现了所有内容，您应该看到**TEST PASSED**消息：
- en: '![Figure 7.63: Screenshot showing the TEST PASSED message'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.63：显示TEST PASSED消息的屏幕截图'
- en: '](Images/C14587_07_63.jpg)'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_63.jpg)'
- en: 'Figure 7.63: Screenshot showing the TEST PASSED message'
  id: totrans-939
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.63：显示TEST PASSED消息的屏幕截图
- en: 'Activity 10: Refactoring Functions to Use Modern JavaScript Features'
  id: totrans-940
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动10：重构函数以使用现代JavaScript功能
- en: '**Solution**'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Open `Activity03.js`; it should contain various functions written in legacy
    JavaScript. When you run `Activity03.js` using Node.js, you should see the following
    output:![Figure 7.64: Output after running Lesson7-activity.js'
  id: totrans-942
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Activity03.js`；它应该包含用传统JavaScript编写的各种函数。当您使用Node.js运行`Activity03.js`时，您应该看到以下输出：![图7.64：运行Lesson7-activity.js后的输出
- en: '](Images/C14587_07_64.jpg)'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_64.jpg)'
- en: 'Figure 7.64: Output after running Lesson7-activity.js'
  id: totrans-944
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.64：运行Lesson7-activity.js后的输出
- en: 'You need to refactor `itemExist`, using the `includes` array:'
  id: totrans-945
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要重构`itemExist`，使用`includes`数组：
- en: '[PRE196]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'In `createFilledArray`, we will use `array.fill` to fill our array with an
    initial value:'
  id: totrans-947
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`createFilledArray`中，我们将使用`array.fill`来用初始值填充我们的数组：
- en: '[PRE197]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'In `removeLast`, we will use `array.pop` to remove the last item:'
  id: totrans-949
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`removeLast`中，我们将使用`array.pop`来移除最后一项：
- en: '[PRE198]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'We will refactor our `Food` class using the `ES6` class:'
  id: totrans-951
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`ES6`类重构我们的`Food`类：
- en: '[PRE199]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'After you have finished the refactor and run the existing code, you should
    see the same output:'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 在您完成重构并运行现有代码后，您应该看到相同的输出：
- en: '![Figure 7.65: Output showing the TEST PASSED message'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.65：显示TEST PASSED消息的输出'
- en: '](Images/C14587_07_65.jpg)'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_65.jpg)'
- en: 'Figure 7.65: Output showing the TEST PASSED message'
  id: totrans-956
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.65：显示TEST PASSED消息的输出
- en: 'Chapter 8: Asynchronous Programming'
  id: totrans-957
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章：异步编程
- en: 'Activity 11: Using Callbacks to Receive Results'
  id: totrans-958
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动11：使用回调接收结果
- en: '**Solution**:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: 'Create a `calculate` function that takes `id` and a `callback` as an argument:'
  id: totrans-960
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`calculate`函数，它接受`id`和`callback`作为参数：
- en: '[PRE200]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'We will first call `getUsers` to get all of the users. This will give us the
    address we need:'
  id: totrans-962
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先调用`getUsers`来获取所有用户。这将给我们所需的地址：
- en: '[PRE201]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Here, we get all of the users, then we apply the `find` method to the `user`
    to find the user we want from the list. If that user does not exist, we call the
    `callback` function with the `User not found` error.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们获取所有用户，然后对`user`应用`find`方法来从列表中找到我们想要的用户。如果该用户不存在，我们将使用`User not found`错误调用`callback`函数。
- en: 'Call `getUsage` to get the user''s usage:'
  id: totrans-965
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`getUsage`来获取用户的使用情况：
- en: '[PRE202]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Then, we need to put the call to `getUsage` inside the callback of `getUsers`
    so it will run after we have finished calling `getUsers`. Here, the callback will
    be called with a list of numbers, which will be the usage. We will also call the
    callback with the error object if we receive an error from `getUsage`.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将对`getUsers`的调用放在`getUsage`的回调函数中，这样它将在我们完成调用`getUsers`后运行。在这里，回调函数将被调用并传入一个数字列表，这将是使用情况。如果我们从`getUsage`收到错误，我们还将使用错误对象调用回调函数。
- en: 'Finally, call `getRate` to get the rate of the user we are doing the calculation
    for:'
  id: totrans-968
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用`getRate`以获取我们正在计算的用户的费率：
- en: '[PRE203]'
  id: totrans-969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: We will put this call inside the callback for `getUsage`. This creates a nested
    chain request for all the information we need. Lastly, we will call the callback
    with the information we are calculating. For the final due amount, we use array
    reduce to calculate the total usage for that user, and then multiply that by the
    rate to get the final amount due.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个调用放在`getUsage`的回调函数中。这为我们需要的所有信息创建了一个嵌套的链请求。最后，我们将使用数组reduce来计算该用户的总使用量，然后将其乘以费率以获得最终应付金额。
- en: 'When the function is completed, invoke it using an existing ID, as in the following
    code:'
  id: totrans-971
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当函数完成时，使用现有ID调用它，如下面的代码：
- en: '[PRE204]'
  id: totrans-972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'You should see output like this:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Figure 8.43: Invoking the function using an existing ID'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.43：使用现有ID调用函数'
- en: '](Images/C14587_08_43.jpg)'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_43.jpg)'
- en: 'Figure 8.43: Invoking the function using an existing ID'
  id: totrans-976
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.43：使用现有ID调用函数
- en: 'Invoke the function using an ID that doesn''t exist:'
  id: totrans-977
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个不存在的ID调用函数：
- en: '[PRE205]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'You should see the following output with the error returned:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到返回的错误如下：
- en: '![Figure 8.44: Invoking a function using an ID that doesn’t exist'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.44：使用不存在的ID调用函数'
- en: '](Images/C14587_08_44.jpg)'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_44.jpg)'
- en: 'Figure 8.44: Invoking a function using an ID that doesn''t exist'
  id: totrans-982
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.44：使用不存在的ID调用函数
- en: 'Activity 12: Refactor the Bill Calculator Using Async and Await'
  id: totrans-983
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动12：使用异步和等待重构账单计算器
- en: '**Solution**'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Create the `calculate` function as an `async` function:'
  id: totrans-985
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`calculate`函数创建为`async`函数：
- en: '[PRE206]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'Use `await` to call `getUsers` to get the resolved result in `users`:'
  id: totrans-987
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`await`调用`getUsers`以获取`users`中的解析结果：
- en: '[PRE207]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: When we are using the `await` keyword, we must use `async` functions. The `await`
    keyword will break the control of our program and will only return and continue
    execution once the promise it is waiting for is resolved.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`await`关键字时，我们必须使用`async`函数。`await`关键字将打破程序的控制，并且只有在等待的promise被解析后才会返回并继续执行。
- en: 'Use `await` to call `getUsage` to get the usage for the user:'
  id: totrans-990
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`await`调用`getUsage`以获取用户的使用情况：
- en: '[PRE208]'
  id: totrans-991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Use `await` to call `getRate` to get the rate for the user:'
  id: totrans-992
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`await`调用`getRate`以获取用户的费率：
- en: '[PRE209]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'Lastly, we will call `return` to retrieve `id`, `address`, and `due`:'
  id: totrans-994
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将调用`return`以检索`id`，`address`和`due`：
- en: '[PRE210]'
  id: totrans-995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'Write the `calculateAll` function as an `async` function:'
  id: totrans-996
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`calculateAll`函数创建为`async`函数：
- en: '[PRE211]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'Use `await` when we call `getUsers` and store the result in `result`:'
  id: totrans-998
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`getUsers`时使用`await`并将结果存储在`result`中：
- en: '[PRE212]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Use a map array to create a list of promises and use `Promise.all` to wrap
    them. Then, should be use `await` on the promise returned by `Promise.all`:'
  id: totrans-1000
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用映射数组创建一个promise列表，并使用`Promise.all`将它们包装起来。然后，应该在`Promise.all`返回的promise上使用`await`：
- en: '[PRE213]'
  id: totrans-1001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Because `await` will work on any promise and will wait until the value is resolved,
    it will also wait for our `Promise.all`. After it is resolved, the final array
    will be returned.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`await`将在任何promise上工作，并且会等待直到值被解析，它也会等待我们的`Promise.all`。在它被解析后，最终数组将被返回。
- en: 'Call `calculate` on one of the users:'
  id: totrans-1003
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个用户上调用`calculate`：
- en: '[PRE214]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'The output should be as follows:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.45: Calling calculate on one of the users'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.45：在一个用户上调用calculate'
- en: '](Images/C14587_08_45.jpg)'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_45.jpg)'
- en: 'Figure 8.45: Calling calculate on one of the users'
  id: totrans-1008
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.45：在一个用户上调用calculate
- en: 'Call the `calculateAll` function:'
  id: totrans-1009
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`calculateAll`函数：
- en: '[PRE215]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'The output should be as follows:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.46: Calling the calculateAll function'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.46：调用calculateAll函数'
- en: '](Images/C14587_08_46.jpg)'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_46.jpg)'
- en: 'Figure 8.46: Calling the calculateAll function'
  id: totrans-1014
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.46：调用calculateAll函数
- en: As you can see, when we call `async` functions, we can treat them as functions
    that return a promise.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，当我们调用`async`函数时，我们可以将它们视为返回promise的函数。
- en: 'Chapter 9: Event-Driven Programming and Built-In Modules'
  id: totrans-1016
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章：事件驱动编程和内置模块
- en: 'Activity 13: Building an Event-Driven Module'
  id: totrans-1017
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动13：构建事件驱动模块
- en: '**Solution**:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: 'Perform the following steps to complete this activity:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此活动：
- en: 'Import the `events` module:'
  id: totrans-1020
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`events`模块：
- en: '[PRE216]'
  id: totrans-1021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'Create the `SmokeDetector` class that extends `EventEmitter` and set `batteryLevel`
    to `10`:'
  id: totrans-1022
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`SmokeDetector`类，它扩展了`EventEmitter`并将`batteryLevel`设置为`10`：
- en: '[PRE217]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: In our constructor, because we are extending the `EventEmitter` class and we
    are assigning a custom property, `batteryLevel`, we will need to call `super`
    inside the constructor and set `batteryLevel` to `10`.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的构造函数中，因为我们正在扩展`EventEmitter`类并且正在分配一个自定义属性`batteryLevel`，我们需要在构造函数中调用`super`并将`batteryLevel`设置为`10`。
- en: 'Create a `test` method inside the `SmokeDetector` class that will test the
    battery level and emit a `low battery` message in the event that the battery is
    low:'
  id: totrans-1025
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SmokeDetector`类中创建一个`test`方法，该方法将测试电池电量，并在电池电量低时发出`低电量`消息：
- en: '[PRE218]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: Our `test()` method will check the battery level and emit a `low battery` event
    when the battery has less than 0.5 units. We will also reduce the battery level
    every time we run the `test` method.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`test()`方法将检查电池电量，并在电池电量低于0.5单位时发出`低电量`事件。每次运行`test`方法时，我们还会减少电池电量。
- en: 'Create the `House` class, which will store the instances of our event listeners:'
  id: totrans-1028
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`House`类，它将存储我们事件监听器的实例：
- en: '[PRE219]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: In the `House` class, we are storing some information about the house. We are
    also storing both of the event listener functions as properties of this object.
    This way, we can use the function reference to call `removeListener` when we want
    to detach a listener.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 在`House`类中，我们存储了一些关于房子的信息。我们还将两个事件侦听器函数存储为此对象的属性。这样，我们可以使用函数引用在想要分离侦听器时调用`removeListener`。
- en: 'Create an `addDetector` method in the `House` class. Here, we will attach the
    event listeners:'
  id: totrans-1031
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`House`类中创建一个`addDetector`方法。在这里，我们将附加事件侦听器：
- en: '[PRE220]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: Here, we are expecting the detector that's passed in to be an `EventEmitter`.
    We are attaching two event listeners to our `detector` argument. When these events
    are emitted, it will invoke our event emitter inside the object.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们期望传入的探测器是一个`EventEmitter`。我们将两个事件侦听器附加到我们的`detector`参数。当这些事件被触发时，它将调用我们对象内的事件发射器。
- en: 'Create a `removeDetector` method, which will help us remove the alarm event
    listeners we attached previously:'
  id: totrans-1034
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`removeDetector`方法，它将帮助我们删除先前附加的警报事件侦听器：
- en: '[PRE221]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: Here, we are using the function reference and the alarm argument to remove the
    listener attached to our listener. Once this is called, the events should not
    invoke our listener again.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用函数引用和警报参数来删除附加到我们侦听器的侦听器。一旦调用了这个，事件就不应该再次调用我们的侦听器。
- en: 'Create a `House` instance called `myHouse`. This will contain some sample information
    about our house. It will also be used to listen to events from our smoke detector:'
  id: totrans-1037
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`myHouse`的`House`实例。这将包含关于我们房子的一些示例信息。它还将用于监听我们的烟雾探测器发出的事件：
- en: '[PRE222]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'Create a `SmokeDetector` instance called `detector`:'
  id: totrans-1039
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`detector`的`SmokeDetector`实例：
- en: '[PRE223]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'Add our `detector` to `myHouse`:'
  id: totrans-1041
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的`detector`添加到`myHouse`：
- en: '[PRE224]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'Create a loop to call the test function `96` times:'
  id: totrans-1043
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个循环来调用测试函数`96`次：
- en: '[PRE225]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'Because the testing function will reduce the battery level, we will expect
    a *low battery* alarm to be emitted if we call it `96` times. This will produce
    the following output:'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 因为测试函数将减少电池电量，如果我们调用它`96`次，我们将期望发出*低电量*警报。这将产生以下输出：
- en: '![Figure 9.50: Low battery alarm emitted'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.50：发出低电量警报'
- en: '](Images/C14587_09_50.jpg)'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_50.jpg)'
- en: 'Figure 9.50: Low battery alarm emitted'
  id: totrans-1048
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.50：发出低电量警报
- en: 'Emit an alarm on the `detector` object:'
  id: totrans-1049
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`detector`对象上发出警报：
- en: '[PRE226]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'The following is the output of the preceding code:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 9.51: Alarm emitted for the detector object'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.51：对检测器对象发出的警报'
- en: '](Images/C14587_09_51.jpg)'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_51.jpg)'
- en: 'Figure 9.51: Alarm emitted for the detector object'
  id: totrans-1054
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.51：对检测器对象发出的警报
- en: 'Remove `detector` from the `myHouse` object:'
  id: totrans-1055
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`myHouse`对象中删除`detector`：
- en: '[PRE227]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'Test this to emit the alarms on the `detector`:'
  id: totrans-1057
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试这个以在`detector`上发出警报：
- en: '[PRE228]'
  id: totrans-1058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'Because we just removed `detector` from our house, we should see no output
    from this:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们刚刚从我们的房子中移除了`detector`，所以我们不应该看到这个输出：
- en: '![Figure 9.52: Testing the emit alarms on the detector'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.52：测试检测器上的发出警报'
- en: '](Images/C14587_09_52.jpg)'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_52.jpg)'
- en: 'Figure 9.52: Testing the emit alarms on the detector'
  id: totrans-1062
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.52：测试检测器上的发出警报
- en: 'Activity 14: Building a File Watcher'
  id: totrans-1063
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动14：构建文件监视器
- en: '**Solution**:'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: 'Import `fs` and `events`:'
  id: totrans-1065
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`fs`和`events`：
- en: '[PRE229]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: Create a `fileWatcher` class that extends the `EventEmitter` class. Use a `modify`
    timestamp to keep track of the file change.
  id: totrans-1067
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个扩展`EventEmitter`类的`fileWatcher`类。使用`modify`时间戳来跟踪文件更改。
- en: 'We need to create a `FileWatcher` class that extends `EventEmitter`. It will
    take the filename and delay as parameters in the constructor. In the constructor,
    we will also need to set the last modified time and the timer variable. We will
    keep them as undefined for now:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个扩展`EventEmitter`的`FileWatcher`类。它将在构造函数中以文件名和延迟作为参数。在构造函数中，我们还需要设置上次修改时间和计时器变量。现在我们将它们保持为未定义：
- en: '[PRE230]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: This is the most basic way to see whether a file has been changed.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 这是查看文件是否已更改的最基本方法。
- en: 'Create the `startWatch` method to start watching the changes on the file:'
  id: totrans-1071
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`startWatch`方法以开始监视文件的更改：
- en: '[PRE231]'
  id: totrans-1072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: Here, we are using `fs.stat` to get the file's information and comparing the
    modified time with the last modified time. If they are not equal, we will output
    **modified** in the console.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`fs.stat`来获取文件的信息，并将修改时间与上次修改时间进行比较。如果它们不相等，我们将在控制台中输出**修改**。
- en: 'Create the `stopWatch` method to stop watching the changes on the file:'
  id: totrans-1074
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`stopWatch`方法以停止监视文件的更改：
- en: '[PRE232]'
  id: totrans-1075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'The `stopWatch` method is very simple: we will check if we have a timer in
    this object. If we do, then we run `clearInterval` on that timer to clear that
    timer.'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: '`stopWatch`方法非常简单：我们将检查这个对象中是否有一个计时器。如果有，那么我们将在该计时器上运行`clearInterval`以清除该计时器。'
- en: Create a `test.txt` file in the same directory as `filewatch.js`.
  id: totrans-1077
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`filewatch.js`相同的目录中创建一个名为`test.txt`的文件。
- en: 'Create a `FileWatcher` instance and start watching the file every `1000` ms:'
  id: totrans-1078
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`FileWatcher`实例并每`1000`毫秒开始监视文件：
- en: '[PRE233]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'Modify some content in `test.txt` and save it. You should see the following
    output:![Figure 9.53: Output after modifying the content in the test.txt file'
  id: totrans-1080
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`test.txt`中的一些内容并保存。您应该看到以下输出：![图9.53：修改`test.txt`文件内容后的输出
- en: '](Images/C14587_09_53.jpg)'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_53.jpg)'
- en: 'Figure 9.53: Output after modifying the content in the test.txt file'
  id: totrans-1082
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.53：修改`test.txt`文件内容后的输出
- en: We modified the file twice, which means we are seeing three modified messages.
    This is happening because when we start the watch, we class this as the file being
    modified.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改了文件两次，这意味着我们看到了三条修改消息。这是因为当我们开始观察时，我们将其视为文件已被修改。
- en: 'Modify `startWatch` so that it also retrieves the new content:'
  id: totrans-1084
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`startWatch`以检索新内容：
- en: '[PRE234]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'When we modify `test.txt` and save it, our code should detect it and output
    the new content:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们修改`test.txt`并保存时，我们的代码应该检测到并输出新内容：
- en: '![Figure 9.54: The modifications that were made in the file can be seen using
    the startWatch function'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.54：可以使用startWatch函数看到对文件所做的修改'
- en: '](Images/C14587_09_54.jpg)'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_54.jpg)'
- en: 'Figure 9.54: The modifications that were made in the file can be seen using
    the startWatch function'
  id: totrans-1089
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.54：可以使用startWatch函数看到对文件所做的修改
- en: 'Modify `startWatch` so that it emits events when the file is modified and an
    error when it encounters an error:'
  id: totrans-1090
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`startWatch`，使其在文件被修改时发出事件，并在遇到错误时发出错误：
- en: '[PRE235]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: Instead of outputting the content, we will emit an event with the new content.
    This makes our code much more flexible.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不再输出内容，而是发出一个带有新内容的事件。这使我们的代码更加灵活。
- en: 'Attach event handlers to `error` and change them on our file `watcher`:'
  id: totrans-1093
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将事件处理程序附加到`error`并在我们的文件`watcher`上更改它们：
- en: '[PRE236]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'Run the code and modify `test.txt`:'
  id: totrans-1095
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并修改`test.txt`：
- en: '![Figure 9.55: Output after changing our file watcher'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.55：更改文件监视器后的输出'
- en: '](Images/C14587_09_55.jpg)'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_55.jpg)'
- en: 'Figure 9.55: Output after changing our file watcher'
  id: totrans-1098
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.55：更改文件监视器后的输出
- en: 'Chapter 10: Functional Programming with JavaScript'
  id: totrans-1099
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章：使用JavaScript进行函数式编程
- en: 'Activity 15: onCheckout Callback Prop'
  id: totrans-1100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动15：onCheckout回调属性
- en: '**Solution**'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: Change the current directory to `Lesson10` and run `npm install` if you haven't
    done so in this directory before. `npm install` downloads the dependencies that
    are required in order to run this activity (React and Parcel).
  id: totrans-1102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前目录更改为`Lesson10`，如果之前在此目录中尚未执行过`npm install`，则运行`npm install`。`npm install`会下载运行此活动所需的依赖项（React和Parcel）。
- en: 'Run `parcel serve activity-on-checkout-prop-start.html` and then execute `npm
    run Activity15`. You will see the application starting up, as follows:![Figure
    10.42: Output after running the start html script'
  id: totrans-1103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`parcel serve activity-on-checkout-prop-start.html`，然后执行`npm run Activity15`。您将看到应用程序启动，如下所示：![图10.42：运行start
    html脚本后的输出
- en: '](Images/C14587_10_42.jpg)'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_42.jpg)'
- en: 'Figure 10.42: Output after running the start html script'
  id: totrans-1105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.42：运行start html脚本后的输出
- en: 'Go to `http://localhost:1234` (or whichever URL the start script output). You
    should see the following HTML page:![Figure 10.43: Initial application in the
    browser'
  id: totrans-1106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`http://localhost:1234`（或者启动脚本输出的任何URL）。您应该看到以下HTML页面：![图10.43：浏览器中的初始应用程序
- en: '](Images/C14587_10_43.jpg)'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_43.jpg)'
- en: 'Figure 10.43: Initial application in the browser'
  id: totrans-1108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.43：浏览器中的初始应用程序
- en: 'The `onClick` of the **Proceed to checkout** can be implemented as follows:'
  id: totrans-1109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**继续结账**的`onClick`可以实现如下：'
- en: '[PRE237]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'This follows on from the following investigation:'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是以下调查的延续：
- en: Finding the button in the `Basket` component's `render` method whose text is
    `Proceed to checkout`.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Basket`组件的`render`方法中查找文本为“继续结账”的按钮。
- en: Noticing its `onClick` handler is currently a function that does nothing when
    called, `() => {}`.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到它的`onClick`处理程序当前是一个在调用时什么都不做的函数，`() => {}`。
- en: Replacing the `onClick` handler with the correct call to `this.props.onCheckout`.
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 用正确的调用`this.props.onCheckout`替换`onClick`处理程序。
- en: 'We should see the following after clicking the `Proceed to checkout` button:'
  id: totrans-1115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“继续结账”按钮后，我们应该看到以下内容：
- en: '![Figure 10.44: Output after clicking on the “Proceed to checkout” button'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.44：单击“继续结账”按钮后的输出'
- en: '](Images/C14587_10_44.jpg)'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_44.jpg)'
- en: 'Figure 10.44: Output after clicking on the "Proceed to checkout" button'
  id: totrans-1118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.44：单击“继续结账”按钮后的输出
- en: 'Activity 16: Testing a Selector'
  id: totrans-1119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动16：测试选择器
- en: '**Solution**'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Run `npm run Activity16` (or `node activity-items-selector-test-start.js`).
    You will see the following output:![Figure 10.45: Expected output after running
    the start file of the activity'
  id: totrans-1121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm run Activity16`（或`node activity-items-selector-test-start.js`）。您将看到以下输出：![图10.45：运行活动的初始启动文件后的预期输出
- en: '](Images/C14587_10_45.jpg)'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_45.jpg)'
- en: 'Figure 10.45: Expected output after running the start file of the activity'
  id: totrans-1123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.45：运行活动的初始启动文件后的预期输出
- en: 'Test that, for empty states, the selector returns `[]`:'
  id: totrans-1124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试一下，对于空状态，选择器返回`[]`：
- en: '[PRE238]'
  id: totrans-1125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'Test that, for an empty basket object, the selector returns []:'
  id: totrans-1126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试一下，对于一个空的购物篮对象，选择器返回[]：
- en: '[PRE239]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: Test that, if the items array is set but empty, the selector returns `[]:`
  id: totrans-1128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试一下，如果项目数组已设置但为空，则选择器返回`[]`：
- en: '[PRE240]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'Test that, if the `items` array is not empty and set, the selector returns
    it:'
  id: totrans-1130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试一下，如果`items`数组不为空且已设置，则选择器返回它：
- en: '[PRE241]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'There should be no errors in the output of the implemented test:'
  id: totrans-1132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实施测试的输出中不应该有错误：
- en: '![Figure 10.46: Final output showing no errors'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.46：最终输出显示没有错误'
- en: '](Images/C14587_10_46.jpg)'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_46.jpg)'
- en: 'Figure 10.46: Final output showing no errors'
  id: totrans-1135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.46：最终输出显示没有错误
- en: 'Activity 17: Fetching the Current Basket From BFF'
  id: totrans-1136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动17：从BFF获取当前购物篮
- en: '**Solution**'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: Change the current directory to `Lesson10` and run `npm install` if you haven't
    done so in this directory before.
  id: totrans-1138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前目录更改为`Lesson10`，如果之前在此目录中尚未执行过`npm install`，则运行`npm install`。
- en: 'Run the BFF for Activity 17 and `npx parcel serve activity-app-start.html`.
    During development, run `npm run Activity17`. You will see the application starting
    up, as follows:![Figure 10.47: Running the initial start file for the activity'
  id: totrans-1139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Activity 17的BFF和`npx parcel serve activity-app-start.html`。在开发过程中，运行`npm run
    Activity17`。您将看到应用程序启动，如下所示：![图10.47：运行活动的初始启动文件
- en: '](Images/C14587_10_47.jpg)'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_47.jpg)'
- en: 'Figure 10.47: Running the initial start file for the activity'
  id: totrans-1141
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.47：运行活动的初始启动文件
- en: 'Go to `http://localhost:1234` (or whichever URL the starting script output).
    You should see the following HTML page:![Figure 10.48: Initial application in
    the browser'
  id: totrans-1142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`http://localhost:1234`（或者启动脚本输出的任何URL）。您应该看到以下HTML页面：![图10.48：浏览器中的初始应用程序
- en: '](Images/C14587_10_48.jpg)'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_48.jpg)'
- en: 'Figure 10.48: Initial application in the browser'
  id: totrans-1144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.48：浏览器中的初始应用程序
- en: 'Run the following query in the GraphiQL UI:'
  id: totrans-1145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GraphiQL UI中运行以下查询：
- en: '[PRE242]'
  id: totrans-1146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'The following is the output of the preceding code:'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 10.49: GraphiQL UI with basket query'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.49：带有购物篮查询的GraphiQL UI'
- en: '](Images/C14587_10_49.jpg)'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_10_49.jpg)'
- en: 'Figure 10.49: GraphiQL UI with basket query'
  id: totrans-1150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.49：带有购物篮查询的GraphiQL UI
- en: 'Create a new `requestBasket` action creator (that leverages redux-thunk). It
    calls `fetchFromBff` with the query from the previous step and dispatches a `REQUEST_BASKET_SUCCESS`
    action with a basket payload extracted from the GraphQL response:'
  id: totrans-1151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`requestBasket`动作创建器（利用redux-thunk）。它使用上一步的查询调用`fetchFromBff`，并分派一个从GraphQL响应中提取的购物篮有效负载的`REQUEST_BASKET_SUCCESS`动作：
- en: '[PRE243]'
  id: totrans-1152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'Reduce the basket data into the store and add the following case to `appReducer`
    to reduce our new `REQUEST_BASKET_SUCCESS` action''s `basket` payload into the
    state:'
  id: totrans-1153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将篮子数据减少到存储中，并将以下情况添加到`appReducer`中，以将我们新的`REQUEST_BASKET_SUCCESS`动作的`basket`负载减少到状态中：
- en: '[PRE244]'
  id: totrans-1154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'Add `requestBasket` in `mapDispatchToProps`, like so:'
  id: totrans-1155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mapDispatchToProps`中添加`requestBasket`，如下所示：
- en: '[PRE245]'
  id: totrans-1156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'Call `requestBasket` on `componentDidMount`:'
  id: totrans-1157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`componentDidMount`上调用`requestBasket`：
- en: '[PRE246]'
  id: totrans-1158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'When loading up the application with all the preceding steps completed, it
    flashes with the "You have 0 items in your basket" message before changing to
    the following screenshot. When the fetch from the BFF completes, it is reduced
    into the store and causes a re-render. This will display the basket once again,
    as follows:'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用所有前述步骤加载应用程序时，它会闪烁显示“您的篮子中有0件物品”的消息，然后变成以下屏幕截图。当从BFF获取完成时，它会减少到存储中并导致重新渲染。这将再次显示篮子，如下所示：
- en: '![Figure 10.50: Final application once it has been integrated with the BFF](Images/C14587_10_50.jpg)'
  id: totrans-1160
  prefs: []
  type: TYPE_IMG
  zh: '![图10.50：一旦与BFF集成，最终应用程序](Images/C14587_10_50.jpg)'
- en: 'Figure 10.50: Final application once it has been integrated with the BFF'
  id: totrans-1161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.50：一旦与BFF集成，最终应用程序
