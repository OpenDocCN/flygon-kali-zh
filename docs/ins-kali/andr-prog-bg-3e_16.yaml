- en: '*Chapter 16*: Adapters and Recyclers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第16章*：适配器和回收器'
- en: In this brief chapter, we will achieve a lot. We will first go through the theory
    of adapters and lists – how we can extend the `RecyclerAdapter` class in Java
    code and add a `RecyclerView` instance that acts as a list to our UI – and then
    through the apparent magic of how the Android API binds them together so that
    `RecyclerView` displays the contents of `RecyclerAdapter` and allows the user
    to scroll through the contents. You have probably guessed that we will be using
    this technique to display our list of notes in the Note to Self app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的章节中，我们将取得很大进展。我们将首先学习适配器和列表的理论 - 如何在Java代码中扩展`RecyclerAdapter`类并添加一个作为列表的`RecyclerView`实例到我们的UI
    - 然后通过Android API的明显魔术将它们绑定在一起，以便`RecyclerView`显示`RecyclerAdapter`的内容并允许用户滚动内容。你可能已经猜到，我们将使用这种技术来显示我们的Note
    to Self应用程序中的笔记列表。
- en: 'In this chapter, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Looking at the theory of adapters and binding them to our UI
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究适配器的理论并将其绑定到我们的UI
- en: Implementing the layout with `RecyclerView`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`RecyclerView`实现布局
- en: Laying out a list item for use in `RecyclerView`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为在`RecyclerView`中使用的列表项布局
- en: Implementing the adapter with `RecyclerAdapter`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`RecyclerAdapter`实现适配器
- en: Binding the adapter to `RecyclerView`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将适配器绑定到`RecyclerView`
- en: Storing notes in `ArrayList` and displaying them in `RecyclerView`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将笔记存储在`ArrayList`中，并在`RecyclerView`中显示它们
- en: Discussing how we can improve the Note to Self app further
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论如何进一步改进Note to Self应用程序
- en: Soon we will have a self-managing layout that holds and displays all of our
    notes, so let's get started.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 很快我们将拥有一个自我管理的布局，用来保存和显示所有的笔记，所以让我们开始吧。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2016.](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2016
    )
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件，网址为[https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2016.](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2016
    )
- en: RecyclerView and RecyclerAdapter
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RecyclerView和RecyclerAdapter
- en: In [*Chapter 5*](B16773_05_ePub_RK.xhtml#_idTextAnchor101), *Beautiful Layouts
    with CardView and ScrollView*, we used `ScrollView` and we populated it with a
    few `CardView` widgets so we could see it scrolling. We could take what we have
    just learned about arrays and `ArrayList` and create an array of `TextView` widgets,
    use them to populate a `ScrollView`, and within each `TextView` place the title
    of a note. This sounds like a perfect solution for showing each note so that it
    is clickable in the Note to Self app.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B16773_05_ePub_RK.xhtml#_idTextAnchor101)，*使用CardView和ScrollView创建美丽的布局*，我们使用了`ScrollView`，并用一些`CardView`小部件填充它，以便我们可以看到它滚动。我们可以利用我们刚学到的关于数组和`ArrayList`的知识，创建一个`TextView`小部件数组，用它们填充一个`ScrollView`，并在每个`TextView`中放置一个笔记的标题。这听起来像是在Note
    to Self应用程序中显示每个笔记的完美解决方案。
- en: We could create the `TextView` widgets dynamically in Java code, set their `text`
    property to be the title of a note, and then add the `TextView` widgets to a `LinearLayout`
    contained in a `ScrollView`. However, this is imperfect.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Java代码中动态创建`TextView`小部件，将它们的`text`属性设置为笔记的标题，然后将`TextView`小部件添加到`ScrollView`中包含的`LinearLayout`中。然而，这并不完美。
- en: The problem with displaying lots of widgets
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示大量小部件的问题
- en: This might seem fine, but what if there were dozens, hundreds, or even thousands
    of notes? We couldn't have thousands of `TextView` widgets in memory because the
    Android device might simply run out of memory or at the very least grind to a
    halt as it tries to handle the scrolling of such a vast amount of widgets and
    their data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不错，但如果有数十、数百甚至数千个笔记怎么办？我们不能在内存中拥有数千个`TextView`小部件，因为Android设备可能会因为尝试处理如此大量的小部件和它们的数据而耗尽内存，或者至少变得非常缓慢。
- en: Now, also imagine that we wanted (which we do) each note in the `ScrollView`
    to show whether it was important, a to-do, or an idea. And how about a short snippet
    from the text of the note as well?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下我们（我们确实想要）希望`ScrollView`中的每个笔记显示它是重要的、待办事项还是想法。以及笔记文本的简短片段呢？
- en: We would need to devise some clever code that loads and destroys `Note` objects
    and multiple `TextView` widgets per note from multiple `ArrayList` instances.
    It can be done, but doing it efficiently is far from straightforward.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设计一些聪明的代码，从多个`ArrayList`实例中加载和销毁`Note`对象和每个笔记的多个`TextView`小部件。这是可以做到的，但要高效地完成远非易事。
- en: The solution to the problem of displaying lots of widgets
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示大量小部件的问题的解决方案
- en: Fortunately, this is a problem faced so commonly by mobile developers that the
    Android API has a solution built in.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这是移动开发人员如此常见的问题，以至于Android API内置了解决方案。
- en: We can add a single widget called `RecyclerView` (like an environmentally friendly
    `ScrollView` but with boosters too) to our UI layout. The `RecyclerView` class
    was designed precisely as a solution to the problem we have been discussing. In
    addition, we need to interact with `RecyclerView` with a special type of class
    that understands how `RecyclerView` works.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的UI布局中添加一个名为`RecyclerView`的单个小部件（类似于环保的`ScrollView`，但也带有助推器）。`RecyclerView`类被设计为解决我们讨论的问题的解决方案。此外，我们需要使用一种特殊类型的类与`RecyclerView`进行交互，该类了解`RecyclerView`的工作原理。
- en: We will interact with it using an adapter. We will use the `RecyclerAdapter`
    class, extend it, customize it, and then use it to control the data from our `ArrayList`
    instance (which will hold our `Note` instances) and display it in `RecyclerView`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用适配器与之交互。我们将使用`RecyclerAdapter`类，扩展它，自定义它，然后使用它来控制我们的`ArrayList`实例（其中将保存我们的`Note`实例）的数据并在`RecyclerView`中显示它。
- en: Let's find out a bit more about how the `RecyclerView` and `RecyclerAdapter`
    classes work.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更多地了解一下`RecyclerView`和`RecyclerAdapter`类的工作原理。
- en: How to use RecyclerView and RecyclerAdapter
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用RecyclerView和RecyclerAdapter
- en: We already know how to store almost unlimited notes; we can do so in an `ArrayList`
    instance, although we haven't implemented it yet. We also know that there is a
    UI layout called `RecyclerView` that is specifically designed to display potentially
    long lists of data from an `ArrayList` instance. We just need to see how to put
    it all into action.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何存储几乎无限的笔记；我们可以在`ArrayList`实例中这样做，尽管我们还没有实现它。我们也知道有一个名为`RecyclerView`的UI布局，专门设计用于从`ArrayList`实例中显示潜在的长列表数据。我们只需要看看如何将所有这些付诸实践。
- en: To add a `RecyclerView` widget to our layout, we can simply drag and drop it,
    from the palette onto our UI, in the usual way. Don't do it yet. Let's just discuss
    it for a bit first.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要向我们的布局添加`RecyclerView`小部件，我们可以简单地从调色板上拖放它到我们的UI上，以通常的方式。现在不要这样做。让我们先讨论一下。
- en: 'The `RecyclerView` widget will look like this in the UI designer if you added
    one underneath the button in `content_main.xml`, for example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在`content_main.xml`中的按钮下面添加了一个`RecyclerView`小部件，那么UI设计师中的`RecyclerView`小部件将如下所示：
- en: '![Figure 16.1 – RecyclerView widget'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.1 - RecyclerView小部件'
- en: '](img/Figure_16.01_B16773.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.01_B16773.jpg)'
- en: Figure 16.1 – RecyclerView widget
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 - RecyclerView小部件
- en: This appearance, however, is more a representation of the possibilities than
    the actual appearance of an app. If we run the app straight after adding a `RecyclerView`
    widget, we just get a blank area where the `RecyclerView` widget is.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种外观更多地代表了可能性，而不是应用程序的实际外观。如果我们在添加`RecyclerView`小部件后立即运行应用程序，我们只会得到一个`RecyclerView`小部件所在的空白区域。
- en: The first thing we need to do, to make practical use of `RecyclerView`, is to
    decide what each item in the list will look like. It could be just a single `TextView`
    widget or it could be an entire layout. We will use `LinearLayout`. To be clear
    and specific, we will use a `LinearLayout` that holds three `TextView` widgets
    for each item in our `RecyclerView`. This will allow us to display the note status
    (important, idea, or to-do), the note title, and a short snippet of text from
    the actual note contents.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际使用`RecyclerView`，我们需要做的第一件事是决定列表中的每个项目的外观。它可以是一个单独的`TextView`小部件，也可以是一个完整的布局。我们将使用`LinearLayout`。为了清晰和具体，我们将使用一个`LinearLayout`，它包含我们的`RecyclerView`中每个项目的三个`TextView`小部件。这将允许我们显示笔记状态（重要、想法或待办事项）、笔记标题以及来自实际笔记内容的短片段文本。
- en: A list item needs to be defined in its own XML file, then `RecyclerView` can
    hold multiple instances of this list item layout.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在其自己的XML文件中定义列表项，然后`RecyclerView`可以容纳此列表项布局的多个实例。
- en: Of course, none of this explains how we overcome the complexity of managing
    what data is shown in which list item and how it is retrieved from an `ArrayList`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些都没有解释我们如何克服管理显示在哪个列表项中的数据的复杂性，以及如何从`ArrayList`中检索数据。
- en: This data handling is taken care of by our own customized implementation of
    the `RecyclerAdapter` class. The `RecyclerAdapter` class implements the `Adapter`
    interface. We don't need to know how `Adapter` works internally; we just need
    to override the necessary methods, and then `RecyclerAdapter` will do all the
    work of communicating with our `RecyclerView` widget.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据处理由我们自己定制的`RecyclerAdapter`类来处理。`RecyclerAdapter`类实现了`Adapter`接口。我们不需要知道`Adapter`内部是如何工作的；我们只需要重写必要的方法，然后`RecyclerAdapter`将负责与我们的`RecyclerView`小部件进行通信。
- en: Wiring up an implementation of `RecyclerAdapter` to `RecyclerView` is certainly
    more complicated than dragging 20 `TextView` instances onto a `ScrollView` – but
    once it is done, we can forget about it and it will keep on working and manage
    itself regardless of how many notes we add to the `ArrayList`. It also has built-in
    features for handling things such as neat formatting and detecting which item
    in a list was clicked.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将`RecyclerAdapter`的实现连接到`RecyclerView`肯定比将20个`TextView`实例拖放到`ScrollView`上要复杂得多
    - 但一旦完成，我们就可以忘记它，它将继续工作并自行管理，而不管我们向`ArrayList`中添加了多少笔记。它还具有处理诸如整洁格式和检测列表中点击了哪个项目等功能。
- en: We will need to override some methods of the `RecyclerAdapter` class and add
    a little code of our own.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重写`RecyclerAdapter`类的一些方法，并添加一些我们自己的代码。
- en: What we will do to set up RecyclerView with RecyclerAdapter and an ArrayList
    of notes
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们将如何使用RecyclerAdapter和笔记的ArrayList设置RecyclerView
- en: 'Let''s look at an outline of the required steps so we know what to expect.
    To get the whole thing up and running, we would do the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看一下所需步骤的概要，以便知道可以期望什么。为了使整个过程正常运行，我们将执行以下操作：
- en: Delete the temporary button and related code, and then add a `RecyclerView`
    widget to our layout with a specific `id` property.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除临时按钮和相关代码，然后向我们的布局添加一个具有特定`id`属性的`RecyclerView`小部件。
- en: Create an XML layout to represent each item in the list. We have already mentioned
    each item in the list will be a `LinearLayout` that contains three `TextView`
    widgets.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个XML布局来表示列表中的每个项目。我们已经提到列表中的每个项目将是一个包含三个`TextView`小部件的`LinearLayout`。
- en: Create a new class that extends `RecyclerAdapter` and add code to several overridden
    methods to control how it looks and behaves, including using our list item layout
    and `ArrayList` full of `Note` instances.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个扩展`RecyclerAdapter`的新类，并向多个重写的方法添加代码，以控制其外观和行为，包括使用我们的列表项布局和充满`Note`实例的`ArrayList`。
- en: Add code to the `MainActivity` class to use the `RecyclerAdapter` class and
    the `RecyclerView` widget and bind it to our `ArrayList` instance.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`MainActivity`类添加代码，以使用`RecyclerAdapter`类和`RecyclerView`小部件，并将其绑定到我们的`ArrayList`实例。
- en: Add an `ArrayList` to `MainActivity` to hold all our notes and update the `createNewNote`
    method to add any new notes created in the `DialogNewNote` class to this `ArrayList`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`MainActivity`添加一个`ArrayList`以保存我们所有的笔记，并更新`createNewNote`方法，以将在`DialogNewNote`类中创建的任何新笔记添加到这个`ArrayList`中。
- en: Let's walk through each of these steps in detail.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细地走一遍每一步。
- en: Adding RecyclerView, RecyclerAdapter, and ArrayList to the Note to Self project
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Note to Self项目添加RecyclerView、RecyclerAdapter和ArrayList
- en: Open the Note to Self project. As a reminder, if you want to see the completed
    code and working app as a result of completing this chapter, it can be found in
    the [*Chapter 16*](B16773_16_ePub_RK.xhtml#_idTextAnchor285)`/Note to self` folder.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 打开“Note to Self”项目。作为提醒，如果您想要查看完成本章后的代码和工作中的应用程序，可以在[*第16章*](B16773_16_ePub_RK.xhtml#_idTextAnchor285)`/Note
    to self`文件夹中找到。
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As the required actions in this chapter jump around between different files,
    classes, and methods, I encourage you to follow along with the files from the
    download bundle by keeping it open for reference in your preferred text editor.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章中所需的操作在不同的文件、类和方法之间跳转，我鼓励您通过在首选文本编辑器中保持打开以供参考的下载包中的文件来跟随。
- en: Removing the temporary "Show Note" button and adding RecyclerView
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除临时的“显示笔记”按钮并添加RecyclerView
- en: 'These next few steps will get rid of the temporary code we added in [*Chapter
    14*](B16773_14_ePub_RK.xhtml#_idTextAnchor249)*, Android Dialog Windows*, and
    set up our `RecyclerView` widget ready for binding to `RecyclerAdapter` later
    in the chapter:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个步骤将清除我们在[*第14章*](B16773_14_ePub_RK.xhtml#_idTextAnchor249)*Android对话框窗口*中添加的临时代码，并设置我们的`RecyclerView`小部件，以便在本章后面绑定到`RecyclerAdapter`：
- en: In the `content_main.xml` file, remove the temporary `Button` with an ID of
    `button`, which we added previously for testing purposes.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`content_main.xml`文件中，删除之前为测试目的添加的ID为`button`的临时`Button`。
- en: 'In the `onCreate` method of the `MainActivity.java` file, delete the `Button`
    instance declaration and initialization along with the anonymous class that handles
    its clicks as this code now creates an error. We will delete some more temporary
    code later in this chapter. Delete the following code:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity.java`文件的`onCreate`方法中，删除`Button`实例声明和初始化以及处理其点击的匿名类，因为此代码现在会创建错误。我们将在本章后面删除一些临时代码。删除以下代码：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now switch back to the `content_main.xml` file in design view and drag a **RecyclerView**
    widget from the **Containers** category of the palette onto the layout.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在切换回设计视图中的`content_main.xml`文件，并从调色板的**容器**类别中拖放一个**RecyclerView**小部件到布局中。
- en: Set its `id` property to `recyclerView`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其`id`属性设置为`recyclerView`。
- en: Now we have removed the temporary UI aspects from our project and we have a
    `RecyclerView` widget complete with a unique `id` value ready to be referenced
    from our Java code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从项目中删除了临时的UI方面，并且我们有了一个完整的`RecyclerView`小部件，具有一个准备从我们的Java代码中引用的唯一`id`值。
- en: Creating a list item for RecyclerView
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为RecyclerView创建列表项
- en: Next, we need a layout to represent each item in our `RecyclerView` widget.
    As previously mentioned, we will use a `LinearLayout` that holds three `TextView`
    widgets.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个布局来表示`RecyclerView`小部件中的每个项目。如前所述，我们将使用一个包含三个`TextView`小部件的`LinearLayout`。
- en: 'Use the following steps to create a list item for use within our `RecyclerView`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤创建一个用于在我们的`RecyclerView`中使用的列表项：
- en: Right-click on the `listitem` in the `LinearLayout`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`LinearLayout`中的`listitem`。
- en: Make sure you are on the `orientation` attribute to `vertical`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您在`orientation`属性上选择了`vertical`。
- en: Look at the next screenshot to see what we are trying to achieve with the remaining
    steps of this section. I have annotated it to show what each part will be in the
    finished app:![Figure 16.2 – List item for use within our RecyclerView
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看下一个屏幕截图，以了解我们在本节剩余步骤中要实现的内容。我已经对其进行了注释，以显示完成应用程序中每个部分的内容：![图16.2 - 用于在我们的RecyclerView中使用的列表项
- en: '](img/Figure_16.02_B16773.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.02_B16773.jpg)'
- en: Figure 16.2 – List item for use within our RecyclerView
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 - 用于在我们的RecyclerView中使用的列表项
- en: Drag three `TextView` widgets onto the layout, one above the other, as per the
    reference image. The first (top) will hold the note status/type (idea, important,
    or to-do). The second (middle) will hold the note title and the third (bottom)
    the snippet of text from the note itself.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将三个`TextView`小部件拖放到布局中，依次排列。第一个（顶部）将保存笔记状态/类型（想法、重要或待办事项）。第二个（中间）将保存笔记标题，第三个（底部）将保存笔记本身的文本片段。
- en: Configure the various attributes of the `LinearLayout` and `TextView` widgets
    as shown in the following table:![](img/B16773_table_16.1.jpg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下表格配置`LinearLayout`和`TextView`小部件的各种属性：![](img/B16773_table_16.1.jpg)
- en: Now we have a `RecylerView` widget for the main layout and a layout to use for
    each item in the list of `RecyclerView`. We can go ahead and code our `RecyclerAdapter`
    class implementation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个用于主布局的`RecylerView`小部件和一个用于`RecyclerView`列表中每个项目的布局。我们可以继续编写我们的`RecyclerAdapter`类实现。
- en: Coding the RecyclerAdapter class
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写RecyclerAdapter类的代码
- en: We will now create and code a brand-new class. Let's call our new class `NoteAdapter`.
    Create a new class called `NoteAdapter` in the same folder as the `MainActivity`
    class (and all the other classes).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建并编写一个全新的类。让我们称之为我们的新类`NoteAdapter`。在与`MainActivity`类（以及所有其他类）相同的文件夹中创建一个名为`NoteAdapter`的新类。
- en: 'Edit the code for the `NoteAdapter` class by adding these `import` statements
    and extending it with the `RecyclerView.Adapter` class, and then add these two
    important member variables. Edit the `NoteAdapter` class to be the same as the
    following code that we have just discussed:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加这些`import`语句并将其扩展为`RecyclerView.Adapter`类来编辑`NoteAdapter`类的代码，然后添加这两个重要的成员变量。编辑`NoteAdapter`类，使其与我们刚刚讨论过的以下代码相同：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice the class declaration is underlined in red showing there is an error
    in our code. The error is there because the `RecylerView.Adapter` class (that
    we are extending) needs us to override some of its abstract methods.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到类声明被红色下划线标出，显示我们的代码中有错误。错误是因为我们需要重写`RecylerView.Adapter`类（我们正在扩展的类）的一些抽象方法。
- en: Note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We discussed abstract classes and their methods in [*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201),
    *More Object-Oriented Programming*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第11章*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)中讨论了抽象类及其方法，*更多面向对象的编程*。
- en: 'The quickest way to do this is to click the class declaration, hold the *Alt*
    key, and then tap the *Enter* key. Choose **Implement methods**, as shown in the
    following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的最快方法是点击类声明，按住*Alt*键，然后点击*Enter*键。选择**实现方法**，如下面的截图所示：
- en: '![Figure 16.3 – Selecting Implement methods'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.3 - 选择实现方法'
- en: '](img/Figure_16.03_B16773.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.03_B16773.jpg)'
- en: Figure 16.3 – Selecting Implement methods
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 - 选择实现方法
- en: Then, click **OK** to have Android Studio auto-generate the required methods.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击**确定**以让Android Studio自动生成所需的方法。
- en: 'This process adds the following three methods:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程添加了以下三个方法：
- en: The `onCreateViewHolder` method, which is called when a layout for a list item
    is required.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreateViewHolder`方法，在需要列表项布局时调用。'
- en: The `onBindViewHolder` method, which is called when `RecyclerAdapter` is bound
    to (connected/associated with) `RecyclerView` in the layout.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onBindViewHolder`方法，在将`RecyclerAdapter`绑定到布局中的`RecyclerView`时调用。'
- en: The `getItemCount` method, which will be used to return the number of `Note`
    instances in `ArrayList`. Now it just returns `0`.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getItemCount`方法，将用于返回`ArrayList`中`Note`实例的数量。现在它只返回`0`。'
- en: We will soon add code to each of these methods to do the required work at the
    specified time.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 很快我们将为这些方法中的每一个添加代码，以在指定的时间做必要的工作。
- en: 'Note, however, that we still have multiple errors in our code, including in
    the auto-generated methods as well as the class declaration. A screenshot of the
    code editor at this stage might be useful:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，我们的代码中仍然存在多个错误，包括自动生成的方法以及类声明。此时代码编辑器的截图可能会有用：
- en: '![Figure 16.4 – Multiple errors in our code'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.4 - 我们代码中的多个错误'
- en: '](img/Figure_16.04_B16773.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.04_B16773.jpg)'
- en: Figure 16.4 – Multiple errors in our code
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4 - 我们代码中的多个错误
- en: The errors are there because the `NoteAdapter.ListItemHolder` class does not
    exist. `ListItemHolder` was added by us when we extended `NoteAdapter`. It is
    our chosen class type that will be used as the holder for each list item. At the
    moment, it doesn't exist, hence the error. The two methods that also have the
    same error for the same reason were auto-generated when we asked Android Studio
    to implement the missing methods.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是因为`NoteAdapter.ListItemHolder`类不存在。当我们扩展`NoteAdapter`时，我们添加了`ListItemHolder`。这是我们选择的类类型，将用作每个列表项的持有者。目前它不存在，因此出现错误。当我们要求Android
    Studio实现缺失的方法时，也会自动生成具有相同原因的两个方法。
- en: Let's solve the problem by making a start on the required `ListItemHolder` class.
    It is useful to us if `ListItemHolder` instances share data/variables with `NoteAdapter`,
    therefore we will create `ListItemHolder` as an inner class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过开始编写所需的`ListItemHolder`类来解决问题。如果`ListItemHolder`实例与`NoteAdapter`共享数据/变量对我们有用，因此我们将`ListItemHolder`创建为内部类。
- en: 'Click the error in the class declaration and select **Create class ''ListItemHolder''**,
    as shown in the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 点击类声明中的错误，然后选择**创建类'ListItemHolder'**，如下截图所示：
- en: '![Figure 16.5 – Selecting Create class ''ListItemHolder'''
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.5 - 选择创建类''ListItemHolder'''
- en: '](img/Figure_16.05_B16773.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.05_B16773.jpg)'
- en: Figure 16.5 – Selecting Create class 'ListItemHolder'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5 - 选择创建类'ListItemHolder'
- en: 'The following code has been added to the `NoteAdapter` class:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码已添加到`NoteAdapter`类中：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But there is still one error with the class declaration, as shown in this screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但是类声明仍然有一个错误，如下截图所示：
- en: '![Figure 16.6 – Error with the class declaration'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.6 - 类声明错误'
- en: '](img/Figure_16.06_B16773.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.06_B16773.jpg)'
- en: Figure 16.6 – Error with the class declaration
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6 - 类声明错误
- en: The error message reads `ListItemHolder` but `ListItemHolder` must also extend
    `RecyclerView.ViewHolder` in order to be used as the parameterized type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息显示`ListItemHolder`，但`ListItemHolder`必须扩展`RecyclerView.ViewHolder`才能用作参数化类型。
- en: 'Amend the declaration of the `ListItemHolder` class to match this code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`ListItemHolder`类的声明以匹配此代码：
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now the error is gone from the `NoteAdapter` class declaration but because
    we implemented `View.OnClickListener`, we need to implement the `onClick` method.
    Furthermore, `ViewHolder` doesn''t provide a default constructor, so we need to
    do it. Add the following `onClick` method (empty for now) and this constructor
    method (empty for now) to the `ListItemHolder` class:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`NoteAdapter`类声明中的错误已经消失，但因为我们实现了`View.OnClickListener`，我们需要实现`onClick`方法。此外，`ViewHolder`没有提供默认构造函数，所以我们需要添加。将以下`onClick`方法（暂时为空）和此构造方法（暂时为空）添加到`ListItemHolder`类中：
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Be sure you added the code to the inner `ListItemHolder` class and not the `NoteAdapter`
    class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您将代码添加到内部的`ListItemHolder`类而不是`NoteAdapter`类。
- en: After much tinkering and auto-generating, we finally have an error-free `NoteAdapter`
    class complete with overridden methods and an inner class that we can code to
    get our `RecyclerAdapter` class working. In addition, we can write code to respond
    to clicks (in the `onClick` method) on each of our `ListItemHolder` instances.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 经过多次调整和自动生成，我们最终拥有了一个无错误的`NoteAdapter`类，其中包括重写的方法和一个内部类，我们可以编写代码来使我们的`RecyclerAdapter`类工作。此外，我们可以编写代码来响应每个`ListItemHolder`实例的点击（在`onClick`方法中）。
- en: Coding the NoteAdapter constructor
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写NoteAdapter构造函数
- en: 'Next, we will code the `NoteAdapter` constructor method, which will initialize
    the members of the `NoteAdapter` class. Add this constructor to the `NoteAdapter`
    class:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写`NoteAdapter`构造方法，该方法将初始化`NoteAdapter`类的成员。将此构造方法添加到`NoteAdapter`类中：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, notice the parameters of the constructor. It receives a `MainActivity`
    instance as well as a `List`. This implies that when we use this class, we will
    need to send in a reference to the main activity of this app (`MainActivity`)
    as well as a `List`/`ArrayList`. We will see what use we put the `MainActivity`
    reference to shortly, but we can sensibly guess that the reference to a `List`
    with the parameterized `<Note>` type will be a reference to our `ArrayList` of
    `Note` instances that we will soon code in the `MainActivity` class. `NoteAdapter`
    will then hold a permanent reference to all the user's notes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意构造函数的参数。它接收一个“MainActivity”实例以及一个“List”。这意味着当我们使用这个类时，我们需要发送一个对这个应用程序的主要活动（“MainActivity”）的引用，以及一个“List”/“ArrayList”。我们很快就会看到我们很快会在“MainActivity”类中编写的“Note”实例的“ArrayList”引用。然后，“NoteAdapter”将永久持有对所有用户笔记的引用。
- en: Coding the onCreateViewHolder method
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写onCreateViewHolder方法
- en: 'Next, we will adapt the auto-generated `onCreateViewHolder` method. Add the
    two highlighted lines of code to the `onCreateViewHolder` method and study the
    parameters that were auto-generated:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将调整自动生成的“onCreateViewHolder”方法。将两行代码添加到“onCreateViewHolder”方法中，并研究自动生成的参数：
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code works by initializing `itemView` using `LayoutInflater` and our newly
    designed `listitem` layout. It then returns a new `ListItemHolder` instance complete
    with an inflated and ready-to-use layout.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码通过使用“LayoutInflater”和我们新设计的“listitem”布局来初始化“itemView”。然后返回一个新的“ListItemHolder”实例，其中包含一个已经膨胀并且可以立即使用的布局。
- en: Coding the onBindViewHolder method
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写onBindViewHolder方法
- en: 'Next, we will adapt the `onBindViewHolder` method. Add the highlighted code
    to make the method the same as this code and also make sure to study the method''s
    parameters as well:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将调整“onBindViewHolder”方法。添加突出显示的代码使方法与此代码相同，并确保也研究方法的参数：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, the code checks whether the note is longer than 15 characters and if
    it is, it truncates it so it looks sensible in the list.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码检查笔记是否超过15个字符，如果是，则将其截断，以便在列表中看起来合理。
- en: Then, it checks what type of note it is (idea, to-do, or important) and assigns
    the appropriate label from the string resources.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它检查笔记的类型（想法、待办事项或重要）并从字符串资源中分配适当的标签。
- en: This new code has left some errors in the code with the `holder.mTitle`, `holder.mDescription`,
    and `holder.mStatus` variables because we need to add them to our `ListItemHolder`
    inner class. We will do this very soon.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这段新代码在“holder.mTitle”、“holder.mDescription”和“holder.mStatus”变量中留下了一些错误，因为我们需要将它们添加到我们的“ListItemHolder”内部类中。我们很快就会做到这一点。
- en: Coding getItemCount
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写getItemCount
- en: 'Amend the `return` statement in this auto-generated method to be the same as
    the highlighted line of code shown next:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 修改此自动生成方法中的“return”语句，使其与下一行显示的突出显示的代码相同：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code is used internally by the class and it supplies the current number
    of items in `ArrayList`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在类内部使用，并提供“ArrayList”中当前项目的数量。
- en: Coding the ListItemHolder inner class
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写ListItemHolder内部类
- en: 'Now we can turn our attention to the inner class, `ListItemHolder`. Adapt the
    `ListItemHolder` inner class by adding the following highlighted code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以转向内部类“ListItemHolder”。通过添加以下突出显示的代码来调整“ListItemHolder”内部类：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `ListItemHolder` constructor just gets a reference to each of the `TextView`
    widgets in the layout. The final two lines of code set the whole view as clickable
    so that the operating system will call the next method we discuss, `onClick`,
    when a holder is clicked.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: “ListItemHolder”构造函数只是获取布局中每个“TextView”小部件的引用。最后两行代码将整个视图设置为可点击，以便操作系统在点击持有者时调用我们讨论的下一个方法“onClick”。
- en: In the `onClick` method, the call to the `mMainActivity.showNote` method has
    an error because the method doesn't exist yet, but we will fix that in the next
    section. The call will show the clicked note in its appropriate `DialogFragment`
    instance.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在“onClick”方法中，“mMainActivity.showNote”方法的调用存在错误，因为该方法尚不存在，但我们将在下一节中修复这个问题。该调用将在适当的“DialogFragment”实例中显示被点击的笔记。
- en: Coding MainActivity to use the RecyclerView and RecyclerAdapter classes
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写MainActivity以使用RecyclerView和RecyclerAdapter类
- en: 'Now, switch over to the `MainActivity` class in the editor window. Add these
    three new members to the `MainActivity` class and remove the temporary code shown
    commented out next:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，切换到编辑窗口中的“MainActivity”类。将这三个新成员添加到“MainActivity”类中，并删除下面注释掉的临时代码：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following `import` directives if you haven''t already:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未添加，请添加以下“import”指令：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These three members are our `ArrayList` for all our `Note` instances, our `RecyclerView`
    instance, and an instance of our class, `NoteAdapter`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个成员是我们所有“Note”实例的“ArrayList”，我们的“RecyclerView”实例以及我们的类“NoteAdapter”的一个实例。
- en: Adding code to the onCreate method
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向“onCreate”方法添加代码
- en: 'Add the following highlighted code to the `onCreate` method after the code
    that handles presses on the floating action button (shown again for context):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理浮动操作按钮的代码之后，将以下突出显示的代码添加到“onCreate”方法中（为了上下文再次显示）：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code will need the following three `import` directives:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将需要以下三个“import”指令：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we initialize the `recyclerView` reference with the `RecyclerView`
    instance in the layout. Our `NoteAdapter` (`mAdapter`) is initialized by calling
    the constructor we coded and note that a reference to `MainActivity` (`this`)
    and the `ArrayList` instance is passed in, just as required by the class we have
    coded previously.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用布局中的“RecyclerView”实例初始化“recyclerView”引用。通过调用我们编写的构造函数来初始化我们的“NoteAdapter”（“mAdapter”）并注意到对“MainActivity”（“this”）和“ArrayList”实例的引用被传递进来，正如我们之前编写的类所要求的那样。
- en: Next, we create a new object, `LayoutManager`. In the next line of code, we
    call `setLayoutManager` on `recyclerView` and pass in this new `LayoutManager`
    instance. Now we can configure some properties of `recyclerView`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新对象“LayoutManager”。在下一行代码中，我们在“recyclerView”上调用“setLayoutManager”并传入这个新的“LayoutManager”实例。现在我们可以配置“recyclerView”的一些属性。
- en: The `setItemAnimator` and `addItemDecoration` methods make each list item a
    little more visually enhanced with a separator line between each item in the list.
    Later, when we build a settings screen, we will give the user the option to add
    and remove this separator.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`setItemAnimator`和`addItemDecoration`方法使每个列表项在列表中的每个项目之间都有一个分隔线，视觉上更加美观。稍后，当我们构建设置屏幕时，我们将让用户选择添加和删除这个分隔线。'
- en: The last thing we do is call the `setAdapter` method, which combines our adapter
    with our view.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的最后一件事是调用`setAdapter`方法，将我们的适配器与我们的视图结合起来。
- en: Now we will make some changes to the `addNote` method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将对`addNote`方法进行一些更改。
- en: Modifying the addNote method
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改addNote方法
- en: 'In the `addNote` method, delete the temporary code we added in [*Chapter 14*](B16773_14_ePub_RK.xhtml#_idTextAnchor249)*,
    Android Dialog Windows*, (shown commented out) and add the new highlighted code
    shown next:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addNote`方法中，删除我们在[*第14章*](B16773_14_ePub_RK.xhtml#_idTextAnchor249)*Android对话框窗口*中添加的临时代码（显示为注释），并添加下面显示的新突出显示的代码：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The new highlighted code adds a note to `ArrayList` instead of simply initializing
    a solitary `Note` object, which has now been commented out. Then, we need to call
    the `notifyDataSetChanged` method, which lets our adapter know that a new note
    has been added.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 新突出显示的代码将一个笔记添加到`ArrayList`中，而不仅仅是初始化一个孤立的`Note`对象，现在已经被注释掉。然后，我们需要调用`notifyDataSetChanged`方法，让我们的适配器知道已经添加了一个新的笔记。
- en: Coding the showNote method
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写showNote方法
- en: 'Add this new method, which is called from the `NoteAdapter` class using the
    reference to this class that was passed into the `NoteAdapter` constructor. More
    specifically, it is called from the `ListerItemHolder` inner class when one of
    the items in `RecyclerView` is tapped by the user. Add the `showNote` method to
    the `MainActivity` class:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这个新方法，它是从`NoteAdapter`类中使用传递给`NoteAdapter`构造函数的对该类的引用来调用的。更具体地说，当用户点击`RecyclerView`中的项目时，它是从`ListerItemHolder`内部类中调用的。将`showNote`方法添加到`MainActivity`类中：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All the errors in the `NoteAdapter.java` file are now gone.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`NoteAdapter.java`文件中的所有错误现在都已经消失。'
- en: The code just added will launch a new instance of `DialogShowNote` and pass
    in the specific, required note as pointed to by `noteToShow`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚添加的代码将启动一个新的`DialogShowNote`实例，并传入由`noteToShow`指向的特定所需的笔记。
- en: Running the app
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'You can now run the app and enter a new note as shown in the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以运行应用程序，并输入一个新的笔记，如下面的截图所示：
- en: '![Figure 16.7 – Adding a new note'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.7 – 添加新笔记'
- en: '](img/Figure_16.07_B16773.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.07_B16773.jpg)'
- en: Figure 16.7 – Adding a new note
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7 – 添加新笔记
- en: 'After you have entered several notes of several types, the list (`RecyclerView`)
    will look something like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当您输入了几种类型的笔记后，列表（`RecyclerView`）将看起来像这样：
- en: '![Figure 16.8 – List of notes'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.8 – 笔记列表'
- en: '](img/Figure_16.08_B16773.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.08_B16773.jpg)'
- en: Figure 16.8 – List of notes
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8 – 笔记列表
- en: Reader challenge
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 读者挑战
- en: We could have spent more time formatting the layouts of our two dialog windows.
    Why not refer to [*Chapter 5*](B16773_05_ePub_RK.xhtml#_idTextAnchor101)*, Beautiful
    Layouts with CardView and ScrollView*, as well as the Material Design website
    and do a better job than we have done so far? Furthermore, you could enhance the
    `RecyclerView` class/list of notes by using `CardView` instead of `LinearLayout`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以花更多时间来格式化我们的两个对话框窗口的布局。为什么不参考[*第5章*](B16773_05_ePub_RK.xhtml#_idTextAnchor101)*使用CardView和ScrollView创建美丽的布局*，以及Material
    Design网站，做得比我们迄今为止做得更好呢？此外，您可以通过使用`CardView`而不是`LinearLayout`来增强`RecyclerView`类/笔记列表。
- en: Don't spend too long adding new notes, however, because there is a slight problem.
    Close and restart the app. Uh oh, all the notes are gone!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 不要花太长时间添加新的笔记，因为有一个小问题。关闭并重新启动应用程序。哦，所有的笔记都消失了！
- en: Frequently asked questions
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: I still don't understand how `RecyclerAdapter` works – why?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我仍然不明白`RecyclerAdapter`是如何工作的 – 为什么？
- en: 'That''s because we haven''t really discussed it. The reason we have not discussed
    the behind-the-scenes details is that we don''t need to know them. If we override
    the required methods, as we have just seen, everything will work. This is how
    `RecyclerAdapter` and most other classes we use are meant to be: hidden implementations
    with public methods to expose the necessary functionality.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们实际上没有讨论它。我们没有讨论背后的细节的原因是我们不需要知道它们。如果我们重写了所需的方法，就像我们刚刚看到的那样，一切都会正常工作。这就是`RecyclerAdapter`和我们使用的大多数其他类的意图：隐藏实现，公开方法来暴露必要的功能。
- en: Do I need to know what is going on inside the `RecyclerAdapter` class and other
    classes as well?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我需要了解`RecyclerAdapter`类和其他类的内部情况吗？
- en: 'It is true that there are more details about `RecyclerAdapter` (and almost
    every class that we use in this book) that we don''t have the space to discuss.
    It is good practice to read the official documentation of the classes you use.
    You can read more about all the classes from the Android API here: [https://developer.android.com/reference](https://developer.android.com/reference).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，关于`RecyclerAdapter`（以及我们在本书中使用的几乎每个类）还有更多细节，我们没有空间来讨论。阅读您使用的类的官方文档是一个好习惯。您可以在这里阅读有关Android
    API的所有类的更多信息：[https://developer.android.com/reference](https://developer.android.com/reference)。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Now we have added the ability to hold multiple notes and implemented the ability
    to display them.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了保存多个笔记的能力，并实现了显示它们的能力。
- en: We achieved this by learning about and using the `RecyclerAdapter` class, which
    implements the `Adapter` interface, which allows us to bind together `RecyclerView`
    and `ArrayList`, allowing the seamless display of data without us (the programmer)
    having to worry about the complex code that is part of these classes and that
    we don't even see.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过学习和使用`RecyclerAdapter`类来实现了这一点，该类实现了`Adapter`接口，允许我们将`RecyclerView`和`ArrayList`绑定在一起，无需我们（程序员）担心这些类的复杂代码，而我们甚至看不到。
- en: In the next chapter, we will start with making the user's notes persist when
    they quit the app or switch off their device. In addition, we will create a settings
    screen and see how we can make the settings persist as well. We will use different
    techniques to achieve each of these goals.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始让用户的笔记在他们退出应用程序或关闭设备时保持。此外，我们将创建一个设置屏幕，并看看我们如何使设置也持久。我们将使用不同的技术来实现这些目标。
