- en: Packaging and Running Applications as Docker Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包和运行应用程序作为Docker容器
- en: 'Docker reduces the logical view of your infrastructure to three core components:
    hosts, containers, and images. Hosts are servers that run containers, and each
    container is an isolated instance of an application. Containers are created from
    images, which are packaged applications. A Docker container image is conceptually
    very simple: it''s a single unit that contains a complete, self-contained application.
    The image format is very efficient, and the integration between the image and
    the container runtime is very smart, so mastering images is your first step to
    using Docker effectively.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将基础设施的逻辑视图简化为三个核心组件：主机、容器和图像。主机是运行容器的服务器，每个容器都是应用程序的隔离实例。容器是从图像创建的，图像是打包的应用程序。Docker容器图像在概念上非常简单：它是一个包含完整、自包含应用程序的单个单元。图像格式非常高效，图像和容器运行时之间的集成非常智能，因此掌握图像是有效使用Docker的第一步。
- en: You've already seen some images in [Chapter 1](59b504fb-1012-4118-aa49-c5e0efce06d3.xhtml),
    *Getting Started with Docker on Windows**,* by running some basic containers to
    check your Docker installation was working correctly, but I didn't closely examine
    the image or how Docker used it. In this chapter, you'll get a thorough understanding
    of Docker images, learning how they're structured, understanding how Docker uses
    them, and looking at how to package your own applications as Docker images.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](59b504fb-1012-4118-aa49-c5e0efce06d3.xhtml)中，您已经通过运行一些基本容器来检查Docker安装是否正常工作，但我没有仔细检查图像或Docker如何使用它。在本章中，您将彻底了解Docker图像，了解它们的结构，了解Docker如何使用它们，并了解如何将自己的应用程序打包为Docker图像。
- en: The first thing to understand is the difference between an image and a container,
    which you can see very clearly by running different types of container from the
    same image.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要理解的是图像和容器之间的区别，通过从相同的图像运行不同类型的容器，您可以非常清楚地看到这一点。
- en: 'In this chapter, you''ll learn more about the basics of Docker, including:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将更多地了解Docker的基础知识，包括：
- en: Running containers from images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从图像运行容器
- en: Building images from Dockerfiles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Dockerfile构建图像
- en: Packaging your own applications as Docker images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将自己的应用程序打包为Docker图像
- en: Working with data in images and containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像和容器中处理数据
- en: Packaging legacy ASP.NET web apps as Docker images
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将传统的ASP.NET Web应用程序打包为Docker图像
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need Docker running on Windows 10 with update 18.09, or Windows Server
    2019 to follow along with the examples. The code for this chapter is available
    at [https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch02](https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch02).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随示例，您需要在Windows 10上运行Docker，并更新到18.09版，或者在Windows Server 2019上运行。本章的代码可在[https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch02](https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch02)上找到。
- en: Running a container from an image
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从图像运行容器
- en: The `docker container run` command creates a container from an image and starts
    the application inside the container. It's actually equivalent to running two
    separate commands, `docker container create` and `docker container start`, which
    shows that containers can have different states. You can create a container without
    starting it, and you can pause, stop, and restart running containers. Containers
    can be in different states, and you can use them in different ways.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container run`命令从图像创建一个容器，并在容器内启动应用程序。实际上，这相当于运行两个单独的命令，`docker container
    create`和`docker container start`，这表明容器可以具有不同的状态。您可以创建一个容器而不启动它，并且可以暂停、停止和重新启动运行中的容器。容器可以处于不同的状态，并且可以以不同的方式使用它们。'
- en: Doing one thing with a task container
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用任务容器执行一个任务
- en: 'The `dockeronwindows/ch02-powershell-env:2e` image is an example of a packaged
    application which is meant to run in a container and perform a single task. The
    image is based on Microsoft Windows Server Core and is set up to run a simple
    PowerShell script when it starts, printing details about the current environment.
    Let''s see what happens when I run a container directly from the image:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`dockeronwindows/ch02-powershell-env:2e`镜像是一个打包的应用程序的示例，旨在在容器中运行并执行单个任务。该镜像基于Microsoft
    Windows Server Core，并设置为在启动时运行一个简单的PowerShell脚本，打印有关当前环境的详细信息。让我们看看当我直接从镜像运行容器时会发生什么：'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Without any options, the container runs a PowerShell script which is built into
    the image, and the script prints out some basic information about the operating
    system environment. I call this a **task container** because the container performs
    one task and then exits.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何选项，容器将运行内置于镜像中的PowerShell脚本，并且脚本将打印有关操作系统环境的一些基本信息。我将其称为**任务容器**，因为容器执行一个任务然后退出。
- en: 'If you run `docker container ls`, which lists all the active containers, you
    won''t see this container. But if you run `docker container ls --all`, which shows
    containers in all states, you''ll see it in the `Exited` status:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行`docker container ls`，列出所有活动容器，您将看不到此容器。但如果运行`docker container ls --all`，显示所有状态的容器，您将在`Exited`状态中看到它：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Task containers are very useful in automating repetitive tasks, like running
    scripts to set up an environment, backing up data, or collecting log files. Your
    container image packages the script to run, along with the exact version of all
    the requirements that the script needs, so anyone with Docker installed can run
    the script without having to install pre-requisites.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 任务容器在自动化重复任务方面非常有用，比如运行脚本来设置环境、备份数据或收集日志文件。您的容器镜像打包了要运行的脚本，以及脚本所需的所有要求的确切版本，因此安装了Docker的任何人都可以运行脚本，而无需安装先决条件。
- en: This is especially useful for PowerShell, where scripts can be dependent on
    several PowerShell modules. The modules may be publicly available, but your script
    can be dependent on specific versions. Instead of sharing a script that requires
    users to install the correct version of many different modules, you build an image
    that has the modules already installed. Then you only need Docker to run the script
    task.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于PowerShell特别有用，因为脚本可能依赖于几个PowerShell模块。这些模块可能是公开可用的，但您的脚本可能依赖于特定版本。您可以构建一个已安装了模块的镜像，而不是共享一个需要用户安装许多不同模块的正确版本的脚本。然后，您只需要Docker来运行脚本任务。
- en: Images are self-contained units, but you can also use them as a template. An
    image may be configured to do one thing, but you can run containers from an image
    in different ways to do different things.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像是自包含的单位，但您也可以将其用作模板。一个镜像可能配置为执行一项任务，但您可以以不同的方式从镜像运行容器以执行不同的任务。
- en: Connecting to an interactive container
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到交互式容器
- en: 'An **interactive container** is one that has an open connection to the Docker
    command line, so you work with the container as if you were connected to a remote
    machine. You can run an interactive container from the same Windows Server Core
    image by specifying the interactive options and a command to run when the container
    starts:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**交互式容器**是指与Docker命令行保持开放连接的容器，因此您可以像连接到远程机器一样使用容器。您可以通过指定交互式选项和容器启动时要运行的命令来从相同的Windows
    Server Core镜像运行交互式容器：'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `--interactive` option runs an interactive container, and the `--tty` flag
    attaches a terminal connection to the container. The `powershell` statement after
    the name of the container image is the command to run when the container starts.
    By specifying a command you replace the startup command that's been set up in
    the image. In this case, I start a PowerShell session and that runs instead of
    the configured command, so the environment printout script doesn't run.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`--interactive`选项运行交互式容器，`--tty`标志将终端连接附加到容器。在容器映像名称后的`powershell`语句是容器启动时要运行的命令。通过指定命令，您可以替换映像中设置的启动命令。在这种情况下，我启动了一个PowerShell会话，它代替了配置的命令，因此环境打印脚本不会运行。'
- en: An interactive container keeps running as long as the command inside is running.
    While you're connected to PowerShell, running `docker container ls` in another
    window on the host will show that the container is still running. When you type
    `exit` in the container, the PowerShell session ends, so there's no process running
    and the container exits too.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式容器会持续运行，只要其中的命令在运行。当您连接到PowerShell时，在主机的另一个窗口中运行`docker container ls`，会显示容器仍在运行。当您在容器中键入`exit`时，PowerShell会话结束，因此没有进程在运行，容器也会退出。
- en: Interactive containers are useful when you're building your own container images,
    they let you can work through the steps interactively first and verify that everything
    will work as you expect. They're good exploratory tools too. You can pull someone
    else's image from a Docker registry and explore the contents before you run the
    application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式容器在构建自己的容器映像时非常有用，它们可以让您首先以交互方式进行步骤，并验证一切是否按您的预期工作。它们也是很好的探索工具。您可以从Docker注册表中拉取别人的映像，并在运行应用程序之前探索其内容。
- en: You'll see as you read through this book that Docker can host complex distributed
    systems in a virtual network, with each component running in its own container.
    If you want to examine parts of the system, you can run an interactive container
    inside the network and check on individual components, without having to make
    the parts publicly accessible.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本书时，您会发现Docker可以在虚拟网络中托管复杂的分布式系统，每个组件都在自己的容器中运行。如果您想检查系统的某些部分，可以在网络内部运行交互式容器，并检查各个组件，而无需使部分公开可访问。
- en: Keeping a process running in a background container
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在后台容器中保持进程运行
- en: The last type of container is the one that you'll use most in production, the
    background container, which keeps a long-running process running in the background.
    It's a container that behaves like a Windows service. In Docker terminology, it's
    called a **detached container**, and it's the Docker Engine that keeps it running
    in the background. Inside the container, the process runs in the foreground. The
    process might be a web server or a console application polling a message queue
    for work, but as long as the process keeps running, Docker will keep the container
    alive.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种类型的容器是您在生产中最常使用的，即后台容器，它在后台保持长时间运行的进程。它是一个行为类似于Windows服务的容器。在Docker术语中，它被称为**分离容器**，Docker引擎会在后台保持其运行。在容器内部，进程在前台运行。该进程可能是一个Web服务器或一个轮询消息队列以获取工作的控制台应用程序，但只要进程保持运行，Docker就会保持容器保持活动状态。
- en: 'I can run a background container from the same image again, specifying the
    `detach` option and a command that runs for some minutes:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以再次从相同的映像运行后台容器，指定`detach`选项和运行一些分钟的命令：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this case when the container has launched, control returns to the terminal;
    the long random string is the ID of the new container. You can run `docker container
    ls` and see the container running, and the `docker container logs` command shows
    you the console output from the container. For commands operating on specific
    containers, you can reference them by the container name or by part of the container
    ID - IDs are random, in my case this container ID begins `bb3`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当容器启动后，控制返回到终端；长随机字符串是新容器的ID。您可以运行`docker container ls`并查看正在运行的容器，`docker
    container logs`命令会显示容器的控制台输出。对于操作特定容器的命令，您可以通过容器名称或容器ID的一部分来引用它们 - ID是随机的，在我的情况下，这个容器ID以`bb3`开头：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `--detach` flag detaches the container so that it moves into the background,
    and the command in this case just pings `localhost` repeatedly one hundred times.
    After a few minutes, the PowerShell command completes so there's no process running
    and the container exits.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`--detach`标志将容器分离，使其进入后台，而在这种情况下，命令只是重复一百次对`localhost`的ping。几分钟后，PowerShell命令完成，因此没有正在运行的进程，容器退出。'
- en: 'This is a key thing to remember: if you want to keep a container running in
    the background, the process that Docker starts when it runs the container has
    to keep running.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要记住的关键事情：如果您想要在后台保持容器运行，那么Docker在运行容器时启动的进程必须保持运行。
- en: Now you've seen that a container is created from an image, but it can run in
    different ways. So you can use the image exactly as it was prepared, or treat
    the image as a template with a default startup mode built in. Next, I'll show
    you how to build that image.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到容器是从镜像创建的，但它可以以不同的方式运行。因此，您可以完全按照准备好的镜像使用，或者将镜像视为内置默认启动模式的模板。接下来，我将向您展示如何构建该镜像。
- en: Building a Docker image
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Docker镜像
- en: Docker images are layered. The bottom layer is the operating system, which can
    be a full OS like Windows Server Core, or a minimal OS like Microsoft Nano Server.
    On top of this are layers for each change you make to the base OS when you build
    an image, by installing software, copying files, and running commands. Logically,
    Docker treats the image as a single unit, but physically each layer is stored
    as a separate file in Docker's cache, so images with a lot of common features
    can share layers from the cache.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像是分层的。底层是操作系统，可以是完整的操作系统，如Windows Server Core，也可以是微软Nano Server等最小的操作系统。在此之上是每次构建镜像时对基本操作系统所做更改的层，通过安装软件、复制文件和运行命令。从逻辑上讲，Docker将镜像视为单个单位，但从物理上讲，每个层都存储为Docker缓存中的单独文件，因此具有许多共同特征的镜像可以共享缓存中的层。
- en: Images are built using a text file with the Dockerfile language – specifying
    the base OS image to start with and all the steps to add on top. The language
    is very simple, and there are only a few commands you need to master in order
    to build production-grade images. I'll start by looking at the basic PowerShell
    image I've been using so far in this chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像是使用Dockerfile语言的文本文件构建的 - 指定要从哪个基本操作系统镜像开始以及添加的所有步骤。这种语言非常简单，您只需要掌握几个命令就可以构建生产级别的镜像。我将从查看到目前为止在本章中一直在使用的基本PowerShell镜像开始。
- en: Understanding Dockerfiles
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Dockerfile
- en: 'A Dockerfile is just a deployment script which packages software into a Docker
    image. The complete code for the PowerShell image is just three lines:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile只是一个将软件打包到Docker镜像中的部署脚本。PowerShell镜像的完整代码只有三行：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It's pretty easy to guess what's happening even if you've never seen a Dockerfile
    before. By convention the instructions (`FROM`, `COPY`, and `CMD`) are uppercase
    and the arguments are lowercase, but this is not mandatory. Also by convention,
    you save the text in a file called `Dockerfile`, but this is not mandatory either
    (a file with no extension looks odd in Windows, but remember that Docker's heritage
    is in Linux).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你以前从未见过Dockerfile，也很容易猜到发生了什么。按照惯例，指令（`FROM`、`COPY`和`CMD`）是大写的，参数是小写的，但这不是强制的。同样按照惯例，你保存文本在一个名为`Dockerfile`的文件中，但这也不是强制的（在Windows中，没有扩展名的文件看起来很奇怪，但请记住Docker的传统是在Linux中）。
- en: 'Let''s take a look at the instructions in the Dockerfile line by line:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看Dockerfile中的指令：
- en: '`FROM mcr.microsoft.com/windows/servercore:ltsc2019` uses an image called `windows/servercore`
    as the starting point for this image, specifying the `ltsc2019` version of the
    image and the registry where it is hosted.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM mcr.microsoft.com/windows/servercore:ltsc2019`使用名为`windows/servercore`的镜像作为此镜像的起点，指定了镜像的`ltsc2019`版本和其托管的注册表。'
- en: '`COPY scripts/print-env-details.ps1 C:\\print-env.ps1` copies the PowerShell
    script from the local computer to a specific location in the image.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY scripts/print-env-details.ps1 C:\\print-env.ps1`将PowerShell脚本从本地计算机复制到镜像中的特定位置。'
- en: '`CMD ["powershell.exe", "C:\\print-env.ps1"]` specifies the startup command
    when a container runs, which in this case is running the PowerShell script.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD ["powershell.exe", "C:\\print-env.ps1"]`指定了容器运行时的启动命令，在这种情况下是运行PowerShell脚本。'
- en: There are a few obvious questions here. Where does the base image come from?
    Built into Docker is the concept of an image registry, which is a store for container
    images. The default registry is a free public service called **Docker Hub**. Microsoft
    publishes some images on Docker Hub, but Windows base images are hosted on the **Microsoft
    Container Registry** (**MCR**).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些明显的问题。基础镜像是从哪里来的？Docker内置了镜像注册表的概念，这是一个容器镜像的存储库。默认注册表是一个名为**Docker Hub**的免费公共服务。微软在Docker
    Hub上发布了一些镜像，但Windows基础镜像托管在**Microsoft Container Registry**（**MCR**）上。
- en: The 2019 release of the Windows Server Core image is called `windows/servercore:ltsc2019`.
    The first time you use the image, Docker will download it from MCR to your local
    machine and then cache it for further use.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Server Core镜像的2019版本被称为`windows/servercore:ltsc2019`。第一次使用该镜像时，Docker会从MCR下载到本地计算机，然后缓存以供进一步使用。
- en: Docker Hub is where all the Microsoft images are listed for discovery, as MCR
    doesn't have a web UI. Even if images are hosted on MCR, they will be listed on
    Docker Hub, so that's the place to go when you're looking for images.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub是Microsoft所有镜像的发现列表，因为MCR没有Web UI。即使镜像托管在MCR上，它们也会在Docker Hub上列出，所以当你在寻找镜像时，那就是去的地方。
- en: Where does the PowerShell script get copied from? When you build an image, the
    directory containing the Dockerfile is used as the context for the build. When
    you build an image from this Dockerfile, Docker will expect to find a folder called
    `scripts` in the context directory, containing a file called `print-env-details.ps1`.
    If it doesn't find that file, the build will fail.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell脚本是从哪里复制过来的？构建镜像时，包含Dockerfile的目录被用作构建的上下文。从这个Dockerfile构建镜像时，Docker会期望在上下文目录中找到一个名为`scripts`的文件夹，其中包含一个名为`print-env-details.ps1`的文件。如果找不到该文件，构建将失败。
- en: Dockerfiles use the backslash as an escape character in order to continue instructions
    onto a new line. This clashes with Windows file paths, so you have to write `C:\print.ps1`
    as `C:\\print.ps1` or `C:/print.ps1`. There is a nice way to get around this,
    using a processor directive at the start of the Dockerfile, which I'll demonstrate
    later in the chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile使用反斜杠作为转义字符，以便将指令继续到新的一行。这与Windows文件路径冲突，所以你必须将`C:\print.ps1`写成`C:\\print.ps1`或`C:/print.ps1`。有一个很好的方法来解决这个问题，在Dockerfile开头使用处理器指令，我将在本章后面进行演示。
- en: How do you know PowerShell is available for use? It's part of the Windows Server
    Core base image, so you can rely on it being there. You can install any software
    that isn't in the base image with additional Dockerfile instructions. You can
    add Windows features, set registry values, copy or download files into the image,
    extract ZIP files, deploy MSIs and do whatever else you need.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何知道PowerShell可以使用？它是Windows Server Core基础镜像的一部分，所以你可以依赖它。你可以使用额外的Dockerfile指令安装任何不在基础镜像中的软件。你可以添加Windows功能，设置注册表值，将文件复制或下载到镜像中，解压ZIP文件，部署MSI文件，以及其他任何你需要的操作。
- en: This is a very simple Dockerfile, but even so two of the instructions are optional.
    Only the `FROM` instruction is mandatory, so if you want to build an exact clone
    of Microsoft's Windows Server Core image, you can do so with just a `FROM` statement
    in your Dockerfile, and call the cloned image anything you like.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的Dockerfile，但即使如此，其中两条指令是可选的。只有`FROM`指令是必需的，所以如果你想构建一个微软的Windows Server
    Core镜像的精确克隆，你可以在Dockerfile中只使用一个`FROM`语句，并且随意命名克隆的镜像。
- en: Building an image from a Dockerfile
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Dockerfile构建镜像
- en: Now that you have a Dockerfile, you use the `docker` command line to build it
    into an image. Like most Docker commands, the `image build` command is straightforward
    and has very few required options, preferring conventions instead.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个Dockerfile，你可以使用`docker`命令行将其构建成一个镜像。像大多数Docker命令一样，`image build`命令很简单，只有很少的必需选项，更倾向于使用约定而不是命令。
- en: 'To build an image, open a command line and navigate to the directory where
    your Dockerfile is. Then, run `docker image build` and give your image a tag,
    which is the name that will identify the image:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个镜像，打开命令行并导航到Dockerfile所在的目录。然后运行`docker image build`并给你的镜像打上一个标签，这个标签就是将来用来识别镜像的名称。
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Every image needs a tag, specified with the `--tag` option, which is a unique
    identifier for the image in your local image cache and in image registries. The
    tag is how you''ll refer to the image when you run containers. A full tag specifies
    the registry to use: the repository name, which is the identifier for the application,
    and a suffix, which is the identifier for this version of the image.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每个镜像都需要一个标签，使用`--tag`选项指定，这是本地镜像缓存和镜像注册表中镜像的唯一标识符。标签是你在运行容器时将引用镜像的方式。完整的标签指定要使用的注册表：存储库名称，这是应用程序的标识符，以及后缀，这是镜像的版本标识符。
- en: 'When you''re building an image for yourself, you can call it anything, but
    the convention is to name your repository as your username for the registry, followed
    by the application name: `{user}/{app}`. You can also use the tag to identify
    application versions or variations, such as `sixeyed/git` and `sixeyed/git:2.17.1-windowsservercore-ltsc2019`,
    which are two of my images on Docker Hub.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为自己构建一个镜像时，你可以随意命名，但约定是将你的存储库命名为你的注册表用户名，后面跟上应用程序名称：`{user}/{app}`。你还可以使用标签来标识应用程序的版本或变体，比如`sixeyed/git`和`sixeyed/git:2.17.1-windowsservercore-ltsc2019`，这是Docker
    Hub上我的两个镜像。
- en: The period at the end of the `image build` command tells Docker the location
    of the context to use for the image. `.` is the current directory. Docker copies
    the contents of the directory tree into a temporary folder for the build, so the
    context needs to contain any files you reference in the Dockerfile. After copying
    the context, Docker starts executing the instructions in the Dockerfile.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`image build`命令末尾的句点告诉Docker要使用的上下文的位置。`.`是当前目录。Docker将目录树的内容复制到一个临时文件夹进行构建，因此上下文需要包含Dockerfile中引用的任何文件。复制上下文后，Docker开始执行Dockerfile中的指令。'
- en: Examining how Docker builds an image
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查Docker构建镜像的过程
- en: 'Understanding how Docker images are constructed will help you build efficient
    images. The `image build` command produces a lot of output, which tells you exactly
    what Docker does for each step of the build. Each instruction in the Dockerfile
    is executed as a separate step that produces a new image layer, and the final
    image will be a combined stack of all of the layers. The following code snippet
    is the output from building my image:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 理解Docker镜像是如何构建的将有助于您构建高效的镜像。`image build`命令会产生大量输出，告诉您Docker在构建的每个步骤中做了什么。Dockerfile中的每个指令都会作为一个单独的步骤执行，产生一个新的镜像层，最终镜像将是所有层的组合堆栈。以下代码片段是构建我的镜像的输出：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is what happens when Docker builds the image:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Docker构建镜像时发生的事情：
- en: The `FROM` image already exists in my local cache, so Docker doesn't need to
    download it. The output is the ID of Microsoft's Windows Server Core image (starting
    `8b79`).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FROM`镜像已经存在于我的本地缓存中，因此Docker不需要下载它。输出是Microsoft的Windows Server Core镜像的ID（以`8b79`开头）。'
- en: Docker copies the script file from the build context into a new image layer
    (ID `5e9e`).
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker将脚本文件从构建上下文复制到一个新的镜像层（ID `5e9e`）。
- en: Docker configures the command to execute when a container is run from the image.
    It creates a temporary container from the *Step 2* image, configures the startup
    command, saves the container as a new image layer (ID `5f27`), and deletes the
    intermediate container (ID `c14c`).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker配置了当从镜像运行容器时要执行的命令。它从*步骤2*镜像创建一个临时容器，配置启动命令，将容器保存为一个新的镜像层（ID `5f27`），并删除中间容器（ID
    `c14c`）。
- en: The final layer is tagged with the image name, but all the intermediate layers
    are also added to the local cache. This layered approach means Docker can be very
    efficient when it builds images and runs containers. The latest Windows Server
    Core image is over 4 GB uncompressed, but when you run multiple containers based
    on Windows Server Core, they will all use the same base image layers, so you don't
    end up with multiple copies of the 4 GB image.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最终层被标记为镜像名称，但所有中间层也被添加到本地缓存中。这种分层的方法意味着Docker在构建镜像和运行容器时可以非常高效。最新的Windows Server
    Core镜像未经压缩超过4GB，但当您运行基于Windows Server Core的多个容器时，它们将都使用相同的基础镜像层，因此您不会得到多个4GB镜像的副本。
- en: You'll understand more about image layers and storage later in the chapter,
    but first I'll look at some more complex Dockerfiles which package .NET and .NET
    Core applications.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在本章后面更多地了解镜像层和存储，但首先我将看一些更复杂的Dockerfile，其中打包了.NET和.NET Core应用程序。
- en: Packaging your own applications
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包您自己的应用程序
- en: The goal of building an image is to package your application in a portable,
    self-contained unit. The image should be as small as possible, so it's easy to
    move around when you want to run the application, and it should have as few OS
    features as possible, so it has a fast startup time and a small attack vector.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 构建镜像的目标是将您的应用程序打包成一个便携、自包含的单元。镜像应尽可能小，这样在运行应用程序时移动起来更容易，并且应尽可能少地包含操作系统功能，这样启动时间快，攻击面小。
- en: Docker doesn't impose restrictions on the image size. Your long-term goal may
    be to build minimal images that run lightweight .NET Core applications on Linux
    or Nano Server. But you can start by packaging your existing ASP.NET apps in their
    entirety as Docker images to run on Windows Server Core. Docker doesn't impose
    restrictions on how to package your app either, so you can choose from different
    approaches.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Docker不对图像大小施加限制。你的长期目标可能是构建在Linux或Nano Server上运行轻量级.NET Core应用程序的最小图像。但你可以先将现有的ASP.NET应用程序作为Docker图像的全部内容打包，以在Windows
    Server Core上运行。Docker也不对如何打包应用程序施加限制，因此你可以选择不同的方法。
- en: Compiling the application during the build
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在构建过程中编译应用程序
- en: There are two common approaches to packaging your own apps in Docker images.
    The first is to use a base image which contains the application platform and the
    build tools. So in your Dockerfile, you copy the source code into the image and
    compile the app as a step during the image-building process.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker图像中打包自己的应用程序有两种常见的方法。第一种是使用包含应用程序平台和构建工具的基础图像。因此，在你的Dockerfile中，你将源代码复制到图像中，并在图像构建过程中编译应用程序。
- en: This is a popular approach for public images, because it means that anyone can
    build the image without having the application platform installed locally. It
    also means that the tooling for the application is bundled with the image, so
    it can make it possible to debug and troubleshoot the application running in the
    container.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个受欢迎的公共图像的方法，因为这意味着任何人都可以构建图像，而无需在本地安装应用程序平台。这也意味着应用程序的工具与图像捆绑在一起，因此可以使在容器中运行的应用程序的调试和故障排除成为可能。
- en: 'Here''s an example with a simple .NET Core application. This Dockerfile is
    for the `dockeronwindows/ch02-dotnet-helloworld:2e` image:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的.NET Core应用程序的示例。这个Dockerfile是为`dockeronwindows/ch02-dotnet-helloworld:2e`图像而设计的：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The Dockerfile uses Microsoft's .NET Core image from Docker Hub as the base
    image. It's a specific variation of the image, one that is based on Nano Server
    release 1809 and has the .NET Core 2.2 SDK installed. The build copies in the
    application source code from the context, and compiles the application as part
    of the container build process.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile使用了来自Docker Hub的Microsoft的.NET Core图像作为基础图像。这是图像的一个特定变体，它基于Nano Server
    1809版本，并安装了.NET Core 2.2 SDK。构建将应用程序源代码从上下文中复制进来，并在容器构建过程中编译应用程序。
- en: 'There are three new instructions in this Dockerfile that you haven''t seen
    before:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Dockerfile中有三个你以前没有见过的新指令：
- en: '`WORKDIR` specifies the current working directory. Docker creates the directory
    in the intermediate container if it doesn''t already exist, and sets it to be
    the current directory. It remains the working directory for the subsequent instructions
    in the Dockerfile, and for containers when they run from the image.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WORKDIR`指定当前工作目录。如果目录在中间容器中不存在，Docker会创建该目录，并将其设置为当前目录。它将保持为Dockerfile中的后续指令以及从图像运行的容器的工作目录。'
- en: '`USER` changes the current user in the build. Nano Server uses a least-privilege
    user by default. This switches to a built-in account in the container image, which
    has administrative rights.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`USER`更改构建中的当前用户。Nano Server默认使用最低特权用户。这将切换到容器图像中的内置帐户，该帐户具有管理权限。'
- en: '`RUN` executes a command inside an intermediate container and saves the state
    of the container after the command completes, creating a new image layer.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RUN`在中间容器中执行命令，并在命令完成后保存容器的状态，创建一个新的图像层。'
- en: 'When I build this image, you''ll see the `dotnet` command output, which is
    the application being compiled from the `RUN` instruction in the image build:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我构建这个图像时，你会看到`dotnet`命令的输出，这是应用程序从图像构建中的`RUN`指令中编译出来的：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You'll see this approach a lot on Docker Hub for applications built with languages
    like .NET Core, Go, and Node.js, where the tooling is easy to add to a base image.
    It means that you can set up an automated build on Docker Hub so Docker's servers
    build your image from a Dockerfile when you push code changes to GitHub. Servers
    can do this without having .NET Core, Go, or Node.js installed, because all the
    build dependencies are inside the base image.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在Docker Hub上经常看到这种方法，用于使用.NET Core、Go和Node.js等语言构建的应用程序，其中工具很容易添加到基础镜像中。这意味着你可以在Docker
    Hub上设置自动构建，这样当你将代码更改推送到GitHub时，Docker的服务器就会根据Dockerfile构建你的镜像。服务器可以在没有安装.NET Core、Go或Node.js的情况下执行此操作，因为所有构建依赖项都在基础镜像中。
- en: This option means that the final image will be a lot bigger than it needs to
    be for a production application. Language SDKs and tooling will probably use more
    disk space than the app itself, but your end result should be the application;
    all the build tools taking up space in your image will never be used when the
    container runs in production. An alternative is to build the application first,
    and then package the compiled binaries into your container image.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种选项意味着最终镜像将比生产应用程序所需的要大得多。语言SDK和工具可能会占用比应用程序本身更多的磁盘空间，但你的最终结果应该是应用程序；当容器在生产环境运行时，镜像中占用空间的所有构建工具都不会被使用。另一种选择是首先构建应用程序，然后将编译的二进制文件打包到你的容器镜像中。
- en: Compiling the application before the build
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在构建之前编译应用程序
- en: 'Building the application first fits in neatly with existing build pipelines.
    Your build servers need to have all of the application platforms and build tools
    installed to compile the application, but your finished container image only has
    the minimum it needs to run the app. With this approach, the Dockerfile for my
    .NET Core app becomes even simpler:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先构建应用程序与现有的构建流水线完美契合。你的构建服务器需要安装所有的应用程序平台和构建工具来编译应用程序，但你的最终容器镜像只包含运行应用程序所需的最小内容。采用这种方法，我的.NET
    Core应用程序的Dockerfile变得更加简单：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This Dockerfile uses a different `FROM` image, one that contains just the .NET
    Core 2.2 runtime and not the tooling (so it can run a compiled application, but
    it can't compile one from source). You can't build this image without building
    the application first, so you'll need to wrap the `docker image build` command
    in a build script that also runs the `dotnet publish` command to compile the binaries.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Dockerfile使用了一个不同的`FROM`镜像，其中只包含.NET Core 2.2运行时，而不包含工具（因此它可以运行已编译的应用程序，但无法从源代码编译）。你不能在构建应用程序之前构建这个镜像，所以你需要在构建脚本中包装`docker
    image build`命令，该脚本还运行`dotnet publish`命令来编译二进制文件。
- en: 'A simple build script, which compiles the application and builds the Docker
    image, looks like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的构建脚本，用于编译应用程序并构建Docker镜像，看起来像这样：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you put your Dockerfile instructions in a file called something other than
    **Dockerfile**, you need to specify the filename with the `--file` option: `docker
    image build --file Dockerfile.slim`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把Dockerfile指令放在一个名为**Dockerfile**之外的文件中，你需要使用`--file`选项指定文件名：`docker image
    build --file Dockerfile.slim`。
- en: 'I''ve moved the requirements for the platform tooling from the image to the
    build server, and that results in a much smaller final image: 410 MB for this
    version, compared to 1.75 GB for the previous one. You can see the size difference
    by listing images and filtering on the image repository name:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我把平台工具的要求从镜像移到了构建服务器上，这导致最终镜像变得更小：与之前版本相比，这个版本的大小为410 MB，而之前的版本为1.75 GB。你可以通过列出镜像并按照镜像仓库名称进行过滤来看到大小的差异：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This new version is also a more restricted image. The source code and the .NET
    Core SDK aren't packaged in the image, so you can't connect to a running container
    and inspect the application code, or make changes to the code and recompile the
    app.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新版本也是一个更受限制的镜像。源代码和.NET Core SDK没有打包在镜像中，所以你不能连接到正在运行的容器并检查应用程序代码，或者对代码进行更改并重新编译应用程序。
- en: 'For enterprise environments, or for commercial applications, you''re likely
    to already have a well-equipped build server, and packaging the built app can
    be part of a more comprehensive workflow:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于企业环境或商业应用程序，你可能已经有一个设备齐全的构建服务器，并且打包构建的应用程序可以成为更全面工作流的一部分：
- en: '![](Images/d09a1ae3-e97a-4318-8118-f2d2a39c5828.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d09a1ae3-e97a-4318-8118-f2d2a39c5828.png)'
- en: In this pipeline the developer pushes their changes to the central source code
    repository (**1**). The build server compiles the application and runs unit tests;
    if they pass, then the container image is built and deployed in a staging environment
    (2). Integration tests and end-to-end tests are run against the staging environment,
    and if they pass, then your version of the container image is a good release candidate
    for testers to verify (3).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个流水线中，开发人员将他们的更改推送到中央源代码仓库（**1**）。构建服务器编译应用程序并运行单元测试；如果测试通过，那么容器镜像将在暂存环境中构建和部署（2）。集成测试和端到端测试在暂存环境中运行，如果测试通过，那么你的容器镜像版本是一个好的发布候选，供测试人员验证（3）。
- en: You deploy a new release by running a container from the image in production,
    and you know that your whole application stack is the same set of binaries that
    passed all of the tests.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在生产环境中从镜像运行容器来部署新版本，并且你知道你的整个应用程序堆栈是通过了所有测试的相同的一组二进制文件。
- en: The downside to this approach is that you need to have the application SDK installed
    on all of your build agents, and the versions of the SDK and all of its dependencies
    need to match what the developers are using. Often in Windows projects, you find
    CI servers with Visual Studio installed, to ensure the server has the same tools
    as the developer. This makes for very heavy build servers, which take a lot of
    effort to commission and maintain.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是你需要在所有构建代理上安装应用程序SDK，并且SDK及其所有依赖项的版本需要与开发人员使用的相匹配。通常在Windows项目中，你会发现安装了Visual
    Studio的CI服务器，以确保服务器具有与开发人员相同的工具。这使得构建服务器非常庞大，需要大量的努力来委托和维护。
- en: It also means that you can't build this Docker image from the source code for
    this chapter yourself unless you have the .NET Core 2.2 SDK installed on your
    machine.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着，除非你在你的机器上安装了.NET Core 2.2 SDK，否则你无法从本章的源代码构建这个Docker镜像。
- en: You can get the best of both options by using a multi-stage build, where your
    Dockerfile defines one step to compile your application, and another step to package
    it into the final image. Multi-stage Dockerfiles are portable, so anyone can build
    the image with no prerequisites, but the final image only contains the minimum
    needed for the app.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用多阶段构建，你可以兼顾两种选择，其中你的Dockerfile定义了一个步骤来编译你的应用程序，另一个步骤将其打包到最终镜像中。多阶段Dockerfile是可移植的，因此任何人都可以在没有先决条件的情况下构建镜像，但最终镜像只包含了应用程序所需的最小内容。
- en: Compiling with multi-stage builds
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多阶段构建编译
- en: In a multi-stage build you have multiple `FROM` instructions in your Dockerfile,
    where each `FROM` instruction starts a new stage in the build. Docker executes
    all the instructions when you build the image, and later stages can access the
    output from earlier stages, but only the final stage is used for the completed
    image.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在多阶段构建中，你的Dockerfile中有多个`FROM`指令，每个`FROM`指令在构建中启动一个新阶段。Docker在构建镜像时执行所有指令，后续阶段可以访问前期阶段的输出，但只有最终阶段用于完成的镜像。
- en: 'I can write a multi-stage Dockerfile for the .NET Core console app by combining
    the previous two Dockerfiles into one:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以通过将前两个Dockerfile合并成一个，为.NET Core控制台应用程序编写一个多阶段的Dockerfile：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are a couple of things that are new here. The first stage uses a large
    base image, with the .NET Core SDK installed. I've named this stage `builder`,
    using the `AS` option in the `FROM` instruction. The rest of the stage goes on
    to copy in the source code and publish the application. When the builder stage
    completes, the published application will be stored in an intermediate container.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新的东西。第一阶段使用了一个大的基础镜像，安装了.NET Core SDK。我使用`FROM`指令中的`AS`选项将这个阶段命名为`builder`。阶段的其余部分继续复制源代码并发布应用程序。当构建器阶段完成时，发布的应用程序将存储在一个中间容器中。
- en: The second stage uses the runtime .NET Core image, which doesn't have the SDK
    installed. In this stage I copy the published output from the previous stage,
    specifying `--from=builder` in the `COPY` instruction. Anyone can compile this
    application from the source using Docker, without needing .NET Core installed
    on their machine.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段使用了运行时.NET Core镜像，其中没有安装SDK。在这个阶段，我将从上一个阶段复制已发布的输出，在`COPY`指令中指定`--from=builder`。任何人都可以使用Docker从源代码编译这个应用程序，而不需要在他们的机器上安装.NET
    Core。
- en: Multi-stage Dockerfiles for Windows apps are completely portable. To compile
    the app and build the image, the only prerequisite is to have a Windows machine
    with Docker installed, and a copy of the code. The builder stage contains the
    SDK and all the compiler tools, but the final image just has the minimum needed
    to run the application.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 用于Windows应用程序的多阶段Dockerfile是完全可移植的。要编译应用程序并构建镜像，唯一的前提是要有一个安装了Docker的Windows机器和代码的副本。构建器阶段包含了SDK和所有编译器工具，但最终镜像只包含运行应用程序所需的最小内容。
- en: This approach isn't just for .NET Core. You can write a multi-stage Dockerfile
    for a .NET Framework app, where the first stage uses an image with MSBuild installed,
    which you use to compile your application. There are plenty of examples of this
    later in the book.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不仅适用于.NET Core。你可以为.NET Framework应用程序编写一个多阶段的Dockerfile，其中第一阶段使用安装了MSBuild的镜像，用于编译你的应用程序。书中后面有很多这样的例子。
- en: Whichever approach you take, there are just a few more Dockerfile instructions
    that you need to understand in order to build more complex application images,
    for software which integrates with other systems.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你采取哪种方法，都只需要理解几个Dockerfile指令，就可以构建更复杂的应用程序镜像，用于与其他系统集成的软件。
- en: Using the main Dockerfile instructions
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用主要的Dockerfile指令
- en: The Dockerfile syntax is very simple. You've already seen `FROM`, `COPY`, `USER`,
    `RUN`, and `CMD`, which are enough to package up a basic application to run as
    a container. For real-world images you'll need to do more than that, and there
    are three more key instructions to understand.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile语法非常简单。你已经看到了`FROM`、`COPY`、`USER`、`RUN`和`CMD`，这已经足够打包一个基本的应用程序以在容器中运行。对于真实世界的镜像，你需要做更多的工作，还有三个关键指令需要理解。
- en: 'Here''s a Dockerfile for a simple static website; it uses **Internet Information
    Services** (**IIS**) and serves an HTML page on the default website, which shows
    some basic details:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单静态网站的Dockerfile；它使用**Internet Information Services**（**IIS**）并在默认网站上提供一个HTML页面，显示一些基本细节：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This Dockerfile starts differently, with the `escape` directive. This tells
    Docker to use the backtick [PRE15]
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Dockerfile的开始方式不同，使用了`escape`指令。这告诉Docker使用反引号[PRE15]
- en: docker image build --build-arg ENV_NAME=TEST --tag dockeronwindows/ch02-static-website:2e
    .
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: docker image build --build-arg ENV_NAME=TEST --tag dockeronwindows/ch02-static-website:2e
    .
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: docker container run --detach --publish 8081:80 dockeronwindows/ch02-static-website:2e
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: docker container run --detach --publish 8081:80 dockeronwindows/ch02-static-website:2e
- en: 6e3df776cb0c644d0a8965eaef86e377f8ebe036e99961a0621dcb7912d96980
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 6e3df776cb0c644d0a8965eaef86e377f8ebe036e99961a0621dcb7912d96980
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: docker container port 6e
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: docker container port 6e
- en: 80/tcp -> 0.0.0.0:8081
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 80/tcp -> 0.0.0.0:8081
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: escape=` FROM mcr.microsoft.com/windows/nanoserver:1809 RUN md c:\data & `echo
    'from image 1' > c:\data\file1.txt
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: escape=` FROM mcr.microsoft.com/windows/nanoserver:1809 RUN md c:\data & `echo
    'from image 1' > c:\data\file1.txt
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: FROM dockeronwindows/ch02-fs-1:2e RUN echo 'from image 2' > c:\data\file2.txt
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: FROM dockeronwindows/ch02-fs-1:2e RUN echo 'from image 2' > c:\data\file2.txt
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: docker container run -it --name c1 dockeronwindows/ch02-fs-2:2e
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: docker container run -it --name c1 dockeronwindows/ch02-fs-2:2e
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: C:\>dir C:\data
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: C:\>dir C:\data
- en: Volume in drive C has no label.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: C驱动器中的卷没有标签。
- en: Volume Serial Number is BC8F-B36C
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 卷序列号为 BC8F-B36C
- en: Directory of C:\data
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 目录：C:\data
- en: 02/06/2019  11:00 AM    <DIR>          .
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 02/06/2019  11:00 AM    <DIR>          .
- en: 02/06/2019  11:00 AM    <DIR>          ..
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 02/06/2019  11:00 AM    <DIR>          ..
- en: 02/06/2019  11:00 AM                17 file1.txt
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 02/06/2019  11:00 AM                17 file1.txt
- en: 02/06/2019  11:00 AM                17 file2.txt
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 02/06/2019  11:00 AM                17 file2.txt
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: C:\>echo ' * ADDITIONAL * ' >> c:\data\file2.txt
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: C:\>echo ' * ADDITIONAL * ' >> c:\data\file2.txt
- en: C:\>echo 'New!' > c:\data\file3.txt
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: C:\>echo 'New!' > c:\data\file3.txt
- en: C:\>dir C:\data
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: C:\>dir C:\data
- en: Volume in drive C has no label.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: C驱动器中的卷没有标签。
- en: Volume Serial Number is BC8F-B36C
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 卷序列号为 BC8F-B36C
- en: Directory of C:\data
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 目录：C:\data
- en: 02/06/2019  01:10 PM    <DIR>          .
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 02/06/2019  01:10 PM    <DIR>          .
- en: 02/06/2019  01:10 PM    <DIR>          ..
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 02/06/2019  01:10 PM    <DIR>          ..
- en: 02/06/2019  11:00 AM                17 file1.txt
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 02/06/2019  11:00 AM                17 file1.txt
- en: 02/06/2019  01:10 PM                38 file2.txt
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 02/06/2019  01:10 PM                38 file2.txt
- en: 02/06/2019  01:10 PM                 9 file3.txt
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 02/06/2019  01:10 PM                 9 file3.txt
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: C:\> exit
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: C:\> 退出
- en: PS> docker container run -it --name c2 dockeronwindows/ch02-fs-2:2e
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: PS> docker container run -it --name c2 dockeronwindows/ch02-fs-2:2e
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: C:\>dir C:\data
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: C:\>dir C:\data
- en: Volume in drive C has no label.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: C驱动器中的卷没有标签。
- en: Volume Serial Number is BC8F-B36C
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 卷序列号为 BC8F-B36C
- en: Directory of C:\data
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 目录：C:\data
- en: 02/06/2019  11:00 AM    <DIR>          .
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 02/06/2019  11:00 AM    <DIR>          .
- en: 02/06/2019  11:00 AM    <DIR>          ..
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 02/06/2019  11:00 AM    <DIR>          ..
- en: 02/06/2019  11:00 AM                17 file1.txt
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 02/06/2019  11:00 AM                17 file1.txt
- en: 02/06/2019  11:00 AM                17 file2.txt
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 02/06/2019  11:00 AM                17 file2.txt
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: escape=`
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: escape=`
- en: FROM mcr.microsoft.com/windows/nanoserver:1809 VOLUME C:\app\config VOLUME C:\app\logs
    USER ContainerAdministrator ENTRYPOINT cmd /S /C
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: FROM mcr.microsoft.com/windows/nanoserver:1809 VOLUME C:\app\config VOLUME C:\app\logs
    USER ContainerAdministrator ENTRYPOINT cmd /S /C
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: docker container run --name source dockeronwindows/ch02-volumes:2e "echo 'start'
    > c:\app\logs\log-1.txt"
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: docker container run --name source dockeronwindows/ch02-volumes:2e "echo 'start'
    > c:\app\logs\log-1.txt"
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: docker container run -it --volumes-from source dockeronwindows/ch02-volumes:2e
    cmd
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: docker container run -it --volumes-from source dockeronwindows/ch02-volumes:2e
    cmd
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ls C:\app
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ls C:\app
- en: 'Directory: C:\app'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 目录：C:\app
- en: Mode     LastWriteTime      Length  Name
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 模式     最后写入时间      长度  名称
- en: '----     -------------      ------  ----'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '----     -------------      ------  ----'
- en: d----l   6/22/2017 8:11 AM          config
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: d----l   6/22/2017 8:11 AM          config
- en: d----l   6/22/2017 8:11 AM          logs
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: d----l   6/22/2017 8:11 AM          logs
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: C:\>type C:\app\logs\log-1.txt
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: C:\>type C:\app\logs\log-1.txt
- en: '''start'''
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 开始
- en: C:\>echo 'more' >> C:\app\logs\log-1.txt
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: C:\>echo 'more' >> C:\app\logs\log-1.txt
- en: C:\>type C:\app\logs\log-1.txt
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: C:\>type C:\app\logs\log-1.txt
- en: '''start'''
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 开始
- en: '''more'''
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 更多
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: docker container run -it --volumes-from source:ro dockeronwindows/ch02-volumes:2e
    cmd
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: docker container run -it --volumes-from source:ro dockeronwindows/ch02-volumes:2e
    cmd
- en: C:\>type C:\app\logs\log-1.txt
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: C:\>type C:\app\logs\log-1.txt
- en: '''start'''
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 开始
- en: '''more'''
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 更多
- en: C:\>echo 'more' >> C:\app\logs\log-1.txt
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: C:\>echo 'more' >> C:\app\logs\log-1.txt
- en: Access is denied.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 拒绝访问。
- en: C:\>echo 'new' >> C:\app\logs\log-2.txt
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: C:\>echo 'new' >> C:\app\logs\log-2.txt
- en: Access is denied.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 拒绝访问。
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: docker container inspect --format '{{ json .Mounts }}' source | ConvertFrom-Json
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: docker container inspect --format '{{ json .Mounts }}' source | ConvertFrom-Json
- en: 'Type        : volume'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '类型        : 卷'
- en: 'Name        : 65ab1b420a27bfd79d31d0d325622d0868e6b3f353c74ce3133888fafce972d9'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：65ab1b420a27bfd79d31d0d325622d0868e6b3f353c74ce3133888fafce972d9
- en: 'Source      : C:\ProgramData\docker\volumes\65ab1b42...\_data'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：C：\ ProgramData \ docker \ volumes \ 65ab1b42 ... \ _data
- en: 'Destination : c:\app\config'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 目的地：c：\ app \ config
- en: 'Driver      : local'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序：本地
- en: 'RW          : TruePropagation :'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: RW：TruePropagation：
- en: 'Type        : volume'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：卷
- en: 'Name        : b1451fde3e222adbe7f0f058a461459e243ac15af8770a2f7a4aefa7516e0761'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：b1451fde3e222adbe7f0f058a461459e243ac15af8770a2f7a4aefa7516e0761
- en: 'Source      : C:\ProgramData\docker\volumes\b1451fde...\_data'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：C：\ ProgramData \ docker \ volumes \ b1451fde ... \ _data
- en: 'Destination : c:\app\logs'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 目的地：c：\ app \ logs
- en: 'Driver      : local'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序：本地
- en: 'RW          : True'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: RW：True
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ls C:\ProgramData\docker\volumes\b1451fde...\_data
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ls C：\ ProgramData \ docker \ volumes \ b1451fde ... \ _data
- en: 'Directory: C:\ProgramData\docker\volumes\b1451fde3e222adbe7f0f058a461459e243ac15af8770a2f7a4aefa7516e0761\_data'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 目录：C：\ ProgramData \ docker \ volumes \ b1451fde3e222adbe7f0f058a461459e243ac15af8770a2f7a4aefa7516e0761
    \ _data
- en: Mode                LastWriteTime         Length Name
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 模式LastWriteTime长度名称
- en: '----                -------------         ------ ----'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '---- ------------- ------'
- en: -a----       06/02/2019     13:33             19 log-1.txt
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: -a---- 06/02/2019 13:33 19 log-1.txt
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: PS> mkdir C:\app-config | Out-Null
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: PS> mkdir C：\ app-config | Out-Null
- en: PS> echo 'VERSION=18.09' > C:\app-config\version.txt
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: PS> echo 'VERSION = 18.09' > C：\ app-config \ version.txt
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: docker container run `
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: docker容器运行`
- en: --volume C:\app-config:C:\app\config `
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: --volume C：\ app-config：C：\ app \ config `
- en: dockeronwindows/ch02-volumes:2e `
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: dockeronwindows / ch02-volumes：2e `
- en: type C:\app\config\version.txt
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 类型C：\ app \ config \ version.txt
- en: VERSION=18.09
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: VERSION = 18.09
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'escape=` FROM microsoft/dotnet:2.2-sdk-nanoserver-1809 AS builder WORKDIR C:\src
    COPY src . USER ContainerAdministrator RUN dotnet restore && dotnet publish #
    app image FROM microsoft/dotnet:2.2-aspnetcore-runtime-nanoserver-1809'
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'escape = `从microsoft / dotnet：2.2-sdk-nanoserver-1809 AS构建者的工作目录C：\ src复制src。用户ContainerAdministrator运行dotnet
    restore && dotnet publish # app image FROM microsoft / dotnet：2.2-aspnetcore-runtime-nanoserver-1809'
- en: EXPOSE 80 WORKDIR C:\dotnetapp RUN mkdir app-state CMD ["dotnet", "HitCountWebApp.dll"]
    COPY --from=builder C:\src\bin\Debug\netcoreapp2.2\publish .
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: EXPOSE 80 WORKDIR C：\ dotnetapp RUN mkdir app-state CMD ["dotnet", "HitCountWebApp.dll"]
    COPY --from=builder C：\ src \ bin \ Debug \ netcoreapp2.2 \ publish。
- en: '[PRE36]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: docker image build --tag dockeronwindows/ch02-hitcount-website:2e-v1 .
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: docker image build --tag dockeronwindows / ch02-hitcount-website：2e-v1。
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: mkdir C:\app-state
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: mkdir C：\ app-state
- en: docker container run -d --publish-all `
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: docker容器运行-d --publish-all`
- en: -v C:\app-state:C:\dotnetapp\app-state `
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: -v C：\ app-state：C：\ dotnetapp \ app-state `
- en: --name appv1 `
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: --name appv1 `
- en: dockeronwindows/ch02-hitcount-website:2e-v1
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: dockeronwindows / ch02-hitcount-website：2e-v1
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: docker container port appv1
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: docker容器端口appv1
- en: 80/tcp -> 0.0.0.0:51377
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 80 / tcp-> 0.0.0.0：51377
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: PS> docker container stop appv1
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: PS> docker容器停止appv1
- en: appv1
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: appv1
- en: PS> docker container run -d --publish-all `
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: PS> docker容器运行-d --publish-all `
- en: -v C:\app-state:C:\dotnetapp\app-state `
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: -v C：\ app-state：C：\ dotnetapp \ app-state `
- en: --name appv2 `
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: --name appv2 `
- en: dockeronwindows/ch02-hitcount-website:2e-v2
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: dockeronwindows / ch02-hitcount-website：2e-v2
- en: db8a39ba7af43be04b02d4ea5d9e646c87902594c26a62168c9f8bf912188b62
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: db8a39ba7af43be04b02d4ea5d9e646c87902594c26a62168c9f8bf912188b62
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: escape=` FROM microsoft/dotnet-framework:4.7.2-sdk-windowsservercore-ltsc2019
    AS builder WORKDIR C:\src\NerdDinner COPY src\NerdDinner\packages.config . RUN
    nuget restore packages.config -PackagesDirectory ..\packages COPY src C:\src RUN
    msbuild NerdDinner.csproj /p:OutputPath=c:\out /p:Configuration=Release
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: escape = `从microsoft / dotnet-framework：4.7.2-sdk-windowsservercore-ltsc2019
    AS构建者的工作目录C：\ src \ NerdDinner复制src \ NerdDinner \ packages.config。运行nuget restore
    packages.config -PackagesDirectory .. \ packages COPY src C：\ src RUN msbuild
    NerdDinner.csproj / p：OutputPath = c：\ out / p：Configuration = Release
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: FROM mcr.microsoft.com/dotnet/framework/aspnet:4.7.2-windowsservercore-ltsc2019
    SHELL ["powershell", "-Command", "$ErrorActionPreference = 'Stop'] ENV BING_MAPS_KEY
    bing_maps_key WORKDIR C:\nerd-dinner RUN Remove-Website -Name 'Default Web Site';
    `
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: FROM mcr.microsoft.com / dotnet / framework / aspnet：4.7.2-windowsservercore-ltsc2019
    SHELL ["powershell", "-Command", "$ErrorActionPreference = 'Stop'] ENV BING_MAPS_KEY
    bing_maps_key WORKDIR C：\ nerd-dinner RUN Remove-Website -Name 'Default Web Site';
    `
- en: New-Website -Name 'nerd-dinner' ` -Port 80 -PhysicalPath 'c:\nerd-dinner' `-ApplicationPool
    '.NET v4.5' RUN & c:\windows\system32\inetsrv\appcmd.exe ` unlock config /section:system.webServer/handlers
    COPY --from=builder C:\out\_PublishedWebsites\NerdDinner C:\nerd-dinner
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: New-Website -Name 'nerd-dinner' ` -Port 80 -PhysicalPath 'c:\nerd-dinner' `-ApplicationPool
    '.NET v4.5' RUN & c:\windows\system32\inetsrv\appcmd.exe ` unlock config /section:system.webServer/handlers
    COPY --from=builder C:\out\_PublishedWebsites\NerdDinner C:\nerd-dinner
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: docker container run -d -P dockeronwindows/ch02-nerd-dinner:2e
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: docker container run -d -P dockeronwindows/ch02-nerd-dinner:2e
- en: '```'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'I can get the container''s published port with `docker container port`, and
    browse to the NerdDinner home page:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用`docker container port`来获取容器的发布端口，并浏览到NerdDinner的主页：
- en: '![](Images/2e704bc2-8b9b-4e32-a63d-4207c87a2d38.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2e704bc2-8b9b-4e32-a63d-4207c87a2d38.png)'
- en: That's a six-year old application running in a Docker container with no code
    changes. Docker is a great platform for building new apps and modernizing old
    apps, but it's also a great way to get your existing applications out of the data
    center and into the cloud, or to move them from old versions of Windows which
    no longer have support, like Windows Server 2003 and (soon) Windows Server 2008.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个六年前的应用程序，在Docker容器中运行，没有代码更改。Docker是一个很好的平台，可以用来构建新的应用程序和现代化旧的应用程序，但它也是一个很好的方式，可以将现有的应用程序从数据中心移到云端，或者将它们从不再支持的旧版本的Windows中移出，比如Windows
    Server 2003和（很快）Windows Server 2008。
- en: At this point the app isn't fully functional, I just have a basic version running.
    The Bing Maps object doesn't show a real map because I haven't provided an API
    key. The API key is something that will change for every environment (each developer,
    the test environments, and production will have different keys).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，这个应用程序还没有完全功能，我只是运行了一个基本版本。Bing Maps对象没有显示真实的地图，因为我还没有提供API密钥。API密钥是每个环境（每个开发人员、测试环境和生产环境）都会改变的东西。
- en: In Docker, you manage environment configuration with environment variables and
    config objects, which I will use for the next iteration of the Dockerfile in [Chapter
    3](ee527f27-ee07-40e1-a39d-86aa2d11da72.xhtml), *Developing Dockerized .NET Framework
    and .NET Core Applications*.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker中，你可以使用环境变量和配置对象来管理环境配置，我将在[第3章](ee527f27-ee07-40e1-a39d-86aa2d11da72.xhtml)中使用这些内容来进行Dockerfile的下一个迭代，*开发Docker化的.NET
    Framework和.NET Core应用程序*。
- en: If you navigate around this version of NerdDinner and try to register a new
    user or search for a dinner, you'll see a yellow crash page telling you the database
    isn't available. In its original form NerdDinner uses SQL Server LocalDB as a
    lightweight database and stores the database file in the app directory. I could
    install the LocalDB runtime into the container image, but that doesn't fit with
    the Docker philosophy of having one application per container. Instead, I'll build
    a separate image for the database so I can run it in its own container.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个版本的NerdDinner中浏览并尝试注册一个新用户或搜索一个晚餐，你会看到一个黄色的崩溃页面告诉你数据库不可用。在其原始形式中，NerdDinner使用SQL
    Server LocalDB作为轻量级数据库，并将数据库文件存储在应用程序目录中。我可以将LocalDB运行时安装到容器映像中，但这与Docker的哲学不符，即一个容器只运行一个应用程序。相反，我将为数据库构建一个单独的映像，这样我就可以在它自己的容器中运行它。
- en: I'll be iterating on the NerdDinner example in the next chapter, adding configuration
    management, running SQL Server as a separate component in its own container, and
    demonstrating how you can start modernizing traditional ASP.NET apps by making
    use of the Docker platform.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将对NerdDinner示例进行迭代，添加配置管理，将SQL Server作为一个独立组件在自己的容器中运行，并演示如何通过使用Docker平台来开始现代化传统的ASP.NET应用程序。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter I took a closer look at Docker images and containers. Images
    are packaged versions of applications, and containers are instances of an application,
    run from an image. You can use containers to do simple fire-and-forget tasks,
    work with them interactively, or have them running in the background. As you start
    to use Docker more, you'll find yourself doing all three.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我更仔细地看了Docker镜像和容器。镜像是应用程序的打包版本，容器是从镜像运行的应用程序的实例。您可以使用容器来执行简单的一次性任务，与它们进行交互，或者让它们在后台运行。随着您对Docker的使用越来越多，您会发现自己会做这三种事情。
- en: The Dockerfile is the source script for building an image. It's a simple text
    file with a small number of instructions to specify a base image, copy files,
    and run commands. You use the Docker command-line to build the image, which is
    very easy to add as a step to your CI build. When a developer pushes code that
    passes all the tests, the output of the build will be a versioned Docker image,
    which you can deploy to any host knowing that it will always run in the same way.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile是构建镜像的源脚本。它是一个简单的文本文件，包含少量指令来指定基础镜像，复制文件和运行命令。您可以使用Docker命令行来构建镜像，这非常容易添加到您的CI构建步骤中。当开发人员推送通过所有测试的代码时，构建的输出将是一个有版本的Docker镜像，您可以将其部署到任何主机，知道它将始终以相同的方式运行。
- en: I looked at a few simple Dockerfiles in this chapter, and finished with a real-world
    application. NerdDinner is a legacy ASP.NET MVC app that was built to run on Windows
    Server and IIS. Using multi-stage builds, I packaged that legacy app into a Docker
    image and ran it in a container. This shows that the new model of compute which
    Docker offers isn't just for greenfield projects using .NET Core and Nano Server
    - you can migrate existing apps to Docker and put yourself in a good position
    to start modernizing them.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我看了一些简单的Dockerfile，并以一个真实的应用程序结束了。NerdDinner是一个传统的ASP.NET MVC应用程序，它是为在Windows
    Server和IIS上运行而构建的。使用多阶段构建，我将这个传统的应用程序打包成一个Docker镜像，并在容器中运行它。这表明Docker提供的新的计算模型不仅适用于使用.NET
    Core和Nano Server的新项目，您还可以将现有的应用程序迁移到Docker，并使自己处于一个良好的现代化起步位置。
- en: In the next chapter I'll use Docker to modernize the architecture of NerdDinner,
    breaking features out into separate components, and using Docker to plug them
    all together.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将使用Docker来现代化NerdDinner的架构，将功能分解为单独的组件，并使用Docker将它们全部连接在一起。
