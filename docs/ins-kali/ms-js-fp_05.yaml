- en: Programming Declaratively - A Better Style
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式编程 - 更好的风格
- en: 'Up to now, we haven''t really been able to appreciate the possibilities of
    FP, as pertains to working at a higher level, declarative fashion. In this chapter,
    we will correct that, and start getting shorter, more concise, and easier to understand
    code, by using some higher-order functions (HOF: functions that take functions
    as parameters) such as:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有真正能够欣赏到FP的可能性，因为它涉及以更高级别、声明性的方式工作。在本章中，我们将纠正这一点，并通过使用一些高阶函数（HOF：接受函数作为参数的函数）来编写更短、更简洁、更易于理解的代码。
- en: '`.reduce()` and `.reduceRight()` to apply an operation to a whole array reducing
    it to a single result'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.reduce()`和`.reduceRight()`来对整个数组应用操作，将其减少为单个结果'
- en: '`.map()`, to transform an array into another, by applying a function to each
    of its elements'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.map()`，通过对其每个元素应用函数来将数组转换为另一个数组'
- en: '`.forEach()`, to simplify writing loops, by abstracting the necessary looping
    code'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.forEach()`，通过抽象必要的循环代码来简化编写循环'
- en: 'We''ll also be able to do searches and selections with:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下功能进行搜索和选择：
- en: '`.filter()`, to pick some elements from an array'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.filter()`，从数组中选择一些元素'
- en: '`.find()` and `.findIndex()`, to search for elements satisfying a condition'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.find()`和`.findIndex()`，用于搜索满足条件的元素'
- en: And a pair of predicates, `.every()` and `.some()`, to check an array for some
    Boolean test
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一对谓词`.every()`和`.some()`，用于检查数组是否通过了某些布尔测试
- en: Using these functions lets you work more declaratively, and you'll see that
    your focus tends to go to what is needed to do, and not so much on how it's going
    to be done; the dirty details are hidden inside our functions. Instead of writing
    a series of possibly nested `for` loops, we'll rather focus on using functions
    as building blocks to specify our desired result.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些函数可以让您更加声明式地工作，您会发现您的注意力往往会转向需要做什么，而不是如何做；肮脏的细节隐藏在我们的函数内部。我们将不再编写一系列可能嵌套的`for`循环，而是更专注于使用函数作为构建块来指定我们想要的结果。
- en: 'We will also be able to work in a *fluent* fashion, in which the output of
    a function becomes the input of a next one: a style we will later touch on.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以以*流畅*的方式工作，其中函数的输出成为下一个函数的输入：这是我们稍后将涉及的一种风格。
- en: Transformations
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换
- en: 'The first set of operations we are going to consider, work on an array, and
    process it in the base of a function to produce some results. There are several
    possible results: a single value, with the `.reduce()` operations; a new array,
    with `.map()`; or just about any kind of result, with `.forEach()`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要考虑的第一组操作是在数组上进行操作，并在函数的基础上处理它以产生一些结果。有几种可能的结果：使用`.reduce()`操作得到单个值；使用`.map()`得到一个新数组；或者使用`.forEach()`得到几乎任何类型的结果。
- en: If you Google around, you will find some articles that declare that these functions
    are not efficient, because a loop done by hand can be faster. This, while possibly
    true, is practically irrelevant. Unless your code really suffers from speed problems,
    and you are able to measure that the slowness derives from the usage of these
    higher-order functions, trying to avoid them, with longer code, and more probability
    of bugs simply doesn't make much sense.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在网上搜索，您会发现一些声明这些函数不高效的文章，因为手动完成的循环可能更快。尽管这可能是真的，但实际上并不重要。除非您的代码真的受到速度问题的困扰，并且能够测量出慢速是由于使用这些高阶函数导致的，否则试图避免它们，使用更长的代码和更多的错误可能性根本就没有多大意义。
- en: Let's start by considering the preceding list of functions in order, starting
    by the most general of all--which, as we'll see, can even be used to emulate the
    rest of the transformations in this chapter!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从考虑函数列表开始，按顺序开始，从最一般的函数开始，正如我们将看到的那样，甚至可以用来模拟本章中其余的转换！
- en: Reducing an array to a value
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数组减少为一个值
- en: 'Answer this question: how many times have you had to loop through an array,
    doing some operation (say, summing elements) to produce a single value (maybe
    the sum of all the array values) as a result? Probably many, many times. This
    kind of operation can be usually implemented functionally, by applying `.reduce()`
    and `.reduceRight()`. Let''s start with the former!'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 回答这个问题：你有多少次不得不循环遍历数组，执行一些操作（比如，求和元素）以产生单个值（也许是所有数组值的总和）作为结果？可能很多次。这种操作通常可以通过应用`.reduce()`和`.reduceRight()`来实现函数化。让我们从前者开始！
- en: 'Time for some terminology! In usual FP parlance, we speak of *folding* operations:
    `.reduce()` is *foldl* (for *fold left*) or just plain *fold*, and `.reduceRight()`
    is correspondingly known as *foldr*. In Category Theory terms, both operations
    are *catamorphisms* : the reduction of all the values in a *container* down to
    a single result.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候学一些术语了！在通常的FP术语中，我们谈论*折叠*操作：`.reduce()`是*foldl*（*fold left*）或简单的*fold*，而`.reduceRight()`相应地被称为*foldr*。在范畴论术语中，这两个操作都是*catamorphisms*：将*容器*中所有值减少到单个结果。
- en: 'The inner working of the `reduce()` function can be illustrated as in Figure
    5.1:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()`函数的内部工作如图5.1所示：'
- en: '![](assets/619697be-da71-4712-b0c6-d85194919859.png)Figure 5.1: The reduce
    operation traverses the array, applying a function to each element and to the
    accumulated valueWhy should you try to always use `.reduce()` or `.reduceRight(`)
    instead of hand-coded loops?'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/619697be-da71-4712-b0c6-d85194919859.png)图5.1：reduce操作遍历数组，对每个元素和累积值应用函数为什么应该尽量使用`.reduce()`或`.reduceRight()`而不是手动编写循环？'
- en: All the aspects of loop control are automatically taken care of, so you don't
    even have the possibility of a, say, *off by one* mistake
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有循环控制方面都会自动处理，因此您甚至没有可能出现例如*偏移一个*的错误
- en: The initialization and handling of the result values are also done implicitly
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果值的初始化和处理也是隐式完成的
- en: And, unless you work really hard at being impure and modifying the original
    array, your code will be side-effects free
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而且，除非你非常努力地进行不纯和修改原始数组，否则你的代码将是无副作用的
- en: Summing an array
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对数组求和
- en: The most common example of application of `.reduce()`, usually seen in all textbooks
    and web pages, is summing all the elements of an array. So, in order to keep with
    tradition, let's start with precisely that example!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`.reduce()`的最常见应用示例通常在所有教科书和网页中都能看到，就是对数组中所有元素求和。因此，为了保持传统，让我们从这个例子开始！'
- en: 'Basically, to reduce an array you must provide a dyadic function (that is,
    a function with two parameters; *binary* would be an another name for that) and
    an initial value. In our case, the function will sum its two arguments. Initially,
    the function will be applied to the provided initial value and the first element
    of the array, so for us the first result we have to provide is a zero, and the
    first result will be the first element itself. Then, the function will be applied
    again, this time to the result of the previous operation, and the second element
    of the array -- and so the second result will be the sum of the first two elements
    of the array. Progressing in this fashion along the whole array, the final result
    will be the sum of all its elements:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，要减少一个数组，你必须提供一个二元函数（也就是说，一个带有两个参数的函数；*二进制*可能是另一个名称）和一个初始值。在我们的情况下，函数将对它的两个参数求和。最初，函数将被应用于提供的初始值和数组的第一个元素，所以对我们来说，我们必须提供的第一个结果是零，第一个结果将是第一个元素本身。然后，函数将再次被应用，这次是对上一次操作的结果和数组的第二个元素--因此第二个结果将是数组的前两个元素的和。以这种方式沿着整个数组进行下去，最终的结果将是所有元素的和：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You don''t actually need the `sum` definition; you might have just written
    `myArray.reduce((x,y) => x+y, 0)`. However, in this fashion the meaning of the
    code is clearer: you want to reduce the array to a single value by `sum`-ming
    all its elements. Instead of having to write out the loop, initializing a variable
    to hold the result of the calculations, and going through the array doing the
    sums, you just declare what operation should be performed. This is what I meant
    by saying that programming with functions such as those that we''ll see in this
    chapter, allows you to work more declaratively, focusing on *what* rather than
    *how*.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上不需要`sum`的定义；你可以直接写`myArray.reduce((x,y) => x+y, 0)`。然而，用这种方式代码的含义更清晰：你想通过对所有元素进行求和来将数组减少为一个单一的值。而不是必须编写循环，初始化一个变量来保存计算结果，然后遍历数组进行求和，你只需声明应该执行的操作。这就是我所说的，使用本章中将要看到的这些函数进行编程，可以让你更多地以声明性的方式工作，关注*做什么*而不是*如何做*。
- en: 'You can also even do without providing the initial value: if you skip it, the
    first value of the array will be used, and the internal loop will start with the
    second element of the array. See [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)
    for more. However, be careful if the array is empty, and if you skipped providing
    an initial value, you''ll get a runtime error!'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以不提供初始值：如果你跳过它，数组的第一个值将被使用，并且内部循环将从数组的第二个元素开始。更多信息请参见[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)。然而，如果数组为空，并且你跳过提供初始值，你将得到一个运行时错误！
- en: We can change the reducing function to see how it progresses through its calculations,
    by just including a little bit of impurity!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以改变减少函数来看它是如何通过包含一点不纯度而进行计算的！
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output would be:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can see how the first sum was done by adding the initial value (zero) and
    the first element of the array, and how that result was used in the second addition,
    and so on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到第一个求和是通过将初始值（零）和数组的第一个元素相加来完成的，然后将该结果用于第二次相加，依此类推。
- en: 'Part of the reason for the *foldl* name seen previously (at least, its `l`
    part) should now be clear: the reducing operation proceeds from left to right,
    from the first element up to the last. You may wonder, however, how it would have
    been named if it had been defined by a right-to-left language (such as Arabic,
    Hebrew, Farsi, or Urdu) speaker!'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 之前看到的*foldl*名称的一部分（至少是`l`部分）现在应该是清楚的：减少操作从左到右进行，从第一个元素到最后一个元素。然而，你可能会想知道，如果它是由一个从右到左的语言（比如阿拉伯语、希伯来语、波斯语或乌尔都语）的说话者定义的，它会被命名为什么！
- en: Calculating an average
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算平均值
- en: Let's work a bit more; how do you calculate the average of a list of numbers?
    If you were explaining this to someone, your answer would surely somewhat be like
    *sum all the elements in the list, and divide that by the number of elements*.
    This, in programming terms, is not a *procedural* description (you don't explain
    how to sum elements, or how to traverse the array), but rather a *declarative*
    one, since you say what to do, not how to do it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再多做一点工作；如何计算一组数字的平均值？如果你要向某人解释这个问题，你的答案肯定会有点像“对列表中的所有元素求和，然后除以元素的数量”。从编程的角度来看，这不是一个*过程性*的描述（你不解释如何对元素求和，或者如何遍历数组），而是一个*声明性*的描述，因为你说了要做什么，而不是如何做。
- en: 'We can transform that description of the calculation into an almost self-explanatory
    function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个计算的描述转化为一个几乎是自解释的函数：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The definition of `average()` follows what would be a verbal explanation: sum
    the elements of the array, starting from zero, and divide by the array''s length
    -- simpler, impossible!'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`average()`的定义遵循了一个口头解释：对数组中的元素求和，从零开始，然后除以数组的长度--简单，不可能出错！'
- en: As we mentioned in the previous section, you could have also written `arr.reduce(sum)`
    without specifying the initial value (zero) for the reduction; it's even shorter
    and closer to the verbal description of the needed calculation. This, however,
    is less safe, because it would fail (producing a runtime error) should the array
    be empty. So, it's better to always provide the starting value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中提到的，你也可以写成`arr.reduce(sum)`，而不指定减少的初始值（零）；这样更简洁，更接近所需计算的口头描述。然而，这样做不太安全，因为如果数组为空，它会失败（产生运行时错误）。因此，最好总是提供起始值。
- en: 'This isn''t, however, the only way of calculating the average. The reducing
    function also gets passed the index of the current position of the array and the
    array as well, so you could do something different the last time:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是计算平均值的唯一方法。减少函数还会传递数组的当前位置的索引和数组本身，因此您可以在最后一次做一些不同的事情：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Getting the array and the index means you could also turn the function into
    an impure one; avoid this! Everybody who sees a `.reduce()` call, will automatically
    assume it's a pure function, and will surely introduce bugs when using it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 获取数组和索引意味着您也可以将函数转换为不纯的函数；避免这样做！每个看到`.reduce()`调用的人都会自动假设它是一个纯函数，并且在使用它时肯定会引入错误。
- en: However, from the point of view of legibility, I'm certain we agree that the
    first version we saw, was more declarative and closer to the mathematical definition,
    than this second version.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从可读性的角度来看，我相信我们会同意，我们看到的第一个版本比这个第二个版本更具声明性，更接近数学定义。
- en: 'It would also be possible to modify `Array.prototype` to add the new function.
    Modifying prototypes is usually frowned upon, because, at the very least, of the
    possibility of clashes with different libraries. However, if you accept that idea,
    you could then write the following code. Do take note of the need for the outer
    `function()` (instead of an arrow function) because of the implicit handling of
    `this`, which wouldn''t be bound otherwise:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以修改`Array.prototype`以添加新函数。通常修改原型是不受欢迎的，因为至少可能会与不同的库发生冲突。但是，如果您接受这个想法，那么您可以编写以下代码。请注意需要外部`function()`（而不是箭头函数）的需要，因为它隐式处理`this`，否则将无法绑定：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Calculating several values at once
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同时计算多个值
- en: 'What would you do if, instead of a single value, you needed to calculate two
    or more results? This would seem a case providing a clear advantage for common
    loops, but there''s a trick you may use. Let''s revisit yet once more the average
    calculation. We might want to do it *the old-fashioned way*, by looping, and at
    the same time summing and counting all numbers. Well, `.reduce()` only lets you
    produce a single result, but there''s no objection to returning an object, with
    as many fields as desired:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要计算两个或更多结果，您会怎么做？这似乎是一个适合使用普通循环的情况，但是您可以使用一个技巧。让我们再次回顾一下平均值的计算。我们可能想要以*老式的方式*循环，同时对所有数字进行求和和计数。嗯，`.reduce()`只允许您生成一个单一的结果，但是没有反对返回一个对象，其中包含尽可能多的字段：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Examine the code carefully. We need two variables, for the sum and the count
    of all numbers. We provide an object as the initial value for the accumulator,
    with two properties set to zero, and our reducing function updates those two properties.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查代码。我们需要两个变量，用于所有数字的总和和计数。我们提供一个对象作为累加器的初始值，其中两个属性设置为零，我们的减少函数更新这两个属性。
- en: 'By the way, using an object isn''t the only option. You could also produce
    any other data structure; let''s just see an example with an array:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，使用对象并不是唯一的选择。您还可以生成任何其他数据结构；让我们看一个数组的例子：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To be frank, I think it's way more obscure than the solution with the object.
    Just consider this as a (not very recommendable) alternative way of calculating
    many values at once!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 坦率地说，我认为这比使用对象的解决方案更加晦涩。只需将其视为一种（不太可取的）同时计算多个值的替代方法！
- en: Folding left and right
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 左右折叠
- en: The complementary `.reduceRight()` method works just as reduce, only starting
    at the end and looping until the beginning of the array. For many operations (such
    as the calculation of averages that we saw previously) this makes no difference,
    but there are some cases in which it will.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 补充的`.reduceRight()`方法与reduce方法一样，只是从末尾开始循环，直到数组的开头。对于许多操作（例如我们之前看到的平均值的计算），这没有区别，但也有一些情况会有区别。
- en: 'We shall be seeing a clear case of this in [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml),
    *Connecting Functions - Pipelining and Composition*, when we compare pipelining
    and composition: let''s go with a simpler example here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第8章](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml)中看到一个明显的例子，*连接函数 - 管道和组合*，当我们比较管道和组合时：让我们在这里使用一个更简单的例子：
- en: '![](assets/224b131b-0306-4be3-a482-ec57be888b0e.png)Figure 5.2: The .reduceRight()
    operation works the same way as .reduce(), but in reverse orderRead more on `.reduceRight()`
    at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/224b131b-0306-4be3-a482-ec57be888b0e.png)图5.2：`.reduceRight()`操作与`.reduce()`相同，只是顺序相反。在[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight)上阅读更多关于`.reduceRight()`的信息。'
- en: 'Suppose we want to implement a function to reverse a string. A solution could
    be transforming the string into an array by using `.split()`, then reversing that
    array, and finally using `.join()` to make it whole again:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要实现一个反转字符串的函数。一种解决方案是使用`.split()`将字符串转换为数组，然后反转该数组，最后使用`.join()`将其重新组合：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This solution (and yes, it can be shortened, but that''s not the point here)
    works, but let''s do it in another way, just to experiment with `.reduceRight()`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案（是的，它可以被简化，但这不是重点）有效，但让我们以另一种方式来做，只是为了尝试`.reduceRight()`：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Given that the addition operator also works with strings, we could have also
    written `reduceRight(sum,"")`. And, if instead of the function we used, we had
    written `(x,y) => y+x`, the result would have been our original string; can you
    see why?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于加法运算符也适用于字符串，我们也可以编写`reduceRight(sum,"")`。如果我们使用的不是函数，而是`(x,y) => y+x`，结果将是我们的原始字符串；您能看出为什么吗？
- en: 'From the previous examples, you can also get an idea: if you first apply `reverse()`
    to an array, and then use `reduce()`, the effect will be the same as if you had
    just applied `.reduceRight()` to the original array. Only one point to take into
    account: `reverse()` alters the given array, so you would be causing an unintended
    side effect, by reversing the original array! The only way out would be first
    generating a copy of the array, and only then doing the rest... Too much work;
    rather keep using `.reduceRight()`!'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，你也可以得到一个想法：如果你首先对一个数组应用`reverse()`，然后使用`reduce()`，效果将与你只是对原始数组应用`.reduceRight()`相同。只需要考虑一点：`reverse()`改变了给定的数组，所以你会导致一个意外的副作用，即颠倒了原始数组！唯一的出路是首先生成数组的副本，然后再做其他操作...
    太麻烦了；还是继续使用`.reduceRight()`吧！
- en: 'However, we can draw another conclusion, showing a result we had foretold:
    it is possible, even if more cumbersome, to use `.reduce()` to simulate the same
    result as `.reduceRight()` -- and in later sections we''ll also use it to emulate
    the other functions in the chapter.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以得出另一个结论，展示了我们之前预言的结果：即使更加繁琐，也可以使用`.reduce()`来模拟与`.reduceRight()`相同的结果--在后面的章节中，我们还将使用它来模拟本章中的其他函数。
- en: Applying an operation - map
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用操作 - map
- en: Processing lists of elements, and applying some kind of operation to each of
    them, is a quite common pattern in computer programming. Writing loops that systematically
    go through all the elements of an array or collection, starting at the first and
    looping until finishing with the last, and doing some kind of process to each
    of them, is a basic coding exercise, usually learned in the first days of all
    programming courses. We already saw one such kind of operation in the previous
    section, with `.reduce()` and `.reduceRight()`; let's now turn a new one, called
    `.map()`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 处理元素列表，并对每个元素应用某种操作，在计算机编程中是一个非常常见的模式。编写循环，系统地遍历数组或集合的所有元素，从第一个开始循环，直到最后一个结束，并对每个元素进行某种处理，是一个基本的编码练习，通常在所有编程课程的第一天就学到。我们已经在上一节中看到了这样一种操作，使用了`.reduce()`和`.reduceRight()`；现在让我们转向一个新的操作，叫做`.map()`。
- en: 'In mathematics, a *map* is a transformation of elements from a *domain* into
    elements of a *codomain*. For example, you might transform numbers into strings,
    or strings into numbers, but also numbers to numbers, or strings to strings: the
    important point is that you have a way to transform an element of the first *kind*
    or *domain* (think *type* if it helps) into an element of the second kind, or
    *codomain*. In our case, it will mean taking the elements of an array and applying
    a function to each of them to produce a new array. In more computer-like terms,
    the map function transforms an array of inputs into an array of outputs.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，*map*是将元素从*域*转换为*余域*的变换。例如，你可以将数字转换为字符串，或者字符串转换为数字，但也可以将数字转换为数字，或者字符串转换为字符串：重要的是你有一种方法将第一种*类型*或*域*的元素（如果有帮助的话，可以考虑*类型*）转换为第二种*类型*或*余域*的元素。在我们的情况下，这意味着取出数组的元素，并对每个元素应用一个函数，以产生一个新的数组。更像计算机的术语，map函数将输入数组转换为输出数组。
- en: Some more terminology. We would say that an array is a functor because it provides
    a mapping operation with some pre-specified properties, that we shall see later.
    And, in Category Theory of which we'll talk a little in [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml),
    *Building Better Containers - Functional Data Types*, the mapping operation itself
    would be called a morphism.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些术语。我们会说一个数组是一个函子，因为它提供了一个具有一些预先指定属性的映射操作，我们稍后会看到。在范畴论中，我们将在[第12章](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml)中稍微谈一下，*构建更好的容器-函数数据类型*，映射操作本身将被称为态射。
- en: 'The inner working of the `.map()` operation can be seen in Figure 5.3:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`.map()`操作的内部工作可以在图5.3中看到：'
- en: '![](assets/0fafb8ed-5d29-4410-b453-f30e702db535.png)Figure 5.3: The map() operation
    transforms each element of the input array, by applying a mapping functionThe
    jQuery library provides a function, `$.map(array, callback)` that is similar to
    the `.map()` method. Be careful, though, for there are important differences.
    The jQuery function processes the undefined values of the array, while `.map()`
    skips them. Also, if the applied function produces an array as its result, jQuery
    *flattens* it, and adds each of its individual elements separately, while `.map()`
    just includes those arrays in the result.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/0fafb8ed-5d29-4410-b453-f30e702db535.png)图5.3：map()操作通过应用映射函数转换输入数组的每个元素jQuery库提供了一个函数`$.map(array,
    callback)`，它类似于`.map()`方法。不过要小心，因为有重要的区别。jQuery函数处理数组的未定义值，而`.map()`跳过它们。此外，如果应用的函数产生一个数组作为其结果，jQuery会*展平*它，并单独添加其每个个体元素，而`.map()`只是将这些数组包含在结果中。'
- en: What are the advantages of using `.map()`, over using a straightforward loop?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.map()`的优势，而不是使用直接的循环是什么？
- en: First, you don't have to write any loops, so that's one fewer possible source
    of bugs
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，你不必编写任何循环，这样就少了一个可能的错误来源。
- en: Second, you don't even have to access the original array or the index position,
    even though they are there for you to use if you really need them
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，你甚至不需要访问原始数组或索引位置，尽管它们可以供你使用，如果你真的需要的话
- en: And lastly, a new array is produced, so your code is pure (though, of course,
    if you really want to produce side-effects, of course, you can!)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，产生了一个新的数组，所以你的代码是纯的（当然，如果你真的想产生副作用，当然可以！）
- en: In JS, `.map()` is basically available only for arrays. (Read more at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).)
    However, in section *Extending current data types* of [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml),
    *Building Better Containers - Functional Data Types*, we will consider how to
    make it available for other basic types, such as numbers, booleans, strings, and
    even functions. Also, libraries such as LoDash or Underscore or Ramda, provide
    similar functionalities.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在JS中，`.map()`基本上只适用于数组。（在[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)上阅读更多。）然而，在[第12章](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml)的*扩展当前数据类型*中，*构建更好的容器-功能数据类型*，我们将考虑如何使它适用于其他基本类型，如数字、布尔值、字符串，甚至函数。此外，诸如LoDash或Underscore或Ramda之类的库提供类似的功能。
- en: 'There are only two caveats when using this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此功能时只有两个注意事项：
- en: Always return something from your mapping function. If you forget this, since
    JS always provides a default `return undefined` for all functions, you'll just
    produce an `undefined`-filled array.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是从您的映射函数返回一些东西。如果您忘记了这一点，因为JS总是为所有函数提供默认的`return undefined`，那么您将只会生成一个填满`undefined`的数组。
- en: If the input array elements are objects or arrays, and you include them in the
    output array, then JS will still allow the original elements to be accessed.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入数组元素是对象或数组，并且您将它们包含在输出数组中，那么JS仍然允许访问原始元素。
- en: Extracting data from objects
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从对象中提取数据
- en: Let's start with a simple example. Suppose we have some geographic data as shown
    in the following snippet, related to countries and the coordinates (latitude,
    longitude) of their capitals. Let's say we happened to want to calculate the average
    position of those cities. (No, I don't have a clue why we'd want to do that...)
    How would we go about it?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始。假设我们有一些地理数据，如下面的片段所示，与国家和它们首都的坐标（纬度、经度）有关。假设我们碰巧想要计算这些城市的平均位置。（不，我不知道为什么我们要这样做……）我们该如何去做？
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In case you are wondering if and why all the data are negative, it's just because
    the shown countries are all south of the Equator, and west of Greenwich. However,
    there are some South American countries with positive latitudes, such as Colombia
    or Venezuela, so not all have negative data. We'll come back to this question
    below, when we study the `some()` and `every()` methods.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道为什么所有数据都是负数，那只是因为所显示的国家都位于赤道以南，而且位于格林威治以西。然而，有一些南美国家的纬度是正数，比如哥伦比亚或委内瑞拉，所以并非所有数据都是负数。当我们学习`some()`和`every()`方法时，我们将在下面回到这个问题。
- en: 'We would want to use our `average()` function (that we developed earlier in
    this chapter), but there is a problem: that function can only be applied to an
    array of *numbers*, and what we have here is an array of *objects*. We can, however,
    do a trick. Focus on calculating the average latitude; we can deal with the longitude
    later, in a similar fashion. We can map each element of the array to just its
    latitude, and we would then have an appropriate input for `average()`. The solution
    would be something like the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要使用我们在本章前面开发的`average()`函数，但是有一个问题：该函数只能应用于*数字*数组，而我们这里有的是*对象*数组。然而，我们可以做一个小技巧。专注于计算平均纬度；我们可以以类似的方式稍后处理经度。我们可以将数组的每个元素映射到其纬度，然后我们就可以得到`average()`的适当输入。解决方案可能是以下内容：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you had extended `Array.prototype`, you could have then written an equivalent
    version, in a different style:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您扩展了`Array.prototype`，那么您可以以不同的风格编写一个等效版本：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will be seeing more about these styles in [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml),
    *Connecting Functions - Pipelining and Composition*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第8章](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml)中看到更多关于这些风格的内容，*连接函数-管道和组合*。
- en: Parsing numbers tacitly
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暗示式解析数字
- en: Working with the map is usually far safer and simpler than looping by hand,
    but some edge cases may trip you up. Say you received an array of strings representing
    numeric values, and you wanted to parse them into actual numbers. Can you explain
    the following results?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用map通常比手动循环更安全和更简单，但有些边缘情况可能会让您感到困惑。假设您收到了一个表示数值的字符串数组，并且您想将它们解析为实际的数字。您能解释以下结果吗？
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When you use `parseFloat()` to get floating point results, everything's OK.
    However, if you wanted to truncate results to integer values, then the output
    really goes awry... what's happening?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`parseFloat()`获得浮点结果时，一切都很好。然而，如果您想要将结果截断为整数值，那么输出就会出现问题……发生了什么？
- en: 'The answer lies in a problem with tacit programming. (We already saw some uses
    of tacit programming in the *An unnecessary mistake*, section of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out with Functions - A Core Concept*, and we''ll be seeing more in [Chapter
    8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml), *Connecting Functions - Pipelining
    and Composition*.) When you don''t explicitly show the parameters to a function,
    it''s easy to have some oversights. See the following code, which will lead us
    to the solution:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在于暗示式编程的问题。（我们已经在[第3章](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml)的*不必要的错误*部分看到了一些暗示式编程的用法，我们将在[第8章](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml)中看到更多，*连接函数-管道和组合*。）当您不明确显示函数的参数时，很容易出现一些疏忽。请看下面的代码，这将引导我们找到解决方案：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The reason for the unexpected behavior with `parseInt()`, is that this function
    can also receive a second parameter, that is the radix to be used when converting
    the string to a number. For instance, a call such as `parseInt("100010100001",
    2)` will convert the binary number 100010100001 to decimal.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseInt()`出现意外行为的原因是，这个函数也可以接收第二个参数，即在将字符串转换为数字时要使用的基数。例如，像`parseInt("100010100001",
    2)`这样的调用将把二进制数100010100001转换为十进制数。'
- en: See more on `parseInt()` at [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/parseInt](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/parseInt),
    where the radix parameter is explained in detail. You should always provide it,
    because some browsers might interpret strings with a leading zero to be octal,
    which would once again produce unwanted results.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/parseInt](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/parseInt)上查看更多关于`parseInt()`的信息，其中详细解释了基数参数。您应该始终提供它，因为某些浏览器可能会将具有前导零的字符串解释为八进制，这将再次产生不需要的结果。
- en: 'So, what happens when we provide `parseInt()` to `map()`? Remember, that `.map()`
    calls your mapping function with three parameters: the array element value, its
    index, and the array itself. When `parseInt` receives these values, it ignores
    the array, but assumes that the provided index is actually a radix... and `NaN`
    values are produced, since the original strings are not valid numbers in the given
    radix.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当我们将`parseInt()`提供给`map()`时会发生什么？记住，`.map()`调用映射函数时会传递三个参数：数组元素值，其索引和数组本身。当`parseInt`接收这些值时，它会忽略数组，但假设提供的索引实际上是一个基数...并且会产生`NaN`值，因为原始字符串在给定基数下不是有效数字。
- en: Working with ranges
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用范围
- en: 'Let''s now turn to a helper function, which will come handy for many usages.
    We want a `range(start,stop)` function, that generates an array of numbers, with
    values ranging from `start` (inclusive) to `stop` (exclusive):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向一个辅助函数，这将对许多用途很有用。我们想要一个`range(start,stop)`函数，它生成一个数字数组，值范围从`start`（包括）到`stop`（不包括）：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Why `.fill(0)`? All undefined array elements are skipped by `map()`, so we need
    to fill them with something, or our code will have no effect.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要使用`.fill(0)`？所有未定义的数组元素都会被`map()`跳过，所以我们需要用一些东西来填充它们，否则我们的代码将没有效果。
- en: Libraries such as Underscore or LoDash provide a more powerful version of our
    range function, letting you go in ascending or descending order, and also specifying
    the step to use, as in `_.range(0, -8, -2)` that produces [`0`, `-2`, `-4`, `-6`],
    but for our needs, the version we wrote is enough. See the *Questions* section
    at the end of this chapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 像Underscore或LoDash这样的库提供了我们的范围函数的更强大版本，让您可以按升序或降序进行操作，并且还可以指定要使用的步长，就像`_.range(0,
    -8, -2)`会产生[`0`, `-2`, `-4`, `-6`]，但对于我们的需求，我们编写的版本就足够了。请参阅本章末尾的*问题*部分。
- en: 'How can we use it? In the following section, we''ll see some usages for controlled
    looping with `forEach()`, but we can redo our factorial function by applying `range()`
    and then `reduce()`. The idea for this is simply to generate all the numbers from
    1 to n and then multiply them together:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用它？在接下来的部分中，我们将看到一些使用`forEach()`进行控制循环的用法，但我们可以通过应用`range()`然后`reduce()`来重新实现我们的阶乘函数。这个想法很简单，就是生成从1到n的所有数字，然后将它们相乘：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It's important to check the border cases, but the function also works for zero;
    can you see why? The reason for that is that the produced range is empty (the
    call is `range(1,1)` that returns an empty array) and then `reduce()` doesn't
    do any calculations, and simply returns the initial value (one), which is correct.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 检查边界情况很重要，但该函数也适用于零；你能看出原因吗？原因是生成的范围是空的（调用是`range(1,1)`返回一个空数组），然后`reduce()`不进行任何计算，只是返回初始值（1），这是正确的。
- en: In [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml), *Connecting Functions
    - Pipelining and Composition*, we'll have opportunity to use `range()` to generate
    source code; check out the *Currying with* *eval()* and *Partial application with*
    *eval()* sections.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml)中，*连接函数-管道和组合*，我们将有机会使用`range()`来生成源代码；请查看*使用*
    *eval()* *进行柯里化*和*使用* *eval()* *进行部分应用*部分。
- en: 'You could use these numeric ranges, to produce other kinds of ranges. For example,
    should you need an array with the alphabet, you could certainly (and tediously)
    write `["A", "B", "C"...` up to `..."X", "Y", "Z"]`. A simpler solution would
    be generating a range with the ASCII codes for the alphabet and mapping those
    into letters:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这些数字范围来生成其他类型的范围。例如，如果您需要一个包含字母表的数组，您肯定可以（而且很繁琐地）写`["A", "B", "C"...`一直到`..."X",
    "Y", "Z"]`。一个更简单的解决方案是生成一个包含字母表的ASCII代码范围，并将其映射为字母：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note the use of `charCodeAt()` to get the ASCII codes for the letters, and `String.fromCharCode(x)`
    to transform the ASCII code back into a character.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用`charCodeAt()`获取字母的ASCII代码，以及`String.fromCharCode(x)`将ASCII代码转换回字符。
- en: Emulating map() with reduce()
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用reduce()模拟map()
- en: Earlier in this chapter, we saw how `reduce()` could be used to implement `reduceRight()`.
    Now, let's see that `reduce()` can also be used to provide a polyfill for `map()`
    --not that you will need it, for browsers usually provide both methods, but just
    to get more ideas of what you can achieve with these tools.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早些时候，我们看到`reduce()`可以用来实现`reduceRight()`。现在，让我们看看`reduce()`也可以用来为`map()`提供一个polyfill--尽管您可能不需要它，因为浏览器通常提供这两种方法，但只是为了更多地了解您可以用这些工具实现什么样的想法。
- en: 'Our own `myMap()` is a one-liner--but it can be hard to understand. The idea
    is that we apply the function to each element of the array, and we `concat()`
    the result to (an initially empty) result array. When the loop finishes working
    with the input array, the result array will have the desired output values:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自己的`myMap()`是一行代码，但可能很难理解。思路是我们将函数应用于数组的每个元素，并将结果`concat()`到（最初为空的）结果数组中。当循环完成处理输入数组时，结果数组将具有所需的输出值：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s test this with a simple array and function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的数组和函数来测试一下：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first log shows the expected result, produced by `map()`. The second output
    gives the same result, so it seems `.myMap()` works! And, the final output is
    just to check that the original input array wasn't modified in any way; mapping
    operations should always produce a new array.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个日志显示了由`map()`产生的预期结果。第二个输出给出了相同的结果，所以似乎`.myMap()`有效！最后一个输出只是为了检查原始输入数组没有以任何方式被修改；映射操作应该总是产生一个新数组。
- en: More general looping
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更一般的循环
- en: The examples that we've seen above, simply looping through an array. However,
    sometimes you need to do some loop, but the required process doesn't really fit
    `.map()` or `.reduce()`... so what can be done? There is a `.forEach()` method
    that can help.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面看到的例子，只是简单地循环遍历数组。然而，有时您需要做一些循环，但所需的过程实际上并不适合`.map()`或`.reduce()`...那么该怎么办呢？有一个`.forEach()`方法可以帮助。
- en: Read more about the specification of the `.forEach()` method at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)上阅读更多关于`.forEach()`方法的规范。
- en: 'You must provide a callback that will receive the value, the index, and the
    array on which you are operating. (The last two arguments are optional.) JS will
    take care of the loop control, and you can do whatever you want at each step.
    For instance, we can program an object copy method by using some `Object` methods
    to copy the source object attributes one at a time, and generate a new object:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须提供一个回调函数，该函数将接收值、索引和您正在操作的数组。（最后两个参数是可选的。）JS将负责循环控制，您可以在每一步做任何您想做的事情。例如，我们可以通过使用一些`Object`方法逐个复制源对象属性，并生成一个新对象来编写对象复制方法：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Yes, of course, you might have also written `myCopy={...myObj}`, but where''s
    the fun in that? OK, that is better, but I needed a nice example to use `.forEach()`...
    sorry about that! Also, there are some hidden inconveniences in that code, which
    we''ll explain in [Chapter 10](383f5538-72cc-420a-ae77-896776c03f27.xhtml), *Ensuring
    Purity - Immutability*, when we try to get really frozen, un-modifiable objects.
    Just a hint: the new object may share values with the old one because we have
    a *shallow* copy, not a *deep* one. We''ll see more about this later in the book.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，当然，您也可以编写`myCopy={...myObj}`，但这样做有什么乐趣呢？好吧，那样更好，但我需要一个好的例子来使用`.forEach()`...对此很抱歉！此外，在那段代码中还有一些隐藏的不便之处，我们将在[第10章](383f5538-72cc-420a-ae77-896776c03f27.xhtml)中解释，*确保纯度-不可变性*，当我们试图获得真正冻结的、不可修改的对象时。只是一个提示：新对象可能与旧对象共享值，因为我们进行的是*浅*复制，而不是*深*复制。我们将在本书的后面更多地了解这一点。
- en: 'If you use the `range()` function we defined previously, you can also do common
    loops, of the `for(i=0; i<10; i++)` variety. We might write yet another version
    of factorial (!) using that:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用我们之前定义的`range()`函数，您也可以执行常见的循环，例如`for(i=0; i<10; i++)`。我们可以使用这种方式编写阶乘（!）的另一个版本：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This definition of factorial really matches the usual description: it generates
    all the numbers from 1 to n inclusive, and multiplies them; simple!'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶乘的定义确实与通常的描述相匹配：它生成从1到n的所有数字，并将它们相乘；简单！
- en: For greater generality, you might want to expand `range()` so it can generate
    ascending and descending ranges of values, possibly also stepping by a number
    different than 1\. This would practically allow you to replace all the loops in
    your code by `.forEach()` loops.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更通用，您可能希望扩展`range()`，使其能够生成升序和降序的值范围，可能还可以通过不同于1的数字进行步进。这实际上可以让您用`.forEach()`循环替换代码中的所有循环。
- en: Logical higher-order functions
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑高阶函数
- en: Up to now, we have been using higher-order functions to produce new results,
    but there are also some other functions that produce logical results, by applying
    a predicate to all the elements of an array.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用高阶函数来生成新的结果，但也有一些其他函数，通过将谓词应用于数组的所有元素来生成逻辑结果。
- en: 'A bit of terminology: the word *predicate* can be used in several senses (as
    in *Predicate Logic*) but for us, in computer science, we adopt the meaning *a
    function that returns true or false*. OK, this isn''t a very formal definition,
    but it''s enough for our needs. For example, we will filter an array depending
    on a predicate, and that just means that we get to decide which elements are included
    or excluded depending on the result of the predicate.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一些术语：*谓词*一词可以用多种意义（如*谓词逻辑*）,但对于我们来说，在计算机科学中，我们采用*返回true或false的函数*的含义。好吧，这不是一个非常正式的定义，但对我们的需求来说足够了。例如，我们将根据谓词筛选数组，这意味着我们可以决定根据谓词的结果包含或排除哪些元素。
- en: 'Using these functions implies that your code will become shorter: you can,
    with a single line of code, get the results corresponding to the whole set of
    values.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些函数意味着您的代码将变得更短：您可以用一行代码获得与整套值对应的结果。
- en: Filtering an array
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 筛选数组
- en: A common need is having to filter the elements of an array according to some
    condition. The `.filter()` method lets you inspect each element of an array, in
    the same fashion as `.map()`. The difference is that instead of producing a new
    element, the result of your function determines whether the input value will be
    kept in the output (if the function returned `true`) or if it will be skipped
    (if the function returned `false`). Also similarly to `.map()`, `.filter()` doesn't
    alter the original array, but rather returns a new array with the picked items.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的需求是根据某些条件筛选数组的元素。`.filter()`方法允许您检查数组的每个元素，方式与`.map()`相同。不同之处在于，函数的结果决定了输入值是否会保留在输出中（如果函数返回`true`）或者是否会被跳过（如果函数返回`false`）。与`.map()`类似，`.filter()`不会改变原始数组，而是返回一个包含选定项的新数组。
- en: 'See Figure 5.4 for a diagram showing the input and output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 查看图5.4，显示输入和输出的图表：
- en: '![](assets/834e362e-be10-4a3b-875c-ffdcc0685d27.png)Figure 5.4: The filter()
    method picks the elements of an array, that satisfy a given predicateRead more
    on the `.filter()` function at [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/834e362e-be10-4a3b-875c-ffdcc0685d27.png)图5.4：`filter()`方法选择满足给定谓词的数组元素在[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)上阅读更多关于`.filter()`函数的内容。'
- en: 'The things to remember when filtering an array are these:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 筛选数组时要记住的事情有：
- en: '**Always return something from your predicate**. If you forget to include a
    `return`, the function will implicitly return `undefined`, and since that''s a
    *falsy* value, the output will be an empty array.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**始终从谓词中返回一些东西**。如果你忘记包含一个`return`，函数将隐式返回`undefined`，而由于那是一个*假值*，输出将是一个空数组。'
- en: '**The copy that is made, is shallow**. If the input array elements are objects
    or arrays, the original elements will still be accessible.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制的是浅层的**。如果输入数组元素是对象或数组，原始元素仍然是可访问的。'
- en: A reduce() example
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个reduce()示例
- en: 'Let''s see a practical example. Suppose a service has returned a JSON object,
    which itself has an array of objects containing an account `id` and the account
    `balance`. How can we get the list of IDs that are *in the red*, with a negative
    balance? The input data could be as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个实际的例子。假设一个服务返回了一个JSON对象，其中包含一个包含账户`id`和账户`balance`的对象数组。我们如何获取*处于赤字状态*，即余额为负的ID列表？输入数据可能如下：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Assuming we got this data in a `serviceResult` variable, we could get the delinquent
    accounts with something like the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将这些数据存储在一个`serviceResult`变量中，我们可以通过以下方式获取拖欠账户：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By the way, given that the filtering operation produced yet another array, if
    you just wanted the accounts IDs, you could do so by mapping the output, to just
    get the ID field.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，考虑到过滤操作产生了另一个数组，如果你只想要账户ID，你可以通过映射输出来实现。
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And if you didn't care for the intermediate result, a one-liner would have done
    as well.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在乎中间结果，一行代码也可以。
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Emulating filter() with reduce()
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用reduce()模拟filter()
- en: 'As we did before with `.map()`, we can also create our own version of `.filter()`
    by using `.reduce()`. The idea is similar: loop through all the elements of the
    input array, apply the predicate to it, and if the result is `true`, add the original
    element to the output array. When the loop is done, the output array will only
    have those elements for which the predicate was `true`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前用`.map()`做的一样，我们也可以通过使用`.reduce()`创建我们自己的`.filter()`版本。这个想法是类似的：循环遍历输入数组的所有元素，对其应用谓词，如果结果为`true`，则将原始元素添加到输出数组中。当循环结束时，输出数组将只包含谓词为`true`的那些元素。
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can quickly see that our function works as expected.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很快地看到我们的函数按预期工作。
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The output is the same pair of accounts as earlier in this section.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '输出与本节前面的账户对相同。 '
- en: Searching an array
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索数组
- en: 'Sometimes, instead of filtering all the elements of an array, you want to find
    an element that satisfies a given predicate. There are a couple of functions that
    can be used for this, depending on your specific needs:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你不想过滤数组的所有元素，而是想找到满足给定条件的元素。根据你的具体需求，可以使用一些函数来实现这一点：
- en: '`.find()` searches through the array and returns the value of the first element
    that satisfies a given condition, or `undefined` if no such element is found'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.find()`搜索数组并返回满足给定条件的第一个元素的值，如果找不到这样的元素，则返回`undefined`'
- en: '`.findIndex()` does a similar task, but instead of returning an element, it
    returns the index of the first element in the array that satisfies the condition,
    or -1 if none was found'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.findIndex()`执行类似的任务，但是它返回的不是元素，而是数组中满足条件的第一个元素的索引，如果找不到则返回-1'
- en: 'The analogy is clear to `.includes()` and `.indexOf()`, which search for a
    specific value, instead of for an element that satisfies a more general condition.
    We can easily write equivalent one-liners:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类比很明显，`.includes()`和`.indexOf()`搜索特定的值，而不是满足更一般条件的元素。我们可以很容易地编写等效的一行代码：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Going back to the geographic data we used earlier, we could easily find a given
    country.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前使用的地理数据，我们可以很容易地找到一个给定的国家。
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We couldn''t use the simpler `.includes()` method because we have to delve
    into the object to get the field we want. If we wanted the position of the country
    in the array, we would have used `.findIndex()`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法使用更简单的`.includes()`方法，因为我们必须深入对象以获取我们想要的字段。如果我们想要数组中国家的位置，我们将使用`.findIndex()`：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A special search case
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊的搜索情况
- en: 'Now, for variety, a little quiz. Suppose you had an array of numbers and wanted
    to run a sanity check, studying whether any of them was `NaN`. How would you do
    it? A tip: don''t try checking the types of the array elements: even though `NaN`
    stands for *Not a Number*, `typeof NaN === "number"`... And you''ll get a surprising
    result if you try to do the search in an *obvious way*...'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了多样化，来做一个小测验。假设你有一个数字数组，并想要进行一次健全性检查，研究其中是否有任何`NaN`。你会怎么做？提示：不要尝试检查数组元素的类型：尽管`NaN`代表*Not
    a Number*，`typeof NaN === "number"`...如果你试图以*显而易见的方式*进行搜索，你会得到一个令人惊讶的结果...
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'What''s going on here? It''s a bit of interesting JS trivia: `NaN` is the only
    value that isn''t equal to itself. Should you need to look for `NaN`, you''ll
    have to use the new `isNaN()` function, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？这是有趣的JS小知识：`NaN`是唯一不等于自身的值。如果你需要查找`NaN`，你将不得不使用新的`isNaN()`函数，如下所示：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Emulating find() and findIndex() with reduce()
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用reduce()模拟find()和findIndex()
- en: As with other methods, let's finish this section by studying how to implement
    the methods we showed, by using the omnipotent `.reduce()`. This is a good exercise
    to get accustomed to working with higher-order functions, even if you are never
    going to actually use these polyfills!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他方法一样，让我们通过使用万能的`.reduce()`来学习如何实现我们展示的方法。这是一个很好的练习，可以让你习惯使用高阶函数，即使你永远不会真正使用这些polyfills！
- en: 'The `.find()` function requires a bit of work. We start the search with an
    undefined value, and if we find an array element such that the predicate is `true`,
    we change the accumulated value to that of the array:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`.find()`函数需要一些工作。我们从一个未定义的值开始搜索，如果我们找到一个数组元素使得谓词为`true`，我们就将累积值更改为数组的值：'
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: For `findIndex()` we must remember that the callback function receives the accumulated
    value, the array current element, and the index of the current element, but other
    than that, the equivalent expression is quite similar to the one for `find()`;
    comparing them is worth the time.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`findIndex()`，我们必须记住回调函数接收累积值、数组当前元素和当前元素的索引，但除此之外，等价表达式与`find()`的表达式非常相似；比较它们是值得的。
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The initial accumulated value is here `-1`, which will be the returned value
    in case no element fulfills the predicate. Whenever the accumulated value is still
    `-1`, but we find an element that satisfies the predicate, we change the accumulated
    value to the array index.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 初始累积值在这里是`-1`，如果没有元素满足谓词，则将返回该值。每当累积值仍为`-1`，但我们找到满足谓词的元素时，我们将累积值更改为数组索引。
- en: Higher level predicates - some, every
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更高级的谓词-一些，每个
- en: 'The last functions we are going to consider, greatly simplify going through
    arrays to test for conditions. These functions are:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要考虑的最后一个函数大大简化了通过数组来测试条件。这些函数是：
- en: '`.every()`, that is `true` if and only *every* element in the array satisfies
    a given predicate'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.every()`，如果数组中的每个元素都满足给定的谓词，则为`true`'
- en: '`.some()`, that is `true` if at least *one* element in the array satisfies
    the predicate'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.some()`，如果数组中至少*一个*元素满足谓词，则为`true`'
- en: 'For example, we could easily check our hypothesis about all the countries having
    negative coordinates:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以轻松检查我们关于所有国家都有负坐标的假设：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we want to find equivalents to these two functions in terms of `reduce()`,
    the two alternatives show nice symmetry:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要找到这两个函数的`reduce()`等价物，那么两个替代方案显示出很好的对称性：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first folding operation evaluates `fn(y)`, and ANDs the result with the
    previous tests; the only way the final result will be `true` is if every test
    comes out `true`. The second folding operation is similar, but ORs the result
    with the previous results, and will produce true, unless every test comes out
    `false`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个折叠操作评估`fn(y)`，并将结果与先前的测试进行逻辑与运算；最终结果为`true`的唯一方式是如果每个测试都为`true`。第二个折叠操作类似，但将结果与先前的结果进行逻辑或运算，除非每个测试都为`false`，否则将产生`true`。
- en: In terms of Boolean algebra, we would say that the alternative formulations
    for `every()` and `some()` exhibit duality. This duality is the same kind that
    appears in the expressions `x === x && true` and `x === x || false`; if `x` is
    a Boolean value, and we exchange `&&` and `||`, and also `true` and `false`, we
    transform one expression into the other, and both are valid.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 从布尔代数的角度来看，我们会说`every()`和`some()`的替代形式表现出对偶性。这种对偶性与表达式`x === x && true`和`x ===
    x || false`中出现的对偶性相同；如果`x`是一个布尔值，并且我们交换`&&`和`||`，以及`true`和`false`，我们将一个表达式转换为另一个表达式，两者都是有效的。
- en: Checking negatives - none
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查负数-无
- en: If you wanted, you could also define `.none()`, as the complement of `.every()`
    -- this new function would be true only if none of the elements of the array satisfied
    the given predicate. The simplest way of coding this would be by noting that if
    no elements satisfy the condition, then all elements satisfy the negation of the
    condition.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您还可以定义`.none()`，作为`.every()`的补集--这个新函数只有在数组的元素都不满足给定的谓词时才为真。编写这个函数的最简单方法是注意到如果没有元素满足条件，那么所有元素都满足条件的否定。
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you want, you can turn it into a method, by modifying the array prototype,
    as we earlier saw -- it's still a bad practice, but it's what we have until we
    start looking into better methods for composing and chaining functions, as in
    [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml), *Connecting Functions
    - Pipelining and Composition*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以将其转换为一个方法，通过修改数组原型，就像我们之前看到的那样--这仍然是一个不好的做法，但这是我们在开始寻找更好的方法来组合和链接函数之前所拥有的。
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We had to use `function()`, instead of an arrow function, for the same reasons
    we saw earlier; in this sort of case, we do need `this` to be correctly assigned.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '我们必须使用`function()`，而不是箭头函数，原因与我们之前看到的相同；在这种情况下，我们确实需要正确分配`this`。 '
- en: In [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml), *Producing Functions
    - Higher-Order Functions*, we will see other ways of negating a function, by writing
    an appropriate higher-order function of our own.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)中，*生成函数-高阶函数*，我们将看到通过编写适当的自定义高阶函数来否定函数的其他方法。
- en: Questions
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: '5.1\. **Filtering... but what**: Suppose you have an array, called `someArray`,
    and you apply the following `.filter()` to it, which at first sight doesn''t even
    look like valid JS code. What will be in the new array, and why?'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 5.1\. **过滤...但是什么**：假设您有一个名为`someArray`的数组，并且您对其应用以下`.filter()`，乍一看甚至看起来不像有效的JS代码。新数组中会有什么，为什么？
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '5.2\. **Generating HTML code, with restrictions**: Using the `filter()`...`map()`...`reduce()`
    sequence is quite common (even allowing that sometimes you won''t use all three)
    and we''ll come back to this in the *Functional Design Patterns* section of [Chapter
    11](24b391f7-abaf-439e-9bfc-a71d989cfd48.xhtml), *Implementing Design Patterns
    - The Functional Way*. The problem here is to use those functions (and none others!)
    to produce an unordered list of elements (`<ul>`...`</ul>`) that can later be
    used onscreen. Your input is an array of objects like the following (does the
    list of characters date me?) and you must produce a list of each name that corresponds
    to chess or checkers players:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 5.2\. **生成HTML代码，带限制**：使用`filter()`...`map()`...`reduce()`序列是相当常见的（即使有时您可能不会使用所有三个），我们将在[第11章](24b391f7-abaf-439e-9bfc-a71d989cfd48.xhtml)的*功能设计模式*部分回到这一点，*实现设计模式-功能方式*。这里的问题是使用这些函数（而不是其他任何函数！）来生成一个无序元素列表（`<ul>`...`</ul>`），以便稍后在屏幕上使用。您的输入是一个类似以下对象的数组（字符列表是否让我显得老？），您必须列出与国际象棋或跳棋玩家对应的每个名称：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The output would be something like the following -- though it doesn't matter
    if you don't generate spaces and indentation. It would be easier if you could
    use, say, `.join()`, but in this case, it won't be allowed; only the three mentioned
    functions can be used.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容--尽管如果您不生成空格和缩进也没关系。如果您能使用`.join()`，那将更容易，但在这种情况下，不允许使用；只能使用这三个提到的函数。
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '5.3 **More formal testing**: In some of the examples preceding, such as in
    the *Emulating* `map()` with `reduce()` section we didn''t write actual unit tests
    but rather were satisfied with doing some console logging. Can you write appropriate
    unit tests instead?'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 5.3 **更正式的测试：** 在前面的一些示例中，比如在*用`reduce()`模拟`map()`*部分，我们没有编写实际的单元测试，而是满足于做一些控制台日志记录。你能否写出适当的单元测试呢？
- en: 5.4\. **Ranging far and wide:** The `range()` function that we saw here can
    have many uses, but lacks a bit in generality. Can you expand it to allow, say,
    for descending ranges, like in `range(10,1)`? (What should the last number in
    the range be?) And, could you also allow for a step size to be included, to specify
    the difference between successive numbers in the range? With this, `range(1,10,2)`
    would produce `[1, 3, 5, 7, 9]`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 5.4\. **广泛涉猎：** 我们在这里看到的`range()`函数可以有很多用途，但在通用性上有点欠缺。你能否扩展它，使其允许降序范围，比如`range(10,1)`？（范围中的最后一个数字应该是什么？）另外，你还能否允许包含步长，以指定范围中连续数字之间的差异？有了这个，`range(1,10,2)`将产生`[1,
    3, 5, 7, 9]`。
- en: '5.5 **Doing the alphabet**: What would have happened in the *Working with ranges*
    section, if instead of writing `map(x => String.fromCharCode(x))` you had simply
    written `map(String.fromCharCode)`? Can you explain the different behavior? Hint:
    we already saw a similar problem elsewhere in this chapter.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 5.5 **做字母表：** 如果在*使用范围*部分，而不是编写`map(x => String.fromCharCode(x))`，你只是简单地写了`map(String.fromCharCode)`会发生什么？你能解释不同的行为吗？提示：我们在本章的其他地方已经看到了类似的问题。
- en: '5.6\. **Producing a CSV**: In a certain application, you want to enable the
    user to download a set of data as a CSV (comma separated value) file, by using
    a data URI. (See more at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs/](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs/).)
    Of course, the first problem is to produce the CSV itself! Assume you have an
    array of arrays of numeric values, as shown in the following snippet, and write
    a function that will transform that structure into a CSV string, that you will
    then be able to plug into the URI. As usual, `\n` stands for the newline character:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 5.6\. **生成CSV：** 在某个应用程序中，您希望用户能够通过使用数据URI（逗号分隔值）文件下载一组数据。 （在[https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs/](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs/)中了解更多。）当然，第一个问题是生成CSV本身！假设您有一个数字值数组的数组，如下面的代码段所示，并编写一个函数，将该结构转换为CSV字符串，然后您将能够将其插入URI中。像往常一样，`\n`代表换行符：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have started working with higher-order functions, so as
    to show a more declarative way of working, with shorter, more expressive code.
    We have gone over several operations: we have seen `.reduce()` and `.reduceRight()`,
    to get a single result from an array; `.map()`, to apply a function to each element
    of an array; `.forEach()`, to simplify looping; `.filter()`, to pick elements
    from an array; `.find()` and `.findIndex()`, to search in an array, and `.every()`
    and `.some()`, to verify general logic conditions.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经开始使用高阶函数，以展示更具声明性的工作方式，以更简洁、更具表现力的代码。我们已经讨论了几种操作：我们已经看到了`.reduce()`和`.reduceRight()`，从数组中获取单个结果；`.map()`，对数组的每个元素应用函数；`.forEach()`，简化循环；`.filter()`，从数组中选择元素；`.find()`和`.findIndex()`，在数组中搜索；以及`.every()`和`.some()`，验证一般逻辑条件。
- en: In [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml), *Producing Functions
    - Higher-Order Functions*, we will continue working with higher order functions,
    but we will then turn to writing our own ones, to gain more expressive power for
    our coding.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)中，*生成函数 - 高阶函数*，我们将继续使用高阶函数，但随后我们将转而编写自己的函数，以获得更多表达力，为我们的编码。
