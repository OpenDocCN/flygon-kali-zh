- en: Reactive Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式系统
- en: In the final chapter of this book, we'll break the flow of the connected narrative
    and jump closer to real-life professional programming. As more data gets processed
    and services become more sophisticated, the need for more adaptive, highly scalable,
    and distributed applications grows exponentially. That is what we are going to
    address in this chapter—how such a software system may look in practice.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章中，我们将打破连贯叙述的流程，更接近真实的专业编程。随着处理的数据越来越多，服务变得更加复杂，对更具适应性、高度可扩展和分布式应用程序的需求呈指数级增长。这就是我们将在本章中讨论的内容——这样的软件系统在实践中可能是什么样子。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to process a lot of data quickly
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何快速处理大量数据
- en: Microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务
- en: Reactive systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式系统
- en: Exercise – Creating `io.reactivex.Observable`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习-创建`io.reactivex.Observable`
- en: How to process a lot of data quickly
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何快速处理大量数据
- en: 'There are many measurable performance characteristics that can be applied to
    an application. Which ones to use depends on the purpose of the application. They
    are usually listed as non-functional requirements. The most typical set includes
    the following three:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 可以应用许多可测量的性能特征到一个应用程序中。要使用哪些取决于应用程序的目的。它们通常被列为非功能性要求。最典型的集合包括以下三个：
- en: '**Throughput**: The number of requests processed per a unit of time.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**吞吐量**：单位时间内处理的请求数。'
- en: '**Latency**: The time elapsed between the moment a request was submitted and
    the moment the *first* byte of the response is received. It is measured in seconds,
    milliseconds, and so on.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟**：从提交请求到接收响应的*第一个*字节所经过的时间。以秒、毫秒等为单位进行测量。'
- en: '**Memory footprint**: The amount of memory—min, max, or average— that the application
    consumes.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存占用**：应用程序消耗的内存量——最小、最大或平均。'
- en: In practice, latency is often calculated as the inverse of the throughput. These
    characteristics vary as a load grows, so the non-functional requirements typically
    include the maximum value for each of them under the average and maximum load.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，延迟通常被计算为吞吐量的倒数。这些特性随着负载的增长而变化，因此非功能性要求通常包括它们在平均和最大负载下的最大值。
- en: Often, the improvements in throughput and latency are only at the expense of
    the memory, unless adding a faster CPU can improve all three characteristics.
    But that depends on the nature of the processing. For example, an input/output
    (or another interaction) with a low-performance device can impose a limit, and
    no change in the code can improve the application performance.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，吞吐量和延迟的改进只是以内存为代价，除非增加更快的CPU可以改善这三个特性。但这取决于处理的性质。例如，与性能低下的设备进行输入/输出（或其他交互）可能会施加限制，代码的任何更改都无法改善应用程序性能。
- en: There are also subtle nuances in the measuring of each of the characteristics.
    For example, instead of measuring latency as the average of all requests, we can
    use the maximum latency among 99% of the fastest (least latency) requests. Otherwise,
    it looks like an average wealth number obtained by dividing the wealth of a billionaire
    and a person at the bottom of the income pyramid by two.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个特性的测量也有微妙的细微差别。例如，我们可以使用最快（最少延迟）请求中99%的最大延迟来代替将延迟作为所有请求的平均值。否则，它看起来像是通过将亿万富翁和收入金字塔底部的人的财富除以二获得的平均财富数字。
- en: 'When evaluating application performance, one has to answer the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估应用程序性能时，必须回答以下问题：
- en: Can the requested upper limit of the latency ever be exceeded? If yes, how often,
    and by how much?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求的延迟上限是否可能被超过？如果是，多久一次，超过多少？
- en: How long can the period of poor latency be, and how often it is allowed to happen?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟不良的时间段可以有多长，允许发生多少次？
- en: Who/what measures the latency in production?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁/什么在生产中测量延迟？
- en: What is the expected peak load, and how long is it expected to last?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期的峰值负载是多少，预计会持续多长时间？
- en: Only after all of these (and similar questions) have been answered, and the
    non-functional requirements have been established, can we start designing the
    system, testing it, tweaking, and testing again. There are many programming techniques
    that prove to be effective in achieving the required throughput with an acceptable
    memory consumption.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在回答了所有这些问题（和类似的问题），并且已经确定了非功能性要求之后，我们才能开始设计系统，测试它，微调并再次测试。有许多编程技术证明在以可接受的内存消耗实现所需的吞吐量方面是有效的。
- en: In this context, the terms *asynchronous*, *non-blocking*, *distributed*, *scalable*, *reactive*,
    *responsive*, *resilient*, *elastic*, and *message-driven* became ubiquitous,
    just synonyms of *high performance*. We are going to discuss each of these terms so
    that the reader can understand the motivation that brought *microservices* and
    *reactive systems* to life, which we are going to present in the next two sections
    of this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，*异步*、*非阻塞*、*分布式*、*可扩展*、*响应式*、*响应式*、*弹性*和*消息驱动*等术语变得无处不在，只是*高性能*的同义词。我们将讨论每个术语，以便读者可以理解为什么会出现*微服务*和*响应式系统*，这将在本章的下两节中介绍。
- en: Asynchronous
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步
- en: '**Asynchronous** means that the requestor gets the response *immediately*,
    but the result is not there. Instead, the requestor receives an object with methods
    that allow us to check whether the result is ready. The requestor calls this method
    periodically, and, when the result is ready, retrieves it using another method
    on the same object.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步**意味着请求者*立即*获得响应，但结果还没有。相反，请求者收到一个带有方法的对象，允许我们检查结果是否准备就绪。请求者定期调用此方法，当结果准备就绪时，使用同一对象上的另一个方法检索它。'
- en: The advantage of such a solution is that the requestor can do other things while
    waiting. For example, in [Chapter 11](e8c37d86-291d-4500-84ea-719683172477.xhtml), *JVM
    Processes and Garbage Collection*, we demonstrated how a child thread can be created.
    So, the main thread can create a child thread that sends a non-asynchronous (also
    called blocking) request, and waits for its return, doing nothing. The main thread,
    meanwhile, can continue executing something else, periodically calling the child
    thread object to see whether the result is ready.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案的优势在于请求者可以在等待时做其他事情。例如，在[第11章](e8c37d86-291d-4500-84ea-719683172477.xhtml)中，*JVM进程和垃圾回收*，我们演示了如何创建一个子线程。因此，主线程可以创建一个子线程，发送一个非异步（也称为阻塞）请求，并等待其返回，什么也不做。与此同时，主线程可以继续执行其他操作，定期调用子线程对象以查看结果是否准备好。
- en: That is the most basic of asynchronous call implementations. In fact, we we
    already used it when we processed a parallel stream. The parallel stream operations
    create child threads behind the scenes, break the stream into segments, and assign
    each segment to a dedicated thread, then aggregate the results from each segment
    in the final one. In the previous chapter, we wrote functions that did the aggregating
    job. As a reminder, these functions are called combiners.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最基本的异步调用实现。事实上，当我们处理并行流时，我们已经使用了它。并行流操作在后台创建子线程，将流分成段，并将每个段分配给一个专用线程，然后将每个段的结果聚合到最终结果中。在上一章中，我们编写了执行聚合工作的函数。作为提醒，这些函数被称为组合器。
- en: Let's compare the performance of the same functionality when processing sequential
    and parallel streams.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较处理顺序和并行流时相同功能的性能。
- en: Sequential versus parallel streams
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顺序与并行流
- en: 'To demonstrate the difference between sequential and parallel processing, let''s
    imagine a system that collects data from 10 physical devices (sensors) and calculates
    an average. The interface of such a system could look like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示顺序和并行处理之间的差异，让我们想象一个从10个物理设备（传感器）收集数据并计算平均值的系统。这样一个系统的接口可能如下所示：
- en: '```java'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface MeasuringSystem {
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: interface MeasuringSystem {
- en: double get(String id);
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: double get(String id);
- en: '}'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'It has only one method, `get()`, which receives an ID of a sensor and returns
    the result of the measurement. Using this interface, we can implement many different
    systems, which are able to call different devices. For demonstration purposes,
    we are not going to write a lot of code. All we need is to put a delay of 100
    milliseconds (to imitate the time it takes to collect the measurement from the
    sensor) and return some number. We can implement the delay as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它只有一个方法，`get()`，它接收传感器的ID并返回测量结果。使用这个接口，我们可以实现许多不同的系统，这些系统能够调用不同的设备。为了演示目的，我们不打算写很多代码。我们只需要延迟100毫秒（模拟从传感器收集测量数据所需的时间）并返回一些数字。我们可以这样实现延迟：
- en: '```java'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void pauseMs(int ms) {
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: void pauseMs(int ms) {
- en: try{
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: try{
- en: TimeUnit.MILLISECONDS.sleep(ms);
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: TimeUnit.MILLISECONDS.sleep(ms);
- en: '} catch(InterruptedException ex){'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch(InterruptedException ex){'
- en: ex.printStackTrace();
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace();
- en: '}'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As for the resulting number, we will use `Math.random()` to simulate the difference
    of the measurements received from different sensors (that is why we need to find
    an average—to offset the errors and other idiosyncrasies of an individual device).
    So, our demo implementation may look as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 至于结果数字，我们将使用`Math.random()`来模拟从不同传感器接收到的测量值的差异（这就是为什么我们需要找到一个平均值——以抵消个别设备的误差和其他特性）。因此，我们的演示实现可能如下所示：
- en: '```java'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class MeasuringSystemImpl implements MeasuringSystem {
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: class MeasuringSystemImpl implements MeasuringSystem {
- en: public double get(String id){
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: public double get(String id){
- en: demo.pauseMs(100);
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: demo.pauseMs(100);
- en: return 10\. * Math.random();
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: return 10\. * Math.random();
- en: '}'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Now, we realize that our `MeasuringInterface` is a functional interface, because
    it has only one method. This means we can use one of the standard functional interfaces
    from the `java.util.function` package; namely, `Function<String, Double>`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们意识到我们的`MeasuringInterface`是一个函数接口，因为它只有一个方法。这意味着我们可以使用`java.util.function`包中的标准函数接口之一；即`Function<String,
    Double>`：
- en: '```java'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Function<String, Double> mSys = id -> {
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Function<String, Double> mSys = id -> {
- en: demo.pauseMs(100);
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: demo.pauseMs(100);
- en: return 10\. + Math.random();
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: return 10\. + Math.random();
- en: '};'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '```'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'So, we can discard our `MeasuringSystem` interface and `MeasuringSystemImpl` class.
    But we can leave the `mSys` (*Measuring System*) identificator that reflects the
    idea behind this function: it represents a measuring system that provides access
    to its sensors and allows us to collect data from them.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以放弃我们的`MeasuringSystem`接口和`MeasuringSystemImpl`类。但是我们可以保留`mSys`（*Measuring
    System*）标识符，它反映了这个函数背后的想法：它代表一个提供对其传感器的访问并允许我们从中收集数据的测量系统。
- en: 'Now, let''s create a list of sensor IDs:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个传感器ID列表：
- en: '```java'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> ids = IntStream.range(1, 11)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> ids = IntStream.range(1, 11)
- en: .mapToObj(i -> "id" + i).collect(Collectors.toList());
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: .mapToObj(i -> "id" + i).collect(Collectors.toList());
- en: '```'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Again, in real life, we would need to collect the IDs of real devices, but for
    demo purposes, we just generate them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在现实生活中，我们需要收集真实设备的ID，但是为了演示目的，我们只是生成它们。
- en: 'Finally, we will create the `collectData()` method, which calls all the sensors
    and calculates an average across all the received data:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建`collectData()`方法，它调用所有传感器并计算接收到的所有数据的平均值：
- en: '```java'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Stream<Double> collectData(Stream<String> stream,
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Stream<Double> collectData(Stream<String> stream,
- en: Function<String, Double> mSys){
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Function<String, Double> mSys){
- en: return  stream.map(id -> mSys.apply(id));
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: return  stream.map(id -> mSys.apply(id));
- en: '}'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, the method receives a stream that provides IDs and a function
    that uses each ID to get a measurement from a sensor.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个方法接收一个提供ID的流和一个使用每个ID从传感器获取测量值的函数。
- en: 'Here is how we are going to call this method from the `averageDemo()` method,
    using the `getAverage()` method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将如何从`averageDemo()`方法中调用这个方法，使用`getAverage()`方法：
- en: '```java'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void averageDemo() {
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: void averageDemo() {
- en: Function<String, Double> mSys = id -> {
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Function<String, Double> mSys = id -> {
- en: pauseMs(100);
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: pauseMs(100);
- en: return 10\. + Math.random();
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 返回10\. + Math.random();
- en: '};'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: getAverage(() -> collectData(ids.stream(), mSys));
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: getAverage(() -> collectData(ids.stream(), mSys));
- en: '}'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void getAverage(Supplier<Stream<Double>> collectData) {
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: void getAverage(Supplier<Stream<Double>> collectData) {
- en: LocalTime start = LocalTime.now();
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: LocalTime start = LocalTime.now();
- en: double a = collectData.get()
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: double a = collectData.get()
- en: .mapToDouble(Double::valueOf).average().orElse(0);
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: .mapToDouble(Double::valueOf).average().orElse(0);
- en: System.out.println((Math.round(a * 100.) / 100.) + " in " +
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println((Math.round(a * 100.) / 100.) + " in " +
- en: Duration.between(start, LocalTime.now()).toMillis() + " ms");
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Duration.between(start, LocalTime.now()).toMillis() + " ms");
- en: '}'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, we create the function that represents the measuring system
    and pass it into the `collectData()` method, along with the stream of IDs. Then,
    we create the `SupplierStream<Double>>` function as the `() -> collectData(ids.stream(),
    mSys)` lambda expression, and pass it as the `collectData` parameter into the `getAverage()` method.
    Inside of the `getAverage()` method, we call the `get()` of the supplier, and
    thus invoke `collectData(ids.stream(), mSys)`, which returns `Stream<Double>`.
    We then convert it to `DoubleStream` with the `mapToDouble()` operation, so we
    can apply the `average()` operation. The `average()` operation returns an `Optional<Double>` object,
    and we call its `orElse(0)` method, which returns either the calculated value
    or zero (if, for example, the measuring system could not connect to any of its
    sensors and returned an empty stream). The last line of the `getAverage()` method
    prints the result and the time it took to calculate it. In real code, we would
    return the result and use it for other calculations. But for our demonstration,
    we just print it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们创建了代表测量系统的函数，并将其传递给`collectData()`方法，以及ID流。然后，我们创建了`SupplierStream<Double>>`函数作为`()
    -> collectData(ids.stream(), mSys)` lambda表达式，并将其作为`collectData`参数传递给`getAverage()`方法。在`getAverage()`方法内部，我们调用供应商的`get()`，从而调用`collectData(ids.stream(),
    mSys)`，它返回`Stream<Double>`。然后我们使用`mapToDouble()`操作将其转换为`DoubleStream`，以便应用`average()`操作。`average()`操作返回一个`Optional<Double>`对象，我们调用它的`orElse(0)`方法，它返回计算出的值或零（例如，如果测量系统无法连接到任何传感器并返回空流）。`getAverage()`方法的最后一行打印了结果和计算所需的时间。在实际代码中，我们会返回结果并将其用于其他计算。但是对于我们的演示，我们只是打印它。
- en: 'Now, we can compare the performance of sequential stream processing to parallel
    stream processing:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将顺序流处理的性能与并行流处理进行比较：
- en: '```java'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> ids = IntStream.range(1, 11)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> ids = IntStream.range(1, 11)
- en: .mapToObj(i -> "id" + i).collect(Collectors.toList());
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: .mapToObj(i -> "id" + i).collect(Collectors.toList());
- en: Function<String, Double> mSys = id -> {
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Function<String, Double> mSys = id -> {
- en: pauseMs(100);
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: pauseMs(100);
- en: return 10\. + Math.random();
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 返回10\. + Math.random();
- en: '};'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: getAverage(() -> collectData(ids.stream(), mSys));
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: getAverage(() -> collectData(ids.stream(), mSys));
- en: '//prints: 10.46 in 1031 ms'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: //打印：10.46在1031毫秒内
- en: getAverage(() -> collectData(ids.parallelStream(), mSys));
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: getAverage(() -> collectData(ids.parallelStream(), mSys));
- en: '//prints: 10.49 in 212 ms'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: //打印：10.49在212毫秒内
- en: '```'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, processing a parallel stream is five times faster than processing
    a sequential stream.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，处理并行流比处理顺序流快五倍。
- en: Although behind the scenes, the parallel stream uses `\` asynchronous processing,
    this is not what programmers have in mind when talking about processing requests asynchronously.
    From the application perspective, it is just parallel (also called concurrent)
    processing. It is faster than sequential processing, but the main thread has to
    wait until all of the calls are made and all of the data retrieved. If each call
    takes at least 100 ms (as it does in our case), then the processing of all the
    calls cannot be completed in less time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在幕后，并行流使用了`\`异步处理，但这并不是程序员在谈论异步处理请求时所指的。从应用程序的角度来看，它只是并行（也称为并发）处理。它比顺序处理快，但主线程必须等待所有调用完成并检索所有数据。如果每个调用至少需要100毫秒（就像我们的情况一样），那么所有调用的处理时间不可能少于这个时间。
- en: Of course, we can create a child thread and let it place all the calls, and
    wait until they complete, while the main thread does something else. We can even
    create a service that does it, so the application can just tell such a service
    what to do (pass the sensor IDs, in our case) and continue doing something else.
    Later, the main thread can call the service again, and get the result or pick
    it up in some agreed-upon place. That would be the truly asynchronous processing
    that the programmers are talking about.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以创建一个子线程，让它进行所有调用，并等待它们完成，而主线程则做其他事情。我们甚至可以创建一个执行此操作的服务，因此应用程序只需告诉这样的服务要做什么（在我们的情况下传递传感器ID）并继续做其他事情。稍后，主线程可以再次调用服务，并获取结果或在约定的地方获取结果。这就是程序员所说的真正的异步处理。
- en: But before writing such a code, let's look at the `CompletableFuture` class
    located in the `java.util.concurrent` package. It does everything we described,
    and even more.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但在编写这样的代码之前，让我们看看位于`java.util.concurrent`包中的`CompletableFuture`类。它可以做我们描述的一切，甚至更多。
- en: Using the CompletableFuture class
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CompletableFuture类
- en: 'Using the `CompletableFuture` object, we can separate sending the request for
    data to the measuring system (and creating the `CompletableFuture` object) from
    getting the result from the `CompletableFuture` object. This is exactly the scenario
    we described when explaining what asynchronous processing is. Let''s demonstrate
    it in the code. Similar to the way we submitted the requests to a measuring system,
    we can do it using the `CompletableFuture.supplyAsync()` static method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CompletableFuture`对象，我们可以将向测量系统发送数据请求（并创建`CompletableFuture`对象）与从`CompletableFuture`对象获取结果分开。这正是我们在解释异步处理时描述的场景。让我们在代码中演示它。类似于我们提交请求到测量系统的方式，我们可以使用`CompletableFuture.supplyAsync()`静态方法来完成：
- en: '```java'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<CompletableFuture<Double>> list = ids.stream()
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: List<CompletableFuture<Double>> list = ids.stream()
- en: .map(id -> CompletableFuture.supplyAsync(() -> mSys.apply(id)))
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: .map(id -> CompletableFuture.supplyAsync(() -> mSys.apply(id)))
- en: .collect(Collectors.toList());
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: .collect(Collectors.toList());
- en: '```'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The difference is that the `supplyAsync()` method does not wait for the call
    to the measuring system to return. Instead, it immediately creates a `CompletableFuture`
    object and returns it, so that a client can use this object to retrieve the value
    returned by the measuring system at any time. There are also methods that allow
    us to check whether the value was returned at all, but that is not the point of
    this demonstration, which is to show how the `CompletableFuture` class can be
    used to organize asynchronous processing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于`supplyAsync()`方法不会等待调用测量系统返回。相反，它立即创建一个`CompletableFuture`对象并返回，以便客户端可以随时使用该对象检索测量系统返回的值。还有一些方法可以让我们检查值是否已经返回，但这不是这个演示的重点，重点是展示`CompletableFuture`类如何用于组织异步处理。
- en: 'The created list of `CompletableFuture` objects can be stored anywhere. We
    have chosen to store it in a `Map`. In fact, we have created a `sendRequests()` method
    that can send any number of requests to any number of measuring systems:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的`CompletableFuture`对象列表可以存储在任何地方。我们选择将其存储在一个`Map`中。事实上，我们创建了一个`sendRequests()`方法，可以向任意数量的测量系统发送任意数量的请求：
- en: '```java'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Map<Integer, List<CompletableFuture<Double>>>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, List<CompletableFuture<Double>>>
- en: sendRequests(List<List<String>> idLists,
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: sendRequests(List<List<String>> idLists,
- en: List<Function<String, Double>> mSystems){
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: List<Function<String, Double>> mSystems){
- en: LocalTime start = LocalTime.now();
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: LocalTime start = LocalTime.now();
- en: Map<Integer, List<CompletableFuture<Double>>> requests
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, List<CompletableFuture<Double>>> requests
- en: = new HashMap<>();
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: = new HashMap<>();
- en: for(int i = 0; i < idLists.size(); i++){
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: for(int i = 0; i < idLists.size(); i++){
- en: 'for(Function<String, Double> mSys: mSystems){'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 'for(Function<String, Double> mSys: mSystems){'
- en: List<String> ids = idLists.get(i);
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> ids = idLists.get(i);
- en: List<CompletableFuture<Double>> list = ids.stream()
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: List<CompletableFuture<Double>> list = ids.stream()
- en: .map(id -> CompletableFuture.supplyAsync(() -> mSys.apply(id)))
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: .map(id -> CompletableFuture.supplyAsync(() -> mSys.apply(id)))
- en: .collect(Collectors.toList());
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: .collect(Collectors.toList());
- en: requests.put(i, list);
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: requests.put(i, list);
- en: '}'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: long dur = Duration.between(start, LocalTime.now()).toMillis();
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: long dur = Duration.between(start, LocalTime.now()).toMillis();
- en: System.out.println("Submitted in " + dur + " ms");
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("提交时间为" + dur + "毫秒");
- en: return requests;
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 返回请求;
- en: '}'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see, the preceding method accepts two parameters:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，前面的方法接受了两个参数：
- en: '`List<List<String>> idLists`: A collection (list) of lists of sensor IDs, each
    list specific to a particular measuring system.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<List<String>> idLists`：传感器ID列表的集合（列表），每个列表特定于特定的测量系统。'
- en: '`List<Function<String, Double>> mSystems`: List of measuring systems, each
    represented as `Function<String, Double>`, that has a single `apply()` method
    that accepts a sensor ID and returns a double value (measurement result). The
    systems in this list are in the same order as the sensor ID lists in the first
    parameter, so we can match IDs to the system by their positions.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<Function<String, Double>> mSystems`：测量系统的列表，每个系统都表示为`Function<String,
    Double>`，具有一个接受传感器ID并返回双精度值（测量结果）的`apply()`方法。此列表中的系统与第一个参数中的传感器ID列表的顺序相同，因此我们可以通过它们的位置将ID与系统匹配。'
- en: 'Then, we create the `Map<Integer, List<CompletableFuture<Double>>>` object
    to store lists of the `CompletableFuture` objects. We generate them in a `for`-loop,
    and then store them in a `Map` with a key that is just some sequential number.
    The `Map` is returned to the client and can be stored anywhere, for any period
    of time (well, there are some limitations that can be modified, but we are not
    going to discuss them here). Later, when the client has decided to get the results
    of the requests, the `getAverage()` method can be used to retrieve them:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个`Map<Integer, List<CompletableFuture<Double>>>`对象来存储`CompletableFuture`对象的列表。我们在`for`循环中生成它们，然后将它们存储在一个带有顺序号的`Map`中。`Map`被返回给客户端，可以存储在任何地方，任意时间段（好吧，有一些可以修改的限制，但我们不打算在这里讨论它们）。稍后，当客户端决定获取请求的结果时，可以使用`getAverage()`方法来检索它们：
- en: '```java'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void getAverage(Map<Integer, List<CompletableFuture<Double>>> requests){
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: void getAverage(Map<Integer, List<CompletableFuture<Double>>> requests){
- en: 'for(List<CompletableFuture<Double>> list: requests.values()){'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 'for(List<CompletableFuture<Double>> list: requests.values()){'
- en: getAverage(() -> list.stream().map(CompletableFuture::join));
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: getAverage(() -> list.stream().map(CompletableFuture::join));
- en: '}'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The preceding method accepts the `Map` object created by the `sendRequests()` method
    and iterates over all the values (lists of the `ComputableFuture` objects) stored
    in `Map`. For each list, it creates a stream that maps each element (object of `ComputableFuture`)
    to the result of the `join()` method called on the element. This method retrieves
    the value returned from the corresponding call to a measuring system. If the value
    is not available, the method waits for some time (a configurable value), and either
    quits (and returns `null`), or, eventually, receives the value from the call to
    the measuring system, if available. Again, we are not going to discuss all the
    guards placed around failures, to keep the focus on the main functionality.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法接受了`sendRequests()`方法创建的`Map`对象，并迭代存储在`Map`中的所有值（`CompletableFuture`对象的列表）。对于每个列表，它创建一个流，将每个元素（`CompletableFuture`对象）映射到调用该元素的`join()`方法的结果。此方法检索从相应调用测量系统返回的值。如果值不可用，该方法会等待一段时间（可配置的值），然后要么退出（并返回`null`），要么最终接收来自测量系统的值（如果可用）。同样，我们不打算讨论围绕故障的所有保护措施，以便专注于主要功能。
- en: 'The `() -> list.stream().map(CompletableFuture::join)` function is actually
    passed into the `getAverage()` method (which should be familiar to you), which
    we used while processing the streams in the previous example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`()-> list.stream().map(CompletableFuture::join)`函数实际上被传递到`getAverage()`方法中（这对您来说应该是熟悉的），我们在前面的示例中处理流时使用过：'
- en: '```java'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void getAverage(Supplier<Stream<Double>> collectData) {
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: void getAverage(Supplier<Stream<Double>> collectData) {
- en: LocalTime start = LocalTime.now();
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: LocalTime start = LocalTime.now();
- en: double a = collectData.get()
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: double a = collectData.get()
- en: .mapToDouble(Double::valueOf).average().orElse(0);
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: .mapToDouble(Double::valueOf).average().orElse(0);
- en: System.out.println((Math.round(a * 100.) / 100.) + " in " +
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println((Math.round(a * 100.) / 100.) + " in " +
- en: Duration.between(start, LocalTime.now()).toMillis() + " ms");
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Duration.between(start, LocalTime.now()).toMillis() + " ms");
- en: '}'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This method calculates the average of all the values emitted by the passed-in
    stream, prints it, and also captures the time it took to process the stream (and
    calculate the average).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法计算传入流发出的所有值的平均值，打印出来，并且还捕获了处理流（和计算平均值）所花费的时间。
- en: 'Now, let''s use the new methods and see how performance is improved:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用新的方法，看看性能如何提高：
- en: '```java'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Function<String, Double> mSys = id -> {
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Function<String, Double> mSys = id -> {
- en: pauseMs(100);
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: pauseMs(100);
- en: return 10\. + Math.random();
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: return 10\. + Math.random();
- en: '};'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: List<Function<String, Double>> mSystems = List.of(mSys, mSys, mSys);
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: List<Function<String, Double>> mSystems = List.of(mSys, mSys, mSys);
- en: List<List<String>> idLists = List.of(ids, ids, ids);
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: List<List<String>> idLists = List.of(ids, ids, ids);
- en: Map<Integer, List<CompletableFuture<Double>>> requestLists =
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, List<CompletableFuture<Double>>> requestLists =
- en: 'sendRequests(idLists, mSystems);  //prints: Submitted in 13 ms'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 'sendRequests(idLists, mSystems);  //prints: Submitted in 13 ms'
- en: pauseMs(2000);  //The main thread can continue doing something else
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: pauseMs(2000);  //主线程可以继续做其他事情
- en: //for any period of time
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: //for any period of time
- en: 'getAverage(requestLists);               //prints: 10.49 in 5 ms'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'getAverage(requestLists);               //prints: 10.49 in 5 ms'
- en: //        10.61 in 0 ms
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: //        10.61 in 0 ms
- en: //        10.51 in 0 ms
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: //        10.51 in 0 ms
- en: '```'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: For simplicity, we reused the same measuring system (and its IDs) to imitate
    working with three measuring systems. You can see that the requests for all three
    systems are submitted in 13 ms. The `sendRequests()` method exists, and the main
    thread is free to do something else for at least two seconds. That is how much
    time it takes to actually send all the requests and receive the response, because
    of `pauseMs(100)`, used for each call to a measuring system. Then, we calculate
    an average for each system, and it takes almost no time. That is what programmers
    mean when they talk about processing requests asynchronously.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们重用了相同的测量系统（及其ID）来模拟与三个测量系统一起工作。您可以看到所有三个系统的请求在13毫秒内提交。`sendRequests()`方法存在，主线程至少有两秒的空闲时间去做其他事情。这是实际发送所有请求并接收响应所需的时间，因为每次调用测量系统都使用`pauseMs(100)`。然后，我们为每个系统计算平均值，几乎不需要时间。这就是程序员在谈论异步处理请求时的意思。
- en: 'The `CompletableFuture` class has many methods, and has support from several
    other classes and interfaces. For example, the pause period of two seconds to
    collect all of the data can be decreased by using a thread pool:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletableFuture`类有许多方法，并且得到了几个其他类和接口的支持。例如，使用线程池可以减少收集所有数据的两秒暂停时间：'
- en: '```java'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Map<Integer, List<CompletableFuture<Double>>>
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, List<CompletableFuture<Double>>>
- en: sendRequests(List<List<String>> idLists,
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: sendRequests(List<List<String>> idLists,
- en: List<Function<String, Double>> mSystems){
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: List<Function<String, Double>> mSystems){
- en: ExecutorService pool = Executors.newCachedThreadPool();
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ExecutorService pool = Executors.newCachedThreadPool();
- en: LocalTime start = LocalTime.now();
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: LocalTime start = LocalTime.now();
- en: Map<Integer, List<CompletableFuture<Double>>> requests
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, List<CompletableFuture<Double>>> requests
- en: = new HashMap<>();
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: = new HashMap<>();
- en: for(int i = 0; i < idLists.size(); i++){
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: for(int i = 0; i < idLists.size(); i++){
- en: 'for(Function<String, Double> mSys: mSystems){'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'for(Function<String, Double> mSys: mSystems){'
- en: List<String> ids = idLists.get(i);
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> ids = idLists.get(i);
- en: List<CompletableFuture<Double>> list = ids.stream()
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: List<CompletableFuture<Double>> list = ids.stream()
- en: .map(id -> CompletableFuture.supplyAsync(() -> mSys.apply(id),
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: .map(id -> CompletableFuture.supplyAsync(() -> mSys.apply(id),
- en: pool))
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: pool))
- en: .collect(Collectors.toList());
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: .collect(Collectors.toList());
- en: requests.put(i, list);
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: requests.put(i, list);
- en: '}'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: pool.shutdown();
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: pool.shutdown();
- en: long dur = Duration.between(start, LocalTime.now()).toMillis();
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: long dur = Duration.between(start, LocalTime.now()).toMillis();
- en: System.out.println("Submitted in " + dur + " ms");
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("Submitted in " + dur + " ms");
- en: return requests;
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: return requests;
- en: '}'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: There is a variety of such pools, for different purposes and different performances.
    But all of that does not change the overall system design, so we will omit such
    details.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种各样的这样的池，用于不同的目的和不同的性能。但所有这些都不会改变整体系统设计，因此我们将忽略这些细节。
- en: So, the power of asynchronous processing is great. But who benefits from it?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，异步处理的威力是巨大的。但谁从中受益呢？
- en: If you have created an application that collects data and calculates an average
    for each measuring system on demand, then from the client's point of view, it
    still takes a lot of time, because the pause (for two seconds, or less if we use
    a thread pool) is still included in the client's wait time. So, the advantage
    of asynchronous processing is lost for the client, unless you have designed your
    API so that the client can submit the request and walk away to do something else,
    then pick up the results later.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您创建了一个应用程序，根据需要收集数据并计算每个测量系统的平均值，那么从客户端的角度来看，仍然需要很长时间，因为暂停（两秒，或者如果我们使用线程池则更少）仍然包括在客户端的等待时间中。因此，除非您设计了API，以便客户端可以提交请求并离开做其他事情，然后稍后获取结果，否则客户端将失去异步处理的优势。
- en: That is the difference between a *synchronous* (or *blocking)* API, when a client
    waits (blocked) until the result is returned, and an *asynchronous* API, when
    a client submits a request and walks away to do something else, then gets the
    results later.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是*同步*（或*阻塞）API和*异步*API之间的区别，当客户端等待（阻塞）直到结果返回时，以及当客户端提交请求并离开做其他事情，然后稍后获得结果时。
- en: The possibility of an asynchronous API enhances our understanding of latency. Usually,
    by latency, programmers mean the time between the moment the request was submitted
    and the time the first byte of the response has been received *during the same
    call to the API*. But if the API is asynchronous, the definition of latency changes
    to, "The moment the request was submitted and the time the result is available
    for the client to collect." The latency during each call, in such cases, is assumed
    to be much smaller than the time between the call to place the request and the
    call to collect the result.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 异步API的可能性增强了我们对延迟的理解。通常，程序员所说的延迟是指在同一次调用API时，从提交请求到接收到响应的第一个字节所花费的时间。但如果API是异步的，延迟的定义就会变成“请求提交和结果可供客户端收集的时间”。在这种情况下，每次调用的延迟被假定要比发出请求和收集结果之间的时间要小得多。
- en: There is also a notion of the *non-blocking* API, which we are going to discuss
    in the next section.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个*非阻塞*API的概念，我们将在下一节讨论。
- en: Non-blocking
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非阻塞
- en: For the client of an application, the notion of a non-blocking API only tells
    us that the application is probably scalable, reactive, responsive, resilient,
    elastic, and message-driven. In the following sections, we are going to discuss
    all of these terms, but for now, we hope you can derive a sense of what each of
    them means from the names themselves.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序的客户端来说，非阻塞API的概念只告诉我们应用程序可能是可扩展的、反应灵敏的、响应快速的、具有弹性的和消息驱动的。在接下来的章节中，我们将讨论所有这些术语，但现在，我们希望您可以从这些名称本身中得出它们各自的含义。
- en: 'Such a statement means two things:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的陈述意味着两件事：
- en: 'Being non-blocking does not affect the protocol of communication between the
    client and the application: it may be synchronous (blocking) or asynchronous.
    Non-blocking is an implementation detail; it is a view of the API from inside
    the application.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非阻塞不会影响客户端和应用程序之间的通信协议：它可以是同步（阻塞）或异步的。非阻塞是一个实现细节；它是从应用程序内部的API视角来看的。
- en: Non-blocking is the implementation that helps the application to be all of the
    following: scalable, reactive, responsive, resilient, elastic, and message-driven.
    This means it is a very important design concept that resides at the foundation
    of many modern applications.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非阻塞是帮助应用程序成为以下所有特性的实现：可扩展、反应灵敏、响应快速、具有弹性和消息驱动。这意味着它是许多现代应用程序基础的一个非常重要的设计概念。
- en: 'It''s know that blocking APIs and non-blocking APIs are not opposites. They
    describe different aspects of the application. The blocking API describes how
    a client interacts with it: the client calls, and stays connected until the response
    is provided. The non-blocking API describes how the application is implemented:
    it does not dedicate an execution thread to each of the requests, but provides
    several lightweight worker threads that do the processing asynchronously and concurrently.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，阻塞API和非阻塞API并不是对立的。它们描述了应用程序的不同方面。阻塞API描述了客户端与之交互的方式：客户端调用并保持连接，直到提供响应。非阻塞API描述了应用程序的实现方式：它不为每个请求分配执行线程，而是提供多个轻量级工作线程，以异步和并发的方式进行处理。
- en: The term non-blocking came into use with the `java.nio` (NIO stands for non-blocking
    input/output) package that provides support for intensive input/output (I/O) operations.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞这个术语是随着提供对密集输入/输出（I/O）操作支持的`java.nio`（NIO代表非阻塞输入/输出）包的使用而出现的。
- en: The java.io versus java.nio package
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: java.io与java.nio包
- en: Writing and reading data to and from external memory (a hard drive, for example)
    is a much slower operation than other processes that happen in the memory. The
    already existing classes and interfaces of the `java.io` package worked fine,
    but once in a while, the performance would bottleneck. The new `java.nio` package
    was created to provide more effective I/O support.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 向外部存储器（例如硬盘）写入和读取数据比在内存中进行的其他进程要慢得多。`java.io`包中已经存在的类和接口运行良好，但偶尔性能会出现瓶颈。新的`java.nio`包被创建出来以提供更有效的I/O支持。
- en: The `java.io` implementation was based on stream processing, which, as we saw
    in the previous section, is basically a blocking operation, even if some kind
    of concurrency is happening behind the scenes. To increase the speed, the `java.nio`
    implementation was based on reading/writing to/from a buffer in the memory. Such
    a design allowed us to separate the slow process of filling/emptying the buffer
    and the fast reading/writing from/to it. In a way, it is similar to what we have
    done in our example of the `CompletableFuture` class usage. The additional advantage
    of having data in a buffer is that it is possible to inspect it, going there and
    back along the buffer, which is impossible when reading sequentially from the
    stream. It has allowed for more flexibility during data processing.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.io`的实现是基于流处理的，正如我们在前一节中看到的，即使在幕后进行了某种并发操作，它基本上仍然是一个阻塞操作。为了提高速度，`java.nio`的实现是基于在内存中读取/写入缓冲区。这样的设计使我们能够将填充/清空缓冲区的缓慢过程与从中快速读取/写入的过程分开。在某种程度上，这类似于我们在`CompletableFuture`类使用示例中所做的。拥有缓冲区中的数据的额外优势是可以检查它，来回沿着缓冲区进行操作，而从流中顺序读取时是不可能的。这使得在数据处理过程中更加灵活。'
- en: In addition, the `java.nio` implementation introduced another middleman process,
    called a channel, which provided bulk data transfers to and from buffers. The
    reading thread gets data from a channel, and only receives what is currently available,
    or nothing at all (if there is no data is in the channel). If data is not available,
    the thread, instead of remaining blocked, can do something else—reading/writing
    to/from other channels, for example. The same way the main thread in our `CompletableFuture` example
    was free to do whatever had to be done while the measuring system was reading
    data from its sensors. This way, instead of dedicating a thread to one I/O process,
    a few worker-threads can serve many I/O processes.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`java.nio`实现引入了另一个中间过程，称为通道，它提供了与缓冲区的批量数据传输。读取线程从通道获取数据，并且只接收当前可用的数据，或者根本没有数据（如果通道中没有数据）。如果数据不可用，线程可以做其他事情，而不是保持阻塞状态，例如读取/写入其他通道。就像我们的`CompletableFuture`示例中的主线程在测量系统从传感器中读取数据时可以自由进行其他操作。这样，与将一个线程专用于一个I/O进程不同，几个工作线程可以为多个I/O进程提供服务。
- en: Such a solution was called a non-blocking I/O, and was later applied to other
    processes, the most prominent being the events processing in an *event loop*,
    also called a *run loop*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的解决方案被称为非阻塞I/O，后来被应用于其他进程，其中最突出的是事件循环中的事件处理，也称为运行循环。
- en: Event loop, or run loop
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件循环，或运行循环
- en: Many non-blocking systems of processing are based on the event (or run) loop—a
    thread that is continually executed, receives events (requests, messages), and
    then dispatches them to the corresponding *event handlers*. There is nothing special
    about the event handlers. They are just methods (functions) dedicated, by the
    programmer, for processing a particular event type.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 许多非阻塞处理系统都基于事件（或运行）循环——一个不断执行的线程，接收事件（请求、消息），然后将它们分派给相应的*事件处理程序*。事件处理程序没有什么特别之处。它们只是由程序员专门用于处理特定事件类型的方法（函数）。
- en: This design is called a *reactor design pattern*, defined as *an event handling
    pattern for handling service requests delivered concurrently to a service handler.* It
    also provided the name for the *reactive programming* and *reactive systems* that
    *react* to some events, and process them accordingly. We will talk about reactive
    systems later, in a dedicated section.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计被称为*反应器设计模式*，定义为*用于处理并发传递给服务处理程序的服务请求的事件处理模式*。它还为*反应式编程*和*反应式系统*提供了名称，这些系统对某些事件做出*反应*并相应地处理它们。我们将在专门的部分中稍后讨论反应式系统。
- en: Event loop-based design is widely used in operating systems and graphical user
    interfaces. It is available in Spring WebFlux in Spring 5, and implemented in
    JavaScript and its popular executing environment, Node.js. The last one uses an
    event loop as its processing backbone. The Vert.x toolkit is built around the
    event loop, too. We will show some examples of the latter in the *Microservices*
    section.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 基于事件循环的设计在操作系统和图形用户界面中被广泛使用。它在Spring 5的Spring WebFlux中可用，并在JavaScript及其流行的执行环境Node.js中实现。最后一个使用事件循环作为其处理骨干。Vert.x工具包也是围绕事件循环构建的。我们将在“微服务”部分展示后者的一些示例。
- en: Before the adoption of the event loop, a dedicated thread was assigned to each
    incoming request—much like in our demonstration of stream processing. Each of
    the threads requires the allocation of a certain amount of resources that is not
    request-specific, so some of the resources—mostly memory allocation—are wasted.
    Then, as the number of requests grows, the CPU needs to switch its context from
    one thread to another more often, to allow more or less concurrent processing
    of all the requests. Under the load, the overhead of switching the context becomes
    substantial enough to affect the performance of an application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在采用事件循环之前，每个传入请求都分配了一个专用线程，就像我们在流处理演示中所做的那样。每个线程都需要分配一定数量的资源，这些资源与请求无关，因此一些资源（主要是内存分配）被浪费了。然后，随着请求数量的增加，CPU需要更频繁地切换上下文，以允许更多或更少的并发处理所有请求。在负载下，上下文切换的开销变得足够大，以至于影响应用程序的性能。
- en: 'Implementing an event loop has addressed these two issues:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 实现事件循环解决了这两个问题：
- en: It eliminated the waste of resources by avoiding the creation of a thread dedicated
    to each request, and keeping it around until the request was processed. With an
    event loop in place, a much smaller memory allocation is needed for each request
    to capture its specifics. It made it possible to keep many more requests in memory,
    so that they can be processed concurrently.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过避免为每个请求创建一个专用线程并保持线程直到请求被处理，从而消除了资源的浪费。有了事件循环，每个请求只需要一个更小的内存分配来捕获其具体信息。这使得可以在内存中保留更多的请求，以便可以并发处理它们。
- en: The overhead of the CPU context-switching became much smaller, too, because
    of the diminishing context size.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU上下文切换的开销也变得更小了，因为上下文大小减小了。
- en: The non-blocking API is how the processing of the requests is implemented. With
    it, the systems are able to handle a much bigger load (to be more scalable and
    elastic), while remaining highly responsive and resilient.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞API是如何实现请求处理的。有了它，系统能够处理更大的负载（更具可伸缩性和弹性），同时保持高度的响应和弹性。
- en: Distributed
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式
- en: The notion of what is distributed has changed over time. It used to mean an
    application running on several computers, connected via a network. It even had
    the synonym name of  parallel computing, because each instance of the application
    did the same thing. Such an application improved system resilience. The failure
    of one computer did not affect the system as a whole.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，分布式的概念也发生了变化。它曾经意味着在多台计算机上运行的应用程序，通过网络连接。它甚至有一个同义词叫做并行计算，因为应用程序的每个实例都在做同样的事情。这样的应用程序提高了系统的弹性。一台计算机的故障不会影响整个系统。
- en: 'Then, another meaning was added: an application spread across several computers,
    so each of its components contributed to the result produced by the application
    as a whole. Such a design was usually used for the calculation- or data-heavy
    tasks that required a lot of CPU power, or required lots of data from many different
    sources.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，又添加了另一层含义：一个应用程序分布在多台计算机上，因此其每个组件都对应用程序整体产生的结果有所贡献。这种设计通常用于需要大量CPU计算能力或需要来自许多不同来源的大量数据的计算或数据密集型任务。
- en: When a single CPU became powerful enough to handle the computation load of thousands
    of older computers and cloud computing, especially systems such as AWS Lambda
    serverless computing platforms, it removed the notion of an individual computer
    from consideration at all; *distributed* may mean any combination of one application,
    or its components, running on one, or many, computers.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当单个CPU变得足够强大，可以处理成千上万台旧计算机的计算负载，尤其是云计算，特别是像AWS Lambda无服务器计算平台这样的系统，它们完全消除了个人计算机的概念；*分布式*可能意味着一个应用程序或其组件在一个或多台计算机上运行的任何组合。
- en: The examples of a distributed system include big data processing systems, distributed
    file or data storage systems, and ledger systems, such as blockchain or Bitcoin,
    that can also be included in the group of data storage systems under the subcategory
    of *smart* data storage systems.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统的例子包括大数据处理系统、分布式文件或数据存储系统以及分类帐系统，如区块链或比特币，也可以包括在*智能*数据存储系统的子类别下的数据存储系统组中。
- en: 'When programmers call a system *distributed* today, they typically mean the
    following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员今天称一个系统为*分布式*时，他们通常指的是以下内容：
- en: The system can tolerate a failure of one, or even several, of its constituting
    components.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统可以容忍其构成组件的一个或甚至多个失败。
- en: Each system component has only a limited, incomplete view of the system.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个系统组件只能看到系统的有限不完整视图。
- en: The structure of the system is dynamic, and may change during the execution.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的结构是动态的，并且在执行过程中可能会发生变化。
- en: The system is scalable.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统是可扩展的。
- en: Scalable
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展
- en: 'Scalability is the ability to sustain a growing load without significant degradation
    of the latency/throughput. Traditionally, it was achieved by breaking the software
    system into tiers: a front tier, middle tier, and backend tier, for example. Each
    tier was composed of multiple deployments of the copies of the same group of components
    responsible for the particular type of processing.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性是在不显著降低延迟/吞吐量的情况下承受不断增加的负载的能力。传统上，这是通过将软件系统分解为层来实现的：前端层、中间层和后端层，例如。每个层由负责特定类型处理的相同组件组的多个部署副本组成。
- en: The front tier components were responsible for the presentation, based on the
    request and the data they received from the middle tier. The middle tier components
    were responsible for computations and decision-making, based on the data coming
    from the front tier and the data they could read from the backend tier. They also
    sent data to the backend for storage. The backend tier stored the data, and provided
    it to the middle tier.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 前端组件负责基于请求和从中间层接收到的数据进行呈现。中间层组件负责基于来自前端层的数据和它们可以从后端层读取的数据进行计算和决策。它们还将数据发送到后端进行存储。后端层存储数据，并将其提供给中间层。
- en: Adding copies of components, each tier allowed us to stay abreast with the increasing
    load. In the past, it was only possible by adding more computers to each tier.
    Otherwise, there would be no resources available for the newly deployed components'
    copies.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加组件的副本，每个层允许我们跟上不断增加的负载。过去，只能通过向每个层添加更多计算机来实现。否则，新部署的组件副本将没有可用资源。
- en: But, with the introduction of cloud computing, and especially the AWS Lambda
    services, scalability is achieved by adding only new copies of the software components.
    The fact that more computers are added to the tier (or not) is hidden from the
    deployer.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，随着云计算的引入，尤其是AWS Lambda服务，可扩展性是通过仅添加软件组件的新副本来实现的。增加了更多计算机到层中（或者没有）对部署者来说是隐藏的。
- en: Another recent trend in distributed-system architecture allowed us to fine-tune
    the scalability by scaling up not only by a tier, but also by a particular small,
    functional part of a tier, and providing one, or several, particular kinds of
    services, called microservices. We will discuss this and show some examples of
    microservices in the *Microservices* section.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统架构中的另一个最近的趋势允许我们通过扩展不仅通过层，而且通过特定的小型功能部分来微调可扩展性，并提供一种或多种特定类型的服务，称为微服务。我们将在*微服务*部分讨论这一点，并展示一些微服务的示例。
- en: With such an architecture, the software system becomes a composition of many
    microservices; each may be duplicated as many times as needed, to support the
    required increase in the processing power. In this sense, we can talk about scalability
    on the level of one microservice only.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的架构下，软件系统变成了许多微服务的组合；每个微服务可以根据需要复制多次，以支持所需的处理能力增加。在这个意义上，我们只能谈论一个微服务的可扩展性。
- en: Reactive
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式
- en: The term *reactive* is usually used in the context of reactive programming and
    reactive systems. Reactive programming (also called Rx programming) is based on
    programming with asynchronous data streams (also called reactive streams). It
    was introduced to Java in the `java.util.concurrent` package, with Java 9\. It
    allows a `Publisher` to generate a stream of data, to which a `Subscriber` can
    asynchronously subscribe.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*反应式*通常用于反应式编程和反应式系统的上下文中。反应式编程（也称为Rx编程）是基于使用异步数据流（也称为反应式流）进行编程。它在Java 9中引入了`java.util.concurrent`包。它允许`Publisher`生成数据流，`Subscriber`可以异步订阅。
- en: 'As you have seen, we were able to process data asynchronously even without
    this new API, by using `CompletableFuture`. But, after writing such a code a few
    times, one notices that most of it is just plumbing, so one gets the feeling there
    has to be an even simpler and more convenient solution. That''s how the Reactive
    Streams initiative ([http://www.reactive-streams.org](http://www.reactive-streams.org))
    was born. The scope of the effort is defined as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，即使没有这个新的API，我们也能够异步处理数据，使用`CompletableFuture`。但是，写了几次这样的代码后，人们会注意到其中大部分只是管道工作，因此人们会觉得一定有更简单、更方便的解决方案。这就是Reactive
    Streams倡议([http://www.reactive-streams.org](http://www.reactive-streams.org))的诞生。该努力的范围定义如下：
- en: The scope of Reactive Streams is to find a minimal set of interfaces, methods and protocols
    that will describe the necessary operations and entities to achieve the goal—asynchronous streams
    of data with non-blocking back pressure.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Reactive Streams的范围是找到一组最小的接口、方法和协议，描述必要的操作和实体，以实现异步数据流和非阻塞背压。
- en: The term *non-blocking back pressure* refers to one of the problems of asynchronous
    processing—a coordination of the speed rate of the incoming data with the ability
    of the system to process it, without the need to stop (block) the data input.
    The solution is to inform the source that the consumer has a difficulty in keeping
    up with the input, but the processing should react to the change of the rate of
    incoming data in a more flexible manner than just blocking the flow (thus, the
    name reactive).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*非阻塞背压*指的是异步处理的问题之一——协调传入数据的速率与系统处理数据的能力，而无需停止（阻塞）数据输入。解决方案是通知源，消费者在跟上输入的速率方面有困难，但处理应该对传入数据速率的变化做出更灵活的反应，而不仅仅是阻塞流（因此称为反应式）。
- en: 'In addition to standard Java libraries, several other libraries already exist
    that implemented the Reactive Streams API: RxJava, Reactor, Akka Streams, and
    Vert.x are among the most known. We will use RxJava 2.1.13 in our examples. You
    can find the RxJava 2.x API at [http://reactivex.io](http://reactivex.io), under
    the name ReactiveX, which stands for Reactive Extension.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准的Java库，已经存在几个实现了Reactive Streams API的其他库：RxJava、Reactor、Akka Streams和Vert.x是其中最知名的。我们将在我们的示例中使用RxJava
    2.1.13。您可以在[http://reactivex.io](http://reactivex.io)找到RxJava 2.x API，名称为ReactiveX，代表Reactive
    Extension。
- en: 'Let''s first compare two implementations of the same functionality, using the `java.util.stream`
    package and the `io.reactivex` package of RxJava 2.1.13, which can be added to
    the project with the following dependency:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先比较使用`java.util.stream`包和RxJava 2.1.13的`io.reactivex`包实现相同功能的两种方式，可以通过以下依赖项添加到项目中：
- en: '```java'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: <dependency>
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: <dependency>
- en: <groupId>io.reactivex.rxjava2</groupId>
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: <groupId>io.reactivex.rxjava2</groupId>
- en: <artifactId>rxjava</artifactId>
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: <artifactId>rxjava</artifactId>
- en: <version>2.1.13</version>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: <version>2.1.13</version>
- en: </dependency>
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: </dependency>
- en: '```'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The sample program is going to be very simple:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 示例程序将非常简单：
- en: 'Create a stream of integers: 1, 2, 3, 4, 5.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个整数流：1、2、3、4、5。
- en: Filter only even numbers (2 and 4).
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅过滤偶数（2和4）。
- en: Calculate the square root of each of the filtered numbers.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算每个过滤后的数字的平方根。
- en: Calculate the sum of all the square roots.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算所有平方根的和。
- en: 'Here is how it can be implemented using the `java.util.stream` package:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`java.util.stream`包实现的方式：
- en: '```java'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: double a = IntStream.rangeClosed(1, 5)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: double a = IntStream.rangeClosed(1, 5)
- en: .filter(i -> i % 2 == 0)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: .filter(i -> i % 2 == 0)
- en: .mapToDouble(Double::valueOf)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: .mapToDouble(Double::valueOf)
- en: .map(Math::sqrt)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: .map(Math::sqrt)
- en: .sum();
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: .sum();
- en: 'System.out.println(a); //prints: 3.414213562373095'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(a); //prints: 3.414213562373095'
- en: '```'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And the same functionality implemented with RxJava looks as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RxJava实现相同功能的方式如下：
- en: '```java'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Observable.range(1, 5)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Observable.range(1, 5)
- en: .filter(i -> i % 2 == 0)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: .filter(i -> i % 2 == 0)
- en: .map(Math::sqrt)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: .map(Math::sqrt)
- en: .reduce((r, d) -> r + d)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: .reduce((r, d) -> r + d)
- en: '.subscribe(System.out::println); //prints: 3.414213562373095'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '.subscribe(System.out::println); //prints: 3.414213562373095'
- en: RxJava is based on the Observable object (which plays the role of Publisher)
    and Observer that subscribes to the Observable and waits for data to be emitted.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava基于Observable对象（扮演发布者的角色）和Observer订阅Observable并等待数据被发出。
- en: '```'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In addition to the `Stream` functionality, `Observable` has significantly different
    capabilities. For example, a stream, once closed, cannot be reopened, while an
    `Observable` object can be used again. Here is an example:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Stream`功能外，`Observable`具有显著不同的功能。例如，流一旦关闭，就无法重新打开，而`Observable`对象可以再次使用。这是一个例子：
- en: '```java'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Observable<Double> observable = Observable.range(1, 5)
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Observable<Double> observable = Observable.range(1, 5)
- en: .filter(i -> i % 2 == 0)
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: .filter(i -> i % 2 == 0)
- en: .doOnNext(System.out::println)    //prints 2 and 4 twice
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: .doOnNext(System.out::println)    //打印2和4两次
- en: .map(Math::sqrt);
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: .map(Math::sqrt);
- en: observable
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: observable
- en: .reduce((r, d) -> r + d)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: .reduce((r, d) -> r + d)
- en: '.subscribe(System.out::println);  //prints: 3.414213562373095'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '.subscribe(System.out::println);  //prints: 3.414213562373095'
- en: observable
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: observable
- en: .reduce((r, d) -> r + d)a
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: .reduce((r, d) -> r + d)a
- en: .map(r -> r / 2)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: .map(r -> r / 2)
- en: '.subscribe(System.out::println);  //prints: 1.7071067811865475'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '.subscribe(System.out::println);  //prints: 1.7071067811865475'
- en: '```'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In the preceding example, as you can see from the comments, the `doOnNext()`
    operation was called twice, which means the `observable` object emitted values
    twice. But if we do not want `Observable` running twice, we can cache its data
    by adding the `cache()` operation:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，从注释中可以看出，`doOnNext()`操作被调用了两次，这意味着`observable`对象发出了两次值。但是，如果我们不希望`Observable`运行两次，我们可以通过添加`cache()`操作来缓存其数据：
- en: '```java'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Observable<Double> observable = Observable.range(1,5)
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Observable<Double> observable = Observable.range(1,5)
- en: .filter(i -> i % 2 == 0)
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: .filter(i -> i % 2 == 0)
- en: .doOnNext(System.out::println)  //prints 2 and 4 only once
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: .doOnNext(System.out::println)  //只打印2和4一次
- en: .map(Math::sqrt)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: .map(Math::sqrt)
- en: .cache();
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: .cache();
- en: observable
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: observable
- en: .reduce((r, d) -> r + d)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: .reduce((r, d) -> r + d)
- en: '.subscribe(System.out::println); //prints: 3.414213562373095'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '.subscribe(System.out::println); //prints: 3.414213562373095'
- en: observable
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: observable
- en: .reduce((r, d) -> r + d)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: .reduce((r, d) -> r + d)
- en: .map(r -> r / 2)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: .map(r -> r / 2)
- en: '.subscribe(System.out::println);  //prints: 1.7071067811865475'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: .subscribe(System.out::println);  //打印：1.7071067811865475
- en: '```'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, the second usage of the same `Observable` took advantage of
    the cached data, allowing for better performance. There is more functionality
    available in the `Observable` interface and RxJava, which the format of this book
    does not allow us to describe. But we hope you get the idea.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，同一个`Observable`的第二次使用利用了缓存数据，从而提高了性能。`Observable`接口和RxJava中还有更多功能，但本书的格式不允许我们进行描述。但我们希望你能理解。
- en: Writing code using RxJava, or another asynchronous-streams library, constitutes
    reactive programming. It realizes the goal declared in the Reactive Manifesto
    ([https://www.reactivemanifesto.org](https://www.reactivemanifesto.org)) as building
    reactive systems that are responsive, resilient, elastic, and message-driven.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RxJava或其他异步流库编写代码构成了反应式编程。它实现了反应式宣言中所宣布的目标，即构建具有响应性、弹性、弹性和消息驱动的反应式系统。
- en: Responsive
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式
- en: It seems that this term is self-explanatory. The ability to respond in a timely
    manner is one of the primary qualities every client demands from any system. It
    is possible to achieve this using many different approaches. Even traditional
    blocking APIs can be supported by enough servers and other infrastructure, to
    provide the expected responsiveness under a very big load. Reactive programming
    just helps to do it using less hardware.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个术语似乎是不言自明的。及时响应的能力是每个客户对任何系统的首要要求之一。可以通过许多不同的方法来实现这一点。即使传统的阻塞API也可以通过足够的服务器和其他基础设施来支持，以在非常大的负载下提供预期的响应性。反应式编程只是帮助使用更少的硬件来实现这一点。
- en: It comes with a price, as reactive code requires changing the way we used to
    do it, even five years ago. But after some time, this new way of thinking becomes
    as natural as any other already-familiar skill. We will see a few more examples
    of reactive programming in the following sections.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有代价的，因为反应式代码需要改变我们过去的做法，甚至是五年前的做法。但过一段时间，这种新的思维方式就会变得和任何其他已经熟悉的技能一样自然。我们将在接下来的章节中看到更多反应式编程的例子。
- en: Resilient
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性
- en: Failures are inevitable. The hardware crashes, the software has defects, unexpected
    data is received, or an unexpected and poorly-tested execution path was taken—any
    of these events, or a combination of them, can happen at any time. Resilience
    is the ability of the system to withstand such a situation and continue to deliver
    the expected results.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 失败是不可避免的。硬件崩溃，软件有缺陷，接收到意外数据，或者采取了意外和未经充分测试的执行路径——任何这些事件或它们的组合都可能随时发生。弹性是系统在这种情况下继续提供预期结果的能力。
- en: It can be achieved using redundancy of the deployable components and hardware,
    using isolation of parts of the system from each other (so the domino effect becomes
    less probable), designing the system so that the lost piece can be replaced automatically
    or an appropriate alarm raised so that qualified personnel can interfere, and
    through other measures.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过部署组件和硬件的冗余、系统各部分的隔离（减少多米诺效应的可能性）、设计系统使得丢失的部分可以自动替换或者引发适当的警报以便合格人员干预等措施来实现。
- en: We have talked about distributed systems already. Such an architecture makes
    the system more resilient by eliminating a single point of failure. Also, breaking
    the system into many specialized components that talk to each other using messages
    allows for a better tuning of the duplication of the most critical parts, and
    creates more opportunities for their isolation and potential failure containment.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经谈论过分布式系统。这样的架构通过消除单点故障使系统更具弹性。此外，将系统分解为许多专门的组件，并使用消息相互通信，可以更好地调整最关键部分的复制，并为其隔离和潜在故障容纳创造更多机会。
- en: Elastic
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性
- en: The ability to sustain the biggest possible load is usually associated with
    scalability. But the ability to preserve the same performance characteristics
    under varying loads is called elasticity. A client of an elastic system should
    not notice any difference between the idle periods and the periods of the peak
    load.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 承受最大负载的能力通常与可伸缩性相关。但在不同负载下保持相同性能特征的能力被称为弹性。弹性系统的客户不应该注意到空闲时期和高峰负载时期之间的任何差异。
- en: The non-blocking reactive style of implementation facilitates this quality.
    Also, breaking the program into smaller parts and converting them into services
    that can be deployed and managed independently allows for fine-tuning the resource
    allocation. Such small services are called microservices, and many of them can together
    comprise a reactive system that can be both scalable and elastic. We will discuss
    these solutions in more detail in the following sections.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞的反应式实现风格有助于实现这一质量。此外，将程序分解为更小的部分并将其转换为可以独立部署和管理的服务，可以进行资源分配的微调。这些小服务被称为微服务，许多微服务可以组成一个既可扩展又具有弹性的反应式系统。我们将在接下来的章节中更详细地讨论这些解决方案。
- en: Message-driven
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息驱动
- en: We have already established that the components' isolation and system distribution
    are two aspects that help to keep the system responsive, resilient, and elastic.
    Loose and flexible connections is an important condition that supports these qualities,
    too. And the asynchronous nature of the reactive system simply does not leave
    the designer any other choice but to build communication between components on
    messages.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了组件的隔离和系统分布是保持系统响应、弹性和弹性的两个方面。松散和灵活的连接也是支持这些特性的重要条件。而反应式系统的异步性质简单地不给设计者留下其他选择，只能在组件之间建立消息通信。
- en: It creates a *breathing space* around each component, without which the system
    would be a tightly coupled monolith, susceptible to all kinds of problems, not
    to mention a maintenance nightmare.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 它为每个组件创建了一个“呼吸空间”，没有这个空间，系统将成为一个紧密耦合的单体，容易受到各种问题的影响，更不用说维护上的噩梦了。
- en: With that, we are going to look at the architectural style that can be used
    to build an application as a collection of loosely coupled services that provide
    the required business functionality—microservices.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们将研究可以用来构建应用程序的架构风格，作为提供所需业务功能的松散耦合服务的集合——微服务。
- en: Microservices
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: 'In order for a deployable unit of code to be qualified as a microservice, it
    has to possess the following characteristics:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使一个可部署的代码单元有资格成为微服务，它必须具备以下特征：
- en: The size of the source code of one microservice should be smaller than the size
    of a traditional application. Another size criteria is that one programmer's team
    should be able to write and support several of them.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个微服务的源代码大小应该小于传统应用程序的大小。另一个大小标准是一个程序员团队应该能够编写和支持其中的几个。
- en: It has to be deployed independently. Naturally, one microservice typically cooperates
    and expects cooperation from other systems, but that should not prevent our ability
    to deploy it.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须能够独立部署。通常，一个微服务通常会合作并期望其他系统的合作，但这不应该妨碍我们部署它的能力。
- en: If a microservice uses a database to store data, it has to have its own schema,
    or a set of tables. This statement is still under debate, especially in cases
    when several services modify the same data set or interdependent datasets. If
    the same team owns all of the related services, it is easier to accomplish. Otherwise,
    there are several possible strategies to ensure independent microservice development
    and deployment.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个微服务使用数据库存储数据，它必须有自己的模式或一组表。这个说法仍在争论中，特别是在几个服务修改相同数据集或相互依赖的数据集的情况下。如果同一个团队拥有所有相关服务，那么更容易实现。否则，有几种可能的策略来确保独立的微服务开发和部署。
- en: It has to be stateless, in the sense that its state should not be kept in memory,
    unless the memory is shared. If one instance of the service has failed, another
    should be able to accomplish what was expected from the service.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须是无状态的，即其状态不应保存在内存中，除非内存是共享的。如果服务的一个实例失败了，另一个实例应该能够完成服务所期望的工作。
- en: It should provide a way to check its *health*—that the service is up and running
    and ready to do the job.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该提供一种检查其*健康*的方式——即服务是否正常运行并准备好执行工作。
- en: That said, let's look over the field of toolkits for microservice implementation.
    One can definitely write microservices from scratch, but before doing that, it
    is always worth looking at what is out there already, even if you find that nothing
    fits your particular needs.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，让我们来看看微服务实现的工具包领域。一个人肯定可以从头开始编写微服务，但在这之前，值得看看已经存在的东西，即使你发现没有什么符合你特定需求的。
- en: The two most popular toolkits are Spring Boot ([https://projects.spring.io/spring-boot](https://projects.spring.io/spring-boot))
    and raw J2EE. The J2EE community founded the MicroProfile ([https://microprofile.io](https://microprofile.io))
    initiative, with a declared goal of optimizing Enterprise Java for a microservices
    architecture. KumuluzEE ([https://ee.kumuluz.com](https://ee.kumuluz.com)) is
    a lightweight open source microservice framework, compliant with MicroProfile.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 两个最流行的工具包是Spring Boot（[https://projects.spring.io/spring-boot](https://projects.spring.io/spring-boot)）和原始的J2EE。J2EE社区成立了MicroProfile（[https://microprofile.io](https://microprofile.io)）倡议，旨在优化企业Java以适应微服务架构。KumuluzEE（[https://ee.kumuluz.com](https://ee.kumuluz.com)）是一个轻量级的符合MicroProfile标准的开源微服务框架。
- en: 'A list of some other frameworks, libraries, and toolkits includes the following
    (in alphabetical order):'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他框架、库和工具包的列表如下（按字母顺序排列）：
- en: '**Akka**: A toolkit for building highly concurrent, distributed, and resilient
    message-driven applications for Java and Scala ([https://akka.io/](https://akka.io/)).'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Akka**：用于构建高并发、分布式和具有弹性的Java和Scala消息驱动应用程序的工具包（[https://akka.io/](https://akka.io/)）。'
- en: '**Bootique**: A minimally opinionated framework for runnable Java applications
    ([https://bootique.io/](https://bootique.io/)).'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bootique**：用于可运行Java应用程序的最小化框架（[https://bootique.io/](https://bootique.io/)）。'
- en: '**Dropwizard**: A Java framework for developing ops-friendly, high-performance,
    RESTful web services ([https://www.dropwizard.io/](https://www.dropwizard.io/)).'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dropwizard**：用于开发友好运维、高性能、RESTful Web服务的Java框架（[https://www.dropwizard.io/](https://www.dropwizard.io/)）。'
- en: '**Jodd**: A set of Java microframeworks, tools, and utilities, under 1.7 MB
    ([https://jodd.org/](https://jodd.org/)).'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jodd**：一组Java微框架、工具和实用程序，不到1.7 MB（[https://jodd.org/](https://jodd.org/)）。'
- en: '**Lightbend Lagom**: An opinionated microservice framework built on Akka and
    Play ([https://www.lightbend.com/](https://www.lightbend.com/)).'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lightbend Lagom**：基于Akka和Play构建的一种倾向性微服务框架（[https://www.lightbend.com/](https://www.lightbend.com/)）。'
- en: '**Ninja**: A fullstack web framework for Java ([http://www.ninjaframework.org/](http://www.ninjaframework.org/)).'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ninja**：用于Java的全栈Web框架（[http://www.ninjaframework.org/](http://www.ninjaframework.org/)）。'
- en: '**Spotify Apollo**: A set of Java libraries used by Spotify for writing microservices
    ([http://spotify.github.io/apollo/](http://spotify.github.io/apollo/)).'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spotify Apollo**：Spotify用于编写微服务的一组Java库（[http://spotify.github.io/apollo/](http://spotify.github.io/apollo/)）。'
- en: '**Vert.x**: A toolkit for building reactive applications on the JVM ([https://vertx.io/](https://vertx.io/)).'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vert.x**：用于在JVM上构建反应式应用程序的工具包（[https://vertx.io/](https://vertx.io/)）。'
- en: All of the frameworks, libraries, and toolkits listed support HTTP/JSON communication
    between microservices. Some of them also have an additional way of sending messages.
    If they do not, any lightweight messaging system can be used. We mention it here
    because, as you may recall, message-driven asynchronous processing is a foundation
    for the elasticity, responsiveness, and resilience of a reactive system composed
    of microservices.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 所有列出的框架、库和工具包都支持微服务之间的HTTP/JSON通信。其中一些还有额外的消息发送方式。如果没有，可以使用任何轻量级的消息系统。我们在这里提到它，因为你可能还记得，基于消息驱动的异步处理是由微服务组成的反应式系统的弹性、响应性和韧性的基础。
- en: To demonstrate the process of microservice building, we will use Vert.x, an
    event-driven non-blocking lightweight polyglot toolkit (components can be written
    in Java, JavaScript, Groovy, Ruby, Scala, Kotlin, or Ceylon). It supports an asynchronous
    programming model and a distributed event bus that reaches into in-browser JavaScript,
    allowing for the creation of real-time web applications.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示微服务构建的过程，我们将使用Vert.x，这是一个事件驱动的非阻塞轻量级多语言工具包（组件可以用Java、JavaScript、Groovy、Ruby、Scala、Kotlin或Ceylon编写）。它支持异步编程模型和分布式事件总线，可达到浏览器JavaScript，从而实现实时Web应用程序的创建。
- en: Vert.x basics
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vert.x基础知识
- en: 'The building block in Vert.x world is a class that implements the `io.vertx.core.Verticle`
    interface:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vert.x世界中的构建块是实现`io.vertx.core.Verticle`接口的类：
- en: '```java'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: package io.vertx.core;
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: package io.vertx.core;
- en: public interface Verticle {
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: public interface Verticle {
- en: Vertx getVertx();
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Vertx getVertx();
- en: void init(Vertx vertx, Context context);
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: void init(Vertx vertx, Context context);
- en: void start(Future<Void> future) throws Exception;
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: void start(Future<Void> future) throws Exception;
- en: void stop(Future<Void> future) throws Exception;
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: void stop(Future<Void> future) throws Exception;
- en: '}'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The implementation of the preceding interface is called a verticle. Most of
    the method names of the preceding interface are self-explanatory. The `getVertex()` method
    provides access to the `Vertx` object—the entry point into the Vert.x Core API
    that has methods that allow us to build the following functionalities necessary
    for microservice building:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 上述接口的实现称为垂直线。上述接口的大多数方法名称都是不言自明的。`getVertex()`方法提供对`Vertx`对象的访问——这是进入Vert.x
    Core API的入口点，该API具有允许我们构建微服务构建所需的以下功能的方法：
- en: Creating DNS clients
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建DNS客户端
- en: Creating periodic services
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建周期性服务
- en: Creating Datagram sockets
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据报套接字
- en: Deploying and undeploying verticles
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和取消部署垂直线
- en: Providing access to the shared data API
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供对共享数据API的访问
- en: Creating TCP and HTTP clients and servers
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建TCP和HTTP客户端和服务器
- en: Providing access to the event bus and filesystem
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供对事件总线和文件系统的访问
- en: All of the deployed verticles can talk to each other via either standard HTTP
    protocol or using `io.vertx.core.eventbus.EventBus`, forming a system of microservices.
    We will show how one can build a reactive system of microservices using verticles
    and RxJava implementations from the `io.vertx.rxjava` package.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 所有部署的垂直线都可以通过标准的HTTP协议或使用`io.vertx.core.eventbus.EventBus`相互通信，形成一个微服务系统。我们将展示如何使用垂直线和来自`io.vertx.rxjava`包的RxJava实现构建一个响应式微服务系统。
- en: 'A `Verticle` interface implementation can be created easily, by extending the
    `io.vertx.rxjava.core.AbstractVerticle` class:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过扩展`io.vertx.rxjava.core.AbstractVerticle`类轻松创建`Verticle`接口实现：
- en: '```java'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: package io.vertx.rxjava.core;
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: package io.vertx.rxjava.core;
- en: import io.vertx.core.Vertx;
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: import io.vertx.core.Vertx;
- en: import io.vertx.core.Context;
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: import io.vertx.core.Context;
- en: import io.vertx.core.AbstractVerticle
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: import io.vertx.core.AbstractVerticle
- en: public class AbstractVerticle extends AbstractVerticle {
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: public class AbstractVerticle extends AbstractVerticle {
- en: protected io.vertx.rxjava.core.Vertx vertx;
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: protected io.vertx.rxjava.core.Vertx vertx;
- en: public void init(Vertx vertx, Context context) {
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: public void init(Vertx vertx, Context context) {
- en: super.init(vertx, context);
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: super.init(vertx, context);
- en: this.vertx = new io.vertx.rxjava.core.Vertx(vertx);
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: this.vertx = new io.vertx.rxjava.core.Vertx(vertx);
- en: '}'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see, the preceding class extends the `io.vertx.core.AbstractVerticle`
    class:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，上述类扩展了`io.vertx.core.AbstractVerticle`类：
- en: '```java'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: package io.vertx.core;
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: package io.vertx.core;
- en: import java.util.List;
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.List;
- en: import io.vertx.core.Verticle;
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: import io.vertx.core.Verticle;
- en: import io.vertx.core.json.JsonObject;
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: import io.vertx.core.json.JsonObject;
- en: public abstract class AbstractVerticle implements Verticle {
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: public abstract class AbstractVerticle implements Verticle {
- en: protected Vertx vertx;
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: protected Vertx vertx;
- en: protected Context context;
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: protected Context context;
- en: public void init(Vertx vertx, Context context) {
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: public void init(Vertx vertx, Context context) {
- en: this.vertx = vertx;
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: this.vertx = vertx;
- en: this.context = context;
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: this.context = context;
- en: '}'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public Vertx getVertx() { return vertx; }
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: public Vertx getVertx() { return vertx; }
- en: public JsonObject config() { return context.config(); }
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: public JsonObject config() { return context.config(); }
- en: public String deploymentID() { return context.deploymentID(); }
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: public String deploymentID() { return context.deploymentID(); }
- en: public List<String> processArgs() { return context.processArgs(); }
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: public List<String> processArgs() { return context.processArgs(); }
- en: public void start(Future<Void> startFuture) throws Exception {
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: public void start(Future<Void> startFuture) throws Exception {
- en: start();
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: start();
- en: startFuture.complete();
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: startFuture.complete();
- en: '}'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void stop(Future<Void> stopFuture) throws Exception {
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: public void stop(Future<Void> stopFuture) throws Exception {
- en: stop();
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: stop();
- en: stopFuture.complete();
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: stopFuture.complete();
- en: '}'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void start() throws Exception {}
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: public void start() throws Exception {}
- en: public void stop() throws Exception {}
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: public void stop() throws Exception {}
- en: '}'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, all you need to do is extend the `io.vertx.rxjava.core.AbstractVerticle`
    class and implement the `start()` method. The new verticle will be deployable,
    even without implementing the `start()` method,  but it will do nothing useful.
    The code in the `start()` method is the entry point into the functionality of
    your application.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您只需要扩展`io.vertx.rxjava.core.AbstractVerticle`类并实现`start()`方法。新的垂直线将是可部署的，即使没有实现`start()`方法，但它将不会执行任何有用的操作。`start()`方法中的代码是应用功能的入口点。
- en: 'To use Vert.x and execute the examples, the following dependencies have to
    be added to the project:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Vert.x并执行示例，必须将以下依赖项添加到项目中：
- en: '```java'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: <dependency>
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: <dependency>
- en: <groupId>io.vertx</groupId>
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: <groupId>io.vertx</groupId>
- en: <artifactId>vertx-web</artifactId>
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: <artifactId>vertx-web</artifactId>
- en: <version>${vertx.version}</version>
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: <version>${vertx.version}</version>
- en: </dependency>
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: </dependency>
- en: <dependency>
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: <dependency>
- en: <groupId>io.vertx</groupId>
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: <groupId>io.vertx</groupId>
- en: <artifactId>vertx-rx-java</artifactId>
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: <artifactId>vertx-rx-java</artifactId>
- en: <version>${vertx.version}</version>
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: <version>${vertx.version}</version>
- en: </dependency>
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: </dependency>
- en: '```'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The `vertx.version` property can be set in the `properties` section of the `pom.xml` file:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '`vertx.version`属性可以在`pom.xml`文件的`properties`部分中设置：'
- en: '```java'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: <properties>
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: <properties>
- en: <vertx.version>3.5.1</vertx.version>
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: <vertx.version>3.5.1</vertx.version>
- en: </properties>
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: </properties>
- en: '```'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: What makes a verticle reactive is the underlying implementation of an event
    loop (a thread) that receives an event (request) and delivers it to a handler—a
    method in a verticle, or another dedicated class, that is processing this type
    of the event. Programmers typically describe them as functions associated with
    each event type. When a handler returns, the event loop invokes the callback,
    implementing the reactor pattern we talked about in the previous section.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 使垂直反应的是事件循环（线程）的基础实现，它接收事件（请求）并将其传递给处理程序 - 垂直中的方法或另一个专用类，该类正在处理此类型的事件。程序员通常将它们描述为与每种事件类型关联的函数。当处理程序返回时，事件循环调用回调，实现了我们在上一节中讨论的反应器模式。
- en: For certain types of procedures that are blocking by nature (JDBC calls or long
    computations, for example), a worker verticle can be executed asynchronously,
    not through the event loop (so, not to block it), but by a separate thread, using
    the `vertx.executeBlocking()` method. The golden rule of an event loop-based application
    design is, *Don't Block the Event Loop!* Violating this rule stops the application
    in its tracks.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些天生具有阻塞性质的程序（例如JDBC调用或长时间计算），可以通过工作人员垂直异步执行，而不是通过事件循环（因此不会阻塞它），而是通过单独的线程，使用`vertx.executeBlocking()`方法。基于事件循环的应用程序设计的黄金法则是，*不要阻塞事件循环！*违反此规则会使应用程序停滞不前。
- en: The HTTP server as a microservice
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为微服务的HTTP服务器
- en: 'As an example, here is a verticle that acts as an HTTP server:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个充当HTTP服务器的垂直：
- en: '```java'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: package com.packt.javapath.ch18demo.microservices;
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: package com.packt.javapath.ch18demo.microservices;
- en: import io.vertx.rxjava.core.AbstractVerticle;
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: import io.vertx.rxjava.core.AbstractVerticle;
- en: import io.vertx.rxjava.core.http.HttpServer;
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: import io.vertx.rxjava.core.http.HttpServer;
- en: public class HttpServer1 extends AbstractVerticle{
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: public class HttpServer1 extends AbstractVerticle{
- en: private int port;
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: private int port;
- en: public HttpServer1(int port) {
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: public HttpServer1(int port) {
- en: this.port = port;
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: this.port = port;
- en: '}'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void start() throws Exception {
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: public void start() throws Exception {
- en: HttpServer server = vertx.createHttpServer();
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: HttpServer server = vertx.createHttpServer();
- en: server.requestStream().toObservable()
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: server.requestStream().toObservable()
- en: .subscribe(request -> request.response()
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: .subscribe(request -> request.response()
- en: .end("Hello from " + Thread.currentThread().getName() +
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: .end("Hello from " + Thread.currentThread().getName() +
- en: '" on port " + port + "!\n\n"));'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '" on port " + port + "!\n\n"));'
- en: server.rxListen(port).subscribe();
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: server.rxListen(port).subscribe();
- en: System.out.println(Thread.currentThread().getName() +
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Thread.currentThread().getName() +
- en: '" is waiting on port " + port + "...");'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '"正在等待端口" + port + "...");'
- en: '}'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In the preceding code, the server is created, and the stream of data from a
    possible request is wrapped into an `Observable`. The data emitted by the `Observable`
    is passed to the function (a request handler) that processes the request and generates
    a necessary response. We also told the server which port to listen to, and can now
    deploy several instances of this verticle, to listen on different ports:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，创建了服务器，并将可能请求的数据流包装成`Observable`。由`Observable`发出的数据传递给处理请求并生成必要响应的函数（请求处理程序）。我们还告诉服务器要监听的端口，并且现在可以部署此垂直的多个实例，以侦听不同的端口：
- en: '```java'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: vertx().getDelegate().deployVerticle(new HttpServer1(8082));
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: vertx().getDelegate().deployVerticle(new HttpServer1(8082));
- en: vertx().getDelegate().deployVerticle(new HttpServer1(8083));
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: vertx().getDelegate().deployVerticle(new HttpServer1(8083));
- en: '```'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'There is also an `io.vertx.rxjava.core.RxHelper` helper class that can be used
    for deployment. It takes care of some of the details that are not important for
    the current discussion:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`io.vertx.rxjava.core.RxHelper`助手类，可用于部署。它处理了一些对当前讨论不重要的细节：
- en: '```java'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: RxHelper.deployVerticle(vertx(), new HttpServer1(8082));
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: RxHelper.deployVerticle(vertx(), new HttpServer1(8082));
- en: RxHelper.deployVerticle(vertx(), new HttpServer1(8083));
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: RxHelper.deployVerticle(vertx(), new HttpServer1(8083));
- en: '```'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Whichever method is used, you will see the following messages:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪种方法，您都将看到以下消息：
- en: '```java'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: vert.x-eventloop-thread-0 is waiting on port 8082...
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: vert.x-eventloop-thread-0正在等待端口8082...
- en: vert.x-eventloop-thread-0 is waiting on port 8083...
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: vert.x-eventloop-thread-0正在等待端口8083...
- en: '```'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'These messages confirm what we had expected: the same event loop thread is
    listening on both ports. We can now place a request to any of the running servers,
    using the standard `curl` command, for example:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这些消息确认了我们的预期：同一事件循环线程正在两个端口上监听。现在，我们可以使用标准的`curl`命令向任何正在运行的服务器发送请求：
- en: '```java'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: curl localhost:8082
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: curl localhost:8082
- en: '```'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The response is going to be the one we hardcoded:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将是我们硬编码的响应：
- en: '```java'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Hello from vert.x-eventloop-thread-0 on port 8082!
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 从端口8082上的vert.x-eventloop-thread-0问好！
- en: '```'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Periodic service as a microservice
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 周期性服务作为微服务
- en: 'Vert.x also allows us to create a periodic service, which does something at
    a regular interval. Here is an example:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x还允许我们创建一个定期服务，该服务会定期执行某些操作。这是一个例子：
- en: '```java'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: package com.packt.javapath.ch18demo.microservices;
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: package com.packt.javapath.ch18demo.microservices;
- en: import io.vertx.rxjava.core.AbstractVerticle;
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: import io.vertx.rxjava.core.AbstractVerticle;
- en: import java.time.LocalTime;
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: import java.time.LocalTime;
- en: import java.time.temporal.ChronoUnit;
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: import java.time.temporal.ChronoUnit;
- en: public class PeriodicService1 extends AbstractVerticle {
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: public class PeriodicService1 extends AbstractVerticle {
- en: public void start() throws Exception {
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: public void start() throws Exception {
- en: LocalTime start = LocalTime.now();
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: LocalTime start = LocalTime.now();```
- en: vertx.setPeriodic(1000, v-> {
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: vertx.setPeriodic(1000, v-> {
- en: System.out.println("Beep!");
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("Beep!");
- en: if(ChronoUnit.SECONDS.between(start, LocalTime.now()) > 3 ){
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: if(ChronoUnit.SECONDS.between(start, LocalTime.now()) > 3 ){
- en: vertx.undeploy(deploymentID());
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: vertx.undeploy(deploymentID());
- en: '}'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: System.out.println("Vertical PeriodicService1 is deployed");
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("Vertical PeriodicService1 is deployed");
- en: '}'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void stop() throws Exception {
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: public void stop() throws Exception {
- en: System.out.println("Vertical PeriodicService1 is un-deployed");
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("Vertical PeriodicService1 is un-deployed");
- en: '}'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see, this vertical, once deployed, prints the `Beep!` message every
    second, and after three seconds, is automatically un-deployed. If we deploy this
    vertical, we will see:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此垂直一旦部署，就会每秒打印一次“Beep！”消息，并且在三秒后会自动取消部署。如果我们部署此垂直，我们将看到：
- en: '```java'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Vertical PeriodicService1 is deployed
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直PeriodicService1被部署
- en: Beep!
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 嘟嘟声！
- en: Beep!
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 嘟嘟声！
- en: Beep!
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 嘟嘟声！
- en: Beep!
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 嘟嘟声！
- en: Vertical PeriodicService1 is un-deployed
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直PeriodicService1被卸载
- en: '```'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The first `Beep!` comes out when the vertical starts, then there are three more
    messages every second, and the vertical is un-deployed, as was expected.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 当垂直开始时，第一个“嘟嘟声！”响起，然后每秒钟会有三条消息，然后垂直被卸载，正如预期的那样。
- en: The HTTP client as a microservice
  id: totrans-515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为微服务的HTTP客户端
- en: 'We can use periodic service verticals to send messages to the server vertical
    using the HTTP protocol. In order to do it, we need a new dependency, so we can
    use the `WebClient` class:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用周期性服务垂直向服务器垂直发送消息，使用HTTP协议。为了做到这一点，我们需要一个新的依赖项，所以我们可以使用`WebClient`类：
- en: '```java'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: <dependency>
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: <dependency>
- en: <groupId>io.vertx</groupId>
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: <groupId>io.vertx</groupId>
- en: <artifactId>vertx-web-client</artifactId>
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: <artifactId>vertx-web-client</artifactId>
- en: <version>${vertx.version}</version>
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: <version>${vertx.version}</version>
- en: </dependency>
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: </dependency>
- en: '```'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'With that, the periodic service that sends messages to the HTTP server vertical
    looks like this:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，向HTTP服务器垂直发送消息的周期性服务看起来是这样的：
- en: '```java'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: package com.packt.javapath.ch18demo.microservices;
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: package com.packt.javapath.ch18demo.microservices;
- en: import io.vertx.rxjava.core.AbstractVerticle;
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: import io.vertx.rxjava.core.AbstractVerticle;
- en: import io.vertx.rxjava.core.buffer.Buffer;
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: import io.vertx.rxjava.core.buffer.Buffer;
- en: import io.vertx.rxjava.ext.web.client.HttpResponse;
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: import io.vertx.rxjava.ext.web.client.HttpResponse;
- en: import io.vertx.rxjava.ext.web.client.WebClient;
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: import io.vertx.rxjava.ext.web.client.WebClient;
- en: import rx.Single;
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: import rx.Single;
- en: import java.time.LocalTime;
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: import java.time.LocalTime;
- en: import java.time.temporal.ChronoUnit;
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: import java.time.temporal.ChronoUnit;
- en: public class PeriodicService2 extends AbstractVerticle {
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: public class PeriodicService2 extends AbstractVerticle {
- en: private int port;
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: private int port;
- en: public PeriodicService2(int port) {
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: public PeriodicService2(int port) {
- en: this.port = port;
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: this.port = port;
- en: '}'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void start() throws Exception {
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: public void start() throws Exception {
- en: WebClient client = WebClient.create(vertx);
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: WebClient client = WebClient.create(vertx);
- en: Single<HttpResponse<Buffer>> single = client
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: Single<HttpResponse<Buffer>> single = client
- en: .get(port, "localhost", "?name=Nick")
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: .get(port, "localhost", "?name=Nick")
- en: .rxSend();
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: .rxSend();
- en: LocalTime start = LocalTime.now();
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: LocalTime start = LocalTime.now();
- en: vertx.setPeriodic(1000, v-> {
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: vertx.setPeriodic(1000, v-> {
- en: single.subscribe(r-> System.out.println(r.bodyAsString()),
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: single.subscribe(r-> System.out.println(r.bodyAsString()),
- en: Throwable::printStackTrace);
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: Throwable::printStackTrace);
- en: if(ChronoUnit.SECONDS.between(start, LocalTime.now()) >= 3 ){
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: if(ChronoUnit.SECONDS.between(start, LocalTime.now()) >= 3 ){
- en: client.close();
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: client.close();
- en: vertx.undeploy(deploymentID());
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: vertx.undeploy(deploymentID());
- en: System.out.println("Vertical PeriodicService2 undeployed");
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("垂直PeriodicService2被卸载");
- en: '}'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: System.out.println("Vertical PeriodicService2 deployed");
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("垂直PeriodicService2被部署");
- en: '}'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, this periodic service accepts the port number as a parameter
    of its constructor, then sends a message to this port on the localhost every second,
    and un-deploys itself after three seconds. The message is the value of the `name` parameter.
    By default, it is the GET request.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个周期性服务接受端口号作为其构造函数的参数，然后每秒向本地主机的此端口发送一条消息，并在三秒后卸载自己。消息是`name`参数的值。默认情况下，它是GET请求。
- en: 'We will also modify our server vertical to read the value of the `name` parameter:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将修改我们的服务器垂直以读取`name`参数的值：
- en: '```java'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public void start() throws Exception {
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: public void start() throws Exception {
- en: HttpServer server = vertx.createHttpServer();
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: HttpServer server = vertx.createHttpServer();
- en: server.requestStream().toObservable()
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: server.requestStream().toObservable()
- en: .subscribe(request -> request.response()
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: .subscribe(request -> request.response()
- en: .end("Hi, " + request.getParam("name") + "! Hello from " +
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: .end("嗨，" + request.getParam("name") + "！来自" +
- en: Thread.currentThread().getName() + " on port " + port + "!"));
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: Thread.currentThread().getName() + " on port " + port + "!"));
- en: server.rxListen(port).subscribe();
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: server.rxListen(port).subscribe();
- en: System.out.println(Thread.currentThread().getName()
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Thread.currentThread().getName()
- en: + " is waiting on port " + port + "...");
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: + "正在等待端口" + port + "...");
- en: '}'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We can deploy both verticals:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以部署两个垂直：
- en: '```java'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: RxHelper.deployVerticle(vertx(), new HttpServer2(8082));
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: RxHelper.deployVerticle(vertx(), new HttpServer2(8082));
- en: RxHelper.deployVerticle(vertx(), new PeriodicService2(8082));
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: RxHelper.deployVerticle(vertx(), new PeriodicService2(8082));
- en: '```'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The output will be as follows:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '```java'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Vertical PeriodicService2 deployed
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直PeriodicService2被部署
- en: vert.x-eventloop-thread-0 is waiting on port 8082...
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: vert.x-eventloop-thread-0正在等待端口8082...
- en: Hi, Nick! Hello from vert.x-eventloop-thread-0 on port 8082!
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 嗨，Nick！来自vert.x-eventloop-thread-0在端口8082上的问候！
- en: Hi, Nick! Hello from vert.x-eventloop-thread-0 on port 8082!
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 嗨，Nick！来自vert.x-eventloop-thread-0在端口8082上的问候！
- en: Vertical PeriodicService2 undeployed
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直PeriodicService2被卸载
- en: Hi, Nick! Hello from vert.x-eventloop-thread-0 on port 8082!
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 嗨，Nick！来自vert.x-eventloop-thread-0在端口8082上的问候！
- en: '```'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Other microservices
  id: totrans-586
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他微服务
- en: In principle, the whole system of microservices can be built based on the messages
    sent using the HTTP protocol, with each microservice implemented as an HTTP server
    or having an HTTP server as the front for the message exchange. Alternatively,
    any other messaging system can be used for the communication.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，整个微服务系统可以基于使用HTTP协议发送的消息构建，每个微服务都实现为HTTP服务器或者将HTTP服务器作为消息交换的前端。或者，可以使用任何其他消息系统进行通信。
- en: In the case of Vert.x, it has its own messaging system-based on the event bus.
    In the next section, we will demonstrate it and use it as an illustration of how
    a reactive system may look.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vert.x的情况下，它有自己基于事件总线的消息系统。在下一节中，我们将演示它，并将其用作反应式系统可能看起来的一个例子。
- en: The size of our sample microservices may leave the impression that microservices
    have to be as fine-grained as object methods. In some cases, it is worth considering
    whether a particular method needs to be scaled, for example. The truth is, this
    architectural style is novel enough to allow for definite size recommendations,
    and the existing frameworks, libraries, and toolkits are flexible enough to support
    practically any size of independently deployable services. Well, if a deployable,
    independent service is as big as a traditional application, then it probably won't
    be called a microservice, but *an external system*, or something similar.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例微服务的大小可能会给人留下微服务必须像对象方法一样细粒度的印象。在某些情况下，值得考虑特定方法是否需要扩展。事实上，这种架构风格足够新颖，可以提供明确的大小建议，并且现有的框架、库和工具包足够灵活，可以支持几乎任何大小的独立部署服务。如果可部署的独立服务与传统应用程序一样大，那么它可能不会被称为微服务，而是*外部系统*或类似的东西。
- en: Reactive systems
  id: totrans-590
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式系统
- en: Those familiar with the concept of **event-driven architecture** (**EDA**) may
    have noticed that it closely resembles the idea of a reactive system. Their descriptions
    use very similar language and diagrams. The difference is that EDA deals with
    only one aspect of a software system—the architecture. The idea of a reactive
    system, on the other hand, is more about the code style and execution flow, including
    an emphasis on using asynchronous data streams, for example. So, a reactive system
    can have EDA, and EDA can be implemented as a reactive system.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉**事件驱动架构**（**EDA**）概念的人可能已经注意到它与反应式系统的想法非常相似。它们的描述使用非常相似的语言和图表。不同之处在于EDA只涉及软件系统的一个方面——架构。另一方面，反应式系统更多地涉及代码风格和执行流程，包括强调使用异步数据流。因此，反应式系统可以具有EDA，而EDA可以实现为反应式系统。
- en: 'Let''s look at another set of examples that provides a glimpse into how a reactive
    system may look, if implemented using Vert.x. Notice that the Vert.x API has two
    source trees: one starts with `io.vertx.core`, and the other with `io.vertx.rxjava`.
    Since we are discussing reactive programming, we are going to use packages under `io.vertx.rxjava`,
    called the rx-fied Vert.x API.'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一组示例，以了解使用Vert.x实现的反应式系统可能是什么样子。请注意，Vert.x API有两个源树：一个以`io.vertx.core`开头，另一个以`io.vertx.rxjava`开头。由于我们正在讨论反应式编程，我们将使用`io.vertx.rxjava`下的包，称为rx-fied
    Vert.x API。
- en: Message-driven system
  id: totrans-593
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息驱动系统
- en: 'Vert.x has a feature that directly supports both the message-driven architecture
    and EDA. It is called an event bus. Any verticle has access to the event bus, and
    can send any message to any address (which is just a string) using the `io.vertx.core.eventbus.EventBus` class,
    or its cousin, `io.vertx.rxjava.core.eventbus.EventBus`. We are only going to
    use the latter, but similar (not rx-fied) functionality is available in `io.vertx.core.eventbus.EventBus`,
    too. One, or several, verticles can register themselves as a message consumer
    for a certain address. If several verticles are consumers for the same address,
    then the `rxSend()` method of `EventBus` delivers the message only to one of these
    consumers, using a round-robin algorithm to pick the receiver of the next message.
    Alternatively, the `publish()` method, as you would expect, delivers the message
    to all consumers with the same address. Here is the code that sends the message
    to the specified address:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x具有直接支持消息驱动架构和EDA的功能。它被称为事件总线。任何verticle都可以访问事件总线，并且可以使用`io.vertx.core.eventbus.EventBus`类或其类似物`io.vertx.rxjava.core.eventbus.EventBus`向任何地址（只是一个字符串）发送任何消息。我们只会使用后者，但是`io.vertx.core.eventbus.EventBus`中也提供了类似（非rx-fied）的功能。一个或多个verticle可以注册自己作为某个地址的消息消费者。如果有多个verticle是相同地址的消费者，那么`EventBus`的`rxSend()`方法使用循环算法仅将消息传递给这些消费者中的一个，以选择下一条消息的接收者。或者，`publish()`方法会将消息传递给具有相同地址的所有消费者。以下是将消息发送到指定地址的代码：
- en: '```java'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: vertx.eventBus().rxSend(address, msg).subscribe(reply ->
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: vertx.eventBus().rxSend(address, msg).subscribe(reply ->
- en: 'System.out.println("Got reply: " + reply.body()),'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("Got reply: " + reply.body()),'
- en: Throwable::printStackTrace );
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: Throwable::printStackTrace );
- en: '```'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The `rxSend()` method returns the `Single<Message>` object that represents
    a message that can be received, and the `subscribe()` method to ... well... subscribe
    to it. The `Single<Message>` class implements the reactive pattern for a single
    value response. The `subscribe()` method accepts two `Consumer` functions: the
    first processes the reply,  the second processes the error. In the preceding code,
    the first function just prints the reply:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '`rxSend()`方法返回表示可以接收的消息的`Single<Message>`对象，并且`subscribe()`方法...嗯...订阅它。`Single<Message>`类实现了单个值响应的反应式模式。`subscribe()`方法接受两个`Consumer`函数：第一个处理回复，第二个处理错误。在前面的代码中，第一个函数只是打印回复：'
- en: '```java'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'reply -> System.out.println("Got reply: " + reply.body())'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 'reply -> System.out.println("Got reply: " + reply.body())'
- en: '```'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The second action prints the stack trace of the exception, if it happens:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个操作打印异常的堆栈跟踪，如果发生异常：
- en: '```java'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Throwable::printStackTrace
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: Throwable::printStackTrace
- en: '```'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you already know, the preceding construct is called a method reference.
    The same function, as a lambda expression, would look like the following:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，前面的结构称为方法引用。作为lambda表达式的相同函数将如下所示：
- en: '```java'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: e -> e.printStackTrace()
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: e -> e.printStackTrace()
- en: '```'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'A call to the `publish()` method looks similar:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 对`publish()`方法的调用看起来很相似：
- en: '```java'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: vertx.eventBus().publish(address, msg)
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: vertx.eventBus().publish(address, msg)
- en: '```'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It publishes the message to many consumers potentially, so the method does not
    return a `Single` object, or any other object that can be used to get a reply.
    Instead, it just returns an `EventBus` object; if needed, more event bus methods
    can be called.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 它将消息发布给许多消费者，因此该方法不会返回`Single`对象或任何其他可用于获取回复的对象。相反，它只返回一个`EventBus`对象；如果需要，可以调用更多的事件总线方法。
- en: Message consumer
  id: totrans-617
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息消费者
- en: 'The message consumer in Vert.x is a verticle that registers with the event
    bus as a potential receiver of the messages sent or published to the specified
    address:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vert.x中的消息消费者是一个verticle，它在事件总线上注册为指定地址发送或发布的消息的潜在接收者：
- en: '```java'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: package com.packt.javapath.ch18demo.reactivesystem;
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: package com.packt.javapath.ch18demo.reactivesystem;
- en: import io.vertx.rxjava.core.AbstractVerticle;
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: import io.vertx.rxjava.core.AbstractVerticle;
- en: public class MsgConsumer extends AbstractVerticle {
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: public class MsgConsumer extends AbstractVerticle {
- en: private String address, name;
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: private String address, name;
- en: public MsgConsumer(String id, String address) {
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: public MsgConsumer(String id, String address) {```
- en: this.address = address;
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: this.address = address;
- en: this.name = this.getClass().getSimpleName() +
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: this.name = this.getClass().getSimpleName() +
- en: '"(" + id + "," + address + ")";'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '"(" + id + "," + address + ")";'
- en: '}'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void start() throws Exception {
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: public void start() throws Exception {
- en: System.out.println(name + " starts...");
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(name + " starts...");
- en: vertx.eventBus().consumer(address).toObservable()
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: vertx.eventBus().consumer(address).toObservable()
- en: .subscribe(msg -> {
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: .subscribe(msg -> {
- en: 'String reply = name + " got message: " + msg.body();'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 'String reply = name + " got message: " + msg.body();'
- en: System.out.println(reply);
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(reply);
- en: if ("undeploy".equals(msg.body())) {
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: if ("undeploy".equals(msg.body())) {
- en: vertx.undeploy(deploymentID());
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: vertx.undeploy(deploymentID());
- en: reply = name + " undeployed.";
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: reply = name + " undeployed.";
- en: System.out.println(reply);
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(reply);
- en: '}'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: msg.reply(reply);
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: msg.reply(reply);
- en: '}, Throwable::printStackTrace );'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '}, Throwable::printStackTrace );'
- en: System.out.println(Thread.currentThread().getName()
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Thread.currentThread().getName()
- en: + " is waiting on address " + address + "...");
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: + " is waiting on address " + address + "...");
- en: '}'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The `consumer(address)` method returns an object of `io.vertx.rxjava.core.eventbus.MessageConsumer<T>`,
    which represents a stream of messages to the provided address. This means that
    one can convert the stream into an `Observable` and subscribe to it to receive
    all of the messages sent to this address. The `subscribe()` method of the `Observable`
    object accepts two `Consumer` functions: the first processes the received message,
    and the second is executed when an error happens. In the first function, we have
    included the `msg.reply(reply)` method, which sends the message back to the source
    of the message. And you probably remember that the sender is able to get this
    reply if the original message was sent by the `rxSend()` method. If the `publish()` method
    was used instead, then the reply sent by the `msg.reply(reply)` method goes nowhere.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '`consumer(address)`方法返回一个`io.vertx.rxjava.core.eventbus.MessageConsumer<T>`对象，表示提供的地址的消息流。这意味着可以将流转换为`Observable`并订阅它以接收发送到此地址的所有消息。`Observable`对象的`subscribe()`方法接受两个`Consumer`函数：第一个处理接收到的消息，第二个在发生错误时执行。在第一个函数中，我们包含了`msg.reply(reply)`方法，它将消息发送回消息的来源。您可能还记得，如果原始消息是通过`rxSend()`方法发送的，发送方可以获得此回复。如果使用了`publish()`方法，那么由`msg.reply(reply)`方法发送的回复将无处可去。'
- en: Also, notice that when the `undeploy` message is received, the message consumer
    undeploys itself. This method is usually only used during automatic deployment,
    when the old version is replaced by the newer one without shutting down the system.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，当接收到`undeploy`消息时，消息消费者会取消部署自身。通常只在自动部署期间使用此方法，当旧版本被新版本替换而不关闭系统时。
- en: Because we are going to deploy several message consumers with the same address
    for the demonstration, we have added the `id` parameter and included it in the `name` value.
    This value serves as a prefix in all of the messages, so we can trace how the
    message propagates across the system.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将部署几个具有相同地址的消息消费者进行演示，所以我们添加了`id`参数并将其包含在`name`值中。此值用作所有消息中的前缀，因此我们可以跟踪消息在系统中的传播。
- en: You have probably realized that the preceding implementation is just a shell
    that can be used to invoke some useful functionalities. The received message can
    be a command to do something, data to be processed, data to be stored in the database,
    or anything else. And the reply can be an acknowledgment that the message was
    received, or some other expected result. If the latter is the case, the processing
    should be very fast, to avoid blocking the event loop (remember the golden rule).
    If the processing cannot be done quickly, the replay can also be a callback token,
    used by the sender later to retrieve the result.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经意识到，前面的实现只是一个可以用来调用一些有用功能的外壳。接收到的消息可以是执行某些操作的命令，要处理的数据，要存储在数据库中的数据，或者其他任何内容。回复可以是收到消息的确认，或者其他预期的结果。如果是后者，处理应该非常快，以避免阻塞事件循环（记住黄金法则）。如果处理不能很快完成，回复也可以是一个回调令牌，稍后由发送方用来检索结果。
- en: Message sender
  id: totrans-651
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息发送者
- en: 'The message sender we will demonstrate is based on the HTTP server implementation
    we demonstrated in the *Microservices* section. It is not necessary to do it this
    way. In real-life code, a vertical typically sends messages automatically, either
    to get data it needs, to provide data some other vertical wants, to notify another
    vertical, to store data in the database, or for any other reason. But for demonstration
    purposes, we have decided that the sender will listen to some port for messages,
    and we will send it messages manually (using the `curl` command) or automatically,
    via some periodic service described in the *Microservices* section. That is why
    the message sender looks a bit more complex than the message consumer:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示的消息发送者基于我们在*微服务*部分演示的HTTP服务器实现。不一定非要这样做。在实际代码中，垂直通常会自动发送消息，要么获取它需要的数据，要么提供其他垂直需要的数据，要么通知另一个垂直，要么将数据存储在数据库中，或者出于任何其他原因。但是出于演示目的，我们决定发送方将侦听某个端口以接收消息，并且我们将手动（使用`curl`命令）或自动（通过*微服务*部分描述的某个周期性服务）发送消息给它。这就是为什么消息发送者看起来比消息消费者复杂一些：
- en: '```java'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: package com.packt.javapath.ch18demo.reactivesystem;
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: package com.packt.javapath.ch18demo.reactivesystem;
- en: import io.vertx.rxjava.core.AbstractVerticle;
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: import io.vertx.rxjava.core.AbstractVerticle;
- en: import io.vertx.rxjava.core.http.HttpServer;
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: import io.vertx.rxjava.core.http.HttpServer;
- en: public class EventBusSend extends AbstractVerticle {
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: public class EventBusSend extends AbstractVerticle {
- en: private int port;
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: private int port;
- en: private String address, name;
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: private String address，name;
- en: public EventBusSend(int port, String address) {
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: public EventBusSend（int port，String address）{
- en: this.port = port;
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: this.port = port;
- en: this.address = address;
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: this.address = address;
- en: this.name = this.getClass().getSimpleName() +
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: this.name = this.getClass（）。getSimpleName（）+
- en: '"(port " + port + ", send to " + address + ")";'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '"（端口" + port + "，发送到" + address + "）";'
- en: '}'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void start() throws Exception {
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: public void start（）throws Exception {
- en: System.out.println(name + " starts...");
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（name + "开始..."）;
- en: HttpServer server = vertx.createHttpServer();
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: HttpServer server = vertx.createHttpServer（）;
- en: server.requestStream().toObservable().subscribe(request -> {
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: server.requestStream（）。toObservable（）。subscribe（request - > {
- en: String msg = request.getParam("msg");
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: String msg = request.getParam（"msg"）;
- en: request.response().setStatusCode(200).end();
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: request.response（）。setStatusCode（200）。end（）;
- en: vertx.eventBus().rxSend(address, msg).subscribe(reply -> {
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: vertx.eventBus（）。rxSend（address，msg）。subscribe（reply - > {
- en: System.out.println(name + " got reply:\n  " + reply.body());
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（name + "收到回复：\n "+ reply.body（））;
- en: '},'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '}，'
- en: e -> {
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: e - > {
- en: if(StringUtils.contains(e.toString(), "NO_HANDLERS")){
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: if（StringUtils.contains（e.toString（），"NO_HANDLERS"））{
- en: vertx.undeploy(deploymentID());
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: vertx.undeploy（deploymentID（））;
- en: System.out.println(name + " undeployed.");
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（name + "取消部署。"）;
- en: '} else {'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: e.printStackTrace();
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: e.printStackTrace（）;
- en: '}'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}); });'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '}）;'
- en: server.rxListen(port).subscribe();
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: server.rxListen（port）。subscribe（）;
- en: System.out.println(Thread.currentThread().getName()
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（Thread.currentThread（）。getName（））
- en: + " is waiting on port " + port + "...");
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: + "正在等待端口" + port + "...");
- en: '}'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Most of the preceding code is related to the HTTP server functionality. The
    few lines that send the message (received by the HTTP server) are these ones:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分前面的代码与HTTP服务器功能相关。发送消息（由HTTP服务器接收）的几行是这些：
- en: '```java'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: vertx.eventBus().rxSend(address, msg).subscribe(reply -> {
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: vertx.eventBus（）。rxSend（address，msg）。subscribe（reply - > {
- en: System.out.println(name + " got reply:\n  " + reply.body());
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（name + "收到回复：\n "+ reply.body（））;
- en: '}, e -> {'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '}，e - > {'
- en: if(StringUtils.contains(e.toString(), "NO_HANDLERS")){
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: if（StringUtils.contains（e.toString（），"NO_HANDLERS"））{
- en: vertx.undeploy(deploymentID());
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: vertx.undeploy（deploymentID（））;
- en: System.out.println(name + " undeployed.");
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（name + "取消部署。"）;
- en: '} else {'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: e.printStackTrace();
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: e.printStackTrace（）;
- en: '}'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '}）;'
- en: '```'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: After the message is sent, the sender subscribes to the possible reply and prints
    it (if the reply was received). If an error happens (an exception is thrown during
    message sending), we can check whether the exception (converted to the `String`
    value) contains literal `NO_HANDLERS`, and un-deploy the sender if so. It took
    us a while to figure out how to identify the case when there are no consumers
    assigned to the address, for which this sender is dedicated to sending messages.
    If there are no consumers (all are un-deployed, most likely), then there is no
    need for the sender, so we un-deploy it.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 发送消息后，发送者订阅可能的回复并打印它（如果收到了回复）。如果发生错误（在发送消息期间抛出异常），我们可以检查异常（转换为`String`值）是否包含文字`NO_HANDLERS`，如果是，则取消部署发送者。我们花了一段时间才弄清楚如何识别没有分配给此发送者发送消息的消费者的情况。如果没有消费者（很可能都取消部署了），那么发送者就没有必要了，所以我们取消部署它。
- en: It is a good practice to clean up and un-deploy all of the verticles that are
    not needed anymore. But if you run the verticles in IDE, chances are, all the
    verticles are stopped as soon as you stop the main process (that has created the
    verticles) in your IDE. If not, run the `jcmd` command and see whether there are
    still Vert.x verticles running. The first number for each of the listed processes
    is the process ID. Identify the verticles that you do not need anymore and use
    the `kill -9  <process ID>` command to stop them.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 清理和取消部署所有不再需要的verticle是一个好习惯。但是，如果在IDE中运行verticle，很有可能一旦停止创建verticle的主进程（已在IDE中创建verticle），所有verticle都会停止。如果没有，请运行`jcmd`命令，并查看是否仍在运行Vert.x
    verticle。列出的每个进程的第一个数字是进程ID。识别不再需要的verticle，并使用`kill -9 <process ID>`命令停止它们。
- en: 'Now, let''s deploy two message consumers, and send them messages via our message
    sender:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们部署两个消息消费者，并通过我们的消息发送者向它们发送消息：
- en: '```java'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String address = "One";
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: String address = "One";
- en: Vertx vertx = vertx();
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: Vertx vertx = vertx（）;
- en: RxHelper.deployVerticle(vertx, new MsgConsumer("1",address));
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: RxHelper.deployVerticle（vertx，new MsgConsumer（"1"，address））;
- en: RxHelper.deployVerticle(vertx, new MsgConsumer("2",address));
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: RxHelper.deployVerticle（vertx，new MsgConsumer（"2"，address））;
- en: RxHelper.deployVerticle(vertx, new EventBusSend(8082, address));
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: RxHelper.deployVerticle（vertx，new EventBusSend（8082，address））;
- en: '```'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'After you run the preceding code, the Terminal shows the following messages:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码后，终端显示以下消息：
- en: '```java'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: MsgConsumer(1,One) starts...
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer（1，One）开始...
- en: MsgConsumer(2,One) starts...
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer（2，One）开始...
- en: EventBusSend(port 8082, send to One) starts...
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: EventBusSend（端口8082，发送到One）开始...
- en: vert.x-eventloop-thread-1 is waiting on address One...
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: vert.x-eventloop-thread-1正在等待地址One...
- en: vert.x-eventloop-thread-0 is waiting on address One...
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: vert.x-eventloop-thread-0正在等待地址One...
- en: vert.x-eventloop-thread-2 is waiting on port 8082...
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: vert.x-eventloop-thread-2正在等待端口8082...
- en: '```'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice the different event loops running to support each verticle.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 注意运行以支持每个verticle的不同事件循环。
- en: 'Now, let''s send a few messages, using the following commands from a terminal
    window:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用终端窗口中的以下命令发送几条消息：
- en: '```java'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: curl localhost:8082?msg=Hello!
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: curl localhost：8082？msg =你好！
- en: curl localhost:8082?msg=Hi!
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: curl localhost：8082？msg = Hi！
- en: curl localhost:8082?msg=How+are+you?
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: curl localhost：8082？msg = How + are + you？
- en: curl localhost:8082?msg=Just+saying...
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: curl localhost：8082？msg = Just + saying...
- en: '```'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The plus sign (`+`) is necessary because a URL cannot contain spaces and has
    to be *encoded*, which means, among other things, replacing spaces with plus sign
    `+` or `%20`. In response to the preceding commands, we will see the following
    messages:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 加号（`+`）是必需的，因为URL不能包含空格，必须*编码*，这意味着，除其他外，用加号`+`或`%20`替换空格。作为对前述命令的响应，我们将看到以下消息：
- en: '```java'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'MsgConsumer(2,One) got message: Hello!'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer（2，One）收到消息：你好！
- en: 'EventBusSend(port 8082, send to One) got reply:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: EventBusSend（端口8082，发送到One）收到回复：
- en: 'MsgConsumer(2,One) got message: Hello!'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer（2，One）收到消息：你好！
- en: 'MsgConsumer(1,One) got message: Hi!'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer（1，One）收到消息：你好！
- en: 'EventBusSend(port 8082, send to One) got reply:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: EventBusSend（端口8082，发送到One）收到回复：
- en: 'MsgConsumer(1,One) got message: Hi!'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer（1，One）收到消息：嗨！
- en: 'MsgConsumer(2,One) got message: How are you?'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer（2，One）收到消息：你好吗？
- en: 'EventBusSend(port 8082, send to One) got reply:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: EventBusSend（端口8082，发送到One）收到回复：
- en: 'MsgConsumer(2,One) got message: How are you?'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer（2，One）收到消息：你好吗？
- en: 'MsgConsumer(1,One) got message: Just saying...'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer（1，One）收到消息：只是说...
- en: 'EventBusSend(port 8082, send to One) got reply:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: EventBusSend（端口8082，发送到One）收到回复：
- en: 'MsgConsumer(1,One) got message: Just saying...'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer（1，One）收到消息：只是说...
- en: '```'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As expected, the consumers received messages by turns, according to the round-robin
    algorithm. Now, let''s deploy all of the verticles:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，消费者根据循环算法轮流接收消息。现在，让我们部署所有的垂直线：
- en: '```java'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: curl localhost:8082?msg=undeploy
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: curl localhost：8082？msg=undeploy
- en: curl localhost:8082?msg=undeploy
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: curl localhost：8082？msg=undeploy
- en: curl localhost:8082?msg=undeploy
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: curl localhost：8082？msg=undeploy
- en: '```'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Here are the messages displayed in response to the preceding commands:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前述命令的响应中显示的消息：
- en: '```java'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'MsgConsumer(1,One) got message: undeploy'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer（1，One）收到消息：取消部署
- en: MsgConsumer(1,One) undeployed.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer（1，One）未部署。
- en: 'EventBusSend(port 8082, send to One) got reply:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: EventBusSend（端口8082，发送到One）收到回复：
- en: MsgConsumer(1,One) undeployed.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer（1，One）未部署。
- en: 'MsgConsumer(2,One) got message: undeploy'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer（2，One）收到消息：取消部署
- en: MsgConsumer(2,One) undeployed.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer（2，One）未部署。
- en: 'EventBusSend(port 8082, send to One) got reply:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: EventBusSend（端口8082，发送到One）收到回复：
- en: MsgConsumer(2,One) undeployed.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer（2，One）未部署。
- en: EventBusSend(port 8082, send to One) undeployed.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: EventBusSend（端口8082，发送到One）未部署。
- en: '```'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'According to the preceding messages, all of our verticals are un-deployed.
    If we submit the `undeploy` message again, we will see:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的消息，我们所有的垂直线都未部署。如果我们再次提交`undeploy`消息，我们将看到：
- en: '```java'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: curl localhost:8082?msg=undeploy
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: curl localhost：8082？msg=undeploy
- en: 'curl: (7) Failed to connect to localhost port 8082: Connection refused'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: curl：（7）无法连接到本地主机端口8082：连接被拒绝
- en: '```'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: That is because the sender is undeployed, and there is no HTTP server that listens
    to port `8082` of the localhost.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为发送者已被取消部署，并且本地主机的端口`8082`没有监听的HTTP服务器。
- en: Message publisher
  id: totrans-768
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息发布者
- en: 'We implemented the message publisher very similarly to the message sender:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了消息发布者与消息发送者非常相似：
- en: '```java'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: package com.packt.javapath.ch18demo.reactivesystem;
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 包com.packt.javapath.ch18demo.reactivesystem;
- en: import io.vertx.rxjava.core.AbstractVerticle;
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: import io.vertx.rxjava.core.AbstractVerticle;
- en: import io.vertx.rxjava.core.http.HttpServer;
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: import io.vertx.rxjava.core.http.HttpServer;
- en: public class EventBusPublish extends AbstractVerticle {
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: public class EventBusPublish extends AbstractVerticle {
- en: private int port;
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: private int port;
- en: private String address, name;
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: private String address，name;
- en: public EventBusPublish(int port, String address) {
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: public EventBusPublish（int port，String address）{
- en: this.port = port;
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: this.port = port;
- en: this.address = address;
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: this.address = address;
- en: this.name = this.getClass().getSimpleName() +
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: this.name = this.getClass().getSimpleName（）+
- en: '"(port " + port + ", publish to " + address + ")";'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: “（端口”+端口+“，发布到”+地址+“）”;
- en: '}'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void start() throws Exception {
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: public void start（）throws Exception {
- en: System.out.println(name + " starts...");
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（name +“开始...”）;
- en: HttpServer server = vertx.createHttpServer();
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: HttpServer server = vertx.createHttpServer（）;
- en: server.requestStream().toObservable()
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: server.requestStream().toObservable()
- en: .subscribe(request -> {
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: .subscribe（request - > {
- en: String msg = request.getParam("msg");
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: String msg = request.getParam（“msg”）;
- en: request.response().setStatusCode(200).end();
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: request.response().setStatusCode(200).end();
- en: vertx.eventBus().publish(address, msg);
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: vertx.eventBus（）。publish（address，msg）;
- en: if ("undeploy".equals(msg)) {
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: if（“undeploy”。equals（msg））{
- en: vertx.undeploy(deploymentID());
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: vertx.undeploy（deploymentID（））;
- en: System.out.println(name + " undeployed.");
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（name +“未部署”）;
- en: '}'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '}）;'
- en: server.rxListen(port).subscribe();
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: server.rxListen（port）.subscribe（）;
- en: System.out.println(Thread.currentThread().getName()
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（Thread.currentThread().getName（）
- en: + " is waiting on port " + port + "...");
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: +“正在等待端口”+端口+“...”）;
- en: '}'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The publisher differs from the sender only by this section:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者与发送者的区别仅在于此部分：
- en: '```java'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: vertx.eventBus().publish(address, msg);
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: vertx.eventBus（）。publish（address，msg）;
- en: if ("undeploy".equals(msg)) {
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: if（“undeploy”。equals（msg））{
- en: vertx.undeploy(deploymentID());
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: vertx.undeploy（deploymentID（））;
- en: System.out.println(name + " undeployed.");
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（name +“未部署”）;
- en: '}'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Since one cannot get a reply while publishing, the preceding code is much simpler
    than the message-sending code. Also, since all of the consumers recieve the `undeploy` message
    at the same time, we can assume that they are all going to be un-deployed, and
    the publisher can un-deploy itself. Let''s test it by running the following program:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在发布时无法获得回复，因此前面的代码比发送消息的代码简单得多。此外，由于所有消费者同时收到`undeploy`消息，我们可以假设它们都将被取消部署，并且发布者可以取消部署自己。让我们通过运行以下程序来测试它：
- en: '```java'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String address = "One";
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: String address =“One”;
- en: Vertx vertx = vertx();
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: Vertx vertx = vertx（）;
- en: RxHelper.deployVerticle(vertx, new MsgConsumer("1",address));
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: RxHelper.deployVerticle（vertx，new MsgConsumer（“1”，address））;
- en: RxHelper.deployVerticle(vertx, new MsgConsumer("2",address));
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: RxHelper.deployVerticle（vertx，new MsgConsumer（“2”，address））;
- en: RxHelper.deployVerticle(vertx, new EventBusPublish(8082, address));
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: RxHelper.deployVerticle（vertx，new EventBusPublish（8082，address））;
- en: '```'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In response to the preceding code execution, we get the following messages:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对前面的代码执行的响应，我们得到以下消息：
- en: '```java'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: MsgConsumer(1,One) starts...
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 消息消费者（1，One）开始...
- en: MsgConsumer(2,One) starts...
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer（2，One）开始...
- en: EventBusPublish(port 8082, publish to One) starts...
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: EventBusPublish（端口8082，发布到One）开始...
- en: vert.x-eventloop-thread-2 is waiting on port 8082...
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: vert.x-eventloop-thread-2正在等待端口8082...
- en: '```'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Now, we issue the following command in another terminal window:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在另一个终端窗口中发出以下命令：
- en: '```java'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: curl localhost:8082?msg=Hello!
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: curl localhost：8082？msg=你好！
- en: '```'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The messages in the terminal window where the verticals are running are as
    follows:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行垂直线的终端窗口中的消息如下：
- en: '```java'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'MsgConsumer(1,One) got message: Hello!'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer（1，One）收到消息：你好！
- en: 'MsgConsumer(2,One) got message: Hello!'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer（2，One）收到消息：你好！
- en: '```'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As expected, both consumers with the same address receive the same message.
    Now, let''s un-deploy them:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，具有相同地址的两个消费者都会收到相同的消息。现在，让我们将它们取消部署：
- en: '```java'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: curl localhost:8082?msg=undeploy
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: curl localhost：8082？msg=undeploy
- en: '```'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The verticals respond with these messages:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直线对这些消息做出响应：
- en: '```java'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'MsgConsumer(1,One) got message: undeploy'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer(1,One)收到消息：undeploy
- en: 'MsgConsumer(2,One) got message: undeploy'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer(2,One)收到消息：undeploy
- en: EventBusPublish(port 8082, publish to One) undeployed.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: EventBusPublish（端口8082，发布到One）已卸载。
- en: MsgConsumer(1,One) undeployed.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer(1,One)已卸载。
- en: MsgConsumer(2,One) undeployed.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: MsgConsumer(2,One)已卸载。
- en: '```'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we submit the `undeploy` message again, we will see:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次提交`undeploy`消息，我们将看到：
- en: '```java'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: curl localhost:8082?msg=undeploy
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: curl localhost:8082?msg=undeploy
- en: 'curl: (7) Failed to connect to localhost port 8082: Connection refused'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 'curl: (7)无法连接到本地主机端口8082：连接被拒绝'
- en: '```'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: With that, we have completed our demonstration of a reactive system composed
    of microservices. Adding methods and classes that do something useful will make
    it closer to the real-life system. But we will leave that as an exercise for the
    reader.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经完成了一个由微服务组成的反应式系统的演示。添加能够执行有用操作的方法和类将使其更接近实际系统。但我们将把这留给读者作为练习。
- en: Reality check
  id: totrans-852
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现实检查
- en: We have run all of the previous examples in one JVM process. If necessary, Vert.x
    instances can be deployed in different JVM processes and clustered by adding the
    `-cluster` option to the `run` command, when the verticals are deployed not from
    IDE, but from a command line. Clustered verticals share the event bus, and the
    addresses are visible to all Vert.x instances. This way, more message consumers
    can be deployed if the consumers of certain addresses cannot process the requests
    (messages) in a timely manner.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个JVM进程中运行了所有之前的示例。如果需要，Vert.x实例可以部署在不同的JVM进程中，并通过在`run`命令中添加`-cluster`选项来进行集群化，当垂直部署不是从IDE，而是从命令行时。集群化的垂直共享事件总线，地址对所有Vert.x实例可见。这样，如果某些地址的消费者无法及时处理请求（消息），就可以部署更多的消息消费者。
- en: Other frameworks that we mentioned earlier have similar capabilities. They make
    microservice creation easy, and may encourage breaking the application into tiny,
    single-method operations, with the expectation of assembling a very resilient
    and responsive system. However, these are not the only criteria of good software.
    System decomposition increases the complexity of its deployment. Also, if one
    development team is responsible for many microservices, the complexity of versioning
    so many pieces in different stages (development, test, integration test, certification,
    staging, and production) may lead to confusion. The deployment process may become
    so complex that slowing down the rate of changes is necessary to keep the system
    in sync with the market requirements.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到的其他框架具有类似的功能。它们使微服务的创建变得容易，并可能鼓励将应用程序分解为微小的、单方法的操作，期望组装一个非常具有弹性和响应性的系统。然而，这些并不是良好软件的唯一标准。系统分解增加了部署的复杂性。此外，如果一个开发团队负责许多微服务，那么在不同阶段（开发、测试、集成测试、认证、暂存和生产）对这么多部分进行版本控制的复杂性可能会导致混乱。部署过程可能变得如此复杂，以至于减缓变更速度是必要的，以使系统与市场需求保持同步。
- en: 'In addition to the developing of microservices, many other aspects have to
    be addressed to support a reactive system:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 除了开发微服务之外，还必须解决许多其他方面，以支持反应式系统：
- en: A monitoring system has to be set up to provide insight into the state of the
    application, but its development should not be so complex as to pull the development
    resources away from the main application.
  id: totrans-856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须建立监控系统以提供对应用程序状态的洞察，但其开发不应该如此复杂，以至于将开发资源从主要应用程序中分散开来。
- en: Alerts have to be installed to warn the team about possible and actual issues
    in a timely manner, so they can be addressed before affecting the business.
  id: totrans-857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须安装警报以及及时警告团队可能和实际问题，以便在影响业务之前解决这些问题。
- en: If possible, self-correcting automated processes have to be implemented. For
    example, the retry logic has to be implemented, with a reasonable upper limit
    of attempts before declaring a failure.
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能的话，必须实施自我纠正的自动化流程。例如，必须实施重试逻辑，并在宣布失败之前设定合理的尝试上限。
- en: A layer of circuit breakers has to protect the system from the domino effect
    when the failure of one component deprives other components of necessary resources.
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一层断路器必须保护系统免受多米诺效应的影响，当一个组件的故障剥夺了其他组件所需的资源时。
- en: An embedded testing system should be able to introduce disruptions and simulate
    load increases to ensure that the application's resilience and responsiveness
    do not degrade over time. For example, the Netflix team has introduced a *chaos
    monkey*—a system that is able to shut down various parts of the production system
    and test its ability to recover. They use it even in production, because a production
    environment has a specific configuration, and no test in another environment can
    guarantee that all possible issues are found.
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式测试系统应该能够引入干扰并模拟负载增加，以确保应用程序的弹性和响应性不会随着时间的推移而降低。例如，Netflix团队引入了*混沌猴*——一个能够关闭生产系统的各个部分并测试其恢复能力的系统。他们甚至在生产中使用它，因为生产环境具有特定的配置，而在另一个环境中的测试无法保证找到所有可能的问题。
- en: As you have probably realized by now, before committing to a reactive system,
    the team has to weigh all the pros and cons to understand exactly why they need
    a reactive system, and the price of its development. It is an old adage that *no
    value can be added for free*. The awesome power of reactive systems comes with
    a corresponding growth of complexity, not only during development, but also during
    system tuning and maintenance.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在可能已经意识到的那样，在承诺采用反应式系统之前，团队必须权衡所有的利弊，以确切地理解他们为什么需要反应式系统，以及其开发的代价。有一句古老的格言说：“没有免费的午餐”。反应式系统的强大力量伴随着复杂性的相应增长，不仅在开发过程中，而且在系统调优和维护过程中也是如此。
- en: Yet, if the traditional systems cannot solve the processing problem that you
    face, or if you're passionate about everything reactive and love the concept,
    by all means, go for it. The ride will be challenging, but the reward will be
    worth it. As another old adage states, *what is easily achievable is not worth
    the effort*.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果传统系统无法解决您面临的处理问题，或者如果您对一切反应式并且热爱这个概念，那么请尽管去做。旅程将充满挑战，但回报将是值得的。正如另一句古老的格言所说，“轻而易举地实现不值得努力”。
- en: Exercise – Creating io.reactivex.Observable
  id: totrans-863
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习-创建io.reactivex.Observable
- en: Write code that demonstrates several ways to create `io.reactivex.Observable`.
    In each example, subscribe to the created `Observable` object and print the emitted
    values.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码演示创建`io.reactivex.Observable`的几种方法。在每个示例中，订阅创建的`Observable`对象并打印发出的值。
- en: We did not discuss this so you will need to study the RxJava2 API and look up
    examples on the internet.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有讨论这一点，因此您需要学习RxJava2 API并在互联网上查找示例。
- en: Answer
  id: totrans-866
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are six of the methods that allow you to create `io.reactivex.Observable`:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是允许您创建`io.reactivex.Observable`的六种方法：
- en: '```java'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: //1
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: //1
- en: 'Observable.just("Hi!").subscribe(System.out::println); //prints: Hi!'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: Observable.just("Hi!").subscribe(System.out::println); //打印：Hi！
- en: //2
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: //2
- en: Observable.fromIterable(List.of("1","2","3"))
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: Observable.fromIterable(List.of("1","2","3"))
- en: '.subscribe(System.out::print); //prints: 123'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: .subscribe(System.out::print); //打印：123
- en: System.out.println();
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println();
- en: //3
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: //3
- en: String[] arr = {"1","2","3"};
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: String[] arr = {"1","2","3"};
- en: 'Observable.fromArray(arr).subscribe(System.out::print); //prints: 123'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: Observable.fromArray(arr).subscribe(System.out::print); //打印：123
- en: System.out.println();
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println();
- en: //4
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: //4
- en: Observable.fromCallable(()->123)
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: Observable.fromCallable(()->123)
- en: '.subscribe(System.out::println); //prints: 123'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: .subscribe(System.out::println); //打印：123
- en: //5
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: //5
- en: ExecutorService pool = Executors.newSingleThreadExecutor();
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: ExecutorService pool = Executors.newSingleThreadExecutor();
- en: Future<String> future = pool
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: Future<String> future = pool
- en: .submit(() -> {
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: .submit(() -> {
- en: Thread.sleep(100);
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: Thread.sleep(100);
- en: return "Hi!";
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: return "Hi!";
- en: '});'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: Observable.fromFuture(future)
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: Observable.fromFuture(future)
- en: '.subscribe(System.out::println); //prints: Hi!'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: .subscribe(System.out::println); //打印：Hi！
- en: pool.shutdown();
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: pool.shutdown();
- en: //6
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: //6
- en: Observable.interval(100, TimeUnit.MILLISECONDS)
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: Observable.interval(100, TimeUnit.MILLISECONDS)
- en: .subscribe(v->System.out.println("100 ms is over"));
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: .subscribe(v->System.out.println("100 ms is over"));
- en: //prints twice "100 ms is over"
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: //两次打印“100毫秒已经过”
- en: try { //this pause gives the above method a chance to print the message
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试 { //这个暂停给上面的方法一个打印消息的机会
- en: TimeUnit.MILLISECONDS.sleep(200);
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: TimeUnit.MILLISECONDS.sleep(200);
- en: '} catch (InterruptedException e) {'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (InterruptedException e) {'
- en: e.printStackTrace();
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: e.printStackTrace();
- en: '}'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Summary
  id: totrans-902
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this last chapter of the book, we have provided the reader with a glimpse
    into real-life professional programming and a short overview of the challenges
    of the trade. We have revisited many of the modern terms used in relation to big
    data processing using highly-scalable responsive and resilient reactive systems
    that are able to solve the challenging processing, problems of the modern age.
    We have even provided code examples of such systems, which may serve as the first
    step for your real-life project.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章中，我们向读者提供了一个真实专业编程的一瞥，并简要概述了这一行业的挑战。我们重新审视了许多现代术语，这些术语与使用高度可扩展、响应迅速和具有弹性的反应式系统相关，这些系统能够解决现代时代的具有挑战性的处理问题。我们甚至提供了这些系统的代码示例，这可能是您真实项目的第一步。
- en: We hope that you remain curious, that you will continue studying and experimenting,
    and that you will eventually build a system that will solve a real problem and
    bring more happiness to the world.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您保持好奇心，继续学习和实验，并最终建立一个能够解决真实问题并为世界带来更多幸福的系统。
