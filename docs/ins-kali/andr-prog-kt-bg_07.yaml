- en: Chapter 7. Kotlin Variables, Operators, and Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。Kotlin变量，运算符和表达式
- en: In this chapter and the next, we are going to learn and practice the core fundamentals
    of Kotlin. In fact, we will explore the main principles of programming in general.
    In this chapter, we will focus on the creation and understanding of data itself,
    and in the next chapter, we will explore how to manipulate and respond to it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和下一章中，我们将学习和实践Kotlin的核心基础知识。事实上，我们将探索编程的主要原则。在本章中，我们将重点关注数据本身的创建和理解，在下一章中，我们将探索如何操作和响应数据。
- en: This chapter will focus on the simplest type of data in Kotlin – variables.
    We will revisit more complex and powerful types of data in [Chapter 15,](ch15.html
    "Chapter 15. Handling Data and Generating Random Numbers") *Handling Data and
    Generating Random Numbers.*
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍Kotlin中最简单的数据类型-变量。我们将在[第15章](ch15.html "第15章。处理数据和生成随机数") *处理数据和生成随机数*中重新讨论更复杂和强大的数据类型。
- en: The core Kotlin fundamentals that we'll learn about apply when working within
    classes that we inherit from (such as `Activity` and `AppCompatActivity`) and
    the classes that we write ourselves (as we will start to do in [Chapter 10,](ch10.html
    "Chapter 10. Object-Oriented Programming") *Object-Oriented Programming*).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习的核心Kotlin基础知识适用于我们继承的类（例如`Activity`和`AppCompatActivity`）以及我们自己编写的类（正如我们将在[第10章](ch10.html
    "第10章。面向对象编程") *面向对象编程*中开始做的）。
- en: As it is more logical to learn the basics before we write our own classes, we
    will learn the basics and then use the extended `Activity` class, `AppCompatActivity`,
    to put this new theory into practice. We will use `Log` and `Toast` again to see
    the results of our coding. In addition, we will use more functions that we will
    write ourselves (called from buttons) as well as the overridden functions of the
    `Activity` class to trigger the execution of our code. We will save studying the
    full details on functions, however, until [Chapter 9,](ch09.html "Chapter 9. Kotlin
    Functions") *Kotlin Functions*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在编写自己的类之前学习基础知识更为合理，我们将学习基础知识，然后使用扩展的`Activity`类`AppCompatActivity`来将这个新理论付诸实践。我们将再次使用`Log`和`Toast`来查看我们编码的结果。此外，我们将使用更多我们自己编写的函数（从按钮调用），以及`Activity`类的重写函数来触发我们代码的执行。然而，我们将在[第9章](ch09.html
    "第9章。Kotlin函数") *Kotlin函数*中学习有关函数的全部细节。
- en: When we move onto [Chapter 10,](ch10.html "Chapter 10. Object-Oriented Programming")
    *Object-Oriented Programming*, and start to write our own classes, as well as
    gain an understanding about how classes that are written by others work, everything
    we have learned here will still apply then too.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们转到[第10章](ch10.html "第10章。面向对象编程") *面向对象编程*，并开始编写我们自己的类，以及了解其他人编写的类如何工作时，我们在这里学到的一切也将适用于那时。
- en: 'By the end of the chapter, you will be comfortable writing Kotlin code that
    creates and uses data within Android. This chapter will take you through the following
    topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够舒适地编写Kotlin代码，在Android中创建和使用数据。本章将带您了解以下主题：
- en: Learning the jargon
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习行话
- en: Learning some more about code comments
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习更多关于代码注释
- en: What are variables?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是变量？
- en: Types of variables
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量类型
- en: The different ways to declare variables
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明变量的不同方式
- en: Initializing variables
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化变量
- en: Operators and expressions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符和表达式
- en: The express yourself demo app
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达自己的演示应用程序
- en: Let's start by finding out exactly what a variable is.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先找出变量究竟是什么。
- en: Learning the jargon
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习行话
- en: Throughout this book, I will use simple English to explain a number of technical
    concepts. I will not ask you to read the technical explanation of a Kotlin or
    Android concept that has not been previously explained in non-technical language.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我将用简单的英语来解释许多技术概念。我不会要求您阅读以前未用非技术语言解释的Kotlin或Android概念的技术解释。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: 'A note to Java programmers who are new to Kotlin: if you have done some Java
    programming, then things are about to get weird! You might even swear that I have
    made some errors; perhaps you might even think that I have forgotten to add semicolons
    to the ends of all the lines of code! I urge you to keep reading because I think
    you will discover that Kotlin has some advantages over Java because it is more
    succinct and expressive. Learning Java still has its place because most of the
    Android API is still Java, and even if the entire Android community were to drop
    Java immediately (and they haven''t), there would still be legacy Java code for
    years to come. I won''t continually point out the differences between Java and
    Kotlin because there are so many and such an analysis is unnecessary. If you are
    interested, I recommend this article: [https://yalantis.com/blog/kotlin-vs-java-syntax/](https://yalantis.com/blog/kotlin-vs-java-syntax/).
    Ultimately, Kotlin and Java compile to the exact same Dalvik-compatible Java byte
    code. In fact, Java and Kotlin are 100% interoperable and can even be mixed together
    in a project. You can even paste Java code into a Kotlin project, and it will
    be instantly converted to Kotlin.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 致新接触Kotlin的Java程序员的一句话：如果您已经做过一些Java编程，那么事情将变得奇怪！您甚至可能会发誓我犯了一些错误；也许您甚至会认为我忘记了在所有代码行的末尾添加分号！我敦促您继续阅读，因为我认为您会发现Kotlin比Java有一些优势，因为它更为简洁和表达力强。学习Java仍然有其存在的价值，因为大多数Android
    API仍然是Java，即使整个Android社区立即放弃Java（他们没有），也会有多年的遗留Java代码。我不会不断指出Java和Kotlin之间的差异，因为差异太多，这样的分析是不必要的。如果您感兴趣，我建议阅读这篇文章：[https://yalantis.com/blog/kotlin-vs-java-syntax/](https://yalantis.com/blog/kotlin-vs-java-syntax/)。最终，Kotlin和Java编译为完全相同的Dalvik兼容Java字节码。事实上，Java和Kotlin是100%可互操作的，甚至可以在项目中混合使用。您甚至可以将Java代码粘贴到Kotlin项目中，它将立即转换为Kotlin。
- en: The Kotlin and Android communities are full of people who speak in technical
    terms; therefore, to join in and learn from these communities, you need to understand
    the terms that they use.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin和Android社区充满了使用技术术语的人；因此，要加入并从这些社区中学习，您需要理解他们使用的术语。
- en: So, the approach that this book takes is to learn a concept or get a rough outline
    using entirely simple language, but at the same time introduce the jargon or technical
    terms as part of the learning.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本书的方法是使用简单的语言学习概念或获得大致轮廓，同时将行话或技术术语作为学习的一部分引入。
- en: Kotlin syntax is the way that we put together the language elements of Kotlin
    to produce code that executes. The Kotlin syntax is a combination of the words
    that we use and the formation of those words into sentence-like structures that
    is our code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin语法是我们将Kotlin语言元素组合成可执行代码的方式。Kotlin语法是我们使用的单词和将这些单词组成类似句子的结构的组合，这就是我们的代码。
- en: These Kotlin "words" are many in number but, taken in small chunks, they are
    certainly easier to learn than any human language. We call these words **keywords**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些Kotlin“单词”数量众多，但是，分成小块来学习，它们肯定比任何人类语言更容易学习。我们称这些单词为**关键字**。
- en: I am confident that if you can read plain English then you can learn Kotlin,
    because learning Kotlin is much easier than learning to read English. So, what
    then separates someone who has finished an elementary Kotlin course such as this
    one and an expert programmer?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信，如果您能阅读简单的英语，那么您就可以学会Kotlin，因为学习Kotlin比学习阅读英语要容易得多。那么，是什么让完成了这样一个初级Kotlin课程的人和专业程序员之间有所不同呢？
- en: The answer is the exact same things that separate a student of language and
    a master poet. Expertise in Kotlin comes not in the number of Kotlin keywords
    we know how to use, but in the way that we use them. Mastery of the language comes
    through practice, further study, and using the keywords more skillfully. Many
    consider programming an art as much as a science, and there is some truth to this.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是语言学生和大师诗人之间的区别正是相同的东西。掌握Kotlin并不在于我们知道如何使用Kotlin关键字的数量，而在于我们如何使用它们。语言的掌握来自于实践、进一步的学习，以及更熟练地使用关键字。许多人认为编程与科学一样是一门艺术，这也有一定道理。
- en: More on code comments
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于代码注释
- en: As you become more advanced at writing Kotlin programs, the solutions that you
    use to create your programs will become longer and more complicated. Furthermore,
    as we will see in later chapters, Kotlin was designed to manage complexity by
    having us divide up our code into separate classes, usually across multiple files.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您在编写Kotlin程序方面变得更加高级，您用于创建程序的解决方案将变得更长、更复杂。此外，正如我们将在后面的章节中看到的，Kotlin旨在通过将代码分成单独的类（通常跨越多个文件）来管理复杂性。
- en: '**Code comments** are a part of the Kotlin files that do not have any function
    in the program execution itself; that is, the compiler ignores them. They serve
    to help the programmer to document, explain, and clarify their code to make it
    more understandable to themselves later, or to other programmers who might need
    to use or change it.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码注释**是Kotlin文件的一部分，在程序执行中没有任何功能；也就是说，编译器会忽略它们。它们用于帮助程序员记录、解释和澄清他们的代码，以便在以后更容易理解自己，或者其他需要使用或更改代码的程序员。'
- en: 'We have already seen a single-line comment:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了单行注释：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding comment begins with the two forward slash characters, `//`. The
    comment ends at the end of the line. So, anything on that line is for people only,
    whereas anything on the next line (unless it''s another comment) needs to be syntactically
    correct Kotlin code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的注释以两个斜杠字符`//`开头。注释在行末结束。因此，该行上的任何内容仅供人阅读，而下一行上的内容（除非是另一个注释）需要是符合语法的Kotlin代码：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can use multiple single-line comments, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多个单行注释，如下所示：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Single-line comments are also useful if we want to temporarily disable a line
    of code. We can put `//` in front of the code and it will not be included in the
    program. Refer back to this code, which tells Android to load our layout:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 单行注释也很有用，如果我们想临时禁用一行代码。我们可以在代码前面加上`//`，这样它就不会包含在程序中。回顾一下这段代码，它告诉Android加载我们的布局：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this situation, the layout will not be loaded, and the app will have a blank
    screen when run as the entire line of code is ignored by the compiler.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，布局将不会加载，当运行时应用程序将显示空白屏幕，因为整行代码被编译器忽略。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We saw this in [Chapter 5](ch05.html "Chapter 5. Beautiful Layouts with CardView
    and ScrollView"), *Beautiful Layouts with CardView and ScrollView* when we temporarily
    commented out one of the lines of code in a function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第5章](ch05.html "第5章。使用CardView和ScrollView创建美丽的布局")中看到了这一点，*使用CardView和ScrollView创建美丽的布局*，当我们暂时注释掉函数中的一行代码时。
- en: There is another type of comment in Kotlin known as the **multiline comment**.
    The multiline comment is useful for longer comments that span across multiple
    lines and for adding things such as copyright information at the top of a code
    file. Like the single-line comment, a multiline comment can be used to temporarily
    disable code; in this case, usually across multiple lines.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中还有另一种类型的注释，称为**多行注释**。多行注释适用于跨越多行的较长注释，以及在代码文件顶部添加版权信息等内容。与单行注释一样，多行注释可以用于临时禁用代码；在这种情况下，通常跨越多行。
- en: 'Everything in between the leading `/*` character and the ending `*/` character
    is ignored by the compiler. Take a look at the following examples:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/*`字符和`*/`字符之间的所有内容都将被编译器忽略。看一下以下示例：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There is no limit to the number of lines in a multiline comment; the type of
    comment that is best to use will depend upon the situation. In this book, I will
    always explain every line of code explicitly in the text, but you will often find
    liberally sprinkled comments within the code itself that add further explanation,
    insight, or context. So, it''s always a good idea to read all the code thoroughly:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释中没有行数限制；最好使用的注释类型将取决于具体情况。在本书中，我将始终在文本中明确解释每一行代码，但您通常会在代码本身中发现大量的注释，这些注释会进一步解释、洞察或提供上下文。因此，彻底阅读所有代码总是一个好主意：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: All the best programmers liberally sprinkle their code with comments!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有最优秀的程序员都会在他们的代码中大量使用注释！
- en: Variables
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: We can think of a **variable** as a named storage box. We choose a name, perhaps
    `variableA`. These names are the programmer's access into the memory of the user's
    Android device.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将**变量**看作是一个命名的存储盒。我们选择一个名称，也许是`variableA`。这些名称是程序员进入用户Android设备内存的途径。
- en: Variables are values in memory that are ready to be used when necessary by referring
    to them with their name.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是内存中的值，当需要时可以通过它们的名称引用它们。
- en: Computer memory has a highly complex system of addresses that, fortunately,
    we do not need to directly interact with. Kotlin variables allow us to devise
    our own convenient names for all the data that we need our app to work with. The
    operating system will, in turn, interact with the physical (hardware) memory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机内存有一个高度复杂的地址系统，幸运的是，我们不需要直接与之交互。Kotlin变量允许我们为应用程序需要处理的所有数据制定自己方便的名称。操作系统将与物理（硬件）内存进行交互。
- en: 'So, we can think of our Android device''s memory as a huge warehouse waiting
    for us to add our variables. When we assign names to our variables, they are stored
    in the warehouse, ready for when we need them. When we use our variable''s name,
    the device knows exactly what we are referring to. We can then tell it to do things,
    such as the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将我们的Android设备内存看作是一个巨大的仓库，等待我们添加我们的变量。当我们为变量分配名称时，它们存储在仓库中，以备我们需要时使用。当我们使用我们的变量名称时，设备知道我们在引用什么。然后我们可以告诉它做一些事情，比如以下内容：
- en: Assign a value to `variableA`
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`variableA`分配一个值
- en: Add `variableA` to `variableB`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`variableA`添加到`variableB`
- en: Test the value of `variableB` and take an action based on the result
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试`variableB`的值，并根据结果采取行动
- en: In a typical app, we might have a variable named `unreadMessages`; perhaps to
    hold the number of unread messages that the user has. We can add to it when a
    new message arrives, take away from it when the user reads a message, and show
    it to the user somewhere in the app's layout, so that they know how many unread
    messages they have.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的应用程序中，我们可能会有一个名为`unreadMessages`的变量；也许用于保存用户未读消息的数量。当有新消息到达时，我们可以将其添加到其中，当用户阅读消息时，我们可以从中减去，并在应用程序的布局中的某个地方向用户显示它，以便他们知道有多少未读消息。
- en: 'Situations that might arise can include the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 可能出现的情况包括以下几种：
- en: The user gets three new messages, so add three to the value of `unreadMessages`.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户收到三条新消息，所以将三条消息添加到`unreadMessages`的值中。
- en: The user logs into the app, so use `Toast` to display a message along with the
    value stored in `unreadMessages`.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户登录应用程序，因此使用`Toast`显示一条消息以及存储在`unreadMessages`中的值。
- en: The user sees that a couple of the messages are from someone they don't like
    and deletes two messages. We could then subtract two from `unreadMessages`.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户看到有几条消息来自他们不喜欢的人，并删除了两条消息。然后我们可以从`unreadMessages`中减去两个。
- en: Variable names are arbitrary, and if you don't use any of the characters or
    keywords that Kotlin restricts, you can call your variables whatever you like.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名是任意的，如果您不使用Kotlin限制的任何字符或关键字，可以随意命名变量。
- en: In practice, however, it is best to adopt a **naming convention** so that your
    variable names will be consistent. In this book, we will use a simple convention
    of variable names starting with a lowercase letter. When there is more than one
    word in the variable's name, the second word will begin with an uppercase letter.
    This is called **camel casing**.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，最好采用**命名约定**，以便您的变量名称保持一致。在本书中，我们将使用一个简单的变量命名约定，以小写字母开头。当变量名中有多个单词时，第二个单词将以大写字母开头。这被称为**驼峰命名法**。
- en: 'Here are some examples of camel-case variable names:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些驼峰命名法变量名称的示例：
- en: '`unreadMessages`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unreadMessages`'
- en: '`contactName`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contactName`'
- en: '`isFriend`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isFriend`'
- en: Before we take a look at some real Kotlin code that uses some variables, we
    need to first look at the **types** of variables that we can create and use.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看一些使用变量的实际Kotlin代码之前，我们需要首先看一下我们可以创建和使用的变量的**类型**。
- en: Types of variables
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量的类型
- en: It is not hard to imagine that even a simple app will have quite a few variables.
    In the previous section, we introduced the `unreadMessages` variable as a hypothetical
    example. What if the app has a list of contacts and needs to remember each of
    their names? Then, we might need variables for each contact.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是一个简单的应用程序也很容易想象会有相当多的变量。在前一节中，我们介绍了`unreadMessages`变量作为一个假设的例子。如果应用程序有一个联系人列表，并需要记住每个联系人的名字，那么我们可能需要为每个联系人创建变量。
- en: And what about when an app needs to know whether a contact is also a friend,
    or just a regular contact? We might need code that tests for friend status and
    then adds messages from that contact into an appropriate folder, so that the user
    knows whether they were messages from a friend or not.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序需要知道联系人是否也是朋友，还是普通联系人时，该怎么办？我们可能需要测试朋友状态的代码，然后将该联系人的消息添加到适当的文件夹中，以便用户知道它们是来自朋友还是其他人的消息。
- en: Another common requirement in a computer program, including Android apps, is
    the right or wrong test. Computer programs represent right or wrong calculations
    using **true** and **false**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序的另一个常见要求，包括Android应用程序，是正确或错误的测试。计算机程序使用**true**和**false**表示正确或错误的计算。
- en: To cover these and many other types of data that you might want to store or
    manipulate, Kotlin uses variables of different **types**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了涵盖您可能想要存储或操作的许多其他类型的数据，Kotlin使用不同**类型**的变量。
- en: There are many types of variables, and we can even invent our own types as well.
    But, for now, we will look at the most commonly-used Kotlin types, and these will
    cover just about every situation that we are likely to run into. The best way
    to explain types is through a number of examples.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类型的变量，我们甚至可以发明自己的类型。但是，现在我们将看一下最常用的Kotlin类型，这些类型将涵盖我们可能遇到的几乎所有情况。解释类型的最佳方法是通过一些示例。
- en: We have already discussed the hypothetical `unreadMessages` variable. This variable
    is, of course, a number.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了假设的`unreadMessages`变量。这个变量当然是一个数字。
- en: On the other hand, the hypothetical `contactName` variable will hold the characters
    or letters that make up a contact's name.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，假设的`contactName`变量将保存组成联系人姓名的字符或字母。
- en: The type that holds a regular number is called an **Int** (an abbreviation of
    integer) type, and the type that holds name-like data is called a **String**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 保存常规数字的类型称为**Int**（整数的缩写）类型，保存类似名称的数据的类型称为**String**。
- en: 'Here is a list of the types of variables that we will use in this book:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本书中将使用的变量类型列表：
- en: '`Int`: The `Int` type is for storing integers and whole numbers. This type
    can store values with a size that is in excess of 2 billion, including negative
    values too.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int`：`Int`类型用于存储整数和整数。此类型可以存储超过20亿的值，包括负值。'
- en: '`Long`: As the name suggests, `Long` data types can be used when even larger
    numbers are needed. A `Long` variable can store numbers up to 9,223,372,036,854,775,807\.
    That''s a lot of unread messages. There are plenty of uses for `Long` variables,
    but if a smaller variable will do, we should use it because our app will use less
    memory.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Long`：顾名思义，当需要更大的数字时，可以使用`Long`数据类型。`Long`变量可以存储高达9,223,372,036,854,775,807的数字。那是很多未读消息。`Long`变量有很多用途，但如果较小的变量可以胜任，我们应该使用它，因为我们的应用程序将使用更少的内存。'
- en: '`Float`: This variable is used for floating point numbers. That is, numbers
    where there is precision beyond the decimal point. As the fractional part of a
    number takes memory space just as the whole number part, the range of a number
    that is possible in a `Float` variable is, therefore, decreased compared to non-floating-point
    numbers. So, unless our variable will use the extra precision, `Float` will not
    be our data type of choice.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Float`：此变量用于浮点数。也就是说，小数点后有精度的数字。由于数字的小数部分占用的内存空间与整数部分一样，因此与非浮点数相比，`Float`变量中可能的数字范围会减少。因此，除非我们的变量将使用额外的精度，否则`Float`不会是我们的数据类型选择。'
- en: '`Double`: When the precision in a `Float` variable is not enough, we have `Double`.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Double`：当`Float`变量中的精度不够时，我们有`Double`。'
- en: '`Boolean`: We will be using plenty of Booleans throughout the book. The `Boolean`
    variable type can be either `true` or `false`; nothing else. Booleans answer questions,
    such as the following:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boolean`：我们将在整本书中使用大量布尔值。`Boolean`变量类型可以是`true`或`false`；没有其他选项。布尔值回答问题，例如：'
- en: Is the contact a friend?
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系人是朋友吗？
- en: Are there any new messages?
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有新消息吗？
- en: Are two examples of Booleans enough?
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个布尔值的例子足够了吗？
- en: '`Char`: This stores a single alphanumeric character. It''s not going to change
    the world on its own, but it could be useful if we put lots of them together.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Char`：这个类型存储单个字母数字字符。它本身不会改变世界，但如果我们把它们放在一起，它可能会有用。'
- en: '`String`: Strings can be used to store any keyboard character. It is similar
    to a `Char` variable but of almost any length. Anything from a contact''s name
    to an entire book can be stored in a single `String`. We will be using Strings
    regularly, including in this chapter.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`：字符串可以用来存储任何键盘字符。它类似于`Char`变量，但长度几乎可以是任意的。从联系人的姓名到整本书都可以存储在一个`String`中。我们将经常使用字符串，包括在本章中。'
- en: '`Class`: This is the most powerful data type and we have already discussed
    it a little. We will take a deep dive into classes in [Chapter 10](ch10.html "Chapter 10. Object-Oriented
    Programming"), *Object-Oriented Programming*.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Class`：这是最强大的数据类型，我们已经稍微讨论过了。我们将在[第10章](ch10.html "第10章。面向对象编程")中深入探讨类，面向对象编程。'
- en: '`Array`: This type comes in lots of different flavors and is key for handling
    and organizing large sets of data. We will explore the variations of `Array` in
    [Chapter 15](ch15.html "Chapter 15. Handling Data and Generating Random Numbers")*,
    Handling Data and Generating Random Numbers.*'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array`：这种类型有很多不同的变体，对于处理和组织大量数据至关重要。我们将在[第15章](ch15.html "第15章。处理数据和生成随机数")中探讨`Array`的变体，处理数据和生成随机数。'
- en: Now we know what variables are and that there is a wide selection of types,
    we are nearly ready to see some actual Kotlin code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了变量是什么，以及有各种类型可供选择，我们几乎准备好看一些实际的Kotlin代码了。
- en: Declaring and initializing variables
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明和初始化变量
- en: Before we can use a variable type that we just discussed, we must **declare**
    them, so that the compiler knows they exist, and we must also **initialize** them,
    so they hold a value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用刚讨论的变量类型之前，我们必须**声明**它们，以便编译器知道它们的存在，并且我们还必须**初始化**它们，以便它们保存一个值。
- en: 'For each of the variable types in Kotlin, such as `Int`, `Float`, and `String`,
    there are two keywords that we can use to declare them: `val` and `var`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Kotlin中的每种变量类型，如`Int`、`Float`和`String`，我们可以使用两个关键字来声明它们：`val`和`var`。
- en: The `val` type is for storing values that are decided by the programmer before
    the application starts or during initialization and cannot be changed again during
    execution. The `var` type is for values that can be manipulated and altered throughout
    execution.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`val`类型用于存储在应用程序启动之前或初始化期间由程序员决定的值，并且在执行过程中不能再次更改。`var`类型用于可以在执行过程中操作和更改的值。'
- en: Therefore, the `val` type is only readable. In technical terms, it is known
    as **immutable**. The `var` type is readable and writeable, and this is called
    **mutable**. Writing code that attempts to change the value of a `val` type during
    execution will cause Android Studio to show an error and the code will not compile.
    There are also rules for `var` that we will explore later.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`val`类型只能读取。在技术术语中，它被称为**不可变**。`var`类型可读可写，这被称为**可变**。在执行过程中尝试更改`val`类型的值的代码将导致Android
    Studio显示错误，代码将无法编译。我们将在后面探讨`var`的规则。
- en: 'There are the two ways that we can declare and initialize a `String` type;
    first, by using `val`, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以声明和初始化`String`类型；首先，通过使用`val`，如下所示：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding line of code, a new `val` variable named `contactName` and
    of type `String` is declared and now holds the `Gordon Freeman` value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，声明了一个名为`contactName`的新`val`变量，类型为`String`，现在持有`Gordon Freeman`的值。
- en: 'Furthermore, the `Gordon Freeman` text is now the only value that `contactName`
    can hold for the duration of the app''s execution. You could attempt to change
    it with the following line of code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Gordon Freeman`文本现在是`contactName`在应用程序执行期间唯一可以持有的值。你可以尝试使用以下代码更改它：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is what you will see if you paste the preceding code into the `onCreate`
    function in an Android project:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将前面的代码粘贴到Android项目的`onCreate`函数中，你将看到以下内容：
- en: '![Declaring and initializing variables](img/B12806_07_01.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![声明和初始化变量](img/B12806_07_01.jpg)'
- en: 'Android Studio is helping us to enforce our decision to make the variable **constant**.
    Of course, we will frequently need to change the value held by a variable. When
    we do, we will use `var` instead; take a look at the next two lines of code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio正在帮助我们强制执行我们的决定，使变量成为**常量**。当然，我们经常需要更改变量持有的值。当我们这样做时，我们将使用`var`；看一下接下来的两行代码：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we use `var` to declare a `String` type, and this time
    we successfully change the value held by `contactName` to `Alyx Vance`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`var`声明了一个`String`类型，这次成功地将`contactName`持有的值更改为`Alyx Vance`。
- en: The point to take away here is that if the variable does not need to change
    during the execution of the app, then we should use `val`, because the compiler
    can help to protect us from making mistakes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要记住的一点是，如果变量在应用程序执行期间不需要更改，那么我们应该使用`val`，因为编译器可以帮助我们避免犯错。
- en: 'Let''s declare and initialize some different types of variables:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明和初始化一些不同类型的变量：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that in the previous code, I declared variables as `val` when they are
    unlikely to change and as `var` when it is likely that they will change. As you
    develop your app, you can guess whether to use `val` or `var` and, if necessary,
    you can change a `var` variable to a `val` variable, or the other way around.
    Also, in the preceding code notice that `String` types are initialized with the
    value between speech marks but `Int`, `Float`, `Long`, and `Boolean` are not.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的代码中，当变量不太可能改变时，我将其声明为`val`，而当它可能会改变时，我将其声明为`var`。在开发应用程序时，你可以猜测是使用`val`还是`var`，如果有必要，你可以将`var`变量更改为`val`变量，或者反过来。另外，在前面的代码中，请注意`String`类型是用引号中的值进行初始化的，但`Int`、`Float`、`Long`和`Boolean`却不是。
- en: Saving keystrokes with type inference
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类型推断节省击键
- en: Kotlin was designed to be as succinct as possible. It was one of the aims of
    the JetBrains team to let developers get as much done with as little code as possible.
    We will see examples of this throughout the Kotlin language. If you have previously
    coded in another language, especially Java, you will notice a significant reduction
    in typing. The first example of this is **type inference**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin的设计目标是尽可能简洁。JetBrains团队的目标之一是让开发人员用尽可能少的代码完成尽可能多的工作。我们将在整个Kotlin语言中看到这样的例子。如果你之前在其他语言，特别是Java中编码过，你会注意到输入量的显著减少。这种减少的第一个例子就是**类型推断**。
- en: 'Kotlin can often infer the type you need from the context, and if this is the
    case, then you don''t need to write the type explicitly; consider the following
    example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin通常可以从上下文中推断出你需要的类型，如果是这种情况，那么你就不需要显式地写出类型；考虑下面的例子：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, a `String` type called `contactName` is declared and
    initialized using "Xian Mei". If you think about it for a moment, it must be a
    `String`. Fortunately, this is obvious to the Kotlin compiler too. We could (and
    should) improve the preceding line of code using type inference, such as with
    this next code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，声明了一个名为`contactName`的`String`类型，并使用"Xian Mei"进行了初始化。如果你仔细想一想，它必须是一个`String`。幸运的是，Kotlin编译器也能明白这一点。我们可以（而且应该）改进前面的代码，使用类型推断，就像下面的代码一样：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The colon and the type have been omitted, but the result is identical.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号和类型已被省略，但结果是相同的。
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Java programmers will also notice that Kotlin code does not need to have a
    semicolon at the end of each line. If you like semicolons, however, the compiler
    will not complain if you do add one to the end of each line:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Java程序员也会注意到，Kotlin代码不需要在每行末尾加上分号。然而，如果你喜欢分号，编译器也不会抱怨你在每行末尾加上分号：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We must remember, however, that although we haven''t specified `String` explicitly,
    it is still a `String` type – and only a `String` type. If we try to do something
    unsuitable for a `String` type, then we will get an error; for example, as we
    do when we try to reinitialize it to a number value as in this code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须记住，尽管我们没有明确指定`String`，它仍然是一个`String`类型——只是一个`String`类型。如果我们尝试对`String`类型不合适的操作，那么我们将会得到一个错误；例如，当我们尝试将其重新初始化为一个数字值时，就像这段代码中所做的那样：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code will be flagged in Android Studio and compilation won''t
    work. Here are all the declarations and initializations from the previous section
    of code, but this time using type inference:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将在Android Studio中标记，并且编译不会成功。以下是前一节代码中的所有声明和初始化，但这次使用了类型推断：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We will see more type inference with variables in the next two sections, and
    in later chapters, we will use type inference with more complex types such as
    classes, Arrays, and Collections. Type inference will also become a good timesaver,
    by making our code shorter and more manageable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，我们将看到更多关于变量的类型推断，在后面的章节中，我们将使用类型推断来处理更复杂的类型，比如类、数组和集合。类型推断也将成为一个很好的时间节省器，使我们的代码更短、更易管理。
- en: 'It might sound obvious, but it is worth mentioning that if you are declaring
    a variable for initialization later then type inference is not possible, as shown
    in the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来很明显，但值得一提的是，如果你在声明一个变量以便稍后初始化，那么类型推断是不可能的，就像下面的代码所示：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding line of code will cause an error and the app will not compile.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码会导致错误，应用程序将无法编译。
- en: 'When using type inference, it will usually be obvious what type a variable
    is but, if there is ever any doubt, you can select a variable in Android Studio
    and press *Shift* + *Ctrl* + *P* simultaneously to get a handy onscreen hint:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用类型推断时，变量的类型通常是显而易见的，但如果有任何疑问，您可以在Android Studio中选择一个变量，同时按*Shift* + *Ctrl*
    + *P*来获得一个方便的屏幕提示：
- en: '![Saving keystrokes with type inference](img/B12806_07_02.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![使用类型推断节省按键](img/B12806_07_02.jpg)'
- en: Omitting the occasional `String`, `Int`, or colon (`:`) type isn't going to
    change much on its own, so let's learn how to make **expressions** with our variables
    by combining them with **operators**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔省略`String`、`Int`或冒号（`:`）类型本身不会有太大变化，所以让我们学习如何通过将它们与**运算符**结合来制作**表达式**。
- en: Operators and expressions
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符和表达式
- en: Of course, in almost any program, we are going to need to "do things" with these
    variables' values. We can manipulate and change variables with operators. When
    we combine operators and variables for a result, it is called an expression.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在几乎任何程序中，我们都需要用这些变量的值来“做事情”。我们可以使用运算符来操作和改变变量。当我们将运算符和变量组合以获得结果时，这被称为表达式。
- en: The following sections list the most common Kotlin operators that allow us to
    manipulate variables. You do not need to memorize them as we will look at every
    line of code as and when we use them for the first time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节列出了最常见的Kotlin运算符，允许我们操作变量。您不需要记住它们，因为我们将在第一次使用它们时查看每行代码。
- en: We already saw the first operator when we initialized our variables in the previous
    section, but we will see it again being a bit more adventurous.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节初始化变量时已经看到了第一个运算符，但我们将再次看到它变得更加冒险。
- en: The assignment operator
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: 'This is the assignment operator:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是赋值运算符：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It makes the variable to the left of the operator the same as the value to
    the right; for example, as in this line of code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它使运算符左侧的变量与右侧的值相同；例如，就像这行代码中的例子：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After the previous line of code has executed, the value stored in `unreadMessages`
    will be the same as the value stored in `newMessages`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一行代码执行后，`unreadMessages`中存储的值将与`newMessages`中存储的值相同。
- en: The addition operator
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加法运算符
- en: 'This is the addition operator:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是加法运算符：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It will add together values on either side of the operator. It''s usually used
    in conjunction with the assignment operator. For example, it can add together
    two variables that have numeric values, as in this next line of code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 它将运算符两侧的值相加。通常与赋值运算符一起使用。例如，它可以将具有数值的两个变量相加，就像下一行代码中的例子：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once the previous code has executed, the sum of the values held by `newMessages`
    and `unreadMessages` will be stored in `unreadMessages`. As another example of
    the same thing, take a look at this line of code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦前面的代码执行了，`newMessages`和`unreadMessages`所保存的值的总和将存储在`unreadMessages`中。作为同样的例子，看看这行代码：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that it is perfectly acceptable (and quite common) to use the same variable
    simultaneously on both sides of an operator.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，同时在运算符的两侧同时使用同一个变量是完全可以接受的（并且非常常见）。
- en: The subtraction operator
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减法运算符
- en: 'This is the subtraction operator:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是减法运算符：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It will subtract the value on the right side of the operator from the value
    on the left. This is usually used in conjunction with the assignment operator,
    as in this example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它将从运算符左侧的值中减去运算符右侧的值。通常与赋值运算符一起使用，就像这个例子中：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Another example of the subtraction operator is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 减法运算符的另一个例子如下：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After the previous line of code has executed, `accountBalance` will hold its
    original value minus whatever the value held in `withdrawals` is.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一行代码执行后，`accountBalance`将保持其原始值减去`withdrawals`中保存的值。
- en: The division operator
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 除法运算符
- en: 'This is the division operator:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是除法运算符：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It will divide the number on the left by the number on the right. Again, it''s
    usually used in conjunction with the assignment operator; here is an example line
    of code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 它将左侧的数字除以右侧的数字。同样，通常与赋值运算符一起使用；这是一个例子行代码：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If, in the previous line of code, `numSweets` held nine and `numChildren` held
    three, then `fairShare` would now hold the value of three.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在前一行代码中，`numSweets`为9，`numChildren`为3，则`fairShare`现在将保存值为3。
- en: The multiplication operator
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 乘法运算符
- en: 'This is the multiplication operator:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是乘法运算符：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It will multiply variables and numbers together and, as with many of the other
    operators, is usually used in conjunction with the assignment operator; for example,
    look at this line of code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 它将变量和数字相乘，与许多其他运算符一样，通常与赋值运算符一起使用；例如，看看这行代码：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Another example of the multiplication operator is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法运算符的另一个例子如下：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After the previous two lines of code have executed, `answer` holds the value
    100, and `biggerAnswer` holds the value 1000.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两行代码执行后，`answer`保存的值为100，`biggerAnswer`保存的值为1000。
- en: The increment operator
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递增运算符
- en: 'This is the increment operator:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是递增运算符：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The increment operator is a quick way to add one to something. For example,
    take a look at this next line of code, which uses the addition operator:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 递增运算符是将某物加一的快速方法。例如，看看下一行代码，它使用了加法运算符：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The previous line of code has the same result as this much more compact code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行代码的结果与这个更紧凑的代码相同：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The decrement operator
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递减运算符
- en: 'This is the decrement operator:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是递减运算符：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The decrement operator (as you have you probably guessed) is a quick way to
    subtract one from something. For example, take a look at this next line of code,
    which uses the subtraction operator:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 递减运算符（你可能已经猜到）是从某物中减去一个的快速方法。例如，看看下一行代码，它使用了减法运算符：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The previous line of code is the same as `myVariable --.`
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行代码与`myVariable --.`相同。
- en: Now we can put this new knowledge into a working app.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将这些新知识应用到一个工作中的应用程序中。
- en: The express yourself demo app
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达自己的演示应用程序
- en: Let's try using some declarations, assignments, and operators. When we bundle
    these elements together into some meaningful syntax, we call it an **expression**.
    Let's write a quick app to try some out. We will then use `Toast` and `Log` to
    check our results.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用一些声明、赋值和运算符。当我们将这些元素捆绑到一些有意义的语法中时，我们称之为**表达式**。让我们写一个快速的应用程序来尝试一些。然后我们将使用`Toast`和`Log`来检查我们的结果。
- en: Create a new project called `Express Yourself`, use an **Empty Activity** project
    template, and leave all the other options in their usual settings. The completed
    code that we will write in this project can be found in the `Chapter07` folder
    of the download bundle.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Express Yourself`的新项目，使用**空活动**项目模板，并将所有其他选项保持在它们通常的设置中。我们将在下载包的`Chapter07`文件夹中找到我们将在这个项目中编写的完成代码。
- en: 'Switch to the **MainActivity** tab in the editor and we will write some code.
    In the `onCreate` function, just before the closing curly brace (`}`), add this
    highlighted code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到编辑器中的**MainActivity**选项卡，我们将写一些代码。在`onCreate`函数中，在闭合大括号（`}`）之前，添加这个突出显示的代码：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We have just added four variables to the `onCreate` function. The first two
    are `val` variables that cannot be altered. They are a `String` type that holds
    a person's name and an `Int` type holding a year of birth. The types are not explicitly
    mentioned in the code; they are inferred.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在`onCreate`函数中添加了四个变量。前两个是`val`变量，不能被改变。它们是一个`String`类型，保存一个人的名字，和一个`Int`类型，保存出生年份。类型在代码中没有明确提到；它们是被推断出来的。
- en: The next two variables are `var` variables. We have an `Int` type to represent
    the current year, and an `Int` type that is uninitialized to represent the age
    of a person. As the `age` variable is uninitialized, its type cannot be inferred,
    and so we must specify it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个变量是`var`变量。我们有一个`Int`类型来表示当前年份，和一个未初始化的`Int`类型来表示一个人的年龄。由于`age`变量未初始化，它的类型无法被推断，所以我们必须指定它。
- en: 'After the previous code, still inside `onCreate`, add the following lines:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码之后，仍然在`onCreate`内部，添加以下行：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run the app and notice the following output in the logcat window:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，注意在logcat窗口中的以下输出：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The use of the `$` symbol in the speech marks of the `Log.i…` code indicates
    to the compiler that we want to output the *value stored in* the `age` variable,
    not the literal word "age".
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Log.i…`代码的引号中使用`$`符号表示我们想要输出`age`变量中存储的*值*，而不是字面上的单词"age"。
- en: The actual value itself (76), indicates that the value stored in `yearOfBirth`
    (1943) was subtracted from the value stored in `currentYear` (2019), and the result
    was used to initialize the `age` variable. As you will see, we can include as
    many `$` symbols in speech marks as we like and mix them with text and even Kotlin
    expressions. This feature is known as **String templates**. Let's try another
    String template.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的值本身（76），表示存储在`yearOfBirth`（1943）中的值被减去存储在`currentYear`（2019）中的值，结果被用来初始化`age`变量。正如你将看到的，我们可以在引号中包含尽可能多的`$`符号，并将它们与文本甚至Kotlin表达式混合使用。这个特性被称为**字符串模板**。让我们尝试另一个字符串模板。
- en: 'Add these two lines of code after the previous code inside the `onCreate` function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`函数内的前面的代码之后添加这两行代码：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first thing to explain about the code is that although it is formatted as
    four lines in this book, when you enter it into Android Studio it must be entered
    as two. The first line, `currentYear++`, increments (adds one) to the value stored
    in `currentYear`. All the rest of the code is one line.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这段代码的第一件事是，尽管它在这本书中格式化为四行，但当你输入到Android Studio中时，它必须输入为两行。第一行`currentYear++`，增加（加一）到存储在`currentYear`中的值。所有其余的代码都是一行。
- en: 'Run the app and observe the following output in the logcat window:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，观察logcat窗口中的以下输出：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The code works because of Kotlin String templates. Let''s break down this rather
    long line of code. First, we call the `Log.i` function as we have done many times
    before. In the first String, we pass `"info"` and, in the second, we pass a selection
    of variable names preceded by the `$` symbol mixed up with some literal text.
    The most interesting part of the breakdown is the second to last part as we use
    an expression to form part of the String:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码之所以有效，是因为Kotlin字符串模板。让我们分解这行相当长的代码。首先，我们像以前做过很多次一样调用`Log.i`函数。在第一个字符串中，我们传递了`"info"`，在第二个字符串中，我们传递了一些变量名，前面加上`$`符号，混合了一些字面文本。分解中最有趣的部分是倒数第二部分，因为我们使用一个表达式来形成字符串的一部分：
- en: '`$name` prints Nolan Bushnell'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$name`打印出Nolan Bushnell'
- en: '`Was born in` is literal text'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Was born in`是字面文本'
- en: '`$yearOfBirth` prints 1943'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$yearOfBirth`打印出1943'
- en: The literal text, `and is`, follows next
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字面文本`and is`接下来
- en: '`$currentAge` prints 76'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$currentAge`打印出76'
- en: Next, follows the literal text of `years old`
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是字面文本`years old`
- en: The literal text, `Next year he will be`, follows next
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字面文本`Next year he will be`接下来
- en: '`${currentYear - yearOfBirth}` is an expression, and the result of the expression
    (77) is printed'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${currentYear - yearOfBirth}`是一个表达式，表达式的结果（77）被打印出来'
- en: The final literal text, `years old`, is printed to conclude the output
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的字面文本`years old`被打印出来以结束输出
- en: 'This demonstrates that we can include any valid Kotlin expression inside a
    `String` type using the following form:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们可以使用以下形式在`String`类型中包含任何有效的Kotlin表达式：
- en: '`${expression}`'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`${expression}`'
- en: We will see more complex and powerful expressions in the next chapter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到更复杂和强大的表达式。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned the fundamental building blocks of data in
    Kotlin. We have explored the different types and an overview of their different
    uses. We have also learned how to use String templates to build Strings from literal
    values, variables, and expressions. We also saw how we can and should use type
    inference to make our code more concise when possible.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Kotlin中数据的基本构建块。我们探讨了不同类型及其不同用途的概述。我们还学会了如何使用字符串模板从字面值、变量和表达式构建字符串。我们还看到了在可能的情况下，我们可以和应该使用类型推断使我们的代码更简洁。
- en: We didn't see much of the Boolean variable type, but we will right that wrong
    in the next chapter when we learn about Kotlin decisions and loops.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有看到太多关于布尔变量类型，但在下一章中，当我们学习 Kotlin 的决策和循环时，我们将纠正这一错误。
