- en: Implementing Data Parallelism
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现数据并行性
- en: 'So far, we have learned about the basics of parallel programming, tasks, and
    task parallelism. In this chapter, we will cover another important aspect of parallel
    programming, which deals with the parallel execution of data: data parallelism.
    While task parallelism creates a separate unit of work for each participating
    thread, data parallelism creates a common task that is executed by every participating
    thread in a source collection. This source collection is partitioned so that multiple
    threads can work on it concurrently. Therefore, it is important to understand
    data parallelism to get the maximum performance out of loops/collections.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了并行编程、任务和任务并行性的基础知识。在本章中，我们将涵盖并行编程的另一个重要方面，即处理数据的并行执行：数据并行性。虽然任务并行性为每个参与线程创建了一个单独的工作单元，但数据并行性创建了一个由源集合中的每个参与线程执行的共同任务。这个源集合被分区，以便多个线程可以同时对其进行处理。因此，了解数据并行性对于从循环/集合中获得最大性能至关重要。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Handling exceptions in parallel loops
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在并行循环中处理异常
- en: Creating custom partitioning strategies in parallel loops
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在并行循环中创建自定义分区策略
- en: Canceling loops
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消循环
- en: Understanding thread storage in parallel loops
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解并行循环中的线程存储
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter, you should have a good understanding of the TPL and
    C#. The source code for this chapter is available on GitHub at [https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter03).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您应该对TPL和C#有很好的理解。本章的源代码可在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter03)。
- en: Moving from sequential loops to parallel loops
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从顺序循环转换为并行循环
- en: The TPL supports data parallelism through the `System.Threading.Tasks.Parallel`
    class, which provides parallel implementation of the `For` and `Foreach` loops.
    As a developer, you don't need to worry about synchronization or creating tasks
    as this is handled by the parallel class. This syntactic sugar allows you to easily
    write parallel loops in a way that's similar to how you have been writing sequential
    loops.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: TPL通过`System.Threading.Tasks.Parallel`类支持数据并行性，该类提供了`For`和`Foreach`循环的并行实现。作为开发人员，您不需要担心同步或创建任务，因为这由并行类处理。这种语法糖使您可以轻松地编写并行循环，方式类似于您一直在编写顺序循环。
- en: 'Here is an example of a sequential `for` loop that books a trade by posting
    the trade object to the server:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个顺序`for`循环的示例，它通过将交易对象发布到服务器来预订交易：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since the loop is sequential, the total time that it takes to finish the loop
    is the time it takes to book one trade multiplied by the total number of trades.
    This means that the loop slows down as the number of trades increases, although
    the trade booking time remains the same. Here, we are dealing with large numbers.
    Since we are going to be booking trades on a server and all the servers support
    multiple requests, it makes sense to convert this loop from a sequential loop
    into a parallel loop as that will give us significant performance gains.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于循环是顺序的，完成循环所需的总时间是预订一笔交易所需的时间乘以交易的总数。这意味着随着交易数量的增加，循环会变慢，尽管交易预订时间保持不变。在这里，我们处理的是大量数据。由于我们将在服务器上预订交易，并且所有服务器都支持多个请求，将这个循环从顺序循环转换为并行循环是有意义的，因为这将给我们带来显著的性能提升。
- en: 'The previous code can be converted so that it''s parallel as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将先前的代码转换为并行代码，如下所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While running a parallel loop, the TPL partitions the source collection so that
    the loop can execute on multiple parts concurrently. The partitioning of tasks
    is done by the `TaskScheduler` class, which takes the system resources and the
    load into consideration while creating partitions. We can also create a **custom
    partitioner** or **scheduler**, as we will see later in this chapter in the *Creating
    a custom partitioning strategy* section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行并行循环时，TPL对源集合进行分区，以便循环可以同时在多个部分上执行。任务的分区是由`TaskScheduler`类完成的，该类在创建分区时考虑系统资源和负载。我们还可以创建一个**自定义分区器**或**调度器**，正如我们将在本章的*创建自定义分区策略*部分中看到的。
- en: 'Data parallelism performs better if the partitioning units are independent.
    With minimal performance overhead, we can also create dependency partitioning
    units using a technique called reduction, which reduces a series of operations
    to a scalar value. There are three ways to convert sequential code into parallel
    code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数据并行性表现更好，如果分区单元是独立的。通过一种称为减少的技术，我们还可以创建依赖分区单元，以最小的性能开销将一系列操作减少为标量值。有三种方法可以将顺序代码转换为并行代码：
- en: Using the `Parallel.Invoke` method
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Parallel.Invoke`方法
- en: Using the `Parallel.For` method
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Parallel.For`方法
- en: Using the `Parallel.ForEach` method
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Parallel.ForEach`方法
- en: Let’s try to understand the various ways in which the `Parallel` class can be
    utilized to exhibit data parallelism.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着了解`Parallel`类可以用于展示数据并行性的各种方式。
- en: Using the Parallel.Invoke method
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Parallel.Invoke方法
- en: 'This is the most basic way of executing a set of operations in parallel and
    forms the basis for parallel `for` and `foreach` loops. The `Parallel.Invoke`
    method accepts an array of actions as a parameter and executes them, though it
    never guarantees that the actions will be executed in parallel. There are some
    important points to remember when using `Parallel.Invoke`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是以并行方式执行一组操作的最基本方式，也是并行`for`和`foreach`循环的基础。`Parallel.Invoke`方法接受一个操作数组作为参数并执行它们，尽管它不能保证操作将并行执行。在使用`Parallel.Invoke`时有一些重要的要点需要记住：
- en: Parallelism is not guaranteed. Whether the actions are executed in parallel
    or in sequence will depend on the `TaskScheduler`.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行性不能保证。操作是并行执行还是按顺序执行将取决于`TaskScheduler`。
- en: '`Parallel.Invoke` doesn''t guarantee the order of operations for passed actions.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Parallel.Invoke`不能保证传递的操作的顺序。'
- en: It blocks the calling thread until all the actions are completed.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会阻塞调用线程，直到所有的动作都完成。
- en: 'The syntax of `Parallel.Invoke` is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.Invoke`的语法如下：'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can either pass an action or a lambda expression, as demonstrated in the
    following example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以传递一个动作或一个lambda表达式，如下例所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Invoke` method behaves like an attached child task as it is blocked until
    all the actions are completed. All the exceptions are stacked together inside
    `System.AggregateException` and thrown to the caller. In the preceding code, since
    there is no exception, we will see the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invoke`方法的行为就像一个附加的子任务，因为它被阻塞，直到所有的动作都完成。所有的异常都被堆叠在`System.AggregateException`中，并抛出给调用者。在前面的代码中，由于没有异常，我们将看到以下输出：'
- en: '![](img/66a69638-847b-4d6a-b800-164e267cc832.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66a69638-847b-4d6a-b800-164e267cc832.png)'
- en: 'We can achieve a similar effect using the `Task` class, although this may look
    like very complex code in comparison to how `Parallel.Invoke` works:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Task`类来实现类似的效果，尽管与`Parallel.Invoke`的工作方式相比，这可能看起来非常复杂：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Invoke` method behaves like an attached child task as it is blocked until
    all the actions are completed. All the exceptions are stacked together inside
    `System.AggregateException` and thrown to the caller.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invoke`方法的行为就像一个附加的子任务，因为它被阻塞，直到所有的动作都完成。所有的异常都被堆叠在`System.AggregateException`中，并抛出给调用者。'
- en: Using the Parallel.For method
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Parallel.For方法
- en: '`Parallel.For` is a variant of the sequential `for` loop, with the difference
    that the iterations run in parallel. `Parallel.For` returns an instance of the `ParallelLoopResult`
    class, which provides the loop competition status once the loop has finished execution.
    We can also check the `IsCompleted` and `LowestBreakIteration` properties of `ParallelLoopResult`
    to find out if the method has completed or canceled, or if break has been called
    by the users. Here are the possible scenarios:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.For`是顺序`for`循环的一个变体，不同之处在于迭代是并行运行的。`Parallel.For`返回`ParallelLoopResult`类的一个实例，一旦循环执行完成，它提供了循环完成状态。我们还可以检查`ParallelLoopResult`的`IsCompleted`和`LowestBreakIteration`属性，以找出方法是否已完成或取消，或者用户是否已调用了break。以下是可能的情况：'
- en: '| `IsCompleted` | `LowestBreakIteration` | **Reason** |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `IsCompleted` | `LowestBreakIteration` | **原因** |'
- en: '| True | N/A | Run to completion |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| True | N/A | 运行完成 |'
- en: '| False | Null | Loop stopped pre-matching |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| False | Null | 循环在匹配前停止 |'
- en: '| False | Non-null integral value | Break called on the loop |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| False | 非空整数值 | 在循环中调用Break |'
- en: 'The basic syntax of the `Parallel.For` method is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.For`方法的基本语法如下：'
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'An example of this is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子如下所示：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This approach can be useful if you don''t want to cancel, break, or maintain
    any thread local state and the order of execution is not important. For example,
    imagine that we want to count the number of files in a directory that have been
    created today. The code for this is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想取消、中断或维护任何线程本地状态，并且执行顺序不重要，这种方法可能很有用。例如，想象一下我们想要计算今天在一个目录中创建的文件的数量。代码如下：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code iterates all the files in the `C:` drive and counts all the files
    that were created today. The following is the output on my machine:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码迭代了`C:`驱动器中的所有文件，并计算了今天创建的文件的数量。以下是我机器上的输出：
- en: '![](img/92b7e1f0-42cb-4454-a9c3-934b0957916c.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92b7e1f0-42cb-4454-a9c3-934b0957916c.png)'
- en: In the next section, we will try to understand the `Parallel.ForEach` method,
    which provides a parallel variant of the `ForEach` loop.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将尝试理解`Parallel.ForEach`方法，它提供了`ForEach`循环的并行变体。
- en: For some collections, sequential executions work faster, depending on the syntax
    of the loop and the type of work that's being done.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些集合，根据循环的语法和正在进行的工作的类型，顺序执行可能更快。
- en: Using the Parallel.ForEach method
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Parallel.ForEach方法
- en: This is a variation of the `ForEach` loop wherein iterations may run in parallel.
    The source collection is partitioned and then the work is scheduled to run multiple
    threads. `Parallel.ForEach` works on generic collections and, just like the `for`
    loop, returns `ParallelLoopResult`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ForEach`循环的一个变体，其中迭代可以并行运行。源集合被分区，然后工作被安排在多个线程上运行。`Parallel.ForEach`适用于通用集合，并且像`for`循环一样返回`ParallelLoopResult`。
- en: 'The basic syntax of the `Parallel.ForEach` loop is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.ForEach`循环的基本语法如下：'
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'An example of this is as follows. We have a list of ports that we need to monitor.
    We also need to update their statuses:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子如下所示。我们有一个需要监视的端口列表。我们还需要更新它们的状态：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we used the `System.Net.NetworkInformation.Ping` class
    to ping a part and display a status to the console. Since the parts are independent,
    we can achieve great performance if the code is made parallel and the order is
    also not important.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了`System.Net.NetworkInformation.Ping`类来ping一个部分，并在控制台上显示状态。由于这些部分是独立的，如果代码并行执行并且顺序也不重要，我们可以实现很好的性能。
- en: 'The following screenshot shows the output of the preceding code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了前面代码的输出：
- en: '![](img/2c68ea2f-feb9-4743-b703-c664e1ecca89.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c68ea2f-feb9-4743-b703-c664e1ecca89.png)'
- en: Parallelism can make applications slow on single-core processors. We can control
    how many cores can be utilized in a parallel operation by using the degree of
    parallelism, which we will cover next.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 并行性可能会使单核处理器上的应用程序变慢。我们可以通过使用并行度来控制并行操作中可以利用多少核心，接下来我们将介绍这个。
- en: Understanding the degree of parallelism
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解并行度
- en: 'So far, we have learned how data parallelism gives us the advantage of running
    loops in parallel on multiple cores of a system, thereby making efficient use
    of the available CPU resources. You should be aware that there is another important
    concept that you can use in order to control how many tasks you want to create
    in your loops. This concept is called the degree of parallelism. It''s a number
    that specifies the maximum number of tasks that can be created by your parallel
    loops. You can set the degree of parallelism via a property called `MaxDegreeOfParallelism`,
    which is part of the `ParallelOptions` class. The following is the syntax of `Parallel.For`,
    wherein you can pass the `ParallelOptions` instance:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了数据并行性如何使我们能够在系统的多个核心上并行运行循环，从而有效利用可用的CPU资源。您应该知道还有另一个重要的概念，可以用来控制您想要在循环中创建多少任务。这个概念叫做并行度。这是一个指定可以由并行循环创建的最大任务数的数字。您可以通过一个名为`MaxDegreeOfParallelism`的属性来设置并行度，这是`ParallelOptions`类的一部分。以下是`Parallel.For`的语法，您可以通过它传递`ParallelOptions`实例：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the syntax of the `Parallel.For` and `Parallel.ForEach` methods,
    wherein you can pass the `ParallelOptions` instance:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Parallel.For`和`Parallel.ForEach`方法的语法，您可以通过它传递`ParallelOptions`实例：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The default value for the degree of parallelism is 64, which means that the
    parallel loops can utilize up to 64 processors in a system by creating that many
    tasks. We can modify this value to limit the number of tasks. Let's try to understand
    this concept with a few examples.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 并行度的默认值为64，这意味着并行循环可以通过创建这么多任务来利用系统中多达64个处理器。我们可以修改这个值来限制任务的数量。让我们通过一些例子来理解这个概念。
- en: 'Let''s look at an example of a `Parallel.For` loop with `MaxDegreeOfParallelism`
    set to `4`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个`MaxDegreeOfParallelism`设置为`4`的`Parallel.For`循环的例子：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/474f3ac2-6330-44fa-b6e1-4560c509c1de.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/474f3ac2-6330-44fa-b6e1-4560c509c1de.png)'
- en: As you can see, the loop was executed by four tasks denoted by the task IDs
    1, 2, 3, and 4.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，循环由四个任务执行，分别用任务ID 1、2、3和4表示。
- en: 'Here is an example of a `Parallel.ForEach` loop with `MaxDegreeOfParallelism`
    set to `4`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`MaxDegreeOfParallelism`设置为`4`的`Parallel.ForEach`循环的例子：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/8dcc5f47-7a0e-481d-b2f2-c6247b60d8ba.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8dcc5f47-7a0e-481d-b2f2-c6247b60d8ba.png)'
- en: As you can see, this loop was executed by four tasks denoted by the task IDs
    1, 2, 3, and 4.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个循环由四个任务执行，分别用任务ID 1、2、3和4表示。
- en: We should modify this setting for advanced scenarios where we are aware that
    a running algorithm cannot span more than a certain number of processors. We should
    also modify this setting if we are running multiple algorithms in parallel and
    we want to restrict each algorithm to only utilize a certain number of processors.
    Next, we will learn how to make custom partitions in collections by introducing
    the concept of partitioning strategies.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该修改这个设置以适应高级场景，例如我们知道运行的算法不能跨越超过一定数量的处理器。如果我们同时运行多个算法并且希望限制每个算法只利用一定数量的处理器，我们也应该修改这个设置。接下来，我们将学习如何通过引入分区策略的概念在集合中创建自定义分区。
- en: Creating a custom partitioning strategy
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义分区策略
- en: 'Partitioning is another important concept in data parallelism. To achieve parallelism
    in the source collection, it needs to be partitioned into smaller sections called
    ranges or chunks, which can be concurrently accessed by various threads. Without
    partitioning, the loop will execute serially. Partitioners can be classified into
    two categories and we can create custom partitioners as well. These categories
    are as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 分区是数据并行性中的另一个重要概念。为了在源集合中实现并行性，它需要被分割成称为范围或块的较小部分，这些部分可以被各个线程同时访问。没有分区，循环将串行执行。分区器可以分为两类，我们也可以创建自定义分区器。这些类别如下：
- en: Range partitioning
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围分区
- en: Chunk partitioning
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块分区
- en: Let's discuss these in detail.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论这些。
- en: Range partitioning
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围分区
- en: This type of partitioning is primarily used with collections where the length
    is known in advance. As the name suggests, every thread gets a range of elements
    to process or the start and end index of a source collection. This is the simplest
    form of partitioning and very efficient in the sense that every thread executes
    its range without overwriting other threads. There is no synchronization overhead,
    though some bits of performance are lost initially while creating ranges. This
    type of partitioning works best in scenarios where the number of elements in each
    range is the same so that they will take a similar length of time to finish. With
    a different number of elements, some tasks may finish early and sit idle, whereas
    other tasks may have a lot of pending elements in the range to process.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的分区主要用于长度预先已知的集合。顾名思义，每个线程都会得到一系列元素来处理，或者源集合的起始和结束索引。这是分区的最简单形式，在某种程度上非常高效，因为每个线程都会执行其范围而不会覆盖其他线程。虽然在创建范围时会有一些性能损失，但没有同步开销。这种类型的分区在每个范围中的元素数量相同时效果最佳，这样它们将花费相似的时间来完成。对于不同数量的元素，一些任务可能会提前完成并处于空闲状态，而其他任务可能在范围内有很多待处理的元素。
- en: Chunk partitioning
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块分区
- en: This type of partitioning is primarily used with collections such as `LinkedList`,
    where the length isn't known in advance. Chunk partitioning provides more load
    balancing in case you have uneven collections. Every thread picks up a chunk of
    elements, processes them, and then comes back to pick up another chunk that hasn't
    been picked up by other threads yet. The size of the chunk depends on the partitioner's
    implementation and there is synchronization overhead to make sure that the chunks
    that are allocated to two threads don't contain duplicates.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的分区主要用于`LinkedList`等集合，其中长度事先不知道。分块分区在您有不均匀的集合的情况下提供更多的负载平衡。每个线程都会挑选一块元素进行处理，然后再回来挑选其他线程尚未挑选的另一块。块的大小取决于分区器的实现，并且有同步开销来确保分配给两个线程的块不包含重复项。
- en: 'We can change the default partitioning strategy of the `Parallel.ForEach` loop
    to perform custom chunk partitioning, as shown in the following example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更改`Parallel.ForEach`循环的默认分区策略，以执行自定义的分块分区，如下例所示：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code, we created chunked partitioners using the `OrderablePartitioner`
    class on a range of items (here, from `1` to `100`). We passed partitioners to
    the `ForEach` loop, where each chunk is passed to a thread and executed. The output
    is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`OrderablePartitioner`类在一系列项目（这里是从`1`到`100`）上创建了分块分区器。我们将分区器传递给`ForEach`循环，其中每个块都传递给一个线程并执行。输出如下：
- en: '![](img/966e964a-5049-40d9-8b2e-8721b689bf52.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/966e964a-5049-40d9-8b2e-8721b689bf52.png)'
- en: So far, we have a good understanding of how parallel loops work. Now, we need
    to discuss some advanced concepts in order to find out more about how we can control
    loop execution; that is, how to stop a loop as needed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对并行循环的工作原理有了很好的理解。现在，我们需要讨论一些高级概念，以便更多地了解如何控制循环执行；也就是说，如何根据需要停止循环。
- en: Canceling loops
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消循环
- en: We have used constructs such as `break` and `continue` in sequential loops;
    `break` is used to break out of a loop by finishing the current iteration and
    skipping the rest, whereas `continue` skips the current iteration and moves to
    the rest of the iterations. These constructs can be used because the sequential
    loops are executed by a single thread. In the case of parallel loops, we cannot
    use the `break` and `continue` keywords since they run on multiple threads or
    tasks. To break a parallel loop, we need to make use of the `ParallelLoopState`
    class. To cancel a loop, we need to make use of the `CancellationToken` and `ParallelOptions`
    classes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在顺序循环中使用了`break`和`continue`等结构；`break`用于通过完成当前迭代并跳过其余部分来跳出循环，而`continue`则跳过当前迭代并移动到其余的迭代。这些结构可以使用，因为顺序循环由单个线程执行。在并行循环的情况下，我们不能使用`break`和`continue`关键字，因为它们在多个线程或任务上运行。要中断并行循环，我们需要使用`ParallelLoopState`类。要取消循环，我们需要使用`CancellationToken`和`ParallelOptions`类。
- en: 'In this section, we will discuss the options that you require to cancel loops:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论取消循环所需的选项：
- en: '`Parallel.Break`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Parallel.Break`'
- en: '`ParallelLoopState.Stop`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParallelLoopState.Stop`'
- en: '`CancellationToken`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CancellationToken`'
- en: Let's get started!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Using the Parallel.Break method
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Parallel.Break方法
- en: '`Parallel.Break` tries to mimic the results of a sequential execution. Let''s
    have a look at how to `break` from a parallel loop. In the following code, we need
    to search a list of numbers for a specific number. We need to break the loop''s
    execution when a match is found:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.Break`试图模仿顺序执行的结果。让我们看看如何从并行循环中`break`。在以下代码中，我们需要搜索一个数字列表以查找特定数字。当找到匹配项时，我们需要中断循环的执行：'
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As shown in the preceding code, the loop is supposed to run until the number
    `2` is found. With a sequential loop, it will break exactly on the second iteration.
    With parallel loops, since iterations run on multiple tasks, it will actually
    print values more than 2, as shown in the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，循环应该在找到数字`2`之前运行。使用顺序循环，它将在第二次迭代时精确中断。对于并行循环，由于迭代在多个任务上运行，实际上会打印出大于2的值，如下面的输出所示：
- en: '![](img/91ed685a-4c48-476c-a30b-ec96de9ba817.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91ed685a-4c48-476c-a30b-ec96de9ba817.png)'
- en: To break out of the loop, we called `parallelLoopState.Break()`, which tries
    to mimic the behavior of the actual `break` keyword in a sequential loop. When
    the `Break()` method is encountered by any of the cores, it will set an iteration
    number in the `LowestBreakIteration` property of the **`ParallelLoopState`** object.
    This becomes the maximum number or the last iteration that can be executed. All
    the other tasks will continue iterating until this number is reached.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跳出循环，我们调用了`parallelLoopState.Break()`，它试图模仿顺序循环中实际`break`关键字的行为。当任何一个核心遇到`Break()`方法时，它将在**`ParallelLoopState`**对象的`LowestBreakIteration`属性中设置一个迭代号。这成为可以执行的最大数字或最后一个迭代。所有其他任务将继续迭代，直到达到这个数字。
- en: 'Subsequent calls to the `Break` method by running iterations in parallel further
    reduces `LowestBreakIteration`, as shown in the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过并行运行迭代来连续调用`Break`方法，进一步减少`LowestBreakIteration`，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we run the preceding code in Visual Studio, we get the following output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Visual Studio中运行前面的代码时，我们会得到以下输出：
- en: '![](img/e418c044-fbe9-43ae-ac1a-6fff50149ec2.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e418c044-fbe9-43ae-ac1a-6fff50149ec2.png)'
- en: Here, we run the code on a multi-core processor. As you can see, a lot of iterations
    get a null value for `LowestBreakIteration` as the code is being executed on multiple
    cores. On iteration 17, one core calls the `Break()` method and sets the value
    of `LowestBreakIteration` to 17\. On iteration 10, another core calls `Break()`
    and further reduces the number to 10\. Later, on iteration 9, another core calls
    `Break()`, and further reduces the number to 9.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在多核处理器上运行代码。正如您所看到的，许多迭代得到了`LowestBreakIteration`的空值，因为代码是在多个核上执行的。在第17次迭代时，一个核心调用了`Break()`方法，并将`LowestBreakIteration`的值设置为17。在第10次迭代时，另一个核心调用`Break()`并进一步将数字减少到10。后来，在第9次迭代时，另一个核心调用了`Break()`，并进一步将数字减少到9。
- en: Using ParallelLoopState.Stop
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ParallelLoopState.Stop
- en: 'If you don''t want to mimic the results of sequential loops and want to exit
    the loop as soon as possible, you can call `ParallelLoopState.Stop`. Just like
    we did with the `Break()` method, all the iterations running in parallel finish
    before the loop exits:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想模仿顺序循环的结果，而是想尽快退出循环，你可以调用`ParallelLoopState.Stop`。就像我们用`Break()`方法一样，所有并行运行的迭代在循环退出之前都会完成：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following is the output when we run the preceding code in Visual Studio:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中运行上述代码时，输出如下：
- en: '![](img/1b495524-49e8-4c5e-8298-8080775a6477.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b495524-49e8-4c5e-8298-8080775a6477.png)'
- en: As you can see, one core called `Stop` on iteration 4, another core called `Stop`
    on iteration 8, and a third core called `Stop` on iteration 12\. Iterations 3
    and 10 still execute since they were already scheduled for execution.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，一个核心在第4次迭代时调用了`Stop`，另一个核心在第8次迭代时调用了`Stop`，第三个核心在第12次迭代时调用了`Stop`。迭代3和10仍然执行，因为它们已经被安排执行。
- en: Using CancellationToken to cancel loops
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CancellationToken取消循环
- en: Just like normal tasks, we can use the `CancellationToken` class to cancel the
    `Parallel.For` and `Parallel.ForEach` loops. When we cancel the token, the loop
    will finish the current iterations that may be running in parallel but will not
    start new iterations. Once the existing iterations finish, the parallel loops
    throw `OperationCanceledException`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通任务一样，我们可以使用`CancellationToken`类来取消`Parallel.For`和`Parallel.ForEach`循环。当我们取消令牌时，循环将完成当前可能并行运行的迭代，但不会开始新的迭代。一旦现有的迭代完成，并行循环会抛出`OperationCanceledException`。
- en: 'Let''s look at this with an example. First, we''ll create a cancellation token
    source:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子来看看。首先，我们将创建一个取消令牌源：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we''ll create a task that cancels the token after five seconds:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个在五秒后取消令牌的任务：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After that, we''ll create a parallel options object by passing the cancellation
    token:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将通过传递取消令牌来创建一个并行选项对象：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we''ll run the loop with an operation that will last for more than five
    seconds:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将运行一个持续时间超过五秒的操作：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is the output when we run the preceding code in Visual Studio:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中运行上述代码时，输出如下：
- en: '![](img/4ee931bb-5b0f-4c54-9af4-599b99d77aec.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ee931bb-5b0f-4c54-9af4-599b99d77aec.png)'
- en: As you can see, the scheduled iterations are still executed, even after the
    canceling token has been called. I hope this gives you a good idea of how we can
    cancel loops based on program requirements. Another important aspect of parallel
    programming is the concept of storage. We'll discuss this in the next section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，即使取消令牌已被调用，预定的迭代仍然会执行。希望这能让你对我们如何根据程序要求取消循环有一个很好的理解。并行编程的另一个重要方面是存储的概念。我们将在下一节讨论这个问题。
- en: Understanding thread storage in parallel loops
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解并行循环中的线程存储
- en: By default, all parallel loops have access to a global variable. However, there
    is a synchronization overhead associated with accessing global variables, and
    because of this, it makes sense to use thread-scoped variables wherever possible.
    We can create either a **thread local** or a **partition local** variable to be
    used in parallel loops.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有并行循环都可以访问全局变量。然而，访问全局变量会带来同步开销，因此在可能的情况下，最好使用线程范围的变量。我们可以创建一个**线程本地**或**分区本地**变量来在并行循环中使用。
- en: Thread local variable
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程本地变量
- en: Thread local variables are like global variables for a particular task. They
    have a lifetime that spans the number of iterations the loop is going to execute.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 线程本地变量就像特定任务的全局变量。它们的生命周期跨越循环要执行的迭代次数。
- en: In the following example, we are going to look at thread local variables using
    the `for` loop. In the case of the `Parallel.For` loop, multiple tasks are created
    to run the iterations. Let's say we need to find out the sum of 60 numbers via
    a parallel loop.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将使用`for`循环来查看线程本地变量。在`Parallel.For`循环的情况下，会创建多个任务来运行迭代。假设我们需要通过并行循环找出60个数字的总和。
- en: As an example, say there are four tasks, each of which has 15 iterations. One
    way of achieving this is to create a global variable. After every iteration, the
    running task should update the global variable. This would require synchronization
    overhead. For four tasks, there would be four thread local variables that are
    private to each task. The variable will be updated by the task and the last updated
    value can be returned to the caller program, which can then be used to update
    the global variable.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设有四个任务，每个任务有15次迭代。实现这一点的一种方法是创建一个全局变量。每次迭代后，运行的任务都应该更新全局变量。这将需要同步开销。对于四个任务，将会有四个对每个任务私有的线程本地变量。任务将更新变量，并且最后更新的值可以返回给调用程序，然后可以用来更新全局变量。
- en: 'Here are the steps to be followed:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要遵循的步骤：
- en: 'Create a collection of 60 numbers, with each item having a value equal to the
    index:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含60个数字的集合，其中每个项目的值都等于索引：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a finished action that will execute once the task has finished all its
    allocated iterations. The method will receive the final result of the thread local
    variable and add that to the global variable, that is, `sumOfNumbers`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个完成的操作，一旦任务完成了所有分配的迭代，就会执行。该方法将接收线程本地变量的最终结果，并将其添加到全局变量`sumOfNumbers`中：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Create a `For` loop. The first two parameters are `startIndex` and `endIndex`.
    The third parameter is a delegate that provides a seed value for the thread local
    variable. It is an action that needs to be performed by the task. In our case,
    we are just assigning the index to `subtotal`, which is our thread local variable.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`For`循环。前两个参数是`startIndex`和`endIndex`。第三个参数是一个委托，为线程本地变量提供种子值。这是一个需要任务执行的操作。在我们的例子中，我们只是将索引分配给`subtotal`，这是我们的线程本地变量。
- en: 'Let''s say there is a task, *TaskA*, which gets the iterations with an index
    from 1 to 5\. *TaskA* will add up these iterations as  1+2+3+4+5\. This equals
    15, which will be returned as the task''s result and passed to `taskFinishedMethod`
    as a parameter:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个任务*TaskA*，它获取索引从1到5的迭代。*TaskA*将这些迭代相加为1+2+3+4+5。这等于15，将作为任务的结果返回，并作为参数传递给`taskFinishedMethod`：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is the output when we run the preceding code in Visual Studio:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中运行上述代码时，输出如下：
- en: '![](img/bb6fdaca-40ff-4b89-864b-d7d9465f0e1d.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb6fdaca-40ff-4b89-864b-d7d9465f0e1d.png)'
- en: Remember that the output may be different on different machines, depending on
    the number of available cores.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，输出可能因可用核心数量不同而在不同的机器上有所不同。
- en: Partition local variable
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区本地变量
- en: This is similar to the thread local variable but works with partitions. As you
    are aware, the `ForEach` loop divides the source collection into a number of partitions.
    Each partition will have its own copy of the partition local variable. With the
    thread local variable, there is a single copy of the variable per thread. Here,
    however, we can have multiple copies per thread since multiple partitions can
    be run on a single thread.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于线程本地变量，但适用于分区。正如您所知，`ForEach`循环将源集合分成多个分区。每个分区将有其自己的分区本地变量副本。对于线程本地变量，每个线程只有一个变量副本。然而，在这里，由于单个线程上可以运行多个分区，因此每个线程可以有多个副本。
- en: First, we need to create a `ForEach` loop. The first parameter is a source collection,
    which means numbers. The second parameter is a delegate that provides a seed value
    for the thread local variable. The third parameter is an action that needs to
    be performed by the task. In our case, we are just assigning the index to the
    `subtotal`, which is our thread local variable.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个`ForEach`循环。第一个参数是源集合，即数字。第二个参数是为线程本地变量提供种子值的委托。第三个参数是任务需要执行的操作。在我们的情况下，我们只是将索引分配给`subtotal`，这是我们的线程本地变量。
- en: For the sake of understanding, let's say there is a task, *TaskA*, that gets
    iterations with indexes from 1 to 5\. *TaskA* will add up these iterations, which
    is 1+2+3+4+5\. This equals 15, which will be returned as the task's result and
    passed to `taskFinishedMethod` as a parameter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解，假设有一个任务*TaskA*，它获取索引从1到5的迭代。*TaskA*将这些迭代相加，即1+2+3+4+5。这等于15，将作为任务的结果返回，并作为参数传递给`taskFinishedMethod`。
- en: 'The code for this is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Again, in this case, the output will be different on different machines, depending
    on the number of available cores.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在这种情况下，输出将因可用核心数量不同而在不同的机器上有所不同。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we elaborated on achieving task parallelism using TPL. We started
    by introducing how to move sequential loops to parallel using some built-in methods
    provided by TPL, such as `Parallel.Invoke`, `Parallel.For`, and `Parallel.ForEach`.
    Next, we discussed how to get maximum utilization out of the available CPU resources
    by understanding the degree of parallelism and partitioning strategies. Then,
    we discussed how to cancel and break out of parallel loops using built-in constructs
    such as cancellation tokens, `Parallel.Break`, and `ParallelLoopState.Stop`. At
    the end of this chapter, we discussed various thread storage options that are
    available in TPL.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了使用TPL实现任务并行性。我们首先介绍了如何使用TPL提供的一些内置方法，如`Parallel.Invoke`、`Parallel.For`和`Parallel.ForEach`，将顺序循环转换为并行循环。接下来，我们讨论了如何通过了解并行度和分区策略来充分利用可用的CPU资源。然后，我们讨论了如何使用内置构造（如取消标记、`Parallel.Break`和`ParallelLoopState.Stop`）取消并跳出并行循环。在本章末尾，我们讨论了TPL中可用的各种线程存储选项。
- en: The TPL provides a few very exciting options that we can use to achieve data
    parallelism through the parallel implementation of `For` and `ForEach` loops.
    Along with features such as `ParallelOptions` and `ParallelLoopState`, we can
    achieve significant performance benefits and control without losing a lot of synchronization
    overhead.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: TPL提供了一些非常令人兴奋的选项，我们可以通过`For`和`ForEach`循环的并行实现来实现数据并行性。除了`ParallelOptions`和`ParallelLoopState`等功能外，我们还可以在不丢失太多同步开销的情况下实现显著的性能优势和控制。
- en: In the next chapter, we will look at another exciting feature of the parallel
    library called **PLINQ**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到并行库的另一个令人兴奋的特性，称为**PLINQ**。
- en: Questions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of these is not the correct method to provide a `for` loop in TPL?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个不是TPL中提供`for`循环的正确方法？
- en: '`Parallel.Invoke`'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Parallel.Invoke`'
- en: '`Parallel.While`'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Parallel.While`'
- en: '`Parallel.For`'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Parallel.For`'
- en: '`Parallel.ForEach`'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Parallel.ForEach`'
- en: Which is not a default partitioning strategy?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个不是默认的分区策略？
- en: Bulk partitioning
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 批量分区
- en: Range partitioning
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 范围分区
- en: Chunk partitioning
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 块分区
- en: What is the default value for the degree of parallelism?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并行度的默认值是多少？
- en: '1'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1'
- en: '64'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '64'
- en: '`Parallel.Break` guarantees immediate returns as soon as it is executed.'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Parallel.Break`保证一旦执行就立即返回。'
- en: 'True'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真
- en: 'False'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假
- en: Can one thread see another thread's thread local or partition local value?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个线程能看到另一个线程的线程本地或分区本地值吗？
- en: 'Yes'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是
- en: 'No'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不
