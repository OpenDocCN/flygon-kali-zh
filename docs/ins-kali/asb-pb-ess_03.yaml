- en: Chapter 2. Going Modular with Ansible Roles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。使用Ansible角色进行模块化
- en: In the last chapter, you learned about writing a simple playbook with Ansible.
    You also learned about the concepts of plays which map hosts to tasks. Writing
    tasks in a single playbook may work fine for a very simple setup. However, if
    we have multiple applications spanning across number of hosts, this will quickly
    become unmanageable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您了解了使用Ansible编写简单的playbook。您还了解了将主机映射到任务的plays的概念。在一个简单的设置中，编写单个playbook中的任务可能会很好地工作。然而，如果我们有多个应用程序跨越多个主机，这将很快变得难以管理。
- en: 'In this chapter, you will be introduced to the following concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将介绍以下概念：
- en: What makes a role and what are roles used for?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么构成了一个角色，角色用于什么？
- en: How to create roles to provide abstraction?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建角色以提供抽象？
- en: Organizing content to provide modularity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织内容以提供模块化
- en: Using include statements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包含语句
- en: Writing simple tasks and handlers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写简单的任务和处理程序
- en: Installing packages, managing services, and serving files with Ansible modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible模块安装软件包、管理服务和提供文件
- en: Understanding roles
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解角色
- en: In real-life scenarios, we will mostly be configuring web servers, database
    servers, load balancers, middleware queues, and so on. If you take one step back
    and look at the big picture, you will realize that you are configuring groups
    of identical servers in a repeatable fashion.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中的场景中，我们通常会配置Web服务器、数据库服务器、负载均衡器、中间件队列等等。如果你退一步看看大局，你会意识到你正在以可重复的方式配置一组相同的服务器。
- en: To manage such infrastructures in the most efficient way, we need some abstraction
    which allows us to define what we need to configure in each of these groups, and
    call them by name. That's exactly what roles do. Ansible roles allow us to configure
    groups of nodes at the same time, without repeating ourselves. Roles also provide
    a way to create modular code, which then can then be shared and reused.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以最有效的方式管理这样的基础设施，我们需要一些抽象，允许我们定义我们需要在这些组中的每个配置，并按名称调用它们。这正是角色所做的。Ansible角色允许我们同时配置一组节点，而不重复自己。角色还提供了一种创建模块化代码的方式，然后可以共享和重用。
- en: Naming roles
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名角色
- en: 'A common practice is to create roles that map to each application or component
    of your infrastructure that you would like to configure. For example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的做法是创建映射到您想要配置的基础设施的每个应用程序或组件的角色。例如：
- en: Nginx
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nginx
- en: MySQL
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL
- en: MongoDB
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB
- en: Tomcat
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tomcat
- en: The directory layout for roles
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色的目录布局
- en: Roles are nothing but directories laid out in a specific manner. Roles follow
    predefined directory layout conventions and expect each component to be in the
    path meant for it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 角色只是按特定方式布置的目录。角色遵循预定义的目录布局约定，并期望每个组件都在其指定的路径中。
- en: 'The following is an example of a role, called Nginx:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个名为Nginx的角色的示例。
- en: '![The directory layout for roles](graphics/B03800_02_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![角色的目录布局](graphics/B03800_02_01.jpg)'
- en: 'Let''s now look at the rules of the game and what each of the components in
    the preceding diagram is for:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看游戏规则以及前面图表中每个组件的用途：
- en: Each role contains a directory which is named after itself, for example, `Nginx`,
    with `roles/` as its parent directory. Each named role directory contains one
    or more optional subdirectories. The most common subdirectories to be present
    are tasks, templates, and handlers. Each of these subdirectories typically contain
    the `main.yml` file, which is a default file.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个角色都包含一个以自己命名的目录，例如`Nginx`，其父目录为`roles/`。每个命名的角色目录都包含一个或多个可选的子目录。通常存在的最常见子目录是tasks、templates和handlers。每个子目录通常包含`main.yml`文件，这是一个默认文件。
- en: Tasks contain the core logic, for example, they will have code specifications
    to install packages, start services, manage files, and so on. If we consider a
    role to be a movie, a task would be the protagonist.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务包含核心逻辑，例如，它们将具有安装软件包、启动服务、管理文件等的代码规范。如果我们将一个角色视为一部电影，那么任务就是主角。
- en: Tasks alone cannot do everything. Considering our analogy with movies, it's
    incomplete without the supporting cast. Protagonists have friends, cars, lovers,
    and antagonists to complete the story. Similarly, tasks consume data, call for
    static or dynamic files, trigger actions, and so on. That's where files, handlers,
    templates, defaults, and `vars` come in. Let's look at what these are for.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务本身并不能完成所有事情。考虑到我们对电影的类比，没有配角就是不完整的。主角有朋友、汽车、恋人和对手来完成故事。同样，任务消耗数据，调用静态或动态文件，触发动作等等。这就是文件、处理程序、模板、默认值和“vars”派上用场的地方。让我们看看它们各自的作用。
- en: Vars and defaults provide data about your application/role, for example, which
    port your server should run on, the path for storing the application data, which
    user to run the service as, and so on. Default variables were introduced in version
    1.3 and these allow us to provide sane defaults. These can later be overridden
    from other places, for example, `vars`, `group_vars`, and `host_vars`. Variables
    are merged and precedence rules apply. This gives us a lot of flexibility to configure
    our servers selectively. For example, running the web server on port `80` on all
    hosts except for the ones in the staging environment, which should run it on port
    `8080`.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vars和defaults提供有关您的应用程序/角色的数据，例如，您的服务器应该在哪个端口上运行，存储应用程序数据的路径，以及要作为服务运行的用户等。默认变量是在1.3版本中引入的，这些变量允许我们提供合理的默认值。这些默认值可以稍后从其他位置覆盖，例如，“vars”、“group_vars”和“host_vars”。变量被合并，并且优先规则适用。这为我们提供了很大的灵活性，可以有选择地配置我们的服务器。例如，在除了在分期环境中的主机之外，所有主机上都在端口“80”上运行Web服务器，而在分期环境中应该在端口“8080”上运行。
- en: Files and templates subdirectories provide options for managing files. Typically,
    the files subdirectory is used to copy over static files to destination hosts,
    for example, some application installers archive static text files, and so on.
    In addition to static files, frequently you may need to manage files that are
    are generated on the fly. For example, a configuration file that has parameters
    such as port, user, and memory, which can be provided dynamically using variables.
    Generating such files requires a special type of primitive, called templates.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件和模板子目录提供了管理文件的选项。通常，文件子目录用于将静态文件复制到目标主机，例如，一些应用程序安装程序存档静态文本文件等等。除了静态文件，您可能经常需要管理动态生成的文件。例如，一个具有端口、用户和内存等参数的配置文件，可以使用变量动态提供。生成这样的文件需要一种特殊类型的原始文件，称为模板。
- en: Tasks can trigger actions based on the change of a state or a condition. In
    a movie, the protagonist may chase the antagonist and take revenge based on the
    provocation or an event. An example event is kidnapping the protagonist's lady
    love. Similarly, you may need to perform an action on your hosts, for example,
    restarting a service based on what happened earlier, which could be a change in
    the state of a configuration file. This trigger-action relationship can be specified
    using a handler.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务可以根据状态或条件的变化触发动作。在电影中，主角可能会追逐对手，并基于挑衅或事件进行报复。一个例子是绑架主角的爱人。同样，您可能需要根据主机执行操作，例如，根据先前发生的情况重新启动服务，这可能是配置文件状态的变化。这种触发-动作关系可以使用处理程序来指定。
- en: Continuing our analogy, many popular movies have sequels and sometimes even
    prequels. In such cases, one should watch it in a particular order, as the storyline
    of a sequel depends on something that happened in the previous movie. Similarly,
    a role can have a dependency on another role. A very common example is, before
    installing Tomcat, Java should be present on the system. These dependencies are
    defined in the meta subdirectory of a role.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 延续我们的类比，许多热门电影都有续集，有时甚至有前传。在这种情况下，应该按特定顺序观看，因为续集的故事情节取决于前一部电影中发生的事情。同样，一个角色可以依赖于另一个角色。一个非常常见的例子是，在安装Tomcat之前，系统上应该有Java。这些依赖关系在角色的元子目录中定义。
- en: Let's get hands-on with this by creating a role for the Nginx application. Let's
    take a problem statement, try to solve it, and learn about roles in the process.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过为Nginx应用程序创建一个角色来动手操作。让我们拿一个问题陈述，试图解决它，并在这个过程中学习角色。
- en: Consider the following scenario. With the onset of the soccer world cup, we
    need to create a web server to serve up a page on sports news.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情景。随着足球世界杯的开始，我们需要创建一个Web服务器来提供体育新闻页面。
- en: 'Being a follower of agile methodologies, we will do this in phases. In the
    first phase, we will just install a web server and serve up a home page. Let''s
    now break this down into the steps we need to take to achieve this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为敏捷方法的追随者，我们将分阶段进行。在第一阶段，我们将只安装一个Web服务器并提供一个主页。现在让我们把这个分解成我们需要采取的步骤：
- en: Install a web server. In this case, we will use 'Nginx' as it is a lightweight
    web server.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装一个Web服务器。在这种情况下，我们将使用“Nginx”作为一个轻量级的Web服务器。
- en: Manage configuration for the Nginx web server.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理Nginx Web服务器的配置。
- en: Start the web server after installing it.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装后启动Web服务器。
- en: Copy over an HTML file, which will be served as a home page.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制一个HTML文件，它将作为主页提供。
- en: 'Now that we have identified what steps to take, we also need to map them to
    the respective module types we will use to achieve each of these:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了要采取的步骤，我们还需要将它们映射到我们将用来实现每个步骤的相应模块类型：
- en: Installing Nginx = Package module (apt)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Nginx = 包模块（apt）
- en: Configuring Nginx = File module (file)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Nginx = 文件模块（文件）
- en: Starting Nginx = Systems module (service)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动Nginx = 系统模块（服务）
- en: Serve Webpage = Files module (file)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供网页 = 文件模块（文件）
- en: Before we start writing code, we will start creating a layout to organize our
    files.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，我们将开始创建一个布局来组织我们的文件。
- en: Creating a site-wide playbook, nesting, and using include statements
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个全站点的playbook，嵌套和使用包含语句。
- en: 'As a best practice, we will create a top-level file, which will contain the
    blueprint of our complete infrastructure. Technically, we can include everything
    that we need to configure inside just one file. However, that would have two problems:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，我们将创建一个顶层文件，其中包含我们完整基础设施的蓝图。从技术上讲，我们可以将需要配置的一切都包含在一个文件中。然而，这会有两个问题：
- en: It would quickly get out of control as we start adding tasks, variables, and
    handlers to this single file. It would be a nightmare to maintain such code.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着我们开始向这个单一文件添加任务、变量和处理程序，它很快就会失控。维护这样的代码将是一场噩梦。
- en: It would also be difficult to reuse and share such code. One of the advantages
    of using a tool such as Ansible is its ability to separate data from code. Data
    is organization-specific, and code is generic. This generic code can then be shared
    with others. However, if you write everything in a single file, it would be impossible
    to do so.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重用和共享这样的代码也会很困难。使用Ansible等工具的优势之一是它能够将数据与代码分离。数据是组织特定的，而代码是通用的。然后可以与他人共享这些通用代码。然而，如果你把所有东西都写在一个文件中，这是不可能做到的。
- en: 'To avoid this problem, we will start organizing our code in a modular fashion,
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，我们将以模块化的方式开始组织我们的代码，如下所示：
- en: We will create roles for each of the applications that we need to configure.
    In this case, it is Nginx
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将为需要配置的每个应用程序创建角色。在这种情况下，就是Nginx。
- en: Our web server may need to install more than one application in addition to
    Nginx, for example, PHP and OpenSSL. To encapsulate all of these, we will create
    a playbook named `www.yml`.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了Nginx之外，我们的Web服务器可能需要安装多个应用程序，例如PHP和OpenSSL。为了封装所有这些，我们将创建一个名为`www.yml`的playbook。
- en: The preceding playbook that we created will map hosts with the Nginx role. We
    may add more roles to it later.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建的前面的playbook将主机映射到Nginx角色。我们以后可以向其中添加更多角色。
- en: We will add this playbook to the top-level playbook, that is, `site.yml`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将把这个playbook添加到顶层playbook，也就是`site.yml`。
- en: 'The following diagram depicts the preceding steps in a very simple manner:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表以非常简单的方式描述了前面的步骤：
- en: '![Creating a site-wide playbook, nesting, and using include statements](graphics/B03800_02_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![创建站点范围的playbook，嵌套和使用包含语句](graphics/B03800_02_02.jpg)'
- en: 'Here is our `site.yml` file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`site.yml`文件：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding `include` directive assists us with modularizing the code. Instead
    of writing it all in one file, we split the logic and import what is required.
    In this case, we will include another playbook, which is called a **nested playbook**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`include`指令帮助我们模块化代码。我们将逻辑拆分并导入所需的内容，而不是在一个文件中写所有内容。在这种情况下，我们将包含另一个playbook，这被称为**嵌套playbook**。
- en: 'The following are some guidelines on what can be included and how:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于可以包含什么以及如何包含的指导方针：
- en: The `include` directive can be used to include tasks, handlers, and even other
    playbooks
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`指令可用于包含任务、处理程序，甚至其他playbooks'
- en: If you include a playbook inside another like we did in the `site.yml` file,
    you cannot substitute the variables
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你像我们在`site.yml`文件中所做的那样在另一个playbook中包含一个playbook，你不能替换变量
- en: The `include` keyword can be used in combination with regular task/handler specifications
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`关键字可以与常规任务/处理程序规范结合使用'
- en: It's possible to pass parameters with include statements. This is called as
    **parameterized** **include**
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用包含语句传递参数。这被称为**参数化** **包含**
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Roles and auto-includes**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**角色和自动包含**'
- en: Roles have implicit rules to auto include files. So long as you follow the directory
    layout conventions, you are assured that all your tasks, handlers, and the rest
    of the files are included automatically. Hence, it's important to create the subdirectories
    with the exact names as specified by Ansible.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 角色具有自动包含文件的隐式规则。只要遵循目录布局约定，就可以确保所有任务、处理程序和其他文件都会自动包含。因此，按照Ansible指定的确切名称创建子目录非常重要。
- en: Creating the www playbook
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`www` playbook。
- en: 'We created a site-wide playbook and used an include statement to call another
    playbook by the name `www.yml`. We will now create this file with one play, which
    maps our web server hosts to the Nginx role:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个站点范围的playbook，并使用包含语句调用另一个名为`www.yml`的playbook。现在我们将创建这个文件，其中包含一个play，将我们的Web服务器主机映射到Nginx角色：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The above code works as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码工作如下：
- en: Run this code on any host that maps to the `[www]` group specified in the hosts
    file.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何映射到hosts文件中指定的`[www]`组的主机上运行此代码。
- en: For each directory inside the `roles/nginx/*` file, include `roles/nginx/*/main.yml`
    to the play. This includes `tasks`, `handlers`, `vars`, `meta`, `default,` and
    so on. This is where the auto include rules apply.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`roles/nginx/*`文件夹中的每个目录，将`roles/nginx/*/main.yml`包含到play中。这包括`tasks`，`handlers`，`vars`，`meta`，`default`等等。这就是自动包含规则适用的地方。
- en: The default and custom role paths
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认和自定义角色路径
- en: 'By default, Ansible looks inside the `roles/` subdirectory of the project that
    we create playbooks for. Being top-class devops engineers, we will follow the
    best practice to have a centralized, version-controlled repository to store all
    your roles. We may also end up reusing the roles created by community. Once we
    do this, we can reuse these roles across multiple projects. In such cases, we
    will check out the code at one or more locations, for example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible会查找我们为其创建playbooks的项目的`roles/`子目录内部。作为一流的DevOps工程师，我们将遵循最佳实践，建立一个集中的、版本控制的存储库来存储所有的角色。我们可能还会重用社区创建的角色。一旦我们这样做了，我们就可以在多个项目中重用这些角色。在这种情况下，我们将在一个或多个位置检出代码，例如：
- en: '`/deploy/ansible/roles`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/deploy/ansible/roles`'
- en: '`/deploy/ansible/community/roles`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/deploy/ansible/community/roles`'
- en: 'For nondefault paths, we will need to add the `roles_path` parameter to `ansible.cfg`
    as shown in the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非默认路径，我们需要在`ansible.cfg`中添加`roles_path`参数，如下所示：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Parameterizing the roles
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给角色参数化
- en: 'At times, we may need to override default parameters specified inside vars
    or the default directory of a role, for example, running web servers on port 8080
    instead of 80\. In such cases, we can also pass parameters to roles in the preceding
    playbook, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要覆盖角色内部vars或默认目录中指定的默认参数，例如，在端口8080上运行web服务器，而不是80。在这种情况下，我们也可以在前面的playbook中传递参数给角色，如下所示：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating a base role
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本角色
- en: In the previous chapter, we created a simple playbook with all plays written
    inside the same file. After discovering new and exciting information about roles,
    we will start refactoring our code and making it modular.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个简单的playbook，所有的play都写在同一个文件中。在发现有关角色的新的和令人兴奋的信息后，我们将开始重构我们的代码，使其模块化。
- en: Refactoring our code – creating a base role
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构我们的代码-创建一个基本角色
- en: 'We have written two plays in the `simple_playbook.yml` file. We intended to
    run the first play on all hosts. This play has tasks to create users, install
    essential packages, and so on:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`simple_playbook.yml`文件中编写了两个play。我们打算在所有主机上运行第一个play。这个play有任务来创建用户，安装必要的软件包等等：
- en: '![Refactoring our code – creating a base role](graphics/B03800_02_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![重构我们的代码-创建一个基本角色](graphics/B03800_02_03.jpg)'
- en: 'It''s a good practice to combine all such essential tasks and create a base
    role. You can name it as base, common, essential, or whatever you please, but
    the concept remains the same. We will now move this code to the base role:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些基本任务组合起来并创建一个基本角色是一个很好的做法。你可以将其命名为base、common、essential，或者任何你喜欢的名字，但概念是一样的。现在我们将把这段代码移到基本角色中：
- en: 'Create the directory layout for the base role. Since we are only going to specify
    tasks, we just need one subdirectory inside the base:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为基本角色创建目录布局。由于我们只会指定任务，所以我们只需要在基本角色内部创建一个子目录：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Create the `main.yml` file inside `roles/base/tasks` to specify tasks for the
    base role.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`roles/base/tasks`内创建`main.yml`文件以指定基本角色的任务。
- en: 'Edit the `main.yml` file and add the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`main.yml`文件并添加以下代码：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating an Nginx role
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Nginx角色
- en: 'We will now create a separate role for Nginx and move the previous code that
    we wrote in the `simple_playbook.yml` file to it, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为Nginx创建一个单独的角色，并将我们在`simple_playbook.yml`文件中编写的先前代码移动到其中，如下所示：
- en: 'Create the directory layout for the Nginx role:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Nginx角色创建目录布局：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create the `install.yml` file inside `roles/base`. Move the Nginx-related tasks
    to it. It should look like this:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`roles/base`内创建`install.yml`文件。将与Nginx相关的任务移到其中。它应该是这样的：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will also create the `service.yml` file to manage the state of the Nginx
    daemon:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将创建`service.yml`文件来管理Nginx守护程序的状态：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We looked at the `include` directive earlier. We will use it to include both
    the `install.yml` and `service.yml` files in the `main.yml` file, as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们之前看过`include`指令。我们将使用它在`main.yml`文件中包含`install.yml`和`service.yml`文件，如下所示：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best Practice**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Why are we creating multiple files to hold the code that installs packages and
    manages services, separately? That's because well-factored roles allow you to
    selectively enable specific features. For example, at times, you may want to deploy
    services in multiple phases. In the first phase, you may just want to install
    and configure applications, and start services only in the second phase of your
    deployment. In such cases, having modular tasks can help. You can always include
    them all in the `main.yml` file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要创建多个文件来分别保存安装软件包和管理服务的代码？这是因为良好设计的角色允许您选择性地启用特定功能。例如，有时您可能希望在多个阶段部署服务。在第一阶段，您可能只想安装和配置应用程序，并且只在部署的第二阶段启动服务。在这种情况下，具有模块化任务可以帮助。您可以始终将它们全部包含在`main.yml`文件中。
- en: Adding role dependencies
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加角色依赖关系
- en: 'We have some essential tasks specified in the base role. We may keep on adding
    more tasks which are a prerequisite for the applications that follow. In such
    cases, we would like our Nginx role to be dependent on the base role. We will
    now specify this dependency inside the meta subdirectory. Let''s take a look at
    the following steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本角色中指定了一些基本任务。我们可能会不断添加更多的任务，这些任务是后续应用程序的先决条件。在这种情况下，我们希望我们的Nginx角色依赖于基本角色。现在我们将在meta子目录中指定这种依赖关系。让我们看一下以下步骤：
- en: Create the `main.yml` file inside the `roles/nginx/meta/main.yml` path.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`roles/nginx/meta/main.yml`路径下创建`main.yml`文件。
- en: 'Add the following code to the `main.yml` file inside the `meta` directory:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`meta`目录中的`main.yml`文件中：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding specification will ensure that the base role is always applied
    before any task in Nginx starts running.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述规范将确保在Nginx的任何任务开始运行之前始终应用基本角色。
- en: Managing files for Nginx
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理Nginx的文件
- en: As per our solution to the scenario, we already have Ansible tasks to install
    Nginx and to start the service. We still don't have a web page to serve yet, and
    we did not think about the Nginx site configurations. We don't expect Nginx to
    magically know about how and where to serve the web page from, do we?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们对场景的解决方案，我们已经有了安装Nginx和启动服务的Ansible任务。我们还没有要提供的网页，也没有考虑Nginx站点配置。我们不希望Nginx神奇地知道如何以及从哪里提供网页，对吧？
- en: 'We need to perform the following steps to serve the HTML page:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行以下步骤来提供HTML页面：
- en: Create a site configuration that lets Nginx know which port to listen to for
    requests, and what to do when a request comes.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个站点配置，让Nginx知道要监听哪个端口以获取请求，以及请求到来时要执行什么操作。
- en: Create some HTML content, which will be served when an HTTP request comes in.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一些HTML内容，当HTTP请求到来时将被提供。
- en: Add code to `tasks/main.yml` to copy over these files.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加代码到`tasks/main.yml`以复制这些文件。
- en: 'You might have noticed, both steps 1 and 2 require that you create and manage
    some files on the host, which will run the Nginx web server. You also learned
    about the file and the subdirectory of a role. You guessed it right. We will use
    this subdirectory to host our files and have them copied over to all the Nginx
    hosts with Ansible. So, let''s create these files now using the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，步骤1和2都要求您在运行Nginx Web服务器的主机上创建和管理一些文件。您还了解了角色的文件和子目录。您猜对了。我们将使用这个子目录来托管我们的文件，并使用Ansible将它们复制到所有Nginx主机上。因此，让我们现在使用以下命令创建这些文件：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a `default.configuration` file to manage the default Nginx site configurations.
    This file should contain parameters such as port, server name, and web root configurations,
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`default.configuration`文件来管理默认的Nginx站点配置。该文件应包含端口、服务器名称和Web根配置等参数，如下所示：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will also create an `index.html` file, which we will push to all web servers:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个`index.html`文件，我们将将其推送到所有Web服务器：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that we have created these files, we will add tasks to copy these over
    and put them in `roles/nginx/tasks/configure.yml,` as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了这些文件，我们将添加任务来复制这些文件并将它们放在`roles/nginx/tasks/configure.yml`中，如下所示：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will also update the `main.yaml` file inside tasks to include the newly
    created file, and add it before the `service.yml` file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将更新任务中的`main.yaml`文件，以包括新创建的文件，并将其添加到`service.yml`文件之前：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Automating events and actions with handlers
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用处理程序自动化事件和操作
- en: 'Let''s assume that we are managing Nginx manually, and that we have to change
    the port that Nginx listens to from the default site to `8080`. What would we
    do to make this happen? Sure, we would edit the `default.conf` file and change
    the port from 80 to 8080\. However, would that be enough? Would that make Nginx
    listen to port 8080 immediately after editing this file? The answer is no. There
    is one more step involved. Let''s take a look at the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们手动管理Nginx，并且我们必须将Nginx监听的端口从默认站点更改为`8080`。我们要做什么才能实现这一点呢？当然，我们会编辑`default.conf`文件，并将端口从80更改为8080。但是，这就足够了吗？编辑此文件后，Nginx会立即监听端口8080吗？答案是否定的。还有一个步骤。让我们看一下以下的截图：
- en: '![Automating events and actions with handlers](graphics/B03800_02_04.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![使用处理程序自动化事件和操作](graphics/B03800_02_04.jpg)'
- en: When we change a configuration file, we will typically also restart/reload the
    service so that it reads our modifications and applies those.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更改配置文件时，通常也会重新启动/重新加载服务，以便它读取我们的修改并应用这些修改。
- en: So far, so good. Now let's come back to our Ansible code. We are going to run
    this code in an automated fashion on a large number of servers, possibly hundreds.
    Considering this, it's not feasible for us to log in to each system to restart
    services after every change. This defeats the purpose of automating the process.
    Now, how do we ask Ansible to take action when an event occurs? That's where handlers
    can help.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很好。现在让我们回到我们的Ansible代码。我们将以自动化的方式在大量服务器上运行此代码，可能是数百台。考虑到这一点，我们无法登录到每个系统以在每次更改后重新启动服务。这违背了自动化流程的目的。现在，当事件发生时，我们如何要求Ansible采取行动呢？这就是处理程序可以帮助的地方。
- en: You learned that Ansible modules are idempotent. They will enforce a change
    in state only if there is a configuration drift. When managing with Ansible, we
    will commit the preceding port change in the `default.conf` file inside `roles/nginx/files`.
    If we launch an Ansible run after making this change then, while executing, it
    will compare the file inside our role with the one on the system, detect the configuration
    drift, and copy it over to the changed file. With Ansible, this is where we will
    add a notification that will trigger a handler to run. In this case, we will call
    a handler to restart the Nginx service.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解到Ansible模块是幂等的。只有在存在配置漂移时，它们才会强制更改状态。在使用Ansible进行管理时，我们将在`roles/nginx/files`中提交先前的端口更改`default.conf`文件。如果我们在进行此更改后启动Ansible运行，那么在执行过程中，它将比较我们角色中的文件与系统上的文件，检测到配置漂移，并将其复制到更改的文件中。使用Ansible，这就是我们将添加一个通知来触发运行处理程序的地方。在这种情况下，我们将调用一个处理程序来重新启动Nginx服务。
- en: 'Let''s now add this handler to `roles/nginx/handlers/main.yml`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将此处理程序添加到`roles/nginx/handlers/main.yml`中：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Handlers are similar to regular tasks. They specify a module's name, instance,
    and state. Why do we not add them with regular tasks then? Well, we only need
    to execute handlers,when an event occurs, not every time we run, ansible. And
    that's the exact reason why we create a separate section for it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序类似于常规任务。它们指定了模块的名称、实例和状态。那么为什么我们不将它们与常规任务一起添加呢？嗯，我们只需要在事件发生时执行处理程序，而不是每次运行ansible时都执行。这正是我们为它创建一个单独的部分的确切原因。
- en: 'Now that we have written the handler, we also need to add a trigger for it.
    We will do this by adding the `notify` directive to `roles/tasks/nginx/configure.yml`,
    as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了处理程序，我们还需要为其添加触发器。我们将通过在`roles/tasks/nginx/configure.yml`中添加`notify`指令来实现这一点。
- en: '![Automating events and actions with handlers](graphics/B03800_02_05.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![使用处理程序自动化事件和操作](graphics/B03800_02_05.jpg)'
- en: Tip
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Even when multiple tasks notify the handler, it will be called only once, toward
    the end. This will avoid multiple restarts of the same service unnecessarily.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 即使多个任务通知处理程序，它也只会在最后调用一次。这将避免不必要地多次重启同一个服务。
- en: 'By now, our Nginx role layout looks more complete and has files, handlers,
    tasks, and directories with individual tasks to manage each phase of the Nginx
    setup. The role layout is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的Nginx角色布局看起来更完整，包括文件、处理程序、任务和具有管理Nginx设置每个阶段的单独任务的目录。角色布局如下：
- en: '![Automating events and actions with handlers](graphics/B03800_02_06.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![使用处理程序自动化事件和操作](graphics/B03800_02_06.jpg)'
- en: Adding pre-tasks and post-tasks to playbooks
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向playbooks添加pre-tasks和post-tasks
- en: 'We would like to print status messages before and after we begin applying Nginx.
    Let''s add it to our `www.yml` playbook with the `pre_tasks` and `post_tasks`
    parameters:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在开始应用Nginx之前和之后打印状态消息。让我们在`www.yml` playbook中使用`pre_tasks`和`post_tasks`参数添加它：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding example, we only printed some messages using the `echo` command.
    However, we can create tasks using any of the modules available with Ansible,
    which can run before, or after, applying roles.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们只是使用`echo`命令打印了一些消息。但是，我们可以使用Ansible提供的任何模块创建任务，在应用角色之前或之后运行。
- en: Running playbooks with roles
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用角色运行playbooks
- en: 'Let''s now apply the refactored code to our hosts. We are going to launch only
    the site-wide playbook, that is, the `site.yml` file and then rely on the include
    statements and roles to do the magic:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将重构后的代码应用到我们的主机上。我们将只启动站点级playbook，也就是`site.yml`文件，然后依赖包含语句和角色来完成魔术：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s take a look at the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下截图：
- en: '![Running playbooks with roles](graphics/B03800_02_07.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![使用角色运行playbooks](graphics/B03800_02_07.jpg)'
- en: 'In addition to the output we saw last time, there are some new messages this
    time. Let''s analyze those:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上次看到的输出之外，这次还有一些新消息。让我们分析一下：
- en: Before and after, roles are applied, pre-tasks and post-tasks get triggered;
    this prints messages using the shell module.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用角色之前和之后，会触发pre-tasks和post-tasks；这使用shell模块打印消息。
- en: We now have the code to copy to the `config` and .`html` file for our Nginx
    web server.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在有了要复制到Nginx Web服务器的`config`和`.html`文件的代码。
- en: We also see that the handler triggers an Nginx service restart. This is due
    to the change in the state for the `configuration` file, which triggers the handler.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还看到处理程序触发了Nginx服务的重启。这是由于`configuration`文件状态的更改而触发了处理程序。
- en: Tip
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Did you notice that tasks in the base role also get triggered, even when we
    have not mentioned the base role in the `www` playbook? This is where meta information
    is useful. Remember we had specified a dependency on the base role inside `meta/main.yml`
    for Nginx? That's what did the trick.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否注意到，即使我们在`www`剧本中没有提到基本角色，基本角色中的任务也会被触发？这就是元信息有用的地方。还记得我们在Nginx的`meta/main.yml`中指定了对基本角色的依赖吗？这就是起作用的原因。
- en: 'Dependencies:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Review questions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习问题
- en: 'Do you think you''ve understood the chapter well enough? Try answering the
    following questions to test your understanding:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您认为自己是否已经足够理解本章了呢？试着回答以下问题来测试您的理解。
- en: Roles contain ___ and ___ subdirectories to specify variables/parameters.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 角色包含___和___子目录来指定变量/参数。
- en: How do you specify a dependency on another role?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何指定对另一个角色的依赖关系？
- en: When we add roles to a play, why is it not required that we use the `include`
    directives? How do the tasks, handlers, and so on, get added to the play automatically?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们向一个剧本添加角色时，为什么不需要使用`include`指令呢？任务、处理程序等是如何自动添加到剧本中的？
- en: Why do we have a separate section for handlers if they resemble regular tasks?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们要为处理程序单独设置一个部分，如果它们类似于常规任务？
- en: Which module can be used to copy over static files to destination hosts?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个模块可以用来将静态文件复制到目标主机？
- en: How do you specify the tasks to be run before applying a role in a playbook?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在剧本中指定在应用角色之前运行的任务？
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to use roles to provide abstraction and to
    help modularizing code for reuse. That's exactly what you see community doing.
    Creating roles, and sharing them with you. You also learned about `include` directives,
    directory layout for roles, and adding role dependencies. We then went on to refactor
    our code and created a base role, the Nginx role. We also looked at how to manage
    events and take actions using handlers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何使用角色来提供抽象，并帮助将代码模块化以便重用。这正是社区所做的。创建角色，并与您分享。您还学习了`include`指令、角色的目录布局以及添加角色依赖关系。然后我们对代码进行了重构，并创建了一个基本角色，即Nginx角色。我们还学习了如何使用处理程序来管理事件并采取行动。
- en: In the next chapter, we will extend the concepts of roles and start adding dynamic
    data with variables and templates.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展角色的概念，并开始使用变量和模板添加动态数据。
