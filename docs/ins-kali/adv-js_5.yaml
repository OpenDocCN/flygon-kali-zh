- en: '*Chapter 5*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*'
- en: Functional Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够做到以下几点：
- en: Explain functional programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释函数式编程
- en: Implement the key concepts of functional programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现函数式编程的关键概念
- en: Apply functional programming concepts to your code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数式编程概念应用于您的代码
- en: Build new code bases in the functional programming style
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以函数式编程风格构建新的代码库
- en: This chapter explains types of programming, including Object-oriented programming
    and Functional Programming, and how to work with different types of functions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了编程的类型，包括面向对象编程和函数式编程，以及如何使用不同类型的函数。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In the first chapter, we covered many of the new and powerful features released
    in ES6\. We discussed the evolution of JavaScript and highlighted the key additions
    in ES6\. We discussed scope rules, variable declaration, arrow functions, template
    literals, enhanced object properties, destructuring assignment, classes and modules,
    transpiling, and iterators and generators.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们涵盖了ES6中发布的许多新功能和强大功能。我们讨论了JavaScript的发展，并突出了ES6中的关键增强。我们讨论了作用域规则、变量声明、箭头函数、模板文字、增强对象属性、解构赋值、类和模块、转译以及迭代器和生成器。
- en: In the second chapter, we covered JavaScript's asynchronous programming paradigm.
    We discussed the JavaScript event loop, callbacks, promises, and the async/await
    syntax.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们涵盖了JavaScript的异步编程范式。我们讨论了JavaScript事件循环、回调、承诺和async/await语法。
- en: In the third chapter, we learned about the Document Object Model (DOM), the
    JavaScript Event object, and the jQuery library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三章中，我们学习了文档对象模型（DOM）、JavaScript事件对象和jQuery库。
- en: In the fourth chapter, we discussed testing JavaScript code. We covered the
    reasons for testing and ways to go about adding tests to code. Then, we discussed
    different types of code tests and how they can be applied to your code base. Finally,
    we discussed various JavaScript code-testing frameworks and how tests can be built
    in them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四章中，我们讨论了测试JavaScript代码。我们涵盖了测试的原因以及如何添加测试的方法。然后，我们讨论了不同类型的代码测试以及它们如何应用于您的代码库。最后，我们讨论了各种JavaScript代码测试框架以及如何在其中构建测试。
- en: In this chapter, we will cover the functional programming coding principles.
    In the first topic, we will define Object-oriented programming and functional
    programming, discuss the differences between the two, and outline the reasons
    why we use functional programming. Then, in the subsequent sections, we will discuss
    each of the key concepts of functional programming. For each key concept, we will
    outline the definition and show its application to functional programming.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍函数式编程的编码原则。在第一个主题中，我们将定义面向对象编程和函数式编程，讨论两者之间的区别，并概述我们使用函数式编程的原因。然后，在随后的部分中，我们将讨论函数式编程的每个关键概念。对于每个关键概念，我们将概述定义并展示其在函数式编程中的应用。
- en: Introducing Functional Programming
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入函数式编程
- en: There are many different ways to approach software design and construction.
    The two most well-known design philosophies, or programming paradigms, are **Object-oriented
    programming (OOP)** and **Functional Programming (FP)**. A programming paradigm
    is a way of thinking about software design and construction. Programming paradigms
    are based on several defining principles and are used to organize and characterize
    the design and construction of software applications. Functional Programming is
    a programming paradigm focused on building software through expressions and declarations.
    In this section, we will discuss the very basics of Object-Oriented Programming
    and Functional Programming, and compare the two programming paradigms.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的方法来处理软件设计和构建。最知名的设计哲学或编程范式是面向对象编程（OOP）和函数式编程（FP）。编程范式是一种思考软件设计和构建的方式。编程范式基于几个定义原则，并用于组织和描述软件应用的设计和构建。函数式编程是一种通过表达式和声明构建软件的编程范式。在本节中，我们将讨论面向对象编程和函数式编程的基础知识，并比较这两种编程范式。
- en: Object-Oriented Programming
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: '**Object-Oriented Programming (OOP)** is a programming paradigm based on objects
    and statements. Objects are programming abstractions used to organize pieces of
    an application. In OOP, objects usually contain and store data in attributes,
    have procedures they can run in methods, and have some notion of **this** or **self**,
    a way for the object to reference itself. Generally, objects come in the form
    of classes. A **class** can be thought of as the definition of an object, with
    its attributes, methods, and **this** scope. An **object** is the instantiation
    of a class. In OOP, statements are instruction-driven code. This will be covered
    more in the *Declarative Versus Imperative* topic. Many programming languages
    work well for OOP software development. The most popular OOP languages are C++,
    Java, and Python.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）是一种基于对象和语句的编程范式。对象是用于组织应用程序部分的编程抽象。在OOP中，对象通常包含并存储属性中的数据，具有可以在方法中运行的过程，并且具有**this**或**self**的概念，这是对象引用自身的一种方式。一般来说，对象以类的形式存在。**类**可以被视为对象的定义，具有其属性、方法和**this**范围。**对象**是类的实例化。在OOP中，语句是指令驱动的代码。这将在*声明式与命令式*主题中更详细地介绍。许多编程语言都适用于面向对象编程软件开发。最流行的面向对象编程语言是C++、Java和Python。
- en: Functional Programming
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数式编程
- en: '**Functional Programming (FP)** is a programming paradigm based on expressions
    and declarations instead of objects and statements. In short, this means that
    FP relies on functions instead of objects to organize code and build applications.
    Functional Programming is thought to have originated from lambda calculus, which
    was created in the 1930s. Functional Programming relies on seven key concepts:
    **declarative functions**, **pure functions**, **higher order functions**, **shared
    state**, **immutability**, **side effects**, and **function composition**. Each
    of these concepts will be covered in a subsequent topic in this chapter.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程（FP）是一种基于表达式和声明而不是对象和语句的编程范式。简而言之，这意味着FP依赖于函数而不是对象来组织代码和构建应用程序。函数式编程被认为起源于λ演算，这是在上世纪30年代创造的。函数式编程依赖于七个关键概念：声明式函数，纯函数，高阶函数，共享状态，不可变性，副作用和函数组合。这些概念中的每一个将在本章的后续主题中进行讨论。
- en: Functional Programming is designed to be more concise, predictable, and testable.
    These benefits, however, can result in FP code being denser than other coding
    paradigms. Some of the most common Functional Programming languages are JavaScript,
    PHP, and Python.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程旨在更简洁，可预测和可测试。然而，这些好处可能导致FP代码比其他编程范式更密集。一些最常见的函数式编程语言是JavaScript，PHP和Python。
- en: Declarative Versus Imperative
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明式与命令式
- en: 'There are two general ways to think about writing code: **Declarative** and
    **Imperative**. Code written in the Functional Programming paradigm should be
    declarative.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种一般的编写代码的方式：**声明式**和**命令式**。在函数式编程范式中编写的代码应该是声明式的。
- en: '**Declarative code** is code that expresses the logic of a computation without
    describing its control flow. Imperative code is code that uses statements to change
    a program''s state.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**声明式代码**是表达计算逻辑而不描述其控制流的代码。命令式代码是使用语句来改变程序的状态的代码。'
- en: These definitions are difficult to understand if you have never studied declarative
    and imperative code before. Declarative code is generally used with Functional
    Programming and imperative code is generally used with Object-Oriented Programming.
    There is no "right answer" when deciding which coding style to use; they both
    have their trade-offs. However, declarative code fits the Functional Programming
    paradigm better than imperative.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前从未学习过声明式和命令式代码，这些定义很难理解。声明式代码通常与函数式编程一起使用，而命令式代码通常与面向对象编程一起使用。在决定使用哪种编码风格时，没有“正确答案”；它们都有各自的权衡。然而，声明式代码比命令式更适合函数式编程范式。
- en: Imperative Functions
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令式函数
- en: '**Imperative code** is most common in OOP. The technical definition is complicated,
    but we can simplify it. An imperative approach to coding is about HOW you solve
    the problem. Consider finding a table at a restaurant. You approach the host/hostess
    and say "I see that the table in the corner is empty. My wife and I are going
    to walk over and sit down." This is an imperative approach because you describe
    exactly how you are going go from the host/hostess to getting a table for your
    party.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令式代码**在面向对象编程中最常见。技术上的定义很复杂，但我们可以简化它。编写命令式代码是关于你如何解决问题。考虑在餐厅找到一张桌子。你走向主人/女主人说：“我看到角落的桌子是空的。我和我的妻子要走过去坐下。”这是一种命令式方法，因为你描述了你将如何从主人/女主人那里到你的团队的桌子。'
- en: Declarative Functions
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明式函数
- en: Declarative programming is most common in FP. The declarative approach to coding
    can be simplified as WHAT we need to do. Consider the restaurant example from
    the previous paragraph. A declarative approach to getting a table would be to
    approach the host/hostess and say "table for two please." We describe what we
    need, not every step we will take to get the table. Declarative programming is
    the act of conforming to the mental model of the developer rather than the operational
    model of the machine. From these definitions and metaphors, we can conclude that
    declarative programming is an abstraction of some imperative implementation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式编程在FP中最常见。编写声明式代码的方法可以简化为我们需要做什么。考虑前面段落中的餐厅例子。获取桌子的声明式方法是走向主人/女主人说：“请给我们两个人的桌子。”我们描述我们需要什么，而不是我们将采取的每一步来获得桌子。声明式编程是符合开发者的思维模型而不是机器的操作模型。从这些定义和比喻中，我们可以得出结论，声明式编程是对一些命令式实现的抽象。
- en: 'Now, let''s move from the metaphor to actual code. Consider the code shown
    in the following snippet:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从比喻转到实际代码。考虑下面片段中显示的代码：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Snippet 5.1: Declarative versus imperative functions'
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段5.1：声明式与命令式函数
- en: In the preceding snippet, we create two functions to add the values in an array.
    The first function, `addImperative`, is an imperative approach to this problem.
    The code states exactly how the array will be added, step by step. The second
    function, `addDeclarative`, is a declarative approach to the same problem. The
    code states how the array will be added. It abstracts out much of the imperative
    solution (`for` loop) by using the JavaScript array reduce operation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，我们创建了两个函数来添加数组中的值。第一个函数`addImperative`是这个问题的一种命令式方法。代码逐步说明了数组将如何被添加。第二个函数`addDeclarative`是同一个问题的一种声明式方法。代码说明了数组将如何被添加。它通过使用JavaScript数组reduce操作来抽象出大部分命令式解决方案（for循环）。
- en: The simplest way to begin writing declarative code instead of imperative code
    is by creating functions. These functions should abstract away the step-by-step
    nature of the imperative parts of your code. Consider array operations such as
    `find`, `map`, and `reduce`. These functions are all array member functions that
    are declarative. They abstract away the step-by-step nature of iterating over
    an array. Using them will help introduce declarative concepts into your code and
    reduce some of the imperative code that you write.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 开始编写声明式代码而不是命令式代码的最简单方法是创建函数。这些函数应该抽象出命令式代码的逐步性质。考虑数组操作，如`find`，`map`和`reduce`。这些函数都是声明式的数组成员函数。它们抽象出了对数组进行迭代的逐步性质。使用它们将有助于将声明式概念引入您的代码，并减少您编写的一些命令式代码。
- en: 'Exercise 28: Building Imperative and Declarative Functions'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习28：构建命令式和声明式函数
- en: Your research team has obtained a list of values from your latest experiment;
    however, due to a calibration error, only some of the data can be used and any
    data that can be used needs to be scaled. You must build a utility function that
    takes in an array, filters out any values less than or equal to 0, scales the
    remaining values by multiplying them by `2`, and returns the final results. First,
    build an imperative function to do this, then build a declarative function to
    do the same thing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您的研究团队已经获得了最新实验的值列表；但是，由于校准错误，只有部分数据可以使用，并且可以使用的任何数据都需要进行缩放。您必须构建一个实用函数，该函数接受一个数组，过滤掉小于或等于0的任何值，将剩余的值缩放为乘以`2`，并返回最终结果。首先，构建一个命令式函数来执行此操作，然后构建一个声明式函数来执行相同的操作。
- en: 'To create functions using imperative and declarative coding practices, perform
    the following steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用命令式和声明式编码实践创建函数，请执行以下步骤：
- en: 'Define a function called `imperative` that takes the following approach:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`imperative`的函数，采用以下方法：
- en: Take in an array argument called `arr`. Create an array called `filtered` that
    will hold the filtered values.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接受一个名为`arr`的数组参数。创建一个名为`filtered`的数组，用于保存过滤后的值。
- en: Create a `for` loop to step through the input array, `arr`. For each item, check
    the array item value. If greater than `0`, push the value to the filtered array.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`for`循环来遍历输入数组`arr`。对于每个项目，检查数组项的值。如果大于`0`，将该值推送到过滤后的数组中。
- en: Create a `for` loop to step through the filtered array. For each item, multiply
    it by `2` and save it back in the filtered array in the same index.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`for`循环来遍历过滤后的数组。对于每个项目，将其乘以`2`并保存在相同索引的过滤后的数组中。
- en: Return the filtered array.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 返回过滤后的数组。
- en: 'Define a function called `declarative` that does the following:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`declarative`的函数，执行以下操作：
- en: Filter the input array with `Array.filter()`. In the filter's `callback` function,
    check whether the value is greater than `0`. If it is, return true; otherwise,
    return false.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Array.filter()`过滤输入数组。在过滤器的`callback`函数中，检查值是否大于`0`。如果是，返回true；否则，返回false。
- en: Chain a map call to the `filter` output.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个map调用链接到`filter`输出。
- en: Map the filtered array with `Array.map()`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Array.map()`映射过滤后的数组。
- en: In the callback, multiply each value by `2`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调中，将每个值乘以`2`。
- en: Return the modified array.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 返回修改后的数组。
- en: Create a test value array with values from `-5` to `+5`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个值从`-5`到`+5`的测试值数组。
- en: Run `imperative` with the values array and log the output.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用值数组运行`imperative`并记录输出。
- en: Run `declarative` with the values array and log the output.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用值数组运行`declarative`并记录输出。
- en: '**Code**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: index.js
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: index.js
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Snippet 5.2: Imperative and declarative code comparison'
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 代码段5.2：命令式和声明式代码比较
- en: https://bit.ly/2skAnic
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2skAnic
- en: '**Outcome**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**'
- en: '![Figure 5.1: Test values output'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1：测试值输出'
- en: '](image/Figure_5.1.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.1.jpg)'
- en: 'Figure 5.1: Test values output'
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.1：测试值输出
- en: '![Figure 5.2: The modified array output'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2：修改后的数组输出'
- en: '](image/Figure_5.2.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.2.jpg)'
- en: 'Figure 5.2: The modified array output'
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.2：修改后的数组输出
- en: You have successfully utilized imperative and declarative coding practices to
    write functions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功利用了命令式和声明式编码实践来编写函数。
- en: Pure Functions
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数
- en: '**Pure functions** are a key component of Functional Programming. A pure function
    can be defined as a function that does not have any effect on or make use of any
    state outside of the function. A function must meet three key criteria to be considered
    pure:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**纯函数**是函数式编程的关键组成部分。纯函数可以定义为不对函数外部的状态产生任何影响或利用任何状态的函数。要被视为纯函数，函数必须满足三个关键标准：'
- en: A function must always return the same output, when given the same inputs.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当给定相同的输入时，函数必须始终返回相同的输出。
- en: A function must have no side effects.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数不能有副作用。
- en: A function must have referential transparency.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数必须具有引用透明性。
- en: Same Output Given Same Input
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相同的输入给出相同的输出
- en: 'Given a set of input values, a pure function must always return the same value
    when provided those input values. This sounds much more complicated than it is.
    Simply put, the output of a pure function cannot change unless the input values
    are changed. This means that a function''s internal code cannot depend on any
    program state outside of the function. A pure function cannot use any variable
    from outside the function to make calculations or code path decisions. An example
    of this is shown in the following snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一组输入值，纯函数在提供这些输入值时必须始终返回相同的值。这听起来比实际情况复杂得多。简而言之，纯函数的输出不能改变，除非更改输入值。这意味着函数的内部代码不能依赖于函数外部的任何程序状态。纯函数不能使用函数外部的任何变量来进行计算或代码路径决策。以下代码段显示了这一点的示例：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Snippet 5.3: Relying on an external state'
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 代码段5.3：依赖外部状态
- en: In the preceding snippet, we create a variable called state with the `prop1`
    property set to `5`. We then define two functions that return the strings `Valid`
    or `Invalid`, depending on a value comparison. In the first function, `notPure`,
    we check the `prop1` value of the state and return a value based on that. In the
    second function, pure, we check the value passed into the function to decide what
    to return. The first function is not a pure function. It relies on a state outside
    of the function to determine the return value of the function. The second function
    is pure because it relies on the input value of the function, not the global state
    variable.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们创建了一个名为state的变量，其中的`prop1`属性设置为`5`。然后我们定义了两个函数，根据值的比较返回字符串`Valid`或`Invalid`。在第一个函数`notPure`中，我们检查state的`prop1`值，并根据此返回一个值。在第二个函数pure中，我们检查传入函数的值来决定返回什么。第一个函数不是一个纯函数。它依赖于函数外部的状态来确定函数的返回值。第二个函数是纯的，因为它依赖于函数的输入值，而不是全局状态变量。
- en: No Side Effects
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无副作用
- en: 'A pure function must have no side effects. This simply means that a pure function
    cannot modify any objects or values passed in by reference. Side effects will
    be discussed in more detail in the *Side Effects* topic. In JavaScript, only objects
    and arrays can be passed into functions by reference. A pure function cannot modify
    these objects or arrays in any way. If your function needs to update or modify
    an array or object internally, we must first create a copy of the array/object.
    It is important to note that, in JavaScript, copying an object or array only copies
    the first level of the entity. This means that if an array or object has arrays
    or objects nested in it, these nested references will not be copied. When the
    copied object is by reference by reference, the nested objects will not have been
    copied, and will also be passed. This means that a nested reference, if not explicitly
    copied, can cause a side effect. To properly copy an object, we must create a
    deep copy. A deep copy of an object is a copy that duplicates all nested references.
    This can be done recursively or through the Node.js `deepcopy` module. An example
    of side effects is shown in the following snippet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数不能有副作用。这简单地意味着纯函数不能修改通过引用传递的任何对象或值。副作用将在*副作用*主题中更详细地讨论。在JavaScript中，只有对象和数组可以通过引用传递给函数。纯函数不能以任何方式修改这些对象或数组。如果您的函数需要在内部更新或修改数组或对象，我们必须首先创建数组/对象的副本。重要的是要注意，在JavaScript中，复制对象或数组只会复制实体的第一层。这意味着如果一个数组或对象中嵌套了数组或对象，这些嵌套的引用将不会被复制。当复制的对象按引用传递时，嵌套的对象也将被传递。这意味着如果嵌套引用没有被显式复制，可能会导致副作用。要正确地复制一个对象，我们必须创建一个深拷贝。对象的深拷贝是一个复制所有嵌套引用的副本。这可以通过递归或通过Node.js的`deepcopy`模块来完成。副作用的一个示例在下面的片段中显示：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Snippet 5.4: Avoiding side effects'
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段5.4：避免副作用
- en: In the preceding snippet, we define two functions, `notPure` and `pure`. Both
    functions add a property to the `input` object passed into the function. The impure
    version of the function (`notPure()`) modifies the `input` object in place. Because
    objects are passed by reference, this update will be seen in all other scopes
    where the object is used. This is a side effect. The pure version of the function
    (`pure()`) creates a deep copy of the object with JSON operations and then adds
    a new property to the new object and returns the new object. Since the object
    was cloned, the original object is not modified. No side effect is created.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们定义了两个函数`notPure`和`pure`。这两个函数都向传入函数的`input`对象添加一个属性。函数的不纯版本（`notPure()`）直接修改了`input`对象。因为对象是按引用传递的，这个更新将在所有其他使用对象的范围内可见。这是一个副作用。函数的纯版本（`pure()`）通过JSON操作创建了对象的深拷贝，然后向新对象添加了一个新属性并返回了新对象。由于对象被克隆了，原始对象没有被修改。没有产生副作用。
- en: Referential Transparency
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用透明度
- en: '**Referential transparency** is a property of pure functions that makes figuring
    out the function behavior simpler. If a function has referential transparency,
    a call to that function can be replaced with the function call''s resultant value
    (the value returned by the function) without changing the meaning of the code.
    In short, this means that functions should return values that make sense in the
    context of the code they are being used in, and they should not depend on or modify
    states outside of the function.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**引用透明度**是纯函数的一个属性，使得弄清楚函数行为更简单。如果一个函数具有引用透明性，那么对该函数的调用可以用函数调用的结果值（函数返回的值）替换，而不改变代码的含义。简而言之，这意味着函数应该返回在其被使用的代码上下文中有意义的值，并且不应该依赖或修改函数外部的状态。'
- en: 'Writing pure functions gives us two key benefits:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 编写纯函数给我们带来了两个关键的好处：
- en: The first is that pure functions are very easy to unit test. Pure functions
    do not rely on external states, so there is no other context to consider when
    writing tests. We only need to consider the input and output values.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个好处是纯函数非常容易进行单元测试。纯函数不依赖外部状态，因此在编写测试时不需要考虑其他上下文。我们只需要考虑输入和输出值。
- en: Second, pure functions make code simpler and more flexible. Pure functions do
    not rely on outside states and do not create side effects. This means that they
    can be used in any special context. They can be used in more places and are therefore
    more flexible.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，纯函数使代码更简单、更灵活。纯函数不依赖外部状态，也不产生副作用。这意味着它们可以在任何特殊的上下文中使用。它们可以在更多的地方使用，因此更灵活。
- en: 'Exercise 29: Building Pure Controllers'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习29：构建纯控制器
- en: You have been hired as a developer to upgrade an online store's shopping cart
    implementation. Build a function to add items to the shopping cart. Your function
    should be pure. You can assume there is a global array, called `cart`, that contains
    the shopping cart. The function should, at a minimum, take in an item (string)
    and a quantity (`number`). Create the function in the provided file (`exercise-test.js`)
    with the function name `addItem()`. The file will have basic tests to test purity.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您已被聘为开发人员，以升级在线商店的购物车实现。构建一个函数来向购物车添加物品。您的函数应该是纯的。您可以假设有一个名为`cart`的全局数组，其中包含购物车。该函数应该至少接受一个物品（字符串）和一个数量（`number`）。在提供的文件（`exercise-test.js`）中创建名为`addItem()`的函数。该文件将有基本测试来测试纯度。
- en: 'To build part of an application with pure function concepts, perform the following steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用纯函数概念构建应用程序的一部分，请执行以下步骤：
- en: Open the test file at **exercises/exercise29/exercise-test.js**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**exercises/exercise29/exercise-test.js**中的测试文件。
- en: 'Create a function called `addItem` that takes in three parameters: `cart`,
    `item`, and `quantity`.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`addItem`的函数，它接受三个参数：`cart`、`item`和`quantity`。
- en: 'Duplicate the `cart` passed into the function and save the duplicated value
    into a variable called `newCart`. Duplicate the `cart` with one of the following
    methods:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制传入函数的`cart`，并将复制的值保存到名为`newCart`的变量中。使用以下方法之一复制`cart`：
- en: 'Use JSON operations for the simplest duplication: `JSON.parse( JSON.stringify(
    cart ) )`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最简单的复制，请使用JSON操作：`JSON.parse( JSON.stringify( cart ) )`。
- en: Step through the original cart array with a loop and push each item to a new
    array.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过循环遍历原始购物车数组，并将每个项目推送到新数组中。
- en: Use `cart.map( () => {} )` since all items in the array are simple types.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cart.map( () => {} )`，因为数组中的所有项目都是简单类型。
- en: Use the `rest/spread` operator, `newCart= [ ...cart ]`, because all items are
    simple types.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`rest/spread`运算符，`newCart= [ ...cart ]`，因为所有项目都是简单类型。
- en: Push the item passed into the function, onto the `cart` array, `quantity` number
    of times.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将传入函数的项目推送到`cart`数组中，`quantity`次数。
- en: Return the `newCart` array.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`newCart`数组。
- en: Run the code provided in `exercise-test.js`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`exercise-test.js`中提供的代码。
- en: If an error is thrown, fix the bug in the code and run the test again.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出错误，请修复代码中的错误，然后再次运行测试。
- en: '**Code**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: exercise-solution.js
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: exercise-solution.js
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Snippet 5.5: Function purity testing'
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Snippet 5.5：函数纯度测试
- en: https://bit.ly/2H2TXJG
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2H2TXJG
- en: '**Output**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '![Figure 5.3: Returning the new cart array'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3：返回新的购物车数组'
- en: '](image/Figure_5.3.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.3.jpg)'
- en: 'Figure 5.3: Returning the new cart array'
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.3：返回新的购物车数组
- en: You have successfully applied the concept of pure functions to build part of
    an application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功应用了纯函数的概念来构建应用程序的一部分。
- en: Higher Order Functions
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高阶函数
- en: 'As we learned in the first topic, a higher order function is a function that
    either takes another function in as an input argument or returns another function
    as the return value. Nearly all asynchronous code in JavaScript makes use of higher
    order functions by passing callback functions in as input arguments. Aside from
    their prolific use in JavaScript, higher order functions are a key part of Functional
    Programming and are used for three key benefits: abstraction, utilities, and complexity
    reduction.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第一个主题中学到的，高阶函数是一个要么将另一个函数作为输入参数，要么返回另一个函数作为返回值的函数。几乎所有JavaScript中的异步代码都利用高阶函数，通过将回调函数作为输入参数传递。除了它们在JavaScript中的广泛使用之外，高阶函数是函数式编程的关键部分，用于三个关键好处：抽象、实用程序和复杂性减少。
- en: Higher order functions are very important for abstraction. Abstraction is a
    way to hide the internal workings or details of a procedure. For example, consider
    the process of cooking a meal from a recipe. A recipe may require you to chop
    a food item. What is chopping? It is an abstraction of an action. The action and
    steps to complete the action are to take a knife, place it over the food item,
    and press downward. Then, move the knife a short distance along the food item
    and repeat the process until no large pieces remain. Chopping is an abstraction
    of this action. It is simpler and quicker to say "chop the carrot" instead of
    the long-form description. As with preparing food, code uses abstraction to wrap
    a complicated procedure and hide the internal workings of the code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数对于抽象非常重要。抽象是隐藏过程的内部工作或细节的一种方式。例如，考虑根据食谱烹饪一餐的过程。食谱可能要求您切碎食物。什么是切碎？它是一个动作的抽象。完成该动作的动作和步骤是拿起刀，将其放在食物上，向下按压。然后，将刀移动一小段距离沿着食物，并重复该过程，直到没有大块残留。切碎是这个动作的抽象。说“切胡萝卜”比长篇描述更简单更快。与准备食物一样，代码使用抽象来包装复杂的过程，并隐藏代码的内部工作。
- en: 'Higher order functions can be very useful for creating functional utilities.
    As programmers, we often create utility functions that are designed to perform
    an action on a set of values. Often, we want to maximize flexibility and create
    functions that work over a wide range of potential input values or formats. Creating
    higher order utility functions that take in some parameters and return a new function
    can be a great way to do this. These functions are often called closures in JavaScript.
    Consider the functions shown in the following snippet:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数对于创建功能性实用程序非常有用。作为程序员，我们经常创建旨在对一组值执行操作的实用函数。通常，我们希望最大限度地提高灵活性，并创建可以在各种潜在输入值或格式上工作的函数。创建接受一些参数并返回新函数的高阶实用函数可以是一个很好的方法。这些函数在JavaScript中通常称为闭包。考虑以下片段中显示的函数：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Snippet 5.6: Higher order utilities'
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Snippet 5.6：高阶实用程序
- en: In the preceding snippet, we have created two utility functions for sorting
    arrays of objects by the value stored in the specified field. The utility functions
    both need the field to be specified. Where they differ is the return value. `SortObjField1`
    is a higher order function that takes in the field name and returns a closure
    function. The closure function takes in the two objects we are trying to sort
    and returns the sorting value. The second helper function, `sortObjField2`, takes
    in the field and the two objects at once and returns the sorting value. The higher
    order utility function is much more powerful because we do not need to know all
    of the values at the same time. We can pass `sortObjField( 'field' )` as a parameter
    to another function to be used in another part of the program.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们创建了两个用于按指定字段中存储的值对对象数组进行排序的实用函数。这两个实用函数都需要指定字段。它们的区别在于返回值。`SortObjField1`是一个高阶函数，它接受字段名称并返回一个闭包函数。闭包函数接受我们尝试排序的两个对象，并返回排序值。第二个辅助函数`sortObjField2`一次接受字段和两个对象，并返回排序值。高阶实用函数更加强大，因为我们不需要同时知道所有的值。我们可以将`sortObjField(
    'field' )`作为参数传递给另一个函数，以在程序的另一个部分中使用。
- en: Higher order functions are also very useful for reducing complexity. Code that
    is longer and more complex is more prone to having bugs. Higher order functions
    abstract away the internal workings of complex parts of the code and can use utility
    functions to reduce the lines of code that need to be written. Both of these effects
    will reduce the size of your code base and therefore reduce the complexity. Making
    the code simpler will help to reduce the time you must spend fixing bugs.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数对于减少复杂性也非常有用。代码越长越复杂，就越容易出现错误。高阶函数将复杂部分的内部工作抽象出来，并可以使用实用函数来减少需要编写的代码行数。这两种效果都将减少代码库的大小，从而减少复杂性。简化代码将有助于减少您必须花费在修复错误上的时间。
- en: 'Exercise 30: Editing Object Arrays'
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习30：编辑对象数组
- en: 'The aim is to apply the concepts of higher order functions to edit arrays of
    objects. To edit the arrays using the necessary functions, perform the following
    steps:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是将高阶函数的概念应用于编辑对象数组。要使用必要的函数编辑数组，请执行以下步骤：
- en: 'Create an array called `data` that contains the following data: `[ { f1: 6,
    f2: 3 }, { f1: 12, f2: 0 }, { f1: 9, f2: 1 }, { f1: 6, f2: 7 } ]`.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个名为`data`的数组，其中包含以下数据：`[ { f1: 6, f2: 3 }, { f1: 12, f2: 0 }, { f1: 9, f2:
    1 }, { f1: 6, f2: 7 } ]`。'
- en: Create a function called `swap` that takes in two arguments, `key1` and `key2`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`swap`的函数，它接受两个参数`key1`和`key2`。
- en: Add a `return` statement to the `swap` function. The `return` statement should
    return a function. This function should take in one argument, `obj`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`swap`函数添加一个`return`语句。`return`语句应返回一个函数。这个函数应该接受一个参数`obj`。
- en: Inside the returned function, using array destructuring, swap the values of
    `key1` and `key2` stored in `obj`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在返回的函数内部，使用数组解构，交换`obj`中存储的`key1`和`key2`的值。
- en: 'Hint: Use `[a, b] = [b, a]` to swap values with array destructuring.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：使用`[a, b] = [b, a]`来使用数组解构交换值。
- en: Return the modified object, `obj`, from the function.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从函数中返回修改后的对象`obj`。
- en: Edit the data array by calling the `map` function on `data`. Pass a call to
    swap, with the parameters `f1` and `f2`, as the argument for the map function.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`data`上调用`map`函数来编辑数据数组。将带有参数`f1`和`f2`的调用传递给`map`函数。
- en: 'Hint: `data.map( swap( ''f1'', ''f2'' ) );`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：`data.map( swap( 'f1', 'f2' ) );`
- en: Log the output of the call to `data.map()`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录对`data.map()`的调用的输出。
- en: '**Code**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: '**index.js**'
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**index.js**'
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: https://bit.ly/2D0t70K
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2D0t70K
- en: '**Output**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '![Figure 5.4: Final Output](image/Figure_5.4.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4：最终输出](image/Figure_5.4.jpg)'
- en: 'Figure 5.4: Final Output'
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.4：最终输出
- en: You’ve successfully applied the concepts of higher order functions to edit arrays
    of objects.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功将高阶函数的概念应用于编辑对象数组。
- en: Shared State
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享状态
- en: 'A **shared state** is any variable, object, or memory space that exists in
    a shared scope. Any non-constant variable used by multiple separate scopes, including
    the global scope and closure scopes, is considered to be in a shared state. In
    functional programming, shared states should be avoided. A shared state prevents
    a function from being pure. When the shared state rule is violated and the program
    modifies a variable, a side effect is created. In OOP, shared states are often
    passed around as objects. OOP functions may modify the shared state. This is very
    much against functional programming rules. An example of a shared state is shown
    in the following snippet:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**共享状态**是存在于共享范围中的任何变量、对象或内存空间。任何被多个独立范围使用的非常量变量，包括全局范围和闭包范围，都被视为处于共享状态。在函数式编程中，应该避免共享状态。共享状态会阻止函数变得纯粹。当违反共享状态规则并且程序修改变量时，就会产生副作用。在面向对象编程中，共享状态通常作为对象传递。面向对象编程函数可能会修改共享状态。这与函数式编程规则背道而驰。下面的片段中展示了一个共享状态的示例：'
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Snippet 5.7: Shared state'
  id: totrans-139
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段5.7：共享状态
- en: In the preceding example, we have a variable in the global scope called `state`.
    In our function called `doSomething`, we reference the variable state to make
    a logical code decision. Since the `state` variable was defined outside of the
    scope of our `doSomething` function and is not an immutable object (an object
    whose state cannot be modified after it has been created), it is considered a
    shared state. This is something that should be avoided in Functional Programming
    because it prevents our functions from being pure.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一个全局范围内的变量称为`state`。在我们的名为`doSomething`的函数中，我们引用变量state来做出逻辑代码决定。由于`state`变量是在`doSomething`函数的范围之外定义的，并且不是一个不可变对象（创建后其状态无法修改的对象），它被认为是一个共享状态。这是函数式编程中应该避免的事情，因为它会阻止我们的函数变得纯粹。
- en: Shared states must be avoided for several reasons. First, a shared state can
    make it difficult to understand a function. To truly understand how a function
    works and what the output results will be given an input, we must understand the
    entire state that the function operates under. If our function uses a shared state,
    we have a much more complex state to understand before we can properly understand
    the function. It is very difficult to understand a shared state in detail. To
    properly understand a shared state, you must understand how the state is updated
    and how it is used in every function it is shared with.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 共享状态必须避免，原因有几个。首先，共享状态可能会使理解函数变得困难。要真正理解函数的工作原理以及给定输入的输出结果，我们必须理解函数所在的整个状态。如果我们的函数使用共享状态，那么在正确理解函数之前，我们必须理解一个更加复杂的状态。详细理解共享状态非常困难。要正确理解共享状态，必须理解状态如何更新以及它如何在与之共享的每个函数中使用。
- en: While it may not sound like a major drawback at first, not understanding how
    our functions work will result in slower development, more bugs, and inadequate
    testing. Shared states slow down development simply because we must take more
    time to understand the functions that rely on them. If we do not take the time
    to understand the shared states and functions that rely on them, then it is likely
    that we will not write code that is efficient and bug-free. This will obviously
    lead to more time spent debugging and refactoring code. Functions that are not
    fully understood tend to be more bug-ridden. If we do not fully understand how
    the function needs to operate under all of the possibilities and limitations defined
    in the shared states, it is likely that we will forget to handle edge cases in
    our development. If these bugs are not found, then faulty code could be released.
    Finally, not understanding functions makes it nearly impossible to fully test
    a function. To fully test any function, we must understand exactly how it will
    operate under all conditions, or in other words, under all states it could be
    called under.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然起初听起来可能不是一个主要的缺点，但不理解我们的函数如何工作将导致开发速度变慢，出现更多的错误和不充分的测试。共享状态会减慢开发速度，因为我们必须花更多的时间来理解依赖于它们的函数。如果我们不花时间理解共享状态和依赖于它们的函数，那么我们很可能不会编写高效和无错误的代码。这显然会导致更多时间用于调试和重构代码。不完全理解的函数往往更容易出现错误。如果我们不完全理解函数在共享状态中定义的所有可能性和限制下需要如何操作，那么我们很可能会忘记在开发中处理边缘情况。如果这些错误没有被发现，那么有缺陷的代码可能会被发布。最后，不理解函数几乎不可能完全测试一个函数。要完全测试任何函数，我们必须完全理解它在所有条件下的操作方式，换句话说，就是在所有可能被调用的状态下。
- en: 'Exercise 31: Fixing Shared States'
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习31：修复共享状态
- en: 'The aim is to refactor code to remove shared states. To properly refactor the
    code, perform the following steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是重构代码以消除共享状态。要正确地重构代码，请执行以下步骤：
- en: Open the file at `exercises/exercise31/exercise.js`. You will be updating this
    file to solve the exercise.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`exercises/exercise31/exercise.js`文件。您将更新此文件以解决练习。
- en: Run the code in the file opened in *step 1* and observe the output.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行*步骤1*中打开的文件中的代码，并观察输出。
- en: Update the `getOlder` function declaration to take in a parameter called `age`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`getOlder`函数声明，以接受一个名为`age`的参数。
- en: Update the body of `getOlder` to return `age+1` or `++age` instead of modifying
    the global variable.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`getOlder`的主体，使其返回`age+1`或`++age`，而不是修改全局变量。
- en: Update the `formatName` function declaration to take in two parameters, `first` and
    `last`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`formatName`函数声明更新为接受两个参数，`first`和`last`。
- en: Update the body of `formatName` to return the `Mrs. ${first} ${last}` string, where
    first and last are the values stored in the input parameters `first` and `last`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`formatName`的主体，使其返回`Mrs. ${first} ${last}`字符串，其中`first`和`last`是存储在输入参数`first`和`last`中的值。
- en: Update the call to the `getOlder` function and pass in `person.age` as the parameter.
    Save the returned value into `person.age`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新对`getOlder`函数的调用，并将`person.age`作为参数传入。将返回的值保存到`person.age`中。
- en: Update the function call to `formatName` and pass in `person.firstName` and
    `person.lastName` as the parameters. Save the value returned in `person.name`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新对`formatName`的函数调用，并将`person.firstName`和`person.lastName`作为参数传入。将返回的值保存到`person.name`中。
- en: Run the code and compare the output to the output from *step 2*. They should
    be the same.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并将输出与*步骤2*的输出进行比较。它们应该是相同的。
- en: '**Code**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: '**solution.js**'
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: solution.js
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: https://bit.ly/2CZwyoC
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2CZwyoC
- en: '**Output**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '![Figure 5.5: Final Output'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.5：最终输出'
- en: '](image/Figure_5.5.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.5.jpg)'
- en: 'Figure 5.5: Final Output'
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.5：最终输出
- en: You’ve successfully managed to refactor code to remove shared states.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功地重构了代码以消除共享状态。
- en: Immutability
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变性
- en: Immutability is a very simple concept but very important to Functional Programming.
    The textbook definition of **immutability** is simply "something that is not changeable."
    In programming, we use the word to mean objects and variables whose state cannot
    be changed after they have been created.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性是函数式编程中非常简单但非常重要的概念。**不可变性**的教科书定义只是“不可改变的”一词。在编程中，我们使用这个词来表示对象和变量在创建后不能改变其状态。
- en: In software development, values can be passed into functions by reference. When
    a variable is passed by reference, it means that a reference to the memory location
    (a pointer) is passed instead of the serialized value of the object contained
    at that location in memory. Since all of the pointers for a variable passed by
    reference point to the same block of memory, any update to the value of the variable
    passed by reference will be seen by any pointer pointing to that block of memory.
    Any variable passed by reference instead of by value can be considered a shared
    state, since it can be modified by multiple separate scopes. It is important to
    write functions that prevent the mutation of data because any change to values
    passed by reference will act as a change to the shared state. Modifying the variables
    passed by reference will violate the principles of Functional Programming and
    will lead to side effects.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，值可以通过引用传递给函数。当变量通过引用传递时，意味着传递的是指向内存位置（指针）的引用，而不是内存中该位置包含的对象的序列化值。由于所有指向引用传递的变量的指针都指向同一块内存，对通过引用传递的变量值的任何更新都将被指向该内存块的任何指针看到。任何通过引用传递而不是通过值传递的变量都可以被视为共享状态，因为它可以被多个独立作用域修改。编写防止数据突变的函数非常重要，因为对通过引用传递的值的任何更改都将被视为对共享状态的更改。修改通过引用传递的变量将违反函数式编程的原则，并导致副作用。
- en: In JavaScript, the concept of immutability generally applies to variables that
    are passed into, and returned by, functions. In JavaScript, simple types (string,
    number, bool) are passed by value, and complex types (objects, arrays, and so
    on) are passed by reference. Any changes to these complex data types will affect
    all occurrences because they are all essentially just pointers to the same block
    of memory.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，不可变性的概念通常适用于传入函数的变量，以及函数返回的变量。在JavaScript中，简单类型（字符串、数字、布尔值）是按值传递的，而复杂类型（对象、数组等）是按引用传递的。对这些复杂数据类型的任何更改都会影响所有出现的地方，因为它们本质上只是指向同一块内存的指针。
- en: 'JavaScript support for immutability is not very complete. JavaScript does not
    have built-in immutable arrays or objects. It is important to note that the variable
    creation keyword, `const`, will not create an immutable object or array. As discussed
    in the very first chapter, const simply locks the name binding so that the name
    binding cannot be reassigned. It does not prevent the object referenced by the
    variable from being modified. Immutable objects in JavaScript can be created in
    two ways: with the `freeze` function and with third-party libraries.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对不可变性的支持并不完整。JavaScript没有内置的不可变数组或对象。需要注意的是，变量创建关键字`const`不会创建不可变对象或数组。正如在第一章中讨论的那样，const只是锁定名称绑定，使得名称绑定不能被重新分配。它不会阻止被变量引用的对象被修改。在JavaScript中，可以通过两种方式创建不可变对象：使用`freeze`函数和使用第三方库。
- en: 'Immutable objects can be created with the freeze function. `freeze` is a function
    on the global `Object prototype ( Object.freeze()` ). It takes in a single argument,
    the object to be frozen, and returns that same object. Freeze prevents anything
    from being added to, removed from, or modified in the object. If an array is frozen,
    it will lock the element values and prevent elements from being added to or removed
    from the array. It is important to note that the freeze function is only a shallow
    freeze. Objects and arrays nested as properties (in objects) or elements (in arrays)
    will not be frozen by the `freeze` function. If you want to fully freeze all nested
    properties, you must write a helper function that traverses the object or array
    tree, freezing each nested level, or find a third-party library. The use of `Object.freeze()`
    is shown in the following snippet:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象可以使用freeze函数创建。`freeze`是全局`Object prototype ( Object.freeze()` )上的一个函数。它接受一个参数，即要冻结的对象，并返回相同的对象。freeze防止向对象中添加、删除或修改任何内容。如果一个数组被冻结，它将锁定元素的值，并防止向数组中添加或删除元素。需要注意的是，freeze函数只是浅冻结。作为属性（在对象中）或元素（在数组中）嵌套的对象和数组不会被`freeze`函数冻结。如果要完全冻结所有嵌套属性，必须编写一个辅助函数来遍历对象或数组树，冻结每个嵌套级别，或者找到一个第三方库。`Object.freeze()`的使用如下所示：
- en: '[PRE9]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Snippet 5.8: Freezing an object'
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段5.8：冻结一个对象
- en: Immutability in JavaScript
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript中的不可变性
- en: Several third-party libraries exist to add immutable functionality to JavaScript.
    There are two libraries that are generally accepted as the best immutability libraries
    in JavaScript. They are **Mori** and **Immutable**. Mori is a library that brings
    ClojurScript's persistent data structures and immutability to JavaScript. **Immutable**
    is Facebook's implementation of an immutability library with a JS API that brings
    many immutable data structures to JavaScript. Both libraries are considered to
    be very efficient and are commonly used in many large projects.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 存在几个第三方库可以为JavaScript添加不可变功能。有两个库通常被认为是JavaScript中最好的不可变性库。它们是**Mori**和**Immutable**。Mori是一个将ClojurScript的持久数据结构和不可变性引入JavaScript的库。**Immutable**是Facebook的不可变性库的实现，具有JS
    API，将许多不可变数据结构引入JavaScript。这两个库被认为非常高效，并且在许多大型项目中通常被使用。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about Mori and Immutable, along with full documentation,
    see the library pages at [https://github.com/swannodette/mori](https://github.com/swannodette/mori)
    and [http://facebook.github.io/immutable-js/](http://facebook.github.io/immutable-js/).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Mori和Immutable的更多信息，以及完整的文档，请参阅[https://github.com/swannodette/mori](https://github.com/swannodette/mori)和[http://facebook.github.io/immutable-js/](http://facebook.github.io/immutable-js/)上的库页面。
- en: There is one final way to obtain immutability in JavaScript; however, it is
    not true immutability. To avoid using third-party libraries or freezing any object
    or array passed to a function, we can simply create a copy of any variable passed
    by reference and modify the copy instead of the original. This will prevent the
    shared state issue of passing data by reference, but it comes with a memory efficiency
    and inefficiency trade-off. Simply assigning the reference to a new variable will
    not duplicate the data. We can duplicate an object or array in one of three ways—with
    a third-party library, by traversing the object tree, or by using JSON operations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中有一种最终实现不可变性的方法；然而，这并不是真正的不可变性。为了避免使用第三方库或冻结传递给函数的任何对象或数组，我们可以简单地创建传递引用的任何变量的副本，并修改副本而不是原始值。这将防止通过引用传递数据的共享状态问题，但它会带来内存效率和效率的折衷。简单地将引用分配给一个新变量不会复制数据。我们可以通过三种方式之一复制对象或数组——使用第三方库，通过遍历对象树，或者使用JSON操作。
- en: Third-party libraries exist to create deep copies of objects. This is generally
    the simplest approach to copying objects. We can also traverse the object's tree
    and copy every value and property into a new object. This will generally require
    us to write and test our own function. Finally, we can use the JSON operations
    stringify and parse to duplicate an object. This is done by first stringifying
    an object, then parsing the string (`JSON.parse( JSON.stringify( obj ) )`). JSON
    operations are usually the simplest approach to duplicating objects, but they
    come with the most drawbacks and limitations. If the object has non-JSON-compatible
    properties, such as functions or classes, this approach will not work. It is also
    very inefficient to convert the entire object into a string and then parse that
    entire string into an object. For small objects, this may not affect performance,
    but if you must copy a large object, it is not recommended that you use this method
    because it is a blocking operation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 存在用于创建对象的深层副本的第三方库。这通常是复制对象的最简单方法。我们还可以遍历对象的树，并将每个值和属性复制到一个新对象中。这通常需要我们编写和测试自己的函数。最后，我们可以使用JSON操作stringify和parse来复制一个对象。首先将对象字符串化，然后解析字符串（`JSON.parse（JSON.stringify（obj））`）。JSON操作通常是复制对象的最简单方法，但它带来了最多的缺点和限制。如果对象具有不兼容JSON的属性，例如函数或类，这种方法将无效。将整个对象转换为字符串，然后将整个字符串解析为对象也非常低效。对于小对象，这可能不会影响性能，但如果您必须复制一个大对象，则不建议使用此方法，因为它是一个阻塞操作。
- en: Side Effects
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 副作用
- en: A **side effect** is any secondary effect or reaction that comes from an action
    we take. Side effects can be either good or bad, but are generally unintended.
    In functional programming, side effects are any state change that can be seen
    outside of a function call, with the exception of the function return value. According
    to the rules of functional programming, functions are not allowed to modify any
    states outside of the function. If the function modifies a state, intentionally
    or unintentionally, this is considered a side effect because it breaks the tenets
    of functional programming.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**副作用**是我们采取行动后产生的任何次要效果或反应。副作用可以是好的也可以是坏的，但通常是无意的。在函数式编程中，副作用是指除函数返回值之外可以在函数调用之外看到的任何状态更改。根据函数式编程的规则，函数不允许修改函数之外的任何状态。如果函数有意或无意地修改了状态，这被视为副作用，因为它违反了函数式编程的原则。'
- en: 'Side effects are bad because they make a program more complex. As discussed
    earlier, shared states increase program complexity. Side effects in functions
    modify shared states and therefore increase complexity. Side effects, intentional
    or otherwise, can make code much harder to test and debug. The following list
    shows a simple breakdown of the most common causes of side effects in JavaScript:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用是不好的，因为它使程序变得更加复杂。正如前面讨论的，共享状态会增加程序的复杂性。函数中的副作用会修改共享状态，因此增加了复杂性。无论有意还是无意，副作用都会使代码更难以测试和调试。以下列表显示了JavaScript中副作用最常见的原因的简单分解：
- en: Modifying any external state (variable)
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改任何外部状态（变量）
- en: The two variable types include global variables and variables in the parent
    function scope.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 两种变量类型包括全局变量和父函数作用域中的变量。
- en: The first bullet in this list should be self-explanatory from the definition
    of FP side effects. A change to any external state, including any variable outside
    of the function's scope, is a side effect. It does not matter what level of scope
    the variable has. It can be in the global scope or anywhere up the parent function
    scope tree; any change to a variable not directly scoped in the function is considered
    a side effect.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表中的第一条应该从FP副作用的定义中是不言自明的。对任何外部状态的改变，包括函数范围之外的任何变量，都是副作用。变量的作用域级别并不重要。它可以在全局作用域中，也可以在父函数作用域树中的任何地方；对函数范围之外的变量的任何改变都被视为副作用。
- en: Input/output
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入/输出
- en: The list includes logging to a console, writing to a screen or display, file
    I/O operations, network operations, HTTP requests, message queues, and database
    requests.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表包括记录到控制台，写入屏幕或显示器，文件I/O操作，网络操作，HTTP请求，消息队列和数据库请求。
- en: The second bullet point in the side effect list is not as intuitive. Consider
    I/O operations for a moment. What do they do? They modify some external resource.
    This could be the contents of the console, the view or display shown on a web
    page, a file in the filesystem, or an external resource only accessed over the
    network. These external resources are not directly scoped to the block of code
    that is modifying them, and they can be modified and viewed from other completely
    unrelated applications. By definition, resources such as the filesystem and console
    are shared states. Modifications to these resources count as side effects.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用列表中的第二个要点并不那么直观。考虑一下I/O操作。它们做什么？它们修改一些外部资源。这可以是控制台的内容，网页上显示的视图或显示，文件系统中的文件，或者仅通过网络访问的外部资源。这些外部资源不直接限定于修改它们的代码块，并且可以被其他完全无关的应用程序修改和查看。根据定义，文件系统和控制台等资源是共享状态。对这些资源的修改算作副作用。
- en: Starting or ending external processes
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动或结束外部进程
- en: The third bullet point in the side effect list is similar to the second. Starting
    an external process, such as a helper thread to offload some large, synchronous
    amount of work, creates a side effect. When we start a new process, we are directly
    changing the state of our system. A new thread is created and it is outside of
    the scope of the function that created it. By definition, this is a side effect.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用列表中的第三个要点与第二个类似。启动外部进程，例如辅助线程以卸载一些大量的同步工作，会产生副作用。当我们启动一个新进程时，我们直接改变了系统的状态。创建了一个新线程，它超出了创建它的函数的范围。根据定义，这是一个副作用。
- en: Calling any other function with side effects
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用任何具有副作用的其他函数
- en: The fourth item in the side effect list is also less intuitive. Any function
    that calls a function with a side effect is considered to have a side effect.
    Consider a program setup where function A calls function B, and function B causes
    a change to the global state. This change to the global state can be prompted
    by either a direct call to function B or by calling function A, which eventually
    calls function B and changes the state. Since a call to function A will still
    result in a global state change, even though the code in function A does not directly
    modify the global state, function A is still considered to have a side effect.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用列表中的第四项也不那么直观。调用具有副作用的函数的任何函数都被认为具有副作用。考虑一个程序设置，其中函数A调用函数B，并且函数B导致全局状态的更改。对全局状态的更改可以由对函数B的直接调用或通过调用函数A而引起。由于对函数A的调用仍然会导致全局状态的更改，即使函数A的代码不直接修改全局状态，函数A仍然被认为具有副作用。
- en: 'While writing FP code, we must consider the following questions:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写FP代码时，我们必须考虑以下问题：
- en: If any I/O operation causes a side effect, how can we apply FP principles to
    writing useful code without side effects? Since I/O operations cause side effects,
    won't every network call or file system operation used in our code cause a side
    effect? Yes. Side effects from I/O will be caused and they are unavoidable. The
    solution to this issue is to isolate side-effect code from the rest of the software.
    Any code that has a side effect or relies on modules or operations with side effects
    (database operations and so on) must be isolated from code that does not. This
    is usually done with modules. Most frontend and backend frameworks encourage us
    to separate state management from the rest of our code by using modules. Code
    that causes side effects is removed and put into its own module so that the rest
    of the code base can be tested and maintained without side effects.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何I/O操作引起副作用，我们如何将FP原则应用于编写没有副作用的有用代码？由于I/O操作会引起副作用，那么我们代码中使用的每个网络调用或文件系统操作都会引起副作用吗？是的。
    I/O引起副作用，它们是不可避免的。解决此问题的方法是将具有副作用的代码与软件的其余部分隔离开来。任何具有副作用或依赖具有副作用的模块或操作（数据库操作等）的代码必须与不具有副作用的代码隔离开来。这通常是通过模块完成的。大多数前端和后端框架鼓励我们使用模块将状态管理与代码的其余部分分离。引起副作用的代码被移除并放入自己的模块中，以便代码库的其余部分可以在没有副作用的情况下进行测试和维护。
- en: Avoiding Side Effects
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免副作用
- en: 'It is almost impossible to write a full application without side effects. Web
    applications/servers must handle/make HTTP requests - side effect by definition.
    In order to achieve this, you can do the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎不可能编写一个没有副作用的完整应用程序。Web应用程序/服务器必须处理/发出HTTP请求-根据定义是副作用。为了实现这一点，您可以执行以下操作：
- en: Isolate code with side effects from the rest of the code base.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将具有副作用的代码与代码库的其余部分隔离。
- en: Separate state management code and code with side effects from the rest of application.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将状态管理代码和具有副作用的代码与应用程序的其余部分分开。
- en: These methods make testing and debugging easier.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法使测试和调试更容易。
- en: Function Composition
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数组合
- en: '**Function composition** is the final key to understanding functional programming.
    Function composition takes many of the concepts learned in this chapter and nicely
    wraps them in the core of functional programming. The widely used definition of
    function composition is that function composition is a mathematical concept that
    allows you to combine multiple functions to create a new function. This definition
    tells us what function composition is, but doesn''t really give us any sense of
    how to compose functions or why we need to use it.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数组合**是理解函数式编程的最后关键。函数组合将本章学到的许多概念很好地融入到函数式编程的核心中。函数组合的广泛使用定义是函数组合是一个数学概念，允许您组合多个函数以创建一个新函数。这个定义告诉我们函数组合是什么，但并没有真正告诉我们如何组合函数或者为什么我们需要使用它。'
- en: 'As we know from the definition, function composition is the act of combining
    functions to create a new one. What does this mean exactly? In mathematics, we
    often see functions composed like so: f(g(x)). If this is not familiar to you,
    in the expression f(g(x)), we pass the variable x into the function g and then
    pass the result of g(x) into the function f. The expression f(g(x)) is evaluated
    from the inside out, from right to left, in the order x, g, f. Every instance
    where the input parameter is used in function g, we can substitute in the value
    of x. Every instance where the input parameter is used in function f, we can substitute
    in the value of g(x). Now, let''s consider this method of function composition
    with code. Consider the code in the following snippet :'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，函数组合是将函数组合在一起创建新函数的行为。这到底意味着什么？在数学中，我们经常看到像这样组合的函数：f(g(x))。如果这对你来说不熟悉，在表达式f(g(x))中，我们将变量x传递给函数g，然后将g(x)的结果传递给函数f。表达式f(g(x))从内到外，从右到左，按顺序x，g，f进行评估。在函数g中使用输入参数的每个实例，我们可以替换为x的值。在函数f中使用输入参数的每个实例，我们可以替换为g(x)的值。现在，让我们用代码考虑这种函数组合的方法。考虑以下代码片段：
- en: '[PRE10]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Snippet 5.10: Function composition'
  id: totrans-201
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 代码段5.10：函数组合
- en: In the preceding snippet, we create a function to multiply a value by 2 and
    a function to add two numbers. We can use these functions to calculate a value
    in two ways. First, we use these functions independently, one at a time. This
    requires us to create a variable and save the output of the first function, call
    the second function with that value, and then save the result of the second function
    into a variable. This requires two lines of code and two variables. Our second
    option for calculating a value is by using function composition. We simply need
    to call one function inside the input argument of the second function and save
    the resultant variable. This requires one line of code and one variable. As we
    can see from the code in the snippet, using function composition will help simplify
    our code and reduce the number of lines of code we need to write.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们创建了一个将值乘以2的函数和一个将两个数字相加的函数。我们可以使用这些函数以两种方式计算一个值。首先，我们独立使用这些函数，依次使用。这需要我们创建一个变量并保存第一个函数的输出，使用该值调用第二个函数，然后将第二个函数的结果保存到一个变量中。这需要两行代码和两个变量。我们计算值的第二个选项是使用函数组合。我们只需要在第二个函数的输入参数中调用一个函数，并保存结果变量。这只需要一行代码和一个变量。从代码片段中可以看出，使用函数组合将有助于简化我们的代码，并减少我们需要编写的代码行数。
- en: Function composition is very useful for reducing the number of lines of code
    we need to write, as well as reducing the complexity of our code. When writing
    code in the Functional Programming paradigm, it is important to recognize instances
    when we can use function composition to our advantage.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合非常有用，可以减少我们需要编写的代码行数，同时减少代码的复杂性。在函数式编程范式中编写代码时，重要的是要认识到我们可以利用函数组合的优势的情况。
- en: 'Activity 5: Recursive Immutability'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动5：递归不可变性
- en: You are building an application in JavaScript and your team has been told it
    cannot use any third-party libraries for security reasons. You must now use FP
    principles for this application and need an algorithm to create immutable objects
    and arrays. Create a recursive function that enforces the immutability of objects
    and arrays at all levels of nesting with `Object.freeze()`. For simplicity, you
    can assume there are no null value or classes nested in the objects. Write your
    function in `'Lesson 5/topic f - immutability/activity-test.js'`. This file contains
    code to test your implementation.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在使用JavaScript构建应用程序，并且已被告知出于安全原因不能使用任何第三方库。现在，您必须为此应用程序使用FP原则，并且需要一种算法来创建不可变的对象和数组。创建一个递归函数，使用`Object.freeze()`来强制对象和数组在所有嵌套级别上的不可变性。为简单起见，您可以假设对象中没有嵌套的空值或类。在`'Lesson
    5/topic f - immutability/activity-test.js'`中编写您的函数。此文件包含测试您实现的代码。
- en: 'To force immutability in objects, perform the following steps:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制对象的不可变性，请执行以下步骤：
- en: Create a function called `immutable` that takes in a single argument, `data`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`immutable`的函数，它接受一个参数`data`。
- en: Freeze the `data` object.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 冻结`data`对象。
- en: Loop through object values and recursively call the immutable function for each.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历对象值，并对每个值递归调用不可变函数。
- en: '**Code**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: '**Outcome**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**'
- en: '![Figure 5.6: Returning the new cart array](image/Figure_5.6.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图5.6：返回新的购物车数组](image/Figure_5.6.jpg)'
- en: 'Figure 5.6: Returning the new cart array'
  id: totrans-213
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.6：返回新的购物车数组
- en: You have successfully demonstrated forcing immutability in objects.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功演示了强制对象的不可变性。
- en: Note
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 291.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第291页找到。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '**Functional Programming** is a programming paradigm that focuses on expressions
    and declarations to design an application and build a code base. Functional Programming
    is one of the hot new programming styles and is considered the best style for
    programming in JavaScript. Functional Programming can help our JavaScript be more
    concise, predictable, and testable. Functional Programming is built on seven key
    concepts: declarative functions, pure functions, higher order functions, shared
    state, immutability, side effects, and function composition.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数式编程**是一种侧重于表达式和声明来设计应用程序和构建代码库的编程范式。函数式编程是炙手可热的新编程风格之一，被认为是JavaScript编程的最佳风格。函数式编程可以帮助我们的JavaScript更加简洁，可预测和可测试。函数式编程建立在七个关键概念上：声明式函数，纯函数，高阶函数，共享状态，不可变性，副作用和函数组合。'
- en: '**Declarative functions** focus on what the solution or goal is, instead of
    how we get the solution. Declarative functions are designed to abstract away a
    lot of the imperative approach to code. They help developers code more in keeping
    with the mental model of the developer, instead of the operational model of the
    machine running the code.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**声明性函数**关注的是解决方案或目标，而不是我们如何得到解决方案。声明性函数旨在抽象掉大量的命令式代码。它们帮助开发人员更符合开发者的思维模型，而不是运行代码的机器的操作模型。'
- en: '**Pure functions** are intended to make our code easier to test, easier to
    debug, and more flexible and reusable. All functions we write in JavaScript should
    strive to be pure. Pure functions must always return the same output value when
    given the same input values. They cannot cause any side effects by modifying external
    states and must have referential transparency.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**纯函数**旨在使我们的代码更易于测试、更易于调试，并且更灵活和可重用。我们在JavaScript中编写的所有函数都应该努力成为纯函数。纯函数在给定相同的输入值时必须始终返回相同的输出值。它们不能通过修改外部状态来引起任何副作用，并且必须具有引用透明性。'
- en: '**Higher order functions** are one of the most common types of functions used
    in JavaScript asynchronous programming. A higher order function is any function
    that takes a function as an input and returns a function as an output. Higher
    order functions are very useful for abstraction of code, complexity reduction,
    and utility function creation and management. They are the key to closures, which
    allow us to be very flexible with our code.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**高阶函数**是JavaScript异步编程中最常用的函数类型之一。高阶函数是任何以函数作为输入并返回函数作为输出的函数。高阶函数非常有用，可以用于抽象代码、减少复杂性以及创建和管理实用函数。它们是闭包的关键，允许我们对代码非常灵活。'
- en: '**Shared states** are one of the most important things to avoid in Functional
    Programming. A shared state is any non-constant variable or non-immutable object
    or memory space that exists in a shared scope. The shared scope could be a global
    scope or any scope up the parent function scope tree. Shared states prevent functions
    from being pure and can result in more bugs, inadequate testing, and slower development.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**共享状态**是函数式编程中要避免的最重要的事情之一。共享状态是存在于共享作用域中的任何非常量变量或非不可变对象或内存空间。共享作用域可以是全局作用域或父函数作用域树中的任何作用域。共享状态会阻止函数成为纯函数，并可能导致更多的错误、不充分的测试和开发速度变慢。'
- en: '**Immutability** is the lack of ability to change something. In JavaScript,
    all variables that are passed by reference should be made immutable. Changes to
    mutable variables passed by reference can cause side effects and unintentionally
    modify states that are not supposed to be shared. Immutability in JavaScript can
    be obtained with the `Object.freeze()` function, third-party libraries, and JSON
    operations.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 不变性是无法改变某物的能力。在JavaScript中，所有按引用传递的变量都应该是不可变的。对可变变量的更改可能会导致副作用，并无意中修改不应共享的状态。在JavaScript中，可以通过`Object.freeze()`函数、第三方库和JSON操作来实现不可变性。
- en: '**Side effects** in JavaScript are any state change that can be seen from outside
    of a function call, excluding the function''s return value. A side effect can
    be caused by any modification to a shared state variable, any I/O operation, any
    external process execution, or by calling any function with a side effect. It
    can be very difficult to fully eliminate side effects from JavaScript applications.
    To minimize the effect of side effects, we must isolate any code with a side effect
    from the rest of the code base. Code that causes side effects should be moved
    into modules for isolation purposes.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，**副作用**是指可以从函数调用外部看到的任何状态更改，不包括函数的返回值。副作用可以由对共享状态变量的任何修改、任何I/O操作、任何外部进程执行或调用具有副作用的任何函数引起。要完全消除JavaScript应用程序中的副作用可能非常困难。为了最小化副作用的影响，我们必须将具有副作用的代码与代码库的其余部分隔离开来。引起副作用的代码应该移入模块以进行隔离。
- en: '**Function composition** is the final key concept of Functional Programming.
    We can create complicated and powerful functions simply by combining simpler functions
    in new ways. Function composition is designed to help abstract and reduce the
    complexity of our code.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数组合**是函数式编程的最后一个关键概念。我们可以通过以新的方式组合更简单的函数来简单地创建复杂而强大的函数。函数组合旨在帮助抽象和减少我们代码的复杂性。'
- en: In the next chapter, you will be introduced to the basic concepts of server-side
    JavaScript and build a Node.js and Express server.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将介绍服务器端JavaScript的基本概念，并构建一个Node.js和Express服务器。
