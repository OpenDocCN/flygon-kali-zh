- en: '*Chapter 16*: C# in Action with .NET Core 3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第16章*：使用.NET Core 3中的C#'
- en: The C# programming language is the medium that we use to turn ideas into runnable
    code. At compile time, the whole set of rules, grammar, constraints, and semantics
    get transformed into the **Intermediate Language**—a high-level assembly language
    used to instruct the **Common Language Runtime (CLR)**, which in turn provides
    the necessary services to run the code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C#编程语言是我们用来将想法转化为可运行代码的媒介。在编译时，整套规则、语法、约束和语义都被转换为中间语言——一种用于指导公共语言运行时（CLR）的高级汇编语言，后者提供运行代码所需的必要服务。
- en: In order to execute some code, native languages such as C, C++, and Rust require
    a thin runtime library to interact with the **operating system** (**OS**) and
    execute abstractions such as *program loading*, *constructors*, and *deconstructors*.
    On the other hand, higher-level languages such as C# and Java need a more complex
    runtime engine to provide other fundamental services such as *garbage collection*,
    *just-in-time compilation*, and *exception management*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行一些代码，像C、C++和Rust这样的本地语言需要一个轻量级的运行时库来与操作系统（OS）交互，并执行*程序加载*、*构造函数*和*析构函数*等抽象。另一方面，像C#和Java这样的高级语言需要一个更复杂的运行时引擎来提供其他基本服务，如*垃圾回收*、*即时编译*和*异常管理*。
- en: When .NET Framework was first created, the CLR was designed to run exclusively
    on Windows, but later, many other runtimes (implementing the same ECMA specifications)
    emerged, playing an important role in the market. For example, the Mono runtime
    was the first community-driven project to run on the Linux platform, and the Microsoft
    Silverlight project had brief success running inside the browsers of all the major
    platforms. Other runtimes, such as .NET Micro Framework for running on microcontrollers,
    .NET Compact Framework for targeting the embedded Windows CE OS, and other more
    recent flavors of the runtime running on Windows Phone and the Universal Windows
    Platform are good examples of the variety of the .NET implementations that have
    the ability to run the same set of instructions we still use today.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当.NET Framework首次创建时，CLR被设计为仅在Windows上运行，但后来，许多其他运行时（实现相同的ECMA规范）出现，对市场起着重要作用。例如，Mono运行时是第一个在Linux平台上运行的社区驱动项目，而微软的Silverlight项目在所有主要平台的浏览器中都取得了短暂的成功。其他运行时，如用于微控制器的.NET
    Micro Framework，用于针对嵌入式Windows CE操作系统的.NET Compact Framework，以及在Windows Phone和通用Windows平台上运行的更近期的运行时的例子，都展示了.NET实现的多样性，这些实现能够运行我们今天仍在使用的相同一组指令。
- en: Each of those runtimes was built upon a number of requirements dictated by the
    historical context of the time, with no exceptions. At its birth, about 20 years
    ago, .NET Framework was designed to satisfy the growing Windows-based personal
    computer ecosystem, whose power grew over time in terms of CPU power, memory,
    and storage. Over the years, most of those runtimes successfully shifted toward
    more constrained hardware specifications, still offering roughly the same set
    of features. For example, even if modern mobile phones have very powerful microprocessors,
    code efficiency is still vital to preserve the battery life of those devices,
    a requirement that was not relevant when .NET Framework was initially designed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运行时都是根据当时的历史背景所规定的一系列要求构建的，没有例外。在大约20年前诞生时，.NET Framework旨在满足不断增长的基于Windows的个人电脑生态系统，其CPU功率、内存和存储空间随着时间的推移而增长。多年来，大多数这些运行时成功地转向了更受限制的硬件规格，仍然提供大致相同的功能集。例如，即使现代手机具有非常强大的微处理器，代码效率对于保护这些设备的电池寿命仍然至关重要，这是.NET
    Framework最初设计时不相关的要求。
- en: Although the .NET specifications used by those runtimes are still the same,
    there are differences that make every developer's life hard when trying to design
    an application that is able to run on multiple runtimes, especially when a requirement
    is for it to be able to run cross-platform and/or cross-device.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些运行时使用的.NET规范仍然相同，但存在差异，使得每个开发人员在尝试设计能够在多个运行时上运行的应用程序时变得困难，特别是当要求它能够跨平台和/或跨设备运行时。
- en: 'The .NET Core 3 runtime was born to resolve those issues, by offering a new
    runtime that satisfies all the modern requirements. In this chapter, we are going
    to examine the factors related to the runtime when developing a C# application:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 3运行时诞生于解决这些问题，通过提供满足所有现代要求的新运行时。在本章中，我们将研究开发C#应用程序时与运行时相关的因素：
- en: Using the .NET **command-line interface (CLI)**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用.NET命令行界面（CLI）
- en: Developing on Linux distributions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux发行版上开发
- en: What .NET Standard is and how can it help the application design
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET标准是什么以及它如何帮助应用程序设计
- en: Consuming NuGet packages
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费NuGet包
- en: Migrating an application designed with .NET Framework
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移使用.NET Framework设计的应用程序
- en: Publishing an application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布应用程序
- en: By the end of this chapter, you will be more familiar with the .NET Core tools
    that allow you to compile and publish your application so that you can design
    a library to share the code with other applications running on .NET Core or other
    runtime flavors. Also, where you already have an application based on .NET Framework,
    you will learn the main steps to migrate it to fully leverage the .NET Core runtime.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将更熟悉允许您编译和发布应用程序的.NET Core工具，以便您可以设计一个库，与在.NET Core或其他运行时版本上运行的其他应用程序共享代码。此外，如果您已经有一个基于.NET
    Framework的应用程序，您将学习迁移它以充分利用.NET Core运行时的主要步骤。
- en: Using the .NET command-line interface (CLI)
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用.NET命令行界面（CLI）
- en: The **command-line interface** (**CLI**) is a new but strategic tool in the
    .NET ecosystem, enabling a modern developmental approach that can be used the
    same way across all platforms. At first sight, defining a tool based on the old
    console as "modern" might look strange, but in the world of modern development,
    the ability to script the build process to embrace the **Continuous Integration**
    and **Continuous Delivery**/**Deployment** (**CI**/**CD**) strategy is fundamental
    to provide faster and higher quality development life cycles.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令行界面**（**CLI**）是.NET生态系统中的一个新但战略性的工具，它可以在所有平台上以相同的方式使用，实现现代的开发方法。乍一看，基于旧控制台的工具定义为“现代”可能看起来很奇怪，但在现代开发世界中，脚本化构建过程以支持**持续集成**和**持续交付**/**部署**（**CI**/**CD**）策略对于提供更快和更高质量的开发生命周期至关重要。'
- en: After installing the .NET Core SDK (see [https://dotnet.microsoft.com/](https://dotnet.microsoft.com/)),
    the .NET CLI is available through the Linux Terminal or Windows Command Prompt.
    A good alternative on Windows is the new **Windows Terminal** application, which
    can be downloaded through the Windows Store and provides a great replacement for
    the traditional Command Prompt, as well as the **PowerShell** terminal.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 安装.NET Core SDK（参见[https://dotnet.microsoft.com/](https://dotnet.microsoft.com/)）后，可以通过Linux终端或Windows命令提示符使用.NET
    CLI。在Windows上的一个很好的替代品是新的**Windows终端**应用程序，可以通过Windows商店下载，并提供了传统命令提示符以及**PowerShell**终端的很好替代。
- en: 'The .NET CLI has a rich list of commands, enabling a complete set of operations
    for the entire development life cycle. Detailed and contextual help for every
    command is obtained by adding the `––help` string as the last argument. The most
    relevant commands are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: .NET CLI具有丰富的命令列表，可以完成整个开发生命周期的一整套操作。通过将`––help`字符串添加为最后一个参数，可以获得每个命令的详细和上下文帮助。最相关的命令如下：
- en: '`dotnet new`: The `new` command creates a folder for a new application project
    or solution, based on a long list of predefined templates that can be easily installed
    in addition to the default ones. Typing this command alone will just list all
    the available templates.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet new`：`new`命令基于预定义的模板创建一个新的应用程序项目或解决方案的文件夹，这些模板可以很容易地安装在默认模板之外。仅输入此命令将列出所有可用的模板。'
- en: '`dotnet restore`: The `restore` command restores the referenced libraries from
    the NuGet server (outside the default `nuget.org` internet packages repository,
    the user can create a `nuget.config` file to specify other locations such as GitHub,
    or even a local folder).'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet restore`：`restore`命令从NuGet服务器还原引用的库（在默认的`nuget.org`互联网软件包存储库之外，用户可以创建一个`nuget.config`文件来指定其他位置，如GitHub，甚至是本地文件夹）。'
- en: '`dotnet run`: The `run` command builds, restores, and runs the project in a
    single shot.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet run`：`run`命令在一个步骤中构建，还原和运行项目。'
- en: '`dotnet test`: The `test` command runs the test for the specified project.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet test`：`test`命令运行指定项目的测试。'
- en: '`dotnet publish`: The `publish` command creates the deployable binaries, as
    we will discuss in the *Publishing an application* section.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet publish`：`publish`命令创建可部署的二进制文件，我们将在*发布应用程序*部分讨论。'
- en: In addition to these commands, the .NET CLI can be used to invoke other tools.
    Some of them are preinstalled. For example, `dotnet dev-certs` is a tool that's
    used to manage the HTTPS certificates on the local machine. Another example of
    the preinstalled tools on offer is `dotnet watch`, which observes the changes
    made to the source files in a project and automatically reruns the application
    every time any change occurs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些命令之外，.NET CLI还可以用于调用其他工具。其中一些是预安装的。例如，`dotnet dev-certs`是一个用于管理本地机器上的HTTPS证书的工具。提供的预安装工具的另一个例子是`dotnet
    watch`，它观察项目中对源文件所做的更改，并在发生任何更改时自动重新运行应用程序。
- en: The `dotnet tool` command is the gateway to extend the CLI capability because
    it allows us to download and install additional tools through the configured NuGet
    servers. At the time of writing, there is still no way to filter the packages
    containing .NET tools on [https://nuget.org](https://nuget.org); therefore, your
    best option is reading the suggestions from articles or other users.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotnet tool`命令是扩展CLI功能的入口，因为它允许我们通过配置的NuGet服务器下载和安装附加工具。在撰写本文时，尚无法在[https://nuget.org](https://nuget.org)上过滤包含.NET工具的软件包；因此，您最好的选择是阅读文章或其他用户的建议。'
- en: 'When creating a new project (using the CLI), you may want to decide the runtime
    version first. The `dotnet ––info` command returns a list of all the installed
    runtimes and SDKs. By default, the CLI uses the more recently installed `global.json`.
    The settings in this file will affect all the operations done by the .NET CLI
    (which is also used by Visual Studio) for all the folders under the one containing
    the file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新项目（使用CLI）时，您可能希望首先决定运行时版本。`dotnet ––info`命令返回所有已安装的运行时和SDK的列表。默认情况下，CLI使用最近安装的`global.json`。此文件中的设置将影响包含该文件的文件夹下的所有操作所使用的.NET
    CLI（也被Visual Studio使用）：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, you can edit the file with your favorite editor and change the SDK version
    to one of the values listed previously:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用您喜欢的编辑器编辑文件，并将SDK版本更改为先前列出的值之一：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Be careful to choose the `info` parameter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 小心选择`info`参数。
- en: 'This process is useful to keep an application tied to a specific SDK instead
    of automatically inheriting the latest one installed. That being said, it is now
    time to create a new empty solution, which is a codeless container for one or
    more projects. Creating a solution is optional, but is very useful when you need
    to create multiple cross-referenced projects:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程对于将应用程序绑定到特定的SDK而不是自动继承最新安装的SDK是有用的。话虽如此，现在是时候创建一个新的空解决方案了，这是一个一个或多个项目的无代码容器。创建解决方案是可选的，但在需要创建多个交叉引用的项目时非常有用：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It''s now time to create a new console project under the solution folder. The
    solution name can be omitted from the `sln add` command since there is only one
    solution in the folder:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是在解决方案文件夹下创建一个新的控制台项目的时候了。由于文件夹中只有一个解决方案，因此可以在`sln add`命令中省略解决方案名称：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we can build and run the project:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以构建和运行项目：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, we can use the `watch` command to rerun the project every time
    any file is changed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`watch`命令在任何文件更改时重新运行项目：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As soon as the first `Waiting for a file to change before restarting dotnet...`
    message was printed on the console, I modified and saved the `Program.cs` file
    using the Visual Studio Code editor. The changes on that file triggered the build
    process automatically, and the binary files were created as usual in the `bin`
    folder, whose tree structure has been slightly changed from .NET Framework.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当控制台上打印出第一个`等待文件更改后重新启动dotnet...`消息时，我使用Visual Studio Code编辑器修改并保存了`Program.cs`文件。该文件的更改自动触发了构建过程，并且二进制文件像往常一样在`bin`文件夹中创建，其树结构已经从.NET
    Framework中略有改变。
- en: 'There is still the `Debug` or `Release` folder, which in turn contains a new
    subfolder with the name of the framework; in this case, `netcoreapp3.0`. The new
    project system is multi-target capable and can generate different binaries depending
    on the framework, runtime, and bitness specified in the project file. The contents
    of that folder are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有`Debug`或`Release`文件夹，其中包含一个名为框架的新子文件夹；在这种情况下，是`netcoreapp3.0`。新的项目系统支持多目标，并且可以根据项目文件中指定的框架、运行时和位数生成不同的二进制文件。该文件夹的内容如下：
- en: '`Hello.dll`. This is the assembly containing the `IL` code that was generated
    by the compiler.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hello.dll`。这是包含编译器生成的`IL`代码的程序集。'
- en: '`Hello.exe`: The `.exe` file is a host application that bootstraps your application.
    Later, we will talk about publishing/deploying an application with more options.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hello.exe`：`.exe`文件是一个托管应用程序，用于引导您的应用程序。稍后，我们将讨论使用更多选项发布/部署应用程序。'
- en: '`Hello.pdb`: The `.pdb` file contains the symbols that allow the debugger to
    cross-reference the `IL` code to the source files, and the symbol (that is, variable,
    method, or class) names to the actual code.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hello.pdb`：`.pdb`文件包含允许调试器将`IL`代码与源文件进行交叉引用的符号，以及符号（即变量、方法或类）名称与实际代码进行交叉引用。'
- en: '`Hello.deps.json`: This file contains the full dependency tree in JSON format.
    It is used to retrieve the libraries needed during compilation and it is a very
    effective way to discover undesired dependencies or problems when mixing different
    versions of the same assembly.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hello.deps.json`：此文件以JSON格式包含完整的依赖树。它用于在编译期间检索所需的库，并且是发现不需要的依赖项或在混合不同版本的相同程序集时出现问题的非常有效的方法。'
- en: '`Hello.runtimeconfig.json` and `Hello.runtimeconfig.dev.json`: These are used
    by the runtime to know which shared runtime should be used to run the application.
    The `.dev` file contains configurations that are used in addition to the base
    file when the environment specifies that the application should be run in a development
    environment.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hello.runtimeconfig.json`和`Hello.runtimeconfig.dev.json`：这些文件由运行时使用，以了解应该使用哪个共享运行时来运行应用程序。`.dev`文件包含在环境指定应用程序应在开发环境中运行时使用的配置。'
- en: We just created a very basic application, but those steps are all that is required
    to create a complex application made of several libraries and using other, more
    complex templates. An interesting fact is that the same steps can be executed
    on the *Linux Terminal* to obtain the same results.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个非常基本的应用程序，但这些步骤就是创建一个由几个库组成并使用其他更复杂模板的复杂应用程序所需的全部步骤。有趣的是，可以在*Linux终端*上执行相同的步骤以获得相同的结果。
- en: Developing on Linux distributions
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux发行版上开发
- en: The requirements revolution felt by developers did not stop with the mobile
    market and is still ongoing today. For example, the need to run across multiple
    OSes is more important than ever since the cloud era began. Many applications
    started moving from on-premises to cloud architectures, from virtual machines
    to containers, and from service-oriented architectures to microservices. This
    shift is so big that even the Microsoft CEO proudly celebrated the prevalence
    of Linux OSes on Azure, which is a clear sign of the importance of being able
    to create cross-platform applications.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员所感受到的需求革命并没有随着移动市场而停止，今天仍在持续进行。例如，跨多个操作系统运行的需求比以往任何时候都更为重要，因为云时代开始了。许多应用程序开始从本地部署转移到云架构，从虚拟机转移到容器，从面向服务的架构转移到微服务。这种转变如此之大，以至于即使微软的CEO也自豪地庆祝了Azure上Linux操作系统的普及，这清楚地表明了创建跨平台应用程序的重要性。
- en: There is no doubt that the ability of .NET Core to run on different OSes, devices,
    and CPU architectures is vital, but it comes with an awesome level of abstraction
    that minimizes the efforts of the developers, hiding most of the differences.
    For example, the Linux panorama offers a multitude of distributions, but you don't
    need to worry, as the abstraction doesn't affect the application's performance.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，.NET Core在不同的操作系统、设备和CPU架构上运行的能力至关重要，但它带来了令人惊叹的抽象水平，最大程度地减少了开发人员的工作量，隐藏了大部分差异。例如，Linux景观提供了多种发行版，但你不需要担心，因为抽象不会影响应用程序的性能。
- en: The lesson learned from the IT industry is that the technologies currently driving
    the growth of the cloud are not the final destination, but just a transition.
    At the time of writing, a technology called **Web Assembly System Interface (WASI)**
    is being standardized as a powerful abstraction to sandbox small units of code,
    providing a security isolation that can be used to run not only web applications
    (already available in every browser through **WebAssembly**) but also cloud or
    even classic standalone applications.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: IT行业学到的教训是，当前推动云增长的技术并不是最终目的地，而只是一个过渡。在撰写本文时，一种名为**Web Assembly System Interface
    (WASI)**的技术正在标准化，作为一个强大的抽象，用于隔离小的代码单元，提供安全隔离，可以用于运行不仅是Web应用程序（已经通过**WebAssembly**在每个浏览器中可用），而且还可以运行云或经典的独立应用程序。
- en: We still don't know if WASI will be successful, but there is no doubt that a
    modern runtime must be ready to ride the wave, and this implies embracing the
    agility to rapidly evolve and mutate as soon as new requirements knock at the
    door.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然不知道WASI是否会成功，但毫无疑问，现代运行时必须准备好迎接这一浪潮，这意味着要拥抱快速发展和变异的灵活性，一旦新的需求敲门。
- en: Preparing the development box
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开发环境
- en: There are multiple options when it comes to creating a development environment
    on Linux. The first is to install Linux on the physical machine itself, which
    gives benefits in terms of performance throughout the whole development life cycle.
    The choice of the primary OS is very subjective and, while Windows and macOS currently
    offer a better desktop experience, the choice mostly depends on the application
    ecosystem that you need.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Linux上的开发环境时，有多种选择。第一种是在物理机器上安装Linux，这在整个开发生命周期中都具有性能优势。主要操作系统的选择非常主观，虽然Windows和macOS目前提供更好的桌面体验，但选择主要取决于您需要的应用程序生态系统。
- en: Another well-tested scenario is developing inside a virtual machine. In this
    case, you can use *Windows Hyper-V* or *Parallels Desktop* on Mac. If you don't
    have a distribution of choice, I strongly suggest you start installing Ubuntu
    desktop.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个经过充分测试的方案是在虚拟机内进行开发。在这种情况下，您可以在Mac上使用*Windows Hyper-V*或*Parallels Desktop*。如果您没有选择的发行版，我强烈建议您开始安装Ubuntu桌面版。
- en: "On Windows, you will find it very useful to use the integrated Linux support\
    \ called **Windows Subsystem for Linux (WSL)**, which can be installed as an additional\
    \ Windows 10 component. The current mature release, at the time of writing, is\
    \ **WSL 1**, which runs \La Linux distribution over the Windows kernel. In this\
    \ solution, the Linux system calls are automatically remapped to the Windows kernel\
    \ mode implementations."
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，您会发现使用名为**Windows子系统Linux（WSL）**的集成Linux支持非常有用，它可以作为Windows 10的附加组件进行安装。在撰写本文时，当前成熟的版本是**WSL
    1**，它在Windows内核上运行Linux发行版。在这个解决方案中，Linux系统调用会自动重新映射到Windows内核模式的实现。
- en: While the distribution installed in this configuration is a fully genuine Linux
    distribution, some of its system calls cannot be translated and others, such as
    filesystem operations, are slower because their translation is not trivial. With
    **WSL 1**, most of the .NET Core code will run flawlessly; therefore, it is a
    good option for quickly switching between the Windows desktop and a true Linux
    environment.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种配置中安装的发行版是一个真正的Linux发行版，其中一些系统调用无法被翻译，而其他一些，如文件系统操作，由于它们的翻译不是微不足道的，因此速度较慢。使用**WSL
    1**，大多数.NET Core代码将无缝运行；因此，它是快速在Windows桌面和真正的Linux环境之间切换的好选择。
- en: The future of WSL is already available in the latest Windows preview and will
    soon be released in full. In this configuration, the full Linux kernel is installed
    on Windows and coexists with the Windows kernel, removing any of the previous
    limitations and providing near-native speed. As soon as it becomes fully available,
    I strongly recommend this development environment.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: WSL的未来已经在最新的Windows预览版中可用，并将很快完全发布。在这种配置中，完整的Linux内核安装在Windows上，并与Windows内核共存，消除了以前的任何限制，并提供接近本机速度。一旦它完全可用，我强烈推荐这个开发环境。
- en: 'Once you prepare the Linux machine, you have three options:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好Linux机器后，您有三个选择：
- en: Install the .NET Core **SDK** because you want to manage the developer life
    cycle from within Linux.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装.NET Core **SDK**，因为您希望从Linux内部管理开发人员生命周期。
- en: Install the .NET Core runtime because you just want to run the application and/or
    its tests on Linux to verify the cross-platform development is working as expected.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装.NET Core运行时，因为您只想在Linux上运行应用程序和/或其测试，以验证跨平台开发是否按预期工作。
- en: Don't install either of the two, because you want to test the application as
    a self-contained deployment. We will investigate this option later in the *Publishing
    an application* section.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要安装这两者中的任何一个，因为您希望将应用程序作为独立部署进行测试。我们将在*发布应用程序*部分稍后调查这个选项。
- en: 'The prerequisites and packages needed for the SDK or the runtimes are continuously
    subject to change; therefore, it is better to refer to the official download page
    at [https://dot.net](https://dot.net). Once installed, the `dotnet ––info` from
    a Terminal and show the following information:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: SDK或运行时所需的先决条件和软件包不断变化；因此，最好参考官方下载页面[https://dot.net](https://dot.net)。安装后，从终端运行`dotnet
    ––info`，将显示以下信息：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you decided to use the virtual machine or WSL, you should now install the
    **SSH daemon** so that you can communicate from the host machine to Linux. You
    should refer to the Linux distribution-specific instructions, but generally, the
    **openssh** package is the most popular choice:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定使用虚拟机或WSL，现在应该安装**SSH守护程序**，以便您可以从主机机器与Linux通信。您应该参考特定于Linux发行版的说明，但通常来说，**openssh**软件包是最受欢迎的选择：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, the Linux machine can be contacted either via the hostname (if it is automatically
    registered to your DNS) or the IP address. You can obtain these two pieces of
    information by typing the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Linux机器可以通过主机名（如果它已自动注册到您的DNS）或IP地址进行联系。您可以通过输入以下内容获取这两个信息：
- en: '`ip address`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ip address`'
- en: '`hostname`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hostname`'
- en: 'There is a variety of free `ssh` command-line tool in Windows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中有各种免费的`ssh`命令行工具：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If it doesn''t work because of a configuration problem, the typical troubleshooting
    path is to restore the default permissions on the configuration file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于配置问题而无法工作，则典型的故障排除路径是恢复配置文件的默认权限：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are, of course, many optional tools for Linux, but it is worth mentioning
    a few of them here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Linux有许多可选工具，但在这里值得一提的是其中一些：
- en: '**Net-tools**: This is a package containing many network-related tools to diagnose
    the network protocols such as *arp*, *hostname*, *netstat*, and *route*. Some
    distributions already include them; otherwise, you can install by using your favorite
    package manager, such as **apt-get** on Ubuntu.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Net-tools**：这是一个包含许多与网络相关的工具的软件包，用于诊断网络协议，如*arp*、*hostname*、*netstat*和*route*。一些发行版已经包含它们；否则，您可以使用您喜欢的软件包管理器进行安装，例如Ubuntu上的**apt-get**。'
- en: '**LLDB**: This is a Linux-native debugger. Microsoft provides the SOS extension
    for LLDB containing the same set of commands as the more popular SOS for WinDbg.
    This extension provides a lot of .NET-specific commands to diagnose leaks, walk
    the objects graph, investigate exceptions, and they can also be used on crash
    dumps.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LLDB**：这是一个Linux本地调试器。微软提供了LLDB的SOS扩展，其中包含与更受欢迎的WinDbg的SOS相同的一组命令。此扩展提供了许多.NET特定的命令，用于诊断泄漏，遍历对象图，调查异常，并且它们也可以用于崩溃转储。'
- en: '**Build-essential**: This is a package containing many developer tools, including
    the C/C++ compiler and related libraries to develop native code. This is useful
    if you wish to create native code to be invoked using **PInvoke** calls from .NET.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Build-essential**：这是一个包含许多开发工具的软件包，包括C/C++编译器和相关库，用于开发本地代码。如果您希望创建本地代码，并希望使用**PInvoke**从.NET调用它们，这将非常有用。'
- en: '`ssh` tool under the hood are *Remote – SSH* and *Remote – WSL*. The SSH extension
    allows us to develop on the remote Linux machine via SSH, whereas the WSL one
    allows us to develop on the local WSL subsystem.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底层的`ssh`工具是*Remote - SSH*和*Remote - WSL*。SSH扩展允许我们通过SSH在远程Linux机器上开发，而WSL允许我们在本地WSL子系统上开发。
- en: 'You can just follow the most updated extension''s instructions to configure
    the remote machine (exhaustive documentation can be found at the installation
    link in the *Further reading* section at the end of this chapter). Once installed,
    by hitting *F1*, you can access the Visual Studio Code commands. Then, type `Remote-SSH`,
    click **Add New SSH Host**, and finally repeat and pick **Connect to Host**:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照最新的扩展说明来配置远程机器（详尽的文档可以在本章末尾的*进一步阅读*部分的安装链接中找到）。安装完成后，通过按下*F1*，您可以访问Visual
    Studio Code命令。然后，输入`Remote-SSH`，点击**添加新的SSH主机**，最后重复并选择**连接到主机**：
- en: '![Figure 16.1 – Connecting to a remote host via SSH from Visual Studio Code'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.1 - 通过SSH从Visual Studio Code连接到远程主机'
- en: '](img/Figure_16.1_B12346.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.1_B12346.jpg)'
- en: Figure 16.1 – Connecting to a remote host via SSH from Visual Studio Code
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 - 通过SSH从Visual Studio Code连接到远程主机
- en: This first connection will remotely install the required tools on Linux to enable
    the **Remote Development** scenario, which is where all the compilation and run
    tasks are done remotely, instead of on the machine where you type the code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一次连接将在Linux上远程安装所需的工具，以启用**远程开发**场景，其中所有编译和运行任务都是在远程完成，而不是在您输入代码的机器上完成。
- en: Even if you can just deploy the binaries and run them remotely, this configuration
    is very useful to test code that is demonstrating anomalies when running on Linux.
    In Visual Studio Code, you can open the Terminal window using the **View** | **Terminal**
    menu. The integrated Terminal window can be used to create the solution and projects
    and watch the sources to rerun the application automatically in the same way we
    previously did.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您可以部署二进制文件并远程运行它们，但这种配置对于测试在Linux上运行时显示异常的代码非常有用。在Visual Studio Code中，您可以使用**查看**
    | **终端**菜单打开终端窗口。集成的终端窗口可用于创建解决方案和项目，并观察源代码以在以前相同的方式自动重新运行应用程序。
- en: Writing cross-platform aware code
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写跨平台感知的代码
- en: The abstractions provided by .NET Core let you forget many of the peculiarities
    that exist and work differently from one OS to another, but there are still things
    that must be considered carefully when developing the code. Most of these apparently
    insignificant details should become a best practice of the developer in order
    to avoid problems when running the application on different systems.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core提供的抽象让您忘记了许多存在并在不同操作系统上工作方式不同的特殊性，但在开发代码时仍然有一些必须仔细考虑的事情。这些看似微不足道的细节大多应成为开发人员的最佳实践，以避免在不同系统上运行应用程序时出现问题。
- en: Filesystem casing
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件系统大小写
- en: The most common mistake is not to consider the filesystem casing. On Linux,
    the files and folder names are *case-sensitive*; therefore, it is not unusual
    to discover problems due to a path containing the wrong casing for a file or a
    folder name.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的错误是不考虑文件系统的大小写。在Linux上，文件和文件夹的名称是*区分大小写*的；因此，发现由于路径包含文件或文件夹名称的错误大小写而导致问题并不罕见。
- en: Home directory
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主目录
- en: The structure of the user profiles is different in Windows and Linux, and even
    more importantly, the home directory when running the application with `sudo`
    (admin) privileges is different than the current logged-in user.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows和Linux中，用户配置文件的结构是不同的，而且更重要的是，在使用`sudo`（管理员）权限运行应用程序时，主目录与当前登录用户不同。
- en: Path separators
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路径分隔符
- en: 'We all know that Linux and Windows use the forward slash and the backslash
    characters to separate the files and folders, respectively. This is why the `System.IO.Path`
    class exposes the available separators through a few properties. Even better,
    avoid using the separators at all. For example, to compose a folder, the following
    statement should be preferred:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道Linux和Windows使用正斜杠和反斜杠字符来分隔文件和文件夹。这就是为什么`System.IO.Path`类通过一些属性公开可用的分隔符。更好的是，根本不要使用分隔符。例如，要组成一个文件夹，应优先选择以下语句：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally, to transform a relative into a full path, use the `Path.GetFullPath`
    method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要将相对路径转换为完整路径，请使用`Path.GetFullPath`方法。
- en: End-of-line separators
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行尾分隔符
- en: When dealing with text files, the end-of-line separator in Windows is `\r\n`
    (`0x0D`, `0x0A`), while on Linux, we just use `\r` (`0x0D`). As for the `Path`
    class, the separator can be retrieved at runtime with `Environment.NewLine`, but
    most of the time, you can forget the difference by letting the `System.IO.TextReader.ReadLine`
    and `System.IO.TextWriter.WriteLine` abstractions take care of that.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文本文件时，Windows的行尾分隔符是`\r\n`（`0x0D`，`0x0A`），而在Linux上，我们只使用`\r`（`0x0D`）。至于`Path`类，分隔符可以在运行时通过`Environment.NewLine`检索，但大多数情况下，您可以通过让`System.IO.TextReader.ReadLine`和`System.IO.TextWriter.WriteLine`抽象来处理这个区别。
- en: Digital certificates
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字证书
- en: While Windows has a standard central repository for digital certificates, Linux
    does not, and it is up to the developer to decide whether to rely only on the
    certificate file or a distribution-specific solution. When you need to store a
    certificate, including the private key, it must be protected, because the private
    key is a secret that must never be disclosed. Providing the appropriate restrictions
    to defend those certificates is up to the developer.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Windows有一个标准的数字证书中央存储库，但Linux没有，开发人员需要决定是依赖于证书文件还是特定于发行版的解决方案。当您需要存储证书时，包括私钥，必须加以保护，因为私钥是绝对不能泄露的秘密。提供适当的限制以保护这些证书是开发人员的责任。
- en: Platform-specific APIs
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特定于平台的API
- en: Every platform-specific API such as the `NotImplementedException`. On Windows,
    the registry has historically been used to store per-user or even global settings
    related to the application. Linux has no equivalent; therefore, in modern development,
    it is better to get rid of the registry entirely. Another popular API is **Windows
    Management Instrumentation (WMI)**, which is only available on Windows and has
    no equivalent on Linux.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每个特定于平台的API，例如`NotImplementedException`。在Windows上，注册表历来用于存储与应用程序相关的每个用户甚至全局设置。Linux没有等价物；因此，在现代开发中，最好完全摆脱注册表。另一个流行的API是**Windows管理仪器（WMI）**，它仅在Windows上可用，在Linux上没有等价物。
- en: Security
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全
- en: Everything related to Windows accounts is, again, only available on Windows.
    The easiest way to modify the filesystem security flags on Linux is to spawn a
    new process running the standard `chmod` command-line tool with the appropriate
    arguments.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与Windows帐户相关的所有内容仅在Windows上可用。在Linux上修改文件系统安全标志的最简单方法是生成一个新进程，运行带有适当参数的标准`chmod`命令行工具。
- en: Environment variables
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境变量
- en: A very powerful and common denominator among all the platforms is the availability
    of the environment variables. Windows developers generally don't use them very
    often, while they are quite popular on Linux. For example, ASP.NET Core uses them
    to switch configurations between development, staging, and production, but can
    also be used to retrieve the standard variables, such as `HOME` on Linux and `HOMEPATH`
    on Windows, both of which represent the root folder for the current user's profile.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所有平台中非常强大且常见的共同点是环境变量的可用性。Windows开发人员通常不经常使用它们，而它们在Linux上非常受欢迎。例如，ASP.NET Core使用它们在开发、暂存和生产之间切换配置，但也可以用于检索标准变量，例如Linux上的`HOME`和Windows上的`HOMEPATH`，它们都代表当前用户配置文件的根文件夹。
- en: Gaps you may discover only at runtime
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 您可能只在运行时发现的差距
- en: 'There are times where you may need to detect at runtime the OS or the CPU architecture
    that the code is running on. For this purpose, the `System.Runtime.InteropServices.RuntimeInformation`
    class provides a lot of interesting information:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能需要在运行时检测代码正在运行的操作系统或CPU架构。为此，`System.Runtime.InteropServices.RuntimeInformation`类提供了许多有趣的信息：
- en: The `OSDescription` property returns a string describing the OS the application
    is running on.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OSDescription` 属性返回描述应用程序正在运行的操作系统的字符串。'
- en: The `OSArchitecture` property returns a string with the OS architecture. For
    example, the *X64* value stands for the Intel 64-bit architecture.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OSArchitecture` 属性返回带有OS架构的字符串。例如，*X64*值代表Intel 64位架构。'
- en: The `FrameworkDescription` property returns a string describing the current
    framework, such as *.NET Core 3.0.1*. The short string *3.0.1* is instead available
    through the `Environment.Version` property.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FrameworkDescription` 属性返回描述当前框架的字符串，例如*.NET Core 3.0.1*。而短字符串*3.0.1*则可通过`Environment.Version`属性获得。'
- en: The `ProcessArchitecture` property returns the processor architecture. This
    distinction exists because Windows can create 32-bit processes on its 64-bit flavor.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProcessArchitecture` 属性返回处理器架构。这种区别存在是因为Windows可以在其64位版本上创建32位进程。'
- en: The `GetRuntimeDirectory` method returns the full path, pointing to the runtime
    used by the application.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetRuntimeDirectory` 方法返回指向应用程序使用的运行时的完整路径。'
- en: 'Finally, the `RuntimeInformation.IsOSPlatform` method returns a Boolean that
    can be used to execute platform-specific code:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`RuntimeInformation.IsOSPlatform` 方法返回一个布尔值，可以用于执行特定于平台的代码：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You should always evaluate whether to use this technique to adopt platform-specific
    decisions, or to create a NuGet package containing one DLL for each platform.
    This latter solution is more maintainable but is not discussed in this book.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终评估是否使用此技术来采用特定于平台的决策，或者创建一个包含每个平台的一个DLL的NuGet包。后一种解决方案更易于维护，但本书未对此进行讨论。
- en: What .NET Standard is and how can it help the application design
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是.NET Standard，它如何帮助应用程序设计
- en: While .NET Core is the best candidate for running your code almost everywhere,
    it is also true that we currently may need to run our code on different runtimes,
    such as .NET Framework for existing Windows applications, Xamarin for developing
    mobile applications, and Blazor for running code in the WebAssembly sandbox or
    on other older runtimes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然.NET Core是在几乎所有地方运行代码的最佳选择，但也是事实，我们目前可能需要在不同的运行时上运行我们的代码，例如.NET Framework用于现有的Windows应用程序，Xamarin用于开发移动应用程序，以及Blazor用于在WebAssembly沙箱中运行代码或在其他较旧的运行时上运行。
- en: The first attempt to share compiled libraries across multiple runtimes was done
    with the **portable class library**, where the developer could only use the APIs
    that were available in all the selected runtimes. The resulting intersection was
    impractical because restricting the number of available APIs to just the common
    APIs was way too limiting. .NET Standard initiative was born to resolve this issue
    by creating versioned sets of API definitions for a number of well-known APIs.
    In order to be .NET Standard-compliant, any runtime must guarantee to implement
    that complete set of APIs. Think of .NET Standard as a sort of giant interface
    holding all the included APIs. Furthermore, every new version of .NET Standard
    adds new APIs to the previous ones.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个运行时之间共享编译库的第一次尝试是使用**可移植类库**，开发人员只能使用所有选定运行时中可用的API。由于将可用API的数量限制为仅限于公共API太过限制，因此得到的交集是不切实际的。.NET
    Standard倡议诞生于解决此问题，通过为许多知名API创建版本化的API定义集来解决此问题。为了符合.NET Standard，任何运行时都必须保证实现该完整的API集。将.NET
    Standard视为一种包含所有包含的API的巨大接口。此外，每个新版本的.NET Standard都会向以前的版本添加新的API。
- en: Tip
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Even if an API is a part of a .NET Standard contract, it can be implemented
    on certain platforms by throwing `NotImplementedException`. This solution was
    allowed to ease the migration of old applications to .NET Standard and must be
    taken into consideration when using a .NET Standard library.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 即使API是.NET Standard合同的一部分，它也可以通过抛出`NotImplementedException`在某些平台上实现。允许这种解决方案是为了简化将旧应用程序迁移到.NET
    Standard，并且在使用.NET Standard库时必须考虑这一点。
- en: .NET Standard version 1.0 defined a very small set of APIs to satisfy almost
    all the available runtimes of the past, such as **Silverlight** and **Windows
    Phone 8**. Version after version, the number of defined APIs has grown larger,
    excluding older runtimes but also offering more APIs overall to developers. For
    example, version 1.5 offered a good compromise in terms of the number of APIs
    because it supported the very popular .NET Framework 4.6.2\. In the .NET Standard
    repository on GitHub ([https://github.com/dotnet/standard/tree/master/docs/versions](https://github.com/dotnet/standard/tree/master/docs/versions)),
    you can find the complete list of the versions and supported API sets.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Standard版本1.0定义了一个非常小的API集，以满足几乎所有过去的可用运行时，例如**Silverlight**和**Windows
    Phone 8**。版本之后，定义的API数量变得更多，排除了旧的运行时，但也为开发人员提供了更多的API。例如，版本1.5在API数量方面提供了一个很好的折衷，因为它支持非常流行的.NET
    Framework 4.6.2。在GitHub上的.NET Standard存储库（[https://github.com/dotnet/standard/tree/master/docs/versions](https://github.com/dotnet/standard/tree/master/docs/versions)），您可以找到版本和支持的API集的完整列表。
- en: At the time of writing, you should care about the .NET Standard versions only
    as a library author. If you look at the very popular `Newtonsoft.Json` package
    on NuGet, you will see that it complies to .NET Standard 1.0\. This makes very
    sense because it allows the library to be used by almost the entire .NET ecosystem.
    The simple rule is that library developers should support the lowest possible
    version.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，您应该只关心.NET Standard版本作为库作者。如果您查看NuGet上非常流行的`Newtonsoft.Json`包，您会发现它符合.NET
    Standard 1.0。这是非常合理的，因为它允许该库被几乎整个.NET生态系统使用。简单的规则是库开发人员应该支持最低可能的版本。
- en: From the application developer's perspective, the problem is different because
    you may want to use the highest possible number in order to have the largest number
    of APIs available. If your target is to develop applications just for .NET Framework
    and .NET Core (which is very common when migrating to a new runtime), your choice
    will be version 2.0 because this is the last version of the .NET Standard contract
    supported from .NET Framework.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序开发人员的角度来看，问题是不同的，因为您可能希望使用尽可能高的数字，以便拥有最多的API。如果您的目标是仅为.NET Framework和.NET
    Core开发应用程序（在迁移到新运行时时非常常见），您的选择将是版本2.0，因为这是.NET Framework支持的最后一个.NET Standard合同版本。
- en: At the time of writing, the most recent version of .NET Standard is 2.1, which
    includes APIs such as `Span<T>`, and many new method overloads that take `Span<T>`
    instead of arrays, thereby providing better performance results.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，最新版本的.NET Standard是2.1，其中包括诸如`Span<T>`之类的API，以及许多新的方法重载，这些方法采用`Span<T>`而不是数组，从而提供更好的性能结果。
- en: Creating a .NET Standard library
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建.NET Standard库
- en: 'Creating a .NET Standard library is straightforward. In Visual Studio, there
    is a specific template, whereas from the command line, the following command creates
    a .NET Standard library whose version is 2.0 by default. You can list the other
    choices by appending `--help` onto the end of the following command, or you can
    stay with `netstandard2.0` and create the library project:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 创建.NET Standard库非常简单。在Visual Studio中，有一个特定的模板，而从命令行中，以下命令将创建一个默认版本为2.0的.NET
    Standard库。您可以通过在以下命令的末尾添加`--help`来列出其他选择，或者您可以保持`netstandard2.0`并创建库项目：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once created, the library can be added to the previous solution with this command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，可以使用此命令将库添加到以前的解决方案中：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, you can add the `MyLibrary` reference to the `Hello` project with
    this other command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用另一个命令将`MyLibrary`引用添加到`Hello`项目中：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The generated assembly is a class library that can be referenced from all the
    projects targeting the runtimes and supporting that .NET Standard version.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的程序集是一个类库，可以从所有针对运行时并支持该.NET Standard版本的项目中引用。
- en: Deciding between the .NET Standard and .NET Core libraries
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在.NET Standard和.NET Core库之间做出决定
- en: Every time you need to share some code across multiple runtimes, the best option
    is to try to fit it, whenever possible, into a .NET Standard library.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您需要在多个运行时之间共享一些代码时，最好的选择是尽可能将其放入.NET Standard库中。
- en: We already said that library authors should target the lowest possible version
    number, but of course, if you are the only library consumer, you may decide to
    adopt .NET Standard 2.0 to share codes, for example, between .NET Framework, .NET
    Core Mono 5.4, and Unity 2018.1.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过，库的作者应该针对最低可能的版本号，但当然，如果你是唯一的库使用者，你可能决定采用.NET Standard 2.0来共享代码，例如，在.NET
    Framework、.NET Core Mono 5.4和Unity 2018.1之间。
- en: 'Every time your library is going to be exclusively consumed by a .NET Core
    application, you may want to create a .NET Core class library instead as it does
    not limit the API set that you can use in your application:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你的库将被专门用于.NET Core应用程序时，你可能希望创建一个.NET Core类库，因为它不限制你在应用程序中可以使用的API集：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the previous example, a new .NET Core class library (`NetCoreLibrary`) has
    been created and added to the reference of the `Hello` project.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，已经创建了一个新的.NET Core类库（`NetCoreLibrary`）并将其添加到`Hello`项目的引用中。
- en: Consuming NuGet packages
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NuGet包
- en: Packages play a very important role in modern application development because
    they define a self-contained unit of code that can be used as a brick to build
    larger applications.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 包在现代应用程序开发中扮演着非常重要的角色，因为它们定义了一个独立的代码单元，可以用作构建更大应用程序的基石。
- en: This same definition was used in the past for libraries composed by a single
    `.dll` file, but modern development often requires more files to make a unit of
    code that's properly self-contained. The simplest example is when a package contains
    the library as well as its dependencies, but another, more complex, example is
    writing a library needing platform invocation calls to native APIs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，这个定义也适用于由单个`.dll`文件组成的库，但现代开发通常需要更多的文件来构建一个适当独立的代码单元。最简单的例子是当一个包包含了库以及它的依赖项，但另一个更复杂的例子是编写一个需要对本地API进行平台调用的库。
- en: '`RuntimeInformation` class, but it is generally better for both performance
    and maintenance to split the code into one library for each OS and CPU architecture.
    The advantage of packaging the platform-dependent libraries is that it lets the
    .NET Core build tools copy the relevant library in the output folder at publishing
    time. Beyond the interoperability with native code, there are other cases, such
    as providing different implementations depending on the runtime (for example,
    .NET Core, .NET Framework, Mono, and so on).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`RuntimeInformation`类，但通常为了性能和维护的考虑，最好将代码分割成每个操作系统和CPU架构的一个库。打包平台相关库的优势在于它让.NET
    Core构建工具在发布时将相关库复制到输出文件夹中。除了与本地代码的互操作性之外，还有其他情况，比如根据运行时（例如.NET Core、.NET Framework、Mono等）提供不同的实现。'
- en: Adding packages to a project
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向项目添加包
- en: 'There are multiple ways to add a package reference to a project; it mostly
    depends on your IDE of choice. Visual Studio offers full visual support by opening
    the **Solution Explorer** (this is the window showing the solution and projects
    hierarchy), expanding a project tree, right-clicking the **Dependencies** node,
    and picking the **Manage NuGet Packages** menu item. The following is a typical
    NuGet window, listing the packages available from **nuget.org** that can be added
    to your project:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以向项目添加包引用；这主要取决于你选择的IDE。Visual Studio通过打开**解决方案资源管理器**（这是显示解决方案和项目层次结构的窗口），展开项目树，右键单击**依赖项**节点，并选择**管理NuGet包**菜单项来提供完整的可视化支持。以下是一个典型的NuGet窗口，列出了可以从**nuget.org**添加到你的项目中的包：
- en: '![Figure 16.2 – The NuGet Package Manager Window'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.2–NuGet包管理器窗口'
- en: '](img/Figure_16.2_B12346.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.2_B12346.jpg)'
- en: Figure 16.2 – The NuGet Package Manager Window
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2–NuGet包管理器窗口
- en: 'The NuGet window allows you to add, remove, or update to a different version
    of the project packages:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: NuGet窗口允许你添加、删除或更新项目包的不同版本：
- en: On the right, the **Package source** combo box shows the list of websites or
    local folders providing packages. The list can be configured by clicking on the
    nearby gear icon.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在右侧，**包源**组合框显示了提供包的网站或本地文件夹的列表。点击附近的齿轮图标可以配置列表。
- en: On the left, the `author:microsoft`.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在左侧，`author:microsoft`。
- en: The **Installed** tab only shows the packages that are already installed in
    the project.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已安装**选项卡只显示已安装在项目中的包。'
- en: The **Updates** tab shows the installed packages for which a new version is
    available from the selected source.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新**选项卡显示了已安装包的新版本，这些新版本来自所选源。'
- en: Once you've selected a package on the right-hand side of the tab, you select
    the desired version and it will proceed to install, uninstall, or update, depending
    on the tab you started from.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你在选项卡的右侧选择了一个包，你就可以选择所需的版本，然后它将根据你从哪个选项卡开始进行安装、卸载或更新。
- en: 'When a solution is composed of multiple projects, it is important to be consistent
    in the version packages. For this reason, Visual Studio offers the ability to
    **Manage NuGet Packages for Solution**, a menu item available by right-clicking
    the **Solution** node. This window is similar, but has an additional tab called
    **Consolidate**, showing the packages that are installed with different versions
    in multiple projects. Ideally, this tab shouldn''t show any packages:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个解决方案由多个项目组成时，保持版本包的一致性非常重要。因此，Visual Studio提供了**管理解决方案的NuGet包**的功能，这是一个右键单击**解决方案**节点可用的菜单项。这个窗口类似，但有一个额外的选项卡叫做**整合**，显示了在多个项目中安装了不同版本的包。理想情况下，这个选项卡不应该显示任何包：
- en: '![Figure 16.3 – The NuGet Package Manager for the Solution, Consolidate tab'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.3–解决方案的NuGet包管理器，整合选项卡'
- en: '](img/Figure_16.3_B12346.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.3_B12346.jpg)'
- en: Figure 16.3 – The NuGet Package Manager for the Solution, Consolidate tab
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3–解决方案的NuGet包管理器，整合选项卡
- en: 'An alternative way to search for packages is going straight to the source.
    In the following screenshot, you can see the [http://nuget.org](http://nuget.org/)
    website, which is the primary repository of .NET packages:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索包的另一种方法是直接到源头。在下面的截图中，你可以看到[http://nuget.org](http://nuget.org/)网站，这是.NET包的主要存储库：
- en: '![Figure 16.4 – Searching on the NuGet gallery website'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.4-在NuGet库网站上搜索'
- en: '](img/Figure_16.4_B12346.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.4_B12346.jpg)'
- en: Figure 16.4 – Searching on the NuGet gallery website
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4-在NuGet库网站上搜索
- en: 'This web page shows important details for each package you select:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网页显示了您选择的每个包的重要细节：
- en: On the right, the **Source repository** link jumps to the source repository
    whenever it is available.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧的**源代码库**链接在可用时跳转到源代码库。
- en: The **Dependencies** section can be expanded to show which other packages it
    relies on.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项**部分可以展开，显示它依赖的其他包。'
- en: The **GitHub Usage** section acts as a sort of reputation for the package, showing
    how many open source projects took a dependency from it. The more a package is
    used by the community, the higher the chance that it is supported and reliable.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub使用**部分充当了包的声誉，显示了有多少开源项目依赖于它。一个包被社区使用的次数越多，它被支持和可靠的机会就越大。'
- en: 'In the upper part of the page, the package section shows different ways to
    add the package to your project:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面的上部，包部分显示了将包添加到项目的不同方法：
- en: '**Package Manager** shows the manual command you can execute from the window
    with the same name in Visual Studio.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包管理器**显示您可以从Visual Studio中同名窗口执行的手动命令。'
- en: '**.NET CLI** shows the .NET CLI command.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET CLI**显示.NET CLI命令。'
- en: '`.csproj` directly.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.csproj`直接。'
- en: '**Paket CLI** is an alternative CLI tool to the .NET CLI.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Paket CLI**是.NET CLI的另一种CLI工具。'
- en: 'Adding a package via the CLI is straightforward because `nuget.org` already
    provides us with the exact command string to type into the console Terminal. Remember
    to enter the project folder first, and then type the command. For example, the
    following is the command to add a reference to the `Newtonsoft.Json` package from
    the command line:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过CLI添加包是很简单的，因为`nuget.org`已经为我们提供了要在控制台终端中输入的确切命令字符串。记得先进入项目文件夹，然后输入命令。例如，以下是从命令行添加对`Newtonsoft.Json`包的引用的命令：
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Regardless of the OS, if you are using Visual Studio Code, it provides the handy
    Terminal window from which you can type any .NET CLI command.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 无论操作系统如何，如果您使用Visual Studio Code，它都提供了一个方便的终端窗口，您可以在其中输入任何.NET CLI命令。
- en: Another frequently used method to add a package reference is to directly edit
    the `.csproj` file. With .NET Core, the project file structure was drastically
    simplified, getting rid of all the past tags and also offering the ability, within
    Visual Studio, to edit and update the file without closing or unloading the project.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个经常使用的添加包引用的方法是直接编辑`.csproj`文件。使用.NET Core，项目文件结构得到了大幅简化，摆脱了过去的所有标签，并且还提供了在Visual
    Studio中编辑和更新文件的能力，而无需关闭或卸载项目。
- en: 'The following is the relevant portion of a `.csproj` file where you can add
    the `PackageReference` tag by hand:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`.csproj`文件的相关部分，您可以手动添加`PackageReference`标签：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, the `ItemGroup` element can be repeated multiple times and each
    of them may contain multiple `PackageReference` tags.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`ItemGroup`元素可以多次重复，并且每个元素可能包含多个`PackageReference`标签。
- en: Migrating from .NET Framework to .NET Core
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从.NET Framework迁移到.NET Core
- en: I believe the most important new feature of the .NET Core runtime is its ability
    to be deployed side by side with any other .NET Core version, guaranteeing that
    any future release will not affect older runtimes or libraries and, consequently,
    applications. The primary reason that prevented Microsoft from modernizing and
    improving the performance of .NET Framework was the shared nature of the .NET
    runtime and base class libraries. Because of that, the smallest change to those
    libraries could potentially cause unacceptable breaking changes to the hundreds
    of millions of installations already deployed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为.NET Core运行时最重要的新功能是它能够与任何其他.NET Core版本并行部署，确保任何未来的发布都不会影响旧的运行时或库，因此也不会影响应用程序。阻止微软现代化和改进.NET
    Framework性能的主要原因是.NET运行时和基类库的共享性质。因此，对这些库的最小更改可能会导致已部署的数亿个安装出现不可接受的破坏性变化。
- en: The obvious consequence of the new side-by-side deployment strategy in .NET
    Core is the total absence of the **Global Assembly Cache (GAC)**, which provided
    a central repository to which a system or user library could be deployed. The
    runtime is now completely isolated from the rest of the system, a decision that
    enabled the ability to deploy the application in a so-called **self-contained
    deployment** where all the required code, including the runtime and the system
    library, together with the application code, are copied into a single folder.
    We will dig into the deployment options later in the *Publishing an application*
    section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core新的并行部署策略的明显后果是**全局程序集缓存（GAC）**的完全消失，它提供了一个中央存储库，可以将系统或用户库部署到其中。运行时现在完全与系统的其余部分隔离，这个决定使得能够将应用程序部署到所谓的**自包含部署**中，其中所有所需的代码，包括运行时和系统库，以及应用程序代码，都被复制到一个文件夹中。我们将在*发布应用程序*部分深入探讨部署选项。
- en: 'Among all the available runtimes, .NET Framework has always been the touchstone
    and, at the time of writing, is still a valid ecosystem that will be supported
    for a very long time by Microsoft since it is redistributed with the Windows client
    and server OSes. Though, as wise developers, we can''t ignore the fact that with
    the release of .NET Core 3, Microsoft made two important statements:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有可用的运行时中，.NET Framework一直是基准，在撰写本文时，它仍然是一个有效的生态系统，将在未来很长一段时间内得到微软的支持，因为它与Windows客户端和服务器操作系统一起重新分发。尽管如此，作为明智的开发人员，我们不能忽视.NET
    Core 3的发布，微软发表了两个重要声明：
- en: .NET Framework 4.8 will be the *last version* of this runtime and libraries.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Framework 4.8将是这个运行时和库的*最后一个版本*。
- en: .NET 5 will be the new *short name* for .NET Core to be released at the end
    of 2020.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 5将是2020年底发布的.NET Core的新*简称*。
- en: There is no doubt that .NET Core 3 demarcates a turning point in the history
    of the .NET runtime as it provides all the workloads that were previously supported
    by .NET Framework. Starting from .NET Core 3, you can now create server and Windows
    desktop applications, leverage the power of machine learning, or develop cloud
    applications. This is also a strong piece of advice for all relevant developers
    who are invited to create all-new applications using .NET Core, because it offers
    the latest state-of-the-art technology in terms of runtime, libraries, compilers,
    and tools.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，.NET Core 3标志着.NET运行时历史上的一个转折点，因为它提供了以前由.NET Framework支持的所有工作负载。从.NET Core
    3开始，您现在可以创建服务器和Windows桌面应用程序，利用机器学习的力量，或开发云应用程序。这也是对所有相关开发人员的强烈建议，他们被邀请使用.NET
    Core创建全新的应用程序，因为它提供了最先进的运行时、库、编译器和工具技术。
- en: Analyzing your architecture
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析您的架构
- en: Before starting any migration step, it is important to verify whether the technologies,
    frameworks, and third-party libraries are available on .NET Core.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始任何迁移步骤之前，重要的是要验证技术、框架和第三方库是否在.NET Core上可用。
- en: The old .NET Framework base class library has been ported entirely, as have
    the great majority of the most popular NuGet packages authored by Microsoft and
    other third parties, giving all of us a very high chance of finding updated versions
    compatible with .NET Core. If those dependencies are available as .NET Standard
    2.0 or a lower version (remember that .NET Standard 2.1 is not supported by .NET
    Framework), then they are good to go. But as we have seen previously, the NuGet
    package can contain multiple libraries targeting different runtimes, so it is
    important to verify the compatibility of the library on the vendor's page.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的.NET Framework基类库已完全移植，微软和其他第三方撰写的大多数最受欢迎的NuGet包也已移植，这使我们所有人都有很高的机会找到与.NET
    Core兼容的更新版本。如果这些依赖项可用作.NET Standard 2.0或更低版本（请记住，.NET Standard 2.1不受.NET Framework支持），那么它们就可以使用。但正如我们之前所见，NuGet包可能包含针对不同运行时的多个库，因此验证库在供应商页面上的兼容性非常重要。
- en: If your projects rely heavily on Windows because they need Windows APIs, you
    may want to take a look at the **Windows Compatibility Pack NuGet** package, which
    contains about 20,000 APIs.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的项目严重依赖于Windows，因为它们需要Windows API，您可能需要查看**Windows兼容性包NuGet**包，其中包含约20,000个API。
- en: Information box
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 信息框
- en: Even if a library is only .NET Framework-compatible, in most cases, it can be
    referenced by .NET Core thanks to a *shim mechanism* that makes this possible.
    In this case, Visual Studio shows a yellow triangle indicating a warning in the
    build log. The potential incompatibilities should be tested carefully to verify
    the correctness of the application.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 即使一个库只兼容.NET Framework，在大多数情况下，由于*shim机制*的存在，它也可以被.NET Core引用。在这种情况下，Visual
    Studio会在构建日志中显示一个黄色三角形，表示警告。潜在的不兼容性应该经过仔细测试，以验证应用程序的正确性。
- en: Although .NET Core supports the vast majority of the past workloads, some of
    them are not available and others have been rewritten, making the migration process
    a bit harder, but giving other advantages in return.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管.NET Core支持绝大多数过去的工作负载，但其中一些不可用，其他一些已经被重写，使得迁移过程有点困难，但同时也带来了其他优势。
- en: Migrating ASP.NET Web Forms applications
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迁移ASP.NET Web Forms应用程序
- en: This technology is very old and considered obsolete, because the web of today
    has evolved with very different paradigms in comparison to the web technologies
    of the past. The best route to migrate this code is using the **Blazor template**,
    which allows us to run C# code inside the browser thanks to the *WebAssembly*
    support, which is now available in any modern browser. While this solution is
    not a real port, but a rewrite, it allows us to stay on C# for both the server
    and most of the client code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这项技术非常古老，被认为已经过时，因为今天的网络与过去的网络技术相比已经演变出非常不同的范式。迁移此代码的最佳途径是使用**Blazor模板**，这使我们能够在浏览器中运行C#代码，这要归功于*WebAssembly*支持，现在在任何现代浏览器中都可用。虽然这个解决方案并不是真正的移植，而是重写，但它允许我们在服务器和大部分客户端代码上都使用C#。
- en: Windows Communication Foundation (WCF)
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows通信基础（WCF）
- en: On .NET Core, support for the **Windows Communication Foundation** (**WCF**)
    is available only for the client side, which means just consuming the WCF services.
    Nowadays, there are more performant and simpler technologies available, such as
    **gRPC** (requiring HTTP2) and **REST** (Web API). For those who still need to
    create SOAP-based web services, a community-driven open source project called
    **CoreWCF** is available on GitHub. Before you start migrating your old code using
    this library, you should verify that all of the WCF options used in your projects
    are also available on CoreWCF.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Core上，**Windows通信基础**（**WCF**）仅适用于客户端，这意味着只能消费WCF服务。如今，有更高性能和更简单的技术可用，例如**gRPC**（需要HTTP2）和**REST**（Web
    API）。对于仍然需要创建基于SOAP的Web服务的人来说，一个名为**CoreWCF**的社区驱动的开源项目在GitHub上可用。在开始使用此库迁移旧代码之前，您应该验证项目中使用的所有WCF选项在CoreWCF上是否也可用。
- en: At the time of writing, neither .NET Core nor CoreWCF support the **WS-*** standards
    at all.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，无论是.NET Core还是CoreWCF都不支持**WS-***标准。
- en: Windows Workflow Foundation
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows工作流基础
- en: Workflow Foundation has not been ported, but another open source project called
    **CoreWF** is available on GitHub. As we mentioned previously for WCF, you should
    verify the full availability of the features used in your projects first.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流基础并未移植，但另一个名为**CoreWF**的开源项目在GitHub上可用。正如我们先前提到的WCF一样，您应该首先验证项目中使用的功能的完全可用性。
- en: Entity Framework
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Entity Framework
- en: '**Entity Framework 6 (EF6)** is also available on .NET Core and you should
    not have any issue in migrating this project, but it is worth mentioning that
    this technology is considered *feature complete* by Microsoft, which is now only
    developing **Entity Framework Core (EF Core)**. Depending on how your repository
    access is structured, including the model graph and the providers used in your
    project, you may want to consider migrating your access code to EF Core. In this
    case, be aware that, in .NET Core 3, many-to-many relationships are supported
    but require the intermediate entity class to be described in the model. The APIs
    in EF Core are very different but, on the other hand, they offer a lot of new
    functionalities. The roadmap for .NET 5 (which is the new name for .NET Core)
    includes a lot of new features that you may want to consider.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**Entity Framework 6（EF6）**也可以在.NET Core上使用，你在迁移这个项目时不应该遇到任何问题，但值得一提的是，这项技术被微软认为是*功能完备*的，现在只开发**Entity
    Framework Core（EF Core）**。根据你的存储库访问结构，包括模型图和项目中使用的提供程序，你可能希望考虑将你的访问代码迁移到EF Core。在这种情况下，要注意的是，在.NET
    Core 3中，支持多对多关系，但需要在模型中描述中间实体类。EF Core中的API与之前非常不同，但另一方面，它们提供了许多新的功能。.NET 5（这是.NET
    Core的新名称）的路线图包括许多你可能想要考虑的新功能。'
- en: For all the aforementioned reasons, you may find it easier to first migrate
    using EF6 and only later migrate to EF Core. This decision is very project dependent.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 基于上述所有原因，你可能会发现首先使用EF6进行迁移，然后再迁移到EF Core会更容易。这个决定非常依赖于项目本身。
- en: ASP.NET MVC
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ASP.NET MVC
- en: The ASP.NET MVC framework has been entirely rewritten on ASP.NET Core, but it
    still offers the same key functionalities. Unless you deeply customize and extend
    the infrastructure, the migration is definitely straightforward, but still requires
    some small rewriting of code because of the namespace and type changes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET MVC框架已经完全重写为ASP.NET Core，但它仍然提供相同的关键功能。除非你深度定制和扩展基础设施，否则迁移肯定是直接的，但仍然需要对代码进行一些小的重写，因为命名空间和类型发生了变化。
- en: Code Access Security APIs
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码访问安全API
- en: All of the **Code Access Security (CAS)** APIs have been removed from .NET Core
    because the only trustable boundary is the one offered natively by the process
    hosting the code. If you are still using CAS, it is highly recommended to get
    rid of it, regardless of your .NET Core migration.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的**代码访问安全（CAS）**API都已经从.NET Core中移除，因为唯一可信的边界是由托管代码的进程本身提供的。如果你仍在使用CAS，强烈建议摆脱它，无论你的.NET
    Core迁移如何。
- en: AppDomains and Remoting APIs
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AppDomains和远程API
- en: With .NET Core, there is always a single AppDomain per process. For this reason,
    you will see that most of the AppDomain APIs are gone and not available. If you
    have used AppDomains to isolate and unload certain assemblies, you should look
    at `AssemblyLoadContext`, a new API in .NET Core 3 that allows you to address
    this problem in a powerful way without requiring remoting communication, which
    has been removed from .NET Core as well.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Core中，每个进程始终只有一个AppDomain。因此，你会发现大多数AppDomain API都已经消失并且不可用。如果你曾经使用AppDomains来隔离和卸载某些程序集，你应该看看`AssemblyLoadContext`，这是.NET
    Core 3中的一个新API，它可以以强大的方式解决这个问题，而不需要远程通信，因为远程通信也已经从.NET Core中移除了。
- en: Preparing the migration process
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备迁移过程
- en: A common step to pursue when starting the migration process from .NET Framework
    to .NET Core is updating .NET Framework to at least version 4.7.2.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从.NET Framework迁移到.NET Core的迁移过程中，一个常见的步骤是将.NET Framework更新至至少4.7.2版本。
- en: Version 4.7.2 is a special version, as it was the first release to fully support
    the .NET Standard binary contract, avoiding the requirement of external NuGet
    packages needed to fill the gaps. This step shouldn't cause any issues and you
    can continue to deploy the current projects with this latest version of .NET Framework
    with no fear. Depending on the complexity of the solution, you may want to work
    on the migration while still running production code on .NET Framework until everything
    is fully tested.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 4.7.2版本是一个特殊的版本，因为它是第一个完全支持.NET标准二进制契约的版本，避免了需要填补空白的外部NuGet包的要求。这一步不应该引起任何问题，你可以继续使用这个最新版本的.NET
    Framework部署当前的项目，而不必担心。根据解决方案的复杂性，你可能希望在仍然在.NET Framework上运行生产代码的同时进行迁移，直到一切都经过充分测试。
- en: At this point, the analysis should focus on external dependencies such as NuGet
    packages from third parties that you don't have control over. Once you have identified
    the newer packages, update them so that your .NET Framework solution can run on
    the newer versions. You still have a deployable solution that starts off with
    a few pieces that are compatible with .NET Core, even if you didn't change any
    lines of code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，分析应该集中在外部依赖上，比如来自第三方的NuGet包，这些包是你无法控制的。一旦你确定了更新的包，更新它们，这样你的.NET Framework解决方案就可以在更新的版本上运行。即使你没有改变任何代码，你仍然有一个可部署的解决方案，它以与.NET
    Core兼容的一些部分开始。
- en: The Portability Analyzer Tool
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可移植性分析器工具
- en: The **API Port tool** is available on GitHub at [https://github.com/microsoft/dotnet-apiport](https://github.com/microsoft/dotnet-apiport)
    and provides us with the ability to create a detailed report of a .NET application
    that lists all the APIs used and whether they are available on other platforms.
    The tool is available both as a Visual Studio extension or via the CLI so that
    you can automate the process as desired. The ultimate report provided by the tool
    is an Excel spreadsheet containing a cross-reference of all the APIs that allows
    you to plan the migration without getting any undesirable surprises during the
    process.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**API Port工具**在GitHub上可用，网址是[https://github.com/microsoft/dotnet-apiport](https://github.com/microsoft/dotnet-apiport)，它为我们提供了创建一个详细报告的能力，列出了.NET应用程序中使用的所有API以及它们在其他平台上是否可用。该工具既可以作为Visual
    Studio扩展，也可以通过CLI使用，这样你就可以根据需要自动化这个过程。该工具提供的最终报告是一个Excel电子表格，其中包含所有API的交叉引用，让你可以在迁移过程中进行规划，而不会在过程中遇到任何不良的意外。'
- en: Migrating the libraries
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移库
- en: We can finally start updating the library projects in the solution. It is important
    to have a clear view of the dependency tree of the entire solution and packages.
    If the project is very large, you may want to leverage the power of external tools
    such as the popular **NDepend**. On the dependency tree, you should identify the
    libraries at the bottom of the tree that have no other dependencies on external
    packages—they are the best starting point.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于可以开始更新解决方案中的库项目了。重要的是要清楚地了解整个解决方案和包的依赖树。如果项目非常庞大，您可能希望利用外部工具的强大功能，比如流行的**NDepend**。在依赖树上，您应该识别出树底部没有其他外部包依赖的库，它们是最好的起点。
- en: In most cases, migrating a library with no dependencies (or a library depends
    on a package that can run on both frameworks) is straightforward. There is no
    automated support, so you should create a new **.NET Standard 2.0** project.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，迁移没有依赖关系的库（或者库依赖于可以在两个框架上运行的包）是直接的。没有自动化支持，因此您应该创建一个**.NET Standard
    2.0**项目。
- en: Tip
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: At the time of writing, the [https://github.com/dotnet/try-convert/releases](https://github.com/dotnet/try-convert/releases)
    repository contains the preview of a tool that is able to convert projects into
    .NET Core. As the name `try-convert` suggests, it cannot handle all types of project,
    but can still be used as a starting point for the migration.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，[https://github.com/dotnet/try-convert/releases](https://github.com/dotnet/try-convert/releases)存储库包含了一个工具的预览，该工具能够将项目转换为.NET
    Core。正如`try-convert`这个名字所暗示的，它无法处理所有类型的项目，但仍然可以作为迁移的起点。
- en: 'Migrating to the new .`csproj` project structure can be done in one of two
    ways:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移到新的`.csproj`项目结构可以通过以下两种方式之一完成：
- en: Creating a new project and moving the source files over it
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新项目并将源文件移动到其中
- en: Modifying the `.csproj` file of the old project
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改旧项目的`.csproj`文件
- en: 'The first strategy is simpler, but it has the downside of changing the project
    name, which also implies changing the default for the namespace name and the assembly
    name. These can be renamed by making the following changes to the `.csproj` file:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种策略更简单，但缺点是会改变项目名称，这也意味着要更改默认的命名空间和程序集名称。这些可以通过对`.csproj`文件进行以下更改来重命名：
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Remember that creating a new project also implies fixing the references of all
    the dependent projects.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，创建新项目也意味着修复所有依赖项目的引用。
- en: The second strategy consists of replacing the contents of the `.csproj` file,
    which requires you to have tested the changes prior to this on a separate project.
    When migrating the package references, be advised that new .NET Core projects
    ignore the `packages.config` file and require all the references to be specified
    in the `PackageReference` tags, as mentioned earlier in the *Consuming NuGet packages*
    section.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种策略包括替换`.csproj`文件的内容，这要求您在单独的项目上测试了这些更改之前。在迁移包引用时，请注意新的.NET Core项目会忽略`packages.config`文件，并要求所有引用都在`PackageReference`标签中指定，就像在*使用NuGet包*部分中提到的那样。
- en: Finding the missing APIs
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找缺失的API
- en: During the migration, you might discover some missing APIs. For this specific
    case, Microsoft created the [https://apisof.net/](https://apisof.net/) website,
    which has classified more than 700,000 APIs among those available through the
    base class library and NuGet. Thanks to its search capability, you can search
    for any class, method, property, or event and discover its usage and which platform
    and version supports it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移过程中，您可能会发现一些缺失的API。对于这种特定情况，微软创建了[https://apisof.net/](https://apisof.net/)网站，该网站对基类库和NuGet可用的70万多个API进行了分类。由于其搜索功能，您可以搜索任何类、方法、属性或事件，并发现其用法以及支持它的平台和版本。
- en: Migrating the tests
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移测试
- en: 'Once you''ve migrated the lower-level dependent libraries, it is a good idea
    to create the test projects so that any migrated code gets tested on both frameworks.
    The test projects themselves shouldn''t really be migrated, as you may want to
    test the code on both frameworks. For this reason, you may want to share the test
    code in a **Shared Project** (a template available from the following screen in
    Visual Studio), which is a special project that doesn''t produce any binary:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您迁移了较低级别的依赖库，最好创建测试项目，以便对任何迁移的代码在两个框架上进行测试。测试项目本身实际上不应该被迁移，因为您可能希望在两个框架上测试代码。因此，您可能希望在**共享项目**（在Visual
    Studio的以下屏幕中可用的模板）中共享测试代码，这是一个不会产生任何二进制文件的特殊项目：
- en: '![Figure 16.5 – The Add a new project Visual Studio dialog box'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.5 - 添加新项目的Visual Studio对话框'
- en: '](img/Figure_16.5_B12346.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.5_B12346.jpg)'
- en: Figure 16.5 – The Add a new project Visual Studio dialog box
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5 - 添加新项目的Visual Studio对话框
- en: All the projects referencing a Shared Project inherit its source code, as it
    was included directly. All the major test frameworks (xUnit, NUnit, and MSTest)
    have been ported to .NET Core, but there may be a few differences in the supported
    test APIs; therefore, any infrastructural code using the test API should be verified
    first.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 所有引用共享项目的项目都继承了其源代码，就好像它们直接包含在其中一样。所有主要的测试框架（xUnit、NUnit和MSTest）都已经移植到.NET Core，但在支持的测试API方面可能会有一些差异；因此，任何使用测试API的基础设施代码都应该首先进行验证。
- en: Lastly, if the test code uses AppDomains to unload certain assemblies, remember
    to rewrite it using the more powerful `AssemblyLoadContext` API. The migration
    should now continue by iterating over the porting libraries and their tests until
    all the infrastructure has been migrated and is working on both frameworks.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果测试代码使用AppDomains来卸载某些程序集，请记住要使用更强大的`AssemblyLoadContext` API进行重写。现在应该继续迁移，迭代移植库和它们的测试，直到所有基础设施都已经迁移并在两个框架上运行。
- en: Migrating the desktop projects
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移桌面项目
- en: The WPF and Windows Forms workloads are available on .NET Core 3 and their migration
    should be straightforward. At the time of writing, the Windows Forms designer
    is available as a preview, but you can still share the designer code in the Shared
    Project mentioned previously to continue using the .NET Framework designer.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: WPF和Windows Forms工作负载可在.NET Core 3上使用，它们的迁移应该是直接的。在撰写本文时，Windows Forms设计器作为预览可用，但您仍然可以在之前提到的共享项目中共享设计器代码，以继续使用.NET
    Framework设计器。
- en: 'On .NET Core 3.1, some of the Windows Forms controls have been removed, but
    they can be replaced with newer ones exhibiting the same functionalities:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 3.1上，一些Windows Forms控件已被移除，但它们可以被具有相同功能的新控件替代：
- en: '![](img/Chapter_16_Table.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_16_Table.jpg)'
- en: Another missing feature is **ClickOnce**, a deployment system that is widely
    used inside many companies. Microsoft's suggestion is to migrate the deployment
    package to the newer **MSIX** technology.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺失的功能是**ClickOnce**，这是许多公司内广泛使用的部署系统。微软建议将部署包迁移到更新的**MSIX**技术。
- en: Migrating ASP.NET projects
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移ASP.NET项目
- en: Migrating ASP.NET MVC projects is the only workload that requires more manual
    work and code changes, but also brings many clear advantages from the newly rewritten
    ASP.NET Core framework in terms of performance and simplification, such as the
    unified `Controller` hierarchy of the **MVC** and **WebAPI** worlds.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移ASP.NET MVC项目是唯一需要更多手动工作和代码更改的工作负载，但也带来了许多明显的优势，因为新编写的ASP.NET Core框架在性能和简化方面，如**MVC**和**WebAPI**世界的统一`Controller`层次结构。
- en: Tip
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Before starting, I strongly suggest being familiar with the *ASP.NET Core MVC*
    framework, with particular focus on dependency injection, identity, authorization,
    configuration, and logging, the details of which go far beyond the scope of this
    book.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我强烈建议熟悉*ASP.NET Core MVC*框架，特别关注依赖注入、身份验证、授权、配置和日志记录，这些细节远远超出了本书的范围。
- en: To migrate a ASP.NET web project, it is always better to start from a new ASP.NET
    Core MVC template instead of tweaking the old `.csproj`, since the code won't
    run as-is and will always require some changes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要迁移ASP.NET Web项目，最好始于新的ASP.NET Core MVC模板，而不是调整旧的`.csproj`，因为代码不会原样运行，总是需要一些更改。
- en: 'Any code related to the ASP.NET infrastructure is the first you may want to
    migrate. For example, `Global.asax` generally contains the initialization code,
    while **HTTP Modules** and **Handlers** are infrastructural code meant to intercept
    the requests and responses. The general rules for migrating this code are as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 与ASP.NET基础设施相关的任何代码都是您可能想要迁移的第一项。例如，`Global.asax`通常包含初始化代码，而**HTTP模块**和**处理程序**是旨在拦截请求和响应的基础代码。迁移此代码的一般规则如下：
- en: Static structures or global helpers should be converted into a **Dependency
    Injection (DI)** singleton service.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态结构或全局助手应转换为**依赖注入（DI）**单例服务。
- en: Any code that is meant to intercept, read, or modify the HTTP requests and responses
    should become middleware and be configured in the `Startup` class.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何旨在拦截、读取或修改HTTP请求和响应的代码都应成为中间件，并在`Startup`类中进行配置。
- en: Identify any code outside of the `Controller` logic, determine its life cycle,
    and make it available through `Controller` constructor, consider creating a factory
    instead and provide the factory through `Controller`.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别`Controller`逻辑之外的任何代码，确定其生命周期，并通过`Controller`构造函数使其可用，考虑创建一个工厂，然后通过`Controller`提供工厂。
- en: With the old MVC framework, most of the infrastructure customization was needed
    to provide external services to the controller. This is not required anymore because
    **DI** allows controllers to require any service at any time.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧的MVC框架中，大多数基础设施定制是为了向控制器提供外部服务。这不再需要，因为**DI**允许控制器随时需要任何服务。
- en: A second key step is determining the identity framework infrastructure requirement.
    The new template provides a lot of enhancements, as well as basic support for
    legal *GDPR requirements*. In most cases, it is better to start from the new infrastructure
    and migrate the database, instead of just porting the old code. On NuGet, you
    will find support for many providers, starting from OAuth generic ones to social
    identity providers, OpenID specification providers, and many others. It is also
    possible to leverage the popular open source project **Identity Server**, an identity
    provider that is now part of the .NET Foundation.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个关键步骤是确定身份框架基础设施需求。新模板提供了许多增强功能，以及对法律*GDPR要求*的基本支持。在大多数情况下，最好从新基础设施开始，并迁移数据库，而不仅仅是移植旧代码。在NuGet上，您会发现许多提供程序的支持，从OAuth通用提供程序到社交身份提供程序，OpenID规范提供程序等等。还可以利用流行的开源项目**Identity
    Server**，这是.NET基金会的一部分。
- en: The authorization framework has changed as well and brings two important key
    features. The first is being claim-based. This presents a lot of advantages in
    comparison to the old role-based security (which has several limitations). `Claims`
    can also be used as roles whenever your checks are just Booleans, but they allow
    more complex logic structured as `Policies` inside ASP.NET Core, which is definitely
    worth adopting.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 授权框架也发生了变化，并带来了两个重要的关键功能。第一个是基于声明的。与旧的基于角色的安全性相比，这带来了许多优势（它有一些限制）。 `Claims`也可以用作角色，每当您的检查只是布尔值时，但它们允许更复杂的逻辑结构化为ASP.NET
    Core中的`Policies`，这绝对值得采用。
- en: Once all the infrastructure has been ported or converted, the application logic
    can finally be moved to the new controllers. As we mentioned previously, there
    is now a single `Controller` base class that is used for both MVC and Web API
    controllers. Matching a controller from a request is done via the routing mechanism.
    In ASP.NET Core, the routing is configured through attributes in your `Controller`
    class.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有基础设施都已移植或转换，应用程序逻辑最终可以移至新的控制器。正如我们之前提到的，现在有一个单一的`Controller`基类，用于MVC和Web
    API控制器。通过路由机制匹配请求的控制器。在ASP.NET Core中，路由是通过`Controller`类中的属性进行配置的。
- en: Every controller may expose one or more `Actions` that can be tagged with the
    attributes defining the HTTP verbs they are restricted to, such as `HttpGet` and
    `HttpPost`. Actions related to the HTTP `GET` verb do not take any input parameters,
    while other verbs such as `POST` and `PUT` can benefit from the *model-binding*
    feature, which automatically maps the values passed by the requests to the input
    parameters. You can find more information about model binding in the official
    documentation at [https://docs.microsoft.com/en-us/aspnet/core/mvc/models/model-binding](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/model-binding).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 每个控制器可能公开一个或多个“操作”，可以使用定义它们所限制的HTTP动词的属性进行标记，例如`HttpGet`和`HttpPost`。与HTTP“GET”动词相关的操作不接受任何输入参数，而其他动词（如`POST`和`PUT`）可以受益于*模型绑定*功能，该功能会自动将请求传递的值映射到输入参数。您可以在官方文档[https://docs.microsoft.com/en-us/aspnet/core/mvc/models/model-binding](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/model-binding)中找到有关模型绑定的更多信息。
- en: 'The response of the HTTP roundtrip depends, of course, on its HTTP verb. The
    typical return types for actions are as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP往返的响应当然取决于其HTTP动词。操作的典型返回类型如下：
- en: An object representing the response value to return to the HTTP client. It will
    be serialized by the infrastructure according to the types specified by the client
    in the accept header.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表要返回给HTTP客户端的响应值的对象。它将根据客户端在接受标头中指定的类型进行基础设施序列化。
- en: A `Task<T>`, where `T` is the response value specified in the preceding. Tasks
    should be used whenever the content retrieval requires some "slow" access, such
    as accessing the filesystem or a database.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task<T>`，其中`T`是前述中指定的响应值。每当内容检索需要一些“慢速”访问时，例如访问文件系统或数据库时，应使用任务。'
- en: An object implementing `IActionResult`, such as `OkResult` and `NotFoundResult`
    created by the homonymous method name in the `ControllerBase` class, which is
    the base class for any Controller. They are used to give full control over the
    status code and the response headers. The full list of ready-to-use `IActionResult`
    types is defined in the `Microsoft.AspNetCore.MVC` namespace. Some of these objects
    have a constructor that take the object to return, such as `OkObjectResult`, which
    returns an object as content and sets the HTTP status code to 200.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`IActionResult`的对象，例如由`ControllerBase`类中同名方法创建的`OkResult`和`NotFoundResult`，该类是任何控制器的基类。它们用于完全控制状态代码和响应标头。准备好使用的`IActionResult`类型的完整列表在`Microsoft.AspNetCore.MVC`命名空间中定义。其中一些对象具有构造函数，接受要返回的对象，例如`OkObjectResult`，它将对象作为内容返回，并将HTTP状态代码设置为200。
- en: An object implementing `Task<IActionResult>`, which is the asynchronous version
    of the previous case.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`Task<IActionResult>`的对象，这是前一种情况的异步版本。
- en: The last case is returning `void`, which lets the infrastructure return the
    default response with no content at all.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一种情况是返回`void`，这样基础设施将返回没有任何内容的默认响应。
- en: Once the code has been migrated, you have to consider the hosting environment.
    The web server for ASP.NET Core applications is called `web.config` file should
    be revised either in the new `appsettings.json` configuration file or directly
    in the code for Kestrel configurations in the `Program.cs` file.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码已经迁移，您必须考虑托管环境。ASP.NET Core应用程序的Web服务器称为`web.config`文件，应该在新的`appsettings.json`配置文件中进行修订，或者直接在`Program.cs`文件中进行Kestrel配置的代码中进行修订。
- en: Be advised that using IIS is still possible, but this can only be used as a
    reverse proxy and requires the use of the official ASP.NET Core IIS Module, which
    forwards all the HTTP traffic to and from the Kestrel web server.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，仍然可以使用IIS，但这只能用作反向代理，并且需要使用官方的ASP.NET Core IIS模块，该模块将所有HTTP流量转发到Kestrel
    Web服务器。
- en: This solution brings an excellent, improved, and cross-platform solution to
    ASP.NET Core, but if you still want to host the project on IIS, it is definitely
    possible by installing the official **ASP.NET Core IIS Module** on the hosting
    server. The module will forward all the HTTP requests and responses to the Kestrel
    web server, so most of the settings in IIS can be safely ignored.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案为ASP.NET Core带来了一个出色的、改进的、跨平台的解决方案，但如果您仍然希望在IIS上托管项目，通过在托管服务器上安装官方的**ASP.NET
    Core IIS模块**，这是完全可能的。该模块将所有HTTP请求和响应转发到Kestrel Web服务器，因此IIS中的大多数设置都可以安全地忽略。
- en: Summing up the migration steps
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结迁移步骤
- en: 'Planning a migration is certainly not always easy, but there is a clear path
    that can be applied to any group of projects. Some of the following steps may
    be harder or easier, depending on the technology they were implemented on, while
    some others are pretty straightforward and only require practicing in advance,
    but the number of available APIs make the process far easier starting from .NET
    Core version 3\. The rough steps to migrate an application are as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 规划迁移肯定并不总是容易的，但有一条明确的路径可以应用于任何一组项目。以下一些步骤可能更难或更容易，这取决于它们所实施的技术，而其他一些步骤非常直接，只需要提前练习，但从.NET
    Core版本3开始，可用的API数量使得整个过程变得更加容易。迁移应用程序的大致步骤如下：
- en: Ensure you are using the technologies available in .NET Core. You may want to
    consider a replacement when they are not but analyze the implications on the application
    architecture carefully.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您正在使用.NET Core中可用的技术。当它们不可用时，您可能需要考虑进行替换，但要仔细分析对应用程序架构的影响。
- en: Once you've decided to start the migration, upgrade all of your projects to
    the latest .NET Framework as a very first step.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦决定开始迁移，首先将所有项目升级到最新的.NET Framework。
- en: Ensure all the third-party dependencies are available as .NET Standard and migrate
    your current .NET Framework projects to use them.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保所有第三方依赖项都可用作.NET Standard，并将您当前的.NET Framework项目迁移到使用它们。
- en: Analyze your projects using the Portability Analyzer Tool or verify the availability
    of the APIs at https://apisof.net/.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用可移植性分析器工具分析您的项目，或验证API的可用性https://apisof.net/。
- en: Every time you migrate a single .NET Framework library project to .NET Standard,
    the application can be potentially merged back on the main branch and be deployed
    in production.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次将单个.NET Framework库项目迁移到.NET Standard时，应用程序都有可能合并回主分支并部署到生产环境。
- en: Migrate the projects by navigating the dependency tree from the ones with no
    dependencies, going all the way up to the applications referencing the ones that
    have already been migrated.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从没有依赖关系的项目开始导航依赖树，一直到引用已经迁移的项目的应用程序，来迁移项目。
- en: At first glance, migration can look a bit scary, but there are many advantages
    that you will appreciate as soon as the application starts running on.NET Core.
    Among them, the deployment offers new, exciting, and powerful features, which
    we are going to discuss in the next section.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，迁移可能看起来有点可怕，但一旦应用程序开始在.NET Core上运行，您将会欣赏到许多优势。其中，部署提供了新的、令人兴奋的、强大的功能，我们将在下一节中讨论。
- en: Publishing an application
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布应用程序
- en: "The last essential step for making an application usable outside the developer\
    \ \Lmachine is **publishing**. There are two kinds of deployment: framework-dependent\
    \ and self-contained."
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使应用程序在开发者机器之外可用的最后一个关键步骤是**发布**。有两种部署方式：依赖框架和自包含。
- en: '**Framework-dependent deployment (FDD)** creates a folder with all the required
    binaries needed to run the application on any computer with the same OS and the
    .NET runtime installed. FDD deployment has several advantages:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**Framework-dependent deployment (FDD)**会创建一个包含在任何安装了相同操作系统和.NET运行时的计算机上运行应用程序所需的所有必需二进制文件的文件夹。FDD部署有几个优点：'
- en: It lowers the size of the deployment folder.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这降低了部署文件夹的大小。
- en: It makes the security updates easy to install by an IT manager instead of the
    need to redeploy them.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得安全更新易于由IT管理员安装，而无需重新部署它们。
- en: When deploying in Docker containers, you can start from pre-built images already
    containing the .NET runtime for the version you need.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker容器中部署时，您可以从预先构建的镜像开始，这些镜像已经包含您所需的.NET运行时版本。
- en: The other publishing option is **self-contained deployment (SCD)**, which creates/copies
    all the required files to run the application, including the runtime and all the
    base class libraries. The main advantage of SCD is that it gets rid of any requirements
    on the hosting target, enabling scenarios where you can run the application just
    by copying the folder.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个发布选项是**自包含部署（SCD）**，它会创建/复制运行应用程序所需的所有文件，包括运行时和所有基类库。SCD的主要优势在于它消除了对托管目标的任何要求，使得您可以通过复制文件夹来运行应用程序。
- en: Tip
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: On Linux, some basic libraries may be needed on certain distributions that are
    very constrained. On the [https://dot](https://dot.net/).net, you can find updated
    information about those requirements.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，某些基本库可能需要在某些非常受限制的发行版上。在[https://dot](https://dot.net/)上，您可以找到关于这些要求的更新信息。
- en: 'On the other hand, the self-contained deployment scenario also has some drawbacks:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，自包含部署方案也有一些缺点：
- en: The application must be published for a specific OS and CPU architecture.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序必须发布到特定的操作系统和CPU架构。
- en: You should promptly respond to security bulletins every time the .NET Core runtime
    gets any security update. In this case, after applying the updates to the developer
    machine, you will have to rebuild and redeploy the application.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次.NET Core运行时获得安全更新时，您都应立即响应安全公告。在这种情况下，在将更新应用到开发者机器后，您将不得不重新构建和部署应用程序。
- en: The total deployment size is much larger.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总部署大小要大得多。
- en: Starting from .NET Core 2.2, the FDD produces automatically executable files
    instead of just `.dll` files for the main projects, while in the past, FDD applications
    needed to be run through the `dotnet run` command. Now, they are created as executables
    and also known as **Framework Dependent Executables (FDE)**, which is the default
    when publishing an application using the .NET Core 3 **SDK**.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 从.NET Core 2.2开始，FDD会自动生成可执行文件，而不仅仅是主项目的`.dll`文件，而在过去，FDD应用程序需要通过`dotnet run`命令运行。现在，它们被创建为可执行文件，也被称为**Framework
    Dependent Executables (FDE)**，这是使用.NET Core 3 **SDK**发布应用程序时的默认设置。
- en: Publishing as an FDD
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为FDD发布
- en: 'If you want to keep the deployment size compact, just make sure your version
    of choice for the .NET Core runtime is installed on the target machine and that
    you publish the application as an **FDD**. Publishing an application as an **FDD**
    from the command line is straightforward; first, you enter the project folder
    and then type the following command:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望保持部署大小紧凑，只需确保目标机器上安装了您选择的.NET Core运行时版本，并将应用程序发布为**FDD**。从命令行发布应用程序作为**FDD**很简单；首先，进入项目文件夹，然后输入以下命令：
- en: '[PRE19]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The CLI will build and publish the project, also printing the path of the publishing
    folder on the screen:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: CLI将构建和发布项目，并在屏幕上打印发布文件夹的路径：
- en: '[PRE20]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The target folder can be changed by appending the `-o` argument to the previous
    command:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在上一个命令中添加`-o`参数来更改目标文件夹：
- en: '[PRE21]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this case, the output folder will be as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出文件夹将如下所示：
- en: '[PRE22]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The publishing command can also specify the requested runtime accepting a **Runtime
    Identifier (RID)** ([https://docs.microsoft.com/en-us/dotnet/core/rid-catalog](https://docs.microsoft.com/en-us/dotnet/core/rid-catalog)).
    For example, publishing the application for Linux on the 64-bit architecture is
    done with the following command:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 发布命令还可以指定所请求的运行时，接受**Runtime Identifier (RID)**（[https://docs.microsoft.com/en-us/dotnet/core/rid-catalog](https://docs.microsoft.com/en-us/dotnet/core/rid-catalog)）。例如，使用以下命令在64位架构的Linux上发布应用程序：
- en: '[PRE23]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Unless you also specify the output folder, this will reflect the specified
    RID:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您还指定了输出文件夹，否则这将反映指定的RID：
- en: '[PRE24]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `--no-self-contained` argument is needed because, by default, the application
    is published as self-contained if a runtime identifier is specified.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 需要`--no-self-contained`参数，因为默认情况下，如果指定了运行时标识符，应用程序将作为自包含发布。
- en: Publishing as an SCD
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为SCD发布
- en: Using SCD means getting rid of any installed runtime dependencies. For this
    reason, when you decide to publish as an SCD, you also have to specify the runtime
    identifier (the target OS and CPU architecture) so that all the required runtime
    dependencies are published together with the application.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SCD意味着摆脱任何已安装的运行时依赖关系。因此，当您决定以SCD方式发布时，还必须指定运行时标识符（目标操作系统和CPU架构），以便所有必需的运行时依赖项与应用程序一起发布。
- en: 'Publishing as an SCD just requires adding the `--self-contained` and `-r` option
    followed by the runtime identifier. The shorter version is just specifying the
    `-r` option as, by default, this turns on the self-contained options as well.
    For example, publishing a self-contained application for the 64-bit version of
    Windows is done with the following command:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 作为SCD发布只需要添加`--self-contained`和`-r`选项，后面跟着运行时标识符。较短的版本只需指定`-r`选项，因为默认情况下，这也会打开自包含选项。例如，为Windows的64位版本发布自包含应用程序的命令如下：
- en: '[PRE25]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output folder, in this case, will be as follows, as specified by the output
    messages of the command line:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出文件夹将如下所示，由命令行的输出消息指定：
- en: '[PRE26]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Whether you'll depend on the runtime installation or not is just one of the
    options when publishing. Now, we will examine other interesting possibilities.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布时，是否依赖于运行时安装只是其中一个选项。现在，我们将研究其他有趣的可能性。
- en: Understanding other publishing options
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解其他发布选项
- en: Starting from .NET Core 3, it is possible to specify a number of interesting
    options when publishing. These options can be either specified on the command
    line or even forced inside the `.csproj` file, making them the default for the
    project inside the `PropertyGroup` tag.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 从.NET Core 3开始，可以在发布时指定许多有趣的选项。这些选项可以在命令行上指定，甚至可以在`.csproj`文件中强制执行，使其成为`PropertyGroup`标签内项目的默认选项。
- en: Single-file publishing
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单文件发布
- en: Publishing as a single file is a very convenient feature that creates a single
    file for all of the project files. Having a single executable enables the possibility
    of moving the application easily through a USB key or as a download. The only
    files that cannot be embedded in the executable are the configuration files and
    the web static files (for example, HTML).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序发布为单个文件是一个非常方便的功能，它为所有项目文件创建一个单个文件。拥有一个单独的可执行文件使得可以通过USB键或下载轻松移动应用程序。唯一无法嵌入可执行文件的文件是配置文件和Web静态文件（例如HTML）。
- en: 'The following is the command line that''s used to publish the application as
    a single file. Single-file publishing is compatible with FDD; in this case, you
    can append `–-no-self-contained` to the command line:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于将应用程序发布为单个文件的命令行。单文件发布与FDD兼容；在这种情况下，您可以在命令行中附加`--no-self-contained`：
- en: '[PRE27]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alternatively, you can turn on the single-file publishing option in the `.csproj`
    file:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在`.csproj`文件中打开单文件发布选项：
- en: '[PRE28]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You will immediately notice the size of the binary as particularly large because
    it contains all the dependent code, even the portions of the assemblies that you
    didn't need. What if we can get rid of all the unused methods, properties, or
    classes from inside our references? The solution comes from **IL trimming**.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 您会立即注意到二进制文件的大小特别大，因为它包含所有的依赖代码，甚至是您不需要的程序集部分。如果我们可以摆脱所有未使用的方法、属性或类，那该多好啊？解决方案来自**IL修剪**。
- en: IL trimming
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IL修剪
- en: Trimming is the ability to remove all the unused code from the deployment binary.
    This feature comes from the **Mono** **IL Linker** code base. This setting requires
    the deployment to be self-contained, which, in turn, requires the runtime identifier
    to be specified.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 修剪是从部署二进制文件中删除所有未使用代码的能力。这个功能来自**Mono** **IL链接器**代码库。此设置要求部署为自包含，这又要求指定运行时标识符。
- en: 'The **PublishTrimmed** factory can be turned on when publishing on the command
    line:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上发布时，可以打开**PublishTrimmed**工厂：
- en: '[PRE29]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Otherwise, it can be specified in the **csproj** file:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，可以在**csproj**文件中指定：
- en: '[PRE30]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When heavily using reflection, the trimmer loses the ability to understand which
    libraries and members are needed. For example, if you dynamically compose the
    member name, the trimmer can't know the members to keep or discard. In this case,
    there are other two options, `TrimmerRootAssembly` and `TrimmerRootDescription`,
    that can be used to specify the code that should not be trimmed away.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当大量使用反射时，修剪器失去了理解哪些库和成员是必需的能力。例如，如果动态组合成员名称，修剪器无法知道要保留还是丢弃的成员。在这种情况下，还有另外两个选项，`TrimmerRootAssembly`和`TrimmerRootDescription`，可以用来指定不应被修剪的代码。
- en: Ahead-of-Time (AOT) compilation
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提前编译（AOT）编译
- en: 'AOT compilation allows us to precompile the application by generating almost
    all the native CPU assembly code on the developer machine. If you have never heard
    of the **ngen** tool in .NET Framework, it was used to generate the native assembly
    code on the target machine, making the application bootstrap performance much
    faster, as the **Just-in-Time** (**JIT**) compiler was no longer needed. The AOT
    compiler has the same goal but uses a different strategy: in fact, the compilation
    is done on the developer machine and because of this, the quality of the generated
    code is lower. This is because the compiler cannot make assumptions on the CPU
    that will run the code.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: AOT编译允许我们通过在开发者机器上生成几乎所有本机CPU汇编代码来预编译应用程序。如果你从未听说过.NET Framework中的**ngen**工具，它是用于在目标机器上生成本机汇编代码的，使应用程序的引导性能更快，因为不再需要**即时**（**JIT**）编译器。AOT编译器具有相同的目标，但使用不同的策略：实际上，编译是在开发者机器上完成的，因此生成的代码质量较低。这是因为编译器无法对将运行代码的CPU做出假设。
- en: In order to balance the lower-quality code, .NET Core 3 enables **TieredCompilation**
    by default. Whenever an application method is called more than 30 times, it is
    considered "hot" and scheduled on a remote thread to be recompiled from the **JIT
    compiler**, thereby providing better performance.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了平衡较低质量的代码，.NET Core 3默认启用了**TieredCompilation**。每当一个应用程序方法被调用超过30次时，它被视为“热点”，并安排在远程线程上重新从**JIT编译器**进行重新编译，从而提供更好的性能。
- en: 'The **AOT** compilation can be enabled when publishing from the command line,
    as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布时，可以通过以下命令行启用**AOT**编译：
- en: '[PRE31]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Alternatively, you can modify the `.csproj` file to make this setting persistent:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以修改`.csproj`文件以使此设置持久化：
- en: '[PRE32]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The AOT compilation provides a better startup, but also requires specifying
    the runtime identifier, which means compiling for a specific OS and CPU architecture.
    This setting wipes out the advantage of IL code being deployed on multiple platforms.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: AOT编译提供了更好的启动，但也需要指定运行时标识符，这意味着为特定的操作系统和CPU架构进行编译。这种设置消除了IL代码部署在多个平台上的优势。
- en: Quick JIT
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速JIT
- en: Every time you are worried about the need to pre-generate the native compilation
    but still need to provide a fast application bootstrap, you can enable **QuickJIT**,
    a faster **JIT** compiler that has the downside of producing less performant code.
    Once again, the tiered compilation balances the code-quality disadvantages and
    recompiles the code as soon it qualifies as a hot path.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您担心需要预生成本机编译，但仍需要提供快速的应用程序引导时，您可以启用**QuickJIT**，这是一个更快的**JIT**编译器，缺点是生成的代码性能较差。再次，分层编译平衡了代码质量的缺点，并在其符合热路径条件时重新编译代码。
- en: 'Enabling Quick JIT from the command line is no different than the other options:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行启用Quick JIT与其他选项没有区别：
- en: '[PRE33]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Enabling Quick JIT in the **csproj** file is similar as well:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在**csproj**文件中启用Quick JIT也是类似的：
- en: '[PRE34]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It is important to observe that the calls to external libraries cannot be compiled
    in native code by the AOT compiler as the libraries may be replaced with newer
    versions in the target machine, invalidating the generated code. Every time some
    code cannot be compiled as native, it will be compiled with the **JIT** on the
    target machine. For this reason, it totally makes sense to enable **AOT** and
    **QuickJIT** together.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，AOT编译器无法将对外部库的调用编译为目标机器上的本机代码，因为库可能会被新版本替换，从而使生成的代码失效。每当有些代码无法编译为本机代码时，它将在目标机器上使用**JIT**进行编译。因此，完全有意义同时启用**AOT**和**QuickJIT**。
- en: Tip
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The **ngen** compiler of .NET Framework is able to generate the assembly code
    for all the IL in the assemblies, but as soon as any dependent assembly is replaced,
    all the native code is invalidated, requiring the JIT to compile all the code.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework的**ngen**编译器能够为程序集中的所有IL生成汇编代码，但一旦任何依赖的程序集被替换，所有本机代码都将失效，需要JIT重新编译所有代码。
- en: Whether your application needs to be self-contained, single-file, or precompiled,
    there is a multitude of deployment options that .NET Core offers to make your
    application shine in every scenario, and you can now pick the one you prefer.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您的应用程序需要自包含、单文件还是预编译，.NET Core都提供了多种部署选项，使您的应用程序在各种情况下都能发光，现在您可以选择您喜欢的选项。
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we went through all the fundamental steps to follow in order
    to build a new application using the .NET Core runtime, which is accompanied by
    an increased number of APIs. We started by looking at the new powerful command
    line that offers all the commands that can be used to control the development
    life cycle of the application. The command-line extensibility removes any limitations,
    allowing anyone to add local and global tools to the ecosystem.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们经历了构建使用.NET Core运行时的新应用程序所需遵循的所有基本步骤，该运行时伴随着增加的API数量。我们首先看了一下新的强大的命令行，它提供了控制应用程序开发生命周期的所有命令。命令行的可扩展性消除了任何限制，允许任何人向生态系统中添加本地和全局工具。
- en: We have also seen how the command-line commands are exactly the same when developing
    on Linux OSes, which can be used as a developer box directly or through Windows,
    as you please. In fact, the Visual Studio Code remote extensions let you develop
    and debug the code on a Linux machine from Windows.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了当在Linux操作系统上开发时，命令行命令与在Windows上开发时完全相同，可以直接或通过Windows使用作为开发工具。事实上，Visual
    Studio Code远程扩展允许您从Windows在Linux机器上开发和调试代码。
- en: But we also saw that .NET Core 3 is not a one-way trip, because .NET Standard
    libraries allow us to share code with all the recent runtimes, making it easier
    to reuse the code. In addition to that, the very rich ecosystem of NuGet packages
    makes consuming libraries straightforward.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也看到，.NET Core 3并不是单向旅程，因为.NET标准库使我们能够与所有最新的运行时共享代码，使代码重用变得更加容易。除此之外，NuGet包的非常丰富的生态系统使得消费库变得简单直接。
- en: 'Adopting the new runtime is not that hard: some applications can be migrated
    by just converting the project file, while others require more coding, but the
    resulting application will benefit from the new ecosystem.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 采用新的运行时并不难：一些应用程序可以通过简单地转换项目文件来迁移，而其他应用程序则需要更多的编码，但最终的应用程序将受益于新的生态系统。
- en: In the last section, we examined the complete set of possibilities when publishing
    an application, which is the culmination of the application development process.
    At this point, you are able to transform ideas and algorithms into a running application,
    possibly running on the most popular OSes.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们研究了发布应用程序时的完整可能性，这是应用程序开发过程的顶点。在这一点上，您可以将想法和算法转化为运行中的应用程序，可能在最流行的操作系统上运行。
- en: In the next chapter, we will talk about unit testing, a practice that is extremely
    important for guaranteeing code quality across time and providing proof that future
    development iterations will not introduce breaking changes or regressions.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论单元测试，这是非常重要的实践，可以保证代码质量并提供证据，证明未来的开发迭代不会引入破坏性变化或退化。
- en: Test what you learned
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你所学到的东西
- en: After installing five different SDKs, how can you tell the CLI to use a specific
    version for an entire solution?
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装了五个不同的SDK后，如何告诉CLI在整个解决方案中使用特定版本？
- en: How can you concatenate some paths so that they work correctly on both Windows
    and Linux?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将一些路径连接起来，以便它们在Windows和Linux上都能正确工作？
- en: How can you share some code among three different applications based on .NET
    Framework, .NET Core 3, and Xamarin?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在基于.NET Framework、.NET Core 3和Xamarin的三个不同应用程序之间共享一些代码？
- en: What is the fastest method for a new library project to add the exact same references
    to an existing one?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新的库项目添加与现有项目完全相同的引用的最快方法是什么？
- en: When migrating a complex solution, where should we start?
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在迁移复杂解决方案时，我们应该从哪里开始？
- en: What deployment options guarantee faster application startup time?
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些部署选项可以保证更快的应用程序启动时间？
- en: Further reading
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The Visual Studio Code extensions to compile and debug a project on a remote
    Linux or WSL session, can be found at the following links:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code扩展可以在远程Linux或WSL会话上编译和调试项目，可以在以下链接找到：
- en: '[https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh)'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh)'
- en: '[https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl)'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl)'
- en: 'The ability to create NuGet packages containing multiple binaries, each of
    them targeting a different CPU architecture or framework version is described
    at the following link: [https://docs.microsoft.com/en-us/nuget/create-packages/supporting-multiple-target-frameworks](https://docs.microsoft.com/en-us/nuget/create-packages/supporting-multiple-target-frameworks).'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 描述了创建包含多个二进制文件的NuGet包的能力，每个二进制文件都针对不同的CPU架构或框架版本，可以在以下链接找到：[https://docs.microsoft.com/en-us/nuget/create-packages/supporting-multiple-target-frameworks](https://docs.microsoft.com/en-us/nuget/create-packages/supporting-multiple-target-frameworks)。
