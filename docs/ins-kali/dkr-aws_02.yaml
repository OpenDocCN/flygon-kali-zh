- en: Building Applications Using Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker构建应用程序
- en: In the previous chapter, you were introduced to the sample application, and
    you were able to download and run the application locally. At present, your development
    environment is set up for local development; however, before you can get your
    application to production, you need to be able to package up your application
    and all of its dependencies, ensure the target production environment has the
    correct supporting operating system libraries and configuration, select an appropriate
    web server to host your application, and have a mechanism to be able to package
    this all together, ideally in a self-contained artifact that requires minimal
    external configuration. Traditionally, all of this has been very difficult to
    achieve reliably and consistently – but this is where Docker has changed the landscape
    dramatically. With Docker and supporting tools, you now have the ability to achieve
    all of this and more in a much faster, more reliable, more consistent, and more
    portable fashion than ever before.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您已经介绍了示例应用程序，并且能够下载并在本地运行该应用程序。目前，您的开发环境已经设置好用于本地开发；但是，在将应用程序部署到生产环境之前，您需要能够打包应用程序及其所有依赖项，确保目标生产环境具有正确的操作系统支持库和配置，选择适当的Web服务器来托管您的应用程序，并且有一种机制能够将所有这些内容打包在一起，最好是一个自包含的构件，需要最少的外部配置。传统上，要可靠和一致地实现所有这些内容非常困难，但是Docker已经极大地改变了这一局面。通过Docker和支持工具，您现在有能力以比以往更快、更可靠、更一致和更可移植的方式实现所有这些内容以及更多。
- en: In this chapter, you will learn how to create a comprehensive workflow that
    allows you to test, build, and publish your applications in a portable, repeatable,
    and consistent manner using Docker. The approach you will learn about has numerous
    benefits—for example, you will be able to perform all tasks by running a handful
    of simple, easy-to-remember commands, and you will be able to do so without needing
    to install any application-specific or operating-system-specific dependencies
    into your local development or build environment. This makes it very easy to move
    to another machine or configure a continuous-delivery service to perform the same
    workflow—as long as you have the core Docker-based environment you set up in the
    previous chapter, you will be able to run the workflow on any machine, regardless
    of the specifics of your application or programming language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用Docker创建一个全面的工作流程，使您能够以可移植、可重复和一致的方式测试、构建和发布应用程序。您将学习的方法有许多好处，例如，您将能够通过运行几个简单、易于记忆的命令来执行所有任务，并且无需在本地开发或构建环境中安装任何特定于应用程序或操作系统的依赖项。这使得在另一台机器上移动或配置连续交付服务来执行相同的工作流程非常容易——只要您在上一章中设置的核心基于Docker的环境，您就能够在任何机器上运行工作流程，而不受应用程序或编程语言的具体细节的影响。
- en: You will learn how to define test and runtime environments for your application
    using a Dockerfile, configuring support for multi-stage builds that allow you
    to build application artifacts in an image that has all development tools and
    libraries available, and then copy those artifacts to other stages of your Dockerfile.
    You will leverage Docker Compose as a tool to orchestrate complex Docker environments
    with multiple containers, which allows you to test integration scenarios, such
    as your application interacting with a database, and also mimic how you would
    run your application in production environments.  An important concept that will
    be introduced is the concept of building a release image, which is a production-ready
    image that can be shipped to production, assuming any new application features
    and functionality work as expected. You will build and run this release image
    in your local Docker environment, connect your application to a database, and
    then create acceptance tests that verify the application works as expected, from
    the perspective of an external client connecting to your application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习如何使用Dockerfile为应用程序定义测试和运行时环境，配置支持多阶段构建，允许您在具有所有开发工具和库的镜像中构建应用程序构件，然后将这些构件复制到Dockerfile的其他阶段。您将利用Docker
    Compose作为一个工具来编排具有多个容器的复杂Docker环境，这使您能够测试集成场景，例如您的应用程序与数据库的交互，并模拟您在生产环境中运行应用程序的方式。一个重要的概念是引入构建发布镜像的概念，这是一个可以被部署到生产环境的生产就绪镜像，假设任何新的应用程序特性和功能都能正常工作。您将在本地Docker环境中构建和运行此发布镜像，将您的应用程序连接到数据库，然后创建验收测试，验证应用程序从外部客户端连接到您的应用程序的角度来看是否正常工作。
- en: Finally, you will bring all you have learned together using GNU Make to automate
    your workflow. Once finished, you will be able to run unit tests and build application
    artifacts by simply running `make test`, and then build your release image, start
    up a production-like environment, and run acceptance tests by running `make release`. 
    This will make it very simple to test and publish new application changes with
    confidence as they are developed, using a portable and consistent workflow that
    can be easily run in a local development environment and in any continuous-delivery
    environment that supports Docker and Docker Compose.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将使用GNU Make将学到的所有知识整合起来，自动化您的工作流程。完成后，您只需运行`make test`即可运行单元测试和构建应用程序构件，然后构建您的发布镜像，启动类似生产环境的环境，并通过运行`make
    release`运行验收测试。这将使测试和发布新的应用程序更改变得非常简单，并且可以放心地使用便携和一致的工作流在本地开发环境和任何支持Docker和Docker
    Compose的持续交付环境中运行。
- en: 'The following topics will be covered:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 将涵盖以下主题：
- en: Testing and building applications using Docker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker测试和构建应用程序
- en: Creating multi-stage builds
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多阶段构建
- en: Creating a test stage to build and test application artifacts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个测试阶段来构建和测试应用程序构件
- en: Creating a release stage to build and test a release image
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个发布阶段来构建和测试发布镜像
- en: Using Docker Compose to test and build applications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker Compose测试和构建应用程序
- en: Creating acceptance tests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建验收测试
- en: Automating the workflow
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化工作流程
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following lists the technical requirements to complete this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了完成本章所需的技术要求：
- en: Prerequisite software installed as per instructions in Chapter 1
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据第1章的说明安装先决软件
- en: GitHub account created as per instructions in Chapter 1
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据第1章的说明创建GitHub帐户
- en: The following GitHub URL contains the code samples used in this chapter: [https://github.com/docker-in-aws/docker-in-aws/tree/master/ch2](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch2)[.](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch3)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下GitHub网址包含本章中使用的代码示例：[https://github.com/docker-in-aws/docker-in-aws/tree/master/ch2](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch2)[.](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch3)
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的运行情况：
- en: '[http://bit.ly/2PJG2Zm](http://bit.ly/2PJG2Zm)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2PJG2Zm](http://bit.ly/2PJG2Zm)'
- en: Testing and building the application using Docker
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker测试和构建应用程序
- en: In the previous chapter, you gained a good understanding of what the sample
    application is, and how to test and run the application in your local development
    environment. You are now ready to start creating a Docker workflow that will test,
    build, and package your application into a Docker image.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您对示例应用程序是什么以及如何在本地开发环境中测试和运行应用程序有了很好的理解。现在，您已经准备好开始创建一个Docker工作流程，用于测试、构建和打包应用程序成为一个Docker镜像。
- en: It is important to understand that whenever you are packaging an application
    into a Docker image, the best-practice approach is to reduce or eliminate all
    development and test dependencies from your final packaged application. By my
    own convention, I refer to this packaged application—free of test and development
    dependencies—as a *release image, *which supports the paradigm of continuous delivery,
    where every successful build should be a release candidate that is able to be
    published to production if required.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，每当您将一个应用程序打包成一个Docker镜像时，最佳实践是减少或消除所有开发和测试依赖项，使其成为最终打包的应用程序。按照我的约定，我将这个打包的应用程序——不包含测试和开发依赖项——称为*发布镜像*，支持持续交付的范式，即每次成功构建都应该是一个发布候选，可以在需要时发布到生产环境。
- en: 'To achieve this goal of creating a release image, an approach that works well
    is to split the Docker build process into two stages:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现创建发布镜像的目标，一个行之有效的方法是将Docker构建过程分为两个阶段：
- en: '**Test stage**: This stage has all the test and development dependencies available
    to compile and build your application source into an application artifact, and
    run unit and integration tests.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试阶段**：该阶段具有所有测试和开发依赖项，可用于编译和构建应用程序源代码成应用程序构件，并运行单元测试和集成测试。'
- en: '**Release stage**: This stage copies the tested and built application artifact(s)
    from the test stage into a minimalistic runtime environment configured appropriately
    for running the application in production.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布阶段**：该阶段将经过测试和构建的应用程序构件从测试阶段复制到一个最小化的运行时环境中，该环境已适当配置以在生产环境中运行应用程序。'
- en: Docker natively supports such an approach using a feature called multi-stage
    builds, and this is the approach we will adopt in this book. For now, we will
    focus on the test stage, and move on to the release stage in the next section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Docker原生支持这种方法，使用一个名为多阶段构建的功能，这是我们将在本书中采用的方法。现在，我们将专注于测试阶段，并在下一节转移到发布阶段。
- en: Creating a test stage
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个测试阶段
- en: 'We will get started by creating a `Dockerfile` at the root of the `todobackend` repository,
    meaning your repository structure should look something like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在`todobackend`存储库的根目录创建一个`Dockerfile`开始，这意味着您的存储库结构应该看起来像这样：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s now define a couple of directives in the newly created Dockerfile:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在新创建的Dockerfile中定义一些指令：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `FROM` directive is the first directive you define in a Dockerfile, and
    note that we are using the Alpine Linux distribution as the base image. Alpine
    Linux is a minimalistic distribution that has a much smaller footprint than the
    more traditional Linux distributions, such as Ubuntu and CentOS, and has become
    very popular in the container world since Docker adopted Alpine as the distribution
    of choice for official Docker images.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM`指令是您在Dockerfile中定义的第一个指令，注意我们使用Alpine Linux发行版作为基础镜像。Alpine Linux是一个极简的发行版，比传统的Linux发行版（如Ubuntu和CentOS）的占用空间要小得多，并且自从Docker采用Alpine作为官方Docker镜像的首选发行版以来，在容器世界中变得非常流行。'
- en: One keyword you may not have come across is the `AS` keyword, which is appended
    to the `FROM` directive, which configures the Dockerfile as a [multi-stage build](https://docs.docker.com/develop/develop-images/multistage-build/)
    and names the current stage as `test`. When you have a multi-stage build, you
    can include multiple `FROM` directives, with each stage defined as including the
    current `FROM` directive and subsequent directives, up until the next `FROM` directive.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个你可能不熟悉的关键字是`AS`关键字，它附加到`FROM`指令，将Dockerfile配置为[多阶段构建](https://docs.docker.com/develop/develop-images/multistage-build/)，并将当前阶段命名为`test`。当你有一个多阶段构建时，你可以包含多个`FROM`指令，每个阶段都包括当前的`FROM`指令和后续的指令，直到下一个`FROM`指令。
- en: Next, we use the `LABEL` directive to attach a label called `application` with
    a value of `todobackend`, which is useful for being able to identify Docker images
    that support the todobackend application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`LABEL`指令附加一个名为`application`的标签，其值为`todobackend`，这对于能够识别支持todobackend应用程序的Docker镜像非常有用。
- en: Installing system and build dependencies
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装系统和构建依赖
- en: 'We now need to install the various system and build operating system dependencies
    that will support testing and building the application:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要安装各种系统和构建操作系统依赖项，以支持测试和构建应用程序：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding example, we install the following dependencies:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们安装了以下依赖项：
- en: '**Basic utilities**: In Alpine Linux, the package manager is called `apk`,
    and a common pattern used in Docker images is `apk add --no-cache`, which installs
    the referenced packages and ensures the downloaded packages are not cached. We
    install `bash`, which is useful for troubleshooting, and `git`, which is required
    as we will use Git metadata later on to generate application-version tags for
    the Docker release image.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本实用程序：在Alpine Linux中，软件包管理器称为`apk`，在Docker镜像中常用的模式是`apk add --no-cache`，它安装了引用的软件包，并确保下载的软件包不被缓存。我们安装了`bash`，这对故障排除很有用，还有`git`，因为我们将在以后使用Git元数据来为Docker发布镜像生成应用程序版本标签。
- en: '**Build dependencies**: Here we install the various development libraries required
    to build the application.  This includes `gcc`, `python3-dev`, `libffi-dev`, `musl-dev`,
    and `linux-headers` for compiling any Python C extensions and their supporting
    standard libraries, as well as the `mariadb-dev` package, which is required to
    build the MySQL client in the todobackend application. You also install a Python
    package called `wheel` that allows you to build Python *wheels*, which are a precompiled
    and pre-built packaging format that we will use later on.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建依赖：在这里，我们安装了构建应用程序所需的各种开发库。这包括`gcc`，`python3-dev`，`libffi-dev`，`musl-dev`和`linux-headers`，用于编译任何Python
    C扩展及其支持的标准库，以及`mariadb-dev`软件包，这是构建todobackend应用程序中MySQL客户端所需的。您还安装了一个名为`wheel`的Python软件包，它允许您构建Python“wheels”，这是一种预编译和预构建的打包格式，我们以后会用到。
- en: Installing application dependencies
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装应用程序依赖
- en: 'The next step is to install application dependencies, which, as you learned
    in the previous chapter, means installing packages defined in the `src/requirements.txt` and `src/requirements_test.txt` files:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是安装应用程序的依赖项，就像你在上一章中学到的那样，这意味着安装在`src/requirements.txt`和`src/requirements_test.txt`文件中定义的软件包：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You first use the `COPY` directive to copy the `src/requirements.txt` and `src/requirements_test.txt` files
    to a folder in the `/build` container, which you then specify as the working directory
    via the `WORKDIR` directive.   Note that `/src/requirements.txt` is not a physical
    path on your Docker client - it is a path within the Docker *build context,* which
    is a configurable location on your Docker client file system that you specify
    whenever you execute a build.  To ensure all relevant application source code
    files are available for the Docker build process, a common practice is to set
    the root of your application repository as the build context, so in the example
    above `/src/requirements.txt` refers to `<path-to-repository>/src/requirements.txt` on
    your Docker client.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先使用`COPY`指令将`src/requirements.txt`和`src/requirements_test.txt`文件复制到`/build`容器中的一个文件夹中，然后通过`WORKDIR`指令将其指定为工作目录。请注意，`/src/requirements.txt`不是您的Docker客户端上的物理路径
    - 它是Docker *构建上下文*中的路径，这是您在执行构建时指定的Docker客户端文件系统上的可配置位置。为了确保Docker构建过程中所有相关的应用程序源代码文件都可用，一个常见的做法是将应用程序存储库的根目录设置为构建上下文，因此在上面的示例中，`/src/requirements.txt`指的是您的Docker客户端上的`<path-to-repository>/src/requirements.txt`。
- en: Next, you use the `pip3` wheel command to build Python wheels into the `/build` working
    directory for all of the base application and test dependencies, using the `--no-cache-dir` flag
    to avoid bloating our image and the `--no-input` flag to disable prompting for
    user confirmations. Finally, you install the previously built wheels into the
    container using the `pip3 install` command, using the `--no-index` flag to instruct
    pip not to attempt to download any packages from the internet, and instead install
    all packages from the `/build` folder as specified by the `-f` flag.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您使用`pip3` wheel命令将Python wheels构建到`/build`工作目录中，用于所有基本应用程序和测试依赖项，使用`--no-cache-dir`标志来避免膨胀我们的镜像，使用`--no-input`标志来禁用提示用户确认。最后，您使用`pip3
    install`命令将先前构建的wheels安装到容器中，使用`--no-index`标志指示pip不要尝试从互联网下载任何软件包，而是从`/build`文件夹中安装所有软件包，如`-f`标志所指定的那样。
- en: This approach may seem a little strange, however, it is based upon the principle
    that you should only build your application dependencies once as installable packages,
    and then install the built dependencies as required.  Later on, we will install
    the same dependencies into the release image, ensuring that your release image
    accurately reflects the exact set of dependences your application was tested and
    built against.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能看起来有点奇怪，但它基于一个原则，即您应该只构建一次您的应用程序依赖项作为可安装的软件包，然后根据需要安装构建的依赖项。稍后，我们将在发布镜像中安装相同的依赖项，确保您的发布镜像准确反映了您的应用程序经过测试和构建的确切依赖项集。
- en: Copying application source and running tests
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制应用程序源代码并运行测试
- en: 'The final steps in the test stage are to copy the application source into the
    container and add support for running tests:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 测试阶段的最后步骤是将应用程序源代码复制到容器中，并添加支持运行测试的功能：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, you first copy the entire `/src` folder to a folder
    called `/app`, and then change the working directory to `/app`. You might be wondering
    why we didn't just copy all of the application source earlier when we copied the
    requirements files. The answer here is that we are implementing a caching optimization,
    as your requirements files require the building of application dependencies, and
    by building them in a separate, earlier layer, if the requirements files remain
    the same (which they tend to do), Docker can leverage cached versions of the most
    recent layers that were built, rather than having to build and install application
    dependencies each time your image is built.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，您首先将整个`/src`文件夹复制到一个名为`/app`的文件夹中，然后将工作目录更改为`/app`。您可能会想为什么我们在复制需求文件时没有直接复制所有应用程序源代码。答案是，我们正在实施缓存优化，因为您的需求文件需要构建应用程序依赖项，并且通过在一个单独的较早的层中构建它们，如果需求文件保持不变（它们往往会这样做），Docker可以利用最近构建的层的缓存版本，而不必每次构建图像时都构建和安装应用程序依赖项。
- en: Finally, we add the `CMD` directive, which defines the default command that
    will be executed should a container based from this image be created and executed.
    Note that we specify the same `python3 manage.py test` command we used in the
    previous chapter to run our application tests locally.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了`CMD`指令，它定义了应该在基于此镜像创建和执行的容器中执行的默认命令。请注意，我们指定了与上一章中用于在本地运行应用程序测试的`python3
    manage.py test`命令相同的命令。
- en: You might wonder why we didn't just run our tests in the image using the `RUN` directive.
    The answer here is that you may want to collect artifacts as part of the build
    process, such as test reports, which are much easier to copy from a container
    that you spawn from a Docker image, than during the actual image-build process.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想为什么我们不直接使用`RUN`指令在图像中运行测试。答案是，您可能希望在构建过程中收集构件，例如测试报告，这些构件更容易从您从Docker镜像生成的容器中复制，而不是在实际的图像构建过程中。
- en: 'At this point, we have defined the first stage of our Docker build process,
    which will create a ready-to-test self-contained environment complete with the
    required operating-system dependencies, application dependencies and application
    source code. To build the image, you can run the `docker build` command, tagging
    the image with a name of `todobackend-test`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义了Docker构建过程的第一个阶段，它将创建一个准备好进行测试的自包含环境，其中包括所需的操作系统依赖项、应用程序依赖项和应用程序源代码。要构建图像，您可以运行`docker
    build`命令，并使用名称`todobackend-test`对图像进行标记。
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding example, the `--target` flag allows you to target a specific
    stage in a multi-stage Dockerfile.  Although we only have a single stage at the
    moment, this flag allows us to build only the test stage in the event we have
    multiple stages in the Dockerfile. By convention, the `docker build` command looks
    for a `Dockerfile` file in the directory where you run the command, and the period
    at the end of the command specifies the current directory (i.e. the application
    repository root in this example) as the build context that should be copied to
    the Docker Engine when building the image.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`--target`标志允许您针对多阶段Dockerfile中的特定阶段进行构建。尽管我们目前只有一个阶段，但该标志允许我们仅在Dockerfile中有多个阶段的情况下构建测试阶段。按照惯例，`docker
    build`命令会在运行命令的目录中查找`Dockerfile`文件，并且命令末尾的句点指定了当前目录（例如，在本例中是应用程序存储库根目录）作为构建上下文，在构建图像时应将其复制到Docker引擎。
- en: 'With the image built and tagged with an image name of `todobackend` in your
    local Docker Engine, you can now start a container from the image, which by default
    will run the `python3 manage.py test` command as specified by the `CMD` directive:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构建并在本地Docker Engine中标记为`todobackend`的映像名称构建的映像，您现在可以从映像启动一个容器，默认情况下将运行`python3
    manage.py test`命令，如`CMD`指令所指定的那样：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `-it` flag specifies to run the container with an interactive terminal,
    and the `--rm` flag will automatically delete the container once it exits. Note
    that the tests all pass successfully, so we know the application built in the
    image is in a good state, at least in terms of the current tests that have been
    defined for the application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`-it`标志指定以交互式终端运行容器，`--rm`标志将在容器退出时自动删除容器。请注意，所有测试都成功通过，因此我们知道映像中构建的应用程序在至少在当前为应用程序定义的测试方面是良好的状态。'
- en: Configuring the release stage
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置发布阶段
- en: With the test stage in place, we now have an image that includes all application
    dependencies packaged in a format that can be installed without compilation or
    development dependencies, along with our application source code in a state that
    we can easily verify passes all tests.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有了测试阶段，我们现在有了一个映像，其中包含了所有应用程序依赖项，以一种可以在不需要编译或开发依赖项的情况下安装的格式打包，以及我们的应用程序源代码处于一个我们可以轻松验证通过所有测试的状态。
- en: The next stage that we need to configure is the release stage, which copies
    the application source code and various application dependencies built during
    the test stage to a new production-ready release image. Because the application
    dependencies are now available in a precompiled format, the release image does
    not require development dependencies or source code compilation tools, allowing
    us to create a smaller, leaner release image with a reduced attack surface.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要配置的下一个阶段是发布阶段，它将应用程序源代码和在测试阶段构建的各种应用程序依赖项复制到一个新的生产就绪的发布映像中。由于应用程序依赖项现在以预编译格式可用，因此发布映像不需要开发依赖项或源代码编译工具，这使我们能够创建一个更小、更精简的发布映像，减少了攻击面。
- en: Installing system dependencies
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装系统依赖项
- en: 'To get started creating the release stage, we can add a new `FROM` directive
    at the bottom of the Dockerfile, which Docker will treat as the start of a new
    stage:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建发布阶段，我们可以在Dockerfile的底部添加一个新的`FROM`指令，Docker将把它视为新阶段的开始：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding example, you can see the release image is based, once again,
    on the Alpine Linux image, which is an excellent choice for a release image given
    its very small footprint. You can see that we install fewer operating-system dependencies,
    which includes the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，您可以看到发布映像再次基于Alpine Linux映像，这是一个非常好的选择，因为它的占用空间非常小。您可以看到我们安装了更少的操作系统依赖项，其中包括以下内容：
- en: '`python3`: The Python 3 interpreter and runtime is required given the sample
    application is a Python application'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`python3`：由于示例应用程序是一个Python应用程序，因此需要Python 3解释器和运行时'
- en: '`mariadb-client`: Includes system libraries required to communicate with the
    MySQL application database'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mariadb-client`：包括与MySQL应用程序数据库通信所需的系统库'
- en: '`bash`: Useful for troubleshooting and executing entry point scripts, which
    we will discuss in later chapters.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bash`：用于故障排除和执行入口脚本，我们将在后面的章节中讨论。'
- en: Note that instead of installing the `python3-dev` and  `mariadb-dev` packages,
    we only need to install the non development versions of these packages, given
    we compiled and built all application dependences as precompiled wheels in the
    test stage.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只需要安装这些软件包的非开发版本，而不是安装`python3-dev`和`mariadb-dev`软件包，因为我们在测试阶段编译和构建了所有应用程序依赖项的预编译轮。
- en: Creating an application user
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序用户
- en: 'The next step is to create an application user that our application will run
    as. By default, Docker containers run as root, which is fine for test and development
    purposes, however, in production, even with the isolation mechanisms that containers
    provide, it is still considered best practice to run your containers as a non-root
    user:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个应用程序用户，我们的应用程序将作为该用户运行。默认情况下，Docker容器以root用户身份运行，这对于测试和开发目的来说是可以的，但是在生产环境中，即使容器提供了隔离机制，作为非root用户运行容器仍被认为是最佳实践：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding example, we first create a group named `app` with a group ID
    of `1000`, and then create a user called `app` with a user ID of `1000`, which
    belongs to the `app` group.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们首先创建了一个名为`app`的组，组ID为`1000`，然后创建了一个名为`app`的用户，用户ID为`1000`，属于`app`组。
- en: Copying and installing application source code and dependencies
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制和安装应用程序源代码和依赖项
- en: 'The final step is to copy the application source code and dependencies that
    were previously built in the test stage, install the dependencies into the release
    image, and then remove any temporary files used during this process.  We also
    need to set the working directory to `/app`, and configure the container to run
    as the `app` user we created in the previous section:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是复制先前在测试阶段构建的应用程序源代码和依赖项，将依赖项安装到发布镜像中，然后删除在此过程中使用的任何临时文件。我们还需要将工作目录设置为`/app`，并配置容器以作为前一节中创建的`app`用户运行：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You first use the `COPY` directive with the `--from` flag, which tells Docker
    to look in the stage specified in the `--from` flag for the files to copy. Here
    we copy the `/build` and `/app` folders from the test stage image to folders with
    the same names in the release stage, and also configure the `--chown` flag to
    change the ownership of these copied folders to the application user. We then
    use the `pip3` command to install only the core requirements specified in the `requirements.txt` file
    (you don't need the dependencies specified in `requirements_test.txt` for running
    the application), using the `--no-index` flag to disable the PIP connecting to
    the internet to download packages, and instead use the `/build` folder, as referenced
    by the `-f` flag, to find the dependencies previously built during the test stage
    and copied to this folder. We also specify the `--no-cache-dir` flag to avoid
    unnecessarily caching packages in the local filesystem, and remove the `/build` folder
    once everything is installed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先使用`COPY`指令和`--from`标志，告诉Docker在`--from`标志指定的阶段查找要复制的文件。在这里，我们将测试阶段镜像中的`/build`和`/app`文件夹复制到发布阶段中同名的文件夹，并配置`--chown`标志以将这些复制的文件夹的所有权更改为应用程序用户。然后我们使用`pip3`命令仅安装`requirements.txt`文件中指定的核心要求（您不需要`requirements_test.txt`中指定的依赖项来运行应用程序），使用`--no-index`标志禁用PIP连接到互联网下载软件包，而是使用`-f`标志引用的`/build`文件夹来查找先前在测试阶段构建并复制到此文件夹的依赖项。我们还指定`--no-cache-dir`标志以避免在本地文件系统中不必要地缓存软件包，并在安装完成后删除`/build`文件夹。
- en: Finally, you set the working directory as `/app`, and configure the container
    to run as the `app` user by specifying the `USER` directive.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将工作目录设置为`/app`，并通过指定`USER`指令配置容器以`app`用户身份运行。
- en: Building and running the release image
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行发布镜像
- en: Now that we have completed the configuration of the release stage of the Dockerfile,
    it's time to build our new released image and verify we can actually run our application
    successfully.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了Dockerfile发布阶段的配置，是时候构建我们的新发布镜像，并验证我们是否能成功运行我们的应用程序。
- en: 'To build the image, we can use the `docker build` command, and because the
    release stage is the last stage of the Dockerfile, you don''t need to target a
    specific stage, as we did previously for the test stage:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建镜像，我们可以使用`docker build`命令，因为发布阶段是Dockerfile的最后阶段，所以你不需要针对特定阶段进行目标设置，就像我们之前为测试阶段所做的那样：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At this point, we can run the Django application that is located in the release
    image, but you might be wondering exactly how that works. When we ran the `python3
    manage.py runserver` command earlier, it spun up a local development web server
    which is not recommended for production-user cases, so we require an alternative
    web server to run our application in production.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以运行位于发布镜像中的Django应用程序，但是你可能想知道它是如何工作的。当我们之前运行`python3 manage.py runserver`命令时，它启动了一个本地开发Web服务器，这在生产用户案例中是不推荐的，所以我们需要一个替代的Web服务器来在生产环境中运行我们的应用程序。
- en: 'You may have noticed earlier in the `requirements.txt` file a package called `uwsgi`—this
    is a very popular web server that can be used in production, and, conveniently
    for our use case, can be installed via PIP.  This means that `uwsgi` is already
    available as a web server in our release container and can be used to serve the
    sample application:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在`requirements.txt`文件中注意到了一个名为`uwsgi`的包——这是一个非常流行的Web服务器，可以在生产中使用，并且对于我们的用例非常方便，可以通过PIP安装。这意味着`uwsgi`已经作为Web服务器在我们的发布容器中可用，并且可以用来提供示例应用程序。
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We use the `-p` flag to map port `8000` on the container to port `8000` on your
    host, and execute the `uwsgi` command passing in various configuration flags that
    run the application on port `8000` and specify the `todobackend.wsgi` module as
    the application served by `uwsgi`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`-p`标志将容器上的端口`8000`映射到主机上的端口`8000`，并执行`uwsgi`命令，传入各种配置标志，以在端口`8000`上运行应用程序，并指定`todobackend.wsgi`模块作为`uwsgi`提供的应用程序。
- en: The Web Server Gateway Interface (WSGI) is a standard interface used by Python
    applications to interact with web servers. Every Django application includes a
    WSGI module for communicating with a web server, which can be accessed via `<application-name>.wsgi`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器网关接口（WSGI）是Python应用程序用来与Web服务器交互的标准接口。每个Django应用程序都包括一个用于与Web服务器通信的WSGI模块，可以通过`<application-name>.wsgi`访问。
- en: 'At this point, you can browse to `http://localhost:8000` and although the application
    does return a response, you will find that the web server and application are
    missing a bunch of static content:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可以浏览`http://localhost:8000`，虽然应用程序确实返回了一个响应，但你会发现Web服务器和应用程序缺少一堆静态内容：
- en: '![](assets/1666a16d-f8ad-4509-974d-aca192694abf.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1666a16d-f8ad-4509-974d-aca192694abf.png)'
- en: 'The problem here is that Django automatically generates static content when
    you run the Django development web server, however, when you run the application
    in production along with an external web server, you are responsible for generating
    static content yourself. We will learn how to do this later on in this chapter,
    however for now, you can verify the API works by using `curl`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，当你运行Django开发Web服务器时，Django会自动生成静态内容，但是当你在生产环境中与外部Web服务器一起运行应用程序时，你需要自己生成静态内容。我们将在本章后面学习如何做到这一点，但是现在，你可以使用`curl`来验证API是否可用：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'One thing to note here is that the todobackend data has the same data that
    we loaded back in Chapter 1, despite us having built a Docker image from scratch.
    The problem here is that the SQLite database that was created back in Chapter
    1 resides in the `src` folder, in a file called `db.sqlite3`. Clearly, we don''t
    want to copy this file into our Docker image during the build process, and one
    way to achieve this is to create a `.dockerignore` file at the root of the repository:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，尽管我们是从头开始构建Docker镜像，但是todobackend数据与我们在第1章加载的数据相同。问题在于，第1章中创建的SQLite数据库位于`src`文件夹中，名为`db.sqlite3`。显然，在构建过程中我们不希望将此文件复制到我们的Docker镜像中，而要实现这一点的一种方法是在存储库的根目录创建一个`.dockerignore`文件：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `.dockerignore` file works similarly to `.gitignore` in a Git repository,
    and is used to exclude files from the Docker build context. Because the `db.sqlite3` file
    is located in a subfolder, we use a wildcard globing pattern of `**` (note this
    is different from `.gitignore` behavior, which globs by default), which means
    we recursively exclude any file matching the wildcard pattern. We also exclude
    any test output files that have a `.xml` extension, code coverage files, the `__pycache__` folder,
    and any compiled Python files with `.pyc` extensions, which are intended to be
    generated on the fly at runtime.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`.dockerignore`文件的工作方式类似于Git存储库中的`.gitignore`，用于从Docker构建上下文中排除文件。因为`db.sqlite3`文件位于子文件夹中，我们使用通配符globing模式`**`（请注意，这与`.gitignore`的行为不同，默认情况下进行globing），这意味着我们递归地排除与通配符模式匹配的任何文件。我们还排除任何具有`.xml`扩展名的测试输出文件，代码覆盖文件，`__pycache__`文件夹以及任何具有`.pyc`扩展名的编译Python文件，这些文件是打算在运行时动态生成的。'
- en: 'If you now rebuild the Docker image and start-up the the `uwsgi` web server
    locally on port `8000`, when you browse to the application (`http://localhost:8000`),
    you will get a different error:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在重新构建Docker镜像，并在本地端口`8000`上启动`uwsgi`Web服务器，当您浏览应用程序（`http://localhost:8000`）时，您将会得到一个不同的错误：
- en: '![](assets/c7ab5b6d-1d1b-47d8-8242-5e7c51cc22c4.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c7ab5b6d-1d1b-47d8-8242-5e7c51cc22c4.png)'
- en: The problem now is that no database exists for the todobackend application,
    so the application is failing as it cannot locate the table that stores Todo items.
    To resolve this problem, we are now at the point where we need to integrate with
    an external database engine, meaning we need a solution to work with multiple
    containers locally.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是todobackend应用程序没有数据库存在，因此应用程序失败，因为它无法找到存储待办事项的表。为了解决这个问题，我们现在需要集成一个外部数据库引擎，这意味着我们需要一个解决方案来在本地使用多个容器。
- en: Testing and building the application using Docker Compose
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Compose测试和构建应用程序
- en: 'In the previous section, you used Docker commands to perform the following
    tasks:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您使用Docker命令执行了以下任务：
- en: Build a test image
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个测试镜像
- en: Run tests
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试
- en: Build a release image
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个发布镜像
- en: Run the application
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: Each time we ran a Docker command, we had to supply quite a bit of configuration,
    and trying to remember the various commands that you need to run is already starting
    to become difficult. In addition to this, we also discovered that to start the
    release image for the application, we need to have an operational external database. 
    For local testing use cases, running an external database in another container
    is an excellent approach, but having to orchestrate this by running a series of
    Docker commands with lots of different input parameters very quickly becomes difficult
    to manage.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们运行Docker命令时，都需要提供相当多的配置，并且试图记住需要运行的各种命令已经开始变得困难。除此之外，我们还发现，要启动应用程序的发布镜像，我们需要有一个操作的外部数据库。对于本地测试用例，运行另一个容器中的外部数据库是一个很好的方法，但是通过运行一系列带有许多不同输入参数的Docker命令来协调这一点很快变得难以管理。
- en: '**Docker Compose** is a tool that allows you to orchestrate multi-container
    environments using a declarative approach, making it much easier to orchestrate
    complex workflows that may require multiple containers. By convention, Docker
    Compose looks for a file called `docker-compose.yml` in the current directory,
    so let''s create this file at the root of the `todobackend` repository, alongside
    our `Dockerfile`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker Compose**是一个工具，允许您使用声明性方法编排多容器环境，使得编排可能需要多个容器的复杂工作流程变得更加容易。按照惯例，Docker
    Compose会在当前目录中寻找一个名为`docker-compose.yml`的文件，所以让我们在`todobackend`存储库的根目录下创建这个文件，与我们的`Dockerfile`放在一起。'
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Docker Compose files are defined in a YAML format, which requires proper indentation
    to infer the correct relationships between parent, siblings and child objects
    or properties.  If you have not worked with YAML before, you can check out the [Ansible
    YAML Syntax guide](https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html),
    which provides a brief introduction to YAML formatting.  You can also use an online
    YAML linting tool  such as http://www.yamllint.com/ to check your YAML, or install
    YAML support in your favourite text editor.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose文件是用YAML格式定义的，需要正确的缩进来推断父对象、同级对象和子对象或属性之间的正确关系。如果您以前没有使用过YAML，可以查看[Ansible
    YAML Syntax guide](https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html)，这是一个对YAML格式的简要介绍。您也可以使用在线的YAML
    linting工具，比如http://www.yamllint.com/来检查您的YAML，或者在您喜欢的文本编辑器中安装YAML支持。
- en: We first specify the `version` property, which is mandatory and references the
    version of the Compose file format syntax that we are using. If you are using
    Docker for local development and build tasks, I recommending using version 2.x
    of the Compose file format, as it includes some useful features, such as health
    checks on dependent services, that we will learn how to use shortly.  If you are
    using Docker Swarm to run your containers, then you should use version 3.x of
    the Compose file format, as this version supports a number of features that relate
    to managing and orchestrating Docker Swarm.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们指定了`version`属性，这是必需的，引用了我们正在使用的Compose文件格式语法的版本。如果您正在使用Docker进行本地开发和构建任务，我建议使用Compose文件格式的2.x版本，因为它包括一些有用的功能，比如对依赖服务进行健康检查，我们很快将学习如何使用。如果您正在使用Docker
    Swarm来运行您的容器，那么您应该使用Compose文件格式的3.x版本，因为这个版本支持一些与管理和编排Docker Swarm相关的功能。
- en: If you choose to use version 3.x, your applications will need to be more robust
    in terms of dealing with scenarios such as your database not being available at
    application startup (see [https://docs.docker.com/compose/startup-order/](https://docs.docker.com/compose/startup-order/)),
    which is a problem we will encounter later on in this chapter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择使用3.x版本，您的应用程序需要更加健壮，以处理诸如数据库在应用程序启动时不可用的情况（参见[https://docs.docker.com/compose/startup-order/](https://docs.docker.com/compose/startup-order/)），这是我们在本章后面将遇到的一个问题。
- en: We next specify the `services` property, which defines one or more services
    that run in our Docker Compose environment. In the preceding example, we create
    two services that correspond to the test and release stages of our workflow, and
    then add a single `build` property to each service, which defines how we want
    to build the Docker image for each service. Note that the `build` properties are
    based upon the various flags that we passed to the `docker build` command—for
    example, when we build the test stage image, we set the build context to the local
    folder, used the local Dockerfile as the build specification for the image, and
    targeted only the test stage for building the image. Rather than imperatively
    specifying these settings each time we run a Docker command, we are declaratively
    defining the desired configuration for the build process, which is an important
    distinction.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们指定`services`属性，它定义了在我们的Docker Compose环境中运行的一个或多个服务。在前面的示例中，我们创建了两个服务，对应于工作流程的测试和发布阶段，然后为每个服务添加了一个`build`属性，它定义了我们希望如何为每个服务构建Docker镜像。请注意，`build`属性基于我们传递给`docker
    build`命令的各种标志，例如，当我们构建测试阶段镜像时，我们将构建上下文设置为本地文件夹，使用本地Dockerfile作为构建规范的图像，并仅针对测试阶段构建图像。我们不是在每次运行Docker命令时命令式地指定这些设置，而是声明性地定义了构建过程的期望配置，这是一个重要的区别。
- en: 'Of course we need to run a command to actually build these services, which
    you can do by running the `docker-compose build` command at the root of the `todobackend`
    repository:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要运行一个命令来实际构建这些服务，您可以在`todobackend`存储库的根目录运行`docker-compose build`命令。
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can see that running the `docker-compose build test` command achieves the
    equivalent of the earlier `docker build` command we ran, however, we don't need
    to pass any build options or configuration to the `docker-compose` command, given
    all of our specific settings are captured in the `docker-compose.yml` file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到运行`docker-compose build test`命令实现了我们之前运行的`docker build`命令的等效效果，然而，我们不需要向`docker-compose`命令传递任何构建选项或配置，因为我们所有的特定设置都包含在`docker-compose.yml`文件中。
- en: 'If you now want to run tests from the newly built image, you can execute the `docker-compose
    run` command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在要从新构建的镜像运行测试，可以执行`docker-compose run`命令：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can also extend the Docker Compose file to add port mapping and command
    configurations to services, as demonstrated in the following example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以扩展Docker Compose文件，以向服务添加端口映射和命令配置，如下例所示：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here we specify that when the release service is run, it should create a static
    port mapping from port `8000` on the host to port `8000` on the container, and
    pass the `uwsgi` command we used earlier to the release container.  If you now
    run the release stage using the `docker-compose up` command, note that Docker
    Compose will automatically build the image for a service if it does not yet exist,
    and then start the service:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定当运行发布服务时，它应该在主机的8000端口和容器的8000端口之间创建静态端口映射，并将我们之前使用的`uwsgi`命令传递给发布容器。如果现在使用`docker-compose
    up`命令运行发布阶段，请注意Docker Compose将自动为服务构建镜像（如果尚不存在），然后启动服务：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You typically use the `docker-compose up` command for long-running services,
    and the `docker-compose run` command to run short-lived tasks. You also cannot
    override the command arguments passed to `docker-compose up`, whereas you can
    pass command overrides to the `docker-compose run` command.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您使用`docker-compose up`命令来运行长时间运行的服务，使用`docker-compose run`命令来运行短暂的任务。您还不能覆盖传递给`docker-compose
    up`的命令参数，而可以将命令覆盖传递给`docker-compose run`命令。
- en: Adding a database service using Docker Compose
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Compose添加数据库服务
- en: To resolve the application error we currently have when running the release
    image, we need to run a database that the application can connect to, and ensure
    the application is configured to use the database.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决运行发布图像时出现的应用程序错误，我们需要运行一个应用程序可以连接到的数据库，并确保应用程序配置为使用该数据库。
- en: 'We can achieve this using Docker Compose by adding a new service called `db`,
    which is based on the official MySQL server container:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用Docker Compose添加一个名为`db`的新服务来实现这一点，该服务基于官方的MySQL服务器容器：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that you can specify an external image using the `image` property, and
    the environment settings configure the MySQL container with a database called
    todobackend, a username, password, and a root password.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以使用`image`属性指定外部图像，并且环境设置将使用数据库名为todobackend、用户名、密码和根密码配置MySQL容器。
- en: 'Now, you might be wondering how we configure our application to use MySQL and
    the new `db` service.  The todobackend application includes a settings file called `src/todobackend/settings_release.py`,
    which configures support for MySQL as the database backend:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能想知道如何配置我们的应用程序以使用MySQL和新的`db`服务。todobackend应用程序包括一个名为`src/todobackend/settings_release.py`的设置文件，该文件配置了MySQL作为数据库后端的支持：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `DATABASES` setting includes a configuration that specifies an engine of `mysql.connector.django`,
    which provides support for MySQL overriding the default SQLite driver, and you
    can see that the database name, username, and password can be obtained from the
    environment via the `os.environ.get` call. Also note that the `STATIC_ROOT` setting
    – this is where Django looks for static content, such as HTML, CSS, JavaScript,
    and images—and by default, Django will look in `/public/static` if this environment
    variable is not defined.  As we saw earlier, currently our web application is
    missing this content, so keep this setting in mind for later when we fix the missing
    content issue.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`DATABASES`设置包括一个配置，指定了`mysql.connector.django`引擎，该引擎提供了对MySQL的支持，覆盖了默认的SQLite驱动程序，并且您可以看到数据库名称、用户名和密码可以通过`os.environ.get`调用从环境中获取。还要注意`STATIC_ROOT`设置-这是Django查找静态内容（如HTML、CSS、JavaScript和图像）的位置-默认情况下，如果未定义此环境变量，Django将在`/public/static`中查找。正如我们之前看到的，目前我们的Web应用程序缺少这些内容，因此在以后修复缺少内容问题时，请记住这个设置。'
- en: 'Now that you understand how the todobackend application can be configured to
    support a MySQL database, let''s modify the Docker Compose file to use the `db` service:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了如何配置todobackend应用程序以支持MySQL数据库，让我们修改Docker Compose文件以使用`db`服务：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We first configure the `environment` property on the `release` service, which
    configures environment variables that will be passed to the container. Note that
    for Django applications, you can configure the `DJANGO_SETTINGS_MODULE` environment
    variable to specify which settings should be used, and this allows you to use
    the `settings_release` configuration that adds MySQL support. This configuration
    also allows you to use environment variables to specify the MySQL database settings,
    which must match the configuration of the `db` service.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先配置`release`服务上的`environment`属性，该属性配置了将传递给容器的环境变量。请注意，对于Django应用程序，您可以配置`DJANGO_SETTINGS_MODULE`环境变量以指定应该使用哪些设置，这使您可以使用添加了MySQL支持的`settings_release`配置。此配置还允许您使用环境变量来指定MySQL数据库设置，这些设置必须与`db`服务的配置相匹配。
- en: We next configure the `depends_on` property for the `release` service, which
    describes any dependencies the service may have. Because the application must
    have a working connection to the database before it can start, we specify a condition
    of `service_healthy`, which means the `db` service must have passed a Docker health
    check before Docker Compose will attempt to start the `release` service. To configure
    the Docker health check on the `db` service, we configure the `healthcheck` property,
    which will configure Docker to run the command specified by the `test` parameter
    inside the `db` service container to verify service health, and to retry this
    command every 3 seconds up to 10 times until the `db` service is healthy. For
    this scenario, we use the `mysqlshow` command, which will only return a successful
    zero exit code once the MySQL process is accepting connections. Because Docker
    Compose will interpret single dollar signs as environment variables it should
    evaluate and replace in the Docker Compose file, we escape the environment variables
    referenced in the `test` command with double dollar signs to ensure that the command
    will literally execute `mysqlshow -u $MYSQL_USER -p$MYSQL_PASSWORD`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为`release`服务配置`depends_on`属性，该属性描述了服务可能具有的任何依赖关系。因为应用程序在启动之前必须与数据库建立有效连接，所以我们指定了`service_healthy`的条件，这意味着在Docker
    Compose尝试启动`release`服务之前，`db`服务必须通过Docker健康检查。为了配置`db`服务上的Docker健康检查，我们配置了`healthcheck`属性，它将配置Docker运行`db`服务容器内由`test`参数指定的命令来验证服务健康，并重试此命令，每3秒一次，最多重试10次，直到`db`服务健康为止。对于这种情况，我们使用`mysqlshow`命令，它只有在MySQL进程接受连接时才会返回成功的零退出代码。由于Docker
    Compose将单个美元符号解释为应该在Docker Compose文件中评估和替换的环境变量，我们使用双美元符号转义`test`命令中引用的环境变量，以确保该命令会直接执行`mysqlshow
    -u $MYSQL_USER -p$MYSQL_PASSWORD`。
- en: 'At this point, we can test the changes by tearing down the current environment
    by pressing *Ctrl* + *C* in the terminal running the `release` service and typing
    the `docker-compose down -v` command (the `-v` flag will also delete any volumes
    created by Docker Compose), and then executing the `docker-compose up release` command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以通过在运行`release`服务的终端中按下*Ctrl* + *C*并输入`docker-compose down -v`命令（`-v`标志还将删除Docker
    Compose创建的任何卷）来拆除当前环境，然后执行`docker-compose up release`命令来测试更改：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, note that Docker Compose automatically pulls the MySQL
    5.7 image as configured via the `image` property, and then starts the `db` service.
    This will take between 15-30 seconds, and during this period, Docker Compose is
    waiting for Docker to report back that the `db` service is healthy. Every 3 seconds
    Docker runs the `mysqlshow` command as configured in the health check, repeating
    this continuously until the command returns a successful exit code (that is, an
    exit code of `0`), at which point Docker will mark the container as healthy. Only
    at this point will Docker Compose start up the `release` service, which should
    start successfully given the `db` service is fully operational.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，请注意，Docker Compose会根据`image`属性自动拉取MySQL 5.7镜像，然后启动`db`服务。这将需要15-30秒，在此期间，Docker
    Compose正在等待Docker报告`db`服务的健康状况。每3秒，Docker运行在健康检查中配置的`mysqlshow`命令，不断重复此过程，直到命令返回成功的退出代码（即退出代码为`0`），此时Docker将标记容器为健康。只有在这一点上，Docker
    Compose才会启动`release`服务，假设`db`服务完全可操作，`release`服务应该会成功启动。
- en: If you browse once again to `http://localhost:8000/todos`, you will find that
    even though we added a `db` service and configure the release service to use this
    database, you are still receiving the `no such table` error you saw previously
    in the previous screenshot.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次浏览`http://localhost:8000/todos`，您会发现即使我们添加了一个`db`服务并配置了发布服务以使用这个数据库，您仍然会收到之前在上一个截图中看到的`no
    such table`错误。
- en: Running database migrations
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行数据库迁移
- en: We are still receiving errors about missing tables, and the reason is because
    we have not run database migrations to establish the required database schema
    the application expects to be in place. Recall that we used the `python3 manage.py
    migrate` command locally to run these migrations, so we need to do the same in
    our Docker environment.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然收到有关缺少表的错误，原因是因为我们尚未运行数据库迁移以建立应用程序期望存在的所需数据库架构。请记住，我们在本地使用`python3 manage.py
    migrate`命令来运行这些迁移，因此我们需要在我们的Docker环境中执行相同的操作。
- en: 'If you tear down the environment again by pressing *Ctrl* + *C* and running `docker-compose
    down -v`, one approach would be to use the `docker-compose run` command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次拆除环境，按下*Ctrl* + *C*并运行`docker-compose down -v`，一个方法是使用`docker-compose run`命令：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding example, note that when you use the `docker-compose run` command,
    Docker Compose does NOT support the health check behavior we previously observed
    when we ran `docker-compose up`.  This means you can take one of two approaches:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，请注意，当您使用`docker-compose run`命令时，Docker Compose不支持我们之前在运行`docker-compose
    up`时观察到的健康检查行为。这意味着您可以采取以下两种方法：
- en: Ensure you run `docker-compose up release` first, and then run `docker-compose
    run python3 manage.py migrate` - this will leave your application in a state where
    it will raise errors until the migrations complete.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您首先运行`docker-compose up release`，然后运行`docker-compose run python3 manage.py
    migrate` - 这将使您的应用程序处于一种状态，直到迁移完成之前都会引发错误。
- en: Define the migrations as a separate service, called `migrate`, with a dependency
    on the `db` service, bring up the `migrate` service, which will execute the migrations
    and exit, and then bring up the application.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将迁移定义为一个单独的服务，称为`migrate`，依赖于`db`服务，启动`migrate`服务，该服务将执行迁移并退出，然后启动应用程序。
- en: Although as you will soon see, option 1 is simpler, option 2 is more robust
    as it ensures the database is in the correct state before starting the application.
    Option 2 also aligns with the approach we will take later on in this book when
    we have to orchestrate running database migrations in AWS, so we will implement
    option 2 now.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管很快您会看到，选项1更简单，但选项2更健壮，因为它确保在启动应用程序之前数据库处于正确的状态。选项2也符合我们稍后在本书中在AWS中编排运行数据库迁移时将采取的方法，因此我们现在将实施选项2。
- en: 'The following example demonstrates the changes we need to make to run the migrations
    as a separate service:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了我们需要进行的更改，以将迁移作为一个单独的服务运行：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, note that in addition to the `migrate` service, we
    have added a new service, called `app`, as well. The reason is that we want to
    extend migrate from the `release` service (as defined by the `extends` parameter)
    so it will inherit the release image and release service settings, however, one
    limitation of extending another service is that you cannot extend a service that
    has a `depends_on` statement. This requires us to use the `release` service as
    more of a base configuration that other services inherit from, and shift the `depends_on`, `ports`, and `command` parameters
    from the release service to the new `app` service.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，请注意，除了`migrate`服务，我们还添加了一个名为`app`的新服务。原因是我们希望从`release`服务扩展`migrate`（如`extends`参数所定义），以便它将继承发布映像和发布服务设置，但是扩展另一个服务的一个限制是您不能扩展具有`depends_on`语句的服务。这要求我们将`release`服务更多地用作其他服务继承的基本配置，并将`depends_on`、`ports`和`command`参数从发布服务转移到新的`app`服务。
- en: 'With this configuration in place, we can tear down the environment and stand
    up our new environment, as demonstrated in the following example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个配置，我们可以拆除环境并建立我们的新环境，就像以下示例中演示的那样：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding example, note that Docker Compose builds new images for each
    service, however these builds complete very quickly as they are identical to the
    release image, given each service extends the `release` service. You will observe
    a 15-30 second delay when you bring up the `migrate` service waiting for the `db` service
    health check to pass, after which the migrations are run, creating the appropriate
    schema and tables the todobackend application expects. After starting the `app` service,
    you should be able to interact with the todobackend API without receiving any
    errors:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，请注意Docker Compose为每个服务构建新的映像，但是由于每个服务都扩展了`release`服务，因此这些构建非常快速。当您启动`migrate`服务等待`db`服务的健康检查通过时，您将观察到15-30秒的延迟，之后将运行迁移，创建todobackend应用程序期望的适当模式和表。启动`app`服务后，您应该能够与todobackend
    API交互而不会收到任何错误：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Generating static web content
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成静态网页内容
- en: If you browse to `http://localhost:8000/todos`, although the application is
    no longer returning an error, the formatting of the web page still is broken.
    The problem here is that Django requires you to run a separate `manage.py` management
    task called `collectstatic`, which generates static content and places it at the
    location defined by the `STATIC_ROOT` setting. The release settings for our application
    define the file location for this as `/public/static`, so we somehow need to run
    the `collectstatic` task before our application starts up. Note that Django serves
    all static content from the `/static` URL path, for example `http://localhost:8000/static`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您浏览`http://localhost:8000/todos`，尽管应用程序不再返回错误，但网页的格式仍然是错误的。问题在于Django要求您运行一个名为`collectstatic`的单独的`manage.py`管理任务，它会生成静态内容并将其放置在`STATIC_ROOT`设置定义的位置。我们应用程序的发布设置将文件位置定义为`/public/static`，因此我们需要在应用程序启动之前运行`collectstatic`任务。请注意，Django从`/static`
    URL路径提供所有静态内容，例如`http://localhost:8000/static`。
- en: 'There are a couple of approaches that you can use to solve this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决这个问题：
- en: Create an entrypoint script that runs on startup and executes the `collectstatic` task
    before starting the application.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个在启动时运行并在启动应用程序之前执行`collectstatic`任务的入口脚本。
- en: Create an external volume and run a container that executes the `collectstatic` task,
    generating static files in the volume. Then start the application with the external
    volume mounted, ensuring it has access to static content.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个外部卷并运行一个容器，执行`collectstatic`任务，在卷中生成静态文件。然后启动应用程序，挂载外部卷，确保它可以访问静态内容。
- en: Both of these approaches are valid, however, to introduce the concept of Docker
    volumes and how you can use them in Docker Compose, we will adopt the second approach.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都是有效的，但是为了介绍Docker卷的概念以及你如何在Docker Compose中使用它们，我们将采用第二种方法。
- en: 'To define a volume in Docker Compose, you use the top-level `volumes` parameter,
    which allows you to define one or more named volumes:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Docker Compose中定义卷，你可以使用顶层的`volumes`参数，它允许你定义一个或多个命名卷。
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding example, you add a volume called `public` and specify the driver
    as local, meaning it is a standard Docker volume. You then use the `volumes` parameter
    in the app service to mount the public volume to the `/public` path in the container,
    and finally you configure `uwsgi` to serve requests for static content from the `/public` path,
    which avoids expensive application calls to the Python interpreter to serve static
    content.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，你添加了一个名为`public`的卷，并将驱动程序指定为本地，这意味着它是一个标准的Docker卷。然后你在app服务中使用`volumes`参数将public卷挂载到容器中的`/public`路径，最后你配置`uwsgi`来从`/public`路径为静态内容提供服务，这避免了昂贵的应用程序调用Python解释器来提供静态内容。
- en: 'After tearing down your current Docker Compose environment, all that is required
    to generate static content is the `docker-compose run` command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在销毁当前的Docker Compose环境后，生成静态内容只需要使用`docker-compose run`命令。
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding example, the `collectstatic` task fails because, by default,
    volumes are created as root and the container runs as the app user. To resolve
    this, we need to pre-create the `/public` folder in `Dockerfile` and make the
    app user the owner of this folder:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`collectstatic`任务失败，因为默认情况下卷是以root创建的，而容器是以app用户运行的。为了解决这个问题，我们需要在`Dockerfile`中预先创建`/public`文件夹，并将app用户设置为该文件夹的所有者。
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that the approach shown above only works for volumes that are created using
    Docker volume mounts, which is what Docker Compose uses if you don't specify a
    host path on your Docker Engine.   If you specify a host path, the volume is bind
    mounted, which causes the volume to have root ownership by default, unless you
    pre-create the path on the host with the correct permissions.  We will encounter
    this issue later on when we use the Elastic Container Service, so keep this in
    mind.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上面显示的方法仅适用于使用Docker卷挂载创建的卷，这是Docker Compose在你没有在Docker Engine上指定主机路径时使用的方法。如果你指定了主机路径，卷将被绑定挂载，这会导致卷默认具有root所有权，除非你在主机上预先创建具有正确权限的路径。当我们使用弹性容器服务时，我们将在以后遇到这个问题，所以请记住这一点。
- en: 'Because you modified the Dockerfile, you need to tell Docker Compose to rebuild
    all images, which you can do by using the `docker-compose build` command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你修改了Dockerfile，你需要告诉Docker Compose重新构建所有镜像，你可以使用`docker-compose build`命令来实现。
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you now browse to `http://localhost:8000`, the correct static content should
    be displayed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在浏览`http://localhost:8000`，正确的静态内容应该被显示出来。
- en: When you define a local volume in Docker Compose, the volume will be automatically
    be destroyed when you run the `docker-compose down -v` command. If you wish to
    persist storage independently of Docker Compose, you can define an external volume,
    which you are then responsible for creating and destroying.  See [https://docs.docker.com/compose/compose-file/compose-file-v2/#external](https://docs.docker.com/compose/compose-file/compose-file-v2/#external)
    for more details.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker Compose中定义本地卷时，当你运行`docker-compose down -v`命令时，卷将自动销毁。如果你希望独立于Docker
    Compose持久存储，你可以定义一个外部卷，然后你需要负责创建和销毁它。更多详情请参阅[https://docs.docker.com/compose/compose-file/compose-file-v2/#external](https://docs.docker.com/compose/compose-file/compose-file-v2/#external)。
- en: Creating acceptance tests
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建验收测试
- en: Now that the application is configured correctly, the final task to configure
    for the release stage is to define acceptance tests that verify the application
    is working as expected. Acceptance tests are all about ensuring the release image
    you have built works in an environment that is as close to production as possible,
    within the constraints of a local Docker environment. At a minimum, if your application
    is a web application or API service, such as the todobackend application, you
    might just verify the application returns a valid HTTP response, or you might
    run through key features, such as creating an item, updating an item, and deleting
    an item.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序已正确配置，为发布阶段配置的最后一个任务是定义验收测试，以验证应用程序是否按预期工作。验收测试的目的是确保您构建的发布镜像在尽可能接近生产环境的环境中工作，在本地Docker环境的约束条件下。至少，如果您的应用程序是Web应用程序或API服务，比如todobackend应用程序，您可能只需验证应用程序返回有效的HTTP响应，或者您可能运行关键功能，比如创建项目、更新项目和删除项目。
- en: For the todobackend application, we will create a few basic tests to demonstrate
    the approach, using a tool called BATS (Bash automated test system). BATS is great
    for system administrators who are more comfortable using bash, and leverages out-of-the-box
    tools to execute tests.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于todobackend应用程序，我们将创建一些基本测试来演示这种方法，使用一个名为BATS（Bash自动化测试系统）的工具。BATS非常适合更喜欢使用bash的系统管理员，并利用开箱即用的工具来执行测试。
- en: 'To get started with BATS, we need to create a test script, called `acceptance.bats`,
    in the `src` folder of the **todobackend** repository using the BATS syntax, which
    you can read more about at [https://github.com/sstephenson/bats](https://github.com/sstephenson/bats):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用BATS，我们需要在**todobackend**存储库的`src`文件夹中使用BATS语法创建一个名为`acceptance.bats`的测试脚本，您可以在[https://github.com/sstephenson/bats](https://github.com/sstephenson/bats)上了解更多信息：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The BATS file includes a `setup()` function and a number of test cases, which
    are each prefixed with the `@test` marker. The `setup()` function is a special
    function that will be run before each test case, and is useful for defining common
    variables and ensuring the application state is consistent before each test. You
    can see that we set a few variables that are used in the various test cases:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: BATS文件包括一个`setup()`函数和一些测试用例，每个测试用例都以`@test`标记为前缀。`setup()`函数是一个特殊的函数，在每个测试用例运行之前都会运行，用于定义公共变量并确保应用程序状态在每个测试之前保持一致。您可以看到我们设置了一些在各种测试用例中使用的变量：
- en: '`url`: Defines the URL of the application under test. This is defined by the `APP_URL` environment
    variable, defaulting to `localhost:8000` if `APP_URL` is not defined.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`：定义了要测试的应用程序的URL。这由`APP_URL`环境变量定义，默认为`localhost:8000`，如果未定义`APP_URL`。'
- en: '`item`: Defines a test Todo item in JSON format that is created via the Todos
    API during the tests.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`item`：以JSON格式定义了一个测试Todo项，该项在测试期间通过Todos API创建。'
- en: '`location`: Defines a regular expression intended to locate and capture the
    value of the Location header that is returned in the HTTP response whenever you
    create a Todo item.  The `([^[:space:]]*)` portion of the regular expression captures
    zero or more characters until whitespace (as designated by the `[:space:]` indicator)
    is encountered. For example, if the location header was `Location: http://localhost:8000/todos/53`,
    the regular expression will capture `http://localhost:8000/todos/53`.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location`：定义了一个正则表达式，用于定位和捕获在创建Todo项时返回的HTTP响应中的Location标头的值。正则表达式的`([^[:space:]]*)`部分捕获零个或多个字符，直到遇到空格（由`[:space:]`指示）为止。例如，如果位置标头是`Location:
    http://localhost:8000/todos/53`，正则表达式将捕获`http://localhost:8000/todos/53`。'
- en: 'The `curl` command: The final setup task is to delete all todo items in the
    database, which you can do by sending a DELETE request to the `/todos` URL. This
    ensures the todobackend database is clean on each test run, reducing the likelihood
    of different tests introducing side effects that break other tests.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`curl`命令：最后的设置任务是删除数据库中的所有待办事项，您可以通过向`/todos`URL发送DELETE请求来实现。这确保了每次测试运行时todobackend数据库都是干净的，减少了不同测试引入破坏其他测试的副作用的可能性。'
- en: 'The BATS file next defines several test cases:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: BATS文件接下来定义了几个测试用例：
- en: '`todobackend root`: This includes the `run` function, which runs the specified
    command and captures the exit code of the command in a variable called status,
    and the output of the command in a variable called `output`.  For this scenario,
    the test runs a special configuration of the `curl` command that captures only
    the HTTP status code that is returned, and then verifies the `curl` command completed
    successfully by calling `[ $status = 0 ]`, and that the returned HTTP status code
    was a 200 code by calling `[ $output = 200 ]`. These tests are regular shell *test
    expressions*, and are the equivalent of the canonical `assert` statement found
    in many programming languages.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`todobackend root`：这包括`run`函数，该函数运行指定的命令并将命令的退出代码捕获在一个名为status的变量中，将命令的输出捕获在一个名为`output`的变量中。对于这种情况，测试运行`curl`命令的特殊配置，该配置仅捕获返回的HTTP状态代码，然后通过调用`[
    $status = 0 ]`来验证`curl`命令成功完成，并通过调用`[ $output = 200 ]`来验证返回的HTTP状态代码是200代码。这些测试是常规的shell
    *测试表达式*，相当于许多编程语言中找到的规范`assert`语句。'
- en: '`todo items returns empty list`: This test case uses the `jq` command to pass
    the output calling the `/todos` path. Note that because you can''t use pipes in
    conjunction with the special `run` function, I have used the bash process substitution
    syntax, `<(...)`, to make the output of the `curl` command appear as a file that
    is being read by the `jq` command.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`todo items returns empty list`：这个测试用例使用`jq`命令传递调用`/todos`路径的输出。请注意，由于不能在特殊的`run`函数中使用管道，我已经使用了bash进程替换语法`<(...)`，使`curl`命令的输出看起来像是被`jq`命令读取的文件。'
- en: '`create todo item`: This first creates a todo item, checks whether the returned
    exit code is zero, and then uses a *bash conditional expression* (as indicated
    by the `[[...]]` syntax) to verify that the output of the `curl` command includes `201
    Created` in the HTTP response, which is a standard response when creating an item.
    When using the bash conditional expressions, it is important to note that BATS
    will not detect an error if the conditional expression fails, hence we use the `||
    false` special syntax, which is only evaluated in the event the conditional expression
    fails and returns a non-zero response of `false`, causing the test case to fail
    if the test expression fails. The conditional expressions use the `=~` regular
    expression operator (this operator is not available in conditional expressions,
    hence our use of bash test expressions), with the second conditional expression
    evaluating the `location` regular expression defined in the setup function. The
    final command uses the special `BASH_REMATCH` variable that includes the results
    of the most recent conditional expression evaluation, which in this case is the
    URL matched in the Location header. This allows us to capture the returned location
    when we create a Todo item, and verify that the created item matches the item
    that we posted.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建待办事项：首先创建一个待办事项，检查返回的退出代码是否为零，然后使用* bash条件表达式*（如`[[...]]`语法所示）来验证`curl`命令的输出是否包含HTTP响应中的`201
    Created`，这是创建事项时的标准响应。在使用bash条件表达式时，重要的是要注意，如果条件表达式失败，BATS不会检测到错误，因此我们使用`|| false`特殊语法，该语法仅在条件表达式失败并返回非零响应`false`时才会被评估，如果测试表达式失败，测试用例将失败。条件表达式使用`=~`正则表达式运算符（此运算符在条件表达式中不可用，因此我们使用bash测试表达式），第二个条件表达式评估了设置函数中定义的`location`正则表达式。最后一个命令使用特殊的`BASH_REMATCH`变量，其中包含最近一次条件表达式评估的结果，本例中是在Location标头中匹配的URL。这允许我们在创建待办事项时捕获返回的位置，并验证创建的事项是否与我们发布的事项匹配。
- en: '`delete todo item`: This creates a Todo item, captures the location returned
    for the item, deletes the item, and then verifies that the item was in fact deleted
    by verifying the number of Todo items in the database is zero after the deletion.
    Recall that the setup function runs before each test case, which clears all Todo
    items, hence at the beginning of this test case the Todo item count will always
    be zero, and the action of creating and then deleting an item should always return
    the count to zero.  The various commands used in this test case are based upon
    the concepts introduced in the `create todo item` test case, hence I won''t describe
    each command in detail.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除待办事项：这将创建一个待办事项，捕获返回的位置，删除该事项，然后验证事项是否被删除，验证数据库中的待办事项数量在删除后是否为零。请记住，设置函数在每个测试用例运行之前运行，它会清除所有待办事项，因此在这个测试用例开始时，待办事项数量始终为零，创建和删除事项的操作应该总是将数量返回为零。此测试用例中使用的各种命令基于“创建待办事项”测试用例中介绍的概念，因此我不会详细描述每个命令。
- en: Now that we have define a suite of acceptance tests, it's time to modify the
    Docker environment to support the execution of these tests once the application
    is started successfully.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一套验收测试，是时候修改Docker环境，以支持在应用程序成功启动后执行这些测试。
- en: 'We first need to add the `curl`, `bats`, and `jq` packages to the `Dockerfile` at
    the root of the todobackend repository:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要将`curl`，`bats`和`jq`软件包添加到todobackend存储库根目录下的`Dockerfile`中。
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next we need to add a new service called `acceptance` to the `docker-compose.yml`
    file, which will wait until the `app` service is healthy and then run acceptance
    tests:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要向“docker-compose.yml”文件添加一个名为“acceptance”的新服务，该服务将等待“app”服务健康，然后运行验收测试。
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We first add a `healthcheck` property to the `app` service, which uses the `curl`
    utility to check connectivity to the local web server endpoint.  We then define
    the acceptance service, which we extend from the `release` image and configure with
    the `APP_URL` environment variable, which configures the correct URL the acceptance
    tests should be executed against, whilst  the `command` and `depends_on` properties
    are used to run the acceptance tests once the `app` service is healthy.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为`app`服务添加了一个`healthcheck`属性，它使用`curl`实用程序来检查与本地Web服务器端点的连接。然后，我们定义了接受服务，我们从`release`镜像扩展，并配置了`APP_URL`环境变量，该变量配置了应该针对执行接受测试的正确URL，而`command`和`depends_on`属性用于在`app`服务健康时运行接受测试。
- en: 'With this configuration in place, you now need to tear down the current environment,
    rebuild all images, and perform the various steps to get the application up and
    running, except when you get to the point where you are about to run the `docker-compose
    up app` command, you should now run the `docker-compose up acceptance` command,
    as this will automatically start the `app` service in the background:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个配置，现在您需要拆除当前的环境，重建所有镜像，并执行各种步骤来启动应用程序，除非您到了即将运行`docker-compose up app`命令的时候，您现在应该运行`docker-compose
    up acceptance`命令，因为这将自动在后台启动`app`服务：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, all tests pass successfully, as indicated by the `ok` status
    for each test.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，所有测试都通过了，每个测试都显示了`ok`状态。
- en: Automating the workflow
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化工作流程
- en: At this point, you have managed to successfully configure Docker Compose to
    build, test, and create a working local environment for the sample application,
    complete with MySQL database integration and acceptance tests.  You can now stand
    up this environment with a handful of commands, but even though using Docker Compose
    has significantly simplified the commands you need to run, it is still difficult
    to remember which commands to use and in which order. Ideally we want a single
    command to run the complete workflow, and this is where a tool such as GNU Make
    is very useful.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已成功配置了Docker Compose来构建、测试和创建样本应用程序的工作本地环境，包括MySQL数据库集成和接受测试。现在，您可以用少数命令来启动这个环境，但即使使用Docker
    Compose大大简化了您需要运行的命令，仍然很难记住要使用哪些命令以及以什么顺序。理想情况下，我们希望有一个单一的命令来运行完整的工作流程，这就是GNU
    Make这样的工具非常有用的地方。
- en: Make has been around a long time, and is still considered the build tool of
    choice for many C and C++ applications. Task automation is a key feature of Make,
    and the ability to define tasks or targets in a simple format that can be invoked
    with a single command has made Make a popular automation tool, particularly when
    dealing with Docker containers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Make已经存在很长时间了，仍然被认为是许多C和C++应用程序的首选构建工具。任务自动化是Make的一个关键特性，能够以简单的格式定义任务或目标，并且可以通过单个命令调用，这使得Make成为一个流行的自动化工具，特别是在处理Docker容器时。
- en: 'By convention make looks for a file, called Makefile, in the current working
    directory, and you can create a very simple Makefile, as demonstrated here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，make会在当前工作目录中寻找一个名为Makefile的文件，您可以创建一个非常简单的Makefile，就像这里演示的那样：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding example, you create a *target* called `hello` with two shell
    commands, which you can execute by running `make <target>`, or `make hello` in
    this example.  Each target can include one or more commands, which are executed
    in the sequence provided.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您创建了一个名为`hello`的*目标*，其中包含两个shell命令，您可以通过运行`make <target>`或在这个例子中运行`make
    hello`来执行这些命令。每个目标可以包括一个或多个命令，这些命令按照提供的顺序执行。
- en: 'One important point to note is that make expects tabs (not spaces) to be used
    when you define the various commands for a given target, so if you receive a missing
    separator error, such as `Makefile:2: *** missing separator. Stop.`, check that
    you have used tabs to indent each command.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '需要注意的一点是，make期望在为给定目标定义各种命令时使用制表符（而不是空格），因此如果你收到缺少分隔符的错误，比如“Makefile:2: ***
    missing separator. Stop.”，请检查你是否使用了制表符来缩进每个命令。'
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding example, you can see that the output of the each command is
    displayed on screen. Note that the special `@` character on the first command
    suppresses echoing each command as it is run.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，你可以看到每个命令的输出都显示在屏幕上。请注意，第一个命令上的特殊字符“@”会抑制每个命令的回显。
- en: Any decent modern text editor, such as Sublime Text or Visual Studio Code, should
    automatically take care of tabs for you in Makefiles.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 任何像Sublime Text或Visual Studio Code这样的体面的现代文本编辑器都应该自动处理Makefiles中的制表符。
- en: 'One important piece of housekeeping you should perform in your Makefiles when
    using them for task automation is to configure the somewhat amusingly-named special target called `.PHONY`, with
    the names of each target that you will be executing:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Makefiles进行任务自动化时，你应该执行一个重要的清理工作，即配置一个名为“.PHONY”的特殊目标，并列出你将要执行的每个目标的名称：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Because `make` is really a build tool for compiling source code files, the `.PHONY` target
    tells make that if it sees a file named `hello`, it should still run the target.
    If you didn't specify `.PHONY` and there was a file called `hello` in the local
    directory, make would exit stating that the `hello` file has already been built. 
    This clearly doesn't make much sense when you are using make to automate tasks,
    so you should always use the `.PHONY` target to avoid any strange surprises.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因为“make”实际上是一个用于编译源代码文件的构建工具，所以“.PHONY”目标告诉make，如果它看到一个名为“hello”的文件，它仍然应该运行该目标。如果你没有指定“.PHONY”，并且本地目录中有一个名为“hello”的文件，make将退出并声明“hello”文件已经构建完成。当你使用make来自动化任务时，这显然没有多大意义，所以你应该始终使用“.PHONY”目标来避免任何奇怪的意外。
- en: Automating the test stage
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试阶段
- en: 'Now that you have been introduced to make, let''s modify our Makefile to do
    something that is actually useful, and execute the various actions performed during
    the test stage. Recall that the test stage involves building the first stage of
    the Dockerfile as a service, called `test`, and then running the `test` service,
    which by default will run the  `python3 manage.py test` command, executing application
    unit tests:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了如何制作，让我们修改我们的Makefile，以执行实际有用的操作，并执行测试阶段执行的各种操作。回想一下，测试阶段涉及构建Dockerfile的第一个阶段作为一个名为“test”的服务，然后运行“test”服务，默认情况下将运行“python3
    manage.py test”命令，执行应用程序单元测试：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that rather than building the `test` service in the Docker Compose file,
    we actually build the release service and specify the `--pull` flag, which ensures
    that Docker will always check whether there are any newer releases of the Docker
    image referenced in the `FROM` directive. We build the `release` service this way
    because we only want to build the entire `Dockerfile` once, rather than rebuild
    the `Dockerfile` on each stage execution.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们实际上并没有在Docker Compose文件中构建“test”服务，而是构建了发布服务并指定了“--pull”标志，这确保Docker始终检查Docker镜像中的任何更新版本。我们以这种方式构建“release”服务，因为我们只想构建整个“Dockerfile”一次，而不是在每个阶段执行时重新构建“Dockerfile”。
- en: This guards against the unlikely, yet still possible, scenario where you could
    pull a newer base image if rebuilding during the release stage, which may result
    in a different runtime environment to what you tested in the test stage.  We also
    run the docker-compose build command immediately afterwards, which ensures all
    services are built before we run tests.  Because we built the entire `Dockerfile`
    in the previous command, this will ensure any cached images for other services
    are updated to the newest image build.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以防止一个不太可能但仍然可能发生的情况，即在发布阶段重新构建时，您可能会拉取一个更新的基础镜像，这可能导致与您在测试阶段测试的不同的运行时环境。我们还立即运行docker-compose
    build命令，这可以确保在运行测试之前构建所有服务。因为我们在前一个命令中构建了整个`Dockerfile`，这将确保其他服务的缓存镜像都更新为最新的镜像构建。
- en: Automating the release stage
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化发布阶段
- en: 'After completing the test stage, we next run the release stage, which requires
    us to perform the following actions:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 完成测试阶段后，我们接下来运行发布阶段，这需要我们执行以下操作：
- en: Run database migrations
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行数据库迁移
- en: Collect static files
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集静态文件
- en: Start the application
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动应用程序
- en: Run acceptance tests
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行验收测试
- en: 'The following demonstrates creating a target, called `release`, in the Makefile:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下演示了在Makefile中创建一个名为`release`的目标：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice that we execute each of the required commands with one minor variation,
    which is to add the `--abort-on-container-exit` command to each of the `docker-compose
    up` commands.  By default, the `docker-compose up` command will not return a non-zero
    exit code should any of the container(s) started by the command fail. This flag
    allows you to override this and specify should any service fail that was started
    by the `docker-compose up` command, then Docker Compose should exit with an error.
    Setting this flag is important if you want your make commands to fail whenever
    there is an error.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们执行所需命令的每一个时，都会有一个小变化，即在每个`docker-compose up`命令中添加`--abort-on-container-exit`命令。默认情况下，`docker-compose
    up`命令不会返回非零退出代码，如果命令启动的任何容器失败。这个标志允许您覆盖这一点，并指定任何由`docker-compose up`命令启动的服务失败，那么Docker
    Compose应该以错误退出。如果您希望在出现错误时使您的make命令失败，设置此标志是很重要的。
- en: Refining the workflow
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完善工作流程
- en: There's a few more minor enhancements we can make to the workflow that will
    ensure we have a robust, consistent, and portable mechanism for testing and building
    our application.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些更小的增强可以应用到工作流程中，这将确保我们有一个强大、一致和可移植的测试和构建应用程序的机制。
- en: Cleaning up the Docker environment
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理Docker环境
- en: Throughout this chapter, we have been cleaning up our environment by running
    the `docker-compose down` command, which stops and destroys any containers associated
    with the todobackend Docker Compose environment.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们一直通过运行`docker-compose down`命令来清理我们的环境，该命令停止并销毁与todobackend Docker Compose环境相关的任何容器。
- en: 'One other aspect of housekeeping that you need to be aware of when building
    Docker images is the concept of orphaned or dangling images, which are images
    that have been superseded by a newer build. You can get a sense of this by running
    the `docker images` command, and I have indicated which images are dangling in
    bold:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Docker镜像时，您需要注意的另一个方面是孤立或悬空的镜像的概念，这些镜像已经被新版本取代。您可以通过运行`docker images`命令来了解这一点，我已经用粗体标出了哪些镜像是悬空的：
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that each highlighted image has no repository and no tag, hence why they
    are referred to as orphaned or dangling. These dangling images are of no use and
    take up resources and storage, so it is ideal that you clean up these images regularly,
    to ensure the performance of your Docker environment. Back in our Dockerfile,
    we added the `LABEL` directive to each stage, which allows for easy identification
    of images that relate to our todobackend application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个突出显示的图像都没有存储库和标签，因此它们被称为孤立或悬空。这些悬空图像没有用处，占用资源和存储空间，因此最好定期清理这些图像，以确保Docker环境的性能。回到我们的Dockerfile，我们在每个阶段添加了`LABEL`指令，这允许轻松识别与我们的todobackend应用相关的图像。
- en: 'We can leverage these labels to target dangling images built for the todobackend
    application, so let''s add a new target, called `clean`, to our Makefile, which
    brings down the Docker Compose environment and removes dangling images:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这些标签来定位为todobackend应用构建的悬空图像，因此让我们在Makefile中添加一个名为`clean`的新目标，该目标关闭Docker
    Compose环境并删除悬空图像。
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We use the `-q` flag to only print out image IDs, and then use the `-f` flag
    to add filters that specify to only show dangling images that have a label of `application=todobackend`.
    We then pipe the output of this command to the `xargs` command, which captures
    the list of filtered images in the `ARGS` parameter and passes `ARGS` to the `docker
    rmi -f --no-prune` command, removing the images forcibly as specified by the `-f` flag
    with the `--no-prune` flag ensuring any untagged images that include layers from
    current tagged images are not removed. We use `xargs` here because it deals with
    the list of images intelligently – for example, if there are no images to delete,
    then `xargs` exits silently without an error.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-q`标志仅打印出图像ID，然后使用`-f`标志添加过滤器，指定仅显示具有`application=todobackend`标签的悬空图像。然后将此命令的输出导入到`xargs`命令中，`xargs`捕获过滤图像列表并将其传递给`docker
    rmi -f --no-prune`命令，根据`-f`标志强制删除图像，并使用`--no-prune`标志确保不删除包含当前标记图像层的未标记图像。我们在这里使用`xargs`是因为它能智能地处理图像列表-例如，如果没有要删除的图像，那么`xargs`会在没有错误的情况下静默退出。
- en: 'The following demonstrates the output of running the `make clean` command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下演示了运行`make clean`命令的输出：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: One thing you may notice when running the `make clean` command is that stopping
    the todobackend app service takes some time, in fact, it takes around 10 seconds
    to stop. This is because Docker first sends a SIGTERM signal to the container
    when stopping a container, which signals to the container that it is about to
    be terminated.  By default, if the container does not exit within 10 seconds,
    Docker sends a SIGKILL signal, which forcibly terminates the container.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行`make clean`命令时，您可能会注意到一件事，即停止todobackend应用服务需要一些时间，实际上，需要大约10秒才能停止。这是因为在停止容器时，Docker首先向容器发送SIGTERM信号，这会向容器发出即将被终止的信号。默认情况下，如果容器在10秒内没有退出，Docker会发送SIGKILL信号，强制终止容器。
- en: 'The problem here is that the `uwsgi` process running in our app container ignores
    SIGTERM signals by default, so we need to add the `--die-on-term` flag in the
    Docker Compose file that configures `uwsgi` to shut down if it receives a SIGTERM
    signal, ensuring it will be able to shut down gracefully and in a timely fashion:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们应用容器中运行的`uwsgi`进程默认情况下会忽略SIGTERM信号，因此我们需要在配置`uwsgi`的Docker Compose文件中添加`--die-on-term`标志，以确保它能够优雅地和及时地关闭，如果收到SIGTERM信号。
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding example, I have also added the `--processes` and `--threads` flags,
    which enable concurrent processing.  You can read about these and more configuration
    options at [https://uwsgi-docs.readthedocs.io/en/latest/WSGIquickstart.html#adding-concurrency-and-monitoring](https://uwsgi-docs.readthedocs.io/en/latest/WSGIquickstart.html#adding-concurrency-and-monitoring).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我还添加了`--processes`和`--threads`标志，这些标志启用并发处理。您可以在[https://uwsgi-docs.readthedocs.io/en/latest/WSGIquickstart.html#adding-concurrency-and-monitoring](https://uwsgi-docs.readthedocs.io/en/latest/WSGIquickstart.html#adding-concurrency-and-monitoring)中了解更多配置选项。
- en: Using dynamic port mapping
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态端口映射
- en: Currently, the release stage workflow runs the application using a static port-mapping,
    where port 8000 on the app service container is mapped to port `8000` on your
    Docker Engine. Although this will typically work fine when running locally (unless
    you have some other application that is using port 8000), this may cause problems
    when it comes to running the release-stage workflow on a remote continuous-delivery
    build service, which may be running multiple builds for many different applications.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，发布阶段工作流程使用静态端口映射运行应用程序，其中app服务容器上的端口8000映射到Docker Engine上的端口`8000`。尽管在本地运行时通常可以正常工作（除非有其他使用端口8000的应用程序），但是在远程持续交付构建服务上运行发布阶段工作流程时可能会导致问题，该服务可能正在为许多不同的应用程序运行多个构建。
- en: A better approach is to use dynamic port-mapping, which maps the `app` service
    container port to a dynamic port on your Docker Engine that is currently not in
    use. The port is picked from what is referred to as the *ephemeral port range*,
    which is a port range reserved for dynamic use by applications.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用动态端口映射，将`app`服务容器端口映射到Docker Engine上当前未使用的动态端口。端口是从所谓的*临时端口范围*中选择的，这是一个为应用程序动态使用保留的端口范围。
- en: 'To configure dynamic port-mapping, you need to change the port-mapping in the `docker-compose.yml` file
    for the `app` service:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置动态端口映射，您需要在`docker-compose.yml`文件中的`app`服务中更改端口映射：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the preceding example, we simply change the port-mapping from a static mapping
    of `8000:8000` to `8000`, which enables dynamic port-mapping. With this configuration
    in place, one problem is that you don''t know in advance what port is going to
    be assigned, however, you can use the `docker-compose port <service> <container-port>` command
    to determine the current dynamic port-mapping for a given service on a given container
    port:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们只是将端口映射从`8000:8000`的静态映射更改为`8000`，这样就可以启用动态端口映射。有了这个配置，一个问题是您事先不知道将分配什么端口，但是您可以使用`docker-compose
    port <service> <container-port>`命令来确定给定服务在给定容器端口上的当前动态端口映射：
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Of course, rather than manually type this command each time, we can incorporate
    it into our automation workflow:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，与其每次手动输入此命令，我们可以将其纳入自动化工作流程中：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding example, we use a command substitution to obtain the current
    port-mapping and pipe the output to a `sed` expression that replaces `0.0.0.0` with `localhost`.
    Note that because GNU Make interprets the dollar sign symbol as a Make variable
    reference, you are required to double-escape dollar signs (`$$`) if you want a
    single dollar sign evaluated by the shell command that will be executed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们使用命令替换来获取当前的端口映射，并将输出传输到一个`sed`表达式，将`0.0.0.0`替换为`localhost`。请注意，因为GNU
    Make将美元符号解释为Make变量引用，如果您希望shell命令执行时评估单个美元符号，则需要双重转义美元符号（`$$`）。
- en: 'With this in place, the output of the `make release` command will now complete
    with the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个配置，`make release`命令的输出现在将完成如下：
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Adding a version target
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加版本目标
- en: Versioning your applications is critical, particularly when building Docker
    images and you want to distinguish between various images. Later on, when we publish
    our Docker images, we will need to include a version tag on each published image,
    and a simple convention for versioning is to use the Git commit hash of the current
    commit in your application repository.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对应用程序进行版本控制非常重要，特别是在构建Docker镜像时，您希望区分各种镜像。稍后，当我们发布我们的Docker镜像时，我们将需要在每个发布的镜像上包含一个版本标签，版本控制的一个简单约定是在应用程序存储库中使用当前提交的Git提交哈希。
- en: 'The following demonstrates how you can capture this in a Make variable and
    display the current version:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下演示了如何在一个Make变量中捕获这个，并显示当前版本：
- en: '[PRE48]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We first declare a variable called `APP_VERSION` and prefix this with the `export`
    keyword, which means the variable will be available in the environment for each
    target. We then use a Make function called `shell` to execute the `git rev-parse
    --short HEAD` command, which returns the seven-character short hash of the current
    commit. Finally, we add a new target, called `version`, that simply prints the
    version in a JSON format to the terminal, which will be useful later in this book
    when we automate the continuous delivery of our application.  Note that `make`
    uses the dollar sign to reference variables and also to execute Make functions,
    which you can read more about at [https://www.gnu.org/software/make/manual/html_node/Functions.html](https://www.gnu.org/software/make/manual/html_node/Functions.html).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明一个名为`APP_VERSION`的变量，并在前面加上`export`关键字，这意味着该变量将在每个目标的环境中可用。然后，我们使用一个名为`shell`的Make函数来执行`git
    rev-parse --short HEAD`命令，该命令返回当前提交的七个字符的短哈希。最后，我们添加一个名为`version`的新目标，它简单地以JSON格式打印版本到终端，这在本书后面当我们自动化应用程序的持续交付时将会很有用。请注意，`make`使用美元符号来引用变量，也用来执行Make函数，您可以在[https://www.gnu.org/software/make/manual/html_node/Functions.html](https://www.gnu.org/software/make/manual/html_node/Functions.html)了解更多信息。
- en: If you just run the `make` command without specifying a target, make will execute
    the first target in the Makefile. This means, for our scenario, just running `make` will
    output the current version.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只运行`make`命令而没有指定目标，make将执行Makefile中的第一个目标。这意味着，对于我们的情况，只运行`make`将输出当前版本。
- en: 'The following demonstrates running the `make version` command:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下演示了运行`make version`命令：
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Testing the end-to-end workflow
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试端到端工作流
- en: At this point, all of the pieces of our local Docker workflow are in place,
    and now is a good time to review the workflow and verify everything is working.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们本地Docker工作流的所有部分都已就位，现在是审查工作流并验证一切是否正常运行的好时机。
- en: 'The core workflow now consists of the following tasks:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 核心工作流现在包括以下任务：
- en: Run the test stage – `make test`
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试阶段 - `make test`
- en: Run the release stage – `make release`
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行发布阶段 - `make release`
- en: Clean up – `make clean`
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理 - `make clean`
- en: I will leave this up to you to test, but I encourage you to get comfortable
    with the workflow and ensure everything completes without error.  After running `make
    release`, verify you can navigate to the application, the application displays
    HTML content correctly, and that you can perform create, read, update, and delete
    operations.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我会把这个测试留给你，但我鼓励你熟悉这个工作流程，并确保一切都能顺利完成。运行`make release`后，验证您是否可以导航到应用程序，应用程序是否正确显示HTML内容，以及您是否可以执行创建、读取、更新和删除操作。
- en: Once you are satisfied everything is working as expected, ensure you have committed
    and pushed your changes to the GitHub repository you forked in the previous chapter.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您确信一切都按预期工作，请确保已提交并推送您在上一章中分叉的GitHub存储库的更改。
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you implemented a Docker workflow that tests, builds, and packages
    your application into a Docker image that is ready to publish and deploy to production.
    You learned how you can build your application in two stages using Docker multi-stage
    builds—the test stage uses a development environment complete with development
    libraries and source compilation tools that allows you to build and test your
    application and its dependencies in precompiled packages, while the release stage
    takes those built packages and installs them into a production-ready operating
    environment, free of development libraries and other tools, significantly reducing
    the attack surface of your application.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您实现了一个Docker工作流，用于测试、构建和打包应用程序成一个Docker镜像，准备发布和部署到生产环境。您学会了如何使用Docker多阶段构建来构建应用程序的两个阶段——测试阶段使用开发环境，包括开发库和源代码编译工具，允许您构建和测试应用程序及其依赖关系的预编译包；而发布阶段则将这些构建好的包安装到一个生产就绪的操作环境中，不包含开发库和其他工具，显著减少了应用程序的攻击面。
- en: You learned how you to use Docker Compose to help simplify the various commands
    and actions you need to perform during the test and release stages, creating a
    `docker-compose.yml` file with a number of services, each defined in a declarative,
    easy-to-understand format. You learned how to replicate a number of deployment
    tasks required to get your application up and running, such as running database
    migrations, collecting static files, and ensuring the application database was
    healthy before you attempted to run your application. Being able to perform each
    of these tasks in a local environment provides you with the confidence and understanding
    of how these tasks will work in your actual production environments, and gives
    you early warning should any of your application or configuration changes break
    these processes locally. After starting your application in the correct state
    and connected to the application database, you learned how you can run acceptance
    tests from the point of view of an external client, which gives you great confidence
    that your image is working as expected, and early warning when these acceptance
    tests fail as part of the ongoing development of your application.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您学会了如何使用Docker Compose来简化测试和发布阶段需要执行的各种命令和操作，创建了一个`docker-compose.yml`文件，其中包含了一些服务，每个服务都以一种声明性、易于理解的格式进行定义。您学会了如何复制一些部署任务，例如运行数据库迁移、收集静态文件，并确保应用程序数据库在尝试运行应用程序之前是健康的。在本地环境中执行每个任务使您能够对这些任务在实际生产环境中的工作方式有信心和了解，并在本地出现任何应用程序或配置更改破坏这些过程时提前警告。在将应用程序处于正确状态并连接到应用程序数据库后，您学会了如何从外部客户端的角度运行验收测试，这让您对镜像是否按预期工作有了很大的信心，并在这些验收测试在应用程序持续开发过程中失败时提前警告。
- en: Finally, you learned how to bring all of this together in a fully automated
    workflow using GNU Make, which provides you with simple high-level commands that
    you can use to execute the workflow. You now have the ability to execute the test
    stage by simply running `make test`, run the release stage by running `make release`,
    and clean up your environment using `make clean`. This makes it very easy to run
    the workflow, and later in this book, will simplify the configuration of continuous-delivery
    build systems that we will be using to automatically test, build, and publish
    your Docker applications.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学会了如何使用GNU Make将所有这些内容整合到一个完全自动化的工作流程中，它为你提供了简单的高级命令，可以用来执行工作流程。现在你可以通过简单地运行`make
    test`来执行测试阶段，通过运行`make release`来运行发布阶段，并使用`make clean`清理你的环境。这使得运行工作流程变得非常容易，并且在本书的后面，将简化我们将使用的自动测试、构建和发布Docker应用程序的持续交付构建系统的配置。
- en: In coming chapters, you will learn how to actually publish the Docker release
    image you created in this chapter, but before you can do this, you need to establish
    an AWS account, configure access to your account, and install tools that support
    interacting with AWS, which will be the focus of the next chapter.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将学习如何实际发布你在本章中创建的Docker发布镜像，但在你这样做之前，你需要建立一个AWS账户，配置对你的账户的访问，并安装支持与AWS交互的工具，这将是下一章的重点。
- en: Questions
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'True/false: You use the `FROM` and `TO` directives to define a multi-stage
    Dockerfile.'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：你使用`FROM`和`TO`指令来定义多阶段Dockerfile。
- en: 'True/false: The `docker` command `--rm` flag automatically deletes a container
    after it has exited.'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：`docker`命令的`--rm`标志在容器退出后自动删除容器。
- en: 'True/false: When you run your workflow, you should only build application artifacts
    once.'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：当运行你的工作流程时，你应该只构建应用程序构件一次。
- en: 'True/false: When running the `docker-compose run` command with no additional
    flags, if the targeted services started fails with an error, docker-compose will
    exit with a non-zero code.'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：当运行`docker-compose run`命令时，如果目标服务启动失败并出现错误，docker-compose将以非零代码退出。
- en: 'True/false: When running the `docker-compose up` command with no additional
    flags, if one of the services started fails with an error, docker-compose will
    exit with a non-zero code.'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：当运行`docker-compose up`命令时，如果其中一个服务启动失败并出现错误，docker-compose将以非零代码退出。
- en: 'True/false: You should configure a Docker Compose version of 3.x if you want
    to use Docker Swarm.'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：如果你想使用Docker Swarm，你应该配置一个Docker Compose版本为3.x。
- en: You configure the service_healthy condition on a dependency of a service in
    your Docker file.  Then you run the service using the `docker-compose run` command;
    the dependency is started, however, Docker Compose does not wait until the dependency
    is healthy and starts the service immediately, causing a failure. How could you
    resolve this?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在Docker文件中为一个服务的依赖项配置了service_healthy条件。然后你使用`docker-compose run`命令运行服务；依赖项已启动，然而Docker
    Compose并不等待依赖项健康，而是立即启动服务，导致失败。你如何解决这个问题？
- en: You create a service in Docker Compose with a port-mapping of `8000:8000`. When
    you attempt to start this service, an error is raised indicating the port is in
    use. How could you resolve this and ensure it never happens again?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在Docker Compose中创建了一个服务，端口映射为`8000:8000`。当你尝试启动这个服务时，会出现一个错误，指示端口已被使用。你如何解决这个问题，并确保它不会再次发生呢？
- en: After creating a Makefile, you receive an error about a missing separator when
    attempting to run a target. What is the most likely cause of this error?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Makefile后，当尝试运行一个目标时，收到一个关于缺少分隔符的错误。这个错误最有可能的原因是什么？
- en: Which GNU Make function allows you to capture the output of a shell command?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个GNU Make函数允许你捕获shell命令的输出？
- en: You define a target called test in a Makefile, however when you run `make test`,
    you get a response saying there is nothing to do. How could you resolve this?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Makefile中定义了一个名为test的目标，但是当你运行`make test`时，你会得到一个回应说没有什么可做的。你该如何解决这个问题呢？
- en: Which properties must be configured in a Docker Compose service definition to
    use the `docker-compose push` command?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Docker Compose服务定义中必须配置哪些属性才能使用`docker-compose push`命令？
- en: Further reading
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can check the following links for more information about the topics covered
    in this chapter:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看以下链接，了解本章涵盖的主题的更多信息：
- en: Docker Command-Line Reference: [https://docs.docker.com/engine/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/)
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker命令行参考：[https://docs.docker.com/engine/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/)
- en: Docker multi-stage builds: [https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/)
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker多阶段构建：[https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/)
- en: Docker Compose Version 2 Specification: [https://docs.docker.com/compose/compose-file/compose-file-v2/](https://docs.docker.com/compose/compose-file/compose-file-v2/)
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose版本2规范：[https://docs.docker.com/compose/compose-file/compose-file-v2/](https://docs.docker.com/compose/compose-file/compose-file-v2/)
- en: Docker Compose Command-Line Reference: [https://docs.docker.com/compose/reference/](https://docs.docker.com/compose/reference/)
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose命令行参考：[https://docs.docker.com/compose/reference/](https://docs.docker.com/compose/reference/)
- en: Docker Compose start order: [https://docs.docker.com/compose/startup-order/](https://docs.docker.com/compose/startup-order/)
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose启动顺序：[https://docs.docker.com/compose/startup-order/](https://docs.docker.com/compose/startup-order/)
- en: uWSGI Quickstart for Python Applications: [http://uwsgi-docs.readthedocs.io/en/latest/WSGIquickstart.html](http://uwsgi-docs.readthedocs.io/en/latest/WSGIquickstart.html)
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uWSGI Python应用程序快速入门：[http://uwsgi-docs.readthedocs.io/en/latest/WSGIquickstart.html](http://uwsgi-docs.readthedocs.io/en/latest/WSGIquickstart.html)
- en: Bash-Automated Test System: [https://github.com/sstephenson/bats](https://github.com/sstephenson/bats)
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash自动化测试系统：[https://github.com/sstephenson/bats](https://github.com/sstephenson/bats)
- en: GNU Make Phony Targets: [https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html](https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html)
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU Make虚假目标：[https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html](https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html)
- en: GNU Make Functions: [https://www.gnu.org/software/make/manual/html_node/Functions.html#Functions](https://www.gnu.org/software/make/manual/html_node/Functions.html#Functions)
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU Make函数：[https://www.gnu.org/software/make/manual/html_node/Functions.html#Functions](https://www.gnu.org/software/make/manual/html_node/Functions.html#Functions)
