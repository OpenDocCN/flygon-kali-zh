- en: Event Registration App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动注册应用程序
- en: Hopefully, you had a lot of fun creating memes and sharing them with your friends!
    You successfully built a Meme Creator in the previous project using HTML5 canvas.
    You also used flexbox to design the page layout and learned a few things regarding
    ES6 modules.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您在创建表情并与朋友分享时玩得很开心！您在上一个项目中成功使用HTML5画布构建了一个表情创作器。您还使用了flexbox来设计页面布局，并学习了有关ES6模块的一些知识。
- en: The most important part of the previous chapter was the development environment
    we created with Webpack. It lets us develop applications faster with `HotModuleReplacement`,
    create an optimized production build with single file assets and reduced code
    size, and also hides the original source code from the user, while we can use
    source maps to debug the original code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章最重要的部分是我们使用Webpack创建的开发环境。它让我们可以使用`HotModuleReplacement`更快地开发应用程序，创建具有单个文件资产和减小代码大小的优化生产构建，并且还可以隐藏原始源代码，同时我们可以使用源映射来调试原始代码。
- en: 'Now that we have module support, we can use it to create modular functions,
    which will allow us to write reusable code that can be used across different parts
    of the project or can also be used with a different project. In this chapter,
    you are going to build an Event Registration app while learning the following
    concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了模块支持，我们可以使用它来创建模块化函数，这将允许我们编写可重用的代码，可以在项目的不同部分之间使用，也可以在不同的项目中使用。在本章中，您将构建一个活动注册应用程序，同时学习以下概念：
- en: Writing ES6 modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写ES6模块
- en: Form validation with JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaScript进行表单验证
- en: Working with dynamic data (data loaded from the server)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态数据（从服务器加载的数据）
- en: Making AJAX requests using fetch
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用fetch进行AJAX请求
- en: Working with asynchronous functions using Promises
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Promises处理异步函数
- en: Creating charts using Chart.js
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Chart.js创建图表
- en: Event - JS meetup
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动 - JS聚会
- en: 'Here is the scenario for our project:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们项目的情景：
- en: 'You are organizing a JavaScript meetup in your locality. You have invited people
    from schools, colleges, and offices, who are all interested in JavaScript. You
    need to create a website for attendees to register for the event. The website
    should have the following functionalities:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在本地组织一个JavaScript聚会。您邀请了来自学校、大学和办公室的对JavaScript感兴趣的人。您需要为与会者创建一个注册活动的网站。该网站应具有以下功能：
- en: A form to help users register for the event
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助用户注册活动的表单
- en: A page that shows statistics on the number of users interested in the event
    as a chart
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示对活动感兴趣的用户数量的统计数据页面
- en: An about page with event details and the location of the event embedded as a
    Google Map
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于页面，包括活动详情和活动位置的Google地图嵌入
- en: Also, most of the people will be using mobile phones to register for the event.
    So, the application should be fully responsive.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，大多数人将使用手机注册活动。因此，应用程序应完全响应。
- en: 'This is how the app should look on mobiles:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序在手机上的样子：
- en: '![](../images/00020.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00020.jpeg)'
- en: Initial project setup
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始项目设置
- en: 'To get started with the project, open up the starter files for Chapter 3 in
    VSCode. Create a `.env` file with the values from the `.env.example` file. Assign
    the following values to each environment variable:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始项目，请在VSCode中打开第3章的起始文件。创建一个`.env`文件，并使用`.env.example`文件中的值。为每个环境变量分配以下值：
- en: '`NODE_ENV=dev`: Should be set to `production` when generating a build.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NODE_ENV=dev`：在生成构建时应设置为`production`。'
- en: '`SERVER_URL=http://localhost:3000`: We will soon have a server running in this
    URL.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SERVER_URL=http://localhost:3000`：我们很快将在此URL上运行服务器。'
- en: '`GMAP_KEY`: We are going to use the Google Maps API in this project. You need
    to generate your unique API key to use Google Maps. See: [https://developers.google.com/maps/documentation/javascript/get-api-key](https://developers.google.com/maps/documentation/javascript/get-api-key) to
    generate your API key and add the key to this environment variable.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GMAP_KEY`：我们将在此项目中使用Google Maps API。您需要生成自己的唯一API密钥以使用Google Maps。请参阅：[https://developers.google.com/maps/documentation/javascript/get-api-key](https://developers.google.com/maps/documentation/javascript/get-api-key)
    生成您的API密钥，并将密钥添加到此环境变量中。'
- en: Earlier in [Chapter 2](part0046.html#1BRPS0-f852807d0cb141b58fff8f992d32cbb7),
    *Building a Meme Creator*, I mentioned that you cannot access your JavaScript
    variables inside HTML when the modules are bundled with Webpack. In [Chapter 1](part0022.html#KVCC0-f852807d0cb141b58fff8f992d32cbb7),
    *Building a ToDo List*, we used the HTML attribute to call a JavaScript function.
    This might look useful, but it will also expose our object structure to users
    (I'm referring to other developers visiting your page). Users can get a clear
    idea of how the `ToDoClass` class is structured by inspecting the object using
    Chrome DevTools. This should be prevented while building large-scale applications.
    Hence, Webpack does not allow variables to be present in the global scope.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0046.html#1BRPS0-f852807d0cb141b58fff8f992d32cbb7)中，*构建表情创作器*，我提到当模块与Webpack捆绑在一起时，您无法在HTML中访问JavaScript变量。在[第1章](part0022.html#KVCC0-f852807d0cb141b58fff8f992d32cbb7)中，*构建待办事项列表*，我们使用HTML属性调用JavaScript函数。这看起来可能很有用，但它也会向用户（我指的是访问您页面的其他开发人员）公开我们的对象结构。用户可以通过检查Chrome
    DevTools来清楚地了解`ToDoClass`类的结构。在构建大型应用程序时应该防止这种情况发生。因此，Webpack不允许变量存在于全局范围内。
- en: 'Some plugins will need variables or objects to be present in the global scope
    (like the Google Maps API we are going to use). For this purpose, Webpack provides
    an option to expose some selected objects as libraries to the global scope (inside
    HTML). See the `webpack.config.js` file in the starter files. In the `output`
    section, I have added `library: ''bundle''`, which means if we add the `export`
    keyword to any function, variable or object, they will be accessible inside the
    `bundle` object in the global scope. We will see how to use it while adding Google
    Maps to our app.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '一些插件需要全局范围内存在变量或对象（比如我们将要使用的Google Maps API）。为此，Webpack提供了一个选项，可以将一些选定的对象作为库暴露到全局范围内（在HTML内）。查看起始文件中的`webpack.config.js`文件。在`output`部分，我已经添加了`library:
    ''bundle''`，这意味着如果我们向任何函数、变量或对象添加`export`关键字，它们将在全局范围内的`bundle`对象中可访问。我们将看到如何在向我们的应用程序添加Google
    Maps时使用它。'
- en: Now that we have the environment variables ready, open up the terminal in the
    project root folder and run `npm install` to install all the dependencies. Once
    the dependencies are installed, hit `npm run watch` in the terminal to start the
    Webpack dev server. You can now see the page in the localhost URL printed by Webpack
    in the console (`http://localhost:8080/`). Take a look at all the pages.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好环境变量，打开项目根文件夹中的终端并运行`npm install`来安装所有依赖项。一旦依赖项安装完成，在终端中输入`npm run
    watch`来启动Webpack开发服务器。您现在可以在控制台中由Webpack打印的本地主机URL（`http://localhost:8080/`）上查看页面。查看所有页面。
- en: Adding styles to the page
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向页面添加样式
- en: At the moment, the page is responsive, since it is built with Bootstrap. However,
    we still need to add a few style changes to the form. It is currently very large
    on desktop screens. Also, we need to align the title to the center of the page.
    Let's add styles for the `index.html` page.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，页面是响应式的，因为它是使用Bootstrap构建的。然而，我们仍然需要对表单进行一些样式更改。在桌面屏幕上，它目前非常大。此外，我们需要将标题对齐到页面中央。让我们为`index.html`页面添加样式。
- en: 'To align the form and its title to the center of the page, in the `styles.css`
    file (`src/css/styles.css`), add the following code (make sure the Webpack dev
    server is running):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将表单及其标题居中对齐到页面中央，在`styles.css`文件（`src/css/styles.css`）中添加以下代码（确保Webpack开发服务器正在运行）：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The styles will be reflected immediately on the page, since `HotModuleReplacement`
    is enabled in Webpack (no more reloading!). Now, add some margin to the title
    and set a minimum width for the form:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Webpack中启用了`HotModuleReplacement`，样式将立即反映在页面上（不再重新加载！）。现在，给标题添加一些边距，并为表单设置最小宽度：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now the form will have a minimum width of `500px`. However, we are facing another
    problem! Since the form will always have `500px`, it will go out of the screen
    on mobile devices (mobile users are our primary audience). We need to use media
    queries to overcome this problem. Media queries allow us to add CSS depending
    on the type of medium the page is viewed on. In our case, we need to change `min-width`
    on mobiles. To query mobile devices, add the following style below the previous
    styles:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在表单的最小宽度将为`500px`。然而，我们面临另一个问题！由于表单将始终为`500px`，在移动设备上（移动用户是我们的主要受众）将超出屏幕。我们需要使用媒体查询来解决这个问题。媒体查询允许我们根据页面所在的媒介类型添加CSS。在我们的情况下，我们需要在移动设备上更改`min-width`。要查询移动设备，请在先前的样式下方添加以下样式：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will check whether the device width is less than `736px` (usually, mobiles
    fall under this category), and then add `min-width` of `90vw`. `vw` stands for
    the viewport width. `90vw` means 90% of the size of the width of the viewport
    (here, the viewport is the screen).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检查设备宽度是否小于`736px`（通常，移动设备属于此类别），然后添加`90vw`的`min-width`。`vw`代表视口宽度。`90vw`表示视口宽度的大小的90%（这里，视口是屏幕）。
- en: More information on using media queries can be found on this w3schools page: [https://www.w3schools.com/css/css_rwd_mediaqueries.asp](https://www.w3schools.com/css/css_rwd_mediaqueries.asp).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用媒体查询的更多信息，请访问w3schools页面：[https://www.w3schools.com/css/css_rwd_mediaqueries.asp](https://www.w3schools.com/css/css_rwd_mediaqueries.asp)。
- en: 'I have used a loading indicator image on the `index.html` and `status.html`
    pages. To specify a size for the image without breaking its original aspect ratio,
    use `max-width` and `max-height` as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`index.html`和`status.html`页面上使用了加载指示器图像。要指定图像的大小而不破坏其原始宽高比，使用`max-width`和`max-height`如下：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: See the status page. The loading indicator size will be reduced. We have added
    the necessary styles for our application. Now, it's time to make it work using
    JavaScript.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 查看状态页面。加载指示器的大小将被减小。我们已经为我们的应用程序添加了必要的样式。现在，是时候使用JavaScript使其工作了。
- en: Validating and submitting the form using JavaScript
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaScript验证和提交表单
- en: 'HTML Forms are the most important part of web applications, where user input
    is recorded. In our JS Meetup app, we got a nice looking form built with the help
    of Bootstrap. Let''s explore what the form contains using the `index.html` file.
    The form contains four compulsory fields:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: HTML表单是Web应用程序中最重要的部分，用户输入会被记录下来。在我们的JS Meetup应用程序中，我们使用Bootstrap构建了一个漂亮的表单。让我们使用`index.html`文件来探索表单包含的内容。表单包含四个必填字段：
- en: Name
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姓名
- en: Email Address
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件地址
- en: Phone Number
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话号码
- en: Age
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年龄
- en: 'And it also contains three optional fields (two of whose values are preselected):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 它还包含三个可选字段（其中两个的值已经预先选择）：
- en: The user's profession
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的职业
- en: His experience level in JavaScript
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他在JavaScript方面的经验水平
- en: Comments on what he expects to learn from this event
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对他对这次活动期望学到的内容进行评论
- en: Since profession and experience level options are preselected with a default
    value, they aren't marked as compulsory to the user. But, during validation, we
    need to consider them as compulsory fields. Only the comments field is optional.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于职业和经验水平选项已预先选择了默认值，因此它们不会被标记为用户必填。但是，在验证期间，我们需要将它们视为必填字段。只有评论字段是可选的。
- en: 'Here''s how our form should work:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的表单应该如何工作的：
- en: The user fills up all the form details and clicks Submit
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户填写所有表单细节并点击提交
- en: The form details will be validated and if any required fields are missing, it
    will highlight the fields with a red border
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单详细信息将被验证，如果缺少任何必填字段，它将用红色边框突出显示这些字段
- en: If the form values are valid, it will then proceed to submit the form to the
    server
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表单值有效，它将继续将表单提交到服务器
- en: Once the form is submitted, the user will receive a notification that the form
    has been submitted successfully and the form entries will be cleared
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交表单后，用户将收到通知表单已成功提交，并且表单条目将被清除
- en: JavaScript was initially used as a language for doing form validation in HTML.
    Over the course of time, it has evolved into a full-fledged web application development
    language. Web applications built with JavaScript make a lot of requests to the
    server to provide dynamic data to the user. Such network requests are always asynchronous
    and need to be handled properly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript最初用作在HTML中进行表单验证的语言。随着时间的推移，它已经发展成为一个完整的Web应用程序开发语言。使用JavaScript构建的Web应用程序会向服务器发出许多请求，以向用户提供动态数据。这些网络请求始终是异步的，需要正确处理。
- en: HTML forms
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML表单
- en: 'Before we implement our form validation logic, let''s look into the normal
    workings of the form. Click Submit in the current form. You should get a blank
    page with a message saying Cannot POST /register. That is Webpack dev server''s
    message saying there are no routes configured for `/register` with the `POST`
    method. This is because, in `index.html`, the form is created with the following
    attributes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现表单验证逻辑之前，让我们先了解表单的正常工作方式。单击当前表单中的提交。您应该会看到一个空白页面，并显示消息“无法POST /register”。这是Webpack开发服务器的消息，表示没有为`/register`配置`POST`方法的路由。这是因为在`index.html`中，表单是使用以下属性创建的：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This means the form's action when the Submit button is clicked to send data
    to the `/register` page with the `POST` method. While making network requests,
    `GET` and `POST` are two commonly used HTTP methods or verbs. The `GET` method
    cannot have a request body, so all the data is transmitted via URL as query parameters.
    However, the `POST` method can have a request body, where data can be sent as
    form data or a JSON object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当单击提交按钮发送数据到`/register`页面时，使用`POST`方法。在进行网络请求时，`GET`和`POST`是两种常用的HTTP方法或动词。`GET`方法不能有请求正文，因此所有数据都通过URL作为查询参数传输。但是，`POST`方法可以有请求正文，其中数据可以作为表单数据或JSON对象发送。
- en: There are different HTTP methods used for communicating with the server. Check
    out the following REST API Tutorial page for more information on HTTP methods: [http://www.restapitutorial.com/lessons/httpmethods.html](http://www.restapitutorial.com/lessons/httpmethods.html).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的HTTP方法用于与服务器通信。查看以下REST API教程页面，了解有关HTTP方法的更多信息：[http://www.restapitutorial.com/lessons/httpmethods.html](http://www.restapitutorial.com/lessons/httpmethods.html)。
- en: 'Currently, the form sends data in the form of form data using the `POST` method.
    In your `index.html` file, change the form method attribute to `get` and reload
    the page (the Webpack dev server does not automatically reload changes to HTML
    files). Now, click submit. You should see a similar blank page, but the form details
    are now being sent on the URL itself. The URL will now look as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，表单以`POST`方法使用表单数据发送数据。在您的`index.html`文件中，将表单方法属性更改为`get`并重新加载页面（Webpack开发服务器不会自动重新加载HTML文件的更改）。现在，单击提交。您应该看到类似的空白页面，但是现在表单详细信息正在发送到URL本身。现在URL将如下所示：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All the fields are empty except profession and experience, since they are preselected.
    The form values are added at the end of the route `/register`, followed by a `?`
    symbol, which specifies the next text is the query parameter and the form values
    are separated using the `&` symbol. Since a `GET` request sends data in the URL
    itself, it is not suitable for sending confidential data, such as login details
    or the user details that we are going to send in this form. Hence, the `POST`
    method is chosen to do a form submit. Change the method to post in your `index.html`
    file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所有字段都为空，除了职业和经验，因为它们是预先选择的。表单值添加在路由`/register`的末尾，后跟一个`?`符号，指定下一个文本是查询参数，表单值使用`&`符号分隔。由于`GET`请求会将数据发送到URL本身，因此不适合发送机密数据，例如登录详细信息或我们将在此表单中发送的用户详细信息。因此，选择`POST`方法进行表单提交。在您的`index.html`文件中将方法更改为post。
- en: 'Let''s see how to inspect data that is sent using the `POST` request. Open
    Chrome DevTools and select the Network tab. Now type in some details in your form
    and click submit. You should see a new entry in your network requests list with
    the name `register`. If you click on it, it will open a new panel with the request
    details. The request data will be present in the headers tab in the Form Data
    section. Refer to the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何检查使用`POST`请求发送的数据。打开Chrome DevTools并选择网络选项卡。现在在表单中输入一些详细信息，然后单击提交。您应该在网络请求列表中看到一个名为`register`的新条目。如果单击它，它将打开一个新面板，其中包含请求详细信息。请求数据将出现在表单数据部分的标头选项卡中。请参考以下屏幕截图：
- en: '![](../images/00021.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00021.jpeg)'
- en: Chrome DevTools has a lot of tools for working with network requests. We are
    only using it to inspect our sent data. But there is a lot more stuff you can
    do with it. As per the preceding image, you can see the form values I have typed
    in my form in the form data section in the Headers tab.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome DevTools具有许多用于处理网络请求的工具。我们只使用它来检查我们发送的数据。但是您还可以做更多的事情。根据上图，您可以在标头选项卡的表单数据部分中看到我在表单中输入的表单值。
- en: Visit the following Google Developers page: [https://developers.google.com/web/tools/chrome-devtools/](https://developers.google.com/web/tools/chrome-devtools/)
    to learn more on using Chrome DevTools.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 访问以下Google开发者页面：[https://developers.google.com/web/tools/chrome-devtools/](https://developers.google.com/web/tools/chrome-devtools/)
    以了解更多关于使用Chrome DevTools的信息。
- en: Now you have a good idea of how submitting a form works. We do not have any
    pages created in the `/register` route and submitting a form by redirecting it
    to a separate page is no longer a good user experience (we are in the era of **Single-Page
    Applications** (**SPAs**)). Taking this into account, I have created a small Node.js
    server app, which can receive form requests. We are going to disable the default
    form submit action and will be submitting the form with JavaScript as an AJAX
    request.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对提交表单的工作原理有了一个很好的了解。我们在`/register`路由中没有创建任何页面，并且通过将表单重定向到单独的页面进行提交不再是一个好的用户体验（我们处于**单页应用程序**（**SPA**）的时代）。考虑到这一点，我创建了一个小的Node.js服务器应用程序，可以接收表单请求。我们将禁用默认的表单提交操作，并将使用JavaScript作为AJAX请求提交表单。
- en: Reading form data in JavaScript
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JavaScript中读取表单数据
- en: 'Time to code! Keep Webpack dev server running with the `npm run watch` command
    (the `NODE_ENV` variable should be `dev`). Open the project folder in VSCode and
    open the `home.js` file from the `src/js/` directory. I have already added a reference
    to `dist/home.js` in the `index.html` file. I would have also added code to import
    the `general.js` file in `home.js`. Now, add the following code below the import
    statement:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候编码了！使用`npm run watch`命令保持Webpack开发服务器运行（`NODE_ENV`变量应为`dev`）。在VSCode中打开项目文件夹，并从`src/js/`目录中打开`home.js`文件。我已经在`index.html`文件中添加了对`dist/home.js`的引用。我还将在`home.js`中添加代码来导入`general.js`文件。现在，在导入语句下面添加以下代码：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will create a new class `Home` and will create a new instance of it when
    the page has completed loading. We need not assign the instance object to any
    variables because we are not going to use it inside the HTML file like we did
    in the ToDo list app. Everything will be handled from JavaScript itself.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的`Home`类，并在页面加载完成时创建一个新的实例。我们不需要将实例对象分配给任何变量，因为我们不会像在ToDo列表应用程序中那样在HTML文件中使用它。一切都将从JavaScript本身处理。
- en: 'Our first step is to create a reference to all the input fields in the form
    and the form itself. This includes the form itself and the loading indicator that
    is currently hidden in the page using the `.hidden` Bootstrap class. Add the following
    code to the class''s constructor:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是创建对表单中所有输入字段和表单本身的引用。这包括表单本身和当前在页面中使用`.hidden` Bootstrap类隐藏的加载指示器。将以下代码添加到类的构造函数中：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As I mentioned while building the Meme Creator, it is best to store references
    to DOM elements in variables prefixed with  the `$` symbol. Now, we can easily
    identify variables having references to DOM elements from other variables. This
    is purely for development efficiency and is not a strict rule you need to follow.
    In the preceding code, for experience radio buttons, the reference of only the
    first radio button is stored. This is for resetting the radio buttons; to read
    the value of the selected radio buttons, a different method needs to be used.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我在构建Meme Creator时提到的，最好将对DOM元素的引用存储在以`$`符号为前缀的变量中。现在，我们可以轻松地从其他变量中识别具有对DOM元素的引用的变量。这纯粹是为了开发效率，不是你需要遵循的严格规则。在前面的代码中，对于体验单选按钮，只存储了第一个单选按钮的引用。这是为了重置单选按钮；要读取所选单选按钮的值，需要使用不同的方法。
- en: We can now access all the DOM elements within our `Home` class. The one event
    that is going to trigger the entire form validation process is when the form is
    submitted. The form submit event happens when a DOM element with the attribute
    `type="submit"` inside the `<form>` element is clicked. In our case, the `<button>`
    element contains this attribute and is referenced as the `$submit` variable. Even
    though `$submit` triggers the submit event, the event belongs to the entire form,
    that is, `$form` variable. Hence, we need to add an event listener to `this.$form`
    in our class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`Home`类中访问所有的DOM元素。触发整个表单验证过程的事件是表单提交时发生的。表单提交事件发生在`<form>`元素内部带有属性`type="submit"`的DOM元素被点击时。在我们的情况下，`<button>`元素包含这个属性，并且被引用为`$submit`变量。尽管`$submit`触发了提交事件，但事件属于整个表单，也就是`$form`变量。因此，我们需要在我们的类中为`this.$form`添加一个事件监听器。
- en: 'We are only going to have a single event listener. So, just add the following
    code to the constructor after the preceding variables are declared:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只会有一个事件监听器。因此，在声明前面的变量之后，只需将以下代码添加到构造函数中：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will attach an event listener to the form and will call the `onFormSubmit()`
    method of the class when the form is submitted with the form submit event as its
    parameter. So, let''s create the `onFormSubmit()` method inside our `Home` class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为表单附加一个事件监听器，并在表单提交时调用类的`onFormSubmit()`方法，以表单提交事件作为其参数。因此，让我们在`Home`类中创建`onFormSubmit()`方法：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`event.preventDefault()` will prevent the default event action from happening.
    In our case, it will prevent the submission of the form. Open the page in Chrome (`http://localhost:8080/`)
    and try clicking Submit now. If no action occurs, then great! Our JavaScript code
    is blocking the form from being submitted.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`event.preventDefault()`将阻止默认事件动作发生。在我们的情况下，它将阻止表单的提交。在Chrome中打开页面（`http://localhost:8080/`）并尝试点击提交。如果没有任何动作发生，那太好了！我们的JavaScript代码正在阻止表单提交。'
- en: 'We can use this function for initiating form validation. The first step in
    form validation is to read the values of all the input elements in the form. Create
    a new method `getFormValues()` inside the `Home` class, which will return the
    values of form fields as a JSON object:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个函数来启动表单验证。表单验证的第一步是读取表单中所有输入元素的值。在`Home`类中创建一个新的方法`getFormValues()`，它将以JSON对象的形式返回表单字段的值：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'See how I used `document.querySelector()` to read the value of the checked
    radio button? The function is self-explanatory itself. I have added `parseInt()`,
    since the value will be returned as a string and needs to be converted to Int
    for validation purposes. Create a variable inside the `onFormSubmit()` method
    to store the values of all the fields in the form. Your `onFormSubmit()` method
    will now look as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 看到我如何使用`document.querySelector()`来读取选中的单选按钮的值了吗？该函数本身就是不言自明的。我添加了`parseInt()`，因为该值将作为字符串返回，并且需要转换为Int以进行验证。在`onFormSubmit()`方法中创建一个变量来存储表单中所有字段的值。您的`onFormSubmit()`方法现在将如下所示：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Try printing the `formValues` variable in the Chrome DevTools console using
    `console.log(formValues)`. You should see all the fields with their respective
    values in a JSON object. Now that we have the required values, our next step is
    to validate the data.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用`console.log(formValues)`在Chrome DevTools控制台中打印`formValues`变量。您应该看到一个JSON对象中的所有字段及其相应的值。现在我们有了所需的值，下一步是验证数据。
- en: In our JS Meetup app, we only have a single form. But in larger applications,
    you might have more than one form in different parts of the application that do
    the same thing. However, due to design purposes, the forms will have different
    HTML classes and IDs but the form values will remain the same. In such cases,
    the validation logic can be reused across the app. This is a perfect opportunity
    to build your first reusable JavaScript module.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的JS Meetup应用程序中，我们只有一个表单。但在更大的应用程序中，您可能会在应用程序的不同部分中有多个表单执行相同的操作。但是，由于设计目的，表单将具有不同的HTML类和ID，但表单值将保持不变。在这种情况下，验证逻辑可以在整个应用程序中重复使用。这是构建您的第一个可重用JavaScript模块的绝佳机会。
- en: Form validation module
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单验证模块
- en: By using Webpack, we now have the ability to create separate modules and import
    them in JavaScript. However, we need some kind of approach to organizing our created
    modules. As the size of the application grows, you might have tens or even hundreds
    of modules. Organizing them in such a way that they can be easily identified will
    greatly help your team, as they will be able to easily find a module when needed
    instead of recreating a module with the same functionality.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Webpack，我们现在有能力创建单独的模块并在JavaScript中导入它们。但是，我们需要某种方法来组织我们创建的模块。随着应用程序的规模增长，您可能会有数十甚至数百个模块。以便能够轻松识别它们的方式来组织它们将极大地帮助您的团队，因为他们将能够在需要时轻松找到模块，而不是重新创建具有相同功能的模块。
- en: 'In our application, let''s create a new folder inside the `src/js/` directory
    called `services`. This directory will contain all the reusable modules. Now,
    inside the `services` directory, create another directory called `formValidation`,
    inside which we will create the `validateRegistrationForm.js` file. Your project
    `src/js/` directory will now look as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，让我们在`src/js/`目录中创建一个名为`services`的新文件夹。该目录将包含所有可重用的模块。现在，在`services`目录中，创建另一个名为`formValidation`的目录，在其中我们将创建`validateRegistrationForm.js`文件。您的项目`src/js/`目录现在将如下所示：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, imagine yourself as a different developer who is looking at this code for
    the first time. Inside the `js` directory, there is another directory called `services`.
    Inside that, `formValidation` is available as a service. You now know that there
    is a service for form validation. If you look inside this directory, it will have
    the `validateRegistrationForm.js` file, which informs you of the purpose of this
    module just by its filename.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象自己是一个第一次看到这段代码的不同开发人员。在`js`目录中，有另一个名为`services`的目录。在其中，`formValidation`作为一个服务可用。您现在知道有一个用于表单验证的服务。如果您查看此目录，它将具有`validateRegistrationForm.js`文件，该文件仅凭其文件名就告诉您此模块的目的。
- en: If you want to create a validation module for a login form (just an imaginary
    scenario), simply create another file inside the `formValidation` directory with
    the name `validateLoginForm.js`. This way, your code will be easily maintainable
    and scalable by reusing all the modules to a maximum.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想为登录表单创建一个验证模块（只是一个想象的场景），只需在`formValidation`目录中创建另一个名为`validateLoginForm.js`的文件。这样，您的代码将易于维护，并通过最大程度地重用所有模块来扩展。
- en: Don't worry about long filenames! Maintainable code is more important, but if
    the filename is long it makes it easy to understand the purpose of that file.
    But if you are working in a team, stick to the rules of the lint tools used by
    your team.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心文件名太长！可维护的代码更重要，但如果文件名太长，它会更容易理解该文件的目的。但是，如果您在团队中工作，请遵守团队使用的lint工具的规则。
- en: 'Time to build the module! In the `validateRegistrationForm.js` file you just
    created, add the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候构建模块了！在您刚刚创建的`validateRegistrationForm.js`文件中，添加以下代码：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Having the same name for the module's file and its default exported item will
    make import statements look easier to understand. You will see that when you import
    this module into your `home.js` file. The preceding function will accept the `formValues`
    (which we read from the form in the previous section) JSON object as the parameter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块文件和其默认导出项相同的名称将使导入语句看起来更容易理解。当您将此模块导入到您的`home.js`文件中时，您将看到这一点。前面的函数将接受`formValues`（我们从上一节中的表单中读取的）JSON对象作为参数。
- en: 'Before we write this function, we need to set up validation logic for each
    of the input fields as separate functions. These functions will return true when
    the input satisfies the validation criteria. Let''s start with validating the
    username. Below `validateRegistrationForm()`, create a new function `validateUserName()`,
    as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写此函数之前，我们需要为每个输入字段设置验证逻辑为单独的函数。当输入满足验证条件时，这些函数将返回true。让我们从验证用户名开始。在`validateRegistrationForm()`下面，创建一个名为`validateUserName()`的新函数，如下所示：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We use this function to check whether the username is at least `3` characters
    long. We use the conditional operator to return `true` if the length is greater
    than `3` and `false` if it is smaller.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用此函数来检查用户名是否至少为`3`个字符长。我们使用条件运算符，如果长度大于`3`则返回`true`，如果长度小于`3`则返回`false`。
- en: We have used conditional operator `()?:` once before in the ToDo list app. If
    you are still having problems understanding this operator, visit the following
    MDN page: [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在ToDo列表应用程序中使用了条件运算符`()?:`。如果您仍然对这个运算符有困难，可以访问以下MDN页面进行了解：[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)。
- en: 'We can make this function event shorter:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使这个函数更加简洁：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This way, JavaScript will automatically evaluate whether the length is greater
    than three and assign true or false based on the result. Now, to validate the
    email address, we need to use regular expressions. We used a regular expression
    to change the mime type of the image in the Meme Creator app. This time, we'll
    look into how regular expressions work.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，JavaScript将自动评估长度是否大于三，并根据结果分配true或false。现在，要验证电子邮件地址，我们需要使用正则表达式。我们曾经使用正则表达式来更改Meme
    Creator应用程序中图像的MIME类型。这一次，我们将研究正则表达式的工作原理。
- en: Working with regular expressions in JavaScript
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JavaScript中使用正则表达式
- en: 'Regular expressions (RegExp) are basically a definition of a pattern (such
    as a sequence of characters, numbers, and so on) that can be searched within other
    text. For example, say you need to find all the words in a paragraph that start
    with the letter *a*. Then, in JavaScript, you define the pattern as:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式（RegExp）基本上是一个模式的定义（例如一系列字符、数字等），可以在其他文本中进行搜索。例如，假设您需要找到段落中以字母*a*开头的所有单词。然后，在JavaScript中，您将模式定义为：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Regular expressions are always defined inside `/ /`. In the preceding code
    snippet, we have the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式总是在`/ /`内定义。在前面的代码片段中，我们有以下内容：
- en: '`^` means in the beginning of'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^`表示在开头'
- en: '`+` means having at least one'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`表示至少有一个'
- en: 'This regular expression will match strings that start with the letter *a*.
    You can test these statements in: [https://jsfiddle.net/](https://jsfiddle.net/).
    To test a string with this regular expression, do the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式将匹配以字母*a*开头的字符串。您可以在以下网址测试这些语句：[https://jsfiddle.net/](https://jsfiddle.net/)。要使用这个正则表达式验证一个字符串，请执行以下操作：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To validate the email address, use the following function, which contains a
    regular expression to validate an email address:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证电子邮件地址，请使用以下函数，其中包含一个用于验证电子邮件地址的正则表达式：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Don''t be overwhelmed by the RegExp, it is something commonly available on
    the internet. Whenever you need regular expressions for common formats, such as
    an email address or phone number, you can find them on the internet. To validate
    a mobile number, do the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被正则表达式所压倒，它是互联网上常见的东西。每当您需要常见格式的正则表达式，比如电子邮件地址或电话号码，您都可以在互联网上找到它们。要验证手机号码，请执行以下操作：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This validates whether the phone number is in the format of `XXX-XXX-XXXX` (this
    format is given in the placeholder of the form).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这将验证电话号码是否符合`XXX-XXX-XXXX`的格式（此格式在表单的占位符中给出）。
- en: You will have to write your own regular expressions if your requirement is very
    specific. At that time, refer to the following page: [https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的要求非常具体，您将不得不编写自己的正则表达式。那时，请参考以下页面：[https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions)。
- en: Email address is validated by default in the form, since the email input field's
    type attribute is set to email. However, it is necessary to validate it in JavaScript,
    as not all browsers might support this attribute and the HTML can be easily edited
    from the Chrome DevTools. The same applies to other fields.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件地址在表单中默认验证，因为电子邮件输入字段的类型属性设置为电子邮件。但是，有必要在JavaScript中验证它，因为并非所有浏览器都可能支持此属性，而且HTML可以很容易地从Chrome
    DevTools进行编辑。其他字段也是一样。
- en: 'To validate age, let''s assume the user should be in the age group 10-25 years:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证年龄，假设用户应该在10-25岁的年龄组中：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To validate profession, the accepted values for profession are `school`, `college`, `trainee`,
    and `employee`. They are the values of the `<option>` element of the profession
    selection field in your `index.html` file. To validate `profession`, do the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证职业，职业的接受值为`school`、`college`、`trainee`和`employee`。它们是`index.html`文件中职业选择字段的`<option>`元素的值。要验证`profession`，请执行以下操作：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: JavaScript arrays have a method called `indexOf()`. It accepts an array element
    as a parameter and returns the index of the element within the array. However,
    if the element is not present in the array, it returns `-1`. We can use this function
    to check whether the value of profession is one of the accepted values by finding
    its index within the array and checking whether the index is greater than `-1`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript数组有一个名为`indexOf()`的方法。它接受一个数组元素作为参数，并返回该元素在数组中的索引。但是，如果数组中不存在该元素，则返回`-1`。我们可以使用这个函数来检查职业的值是否是接受的值之一，方法是找到它在数组中的索引，并检查索引是否大于`-1`。
- en: 'Finally, to validate experience, the values of the experience radio buttons
    are 1, 2, and 3\. So, experience should be a number between 0-4:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要验证经验，经验单选按钮的值为1、2和3。因此，经验应该是0-4之间的数字：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Since the comments field is optional, we do not need to have validation logic
    for this field. Now, inside the `validateRegistrationForm()` function which we
    created initially, add the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于评论字段是可选的，我们不需要为该字段编写验证逻辑。现在，在我们最初创建的`validateRegistrationForm()`函数中，添加以下代码：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The result object now contains the validation status (`true`/`false`) of each
    of the form inputs. Check whether the form is valid overall. The form is valid
    only if all the properties of the result object is `true`. To check whether all
    the properties of the result object are `true`, we need to use a `for`/`in` loop.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，结果对象包含每个表单输入的验证状态（`true`/`false`）。检查整个表单是否有效。只有当结果对象的所有属性都为`true`时，表单才有效。要检查结果对象的所有属性是否都为`true`，我们需要使用`for`/`in`循环。
- en: 'The `for`/`in` loop iterates over the properties of the object. Since all the
    properties of the `result` object need to be `true`, create a variable `isValid`
    with the initial value `true`. Now, iterate over all the properties of the `result`
    object and simply AND (`&&`) the values with the `isValid` variable:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`/`in`循环遍历对象的属性。由于`result`对象的所有属性都需要为`true`，因此创建一个初始值为`true`的变量`isValid`。现在，遍历`result`对象的所有属性，并将值与`isValid`变量进行逻辑与（`&&`）操作：'
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Generally, you access the property of an object using the dot notation (`.`).
    However, since we are using the `for`/`in` loop, the property name is stored in
    the variable `field`. In this case, we need to access the property using the bracket
    notation `result[field]` if `field` contains the value `age`; this is equivalent
    to `result.age` in dot notation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您可以使用点符号（`.`）访问对象的属性。但是，由于我们使用了`for`/`in`循环，属性名称存储在变量`field`中。在这种情况下，如果`field`包含值`age`，我们需要使用方括号表示法`result[field]`来访问属性；这相当于点表示法中的`result.age`。
- en: 'The `isValid` variable will be only `true` when all the properties of the result
    object are `true`. This way, we have both the form''s validation status and the
    individual field''s status. The `validateRegistrationForm()` function will return
    both the `isValid` variable and the `result` object as properties of another object:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当结果对象的所有属性都为`true`时，`isValid`变量才为`true`。这样，我们既有表单的验证状态，又有各个字段的状态。`validateRegistrationForm()`函数将作为另一个对象的属性返回`isValid`变量和`result`对象：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We are using the ES6 feature object literal property value shorthand here. Our
    form validation module is ready! We can import this module into our `home.js`
    file and use it with the Event Registration app.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了ES6的对象字面量属性值简写特性。我们的表单验证模块已经准备好了！我们可以将这个模块导入到我们的`home.js`文件中，并在事件注册应用程序中使用它。
- en: 'In your `home.js` file, before the class `Home`, add the following line:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`home.js`文件中，在`Home`类之前，添加以下行：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, inside the class `Home` in the `onFormSubmit()` method, add the following
    code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Home`类的`onFormSubmit()`方法中，添加以下代码：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding code does the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行以下操作：
- en: It calls the `validateRegistrationForm()` module we created before with `formValues`
    as its parameter and stores the returned value in the `formStatus` object.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它调用我们之前创建的`validateRegistrationForm()`模块，并将`formValues`作为其参数，并将返回的值存储在`formStatus`对象中。
- en: First, it checks whether the entire form is valid using the value of `formStatus.isValid`.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它检查整个表单是否有效，使用`formStatus.isValid`的值。
- en: If it is `true`, it calls a method `clearErrors()` to clear all the error highlights
    in the UI (our HTML form) and then calls another method `submitForm()` to submit
    the form.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果为`true`，则调用`clearErrors()`方法清除UI（我们的HTML表单）中的所有错误高亮，并调用另一个方法`submitForm()`提交表单。
- en: If it is `false` (the form is not valid), it calls the `clearErrors()` method
    to clear the form and then calls the `highlightErrors()` method with `formStatus.result`,
    which contains validation details of individual fields as a parameter to highlight
    the fields that have errors.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果为`false`（表单无效），则调用`clearErrors()`方法清除表单，然后使用`formStatus.result`调用`highlightErrors()`方法，该方法作为参数包含各个字段的验证详细信息，以突出显示具有错误的字段。
- en: We need to create the methods that are being called in the preceding code inside
    the `Home` class, since they are methods of the `Home` class. The working of the
    `clearErrors()` and `highlightErrors()` methods are straightforward. `clearErrors`
    simply removes the `.has-error` class from the parent `<div>` of the input field.
    While `highlightError` adds the `.has-error` class to the parent `<div>` if the
    input field fails validation (if the result of the field is `false`).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`Home`类中创建在上述代码中调用的方法，因为它们是`Home`类的方法。`clearErrors()`和`highlightErrors()`方法的工作很简单。`clearErrors`只是从输入字段的父`<div>`中移除`.has-error`类。而`highlightError`如果输入字段未通过验证（字段的结果为`false`），则将`.has-error`类添加到父`<div>`中。
- en: 'The code for the `clearErrors()` method is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`clearErrors()`方法的代码如下：'
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The code for the `highlightErrors()` method is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`highlightErrors()`方法的代码如下：'
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For now, leave the `submitForm()` method empty:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，将`submitForm()`方法留空：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Open the form on your browser (hopefully you left the Webpack dev server running).
    Try entering some values in the input fields and click Submit. If you entered
    valid input values, it shouldn't perform any action. If you entered invalid input
    entries (as per our validation logic), the input field will be highlighted with
    a red border, since we added the `.has-error` Bootstrap class to the field's parent
    element. If you correct the field with a valid value and click submit again, the
    error should disappear, since we used the `clearErrors()` method to clear all
    the old error highlighting.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开表单（希望您保持Webpack开发服务器运行）。尝试在输入字段中输入一些值，然后单击提交。如果输入了有效的输入值，它不应执行任何操作。如果输入了无效的输入条目（根据我们的验证逻辑），则输入字段将以红色边框突出显示，因为我们向字段的父元素添加了`.has-error`
    Bootstrap类。如果您更正了具有有效值的字段，然后再次单击提交，错误应该消失，因为我们使用了`clearErrors()`方法来清除所有旧的错误高亮。
- en: Submitting the form using AJAX
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AJAX提交表单
- en: We are now in the second half of the form section, submitting the form. We have
    disabled the default submit behavior of our form and we now need to implement
    an AJAX form to submit logic.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入表单部分的第二部分，提交表单。我们已经禁用了表单的默认提交行为，现在需要实现一个用于提交逻辑的AJAX表单。
- en: AJAX is the abbreviation for **Asynchronous JavaScript And XML** (**AJAX**).
    It is not a programming tool, but it is a concept by which you make a network
    request, get data from the server, and update certain parts of your website without
    having to reload the entire page.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX是**异步JavaScript和XML**（**AJAX**）的缩写。它不是一个编程工具，而是一个概念，通过它你可以发出网络请求，从服务器获取数据，并更新网站的某些部分，而无需重新加载整个页面。
- en: The name Asynchronous JavaScript And XML might sound confusing but, initially,
    XML was widely used to exchange data with the server. We can also use JSON/normal
    text to exchange data with the server.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 异步JavaScript和XML这个名字可能听起来有点困惑，但最初XML被广泛用于与服务器交换数据。我们也可以使用JSON/普通文本与服务器交换数据。
- en: For submitting the form to the server, I have created a small Node.js server
    (built using express framework) that pretends to save your form details and returns
    a success message. The server is available in `Chapter03` folder of the code files.
    To start the server, simply run `npm install` inside the server's directory, followed
    by the `npm start` command. This will start the server in the `http://localhost:3000/` URL.
    If you open this URL in the browser, you will see a blank page with the message
    Cannot GET /; this means the server is running properly.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将表单提交到服务器，我创建了一个小的Node.js服务器（使用express框架构建），假装保存你的表单详情并返回一个成功消息。服务器在代码文件的`Chapter03`文件夹中。要启动服务器，只需在服务器目录中运行`npm
    install`，然后运行`npm start`命令。这将在`http://localhost:3000/`URL上启动服务器。如果你在浏览器中打开这个URL，你会看到一个空白页面，上面显示着消息Cannot
    GET /;这意味着服务器正常运行。
- en: 'The server has two API endpoints, one of which we need to communicate with
    to send the details of the user. This is how the registration API endpoint works:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器有两个API端点，我们需要与其中一个通信以发送用户的详情。这就是注册API端点的工作方式：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In a real-world JavaScript application, you will have to work with a lot of
    network requests like this. Most of your user actions will trigger an API call
    which needs to be processed by the server. In our scenario, we need to call the
    preceding API to register the user.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实的JavaScript应用中，你将不得不处理很多像这样的网络请求。大部分用户操作都会触发需要服务器处理的API调用。在我们的场景中，我们需要调用前面的API来注册用户。
- en: 'Let''s strategize how the API call should work:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来规划一下API调用应该如何工作：
- en: As the name suggests, this event is going to be asynchronous. We need to use
    a new concept of ES6, called Promises, to handle this API call.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如其名称所示，这个事件将是异步的。我们需要使用ES6的一个新概念，叫做Promises，来处理这个API调用。
- en: We are going to have another API call in the next section. It's better to create
    the API call as a module-like form validation module.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下一节中，我们将有另一个API调用。最好将API调用创建为类似模块验证模块的形式。
- en: We must validate whether the registration is successful in the server using
    the server's response.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须验证服务器是否成功注册了用户。
- en: Since the whole API call will take some time, we should also show a loading
    indicator to the user during the process.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于整个API调用会花费一些时间，我们应该在过程中向用户显示一个加载指示器。
- en: Finally, if the registration is successful, we should immediately notify the
    user and clear the form.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果注册成功，我们应该立即通知用户并清空表单。
- en: Making network requests in JavaScript
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JavaScript中进行网络请求
- en: JavaScript has `XMLHttpRequest` for making AJAX network requests. A new specification
    called fetch is introduced in ES6, which makes working with network requests more
    modern and efficient with Promises support. Other than these two methods, jQuery
    has the `$.ajax()` method, which is widely used for making network requests. `Axios.js`
    is another `npm` package that is also widely used for making network requests.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有`XMLHttpRequest`用于进行AJAX网络请求。ES6引入了一个叫做fetch的新规范，它通过Promises支持使得处理网络请求更加现代和高效。除了这两种方法，jQuery还有`$.ajax()`方法，广泛用于进行网络请求。`Axios.js`是另一个广泛用于进行网络请求的`npm`包。
- en: We will use fetch in our application for making network requests.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的应用中使用fetch进行网络请求。
- en: Fetch does not work with Internet Explorer and requires polyfills. Check out: [https://caniuse.com/](https://caniuse.com/)
    for the browser compatibility of any new `HTML/CSS/Javascript` components you'd
    like to use.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Fetch在Internet Explorer中不起作用，需要使用polyfills。查看：[https://caniuse.com/](https://caniuse.com/)来了解任何你想使用的新的`HTML/CSS/Javascript`组件的浏览器兼容性。
- en: What is a Promise?
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Promise？
- en: You'll probably be wondering by now what it is that I'm calling a Promise? Well,
    a Promise, as it sounds, is a Promise made by JavaScript that the asynchronous
    function will complete execution at some point.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能会想知道我所说的Promise是什么？嗯，Promise，顾名思义，是JavaScript做出的一个承诺，即异步函数将在某个时刻完成执行。
- en: 'In the previous chapter, we came across an asynchronous event: reading the
    contents of a file using `FileReader`. This is how `FileReader` worked:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们遇到了一个异步事件：使用`FileReader`读取文件内容。这就是`FileReader`的工作方式：
- en: It starts reading the file. Since reading is an asynchronous event, other JavaScript
    code will continue execution while reading is still happening.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它开始读取文件。由于读取是一个异步事件，其他JavaScript代码在读取仍在进行时会继续执行。
- en: 'You might be wondering, w*hat if I need to execute some code only after the
    event is complete?* This is how `FileReader` handles it:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，*如果我需要在事件完成后执行一些代码怎么办？*这就是`FileReader`处理的方式：
- en: Once the reading is complete, `FileReader` fires a `load` event
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦读取完成，`FileReader`会触发一个`load`事件。
- en: It also has an `onload()` method that listens for the `load` event and, when
    the `load` event is triggered, the `onload()` method will start executing
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还有一个`onload()`方法来监听`load`事件，当`load`事件被触发时，`onload()`方法将开始执行。
- en: So, we need to put our required code inside the `onload()` method and it will
    execute only after `FileReader` has completed reading the file contents
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，我们需要将我们需要的代码放在`onload()`方法中，它只会在`FileReader`完成读取文件内容后执行。
- en: This might look like an easier way to handle asynchronous events, but imagine
    if there are multiple asynchronous events that need to happen one after another!
    How many events would you have to fire and how many event listeners would you
    need to keep track of? This will result in code that is very difficult to understand.
    Also, event listeners in JavaScript are expensive resources (they consume a lot
    of memory) and they must be minimized as much as possible.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是处理异步事件的更简单方式，但想象一下如果有多个需要依次发生的异步事件！你将不得不触发多少事件，需要跟踪多少事件监听器？这将导致非常难以理解的代码。此外，JavaScript中的事件监听器是昂贵的资源（它们消耗大量内存），必须尽量减少。
- en: 'Callback functions are used a lot to handle asynchronous events. But if you
    have a lot of asynchronous functions happening one after another, your code will
    look something like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数经常用于处理异步事件。但是，如果有很多异步函数依次发生，您的代码将看起来像这样：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After writing lot of callbacks, your closing brackets will be arranged like
    a pyramid. This is called callback hell. Callback hell is messy and should be
    avoided when building applications. So, callbacks are not useful here.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写了很多回调之后，您的闭合括号将被排列成金字塔形。这被称为回调地狱。回调地狱很混乱，构建应用程序时应该避免。因此，回调在这里没有用处。
- en: 'Enter Promises, a new way to deal with asynchronous events. This is how a JavaScript
    `Promise` works:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 进入Promises，一种处理异步事件的新方法。这是JavaScript `Promise`的工作方式：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: A `Promise` constructor creates a function with two parameters, resolve and
    reject, which are functions. Then, `Promise` will return the value only when resolve
    or reject is called. Resolve is called when the asynchronous code is executed
    successfully, and reject is called when an error occurs. Here, `Promise` returns
    a value, `5`, when the asynchronous logic is executed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise`构造函数创建一个具有两个参数的函数，resolve和reject，它们都是函数。然后，`Promise`只有在调用resolve或reject时才会返回值。当异步代码成功执行时，调用resolve，当发生错误时调用reject。在这里，`Promise`在异步逻辑执行时返回一个值`5`。'
- en: Say you have a function called `theAsyncCode()`, which does some asynchronous
    stuff. You also have another function `onlyAfterAsync()` that needs to run strictly
    only after `theAsyncCode()` and uses the value returned by `theAsyncCode()`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个名为`theAsyncCode()`的函数，它执行一些异步操作。您还有另一个函数`onlyAfterAsync()`，它需要严格在`theAsyncCode()`之后运行，并使用`theAsyncCode()`返回的值。
- en: 'Here''s how you deal with these two functions with Promises:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用Promises处理这两个函数：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'First, `theAsyncCode()` should return a `Promise` instead of a value. Your
    asynchronous code should be written inside that `Promise`. Then, you write the
    `onlyAfterAsync()` function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`theAsyncCode()`应该返回一个`Promise`而不是一个值。您的异步代码应该写在那个`Promise`里。然后，您编写`onlyAfterAsync()`函数：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To execute the preceding functions one after another, we need to chain them
    using the `Promise.then().catch()` statements. Here, `Promise` is returned by
    the `theAsyncCode()` function. Hence, the code should be:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要依次执行前面的函数，我们需要使用`Promise.then().catch()`语句将它们链接起来。在这里，`Promise`由`theAsyncCode()`函数返回。因此，代码应该是：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When `theAsyncCode()` executes `resolve(5)`, the `then` method is automatically
    called with the resolved value as its parameter. We can now execute the `onlyAfterAsync()`
    method inside the `then` method. If `theAsyncCode()` executes `reject('an error')`
    instead of `resolve(5)`, it will trigger the `catch` method instead of `then`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当`theAsyncCode()`执行`resolve(5)`时，`then`方法会自动以解析值作为其参数调用。现在我们可以在`then`方法中执行`onlyAfterAsync()`方法。如果`theAsyncCode()`执行的是`reject('an
    error')`而不是`resolve(5)`，它将触发`catch`方法而不是`then`。
- en: 'If you have another function, `theAsyncCode2()`, which uses the data returned
    by `theAsyncCode()`, it should be executed before the `onlyAfterAsync()` function:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有另一个函数`theAsyncCode2()`，它使用`theAsyncCode()`返回的数据，那么它应该在`onlyAfterAsync()`函数之前执行：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You just need to update your `.then().catch()` chain, such that:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需要更新您的`.then().catch()`链，如下所示：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This way, all three functions will be executed one after another. If either
    `theAsyncCode()` or `theAsyncCode2()` returns with `reject()`, then the `catch`
    statement will be called.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，所有三个函数将依次执行。如果`theAsyncCode()`或`theAsyncCode2()`中的任何一个返回`reject()`，那么将调用`catch`语句。
- en: 'If we only need to call a function with the resolved value of the previous
    function in the chain as the parameter, we can further simplify the chain as:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只需要使用链中前一个函数的解析值作为参数调用函数，我们可以进一步简化链：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This will give the same result. I have set up a small JS fiddle at: [https://jsfiddle.net/jjq60Ly6/4/](https://jsfiddle.net/jjq60Ly6/4/),
    where you can experience the working of Promises in action. Visit the JS fiddle,
    open the Chrome DevTools console, and click Run at the top-left of the JS fiddle
    page. You should see the `console.log` statements printed from the three functions
    in order. Feel free to edit the fiddle and experiment with the Promises.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到相同的结果。我在[https://jsfiddle.net/jjq60Ly6/4/](https://jsfiddle.net/jjq60Ly6/4/)上设置了一个小的JS
    fiddle，您可以在那里体验Promises的工作。访问JS fiddle，打开Chrome DevTools控制台，然后单击JS fiddle页面左上角的Run。您应该看到按顺序从三个函数中打印出`console.log`语句。随意编辑fiddle并尝试使用Promises进行实验。
- en: Shortly after finishing this chapter, ES8 was announced, which confirmed the
    `async` functions to be part of the JavaScript language. ES8's `async` and `await`
    keywords provide an even simpler way to resolve Promises instead of the `.then().catch()`
    chain we used in ES6\. To learn using the `async` functions, go to the following
    MDN page: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章后不久，ES8被宣布，确认了`async`函数是JavaScript语言的一部分。ES8的`async`和`await`关键字提供了一种更简单的方式来解决Promise，而不是ES6中使用的`.then().catch()`链。要学习使用`async`函数，请访问以下MDN页面：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)。
- en: Creating the API call module
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建API调用模块
- en: We will use a POST API call to register our users. However, in the status section
    of the app, we need to use a `GET` request to show the statistic data of the people
    interested in the event. So, we are going to build a generic API call module.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用POST API调用来注册我们的用户。但是，在应用程序的状态部分，我们需要使用`GET`请求来显示对活动感兴趣的人的统计数据。因此，我们将构建一个通用的API调用模块。
- en: 'To create the API call module, inside the `services` directory, create another
    directory called `api` and, inside it, create `apiCall.js`. The structure of your
    `services` directory should be as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建API调用模块，在`services`目录内，创建另一个名为`api`的目录，并在其中创建`apiCall.js`。您的`services`目录的结构应如下所示：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Inside `apiCall.js file`, create the following function:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在`apiCall.js`文件中创建以下函数：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding function, route is a required parameter, while body and method
    have their default values defined. This means they are optional. If you call the
    function with only one argument, the other two parameters will use their default
    values:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，路由是一个必需的参数，而`body`和`method`有其默认值。这意味着它们是可选的。如果您只使用一个参数调用该函数，则另外两个参数将使用它们的默认值：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you call the function with all three parameters, it will work like a normal
    function:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用所有三个参数调用该函数，它将像普通函数一样工作：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Default parameters are also introduced only in ES6\. We are using default parameters
    because a `GET` request does not require a body attribute. It only sends the data
    as query parameters in the URL.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数仅在ES6中引入。我们使用默认参数是因为`GET`请求不需要`body`属性。它只将数据作为查询参数发送到URL中。
- en: 'We have already seen the workings of `GET` and `POST` requests in action in
    the default form''s Submit section. Let''s construct an `apiCall` function that
    can do both `GET` and `POST` requests:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在默认表单的提交部分看到了`GET`和`POST`请求的工作原理。让我们构建一个`apiCall`函数，可以执行`GET`和`POST`请求：
- en: 'Inside the `apiCall` function, create a new `Promise` object with the name `request`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`apiCall`函数内，创建一个名为`request`的新`Promise`对象：
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The fetch API accepts two parameters as input and returns `Promise`, which resolves
    when the network request is complete. The first parameter is the request URL and
    the second parameter contains an object with information regarding the request,
    such as `headers`, `cors`, `method`, `body`, and so on.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: fetch API接受两个参数作为输入，并返回`Promise`，当网络请求完成时解析。第一个参数是请求URL，第二个参数包含有关请求的信息的对象，如`headers`，`cors`，`method`，`body`等。
- en: Constructing the request details
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建请求详细信息
- en: 'Write the following code inside the request `Promise`. First, since we are
    working with JSON data, we need to create a header with the content type `application/json`.
    We can use the `Headers` constructor for this purpose:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码写入请求`Promise`内。首先，因为我们正在处理JSON数据，我们需要创建一个带有内容类型`application/json`的标头。我们可以使用`Headers`构造函数来实现这一目的：
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, using the `headers` created earlier and the `method` variable from the
    parameter, we create the `requestDetails` object:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用之前创建的`headers`和参数中的`method`变量，我们创建`requestDetails`对象：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Note that I have included `mode: ''cors''` in `requestDetails`. **Cross-Origin
    Resource Sharing** (**CORS**) allows servers to do cross-domain data transfers
    securely. Imagine you have a website running in `www.mysite.org`. You need to
    make an API call (network request) to another server running in `www.anothersite.org`.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，我已在`requestDetails`中包含了`mode: ''cors''`。**跨域资源共享**（**CORS**）允许服务器安全地进行跨域数据传输。假设您有一个运行在`www.mysite.org`上的网站。您需要向在`www.anothersite.org`上运行的另一个服务器发出API调用（网络请求）。'
- en: 'Then, it is a cross-origin request. To make a cross-origin request, the server
    in `www.anothersite.org` must have the `Access-Control-Allow-Origin` headers set
    to allow `www.mysite.org`. Otherwise, browsers will block the cross-origin request
    to prevent unauthorized access to another server. The request from `www.mysite.org`
    should also include `mode: ''cors''` in its request details.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，这是一个跨域请求。要进行跨域请求，`www.anothersite.org`上的服务器必须设置`Access-Control-Allow-Origin`标头以允许`www.mysite.org`。否则，浏览器将阻止跨域请求，以防止未经授权访问另一个服务器。来自`www.mysite.org`的请求还应在其请求详细信息中包含`mode:
    ''cors''`。'
- en: In our Event Registration app, the Webpack dev server is running in `http://localhost:8080/`,
    while the Node.js server is running in `http://localhost:3000/`. Hence, it is
    a cross-origin request. I have already enabled `Access-Control-Allow-Origin` and
    set `Access-Control-Allow-Headers` so that it won't cause any problems with the
    `apiCall` function.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的事件注册应用程序中，Webpack开发服务器正在`http://localhost:8080/`上运行，而Node.js服务器正在`http://localhost:3000/`上运行。因此，这是一个跨域请求。我已经启用了`Access-Control-Allow-Origin`并设置了`Access-Control-Allow-Headers`，以便它不会对`apiCall`函数造成任何问题。
- en: Detailed information on CORS requests can be found in the following MDN page: [https://developer.mozilla.org/en/docs/Web/HTTP/Access_control_CORS](https://developer.mozilla.org/en/docs/Web/HTTP/Access_control_CORS).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有关CORS请求的详细信息可以在以下MDN页面找到：[https://developer.mozilla.org/en/docs/Web/HTTP/Access_control_CORS](https://developer.mozilla.org/en/docs/Web/HTTP/Access_control_CORS)。
- en: 'Our `requestDetails` object should also include a body of the request. However,
    the body should only be included for the `POST` request. Hence, it can be written
    below the `requestDetails` object declaration, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`requestDetails`对象还应包括请求的`body`。但是，`body`应仅包括在`POST`请求中。因此，可以在`requestDetails`对象声明下面编写，如下所示：
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This will add the body property for the `POST` requests. To do the fetch request,
    we need to construct the request URL. We have already set the environment variable
    `SERVER_URL=http://localhost:3000`, which Webpack will transform into a global
    variable `SERVER_URL` accessible everywhere inside the JavaScript code. The route
    is passed in the `apiCall()` function''s parameter. The fetch request can be constructed
    as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为`POST`请求添加`body`属性。要进行fetch请求，我们需要构建请求URL。我们已经设置了环境变量`SERVER_URL=http://localhost:3000`，Webpack将其转换为全局变量`SERVER_URL`，可在JavaScript代码的任何地方访问。路由传递给`apiCall()`函数的参数。fetch请求可以构建如下：
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here's what the `handleErrors` function does. It will check whether the response
    returned by the server is successful (`response.ok`). If so, it will decode the
    response and return it (`response.json()`). Otherwise, it will throw an error.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleErrors` 函数的作用是什么？它将检查服务器返回的响应是否成功（`response.ok`）。如果是，它将解码响应并返回它（`response.json()`）。否则，它将抛出一个错误。'
- en: 'We can further simplify the Promise chain using the method we discussed earlier:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们之前讨论的方法进一步简化 Promise 链：
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Fetch has a small problem. It cannot handle timeouts by itself. Imagine the
    server facing a problem and being unable to return a request. In that scenario,
    the fetch will never resolve. To avoid this, we need to do a workaround. Below
    the `request` Promise, create another `Promise` called `timeout`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Fetch 有一个小问题。它无法自行处理超时。想象一下服务器遇到问题，无法返回请求。在这种情况下，fetch 将永远不会解决。为了避免这种情况，我们需要做一些变通。在
    `request` Promise 之后，创建另一个名为 `timeout` 的 `Promise`：
- en: '[PRE50]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create a constant `timeoutDuration` on top of the `apiCall.js` file outside
    the `apicall()` function, as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `apiCall.js` 文件的 `apicall()` 函数之外创建一个名为 `timeoutDuration` 的常量，如下所示：
- en: '[PRE51]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This constant is placed on top of the file so that we can easily change the
    timeout duration in future (easier code maintainability). `timeout` is a simple
    Promise that automatically rejects after a time of 5 seconds (from the `timeoutDuration`
    constant). I have created the server in a way that it responds after 3 seconds.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 将此常量放在文件顶部，以便我们可以在将来轻松更改超时持续时间（更易于代码维护）。`timeout` 是一个简单的 Promise，它在5秒后自动拒绝（来自
    `timeoutDuration` 常量）。我已经创建了服务器，以便在3秒后响应。
- en: 'Now, JavaScript has a cool way to resolve multiple Promises, the `Promise.race()`
    method. As the name suggests, this will make two Promises run simultaneously and
    accept the value of the one that is resolved/rejected first. This way, if the
    server doesn''t respond within 3 seconds, a timeout will happen in 5 seconds and
    `apiCall` will be rejected with a timeout! To do this, add the following code
    within the `apiCall()` function after the `request` and `timeout` Promises:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，JavaScript 有一种很酷的方法来解决多个 Promises，即 `Promise.race()` 方法。正如其名字所示，这将使两个 Promises
    同时运行，并接受首先解决/拒绝的那个的值。这样，如果服务器在3秒内没有响应，5秒后就会发生超时，`apiCall` 将被拒绝并显示超时！为此，在 `apiCall()`
    函数中的 `request` 和 `timeout` Promises 之后添加以下代码：
- en: '[PRE52]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `apiCall()` function as a whole returns a Promise which is the resolved
    value of either the `request` or `timeout` Promise (depends on which one of them
    is executed faster). That's it! Our `apiCall` module is now ready to be used within
    our Event Registration app.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiCall()` 函数作为一个整体返回一个 Promise，该 Promise 是 `request` 或 `timeout` Promise
    的解决值（取决于它们中哪一个更快执行）。就是这样！我们的 `apiCall` 模块现在已经准备好在我们的事件注册应用程序中使用。'
- en: If you find the `apiCall` function difficult to understand and follow, read
    it again with the `apiCall.js` file from the `Chapter03` completed code files
    as reference. It will make the explanation much simpler.To learn Promises in detail
    with more examples, read the following Google Developers page: [https://developers.google.com/web/fundamentals/getting-started/primers/promises](https://developers.google.com/web/fundamentals/getting-started/primers/promises)
    and MDN page: [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您觉得 `apiCall` 函数难以理解和跟踪，请再次阅读 `Chapter03` 完整代码文件中的 `apiCall.js` 文件，以便更简单地解释。要详细了解
    Promise 并带有更多示例，请阅读以下 Google Developers 页面：[https://developers.google.com/web/fundamentals/getting-started/primers/promises](https://developers.google.com/web/fundamentals/getting-started/primers/promises)
    和 MDN 页面：[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise)。
- en: Other network request methods
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他网络请求方法
- en: 'Follow these links to learn about other plugins/APIs to make network requests
    in JavaScript:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 点击这些链接了解 JavaScript 中进行网络请求的其他插件/API：
- en: jQuery, the `$.ajax()` method: [http://api.jquery.com/jquery.ajax/](http://api.jquery.com/jquery.ajax/)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQuery，`$.ajax()` 方法：[http://api.jquery.com/jquery.ajax/](http://api.jquery.com/jquery.ajax/)
- en: '`XMLHttpRequest`: [https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest](https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest`: [https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest](https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest)'
- en: '`Axios.js`: [https://github.com/mzabriskie/axios](https://github.com/mzabriskie/axios)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Axios.js: [https://github.com/mzabriskie/axios](https://github.com/mzabriskie/axios)'
- en: To make fetch work with Internet Explorer, read the following page on how to
    add `polyfill` for fetch: [https://github.com/github/fetch/](https://github.com/github/fetch/).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 fetch 在 Internet Explorer 中工作，请阅读以下页面，了解如何为 fetch 添加 `polyfill`：[https://github.com/github/fetch/](https://github.com/github/fetch/)。
- en: Back to the form
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到表单
- en: 'The first step to start submitting is to hide the submit button and replace
    it with a loading indicator. This way, the user can''t accidentally click Submit
    twice. Also, the loading indicator serves as an indication that a process is happening
    in the background. In the `home.js` file, inside the `submitForm()` method, add
    the following code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 开始提交的第一步是隐藏提交按钮并用加载指示器替换它。这样，用户就不会意外地点击两次提交。此外，加载指示器还表示后台正在进行某个过程。在 `home.js`
    文件的 `submitForm()` 方法中，添加以下代码：
- en: '[PRE53]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This will hide the submit button and display the loading indicator. To make
    `apiCall`, we need to import the `apiCall` function and notify the user that the
    request has been completed. I have added a package called `toastr` in the `package.json`
    file. It should have been installed already when you ran the `npm install` command.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这将隐藏提交按钮并显示加载指示器。要进行 `apiCall`，我们需要导入 `apiCall` 函数并通知用户请求已完成。我在 `package.json`
    文件中添加了一个名为 `toastr` 的包。当您运行 `npm install` 命令时，它应该已经安装。
- en: 'At the top of the `home.js` file, add the following import statements:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `home.js` 文件的顶部，添加以下导入语句：
- en: '[PRE54]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This will import `toastr` and its styles file (`toastr.less`), along with the
    recently created `apiCall` module. Now, inside the `submitForm()` method, add
    the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导入`toastr`及其样式文件（`toastr.less`），以及最近创建的`apiCall`模块。现在，在`submitForm()`方法中，添加以下代码：
- en: '[PRE55]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Since `apiCall()` returns a Promise, we are using a `Promise.then().catch()`
    chain here. When the registration is a success, `toastr` will show a success toast
    in the top-right corner of the page with the message sent by the server. If a
    problem occurs, it will simply show an error toast. Also, we need to clear the
    form using the `this.resetForm()` method. Add the `resetForm()` method inside
    the `Home` class with the following code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`apiCall()`返回一个Promise，我们在这里使用`Promise.then().catch()`链。当注册成功时，`toastr`将在页面的右上角显示一个成功的提示，其中包含服务器发送的消息。如果出现问题，它将简单地显示一个错误提示。此外，我们需要使用`this.resetForm()`方法清除表单。在`Home`类中添加`resetForm()`方法，代码如下：
- en: '[PRE56]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Go back to the Event Registration page in Chrome and try submitting the form.
    If all the values are valid, it should successfully submit the form with a success
    toast message and the form values will be reset to their initial values. In real-world
    applications, the server will send a confirmation mail to the user. However, server-side
    coding is beyond the scope of this book. But I would like to explain this a little
    in the next chapter.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome中返回到活动注册页面，尝试提交表单。如果所有值都有效，它应该成功提交表单并显示成功的提示消息，表单值将被重置为初始值。在现实世界的应用中，服务器将向用户发送确认邮件。然而，服务器端编码超出了本书的范围。但我想在下一章中稍微解释一下这个。
- en: Try turning off the Node.js server and submitting the form. It should throw
    an error. You have successfully completed building your Event Registration form
    while learning some advanced concepts in JavaScript. Now, let's move on to the
    second page of our application--the status page, where we need to show a chart
    for registered user statistics.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试关闭Node.js服务器并提交表单。它应该会抛出一个错误。在学习JavaScript的一些高级概念的同时，您已经成功完成了构建您的活动注册表单。现在，让我们继续进行我们应用程序的第二页——状态页面，我们需要显示一个注册用户统计图表。
- en: Adding charts to the website using Chart.js
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Chart.js向网站添加图表
- en: We just created a nice little registration form for our users. It's now time
    to work with the second section of our Event Registration app. The status page
    shows a chart for the number of people interested in the event based on experience,
    profession, and age. If you open the status page now, it should show a data loading...
    message with the loading indicator image. But I have built all the necessary components
    needed for this page in the `status.html` file. They are all currently hidden
    using Bootstrap's `.hidden` class.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚为用户创建了一个不错的注册表单。现在是时候处理我们活动注册应用程序的第二部分了。状态页面显示了一个图表，显示了对活动感兴趣的人数，根据经验、职业和年龄。如果现在打开状态页面，它应该显示一个数据加载中...的消息和加载指示器图像。但我已经在`status.html`文件中构建了所有这个页面所需的组件。它们都使用Bootstrap的`.hidden`类当前隐藏。
- en: Let's see what's present in the `status.html` file. Try removing the `.hidden`
    class from each of the following sections to see how they look in the web application.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`status.html`文件中有什么。尝试从以下每个部分中删除`.hidden`类，看看它们在Web应用程序中的外观。
- en: 'First is the loading indicator section which is currently being displayed on
    the page:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是加载指示器部分，它目前显示在页面上：
- en: '[PRE57]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'It is followed by a section containing an error message to be showed when the
    API call fails:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个包含错误消息的部分，当API调用失败时显示：
- en: '[PRE58]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'After the preceding sections, we have a tabs section which will provide the
    user with an option to switch between different charts. The code will look as
    follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分之后，我们有一个选项卡部分，它将为用户提供在不同图表之间切换的选项。代码如下所示：
- en: '[PRE59]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The tabs are nothing but an unordered list with the classes `.nav` and `.nav-tabs`,
    which are styled by Bootstrap into tabs. The tab sections are list items with
    the class `.active` to highlight a selected tab section (`role="presentation"`
    is used for accessibility options). Inside the list items, there are anchor tags
    with an empty `href` attribute.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 选项卡只是一个带有`.nav`和`.nav-tabs`类的无序列表，由Bootstrap样式为选项卡。选项卡部分是带有`.active`类的列表项，用于突出显示所选的选项卡部分（`role="presentation"`用于辅助选项）。在列表项内，有一个空的`href`属性的锚标签。
- en: 'Finally, we have our chart area with three canvas elements to display charts
    for the three different categories mentioned in the preceding tabs:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有我们的图表区域，有三个画布元素，用于显示前面选项卡中提到的三个不同类别的图表：
- en: '[PRE60]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As we saw in the previous chapter, canvas elements are best for displaying
    graphics on a web page, since editing the DOM elements is an expensive operation.
    Chart.js uses the canvas element to display the given data as a chart. Let''s strategize
    how the status page should work:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，画布元素最适合在网页上显示图形，因为编辑DOM元素是一项昂贵的操作。Chart.js使用画布元素来显示给定数据的图表。让我们制定状态页面应该如何工作的策略：
- en: The loading indicator should be shown while the API call is made to fetch statistic
    data from the server
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在从服务器获取统计数据的API调用时，应该显示加载指示器
- en: If the data is retrieved successfully, the loading indicator should be hidden
    and the tabs section and chart area should become visible
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据成功检索，则加载指示器应该被隐藏，选项卡部分和图表区域应该变得可见
- en: Only the canvas corresponding to the selected tab should be visible; other canvas
    elements should be hidden
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有与所选选项卡对应的画布应该可见；其他画布元素应该被隐藏
- en: A pie chart should be added to the canvas using the Chart.js plugin
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用Chart.js插件向画布添加饼图
- en: If data retrieval fails, all the sections should be hidden and the error section
    should be shown
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据检索失败，则所有部分应该被隐藏，错误部分应该被显示
- en: 'Alright! Let''s get to work. Open the `status.js` file which I already added
    as a reference in `status.html`. Create a class `Status` with a reference to all
    the required DOM elements in its constructor, as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！让我们开始工作。打开我已经在`status.html`中添加为参考的`status.js`文件。创建一个`Status`类，并在其构造函数中引用所有所需的DOM元素，如下所示：
- en: '[PRE61]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'I have also created a class variable `statisticData` which can be used for
    storing the data that will be retrieved from the API call. Also, add the code
    to create an instance for the class when the page loads:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我还创建了一个类变量`statisticData`，用于存储从API调用中检索到的数据。此外，在页面加载时添加创建类的实例的代码：
- en: '[PRE62]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The first step to our status page is to make a network request to the get required
    data from the server. I have created the following API endpoint in the Node.js
    server:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们状态页面的第一步是向服务器发出网络请求，以获取所需的数据。我已在Node.js服务器中创建了以下API端点：
- en: '[PRE63]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The server will return the data containing the number of people who are interested
    based on their experience, profession, and age in a format suitable for use with
    Chart.js. Let''s use the `apiCall` module we built before to make this network
    request. In your `status.js` file, first add the following import statement above
    the `Status` class:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将以适合与Chart.js一起使用的格式返回包含基于其经验、职业和年龄感兴趣的人数的数据。让我们使用之前构建的`apiCall`模块来进行网络请求。在您的`status.js`文件中，首先在`Status`类上面添加以下导入语句：
- en: '[PRE64]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'After that, add the following method inside the `Status` class:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在`Status`类中添加以下方法：
- en: '[PRE65]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This time, we can use the `apiCall()` function with only a single parameter,
    because we are making a `GET` request and we have already defined the default
    parameters of the `apiCall()` function as `body = {}` and `method = ''GET''`.
    This way, we don''t have to specify the body and method parameters while making
    a `GET` request. Inside your constructor, add the `this.loadData()` method so
    that it will make the network request automatically when the page loads:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们可以只使用一个参数调用`apiCall()`函数，因为我们正在进行`GET`请求，并且我们已经将`apiCall()`函数的默认参数定义为`body
    = {}`和`method = 'GET'`。这样，我们在进行`GET`请求时就不必指定body和method参数。在您的构造函数中，添加`this.loadData()`方法，这样当页面加载时它将自动进行网络请求：
- en: '[PRE66]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now, look at the web page in Chrome. After three seconds, it should show the
    tabs. At the moment, clicking the tabs will only reload the page. We'll handle
    this after creating the charts.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Chrome中查看网页。三秒后，应该显示选项卡。目前，单击选项卡只会重新加载页面。我们将在创建图表后处理这个问题。
- en: Adding charts to the canvas elements
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图表添加到画布元素
- en: 'We have the required data in our class variable `statisticData`, with which
    the charts should be rendered. I have already added Chart.js to the project dependencies
    in the `package.json` file and it should have been installed when you executed
    the `npm install` command. Let''s import Chart.js into our project by adding the
    following code at the top of the `status.js` file:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类变量`statisticData`中有所需的数据，应该用它来渲染图表。我已经在`package.json`文件中添加了Chart.js作为项目依赖项，当您执行`npm
    install`命令时，它应该已经安装。让我们通过在`status.js`文件顶部添加以下代码来将Chart.js导入我们的项目中：
- en: '[PRE67]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: It is not compulsory to add the `import` statements only on top of the file.
    However, adding the `import` statements on top gives us a clear view of all the
    dependencies of the module in the current file.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 不一定要在文件顶部添加`import`语句。但是，在顶部添加`import`语句可以清晰地看到当前文件中模块的所有依赖关系。
- en: 'Chart.js provides a constructor with which we can create a new chart. The `Chart`
    constructor has the following syntax:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Chart.js提供了一个构造函数，我们可以使用它来创建一个新的图表。`Chart`构造函数的语法如下：
- en: '[PRE68]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The first parameter of the `Chart` constructor should be a reference to the
    canvas element and the second parameter is the JSON object with two properties:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chart`构造函数的第一个参数应该是对canvas元素的引用，第二个参数是具有两个属性的JSON对象：'
- en: The `type` property should contain the type of graph that we need to use in
    our project. We need to use a pie chart in our project.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`属性应该包含我们在项目中需要使用的图表类型。我们需要在项目中使用饼图。'
- en: The `data` property should contain the datasets needed to create the graph as
    an object in a format based on the type of graph. In our case, for the pie chart,
    the required format is specified in the Chart.js documentation on the following
    page: [http://www.chartjs.org/docs/latest/charts/doughnut.html](http://www.chartjs.org/docs/latest/charts/doughnut.html).
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`属性应该包含作为基于图表类型的格式的对象所需的数据集。在我们的情况下，对于饼图，所需的格式在Chart.js文档的以下页面上指定：[http://www.chartjs.org/docs/latest/charts/doughnut.html](http://www.chartjs.org/docs/latest/charts/doughnut.html)。'
- en: 'The data object will have the following format:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 数据对象将具有以下格式：
- en: '[PRE69]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The data object has the following properties:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 数据对象具有以下属性：
- en: A `datasets` property with an array of another object having the `data`, `backgroundColor`,
    and `borderColor` as arrays
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`datasets`属性，其中包含另一个对象的数组，该对象具有`data`、`backgroundColor`和`borderColor`作为数组
- en: A `labels` property with an array of labels in the same order as that of the
    array of data
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`labels`属性是一个标签数组，顺序与数据数组相同'
- en: 'The created charts will automatically occupy the entire space provided by their
    parent element. Create the following functions inside the `Status` class to load
    `Chart` into the status page:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的图表将自动占据其父元素提供的整个空间。在`Status`类内部创建以下函数，将`Chart`加载到状态页面中：
- en: 'You can create a chart based on experience, as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据经验创建一个图表，如下所示：
- en: '[PRE70]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You can create a chart based on profession, as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据职业创建一个图表，如下所示：
- en: '[PRE71]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You can create a chart based on age, as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据年龄创建一个图表，如下所示：
- en: '[PRE72]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'These functions should be called when the data is loaded into the `statisticData`
    variable. So, the best place to call them is after the API call has been a success.
    In the `loadData()` method, add the following code, as shown:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数应在数据加载到`statisticData`变量中时调用。因此，在API调用成功后调用它们的最佳位置是在`loadData()`方法中添加以下代码，如下所示：
- en: '[PRE73]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, open the status page in Chrome. You should see three charts rendered on
    the page. The charts have occupied the entire width of their parent element. To
    reduce their size, add the following style to your `styles.css` file:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Chrome中打开状态页面。您应该看到页面上呈现了三个图表。图表已经占据了其父元素的整个宽度。要减小它们的大小，请在您的`styles.css`文件中添加以下样式：
- en: '[PRE74]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This should reduce the size of the charts. The best part about Chart.js is that
    it is responsive by default. Try resizing the page in Chrome's responsive design
    mode. You should see the charts being resized when the height and width of the
    page are changed. We have now added three charts on our status page.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这将减小图表的尺寸。Chart.js 最好的部分是它默认是响应式的。尝试在 Chrome 的响应式设计模式下调整页面大小。当页面的高度和宽度改变时，你应该看到图表被重新调整大小。我们现在在我们的状态页面上添加了三个图表。
- en: For our final step, we need the tabs to toggle the appearance of the chart so
    that only one chart is visible at a time.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最后一步，我们需要选项卡来切换图表的外观，以便一次只有一个图表可见。
- en: Setting up tab sections
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置选项卡部分
- en: The tabs should work such that only one of the charts is visible at a given
    time. Also, the selected tab should be marked active using the `.active` class.
    A simple solution to this problem is hiding all the charts, removing `.active`
    from all the tab items, and then adding `.active` only to the clicked tab item
    and displaying the required chart. This way, we can easily get the required tab
    functionality.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 选项卡应该工作，以便在任何给定时间只有一个图表可见。此外，所选选项卡应使用 `.active` 类标记为活动状态。这个问题的一个简单解决方案是隐藏所有图表，从所有选项卡项目中移除
    `.active`，然后只向点击的选项卡项目添加 `.active` 并显示所需的图表。这样，我们可以轻松获得所需的选项卡功能。
- en: 'First, create a method inside the `Status` class to clear the selected tabs
    and hide all the charts:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `Status` 类中创建一个方法来清除选定的选项卡并隐藏所有图表：
- en: '[PRE75]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create a method to add event listeners to the clicked tab items:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个方法来为点击的选项卡项目添加事件监听器：
- en: '[PRE76]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Also, call the preceding method inside `constructor` using `this.addEventListeners();`
    so that the event listeners are attached when the page loads.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 还要在 `constructor` 中使用 `this.addEventListeners();` 调用前面的方法，以便在页面加载时附加事件监听器。
- en: 'Whenever we click one of the tab items, it will call the respective load chart
    function. Say we clicked the Experience tab. This would call the `loadExperience()`
    method with `event` as a parameter. But we might want to call this function after
    the API call to load the chart without the event parameter. To make `loadExperience()`
    work in both scenarios, modify the method as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们点击选项卡项目中的一个时，它将调用相应的加载图表函数。比如我们点击了 Experience 选项卡。这将使用 `event` 作为参数调用 `loadExperience()`
    方法。但是我们可能希望在 API 调用后调用此函数以加载图表，而不带有事件参数。为了使 `loadExperience()` 在两种情况下都能工作，修改该方法如下：
- en: '[PRE77]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In the preceding function:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中：
- en: The event parameter is defined with a default value of `null`. If `loadExperience()`
    is called with the event parameter (when the user clicks on the tab), the `if(event)`
    condition will pass and `event.preventDefault()` will stop the default click action
    of the anchor tag. This will prevent the page from reloading.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件参数被定义为默认值 `null`。如果使用事件参数调用 `loadExperience()`（当用户点击选项卡时），`if(event)` 条件将通过，`event.preventDefault()`
    将停止锚标签的默认点击操作。这将防止页面重新加载。
- en: If `this.loadExperience()` is called from within the `apiCall` promise chain,
    it will not have the `event` parameter and the value of the event defaults to
    `null`. The `if(event)` condition will fail (since `null` is a falsy value) and
    `event.preventDefault()` won't be executed. This will prevent an exception, since
    `event` is not defined in this scenario.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果从 `apiCall` 的 promise 链中调用 `this.loadExperience()`，它将不具有 `event` 参数，事件的值默认为
    `null`。`if(event)` 条件将失败（因为 `null` 是一个假值），`event.preventDefault()` 将不会被执行。这将防止异常，因为在这种情况下
    `event` 未定义。
- en: After that, `this.hideCharts()` is called, which will hide all the charts and
    remove `.active` from all the tabs.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，调用 `this.hideCharts()`，这将隐藏所有图表并从所有选项卡中移除 `.active`。
- en: The next two lines will remove `.hidden` from the experience chart's canvas
    and add the `.active` class to the Experience Tab.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的两行将从经验图表的画布中移除 `.hidden` 并向 Experience 选项卡添加 `.active` 类。
- en: In the `apiCall` function's `then` chain, remove `this.loadAge()` and `this.loadProfession()` so
    that only the experience chart will be loaded first (since it is the first tab).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `apiCall` 函数的 `then` 链中，移除 `this.loadAge()` 和 `this.loadProfession()`，这样只有经验图表会首先加载（因为它是第一个选项卡）。
- en: If you open Google Chrome and click on the Experience tab, it should re-render the
    graph without refreshing the page. This is because we added `event.preventDefault()`
    to stop the default action in the `loadExperience()` method and used Chart.js
    to render the graph when the tab was clicked.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Google Chrome 中打开并点击 Experience 选项卡，它应该重新渲染图表而不刷新页面。这是因为我们在 `loadExperience()`
    方法中添加了 `event.preventDefault()` 来阻止默认操作，并使用 Chart.js 在点击选项卡时渲染图表。
- en: 'By using the same logic in `loadAge()` and `loadProfession()`, we can now easily
    make the tabs work as expected. In your `loadAge()` method add the event handling
    code as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `loadAge()` 和 `loadProfession()` 中使用相同的逻辑，我们现在可以轻松使选项卡按预期工作。在你的 `loadAge()`
    方法中添加以下事件处理代码：
- en: '[PRE78]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Similarly, In the `loadProfession()` method add the following code:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在 `loadProfession()` 方法中添加以下代码：
- en: '[PRE79]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Open Chrome. Click on the tabs to check whether all of them are working properly.
    If so, you have successfully completed the status page! Chart.js is responsive
    by default; hence, if you resize the page, it will resize the pie chart automatically.
    Now, one last page remains, in which you need to add Google Maps to display the
    event location. In normal JavaScript, adding Google Maps is straightforward. But,
    in our case, since we are using Webpack to bundle our JavaScript code, we need
    to add one small step to the normal process (Google Maps need to access a JavaScript
    variable inside HTML!).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Chrome。点击选项卡以检查它们是否都正常工作。如果是，你已成功完成了状态页面！Chart.js 默认是响应式的；因此，如果你调整页面大小，它将自动调整饼图的大小。现在，还有最后一页，你需要添加谷歌地图来显示事件位置。在普通的
    JavaScript 中，添加谷歌地图很简单。但是，在我们的情况下，因为我们使用 Webpack 来捆绑我们的 JavaScript 代码，我们需要在正常流程中添加一个小步骤（谷歌地图需要在
    HTML 中访问 JavaScript 变量！）。
- en: Chart.js has eight types of charts. Do try each of them at: [http://www.chartjs.org/](http://www.chartjs.org/),
    and if you are looking for a more advanced Charting and Graphics library, check
    out `D3.js` (**Data-Driven Documents**) at: [https://d3js.org/](https://d3js.org/).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Chart.js有八种类型的图表。请尝试访问：[http://www.chartjs.org/](http://www.chartjs.org/)，如果你正在寻找更高级的图表和图形库，请查看`D3.js`（**数据驱动文档**）：[https://d3js.org/](https://d3js.org/)。
- en: Adding Google Maps to the web page
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网页中添加谷歌地图
- en: Open the `about.html` file in VSCode or your text editor. It will have two paragraph `<p>`
    tags, in which you can add some information regarding your event. After that,
    there will be a `<div>` element with the ID `#map`, which is supposed to show
    the location of your event in a map.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在VSCode或文本编辑器中打开`about.html`文件。它将有两个`<p>`标签，你可以在其中添加有关活动的一些信息。之后，将会有一个ID为`#map`的`<div>`元素，它应该显示活动在地图中的位置。
- en: 'I have asked you to generate an API key to use Google Maps before. If you haven''t
    generated it, please get one from: [https://developers.google.com/maps/documentation/javascript/get-api-key](https://developers.google.com/maps/documentation/javascript/get-api-key)
    and add it to your `.env` file''s `GMAP_KEY` variable. According to the Google
    Maps documentation, to add a Map with a marker to your web page, you must include
    the following script on the page:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前已经要求你生成一个API密钥来使用谷歌地图。如果你还没有生成，请从以下网址获取：[https://developers.google.com/maps/documentation/javascript/get-api-key](https://developers.google.com/maps/documentation/javascript/get-api-key)，并将其添加到你的`.env`文件的`GMAP_KEY`变量中。根据谷歌地图的文档，要在网页上添加一个带有标记的地图，你必须在页面上包含以下脚本：
- en: '[PRE80]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here, the `async` and `defer` attributes of the `<script>` tag will load the
    script asynchronously and make sure it is executed only after the document is
    loaded.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<script>`标签的`async`和`defer`属性将异步加载脚本，并确保它仅在文档加载后执行。
- en: 'To know more about the workings of `async` and `defer`, refer to the following
    w3schools pages. For Async: [https://www.w3schools.com/tags/att_script_async.asp](https://www.w3schools.com/tags/att_script_async.asp)
    and for Defer: [https://www.w3schools.com/tags/att_script_defer.asp](https://www.w3schools.com/tags/att_script_defer.asp).'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '要了解有关`async`和`defer`的工作原理的更多信息，请参考以下w3schools页面。有关Async: [https://www.w3schools.com/tags/att_script_async.asp](https://www.w3schools.com/tags/att_script_async.asp)，有关Defer:
    [https://www.w3schools.com/tags/att_script_defer.asp](https://www.w3schools.com/tags/att_script_defer.asp)。'
- en: Let's look into the `src` attribute. Here, there is a URL, followed by two query
    parameters, key and callback. Key is where you need to include your Google Maps
    API key, and callback should be a function that needs to be executed once the
    script has completed loaded (the script is loading asynchronously). The challenge
    lies in that the script needs to be included in the HTML where our JavaScript
    variables are not accessible (we are Webpack users now!).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`src`属性。在这里，有一个URL，后面跟着两个查询参数，key和callback。Key是你需要包含你的谷歌地图API密钥的地方，callback应该是一个需要在脚本加载完成后执行的函数（脚本是异步加载的）。挑战在于脚本需要包含在我们的JavaScript变量不可访问的HTML中（我们现在是Webpack用户！）。
- en: But, as I have explained before, in the `webpack.config.js` file, I have added
    the `output.library` property, which will expose the objects, functions, or variables
    that are marked with the keyword `export` in the entry files of Webpack to the
    HTML by making their scope global (changing their scope from `const` or `let`
    to `var`). However, they are not directly accessible by their names. The value
    of `output.library` I have given is `bundle`. So, the things that are marked with
    the `export` keyword will be available as a property of the `bundle` object.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如我之前解释的，在`webpack.config.js`文件中，我已经添加了`output.library`属性，它将通过将它们的作用域从`const`或`let`更改为`var`，将使用`export`关键字标记的对象、函数或变量暴露给HTML（但它们不能直接通过它们的名称访问）。我给出的`output.library`的值是`bundle`。因此，使用`export`关键字标记的东西将作为`bundle`对象的属性可用。
- en: Open the Event Registration app in Chrome and open your Chrome DevTools console.
    If you type `bundle` into your console, you can see that it prints out an empty
    object. This is because we haven't made any exports from the *Webpack's entry
    files* (we did some exports in `apiCall.js` and `registrationForm.js` but those
    files are not in the `webpack.config.js` entry property). Hence, we only have
    an empty bundle object at the moment.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome中打开事件注册应用程序，并打开Chrome DevTools控制台。如果你在控制台中输入`bundle`，你会发现它打印出一个空对象。这是因为我们还没有从*Webpack的入口文件*中进行任何导出（我们在`apiCall.js`和`registrationForm.js`中进行了一些导出，但这些文件不在`webpack.config.js`的入口属性中）。因此，目前我们只有一个空的bundle对象。
- en: 'Let''s think of a way to successfully include the Google Maps script in our
    web app:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想一种成功将谷歌地图脚本包含在我们的Web应用程序中的方法：
- en: The API key is currently available as a global variable `GMAP_KEY` in our JavaScript
    code. So, it would be better to create the script element from the JavaScript
    and append it to the HTML when the page has loaded. This way, we don't have to
    export the API key.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API密钥当前在我们的JavaScript代码中作为全局变量`GMAP_KEY`可用。因此，最好是在页面加载完成后从JavaScript创建脚本元素并将其附加到HTML中。这样，我们就不必导出API密钥。
- en: For the callback function, we will create a JavaScript function and export it.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于回调函数，我们将创建一个JavaScript函数并导出它。
- en: 'Open the `about.js` file in VSCode and add the following code:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在VSCode中打开`about.js`文件并添加以下代码：
- en: '[PRE81]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The preceding code does the following:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行以下操作：
- en: When the page has finished loading, it will create a new script element `document.createElement('script')` and
    store it in `$script` constant object.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当页面加载完成时，它将创建一个新的脚本元素`document.createElement('script')`并将其存储在`$script`常量对象中。
- en: Now, we add the `src` attribute to the `$script` object with the value as the
    required script URL. Note that I have included the `GMAP_KEY` variable in the
    key and `bundle.initMap` as the callback function (since we are exporting `initMap`
    in `about.js`).
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们将`src`属性添加到`$script`对象中，并将值设置为所需的脚本URL。请注意，我已经在密钥中包含了`GMAP_KEY`变量，并将`bundle.initMap`作为回调函数（因为我们在`about.js`中导出了`initMap`）。
- en: Finally, it will append the script to the body element as a child. This will
    make the Google Maps script work as expected.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它将把脚本作为子元素附加到body元素。这将使Google Maps脚本按预期工作。
- en: We didn't need `async` or `defer` here, since load the script only after the
    page has loaded.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们这里不需要`async`或`defer`，因为只有在页面加载完成后才加载脚本。
- en: In your Chrome DevTools console, while you are on the about page, try typing
    `bundle` again. This time, you should see an object printed with `initMap` as
    one of its properties.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Chrome DevTools控制台上，当你在about页面上时，尝试再次输入`bundle`。这一次，你应该看到一个打印出`initMap`作为其属性之一的对象。
- en: In our ToDo List app, we created HTML elements by writing the HTML code directly
    in template strings. It is very efficient for constructing a large number of HTML
    elements. However, for smaller elements, it is better to use the `document.createElement()`
    method, since it makes the code more readable and easy to understand when there
    are a lot of attributes to that element that need dynamic values.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的ToDo List应用中，我们通过直接在模板字符串中编写HTML代码来创建HTML元素。这对于构建大量HTML元素非常有效。然而，对于较小的元素，最好使用`document.createElement()`方法，因为当该元素有很多需要动态值的属性时，这样做会使代码更易读和易懂。
- en: Adding Google Maps with a marker
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加带有标记的Google地图
- en: We have successfully included the Google Maps script on the page. When the Google
    Maps script finishes loading, it will call the `initMap` function we declared
    in the `about.js` file. Now, we will use that function to create the map with
    a marker pointing to the location of the JS Meetup Event.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功在页面上包含了Google Maps脚本。当Google Maps脚本加载完成时，它将调用我们在`about.js`文件中声明的`initMap`函数。现在，我们将使用该函数来创建一个指向JS
    Meetup活动位置的地图标记。
- en: The process of adding Google Maps with a marker and more functionalities is
    well explained in the Google Maps documentation, available at: [https://developers.google.com/maps/documentation/javascript/adding-a-google-map](https://developers.google.com/maps/documentation/javascript/adding-a-google-map).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 添加Google地图标记和更多功能的过程在Google地图文档中有很好的解释，可在以下链接找到：[https://developers.google.com/maps/documentation/javascript/adding-a-google-map](https://developers.google.com/maps/documentation/javascript/adding-a-google-map)。
- en: 'The Google Maps script we included earlier provides us with a few constructors
    that can create `map`, `Marker`, and `infowindow`. To add a simple Google Maps
    with `marker`, add the following code inside the `initMap()` function:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前包含的Google Maps脚本为我们提供了一些构造函数，可以创建`map`、`Marker`和`infowindow`。要添加一个带有`marker`的简单Google地图，请在`initMap()`函数内添加以下代码：
- en: '[PRE82]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Replace the `lat` and `lng` values in the preceding code with the latitude and
    longitude of your event location and change the content of the `infowindow` object
    with the address and contact details for the event location. Now, open the `about.html`
    page on Google Chrome; you should see the map with a marker at your event's location.
    The information window will be open by default.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 用你的活动地点的纬度和经度替换上述代码中的`lat`和`lng`值，并将`infowindow`对象的内容更改为活动地点的地址和联系方式。现在，在Google
    Chrome上打开`about.html`页面；你应该看到地图上有一个标记指向你的活动地点。信息窗口将默认打开。
- en: Congratulations! You have successfully built your Event Registration app! But,
    before we start inviting people to the event, there is one more thing you need
    to do in your application.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经成功构建了你的Event Registration应用！但是，在我们开始邀请人们参加活动之前，你的应用还有一件事情需要做。
- en: Generating a production build
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成生产构建
- en: You might have noticed something about both the Meme Creator and the Event Registration
    apps. The apps load plain HTML first; after that, styles are loaded. This makes
    the applications look plain for a moment. This problem does not exist in the ToDo
    List app because we load CSS first in the ToDo List app. In the Meme Creator app,
    there was an optional section called *Optimizing Webpack builds for different
    environments*. This might be a good time to read it. If you haven't read it yet,
    go back, give that section a read, and come back to generate the production build.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了关于Meme Creator和Event Registration应用的一些问题。这些应用首先加载纯HTML；之后加载样式。这使得应用在一段时间内看起来很普通。在ToDo
    List应用中不存在这个问题，因为我们首先加载了CSS。在Meme Creator应用中，有一个名为*为不同环境优化Webpack构建*的可选部分。现在可能是阅读它的好时机。如果你还没有阅读过，请回去，阅读一下那部分内容，然后回来生成生产构建。
- en: So far, our app has been working in a development environment. Remember? In
    the `.env` file, I told you to set `NODE_ENV=dev`. This is because, when you set
    `NODE_ENV=production` as per the `webpack.config.js` file I created, Webpack will
    go into production mode. The `npm run watch` command is used to run the Webpack
    dev server to create a development server for our use. In your `package.json`
    file, there should be another command called `webpack`. This command is used to
    generate production builds.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用一直在开发环境中运行。记得吗？在`.env`文件中，我告诉你要设置`NODE_ENV=dev`。这是因为，当你按照我创建的`webpack.config.js`文件设置`NODE_ENV=production`时，Webpack将进入生产模式。`npm
    run watch`命令用于运行Webpack开发服务器，为我们提供一个开发服务器。在你的`package.json`文件中，应该有另一个名为`webpack`的命令。这个命令用于生成生产构建。
- en: 'The `webpack.config.js` file included in this project has a lot of plugins
    that are used to optimize the code and make the app loading times faster for the
    end user. `npm run watch` will not work properly, only when `NODE_ENV` is production,
    since there are a lot of plugins included to do production optimizations. To generate
    a production build for your Event Registration app, follow these steps:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目中包含的`webpack.config.js`文件有很多插件，用于优化代码，使应用加载时间更快。只有当`NODE_ENV`为production时，`npm
    run watch`才能正常工作，因为有很多插件用于进行生产优化。要为你的Event Registration应用生成生产构建，请按照以下步骤进行：
- en: Change the value of the `NODE_ENV` variable in your `.env` file to `production`.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`.env`文件中`NODE_ENV`变量的值更改为`production`。
- en: Run the following command `npm run webpack` from your project root folder in
    the terminal.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中从项目根文件夹运行以下命令`npm run webpack`。
- en: It will take a while for the command to finish execution, but once it's done,
    you should see a number of files in your project `/dist` folder. There will be
    JS files, CSS files, and `.map` files that contain source map information for
    the generated CSS and JS files. JS files will be compressed and well minified
    so that loading and execution times are very fast. There will also be a fonts
    directory containing the fonts used by Bootstrap.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 命令执行需要一段时间，但一旦完成，你应该在项目的`/dist`文件夹中看到许多文件。那里会有JS文件、CSS文件和包含生成的CSS和JS文件的`.map`文件的源映射信息。JS文件将被压缩和精简，以便加载和执行时间非常快。还会有一个包含Bootstrap使用的字体的字体目录。
- en: So far, we have only included the JS file in the HTML, since it contains the
    CSS code too. However, it is the reason why the page shows blank HTML without
    CSS when it starts loading. The CSS file should be included before the `<body>`
    element so that it will load first and the page style will be uniform when it
    is loading (see how we included CSS files in [Chapter 1](part0022.html#KVCC0-f852807d0cb141b58fff8f992d32cbb7),
    *Building a ToDo List App*). For the production build, we need to remove references
    to old JS files and include the newly generated CSS and JS files.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在HTML中包含了JS文件，因为它也包含了CSS代码。然而，这就是为什么页面在开始加载时显示空白的HTML而没有CSS的原因。CSS文件应该在`<body>`元素之前包含，这样它将首先加载，页面样式在加载时将是统一的（看看我们在[第1章](part0022.html#KVCC0-f852807d0cb141b58fff8f992d32cbb7)中如何包含CSS文件，*构建一个待办事项列表应用*）。对于生产构建，我们需要删除对旧JS文件的引用，并包含新生成的CSS和JS文件。
- en: 'In your `dist/` directory, there will be a `manifest.json` file that contains
    the list of files generated for every entry in Webpack. `manifest.json` should
    look something like this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`dist/`目录中，会有一个`manifest.json`文件，其中包含了Webpack每个入口生成的文件列表。`manifest.json`应该看起来像这样：
- en: '[PRE83]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The prefix numbers are just hash values and they might be different for you;
    don''t worry about that. Now, include the CSS and JS files for each HTML file.
    For example, take the `status.html` file and add the CSS and JS files in the status
    property of the preceding `manifest.json` file, such that:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀数字只是哈希值，它们可能对你来说是不同的；不用担心。现在，为每个HTML文件包含CSS和JS文件。例如，取`status.html`文件，并在前面的`manifest.json`文件的status属性中添加CSS和JS文件，如下所示：
- en: '[PRE84]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Repeat the same process for other HTML files and then your production build
    will be ready! You cannot use Webpack dev server now, so you could use the `http-server`
    tool to open the web page or directly open the HTML file with Chrome (I'd recommend
    using `http-server`). This time, while the page is loading, you won't see the
    HTML page without styles, since CSS is loaded before the body elements.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 对其他HTML文件重复相同的过程，然后你的生产构建就准备好了！现在不能使用Webpack开发服务器，所以你可以使用`http-server`工具打开网页，或者直接用Chrome打开HTML文件（我建议使用`http-server`）。这一次，在页面加载时，你不会看到没有样式的HTML页面，因为CSS会在body元素之前加载。
- en: Shipping the code
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布代码
- en: Now that you have learned how to generate production builds, what if you want
    to send this code to someone else? Say the DevOps team or the server administrator.
    In this case, if you are using version control, add the `dist/` directory, the
    `node_modules/` directory, and the `.env` files to your ignore list. Send the
    code without these two directories and the `.env` file. The other person should
    be able to figure out which environment variables to use using the `.env.example`
    file, creating the `.env` file, and also using the `npm install` and `npm run
    webpack` commands to generate the `node_modules/` and `dist/` directories.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何生成生产构建，如果你想把这段代码发送给其他人呢？比如DevOps团队或服务器管理员。在这种情况下，如果你正在使用版本控制，将`dist/`目录、`node_modules/`目录和`.env`文件添加到你的忽略列表中。发送代码时不包括这两个目录和`.env`文件。其他人应该能够使用`.env.example`文件找出要使用的环境变量，创建`.env`文件，并使用`npm
    install`和`npm run webpack`命令生成`node_modules/`和`dist/`目录。
- en: For all the other steps, neatly document the procedure in a `README.md` file
    in your project root folder and send it along with the other files.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有其他步骤，将过程整齐地记录在项目根目录的`README.md`文件中，并将其与其他文件一起发送。
- en: The main reason why sharing the `.env` file should be avoided is because the
    environment variables might contain sensitive information and should not be transported
    or stored in version control as plain text.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 共享`.env`文件应该避免的主要原因是环境变量可能包含敏感信息，不应以明文形式在版本控制中传输或存储。
- en: You have now learned about generating production builds for your applications
    built with Webpack. Now, the Meme Creator app does not have a production build
    yet! I'll let you use the `webpack.config.js` file used in this chapter as a reference.
    So, go ahead and create a production build for your Meme Creator.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经学会了如何为使用Webpack构建的应用生成生产构建。现在，Meme Creator应用还没有生产构建！我会让你使用本章中使用的`webpack.config.js`文件作为参考。所以，继续为你的Meme
    Creator创建一个生产构建。
- en: Summary
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Well done! You just built a really useful Event Registration app. Along the
    way, you have learned some really advanced concepts of JavaScript, such as building
    ES6 Modules for reusable code, making asynchronous AJAX calls with fetch, and
    handling asynchronous code using Promises. You also used the Chart.js library
    to build charts to visually display the data and, finally, created a production-ready
    build with Webpack.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你刚刚构建了一个非常有用的活动注册应用。在这个过程中，你学到了一些JavaScript的高级概念，比如构建可重用代码的ES6模块，使用fetch进行异步AJAX调用，并使用Promises处理异步代码。你还使用Chart.js库构建图表来直观显示数据，最后使用Webpack创建了一个生产就绪的构建。
- en: Having learned all these concepts, you are no longer a beginner in JavaScript;
    you can proudly call yourself a pro! But, apart from these concepts, there's still
    a lot going on with modern JavaScript. As I told you before, JavaScript is no
    longer a scripting language used only for form validation on browsers. In the
    next chapter, we are going to build a peer-to-peer video calling application using
    JavaScript.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 学会了所有这些概念，你不再是JavaScript的初学者；你可以自豪地称自己为专家！但是，除了这些概念，现代JavaScript还有很多其他内容。正如我之前告诉过你的，JavaScript不再仅仅是用于浏览器表单验证的脚本语言。在下一章中，我们将使用JavaScript构建一个点对点视频通话应用程序。
