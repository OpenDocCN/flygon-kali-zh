- en: Reactive Programming Patterns and Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程模式和技术
- en: In the previous chapter ([Chapter 9](b1363fa4-f669-4670-9d40-a7e888557249.xhtml),
    *Functional Programming Practices*), we delved into functional programming and
    learned about **Func**, **Predicate**, **LINQ**, **Lambda**, **anonymous functions**,
    **expression trees**, and **recursion**. We also looked at the implementation
    of the strategy pattern using functional programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章（[第9章](b1363fa4-f669-4670-9d40-a7e888557249.xhtml)，*函数式编程实践*）中，我们深入研究了函数式编程，并了解了**Func**，**Predicate**，**LINQ**，**Lambda**，**匿名函数**，**表达式树**和**递归**。我们还看了使用函数式编程实现策略模式。
- en: This chapter will explore the use of reactive programming and provides a hands-on
    demonstration of reactive programming using the C# language. We will delve into
    the principles and models of reactive programming and discuss the `IObservable`
    and `IObserver` providers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨响应式编程的使用，并提供使用C#语言进行响应式编程的实际演示。我们将深入探讨响应式编程的原理和模型，并讨论`IObservable`和`IObserver`提供程序。
- en: 'The inventory application will be expanded in two main ways: by reacting to
    changes and by discussing the **Model-View-ViewModel** (**MVVM**) pattern.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 库存应用程序将通过对变化的反应和讨论**Model-View-ViewModel**（**MVVM**）模式来进行扩展。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The principles of reactive programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程的原则
- en: Reactive and IObservable
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式和IObservable
- en: Reactive extensions—.NET Rx Extensions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式扩展 - .NET Rx扩展
- en: Inventory application use case—getting inventory with a filter, paging, and
    sorting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库存应用程序用例 - 使用过滤器、分页和排序获取库存
- en: Patterns and practices – MVVM
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式和实践 - MVVM
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter contains various code examples to explain the concepts of reactive
    programming. The code is kept simple and is only for demonstration purposes. Most
    of the examples involve a .NET Core console application written in C#.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例，以解释响应式编程的概念。代码保持简单，仅用于演示目的。大多数示例涉及使用C#编写的.NET Core控制台应用程序。
- en: The complete source code is available at the following link: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter10).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可在以下链接找到：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter10)。
- en: 'Running and executing the code will require the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 运行和执行代码将需要以下内容：
- en: Visual Studio 2019 (you can also use Visual Studio 2017)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019（也可以使用Visual Studio 2017）
- en: Setting up .NET Core
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置.NET Core
- en: SQL Server (the Express Edition is used in this chapter)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server（本章中使用Express Edition）
- en: Installing Visual Studio
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Visual Studio
- en: 'To run the code examples, you will need to install Visual Studio (the preferred
    IDE). To do so, you can follow these instructions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码示例，您需要安装Visual Studio（首选IDE）。要做到这一点，您可以按照以下说明进行操作：
- en: Download Visual Studio 2017 or the later version (2019) from the download link
    mentioned with the installation instructions: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从安装说明中提到的下载链接下载Visual Studio 2017或更高版本（2019）：[https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio)。
- en: Follow the installation instructions.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照安装说明进行操作。
- en: Multiple options are available for Visual Studio installation. Here, we are
    using Visual Studio for Windows.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio安装有多个选项可用。在这里，我们使用Windows的Visual Studio。
- en: Setting up .NET Core
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置.NET Core
- en: 'If you do not have .NET Core installed, you will need to follow these steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装.NET Core，则需要按照以下步骤进行操作：
- en: Download .NET Core for Windows: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载Windows的.NET Core：[https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows)。
- en: For multiple versions and a related library, visit [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于多个版本和相关库，请访问[https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2)。
- en: Installing SQL Server
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装SQL Server
- en: 'If you do not have SQL Server installed, you can follow these instructions:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装SQL Server，则可以按照以下说明进行操作：
- en: Download SQL Server from the following link: [https://www.microsoft.com/en-in/download/details.aspx?id=1695](https://www.microsoft.com/en-in/download/details.aspx?id=1695).
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载SQL Server：[https://www.microsoft.com/en-in/download/details.aspx?id=1695](https://www.microsoft.com/en-in/download/details.aspx?id=1695)。
- en: You can find the installation instructions here: [https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017).
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在此处找到安装说明：[https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017)。
- en: For troubleshooting and for more information, refer to the following link: [https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm](https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有关故障排除和更多信息，请参考以下链接：[https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm](https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm)。
- en: The principles of reactive programming
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程的原则
- en: These days, everyone is talking about **asynchronous programming**. Various
    applications are built on RESTful services that use asynchronous programming. The
    term *asynchronous* is relevant to reactive programming. Reactive is all about
    data streams, and reactive programming is a model structure that is built around
    asynchronous data streams. Reactive programming is also known as *the art of programming
    the propagation of changes*. Let's go back to our example from [Chapter 8](ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml), *Concurrent
    Programming in .NET Core,* where we were discussing the ticket collection counters
    at a big conference.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，每个人都在谈论**异步编程**。各种应用程序都建立在使用异步编程的RESTful服务之上。术语*异步*与响应式编程相关。响应式编程关乎数据流，而响应式编程是围绕异步数据流构建的模型结构。响应式编程也被称为*变化传播的艺术*。让我们回到[第8章](ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml)中的例子，*在.NET
    Core中进行并发编程*，我们当时正在讨论大型会议上的取票柜台。
- en: 'In addition to the three ticket-collection counters, we have one more counter
    named the calculation counter. This fourth counter concentrates on counting the
    collection, and it counts how many tickets are distributed from each of the three
    counters. Consider the following diagram:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了三个取票柜台，我们还有一个名为计算柜台的柜台。这第四个柜台专注于计算收集，它计算从三个柜台中分发了多少张票。考虑以下图表：
- en: '![](img/747ea7b4-c8c3-4740-a44a-fb4986c84231.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/747ea7b4-c8c3-4740-a44a-fb4986c84231.png)'
- en: 'In the preceding diagram, the total of A+B+C is the sum of the remaining three
    columns; it is 1+1+1 = 3\. The **Total** column always shows the sum of rest of
    the three columns, and it will never show the actual person who is standing in
    the queue and waiting for their turn to collect the ticket. The value of the **Total**
    column depends upon the number of the remaining columns. If **Counter A** had
    two people in a queue, then the **Total** column would have the sum of 2+1+1 =
    4\. You can also refer to the **Total** column as a computed column. This column
    calculates the sum as soon as other rows/columns shift their counts (people waiting
    in the queue). If we were to write the **Total** column in C#, we would choose
    the computed property, and this would look as follows: `public int TotalColumn
    { get { return ColumnA + ColumnB + ColumnC; } }`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，A+B+C的总和是剩下三列的总和；即1+1+1=3。**总计**列总是显示剩下三列的总和，它永远不会显示实际站在队列中等待领取票的人。**总计**列的值取决于剩下的列的数量。如果**A柜台**中有两个人在队列中，那么**总计**列将是2+1+1=4。你也可以把**总计**列称为计算列。这一列在其他行/列移动其计数（排队等候的人）时计算总和。如果我们要用C#编写**总计**列，我们会选择计算属性，代码如下：`public
    int TotalColumn { get { return ColumnA + ColumnB + ColumnC; } }`。
- en: 'In the preceding diagram, data flows from column to column. You can treat this
    as a data stream. You can create a stream for anything such as click events and
    hover events. Anything can be a stream variable: user inputs, properties, caches,
    data structures, and more. In the stream world, you can listen to the stream and
    react accordingly.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，数据从一列流向另一列。你可以把这看作是一个数据流。你可以为任何事物创建一个流，比如点击事件和悬停事件。任何东西都可以是一个流变量：用户输入、属性、缓存、数据结构等等。在流世界中，你可以监听流并做出相应的反应。
- en: 'A sequence of events is called a **stream**. A stream can emit three things:
    a value, an error, and a signal for completion.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列事件被称为**流**。流可以发出三种东西：一个值，一个错误和一个完成的信号。
- en: 'You can easily work with a stream in this way:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地使用流进行工作：
- en: One stream can be the input for another stream.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个流可以作为另一个流的输入。
- en: Multiple streams can be the input for another stream.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个流可以作为另一个流的输入。
- en: Streams can be merged.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流可以合并。
- en: Data values can be mapped from one stream to another.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据值可以从一个流映射到另一个流。
- en: Streams can be filtered with the data/events that you need.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流可以用你需要的数据/事件进行过滤。
- en: 'To understand streams more closely, see the following diagram that represents
    a stream (a sequence of events):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要更近距离地了解流，看看下面代表流（事件序列）的图表：
- en: '![](img/e147faca-305d-440c-87b6-0ba924c39f34.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e147faca-305d-440c-87b6-0ba924c39f34.png)'
- en: The preceding diagram is a representation of a stream (sequence of events) where
    we have one to four events. Any of these events can be triggered or someone can
    click on any of them. These events can be represented by values and these values
    can be strings. The X sign shows that an error has occurred during the operation
    where streams are merged or their data is being mapped. Finally, the | sign shows
    that a stream (or an operation) is complete.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上图是一个流（事件序列）的表示，其中我们有一到四个事件。任何这些事件都可以被触发，或者有人可以点击它们中的任何一个。这些事件可以用值来表示，这些值可以是字符串。X符号表示在合并流或映射它们的数据过程中发生了错误。最后，|符号表示一个流（或一个操作）已经完成。
- en: Be reactive with reactive programming
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用响应式编程来实现响应式
- en: Obviously, our computed property (discussed in the previous section) cannot
    be reactive or represent reactive programming. Reactive programming has specific
    designs and technologies. To experience the reactive programming or to be reactive, you
    can start with documents, available at [http://reactivex.io/](http://reactivex.io/)
    and experience it by going through the reactive manifesto ([https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/))[.](https://www.reactivemanifesto.org/)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们在前一节中讨论的计算属性不能是响应式的，也不能代表响应式编程。响应式编程具有特定的设计和技术。要体验响应式编程或成为响应式，你可以从[http://reactivex.io/](http://reactivex.io/)上获取文档，并通过阅读响应式宣言([https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/))来体验它[.](https://www.reactivemanifesto.org/)
- en: In simple terms, reactive properties are binding properties that react when
    an event is triggered.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，响应式属性是绑定属性，当事件触发时会做出反应。
- en: Nowadays, when we deal with various large systems/applications, we find that
    they are too large to handle at once. These large systems are divided or composed
    into smaller systems. These smaller units/systems rely on reactive properties.
    To adhere to reactive programming, reactive systems apply design principles so
    that these properties can apply to all methods. With the help of this design/approach,
    we can make a composable system.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，当我们处理各种大型系统/应用程序时，我们发现它们太大，无法一次处理。这些大型系统被分割或组成较小的系统。这些较小的单元/系统依赖于反应性属性。为了遵循反应式编程，反应式系统应用设计原则，使这些属性可以应用于所有方法。借助这种设计/方法，我们可以构建一个可组合的系统。
- en: According to the manifesto, reactive programming and reactive systems are both different.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 根据宣言，反应式编程和反应式系统是**不同**的。
- en: 'On the basis of the reactive manifesto, we can conclude that reactive systems
    are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 根据反应式宣言，我们可以得出反应式系统如下：
- en: '**Responsive**: Reactive systems are event-based design systems; these systems
    are quick to respond to any request in a short amount of time.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式**：反应式系统是基于事件的设计系统；这些系统能够在短时间内快速响应任何请求。'
- en: '**Scalable**: Reactive systems are reactive in nature. These systems can react
    to changing the scalability rate by expanding or reducing the allocated resources.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展**：反应式系统天生具有反应性。这些系统可以通过扩展或减少分配的资源来对可扩展性变化做出反应。'
- en: '**Resilient**: A resilient system is one that will not stop even if there is
    a failure/exception. Reactive systems are designed in such a way so that in any
    exception or failure, the system will never die; it remains working.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：弹性系统是指即使出现故障/异常也不会停止的系统。反应式系统设计成这样，以便在任何异常或故障中，系统都不会崩溃；它会继续工作。'
- en: '**Message-based**: Any data item represents a message that can be sent to a
    specific destination. When a message or data item has arrived at a given state,
    an event emits a signal to notify the subscribers that a message has reached. Reactive
    systems rely on this message passing.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于消息的**：任何数据项都代表可以发送到特定目的地的消息。当消息或数据项到达给定状态时，事件会发出信号通知订阅者消息已到达。反应式系统依赖于这种消息传递。'
- en: 'The following diagram shows a pictorial view of a reactive system:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了反应式系统的图形视图：
- en: '![](img/2e361032-d61e-429f-a4f8-9745429379ec.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e361032-d61e-429f-a4f8-9745429379ec.png)'
- en: In this diagram, a reactive system is composed of small systems that are resilient,
    scalable, responsive, and message-based.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，反应式系统由具有弹性、可扩展、响应式和基于消息的小系统组成。
- en: Reactive streams in action
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式流的操作
- en: So far, we have discussed the fact that reactive programming is a data stream.
    In the previous sections, we have also discussed how streams work and how these
    streams travel in a timely manner. We have seen an example of events and discussed
    the data streams in a reactive program. Now, let's go ahead with the same example
    and look at how two streams work with various operations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了反应式编程是数据流的事实。在前面的部分中，我们还讨论了流的工作方式以及这些流如何及时传输。我们已经看到了事件的一个例子，并讨论了反应式程序中的数据流。现在，让我们继续使用相同的示例，看看两个流如何与各种操作一起工作。
- en: In the next example, we have two observable streams of an integer data type
    collection. Please note that we are using the pseudo code in this section to explain
    the behavior and the way in which these collections of data streams work.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们有两个整数数据类型集合的可观察流。请注意，我们在本节中使用伪代码来解释这些数据流的行为和工作方式。
- en: 'The following diagram represents two observable streams. The first stream,
    `Observer1`, contains numbers **1**, **2**, and **4**, whereas `Observer2`, which
    is a second stream, contains numbers **3** and **5**:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下图表示了两个可观察流。第一个流`Observer1`包含数字1、2和4，而第二个流`Observer2`包含数字3和5：
- en: '![](img/35ab0fbd-3968-400c-9032-08126e65ac7a.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35ab0fbd-3968-400c-9032-08126e65ac7a.png)'
- en: 'Merging two streams involves combining their sequence elements into a new stream.
    The following diagram shows a new stream that results when `Observer1` and `Observer2`
    are merged:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 合并两个流涉及将它们的序列元素合并成一个新流。下图显示了当`Observer1`和`Observer2`合并时产生的新流：
- en: '![](img/d4aeb61d-ed6b-4fcf-9a24-8562bed48a92.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4aeb61d-ed6b-4fcf-9a24-8562bed48a92.png)'
- en: The preceding diagram is only a representation of a stream and is not an actual
    representation of the sequence of elements in the stream. In this diagram, we
    have seen that elements (numbers) are in the sequence **1**, **2**, **3**, **4**,
    **5**, but this is not true in a realistic example. The sequence can vary; it
    could be **1**, **2**, **4**, **3**, **5**, or in any other order.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表只是流的表示，不是流中元素顺序的实际表示。在这个图表中，我们看到元素（数字）的顺序是1、2、3、4、5，但在实际例子中并非如此。顺序可能会变化；它可以是1、2、4、3、5，或者任何其他顺序。
- en: 'Filtering a stream is just like skipping elements/records. You can imagine
    a `Where` clause in LINQ, which looks something like this: `myCollection.Where(num
    => num <= 3);`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤流就像跳过元素/记录一样。你可以想象LINQ中的`Where`子句，看起来像这样：`myCollection.Where(num => num <=
    3);`。
- en: 'The following diagram illustrates a pictorial view of criteria, where we''re
    trying to pick only the elements that are meeting the specific criteria:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了标准的图形视图，我们试图仅选择符合特定标准的元素：
- en: '![](img/1a2965f1-b4a3-4034-82f1-7119a41fad65.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a2965f1-b4a3-4034-82f1-7119a41fad65.png)'
- en: We are filtering our stream and picking only those elements that are *<=3*.
    This means we are skipping elements **4** and **5**. In this case, we can say
    the filter is there to skip elements or to match the criteria.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在过滤我们的流，并只选择那些*<=3*的元素。这意味着我们跳过元素4和5。在这种情况下，我们可以说过滤器是用来跳过元素或符合标准的。
- en: 'To understand a map stream, you can imagine any mathematical operation where
    you would be counting sequences or incrementing numbers by adding some constant
    values. For example, if we have an integer value of *3* and our map stream is
    *+3*, that means we are counting a sequence as *3 + 3 = 6*. You can also correlate
    this with the LINQ and select and project the output like this: `return myCollection.Select(num
    => num+3);`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解映射流，您可以想象任何数学运算，例如通过添加一些常数值来计数序列或递增数字。例如，如果我们有一个整数值为*3*，而我们的映射流是*+3*，那意味着我们正在计算一个序列，如*3
    + 3 = 6*。您还可以将其与LINQ和选择以及像这样投影输出进行关联：`return myCollection.Select(num => num+3);`。
- en: 'The following diagram represents a map of the stream:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表表示了流的映射：
- en: '![](img/031e8a71-9f81-475c-ac46-ae15cd06bc7c.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/031e8a71-9f81-475c-ac46-ae15cd06bc7c.png)'
- en: After applying filters with the condition, *<= 3*, our stream has the elements **1**,
    **2**, and **3**. Additionally, we applied `Map (+3)` to the filtered stream with
    the elements **1**, **2**, and **3**, and, finally, our stream has the elements **4**,**5**,**6**
    (1+3, 2+3, 3+3).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用条件为*<= 3*的过滤器后，我们的流具有元素**1**、**2**和**3**。此外，我们对过滤后的流应用了`Map (+3)`，其中包含元素**1**、**2**和**3**，最后，我们的流具有元素**4**、**5**、**6**（1+3,
    2+3, 3+3）。
- en: 'In the real world, these operations would occur sequentially or on demand.
    We have already done this operation of sequences so that we can apply the operations
    of merge, filter, and mapping in a sequential manner. The following diagram represents
    the flow of our imaginary example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，这些操作将按顺序或按需发生。我们已经按顺序执行了这些序列操作，以便我们可以按顺序应用合并、过滤和映射操作。以下图表表示我们想象中例子的流程：
- en: '![](img/c3bfc2c2-2d3a-484f-a99f-8f8c3082316c.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3bfc2c2-2d3a-484f-a99f-8f8c3082316c.png)'
- en: So, we have tried to represent our examples through diagrams, and we have gone
    through various operations where two streams talk to each other, and we got a
    new stream, and then we filtered and mapped the stream.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们尝试通过图表来表示我们的例子，并且我们已经经历了各种操作，其中两个流相互交谈，我们得到了一个新的流，然后我们过滤和映射了这个流。
- en: To understand this better, refer to [https://rxmarbles.com/](https://rxmarbles.com/).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地理解这一点，请参考[https://rxmarbles.com/](https://rxmarbles.com/)。
- en: Now let's create a simple code to complete this example in the real world. First,
    we will study the code that implements the example, and then we will discuss the
    output of the stream.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个简单的代码来完成这个真实世界的例子。首先，我们将学习实现示例的代码，然后我们将讨论流的输出。
- en: 'Consider the following code snippet as an example of the `IObservable` interface:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段作为`IObservable`接口的示例：
- en: '`public static IObservable<T> From<T>(this T[] source) => source.ToObservable();`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`public static IObservable<T> From<T>(this T[] source) => source.ToObservable();`'
- en: This code represents an extension method of a `T` type array. We created a generic
    method and named it `From`. This method returns an `Observable` sequence.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码表示了`T`类型数组的扩展方法。我们创建了一个通用方法，并命名为`From`。这个方法返回一个`Observable`序列。
- en: 'You can visit the official documentation to know more about extension methods
    here: [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问官方文档了解更多关于扩展方法的信息：[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)。
- en: 'In our code, we have the `TicketCounter` class. This class has two observers
    that are actually arrays of the integer data type. The following code shows two
    observables:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们有`TicketCounter`类。这个类有两个观察者，实际上是整数数据类型的数组。以下代码显示了两个可观察对象：
- en: '[PRE0]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this code, we apply the `From()` extension method to `Counter1` and `Counter2`.
    These counters actually represent our ticket counters and recall our example from
    [Chapter 8](ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml), *Concurrent programming
    in .NET Core*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们将`From()`扩展方法应用于`Counter1`和`Counter2`。这些计数器实际上代表我们的售票处，并回顾了我们在[第8章](ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml)中的例子，*在.NET
    Core中进行并发编程*。
- en: 'The following code snippet represents `Counter1` and `Counter2`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段表示`Counter1`和`Counter2`：
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this code, we have two fields, `Counter1` and `Counter2`, and they are initialized
    from the constructor. When the `TicketCounter` class is being initialized, these
    fields get the values from the constructor of the class, as defined in the following
    code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们有两个字段，`Counter1`和`Counter2`，它们是从构造函数中初始化的。当初始化`TicketCounter`类时，这些字段从类的构造函数中获取值，如下面的代码所定义的：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To understand the complete code, go to and execute the code by hitting *F5* in
    Visual Studio. From here, you will see the following screen:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解完整的代码，请转到Visual Studio并按下*F5*执行代码。从这里，您将看到以下屏幕：
- en: '![](img/7ca5c074-4bcc-4994-bb14-27c1f6df5946.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ca5c074-4bcc-4994-bb14-27c1f6df5946.png)'
- en: 'This is the console output and, in this console window, the user has been asked
    to enter a comma-separated number from `0` to `9`. Go ahead and enter a comma-separated
    number here. Please note that, here, we are trying to create a code that depicts
    our diagram of data stream representation, which was discussed earlier in this
    section:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是控制台输出，在这个控制台窗口中，用户被要求输入一个从`0`到`9`的逗号分隔数字。继续并在这里输入一个逗号分隔的数字。请注意，这里，我们试图创建一个代码，描述我们之前在本节中讨论的数据流表示的图表。
- en: '![](img/d898ad73-55f7-4510-8b2b-b860bce2c9cf.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d898ad73-55f7-4510-8b2b-b860bce2c9cf.png)'
- en: 'As per the preceding diagram, we have entered two different comma-separated
    numbers. The first is `1,2,4` and the second is `3,5`. Now consider our `Merge`
    method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的图表，我们输入了两个不同的逗号分隔数字。第一个是`1,2,4`，第二个是`3,5`。现在考虑我们的`Merge`方法：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Merge` method is merging two sequences of the data stream into `_observable`.
    The `Merge` operation is initiated with the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Merge`方法将数据流的两个序列合并为`_observable`。`Merge`操作是通过以下代码启动的：'
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this code, the user is prompted to enter comma-separated numbers, and then
    the program stores these numbers into `counter1` and `counter2` by applying the `ToInts`
    method. The following is the code of our `ToInts` method:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，用户被提示输入逗号分隔的数字，然后程序通过`ToInts`方法将这些数字存储到`counter1`和`counter2`中。以下是我们`ToInts`方法的代码：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code is an extension method for `string`. The target variable is of a `string`
    type that contains integers separated by `separator`. In this method, we are using
    the built-in `ConvertAll` method that is provided by .NET Core. This first splits
    the string and checks whether the split value is of an `integer` type. It then
    returns the `Array` of integers. This method produces the output, as shown in
    the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是`string`的扩展方法。目标变量是一个包含由`separator`分隔的整数的`string`类型。在这个方法中，我们使用了.NET Core提供的内置`ConvertAll`方法。它首先分割字符串，并检查分割值是否为`integer`类型。然后返回整数的`Array`。这个方法产生的输出如下截图所示：
- en: '![](img/481c8752-3a12-4265-86d3-05dd0b57ceca.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/481c8752-3a12-4265-86d3-05dd0b57ceca.png)'
- en: 'The following is the output of our `merge` operation:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们`merge`操作的输出：
- en: '![](img/b45912b4-2e62-4a21-8fad-4ea7d1524d85.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b45912b4-2e62-4a21-8fad-4ea7d1524d85.png)'
- en: 'The preceding output shows that we now have a final merged observer stream
    with the elements in sequence. Let''s apply a filter to this stream. The following
    code is our `Filter` method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示，我们现在有了一个最终合并的观察者流，其中包含了按顺序排列的元素。让我们对这个流应用一个筛选器。以下是我们的`Filter`方法的代码：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have the filter criteria for the number `<= 3`, which means we will pick
    only the elements whose values are either less than or equal to `3`. This method
    will initiate with the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有数字`<= 3`的筛选条件，这意味着我们只会选择值小于或等于`3`的元素。这个方法将以以下代码开始：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When the preceding code is executed, it produces the following output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行上述代码时，会产生以下输出：
- en: '![](img/22aede10-aae2-4fee-9e9d-8d549af5ea7d.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22aede10-aae2-4fee-9e9d-8d549af5ea7d.png)'
- en: 'Finally, we have a filtered stream with the elements in the sequence 1,3,2\.
    Now we need to map on this stream. We need a mapped element with `num + 3`, which
    means we need to output an integer number by adding `3` to this number. The following
    is our `Map` method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到了一个按顺序排列的筛选流，其中包含了元素1,3,2。现在我们需要在这个流上进行映射。我们需要一个通过`num + 3`得到的映射元素，这意味着我们需要通过给这个数字加上`3`来输出一个整数。以下是我们的`Map`方法：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding method will be initialized with the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法将以以下代码初始化：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On execution of the preceding method, we will see the following output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述方法后，我们将看到以下输出：
- en: '![](img/b1f0aa3c-79ef-48d4-98e2-c178c079b892.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1f0aa3c-79ef-48d4-98e2-c178c079b892.png)'
- en: 'After applying the `Map` method, we have the stream of an element in the sequence
    of 4,6,5\. We have discussed how reactive works even with an imaginary example.
    We have created a small .NET Core console application to see the power of `Merge`,
    `Filter`, and `Map` operations on the observables. The following is the output
    of our console application:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 应用`Map`方法后，我们得到了一个按顺序排列的元素流4,6,5。我们已经讨论了响应式如何与一个虚构的例子一起工作。我们创建了一个小的.NET Core控制台应用程序，以查看`Merge`，`Filter`和`Map`操作对可观察对象的影响。以下是我们控制台应用程序的输出：
- en: '![](img/8ed54e75-5467-4282-ab32-9dbf41194cfa.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ed54e75-5467-4282-ab32-9dbf41194cfa.png)'
- en: The previous snapshot is telling the whole story of the execution of our sample
    application; `Counter1` and `Counter2` are data streams that contain the sequences
    of data 1,2,4 and 3,5\. We have the preceding output for `Merge` with the result
    `1,3,2,5,4 Filter (<=3)`, with the result 1,3,2 and `Map (+3)` with the data 4,6,5.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的快照讲述了我们示例应用程序的执行过程；`Counter1`和`Counter2`是包含数据序列1,2,4和3,5的数据流。我们有了`Merge`的输出结果是`1,3,2,5,4
    Filter (<=3)`，结果是1,3,2和`Map (+3)`的数据是4,6,5。
- en: Reactive and IObservable
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式和IObservable
- en: In the previous section, we discussed reactive programming and went through
    its model. In this section, we will discuss the Microsoft implementation of reactive
    programming. In response to reactive programming in .NET Core, we have various
    interfaces that provide a way to implement reactive programming in our application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，我们讨论了响应式编程并了解了它的模型。在这一部分，我们将讨论微软对响应式编程的实现。针对.NET Core中的响应式编程，我们有各种接口，提供了在我们的应用程序中实现响应式编程的方法。
- en: '`IObservable<T>` is a generic interface that is defined in the `System` namespace
    and declared as `public interface IObservable<out T>`. Here, `T` represents a
    generic type of parameter that provides notification information. In simple terms,
    this interface helps us to define a provider for notifications, and these notifications
    can be pushed for information. You can use the observer pattern while implementing
    the `IObservable<T>` interface in your application.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`IObservable<T>`是一个泛型接口，定义在`System`命名空间中，声明为`public interface IObservable<out
    T>`。在这里，`T`代表提供通知信息的泛型参数类型。简单来说，这个接口帮助我们定义了一个通知的提供者，这些通知可以被推送出去。在你的应用程序中实现`IObservable<T>`接口时，可以使用观察者模式。'
- en: Observer pattern – implementation using IObservable<T>
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式 - 使用IObservable<T>进行实现
- en: In simple terms, a subscriber registers with a provider so that the subscriber
    may get notifications related to the message information. These notifications
    notify the provider that messages have been delivered to subscribers. This information
    may also be related to changes in operations or any other changes in the method
    or object itself. This is also known as **state changes**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，订阅者注册到提供者，以便订阅者可以得到与消息信息相关的通知。这些通知通知提供者消息已经被传递给订阅者。这些信息也可能与操作的变化或方法或对象本身的任何其他变化相关。这也被称为**状态变化**。
- en: The observer pattern specifies two terms: Observer and Observable. The observable
    is a provider also known as the **subject***.* The observer is registered with
    the `Observable`/`Subject`/`Provider` types, and the observer will be automatically
    notified by the provider whenever any changes occur due to the pre-defined criteria/condition,
    change or event, and so on.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式指定了两个术语：观察者和可观察对象。可观察对象也称为提供者或主题。观察者注册在`Observable`/`Subject`/`Provider`类型上，并且当由于预定义的标准/条件、更改或事件等发生任何变化时，提供者会自动通知观察者。
- en: 'The following diagram is a simple representation of the observer pattern, where
    the subject is notifying two different observers:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表是观察者模式的简单表示，其中主题通知了两个不同的观察者：
- en: '![](img/4d2b83fd-d913-4456-bf7a-b587b7e12da5.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d2b83fd-d913-4456-bf7a-b587b7e12da5.png)'
- en: Go back to the `FlixOne` inventory web application from [Chapter 9](b1363fa4-f669-4670-9d40-a7e888557249.xhtml),
    *Functional Programming Practices*, initiate your Visual Studio, and open the `FlixOne.sln` solution.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第9章](b1363fa4-f669-4670-9d40-a7e888557249.xhtml)的`FlixOne`库存Web应用程序返回，*功能编程实践*，启动你的Visual
    Studio，并打开`FlixOne.sln`解决方案。
- en: 'Open Solution Explorer. From here, you will see that our project will look
    similar to the following snapshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 打开解决方案资源管理器。从这里，你会看到我们的项目看起来类似于以下快照：
- en: '![](img/6c18ba34-8fb5-4905-b012-8d55995ca8fc.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c18ba34-8fb5-4905-b012-8d55995ca8fc.png)'
- en: 'Expand the Common folder under Solution Explorer and add two files: `ProductRecorder.cs`
    and `ProductReporter.cs`. These files are the implementation of the `IObservable<T>`
    and `IObserver<T>` interfaces. We also need to add a new ViewModel so that we
    can report actual messages to the users. To do so, expand the `Models` folder
    and add the `MessageViewModel.cs` file.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器下展开`Common`文件夹，并添加两个文件：`ProductRecorder.cs`和`ProductReporter.cs`。这些文件是`IObservable<T>`和`IObserver<T>`接口的实现。我们还需要添加一个新的ViewModel，以便向用户报告实际的消息。为此，展开`Models`文件夹并添加`MessageViewModel.cs`文件。
- en: 'The following code is showing our `MessageViewModel` class:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了我们的`MessageViewModel`类：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`MessageViewModel` contains the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageViewModel`包含以下内容：'
- en: '`MsgId`: A unique identifier'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MsgId`：唯一标识符'
- en: '`IsSuccess`: Shows whether the operation has failed or succeeded'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsSuccess`：显示操作是失败还是成功。'
- en: '`Message`: A success message or an error message that depends upon the value
    of `IsSuccess`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message`：根据`IsSuccess`的值而定的成功消息或错误消息'
- en: '`ToString()`: An override method that returns a string after concatenating
    all the information'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToString()`：一个重写方法，在连接所有信息后返回一个字符串'
- en: 'Let''s now discuss our two classes; the following code is from the `ProductRecorder`
    class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论我们的两个类；以下代码来自`ProductRecorder`类：
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our `ProductRecorder` class implements the `IObservable<Product>` interface.
    If you recall our discussion regarding the observer pattern, you will come to
    know that this class is actually a provider, a subject, or an observable. The `IObservable<T>`
    interface has a `Subscribe` method that we need to use to subscribe our subscribers
    or observers (we will discuss the observer later in this section).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ProductRecorder`类实现了`IObservable<Product>`接口。如果你回忆一下我们关于观察者模式的讨论，你会知道这个类实际上是一个提供者、主题或可观察对象。`IObservable<T>`接口有一个`Subscribe`方法，我们需要用它来订阅我们的订阅者或观察者（我们将在本节后面讨论观察者）。
- en: 'There should be a criteria or a condition so that the subscriber can get notifications.
    In our case, we have a `Record` method that serves this purpose. Consider the
    following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 应该有一个标准或条件，以便订阅者可以收到通知。在我们的情况下，我们有一个`Record`方法来实现这个目的。考虑以下代码：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding is a `Record` method. We created this method to showcase the power
    of the pattern. This method is simply checking for the valid discount rates. If
    `discount rate` is not valid, as per the criteria/condition, this method would
    raise an exception and share the product name with an invalid `discount rate`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 前面是一个`Record`方法。我们创建这个方法来展示模式的强大之处。这个方法只是检查有效的折扣率。如果根据标准/条件，`折扣率`无效，这个方法将引发异常并与无效的`折扣率`一起分享产品名称。
- en: 'The previous method validates the discount rate as per the criteria and sends
    a notification about the raised exception to the subscriber upon failure of the
    criteria. Take a look at the iteration block (the `foreach` loop) and imagine
    a situation where we do not have anything to iterate and all the subscribers have
    been notified. Can we imagine what will happen in this case? The same kind of
    situation may arise for `infinite` loop. To stop this, we need something that
    terminates the loop. For this, we have the following `EndRecording` method:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法根据标准验证折扣率，并在标准失败时向订阅者发送关于引发异常的通知。看一下迭代块（`foreach`循环）并想象一种情况，我们没有任何东西可以迭代，所有订阅者都已经收到通知。我们能想象在这种情况下会发生什么吗？同样的情况可能会发生在无限循环中。为了阻止这种情况，我们需要一些终止循环的东西。为此，我们有以下的`EndRecording`方法：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our `EndRecoding` method is looping through the collection of `_observers` and
    triggering the `OnCompleted()` method explicitly. Finally, it cleared the `_observers` collection.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`EndRecoding`方法正在循环遍历`_observers`集合，并显式触发`OnCompleted()`方法。最后，它清除了`_observers`集合。
- en: 'Now, let''s discuss the `ProductReporter` class. This class is an example of
    the implementation of the `IObserver<T>` interface. Consider the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论`ProductReporter`类。这个类是`IObserver<T>`接口实现的一个例子。考虑以下代码：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `IObserver<T>` interface has the `OnComplete`, `OnError`, and `OnNext` methods
    that we have to implement in the `ProductReporter` class. The purpose of the `OnComplete`
    method is to notify the subscriber that the job has been done and then flush out
    the code. Furthermore, `OnError` is invoked when an error occurs during execution,
    while `OnNext` provides information of the next element in the sequence of a stream.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`IObserver<T>`接口有`OnComplete`、`OnError`和`OnNext`方法，我们需要在`ProductReporter`类中实现这些方法。`OnComplete`方法的目的是通知订阅者工作已经完成，然后清除代码。此外，`OnError`在执行过程中发生错误时被调用，而`OnNext`提供了流序列中下一个元素的信息。'
- en: 'In the following code, `PrepReportData` is a value addition that gives the
    user a formatted report about all the operations of the process:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`PrepReportData`是一个增值，它为用户提供了有关过程的所有操作的格式化报告：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding method is simply making additions to our `Reporter` collection,
    which is a collection of `MessageViewModel` classes. Note that, for simplicity
    purposes, you can also use the `ToString()` method that we have implemented in
    our `MessageViewModel` class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法只是向我们的`Reporter`集合添加了一些内容，这是`MessageViewModel`类的集合。请注意，出于简单起见，您还可以使用我们在`MessageViewModel`类中实现的`ToString()`方法。
- en: 'The following code snippet shows the `Subcribe` and `Unsubscribe` methods:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了`Subcribe`和`Unsubscribe`方法：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The previous two methods tell the system that there is a provider. Subscribers
    could subscribe to the provider or unsubscribe/dispose of it upon completion of
    the operations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种方法告诉系统有一个提供者。订阅者可以订阅该提供者，或在操作完成后取消订阅/处理它。
- en: Now it's time to showcase our implementation and see some good results. To do
    so, we need to make some changes to our existing `Product Listing` page and add
    a new View page to our project.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是展示我们的实现并看到一些好结果的时候了。为此，我们需要对现有的`Product Listing`页面进行一些更改，并向项目添加一个新的View页面。
- en: 'Add the following link to our `Index.cshtml` page so that we can see the new
    link to view Audit Report:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Index.cshtml`页面中添加以下链接，以便我们可以看到查看审计报告的新链接：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code snippet, we added a new link to show the Audit Report
    based on our implementation of the `Report Action` method, which we have defined
    in our `ProductConstroller` class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们添加了一个新链接，以显示基于我们在`ProductConstroller`类中定义的`Report Action`方法的审计报告。
- en: 'After adding this code, our Product Listing page will look as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此代码后，我们的产品列表页面将如下所示：
- en: '![](img/8ef8a83f-a7a4-4df1-85cc-96b6ed21a54c.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ef8a83f-a7a4-4df1-85cc-96b6ed21a54c.png)'
- en: 'First, let''s discuss the `Report action` method. For this, consider the following
    code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论`Report action`方法。为此，请考虑以下代码：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, we are only taking the first three products for demonstration
    purposes. Please note that you can modify the code as per your own implementation.
    In the code, we have created a `productProvider` class and three observers to
    subscribe to our `productProvider` class.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们只取前三个产品进行演示。请注意，您可以根据自己的实现修改代码。在代码中，我们创建了一个`productProvider`类和三个观察者来订阅我们的`productProvider`类。
- en: 'The following diagram is a pictorial view of all the activities to showcase
    the `IObservable<T>` and `IObserver<T>` interfaces that we have discussed:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表是我们讨论过的`IObservable<T>`和`IObserver<T>`接口的所有活动的图形视图：
- en: '![](img/846c2b3f-d4ee-49c8-b5d5-106160ff4a5f.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/846c2b3f-d4ee-49c8-b5d5-106160ff4a5f.png)'
- en: 'The following code is used to subscribe to `productrovider`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于订阅`productrovider`：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we need to log the report and then unsubscribe:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要记录报告，然后取消订阅：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s come back to our screen and add the `Report.cshtml` file to Views |
    Product. The following code is part of our Report page. You can find the complete
    code in the `Product` folder:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的屏幕，并将`Report.cshtml`文件添加到Views | Product。以下代码是我们报告页面的一部分。您可以在`Product`文件夹中找到完整的代码：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code will create a header for the columns of our table that shows the audit
    report.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将为表格的列创建标题，显示审计报告。
- en: 'The following code will complete the table and add values to the `IsSuccess`
    and `Message` columns:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将完成表格并向`IsSuccess`和`Message`列添加值：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'At this point, we are done with our implementation of the observer pattern
    using `IObservable<T>` and `IObserver<T>` interfaces. Run the project by pressing
    *F5* in Visual Studio, click on Product in the home page, and then click on the Audit
    Report link. From here, you will see that the audit report of our selected products,
    as shown in the following screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经使用`IObservable<T>`和`IObserver<T>`接口实现了观察者模式。在Visual Studio中按下*F5*运行项目，在主页上点击Product，然后点击审计报告链接。从这里，您将看到我们选择的产品的审计报告，如下图所示：
- en: '![](img/078bcd2a-09a4-484c-8d76-95933be89587.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/078bcd2a-09a4-484c-8d76-95933be89587.png)'
- en: The preceding screenshot shows a simple listing page that shows the data from
    a `MessageViewModel` class. You can make the changes and modify them as per your
    requirement. In general, audit reports are coming from a lot of operational activities
    that we are seeing in the preceding screen. You could also save the audited data
    in the database and then serve this data accordingly for different purposes such
    as for reporting to admin and more.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 上述屏幕截图显示了一个简单的列表页面，显示了来自`MessageViewModel`类的数据。您可以根据需要进行更改和修改。一般来说，审计报告来自我们在上述屏幕中看到的许多操作活动。您还可以将审计数据保存在数据库中，然后根据需要为不同目的提供这些数据，例如向管理员报告等。
- en: Reactive extensions – .NET Rx extensions
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式扩展 - .NET Rx扩展
- en: The discussion in the previous session was aimed at reactive programming and
    the implementation of reactive programming using the `IObservable<T>` and `IObserver<T>`
    interfaces as an observer pattern. In this section, we will extend our learning
    with the help of **Rx Extensions**. If you would like to find out more about the
    development of Rx Extensions, you should follow the official repository at [https://github.com/dotnet/reactive](https://github.com/dotnet/reactive).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节讨论的是响应式编程以及使用`IObservable<T>`和`IObserver<T>`接口作为观察者模式实现响应式编程。在本节中，我们将借助**Rx扩展**扩展我们的学习。如果您想了解有关Rx扩展开发的更多信息，可以关注官方存储库[https://github.com/dotnet/reactive](https://github.com/dotnet/reactive)。
- en: 'Please note that Rx Extensions are now merged with the `System` namespace,
    and you can find everything in the `System.Reactive` namespace. If you have experience
    with Rx Extensions, you should know that the namespace of these extensions has
    been changed, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Rx扩展现在已与`System`命名空间合并，您可以在`System.Reactive`命名空间中找到所有内容。如果您有Rx扩展的经验，您应该知道这些扩展的命名空间已更改，如下所示：
- en: '`Rx.Main` has been changed to `System.Reactive`.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rx.Main`已更改为`System.Reactive`。'
- en: '`Rx.Core` has been changed to `System.Reactive.Core`.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rx.Core`已更改为`System.Reactive.Core`。'
- en: '`Rx.Interfaces` has been changed to `System.Reactive.Interfaces`.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rx.Interfaces`已更改为`System.Reactive.Interfaces`。'
- en: '`Rx.Linq` has been changed to `System.Reactive.Linq`.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rx.Linq`已更改为`System.Reactive.Linq`。'
- en: '`Rx.PlatformServices` has been changed to `System.Reactive.PlatformServices`.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rx.PlatformServices`已更改为`System.Reactive.PlatformServices`。'
- en: '`Rx.Testing` has been changed to `Microsoft.Reactive.Testing`.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rx.Testing`已更改为`Microsoft.Reactive.Testing`。'
- en: 'To initiate Visual Studio, open the `SimplyReactive` project (discussed in
    the previous section) and open the NuGet Package Manager. Click on Browse and
    enter the search term `System.Reactive`. From here, you will see the following
    results:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动Visual Studio，请打开在上一节中讨论的`SimplyReactive`项目，并打开NuGet包管理器。点击浏览，输入搜索词`System.Reactive`。从这里，您将看到以下结果：
- en: '![](img/f1de57f4-7e26-4caa-9028-33a6d4e13cd5.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1de57f4-7e26-4caa-9028-33a6d4e13cd5.png)'
- en: The aim of this section is to make you aware of reactive extensions but not
    delve into its internal development. These extensions are under the Apache2.0
    license and maintained by .NET Foundation. We have already implemented reactive
    extensions in our `SimplyReactive` application.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目的是让您了解响应式扩展，而不深入其内部开发。这些扩展受Apache2.0许可证管辖，并由.NET基金会维护。我们已经在我们的`SimplyReactive`应用程序中实现了响应式扩展。
- en: Inventory application use case
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库存应用用例
- en: In this section, we will continue with our FlixOne inventory application. Throughout
    this section, we will discuss the web application pattern and extend our web application
    developed in [Chapter 4](4f644693-85a7-4543-af8c-109d8519b2e5.xhtml), *Implementing
    Design Patterns - Basics Part 2*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续讨论我们的FlixOne库存应用程序。在本节中，我们将讨论Web应用程序模式，并扩展我们在[第4章](4f644693-85a7-4543-af8c-109d8519b2e5.xhtml)中开发的Web应用程序，*实现设计模式-基础知识第2部分*。
- en: This chapter continues looking at web applications that were discussed in the
    previous chapter. If you skipped the previous chapter ([Chapter 9](b1363fa4-f669-4670-9d40-a7e888557249.xhtml),
    *Functional Programming Practices*), please revisit it to get up to speed with
    the current chapter.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本章继续讨论了上一章中讨论的Web应用程序。如果您跳过了上一章（[第9章](b1363fa4-f669-4670-9d40-a7e888557249.xhtml)，*函数式编程实践*），请重新阅读以便跟上当前章节。
- en: In this section, we will go through the process of requirement gathering and
    then discuss the various challenges of development and business with our web application
    that we developed previously.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍需求收集的过程，然后讨论我们之前开发的Web应用程序的开发和业务的各种挑战。
- en: Starting the project
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动项目
- en: 'In [Chapter 7](232b63cb-5006-431d-8378-b7e2ba4c1119.xhtml), *Implementing Design
    Patterns for Web Applications - Part 2*, we added features to our FlixOne inventory
    web application. We extended the application after considering the following points:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](232b63cb-5006-431d-8378-b7e2ba4c1119.xhtml)，*为Web应用程序实现设计模式-第2部分*中，我们为FlixOne库存Web应用程序添加了功能。在考虑以下几点后，我们扩展了应用程序：
- en: The business needs a rich UI.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务需要一个丰富的用户界面。
- en: New opportunities demand a responsive web application.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的机会需要一个响应式Web应用程序。
- en: Requirements
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求
- en: After several meetings and discussions with management, **Business Analyst**
    (**BA**), and presales folks, the management of the organization decided to work
    upon the following high-level requirements.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几次会议和与管理层、**业务分析师**（**BA**）和售前人员的讨论后，组织的管理层决定处理以下高层需求。
- en: Business requirements
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务需求
- en: 'Our business team listed the following requirements:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的业务团队列出了以下要求：
- en: '**Item filtering**: Currently, users are unable to filter items by category.
    To extend the list-view feature, the user should be able to filter the product
    item based on its respective category.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目过滤**：目前，用户无法按类别筛选项目。为了扩展列表视图功能，用户应该能够根据其各自的类别筛选产品项目。'
- en: '**Item sorting**: Currently, items are appearing in the order in which they
    have been added to the database. There is no mechanism where a user can sort items
    based on the item''s name, price, and so on.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目排序**：目前，项目按照它们添加到数据库的顺序显示。没有机制可以让用户根据项目的名称、价格等对项目进行排序。'
- en: The FlixOne inventory management web application is an imaginary product. We
    are creating this application to discuss the various design patterns required/used
    in the web project.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: FlixOne库存管理Web应用程序是一个虚构的产品。我们正在创建此应用程序来讨论Web项目中所需/使用的各种设计模式。
- en: Getting inventory with a filter, paging, and sorting
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用过滤器、分页和排序获取库存
- en: 'As per our business requirements, we need to apply a filter, paging, and sorting
    to our FlixOne inventory application. First, let''s start implementing the sorting.
    To do so, I''ve created a project and put this project in the `FlixOneWebExtended`
    folder. Start Visual Studio and open the FlixOne solution. We will apply to sort
    to our product listing sheet for these columns: `Category`, `productName`, `Description`,
    and `Price`. Please note that we will not be using any external component for
    sorting, but we will create our own login.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的业务需求，我们需要对我们的FlixOne库存应用程序应用过滤、分页和排序。首先，让我们开始实现排序。为此，我创建了一个项目并将该项目放在`FlixOneWebExtended`文件夹中。启动Visual
    Studio并打开FlixOne解决方案。我们将对我们的产品清单表应用排序，包括这些列：`类别`、`产品名称`、`描述`和`价格`。请注意，我们不会使用任何外部组件进行排序，而是将创建我们自己的登录。
- en: Open the Solution Explorer, and open `ProductController`, which is available
    in the `Controllers` folder. Add the `[FromQuery]Sort sort` parameter to the `Index`
    method. Please note that the `[FromQuery]` attribute indicates that this parameter
    is a query parameter. We will use this parameter to maintain our sorting order.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 打开“解决方案资源管理器”，并打开`ProductController`，该文件位于`Controllers`文件夹中。向`Index`方法添加`[FromQuery]Sort
    sort`参数。请注意，`[FromQuery]`属性表示此参数是一个查询参数。我们将使用此参数来维护我们的排序顺序。
- en: 'The following code shows the `Sort` class:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`Sort`类：
- en: '[PRE23]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `Sort` class contains three public properties as detailed here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sort`类包含以下三个公共属性：'
- en: '`Order`: Indicates the sorting order. The `SortOrder` is an enum defined as
    `public enum SortOrder { D, A, N }`.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Order`：表示排序顺序。`SortOrder`是一个枚举，定义为`public enum SortOrder { D, A, N }`。'
- en: '`ColName`: Indicates the column name.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColName`：表示列名。'
- en: '`ColType`: Indicates the type of a column; `ColumnType` is an enum defined
    as `public enum ColumnType { Text, Date, Number }`.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColType`：表示列的类型；`ColumnType`是一个枚举，定义为`public enum ColumnType { Text, Date,
    Number }`。'
- en: 'Open the `IInventoryRepositry` interface, and add the `IEnumerable<Product>
    GetProducts(Sort sort)` method. This method is responsible for sorting the results.
    Please note that we are going to use LINQ queries to apply sorting. Implement
    this `InventoryRepository` class method and add the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`IInventoryRepositry`接口，并添加`IEnumerable<Product> GetProducts(Sort sort)`方法。此方法负责对结果进行排序。请注意，我们将使用LINQ查询来应用排序。实现这个`InventoryRepository`类的方法，并添加以下代码：
- en: '[PRE24]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following code is handling the case when `sort.ColName` is `productname`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码处理了`sort.ColName`为`productname`的情况：
- en: '[PRE25]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following code is handling the case when `sort.ColName` is `productprice`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码处理了`sort.ColName`为`productprice`的情况：
- en: '[PRE26]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the previous code, we set the value of the `sort` parameter as blank if it
    contains a null value, and then we process it by using `switch..case` in `sort.ColName.ToLower()`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，如果`sort`参数包含空值，则将其值设置为空，并使用`switch..case`在`sort.ColName.ToLower()`中进行处理。
- en: 'The following is our `ListProducts()` method that gives us the result of the `IIncludeIQuerable<Product,Category>` type:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的`ListProducts()`方法，它给我们`IIncludeIQuerable<Product,Category>`类型的结果：
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding code simply gives us `Products` by including `Categories` for
    each product. The sorting order will come from our user, so we need to modify
    our `Index.cshtml` page. We also need to add an anchor tag to the header columns
    of the table. For this, consider the following code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码简单地通过包含每个产品的`Categories`来给我们`Products`。排序顺序将来自我们的用户，因此我们需要修改我们的`Index.cshtml`页面。我们还需要在表的标题列中添加一个锚标记。为此，请考虑以下代码：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding code show the header columns of the table; `new Sort { ColName
    = "ProductName", ColType = ColumnType.Text, Order = SortOrder.A }` is the main
    way we are implementing `SorOrder`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码显示了表的标题列；`new Sort { ColName = "ProductName", ColType = ColumnType.Text,
    Order = SortOrder.A }` 是我们实现`SorOrder`的主要方式。
- en: 'Run the application and you will see the following snapshot of the Product
    Listing page with the sorting feature:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，您将看到产品列表页面的以下快照，其中包含排序功能：
- en: '![](img/c72b4b9f-358a-41d8-9ff6-6f5c30f075af.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c72b4b9f-358a-41d8-9ff6-6f5c30f075af.png)'
- en: 'Now, open the `Index.cshtml` page, and add the following code to the page:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`Index.cshtml`页面，并将以下代码添加到页面中：
- en: '[PRE29]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding code, we are adding a textbox under `Form`. Here, the user
    inputs the data/value, and this data submits to the server as soon as the user
    clicks the submit button. At the server side, the filtered data will returned
    back and show the product listing. After the implementation of the preceding code,
    our Product Listing page will look like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们在`Form`下添加了一个文本框。在这里，用户输入数据/值，并且当用户点击提交按钮时，这些数据会立即提交到服务器。在服务器端，过滤后的数据将返回并显示产品列表。在实现上述代码之后，我们的产品列表页面将如下所示：
- en: '![](img/dcf4ab01-e7d0-46b5-be17-6a942f083335.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcf4ab01-e7d0-46b5-be17-6a942f083335.png)'
- en: 'Go to the `Index` method in `ProductController` and change the parameters.
    Now the `Index` method looks like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`ProductController`中的`Index`方法并更改参数。现在`Index`方法看起来像这样：
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Similarly, we need to update the method parameters of `GetProducts()` in `InventoryRepository`
    and `InventoryRepository`. The following is the code for the `InventoryRepository` class:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们需要更新`InventoryRepository`和`InventoryRepository`中`GetProducts()`方法的参数。以下是`InventoryRepository`类的代码：
- en: '[PRE31]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now run the project by pressing *F5* from Visual Studio and navigating to the
    filter/search option in Product Listing. For this, see this snapshot:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过从Visual Studio按下*F5*并导航到产品列表中的过滤/搜索选项来运行项目。为此，请参阅此快照：
- en: '![](img/802ed721-1eb2-4afc-8b51-3be146702b5b.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/802ed721-1eb2-4afc-8b51-3be146702b5b.png)'
- en: 'After entering your search term, click on the Search button, and this will
    give you the results, as shown in the following snapshot:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 输入搜索词后，单击搜索按钮，这将给您结果，如下快照所示：
- en: '![](img/a6f32b34-7662-4b1d-be5f-6d5a7c0c1bec.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6f32b34-7662-4b1d-be5f-6d5a7c0c1bec.png)'
- en: 'In the preceding Product Listing screenshot, we are filtering our Product records
    with `searchTerm` `mango`, and it produces single results, as shown in the previous
    snapshot. There is one issue in this approach for searching data: add `fruit`
    as a search term, and see what will happen. It will produce zero results. This
    is demonstrated in the following snapshot:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述产品列表截图中，我们正在使用`searchTerm` `mango`过滤我们的产品记录，并且它产生了单个结果，如前面的快照所示。在搜索数据的这种方法中存在一个问题：将`fruit`作为搜索词添加，然后看看会发生什么。它将产生零结果。这在以下快照中得到了证明：
- en: '![](img/06ac51ab-3dfb-47e7-9e2a-8aeea1d0f932.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06ac51ab-3dfb-47e7-9e2a-8aeea1d0f932.png)'
- en: We do not get any result, which means our search is not working when we are
    putting `searchTerm` in lowercase. This means our search is case-sensitive. We
    need to change our code to get it started.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有得到任何结果，这意味着当我们将`searchTerm`转换为小写时，我们的搜索不起作用。这意味着我们的搜索是区分大小写的。我们需要更改我们的代码以使其起作用。
- en: 'Here is our modified code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们修改后的代码：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We are ignoring the case to make our search case-insensitive. We used `StringComparison.InvariantCultureIgnoreCase`
    and ignored the case. Now our search will work with either capital or lowercase
    letters. The following is the snapshot that produces results using lowercase `fruit`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忽略大小写以使我们的搜索不区分大小写。我们使用了`StringComparison.InvariantCultureIgnoreCase`并忽略了大小写。现在我们的搜索将使用大写或小写字母。以下是使用小写`fruit`产生结果的快照：
- en: '![](img/80ddb52c-00e6-4041-b490-377f78e502a6.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80ddb52c-00e6-4041-b490-377f78e502a6.png)'
- en: 'In a previous discussion during the FlixOne app extension, we applied `Sort`
    and `Filter`; now we need to add `paging`. To do so, we have added a new class
    named, `PagedList` as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的FlixOne应用程序扩展讨论中，我们应用了`Sort`和`Filter`；现在我们需要添加`paging`。为此，我们添加了一个名为`PagedList`的新类，如下所示：
- en: '[PRE33]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, change the parameters of the `Index` method of `ProductController` as
    follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将`ProductController`的`Index`方法的参数更改如下：
- en: '[PRE34]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add the following code to the `Index.cshtml` page:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Index.cshtml`页面：
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code makes it possible to move our screen to the next or the
    previous page. Our final screen will look like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使我们能够将屏幕移动到下一页或上一页。我们的最终屏幕将如下所示：
- en: '![](img/d2e1909c-873b-4285-b592-2c69ed0d6667.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2e1909c-873b-4285-b592-2c69ed0d6667.png)'
- en: In this section, we have discussed and extended the features of our FlixOne
    application by implementing `Sorting`, `Paging`, and `Filter`. The aim of this
    section was to give you hands-on experience with a working application. We have
    coded our application in such a way that it will directly meet real-world applications.
    With the preceding enhancement, our application is now capable of giving a product
    listing that can be sorted, paginated, and filtered.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论并扩展了我们的FlixOne应用程序的功能，通过实现`Sorting`，`Paging`和`Filter`。本节的目的是让您亲身体验一个工作中的应用程序。我们已经编写了我们的应用程序，以便它可以直接满足实际应用程序的需求。通过前面的增强，我们的应用程序现在能够提供可以排序、分页和过滤的产品列表。
- en: Patterns and Practices – MVVM
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式和实践-MVVM
- en: In [Chapter 6](8e089021-1efb-4b88-8bf2-e26f69f883b9.xhtml), *Implementing Design
    Patterns for Web Applications - Part 1*, we discussed the **MVC** pattern and
    created an application based on this.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](8e089021-1efb-4b88-8bf2-e26f69f883b9.xhtml)中，*为Web应用程序实现设计模式-第1部分*，我们讨论了MVC模式，并创建了一个基于此模式的应用程序。
- en: Ken Cooper and Ted Peters are the names behind the invention of the MVVM pattern.
    At the time of this invention, both Ken and Ted were architects at the Microsoft
    Corporation. They made this pattern to simplify the UI of event-driven programming.
    Later on, it was implemented in **Windows Presentation Foundation** (**WPF**)
    and **Silverlight**.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 肯·库珀（Ken Cooper）和泰德·彼得斯（Ted Peters）是MVVM模式背后的名字。在这一发明时，肯和泰德都是微软公司的架构师。他们制定了这一模式，以简化基于事件驱动的编程的用户界面。后来，它被实现在Windows
    Presentation Foundation（WPF）和Silverlight中。
- en: The MVVM pattern was announced in 2005 by John Gossman. John has blogged about
    this pattern in context with building WPF applications. The link for this is at [https://blogs.msdn.microsoft.com/johngossman/2005/10/08/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps/](https://blogs.msdn.microsoft.com/johngossman/2005/10/08/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps/).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM模式是由John Gossman于2005年宣布的。John在博客中讨论了这一模式，与构建WPF应用程序有关。链接在这里：[https://blogs.msdn.microsoft.com/johngossman/2005/10/08/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps/](https://blogs.msdn.microsoft.com/johngossman/2005/10/08/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps/)。
- en: MVVM is considered to be one of the variations of MVC to meet the modern **User
    Interface** (**UI**) development approach, where UI development is the core responsibility
    of designer/UI-developers rather than application developers. In this approach
    of development, a designer who is a graphical enthusiast and is focused on making
    a UI more attractive may or may not bother about the development part of the application.
    Generally, designers (UI persons) use various tools to make the UI more attractive.
    The UI can be made with a simple HTML, CSS, and so on, using rich controls of
    WPF or Silverlight.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM被认为是MVC的变体之一，以满足现代用户界面（UI）开发方法，其中UI开发是设计师/UI开发人员的核心责任，而不是应用程序开发人员。在这种开发方法中，一个专注于使UI更具吸引力的图形爱好者的设计师可能会或可能不会关心应用程序的开发部分。通常，设计师（UI人员）使用各种工具来使UI更具吸引力。UI可以使用简单的HTML、CSS等，使用WPF或Silverlight的丰富控件来制作。
- en: '**Microsoft Silverlight** is a framework that helps to develop applications
    with a rich UI. Many developers refer to it as an alternative of Flash by Adobe.
    In July 2015, Microsoft announced that it was no longer supporting Silverlight.
    Microsoft announced the support of WPF in .NET Core 3.0 during its build ([https://developer.microsoft.com/en-us/events/build](https://developer.microsoft.com/en-us/events/build)).
    There is also a blog with more insight into the plan to support WPF found here:
    [https://devblogs.microsoft.com/dotnet/net-core-3-and-support-for-windows-desktop-applications/](https://devblogs.microsoft.com/dotnet/net-core-3-and-support-for-windows-desktop-applications/).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Silverlight是一个帮助开发具有丰富用户界面的应用程序的框架。许多开发人员将其称为Adobe Flash的替代品。2015年7月，微软宣布不再支持Silverlight。微软宣布在其构建期间支持.NET
    Core 3.0中的WPF（[https://developer.microsoft.com/en-us/events/build](https://developer.microsoft.com/en-us/events/build)）。这里还有一个关于支持WPF计划更多见解的博客：[https://devblogs.microsoft.com/dotnet/net-core-3-and-support-for-windows-desktop-applications/](https://devblogs.microsoft.com/dotnet/net-core-3-and-support-for-windows-desktop-applications/)。
- en: 'The MVVM pattern can be elaborated with its various components as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM模式可以通过其各个组件进行详细说明，如下所示：
- en: '**Model**: Holds data and does not care about any business logic in the application.
    I prefer to refer to this as a domain object because it holds the actual data
    of the application we are working with. In other words, we can say that a model
    is not responsible for making the data beautiful. For example, in a product model
    of our FlixOne application, a product model holds the value of various properties,
    and these describe a product by its name, description, category name, price, and
    more. These properties contain the actual data of the product, but the model is
    not responsible for making behavioral changes to any of the data. For example,
    it''s not the responsibility of our product mode to format the product description
    to look perfect on the UI. On the other hand, many of our models contain validations
    and other computed properties. The main challenge is to maintain the pure and
    cleaned model, which means that the model should resemble the real-world model.
    In our case, our `product` model is called a **clean model**. A clean model is
    one that resembles the actual properties of real products. For example, if the `Product`
    model is storing the data of fruits, then it should show properties such as the
    color of fruits and so on. The following code is from a model of our imaginary
    application:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Model**：保存数据，不关心应用程序中的任何业务逻辑。我更喜欢将其称为领域对象，因为它保存了我们正在处理的应用程序的实际数据。换句话说，我们可以说模型不负责使数据变得美观。例如，在我们的FlixOne应用程序的产品模型中，产品模型保存各种属性的值，并通过名称、描述、类别名称、价格等描述产品。这些属性包含产品的实际数据，但模型不负责对任何数据进行行为更改。例如，产品模型不负责将产品描述格式化为在UI上看起来完美。另一方面，我们的许多模型包含验证和其他计算属性。主要挑战是保持纯净的模型，这意味着模型应该类似于真实世界的模型。在我们的情况下，我们的`product`模型被称为**clean
    model**。干净的模型是类似于真实产品属性的模型。例如，如果`Product`模型存储水果的数据，那么它应该显示水果的颜色等属性。以下代码来自我们虚构应用程序的一个模型：'
- en: '[PRE36]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that the preceding code is written in Angular. We will discuss Angular
    code in detail in the upcoming section, *Implementing MVVM*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述代码是用Angular编写的。我们将在接下来的*实现MVVM*部分详细讨论Angular代码。
- en: '**View**: This is a data representation for the end user to access via the
    UI. This simply displays the value of the data, and this value may or may not
    be formatted. For example, we can show the discount rate as 18% on the UI, while
    it would be stored as 18.00 in the model. The view can also responsible for behavioral
    changes. The view accepts user inputs; for example, there would be a view that
    provides a form/screen to add a new product. Also, the view can manage the user
    input such as the key pressed, detecting a keyword, and more. It could also be
    an active view or a passive view. The view that accepts the user input and manipulates
    the data model (properties) according to the user input is an active view. A passive
    view is one that does nothing. In other words, a view that is not associated with
    the model is a passive view, and this kind of view is manipulated by a controller.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**View**：这是最终用户通过UI访问的数据表示。它只是显示数据的值，这个值可能已经格式化，也可能没有。例如，我们可以在UI上显示折扣率为18%，而在模型中它可能存储为18.00。视图还可以负责行为变化。视图接受用户输入；例如，可能会有一个提供添加新产品的表单/屏幕的视图。此外，视图可以管理用户输入，比如按键、检测关键字等。它也可以是主动视图或被动视图。接受用户输入并根据用户输入操纵数据模型（属性）的视图是主动视图。被动视图是什么都不做的视图。换句话说，与模型无关的视图是被动视图，这种视图由控制器操纵。'
- en: '**ViewModel**: This works as a middleman between View and Model. Its responsibility
    is to make the presentation better. In our previous example, where View shows
    the discount rate as 18% but Model has a discount rate of 18.00, it is the responsibility
    of View Model to format 18.00 to 18% so that View can display the formatted discount
    rate.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ViewModel**：它在View和Model之间充当中间人。它的责任是使呈现更好。在我们之前的例子中，View显示折扣率为18%，但Model的折扣率为18.00，这是ViewModel的责任，将18.00格式化为18%，以便View可以显示格式化的折扣率。'
- en: 'If we combine all the points discussed, we can visualize the entire MVVM pattern,
    which would look like the following diagram:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们结合讨论的所有要点，我们可以将整个MVVM模式可视化，看起来像下面的图表：
- en: '![](img/61f3a6af-ade5-4d96-88d1-4d959db0bc1c.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61f3a6af-ade5-4d96-88d1-4d959db0bc1c.png)'
- en: The preceding diagram is a pictorial view of MVVM, and it shows us that **View
    Model** separates **View** and **Model**. **ViewModel** also maintains the `state`
    and `perform` operations. This helps **View** to present the final output to the
    end user. The view is UI, which gets data and presents it to the end user. In
    the next section, we will implement the MVVM pattern using Angular.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表是MVVM的图形视图，它向我们展示了**View Model**如何将**View**和**Model**分开。**ViewModel**还维护`state`和`perform`操作。这有助于**View**向最终用户呈现最终输出。视图是UI，它获取数据并将其呈现给最终用户。在下一节中，我们将使用Angular实现MVVM模式。
- en: Implementation of MVVM
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVVM的实现
- en: In the previous section, we understood what the MVVM pattern is and how it works.
    In this section, we will use our FlixOne application and build an application
    using Angular. To demonstrate the MVVM pattern, we will use the API built on ASP.NET
    Core 2.2.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解了MVVM模式是什么以及它是如何工作的。在本节中，我们将使用我们的FlixOne应用程序并使用Angular构建一个应用程序。为了演示MVVM模式，我们将使用基于ASP.NET
    Core 2.2构建的API。
- en: 'Start Visual Studio and open FlixOne Solution from the `FlixOneMVVM` folder.
    Run the `FlixOne.API` project where you will see the following Swagger documentation
    page:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Visual Studio并打开`FlixOneMVVM`文件夹中的FlixOne Solution。运行`FlixOne.API`项目，您将看到以下Swagger文档页面：
- en: '![](img/9cc95489-4408-41f9-81a0-393b2ae85317.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9cc95489-4408-41f9-81a0-393b2ae85317.png)'
- en: 'The preceding screenshot is the snapshot of our Product APIs documentation,
    where we have incorporated Swagger for the API documentation. If you want to,
    you can test the API from this screen. If the APIs are returning results, then
    your project is successfully set up. If not, please check the prerequisites for
    this project, and also check the `README.md` file from the Git repository for
    this chapter. We have everything that is required to build a new UI; as discussed
    previously, we will create an Angular application that will consume our Product
    APIs. To get started, follow these steps:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图是我们的产品API文档的快照，我们已经整合了Swagger来进行API文档编制。如果您愿意，您可以从此屏幕测试API。如果API返回结果，则您的项目已成功设置。如果没有，请检查此项目的先决条件，并检查本章的Git存储库中的`README.md`文件。我们拥有构建新UI所需的一切；正如之前讨论的，我们将创建一个Angular应用程序，该应用程序将使用我们的产品API。要开始，请按照以下步骤进行：
- en: Open the Solution Explorer.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开解决方案资源管理器。
- en: Right-click on FlixOne Solution.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击FlixOne Solution。
- en: Click on Add New Project.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击添加新项目。
- en: 'From the Add New Project window, select ASP.NET Core Web Application. Call
    it FlixOne.Web and click OK. After doing so, refer to this screenshot:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`添加新项目`窗口中，选择ASP.NET Core Web应用程序。将其命名为FlixOne.Web，然后单击确定。这样做后，请参考此截图：
- en: '![](img/e9f81475-6de0-46c7-bfe0-fb72a917416f.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9f81475-6de0-46c7-bfe0-fb72a917416f.png)'
- en: 'From the next window, select Angular, make sure you have selected ASP.NET Core
    2.2, click OK, and refer to this screenshot:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下一个窗口中，选择Angular，确保您已选择了ASP.NET Core 2.2，然后单击确定，并参考此截图：
- en: '![](img/798ace74-dc36-45d9-aebd-c958464837c1.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/798ace74-dc36-45d9-aebd-c958464837c1.png)'
- en: 'Open Solution Explorer and you will find the new `FlixOne.Web` project and
    folder hierarchy, which looks like this:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开解决方案资源管理器，您将找到新的`FlixOne.Web`项目和文件夹层次结构，看起来像这样：
- en: '![](img/afcc2e76-f48c-4abf-910f-9e7382731283.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/afcc2e76-f48c-4abf-910f-9e7382731283.png)'
- en: 'From the Solution Explorer, right-click on the FlixOne.Web project, and click
    on the Set as Startup project, and then refer to the following screenshot:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中，右键单击`FlixOne.Web`项目，然后单击`设置为启动项目`，然后参考以下截图：
- en: '![](img/a4bac5f7-1e4f-447a-bd53-ee09dcf3a150.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4bac5f7-1e4f-447a-bd53-ee09dcf3a150.png)'
- en: 'Run the `FlixOne.Web` project and see the output, which will look like the
    following screenshot:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`FlixOne.Web`项目并查看输出，将看起来像以下截图：
- en: '![](img/f4643910-9a24-4f31-9102-f27f812cacf8.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4643910-9a24-4f31-9102-f27f812cacf8.png)'
- en: 'We have set up our Angular app successfully. Go back to your Visual Studio
    and open the Output window. Refer to the following screenshot:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功设置了我们的Angular应用程序。返回到您的Visual Studio并打开`输出`窗口。请参考以下截图：
- en: '![](img/5f215bcf-3786-4f4d-95aa-1737550c1192.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f215bcf-3786-4f4d-95aa-1737550c1192.png)'
- en: 'You will find `ng serve "--port" "60672"` from the Output window; this is a
    command that tells the Angular app to listen and serve. Open the `package.json`
    file from `Solution Explorer`; this file belongs to the `ClientApp` folder. You
    will notice `"@angular/core": "6.1.10"`, which means our application is built
    on `angular6`.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '您将在输出窗口中找到`ng serve "--port" "60672"`；这是一个命令，告诉Angular应用程序监听和提供服务。从`解决方案资源管理器`中打开`package.json`文件；这个文件属于`ClientApp`文件夹。您会注意到`"@angular/core":
    "6.1.10"`，这意味着我们的应用是基于`angular6`构建的。'
- en: 'The following is the code of our `product.component.html` (this is a view):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的`product.component.html`的代码（这是一个视图）：
- en: '[PRE37]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run the application from Visual Studio, and click on Product, where you will
    get a Product Listing screen similar to this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 从Visual Studio运行应用程序，并单击产品，您将获得一个类似于此的产品列表屏幕：
- en: '![](img/d2388694-3340-4811-bf69-d26781422dfa.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2388694-3340-4811-bf69-d26781422dfa.png)'
- en: In this section, we have created a small demo application in Angular.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们在Angular中创建了一个小型演示应用程序。
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The aim of this chapter was to get you through the reactive programming by discussing
    its principles and the reactive programming model. Reactive is all about the data
    stream, which we have discussed with examples. We extended our example from [Chapter
    8](ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml), *Concurrent Programming in .NET
    Core*, where we discussed the use case of the ticket collection counter at a conference.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是通过讨论其原则和反应式编程模型来使您了解反应式编程。反应式是关于数据流的，我们通过示例进行了讨论。我们从[第8章](ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml)扩展了我们的示例，*在.NET
    Core中进行并发编程*，在那里我们讨论了会议上的票务收集柜台的用例。
- en: We explored the reactive system during our discussion of the reactive manifesto.
    We discussed the reactive system through the help of showcasing the `merge`, `filter`,
    and `map` operations, and how streams work with the help of examples. Also, we
    discussed the `IObservable` interface and the Rx extensions, using examples.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论反应式宣言时，我们探讨了反应式系统。我们通过展示`merge`、`filter`和`map`操作以及流如何通过示例工作来讨论了反应式系统。此外，我们使用示例讨论了`IObservable`接口和Rx扩展。
- en: We carried forward our `FlixOne` inventory application and discussed the use
    cases to implement the paging and the sorting of inventory data for products.
    Finally, we discussed the MVVM pattern and created a small application on a MVVM
    architecture.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续进行了`FlixOne`库存应用程序，并讨论了实现产品库存数据的分页和排序的用例。最后，我们讨论了MVVM模式，并在MVVM架构上创建了一个小应用程序。
- en: In the next chapter ([Chapter 11](1dd82c08-3988-4c19-aa44-4bc2fd3277a9.xhtml),
    *Advanced Database Design and Application Techniques*), advanced database and
    application techniques will be explored, including applying **Command Query Responsibility
    Segregation** (**CQRS**) and a ledger-style database.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章（[第11章](1dd82c08-3988-4c19-aa44-4bc2fd3277a9.xhtml)，*高级数据库设计和应用技术*）中，将探讨高级数据库和应用技术，包括应用**命令查询职责分离**（**CQRS**）和分类账式数据库。
- en: Questions
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将帮助您巩固本章中包含的信息：
- en: What is a stream?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是流？
- en: What are reactive properties?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是反应式属性？
- en: What is a reactive system?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是反应式系统？
- en: What is meant by merging two reactive streams?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是合并两个反应式流？
- en: What is the MVVM pattern?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是MVVM模式？
- en: Further reading
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics covered in this chapter, refer to the following
    book. This book will provide you with various in-depth and hands-on exercises
    for reactive programming:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解本章涵盖的主题，请参考以下书籍。本书将为您提供各种深入和实践性的响应式编程练习：
- en: '*Reactive Programming for .NET Developer*s, *Antonio Esposito* and *Michael
    Ciceri*, Packt Publishing: [https://www.packtpub.com/web-development/reactive-programming-net-developers](https://www.packtpub.com/web-development/reactive-programming-net-developers)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《.NET开发人员的响应式编程》，Antonio Esposito和Michael Ciceri，Packt Publishing：[https://www.packtpub.com/web-development/reactive-programming-net-developers](https://www.packtpub.com/web-development/reactive-programming-net-developers)
