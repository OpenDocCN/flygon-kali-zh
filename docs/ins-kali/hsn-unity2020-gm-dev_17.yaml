- en: '*Chapter 17*: Scripting the UI, Sounds, and Graphics'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第17章*：UI、声音和图形脚本'
- en: In a game, even if the player sees the game through the camera, there is important
    information that is not visible in plain sight, such as the exact number of remaining
    bullets, their health, the enemies, whether there's an enemy behind them, and
    so on. We have already discussed how to tackle those issues with the UI, sounds,
    and **visual effects** (**VFX**), but as we start to move on with scripting in
    our game, those elements also need to adapt to the game. The idea of this chapter
    is to make our UI, sounds, and VFX react to the game situation through scripting,
    reflecting what is happening in the world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，即使玩家通过摄像机看到游戏，也有一些重要信息是肉眼不可见的，比如剩余子弹的确切数量、他们的生命、敌人、是否有敌人在他们身后等等。我们已经讨论过如何通过UI、声音和视觉效果（VFX）来解决这些问题，但随着我们在游戏中开始进行脚本编写，这些元素也需要适应游戏。本章的理念是通过脚本使我们的UI、声音和VFX对游戏情况做出反应，反映世界上正在发生的事情。
- en: 'In this chapter, we will examine the following feedback scripting concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下反馈脚本概念：
- en: Scripting the UI
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI脚本
- en: Scripting feedback
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本反馈
- en: By the end of this chapter, you will be able to make the UI react to the game
    situation, showing relevant information in form of text and bars, and also be
    able to make the game react to interactions with the UI, such as with buttons.
    Also, you will be able to make the game inform the user of this information through
    other mediums, such as sound and particle graphics, which can be as effective
    as the UI, but more appealing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够使UI对游戏情况做出反应，以文本和条形图的形式显示相关信息，并且还能够使游戏对与UI的交互做出反应，比如按钮。此外，您还将能够使游戏通过其他媒介向用户传达这些信息，比如声音和粒子图形，这些可以和UI一样有效，但更具吸引力。
- en: Scripting the UI
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI脚本
- en: 'We previously created a UI layout with elements such as bars, text, and buttons,
    but so far, they are static. We need to make them adapt to the game''s actual
    state. In this chapter, we are going to discuss the following UI scripting concepts:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建了一个包含条形、文本和按钮等元素的UI布局，但到目前为止，它们都是静态的。我们需要使它们适应游戏的实际状态。在本章中，我们将讨论以下UI脚本概念：
- en: Showing information in the UI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在UI中显示信息
- en: Programming the Pause menu
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写暂停菜单的程序
- en: We will start by seeing how to display information on our UI using scripts that
    modify the text and images that are displayed with Canvas elements. After that,
    we will create the Pause functionality, which will be used throughout the UI.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看看如何使用脚本在我们的UI上显示信息，这些脚本修改了与Canvas元素一起显示的文本和图像。之后，我们将创建暂停功能，该功能将在整个UI中使用。
- en: Showing information in the UI
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在UI中显示信息
- en: 'As discussed earlier, we will use the UI to display information to the user
    to allow them to make informed decisions, so let''s start by seeing how we can
    make the player''s health bar react to the amount of life they have left in the
    `Life` script we created earlier:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用UI向用户显示信息，以便他们做出明智的决定，因此让我们从看看如何使玩家的生命条对我们之前创建的`Life`脚本中剩余的生命做出反应开始：
- en: Add a new script called `Image` component we created earlier to represent the
    life bar:![Figure 17.1 – The Life Bar component in the player's HealthBar Canvas
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Image`的新脚本，用于表示生命条：![图17.1 – 玩家HealthBar画布中的生命条组件
- en: '](img/Figure_17.01_B14199.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.01_B14199.jpg)'
- en: Figure 17.1 – The Life Bar component in the player's HealthBar Canvas
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1 – 玩家HealthBar画布中的生命条组件
- en: In the `Life` `Bar`, script adds a `Life` type field. This way, our script will
    ask the editor which `Life` component we will be monitoring. Save the script:![Figure
    17.2 – Editor-configurable reference to a Life component
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Life` `Bar`脚本中添加一个`Life`类型字段。这样，我们的脚本将询问编辑器我们将监视哪个`Life`组件。保存脚本：![图17.2 –
    可在编辑器中配置的对生命组件的引用
- en: '](img/Figure_17.02_B14199.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.02_B14199.jpg)'
- en: Figure 17.2 – Editor-configurable reference to a Life component
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2 – 可在编辑器中配置的对生命组件的引用
- en: In the Editor, drag the `Player` GameObject from the `targetlife` property to
    make the life bar reference the player's life, and remember to have the `HealthBar`
    object selected before dragging `LifeBar` script which `Life` component to check
    to see how much life the player has remaining. Something interesting here is that
    the enemies have the same `Life` component, so we can easily use this component
    to create life bars for every other object that has lives in our game:![Figure
    17.3 – DraggingPlayer to reference its life component
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，将`Player`游戏对象从`targetlife`属性拖动到生命条引用玩家的`Life`组件，并记得在拖动`LifeBar`脚本之前选择`HealthBar`对象，以检查玩家剩余的生命。有趣的是，敌人也有相同的`Life`组件，所以我们可以轻松地使用这个组件为游戏中具有生命的其他对象创建生命条：![图17.3
    – 拖动Player以引用其生命组件
- en: '](img/Figure_17.03_B14199.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.03_B14199.jpg)'
- en: Figure 17.3 – DraggingPlayer to reference its life component
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.3 – 拖动Player以引用其生命组件
- en: Add the `using UnityEngine.UI;` line right after the `using` statements in the
    first few lines of the script. This will tell C# that we will be interacting with
    the UI scripts:![Figure 17.4 – All the using statements in our script. We are
    not going
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本的前几行的`using`语句之后添加`using UnityEngine.UI;`行。这将告诉C#我们将与UI脚本进行交互：![图17.4 – 我们脚本中的所有using语句。我们现在不会使用它们，但让我们暂时保留它们
- en: to use them all but let's keep them for now
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不使用它们，但让我们暂时保留它们
- en: '](img/Figure_17.04_B14199.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.04_B14199.jpg)'
- en: Figure 17.4 – All the using statements in our script. We are not going to use
    them all but let's keep them for now
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.4 – 我们脚本中的所有using语句。我们现在不会使用它们，但让我们暂时保留它们
- en: Create a `private` field (without the `public` keyword) of the `Image` type.
    We will save the reference to the component here in a moment:![Figure 17.5 – Private
    reference to an image
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`private`字段（不带`public`关键字），类型为`Image`。我们将在这里保存对组件的引用：![图17.5 – 对图像的私有引用
- en: '](img/Figure_17.05_B14199.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.05_B14199.jpg)'
- en: Figure 17.5 – Private reference to an image
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.5 – 对图像的私有引用
- en: Using `GetComponent` in `Awake`, access the reference to the `Image` component
    in our GameObject (`HealthBar`) and save it in the `image` field. As usual, the
    idea is to get this reference just once and save it for later use in the `Update`
    function. Of course, this will always work when you put this component in an object
    with an `Image` component. If not, the other option would be to create a public
    field of the `Image` type and drag the image component into it:![Figure 17.6 –
    Saving the reference to the Image component in this object
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Awake`中使用`GetComponent`，访问我们游戏对象（`HealthBar`）中`Image`组件的引用，并将其保存在`image`字段中。通常情况下，想法是只获取一次这个引用，并在`Update`函数中保存以供以后使用。当然，当你将这个组件放在一个带有`Image`组件的对象中时，这将总是有效。如果不是的话，另一个选择就是创建一个`Image`类型的公共字段，并将图像组件拖放到其中：![图17.6
    – 在此对象中保存对Image组件的引用
- en: '](img/Figure_17.06_B14199.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.06_B14199.jpg)'
- en: Figure 17.6 – Saving the reference to the Image component in this object
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.6 – 在此对象中保存对Image组件的引用
- en: Create an `Update` event function in the `LifeBar` script. We will use this
    to constantly update the life bar according to the player's life.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LifeBar`脚本中创建一个`Update`事件函数。我们将使用这个函数来根据玩家的生命不断更新生命条。
- en: In the `Update` event, divide the amount of life by `100` to have our current
    life percentage expressed in the `0` to `1` range (assuming our maximum life is
    `100`), and set the result in the `fillAmount` field of the `Image` component
    as in the following screenshot. Remember that `fillAmount` expects a value between
    `0` and `1`, with `0` signalling that the bar is empty and `1` that the bar is
    its full capacity:![Figure 17.7 – Updating the fill amount of the LifeBar script's
    Image component according to the Life component
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update`事件中，将生命值除以`100`，以便在`0`到`1`范围内表示我们当前的生命百分比（假设我们的最大生命是`100`），并将结果设置在`Image`组件的`fillAmount`字段中，如下面的截图所示。请记住，`fillAmount`期望一个在`0`到`1`之间的值，`0`表示条是空的，`1`表示条是满的：![图17.7
    – 根据Life组件更新LifeBar脚本的Image组件的填充量
- en: '](img/Figure_17.07_B14199.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.07_B14199.jpg)'
- en: Figure 17.7 – Updating the fill amount of the LifeBar script's Image component
    according to the Life component
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.7 – 根据Life组件更新LifeBar脚本的Image组件的填充量
- en: 'Important note:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Remember that putting `100` within the code is considered hardcoding (it is
    also known as a magic number), meaning later changes on that value would require
    us to look through the code for that value, which is a complicated task in big
    projects. That's why it is considered bad practice. It would be better to have
    a `Maximum Life` field in the `Life` component or at least have a constant with
    this value.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在代码中放入`100`被认为是硬编码（也被称为魔术数字），这意味着以后更改该值需要我们在代码中查找该值，这在大型项目中是一项复杂的任务。这就是为什么它被认为是不好的实践。最好在`Life`组件中有一个`Maximum
    Life`字段，或者至少有一个包含这个值的常量。
- en: 'Save the script and in the Editor, select the player and play the game. During
    **Play** mode, press *Esc* to regain access to the mouse and change the player''s
    health in the Inspector window to see how the life bar updates accordingly. You
    can also test this by making the player receive damage somehow, such as by making
    enemies spawn bullets (more on enemies later):'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本，并在编辑器中选择玩家并开始游戏。在**播放**模式下，按下*Esc*键以重新获得鼠标访问权限，并在检查器窗口中更改玩家的生命值，以查看生命条如何相应更新。你也可以通过让玩家受到伤害来测试这一点，比如让敌人生成子弹（稍后会详细介绍敌人）：
- en: '![Figure 17.8 – Full LifeBar script'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.8 – 完整的LifeBar脚本'
- en: '](img/Figure_17.08_B14199.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.08_B14199.jpg)'
- en: Figure 17.8 – Full LifeBar script
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.8 – 完整的LifeBar脚本
- en: 'Important note:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: In the previous chapter, we explored the concept of events to detect changes
    in the state of other objects. The life bar is another example of using an event
    as we can change the fill amount of the image when the life actually changes.
    I challenge you to try to create an event when the life changes and implement
    this script using the one we looked at in the previous chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了事件的概念，以便检测其他对象状态的变化。生命条是另一个使用事件的例子，因为我们可以在生命实际改变时改变图像的填充量。我向你挑战，尝试创建一个生命改变时触发事件，并使用我们在上一章中看到的脚本来实现这个脚本。
- en: You may be thinking that this UI behavior could be directly coded within the
    `Life` component, and that's completely possible, but the idea here is to create
    simple scripts with little pressure to keep our code separated. Each script should
    have just one reason to be modified, and mixing UI behavior and gameplay behavior
    in a single script would give the script two responsibilities, which results in
    two possible reasons to change our script. With this approach, we can also set
    the player's base life bar at the bottom by just adding the same script to its
    life bar but dragging the **Base Damage** object, which we created in the previous
    chapter, as the target life this time.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这个UI行为可以直接编码在`Life`组件中，这是完全可能的，但这里的想法是创建简单的脚本，减少对我们代码的压力。每个脚本应该只有一个修改的原因，将UI行为和游戏行为混合在一个脚本中会使脚本具有两个责任，这将导致脚本有两个可能的修改原因。通过这种方法，我们还可以通过将相同的脚本添加到其生命条中并将我们在上一章中创建的**基础伤害**对象拖放为目标生命，来设置玩家的基础生命条。
- en: 'Important note:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: The single object responsibility principle we just mentioned is one of the five
    object-oriented programming principles known as SOLID. If you don't know what
    SOLID is, I strongly recommend you look it up to improve your programming best
    practices.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚提到的单一对象责任原则是作为SOLID的五个面向对象编程原则之一。如果你不知道SOLID是什么，我强烈建议你查一下，以改进你的编程最佳实践。
- en: 'Now that we have sorted out the player''s life bar, let''s make the `Bullets`
    label update according to the player''s remaining bullets. Something to consider
    here is that our current Player Shooting script has unlimited bullets, so let''s
    change that by following these steps:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了玩家的生命条，让我们根据玩家剩余的子弹数量更新`Bullets`标签。这里需要考虑的是，我们当前的玩家射击脚本有无限的子弹，所以让我们通过以下步骤来改变这一点：
- en: Add a public `int` type field to the Player Shooting script called `bulletsAmount`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Player Shooting脚本中添加一个名为`bulletsAmount`的公共`int`类型字段。
- en: In the `if` statement that checks the pressure of the left mouse button, add
    a condition to check whether the amount of bullets is greater than `0`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查左鼠标按钮的压力的`if`语句中，添加一个条件来检查子弹数量是否大于`0`。
- en: Inside the `if` statement, reduce the number of bullets by `1`:![Figure 17.9
    – Limiting the number of bullets to shoot
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`if`语句中，减少子弹数量`1`：![图17.9 - 限制射击的子弹数量
- en: '](img/Figure_17.09_B14199.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.09_B14199.jpg)'
- en: Figure 17.9 – Limiting the number of bullets to shoot
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.9 - 限制射击的子弹数量
- en: 'Now that we have a field indicating the number of remaining bullets, we can
    create a script to display that number in the UI by doing the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个字段指示剩余子弹的数量，我们可以创建一个脚本来显示该数字在UI中，方法如下：
- en: Add a `PlayerBulletsUI` script to the bullet's `Text` GameObject. In my case,
    I called it `Bullets Label`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`PlayerBulletsUI`脚本添加到子弹的`Text`游戏对象中。在我的案例中，我将其称为`Bullets Label`。
- en: Add the `using UnityEngine.UI` statement and add a private field of the `Text`
    type, saving it in the reference to our own `Text` component in `Awake`:![Figure
    17.10 – Caching the reference to our own Text component
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`using UnityEngine.UI`语句，并在`Awake`中添加一个`Text`类型的私有字段，将其保存在我们自己的`Text`组件的引用中：![图17.10
    - 缓存对我们自己的文本组件的引用
- en: '](img/Figure_17.10_B14199.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.10_B14199.jpg)'
- en: Figure 17.10 – Caching the reference to our own Text component
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.10 - 缓存对我们自己的文本组件的引用
- en: Create a `public` field of the `PlayerShooting` type called `targetShooting`
    and drag `Player` to this property in the Editor. As was the case for the life
    bar component, the idea is that our UI script will access the script that has
    the remaining bullets to update the text, bridging the two scripts (`Text` and
    `PlayerShooting`) to keep their responsibilities separated.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`targetShooting`的`PlayerShooting`类型的公共字段，并将`Player`拖放到编辑器中的此属性中。就像生命条组件一样，我们的UI脚本将访问具有剩余子弹的脚本以更新文本，以保持两个脚本（`Text`和`PlayerShooting`）的责任分离。
- en: 'Create an `Update` statement and inside it, set the `text` field of the text
    reference (I know, confusing) with a concatenation of `"Bullets: "` and the `bulletsAmount`
    field of the `targetShooting` reference. This way, we will replace the text of
    the label according to the current amount of bullets:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Update`语句，在其中，使用文本引用的`text`字段（我知道，令人困惑）与`targetShooting`引用的`bulletsAmount`字段的连接来设置它。这样，我们将根据当前的子弹数量替换标签的文本：
- en: '![Figure 17.11 – Updating the bullet''s text label'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.11 - 更新子弹文本标签'
- en: '](img/Figure_17.11_B14199.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.11_B14199.jpg)'
- en: Figure 17.11 – Updating the bullet's text label
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.11 - 更新子弹文本标签
- en: 'Important note:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Remember that concatenating strings allocates memory, so again, I urge you to
    only do this when necessary using events.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，连接字符串会分配内存，所以我再次敦促您只在必要时使用事件来做这件事。
- en: 'If you look at the two scripts, you will find a pattern. You can access the
    `UI` and `Gameplay` components and update the UI component accordingly, and most
    UI scripts will behave in the same way. Keeping this in mind, I challenge you
    to create the necessary scripts to make the `using UnityEngine.UI` to use the
    `Text` component. After finishing this, you can compare your solution with the
    one in the following screenshot, starting with `ScoreUI`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看这两个脚本，您会发现一个模式。您可以访问`UI`和`Gameplay`组件，并相应地更新`UI`组件，大多数UI脚本都会以相同的方式运行。牢记这一点，我挑战您创建必要的脚本来使用`using
    UnityEngine.UI`来使用`Text`组件。完成后，您可以将您的解决方案与以下截图中的解决方案进行比较，从`ScoreUI`开始：
- en: '![Figure 17.12 – The ScoreUI script'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.12 - ScoreUI脚本'
- en: '](img/Figure_17.12_B14199.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.12_B14199.jpg)'
- en: Figure 17.12 – The ScoreUI script
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.12 - ScoreUI脚本
- en: 'Also, we need the `WavesUI` component:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要`WavesUI`组件：
- en: '![Figure 17.13 – The WavesUI script'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.13 - WavesUI脚本'
- en: '](img/Figure_17.13_B14199.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.13_B14199.jpg)'
- en: Figure 17.13 – The WavesUI script
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.13 - WavesUI脚本
- en: 'Finally, we need `EnemiesUI`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要`EnemiesUI`：
- en: '![Figure 17.14 – The EnemiesUI script'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.14 - EnemiesUI脚本'
- en: '](img/Figure_17.14_B14199.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.14_B14199.jpg)'
- en: Figure 17.14 – The EnemiesUI script
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.14 - EnemiesUI脚本
- en: As you can see, we have used the events already coded in the managers to change
    the UI only when necessary. Now that we have coded the UI labels and bars, let's
    code the `Pause` menu.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们已经使用了管理器中已编码的事件来仅在必要时更改UI。现在我们已经编写了UI标签和条，让我们编写`Pause`菜单。
- en: Programming the Pause menu
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写暂停菜单
- en: Recall how we created a Pause menu in a previous chapter, but it is currently
    disabled, so let's make it work. First, we need to code `Pause`, which can be
    quite complicated. So again, we will use a simple approach for pausing most behaviors,
    which is stopping the time! Remember that most of our movement scripts use time
    functionality, such as `timeScale`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在上一章中创建了一个暂停菜单，但它目前被禁用了，所以让我们让它工作起来。首先，我们需要编写`Pause`，这可能会相当复杂。因此，我们将再次使用一个简单的方法来暂停大多数行为，即停止时间！请记住，我们的大多数移动脚本都使用时间功能，比如`timeScale`。
- en: 'This field will affect Unity''s time system''s speed, and we can set it to
    `0` to simulate that time has stopped, which will pause animations, stop particles,
    and reduce `0`, making our movements stop. So, let''s do it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字段将影响Unity的时间系统的速度，我们可以将其设置为`0`来模拟时间已经停止，这将暂停动画，停止粒子，并减少`0`，使我们的移动停止。所以，让我们来做吧：
- en: Create a script called `Pause` and add it to a new object in the scene, also
    called `Pause`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Pause`的脚本，并将其添加到场景中的一个新对象中，也称为`Pause`。
- en: In `Update`, detect when the *Esc* key is pressed, and in that scenario, set
    `Time.timeScale` to `0`:![Figure 17.15 – Stopping time to simulate a pause
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update`中，检测当按下*Esc*键时，然后在这种情况下，将`Time.timeScale`设置为`0`：![图17.15 - 停止时间以模拟暂停
- en: '](img/Figure_17.15_B14199.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.15_B14199.jpg)'
- en: Figure 17.15 – Stopping time to simulate a pause
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.15 - 停止时间以模拟暂停
- en: Save and test this.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并测试这个。
- en: 'You will notice that almost everything will stop, but you can see how the shoot
    functionality still works. That''s because the Player Shooting script is not time-dependent.
    One solution here could be to simply check whether `Time.timeScale` is greater
    than `0` to prevent this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到几乎所有东西都会停止，但您可以看到射击功能仍在工作。这是因为玩家射击脚本不依赖于时间。这里的一个解决方案可能是简单地检查`Time.timeScale`是否大于`0`以防止这种情况发生：
- en: '![Figure 17.16 – Checking pause in the PSlayer Shooting script'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.16 - 在PSlayer射击脚本中检查暂停'
- en: '](img/Figure_17.16_B14199.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.16_B14199.jpg)'
- en: Figure 17.16 – Checking pause in the PSlayer Shooting script
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.16 - 在PSlayer射击脚本中检查暂停
- en: 'Important note:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: As usual, we have pursued the simplest way here, but there is a better approach.
    I challenge you to try to create `PauseManager` with a Boolean indicating whether
    the game is paused or not, changing `timeScale` in the process.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们在这里追求了最简单的方法，但有更好的方法。我挑战您尝试创建`PauseManager`，其中包含一个布尔值，指示游戏是否暂停，从而改变`timeScale`。
- en: 'Now that we have a simple but effective way to pause the game, let''s make
    the **Pause** menu visible to unpause the game by doing the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个简单但有效的暂停游戏的方法，让我们通过以下方式使**暂停**菜单可见以取消暂停游戏：
- en: Add a field of the `GameObject` type called `pauseMenu` in the `Pause` script.
    The idea is to drag the **Pause** menu here so that we have a reference to enable
    and disable it.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Pause`脚本中添加一个名为`pauseMenu`的`GameObject`类型字段。想法是将**暂停**菜单拖放到这里，以便我们有一个启用和禁用它的引用。
- en: In `Awake`, add `pauseMenu.SetActive(false);` to disable the **Pause** menu
    at the beginning of the game. Even if we disabled the **Pause** menu in the editor,
    we add this just in case we re-enable it by mistake. It must always start disabled.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Awake`中，添加`pauseMenu.SetActive(false);`以在游戏开始时禁用**暂停**菜单。即使我们在编辑器中禁用了**暂停**菜单，我们也添加了这个以防我们错误地重新启用它。它必须始终处于禁用状态。
- en: 'Using the same function but passing `true` as the first parameter, enable the
    `UnityEvents` and the `Button` script. Our `OnClick` event, which is an event
    that informs us that a specific button has been pressed. Let''s resume the game
    when pressing those buttons by doing the following:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的函数，但将`true`作为第一个参数传递，启用`UnityEvents`和`Button`脚本。我们的`OnClick`事件，这是一个通知我们特定按钮已被按下的事件。按下这些按钮时让游戏恢复，做如下操作：
- en: Create a field of the `Button` type in our `Pause` script called `resumeButton`,
    and drag `resumeButton` to it; this way, our `Pause` script has a reference to
    the button.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`Pause`脚本中创建一个`Button`类型的字段，名为`resumeButton`，并将`resumeButton`拖放到其中；这样，我们的`Pause`脚本就有了对按钮的引用。
- en: In `Awake`, add a listener function called `OnResumePressed` to the `onClick`
    event of `resumeButton`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Awake`中，为`resumeButton`的`onClick`事件添加名为`OnResumePressed`的监听函数。
- en: 'Make the `OnResumePressed` function set `timeScale` to `1` and disable the
    `Awake`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使`OnResumePressed`函数将`timeScale`设置为`1`并禁用`Awake`：
- en: '![Figure 17.18 – Unpausing the game'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.18 - 取消暂停游戏'
- en: '](img/Figure_17.18_B14199.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.18_B14199.jpg)'
- en: Figure 17.18 – Unpausing the game
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.18 - 取消暂停游戏
- en: 'If you save and test this, you will notice that you cannot click the `Pause`
    and disable it when you resume:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您保存并测试此代码，您会注意到当您恢复时无法单击“暂停”并禁用它：
- en: '![Figure 17.19 – Showing and hiding the cursor while in Pause'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.19 - 在暂停时显示和隐藏光标'
- en: '](img/Figure_17.19_B14199.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.19_B14199.jpg)'
- en: Figure 17.19 – Showing and hiding the cursor while in Pause
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.19 - 在暂停时显示和隐藏光标
- en: 'Now that you know how to code buttons, I challenge you to code the `Exit` button''s
    behavior. Again, remember to add `using UnityEngine.UI`. Also, you will need to
    call `Application.Quit();` to exit the game, but take into account that this will
    do nothing in the Editor; we don''t want to close the Editor while creating the
    game. This function only works when you build the game. So for now, just call
    it and if you want to print a message to be sure that the button is working properly,
    a solution is provided in the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何编写按钮，我挑战您编写“退出”按钮的行为。同样，记得添加`using UnityEngine.UI`。此外，您需要调用`Application.Quit();`来退出游戏，但请注意这在编辑器中不起作用；我们不希望在创建游戏时关闭编辑器。此函数仅在构建游戏时起作用。因此，现在只需调用它，如果您想要打印一条消息以确保按钮正常工作，解决方案在以下截图中提供：
- en: '![Figure 17.20 – The Quit button script'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.20 - 退出按钮脚本'
- en: '](img/Figure_17.20_B14199.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.20_B14199.jpg)'
- en: Figure 17.20 – The Quit button script
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.20 - 退出按钮脚本
- en: This solution proposes that you add this script directly to the `onClick` event
    on its `Button` sibling component, and in that case, executes the `Quit` function.
    You could also add this behavior to the `Pause` script, and while that will work,
    remember that if a script can be split into two because it does two unrelated
    tasks, it is always best to split it so that separate behavior is unrelated. Here,
    the Pause behavior is not related to the Quit behaviour.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此解决方案建议您直接将此脚本添加到其`Button`兄弟组件的`onClick`事件上，并在这种情况下执行`Quit`函数。您还可以将此行为添加到`Pause`脚本中，虽然这样也可以工作，但请记住，如果一个脚本可以分成两个因为它执行两个不相关的任务，最好将其拆分为两个不相关的行为。在这里，暂停行为与退出行为无关。
- en: Now that we have our Pause system set up using the UI and buttons, let's continue
    looking at other visual and audible ways to make our player aware of what has
    happened.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用UI和按钮设置了暂停系统，让我们继续探讨其他视觉和听觉方式，让玩家意识到发生了什么。
- en: Scripting feedback
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本化反馈
- en: We just used the UI to pass on data to the user so that they know what is happening,
    but sometimes that's not enough. We can reinforce game events using other types
    of feedback, such as sound and explosions, which we integrated in previous chapters.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是使用UI向用户传递数据，以便他们知道发生了什么，但有时这还不够。我们可以使用其他类型的反馈来加强游戏事件，例如声音和爆炸，这些在之前的章节中已经集成了。
- en: 'In this section, we will explore the following feedback concepts:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下反馈概念：
- en: Scripting visual feedback
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本化视觉反馈
- en: Scripting audio feedback
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本化音频反馈
- en: Scripting animations
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本化动画
- en: We will start seeing how to make our gameplay have more feedback, with different
    visuals used in the right moments, such as audio and particle systems. Then, we
    are going to make the animations of our characters match these moments, for example,
    we will create the illusion that they are actually walking.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始看到如何使我们的游戏玩法具有更多的反馈，使用在正确时刻使用的不同视觉效果，比如音频和粒子系统。然后，我们将使我们角色的动画与这些时刻相匹配，例如，我们将创造他们实际上正在行走的幻觉。
- en: Scripting visual feedback
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本化视觉反馈
- en: Visual feedback is the concept of using different VFX, such as particles and
    a VFX Graph, to reinforce what is happening. For example, say right now we are
    shooting and we know that this is happening because we can see the bullet. It
    doesn't exactly feel like shooting as a proper shooting simulation needs our gun
    to show the muzzle flash effect. Another example would be the enemy dying—it just
    despawns! That doesn't feel as satisfying as it should be. We can instead add
    a little explosion (considering they are robots).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉反馈是使用不同的VFX概念，比如粒子和VFX图表，来加强发生的事情。例如，比如现在我们正在射击，我们知道这是发生的，因为我们可以看到子弹。但这并不完全感觉像真正的射击，因为一个合适的射击模拟需要我们的枪显示枪口闪光效果。另一个例子是敌人死亡——它只是消失了！这并不像应该的那样令人满意。我们可以改为添加一点爆炸效果（考虑到它们是机器人）。
- en: 'Let''s start making our enemies spawn an explosion when they die by doing the
    following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使我们的敌人在死亡时生成爆炸，方法如下：
- en: Create an explosion effect or download one from the Asset Store. It shouldn't
    loop and it needs to be destroyed automatically when the explosion is over (ensure
    `destroy` in the main module).
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个爆炸效果或从资产商店下载一个。它不应该循环，并且在爆炸结束时需要自动销毁（确保在主模块中销毁）。
- en: Some explosions in the Asset Store might use non-URP-compatible shaders. You
    can fix them by setting the **Edit** | **Render Pipeline** | **Universal Render
    Pipeline** | **Upgrade Selected Materials** option to **UniversalRP Materials**
    while keeping the materials selected.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资产商店中的一些爆炸可能使用不兼容URP的着色器。您可以通过将“编辑” | “渲染管线” | “通用渲染管线” | “升级所选材料”选项设置为“UniversalRP材料”来修复它们，同时保持所选材料。
- en: Manually upgrade the materials that didn't upgrade automatically.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动升级未自动升级的材料。
- en: Add a script to the `Enemy` prefab called `ExplosionOnDeath`. This will be responsible
    for spawning the particles Prefab when the enemy dies.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Enemy”预制体中添加一个名为“ExplosionOnDeath”的脚本。这将负责在敌人死亡时生成粒子预制体。
- en: Add a field of the `GameObject` type called `particlePrefab` and drag the explosion
    Prefab to it.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为“particlePrefab”的GameObject类型字段，并将爆炸预制体拖放到其中。
- en: 'Important note:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: You may be expecting to add the explosion spawning to the `Life` component.
    In that case, you are assuming that anything to do with life will spawn a particle
    when dying, but consider scenarios where characters die with a falling animation
    instead, or maybe an object that just despawns with no effect whatsoever. If a
    certain behavior is not used in most scenarios, it is better to code it in a separate
    optional script to allow us to mix and match different components and get the
    exact behavior we want.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望将爆炸生成添加到“生命”组件中。在这种情况下，您假设任何与生命有关的东西在死亡时都会生成一个粒子，但请考虑角色以下落动画死亡的情况，或者可能是一个物体在没有任何效果的情况下消失。如果某种行为在大多数情况下都没有使用，最好将其编码为一个单独的可选脚本，以允许我们混合和匹配不同的组件，并获得我们想要的确切行为。
- en: Make the script access the `Life` component and subscribe to its `onDeath` event.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使脚本访问“生命”组件并订阅其“onDeath”事件。
- en: In the `listener` function, spawn the particle system in the same location:![Figure
    17.21 – The explosion spawner script
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“listener”函数中，在相同位置生成粒子系统：![图17.21 – 爆炸生成器脚本
- en: '](img/Figure_17.21_B14199.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.21_B14199.jpg)'
- en: Figure 17.21 – The explosion spawner script
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.21 – 爆炸生成器脚本
- en: As you can see, we are just using the same concepts we learned about in previous
    chapters, but combining them in new ways. This is what programming is all about.
    Let's continue with the muzzle effect, which will also be a particle system, but
    we will take another approach this time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们只是在以前的章节中学到的概念中，以新的方式进行组合。这就是编程的全部内容。让我们继续进行枪口效果，这也将是一个粒子系统，但这次我们将采取另一种方法。
- en: Download a weapon model from the Asset Store and instantiate it so that it is
    the parent of the hand of the player. Remember that our character is rigged and
    has a hand bone, so you should put the weapon there:![Figure 17.22 – Parenting
    a weapon in the hand bone
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从资产商店下载一个武器模型并将其实例化，使其成为玩家手的父级。记住我们的角色是绑定的，并且有一个手骨，所以你应该把武器放在那里：![图17.22 – 将武器放在手骨中
- en: '](img/Figure_17.22_B14199.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.22_B14199.jpg)'
- en: Figure 17.22 – Parenting a weapon in the hand bone
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.22 – 将武器放在手骨中
- en: Create or get a muzzle particle system. In this case, my muzzle particle system
    was created as a short particle system that has a burst of particles and then
    automatically stops. Try to get one with that behavior because there are others
    out there that will loop instead, and the script to handle that scenario would
    be different.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建或获取一个枪口粒子系统。在这种情况下，我的枪口粒子系统是作为一个短粒子系统创建的，它有一阵粒子然后自动停止。尝试获取一个具有这种行为的粒子系统，因为还有其他的粒子系统会循环，处理这种情况的脚本会有所不同。
- en: Create an instance of the particle system Prefab in the Editor and parent it
    inside the weapon, locating it in front of the weapon, aligned with the barrel
    of the gun. Make sure the **Play On Awake** property of the main module of the
    particle system is unchecked; we don't want the muzzle to fire until we press
    the fire key:![Figure 17.23 – The muzzle parented to the weapon
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中创建一个粒子系统预制体的实例，并将其放置在武器内，位于枪管的前方。确保粒子系统的主模块的“自动播放”属性未选中；我们不希望枪口在我们按下开火键之前就发射：![图17.23
    – 枪口与武器相连
- en: '](img/Figure_17.23_B14199.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.23_B14199.jpg)'
- en: Figure 17.23 – The muzzle parented to the weapon
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.23 – 枪口与武器相连
- en: Create a field of the `ParticleSystem` type called `muzzleEffect` in `PlayerShooting`
    and drag the muzzle effect that is parented in the gun to it. Now, we have a reference
    to the `ParticleSystem` component of the muzzle to manage it.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerShooting`中创建`ParticleSystem`类型的字段，命名为`muzzleEffect`，并将父级为枪的枪口效果拖动到其中。现在，我们有了对枪口的`ParticleSystem`组件的引用来管理它。
- en: 'Inside the `if` statement that checks whether we are shooting, execute `muzzleEffect.Play();`
    to play the particle system. It will automatically stop and is short enough to
    finish between key pressures:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查是否正在射击的`if`语句中，执行`muzzleEffect.Play();`以播放粒子系统。它将自动停止，并且足够短，可以在按键压力之间完成：
- en: '![Figure 17.24 – The muzzle parented to the weapon'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.24 - 枪口与武器相连'
- en: '](img/Figure_17.24_B14199.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.24_B14199.jpg)'
- en: Figure 17.24 – The muzzle parented to the weapon
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.24 - 枪口与武器相连
- en: 'Important note:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: 'Here, we again have the same question: Will all the weapons have a muzzle when
    shooting? In this scenario, I would say yes due to the scope of our project, so
    I will keep the code as it is. However, in the future, you can create an `onShoot`
    event if you need other components to know whether this script is shooting. This
    way, you can extend the shooting behavior. Consider using events as a way of enabling
    plugins in your script.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们再次面临同样的问题：所有武器在射击时都会有枪口吗？在这种情况下，由于我们项目的范围，我会说是的，所以我会保持代码不变。但是，在将来，如果您需要其他组件知道此脚本是否在射击，可以创建一个`onShoot`事件。这样，您可以扩展射击行为。考虑使用事件作为启用脚本中的插件的一种方式。 '
- en: Now that we have some VFX in place, let's add sound effects.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一些VFX，让我们添加音效。
- en: Scripting audio feedback
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本音频反馈
- en: 'VFX added a good depth of immersion to what is happening in the game, but we
    can improve this even further with sound. Let''s start adding sound to the explosion
    effect by doing the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: VFX为游戏中发生的事情增加了很好的沉浸感，但我们可以通过声音进一步改进。让我们开始通过以下方式向爆炸效果添加声音：
- en: Download an explosion sound effect.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载爆炸音效。
- en: Select the explosion prefab and add **Audio Source** to it.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择爆炸预制件并向其添加**Audio Source**。
- en: Set the downloaded explosion's audio clip as the **AudioClip** property of the
    audio source.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下载的爆炸音频剪辑设置为音频源的**AudioClip**属性。
- en: Make sure **Play On Awake** is checked and **Loop** is unchecked under **Audio
    Source**.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保**Play On Awake**已选中，并且**Loop**未选中在**Audio Source**下。
- en: Set the **Spatial Blend** slider to **3D** and test the sound, configuring the
    **3D Sound** settings as needed:![Figure 17.25 – Adding sound to the explosion
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Spatial Blend**滑块设置为**3D**并测试声音，根据需要配置**3D声音**设置：![图17.25 - 爆炸时添加声音
- en: '](img/Figure_17.25_B14199.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.25_B14199.jpg)'
- en: Figure 17.25 – Adding sound to the explosion
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.25 - 爆炸时添加声音
- en: 'As you can see here, we didn''t need to use any script. As the sound is added
    to the Prefab, it will be played automatically in the very moment the prefab is
    instantiated. Now, let''s integrate the shooting sound by doing the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这里所看到的，我们不需要使用任何脚本。由于声音已添加到预制件中，它将在实例化预制件的那一刻自动播放。现在，让我们通过以下方式集成射击声音：
- en: Download a shooting sound and add it through an audio source to the weapon of
    the player, this time unchecking the **Play On Awake** checkbox and again setting
    **Spatial Blend** to **3D**.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载射击声音，并通过音频源添加到玩家的武器中，这次取消**Play On Awake**复选框，并再次将**Spatial Blend**设置为**3D**。
- en: In the `PlayerShooting` script, create a field of the `AudioSource` type called
    `shootSound` and drag the weapon to this property to connect the script with the
    `AudioSource` variable in the weapon.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerShooting`脚本中，创建`AudioSource`类型的字段，命名为`shootSound`，并将武器拖动到此属性中，以将脚本与武器中的`AudioSource`变量连接起来。
- en: 'In the `if` statement that checks whether we can shoot, add the `shootSound.Play();`
    line to execute the sound when shooting, using the same logic applied to the particle
    system:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查是否可以射击的`if`语句中，添加`shootSound.Play();`行以执行射击时的声音，使用相同的逻辑应用于粒子系统：
- en: '![Figure 17.26 – Adding sound when shooting'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.26 - 射击时添加声音'
- en: '](img/Figure_17.26_B14199.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.26_B14199.jpg)'
- en: Figure 17.26 – Adding sound when shooting
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.26 - 射击时添加声音
- en: Another approach to this would be the same as the one we did with the explosion;
    just add the shooting sound to the bullet, but if the bullet collides with a wall,
    soon enough the sound will be cut off. Or, if in the future we want an automatic
    weapon sound, it will need to be implemented as a single looping sound that starts
    when we press the relevant key and stops when we release it. This way, we prevent
    too many sound instances from overlapping when we shoot too many bullets. Take
    into account those kinds of scenarios when choosing the approach to script your
    feedback.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是与我们处理爆炸时的方法相同；只是将射击声音添加到子弹中，但如果子弹与墙壁碰撞，很快声音就会被切断。或者，如果将来我们想要自动武器声音，就需要将其实现为一个单一的循环声音，当我们按下相关按键时开始，松开按键时停止。这样，当我们射出太多子弹时，可以防止太多声音实例重叠。在选择脚本反馈的方法时，请考虑这些情景。
- en: Now that we have finished with our audio feedback, let's finish integrating
    our animation assets, which we prepared in [*Chapter 12*](B14199_12_Final_SK_ePub.xhtml#_idTextAnchor161),
    *Creating Animations with Animator, Cinemachine, and Timeline*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了音频反馈，让我们完成集成我们在[*第12章*](B14199_12_Final_SK_ePub.xhtml#_idTextAnchor161)中准备的动画资产，*使用Animator、Cinemachine和Timeline创建动画*。
- en: Scripting animations
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本动画
- en: 'In [*Chapter 12*](B14199_12_Final_SK_ePub.xhtml#_idTextAnchor161), *Creating
    Animations with Animator, Cinemachine, and Timeline*, we created an animator controller
    as a way to integrate several animations, and we also added parameters to it to
    control when the transitions between animations should execute. Now, it is time
    to do some scripting to make these parameters be affected by the actual behavior
    of the player and match the player''s current state by doing the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第12章*](B14199_12_Final_SK_ePub.xhtml#_idTextAnchor161)，*使用Animator、Cinemachine和Timeline创建动画*，我们创建了一个动画控制器，作为整合多个动画的一种方式，并为其添加了参数，以控制动画之间的过渡何时执行。现在，是时候做一些脚本，使这些参数受到玩家实际行为的影响，并通过以下方式匹配玩家当前状态：
- en: In the `PlayerShooting` script, add a reference to `Animator` using `GetComponent`
    in `Awake` and cache it in a field:![Figure 17.27 – Caching the Animator reference
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerShooting`脚本中，使用`Awake`中的`GetComponent`添加对`Animator`的引用，并将其缓存在字段中：![图17.27
    - 缓存Animator引用
- en: '](img/Figure_17.27_B14199.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.27_B14199.jpg)'
- en: Figure 17.27 – Caching the Animator reference
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.27 - 缓存Animator引用
- en: Call the `animator.SetBool("Shooting", true);` function in the `if` statement
    that checks whether we are shooting, and add the same function but pass `false`
    as a second argument in the `else` clause of the `if` statement. This function
    will modify the `"Shooting"` parameter of the animator controller:![Figure 17.28
    – Setting the Shooting Boolean depending on whether we are shooting
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查我们是否在射击的`if`语句中调用`animator.SetBool("Shooting", true);`函数，并在`if`语句的`else`子句中添加相同的函数，但将`false`作为第二个参数传递。此函数将修改动画控制器的`"Shooting"`参数：![图17.28
    - 根据我们是否在射击来设置Shooting布尔值
- en: '](img/Figure_17.28_B14199.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.28_B14199.jpg)'
- en: Figure 17.28 – Setting the Shooting Boolean depending on whether we are shooting
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.28 - 根据我们是否在射击来设置Shooting布尔值
- en: If you test this, you may notice an error—the animation is not playing. If you
    check the script, you will notice that it will be `true` just for one frame as
    we are using `GetKeyDown`, so the Shooting Boolean will immediately be set to
    `false` in the next frame. One solution of the several that we can implement here
    would be to make our shooting script repeat the shooting action while pressing
    the key instead of releasing and clicking again to shoot another bullet.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您测试此功能，可能会注意到一个错误-动画没有播放。如果您检查脚本，您会注意到它只会在一个帧中为`true`，因为我们使用`GetKeyDown`，所以Shooting布尔值将立即在下一帧被设置为`false`。我们可以在这里实现的几种解决方案之一是，使我们的射击脚本在按住键时重复射击动作，而不是释放并再次点击以射出另一颗子弹。
- en: 'Check the following screenshot for the solution and try to understand the logic:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看以下截图以获取解决方案，并尝试理解逻辑：
- en: '![Figure 17.29 – Repetitive shooting script'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.29 - 重复射击脚本'
- en: '](img/Figure_17.29_B14199.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.29_B14199.jpg)'
- en: Figure 17.29 – Repetitive shooting script
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.29 - 重复射击脚本
- en: As you can see, our script now uses `GetKey` to keep shooting while keeping
    the shoot button pressed, and to prevent shooting in every frame, we compare the
    current time against the last shoot time to check how much time has passed since
    the last shot. We created the `fireRate` field to control the time between shots.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的脚本现在使用`GetKey`来保持按住射击按钮时持续射击，并且为了防止在每一帧中射击，我们将当前时间与上次射击时间进行比较，以检查自上次射击以来经过了多少时间。我们创建了`fireRate`字段来控制射击之间的时间。
- en: 'For the animator controller''s `Velocity` parameter, we can detect the magnitude
    of the velocity vector of `Rigidbody`, in meters per second, and set that as the
    current value. This can be perfectly separated from the `PlayerMovement` script,
    so we can reuse this if necessary in other scenarios. So, we need a script such
    as the following, which just connects the `Rigidbody` component''s velocity with
    the `animator` `Velocity` parameter:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动画控制器的`Velocity`参数，我们可以检测`Rigidbody`的速度矢量的大小（以米/秒为单位），并将其设置为当前值。这可以完全与`PlayerMovement`脚本分离，因此在其他情况下我们可以重复使用这个。因此，我们需要一个脚本，如下所示，它只是将`Rigidbody`组件的速度与`animator`的`Velocity`参数连接起来：
- en: '![Figure 17.30 – Repetitive shooting script'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.30 - 重复射击脚本'
- en: '](img/Figure_17.30_B14199.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.30_B14199.jpg)'
- en: Figure 17.30 – Repetitive shooting script
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.30 - 重复射击脚本
- en: You may need to increase the `0.01` transitions threshold used so far a bit
    in the conditions of the transitions of the animator controller because `Rigidbody`
    keeps moving after releasing the keys. Using `1` worked perfectly for me. Another
    option would be to increase the drag and the velocity of the player to make the
    character stop faster. Pick whatever method works best for you.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要稍微增加动画控制器的转换条件中使用的`0.01`过渡阈值，因为`Rigidbody`在释放键后仍在移动。对我来说，使用`1`效果非常好。另一个选择是增加玩家的阻力和速度，使角色更快地停下来。选择最适合您的方法。
- en: As you can see, we can gather data about the actual movement and shooting action
    of our player to inform the animator controller of its state so that it can react
    accordingly.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以收集有关玩家实际移动和射击动作的数据，以通知动画控制器其状态，以便它可以做出相应的反应。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Feedback is an important topic in video games. It gives valuable information
    to the player, such as the location of enemies if there is a 3D sound setup, distant
    shooting depicted by muzzle flashes in the background, life bars indicating that
    the player is about to die, animations that react according to the player's movements,
    and so on. In this chapter, we saw different forms of feedback, sounds, VFX, animations,
    and the UI, which we already created in *Part 2* of this book. Here, we learned
    how to use scripting to connect the UI to the game.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 反馈是视频游戏中的一个重要主题。它为玩家提供宝贵的信息，例如敌人的位置（如果有3D声音设置）、远处射击的枪口火光、生命条指示玩家即将死亡、根据玩家动作反应的动画等。在本章中，我们看到了不同形式的反馈，声音、VFX、动画和UI，这些都是我们在本书的*第2部分*中已经创建的。在这里，我们学习了如何使用脚本将UI连接到游戏中。
- en: Now, you can script the UI, particle systems, and sounds to react to the game
    status, including changing the score text or the life bars of the UI or playing
    particle and sound effects when the character shoots. This improves the player's
    immersion experience in your game.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以编写脚本来让界面、粒子系统和声音根据游戏状态做出反应，包括更改界面上的得分文本或生命条，或在角色射击时播放粒子和声音效果。这将提高玩家在游戏中的沉浸体验。
- en: In the next chapter, we are going to discuss how to create a challenging AI
    for our enemies.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何为我们的敌人创建具有挑战性的人工智能。
