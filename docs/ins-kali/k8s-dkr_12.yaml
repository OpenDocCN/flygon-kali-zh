- en: '*Chapter 9*: Deploying a Secured Kubernetes Dashboard'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 9 章*：部署安全的 Kubernetes 仪表板'
- en: Kubernetes clusters are made up of more than the API server and the kubelet.
    Clusters are generally made up of additional applications that need to be secured,
    such as container registries, source control systems, pipeline services, GitOps
    applications, and monitoring systems. The users of your cluster will often need
    to interact with these applications directly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 集群不仅由 API 服务器和 kubelet 组成。集群通常由需要进行安全保护的其他应用程序组成，例如容器注册表、源代码控制系统、流水线服务、GitOps
    应用程序和监控系统。您的集群用户通常需要直接与这些应用程序进行交互。
- en: While many clusters are focused on authenticating access to user-facing applications
    and services, cluster solutions are not given the same first-class status. Users
    often are asked to use kubectl's **port-forward** or **proxy** capability to access
    these systems. This method of access is an anti-pattern from a security and user
    experience standpoint. The first exposure users and administrators will have to
    this anti-pattern is the Kubernetes Dashboard. This chapter will detail why this
    method of access is an anti-pattern and how to properly access the Dashboard.
    We'll walk you through how not to deploy a secure web application and point out
    the issues and risks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多集群都专注于对面向用户的应用程序和服务进行身份验证，但集群解决方案并未受到同等重视。用户通常被要求使用 kubectl 的端口转发或代理功能来访问这些系统。从安全和用户体验的角度来看，这种访问方法是一种反模式。用户和管理员将首次接触到这种反模式的是
    Kubernetes 仪表板。本章将详细介绍为什么这种访问方法是一种反模式，以及如何正确访问仪表板。我们将指出如何不部署安全的 Web 应用程序，并指出其中的问题和风险。
- en: We'll use the Kubernetes Dashboard as a way to learn about web application security
    and how to apply those patterns in your own cluster. These lessons will work with
    not just the dashboard, but other cluster focused applications such as the Kiali
    dashboard for Istio, Grafana, Prometheus, and other cluster management applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Kubernetes 仪表板来学习有关 Web 应用程序安全性以及如何在自己的集群中应用这些模式。这些课程不仅适用于仪表板，还适用于其他集群重点应用程序，如
    Istio 的 Kiali 仪表板、Grafana、Prometheus 和其他集群管理应用程序。
- en: Finally, we'll spend some time talking about local dashboards and how to evaluate
    their security. This is a popular trend, but not universal. It's important to
    understand the security of both approaches, and we'll explore them in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将花一些时间讨论本地仪表板以及如何评估它们的安全性。这是一个流行的趋势，但并非普遍适用。了解这两种方法的安全性非常重要，我们将在本章中探讨它们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How does the dashboard know who you are?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表板如何知道你是谁？
- en: Is the dashboard insecure?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表板是否不安全？
- en: Deploying the dashboard with a reverse proxy
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反向代理部署仪表板
- en: Integrating the dashboard with OpenUnison
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将仪表板与 OpenUnison 集成
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the exercises in this chapter you will require a KinD cluster running
    with OIDC integration. We created this in [*Chapter 7*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203)*,
    Integrating Authentication into Your Cluster.*
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的练习，您需要一个运行 OIDC 集成的 KinD 集群。我们在《第 7 章》[*第 7 章*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203)*《将身份验证集成到您的集群中》*中创建了这个集群。
- en: 'You can access the code for this chapter at the following GitHub repository:
    [https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下 GitHub 存储库中访问本章的代码：[https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide)。
- en: How does the dashboard know who you are?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仪表板如何知道你是谁？
- en: The Kubernetes Dashboard is a powerful web application for quickly accessing
    your cluster from inside a browser. It lets you browse your namespaces and view
    the status of nodes, and even provides a shell you can use to access Pods directly.
    There is a fundamental difference between using the dashboard and kubectl. The
    dashboard, being a web application, needs to manage your session, whereas kubectl
    does not. This leads to a different set of security issues during deployment that
    are often not accounted for, leading to severe consequences. In this section,
    we'll explore how the dashboard identifies users and interacts with the API server.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 仪表板是一个强大的 Web 应用程序，可以快速从浏览器内部访问您的集群。它允许您浏览命名空间并查看节点的状态，甚至提供一个您可以使用来直接访问
    Pod 的 shell。使用仪表板和 kubectl 之间存在根本的区别。作为 Web 应用程序，仪表板需要管理您的会话，而 kubectl 不需要。这导致在部署过程中出现一组不同的安全问题，通常没有考虑到，导致严重后果。在本节中，我们将探讨仪表板如何识别用户并与
    API 服务器进行交互。
- en: Dashboard architecture
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仪表板架构
- en: 'Before diving into the specifics of how the dashboard authenticates a user,
    it''s important to understand the basics of how the dashboard works. The dashboard
    at a high level has three layers:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解仪表板如何对用户进行身份验证之前，了解仪表板的基本工作原理非常重要。从高层次来看，仪表板有三个层次：
- en: '**User Interface**: This is the Angular + HTML frontend that is displayed in
    your browser and that you interact with.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户界面**：这是在浏览器中显示并与之交互的 Angular + HTML 前端。'
- en: '**Middle Tier**: The frontend interacts with a set of APIs hosted in the dashboard''s
    container to translate calls from the frontend into Kubernetes API calls.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间层**：前端与仪表板容器中托管的一组 API 进行交互，将前端的调用转换为 Kubernetes API 调用。'
- en: '**API Server**: The middle tier API interacts directly with the Kubernetes
    API server.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API 服务器**：中间层 API 直接与 Kubernetes API 服务器进行交互。'
- en: 'This three-layered architecture of the Kubernetes Dashboard can be seen in
    the following diagram:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 仪表板的这种三层架构可以在以下图表中看到：
- en: '![Figure 9.1 – Kubernetes Dashboard architecture'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.1 – Kubernetes 仪表板架构'
- en: '](image/Fig_9.1_B15514.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_9.1_B15514.jpg)'
- en: Figure 9.1 – Kubernetes Dashboard architecture
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – Kubernetes 仪表板架构
- en: When a user interacts with the dashboard, the user interface makes calls to
    the middle tier, which in turn makes calls to the API server. The dashboard doesn't
    know how to collect credentials, with which most of the applications users would
    generally get access. There's no place to put a username or password. It has a
    very simple session mechanism system based on cookies, but for the most part the
    dashboard doesn't really know, or care, who the currently logged in user is. The
    only thing the dashboard cares about is what token to use when communicating with
    the API server.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户与仪表板交互时，用户界面会调用中间层，中间层再调用 API 服务器。仪表板不知道如何收集凭证，大多数应用程序用户通常会获得访问权限。没有地方放用户名或密码。它有一个基于
    cookie 的非常简单的会话机制系统，但在大多数情况下，仪表板实际上并不知道或关心当前登录的用户是谁。仪表板关心的唯一事情是在与 API 服务器通信时使用什么令牌。
- en: So, how does the dashboard know who you are?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，仪表板如何知道你是谁呢？
- en: Authentication methods
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证方法
- en: 'There are three ways that the dashboard can determine who a user is:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板可以确定用户身份的三种方式：
- en: '**No credentials**: The dashboard can be told not to collect any tokens or
    credentials. When this happens, the dashboard will interact with the API server
    using the container''s own service account with whatever privileges it is assigned
    via RBAC.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无凭证**：可以告诉仪表板不收集任何令牌或凭证。当这种情况发生时，仪表板将使用容器自己的服务帐户与 API 服务器进行交互，具有通过 RBAC 分配的任何特权。'
- en: '**Token from login/uploaded kubectl configuration**: The dashboard can prompt
    the user for their kubectl configuration file or for a bearer token to use. Once
    a token is provided (or extracted from the configuration file uploaded to the
    dashboard), an encrypted cookie is created to store the token. This cookie is
    decrypted by the middle tier, and the token inside is passed to the API server.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**来自登录/上传kubectl配置的令牌**：仪表板可以提示用户提供他们的kubectl配置文件或一个用于使用的令牌。一旦提供了令牌（或从上传到仪表板的配置文件中提取出来），就会创建一个加密的cookie来存储令牌。这个cookie会被中间层解密，里面的令牌会被传递给API服务器。'
- en: '**Token from a reverse proxy**: If there''s an authorization header containing
    a bearer token in requests from the user interface to the middle tier, the middle
    tier will use that bearer token in requests to the API server. This is the most
    secure option and the implementation that will be detailed in this chapter.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**来自反向代理的令牌**：如果用户界面向中间层发出的请求中包含一个包含令牌的授权头，则中间层将在向API服务器发出请求时使用该令牌。这是最安全的选项，也是本章将详细介绍的实现方式。'
- en: Throughout the rest of this chapter, the first two options will be explored
    as anti-patterns for accessing the dashboard, and we will explain why the reverse
    proxy pattern is the best option for accessing a cluster's dashboard implementation
    from a security standpoint and a user experience standpoint.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，将探讨访问仪表板的前两个选项作为反模式，并解释为什么反向代理模式是从安全和用户体验的角度来看访问集群仪表板实现的最佳选项。
- en: Understanding dashboard security risks
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解仪表板安全风险
- en: The question of the dashboard's security often comes up when setting up a new
    cluster. Securing the dashboard boils down to how the dashboard is deployed, rather
    than if the dashboard itself is secure. Going back to the architecture of the
    dashboard application, there is no sense of "security" being built in. The middle
    tier simply passes a token to the API server.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置新集群时，仪表板的安全性问题经常被提出。保护仪表板归结为仪表板的部署方式，而不是仪表板本身是否安全。回到仪表板应用程序的架构，没有安全性的概念被构建进去。中间层只是简单地将令牌传递给API服务器。
- en: When talking about any kind of IT security, it's important to look at it through
    the lens of *defense in depth*. This is the idea that any system should have multiple
    layers of security. If one fails, there are other layers to fill the gap until
    the failed layers can be addressed. A single failure doesn't give an attacker
    direct access.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论任何类型的IT安全时，重要的是通过“深度防御”的视角来看待。这是任何系统都应该有多层安全的理念。如果一层失败，就有其他层来填补漏洞，直到失败的层得到解决。单一的失败不会直接给攻击者提供访问权限。
- en: The most often cited incident related to the dashboard's security was the breach
    of Tesla in 2018 by crypto-miners. Attackers were able to access Pods running
    in Tesla's clusters because the dashboard wasn't secured. The cluster's Pods had
    access to tokens that provided the attackers with access to Tesla's cloud providers
    where the attackers ran their crypto-mining systems.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与仪表板安全性相关的最常引用的事件是2018年加密货币挖矿者入侵特斯拉的事件。攻击者能够访问特斯拉集群中运行的Pods，因为仪表板没有得到保护。集群的Pods可以访问提供攻击者访问特斯拉云供应商的令牌，攻击者在那里运行他们的加密挖矿系统。
- en: Dashboards in general are often an attack vector because they make it easy to
    find what attackers are looking for and can easily be deployed insecurely. Illustrating
    this point, at KubeCon NA 2019 a **Capture the Flag** (**CTF**) was presented
    where one of the scenarios was a developer "accidentally" exposing the cluster's
    dashboard.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，仪表板通常是攻击向量，因为它们很容易找到攻击者寻找的内容，并且很容易被不安全地部署。为了说明这一点，在KubeCon NA 2019上展示了一个“夺旗”（CTF）活动，其中一个场景是开发人员“意外”暴露了集群的仪表板。
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The CTF is available as a home lab at [https://securekubernetes.com/](https://securekubernetes.com/).
    It's a highly recommended resource for anyone learning Kubernetes security. In
    addition to being educational, and terrifying, it's also really fun!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: CTF可作为家庭实验室在[https://securekubernetes.com/](https://securekubernetes.com/)上使用。这是一个非常推荐的资源，供任何学习Kubernetes安全的人使用。除了具有教育意义和可怕之外，它也非常有趣！
- en: Since the Tesla breach, it's become harder to deploy the dashboard without credentials.
    It's no longer the default and requires updates to both the dashboard and the
    cluster. To demonstrate just how dangerous this can be, let's go through the steps
    to do it and see what damage can be done.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 自特斯拉遭受攻击以来，部署仪表板而不需要凭据变得更加困难。这不再是默认设置，需要更新仪表板和集群。为了演示这样做有多危险，让我们来看看可以造成什么样的损害。
- en: Going through these steps might bring about the thought "does anyone really
    go through all these steps to get to the dashboard?" The answer is probably something
    no one wants to talk about. In the previous chapter, multiple options for authorizing
    access to a cluster and designing multi-tenancy were discussed. One of the options
    was tenancy at the cluster layer, where each tenant gets its own cluster. Unfortunately,
    many of these deployments include cluster-admin access for the tenants, which
    would give them the ability to perform these steps. Cluster administrators are
    a few Google searches away from instructions to easily bypass that pesky VPN developers
    don't like using from home.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 经历这些步骤可能会让人想到“有人真的会经历所有这些步骤来进入仪表板吗？”答案可能是没有人愿意谈论的事情。在上一章中，讨论了授权访问集群和设计多租户的多个选项。其中一个选项是在集群层面进行租户管理，其中每个租户都有自己的集群。不幸的是，许多这些部署包括租户的集群管理员访问权限，这将使他们能够执行这些步骤。集群管理员离谷歌搜索指令只有几步之遥，就能轻松绕过那些开发人员不喜欢在家中使用的烦人VPN。
- en: Deploying an insecure dashboard
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署一个不安全的仪表板
- en: While this may sound crazy, it's something that we have seen in the wild far
    too often. The recommended dashboard installation states multiple times not to
    use this type of configuration outside of an isolated development lab. The downfall
    is that since it does make deploying the dashboard so easy, many newer administrators
    use it since it's easy to set up, and they often use the same deployment in a
    production cluster.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这听起来很疯狂，但我们在野外经常看到这种情况。推荐的仪表板安装多次声明不要在隔离的开发实验室之外使用这种类型的配置。不足之处在于，由于它确实使部署仪表板变得如此简单，许多新的管理员使用它，因为它易于设置，并且他们经常在生产集群中使用相同的部署。
- en: 'Now, let''s show how easy it is to attack a dashboard that is deployed without
    security in mind:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们展示一下部署时没有考虑安全性的仪表板有多容易受到攻击：
- en: 'The first step is to tell the dashboard to allow users to bypass authentication.
    Edit the **kubernetes-dashboard** deployment in the **kubernetes-dashboard** namespace:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是告诉仪表板允许用户绕过身份验证。编辑**kubernetes-dashboard**命名空间中的**kubernetes-dashboard**部署：
- en: '**kubectl edit deployment kubernetes-dashboard -n kubernetes-dashboard**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**kubectl edit deployment kubernetes-dashboard -n kubernetes-dashboard**'
- en: Look for the **args** option for the container, add **- --enable-skip-login**,
    then save:![Figure 9.2 – Enabling skip-login on the dashboard
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找容器的**args**选项，添加**- --enable-skip-login**，然后保存：![图9.2 - 在仪表板上启用跳过登录
- en: '](image/Fig_9.2_B15514.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_9.2_B15514.jpg)'
- en: Figure 9.2 – Enabling skip-login on the dashboard
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 - 在仪表板上启用跳过登录
- en: 'Now we need to expose the dashboard to the network by creating a new Ingress
    rule. Create a new Ingress manifest called **insecure-dashboard.yaml** with the
    following YAML. Remember to replace the IP address in the **host** section with
    your Docker host''s IP address:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要通过创建新的Ingress规则将仪表板暴露给网络。使用以下YAML创建一个名为**insecure-dashboard.yaml**的新Ingress清单。记得用你的Docker主机IP地址替换**host**部分的IP地址：
- en: 'apiVersion: networking.k8s.io/v1beta1'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: networking.k8s.io/v1beta1'
- en: 'kind: Ingress'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：Ingress
- en: 'metadata:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: dashboard-external-auth'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：dashboard-external-auth
- en: 'namespace: kubernetes-dashboard'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间：kubernetes-dashboard
- en: 'annotations:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注释：
- en: 'kubernetes.io/ingress.class: nginx'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'kubernetes.io/ingress.class: nginx'
- en: 'nginx.ingress.kubernetes.io/affinity: cookie'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'nginx.ingress.kubernetes.io/affinity: cookie'
- en: 'nginx.ingress.kubernetes.io/backend-protocol: https'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'nginx.ingress.kubernetes.io/backend-protocol: https'
- en: 'nginx.ingress.kubernetes.io/secure-backends: "true"'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'nginx.ingress.kubernetes.io/secure-backends: "true"'
- en: 'nginx.org/ssl-services: kubernetes-dashboard'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 'nginx.org/ssl-services: kubernetes-dashboard'
- en: 'spec:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 规格：
- en: 'rules:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 规则：
- en: '- host: k8s-secret-dashboard.apps.192-168-2-129.nip.io'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '- host: k8s-secret-dashboard.apps.192-168-2-129.nip.io'
- en: 'http:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: http：
- en: 'paths:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 路径：
- en: '- backend:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '- 后端：'
- en: 'serviceName: kubernetes-dashboard'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 'serviceName: kubernetes-dashboard'
- en: 'servicePort: 443'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'servicePort: 443'
- en: 'path: /'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 路径：/
- en: 'Create the Ingress rule by deploying the manifest using **kubectl**. Since
    we added the namespace value to the manifest, we do need to add **-n** to the
    kubectl command:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用**kubectl**部署清单来创建Ingress规则。由于我们在清单中添加了命名空间值，因此需要在kubectl命令中添加**-n**：
- en: '**kubectl create -f insecure-dashboard.yaml**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**kubectl create -f insecure-dashboard.yaml**'
- en: Once the Ingress is created, open a browser and go to your secret dashboard
    using the Nip.io name specified in the **host** section of the Ingress rule.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Ingress后，打开浏览器，使用Ingress规则的**host**部分指定的Nip.io名称访问您的secret仪表板。
- en: You will see an authentication screen that asks for a token or a Kubeconfig
    file, but since we enabled the option to skip the login when we edited the dashboard,
    you can simply skip the login by clicking on **Skip**:![Figure 9.3 – Kubernetes
    Dashboard with login disabled
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一个要求令牌或Kubeconfig文件的身份验证屏幕，但由于我们在编辑仪表板时启用了跳过登录的选项，您可以通过单击**跳过**来简单地跳过登录：![图9.3
    - 禁用登录的Kubernetes仪表板
- en: '](image/Fig_9.3_B15514.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_9.3_B15514.jpg)'
- en: Figure 9.3 – Kubernetes Dashboard with login disabled
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 - 禁用登录的Kubernetes仪表板
- en: Once in the dashboard, the default service account doesn't have access to anything:![Figure
    9.4 – Kubernetes Dashboard with the default service account
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入仪表板，默认服务账户将无法访问任何内容：![图9.4 - 默认服务账户的Kubernetes仪表板
- en: '](image/Fig_9.4_B15514.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_9.4_B15514.jpg)'
- en: Figure 9.4 – Kubernetes Dashboard with the default service account
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 - 默认服务账户的Kubernetes仪表板
- en: So far this may not look too bad. You will see *access forbidden* errors, so
    right now the dashboard will not allow you to do any damage. Unfortunately, many
    people get to this point and go the extra step to change the permissions that
    the default service account has on the cluster.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这可能看起来还不错。您将看到*访问被禁止*的错误，所以目前仪表板不会允许您造成任何损害。不幸的是，许多人到达这一点并采取额外的步骤来更改默认服务账户在集群上的权限。
- en: Right now, the service account isn't authorized for access to the cluster, so
    change that by creating a new **ClusterRoleBinding** to the cluster-admin **ClusterRole**.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，服务账户未被授权访问集群，因此通过创建新的**ClusterRoleBinding**到cluster-admin **ClusterRole**来更改。
- en: 'Create a new file called **dashboard-role.yaml** with the following contents:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为**dashboard-role.yaml**的新文件，内容如下：
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: rbac.authorization.k8s.io/v1'
- en: 'kind: ClusterRoleBinding'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：ClusterRoleBinding
- en: 'metadata:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: secret-dashboard-cluster-admin'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：secret-dashboard-cluster-admin
- en: 'roleRef:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'roleRef:'
- en: 'apiGroup: rbac.authorization.k8s.io'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiGroup: rbac.authorization.k8s.io'
- en: 'kind: ClusterRole'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：ClusterRole
- en: 'name: cluster-admin'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：cluster-admin
- en: 'subjects:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 主题：
- en: '- apiGroup: ""'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '- apiGroup: ""'
- en: 'kind: ServiceAccount'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 'kind: ServiceAccount'
- en: 'namespace: kubernetes-dashboard'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间：kubernetes-dashboard
- en: 'name: kubernetes-dashboard'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：kubernetes-dashboard
- en: 'Create the new **ClusterRoleBinding** by applying it using **kubectl**:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用kubectl应用它来创建新的**ClusterRoleBinding**：
- en: '**kubectl create -f dashboard-role.yaml**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**kubectl create -f dashboard-role.yaml**'
- en: Congratulations! The secret dashboard is now available for anyone who may want
    to use it!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！秘密仪表板现在可以供任何想要使用它的人使用！
- en: Now, you may be thinking *"Who can find my dashboard? They would need to know
    the URL, and I'm not telling anyone what it is."* You feel secure because nobody
    else knows the URL or the IP address to your dashboard. This is called Security
    by Obscurity and is generally accepted to be a terrible approach to securing a
    system.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会想*"谁能找到我的仪表板？他们需要知道URL，而我不会告诉任何人。"* 你感到安全，因为没有其他人知道你的仪表板的URL或IP地址。这被称为安全性通过混淆，通常被认为是一种糟糕的保护系统的方法。
- en: Let's use a scenario of how someone may exploit the dashboard without you knowing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个场景来说明，有人可能在你不知情的情况下利用仪表板。
- en: 'You are a big Reddit fan, and one day you come across a Reddit post titled
    *This is a great tool for securing your Kubernetes Dashboard*. The post seems
    to be legit and you are excited to test this new tool out. After reading the post,
    you see the link at the bottom to the utility and the command to run it: You can
    download it from [https://raw.githubusercontent.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/master/chapter9/kubectl-secure-my-dashboard.go](https://raw.githubusercontent.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/master/chapter9/kubectl-secure-my-dashboard.go)
    to give it a try!'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你是Reddit的忠实粉丝，有一天你看到了一个Reddit帖子，标题是*这是一个用于保护你的Kubernetes仪表板的好工具*。这个帖子看起来很正规，你很兴奋地想测试一下这个新工具。阅读完帖子后，你看到了底部的链接和运行它的命令：你可以从[https://raw.githubusercontent.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/master/chapter9/kubectl-secure-my-dashboard.go](https://raw.githubusercontent.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/master/chapter9/kubectl-secure-my-dashboard.go)下载它来试试看！
- en: 'To fully experience this example, you can run the tool on your KinD cluster
    by executing the following command from your cloned repository in the **chapter9**
    directory. Be sure to change the URL to your dashboard''s Ingress host:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全体验这个例子，你可以在你的KinD集群上运行这个工具，通过在**chapter9**目录下的克隆存储库中执行以下命令。确保将URL更改为你的仪表板的Ingress主机：
- en: go run kubectl-secure-my-dashboard.go https://k8s-secret-dashboard.apps.192-168-2-129.nip.io
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: go run kubectl-secure-my-dashboard.go https://k8s-secret-dashboard.apps.192-168-2-129.nip.io
- en: '**Running analysis on https://k8s-secret-dashboard.apps.192-168-2-129.nip.io**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**在https://k8s-secret-dashboard.apps.192-168-2-129.nip.io上运行分析**'
- en: '**Your dashboard has been secured!**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的仪表板已经得到了保护！**'
- en: 'Now, let''s see review what just happened. Open a browser and go to your secret
    dashboard site to view what''s been changed:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下刚刚发生的事情。打开浏览器，进入你的秘密仪表板网站，查看发生了什么变化：
- en: '![Figure 9.5 – Kubernetes Dashboard showing malware deployed'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5 - 显示部署恶意软件的Kubernetes仪表板'
- en: '](image/Fig_9.5_B15514.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_9.5_B15514.jpg)'
- en: Figure 9.5 – Kubernetes Dashboard showing malware deployed
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 - 显示部署恶意软件的Kubernetes仪表板
- en: It appears our hardening plugin was a ruse to deploy a bitcoin miner. How rude!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 看来我们的加固插件是一个部署比特币矿工的诡计。太无礼了！
- en: Now that you have seen how easily an insecure dashboard can be exploited, delete
    the deployment using kubectl.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了一个不安全的仪表板是如何容易被利用的，使用kubectl删除部署。
- en: While this attack could be mitigated by preauthorizing registries with approved
    images (this topic will be covered when **OpenPolicyAgent** is covered in [*Chapter
    11*](B15514_11_Final_ASB_ePub.xhtml#_idTextAnchor272), *Extending Security Using
    Open Policy Manager)*, at that point the security is reactive, trying to respond
    to threats instead of preventing them. Using an admission controller won't stop
    someone from extracting secrets from your dashboard either.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种攻击可以通过预授权具有批准图像的注册表来减轻（当**OpenPolicyAgent**在[*第11章*](B15514_11_Final_ASB_ePub.xhtml#_idTextAnchor272)中介绍时，*使用Open
    Policy Manager扩展安全性*将涉及到这个话题），但在那时安全性是被动的，试图应对威胁而不是预防它们。使用准入控制器也无法阻止某人从仪表板中提取机密信息。
- en: 'While this was the simplest way to get access to the dashboard insecurely,
    it''s not the only way. The kubectl utility includes two features that can make
    accessing the dashboard easy. The port-forward utility is often used to create
    a tunnel to a pod inside the cluster. This utility creates a TCP stream to a specific
    port on your pod, making it accessible to your local host (or more if you wanted).
    This still bypasses authentication in the dashboard, requiring that the dashboard''s
    service account has access via RBAC to perform whichever tasks are needed. While
    it is true that the user must have RBAC authorization to port-forward to a pod,
    this leaves the dashboard open via two attack vectors:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是以最简单的方式不安全地访问仪表板的方法，但并不是唯一的方法。kubectl实用程序包括两个功能，可以使访问仪表板变得容易。端口转发实用程序通常用于在集群内部创建到pod的隧道。该实用程序创建到pod上特定端口的TCP流，使其可以被本地主机访问（或者更多，如果你想的话）。这仍然绕过了仪表板中的身份验证，要求仪表板的服务账户通过RBAC具有执行所需任务的访问权限。虽然用户必须具有RBAC授权才能将端口转发到pod，但这样会使仪表板通过两个攻击向量开放：
- en: '**External**: Any script running on a user''s local workstation can access
    the forwarded network tunnel.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部**：运行在用户本地工作站上的任何脚本都可以访问转发的网络隧道。'
- en: '**Internal**: Any pod inside of the cluster can access the dashboard pod.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部**：集群内部的任何pod都可以访问仪表板pod。'
- en: For internal access, network policies can be used to limit which namespaces
    and Pods can access the dashboard's API. It's a good idea to use network policies
    to begin with, but that's a single point of failure in this instance. One misconfigured
    policy will open the dashboard to attack.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内部访问，可以使用网络策略来限制哪些命名空间和Pod可以访问仪表板的API。最好一开始就使用网络策略，但在这种情况下这是一个单点故障。一个配置错误的策略将会使仪表板暴露于攻击之下。
- en: Threats from external sources will likely come in the form of scripts you (or
    another tool you use) may decide to run. Web browsers aren't able to access the
    ports opened by port-forwarding from a page hosted outside your local system,
    but any script running on your workstation can. For instance, while you could
    access a port-forwarded host by opening your browser and going directly to that
    port, a web page with malicious JavaScript that loads from a remote site can't
    open a connection to your local host. Attempt to run the hardening script from
    earlier in the section against a forwarded port and the same result will occur,
    an unwanted pod on your infrastructure.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 外部来源的威胁可能以您（或您使用的其他工具）决定运行的脚本的形式出现。Web浏览器无法访问从本地系统外部托管的页面通过端口转发打开的端口，但是您工作站上运行的任何脚本都可以。例如，虽然您可以通过打开浏览器并直接转到该端口来访问转发的主机，但是从远程站点加载的恶意JavaScript的网页无法打开到您本地主机的连接。尝试对转发的端口运行之前在本节中运行的加固脚本，将会产生相同的结果，即在您的基础设施上出现一个不需要的pod。
- en: Another technique for providing access is to use the API server's integrated
    proxy utility. Running **kubectl proxy** creates a local network tunnel to the
    API server that can then be used to proxy HTTP requests to any pod, including
    the dashboard. This has the same drawbacks as **kubectl port-forward** and will
    open your cluster up to attacks from any script running locally.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 提供访问的另一种技术是使用API服务器的集成代理实用程序。运行**kubectl proxy**会创建一个到API服务器的本地网络隧道，然后可以用于代理HTTP请求到任何Pod，包括仪表盘。这与**kubectl
    port-forward**具有相同的缺点，并且会使您的集群面临来自本地运行的任何脚本的攻击。
- en: The common thread among these methods is they have a single point of failure
    in their security. Even with mitigations put in place to limit what images can
    be deployed, an unsecured dashboard can still be used to access Secret objects,
    delete deployments, and even remote shell into Pods via the terminal integrated
    into the dashboard.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的共同点是它们在安全性上存在单一故障点。即使采取了限制可以部署的图像的措施，一个不安全的仪表盘仍然可以用于访问秘密对象、删除部署，甚至通过仪表盘中集成的终端远程进入Pod。
- en: Having explored how to bypass all authentication on the dashboard, and its implications,
    next we'll look at how to provide a token to the dashboard without deploying additional
    infrastructure.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨了如何绕过仪表盘上的所有身份验证及其影响之后，接下来我们将看看如何向仪表盘提供令牌，而无需部署额外的基础设施。
- en: Using a token to log in
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用令牌登录
- en: A user may upload a token or kubectl configuration file to the dashboard as
    a login to avoid the perils of a secret dashboard. As discussed earlier, the dashboard
    will take the user's bearer token and use it with all requests to the API server.
    While this may appear to solve the problem of giving the dashboard its own privileged
    service account, it brings its own issues. The dashboard isn't kubectl and doesn't
    know how to refresh tokens as they expire. This means that a token would need
    to be fairly long lived to be useful. This would require either creating service
    accounts that can be used or making your OpenID Connect **id_tokens** longer lived.
    Both options would negate much of the security put in place by leveraging OpenID
    Connect for authentication.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以将令牌或kubectl配置文件上传到仪表盘作为登录，以避免秘密仪表盘的危险。正如前面讨论的，仪表板将获取用户的令牌并将其与对API服务器的所有请求一起使用。虽然这似乎解决了为仪表盘提供特权服务帐户的问题，但它也带来了自己的问题。仪表盘不是kubectl，并不知道如何在令牌过期时刷新令牌。这意味着令牌需要相当长的生命周期才能发挥作用。这将要求创建可以使用的服务帐户，或者使您的OpenID
    Connect **id_tokens**更长寿。这两种选择都会抵消通过利用OpenID Connect进行身份验证所实施的大部分安全性。
- en: So far, we've only focused on the wrong way to deploy the dashboard. While it
    is important to understand this, what is the correct method? In the next section,
    we'll detail the correct way to deploy the dashboard using a reverse proxy.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只关注了错误的部署仪表盘的方法。虽然了解这一点很重要，但正确的方法是什么？在下一节中，我们将详细介绍使用反向代理部署仪表盘的正确方法。
- en: Deploying the dashboard with a reverse proxy
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用反向代理部署仪表盘
- en: Proxies are a common pattern in Kubernetes. There are proxies at every layer
    in a Kubernetes cluster. The proxy pattern is also used by most service mesh implementations
    on Kubernetes, creating side cars that will intercept requests. The difference
    between the reverse proxy described here and these proxies is in their intent.
    Microservice proxies often do not carry a session, whereas web applications need
    a session to manage state.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是Kubernetes中常见的模式。在Kubernetes集群的每一层都有代理。代理模式也被大多数Kubernetes上的服务网格实现所使用，创建将拦截请求的sidecar。这里描述的反向代理与这些代理的区别在于它们的意图。微服务代理通常不携带会话，而Web应用程序需要会话来管理状态。
- en: 'The following diagram shows the architecture of a Kubernetes Dashboard with
    a reverse proxy:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了带有反向代理的Kubernetes仪表板的架构：
- en: '![Figure 9.6 – Kubernetes Dashboard with a reverse proxy'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6 – 带有反向代理的Kubernetes仪表板'
- en: '](image/Fig_9.6_B15514.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_9.6_B15514.jpg)'
- en: Figure 9.6 – Kubernetes Dashboard with a reverse proxy
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 带有反向代理的Kubernetes仪表板
- en: 'The reverse proxy shown in *Figure 9.6* performs three roles:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6中显示的反向代理执行三个角色：
- en: '**Authentication**: The reverse proxy intercepts unauthenticated requests (or
    stale sessions) and triggers the authentication process with an OpenID Connect
    identity provider to authenticate the user.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：反向代理拦截未经身份验证的请求（或过期会话），并触发使用OpenID Connect身份提供者进行用户身份验证的过程。'
- en: '**Session management**: Kubernetes'' Dashboard is a user-facing application.
    It should have the typical controls put in place to support session timeouts and
    revocation. Be wary of a reverse proxy that stores all session data in a cookie.
    These methods are difficult to revoke.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话管理**：Kubernetes的仪表板是一个面向用户的应用程序。它应该具有典型的控件，以支持会话超时和撤销。要注意的是，存储所有会话数据的反向代理在cookie中。这些方法很难撤销。'
- en: '**Identity injection**: Once the proxy has authenticated a user, it needs to
    be able to inject an HTTP authorization header on each request that is a JWT identifying
    the logged-in user, is signed by the same OpenID Connect identity provider, and
    has the same issuer and recipient as the API server. The exception to this is
    using impersonation, which, as discussed in [*Chapter 7*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203)
    *, Integrating Authentication into Your Cluster*, injects specific headers into
    the requests.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份注入**：一旦代理已经对用户进行了身份验证，它需要能够在每个请求上注入一个HTTP授权头，该头是一个JWT，用于标识已登录的用户，由相同的OpenID
    Connect身份提供者签名，并且具有与API服务器相同的发行者和接收者。唯一的例外是使用模拟，正如在[*第7章*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203)中讨论的那样，将特定的头部注入到请求中。'
- en: The reverse proxy does not need to run on the cluster. Depending on your setup,
    it may be advantageous to do so, especially when utilizing impersonation with
    your cluster. When using impersonation, the reverse proxy uses a service account's
    token, so it's best for that token to never leave the cluster.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 反向代理不需要在集群上运行。根据您的设置，这样做可能是有利的，特别是在利用集群进行模拟时。在使用模拟时，反向代理使用服务账户的令牌，因此最好让该令牌永远不要离开集群。
- en: The focus of this chapter has been on the Kubernetes project's dashboard. There
    are multiple options for dashboard functionality. Next, we'll explore how these
    dashboards interact with the API server and how to evaluate their security.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是Kubernetes项目的仪表板。仪表板功能有多种选择。接下来，我们将探讨这些仪表板如何与API服务器交互以及如何评估它们的安全性。
- en: Local dashboards
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地仪表板
- en: A common theme among third-party dashboards is to run locally on your workstation
    and use a Kubernetes SDK to interact with the API server the same way kubectl
    would. These tools offer the benefit of not having to deploy additional infrastructure
    to secure them.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方仪表板的一个共同主题是在您的工作站上本地运行，并使用Kubernetes SDK与API服务器进行交互，就像kubectl一样。这些工具的好处在于不需要部署额外的基础设施来保护它们。
- en: 'Visual Studio Code''s Kubernetes plugin is an example of a local application
    leveraging direct API server connections. When launching the plugin Visual Studio
    Code accesses your current kubectl configuration and interacts with the API server
    using that configuration. It will even refresh an OpenID Connect token when it
    expires:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code的Kubernetes插件是一个利用直接API服务器连接的本地应用程序的例子。当启动插件Visual Studio
    Code访问您当前的kubectl配置，并使用该配置与API服务器交互。甚至在OpenID Connect令牌过期时，它会刷新该令牌：
- en: '![Figure 9.7 – Visual Studio Code with the Kubernetes plugin'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7 - Visual Studio Code与Kubernetes插件'
- en: '](image/Fig_9.7_B15514.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_9.7_B15514.jpg)'
- en: Figure 9.7 – Visual Studio Code with the Kubernetes plugin
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 - Visual Studio Code与Kubernetes插件
- en: The Kubernetes plugin for Visual Studio Code is able to refresh its OpenID Connect
    Token because it's built with the client-go SDK, the same client libraries used
    by kubectl. When evaluating client dashboards make sure it works with your authentication
    type even if it isn't OpenID Connect. Many of the SDKs for Kubernetes don't support
    OpenID Connect token refreshes. The Java and Python SDKs only recently (as of
    the published date of this book) began supporting the refresh of OpenID Connect
    tokens the way the client-go SDK does. When evaluating a local dashboard, make
    sure it's able to leverage your short-lived tokens and can refresh them as needed,
    just like kubectl can.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code的Kubernetes插件能够刷新其OpenID Connect令牌，因为它是使用client-go SDK构建的，这与kubectl使用的客户端库相同。在评估客户端仪表板时，请确保它与您的身份验证类型配合使用，即使它不是OpenID
    Connect。许多Kubernetes的SDK不支持OpenID Connect令牌的刷新。截至本书出版日期，Java和Python SDK最近才开始支持刷新OpenID
    Connect令牌，就像client-go SDK一样。在评估本地仪表板时，请确保它能够利用您的短期令牌，并在需要时刷新它们，就像kubectl一样。
- en: Other cluster-level applications
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他集群级应用程序
- en: The introduction of this chapter discussed how a cluster is made up of several
    applications besides Kubernetes. Other applications will likely follow the same
    model as the dashboard for security, and the reverse proxy method is a better
    method for exposing those applications than kubectl port-forward, even when the
    application has no built-in security. Use the common Prometheus stack as an example.
    Grafana has support for user authentication, but Prometheus and Alert Manager
    do not. How would you track who had access to these systems or when they were
    accessed using port-forwarding?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了集群除Kubernetes之外还由多个应用程序组成。其他应用程序可能会遵循与仪表板相同的安全模型，而反向代理方法比kubectl端口转发更适合暴露这些应用程序，即使应用程序没有内置安全性。以常见的Prometheus堆栈为例。Grafana支持用户身份验证，但Prometheus和Alert
    Manager则不支持。如果使用端口转发，您将如何跟踪谁访问了这些系统，或者它们何时被访问？
- en: There's no user context provided. Using a reverse proxy, logs of each URL and
    the user that was authenticated to access the URL can be forwarded to a central
    log management system and analyzed by a **Security Information and Event Manager**
    (**SIEM**) providing an additional layer of visibility into a cluster's usage.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 未提供用户上下文。使用反向代理，每个URL的日志和用于访问URL的用户可以被转发到中央日志管理系统，并由安全信息和事件管理器（SIEM）进行分析，提供对集群使用的额外可见性层。
- en: Just as with the dashboard, using a reverse proxy with these applications provides
    a layered security approach. It offloads sessions management from the application
    in question and provides the capability to have enhanced authentication measures
    in place such as multi-factor authentication and session revocation. These benefits
    will lead to a more secure, and easier to use, cluster.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与仪表板一样，使用反向代理提供了分层安全方法。它可以从相关应用程序中卸载会话管理，并提供增强的身份验证措施，如多因素身份验证和会话撤销的能力。这些好处将导致一个更安全、更易于使用的集群。
- en: Integrating the dashboard with OpenUnison
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将仪表板与OpenUnison集成
- en: The topic of how OpenUnison injected identity headers using impersonation was
    covered in [*Chapter 7*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203)*, Integrating
    Authentication into Your Cluster*, but not how OpenUnison injected user's identity
    into the dashboard with an OpenID Connect integrated cluster. It worked, but it
    wasn't explained. This section will use the OpenUnison implementation as an example
    of how to build a reverse proxy for the dashboard. Use the information in this
    section to get a better understanding of API security or to build your own solution
    for dashboard authentication.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: OpenUnison使用模拟的方式注入身份标头的主题在[*第7章*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203)*，将身份验证集成到您的集群*中进行了讨论，但没有讨论OpenUnison如何将用户的身份注入到集成了OpenID
    Connect的集群的仪表板中。它起作用，但没有解释。本节将使用OpenUnison实现作为一个示例，说明如何为仪表板构建一个反向代理。使用本节的信息来更好地理解API安全性，或者为仪表板身份验证构建自己的解决方案。
- en: 'The OpenUnison deployment comprises two integrated applications:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: OpenUnison部署包括两个集成应用程序：
- en: '**The OpenID Connect Identity Provider & Login Portal**: This application hosts
    the login process and the discovery URLs used by the API server to get the keys
    needed to validate an **id_token**. It also hosts the screens where you can obtain
    your token for kubectl.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenID Connect身份提供者和登录门户**：该应用程序托管登录过程和API服务器用于获取验证**id_token**所需密钥的发现URL。它还托管了您可以获取kubectl令牌的屏幕。'
- en: '**The dashboard**: A reverse proxy application that authenticates to the integrated
    OpenID Connect identity provider and injects the user''s **id_token** into each
    request.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪表板**：一个反向代理应用程序，对集成的OpenID Connect身份提供程序进行身份验证，并将用户的**id_token**注入到每个请求中。'
- en: This diagram shows how the dashboard's user interface interacts with its server
    side component with a reverse proxy injecting the user's **id_token****:**
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了仪表板的用户界面如何与其服务器端组件进行交互，反向代理注入用户的**id_token**：
- en: '![Figure 9.8 – OpenUnison integration with the dashboard'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8 - OpenUnison与仪表板的集成'
- en: '](image/Fig_9.8_B15514.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_9.8_B15514.jpg)'
- en: Figure 9.8 – OpenUnison integration with the dashboard
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 - OpenUnison与仪表板的集成
- en: The dashboard uses the same OpenID Connect identity provider as the API server,
    but doesn't use the **id_token** provided by it. Instead, OpenUnison has a plugin
    that will generate a new **id_token** independent of the identity provider with
    the user's identity data in it. OpenUnison can do this because the key used to
    generate an **id_token** for the OpenID Connect identity provider, used by kubectl
    and the API server, is stored in OpenUnison.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板使用与API服务器相同的OpenID Connect身份提供程序，但不使用其提供的**id_token**。相反，OpenUnison有一个插件，将独立于身份提供者生成一个新的**id_token**，其中包含用户的身份数据。OpenUnison可以做到这一点，因为用于为OpenID
    Connect身份提供者生成**id_token**的密钥，被存储在OpenUnison中。
- en: A new, short-lived token is generated separate from the OpenID Connect session
    used with kubectl. This way, the token can be refreshed independently of a kubectl
    session. This process provides the benefits of 1- to 2-minute token life with
    the convenience of a direct login process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个新的、短暂的令牌，与kubectl一起使用的OpenID Connect会话分开。这样，令牌可以独立于kubectl会话进行刷新。这个过程提供了1到2分钟令牌寿命的好处，同时又具有直接登录过程的便利性。
- en: If you have an eye for security, you may point out that this method has a glaring
    single-point-of-failure in the security model, a user's credentials! Just as with
    the Secret dashboard built earlier in this chapter in the *Understanding dashboard
    security risks section*, an attacker generally just needs to ask for credentials
    in order to get them. This is often done via email in an attack called phishing,
    where an attacker sends a victim a link to a page that looks like their login
    page but really just collects credentials. This is why multi-factor authentication
    is so important for infrastructure systems.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对安全有所了解，您可能会指出这种方法在安全模型中存在一个明显的单点故障，即用户的凭据！就像本章前面构建的Secret仪表板一样，在*了解仪表板安全风险部分*，攻击者通常只需要要求凭据就能获取到它们。这通常是通过电子邮件进行的，称为网络钓鱼攻击，攻击者向受害者发送一个看起来像他们登录页面的链接，但实际上只是收集凭据。这就是为什么多因素认证对基础设施系统如此重要。
- en: In a 2019 study, Google showed multi-factor authentication stopped 99% of automated
    and phishing attacks (https://security.googleblog.com/2019/05/new-research-how-effective-is-basic.html).
    Adding multi-factor authentication to the identity provider OpenUnison authenticates
    against, or integrating it directly into OpenUnison, is one of the most effective
    ways to secure the dashboard and your cluster.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在2019年的一项研究中，谷歌显示多因素认证可以阻止99%的自动化和网络钓鱼攻击（https://security.googleblog.com/2019/05/new-research-how-effective-is-basic.html）。将多因素认证添加到身份提供者OpenUnison进行认证，或直接集成到OpenUnison中，是保护仪表板和集群的最有效方法之一。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the security of the Kubernetes Dashboard in detail.
    First, we walked through the architecture and how the dashboard passes your identity
    information on to the API server. We then explored how the dashboard gets compromised,
    and finally we detailed how to correctly deploy the dashboard securely.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细探讨了Kubernetes仪表板的安全性。首先，我们介绍了架构以及仪表板如何将您的身份信息传递给API服务器。然后，我们探讨了仪表板如何被
    compromise，最后我们详细介绍了如何正确地安全部署仪表板。
- en: With this knowledge, you can now provide a secured tool to your users. Many
    users prefer the simplicity of accessing the dashboard via a web browser. Adding
    multi-factor authentication adds an additional layer of security and peace of
    mind. When your security team questions the security of the dashboard, you'll
    have the answers needed to satisfy their concerns.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，您现在可以为用户提供一个安全的工具。许多用户更喜欢通过Web浏览器访问仪表板的简单性。添加多因素认证可以增加额外的安全层和安心感。当您的安全团队质疑仪表板的安全性时，您将有所需的答案来满足他们的担忧。
- en: The previous three chapters focused on the security of the Kubernetes APIs.
    Next, we'll explore securing the soft underbelly of every Kubernetes deployment,
    nodes!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 前三章着重讨论了Kubernetes API的安全性。接下来，我们将探讨如何保护每个Kubernetes部署的软肋，即节点！
- en: Questions
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: The dashboard is insecure.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仪表板不安全。
- en: A. True
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: A. 真
- en: B. False
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: B. 假
- en: How can the dashboard identify a user?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仪表板如何识别用户？
- en: A. The options are either no authentication, or a token injected from a reverse
    proxy
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: A. 选项要么是无认证，要么是从反向代理注入的令牌
- en: B. Username and password
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: B. 用户名和密码
- en: C. ServiceAccount
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: C. ServiceAccount
- en: D. Multi-factor authentication
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: D. 多因素认证
- en: How does the dashboard track session state?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仪表板如何跟踪会话状态？
- en: A. Sessions are stored in etcd.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: A. 会话存储在etcd中。
- en: B. Sessions are stored in custom resource objects called **DashboardSession**.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: B. 会话存储在称为**DashboardSession**的自定义资源对象中。
- en: C. There are no sessions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: C. 没有会话。
- en: D. If a token is uploaded, it's encrypted and stored in the browser as a cookie.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: D. 如果上传了令牌，它将被加密并存储在浏览器中作为cookie。
- en: When using a token, how often can the dashboard refresh it?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用令牌时，仪表板可以多久刷新一次？
- en: A. Once a minute
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: A. 每分钟一次
- en: B. Every thirty seconds
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: B. 每30秒
- en: C. When the token expires
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: C. 当令牌过期时
- en: D. None of the above
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: D. 以上都不是
- en: What's the best way to deploy the dashboard?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署仪表板的最佳方式是什么？
- en: A. Using **kubectl port-forward**
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: A. 使用**kubectl端口转发**
- en: B. Using **kubectl proxy**
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: B. 使用**kubectl代理**
- en: C. With a secret ingress host
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: C. 使用秘密的入口主机
- en: D. Behind a reverse proxy
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: D. 在反向代理后面
- en: The dashboard doesn't support impersonation.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仪表板不支持冒充。
- en: A. True
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: A. 正确
- en: B. False
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: B. 错误
- en: OpenUnison is the only reverse proxy that supports the dashboard.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenUnison是唯一支持仪表板的反向代理。
- en: A. True
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: A. 正确
- en: B. False
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: B. 错误
