- en: Chapter 8. Seeing It All Come Together
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。看到一切如何结合在一起
- en: All software projects are special and there can never be a "one size fits all"
    approach, but as we have seen, a lot of thought has gone into all kinds of different
    approaches to development. A project goes through many stages of development,
    often it starts out exploring the basic ideas, sometimes we can not even be sure
    at that stage what the domain of the project will be. We then begin to factor
    out a certain core competency of the application and a core domain starts to evolve.
    At this stage the involvement of the business experts is crucial to make sure
    the domain aligns with the business needs, and the project does not get sidetracked
    due to misunderstandings, while the ubiquitous language is evolving along the
    way. The project tends to grow from one or two developers to a larger team, and
    team organization becomes more important since we need to start thinking about
    the communication overhead involved in the development as the assumption that
    everybody is familiar with more or less everything in the codebase no longer holds
    true. At this point a team can decide to go for a domain-driven approach and start
    to really model the now established domain in more detail. Even though the involvement
    of the business experts might not be needed every day in the later stages, a consistent
    involvement is important to make sure a project does not depart from the core
    domain needs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 所有软件项目都是特殊的，永远不可能有一种“一刀切”的方法，但正如我们所看到的，对开发的各种不同方法都进行了深思熟虑。一个项目经历了许多开发阶段，通常开始探索基本的想法，有时甚至在那个阶段我们都不能确定项目的领域是什么。然后我们开始分解应用程序的某个核心能力，核心领域开始逐渐发展。在这个阶段，业务专家的参与至关重要，以确保领域与业务需求保持一致，并且项目不会因误解而岔道，同时通用语言也在不断发展。项目往往会从一个或两个开发人员发展成一个更大的团队，团队组织变得更加重要，因为我们需要开始考虑开发中涉及的沟通开销，因为不再成立的假设是每个人都对代码库中的几乎所有内容都很熟悉。在这一点上，团队可以决定采用面向领域的方法，并开始更详细地对现在已经建立的领域进行建模。尽管在后期阶段可能不需要业务专家的每日参与，但持续的参与对确保项目不偏离核心领域需求至关重要。
- en: This idealized form of project growth is dependent on multiple environmental
    factors, not only does the team have to be set up to make the choices described,
    the application also needs to be ready for the approach. We've seen previously
    that not all projects work well with a domain-driven approach, and there are many
    different kinds of JavaScript projects, which can fit the approach at different
    stages of development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这种理想化的项目增长形式取决于多种环境因素，团队不仅需要做出所描述的选择，应用程序也需要准备好采用这种方法。我们之前看到，并不是所有项目都适合面向领域的方法，还有许多不同类型的JavaScript项目，可以在开发的不同阶段适用这种方法。
- en: 'In this chapter we are taking a look at the different projects, some domains,
    and how those two things, together with domain-driven design, fit the whole picture.
    We will be exploring:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看不同的项目、一些领域以及这两个因素，以及面向领域驱动设计如何适应整个画面。我们将探讨：
- en: The different kind of project, that involve JavaScript
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涉及JavaScript的不同类型的项目
- en: How client- and server-side development influences projects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端和服务器端开发如何影响项目
- en: The different problems and their suitability for domain-driven design
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同问题及其适用于面向领域驱动设计的程度
- en: Example domains for domain-driven design
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向领域驱动设计的示例领域
- en: The different kinds of JavaScript project
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的JavaScript项目
- en: JavaScript, as a very versatile language, made its way through the different
    stages of development. Originally conceived as a way to enable more dynamic behavior
    in the browser, it has conquered not only the complex field of developing, almost
    thick with client-like applications using the browser as the platform and runtime,
    but it is now also seen in server-side applications most prominently using Node.js.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript作为一种非常多才多艺的语言，已经在不同的开发阶段取得了成功。最初被构想为在浏览器中实现更动态的行为，它不仅征服了使用浏览器作为平台和运行时的开发复杂的客户端应用程序领域，而且现在也在使用Node.js的服务器端应用程序中得到了广泛应用。
- en: Going all the way from making a document look more interactive by incorporating
    effects, to rendering a whole application on the client side is a wide spectrum
    of complexity and applications. Some may warrant an approach with a larger focus
    on application-design, some might best be served by smaller script-like approaches
    keeping the logic simple and local for the best maintenance.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从通过加入效果使文档看起来更具交互性，到在客户端渲染整个应用程序，这是一个广泛的复杂性和应用程序的范围。一些可能需要更多关注应用程序设计的方法，一些可能最好通过保持逻辑简单和本地化的较小脚本式方法来提供最佳维护。
- en: Enhancing the user experience
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强用户体验
- en: 'Many business applications are perfectly well served by an application comprised
    of a number of pages all rendered on the server side. For the longest times this
    has been the way to go, and still is most likely the simplest approach as it keeps
    the stack of technologies to a minimum. As soon as the pages start to get complex
    it can help the user experience a lot to add some dynamic elements. Those elements
    can be for pointing out features or to guide the user. It can be very useful to
    do some client-side validation of the input for example, so the user does not
    send an obvious invalid request and has to wait for a slow response from the server:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 许多商业应用程序完全适合由一些页面组成的应用程序。在服务器端渲染所有页面在最长时间内一直是最简单的方法，而且很可能仍然是最简单的方法，因为它将技术堆栈保持在最低水平。一旦页面开始变得复杂，增加一些动态元素可以极大地改善用户体验。这些元素可以用于指出功能或引导用户。例如，对输入进行一些客户端验证可能非常有用，这样用户就不会发送明显无效的请求，并且不必等待服务器的缓慢响应：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A form like this can be seen often, we want to prevent the user from being
    able to click the button until a checkbox is checked, and also maybe something
    needs to be agreed on before the request is valid. Having the validation on the
    server side is important, but giving some feedback to the user before hitting
    the button will be a great enhancement. A small JavaScript function, such as the
    following, can easily accomplish that:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的表单经常会出现，我们希望在复选框被选中之前阻止用户点击按钮，并且在请求有效之前可能还需要达成一些协议。在服务器端进行验证很重要，但在点击按钮之前向用户提供一些反馈将是一个很大的增强。一个小的JavaScript函数，比如下面的例子，可以很容易地实现这一点：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We check the value of the checkbox and deactivate or activate the button as
    needed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查复选框的值，并根据需要停用或激活按钮。
- en: This is a business rule and we want to see it reflected in the code; on the
    other hand, the rule is also enforced on the server side, so the need to make
    it work beyond any doubt does not arise. Problems like these arise often in applications,
    and we don't want to reach for overpowered tools straight away. If we, for example,
    start designing the form object as a business object, and encapsulating the rule
    for whether the form is *send-able* or not, we would arrive at an arguably cleaner
    design, at the readability cost of the code. This is the constant trade-off present
    at projects that are largely UX enhancements. In general, mixing view-code with
    business rules is not good; on the other hand, over-engineering very small enhancements,
    such as the preceding code, gets easily lost in the overhead of creating a more
    complex infrastructure for a cleaner model.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个业务规则，我们希望在代码中看到它的体现；另一方面，该规则也在服务器端执行，因此不需要使其在任何情况下都能正常工作。这类问题经常在应用程序中出现，我们不希望立即使用过于强大的工具。例如，如果我们开始将表单对象设计为业务对象，并封装表单是否“可发送”的规则，我们可能会得到一个更清晰的设计，但代码的可读性会受到影响。这是在大部分是UX增强的项目中不断权衡的问题。通常来说，将视图代码与业务规则混合在一起是不好的；另一方面，过度设计非常小的增强功能，比如前面的代码，很容易在创建更复杂的基础设施以获得更清晰的模型时失去意义。
- en: UX enhancements like this one don't lend themselves nicely to a domain-driven
    approach, since the knowledge about the business logic will have to be replicated,
    with a separate adapter for the HTML representation and the server-model representation.
    Adapters like this create some overhead and, depending on the amount of functionality
    encapsulated, they do not necessarily make sense. As the code on the client side
    grows and moves more toward an application, it starts to make more sense.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的UX增强并不适合领域驱动的方法，因为业务逻辑的知识将不得不被复制，需要一个单独的适配器来处理HTML表示和服务器模型表示。这样的适配器会带来一些额外的开销，并且根据封装的功能量，它们未必是有意义的。随着客户端代码的增长并向应用程序发展，这种做法开始变得更有意义。
- en: Single-page applications
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单页应用程序
- en: In recent years, the concept of a thick client application has become more common
    again. In the early days of the Web, websites were static and later were enhanced
    using JavaScript to ease navigation or basic user interactions. In recent years,
    client-side applications in the browser started to grow to a level where a lot
    of business logic lived on the frontend, and the frontend itself became a true
    application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，厚客户端应用程序的概念再次变得更加普遍。在Web的早期，网站是静态的，后来使用JavaScript进行增强以便于导航或基本用户交互。近年来，浏览器中的客户端应用程序开始增长到一个程度，其中很多业务逻辑都存在于前端，并且前端本身成为了一个真正的应用程序。
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A long time ago, when the world still revolved around Mainframes, clients in
    a computing environment were often dumb terminals accepting the user input and
    showing the output. As the hardware grew more powerful, more and more business
    logic was moved to the client for processing, until we reached true client-side
    applications such as running Microsoft Office. We can see the same again in the
    browser now, as applications have become more complex and the browsers more capable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，当世界仍然围绕着大型机转动时，计算环境中的客户端通常是接受用户输入并显示输出的哑终端。随着硬件变得更加强大，越来越多的业务逻辑被移至客户端进行处理，直到我们达到了真正的客户端应用程序，比如运行Microsoft
    Office。现在我们可以在浏览器中看到同样的情况，随着应用程序变得更加复杂，浏览器的功能也变得更加强大。
- en: A one-page application often implements large pieces of the business logic all
    implemented in JavaScript to serve as the thick client querying the server. Examples
    for such applications are plenty, ranging from the more traditional document-oriented
    style all the way to in-browser applications using HTML, CSS, and JavaScript as
    their runtime environment, taking over the browser more or less completely.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用程序通常在JavaScript中实现大量的业务逻辑，作为向服务器查询的厚客户端。这样的应用程序有很多例子，从更传统的面向文档的风格到在浏览器中使用HTML、CSS和JavaScript作为运行环境的应用程序，更多或更少地完全接管了浏览器。
- en: When developing an in-browser application, the structure of the underlying code
    matters a lot more than when enhancing some functionality of a webpage. The problem
    space is divided into several pieces. First, the code needs to be organized in
    such a way that it stays maintainable over a longer period of time as the applications
    grow and change. As the frontend application code now realizes bigger parts of
    the business logic, the maintenance burden grows and the risk of rewriting bigger
    parts grows with it. The application presents a major investment in the system.
    Second, even though the technology stack in the client seems fairly fixed with
    HTML, CSS, and JavaScript, best practices and browser support for features are
    evolving at a rapid pace. At the same time, backwards compatibility is crucial
    as developers don't have much control over the upgrade process of the users. Third,
    the performance aspect of a client-side application is important. Even though
    there have been massive strides in the speedup of JavaScript runtime engines,
    the users are expecting more and more from the applications and, more importantly,
    are running more and more applications in parallel as well. We can't expect our
    one-page application to own large parts of the machine it is running on, but we
    must be careful about spending resources.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发基于浏览器的应用程序时，底层代码的结构比增强网页功能时更加重要。问题空间被分成几个部分。首先，代码需要以一种能够在应用程序增长和变化的情况下保持可维护性的方式进行组织。随着前端应用程序代码现在实现业务逻辑的更大部分，维护负担增加，重写更大部分的风险也随之增加。应用程序对系统的投资很大。其次，尽管客户端的技术堆栈似乎相当固定，包括HTML、CSS和JavaScript，但最佳实践和浏览器对功能的支持正在快速发展。同时，向后兼容性至关重要，因为开发人员对用户的升级过程没有太多控制。第三，客户端应用程序的性能方面很重要。尽管JavaScript运行时引擎的速度提升已经很大，但用户对应用程序的期望越来越高，更重要的是，他们也在同时运行越来越多的应用程序。我们不能指望我们的单页应用程序拥有机器的大部分，但我们必须谨慎使用资源。
- en: The contrast of increased need for performance versus the need for flexibility
    is a driving factor in the development of frameworks and techniques to support
    the development of client-side applications. We want a framework to be flexible
    while at the same time refraining from over-abstraction, which may be costly in
    terms of performance for our applications. On the other hand, our users expect
    an increased amount of interactivity that requires more and more complex application
    code to manage as the client-side applications grow.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 性能需求增加与灵活性需求之间的对比是驱动框架和技术的发展，以支持客户端应用程序的开发。我们希望框架在保持灵活性的同时避免过度抽象，这可能会在性能方面对我们的应用程序造成成本。另一方面，我们的用户期望有更多的互动，这需要越来越复杂的应用程序代码来管理，因为客户端应用程序的规模不断增长。
- en: Different frameworks and their implications
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不同框架及其影响
- en: The world of JavaScript frameworks is very vast, new frameworks with different
    promises are released constantly and abandoned constantly as well. All frameworks
    have their use cases and, while advocating different architectures, all consider
    providing a way to organize your JavaScript application essential.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript框架的世界非常广阔，不断发布和放弃具有不同承诺的新框架。所有框架都有它们的用例，并且，虽然提倡不同的架构，但都考虑提供组织JavaScript应用程序的方式是必不可少的。
- en: On one side, there are small frameworks, or micro-frameworks, that are almost
    library-like, providing just a bare minimum of organization and abstraction. The
    most well known and probably most widely used of these is Backbone. The goal is
    to provide a way to route a user on the client side—handling the URL, and rewriting
    and updating the application state in the browser. On the other hand, the state
    is encapsulated into models, providing and abstracting the data access to the
    internal client-side state, as well as the remote server-side state, so a sync
    of these two can be managed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，有一些小型框架或微框架，几乎像库一样，只提供最基本的组织和抽象。其中最知名且可能是最广泛使用的是Backbone。目标是提供一种在客户端路由用户的方式——处理URL，并在浏览器中重写和更新应用程序状态。另一方面，状态封装到模型中，提供和抽象对内部客户端状态的数据访问，以及远程服务器端状态，因此可以管理这两者的同步。
- en: On the other end of the spectrum, we find larger application frameworks, a popular
    one being Ember, providing a more integrated development experience in the browser.
    Handling data sync, routing too many different controllers in application pages,
    as well as an advanced view layer rendering different objects to the browser via
    templates including data binding between the interface and the backend model representation.
    This is very much along the lines of the old school approach of Smalltalk, such
    as the Model View Controller pattern.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在光谱的另一端，我们发现更大的应用程序框架，其中一个流行的是Ember，在浏览器中提供更集成的开发体验。处理数据同步，在应用程序页面中处理太多不同的控制器，以及通过模板将不同的对象呈现到浏览器的高级视图层，包括界面和后端模型表示之间的数据绑定。这在很大程度上符合Smalltalk的老派方法，比如模型视图控制器模式。
- en: 'A simple application using Ember for giving names to our orcs could work like
    this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ember为我们的兽人命名的简单应用程序可能是这样的：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A top-level application manages the context, and we then define routes and
    controllers like we do in most MVC applications. This model scales quite well
    and allows for very different applications. The advantage is that we can rely
    a lot on prebuilt infrastructure. For example, in the preceding code, the wiring
    between the route and the controller can be setup quite easily, with the declarative
    assigning `templateName` and `controllerName` to use. Also, the wiring with the
    view is almost done, allowing us to define the main application template as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级应用程序管理上下文，然后我们定义路由和控制器，就像大多数MVC应用程序中所做的那样。这种模型相当适用，并允许非常不同的应用程序。优点是我们可以很大程度上依赖预构建的基础设施。例如，在前面的代码中，路由和控制器之间的连接可以相当容易地设置，通过声明性地分配`templateName`和`controllerName`来使用。此外，与视图的连接几乎已经完成，允许我们定义主应用程序模板如下：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using `Handlebars.js` for templating, and using the `preassign` model for interaction,
    Ember is designed to scale quite large frontend applications, taking over the
    browser interactions and providing a complete application framework.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Handlebars.js`进行模板化，并使用`preassign`模型进行交互，Ember被设计为能够扩展非常大的前端应用程序，接管浏览器交互并提供完整的应用程序框架。
- en: Along the lines of this, we can find almost everything in between. In a world
    of domain-driven development, we now have to choose what best suits our application
    and our style of development. It may seem like a smaller framework is better suited
    to domain-driven design, as it allows the developer to have more influence, this
    is not necessarily the case. The important thing for us should be the way we can
    hook into the framework. The same way we interact with it server-side, we want
    to abstract our code as simple JavaScript objects, seeing the framework as a layer
    for us to get the content for the user displayed and the input from the user back
    in our domain layer. We want our domain layer to be separated from the framework
    as best as possible. With the growing prevalence of model-view-controller and
    alike organizations in today's developments, the frameworks allow for a better
    separation organization-wise as long as we don't fall into the trap of developing
    around the framework, but stick with the discussed organization as plain objects
    outside the framework hooking in to the framework as an implementation of a needed
    functionality.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，我们几乎可以找到中间的一切。在领域驱动开发的世界中，我们现在必须选择最适合我们的应用程序和我们的开发风格。似乎较小的框架更适合领域驱动设计，因为它允许开发人员有更多的影响力，但这未必是真的。对我们来说重要的是我们如何与框架进行连接。就像我们在服务器端与之交互一样，我们希望将我们的代码抽象为简单的JavaScript对象，将框架视为一个层，用于获取用户显示的内容和用户输入返回到我们的领域层。我们希望我们的领域层尽可能地与框架分离。随着当今开发中模型-视图-控制器等组织形式的普及，只要我们不陷入围绕框架开发的陷阱，而是坚持讨论的组织形式，作为框架所需功能的实现方式，框架允许更好地进行组织上的分离。
- en: Rendering on the client side
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在客户端渲染
- en: Depending on the application we are developing, going for a full client-side
    application might not be the way to go. Most business applications are, in the
    end, very task oriented, manipulating data via forms and triggering some logic
    based on this input. The result of the operations is then reflected in a document-like
    fashion. This represents how most business is done, it involves a process to accomplish
    a task, and ends with a report. Thinking about the application we have been working
    on throughout the book, we see a similar pattern. The part of the application
    we have been working on the most consists of several steps involving the dungeon
    master triggering a certain action by filling in details about a transport that
    is supposed to take place. The backend then decides if the conditions are met
    and if the request can be fulfilled and triggers the appropriate action. Most
    of the logic lives on the server side of the application, and due to consistency
    concerns, needs to live there as well. On the other hand, the client side is very
    form-oriented, the tasks involve one or more form steps that need to be accomplished
    according to the process for a given task. The logic for the process and the task
    is on the server, so a full client-side application will need to duplicate a lot
    of the server knowledge to give a client-side application feeling, but then we
    will still need to check with the backend for confirmation. This obviates the
    benefit of moving logic to the client side to a large degree.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们正在开发的应用程序，完全采用客户端应用程序可能不是最佳选择。大多数业务应用程序最终都是非常任务导向的，通过表单操作数据，并根据此输入触发一些逻辑。操作的结果然后以类似文档的方式反映出来。这代表了大多数业务的做法，它涉及一个过程来完成一个任务，并以报告结束。考虑一下我们在整本书中一直在开发的应用程序，我们会发现一个类似的模式。我们一直在开发的应用程序的一部分包括几个步骤，涉及地牢主持人通过填写有关即将发生的运输的细节来触发某个特定操作。然后后端决定是否满足条件，是否可以满足请求，并触发适当的操作。大部分逻辑都存在于应用程序的服务器端，并且由于一致性问题，也需要在那里存在。另一方面，客户端非常注重表单，任务涉及一个或多个表单步骤，需要根据给定任务的流程来完成。流程和任务的逻辑在服务器端，因此完全采用客户端应用程序将需要复制大量服务器知识，以给予客户端应用程序的感觉，但然后我们仍然需要与后端进行确认。这在很大程度上消除了将逻辑移动到客户端的好处。
- en: 'In situations like this, a middle ground approach can make a lot of sense,
    ensuring that the advanced debugging capabilities and monitoring of the server
    side can be leveraged while still giving a more fluid feeling to the application.
    The idea is to render the snippets of HTML to be placed on the page, but place
    them on the page via JavaScript, making full page replacements unnecessary. The
    most common library used to achieve this is **pjax** for requesting the HTML snippets,
    which in turn uses jQuery to place the snippets on the page:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，采用一种折中的方法是很有道理的，可以确保利用服务器端的高级调试功能和监控，同时仍然使应用程序具有更流畅的感觉。这个想法是渲染要放在页面上的HTML片段，但是通过JavaScript将它们放在页面上，从而避免完全替换整个页面。最常用的库用于实现这一点是**pjax**，用于请求HTML片段，它又使用jQuery将片段放在页面上：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The pjax requires the server to send an HTML snippet to be placed on a page
    as the result for a request in this example. It is just a paragraph tag containing
    some information about a Rambo movie:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，pjax需要服务器发送一个HTML片段，作为请求的结果放在页面上。这只是一个包含有关Rambo电影的一些信息的段落标签：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On the client side, we only need to let pjax highjack all the links inside the
    container, making it sent a pjax request and insert the appropriate content. The
    end result is a page that acts like a normal HTML page with links, but the page
    will not totally refresh on a click. It will just reload the appropriate piece
    and update the window location.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，我们只需要让pjax劫持容器内的所有链接，使其发送一个pjax请求并插入适当的内容。最终结果是一个表现得像一个普通HTML页面的页面，但是在点击时不会完全刷新。它只会重新加载适当的部分并更新窗口位置。
- en: This approach can be very useful when building server-heavy apps and still being
    able to maintain a fluid app-like interface without a lot of the build overhead
    involved in full client-side rendering. Again, we can see a big difference here,
    making the frontend more of a thin client, therefore this is maybe not a prime
    candidate for a domain-driven approach, but working closely with a backend build
    using such an approach because it now is the single source of truth about the
    application logic in general.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建服务器密集型应用程序并且仍然能够维护类似应用程序的流畅界面而不需要大量的完全客户端渲染开销时，这种方法可能非常有用。再次，我们可以看到这里有很大的区别，使得前端更像是一个轻客户端，因此这可能不是面向域驱动的首选方法，但是与使用这种方法构建的后端密切合作，因为它现在是关于应用程序逻辑的单一真相来源。
- en: Using JavaScript server side
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务器端使用JavaScript
- en: JavaScript as a language, even though it has been developed for the browser,
    is not bound to only being executed in a browser context. A browser just naturally
    contains an environment for the execution of JavaScript in the context of a page.
    When we want to run JavaScript outside the browser, there is always the option
    to just execute it directly via a JavaScript engine. There are multiple different
    engines available, such as **Spidermonkey** from Mozilla or **V8** from Google.
    Just having JavaScript available is obviously not enough, so we need access to
    files, sockets, and a multitude of other things to be able to productively work
    with server-side code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript作为一种语言，尽管它是为浏览器开发的，但并不仅限于在浏览器上下文中执行。浏览器自然包含了一个用于在页面上下文中执行JavaScript的环境。当我们想要在浏览器之外运行JavaScript时，总是有直接通过JavaScript引擎执行的选项。有多种不同的引擎可用，例如Mozilla的Spidermonkey或Google的V8。显然，仅仅拥有JavaScript是不够的，因此我们需要访问文件、套接字和其他许多其他东西，以便能够有效地处理服务器端代码。
- en: 'Node.js has taken over this part, bundling the Google V8 engine with the standard
    POSIX functions for access to the system-level part. It is by no means the first,
    there is also **Rhino** from Mozilla, bundling the Java ecosystem with Java for
    allowing access to all the parts outside the JavaScript standard library:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js接管了这一部分，将Google V8引擎与标准的POSIX函数捆绑在一起，用于访问系统级部分。这绝不是第一个，还有来自Mozilla的Rhino，将Java生态系统与Java捆绑在一起，以允许访问JavaScript标准库之外的所有部分：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The same thing in Node.js looks a little different, and a little bit more like
    what we expect from JavaScript:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，同样的事情看起来有些不同，更像我们从JavaScript期望的：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With the basics of interaction being available, we can build complex server-side
    applications and leverage the nature of server-side development where it makes
    sense, as we have done throughout the book.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有了交互的基础，我们可以构建复杂的服务器端应用程序，并利用服务器端开发的特性，这在书中一直都有。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In the upcoming ECMAScript 6 standard, a new module syntax will be introduced
    to increase the modularity of JavaScript applications both on the client and server
    side. ECMAScript 6 is almost finished, but at the time of writing it was not available
    everywhere. A good source for upcoming changes, and explicitly for the ECMAScript
    6 modules, is [http://www.2ality.com/2014/09/es6-modules-final.html](http://www.2ality.com/2014/09/es6-modules-final.html).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将推出的ECMAScript 6标准中，将引入一种新的模块语法，以增加客户端和服务器端JavaScript应用程序的模块化。ECMAScript 6几乎已经完成，但在撰写本文时还没有到处都可用。关于即将到来的变化，特别是关于ECMAScript
    6模块的一个很好的信息来源是[http://www.2ality.com/2014/09/es6-modules-final.html](http://www.2ality.com/2014/09/es6-modules-final.html)。
- en: The advantages of a controlled environment
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 受控环境的优势
- en: The reason large parts of the book rely on Node.js as the execution environment
    is the fact that it provides a fixed set of features we can count on. The browser,
    on the other hand, has always been very flexible and changeable. This is a big
    advantage when it comes to the development of business applications. As developers,
    we of course always want to leverage the latest and greatest, and it can make
    a lot of sense to rely on these technologies where it makes sense, but we also
    need to be aware of where a stable platform is of a big advantage.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的大部分依赖Node.js作为执行环境的原因是它提供了一组我们可以依赖的固定功能。另一方面，浏览器一直非常灵活和可变。这在开发业务应用程序时是一个很大的优势。作为开发人员，我们当然总是希望利用最新和最好的技术，而在合适的地方依赖这些技术是很有意义的，但我们也需要意识到稳定的平台在很大程度上是一个巨大的优势。
- en: If we want to model the business logic of an application, we hardly count on
    any new technologies. We need a stable environment where we can execute what we
    have and what is here to stay. The advantage of JavaScript, of course, is that
    we can execute on the client and the server side, which means that if we later
    decide to roll certain logic onto the client side, we can do so, and still fall-back
    to server-side execution of the rules for verification, if needed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要建模应用程序的业务逻辑，我们几乎不依赖于任何新技术。我们需要一个稳定的环境，可以执行我们已有的内容和将来会保留的内容。当然，JavaScript的优势在于我们可以在客户端和服务器端执行，这意味着如果我们以后决定将某些逻辑转移到客户端，我们可以这样做，并且仍然可以回退到服务器端执行规则以进行验证，如果需要的话。
- en: Advanced modularization
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级模块化
- en: In the past, JavaScript has always been known as the browser language and, for
    the longest time, loading scripts was outside of the scope of the language itself,
    but was handled by the HTML part of the environment via script tags.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，JavaScript一直被称为浏览器语言，而且在很长一段时间内，加载脚本是超出语言本身范围的，而是由环境的HTML部分通过脚本标签处理的。
- en: The rise of more advanced applications on the client side and the rise of server-side
    JavaScript has changed the language. This is evolving to include a module standard
    in the next version. For now, there are multiple ways to load other resources
    and to use one of them is a good idea, what exactly is most likely not important.
    The important bit here is that loading external modules allows us to better separate
    our code into logical units, getting away from the 1000+ lines file a lot of the
    client-side JavaScript programs look like. On the server side, this is a solved
    problem and the client side is not far behind.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端更高级应用程序的崛起和服务器端JavaScript的崛起改变了语言。这种语言正在发展，下一个版本将包括一个模块标准。目前，有多种加载其他资源的方式，使用其中一种是个好主意，具体是什么并不重要。重要的是，加载外部模块使我们能够更好地将代码分离成逻辑单元，摆脱了许多客户端JavaScript程序看起来像1000多行文件的情况。在服务器端，这个问题已经解决，而客户端还没有远远赶上。
- en: With these different kinds of JavaScript programs and challenges in mind, we
    can think about what we are aiming for when designing a business application in
    general and how we have seen domain-driven design take a role in the development
    process.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些不同类型的JavaScript程序和挑战，我们可以思考在设计业务应用程序时我们的目标是什么，以及我们如何看待领域驱动设计在开发过程中的作用。
- en: The different kinds of complexity
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的复杂性
- en: Every business application is faced with different kinds of problems throughout
    the development. The goal of domain-driven design is to isolate the complexity
    of an application, making it easy to change and maintain, by providing a language
    as well as a set of rules for the interaction of objects in the domain.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每个业务应用程序在开发过程中都面临着不同类型的问题。领域驱动设计的目标是通过提供一种语言以及一组对象在领域中的交互规则，来隔离应用程序的复杂性，使其易于更改和维护。
- en: As we have seen throughout the book, domain-driven design is all about modeling
    business logic, so it can be accessible for domain experts to judge and evaluate.
    This is an important part of an application and, if done right, it can save a
    lot of trouble throughout the development cycle. When driving an application through
    domain-driven design, we need to identify the core domain and its subdomains.
    Depending on what our domain is about, the pure business complexity that is there
    to model is, not the only complexity so.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在整本书中所看到的，领域驱动设计的核心是建模业务逻辑，以便领域专家可以评判和评估。这是应用程序的重要部分，如果做得好，可以在整个开发周期中节省很多麻烦。在通过领域驱动设计驱动应用程序时，我们需要确定核心领域及其子领域。根据我们的领域是什么，纯粹的业务复杂性是需要建模的，但不是唯一的复杂性。
- en: Neither is every application complex for the business rules, nor does every
    application lend itself nicely to being modeled in an object-oriented approach
    like we've seen throughout. There are complexities that are of a different nature,
    more often closer to what the hard computer science thinks about as its core problem
    domain, and as with every domain it has its specific ways to talk and model those
    parts very, clearly and we should use this as well when we come across it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个应用程序都对业务规则复杂，也并非每个应用程序都适合以我们之前所见的面向对象的方式进行建模。有一些复杂性是不同性质的，更接近于计算机科学所考虑的核心问题领域，就像每个领域一样，它有自己特定的交流和建模方式，当我们遇到时，我们也应该使用这些方式。
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Making computer science another business domain is a way of abstracting away
    the intricacies that we come across when dealing with computer science problems.
    More often than not, trying to expose these problems to the business domain itself
    is not useful and will lead to more confusion. We can think about computer-science
    related topics just as a core we interact with to solve very specific problems
    and develop it as such if we want to isolate it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将计算机科学作为另一个业务领域是一种抽象化处理我们在处理计算机科学问题时遇到的复杂性的方式。往往，试图将这些问题暴露给业务领域本身是没有用的，只会导致更多的混乱。我们可以将与计算机科学相关的主题看作是我们与之交互以解决非常具体问题的核心，如果我们想要隔离它，就应该以这种方式发展它。
- en: Algorithmic complexity
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法复杂性
- en: '|   | *In mathematics and computer science, an algorithm (i/ˈælɡərɪðəm/ AL-gə-ri-dhəm),
    is a self-contained step-by-step set of operations to be performed.* |   |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| *在数学和计算机科学中，算法是一组自包含的逐步操作。* |'
- en: '|   | --*Wikipedia* |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| --*维基百科* |'
- en: At their core, all the things we do can be described as algorithms. They may
    be very short and very unique, but they are a sequence of steps nonetheless. We
    have encountered algorithms in our business applications as a sequence of steps
    that have to take place to initiate the prisoner transport, for example. The algorithms
    we encountered are business rules, and best modeled as part of the domain itself
    since they involve the domain objects directly. However, there are other algorithms
    that we may reuse from mathematics or computer science that are more abstract
    and therefore don't fit well in the business domain.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，我们所做的一切都可以描述为算法。它们可能非常简短和独特，但它们仍然是一系列步骤。例如，我们在业务应用程序中遇到的算法是必须执行的一系列步骤，比如启动囚犯运输。我们遇到的算法是业务规则，并且最好作为领域本身的一部分进行建模，因为它们直接涉及领域对象。然而，还有其他算法，我们可以从数学或计算机科学中重用，它们更抽象，因此不太适合业务领域。
- en: When we talk about algorithmic complexity, we most often refer to well-known
    algorithms such as tree-searching or algorithmic data structures such as lists
    or skip-lists. These kind of abstract ideas don't lend themselves well to fitting
    into the domain we are modeling, but are somewhere outside. When we encounter
    a problem in the domain and it is well served by a known algorithm, we should
    take advantage of that fact and not muddy the domain with such knowledge but keep
    it separate.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论算法复杂性时，我们最常指的是众所周知的算法，如树搜索或算法数据结构，比如列表或跳表。这些抽象的想法不太适合适应我们正在建模的领域，而是在某种程度上是外部的。当我们在领域中遇到问题，并且已知算法能够很好地解决问题时，我们应该利用这一事实，而不是用这些知识混淆领域，而是保持分开。
- en: There are applications, which are bound to have a high algorithmic complexity,
    and these are most likely not prime candidates for domain-driven design. An example
    for this may be search, where a lot of knowledge resides in the data structures
    making searching efficient and therefore useable on a larger scale. The important
    idea is that in such domains, the business experts are the developers and we should
    treat the domain in such a way that the developers can communicate best. The most
    fundamental idea stays the same—that we may want to foster communication through
    common terms, but in such a case, the common terms are developer specific, and
    the best way to express it is in code, so the approach is to write code and try
    it out.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些应用程序，它们的算法复杂度很高，这些应用程序很可能不是领域驱动设计的最佳候选。一个例子是搜索，其中很多知识都存在于数据结构中，使得搜索变得高效，因此可以在更大范围内使用。重要的想法是，在这样的领域中，业务专家就是开发人员，我们应该以开发人员最擅长的方式处理领域。最基本的想法仍然是一样的——我们可能希望通过共同术语促进沟通，但在这种情况下，共同术语是开发人员特定的，最好的表达方式是通过代码，因此方法是编写代码并尝试。
- en: Logical complexity
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑复杂度
- en: Another field closely related to algorithmic problems is logical problems. Depending
    on the domain, these can appear frequently and with a varying degree of complexity.
    A good example for such problems are configurators of any type, for example, an
    application allowing you to order a car involves the problem that the extras can
    conflict. Depending on how many different extras and conflicts there are, the
    problem can get out of hand quickly.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与算法问题密切相关的另一个领域是逻辑问题。根据领域的不同，这些问题可能经常出现，并且具有不同程度的复杂性。这类问题的一个很好的例子是任何类型的配置器，例如，一个允许您订购汽车的应用程序涉及到额外选项可能会发生冲突的问题。根据不同的额外选项和冲突的数量，问题可能会迅速失控。
- en: 'In logical programming, we state facts and let the engine derive possible solutions
    for us:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在逻辑编程中，我们陈述事实，让引擎为我们推导可能的解决方案：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding example, the configurator is backed by a rules engine, which
    allows it to determine potential conflicts in the configuration and reports them
    back to the user. For this to work, we create a list of facts or constraints:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，配置器由规则引擎支持，这使得它能够确定配置中的潜在冲突并将其报告给用户。为了使其工作，我们创建了一个事实或约束的列表：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With this, a rules engine can check if the constraints are satisfied when we
    want to order the car.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一点，规则引擎可以在我们想要订购汽车时检查约束是否满足。
- en: Solving logical problems in applications is similar to algorithmic ones, best
    suited for a separate system built for that purpose, exposing a domain-specific
    logical language to express the problem clearly in logical terms, which is then
    wrapped in the domain.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中解决逻辑问题类似于解决算法问题，最适合于为此目的构建一个独立的系统，以领域特定的逻辑语言清晰地表达问题，然后将其包装在领域中。
- en: The business rules
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 业务规则
- en: As we develop the business software, the complexities we are faced with most
    often are the business rules defined by the clients to which we develop the software.
    The complexity in these rules often does not stem from the fact that the rule
    itself has a high complexity, but the fact that the rules are not set in stone
    and the behavior can change. More importantly, it needs to change quickly to keep
    the software relevant for the business.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发业务软件时，我们最常面对的复杂性通常是客户定义的业务规则，我们为其开发软件。这些规则的复杂性往往不是因为规则本身很复杂，而是规则并不是一成不变的，行为可能会改变。更重要的是，它需要快速改变，以使软件对业务保持相关。
- en: Implementing business rules means tracking what the business needs to do, and
    this is more often than not based on facts in the head of the business domain
    experts. The important part of modeling the domain is extracting this knowledge,
    and verifying its validity with the business as a whole. This is the area where
    a solid domain model strives to make a difference.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 实施业务规则意味着跟踪业务需要做什么，这往往是基于业务领域专家头脑中的事实。对于建模领域的重要部分是提取这些知识，并与整个业务验证其有效性。这是一个坚实的领域模型努力产生差异的领域。
- en: When we are able to talk about the domain with the person who understands the
    domain best, we can verify quickly, and if we share a common language with this
    person, he or she can quickly explain to us new rules going forward. Often, complex
    data structures and algorithms are not the central part of building, such as an
    application, these pieces can be optimized by an external providing system, the
    understanding and flexible modeling of the domain is the power of a domain model.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们能够与最了解领域的人谈论领域时，我们可以快速验证，如果我们与这个人分享共同的语言，他或她可以快速向我们解释新的规则。通常，复杂的数据结构和算法并不是构建应用程序的核心部分，这些部分可以通过外部提供系统进行优化，对领域的理解和灵活的建模是领域模型的力量。
- en: The domains suitable for domain-driven design
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适合领域驱动设计的领域
- en: Throughout this book, we focused on building a business application, which in
    essence makes sure we don't over or under book our dungeon, and more specifically
    to manage the transfer of prisoners that need to be moved due to the constraints
    of the dungeon. We, as developers, had to rely heavily on the domain experts guiding
    us through the development, as we don't have the necessary knowledge of the business
    domain, yet. In this kind of scenario, the establishment of a language comes in
    very handy as it allows us to talk in a precise manner about what the problems
    are and how we can deal with new rules, from then on.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们专注于构建一个业务应用程序，从本质上来说，这确保我们不会过度或不足地预订我们的地牢，更具体地管理因地牢的限制而需要转移的囚犯。作为开发人员，我们必须严重依赖领域专家指导我们开发，因为我们还没有业务领域的必要知识。在这种情况下，建立一种语言非常方便，因为它允许我们以精确的方式讨论问题所在以及我们如何处理新规则。
- en: Previously, we have seen that not all domains lend themselves nicely to such
    a strategy, and even domains that do may contain parts that are best handled by
    secondary systems. Especially when starting out with a new project, we cannot
    be sure if it makes sense to invest in a heavy domain layer or not.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们已经看到并非所有领域都适合这种策略，即使适合的领域中也可能包含最好由辅助系统处理的部分。特别是在启动新项目时，我们无法确定是否值得投资于繁重的领域层。
- en: Banking applications
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 银行业应用
- en: A domain that is well specified, has a fixed ruleset, and is largely dealing
    with number should be a prime candidate for being served by well-developed software,
    so why is there not much accounting software out there, and why are the banks
    investing so heavily in their development teams?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个规范良好，有固定规则集，并且主要涉及数字的领域应该是由成熟软件服务的主要候选者，那么为什么会计软件并不多见，为什么银行要如此大力投资于他们的开发团队呢？
- en: A lot of people explore accounting problems from a domain-driven perspective,
    and the problems arise around similar areas. The first is the set of rules, even
    though the rules seem well defined from the outside, they contain a lot of edge
    cases that need to be covered, and covered correctly, as, by its nature, large
    amounts of money are moving through the system. These rules are largely known
    by a set of experts whose job it is to adjust them every time a change in market
    makes it necessary. This brings us to the second problem, a lot of very subtle
    changes need to be expressed and kept consistent across the system.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人从领域驱动的角度探索会计问题，问题主要出现在类似的领域。首先是一系列规则，尽管这些规则从外部看似乎定义得很好，但实际上包含许多需要覆盖并且正确覆盖的边缘情况，因为大量资金正在系统中流动。这些规则大部分由一组专家所知，他们的工作是在市场变化时调整这些规则。这带来了第二个问题，许多非常微妙的变化需要在整个系统中表达并保持一致。
- en: So, even though on the surface it seems that a relational database covers a
    lot of the cases in a banking application, the required agility for change and
    the intrinsic need for a lot of communication with banking experts makes banking
    a good candidate for applications following domain-driven design, if they indeed
    want to start a new development.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管表面上看来，关系数据库覆盖了银行应用中的许多情况，但对于变化所需的灵活性以及与银行专家进行大量沟通的内在需求使得银行成为领域驱动设计应用的一个很好的候选者，如果他们确实想要开始新的开发。
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Banking is one of those domains better left to the experts. If there is no need
    to build your own accounting system, it's better to buy one of the shelf as the
    domain complexity and probability for error is very high.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 银行业是那些最好由专家来处理的领域之一。如果没有必要构建自己的会计系统，最好购买现成的系统，因为领域的复杂性和错误的可能性非常高。
- en: Travel applications
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旅行应用
- en: Throughout the book, we have been following a domain related to another prime
    candidate for domain-driven design, travel, and related booking management. Comparing
    a dungeon to a hotel may seem a little weird, but from a software point of view,
    the management is similar. We are trying to manage over- and underbooking while
    at the same time optimizing revenue.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直在关注与另一个领域驱动设计的主要候选者相关的领域，即旅行和相关预订管理。从软件角度来看，将地牢与酒店进行比较可能有点奇怪，但管理方式是相似的。我们试图在同时优化收入的同时管理过度预订和不足预订。
- en: Booking hotels is one of those domains that seem simple and well-defined on
    the surface, but are prone to many adjustments and complex rules when digging
    deeper. It will, for example, be quite easy to completely avoid overbooking when
    looking at database entries appropriately, but then again, this goes against the
    goal of maximizing revenue for our hotel. There is a certain amount of overbooking
    required for compensating the eventual dropping-out of guests.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 预订酒店是一个表面上看起来简单而明确定义的领域，但在深入挖掘时容易出现许多调整和复杂规则。例如，当适当查看数据库条目时，完全避免过度预订会相当容易，但这又违反了我们酒店最大化收入的目标。为了补偿最终客人的退出，需要一定数量的过度预订。
- en: This is not the only complex part of managing bookings, an important part of
    the business is adjusting to the season and the current market situation. Booking
    a hotel while a tradeshow is in town can be significantly more expensive than
    on a regular day, especially if not booked for the entire duration of the tradeshow
    since this would mean a room might stay empty even though it could have been booked
    easily when it was available for the entire timespan. On the other hand, partner
    discounts can make booking during these shows cheaper again for certain people,
    and we want to make sure that a certain amount of rooms are available for these
    people when booking other guests. All bookings also have multiple timelines that
    need to be managed, such as discount windows, refund windows, and more.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是管理预订的唯一复杂部分，业务的一个重要部分是适应季节和当前的市场情况。在城市举办贸易展时预订酒店可能会比普通日子显著更昂贵，特别是如果没有预订整个贸易展的时间，因为这意味着房间可能会空着，即使在整个时间段内可以轻松预订。另一方面，合作伙伴折扣可能使这些展会期间的预订对某些人再次变得更便宜，我们希望确保在预订其他客人时有一定数量的房间可供这些人使用。所有预订还有多个需要管理的时间表，例如折扣窗口，退款窗口等。
- en: What makes travel even more interesting for domain-driven design, in recent
    years, is that the representation evolves a lot as well. While previously the
    systems were optimized to be worked by phone or by a small amount of booking agents,
    they started to be exposed to the general public via the web. This exposure led
    to a significant increase in requests and also increased the support needed. Even
    more recently, the systems are no longer operated directly, but needed to be accessible
    via APIs to be integrated into search engines.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，使旅行更加有趣的领域驱动设计的原因是，其表示也在很大程度上发展。以前，系统被优化为通过电话或少量预订代理人操作，现在开始通过网络向公众开放。这种暴露导致请求量显著增加，也增加了所需的支持。甚至最近，这些系统不再直接操作，而是需要通过API访问以集成到搜索引擎中。
- en: All this makes travel complex, and way more than a store and load action from
    the database; especially, since the integration of many systems in combination
    with general public access puts a huge burden on the developed system's ability
    to grow and scale, not only in their performance, but more importantly in their
    complexity.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都使旅行变得复杂，远不止是从数据库中存储和加载操作；特别是，由于许多系统的集成与一般公众的访问结合在一起，对开发系统的能力来说不仅在性能方面，更重要的是在复杂性方面都带来了巨大的负担。
- en: The domain prerequisites
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域先决条件
- en: The domains we have been looking at all involve different forms of complexity
    in the business areas that are served well using a domain-driven design approach.
    In the previous sections, we have seen a couple of domains suited well to this
    approach. What do they have in common?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在研究的领域都涉及业务领域中不同形式的复杂性，这些领域都适合使用域驱动设计方法。在前面的章节中，我们已经看到了一些适合这种方法的领域。它们有什么共同之处？
- en: As seen before, it is all about the different forms of complexity we need to
    approach. A domain that is moving fast in its business rule set needs more attention
    toward its modeling because rules need to be adjusted as they evolve. Even more
    importantly, evolving rules mean that the developers don't have a complete understanding
    of the rules, so the business experts need to be involved heavily. This means
    that the language we are building in domain-driven design pays off quickly. Therefore,
    one important part of domain-driven design is that it is about developer access
    and the ability to understand the domain. We want to be able to quickly get business
    experts integrated in the process to avoid misunderstanding. The business experts,
    in the end, are the ones who drive the domain. We, as developers, provide the
    software that allows the business to be more successful at what it does. As a
    part of our domain-driven design approach, we identified what really matters to
    the business now and how it can be made more efficient and less error-prone.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所见，这一切都关乎我们需要解决的不同形式的复杂性。业务规则集快速变化的领域需要更多关注其建模，因为规则需要随着演变而调整。更重要的是，不断演变的规则意味着开发人员并不完全了解规则，因此业务专家需要大量参与。这意味着我们在域驱动设计中构建的语言很快就会得到回报。因此，域驱动设计的一个重要部分是它关乎开发人员的访问和理解领域的能力。我们希望能够迅速将业务专家整合到流程中，以避免误解。最终，业务专家是推动领域发展的人。我们作为开发人员，提供的是使业务更成功的软件。作为我们域驱动设计方法的一部分，我们确定了对业务现在真正重要的事情，以及如何使其更高效和更少出错。
- en: Approaching the problem from the other side now, and still considering access,
    means access to the system from other systems needs to be simple. At the moment,
    this is true for a lot of domains with new devices being popular all the time
    and business in general driving towards a higher level of integration in a business-to-business
    environment. How does domain-driven design fit in there? The key again is access.
    We want to be able to provide multiple interfaces that are accessible from the
    outside, with the same underlying logic. In domain-driven design, we are all about
    building a strong service layer, and this layer can then be exposed to different
    systems via different interfaces without the need to duplicate logic, which will
    inherently risk a divergence of the parts and logic.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从另一方面来看问题，仍然考虑访问，意味着其他系统对系统的访问需要简单。目前，这对许多领域来说是真实的，因为新设备不断流行，业务普遍朝着更高级别的业务集成发展。域驱动设计如何适应其中？关键再次是访问。我们希望能够提供多个可从外部访问的接口，具有相同的基本逻辑。在域驱动设计中，我们致力于构建强大的服务层，然后可以通过不同的接口将该层暴露给不同的系统，而无需复制逻辑，这将固有地增加部分和逻辑的分歧风险。
- en: Further reading
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'As the name of this book suggests, it is already heavily influenced by the
    ideas Eric Evans presented in his book *Domain-Driven Design: Tackling Complexity
    in the Heart of Software*, *Addison-Wesley*, and I would recommend this as a follow-up.
    He goes in to much more detail about the general approach by providing different
    examples and from the perspective of a classic Java backend approach.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书的书名所暗示的那样，它已经受到埃里克·埃文斯在他的书《领域驱动设计：软件核心复杂性的挑战》*Addison-Wesley*中提出的想法的重大影响，我建议这本书作为后续阅读。他通过提供不同的例子，从经典的Java后端方法的角度更详细地介绍了一般方法。
- en: Another book that should not be missing in any follow-up about software design
    is, of course, *Patterns of Enterprise Application Architecture*, *Martin Fowler*,
    *Addison-Wesley*, which follows most of the patterns used every day in object-oriented
    development and goes into more detail about the patterns in general. The book
    leans more heavily on the Java side, but as we have seen throughout this book,
    using JavaScript in an object-oriented way is very possible and will be recommended
    in a lot of the modeling scenarios.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一本关于软件设计的后续阅读中不应该缺少的书是当然《企业应用架构模式》*Martin Fowler*，*Addison-Wesley*，它遵循了大多数面向对象开发中每天使用的模式，并更详细地介绍了这些模式。该书更加侧重于Java方面，但正如我们在本书中所看到的，以面向对象的方式使用JavaScript是非常可能的，并且在许多建模场景中会被推荐。
- en: Summary
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With applications written in JavaScript becoming more and more complex, the
    need for stronger application design has increased. Browser applications are growing,
    and the business reliance on them grows as well. Due to this, what used to be
    a domain of backend development starts to become important in frontend development.
    For a long time now, people have been evolving the way backend applications can
    be modeled for flexibility, so they can grow with the business, and now browser
    applications need to do the same. There is a lot to learn from the approaches
    that have been developed over the years, and even though some are not directly
    transferable to JavaScript, or might not even be needed, the general ideas port
    over very well. I hope I was able to present some of these ideas throughout the
    book.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 随着用JavaScript编写的应用程序变得越来越复杂，对更强大的应用程序设计的需求也在增加。浏览器应用程序正在增长，企业对它们的依赖也在增加。因此，曾经是后端开发领域的东西开始变得在前端开发中变得重要起来。长期以来，人们一直在不断演变后端应用程序的建模方式，以便能够灵活发展业务，现在浏览器应用程序也需要做同样的事情。多年来已经开发出了很多方法，有很多值得学习的地方，尽管有些方法并不直接适用于JavaScript，甚至可能并不需要，但其中的一般思想非常适用。我希望我能在整本书中呈现一些这样的想法。
- en: On the other hand, with the rise and adoption of Node.js as a platform for application
    development, JavaScript has moved into the backend as well, and the same challenges
    that needed solving for Java or Ruby on the Rails backend systems, now need to
    be solved for JavaScript/Node.js. It is important to stay true to the nature of
    JavaScript, as with Node.js, the goal often is to make systems simpler and easier
    to manage in smaller chunks. This in turn means that a Node.js backend takes a
    lighter modeling approach than a classic enterprise Java system would have. This
    is empowering to the developers, as the overarching large-scale architecture discussions
    move toward a more practical approach being built bottom-up. This should not mean
    that architecture is not important, but with the split of complexity between frontend
    and backend systems, the complexity can be managed better with a lighter approach.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，随着Node.js作为应用程序开发平台的崛起和采用，JavaScript也进入了后端，现在需要解决与Java或Ruby on Rails后端系统相同的挑战，这些挑战现在需要为JavaScript/Node.js解决。重要的是要忠于JavaScript的本质，因为使用Node.js，目标通常是使系统更简单，更容易以更小的块进行管理。这反过来意味着Node.js后端采用了比传统的企业Java系统更轻的建模方法。这对开发人员来说是有力的，因为整体的大规模架构讨论朝着更实用的自下而上的方法发展。这并不意味着架构不重要，但是随着前端和后端系统之间复杂性的分离，采用更轻的方法可以更好地管理复杂性。
