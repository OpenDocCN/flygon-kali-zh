- en: Chapter 1. Java Language Improvements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。Java语言改进
- en: 'In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Using string literals in switch statements
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在switch语句中使用字符串字面量
- en: Using underscores in literals to improve code readability
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用下划线改进代码可读性的字面量
- en: Using the try-with-resources block to improve exception handling code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用try-with-resources块改进异常处理代码
- en: Creating a resource that can be used with the try-with-resources technique
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可与try-with-resources技术一起使用的资源
- en: Catching multiple exception types to improve type checking
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获多个异常类型以改进类型检查
- en: Re-throwing exceptions in Java 7
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java 7中重新抛出异常
- en: Using the diamond operator for constructor type inference
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`diamond`操作符进行构造类型推断
- en: Using the @SafeVarargs annotation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用@SafeVarargs注解
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: '**Java 7** was released in July of 2011 and introduced a number of new features.
    In the Java SDK documentation, you may see it referred to as **Java 1.7.** This
    chapter will focus on those that have been grouped as part of the Project Coin
    ([http://openjdk.java.net/projects/coin/](http://openjdk.java.net/projects/coin/)).
    **Project Coin** refers to the small language changes in Java 7 that are designed
    to make programs more readable by removing extra text when possible. The changes
    to the language do not involve modifying the **Java Virtual Machine** (**JVM**).
    These new features include:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 7**于2011年7月发布，引入了许多新功能。在Java SDK文档中，您可能会看到它被称为**Java 1.7**。本章将重点介绍作为Coin项目的一部分分组的功能（[http://openjdk.java.net/projects/coin/](http://openjdk.java.net/projects/coin/)）。**Coin项目**指的是Java
    7中设计为尽可能删除多余文本以使程序更易读的小语言更改。语言的更改不涉及修改**Java虚拟机**（**JVM**）。这些新功能包括：'
- en: The use of strings in switch statements
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在switch语句中使用字符串
- en: The addition of binary literals and the ability to insert underscores into numeric
    literals
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加二进制字面量和在数字字面量中插入下划线的能力
- en: The use of a multi-catch block
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重捕获块的使用
- en: The try-with-resources block
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: try-with-resources块
- en: Improved type inferences using the diamond operator
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`diamond`操作符改进类型推断
- en: Improvements in the use of methods with a variable number of arguments
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进了具有可变数量参数的方法的使用
- en: Since the inception of Java, only integer values could be used to control a
    switch statement. Strings can now be used and can provide a more convenient technique
    for controlling the execution flow that is based on a string. The *Using string
    literals in switch statements* recipe illustrates this feature.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java问世以来，只能使用整数值来控制switch语句。现在可以使用字符串，并且可以提供一种更方便的技术来控制基于字符串的执行流程。*在switch语句中使用字符串字面量*配方说明了这一特性。
- en: Underscores can now be used with literals as examined in the recipe *Using underscores
    in literals to improve code readability*. These can make a program more readable
    and maintainable. In addition, binary literals can now be used. Instead of using
    a hexadecimal literal, for example, the literal bit pattern can be used.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在字面量中使用下划线，如*使用下划线改进代码可读性的字面量*配方中所述。这些可以使程序更易读和易维护。此外，现在可以使用二进制字面量。例如，可以使用字面位模式，而不是使用十六进制字面量。
- en: New to Java 7 are the improved try-catch block mechanisms. These include the
    ability to catch more than one exception from a single catch block, and improvements
    in how exceptions can be thrown. The *Catching multiple exception types to improve
    type checking* recipe looks into these enhancements.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7中新增了改进的try-catch块机制。这包括从单个catch块中捕获多个异常的能力，以及如何抛出异常的改进。*捕获多个异常类型以改进类型检查*配方探讨了这些增强功能。
- en: Another improvement in exception handling involves the automatic closure of
    resources. In earlier versions of Java, when multiple resources were opened in
    a try block, it could be difficult to effectively close the resources, when an
    exception occurs. Java 7 provides a new technique as discussed in the *Using the
    try-with-resources block to improve exception handling code* recipe.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理的另一个改进涉及自动关闭资源。在早期版本的Java中，当在try块中打开多个资源时，当发生异常时有效关闭资源可能会很困难。Java 7提供了一种新技术，如*使用try-with-resources块改进异常处理代码*配方中所讨论的。
- en: 'To take advantage of this technique, a class representing a resource must implement
    the new `java.lang.AutoCloseable` interface. This interface consists of a single
    method, `close` which, when implemented, should release resources as needed. Many
    core Java classes have been augmented to do this. The recipe: *Creating a resource
    that can be used with the try-with-resources technique* illustrates how to do
    this for non-core classes.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用这种技术，表示资源的类必须实现新的`java.lang.AutoCloseable`接口。该接口由一个名为`close`的方法组成，当实现时，应根据需要释放资源。许多核心Java类已经增强了这一点。配方：*创建可与try-with-resources技术一起使用的资源*说明了如何为非核心类执行此操作。
- en: Java 7 provides the capability to re-throw exceptions in a flexible manner.
    It provides a more precise way of throwing exceptions, and more flexibility in
    how they can be handled in a try/catch bock. The *Re-throwing exceptions in Java
    7* recipe illustrates this capability.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7提供了以灵活的方式重新抛出异常的能力。它提供了一种更精确的抛出异常的方式，并在try/catch块中处理它们的灵活性更大。*在Java 7中重新抛出异常*配方说明了这一能力。
- en: When generics were introduced in **Java 1.5**, it became easier to write code
    to address a number of similar problems. However, its usage at times could become
    somewhat verbose. The introduction of the `diamond` operator has eased this burden,
    and is illustrated in the *Using the diamond operator for constructor type inference*
    recipe.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Java 1.5**引入泛型时，编写代码来解决许多类似问题变得更容易。然而，有时它的使用可能变得有些冗长。引入了`diamond`操作符减轻了这一负担，并在*使用`diamond`操作符进行构造类型推断*配方中进行了说明。
- en: When a method uses a variable number of generic arguments, sometimes an invalid
    warning is generated. The `@SafeVarargs` annotation has been introduced to flag
    a method as safe. This issue is related to heap pollution and is discussed in
    the *Using the @SafeVarargs Annotation* recipe.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法使用变量数量的泛型参数时，有时会生成无效的警告。`@SafeVarargs`注解已被引入以标记方法为安全。这个问题与堆污染有关，并在*使用@SafeVarargs注解*中进行了讨论。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this and the other chapters, most of the code examples will be written to
    execute from within a main method. While no specific **Integrated Development
    Environment** (**IDE**) is needed to use the new features of Java 7, the examples
    in this book were developed using **NetBeans 7.0.1** and **Windows 7**, unless
    otherwise noted. At minimum, a version of the **Java Development Kit** (**JDK**)
    **1.7** or later is needed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和其他章节中，大多数代码示例将被编写为从主方法中执行。虽然不需要特定的**集成开发环境**（**IDE**）来使用Java 7的新功能，但本书中的示例是使用**NetBeans
    7.0.1**和**Windows 7**开发的，除非另有说明。至少需要**Java开发工具包**（**JDK**）**1.7**或更高版本。
- en: Also, note that the code examples provided do not include `import` statements.
    These are not shown here to reduce the number of lines of code. Most IDEs make
    it easy to insert these imports, but you need to be careful that the correct imports
    are used.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意提供的代码示例不包括`import`语句。这里不显示这些内容是为了减少代码行数。大多数IDE都可以很容易地插入这些导入，但您需要小心使用正确的导入。
- en: Using string literals in switch statements
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`switch`语句中使用字符串文字
- en: The ability to use string literals in switch statements is new to Java 7\. Previously,
    only integer values were the valid arguments in a `switch` statement. It is not
    uncommon to need to make a decision based on a string value, and the use of a
    `switch` statement to perform this task can simplify the series of `if` statements
    that would otherwise be needed. This can result in more readable and efficient
    code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7中，使用字符串文字在`switch`语句中是新的。以前，`switch`语句中只有整数值是有效的参数。根据字符串值做出决定并使用`switch`语句执行此任务可以简化原本需要的一系列`if`语句。这可以导致更易读和更高效的代码。
- en: Getting ready
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'A selection based on a string value may occur in an application. Once such
    a situation is identified, do the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可能会基于字符串值进行选择。一旦识别出这种情况，执行以下操作：
- en: Create a `String` variable to be processed via the `switch` statement.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`String`变量，通过`switch`语句进行处理。
- en: Create the `switch` block, using string literals for the case clauses.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`switch`块，使用字符串文字作为case子句。
- en: Use the `String` variable to control the `switch` statement.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`String`变量来控制`switch`语句。
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The example demonstrated here will use a `switch` statement to process an application's
    command line arguments. Create a new console application. In the `main` method,
    we will use the `args` argument to process the application's command line arguments.
    Many applications allow command line arguments to customize or otherwise affect
    the operation of the application. In this example, our application will support
    a verbose mode, logging, and provide a help message regarding the valid command
    line arguments for the application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里演示的例子将使用`switch`语句来处理应用程序的命令行参数。创建一个新的控制台应用程序。在`main`方法中，我们将使用`args`参数来处理应用程序的命令行参数。许多应用程序允许使用命令行参数来自定义或以其他方式影响应用程序的操作。在这个例子中，我们的应用程序将支持详细模式、日志记录，并提供有关应用程序的有效命令行参数的帮助消息。
- en: 'In this example, create a class called `StringSwitchExample` that possesses
    three instance variables to be set by the command line arguments, shown as follows:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，创建一个名为`StringSwitchExample`的类，该类具有三个实例变量，可以通过命令行参数设置，如下所示：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载您购买的所有Packt图书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接发送到您的邮箱。
- en: 'Next, add the following `main` method, which will set these variables based
    on the command line arguments provided:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加以下`main`方法，它将根据提供的命令行参数设置这些变量：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following helper method to display the application setting:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下辅助方法来显示应用程序设置：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Execute the application using the following command line:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令行执行应用程序：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you are using an IDE, then there is usually a way to set the command line
    arguments. For example, in NetBeans, right-clicking on the project name in the
    **Project** window, and selecting **Properties** menu will open a **Project Properties**
    dialog box. In the **Run** category, the **Arguments** textbox allows you to set
    the command line arguments, as shown in the following screenshot:![How to do it...](img/5627_1_01.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用的是集成开发环境（IDE），通常有一种方法可以设置命令行参数。例如，在NetBeans中，右键单击**项目**窗口中的项目名称，然后选择**属性**菜单将打开**项目属性**对话框。在**运行**类别中，**参数**文本框允许您设置命令行参数，如下截图所示：![如何做...](img/5627_1_01.jpg)
- en: 'When the application is executed, your output should appear as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序被执行时，您的输出应该如下所示：
- en: '**Application Settings**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序设置**'
- en: '**Verbose: true**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**详细信息：true**'
- en: '**Logging: true**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**日志记录：true**'
- en: '**Help: false**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**帮助：false**'
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The application setting variables are all initialized to `false`. A for-each
    loop iterates through each command line argument. The `switch` statement uses
    a specific command line argument to turn on an application setting. The `switch`
    statement behaves like the earlier Java `switch` statements.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序设置变量都初始化为`false`。使用for-each循环遍历每个命令行参数。`switch`语句使用特定的命令行参数来打开应用程序设置。`switch`语句的行为类似于早期的Java`switch`语句。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is interesting to note that the Java Virtual Machine (JVM) currently provides
    no direct support for switching with strings. The Java compiler is responsible
    for converting strings in `switch` statements to the appropriate byte code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Java虚拟机（JVM）目前不直接支持使用字符串进行切换。Java编译器负责将`switch`语句中的字符串转换为适当的字节码。
- en: When the for loop completes, the `displayApplicationSettings` method is invoked.
    This displays the current application setting, reflecting the configuration specified
    by the command line arguments.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当`for`循环完成时，将调用`displayApplicationSettings`方法。这将显示当前的应用程序设置，反映了由命令行参数指定的配置。
- en: It is important to note, however, while a `String` variable may be passed to
    the `switch` statements, as with the other data types used in `switch` statements,
    the strings used in the case clauses must be string literals. The general rules
    regarding `switch` statements apply when using string literals. Each statement
    within the `switch` block must have a valid non-null label, no two labels may
    be identical, and only one default label may be associated with each `switch`
    block.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，虽然`String`变量可以传递给`switch`语句，但与`switch`语句中使用的其他数据类型一样，用于案例子句的字符串必须是字符串文字。在使用字符串文字时，适用于`switch`语句的一般规则。`switch`块中的每个语句必须具有有效的非空标签，不能有两个相同的标签，并且每个`switch`块只能关联一个默认标签。
- en: There's more...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When using strings, you need to be careful about the following two issues:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用字符串时，您需要注意以下两个问题：
- en: Null values for strings
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的空值
- en: The case of the string
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的情况
- en: 'Using a string reference variable that is assigned a null value will result
    in a `java.lang.NullPointerException`. See the *Handling null references* recipe
    in [Chapter 11](ch11.html "Chapter 11. Odds and Ends"), *Odds and Ends*, for more
    information on how to handle a `NullPointerException`. This is also true when
    used with a `switch` statement. Also, the evaluation of a case expression is case
    sensitive in a `switch` statement. In the previous example, if the command line
    argument is different from what appears in the case expression, then the case
    is skipped. If we had used the following command line instead, where we capitalized
    the word verbose:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个被赋予空值的字符串引用变量将导致`java.lang.NullPointerException`。有关如何处理`NullPointerException`的更多信息，请参阅[第11章](ch11.html
    "第11章。杂项")中的*处理空引用*配方，*杂项*。当与`switch`语句一起使用时，这也是真实的。此外，在`switch`语句中，对案例表达式的评估是区分大小写的。在前面的例子中，如果命令行参数与案例表达式中显示的内容不同，那么该案例将被跳过。如果我们使用以下命令行，其中我们将单词verbose大写：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then the verbose mode will no longer be used as indicated in the following
    output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，冗长模式将不再使用，如下面的输出所示：
- en: '**Application Settings**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序设置**'
- en: '**Verbose: false**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**冗长：假**'
- en: '**Logging: true**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**日志记录：真**'
- en: '**Help: false**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**帮助：假**'
- en: Using underscores in literals to improve code readability
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用下划线来改善代码的可读性
- en: Numerical literals can contain underscore characters (_) in Java 7\. This is
    intended to improve the readability of code by separating digits of a literal
    into significant groups at almost any arbitrary place that meets the needs of
    the developer. The underscore can be applied to primitive data types in any supported
    base (binary, octal, hexadecimal, or decimal), and to both integer and floating-point
    literals.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7中，数字文字可以包含下划线字符(_)。这旨在通过将文字的数字分成显著的组，在几乎任意满足开发人员需求的地方，来提高代码的可读性。下划线可以应用于任何支持的基数（二进制、八进制、十六进制或十进制）的原始数据类型，以及整数和浮点文字。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The first step is to identify instances where it will be beneficial for the
    developer to format literals in such a manner. Typically, you will want to identify
    longer numbers or numbers that would have significant parts in their external
    form, such as debit card numbers. The basic steps include:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是识别开发人员以这种方式格式化文字将有益的实例。通常，您会希望识别更长的数字或在其外部形式中具有显著部分的数字，例如借记卡号。基本步骤包括：
- en: Identify a literal to use with underscores.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别要与下划线一起使用的文字。
- en: Insert underscores at appropriate places within the literal to make the literal
    more readable.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文字中适当的位置插入下划线，使文字更易读。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: This example illustrates using underscores to clarify the inherent gaps found
    in most debit card numbers, and demonstrates their use with floating point numbers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例说明了使用下划线来澄清大多数借记卡号中存在的固有间隙，并演示了它们在浮点数中的使用。
- en: 'Create a new console application and add the `main` method as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序，并添加以下`main`方法：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add a method to display the credit card number properly formatted for output,
    as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个方法来正确格式化输出的信用卡号，如下所示：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Execute the application. The output will appear as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。输出将如下所示：
- en: '**The card number is: 1234567898765432**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**卡号是：1234567898765432**'
- en: '**The formatted card number is: 1234 5678 9876 5432**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**格式化后的卡号是：1234 5678 9876 5432**'
- en: '**Minimum amount limit exceeded 5000.0**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**最低金额限额超过5000.0**'
- en: Notice that in the first output line the displayed number does not contain underscores,
    but our second line is formatted to use spaces where the underscores were. This
    is to illustrate the difference between how the number looks internally, and how
    it needs to be formatted for external display.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第一行输出中，显示的数字不包含下划线，但我们的第二行格式化为在下划线的位置使用空格。这是为了说明数字在内部的外观与需要为外部显示格式化的方式之间的差异。
- en: How it works...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The debit card example partitioned the number into four sections making it more
    readable. A `long` variable was needed due to the length of the debit card number.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 借记卡示例将数字分成四个部分，使其更易读。由于借记卡号的长度，需要一个`long`变量。
- en: Next, a minimum limit was placed on the amount of money in a bank account. The
    variable `minAmount` of type `float` was set to 5,000.00 using the underscores
    to denote the location of the comma. Two more `float` called `currentAmount` and
    `withdrawalAmount` were declared and set equal to 5,250.00 and 500.00, respectively.
    The code then determined whether the `withdrawalAmount` could be subtracted from
    the `currentAmount` and still maintain a balance above the `minAmount`. If not,
    a message to that effect was displayed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在银行账户中设置了最低限额。类型为`float`的变量`minAmount`被设置为5,000.00，使用下划线表示逗号的位置。另外两个名为`currentAmount`和`withdrawalAmount`的`float`被声明并分别设置为5,250.00和500.00。然后代码确定了是否可以从`currentAmount`中减去`withdrawalAmount`并仍然保持余额高于`minAmount`。如果不行，将显示相应的消息。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In most applications involving currency, the `java.util.Currency` class would
    be a more appropriate choice. The previous example used floating point literals
    only to explain the usage of underscores.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数涉及货币的应用中，`java.util.Currency`类将是更合适的选择。前面的例子只使用浮点文字来解释下划线的用法。
- en: The only purpose of the underscore is to make the code more readable to the
    developer. The compiler ignores the underscores during code generation and during
    any subsequent variable manipulation. Consecutive underscores are treated as one
    and also ignored by the compiler. If the output format of a variable is important,
    it will have to be handled separately.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线的唯一目的是使代码对开发人员更易读。编译器在代码生成期间和任何后续变量操作期间都会忽略下划线。连续的下划线被视为一个，并且也被编译器忽略。如果变量的输出格式很重要，它将需要单独处理。
- en: There's more...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Underscores can be used for more than base 10 literals. In addition, underscores
    can be misused. Here, we will address the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线不仅可以用于十进制文字。此外，下划线也可能被误用。在这里，我们将讨论以下内容：
- en: Simple underscore usage mistakes
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的下划线使用错误
- en: Using underscores with hexadecimal literals
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用下划线与十六进制文字
- en: Using underscores with binary literals
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用下划线与二进制文字
- en: Simple underscore usage mistakes
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单的下划线使用错误
- en: Underscores may generally be placed arbitrarily within the literals, but there
    are guidelines limiting their use. It is invalid to place underscores at the beginning
    or end of a number, adjacent to a decimal point when used in a `float` or `double`,
    prior to the D, F, or L suffix, or where a string of digits is required.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线通常可以随意放置在文字中，但有限制它们的使用。在数字的开头或结尾、在使用`float`或`double`时与小数点相邻、在D、F或L后缀之前，或者在需要一串数字的地方放置下划线都是无效的。
- en: 'The following are the examples of invalid underscore usages:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是无效下划线使用的例子：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These will generate the syntax error, **error: illegal underscore**.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成语法错误，**错误：非法下划线**。
- en: Using underscores with hexadecimal literals
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用下划线与十六进制文字
- en: 'Underscores can be particularly useful when dealing with binary data expressed
    in hexadecimal or binary. In the following example, an integer value representing
    a command to be sent to a data port was expressed as a hexadecimal and as a binary
    literal:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线在处理用十六进制或二进制表示的二进制数据时特别有用。在下面的例子中，表示要发送到数据端口的命令的整数值被表示为十六进制和二进制文字：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These two numbers are the same. They are only expressed in different bases.
    Here, we used base 2 and base 16\. The base 16 representation may be more readable
    in this example. Base 2 literals will be discussed in more depth in the next section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个数字是相同的。它们只是用不同的进制表示。在这里，我们使用了2进制和16进制。在这个例子中，16进制表示可能更易读。2进制文字将在下一节中更深入地讨论。
- en: The underscores were used to more clearly identify parts of the command. The
    assumption is that the first four bits of the command represent an operator, while
    the next 16 bits are an operand. The next 8 bits and 4 bits could represent other
    aspects of the command.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线用于更清晰地识别命令的各个部分。假设命令的前四位表示运算符，接下来的16位是操作数。接下来的8位和4位可能表示命令的其他方面。
- en: Using underscores with binary literals
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用下划线与二进制文字
- en: 'We can also use underscores with binary literals. For example, to initialize
    a device we may need to send a specific 8 bit sequence to the data port. This
    sequence may be organized such that the first two bits specify the operation (read,
    write, and so on), the next three bits may specify a device resource, and the
    last three bits could represent an operand. We may encode this sequence using
    a binary literal with underscores as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在二进制文字中使用下划线。例如，为了初始化设备，我们可能需要向数据端口发送一个特定的8位序列。这个序列可以被组织成这样，前两位指定操作（读、写等），接下来的三位可以指定设备资源，最后三位可以表示操作数。我们可以使用带有下划线的二进制文字来编码这个序列，如下所示：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use of the underscores clearly identifies each field. While it is not necessary
    to use the variable `initializationSequence`, it allows us to use the sequence
    in more than one place in a program. Another example defines a mask where, in
    this case, the first three bits are eliminated during an **AND** operation as
    follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下划线清楚地标识了每个字段。虽然不必使用变量`initializationSequence`，但它允许我们在程序中的多个地方使用该序列。另一个例子定义了一个掩码，在这种情况下，第一个三位在**AND**操作中被消除，如下所示：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In a bitwise AND operation, each bit of the operands are Anded with each other.
    These examples are illustrated as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在按位AND操作中，操作数的每一位都与对方进行AND运算。这些例子如下所示：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When this sequence is executed, we get the following output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此序列时，我们得到以下输出：
- en: '**initializationSequence: 1110010**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始化序列：1110010**'
- en: '**result: 11011**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果：11011**'
- en: The byte cast operator was needed because binary literals default to type `int`.
    Also, notice that the `toBinaryString` method does not display leading zeroes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用字节转换运算符，因为二进制文字默认为`int`类型。另外，请注意`toBinaryString`方法不显示前导零。
- en: Using the try-with-resources block to improve exception handling code
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用try-with-resources块来改进异常处理代码
- en: Prior to Java 7, the code required for properly opening and closing resources,
    such as a `java.io.InputStream` or `java.nio.Channel`, was quite verbose and prone
    to errors. The try-with-resources block has been added in an effort to simplify
    error-handling and make the code more concise. The use of the try-with-resources
    statement results in all of its resources being automatically closed when the
    try block exits. Resources declared with the try-with-resources block must implement
    the interface `java.lang.AutoCloseable`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7之前，为了正确打开和关闭资源（如`java.io.InputStream`或`java.nio.Channel`），所需的代码非常冗长且容易出错。尝试与资源块已添加，以简化错误处理并使代码更简洁。使用try-with-resources语句会导致在try块退出时自动关闭所有资源。使用try-with-resources块声明的资源必须实现接口`java.lang.AutoCloseable`。
- en: This approach enables a better programming style as it avoids nested and excessive
    try-catch blocks. It also ensures accurate resource management, which you may
    see referred to as **Automated Resource Management** (**ARM**) in literature.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以更好地避免嵌套和过多的try-catch块，确保准确的资源管理，文献中可能称之为**自动资源管理**（**ARM**）。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'When working with resources that need to be opened and closed, the `try-with-resource`
    block is implemented by:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理需要打开和关闭的资源时，通过以下方式实现`try-with-resource`块：
- en: Creating the try block and declaring the resources to be managed.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建try块并声明要管理的资源。
- en: Using the resource within the try block.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在try块内使用资源。
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a console application and add the following `main` method to it. Create
    a text file in the working directory called `users.txt` and add a list of names
    to the file. This example opens up that file and creates a backup, while demonstrating
    the use of the `try-with-resources` technique, where a `java.io.BufferedReader`
    and `java.io.BufferedWriter` objects are created with the try block:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个控制台应用程序，并向其添加以下`main`方法。在工作目录中创建一个名为`users.txt`的文本文件，并向文件中添加一系列名称。此示例打开该文件并创建一个备份，同时演示了使用`try-with-resources`技术，其中使用try块创建了一个`java.io.BufferedReader`和`java.io.BufferedWriter`对象：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Execute the application. The output should be as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。输出应该如下：
- en: '**Copy complete!**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**复制完成！**'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The resources to be managed are declared and initialized inside a set of parentheses
    between the `try` keyword and the opening curly brace of the try block. In this
    case, two resources are created. The first is a `BufferedReader` object associated
    with the `users.txt` file and the second is a `BufferedWriter` object associated
    with the `users.bak` file. The new IO techniques using the `java.nio.file.Path`
    interface are discussed in [Chapter 6](ch06.html "Chapter 6. Stream IO in Java
    7"), *Stream IO in Java 7*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理的资源在“try”关键字和try块的左花括号之间的一组括号内声明和初始化。在这种情况下，创建了两个资源。第一个是与“users.txt”文件关联的“BufferedReader”对象，第二个是与“users.bak”文件关联的“BufferedWriter”对象。使用“java.nio.file.Path”接口的新IO技术在[第6章](ch06.html
    "第6章。Java 7中的流IO")中进行了讨论，*Java 7中的流IO*。
- en: The first file is then read line by line and written to the second file. When
    the try block is exited, the two IO streams are automatically closed. A message
    is then displayed showing that the copy operation is complete.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后逐行读取第一个文件，并将其写入第二个文件。当try块退出时，两个IO流会自动关闭。然后显示一条消息，显示复制操作已完成。
- en: Notice the use of the vertical bar in the catch block. This is new to Java 7
    and allows us to catch multiple exceptions in a single catch block. The use of
    this operator is discussed in the *Catching multiple exception types to improve
    type checking* recipe.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在catch块中使用垂直线。这是Java 7中的新功能，允许我们在单个catch块中捕获多个异常。这个操作符的使用在*捕获多个异常类型以改进类型检查*中进行了讨论。
- en: Bear in mind that the resources declared with a try-with-resources block are
    separated by semicolons. Failure to do so will result in a compile-time error.
    Also, resources will be attempted to be closed, regardless of whether the try
    block completes normally or not. If the resource cannot be closed, an exception
    is normally thrown.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用try-with-resources块声明的资源之间用分号分隔。否则将导致编译时错误。此外，无论try块是否正常完成，都将尝试关闭资源。如果资源无法关闭，通常会抛出异常。
- en: Regardless of whether resources are closed or not, the catch and finally blocks
    are always executed. However, exceptions can still be thrown from these blocks.
    This is discussed in more detail in the *Creating a resource that can be used
    with the try-with-resources technique* recipe.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 无论资源是否关闭，catch和finally块始终被执行。但是，异常仍然可以从这些块中抛出。这在*创建可与try-with-resources技术一起使用的资源*中有更详细的讨论。
- en: There's more...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'To complete our understanding of the `try-with-resources` technique, we need
    to address two other topics as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全理解“try-with-resources”技术，我们需要解决另外两个主题，如下所示：
- en: Understanding suppressed exceptions
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解抑制异常
- en: Structuring issues when using the `try-with-resources` technique
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用“try-with-resources”技术时的结构问题
- en: Understanding suppressed exceptions
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解抑制异常
- en: 'In support of this approach, a new constructor was added to the `java.lang.Exception`
    class along with two methods: `addSuppressed` and `getSuppressed`. Suppressed
    exceptions are those exceptions that are not explicitly reported. In the case
    of the try-with-resources try block, exceptions may be thrown from the try block
    itself or when the resources created by the try block are closed. When more than
    one exception is thrown, exceptions may be suppressed.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这种方法，`java.lang.Exception`类添加了一个新的构造函数以及两个方法：`addSuppressed`和`getSuppressed`。抑制的异常是那些没有明确报告的异常。在try-with-resources
    try块的情况下，可能会从try块本身抛出异常，或者在try块创建的资源关闭时抛出异常。当抛出多个异常时，可能会抑制异常。
- en: In the case of the try-with-resources block, any exceptions associated with
    a close operation are suppressed when an exception is thrown from the block itself.
    This is demonstrated in the *Creating a resource that can be used with the try-with-resources
    technique* recipe.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在try-with-resources块的情况下，与关闭操作相关的任何异常在从块本身抛出异常时都会被抑制。这在*Creating a resource
    that can be used with the try-with-resources technique*中有所示。
- en: Suppressed exceptions can be retrieved using the `getSuppressed` method. Programmer
    created exceptions can designate an exception as suppressed by using the `addSuppressed`
    method.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`getSuppressed`方法检索抑制的异常。程序员创建的异常可以使用`addSuppressed`方法将异常标记为被抑制。
- en: Structuring issues when using the try-with-resources technique
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在使用try-with-resources技术时的结构问题
- en: It may not be desirable to use this technique when a single resource is used.
    We will show three different implementations of a sequence of code to display
    the contents of the `users.txt` file. The first, as shown in the following code,
    uses the try-with-resources block. However, it is necessary to precede this block
    with a try block to capture the `java.net.URISyntaxException:`
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用单个资源时，可能不希望使用这种技术。我们将展示三种不同的代码序列实现来显示`users.txt`文件的内容。首先，如下所示的代码使用了try-with-resources块。但是，需要在此块之前加上一个try块来捕获`java.net.URISyntaxException:`
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This example is predicated upon the need to catch the `URISyntaxException`.
    This can be avoided by creating the `java.net.URI` object inside of the `get`
    method as shown below. However, it does make the code harder to read:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是基于需要捕获`URISyntaxException`。可以通过在`get`方法中创建`java.net.URI`对象来避免这种情况。然而，这会使代码更难阅读：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Notice the use of the multiple catch block as discussed in the *Catching multiple
    exception types to improve type checking* recipe. Another approach is to avoid
    the `URI` object altogether by using the `get` method with a `String` argument
    as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用多个catch块，如*Catching multiple exception types to improve type checking*中所讨论的。另一种方法是通过使用带有`String`参数的`get`方法来避免`URI`对象：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The methods that are used and the structure of the code affect the readability
    and maintainability of the code. It may or may not be feasible to eliminate the
    use of the `URI` object, or similar objects, in a code sequence. However, careful
    consideration of alternative approaches can go a long way to improving an application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的方法和代码结构会影响代码的可读性和可维护性。在代码序列中可能有可能消除`URI`对象或类似对象的使用，也可能不可行。然而，仔细考虑替代方法可以大大改善应用程序。
- en: See also
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Catching multiple exception types to improve type checking* recipe and
    *Creating a resource that can be used with the try-with-resources technique* recipe
    provide further coverage of the exception handling in Java 7.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*Catching multiple exception types to improve type checking*和*Creating a resource
    that can be used with the try-with-resources technique*提供了Java 7中异常处理的更多覆盖范围。'
- en: Creating a resource that can be used with the try-with-resources technique
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个可以与try-with-resources技术一起使用的资源
- en: There are many resources in Java libraries, which can be used as part of the
    `try-with-resource` technique. However, there may be times when you may wish to
    create your own resources that can be used with this technique. An example of
    how to do this is illustrated in this recipe.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Java库中有许多资源，可以作为`try-with-resource`技术的一部分使用。然而，有时您可能希望创建自己的资源，以便与这种技术一起使用。本示例演示了如何做到这一点。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To create a resource that can be used with the `try-with-resources` technique:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可以与`try-with-resources`技术一起使用的资源：
- en: Create a class that implements the `java.lang.AutoCloseable` interface.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实现`java.lang.AutoCloseable`接口的类。
- en: Override the `close` method.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`close`方法。
- en: Implement resource-specific methods.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现特定于资源的方法。
- en: Any objects created with the try-with-resources block must implement the `AutoCloseable`
    interface. This interface has a single method, that is, `close`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用try-with-resources块创建的对象都必须实现`AutoCloseable`接口。这个接口有一个方法，即`close`。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here, we will illustrate this approach by creating three classes:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将通过创建三个类来说明这种方法：
- en: One class that contains the `main` method
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含`main`方法的一个类
- en: Two classes that implement the `AutoCloseable` interface
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`AutoCloseable`接口的两个类
- en: 'Create two classes called `FirstAutoCloseableResource` and `SecondAutoCloseableResource`.
    Within these classes, implement a `manipulateResource` and `close` method, shown
    as follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个名为`FirstAutoCloseableResource`和`SecondAutoCloseableResource`的类。在这些类中，实现`manipulateResource`和`close`方法，如下所示：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, add the following code to a `main` method. We use the `try-with-resources`
    technique with the two resources, and then call their `manipulateResource` method:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下代码添加到`main`方法中。我们使用`try-with-resources`技术与两个资源，然后调用它们的`manipulateResource`方法：
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When the code executes, the `close` methods throw an `UnsupportedOperationException`
    shown as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当代码执行时，`close`方法会抛出`UnsupportedOperationException`，如下所示：
- en: '**FirstAutoCloseableResource manipulateResource method executed**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**FirstAutoCloseableResource manipulateResource方法执行**'
- en: '**SecondAutoCloseableResource manipulateResource method executed**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**SecondAutoCloseableResource manipulateResource方法执行**'
- en: '**SecondAutoCloseableResource close method executed**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**SecondAutoCloseableResource close方法执行**'
- en: '**FirstAutoCloseableResource close method executed**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**FirstAutoCloseableResource close方法执行**'
- en: '**java.lang.UnsupportedOperationException: A problem has occurred in SecondAutoCloseableResource**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**java.lang.UnsupportedOperationException: SecondAutoCloseableResource中发生了问题**'
- en: '**at packt.SecondAutoCloseableResource.close(SecondAutoCloseableResource.java:9)**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**在packt.SecondAutoCloseableResource.close(SecondAutoCloseableResource.java:9)**'
- en: '**at packt.TryWithResourcesExample.displayAutoCloseableExample(TryWithResourcesExample.java:30)**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**在packt.TryWithResourcesExample.displayAutoCloseableExample(TryWithResourcesExample.java:30)**'
- en: '**at packt.TryWithResourcesExample.main(TryWithResourcesExample.java:22)**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**在packt.TryWithResourcesExample.main(TryWithResourcesExample.java:22)**'
- en: '**Suppressed: java.lang.UnsupportedOperationException: A problem has occurred
    in FirstAutoCloseableResource**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**被抑制：java.lang.UnsupportedOperationException: 在FirstAutoCloseableResource中发生了问题**'
- en: '**at packt.FirstAutoCloseableResource.close(FirstAutoCloseableResource.java:9)**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**在packt.FirstAutoCloseableResource.close(FirstAutoCloseableResource.java:9)**'
- en: '**... 2 more**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**... 2个更多**'
- en: '**java.lang.UnsupportedOperationException: A problem has occurred in FirstAutoCloseableResource**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**java.lang.UnsupportedOperationException: 在FirstAutoCloseableResource中发生了问题**'
- en: How it works...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Within the resource classes, the `manipulateResource` methods were created to
    perform some resource-specific operation. The resource classes were declared as
    part of the try block, and the `manipulateResource` methods were called. This
    was illustrated in the first part of the output. The output has been highlighted
    to clarify the process.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源类中，创建了`manipulateResource`方法来执行一些特定于资源的操作。资源类被声明为try块的一部分，并调用了`manipulateResource`方法。这在输出的第一部分中有所说明。输出已经被突出显示以澄清这个过程。
- en: When the try block terminated, the `close` methods were executed. They were
    executed in an opposite order than expected. This is the result of how the application
    program stack works.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当try块终止时，`close`方法被执行。它们的执行顺序与预期相反。这是应用程序堆栈工作原理的结果。
- en: Within the catch block, the stack was dumped. In addition, we used the `getSuppressed`
    method to return and display the suppressed methods. Support for suppressed exceptions
    was introduced in Java 7\. These types of exceptions are discussed in the *Using
    the try-with-resource block to improve exception handling code* recipe and later
    on in this recipe.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在catch块中，堆栈被转储。此外，我们使用`getSuppressed`方法返回并显示被抑制的方法。在Java 7中引入了对被抑制异常的支持。这些类型的异常在*使用try-with-resource块改进异常处理代码*配方中讨论，并在本配方后面讨论。
- en: There's more...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Within the `close` method, one of the following three actions is possible:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在`close`方法中，可能有以下三种操作之一：
- en: Do nothing if there is nothing to close or the resource will always close
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有要关闭的内容或资源将始终关闭
- en: Close the resource and return without error
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭资源并返回而不出错
- en: Attempt to close the resource, but throw an exception upon failure
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试关闭资源，但在失败时抛出异常
- en: The first two conditions are easy enough to handle. In the case of the last
    one, there are a few things to bear in mind.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个条件很容易处理。在最后一个条件中，有一些事情需要记住。
- en: Always implement the `close` method and supply specific exceptions. This provides
    the user with more meaningful feedback concerning the underlying problem. Also,
    do not throw an `InterruptedException`. Runtime problems can occur if the `InterruptedException`
    has been suppressed.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 始终实现`close`方法并提供特定的异常。这将为用户提供有关潜在问题更有意义的反馈。此外，不要抛出`InterruptedException`。如果`InterruptedException`被抑制，可能会出现运行时问题。
- en: The `close` method is not required to be idempotent. An **idempotent** method
    is the one where repeated execution of the method will not cause problems. As
    an example, reading from the same file twice will not necessarily cause problems.
    Whereas, writing the same data twice to the file may. The `close` method does
    not have to be idempotent, however, it is recommended that it should be.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`close`方法不需要是幂等的。**幂等**方法是指重复执行该方法不会引起问题。例如，两次从同一文件中读取数据不一定会引起问题。而将相同的数据两次写入文件可能会引起问题。`close`方法不必是幂等的，但建议应该是。'
- en: See also
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using the try-with-resources block to improve exception handling code*
    recipe covers the use of this type of try block.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用try-with-resources块改进异常处理代码*配方涵盖了这种类型的try块的使用。'
- en: Catching multiple exception types to improve type checking
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获多个异常类型以改进类型检查
- en: Within a try block, multiple exceptions can be generated and thrown. A corresponding
    series of catch blocks are used to capture and then deal with the exceptions.
    Frequently, the action needed to deal with one exception is the same for other
    exceptions. An example of this is when the logging of an exception is performed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在try块内，可能会生成和抛出多个异常。一系列对应的catch块用于捕获并处理这些异常。经常情况下，处理一个异常所需的操作对其他异常也是相同的。一个例子是当执行异常的日志记录时。
- en: In Java 7, it is now possible to handle more than one exception from within
    a single catch block. This ability can reduce the duplication of code. In earlier
    versions of Java, there was often a temptation to address this issue by catching
    a higher-level exception class and handling multiple exceptions from that block.
    There is less need for this approach now.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7中，现在可以在单个catch块中处理多个异常。这种能力可以减少代码的重复。在Java的早期版本中，通常会有诱惑去通过捕获更高级别的异常类并从该块中处理多个异常来解决这个问题。现在这种方法的需求较少。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Using a single catch block to capture multiple exceptions is achieved by:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用单个捕获块捕获多个异常来实现：
- en: Adding a catch block
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个捕获块
- en: Including multiple exceptions within the catch blocks' parentheses, separated
    by a vertical bar
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在捕获块的括号内包括多个异常，用竖线分隔
- en: How to do it...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this example, we wish to deal with invalid input from the user by logging
    an exception. This is a simple approach that will suffice to explain how multiple
    exceptions can be handled.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们希望通过记录异常来处理用户的无效输入。这是一个简单的方法，足以解释如何处理多个异常。
- en: 'Create an application with two classes: `MultipleExceptions` and `InvalidParameter`.
    The `InvalidParameter` class is used to handle invalid user input, and the `MultipleExceptions`
    class contains the `main` method and example code.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含两个类`MultipleExceptions`和`InvalidParameter`的应用程序。`InvalidParameter`类用于处理无效的用户输入，而`MultipleExceptions`类包含`main`方法和示例代码。
- en: 'Create the `InvalidParameter` class as follows:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`InvalidParameter`类如下：
- en: '[PRE18]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, create the `MultipleExceptions` class with a `java.util.logging.Logger`
    object as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建`MultipleExceptions`类，并添加一个`java.util.logging.Logger`对象，如下所示：
- en: '[PRE19]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Execute the program using a variety of input. Using a valid number, such as
    **12**, results in the following output:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用各种输入执行程序。使用有效数字，比如12，会产生以下输出：
- en: '**Enter a number: 12**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个数字：12
- en: '**The number is: 12**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 数字是：12
- en: 'Using invalid input like a non-numeric value, such as **cat**, or a negative
    number, such as **-5**, will result in the following output:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用无效输入，比如非数字值，比如cat，或者负数，比如-5，会产生以下输出：
- en: '**Enter a number: cat**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个数字：cat
- en: '**Invalid input, try again**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 无效输入，请重试
- en: '**Aug 28, 2011 1:48:59 PM packt.MultipleExceptions main**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年8月28日下午1:48:59 packt.MultipleExceptions main
- en: '**INFO: Invalid input, try again**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 信息：无效输入，请重试
- en: '**Enter a number: -5**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个数字：-5
- en: '**Invalid input, try again**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 无效输入，请重试
- en: '**Aug 28, 2011 1:49:20 PM packt.MultipleExceptions main**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年8月28日下午1:49:20 packt.MultipleExceptions main
- en: '**INFO: Invalid input, try again**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 信息：无效输入，请重试
- en: How it works...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The logger was created and when an exception occurred, an entry was made in
    the logger file. The output created by using NetBeans also displayed these log
    messages as they occur.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 记录器已创建，当发生异常时，记录器文件中会有一条记录。使用NetBeans创建的输出也会显示这些日志消息。
- en: When an exception was thrown, the catch block was entered. Notice that the two
    exceptions of interest here, `java.util.InputMismatchException` and `InvalidParameter`,
    occur within the same catch statement and are separated with a vertical bar. Also,
    notice that there is only a single variable, `e`, used to represent the exception.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当抛出异常时，进入catch块。请注意，这里感兴趣的两个异常，`java.util.InputMismatchException`和`InvalidParameter`出现在同一个catch语句中，并用竖线分隔。还要注意，只有一个变量`e`用于表示异常。
- en: 'This approach is useful when we need to handle a few specific exceptions, and
    need to handle them in the same way. When a catch block handles more than one
    exception, the catch block parameter is implicitly final. This means that it is
    not possible to assign new values to the parameter. The following is illegal and
    its use will result in a syntax error:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要处理几个特定的异常并以相同的方式处理时，这种方法是有用的。当一个catch块处理多个异常时，catch块参数是隐式final的。这意味着无法给参数赋新值。以下是非法的，使用它会导致语法错误：
- en: '[PRE20]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Besides being more readable and concise than using multiple catch blocks, the
    generated bytecode is also smaller and does not result in the generation of duplicate
    code.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '除了比使用多个catch块更可读和更简洁之外，生成的字节码也更小，不会产生重复的代码。 '
- en: There's more...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The base class or classes of a set of exceptions impact when to use a catch
    block to capture multiple exceptions. Also, assertions are useful in creating
    robust applications. These issues are addressed as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一组异常的基类影响何时使用catch块捕获多个异常。此外，断言在创建健壮的应用程序时是有用的。这些问题如下所述：
- en: The use of a common exception base class and the `java.lang.ReflectiveOperationException`
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个共同的异常基类和`java.lang.ReflectiveOperationException`
- en: Using the `java.lang.AssertionError` class in Java 7
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java 7中使用`java.lang.AssertionError`类
- en: The use of a common exception base class and the ReflectiveOperationException
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用一个共同的异常基类和ReflectiveOperationException
- en: Catching multiple exceptions in the same catch block is useful when different
    exceptions need to be handled in the same way. However, if the multiple exceptions
    share a common base exception class, then it may be simpler to catch the base
    class exception instead. This is the case with many `IOException` derived classes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当不同的异常需要以相同的方式处理时，在同一个catch块中捕获多个异常是有用的。但是，如果多个异常共享一个公共基础异常类，那么捕获基类异常可能更简单。这是许多`IOException`派生类的情况。
- en: 'For example, the `Files` class'' `delete` method may throw one of the following
    four different exceptions:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Files`类的`delete`方法可能会抛出以下四种不同的异常之一：
- en: '`java.nio.file.NoSuchFileException`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.nio.file.NoSuchFileException`'
- en: '`java.nio.file.DirectoryNotEmptyException`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.nio.file.DirectoryNotEmptyException`'
- en: '`java.io.IOException`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.io.IOException`'
- en: '`java.lang.SecurityException`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.SecurityException`'
- en: 'Of these, `NoSuchFileException` and `DirectoryNotEmptyException` are ultimately
    derived from `IOException`. Thus, catching the `IOException` may be sufficient
    as illustrated in the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`NoSuchFileException`和`DirectoryNotEmptyException`最终都是从`IOException`派生出来的。因此，捕获`IOException`可能足够，就像下面的代码所示：
- en: '[PRE21]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, notice that a `URISyntaxException` exception is potentially
    thrown by the `URI` constructor. The recipe *Deleting a file or directory*, in
    [Chapter 4](ch04.html "Chapter 4. Managing Files and Directories"), *Managing
    Files and Directories*, details the use of the `delete` method.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，注意`URI`构造函数可能抛出`URISyntaxException`异常。在[第4章](ch04.html "第4章。管理文件和目录")的食谱*删除文件或目录*中，详细介绍了`delete`方法的使用。
- en: 'In Java 7, a new exception, `ReflectiveOperationException`, has been added
    to the `java.lang` package. It is the base class for the following exceptions:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7中，`ReflectiveOperationException`是`java.lang`包中新增的一个异常。它是以下异常的基类：
- en: '`ClassNotFoundException`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassNotFoundException`'
- en: '`IllegalAccessException`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IllegalAccessException`'
- en: '`InstantiationException`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InstantiationException`'
- en: '`InvocationTargetException`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvocationTargetException`'
- en: '`NoSuchFieldException`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NoSuchFieldException`'
- en: '`NoSuchMethodException`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NoSuchMethodException`'
- en: This exception class can ease the handling of reflection type exceptions. The
    use of the multiple exceptions catching mechanism is more appropriate for those
    sets of exceptions which have no common base class.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个异常类可以简化反射类型异常的处理。多异常捕获机制更适用于那些没有共同基类的异常集合。
- en: Note
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As a general rule, it is better to catch the exception that is as specific to
    the problem as possible. For example, it is better to catch a `NoSuchFileException`
    as opposed to the more broad `Exception`, when dealing with a missing file. This
    provides more detail about the exception.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，最好捕获尽可能特定于问题的异常。例如，处理缺少文件时，最好捕获`NoSuchFileException`而不是更广泛的`Exception`，这提供了更多关于异常的细节。
- en: Using the AssertionError class in Java 7
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Java 7中使用AssertionError类
- en: Assertions are useful in building an application that is more robust. A good
    introduction to this topic can be found at [http://download.oracle.com/javase/1.4.2/docs/guide/lang/assert.html](http://download.oracle.com/javase/1.4.2/docs/guide/lang/assert.html).
    In Java 7, a new constructor was added that allows a message to be attached to
    a user-generated assertion error. This constructor has two arguments. The first
    is the message to be associated with the `AssertionError` and the second is a
    `Throwable` clause.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 断言在构建更健壮的应用程序中很有用。关于这个主题的很好介绍可以在[http://download.oracle.com/javase/1.4.2/docs/guide/lang/assert.html](http://download.oracle.com/javase/1.4.2/docs/guide/lang/assert.html)找到。在Java
    7中，添加了一个新的构造函数，允许将消息附加到用户生成的断言错误。此构造函数有两个参数。第一个是与`AssertionError`关联的消息，第二个是`Throwable`子句。
- en: In the `MultipleExceptions` class developed earlier in this recipe, we tested
    to see if the number was less than zero, and if so we threw an exception. Here,
    we will illustrate the use of the `AssertionError` constructor by throwing an
    `AssertionError`, if the number is greater than 10.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中早期开发的`MultipleExceptions`类中，我们测试了数字是否小于零，如果是，则抛出异常。在这里，我们将通过抛出`AssertionError`来说明使用`AssertionError`构造函数，如果数字大于10。
- en: 'Add the following code to the `main` method near the original test of the number:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`main`方法中，靠近原始数字的测试：
- en: '[PRE22]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Execute the program and enter **12** again. Your results should be similar
    to the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 再次执行程序并输入**12**。您的结果应该类似于以下内容：
- en: '**Enter a number: 12**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入一个数字：12**'
- en: '**Exception in thread "main" java.lang.AssertionError: Number was too big**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程"main"中的异常java.lang.AssertionError：数字太大**'
- en: '**at packt.MultipleExceptions.main(MultipleExceptions.java:28)**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**在packt.MultipleExceptions.main(MultipleExceptions.java:28)**'
- en: '**Caused by: java.lang.Throwable: Throwable assertion message**'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**Caused by: java.lang.Throwable: Throwable assertion message**'
- en: '**... 1 more**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**... 1 more**'
- en: '**Java Result: 1**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java结果：1**'
- en: Prior to Java 7, it was not possible to associate a message with a user-generated
    `AssertionError`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7之前，不可能将消息与用户生成的`AssertionError`关联起来。
- en: See also
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The use of the `Files` class is detailed in [Chapter 4](ch04.html "Chapter 4. Managing
    Files and Directories"), *Managing Files and Directories*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files`类的使用详细介绍在[第4章](ch04.html "第4章。管理文件和目录")中，*管理文件和目录*。'
- en: Rethrowing exceptions in Java 7
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java 7中重新抛出异常
- en: When an exception is caught in a catch block, it is sometimes desirable to rethrow
    the exception. This allows the exception to be processed by the current method
    and methods that called the current method.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当在catch块中捕获异常时，有时希望重新抛出异常。这允许当前方法和调用当前方法的方法处理异常。
- en: However, prior to Java 7 only a base class exception could be rethrown. When
    more than one exception needed to be rethrown, you were restricted to declaring
    a common base class in the method declaration. Now, it is possible to be more
    restrictive on the exceptions which can be thrown for a method.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Java 7之前，只能重新抛出基类异常。当需要重新抛出多个异常时，您被限制在方法声明中声明一个公共基类。现在，可以对可以为方法抛出的异常更加严格。
- en: Getting ready
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'In order to rethrow exceptions in Java, you must first catch them. From within
    the catch block, use the `throw` keyword with the exception to be thrown. The
    new rethrow technique in Java 7 requires that you:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Java中重新抛出异常，必须首先捕获它们。在catch块内部，使用`throw`关键字和要抛出的异常。Java 7中的新的重新抛出技术要求您：
- en: Use a base class exception class in the catch block
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在catch块中使用基类异常类
- en: Use the `throw` keyword to throw the derived class exception from the catch
    block
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`throw`关键字从catch块抛出派生类异常
- en: Modify the method's signature to throw the derived exceptions
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改方法的签名以抛出派生异常
- en: How to do it...
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will modify the `ReflectiveOperationExceptionExample` class developed in
    the *Catching multiple exception types to improve type checking* recipe. Modify
    the `main` method to call the `deleteFile` method in the try block, as shown in
    the following code:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将修改在*Catching multiple exception types to improve type checking*配方中开发的`ReflectiveOperationExceptionExample`类。修改`main`方法，以在try块中调用`deleteFile`方法，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the `deleteFile` method, shown as follows:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`deleteFile`方法，如下所示：
- en: '[PRE24]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Execute the application using a file that does not exist. The output should
    be as follows:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不存在的文件执行应用程序。输出应该如下：
- en: '**java.nio.file.NoSuchFileException**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**java.nio.file.NoSuchFileException**'
- en: '**at packt.ReflectiveOperationExceptionExample.deleteFile(ReflectiveOperationExceptionExample.java:33)**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**在packt.ReflectiveOperationExceptionExample.deleteFile(ReflectiveOperationExceptionExample.java:33)**'
- en: '**at packt.ReflectiveOperationExceptionExample.main(ReflectiveOperationExceptionExample.java:16)**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**在packt.ReflectiveOperationExceptionExample.main(ReflectiveOperationExceptionExample.java:16)**'
- en: How it works...
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `main` method called and handled exceptions generated by the `deleteFile`
    call. The method declared that it can throw a `NoSuchFileException` and a `DirectoryNotEmptyException`.
    Notice that the base class, `IOException`, was used to catch exceptions. Within
    the catch block, a test was made to determine what caused the exception, using
    the `File` class' `isDirectory` method. Once the root cause of the exception was
    determined, the appropriate exception was thrown. The use of the `Files` class
    is detailed in [Chapter 4](ch04.html "Chapter 4. Managing Files and Directories"),
    *Managing Files and Directories*.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法调用并处理了`deleteFile`调用生成的异常。该方法声明可以抛出`NoSuchFileException`和`DirectoryNotEmptyException`。请注意，基类`IOException`用于捕获异常。在catch块内部，使用`File`类的`isDirectory`方法进行测试，以确定异常的原因。确定异常的根本原因后，抛出适当的异常。`Files`类的使用详细介绍在[第4章](ch04.html
    "第4章。管理文件和目录")中，*管理文件和目录*。'
- en: By specifying precisely which exceptions can be thrown by the method, we can
    be clear about what callers of the method can expect. In addition, it prevents
    the inadvertent throwing of other `IOException` derived exceptions from the method.
    The drawback of this example is that if another exception, such as a `FileSystemException`,
    is the root cause, then we will have missed it. It will be caught in the `deleteFile`
    method, since it is derived from the `IOException`. However, we have failed to
    handle it in the method or pass it to the calling method.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通过明确指定方法可能抛出的异常，我们可以清楚地了解方法的调用者可以期望什么。 此外，它可以防止方法意外抛出其他`IOException`派生的异常。 此示例的缺点是，如果另一个异常，例如`FileSystemException`，是根本原因，那么我们将错过它。
    它将在`deleteFile`方法中捕获，因为它是从`IOException`派生的。 但是，我们未能在方法中处理它或将其传递给调用方法。
- en: See also
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The previous three recipes provide additional coverage of exception handling
    in Java 7.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个配方提供了Java 7中异常处理的其他覆盖范围。
- en: Using the diamond operator for constructor type inference
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在构造函数类型推断中使用钻石操作符
- en: The use of the diamond operator simplifies the use of generics when creating
    an object. It avoids unchecked warnings in a program, and it reduces generic verbosity
    by not requiring explicit duplicate specification of parameter types. Instead,
    the compiler infers the type. Dynamically-typed languages do this all the time.
    While Java is statically typed, the use of the diamond operator allows more inferences
    than before. There is no difference in the resulting compiled code.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用钻石操作符简化了创建对象时的泛型使用。 它避免了程序中的未经检查的警告，并通过不需要显式重复指定参数类型来减少泛型冗长。 相反，编译器推断类型。 动态类型语言一直这样做。
    虽然Java是静态类型的，但是钻石操作符的使用允许比以前更多的推断。 编译后的代码没有区别。
- en: The compiler will infer the parameter types for the constructors. This is an
    example of the convention over configuration ([http://en.wikipedia.org/wiki/Convention_over_configuration](http://en.wikipedia.org/wiki/Convention_over_configuration)).
    By letting the compiler infer the parameter type (convention), we avoid explicit
    specification (configuration) of the object. Java also uses annotations in many
    areas to affect this approach. Type inference is now available, whereas it was
    only available for methods before.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将推断构造函数的参数类型。 这是约定大于配置的一个例子（[http://en.wikipedia.org/wiki/Convention_over_configuration](http://en.wikipedia.org/wiki/Convention_over_configuration)）。
    通过让编译器推断参数类型（约定），我们避免了对象的显式规范（配置）。 Java还在许多领域使用注释来影响这种方法。 类型推断现在可用，而以前只能用于方法。
- en: Getting ready
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To use the diamond operator:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 使用钻石操作符：
- en: Create a generic declaration of an object.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建对象的通用声明。
- en: Use the diamond operator,`<>`, to specify the type inference that is to be used.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用钻石操作符`<>`来指定要使用的类型推断。
- en: How to do it...
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a simple Java application with a `main` method. Add the following code
    example to the `main` method to see how they work. For example, to declare a `java.util.List`
    of strings, we can use the following:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的Java应用程序，其中包含一个`main`方法。 将以下代码示例添加到`main`方法中，以查看它们的工作原理。 例如，要声明字符串的`java.util.List`，我们可以使用以下内容：
- en: '[PRE25]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The identifier, `list`, is declared as a list of strings. The diamond operator,`<>`,
    is used to infer the `List` type as `String`. No warnings are generated for this
    code.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标识符`list`声明为字符串列表。 钻石操作符`<>`用于推断`List`类型为`String`。 对于此代码不会生成警告。
- en: How it works...
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When an object is created without specifying the data type, it is called a raw
    type. For example, the following uses a raw type when instantiating the identifier,
    `list:`
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建对象时没有指定数据类型时，称为原始类型。 例如，在实例化标识符`list`时，以下使用了原始类型：
- en: '[PRE26]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When the code is compiled, the following warnings are generated:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 编译代码时，将生成以下警告：
- en: '**Note: packt\Bin.java uses unchecked or unsafe operations**.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：packt\Bin.java使用未经检查或不安全的操作**。'
- en: '**Note: Recompile with -Xlint:unchecked for details**.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：重新编译时使用-Xlint:unchecked以获取详细信息**。'
- en: 'An unchecked warning is generated. It is generally desirable to eliminate unchecked
    warnings in an application. When the **—Xlint:unchecked** is used we get the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成未经检查的警告。 通常希望在应用程序中消除未经检查的警告。 使用**—Xlint:unchecked**时，我们会得到以下结果：
- en: '**packt\Bin.java:26: warning: [unchecked] unchecked conversion**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**packt\Bin.java:26: 警告：[unchecked]未经检查的转换**'
- en: '**List<String> arrayList = new ArrayList()**;'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**List<String> arrayList = new ArrayList()**;'
- en: '**^**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**^**'
- en: '**required: List<String>**'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**需要：List<String>**'
- en: '**found: ArrayList**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**找到：ArrayList**'
- en: '**1 warning**'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**1个警告**'
- en: 'Before Java 7, we could address this warning by explicitly using a parameter
    type as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7之前，我们可以通过显式使用参数类型来解决此警告，如下所示：
- en: '[PRE27]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With Java 7, the diamond operator makes this shorter and simpler. This operator
    becomes even more useful with more complex data types, such as, a `List` of `Map`
    objects as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java 7，钻石操作符使这更短，更简单。 此操作符在处理更复杂的数据类型时变得更加有用，例如，`List`的`Map`对象如下所示：
- en: '[PRE28]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There's more...
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are several other aspects of type inference that should be discussed:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个类型推断的方面需要讨论：
- en: Using the diamond operator when the type is not obvious
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类型不明显时使用钻石操作符
- en: Suppressing unchecked warnings
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抑制未经检查的警告
- en: Understanding erasure
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解擦除
- en: Using the diamond operator when the type is not obvious
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在类型不明显时使用钻石操作符
- en: 'Type inference is supported in Java 7 and later, only if the parameter type
    for the constructor is obvious. For example, if we use the diamond operator without
    specifying a type for the identifier shown as follows, we will get a series of
    warnings:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7及更高版本中支持类型推断，只有构造函数的参数类型是明显的情况下才支持。 例如，如果我们在不指定类型的情况下使用钻石操作符，如下所示，将会收到一系列警告：
- en: '[PRE29]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Compiling the program with **—Xlint:unchecked**, results in the following warnings:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**—Xlint:unchecked**编译程序，将得到以下警告：
- en: '**... packt\Bin.java:29: warning: [unchecked] unchecked call to add(E) as a
    member of the raw type ArrayList**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**... packt\Bin.java:29: 警告：[unchecked]未经检查的调用add(E)作为原始类型ArrayList的成员**'
- en: '**arrayList.add("First")**;'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**arrayList.add("First")**;'
- en: '**where E is a type-variable:**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: “其中E是类型变量：”
- en: '**E extends Object declared in class ArrayList**'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: E扩展Object在ArrayList类中声明
- en: '**... \packt\Bin.java:30: warning: [unchecked] unchecked call to add(E) as
    a member of the raw type ArrayList**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: “... \packt\Bin.java:30:警告：[unchecked]未经检查的调用add(E)作为原始类型ArrayList的成员”
- en: '**arrayList.add("Second")**;'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: arrayList.add("Second");
- en: '**where E is a type-variable:**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: “其中E是类型变量：”
- en: '**E extends Object declared in class ArrayList**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: E扩展Object在ArrayList类中声明
- en: '**2 warnings**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 2个警告
- en: 'These warnings will go away if the data type is specified as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定数据类型，则这些警告将消失：
- en: '[PRE30]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Suppressing unchecked warnings
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抑制未经检查的警告
- en: 'While not necessarily desirable, it is possible to use the `@SuppressWarnings`
    annotation to suppress unchecked exceptions generated by the failure to use the
    diamond operator. The following is an example of this:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不一定是理想的，但可以使用“@SuppressWarnings”注解来抑制由于未使用菱形操作符而生成的未经检查的异常。以下是一个示例：
- en: '[PRE31]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Understanding erasure
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解擦除
- en: Erasure occurs when generics are used. The data type used in the declaration
    is not available at run-time. This language design decision was made when Java
    1.5 introduced generics, to make the code backwards compatible.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用泛型时会发生擦除。声明中使用的数据类型在运行时不可用。这是在Java 1.5引入泛型时做出的语言设计决定，以使代码向后兼容。
- en: 'Consider the following three methods. They differ only in the declaration of
    the `arrayList` variable:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下三种方法。它们只在“arrayList”变量的声明中有所不同：
- en: '[PRE32]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When these methods are compiled, the type information available at compile-time
    is lost. If we examine the compiled bytecode for these three methods, we will
    find that there is no difference between them.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些方法被编译时，编译时可用的类型信息将丢失。如果我们检查这三种方法的编译后字节码，我们会发现它们之间没有区别。
- en: 'Using the following command will display the byte codes for the program:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将显示程序的字节码：
- en: '[PRE33]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The generated code is identical for these three methods. The code for the `useImplicitType`
    is shown as follows. It is identical to the other two methods;
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法生成的代码是相同的。useImplicitType的代码如下所示。它与其他两种方法相同；
- en: '[PRE34]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Using the @SafeVarargs annotation
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@SafeVarargs注解
- en: The `@SafeVarargs` and `@SuppressWarnings` annotations can be used to deal with
    various warnings that are normally harmless. The `@SuppressWarnings` annotation,
    as its name implies, will suppress specific types of warnings.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: “@SafeVarargs”和“@SuppressWarnings”注解可用于处理通常是无害的各种警告。“@SuppressWarnings”注解，顾名思义，将抑制特定类型的警告。
- en: The `@SafeVarargs` annotation, introduced in Java 7, is used to designate certain
    methods and constructors that use a variable number of arguments as safe. Methods
    can be passed with a variable number of arguments. These arguments may be generics.
    If they are, then it may be desirable to suppress harmless warnings using the
    `@SafeVarargs` annotation.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: “@SafeVarargs”注解是在Java 7中引入的，用于指定某些使用可变数量参数的方法和构造函数是安全的。方法可以传递可变数量的参数。这些参数可能是泛型。如果是，那么可能希望使用“@SafeVarargs”注解来抑制无害的警告。
- en: Getting ready
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The `@SafeVarargs` annotation is used with constructors and methods. To use
    the `@SafeVarargs` annotation, the following steps need to be followed:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: “@SafeVarargs”注解用于构造函数和方法。要使用“@SafeVarargs”注解，需要按照以下步骤进行：
- en: Create a method or constructor that uses a variable number of generic parameters.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建使用可变数量的泛型参数的方法或构造函数。
- en: Add the `@SafeVarargs` annotation before the method declaration.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法声明之前添加“@SafeVarargs”注解。
- en: In Java 7, mandatory compiler warnings are generated with generic variable argument
    methods or constructors. The use of the `@SafeVarargs` annotation suppresses warnings,
    when these methods or constructors are deemed to be harmless.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7中，使用泛型可变参数方法或构造函数会生成强制性的编译器警告。使用“@SafeVarargs”注解可以抑制这些警告，当这些方法或构造函数被认为是无害的时候。
- en: How to do it...
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To demonstrate the `@SafeVarargs` annotation, create an application with a
    method called `displayElements` as follows. The method displays information about
    each parameter and its value:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示“@SafeVarargs”注解，创建一个名为“displayElements”的应用程序，该方法显示有关每个参数及其值的信息：
- en: '[PRE35]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The method uses a variable number of generic parameters. Java implements a variable
    number of arguments as an array of objects, which only hold reifiable types. A
    **reifiable** type is discussed in the *How it works* section.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法使用可变数量的泛型参数。Java将可变数量的参数实现为对象数组，该数组仅包含可重用类型。可重用类型在“它是如何工作”的部分中讨论。
- en: 'Add the following code in the `main` method to test the method:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“main”方法中添加以下代码以测试该方法：
- en: '[PRE36]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Execute the application. The output should appear as follows:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。输出应如下所示：
- en: '**java.util.ArrayList: [1, 2]**'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 'java.util.ArrayList: [1, 2]'
- en: '**java.util.ArrayList: [3.0, 4.0]**'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 'java.util.ArrayList: [3.0, 4.0]'
- en: '**java.lang.Integer: 12**'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 'java.lang.Integer: 12'
- en: 'Notice the use of the diamond operator,`<>`, in the declaration of the `java.util.ArrayList`.
    This operator is new to Java 7, and is discussed in the recipe: *Using the diamond
    operator for constructor type inference*.'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意在声明“java.util.ArrayList”时使用了菱形操作符“<>”。这个操作符是Java 7中的新功能，在“使用菱形操作符进行构造函数类型推断”这个主题中进行了讨论。
- en: How it works...
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In Java, a method or constructor with a variable number of arguments is created
    using the `..`. notation as used in the `displayElements` method. In this case,
    the element type is a generic.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，使用“..”符号创建具有可变数量参数的方法或构造函数，就像在“displayElements”方法中使用的那样。在这种情况下，元素类型是泛型的。
- en: The basic problem is the inability of generics and arrays to play well together.
    When generics were added to the Java language in 1.5, they were implemented to
    make them backwards compatible with earlier code. This meant that they were implemented
    using erasure. That is, any type of information that was available at compile-time
    was removed at run-time. This data is referred to as **non-reifiable.**
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 基本问题是泛型和数组无法很好地配合。当泛型在Java语言中添加到1.5时，它们被实现为使它们与早期代码向后兼容。这意味着它们是使用擦除实现的。也就是说，编译时可用的任何类型信息在运行时被移除。这些数据被称为**不可实体化**。
- en: 'Arrays are reified. Information about an array''s element type is retained
    and can be used at run-time. Note that it is not possible to declare an array
    of generics. It is possible to create a simple array of strings as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是实体化的。有关数组元素类型的信息被保留并可以在运行时使用。请注意，不可能声明一个泛型数组。可以按以下方式创建一个简单的字符串数组：
- en: '[PRE37]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'However, we cannot create an array of generics, such as the following:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能创建一个泛型数组，比如下面的例子：
- en: '[PRE38]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This code will generate the following error message:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将生成以下错误消息：
- en: '**Cannot create a generic array of List<String>**'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**无法创建List<String>的泛型数组**'
- en: A method that uses a variable number of arguments is implemented as an array
    of objects. It can only deal with reifiable types. When a method using a variable
    number of arguments is invoked, an array is created to hold these parameters.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可变数量的参数的方法被实现为对象数组。它只能处理可实体化的类型。当调用使用可变数量的参数的方法时，将创建一个数组来保存这些参数。
- en: Since we used a method with variable number of generic arguments, a run-time
    problem can occur known as **heap pollution.** Heap pollution occurs when a variable
    of a parameterized type is assigned a different type than that used to define
    it. At run-time, this will manifest itself as an unchecked warning. At run-time,
    it will result in a `java.lang.ClassCastException`. Use the `@SafeVarargs` annotation
    to designate a method as one that avoids heap pollution.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了具有可变数量的泛型参数的方法，可能会出现称为**堆污染**的运行时问题。当将参数化类型的变量分配给与其定义时使用的类型不同的类型时，将在运行时表现为未经检查的警告。在运行时，它将导致`java.lang.ClassCastException`。使用`@SafeVarargs`注解将一个方法指定为避免堆污染的方法。
- en: Methods that use a variable number of generic arguments will result in a compile-time
    warning. However, not all methods that use a variable number of generic arguments
    will result in a run-time exception. The `@SafeVarargs` is used to mark the safe
    methods as safe. If it is possible for a run-time exception to occur, then the
    annotation should not be used. This is further explored in the next section.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可变数量的泛型参数的方法将导致编译时警告。然而，并非所有使用可变数量的泛型参数的方法都会导致运行时异常。`@SafeVarargs`用于标记安全方法为安全。如果可能发生运行时异常，则不应使用该注解。这在下一节中进一步探讨。
- en: 'Notice that if the `@SafeVarargs` annotation was not used then the following
    warnings will be generated:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果没有使用`@SafeVarargs`注解，将生成以下警告：
- en: '**warning: [unchecked] unchecked generic array creation for varargs parameter
    of type ArrayList<? extends INT#1>[]**'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告：[unchecked]为类型ArrayList<? extends INT#1>[]的可变参数创建了未经检查的泛型数组**'
- en: '**warning: [unchecked] Possible heap pollution from parameterized vararg type
    T**'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告：[unchecked]可能会导致参数化可变参数类型T的堆污染**'
- en: The first warning is applied against the `displayElements` invocation and the
    second warning is applied against the actual method. There is nothing wrong with
    the code, so suppression of these warnings is perfectly acceptable.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个警告适用于`displayElements`调用，第二个警告适用于实际方法。代码没有问题，因此可以完全接受这些警告的抑制。
- en: We could use the `@SuppressWarnings("unchecked")` annotation instead to suppress
    the warning at the declaration of the method, but warnings are still generated
    with their usage. Using `@SafeVarargs` suppresses warnings at both places.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`@SuppressWarnings("unchecked")`注解来抑制方法声明处的警告，但在使用时仍会生成警告。使用`@SafeVarargs`可以在两个地方抑制警告。
- en: There's more...
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Also of interest is:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个有趣的地方是：
- en: The use of `@SafeVarargs` annotation in the Java core libraries
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java核心库中使用`@SafeVarargs`注解
- en: An example of heap pollution
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆污染的一个例子
- en: The use of @SafeVarargs annotation in Java core libraries
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Java核心库中使用@SafeVarargs注解
- en: 'JDK 1.7 libraries have incorporated the `@SafeVarargs` annotation. These include
    the following:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 1.7库已经包含了`@SafeVarargs`注解。其中包括以下内容：
- en: '`public static <T> List<T> java.util.Arrays.asList(T... a)`'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static <T> List<T> java.util.Arrays.asList(T... a)`'
- en: '`public static <T> boolean java.util.Collections.addAll(Collection<? super
    T> c, T... elements)`'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static <T> boolean java.util.Collections.addAll(Collection<? super
    T> c, T... elements)`'
- en: '`public static <E extends Enum<E>> java.util.EnumSet<E> EnumSet.of(E first,
    E... rest)`'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static <E extends Enum<E>> java.util.EnumSet<E> EnumSet.of(E first,
    E... rest)`'
- en: '`protected final void javax.swing.SwingWorker.publish(V... chunks)`'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected final void javax.swing.SwingWorker.publish(V... chunks)`'
- en: These methods were tagged with the `@SafeVarargs` annotation to indicate that
    they will not cause heap pollution. These methods are considered to be safe.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法被标记为`@SafeVarargs`注解，表示它们不会导致堆污染。这些方法被认为是安全的。
- en: An example of heap pollution
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆污染的一个例子
- en: Some methods should not be marked as safe, as illustrated with the following
    code adapted from the javadoc description of the `@SafeVarargs` annotation ([http://download.oracle.com/javase/7/docs/api/index.html](http://download.oracle.com/javase/7/docs/api/index.html)
    under the `java.lang.SafeVarargs` annotation documentation).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方法不应标记为安全，如下面从`@SafeVarargs`注解的javadoc描述中的代码所示（[http://download.oracle.com/javase/7/docs/api/index.html](http://download.oracle.com/javase/7/docs/api/index.html)
    在`java.lang.SafeVarargs`注解文档下）。
- en: 'Add the following method to your code:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码中添加以下方法：
- en: '[PRE39]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Test the method with the following code:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码测试该方法：
- en: '[PRE40]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Execute the program. You should get the following error message:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 执行程序。您应该会收到以下错误消息：
- en: '**Exception in thread "main" java.lang.ClassCastException: java.lang.Integer
    cannot be cast to java.lang.String**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**异常线程"main"java.lang.ClassCastException:java.lang.Integer无法转换为java.lang.String**'
- en: 'A list of strings was passed to the method and assigned to the identifier `stringList`.
    Next, an array of objects was declared and assigned to the same object referenced
    by `stringList`. At this point, the `stringList` and `array` referenced the same
    object, a `java.util.List` of strings. The following illustrates the configuration
    of the memory at this point:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字符串列表被传递给方法，并分配给标识符`stringList`。接下来，声明了一个对象数组，并将其分配给了由`stringList`引用的相同对象。在这一点上，`stringList`和`array`引用了同一个对象，即`java.util.List`的字符串。以下说明了此时内存的配置：
- en: '![An example of heap pollution](img/5627_1_02.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![堆污染的示例](img/5627_1_02.jpg)'
- en: 'With the following assignment:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下分配：
- en: '[PRE41]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The first element of the array is reassigned to `tmpList`. This reassignment
    is illustrated in the following figure:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的第一个元素被重新分配给了`tmpList`。这个重新分配在下图中有所说明：
- en: '![An example of heap pollution](img/5627_1_03.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![堆污染的示例](img/5627_1_03.jpg)'
- en: At this point, we have effectively assigned an `Integer` object to a `String`
    reference variable. It has been assigned to the first element of the array referenced
    by both `stringLists` and `array`. The dashed line shows the old reference, which
    has been replaced with the line. When an attempt is made at run-time to assign
    this `Integer` object to a `String` reference variable, the `ClassCastException`
    occurs.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经有效地将一个`Integer`对象分配给了一个`String`引用变量。它已被分配给了`stringLists`和`array`引用的数组的第一个元素。虚线显示了旧的引用，它已被替换为该行。当在运行时尝试将这个`Integer`对象分配给`String`引用变量时，会发生`ClassCastException`。
- en: This method results in heap pollution and should not be annotated with `@SafeVarargs`
    as it is not safe. The assignment of `tmpList` to the first element of the array
    is permitted, since we are simply assigning a `List<Integer>` object to an `Object`
    reference variable. This is an example of **upcasting**, which is legal in Java.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法会导致堆污染，不应该用`@SafeVarargs`进行注释，因为它不安全。允许将`tmpList`分配给数组的第一个元素，因为我们只是将一个`List<Integer>`对象分配给了一个`Object`引用变量。这是Java中合法的**向上转型**的一个例子。
- en: See also
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The previous recipe *Using the diamond operator for constructor type inference
    explains an improvement in the use of generics*.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配方*使用菱形操作符进行构造类型推断解释了泛型使用的改进。
