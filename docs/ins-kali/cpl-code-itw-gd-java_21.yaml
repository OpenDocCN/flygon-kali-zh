- en: '*Chapter 17*:'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '*第17章*：'
- en: Functional-Style Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程
- en: 'As you probably know, Java is not a purely functional programming language
    like Haskell, but starting with version 8, Java has added some functional-style
    support. The effort of adding this support was a success and functional-style
    code was widely adopted by developers and companies. Functional-style programming
    sustains code that is more understandable, maintainable, and testable. However,
    writing Java code in the functional style requires serious knowledge of lambdas,
    the stream API, `Optional`, functional interfaces, and so on. All these functional
    programming topics can be interview topics as well and, in this chapter, we will
    cover some of the hot questions that are mandatory to know for passing a regular
    Java interview. Our agenda contains the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道，Java不像Haskell那样是一种纯函数式编程语言，但从版本8开始，Java添加了一些函数式支持。添加这种支持的努力取得了成功，并且函数式代码被开发人员和公司广泛采用。函数式编程支持更易理解、易维护和易测试的代码。然而，以函数式风格编写Java代码需要严肃的了解lambda、流API、`Optional`、函数接口等知识。所有这些函数式编程主题也可以是面试的主题，在本章中，我们将涵盖一些必须了解的热门问题，以通过常规的Java面试。我们的议程包括以下主题：
- en: Java functional-style programming in a nutshell
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java函数式编程概述
- en: Questions and coding challenges
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题和编码挑战
- en: Let's get started!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Java functional-style programming in a nutshell
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java函数式编程概述
- en: As usual, this section is meant to highlight and refresh the main concepts of
    our topic and to provide a comprehensive resource for answering the fundamental
    questions that may occur in a technical interview.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，本节旨在突出和复习我们主题的主要概念，并为回答技术面试中可能出现的基本问题提供全面的资源。
- en: Key concepts of functional-style programming
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程的关键概念
- en: 'So, the key concepts of functional programming include the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，函数式编程的关键概念包括以下内容：
- en: Functions as first-class objects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为一等对象
- en: Pure functions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数
- en: Higher-order functions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Let's briefly dive into each of these concepts.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地介绍一下这些概念。
- en: Functions as first-class objects
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数作为一等对象
- en: Saying that functions are first-class objects means that we can create an *instance*
    of a function as having a variable referencing that function instance. This is
    like referencing a `String`, `List`, or any other object. Moreover, functions
    can be passed as parameters to other functions. However, Java methods are not
    first-class objects. The best we can do is to rely on Java lambda expressions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 说函数是一等对象意味着我们可以创建一个函数的*实例*，并将变量引用该函数实例。这就像引用`String`、`List`或任何其他对象。此外，函数可以作为参数传递给其他函数。然而，Java方法不是一等对象。我们能做的最好的事情就是依赖于Java
    lambda表达式。
- en: Pure functions
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纯函数
- en: 'A *pure* function is a function whose execution has no *side effects* and the
    return value depends only on its input parameters. The following Java method is
    a pure function:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*纯*函数是一个执行没有*副作用*的函数，返回值仅取决于其输入参数。以下Java方法是一个纯函数：'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If a method uses member variables or mutates the states of a member variable,
    then it is not a *pure* function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法使用成员变量或改变成员变量的状态，那么它就不是一个*纯*函数。
- en: Higher-order functions
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高阶函数
- en: A higher-order function takes one or more functions as parameters and/or returns
    another function as a result. Java emulates higher-order functions via lambda
    expressions. In other words, in Java, a higher-order function is a method that
    gets one (or more) lambda expressions as arguments and/or returns another lambda
    expression.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数将一个或多个函数作为参数和/或返回另一个函数作为结果。Java通过lambda表达式模拟高阶函数。换句话说，在Java中，高阶函数是一个以一个（或多个）lambda表达式作为参数和/或返回另一个lambda表达式的方法。
- en: 'For example, the `Collections.sort()` method, which takes a `Comparator` as
    parameter, is a higher-order function:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Collections.sort()`方法接受一个`Comparator`作为参数，这是一个高阶函数：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first parameter of `Collections.sort()` is a `List` and the second parameter
    is a lambda expression. This lambda expression parameter is what makes `Collections.sort()`
    a higher-order function.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections.sort()`的第一个参数是一个`List`，第二个参数是一个lambda表达式。这个lambda表达式参数是使`Collections.sort()`成为一个高阶函数的原因。'
- en: Pure functional programming rules
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纯函数式编程规则
- en: 'Now, let''s briefly discuss pure functional programming rules. Pure functional
    programming has a set of rules to follow too. These are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要讨论纯函数式编程规则。纯函数式编程也有一套规则要遵循。这些规则如下：
- en: No state
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有状态
- en: No side effects
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有副作用
- en: Immutable variables
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变变量
- en: Favoring recursion over looping
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏爱递归而不是循环
- en: Let's briefly dive into each of these rules.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地介绍一下这些规则。
- en: No state
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有状态
- en: By *no state*, we do not mean that functional programming eliminates state.
    Commonly, no state means that there is no external state to the function. In other
    words, a function may work with local variables that contain temporary states
    internally, but it cannot reference any member variables of the class/object it
    belongs to.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过*无状态*，我们并不是指函数式编程消除了状态。通常，无状态意味着函数没有外部状态。换句话说，函数可能使用包含临时状态的局部变量，但不能引用其所属类/对象的任何成员变量。
- en: No side effects
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无副作用
- en: 'By *no side effects*, we should understand that a function cannot change (mutate)
    any state outside of the function (outside of its functional scope). State outside
    of a function includes the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过“无副作用”，我们应该理解一个函数不能改变（突变）函数之外的任何状态（在其功能范围之外）。函数之外的状态包括以下内容：
- en: The member variables in the class/object that contain that function
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含该函数的类/对象中的成员变量
- en: The member variables that are passed as parameters to the function
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为参数传递给函数的成员变量
- en: Or the state in external systems (for example, databases or files).
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或外部系统中的状态（例如数据库或文件）。
- en: Immutable variables
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变变量
- en: Functional programming encourages and sustains the usage of immutable variables.
    Relying on immutable variables helps us to avoid *side effects* in a much easier
    and more intuitive way.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程鼓励并支持不可变变量的使用。依赖不可变变量有助于我们更轻松、更直观地避免*副作用*。
- en: Favoring recursion over looping
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更喜欢递归而不是循环
- en: 'Since recursion relies on repeated function calls to emulate looping, the code
    becomes more functional. This means that the following iterative approach for
    calculating factorials is not encouraged by functional programming:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于递归依赖于重复的函数调用来模拟循环，代码变得更加函数式。这意味着不鼓励使用以下迭代方法来计算阶乘：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Functional programming encourages the following recursive approach:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程鼓励以下递归方法：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We use *tail recursion* to improve the performance penalty caused by the fact
    that, in the preceding example, every function call is saved as a frame in the
    recursion stack. Tail recursion is preferred when there are many recursive calls.
    In tail recursion, the function executes the recursive call as the last thing
    to do, so the compiler doesn''t need to save the function call as a frame in the
    recursion stack. Most compilers will optimize tail recursion, hence avoiding the
    performance penalty:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*尾递归*来改善性能损耗，因为在前面的例子中，每个函数调用都保存为递归堆栈中的一个帧。当存在许多递归调用时，尾递归是首选。在尾递归中，函数执行递归调用作为最后要做的事情，因此编译器不需要将函数调用保存为递归堆栈中的帧。大多数编译器将优化尾递归，从而避免性能损耗：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, looping can be achieved via the Java Stream API, which is functionally
    inspired:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，循环可以通过受Java Stream API的启发来实现：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, it is time to practice some questions and coding challenges.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候练习一些问题和编码挑战了。
- en: Questions and coding challenges
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题和编码挑战
- en: In this section, we cover 21 questions and coding challenges that are very popular
    in interviews. Let's begin!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖21个在面试中非常流行的问题和编码挑战。让我们开始吧！
- en: Coding challenge 1 – Lambda parts
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战1- Lambda部分
- en: '**Problem**: Describe the parts of a lambda expression in Java. In addition,
    what characterizes a lambda expression?'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：描述Java中lambda表达式的部分。此外，什么是lambda表达式的特征？'
- en: '**Solution**: As the following diagram reveals, a lambda has three main parts:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：如下图所示，lambda有三个主要部分：'
- en: '![Figure 17.1 – Lambda parts'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.1- Lambda部分'
- en: '](img/Figure_17.1_B15403.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.1_B15403.jpg)'
- en: Figure 17.1 – Lambda parts
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1- Lambda部分
- en: 'The parts of a lambda expression are as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式的部分如下：
- en: On the left of the arrow, there are the parameters of this lambda that are used
    in the lambda body. In this example, these are the parameters of the `FilenameFilter.accept(File
    folder, String fileName)` method.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在箭头的左侧，是lambda的参数，这些参数在lambda主体中被使用。在这个例子中，这些是`FilenameFilter.accept(File folder,
    String fileName)`方法的参数。
- en: On the right of the arrow, there is the lambda body. In this example, the lambda
    body checks whether the folder (`folder`) in which the file (`fileName`) was found
    can be read and whether the name of this file is suffixed with the *.pdf* string.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在箭头的右侧，是lambda的主体。在这个例子中，lambda的主体检查文件（`fileName`）所在的文件夹（`folder`）是否可读，并且这个文件的名称是否以*.pdf*字符串结尾。
- en: The arrow that sits between the list of parameters and the body of a lambda
    acts as a separator.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头位于参数列表和lambda主体之间，起到分隔作用。
- en: 'Next, let''s talk about the characteristics of a lambda expression. So, if
    we write the anonymous class version of the lambda from the preceding diagram,
    then it will be as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈lambda表达式的特征。因此，如果我们写出前面图表中lambda的匿名类版本，那么它将如下所示：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, if we compare the anonymous version and the lambda expression, then we
    notice that the lambda expression is a concise anonymous function that can be
    passed as a parameter to a method or be held in a variable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们比较匿名版本和lambda表达式，我们会注意到lambda表达式是一个简洁的匿名函数，可以作为参数传递给方法或保存在变量中。
- en: 'The four words shown in the following diagram characterize a lambda expression:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下图中显示的四个词表征了lambda表达式：
- en: '![Figure 17.2 – Lambda characteristics'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.2- Lambda特征'
- en: '](img/Figure_17.2_B15403.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.2_B15403.jpg)'
- en: Figure 17.2 – Lambda characteristics
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2- Lambda特征
- en: As a rule of thumb, keep in mind that lambdas sustain the Behavior Parameterization
    design pattern (a behavior is passed as parameter of a function) and it can be
    used only in the context of a functional interface.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，请记住，lambda支持行为参数化设计模式（行为作为函数的参数传递），并且只能在功能接口的上下文中使用。
- en: Coding challenge 2 – Functional interface
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战2-功能接口
- en: '**Problem**: What is a functional interface?'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：什么是功能接口？'
- en: '**Solution**: In Java, a functional interface is an interface that contains
    only one abstract method. In other words, a functional interface contains only
    one method that is not implemented. So, a functional interface wraps a function
    as an interface and the function is represented by a single abstract method on
    the interface.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：在Java中，功能接口是一个只包含一个抽象方法的接口。换句话说，功能接口只包含一个未实现的方法。因此，功能接口将函数作为接口进行封装，并且该函数由接口上的单个抽象方法表示。'
- en: Optionally, besides this abstract method, a functional interface can have default
    and/or static methods as well. Commonly, a functional interface is annotated with
    `@FunctionalInterface`. This is just an informative annotation type that's used
    to mark a functional interface.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个抽象方法之外，功能接口还可以有默认和/或静态方法。通常，功能接口会用`@FunctionalInterface`进行注解。这只是一个信息性的注解类型，用于标记功能接口。
- en: 'Here is an example of a functional interface:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个功能接口的例子：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As a rule of thumb, if an interface has more methods without implementation
    (that is, abstract methods), then it is no longer a functional interface. This
    means that such an interface cannot be implemented by a Java lambda expression.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 根据经验法则，如果一个接口有更多没有实现的方法（即抽象方法），那么它就不再是一个函数式接口。这意味着这样的接口不能被Java lambda表达式实现。
- en: Coding challenge 3 – Collections versus streams
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战3 - 集合与流
- en: '**Problem**: What are the main differences between collections and streams?'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：集合和流之间的主要区别是什么？'
- en: '**Solution**: Collections and streams are quite different. Some of the differences
    are as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：集合和流是非常不同的。一些不同之处如下：'
- en: '`List`, `Set`, and `Map`), streams are meant to apply operations (for example,
    *filtering*, *mapping*, and *matching*) on that data. In other words, streams
    apply complex operations on a view/source represented by data stored on a collection.
    Moreover, any modification/change performed on a stream is not reflected in the
    original collection.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List`、`Set`和`Map`），流旨在对该数据应用操作（例如*过滤*、*映射*和*匹配*）。换句话说，流对存储在集合上的数据表示的视图/源应用复杂的操作。此外，对流进行的任何修改/更改都不会反映在原始集合中。'
- en: '**Data modification**: While we can add/remove elements from a collection,
    we cannot add/remove elements from a stream. Practically, a stream consumes a
    view/source, performs operations on it, and returns a result without modifying
    the view/source.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据修改**：虽然我们可以向集合中添加/删除元素，但我们不能向流中添加/删除元素。实际上，流消耗视图/源，对其执行操作，并在不修改视图/源的情况下返回结果。'
- en: '**Iteration**: While a stream consumes a view/source, it automatically and
    internally performs the iteration of that view/source. The iteration takes place
    depending on the chosen operations that should be applied to the view/source.
    On the other hand, collections must be iterated externally.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代**：流消耗视图/源时，它会自动在内部执行该视图/源的迭代。迭代取决于选择应用于视图/源的操作。另一方面，集合必须在外部进行迭代。'
- en: '**Traversal**: While collections can be traversed multiple times, streams can
    be traversed only once. So, by default, Java streams cannot be reused. Attempting
    to traverse a stream twice will lead to an error reading *Stream has already been
    operated on or closed*.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遍历**：集合可以被多次遍历，而流只能被遍历一次。因此，默认情况下，Java流不能被重用。尝试两次遍历流将导致错误读取*Stream has already
    been operated on or closed*。'
- en: '**Construction**: Collections are eagerly constructed (all the elements are
    present right from the beginning). On the other hand, streams are lazily constructed
    (the so-called *intermediate* operations are not evaluated until a *terminal*
    operation is invoked).'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造**：集合是急切构造的（所有元素从一开始就存在）。另一方面，流是懒惰构造的（所谓的*中间*操作直到调用*终端*操作才被评估）。'
- en: Coding challenge 4 – The map() function
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战4 - map()函数
- en: '`map()` function do and why would you use it?'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数是做什么的，为什么要使用它？'
- en: '`map()` function is an intermediate operation named *mapping* and available
    via the `Stream` API. It is used to transform a type of object to other type by
    simply applying the given function. So, `map()` traverses the given stream and
    transforms each element in a new version of it by applying the given function
    and accumulating the results in a new `Stream`. The given `Stream` is not modified.
    For example, transforming a `List<String>` into a `List<Integer>` via `Stream#map()`
    can be done as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数是一个名为*映射*的中间操作，通过`Stream` API可用。它用于通过简单应用给定函数将一种类型的对象转换为另一种类型。因此，`map()`遍历给定流，并通过应用给定函数将每个元素转换为它的新版本，并在新的`Stream`中累积结果。给定的`Stream`不会被修改。例如，通过`Stream#map()`将`List<String>`转换为`List<Integer>`可以如下进行：'
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Challenge yourself to practice more examples. Try to apply `map()` to transform
    an array into another array.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战自己多练习一些例子。尝试应用`map()`将一个数组转换为另一个数组。
- en: Coding challenge 5 – The flatMap() function
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战5 - flatMap()函数
- en: '`flatMap()` function do and why would you use it?'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap()`函数是做什么的，为什么要使用它？'
- en: '`flatMap()` function is an intermediate operation named *flattening* and is
    available via the `Stream` API. This function is an extension of `map()`, meaning
    that apart from transforming the given object into another type of object, it
    can also flatten it. For example, having a `List<List<Object>>`, we can turn it
    into a `List<Object>` via `Stream#flatMap()` as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap()`函数是一个名为*展平*的中间操作，通过`Stream` API可用。这个函数是`map()`的扩展，意味着除了将给定对象转换为另一种类型的对象之外，它还可以展平它。例如，有一个`List<List<Object>>`，我们可以通过`Stream#flatMap()`将其转换为`List<Object>`，如下所示：'
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The next coding challenge is related to this one, so consider this as well.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个编码挑战与此相关，所以也要考虑这一点。
- en: Coding challenge 6 – map() versus flatMap()
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战6 - map()与flatMap()
- en: '`map()` and `flatMap()` functions?'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`和`flatMap()`函数？'
- en: '`flatMap()` function is capable of flattening the given object as well. In
    other words, `flatMap()` can also flatten a `Stream` object.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap()`函数还能够将给定对象展平。换句话说，`flatMap()`也可以展平一个`Stream`对象。'
- en: Why does this matter? Well, `map()` knows how to wrap a sequence of elements
    in a `Stream`, right? This means that `map()` can produce streams such as `Stream<String[]>`,
    `Stream<List<String>>`, `Stream<Set<String>>`, or even `Stream<Stream<R>>`. But
    the problem is that these kinds of streams cannot be manipulated successfully
    (that is, as we expected) by stream operations such as `sum()`, `distinct()`,
    and `filter()`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这很重要？嗯，`map()`知道如何将一系列元素包装在`Stream`中，对吧？这意味着`map()`可以生成诸如`Stream<String[]>`、`Stream<List<String>>`、`Stream<Set<String>>`甚至`Stream<Stream<R>>`等流。但问题是，这些类型的流不能被流操作成功地操作（即，如我们所期望的那样）`sum()`、`distinct()`和`filter()`。
- en: 'For example, let''s consider the following `List`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑以下`List`：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We try to obtain the distinct names of melons from this list. If wrapping an
    array into a stream can be done via `Arrays.stream()`, for a collection, we have
    `Collection.stream()`. Therefore, the first attempt may look as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图从这个列表中获取甜瓜的不同名称。如果将数组包装成流可以通过`Arrays.stream()`来完成，对于集合，我们有`Collection.stream()`。因此，第一次尝试可能如下所示：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'But this will not work because `map()` will return `Stream<Stream<String>>`.
    The solution is provided by `flatMap()`, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不起作用，因为`map()`将返回`Stream<Stream<String>>`。解决方案由`flatMap()`提供，如下所示：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows: `Gac`, `Cantaloupe`, `Hemi`, `Apollo`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：`Gac`，`Cantaloupe`，`Hemi`，`Apollo`。
- en: Moreover, if you find trouble understanding these functional programming methods,
    then I strongly recommend you to read my other book, *Java Coding Problems*, available
    from Packt ([https://www.packtpub.com/programming/java-coding-problems](https://www.packtpub.com/programming/java-coding-problems)).
    That book contains two comprehensive chapters about Java functional-style programming
    that provide detailed explanations, diagrams, and applications useful for deep
    diving into this topic.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您在理解这些函数式编程方法时遇到困难，我强烈建议您阅读我的另一本书，*Java编码问题*，可从Packt获得（[https://www.packtpub.com/programming/java-coding-problems](https://www.packtpub.com/programming/java-coding-problems)）。该书包含两个关于Java函数式编程的全面章节，提供了详细的解释、图表和应用，对于深入研究这个主题非常有用。
- en: Coding challenge 7 – The filter() function
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战7-过滤器（）函数
- en: '`filter()` function do and why would you use it?'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`函数是做什么的，为什么要使用它？'
- en: '`filter()` function is an intermediate operation named *filtering* available
    via the `Stream` API. It is used to filter the elements of a `Stream` that satisfy
    a certain condition. The condition is specified via the `java.util.function.Predicate`
    function. This predicate function is nothing but a function that takes as a parameter
    an `Object` and returns a `boolean`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`函数是通过`Stream` API提供的一种名为*filtering*的中间操作。它用于过滤满足某种条件的`Stream`元素。条件是通过`java.util.function.Predicate`函数指定的。这个谓词函数只是一个以`Object`作为参数并返回`boolean`的函数。'
- en: 'Let''s assume that we have the following `List` of integers:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下整数`List`：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Streaming this list and extracting only non-zero elements can be accomplished
    as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式对此列表进行流处理并提取非零元素：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The resulting list will contain the following elements: `1`, `2`, `-4`, `2`,
    `-1`, `14`, `-1`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 结果列表将包含以下元素：`1`，`2`，`-4`，`2`，`-1`，`14`，`-1`。
- en: 'Notice that, for several common operations, the Java `Stream` API already provides
    out-of-the-box intermediate operations. For example, there is no need to use `filter()`
    and define a `Predicate` for operations such as the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于几个常见操作，Java `Stream` API已经提供了即用即得的中间操作。例如，无需使用`filter()`和为以下操作定义`Predicate`：
- en: '`distinct()`: Removes duplicates from the stream'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinct()`: 从流中删除重复项'
- en: '`skip(n)`: Discards the first `n` elements'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skip(n)`: 跳过前`n`个元素'
- en: '`limit(s)`: Truncates the stream to be no longer than `s` in length'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit(s)`: 将流截断为不超过`s`长度'
- en: '`sorted()`: Sorts the stream according to the natural order'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sorted()`: 根据自然顺序对流进行排序'
- en: '`sorted(Comparator<? super T> comparator)`: Sorts the stream according to the
    given `Comparator`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sorted(Comparator<? super T> comparator)`: 根据给定的`Comparator`对流进行排序'
- en: All these functions are built into the `Stream` API.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都内置在`Stream` API中。
- en: Coding challenge 8 – Intermediate versus terminal operations
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战8-中间操作与终端操作
- en: '**Problem**: What is the main difference between intermediate and terminal
    operations?'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：中间操作和终端操作之间的主要区别是什么？'
- en: '`Stream`, while the terminal operations produce a result other than `Stream`
    (for example, a collection or a scalar value). In other words, intermediate operations
    allow us to chain/call multiple operations in a type of query named a *pipeline*.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`，而终端操作产生除`Stream`之外的结果（例如，集合或标量值）。换句话说，中间操作允许我们在名为*管道*的查询类型中链接/调用多个操作。'
- en: Intermediate operations are not executed until a terminal operation is invoked.
    This means that intermediate operations are lazy. Mainly, they are executed at
    the moment when a result of some given processing is actually needed. A terminal
    operation triggers the traversal of the `Stream` and the pipeline is executed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 中间操作直到调用终端操作才会执行。这意味着中间操作是懒惰的。主要是在实际需要某个给定处理的结果时执行它们。终端操作触发`Stream`的遍历并执行管道。
- en: Among the intermediate operations, we have `map()`, `flatMap()`, `filter()`,
    `limit()`, and `skip()`. Among the terminal operations, we have `sum()`, `min()`,
    `max()`, `count()`, and `collect()`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间操作中，我们有`map()`，`flatMap()`，`filter()`，`limit()`和`skip()`。在终端操作中，我们有`sum()`，`min()`，`max()`，`count()`和`collect()`。
- en: Coding challenge 9 – The peek() function
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战9-peek()函数
- en: '`peek()` function do and why would you use it?'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`peek()`函数是做什么的，为什么要使用它？'
- en: '`peek()` function is an intermediate operation named *peeking* available via
    the `Stream` API. It allows us to see through a `Stream` pipeline. Mainly, `peek()`should
    execute a certain *non-interfering* action on the current element and forward
    the element to the next operation in the pipeline. Typically, this action consists
    of printing a meaningful message on the console. In other words, `peek()` is a
    good choice for debugging issues related to streams and lambda expression processing.
    For example, imagine that we had the following list of addresses:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`peek()`函数是通过`Stream` API提供的一种名为*peeking*的中间操作。它允许我们查看`Stream`管道。主要是，`peek()`应该对当前元素执行某个*非干扰*的操作，并将元素转发到管道中的下一个操作。通常，这个操作包括在控制台上打印有意义的消息。换句话说，`peek()`是调试与流和lambda表达式处理相关问题的一个很好的选择。例如，想象一下，我们有以下地址列表：'
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is important to mention that, even if `peek()` can be used to mutate state
    (to modify the data source of the stream), it stands for *look, but don't touch*.
    Mutating state via `peek()` can become a real problem in case of parallel stream
    pipelines because the mutating action may be called at whatever time and in whatever
    thread the element is made available by the upstream operation. So, if the action
    modifies the shared state, it is responsible for providing the required synchronization.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要提到，即使`peek()`可以用于改变状态（修改流的数据源），它代表*看，但不要触摸*。通过`peek()`改变状态可能在并行流管道中成为真正的问题，因为修改操作可能在上游操作提供的任何时间和任何线程中被调用。因此，如果操作修改了共享状态，它负责提供所需的同步。
- en: As a rule of thumb, think twice before using `peek()` to mutate the state. Also,
    be aware that this practice is a point of contention among developers and can
    be categorized as bad practice or even anti-pattern umbrellas.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，在使用`peek()`来改变状态之前要三思。此外，要注意这种做法在开发人员中是有争议的，并且可以被归类为不良做法甚至反模式的范畴。
- en: Coding challenge 10 – Lazy streams
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战10 - 懒惰流
- en: '**Problem**: What does it mean to say that a stream is lazy?'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：说一个流是懒惰的是什么意思？'
- en: '**Solution**: Saying that a stream is lazy means that a stream defines a pipeline
    of intermediate operations that are executed only when the pipeline encounters
    a terminal operation. This question is related to *Coding challenge 8* of this
    chapter.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：说一个流是懒惰的意思是，流定义了一系列中间操作的管道，只有当管道遇到终端操作时才会执行。这个问题与本章的*编码挑战8*有关。'
- en: Coding challenge 11 – Functional interfaces versus regular interfaces
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战11 - 函数式接口与常规接口
- en: '**Problem**: What is the main difference between a functional interface and
    a regular interface?'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：函数式接口和常规接口之间的主要区别是什么？'
- en: '**Solution**: The main difference between a functional interface and a regular
    interface consists of the fact that a regular interface can contain any number
    of abstract methods, while a functional interface can have only one abstract method.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：函数式接口和常规接口之间的主要区别在于，常规接口可以包含任意数量的抽象方法，而函数式接口只能有一个抽象方法。'
- en: You can consult *Coding challenge 2* of this book for a deeper understanding.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查阅本书的*编码挑战2*以深入了解。
- en: Coding challenge 12 – Supplier versus Consumer
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战12 - 供应商与消费者
- en: '`Supplier` and `Consumer`?'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Supplier`和`Consumer`？'
- en: '`Supplier` and `Consumer` are two built-in functional interfaces. `Supplier`
    acts as a factory method or as the `new` keyword. In other words, `Supplier` defines
    a method named `get()` that doesn''t take arguments and returns an object of type
    `T`. So, a `Supplier` is useful to *supply* some value.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Supplier`和`Consumer`是两个内置的函数式接口。`Supplier`充当工厂方法或`new`关键字。换句话说，`Supplier`定义了一个名为`get()`的方法，不带参数并返回类型为`T`的对象。因此，`Supplier`对于*提供*某个值很有用。'
- en: On the other hand, `Consumer` defines a method named `void accept(T t)`. This
    method accepts a single argument and returns `void`. The `Consumer` interface
    *consumes* the given value and applies some operations to it. Unlike other functional
    interfaces, `Consumer` may cause *side effects*. For example, `Consumer` can be
    used as a setter method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Consumer`定义了一个名为`void accept(T t)`的方法。这个方法接受一个参数并返回`void`。`Consumer`接口*消耗*给定的值并对其应用一些操作。与其他函数式接口不同，`Consumer`可能会引起*副作用*。例如，`Consumer`可以用作设置方法。
- en: Coding challenge 13 – Predicates
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战13 - 谓词
- en: '`Predicate`?'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Predicate`？'
- en: '`Predicate` is a built-in functional interface that contains an abstract method
    whose signature is `boolean test(T object)`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`Predicate`是一个内置的函数式接口，它包含一个抽象方法，其签名为`boolean test(T object)`：'
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `test()` method tests a condition and returns `true` if that condition is
    met, otherwise it returns `false`. A common usage of a `Predicate` is in conjunction
    with the `Stream<T> filter(Predicate<? super T> predicate)` method for filtering
    unwanted elements of a stream.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`test()`方法测试条件，如果满足条件则返回`true`，否则返回`false`。`Predicate`的常见用法是与`Stream<T> filter(Predicate<?
    super T> predicate)`方法一起过滤流中不需要的元素。'
- en: Coding challenge 14 – findFirst() versus findAny()
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战14 - findFirst()与findAny()
- en: '`findFirst()` and `findAny()`?'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`findFirst()`和`findAny()`？'
- en: '`findFirst()` method returns the first element from the stream and is especially
    useful in obtaining the first element from a sequence. It returns the first element
    from the stream as long as the stream has a defined order. If there is no encounter
    order, then `findFirst()` returns any element from the stream.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`findFirst()`方法从流中返回第一个元素，特别适用于获取序列中的第一个元素。只要流有定义的顺序，它就会返回流中的第一个元素。如果没有遇到顺序，那么`findFirst()`会返回流中的任何元素。'
- en: On the other hand, the `findAny()` method returns any element from the stream.
    In other words, it returns an arbitrary (non-deterministic) element from the stream.The
    `findAny()` method ignores the encountered order, and, in a non-parallel operation,
    it will most likely return the first element, but there is no guarantee of this.
    In order to maximize performance, the result cannot be reliably determined in
    parallel operations.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`findAny()`方法从流中返回任何元素。换句话说，它从流中返回一个任意（非确定性）的元素。`findAny()`方法忽略了遇到的顺序，在非并行操作中，它很可能返回第一个元素，但不能保证这一点。为了最大化性能，在并行操作中无法可靠地确定结果。
- en: Notice that, depending on the stream's source and the intermediate operations,
    streams may or may not have a defined encounter order.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，根据流的来源和中间操作，流可能有或可能没有定义的遇到顺序。
- en: Coding challenge 15 – Converting arrays to streams
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战15 - 将数组转换为流
- en: '**Problem**: How would you convert an array to a stream?'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：如何将数组转换为流？'
- en: '**Solution**: Converting an array of objects into a stream can be done in at
    least three ways, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：将对象数组转换为流可以通过至少三种方式来完成，如下所示：'
- en: 'The first is via `Arrays#stream()`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一种是通过`Arrays#stream()`：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Second, we can use `Stream#of()`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，我们可以使用`Stream#of()`：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The last technique is via `List#stream()`:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一种技术是通过`List#stream()`：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Converting an array of primitives (for example, integers) into a stream can
    be done in at least two ways, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将原始数组（例如整数）转换为流可以通过至少两种方式完成，如下：
- en: 'Firstly, via `Arrays#stream()`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过`Arrays#stream()`：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Secondly, by using `IntStream#of()`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，通过使用`IntStream#of()`：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Of course, for longs, you can use `LongStream`, and for doubles, you can use
    `DoubleStream`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于长整型，您可以使用`LongStream`，对于双精度浮点数，您可以使用`DoubleStream`。
- en: Coding challenge 16 – Parallel streams
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战16-并行流
- en: '**Problem**: What is a parallel stream?'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：什么是并行流？'
- en: '**Solution**: A parallel stream is a stream that can parallelize the execution
    using multiple threads. For example, you may need to filter a stream of 10 million
    integers to find the integers smaller than a certain value. Instead of using a
    single thread to traverse the stream sequentially, you can employ a parallel stream.
    This means that multiple threads will concurrently search for those integers in
    different parts of the stream and then combine the result.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：并行流是一种可以使用多个线程并行执行的流。例如，您可能需要过滤包含1000万个整数的流，以找到小于某个值的整数。您可以使用并行流来代替使用单个线程顺序遍历流。这意味着多个线程将同时在流的不同部分搜索这些整数，然后将结果合并。'
- en: Coding challenge 17 – The method reference
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战17-方法引用
- en: '**Problem**: What is a method reference?'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：什么是方法引用？'
- en: '`::`, and the name of the method is provided after it. We have the following
    references:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`::`，然后在其后提供方法的名称。我们有以下引用：'
- en: 'A method reference to a static method: *Class*::*staticMethod* (for example,
    `Math::max` is equivalent to `Math.max(`*x*`,` *y*`)`)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对静态方法的方法引用：*Class*::*staticMethod*（例如，`Math::max`等同于`Math.max(`*x*`,` *y*`)`）
- en: 'A method reference to a constructor: *Class*::*new* (for example, `AtomicInteger::new`
    is equivalent to `new AtomicInteger(`*x*`)`)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对构造函数的方法引用：*Class*::*new*（例如，`AtomicInteger::new`等同于`new AtomicInteger(`*x*`)`）
- en: 'A method reference to an instance method from instance: *object*::*instanceMethod*
    (`System.out::println` equivalent to `System.out.println(`*foo*`)`)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对实例方法的方法引用：*object*::*instanceMethod*（`System.out::println`等同于`System.out.println(`*foo*`)`）
- en: 'A method reference to an instance method from class type: *Class*::*instanceMethod*
    (`String::length` equivalent to `str.length()`)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对类类型的实例方法的方法引用：*Class*::*instanceMethod*（`String::length`等同于`str.length()`）
- en: Coding challenge 18 – The default method
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战18-默认方法
- en: '**Problem**: What is a default method?'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：什么是默认方法？'
- en: '**Solution**: Default methods were added to Java 8 mainly to provide support
    for interfaces so that they can evolve beyond an abstract contract (that is, containing
    only abstract methods). This facility is very useful for people who write libraries
    and want to evolve APIs in a compatible way. Via default methods, an interface
    can be enriched without disrupting existing implementations.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：默认方法主要是在Java 8中添加的，以提供对接口的支持，使其可以超越抽象合同（即仅包含抽象方法）。这个功能对于编写库并希望以兼容的方式发展API的人非常有用。通过默认方法，接口可以在不破坏现有实现的情况下进行丰富。'
- en: 'A default method is implemented directly in the interface and is recognized
    by the `default` keyword. For example, the following interface defines an abstract
    method called `area()` and a default method called `perimeter()`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 默认方法直接在接口中实现，并且通过`default`关键字识别。例如，以下接口定义了一个名为`area()`的抽象方法和一个名为`perimeter()`的默认方法：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since `Polygon` has a single abstract method, it is a functional interface as
    well. So, it can be annotated with `@FunctionalInterface`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Polygon`有一个抽象方法，它也是一个函数接口。因此，它可以用`@FunctionalInterface`注解。
- en: Coding challenge 19 – Iterator versus Spliterator
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战19-迭代器与Spliterator
- en: '`Iterator` and `Spliterator`?'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator`和`Spliterator`？'
- en: '`Iterator` was created for the `Collection` API, while `Spliterator` was created
    for the `Stream` API.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator`是为`Collection`API创建的，而`Spliterator`是为`Stream`API创建的。'
- en: By analyzing their names, we notice that *Spliterator* = *Splittable Iterator*.
    Hence, a `Spliterator` can split a given source and it can iterate it, too. Splitting
    is needed for parallel processing. In other words, an `Iterator` can sequentially
    iterate the elements in `Collection`, while a `Spliterator` can iterate the elements
    of a stream in parallel or sequential order.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析它们的名称，我们注意到*Spliterator* = *Splittable Iterator*。因此，`Spliterator`可以分割给定的源并且也可以迭代它。分割是用于并行处理的。换句话说，`Iterator`可以顺序迭代`Collection`中的元素，而`Spliterator`可以并行或顺序地迭代流的元素。
- en: An `Iterator` can traverse the elements of a collection only via `hasNext()`/`next()`
    because it doesn't have a size. On the other hand, a `Spliterator` can provide
    the size of the collection either by approximating it via `estimateSize()` or
    exactly via `getExactSizeIfKnown()`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator`只能通过`hasNext()`/`next()`遍历集合的元素，因为它没有大小。另一方面，`Spliterator`可以通过`estimateSize()`近似地提供集合的大小，也可以通过`getExactSizeIfKnown()`准确地提供集合的大小。'
- en: A `Spliterator` can use several flags for internally disabling unnecessary operations
    (for example, `CONCURRENT`, `DISTINCT`, and `IMMUTABLE`). An `Iterator` doesn't
    have such flags.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spliterator`可以使用多个标志来内部禁用不必要的操作（例如，`CONCURRENT`，`DISTINCT`和`IMMUTABLE`）。`Iterator`没有这样的标志。'
- en: 'Finally, you can create a `Spliterator` around an `Iterator` as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以按以下方式围绕`Iterator`创建一个`Spliterator`：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the book *Java Coding Problems* ([https://www.amazon.com/gp/product/B07Y9BPV4W/](https://www.amazon.com/gp/product/B07Y9BPV4W/)),
    you can find more details on this topic, including a complete guide for writing
    a custom `Spliterator`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在书籍*Java编码问题*（[https://www.amazon.com/gp/product/B07Y9BPV4W/](https://www.amazon.com/gp/product/B07Y9BPV4W/)）中，您可以找到有关此主题的更多详细信息，包括编写自定义`Spliterator`的完整指南。
- en: Coding challenge 20 – Optional
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战20-Optional
- en: '`Optional` class?'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional`类？'
- en: '`Optional` class was introduced in Java 8 with the main purpose of mitigating/avoiding
    `NullPointerException`. The Java language architect Brian Goetz''s definition
    is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional`类是在Java 8中引入的，主要目的是减轻/避免`NullPointerException`。Java语言架构师Brian Goetz的定义如下：'
- en: '*Optional is intended to provide a limited mechanism for library method return
    types where there needed to be a clear way to represent no result, and using null
    for such was overwhelmingly likely to cause errors.*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Optional旨在为库方法的返回类型提供有限的机制，在需要清晰表示没有结果的情况下，使用null很可能会导致错误。
- en: 'In a nutshell, you can think of `Optional` as a single value container that
    contains either a value or is empty. For example, an empty `Optional` looks like
    this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，您可以将`Optional`视为一个单值容器，它可以包含一个值或者为空。例如，一个空的`Optional`看起来像这样：
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And a non-empty `Optional` looks like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非空的`Optional`看起来像这样：
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In *Java Coding Problems* ([https://www.amazon.com/gp/product/B07Y9BPV4W/](https://www.amazon.com/gp/product/B07Y9BPV4W/)),
    you can find a complete chapter dedicated to best practices for using `Optional`.
    This is a must-read chapter for any Java developer.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在《Java编程问题》（[https://www.amazon.com/gp/product/B07Y9BPV4W/](https://www.amazon.com/gp/product/B07Y9BPV4W/)）中，您可以找到一个完整的章节专门讨论了使用`Optional`的最佳实践。这是任何Java开发人员必读的章节。
- en: Coding challenge 21 – String::valueOf
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战21 - String::valueOf
- en: '`String::valueOf` mean?'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`String::valueOf`的意思是什么？'
- en: '`String::valueOf` is a method reference to the `valueOf` static method of the
    `String` class. Consider reading *Coding challenge 17* as well for more information
    on this.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`String::valueOf`是对`String`类的`valueOf`静态方法的方法引用。考虑阅读《编码挑战17》以获取更多关于这个的信息。'
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've covered several hot topics regarding functional-style
    programming in Java. While this topic is quite extensive, with many books dedicated
    to it, the questions covered here should be enough to pass a regular Java interview
    that covers the main features of the Java 8 language.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了关于Java中函数式编程的几个热门话题。虽然这个主题非常广泛，有很多专门的书籍，但在这里涵盖的问题应该足以通过涵盖Java 8语言主要特性的常规Java面试。
- en: In the next chapter, we will discuss scaling-related questions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论与扩展相关的问题。
