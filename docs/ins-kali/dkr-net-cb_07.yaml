- en: Chapter 7. Working with Weave Net
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。使用Weave Net
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下操作：
- en: Installing and configuring Weave
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置Weave
- en: Running Weave-connected containers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行连接到Weave的容器
- en: Understanding Weave IPAM
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Weave IPAM
- en: Working with WeaveDNS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WeaveDNS
- en: Weave security
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Weave安全性
- en: Using the Weave network plugin
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Weave网络插件
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Weave Net (Weave for short) is a third-party network solution for Docker. Early
    on, it provided users additional network functionality outside of what Docker
    natively offered. For instance, Weave provided overlay networks and **WeaveDNS**
    before Docker began supporting user-defined overlay networks and embedded DNS.
    However, with the more recent releases, Docker has started to gain feature parity
    from a network perspective with Weave. That being said, Weave still has a lot
    to offer and is an interesting example of how a third-party tool can interact
    with Docker to provide container networking. In this chapter, we'll walk through
    the basics of installing and configuring Weave to work with Docker as well as
    describe some of Weaves functionality from a network perspective. While we'll
    spend some time demonstrating some of the features of Weave this is not intended
    to be a how-to guide for the entire Weave solution. There are many features of
    Weave that will not be covered in this chapter. I recommend you check out their
    website for the most up–to-date information on features and functionality ([https://www.weave.works/](https://www.weave.works/)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Weave Net（简称Weave）是Docker的第三方网络解决方案。早期，它为用户提供了Docker本身没有提供的额外网络功能。例如，Weave在Docker开始支持用户定义的覆盖网络和嵌入式DNS之前，提供了覆盖网络和WeaveDNS。然而，随着最近的发布，Docker已经开始从网络的角度获得了与Weave相同的功能。也就是说，Weave仍然有很多可提供的功能，并且是第三方工具如何与Docker交互以提供容器网络的有趣示例。在本章中，我们将介绍安装和配置Weave的基础知识，以便与Docker一起工作，并从网络的角度描述Weave的一些功能。虽然我们将花一些时间演示Weave的一些功能，但这并不是整个Weave解决方案的操作指南。本章不会涵盖Weave的许多功能。我建议您查看他们的网站，以获取有关功能和功能的最新信息（[https://www.weave.works/](https://www.weave.works/)）。
- en: Installing and configuring Weave
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置Weave
- en: In this recipe, we'll walk through the installation of Weave as well as how
    to provision Weave services on your Docker hosts. We'll also show how Weave handles
    connecting hosts that wish to participate in the Weave network.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将介绍安装Weave以及如何在Docker主机上提供Weave服务。我们还将展示Weave如何处理希望参与Weave网络的主机的连接。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this example, we''ll be using the same lab topology we used in [Chapter
    3](ch03.html "Chapter 3. User-Defined Networks"), *User-Defined Networks*, where
    we discussed user-defined overlay networks:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用与[第3章](ch03.html "第3章。用户定义的网络")中使用的相同的实验室拓扑，*用户定义的网络*，在那里我们讨论了用户定义的覆盖网络：
- en: '![Getting ready](graphics/B05453_07_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](graphics/B05453_07_01.jpg)'
- en: You'll need a couple of hosts, preferably with some of them being on different
    subnets. It is assumed that the Docker hosts used in this lab are in their default
    configuration. In some cases, the changes we make may require you to have root-level
    access to the system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要一些主机，最好其中一些位于不同的子网。假设在本实验中使用的Docker主机处于其默认配置中。在某些情况下，我们所做的更改可能需要您具有系统的根级访问权限。
- en: How to do it…
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Weave is installed and managed through the Weave CLI tool. Once downloaded,
    it manages not only Weave-related configuration but also the provisioning of Weave
    services. On each host you wish to configure, you simply run the following three
    commands:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Weave是通过Weave CLI工具安装和管理的。一旦下载，它不仅管理与Weave相关的配置，还管理Weave服务的提供。在您希望配置的每个主机上，您只需运行以下三个命令：
- en: 'Download the Weave binary to your local system:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Weave二进制文件下载到您的本地系统：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Make the file executable:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使文件可执行：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run Weave:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Weave：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If all of these commands complete successfully, your Docker host is now ready
    to use Weave for Docker networking. To verify, you can check the Weave status
    using the `weave status` command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些命令都成功完成，您的Docker主机现在已准备好使用Weave进行Docker网络。要验证，您可以使用`weave status`命令检查Weave状态：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This output provides you with information regarding all five of Weave''s network-related
    services. Those are `router`, `ipam`, `dns`, `proxy`, and `plugin`. At this point,
    you might be wondering where all these services are running. Keeping with the
    Docker theme, they''re all running inside containers on the host:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出为您提供了有关Weave的所有五个与网络相关的服务的信息。它们是`router`、`ipam`、`dns`、`proxy`和`plugin`。此时，您可能想知道所有这些服务都在哪里运行。保持与Docker主题一致，它们都在主机上的容器内运行：
- en: '![How to do it…](graphics/B05453_07_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](graphics/B05453_07_02.jpg)'
- en: As you can see, there are three Weave-related containers running on the host.
    Running the `weave launch` command spawned all three containers. Each container
    provides unique services that Weave uses to network containers. The `weaveproxy`
    container serves as a shim layer allowing Weave to be leveraged directly from
    the Docker CLI. The `weaveplugin` container implements a custom network driver
    for Docker. The "`weave`" container is commonly called the Weave router and provides
    all the other services that are related to Weave networking.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，有三个与Weave相关的容器在主机上运行。运行`weave launch`命令生成了所有三个容器。每个容器提供Weave用于网络容器的独特服务。`weaveproxy`容器充当一个shim层，允许直接从Docker
    CLI利用Weave。`weaveplugin`容器实现了Docker的自定义网络驱动程序。"`weave`"容器通常被称为Weave路由器，并提供与Weave网络相关的所有其他服务。
- en: 'Each of these containers can be configured and run independently. Running Weave
    with the `weave launch` command assumes that you''d like to use all three containers
    and deploys them with a sane set of defaults. However, if you ever wish to change
    the settings related to a specific container, you''d need to launch the containers
    independently. This can be done in this manner:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器都可以独立配置和运行。使用`weave launch`命令运行Weave意味着您想要使用所有三个容器，并使用一组合理的默认值部署它们。但是，如果您希望更改与特定容器相关的设置，您需要独立启动容器。可以通过以下方式完成：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If at any time you wish to clean up the Weave configuration on a particular
    host, you can issue the `weave reset` command, which will clean up all the Weave-related
    service containers. To start our example, we''ll only be using the Weave router
    container. Let''s clear out the Weave configuration and then start just that container
    on our host `docker1`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在特定主机上清理Weave配置，可以发出`weave reset`命令，它将清理所有与Weave相关的服务容器。为了开始我们的示例，我们将只使用Weave路由器容器。让我们清除Weave配置，然后在我们的主机`docker1`上只启动该容器：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The Weave router (weave container) is the only container we need to provide
    the majority of the network functionality. Let''s take a look at the configuration
    options that are passed to the Weave router by default by inspecting the weave
    container configuration:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Weave路由器（weave容器）是我们需要提供大部分网络功能的唯一容器。让我们通过检查weave容器配置来查看默认情况下传递给Weave路由器的配置选项：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are some items worth pointing out in the preceding output. The IP allocation
    range is given as `10.32.0.0/12`. This is significantly different than the `172.17.0.0/16`
    we're used to dealing with by default on the `docker0` bridge. Also, there's an
    IP address defined to be used as the DNS listen address. Recall that Weave also
    provides WeaveDNS, which can be used to resolve the names of other containers
    on the Weave network by name. Notice that this IP address is that of the `docker0`
    bridge interface on the host.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中有一些值得指出的项目。IP分配范围被给定为`10.32.0.0/12`。这与我们默认在`docker0`桥上处理的`172.17.0.0/16`有很大不同。此外，还定义了一个IP地址用作DNS监听地址。回想一下，Weave还提供了WeaveDNS，可以用来解析Weave网络上其他容器的名称。请注意，这个IP地址就是主机上`docker0`桥接口的IP地址。
- en: 'Let''s now configure another one of our hosts as part of the Weave network:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将另一个主机配置为Weave网络的一部分：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that we installed Weave in the same manner as before, but when we launched
    the router container, we did so by specifying the IP address of the first Docker
    host. In Weave, this is how we peer multiple hosts together. Any host you wish
    to connect to the Weave network just needs to specify the IP address of any existing
    node on the Weave network. If we check the status of Weave on this newly attached
    node, we should see that it shows as connected:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们以与之前相同的方式安装了Weave，但是当我们启动路由器容器时，我们指定了第一个Docker主机的IP地址。在Weave中，这就是我们将多个主机连接在一起的方式。您希望连接到Weave网络的任何主机只需指定Weave网络上任何现有节点的IP地址。如果我们检查新连接的节点上的Weave状态，我们应该看到它显示为已连接：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can proceed to connect the other two remaining nodes in the same way after
    Weave is installed:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Weave后，我们可以继续以相同的方式连接另外两个剩余的节点：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In each case, we specify the previously joined Weave node as the peer of the
    node we are attempting to join. In our case, our join pattern looks like what''s
    shown in the following image:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，我们将先前加入的Weave节点指定为我们尝试加入的节点的对等体。在我们的情况下，我们的加入模式看起来像下面的图片所示：
- en: '![How to do it…](graphics/B05453_07_03.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B05453_07_03.jpg)'
- en: 'However, we could have had each node join any other existing node and achieved
    the same result. That is, joining nodes `docker2`, `docker3`, and `docker4` to
    `docker1` would have yielded the same end state. This is because Weave only needs
    to talk to an existing node to get information about the current state of the
    Weave network. Since all of the existing members have that information, it doesn''t
    matter which one they talk to in order to join a new node to the Weave network.
    If we check the status of any of the Weave nodes now, we should see that we have
    a total of four peers:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可以让每个节点加入到任何其他现有节点，并且得到相同的结果。也就是说，将节点`docker2`、`docker3`和`docker4`加入到`docker1`会产生相同的最终状态。这是因为Weave只需要与现有节点通信，以获取有关Weave网络当前状态的信息。由于所有现有成员都有这些信息，因此无论加入新节点时与哪个节点通信都无所谓。如果现在检查任何Weave节点的状态，我们应该看到我们有四个对等体：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can see that this node has three connections, one to each of the other joined
    nodes. This gives us a total of four peers with twelve connections, three per
    Weave node. So despite only configuring peering between three nodes, we end up
    with a full mesh for container connectivity between all the hosts:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个节点有三个连接，分别连接到其他两个加入的节点。这给我们总共四个对等体，共有十二个连接，每个Weave节点有三个连接。因此，尽管只在三个节点之间配置了对等连接，但最终我们得到了所有主机之间的容器连接的全网格：
- en: '![How to do it…](graphics/B05453_07_04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B05453_07_04.jpg)'
- en: 'Now the configuration of Weave is complete, and we have a full mesh network
    between all of our Weave-enabled Docker hosts. You can verify the connections
    that each host has with the other peers using the `weave status connections` command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Weave的配置已经完成，我们在所有启用Weave的Docker主机之间建立了一个完整的网状网络。您可以使用`weave status connections`命令验证每个主机与其他对等体的连接情况。
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You'll note that this configuration did not require the configuration of a standalone
    key-value store.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，此配置不需要配置独立的键值存储。
- en: It should also be noted that Weave peers can be managed manually using the Weave
    CLI `connect` and `forget` commands. If you fail to specify an existing member
    of the Weave network when you instantiate Weave, you can use Weave connect to
    manually connect to an existing member. Also, if you remove a member from the
    Weave network and don't expect it to return, you can tell the network to entirely
    forget the peer with the `forget` command.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 还应该注意，可以使用Weave CLI的`connect`和`forget`命令手动管理Weave对等体。如果在实例化Weave时未指定Weave网络的现有成员，可以使用Weave
    connect手动连接到现有成员。此外，如果从Weave网络中删除成员并且不希望其返回，可以使用`forget`命令告诉网络完全忘记对等体。
- en: Running Weave-connected containers
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Weave连接的容器
- en: Weave is an interesting example showcasing the different ways in which a third-party
    solution can interact with Docker. It offers several different approaches to interacting
    with Docker. The first is the Weave CLI from which you can not only configure
    Weave, but also spawn containers much like you would through the Docker CLI. The
    second is the network plugin, which ties directly into Docker and allows you to
    provision containers from Docker onto the Weave network. In this recipe, we'll
    walk through how to connect containers to the Weave network using the Weave CLI.
    The Weave network plugin will be covered in its own recipe later in this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Weave是一个有趣的例子，展示了第三方解决方案与Docker交互的不同方式。它提供了几种不同的与Docker交互的方法。第一种是Weave CLI，通过它不仅可以配置Weave，还可以像通过Docker
    CLI一样生成容器。第二种是网络插件，它直接与Docker绑定，允许您将Docker容器配置到Weave网络上。在本教程中，我们将演示如何使用Weave CLI将容器连接到Weave网络。Weave网络插件将在本章的后续教程中介绍。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Weave also offers an API proxy service that allows Weave to insert itself as
    a shim in between Docker and the Docker CLI transparently. That configuration
    will not be covered in this chapter, but they have extensive documentation about
    that functionality at this link:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Weave还提供了一个API代理服务，允许Weave在Docker和Docker CLI之间透明地插入自己。本章不涵盖该配置，但他们在此链接上有关于该功能的广泛文档。
- en: '[https://www.weave.works/docs/net/latest/weave-docker-api/](https://www.weave.works/docs/net/latest/weave-docker-api/)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.weave.works/docs/net/latest/weave-docker-api/](https://www.weave.works/docs/net/latest/weave-docker-api/)'
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is assumed that you're building off of the lab we created in the first recipe
    of this chapter. It is also assumed that the hosts have Docker and Weave installed.
    The Weave peering we defined in the previous chapter is also assumed to be in
    place.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在构建本章第一个教程中创建的实验室。还假设主机已安装了Docker和Weave。我们还假设在上一章中定义的Weave对等体已经就位。
- en: How to do it…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: When using the Weave CLI to manage container connectivity, there are two approaches
    you can take to connect a container to the Weave network.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Weave CLI管理容器连接时，有两种方法可以将容器连接到Weave网络。
- en: The first is to use the `weave` command to run a container. Weave accomplishes
    this by passing anything you specify after `weave run` to `docker run`. The advantage
    to this approach is that Weave is made aware of the connection since it's the
    one actually telling Docker to run the container.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是使用`weave`命令来运行一个容器。Weave通过将`weave run`后面指定的任何内容传递给`docker run`来实现这一点。这种方法的优势在于，Weave知道了连接，因为它实际上是在告诉Docker运行容器。
- en: 'This puts Weave in a perfect position to ensure that the container is started
    with the proper configuration for it to work on the Weave network. For instance,
    we can start a container named `web1` on the host `docker1` using this syntax:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得Weave处于一个完美的位置，可以确保容器以适当的配置启动，以便在Weave网络上工作。例如，我们可以使用以下语法在主机`docker1`上启动名为`web1`的容器：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that the syntax for the `run` command is identical to that of Docker.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`run`命令的语法与Docker的相同。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Despite the similarities, there are a couple of differences worth noting. Weave
    can only start containers in the background or `-d` mode. Also, you can not specify
    the `--rm` flag to remove the container after it finishes execution.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有相似之处，但有几点不同值得注意。Weave只能在后台或`-d`模式下启动容器。此外，您不能指定`--rm`标志在执行完毕后删除容器。
- en: 'Once the container is started in this manner, let''s look at the container''s
    interface configuration:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦以这种方式启动容器，让我们看一下容器的接口配置：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that the container now has an additional interface named `ethwe`, which
    has an IP address of `10.32.0.1/12`. This is the Weave network interface and is
    added in addition to the Docker network interface (`eth0`). If we check, we''ll
    note that since we passed the `-P` flag, Docker has published the containers-exposed
    port to several the `eth0` interface:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，容器现在有一个名为`ethwe`的额外接口，其IP地址为`10.32.0.1/12`。这是Weave网络接口，除了Docker网络接口（`eth0`）之外添加的。如果我们检查，我们会注意到，由于我们传递了`-P`标志，Docker已经将容器暴露的端口发布到了`eth0`接口上。
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This proves that all of the port publishing functionality we saw earlier is
    still done through Docker networking constructs. The Weave interface is just added
    in addition to the existing Docker native network interfaces.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了我们之前看到的所有端口发布功能仍然是通过Docker网络结构完成的。Weave接口只是添加到现有的Docker本机网络接口中。
- en: 'The second approach to connecting a container to the Weave network can be accomplished
    in two different ways but yields essentially the same result. Existing Docker
    containers can be added to the Weave network by either starting a currently stopped
    container using the Weave CLI, or by attaching a running container to Weave. Let''s
    look at each approach. First, let''s start a container on the host `docker2` in
    the same way we normally do using the Docker CLI and then restart it using Weave:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 连接容器到Weave网络的第二种方法可以通过两种不同的方式实现，但基本上产生相同的结果。可以通过使用Weave CLI启动当前停止的容器，或者将正在运行的容器附加到Weave来将现有的Docker容器添加到Weave网络。让我们看看每种方法。首先，让我们以与通常使用Docker
    CLI相同的方式在主机`docker2`上启动一个容器，然后使用Weave重新启动它：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So as you can see, Weave has taken care of adding the Weave interface to the
    container when it was restarted using the Weave CLI. Similarly, we can start a
    second instance of our `web1` container on the host `docker3` and then dynamically
    connect it to the Weave network with the `weave attach` command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如您所看到的，当使用Weave CLI重新启动容器时，Weave已经处理了将Weave接口添加到容器中。类似地，我们可以在主机`docker3`上启动我们的`web1`容器的第二个实例，然后使用`weave
    attach`命令动态连接到Weave网络：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we can see in the preceding output, the container did not have an `ethwe`
    interface until we manually attached it to the Weave network. The attachment was
    done dynamically without the need to restart the container. In addition to adding
    containers to the Weave network, you may also dynamically remove them from Weave
    using the `weave detach` command.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的输出中所看到的，容器在我们手动将其附加到Weave网络之前没有 `ethwe` 接口。附加是动态完成的，无需重新启动容器。除了将容器添加到Weave网络外，您还可以使用
    `weave detach` 命令动态将其从Weave中移除。
- en: 'At this point, you should have connectivity between all of the containers that
    are now connected to the Weave network. In my case, they were allocated the following
    IP addresses:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您应该已经连接到了Weave网络的所有容器之间的连通性。在我的情况下，它们被分配了以下IP地址：
- en: '`web1` on host `docker1`: `10.32.0.1`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web1` 在主机 `docker1` 上：`10.32.0.1`'
- en: '`web2` on host `docker2`: `10.44.0.0`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web2` 在主机 `docker2` 上：`10.44.0.0`'
- en: '`web1` on host `docker3`: `10.36.0.0`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web1` 在主机 `docker3` 上：`10.36.0.0`'
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This proves that the Weave network is working as expected and the containers
    are on the correct network segment.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了Weave网络正在按预期工作，并且容器位于正确的网络段上。
- en: Understanding Weave IPAM
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Weave IPAM
- en: As we saw multiple times in earlier chapters, IPAM is a critical component of
    any container networking solution. The criticality of IPAM becomes even clearer
    when you start using common networks across multiple Docker hosts. As the number
    of IP allocations begins to scale being able to resolve these containers by names
    also becomes vital. Much like Docker, Weave has its own integrated IPAM for their
    container network solution. In this chapter, we'll show how to configure and leverage
    Weave IPAM to manage IP allocations across the Weave network.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中多次看到的那样，IPAM是任何容器网络解决方案的关键组成部分。当您开始在多个Docker主机上使用常见网络时，IPAM的关键性变得更加清晰。随着IP分配数量的增加，能够通过名称解析这些容器也变得至关重要。与Docker一样，Weave为其容器网络解决方案提供了集成的IPAM。在本章中，我们将展示如何配置和利用Weave
    IPAM来管理Weave网络中的IP分配。
- en: Getting ready
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: It is assumed that you're building off of the lab we created in the first recipe
    of this chapter. It is also assumed that the hosts have Docker and Weave installed.
    Docker should be in its default configuration, and Weave should be installed but
    not yet peered. If you need to remove the peering defined in previous examples,
    issue the `weave reset` command on each host.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在基于本章第一个配方中创建的实验室进行构建。还假设主机已安装了Docker和Weave。Docker应该处于其默认配置状态，Weave应该已安装但尚未进行对等连接。如果您需要删除先前示例中定义的对等连接，请在每个主机上发出
    `weave reset` 命令。
- en: How to do it…
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Weave's solution to IPAM relies on the Weave network as a whole using one large
    subnet, which is then carved into smaller pieces and allocated directly to each
    host. The host then allocates container IP addresses out of the IP address pool
    it was allocated. In order for this to work, the Weave cluster has to agree on
    what IP allocations to assign to each host. It does this by first reaching a consensus
    within the cluster. If you have a general idea of how large your cluster will
    be, you can provide specifics to Weave during initialization that help it make
    a better decision.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Weave对IPAM的解决方案依赖于整个Weave网络使用一个大的子网，然后将其划分为较小的部分，并直接分配给每个主机。然后主机从分配给它的IP地址池中分配容器IP地址。为了使其工作，Weave集群必须就要分配给每个主机的IP分配达成一致意见。它首先在集群内部达成共识。如果您大致知道您的集群将有多大，您可以在初始化期间向Weave提供具体信息，以帮助它做出更好的决定。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The goal of this recipe is not to get into specifics on optimizing the consensus
    algorithm that Weave uses with IPAM. For specifics on that, see the following
    link:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的目标不是深入讨论Weave与IPAM使用的共识算法的细节。有关详细信息，请参阅以下链接：
- en: '[https://www.weave.works/docs/net/latest/ipam/](https://www.weave.works/docs/net/latest/ipam/)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.weave.works/docs/net/latest/ipam/](https://www.weave.works/docs/net/latest/ipam/)'
- en: For the sake of this recipe, we'll assume that you don't know how big your cluster
    will be and we'll work off the premise that it will start with two hosts and expand
    from there.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个示例，我们假设您不知道您的集群有多大，我们将假设它将从两个主机开始并从那里扩展。
- en: 'It''s important to understand that the IPAM in Weave sits idle until you provision
    your first container. For instance, let''s start by configuring Weave on the host
    `docker1`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，Weave中的IPAM在您首次配置容器之前处于空闲状态。例如，让我们从在主机`docker1`上配置Weave开始：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first thing you should notice is the addition of the parameter `--ipalloc-range`.
    As we mentioned earlier, Weave works off the concept of one large subnet. By default,
    this subnet is `10.32.0.0/12`. This default setting can be overridden during Weave
    initialization by passing the `--ipalloc-range` flag to Weave. To make these examples
    a little easier to understand, I decided to change the default subnet to something
    more manageable; in this case, `172.16.16.0/24`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意到的第一件事是添加参数`--ipalloc-range`。正如我们之前提到的，Weave是基于一个大子网的概念工作。默认情况下，这个子网是`10.32.0.0/12`。在Weave初始化期间，可以通过向Weave传递`--ipalloc-range`标志来覆盖此默认设置。为了使这些示例更容易理解，我决定将默认子网更改为更易管理的内容；在这种情况下，是`172.16.16.0/24`。
- en: 'Let''s also run the same command on the host `docker2` but pass it the IP address
    of the host `docker1`, so it can immediately peer:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还在主机`docker2`上运行相同的命令，但是传递主机`docker1`的IP地址，以便它可以立即进行对等连接：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that I once again passed the same subnet to Weave. It is critical that
    the IP allocation range on each host running Weave is identical. Only hosts that
    agree on the same IP allocation range will be able to function properly. Let''s
    now check the status of the Weave services:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我再次向Weave传递了相同的子网。每个运行Weave的主机上的IP分配范围相同是至关重要的。只有同意相同IP分配范围的主机才能正常运行。现在让我们检查一下Weave服务的状态：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output shows two peers indicating that our peering to `docker1` was successful.
    Note that the IPAM service shows a status of `idle`. The `idle` status means that
    Weave is waiting for more peers to join before it makes any decisions about what
    hosts will get what IP allocations. Let''s see what happens when we run a container:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示两个对等点，表明我们对`docker1`的对等连接成功。请注意，IPAM服务显示为`idle`状态。`idle`状态意味着Weave正在等待更多对等点加入，然后才会做出关于哪些主机将获得哪些IP分配的决定。让我们看看当我们运行一个容器时会发生什么：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we check the Weave status again, we should see that IPAM has now changed
    from **idle** to **ready**:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次检查Weave状态，我们应该看到IPAM现在已从**idle**更改为**ready**：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Running the first container connected to the Weave network has forced Weave
    to come to a consensus. At this point, Weave has decided that the cluster size
    is two and has made its best effort to allocate the available IP addressing between
    the hosts. Let''s run a container on the host `docker1` as well and then check
    the IP addresses that were allocated to each container:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到Weave网络的第一个容器迫使Weave达成共识。此时，Weave已经决定集群大小为两，并已尽最大努力在主机之间分配可用的IP地址。让我们在主机`docker1`上运行一个容器，然后检查分配给每个容器的IP地址：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Using the **weave ps** command, we can see that the container we just spawned
    on the host `docker1` received an IP address of `172.16.16.1/24`. If we check
    the IP address of the container `web2` on the host `docker2`, we''ll see that
    it got an IP address of `172.16.16.128/24`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**weave ps**命令，我们可以看到我们刚刚在主机`docker1`上生成的容器收到了IP地址`172.16.16.1/24`。如果我们检查主机`docker2`上的容器`web2`的IP地址，我们会看到它获得了IP地址`172.16.16.128/24`：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This makes perfect sense. Weave knew that it had two members in the network
    so it splits the allocation directly in half, essentially giving each host its
    own `/25` network allocation. `docker1` started allocating out of the first half
    of the `/24` and `docker2` started right at the beginning of the second half.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常合理的。Weave知道网络中有两个成员，所以它直接将分配分成两半，基本上为每个主机提供自己的`/25`网络分配。`docker1`开始分配`/24`的前半部分，`docker2`则从后半部分开始。
- en: 'Despite fully allocating the entire space, it does not mean that we are now
    out of IP space. These initial allocations are more like reservations and can
    be changed based on the size of the Weave network. For instance, we can now add
    the host `docker3` to the Weave network and start another instance of the `web1`
    container on it:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管完全分配了整个空间，这并不意味着我们现在用完了IP空间。这些初始分配更像是预留，可以根据Weave网络的大小进行更改。例如，我们现在可以将主机`docker3`添加到Weave网络，并在其上启动`web1`容器的另一个实例：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Because the network now has more members, Weave just further splits the initial
    allocation into smaller chunks. Based on the IP addresses being allocated to the
    containers on each host, we can see that Weave tries to keep the allocations within
    valid subnets. The following image shows what would happen to the IP allocations
    as the third and fourth hosts joined the Weave network:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因为网络现在有更多成员，Weave只是进一步将初始分配分成更小的块。根据分配给每个主机上容器的IP地址，我们可以看到Weave试图保持分配在有效的子网内。以下图片显示了第三和第四个主机加入Weave网络时IP分配的情况：
- en: '![How to do it…](graphics/B05453_07_05.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_07_05.jpg)'
- en: It's important to keep in mind that while the allocations given to each server
    are flexible, they all use the same mask as the initial allocation when they assign
    the IP address to the container. This ensures that the containers all assume that
    they are on the same network and have direct connectivity to each other removing
    the need to have routes pointing to other hosts.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，尽管分配给每台服务器的分配是灵活的，但当它们为容器分配IP地址时，它们都使用与初始分配相同的掩码。这确保容器都假定它们在同一个网络上，并且彼此直接连接，无需有路由指向其他主机。
- en: 'To prove that the initial IP allocation must be the same across all hosts,
    we can try joining the last host, `docker4`, using a different subnet:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明初始IP分配必须在所有主机上相同，我们可以尝试使用不同的子网加入最后一个主机`docker4`：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we check the Weave router''s container for logs, we''ll see that it''s unable
    to join the existing Weave network because of having the wrong IP allocation defined:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查Weave路由器容器的日志，我们会发现它无法加入现有的Weave网络，因为定义了错误的IP分配：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The only way to join the existing Weave network would be to use the same initial
    IP allocation as all of the existing nodes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 加入现有的Weave网络的唯一方法是使用与所有现有节点相同的初始IP分配。
- en: 'Finally, it''s important to call out that it''s not a requirement to use Weave
    IPAM in this fashion. You can allocate IP addressing manually by specifying an
    IP address during a `weave run` like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重要的是要指出，不是必须以这种方式使用Weave IPAM。您可以通过在`weave run`期间手动指定IP地址来手动分配IP地址，就像这样：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When specifying individual IP addresses, you can choose any IP address you like.
    As you'll see in a later recipe, you can also specify a subnet for allocation
    and have Weave keep track of that subnet allocation in IPAM. When assigning an
    IP address from a subnet the subnet must be part of the initial Weave allocation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定单个IP地址时，您可以选择任何IP地址。正如您将在后面的配方中看到的那样，您还可以指定用于分配的子网，并让Weave跟踪该子网在IPAM中的分配。在从子网分配IP地址时，子网必须是初始Weave分配的一部分。
- en: 'If you wish to manually allocate IP addresses to some containers, it may be
    wise to configure an additional Weave parameter during the initial Weave configuration
    to limit the scope of the dynamic allocations. You may pass the `--ipalloc-default-subnet`
    parameter to Weave during launch to limit the scope of which IP addresses are
    dynamically assigned to hosts. For instance, you might pass this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望手动为某些容器分配IP地址，可能明智的是在初始Weave配置期间配置额外的Weave参数，以限制动态分配的范围。您可以在启动时向Weave传递`--ipalloc-default-subnet`参数，以限制动态分配给主机的IP地址的范围。例如，您可以传递以下内容：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This would configure the Weave subnet to be `172.16.16.0/25` leaving the rest
    of the larger network available for manual allocation. We'll see in a later recipe
    that this type of configuration plays a big role in how Weave handles network
    isolation across the Weave network.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将配置Weave子网为`172.16.16.0/25`，使较大网络的其余部分可用于手动分配。我们将在后面的教程中看到，这种类型的配置在Weave如何处理Weave网络上的网络隔离中起着重要作用。
- en: Working with WeaveDNS
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WeaveDNS
- en: Naturally, the next thing to consider after IPAM is name resolution. Regardless
    of scale, having some way to locate and identify containers by something other
    than an IP address becomes a necessity. Much like newer versions of Docker, Weave
    offers its own DNS service for resolving container names that live on Weave networks.
    In this recipe, we'll review the default configuration for WeaveDNS as well as
    show how it's implemented and some relevant configuration settings to get you
    up and running.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 自然而然，在IPAM之后要考虑的下一件事是名称解析。无论规模如何，都需要一种方法来定位和识别容器，而不仅仅是IP地址。与较新版本的Docker一样，Weave为解析Weave网络上的容器名称提供了自己的DNS服务。在本教程中，我们将审查WeaveDNS的默认配置，以及它是如何实现的，以及一些相关的配置设置，让您可以立即开始运行。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is assumed that you're building off the lab we created in the first recipe
    of this chapter. It is also assumed that the hosts have Docker and Weave installed.
    Docker should be in its default configuration and Weave should be installed with
    all four hosts successfully peered together, as we did in the first recipe of
    this chapter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在构建本章第一个教程中创建的实验室。还假设主机已安装了Docker和Weave。Docker应该处于默认配置状态，并且Weave应该已成功地与所有四个主机进行了对等连接，就像我们在本章的第一个教程中所做的那样。
- en: How to do it…
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'If you''ve been following along up until this point in the chapter, you''ve
    already provisioned WeaveDNS. WeaveDNS comes along with the Weave router container
    and is enabled by default. We can see this by looking at the Weave status:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直在本章中跟随到这一点，您已经配置了WeaveDNS。WeaveDNS随Weave路由器容器一起提供，并且默认情况下已启用。我们可以通过查看Weave状态来看到这一点：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When Weave provisions the DNS service, it starts with some sane defaults. In
    this case, it''s detected that my hosts DNS server is `10.20.30.13`, and so it
    has configured that as an upstream resolver. It''s also selected `weave.local`
    as the domain name. If we start a container using the weave run syntax, Weave
    will make sure that the container is provisioned in a manner that allows it to
    consume this DNS service. For instance, let''s start a container on the host `docker1`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当Weave配置DNS服务时，它会从一些合理的默认值开始。在这种情况下，它检测到我的主机DNS服务器是`10.20.30.13`，因此将其配置为上游解析器。它还选择了`weave.local`作为域名。如果我们使用weave
    run语法启动容器，Weave将确保容器以允许其使用此DNS服务的方式进行配置。例如，让我们在主机`docker1`上启动一个容器：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After starting the container, we can see that Weave has configured the container''s
    `resolv.conf` file differently than Docker would have. Recall that Docker, by
    default, in nonuser-defined networks, will give a container the same DNS configuration
    as the Docker hosts itself. In this case, Weave has given the container a name
    server of `172.17.0.1`, which is, by default, the IP address assigned to the `docker0`
    bridge. You might be wondering how Weave expects the container to resolve its
    own DNS system by talking to the `docker0` bridge. The solution is quite simple.
    The Weave router container is run in host mode and has a service bound to port
    `53`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 启动容器后，我们可以看到Weave已经配置了容器的`resolv.conf`文件，与Docker的默认配置不同。回想一下，默认情况下，在非用户定义的网络中，Docker会给容器分配与Docker主机本身相同的DNS配置。在这种情况下，Weave给容器分配了一个名为`172.17.0.1`的名称服务器，默认情况下是分配给`docker0`桥接口的IP地址。您可能想知道Weave如何期望容器通过与`docker0`桥接口通信来解析自己的DNS系统。解决方案非常简单。Weave路由器容器以主机模式运行，并绑定到端口`53`的服务。
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we check the ports bound on the host, we can see that the weave router is
    exposing port `53`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查主机上绑定的端口，我们可以看到weave路由器正在暴露端口`53`：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This means that the WeaveDNS service in the Weave container will be listening
    on the `docker0` bridge interface for DNS requests. Let''s start another container
    on the host `docker2`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Weave容器中的WeaveDNS服务将在`docker0`桥接口上监听DNS请求。让我们在主机`docker2`上启动另一个容器：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As long as both containers are on the Weave network and have the appropriate
    settings, Weave will automatically generate a DNS record with the containers name.
    We can view all the name records Weave is aware of using the `weave status dns`
    command from any Weave-enabled host:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 只要两个容器都在Weave网络上并且具有适当的设置，Weave将自动生成一个包含容器名称的DNS记录。我们可以使用`weave status dns`命令从任何Weave启用的主机上查看Weave知道的所有名称记录：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we can see the container name, the IP address, the container ID, and the
    MAC address of the destination host's Weave network interface.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到目标主机的Weave网络接口的容器名称、IP地址、容器ID和MAC地址。
- en: 'This works well but relies on the container being configured with the appropriate
    settings. This is another scenario where using the Weave CLI is rather helpful
    since it ensures that these settings are in place at container runtime. For instance,
    if we start another container on the host `docker3` with the Docker CLI and then
    attach it to Docker, it won''t get a DNS record:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有效，但依赖于容器配置了适当的设置。这是另一种情况，使用Weave CLI会非常有帮助，因为它确保这些设置在容器运行时生效。例如，如果我们在主机`docker3`上使用Docker
    CLI启动另一个容器，然后将其连接到Docker，它将不会获得DNS记录：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This doesn''t work for two reasons. First, the container doesn''t know where
    to look for Weave DNS, and it is trying to resolve it through the DNS server Docker
    provided. In this case, that''s the one configured on the Docker host:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两个原因不起作用。首先，容器不知道在哪里查找Weave DNS，并且试图通过Docker提供的DNS服务器来解析它。在这种情况下，这是在Docker主机上配置的一个：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Second, Weave did not register a record in WeaveDNS when the container was
    attached. In order for Weave to generate a record for the container in WeaveDNS,
    the container must be in the same domain. To do this, when Weave runs a container
    through its CLI, it passes the hostname of the container along with a domain name.
    We can mimic this behavior by provisioning a hostname when we run the container
    in Docker. For instance:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，当容器被连接时，Weave没有在WeaveDNS中注册记录。为了使Weave在WeaveDNS中为容器生成记录，容器必须在相同的域中。为此，当Weave通过其CLI运行容器时，它会传递容器的主机名以及域名。当我们在Docker中运行容器时，我们可以通过提供主机名来模拟这种行为。例如：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now when we attach the container to the Weave network, we should see a DNS
    record generated for it:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们将容器连接到Weave网络时，我们应该看到为其生成的DNS记录：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you wanted to have this container also be able to resolve records in WeaveDNS,
    you'd also need to pass the `--dns=172.17.0.1` flag to the container to ensure
    that its DNS server is set to the IP address of the `docker0` bridge.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望该容器还能够解析WeaveDNS中的记录，还需要向容器传递`--dns=172.17.0.1`标志，以确保其DNS服务器设置为`docker0`桥的IP地址。
- en: 'You might have noticed that we now have two entries in WeaveDNS for the same
    container name. This is how Weave provides for basic load balancing within the
    Weave network. For instance, if we head back to the `docker2` host, let''s try
    and ping the name `web1` a couple of different times:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们现在在WeaveDNS中有相同容器名称的两个条目。这是Weave在Weave网络中提供基本负载平衡的方式。例如，如果我们回到`docker2`主机，让我们尝试多次ping名称`web1`：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note how the container is resolving to a different IP address during the second
    ping attempt. Since there are multiple records in WeaveDNS for the same name,
    we can provide basic load balancing functionality just using DNS. Weave will also
    track the state of the containers and pull dead containers out of WeaveDNS. For
    instance, if we kill the container on the host `docker3`, we should see one of
    the `web1` records fall out of DNS leaving only a single record for `web1`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第二次ping尝试期间，容器解析为不同的IP地址。由于WeaveDNS中有相同名称的多个记录，我们可以仅使用DNS提供基本负载平衡功能。Weave还将跟踪容器的状态，并将死掉的容器从WeaveDNS中移除。例如，如果我们在`docker3`主机上杀死容器，我们应该看到`web1`记录中的一个被移出DNS，只留下`web1`的单个记录：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are many different configuration options available to you for customizing
    how WeaveDNS works. To see the entire guide, check out the documentation at [https://www.weave.works/docs/net/latest/weavedns/](http://
    https://www.weave.works/docs/net/latest/weavedns/).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的配置选项可供您自定义WeaveDNS的工作方式。要查看完整指南，请查看[https://www.weave.works/docs/net/latest/weavedns/](http://
    https://www.weave.works/docs/net/latest/weavedns/)上的文档。
- en: Weave security
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Weave安全性
- en: Weave offers a couple of features that fall under the umbrella of security.
    Since Weave is an overlay-based network solution, it offers the ability to encrypt
    the overlay traffic as it traverses the physical or underlay network. This can
    be particularly useful when your containers may need to traverse a public network.
    In addition, Weave allows you to isolate containers within certain network segments.
    Weave relies on using different subnets for each isolated segment to achieve this.
    In this recipe, we'll walk through how to configure both overlay encryption as
    well as how to provide isolation for different containers across the Weave network.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Weave提供了一些属于安全性范畴的功能。由于Weave是一种基于覆盖的网络解决方案，它提供了在物理或底层网络中传输覆盖流量的加密能力。当您的容器可能需要穿越公共网络时，这可能特别有用。此外，Weave允许您在某些网络段内隔离容器。Weave依赖于为每个隔离的段使用不同的子网来实现此目的。在本配方中，我们将介绍如何配置覆盖加密以及如何为Weave网络中的不同容器提供隔离。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is assumed that you're building off the lab we created in the first recipe
    of this chapter. It is also assumed that the hosts have Docker and Weave installed.
    Docker should be in its default configuration, and Weave should be installed but
    not yet peered. If you need to remove the peering defined in previous examples,
    issue the `weave reset` command on each host.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在构建本章第一个配方中创建的实验室。还假设主机已安装了Docker和Weave。Docker应该处于默认配置状态，Weave应该已安装但尚未进行对等连接。如果您需要删除先前示例中定义的对等连接，请在每个主机上发出`weave
    reset`命令。
- en: How to do it…
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Configuring Weave to encrypt the overlay network is fairly straightforward
    to accomplish; however, it must be done during the initial configuration of Weave.
    Using the same lab topology from the previous recipes, let''s run the following
    commands to build the Weave network:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 配置Weave以加密覆盖网络相当容易实现；但是，必须在Weave的初始配置期间完成。使用前面配方中的相同实验拓扑，让我们运行以下命令来构建Weave网络：
- en: 'On the host `docker1`:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主机`docker1`上：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'On the hosts `docker2`, `docker3`,and `docker4`:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主机`docker2`，`docker3`和`docker4`上：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You''ll note that the command we run on the hosts is largely the same with
    the exception of the last three hosts specifying `docker1` as a peer in order
    to build the Weave network. In either case, there are a few additional parameters
    we''ve passed to the router during Weave initialization:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们在主机上运行的命令基本相同，只是最后三个主机指定`docker1`作为对等体以构建Weave网络。在任何情况下，在Weave初始化期间，我们传递了一些额外的参数给路由器：
- en: '`--password`: This is what enables the encryption for the communication between
    Weave nodes. You should, unlike in my example, pick a very secure password to
    use. This needs to be the same on every node running weave.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--password`：这是启用Weave节点之间通信加密的参数。与我的示例不同，您应该选择一个非常安全的密码来使用。这需要在运行weave的每个节点上相同。'
- en: '`--trusted-subnets`: This allows you to define subnets of hosts as trusted,
    which means they don''t require their communication to be encrypted. When Weave
    does encryption it falls back to a slower data path than what is normally used.
    Since using the `--password` parameter turns on encryption end to end, it might
    make sense to define some subnets as not needing encryption'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--trusted-subnets`：这允许您定义主机子网为受信任的，这意味着它们不需要加密通信。当Weave进行加密时，它会退回到比通常使用的更慢的数据路径。由于使用`--password`参数会打开端到端的加密，定义一些子网不需要加密可能是有意义的'
- en: '`--ipalloc-range`: Here, we define the larger Weave network to be `172.16.16.0/24`.
    We saw this command used in earlier recipes:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--ipalloc-range`：在这里，我们定义更大的Weave网络为`172.16.16.0/24`。我们在之前的配方中看到了这个命令的使用：'
- en: '`--ipalloc-default-subnet`: This instructs Weave to, by default, allocate container
    IP addresses out of a smaller subnet of the larger Weave allocation. In this case,
    that''s `172.16.16.128/25`.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--ipalloc-default-subnet`：这指示Weave默认从更大的Weave分配中的较小子网中分配容器IP地址。在这种情况下，那就是`172.16.16.128/25`。'
- en: 'Now, let''s run the following containers on each host:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在每个主机上运行以下容器：
- en: '`docker1`:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker1`：'
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`docker2`:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker2`：'
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`docker3`:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker3`：'
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`docker4`:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker4`：'
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You''ll note that on the host `docker3` and `docker4`, I added the `net:172.16.16.0/25`
    parameter. Recall when we started the Weave network, we told Weave to by default
    allocate IP addresses out of `172.16.16.128/25`. We can override this at container
    runtime and provide a new subnet for Weave to use so long as it''s within the
    larger Weave network. In this case, the containers on `docker1` and `docker2`
    will get an IP address within `172.16.16.128/25` because that is the default.
    The containers on `docker3` and `docker4` will get an IP address within `172.16.16.0/25`
    since we overrode the default. We can confirm this once you''ve started all the
    containers:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在主机`docker3`和`docker4`上，我添加了`net:172.16.16.0/25`参数。回想一下，当我们启动Weave网络时，我们告诉Weave默认从`172.16.16.128/25`中分配IP地址。只要在更大的Weave网络范围内，我们可以在容器运行时覆盖这一设置，并为Weave提供一个新的子网来使用。在这种情况下，`docker1`和`docker2`上的容器将获得`172.16.16.128/25`内的IP地址，因为这是默认设置。`docker3`和`docker4`上的容器将获得`172.16.16.0/25`内的IP地址，因为我们覆盖了默认设置。一旦您启动了所有容器，我们可以确认这一点：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As I mentioned earlier, using distinct subnets is how Weave provides for container
    segmentation. In this case, the topology would look like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，使用不同的子网是Weave提供容器分割的方式。在这种情况下，拓扑将如下所示：
- en: '![How to do it…](graphics/B05453_07_06.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](graphics/B05453_07_06.jpg)'
- en: 'The dotted lines symbolize the isolation that Weave is providing for us in
    the overlay network. Since the `tenant1` containers live is a separate subnet
    from the `tenant2` containers, they will not have connectivity. In this manner,
    Weave is using basic networking to allow for container isolation. We can prove
    this works with a few tests:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虚线象征着Weave在覆盖网络中为我们提供的隔离。由于`tenant1`容器位于与`tenant2`容器不同的子网中，它们将无法连接。这样，Weave使用基本的网络来实现容器隔离。我们可以通过一些测试来证明这一点：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You'll notice that when the `web2tenant2` container attempts to access a service
    within its own tenant (subnet), it works as expected. Attempts to access a service
    in `tenant1` receive no response. However, since DNS is shared across the Weave
    network, the container can still resolve the IP address of the containers in `tenant1`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当`web2tenant2`容器尝试访问其自己租户（子网）中的服务时，它按预期工作。尝试访问`tenant1`中的服务将不会收到响应。但是，由于DNS在Weave网络中是共享的，容器仍然可以解析`tenant1`中容器的IP地址。
- en: 'This also illustrates an example of encryption and how we can specify certain
    hosts as being trusted. Regardless of which subnetwork the containers live in,
    Weave still builds connectivity between all of the hosts. Since we enabled encryption
    during Weave initialization, all of those connections should now be encrypted.
    However, we also specified a trusted network. The trusted network defines nodes
    that do not require encryption between themselves. In our case, we specified `192.168.50.0/24`
    as being trusted. Since there are two nodes that have those IP addresses, `docker3`
    and `docker4`, we should see that the connectivity between them is unencrypted.
    We can validate that using the weave status connections command on the hosts.
    We should get the following response:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这也说明了加密的例子，以及我们如何指定某些主机为受信任的。无论容器位于哪个子网中，Weave仍然在所有主机之间建立连接。由于我们在Weave初始化期间启用了加密，所有这些连接现在应该是加密的。但是，我们还指定了一个受信任的网络。受信任的网络定义了不需要在它们之间进行加密的节点。在我们的情况下，我们指定`192.168.50.0/24`为受信任的网络。由于有两个具有这些IP地址的节点，`docker3`和`docker4`，我们应该看到它们之间的连接是未加密的。我们可以在主机上使用weave
    status connections命令来验证这一点。我们应该得到以下响应：
- en: '`docker1` (truncated output):'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker1`（截断输出）：'
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`docker2` (truncated output):'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker2`（截断输出）：'
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`docker3` (truncated output):'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker3`（截断输出）：'
- en: '[PRE52]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`docker4` (truncated output):'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker4`（截断输出）：'
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You can see that all the connections show as encrypted with the exception of
    the connections between the host `docker3` (`192.168.50.101`) and the host `docker4`
    (`192.168.50.102`). Since both hosts need to agree on what a trusted network is,
    the hosts `docker1` and `docker2` will never agree for their connections to be
    unencrypted.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到所有的连接都显示为加密，除了主机`docker3`（`192.168.50.101`）和主机`docker4`（`192.168.50.102`）之间的连接。由于两个主机需要就受信任的网络达成一致，主机`docker1`和`docker2`将永远不会同意它们的连接是未加密的。
- en: Using the Weave network plugin
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Weave网络插件
- en: One of the things that sets Weave apart is that it can be operated in several
    different manners. As we've seen in the previous recipes of this chapter, Weave
    has its own CLI which we can use to provision containers directly onto the Weave
    network. While this is certainly a tight integration that works well, it requires
    that you leverage the Weave CLI or Weave API proxy to integrate with Docker. In
    addition to these options, Weave has also written a native Docker network plugin.
    This plugin allows you to work with Weave directly from Docker. That is, once
    the plugin is registered, you no longer need to use the Weave CLI to provision
    containers into Weave. In this recipe, we'll review how to install and work with
    the Weave network plugin.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Weave的一个特点是它可以以几种不同的方式操作。正如我们在本章的前几个示例中看到的，Weave有自己的CLI，我们可以使用它直接将容器配置到Weave网络中。虽然这当然是一种紧密集成的工作方式，但它要求您利用Weave
    CLI或Weave API代理与Docker集成。除了这些选项，Weave还编写了一个原生的Docker网络插件。这个插件允许您直接从Docker中使用Weave。也就是说，一旦插件注册，您就不再需要使用Weave
    CLI将容器配置到Weave中。在本示例中，我们将介绍如何安装和使用Weave网络插件。
- en: Getting ready
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is assumed that you're building off the lab we created in the first recipe
    of this chapter. It is also assumed that the hosts have Docker and Weave installed.
    Docker should be in its default configuration, Weave should be installed, with
    all four hosts successfully peered together, as we did in the first recipe of
    this chapter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在基于本章第一个示例中创建的实验室进行构建。还假设主机已经安装了Docker和Weave。Docker应该处于默认配置状态，Weave应该已安装，并且所有四个主机已成功互联，就像我们在本章的第一个示例中所做的那样。
- en: How to do it…
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Like the other components of Weave, leveraging the Docker plugin couldn''t
    be easier. All you need to do is to tell Weave to launch it. For instance, if
    I decided to use the Docker plugin on the host `docker1`, I could launch the plugin
    like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与Weave的其他组件一样，利用Docker插件非常简单。您只需要告诉Weave启动它。例如，如果我决定在主机`docker1`上使用Docker插件，我可以这样启动插件：
- en: '[PRE54]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Much like the other services, the plugin comes in the form of a container.
    After running the preceding command, you should see the plugin running as a container
    named `weaveplugin`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他服务一样，该插件以容器的形式存在。在运行了前面的命令之后，您应该看到插件作为名为`weaveplugin`的容器运行：
- en: '![How to do it…](graphics/B05453_07_07.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_07_07.jpg)'
- en: 'Once running, you should also see it registered as a network plugin:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行，您还应该看到它注册为一个网络插件：
- en: '[PRE55]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can also see it as a defined network type using the `docker network` subcommand:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将其视为使用`docker network`子命令定义的网络类型：
- en: '[PRE56]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'At this point, connecting containers to the Weave network can be done directly
    through Docker. All you need to do is specify the network name of `weave` when
    you start a container. For instance, we can run:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，通过Docker直接将容器连接到Weave网络可以直接完成。您只需要在启动容器时指定`weave`的网络名称。例如，我们可以运行：
- en: '[PRE57]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If we look at the container interfaces we should see the two interfaces we''re
    accustomed to seeing with Weave connected containers:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看容器接口，我们应该看到我们习惯在Weave连接的容器中看到的两个接口：
- en: '[PRE58]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: However, you might note that the IP address for `eth1` is not on the `docker0`
    bridge, but rather on `docker_gwbridge` we saw used in earlier chapters when we
    showed the Docker overlay driver. The benefit of using the gateway bridge rather
    than the `docker0` bridge is that the gateway bridge has ICC disabled by default.
    This prevents Weave connected containers that are supposed to be isolated from
    accidentally cross talking across the `docker0` bridge if you had ICC mode enabled.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可能会注意到`eth1`的IP地址不在`docker0`桥上，而是在我们在早期章节中看到的`docker_gwbridge`上使用的。使用网关桥而不是`docker0`桥的好处是，网关桥默认情况下已禁用ICC。这可以防止Weave连接的容器意外地在`docker0`桥上跨通信，如果您启用了ICC模式。
- en: 'A downside to the plugin approach is that Weave isn''t in the middle to tell
    Docker about the DNS-related configurations, which means that the containers aren''t
    registering their names. Even if they were, they also aren''t receiving the proper
    name resolution settings required to resolve WeaveDNS. There are two ways we can
    specify the proper settings to the container. In either case, we need to manually
    specify the parameters at container runtime. The first method involves manually
    specifying all the required parameters yourself. Manually, it''s done as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 插件方法的一个缺点是Weave不在中间告诉Docker有关DNS相关的配置，这意味着容器没有注册它们的名称。即使它们注册了，它们也没有接收到解析WeaveDNS所需的正确名称解析设置。我们可以指定容器的正确设置的两种方法。在任何一种情况下，我们都需要在容器运行时手动指定参数。第一种方法涉及手动指定所有必需的参数。手动完成如下：
- en: '[PRE59]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In order to register with DNS, you need the four bolded settings shown in the
    preceding code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了注册DNS，您需要在前面的代码中显示的四个加粗设置：
- en: '`--hostname=web1.weave.local`: If you don''t set the hostname of the container
    to a name within `weave.local`, the DNS server won''t register the name.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--hostname=web1.weave.local`：如果您不将容器的主机名设置为`weave.local`中的名称，DNS服务器将不会注册该名称。'
- en: '`--net=weave`: It has to be on the Weave network for any of this to work.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--net=weave`：它必须在Weave网络上才能正常工作。'
- en: '`--dns=172.17.0.1`: We need to tell it to use the Weave DNS server listening
    on the `docker0` bridge IP address. However, you might have noticed that this
    container doesn''t actually have an IP address on the `docker0` bridge. Rather,
    since we''re connected to the `docker-gwbridge`, we have an IP address in the
    `172.18.0.0/16` network. In either case, since both bridges have IP interfaces
    the container can route through the `docker_gwbridge` to get to the IP interface
    on the `docker0` bridge.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--dns=172.17.0.1`：我们需要告诉它使用在`docker0`桥IP地址上监听的Weave DNS服务器。但是，您可能已经注意到，该容器实际上并没有在`docker0`桥上拥有IP地址。相反，由于我们连接到`docker-gwbridge`，我们在`172.18.0.0/16`网络中有一个IP地址。在任何一种情况下，由于两个桥都有IP接口，容器可以通过`docker_gwbridge`路由到`docker0`桥上的IP接口。'
- en: '`--dns-search=weave.local`: This allows the container to resolve names without
    specifying the **Fully Qualified Domain Name** (**FQDN**).'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--dns-search=weave.local`：这允许容器解析名称而无需指定**完全限定域名**（**FQDN**）。'
- en: 'Once a container is started with these settings, you should see records registering
    in WeaveDNS:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用这些设置启动容器，您应该看到WeaveDNS中注册的记录：
- en: '[PRE60]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The second solution is still manual but involves pulling the DNS information
    from Weave itself. Rather than specifying the DNS server and the search domain,
    you can inject it right from Weave. Weave has a command named `dns-args` that
    will return the relevant information for you. So rather than specifying it, we
    can simply inject that command as part of the container parameters like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种解决方案仍然是手动的，但涉及从Weave本身提取DNS信息。您可以从Weave中注入DNS服务器和搜索域，而不是指定它。Weave有一个名为`dns-args`的命令，将为您返回相关信息。因此，我们可以简单地将该命令作为容器参数的一部分注入，而不是指定它，就像这样：
- en: '[PRE61]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Granted, this doesn''t prevent the need to specify the network or the FQDN
    of the container, but it does trim down some of the typing. At this point, you
    should see all of the records defined in WeaveDNS and be able to access services
    across the Weave network by name:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不妨碍需要指定网络或容器的FQDN，但它确实减少了一些输入。此时，您应该能够看到WeaveDNS中定义的所有记录，并能够通过名称访问Weave网络上的服务。
- en: '[PRE62]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You might note that these container''s DNS configuration isn''t exactly as
    you expected. For instance, the `resolv.conf` file does not show the DNS server
    we specified at container runtime:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到这些容器的DNS配置并不完全符合您的预期。例如，`resolv.conf`文件并未显示我们在容器运行时指定的DNS服务器。
- en: '[PRE63]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'However, if you inspect the container''s configuration, you''ll see that the
    correct DNS server is properly defined:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您检查容器的配置，您会看到正确的DNS服务器被正确定义。
- en: '[PRE64]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Recall that user-defined networks require the use of Docker's embedded DNS system.
    The IP address we saw in the containers `resolv.conf` file references Docker's
    embedded DNS server. In turn, when we specify a DNS server for a container, the
    embedded DNS server adds that server as a forwarder in embedded DNS. This means
    that, although the request is still hitting the embedded DNS server first, the
    request is being forwarded on to WeaveDNS for resolution.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，用户定义的网络需要使用Docker的嵌入式DNS系统。我们在容器的`resolv.conf`文件中看到的IP地址引用了Docker的嵌入式DNS服务器。反过来，当我们为容器指定DNS服务器时，嵌入式DNS服务器会将该服务器添加为嵌入式DNS中的转发器。这意味着，尽管请求仍然首先到达嵌入式DNS服务器，但请求会被转发到WeaveDNS进行解析。
- en: Note
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请注意
- en: The Weave plugin also allows you to create additional user-defined networks
    using the Weave driver. However, since Docker sees those as global in scope, they
    require the use of an external key store. If you're interested in using Weave
    in that fashion, please refer to the Weave documentation at [https://www.weave.works/docs/net/latest/plugin/](https://www.weave.works/docs/net/latest/plugin/).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Weave插件还允许您使用Weave驱动程序创建额外的用户定义网络。然而，由于Docker将其视为全局范围，它们需要使用外部密钥存储。如果您有兴趣以这种方式使用Weave，请参考[https://www.weave.works/docs/net/latest/plugin/](https://www.weave.works/docs/net/latest/plugin/)上的Weave文档。
