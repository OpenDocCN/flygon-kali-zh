- en: Installation and a Sneak Peek into Java 11
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和预览Java 11
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Installing JDK 18.9 on Windows and setting up the PATH variable
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上安装JDK 18.9并设置PATH变量
- en: Installing JDK 18.9 on Linux (Ubuntu, x64) and configuring the PATH variable
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux（Ubuntu，x64）上安装JDK 18.9并配置PATH变量
- en: Compiling and running a Java application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译和运行Java应用程序
- en: What's new in JDK 18.9
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 18.9的新功能
- en: Using application class-data sharing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用应用程序类数据共享
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Every quest for learning a programming language begins with setting up the environment
    to experiment with our learning. Keeping in sync with this philosophy, in this
    chapter, we will show you how to set up your development environment and then
    run a simple modular application to test our installation. After that, we'll give
    you an introduction to the new features and tools in JDK 18.9\. Then, we will
    compare JDK 9, 18.3, and 18.9\. We'll end the chapter with a new feature introduced
    in JDK 18.3 that allows application-class-data sharing.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 学习编程语言的每一个探索都始于设置环境以进行学习实验。为了与这一理念保持一致，在本章中，我们将向您展示如何设置开发环境，然后运行一个简单的模块化应用程序来测试我们的安装。之后，我们将向您介绍JDK
    18.9中的新功能和工具。然后，我们将比较JDK 9、18.3和18.9。我们将以JDK 18.3中引入的允许应用程序类数据共享的新功能结束本章。
- en: Installing JDK 18.9 on Windows and setting up the PATH variable
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上安装JDK 18.9并设置PATH变量
- en: In this recipe, we will look at installing JDK on Windows and how to set up
    the `PATH` variable to be able to access the Java executables (such as `javac`,
    `java`, and `jar`) from anywhere within the command shell.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将介绍如何在Windows上安装JDK以及如何设置`PATH`变量，以便能够在命令行中的任何位置访问Java可执行文件（如`javac`、`java`和`jar`）。
- en: How to do it...
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Visit [http://jdk.java.net/11/](http://jdk.java.net/11/) and accept the early-adopter
    license agreement, which looks like this:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[http://jdk.java.net/11/](http://jdk.java.net/11/)并接受早期采用者许可协议，它看起来像这样：
- en: '![](img/7f7dc193-5003-47d7-bd7e-fb5fcab5076c.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f7dc193-5003-47d7-bd7e-fb5fcab5076c.png)'
- en: After accepting the license, you will get a grid of the available JDK bundles
    based on the OS and architecture (32/64-bit). Click to download the relevant JDK
    executable (`.exe`) for your Windows platform.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受许可协议后，您将获得一个基于操作系统和架构（32/64位）的可用JDK捆绑包的网格。单击下载适用于您的Windows平台的相关JDK可执行文件（.exe）。
- en: Run the JDK executable (`.exe`) and follow the onscreen instructions to install
    JDK on your system.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行JDK可执行文件（.exe）并按照屏幕上的说明在系统上安装JDK。
- en: If you have chosen all the defaults during the installation, you will find JDK
    installed in `C:/Program Files/Java` for 64 bit and `C:/Program Files (x86)/Java`
    for 32 bit.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在安装过程中选择了所有默认设置，您将在64位的`C:/Program Files/Java`和32位的`C:/Program Files (x86)/Java`找到安装的JDK。
- en: Now that we have finished installing JDK, let's see how we can set the `PATH`
    variable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经安装了JDK，让我们看看如何设置`PATH`变量。
- en: 'The tools provided with JDK, namely `javac`, `java`, `jconsole`, and `jlink`,
    are available in the bin directory of your JDK installation. There are two ways
    you could run these tools from the Command Prompt:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JDK提供的工具，即`javac`、`java`、`jconsole`和`jlink`，都位于JDK安装的bin目录中。您可以通过两种方式从命令提示符中运行这些工具：
- en: 'Navigate to the directory where the tools are installed and run them, as follows:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到安装工具的目录并运行它们，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Export the path to the directory so that the tools are available from any directory in
    the command prompt. To achieve this, we have to add the path to the JDK tools
    in the `PATH` environment variable. The command prompt will search for the relevant
    tool in all the locations declared in the `PATH` environment variable.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出路径到目录，以便在命令提示符中的任何目录中都可以使用工具。为了实现这一点，我们必须将JDK工具的路径添加到`PATH`环境变量中。命令提示符将在`PATH`环境变量中声明的所有位置中搜索相关工具。
- en: 'Let''s see how you can add the JDK bin directory to the `PATH` variable:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将JDK的bin目录添加到`PATH`变量中：
- en: 'Right-click on My Computer and then click on Properties. You will see your
    system information. Search for Advanced system settings and click on it to get
    a window, as shown in the following screenshot:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击“我的电脑”，然后单击“属性”。您将看到系统信息。搜索“高级系统设置”，单击它以获得一个窗口，如下面的屏幕截图所示：
- en: '![](img/761194d9-a941-4080-864e-860966d3d79e.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/761194d9-a941-4080-864e-860966d3d79e.png)'
- en: 'Click on Environment Variables to view the variables defined in your system.
    You will see that there are quite a few environment variables already defined,
    as shown in the following screenshot (the variables will differ across systems;
    in the following screenshot, there are a few predefined variables and a few variables
    added by me):'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“环境变量”以查看系统中定义的变量。您会看到已经定义了相当多的环境变量，如下面的屏幕截图所示（变量将在不同系统之间有所不同；在下面的屏幕截图中，有一些预定义的变量和一些我添加的变量）：
- en: '![](img/ef3fbf36-9efa-4da2-9d6f-2d6952ce7015.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef3fbf36-9efa-4da2-9d6f-2d6952ce7015.png)'
- en: The variables defined under System variables are available across all the users
    of the system, and those defined under User variables for <user name> are available
    only to the specific user.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在“系统变量”下定义的变量可供系统的所有用户使用，而在“用户变量”下定义的变量仅供特定用户使用。
- en: 'A new variable, with the name `JAVA_HOME`, and its value as the location of
    the JDK 9 installation. For example, it would be `C:\Program Files\Java\jdk-11` (for
    64 bit) or `C:\Program Files (x86)\Java\jdk-11` (for 32 bit):'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个新变量，名为`JAVA_HOME`，其值为JDK 9安装的位置。例如，它将是`C:\Program Files\Java\jdk-11`（64位）或`C:\Program
    Files (x86)\Java\jdk-11`（32位）：
- en: '![](img/82b23ee9-7eb9-45d6-9893-92849060dbd1.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82b23ee9-7eb9-45d6-9893-92849060dbd1.png)'
- en: Update the `PATH` environment variable with the location of the bin directory
    of your JDK installation (defined in the `JAVA_HOME` environment variable). If
    you already see the `PATH` variable defined in the list, then you need to select
    that variable and click on Edit. If the `PATH` variable is not seen, click on
    New.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JDK安装的bin目录的位置（在`JAVA_HOME`环境变量中定义）更新`PATH`环境变量。如果您已经在列表中看到了`PATH`变量定义，那么您需要选择该变量并点击编辑。如果没有看到`PATH`变量，则点击新建。
- en: 'Any of the actions in the previous step will give you a popup, as shown in
    the following screenshot (on Windows 10):'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步中的任何操作都会弹出一个窗口，如下面的屏幕截图所示（在Windows 10上）：
- en: '![](img/2e7ae014-01ed-45e7-84aa-09cb0ec41743.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e7ae014-01ed-45e7-84aa-09cb0ec41743.png)'
- en: 'The following screenshot shows the other Windows versions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了其他Windows版本：
- en: '![](img/477d1f7a-76ac-485e-911b-a73cc7fd0e37.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/477d1f7a-76ac-485e-911b-a73cc7fd0e37.png)'
- en: You can either click on New in the first screenshot and insert the `%JAVA_HOME%\bin` value,
    or you can append the value against the Variable value field by adding `; %JAVA_HOME%\bin`.
    The semicolon (`;`) in Windows is used to separate multiple values for a given
    variable name.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在第一个屏幕截图中单击新建并插入`%JAVA_HOME%\bin`值，或者通过在变量值字段中添加`; %JAVA_HOME%\bin`来追加值。在Windows中，分号(`;`)用于分隔给定变量名的多个值。
- en: After setting the values, open the command prompt and run `javac -version`.
    You should be able to see `javac 11-ea` as the output. If you don't see it, it
    means that the bin directory of your JDK installation has not been correctly added
    to the `PATH` variable.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置完值后，打开命令提示符并运行`javac -version`。您应该能够看到`javac 11-ea`作为输出。如果您没有看到它，这意味着您的JDK安装的bin目录没有正确添加到`PATH`变量中。
- en: Installing JDK 18.9 on Linux (Ubuntu, x64) and configuring the PATH variable
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux（Ubuntu，x64）上安装JDK 18.9并配置PATH变量
- en: In this recipe, we will look at installing JDK on Linux (Ubuntu, x64), and how
    to configure the `PATH` variable to make the JDK tools (such as `javac`, `java`,
    and `jar`) available from any location within the Terminal.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看看如何在Linux（Ubuntu，x64）上安装JDK，并如何配置`PATH`变量以使终端中的JDK工具（如`javac`、`java`和`jar`）可以从任何位置使用。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Follow steps 1 and 2 of the *Installing JDK 18.9 on Windows and setting up the
    PATH variable* recipe to reach the downloads page.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照*在Windows上安装JDK 18.9并设置PATH变量*的步骤1和2来到达下载页面。
- en: Copy the download link (`tar.gz`) for the JDK for the Linux x64 platform from
    the downloads page.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载页面上复制Linux x64平台的JDK的下载链接（`tar.gz`）。
- en: Download the JDK by using `$> wget <copied link>`, for example, `$> wget https://download.java.net/java/early_access/jdk11/26/BCL/jdk-11-ea+26_linux-x64_bin.tar.gz`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`$> wget <copied link>`下载JDK，例如，`$> wget https://download.java.net/java/early_access/jdk11/26/BCL/jdk-11-ea+26_linux-x64_bin.tar.gz`。
- en: Once the download completes, you should have the relevant JDK available, for
    example, `jdk-11-ea+26_linux-x64_bin.tar.gz`. You can list the contents by using
    `$> tar -tf jdk-11-ea+26_linux-x64_bin.tar.gz`. You can even pipe it to `more`
    to paginate the output: `$> tar -tf jdk-11-ea+26_linux-x64_bin.tar.gz | more`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，您应该有相关的JDK可用，例如，`jdk-11-ea+26_linux-x64_bin.tar.gz`。您可以使用`$> tar -tf jdk-11-ea+26_linux-x64_bin.tar.gz`列出内容。您甚至可以使用`$>
    tar -tf jdk-11-ea+26_linux-x64_bin.tar.gz | more`将其传输到`more`来分页输出。
- en: Extract the contents of the `tar.gz` file under `/usr/lib` by using `$> tar
    -xvzf jdk-11-ea+26_linux-x64_bin.tar.gz -C /usr/lib`. This will extract the contents
    into a directory, `/usr/lib/jdk-11`. You can then list the contents of JDK 11
    by using `$> ls /usr/lib/jdk-11`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`$> tar -xvzf jdk-11-ea+26_linux-x64_bin.tar.gz -C /usr/lib`在`/usr/lib`下提取`tar.gz`文件的内容。这将把内容提取到一个目录`/usr/lib/jdk-11`中。然后，您可以使用`$>
    ls /usr/lib/jdk-11`列出JDK 11的内容。
- en: 'Update the `JAVA_HOME` and `PATH` variables by editing the `.bash_aliases`
    file in your Linux home directory:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编辑Linux主目录中的`.bash_aliases`文件来更新`JAVA_HOME`和`PATH`变量：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Source the `.bashrc` file to apply the new aliases:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 源`.bashrc`文件以应用新的别名：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All the examples in this book are run against JDK installed on Linux (Ubuntu,
    x64), except for places where we have specifically mentioned that these are run
    on Windows. We have tried to provide run scripts for both platforms.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有示例都是在Linux（Ubuntu，x64）上安装的JDK上运行的，除非我们特别提到这些是在Windows上运行的地方。我们已经尝试为两个平台提供运行脚本。
- en: Compiling and running a Java application
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和运行Java应用程序
- en: In this recipe, we will write a very simple modular `Hello world` program to
    test our JDK installation. This simple example prints `Hello world` in XML; after
    all, it's the world of web services.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个非常简单的模块化`Hello world`程序来测试我们的JDK安装。这个简单的示例在XML中打印`Hello world`；毕竟，这是Web服务的世界。
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have JDK installed and the `PATH` variable updated to point to the
    JDK installation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经安装了JDK并更新了`PATH`变量以指向JDK安装位置。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s define the model object with the relevant properties and annotations
    that will be serialized into XML:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用相关属性和注释定义模型对象，这些属性和注释将被序列化为XML：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, `@XmlRootElement` is used to define the root tag, `@XmlAccessorType` is
    used to define the type of source for the tag name and tag values, and `@XmlElement`
    is used to identify the sources that become the tag name and tag values in the
    XML.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，`@XmlRootElement`用于定义根标签，`@XmlAccessorType`用于定义标签名称和标签值的来源类型，`@XmlElement`用于标识成为XML中标签名称和标签值的来源。
- en: 'Let''s serialize an instance of the `Message` class into XML using JAXB:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用JAXB将`Message`类的一个实例序列化为XML：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will now create a module named `com.packt`. To create a module, we need
    to create a file named `module-info.java`, which contains the module definition. The
    module definition contains the dependencies of the module and the packages exported
    by the module to other modules:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将创建一个名为`com.packt`的模块。要创建一个模块，我们需要创建一个名为`module-info.java`的文件，其中包含模块定义。模块定义包含模块的依赖关系和模块向其他模块导出的包：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will explain modules in detail in [Chapter 3](1b2f25bd-aef0-4b6f-a9e7-144ee4f8d6e1.xhtml),
    *Modular Programming*. But this example is just to give you a taste of modular
    programming and to test your JDK installation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](1b2f25bd-aef0-4b6f-a9e7-144ee4f8d6e1.xhtml)中详细解释模块化。但这个例子只是为了让您体验模块化编程并测试您的JDK安装。
- en: 'The directory structure with the preceding files is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 具有上述文件的目录结构如下：
- en: '![](img/c74606e0-ea0b-4bb3-b8ed-a8f2cc8cf30f.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c74606e0-ea0b-4bb3-b8ed-a8f2cc8cf30f.png)'
- en: 'Let''s compile and run the code. From the `hellowordxml` directory, create
    a new directory in which to place your compiled class files:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译并运行代码。从`hellowordxml`目录中，创建一个新目录，用于放置编译后的类文件：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Compile the source, `HelloWorldXml.java` and `module-info.java`, into the `mods/com.packt` directory:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将源代码`HelloWorldXml.java`和`module-info.java`编译成`mods/com.packt`目录：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the compiled code using `java --module-path mods -m com.packt/com.packt.HelloWorldXml`.
    You will see the following output:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`java --module-path mods -m com.packt/com.packt.HelloWorldXml`运行编译后的代码。您将看到以下输出：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Don't worry if you are not able to understand the options passed with the `java`
    or `javac` commands. You will learn about them in [Chapter 3](1b2f25bd-aef0-4b6f-a9e7-144ee4f8d6e1.xhtml),
    *Modular Programming*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法理解`java`或`javac`命令中传递的选项，请不要担心。您将在[第3章](1b2f25bd-aef0-4b6f-a9e7-144ee4f8d6e1.xhtml)中了解它们，*模块化编程*。
- en: What's new in Java 11?
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 11中有什么新功能？
- en: The release of Java 9 was a milestone in the Java ecosystem. The modular framework
    developed under Project Jigsaw became part of Java SE release. Another major feature
    was the JShell tool, which is a REPL tool for Java. Many other new features introduced
    with Java 9 are listed in the release notes: [http://www.oracle.com/technetwork/java/javase/9all-relnotes-3704433.html](http://www.oracle.com/technetwork/java/javase/9all-relnotes-3704433.html).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9的发布是Java生态系统的一个里程碑。在项目Jigsaw下开发的模块化框架成为了Java SE发布的一部分。另一个主要功能是JShell工具，这是一个用于Java的REPL工具。Java
    9引入的许多其他新功能在发布说明中列出：[http://www.oracle.com/technetwork/java/javase/9all-relnotes-3704433.html](http://www.oracle.com/technetwork/java/javase/9all-relnotes-3704433.html)。
- en: In this recipe, we will enumerate and discuss some of the new features introduced
    with JDK 18.3 and 18.9 (Java 10 and 11).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将列举并讨论JDK 18.3和18.9（Java 10和11）引入的一些新功能。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The Java 10 release (JDK 18.3) started a six-month release cycle—every March
    and every September—and a new release numbering system. It also introduced many
    new features, the most significant of which (for application developers) are the
    following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Java 10发布（JDK 18.3）开始了一个为期六个月的发布周期——每年三月和九月——以及一个新的发布编号系统。它还引入了许多新功能，其中最重要的（对于应用程序开发人员）是以下内容：
- en: Local variable type inference that allows the declaration of a variable using
    the reserved `var` type (see [Chapter 15](96b2e30f-7c28-4869-8064-eeedb9646b12.xhtml),
    *The New Way of Coding with Java 10 and Java 11*)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许使用保留的`var`类型声明变量的本地变量类型推断（见[第15章](96b2e30f-7c28-4869-8064-eeedb9646b12.xhtml)，*使用Java
    10和Java 11进行编码的新方法*）
- en: Parallel full garbage collection for the G1 garbage collector, which improves
    worst-case latencies
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: G1垃圾收集器的并行完整垃圾收集，改善了最坏情况下的延迟
- en: A new method, `Optional.orElseThrow()`, that is now the preferred alternative
    to the existing `get()` method
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新的方法`Optional.orElseThrow()`，现在是现有`get()`方法的首选替代方法
- en: 'New APIs for creating unmodifiable collections: The `List.copyOf()`, `Set.copyOf()`,
    and `Map.copyOf()` methods of the `java.util` package and new methods of the `java.util.stream.Collectors` class: `toUnmodifiableList()`,
    `toUnmodifiableSet()`, and `toUnmodifiableMap()` (see [Chapter 5](eaa70333-8e9d-453d-a9b6-063152fcc1e1.xhtml),
    *Streams and Pipelines*)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于创建不可修改集合的新API：`java.util`包的`List.copyOf()`、`Set.copyOf()`和`Map.copyOf()`方法，以及`java.util.stream.Collectors`类的新方法：`toUnmodifiableList()`、`toUnmodifiableSet()`和`toUnmodifiableMap()`（参见[第5章](eaa70333-8e9d-453d-a9b6-063152fcc1e1.xhtml)，*流和管道*）
- en: A default set of root Certification Authorities, making OpenJDK builds more
    appealing to developers
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组默认的根证书颁发机构，使OpenJDK构建更受开发人员欢迎
- en: A new Javadoc command-line option, `--add-stylesheet`, provides support for
    the use of multiple stylesheets in the generated documentation
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的Javadoc命令行选项`--add-stylesheet`支持在生成的文档中使用多个样式表
- en: Extending the existing class-data sharing feature to allow application classes
    to be placed in the shared archive that improves startup time and reduces the
    footprint (see the *Using application class-data sharing* recipe)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展现有的类数据共享功能，允许将应用程序类放置在共享存档中，从而提高启动时间并减少占用空间（参见*使用应用程序类数据共享*教程）
- en: An experimental just-in-time compiler, Graal, can be used on the Linux/x64 platform
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种实验性的即时编译器Graal，可以在Linux/x64平台上使用
- en: A clean garbage-collector (GC) interface that makes it simpler to add a new
    GC to HotSpot without perturbing the current code base and makes it easier to
    exclude a GC from a JDK build
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个干净的垃圾收集器（GC）接口，使得可以更简单地向HotSpot添加新的GC，而不会干扰当前的代码库，并且更容易地从JDK构建中排除GC
- en: Enabling HotSpot to allocate the object heap on an alternative memory device,
    such as an NVDIMM memory module, specified by the user
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使HotSpot能够在用户指定的替代内存设备上分配对象堆，例如NVDIMM内存模块
- en: Thread-local handshakes, for executing a callback on threads without performing
    a global VM safepoint
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程本地握手，用于在执行全局VM安全点的情况下在线程上执行回调
- en: 'Docker awareness: JVM will know whether it is running in a Docker container
    on a Linux system and can extract container-specific configuration information
    instead of querying the operating system'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker意识：JVM将知道它是否在Linux系统上的Docker容器中运行，并且可以提取容器特定的配置信息，而不是查询操作系统
- en: Three new JVM options, to give Docker container users greater control over the
    system memory
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个新的JVM选项，为Docker容器用户提供对系统内存的更大控制
- en: See the full list of Java 10's new features in the release notes: [https://www.oracle.com/technetwork/java/javase/10-relnote-issues-4108729.html](https://www.oracle.com/technetwork/java/javase/10-relnote-issues-4108729.html).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布说明中查看Java 10的新功能的完整列表：[https://www.oracle.com/technetwork/java/javase/10-relnote-issues-4108729.html](https://www.oracle.com/technetwork/java/javase/10-relnote-issues-4108729.html)。
- en: We will discuss the new features of JDK 18.9 in more detail in the next section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节更详细地讨论JDK 18.9的新功能。
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: We have picked a few features that we feel are the most important and useful
    for an application developer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们挑选了一些我们认为对应用程序开发人员最重要和有用的功能。
- en: JEP 318 – Epsilon
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JEP 318 – Epsilon
- en: Epsilon is a so-called no-op garbage collector that basically does nothing.
    Its use cases include testing for performance, memory pressure, and the virtual
    machine interface. It also could be used for short-lived jobs or the jobs that
    do not consume much memory and do not require garbage collection.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Epsilon是一种所谓的无操作垃圾收集器，基本上什么都不做。它的用例包括性能测试、内存压力和虚拟机接口。它还可以用于短暂的作业或不消耗太多内存且不需要垃圾收集的作业。
- en: We discussed this feature in more details in the recipe *Understand Epsilon,
    a low-overhead garbage collector* recipe in [Chapter 11](d8d77bf4-a30b-4474-95ca-0a166aef48c0.xhtml), *Memory
    Management and Debugging*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第11章](d8d77bf4-a30b-4474-95ca-0a166aef48c0.xhtml)的*内存管理和调试*中的食谱*理解Epsilon，一种低开销的垃圾收集器*中更详细地讨论了此功能。
- en: JEP 321 – HTTP Client (Standard)
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JEP 321 – HTTP客户端（标准）
- en: JDK 18.9 standardizes the incubated HTTP API client introduced in JDK 9 and
    updated in JDK 10\. Based on CompleteableFuture, it supports nonblocking requests
    and responses. The new implementation is asynchronous and provides a better traceable data
    flow.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 18.9标准化了JDK 9中引入并在JDK 10中更新的孵化HTTP API客户端。基于`CompleteableFuture`，它支持非阻塞请求和响应。新的实现是异步的，并提供了更好的可追踪的数据流。
- en: '[Chapter 10](8cb83861-fd84-4819-9f1f-188258daf864.xhtml), *Networking*, explains
    this feature in more detail in several recipes.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[第10章](8cb83861-fd84-4819-9f1f-188258daf864.xhtml)的*网络*中，通过几个食谱更详细地解释了此功能。'
- en: JEP 323 – Local-Variable Syntax for Lambda Parameters
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JEP 323 – 用于Lambda参数的本地变量语法
- en: A local-variable syntax for lambda parameters has the same syntax as a local-variable-declaration
    using the reserved `var` type introduced in Java 11\. See the *Using local variable
    syntax for lambda parameters* recipe in [Chapter 15](96b2e30f-7c28-4869-8064-eeedb9646b12.xhtml), *The
    New Way of Coding with Java 10 and Java 11*, for more details.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: lambda参数的本地变量语法与Java 11中引入的保留`var`类型的本地变量声明具有相同的语法。有关更多详细信息，请参阅[第15章](96b2e30f-7c28-4869-8064-eeedb9646b12.xhtml)的*使用lambda参数的本地变量语法*食谱。
- en: JEP 333 – ZGC
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JEP 333 – ZGC
- en: The **Z Garbage Collector** (**ZGC**) is an experimental low-latency garbage
    collector. Its pause times should not exceed 10 ms and there should be no more
    than 15% application throughput reduction compared to using the G1 collector.
    ZGC also lays a foundation for future features and optimizations. Linux/x64 will
    be the first platform to get ZGC support.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**Z垃圾收集器**（**ZGC**）是一种实验性的低延迟垃圾收集器。其暂停时间不应超过10毫秒，与使用G1收集器相比，应用吞吐量不应降低超过15%。ZGC还为未来的功能和优化奠定了基础。Linux/x64将是第一个获得ZGC支持的平台。'
- en: New API
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新API
- en: 'There are several additions to the standard Java API:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 标准Java API有几个新增内容：
- en: '`Character.toString(int codePoint)`: Returns a `String` object representing
    the character specified by the provided Unicode code point:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Character.toString(int codePoint)`: 返回表示由提供的Unicode代码点指定的字符的`String`对象：'
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`CharSequence.compare(CharSequence s1, CharSequence s2)`: Compares two `CharSequence`
    instances lexicographically. Returns the difference between the position of the
    second parameter and the position of the first parameter in the ordered list:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CharSequence.compare(CharSequence s1, CharSequence s2)`: 按字典顺序比较两个`CharSequence`实例。返回有序列表中第二个参数的位置与第一个参数位置的差异：'
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `repeat(int count)` method of the `String` class: Returns a `String` value
    composed of `count` times repeated in the `String` source value:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`类的`repeat(int count)`方法：返回由`count`次重复组成的`String`值：'
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `isBlank()` method of the `String` class: Returns `true` if the `String` value
    is empty or contains only white spaces, otherwise `false`. In our example, we
    have contrasted it with the `isEmpty()` method, which returns `true` if, and only
    if, `length()` is zero:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`类的`isBlank()`方法：如果`String`值为空或仅包含空格，则返回`true`，否则返回`false`。在我们的示例中，我们将其与`isEmpty()`方法进行了对比，后者仅在`length()`为零时返回`true`：'
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `lines()` method of the `String` class: Returns a `Stream` object that
    emits lines extracted from the source `String` value, separated by line terminators – `\n`,
    `\r`, or `\r\n`:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`类的`lines()`方法：返回一个`Stream`对象，该对象从源`String`值中提取行，行之间由行终止符`\n`、`\r`或`\r\n`分隔：'
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Three methods of the `String` class that remove leading space, trailing space,
    or both from the source `String` value:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`类的三个方法，用于从源`String`值中移除前导空格、尾随空格或两者：'
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Two `Path.of()` methods that construct a `java.nio.file.Path` object:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个构造`java.nio.file.Path`对象的`Path.of()`方法：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `asMatchPredicate()` method of the `java.util.regex.Pattern` class, which
    creates an object of the `java.util.function.Predicate` functional interface,
    which then allows us to test a `String` value for matching the compiled pattern.
    In the following example, we test whether a `String` value starts with the `a` character
    and ends with the `b` character:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.regex.Pattern`类的`asMatchPredicate()`方法，它创建了一个`java.util.function.Predicate`函数接口的对象，然后允许我们测试`String`值是否与编译后的模式匹配。在下面的示例中，我们测试`String`值是否以`a`字符开头并以`b`字符结尾：'
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There's more...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are quite a few other changes  introduced in JDK 18.9:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 18.9中引入了相当多的其他更改：
- en: The Java EE and CORBA modules are removed
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除了Java EE和CORBA模块
- en: JavaFX is separated and removed from the Java standard libraries
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX已从Java标准库中分离并移除
- en: The Pack200 and Unpack200 tools and the Pack200 API in `util.jar` are deprecated
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`util.jar`中的Pack200和Unpack200工具以及Pack200 API已被弃用'
- en: The Nashorn JavaScript engine, along with the JJS tool, are deprecated with
    the intent to remove them in the future
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nashorn JavaScript引擎以及JJS工具已被弃用，并打算在将来删除它们
- en: The Java class file format is extended to support a new constant pool form,
    `CONSTANT_Dynamic`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java类文件格式被扩展以支持新的常量池形式`CONSTANT_Dynamic`
- en: Aarch64 intrinsics are improved, with the implementation of new intrinsics for
    the `java.lang.Math` sin, cos, and log functions, on Aarch64 processorsJEP 309—Dynamic
    Class-File Constants
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aarch64内在函数得到改进，为Aarch64处理器实现了`java.lang.Math` sin、cos和log函数的新内在函数JEP 309—动态类文件常量
- en: Flight Recorder provides a low-overhead data-collection framework for troubleshooting
    both Java applications and the HotSpot JVM
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flight Recorder为故障排除Java应用程序和HotSpot JVM提供了低开销的数据收集框架
- en: The Java launcher can now run a program supplied as a single file of Java source
    code, so these programs can run directly from the source
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java启动器现在可以运行作为Java源代码单个文件提供的程序，因此这些程序可以直接从源代码运行
- en: A low-overhead heap profiling, providing a way to sample Java heap allocations,
    is accessible via JVM Tool Interface
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低开销的堆分析，提供了一种对Java堆分配进行采样的方式，可以通过JVM工具接口访问
- en: '**Transport Layer Security** (**TLS**) 1.3 increases security and improves
    performance'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输层安全性**（**TLS**）1.3增加了安全性并提高了性能'
- en: Support of Unicode version 10.0 in the `java.lang.Character`, `java.lang.String`,
    `java.awt.font.NumericShaper`, `java.text.Bidi,java.text.BreakIterator`, and `java.text.Normalizer`
    classes
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`java.lang.Character`，`java.lang.String`，`java.awt.font.NumericShaper`，`java.text.Bidi,java.text.BreakIterator`和`java.text.Normalizer`类中支持Unicode版本10.0
- en: Read the Java 11 (JDK 18.9) release notes for more details and other changes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读Java 11（JDK 18.9）发行说明以获取更多详细信息和其他更改。
- en: Using application class-data sharing
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用应用程序类数据共享
- en: This feature has existed in Java since Java 5\. It was extended in Java 9 as
    a commercial feature by allowing not only bootstrap classes but also application
    classes to be placed in the archive shared by JVMs. In Java 10, this feature became
    part of the open JDK. It decreases startup time and, when several JVMs are running
    on the same machine with the same application being deployed, reduces memory consumption.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能自Java 5以来就存在。它在Java 9中作为商业功能得到了扩展，不仅允许引导类，还允许将应用程序类放置在JVM共享的存档中。在Java 10中，这个功能成为了open
    JDK的一部分。它减少了启动时间，并且当同一台机器上运行多个JVM并部署相同的应用程序时，减少了内存消耗。
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'The advantages of loading classes from the shared archive became possible for
    two reasons:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从共享存档加载类的优势有两个原因：
- en: The classes stored in the archive are preprocessed, which means that the JVM
    memory mapping is stored in the archive too. It reduces the overhead of class-loading
    when a JVM instance starts.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存档中存储的类是经过预处理的，这意味着JVM内存映射也存储在存档中。这减少了JVM实例启动时类加载的开销。
- en: The memory region can even be shared between the JVM instances running on the
    same computer, which reduces overall memory consumption by eliminating the need
    to replicate the same information in each instance.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存区域甚至可以在同一台计算机上运行的JVM实例之间共享，这通过消除每个实例中复制相同信息的需要来减少总体内存消耗。
- en: The new JVM functionality allows us to create a list of classes to be shared,
    then use this list to create a shared archive, and use the shared archive to fast-load
    archived classes into memory.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 新的JVM功能允许我们创建一个要共享的类列表，然后使用这个列表创建一个共享存档，并使用共享存档快速加载存档类到内存中。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'By default, JVM can create an archive using the list of classes that comes
    with JDK. For example, run the following command:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，JVM可以使用随JDK提供的类列表创建一个存档。例如，运行以下命令：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It will create the shared archive as a `classes.jsa` file. On a Linux system,
    this file is placed in the following folder:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它将创建一个名为`classes.jsa`的共享存档文件。在Linux系统上，该文件放置在以下文件夹中：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On a Windows system, it is placed in the following folder:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows系统上，它放置在以下文件夹中：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If this folder is accessible by the system admin only, run the command as an
    admin.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个文件夹只能被系统管理员访问，以管理员身份运行命令。
- en: Please notice that not all classes can be shared. For example, the `.class`
    files located in the directory on the classpath and classes loaded by custom class
    loaders cannot be added to the shared archive.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非所有类都可以共享。例如，位于类路径上的目录中的`.class`文件和由自定义类加载器加载的类不能添加到共享存档中。
- en: 'To tell the JVM to use the default shared archive, use the following command:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉JVM使用默认的共享存档，使用以下命令：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding command maps the content of the archive at a fixed address. This
    memory-mapping operation may occasionally fail when the required address space
    is not available. If that happens when the `-Xshare:on` option is used, the JVM
    exits with an error. Alternatively, the `-Xshare:auto` option can be used, which
    just disables the feature and loads the classes from the classpath if the shared
    archive cannot be used for whatever reason.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将存档的内容映射到固定地址。当所需的地址空间不可用时，这种内存映射操作有时会失败。如果在使用`-Xshare:on`选项时发生这种情况，JVM将以错误退出。或者，可以使用`-Xshare:auto`选项，它只是禁用该功能，并且如果由于任何原因无法使用共享存档，则从类路径加载类。
- en: 'The simplest way to create a list of loaded application classes is by using
    the following command:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建加载的应用程序类列表的最简单方法是使用以下命令：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding command records all the loaded classes in the `classes.txt` file.
    If you would like to make your application load faster, stop the JVM just after
    the application has been started. If you need it to load certain classes faster
    but these classes are not loaded at the application startup automatically, make
    sure that the use cases that require these classes are executed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令记录了`classes.txt`文件中加载的所有类。如果要使应用程序加载更快，请在应用程序启动后立即停止JVM。如果需要更快地加载某些类，但这些类不会在应用程序启动时自动加载，请确保执行需要这些类的用例。
- en: Alternatively, you can manually edit the `classes.txt` file and add/remove any
    classes you need to put in the shared archive. Create this file once automatically
    and see the format. It is a simple text file that lists one class in each line.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您可以手动编辑`classes.txt`文件，并添加/删除任何需要放入共享存档的类。首次自动创建此文件并查看格式。这是一个简单的文本文件，每行列出一个类。
- en: 'Once the list is created, use the following command to generate the shared
    archive:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建列表后，使用以下命令生成共享存档：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that the shared archive file has a name other than `classes.jsa`, so
    the default shared archive is not overwritten.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，共享存档文件的名称不是`classes.jsa`，因此不会覆盖默认共享存档。
- en: 'Use the created archive by executing the following command:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令使用创建的存档：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Again, you can use the `-Xshare:auto` option to avoid an unexpected exit of
    the JVM.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以使用`-Xshare:auto`选项，以避免JVM意外退出。
- en: The effect of the shared archive usage depends on the number of classes in it
    and other particulars of the application. So, we recommend you experiment and
    test various configurations before committing to a certain list of classes in
    production.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 共享存档的使用效果取决于其中的类数量和应用程序的其他细节。因此，我们建议您在承诺使用特定类列表之前进行实验和测试各种配置。
