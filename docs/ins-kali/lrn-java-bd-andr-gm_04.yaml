- en: Chapter 4. Discovering Loops and Methods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。发现循环和方法
- en: In this chapter, we will learn how to repeatedly execute portions of our code
    in a controlled and precise way by looking at different types of loops in Java.
    These include `while` loops, `do-while` loops, and `for` loops. We will learn
    about the best occasions to use the different types of loops.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何通过查看Java中不同类型的循环来以受控且精确的方式重复执行我们代码的部分。这些包括`while`循环、`do-while`循环和`for`循环。我们将学习在何种情况下使用不同类型的循环。
- en: Then we will briefly cover the topic of random numbers. We will also see how
    the Java `Random` class can be used. This will obviously be of great help in enhancing
    our math game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将简要介绍随机数的主题。我们还将看到如何使用Java的`Random`类。这显然对增强我们的数学游戏非常有帮助。
- en: Next, we will look at **methods**. They allow us to compartmentalize our code
    into more manageable blocks. We will then see how to share data between methods
    and divide programming tasks to simplify problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看**方法**。它们允许我们将代码分隔成更易管理的块。然后，我们将看到如何在方法之间共享数据，并将编程任务分解以简化问题。
- en: We will then use all that we have learned about loops, random numbers and methods
    on our math game project. For example, we will make the game change the question
    after each time we attempt the answer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在我们的数学游戏项目中使用我们所学到的关于循环、随机数和方法的所有知识。例如，我们将使游戏在每次尝试答案后更改问题。
- en: We will also add question difficulty levels and random questions within a range
    appropriate for a given difficulty level. We will show and update our score. The
    score goes up faster depending upon the difficulty level of the question answered
    (correctly). Eventually, even the best mathematicians among us should be beaten
    by the game. Nevertheless, most of us will hopefully get a bit further than what
    is shown in the next screenshot.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加问题难度级别和在适当难度级别内的随机问题。我们将展示并更新我们的分数。答对问题的难度级别越高，分数增加得越快。最终，即使我们中最优秀的数学家也应该被游戏打败。然而，我们中的大多数人希望能够比下面的截图所显示的更进一步。
- en: 'If the player gets a question wrong, the difficulty goes back to the easiest
    level and the score to zero. This is what the game will look like when we are
    done:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家答错了问题，难度将回到最简单的级别，分数将变为零。这是我们完成后游戏的样子：
- en: '![Discovering Loops and Methods](img/8859OS_04_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![发现循环和方法](img/8859OS_04_01.jpg)'
- en: 'In this chapter we will:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn about looping in multiple types of loops
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解多种类型的循环中的循环
- en: Learn how to generate random numbers in Java
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在Java中生成随机数
- en: Learn everything about Java methods, including how to write and call them
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习有关Java方法的所有内容，包括如何编写和调用它们
- en: Significantly enhance our math game
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显著增强我们的数学游戏
- en: Looping with loops
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用循环进行循环
- en: It would be completely reasonable to ask what loops have to do with programming,
    but they are exactly what the name implies. They are a way of performing the same
    part of the code more than once, or looping over the same part of code, but potentially
    for a different outcome each time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 询问循环与编程有什么关系是完全合理的，但它们确实如其名称所示。它们是一种多次执行相同代码的方式，或者循环执行相同代码的一部分，但每次可能会有不同的结果。
- en: This can simply mean doing the same thing until the code being looped over prompts
    the loop to end. It could prompt the loop after a predetermined number of times
    as specified by the loop code itself. It could also prompt the loop when a predetermined
    situation or **condition** is met. Or there could be a combination of more than
    one of these ways of prompting the loop to end. Along with `if`, `else`, and `switch`,
    loops are part of the Java **control flow statements**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能意味着做同样的事情，直到循环的代码提示循环结束。它可以在由循环代码本身指定的预定次数后提示循环。它也可以在满足预定情况或**条件**时提示循环结束。或者可能是这些提示循环结束的方式的组合。除了`if`、`else`和`switch`，循环也是Java**控制流语句**的一部分。
- en: We will look at all the major types of loop that Java offers us to control our
    code, and after we have looked at methods, we will use some of them to implement
    the enhancements to our math game. Let's proceed to our first type of loop.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究Java提供的所有主要类型的循环，然后在研究了方法之后，我们将使用其中一些来实现对我们数学游戏的增强。让我们继续进行我们的第一种循环。
- en: While loops
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: While循环
- en: 'A `while` loop has the simplest syntax. Recollect the `if` statements in [Chapter
    3](ch03.xhtml "Chapter 3. Speaking Java – Your First Game"), *Speaking Java –
    Your First Game*. We can put virtually any combination of operators and variables
    in the conditional expression of the `if` statement. If the expression evaluated
    to `true`, then the code in the body of the `if` block is executed. Similarly,
    in the `while` loop, we put an expression that can evaluate to `true` or `false`,
    as shown in this code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环具有最简单的语法。回想一下[第3章](ch03.xhtml "第3章。说Java - 你的第一个游戏")中的`if`语句，*说Java
    - 你的第一个游戏*。我们可以在`if`语句的条件表达式中放置几乎任何组合的运算符和变量。如果表达式评估为`true`，则执行`if`块中的代码。同样，在`while`循环中，我们放置一个可以评估为`true`或`false`的表达式，如下所示：'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What is happening here is that outside the `while` loop, an integer, `x`, is
    declared and initialized to `10`. Then the `while` loop begins. Its condition
    is `x > 0`, so it will continue looping through the code in its body until the
    condition evaluates to `false`. Hence, the code will execute 10 times.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的是，在`while`循环之外，声明了一个整数`x`，并将其初始化为`10`。然后`while`循环开始。它的条件是`x > 0`，因此它将继续循环执行其主体中的代码，直到条件评估为`false`。因此，代码将执行10次。
- en: On the first pass, `x` is equal to `10`, then `9`, then `8`, and so on. But
    once `x` becomes equal to `0`, it is obviously no longer greater than `0`. So
    the program will exit the `while` loop and continue with the first line of code
    after the loop.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次循环中，`x`等于`10`，然后是`9`，然后是`8`，依此类推。但一旦`x`等于`0`，显然它不再大于`0`。因此，程序将退出`while`循环，并继续执行循环后的第一行代码。
- en: 'Just like an `if` statement, it is possible that the `while` loop will not
    execute even once. Take a look at this example of a `while` loop that never executes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`if`语句一样，`while`循环有可能甚至不执行一次。看一下这个永远不执行的`while`循环的例子：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Moreover, there is no limit to the complexity of the condition expression or
    the amount of code that can be written in the loop body:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，条件表达式的复杂程度或循环体中可以编写的代码量没有限制：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding `while` loop would continue to execute until either `playerLive`s
    or `alienShips` becomes equal to or less than zero. As soon as one of these conditions
    occurs, the expression evaluates to `false` and the program continues to execute
    from the first line of code after the `while` loop.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`while`循环将继续执行，直到`playerLive`或`alienShips`变为等于或小于零。一旦其中一个条件发生，表达式就会评估为`false`，程序就会从`while`循环后的第一行代码继续执行。
- en: 'It is worth noting that once the body of the loop has been entered, it will
    always complete, even if the expression evaluates to `false` somewhere in between,
    as the condition is not checked again until the code tries to start another pass:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，一旦进入循环体，即使表达式在中间某个地方评估为`false`，循环体也会始终完成，因为在代码尝试开始另一次通过之前不会再次检查条件：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding loop body will execute exactly once. We can also set a `while`
    loop that will run forever (which is unsurprisingly called an **infinite loop**),
    like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的循环体将确切地执行一次。我们还可以设置一个永远运行的`while`循环（不出所料地称为**无限循环**），就像这样：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Breaking out of a loop
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳出循环
- en: 'We might use an infinite loop like the loop in the preceding example so that
    we can decide when to exit the loop from within its body. We would do this using
    the `break` keyword when we are ready to leave the loop body, as shown in the
    following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个无限循环，就像前面的例子中的循环一样，这样我们就可以决定何时从循环体内退出循环。当我们准备离开循环体时，我们会使用`break`关键字，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You might have been able to guess that we can combine any of the decision making
    tools like `if`, `else`, and `switch` within our `while` loops and the rest of
    the loops we will look at in a minute:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到，我们可以在`while`循环和我们即将看到的其他循环中结合任何决策工具，比如`if`、`else`和`switch`：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It would be simple to go on for many more pages demonstrating the versatility
    of `while` loops, but at some point, we want to get back to doing some real programming.
    So here is one last concept, combined with `while` loops.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地继续演示`while`循环的多种用途，但是在某个时候，我们想要回到做一些真正的编程。因此，这是最后一个概念，结合了`while`循环。
- en: The continue keyword
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: continue关键字
- en: 'The `continue` keyword acts in a way similar to `break`—up to a point. The
    `continue` keyword will break out of the loop body but will also check the condition
    expression afterwards, so the loop *could* run again. The following example will
    show the use of `continue`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`关键字的作用方式与`break`类似，但有一点不同。`continue`关键字将跳出循环体，但之后也会检查条件表达式，所以循环*可能*会再次运行。下面的例子将展示`continue`的用法：'
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Do-while loops
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Do-while循环
- en: 'A `do-while` loop is very much the same as a `while` loop with the exception
    that it evaluates its expression after the body. This means that a `do-while`
    loop will always execute at least once, as demonstrated in the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`do-while`循环与`while`循环非常相似，唯一的区别是它在循环体之后评估表达式。这意味着`do-while`循环将始终至少执行一次，如下面的代码所示：'
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `break` and `continue` keywords can also be used in `do-while` loops.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`和`continue`关键字也可以在`do-while`循环中使用。'
- en: For loops
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: For循环
- en: 'A `for` loop has a slightly more complicated syntax than a `while` and `do-while`
    loop as it take three parts to initialize. Take a look at the following `for`
    loop first. Then we will break it apart:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的语法比`while`和`do-while`循环稍微复杂一些，因为它需要三个部分来初始化。首先看一下下面的`for`循环。然后我们将它拆分开来：'
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The apparently obscure form of the `for` loop is clearer when put like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的这种看似晦涩的形式在这样表述时更加清晰：'
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To clarify further, we have the following in a `for` loop:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步澄清，我们在`for`循环中有以下内容：
- en: '**Declaration and initialization**: We create a new `int` variable, `i`, and
    initialize it to 0.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明和初始化**：我们创建一个新的`int`变量`i`，并将其初始化为0。'
- en: '**Condition**: Just like the other loops, this refers to the condition that
    must be evaluated to true for the loop to continue.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件**：就像其他循环一样，这指的是必须评估为真以使循环继续的条件。'
- en: '**Change after each pass through loop**: In the preceding example, `i++` means
    that 1 is added to `i` on each pass. We could also use `i--` to reduce/decrement
    `i` on each pass, which is shown in the following code:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每次通过循环后更改**：在前面的例子中，`i++`表示每次通过循环时`i`增加1。我们也可以使用`i--`来减少/递减`i`，如下面的代码所示：'
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that `break` and `continue` can also be used in `for` loops.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`break`和`continue`也可以在`for`循环中使用。
- en: The `for` loop essentially takes control of initialization, condition evaluation,
    and the control variable on itself. We will be using a `for` loop to enhance our
    math game right after we take a look at random numbers and methods.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环本质上控制了初始化、条件评估和控制变量。在我们看完随机数和方法之后，我们将使用`for`循环来增强我们的数学游戏。'
- en: Random numbers in Java
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java中的随机数
- en: Before we dive into methods, we will first take a look at how we can create
    random numbers because this is how we will generate our random questions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究方法之前，我们首先来看一下如何创建随机数，因为这是我们将生成随机问题的方法。
- en: 'All the hard work is done for us by the `Random` class. First we need to create
    an object of the `Random` type:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Random`类为我们完成了所有的工作。首先我们需要创建一个`Random`类型的对象：'
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then we use our new object''s `nextInt` method to generate a random number
    within a certain range:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用新对象的`nextInt`方法来生成一个在某个范围内的随机数：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The range for the number that we enter starts from zero. So the preceding line
    of code will generate a random number between 0 and 9\. If we want a random number
    between 1 and 10, we just do this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输入的数字范围从零开始。因此，前面的代码将生成一个介于0和9之间的随机数。如果我们想要一个介于1和10之间的随机数，我们只需要这样做：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Often in these early chapters, we need to accept there is a bit of magic going
    on in objects like Random. In [Chapter 6](ch06.xhtml "Chapter 6. OOP – Using Other
    People's Hard Work"), *OOP – Using Other People's Hard Work*, we will be ripping
    open the black boxes and even making our own. We will be able to write our own
    classes and our own methods within those classes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些早期章节中，我们经常需要接受一些魔法在Random等对象中发生。在[第6章](ch06.xhtml "第6章。OOP-使用他人的辛勤工作")中，*OOP-使用他人的辛勤工作*，我们将打开黑匣子，甚至制作我们自己的黑匣子。我们将能够编写我们自己的类和这些类中的方法。
- en: A good start is a look at regular vanilla methods, which we will do next.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的开始是查看常规的基本方法，接下来我们将这样做。
- en: Math game – asking a question
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学游戏-提问
- en: Now that we have all that knowledge under our belts, we can use it to improve
    our math game. First, we will create a new Android activity to be the actual game
    screen as opposed to the start menu screen. We will then use the UI designer to
    lay out a simple game screen so that we can use our Java skills with variables,
    types, declaration, initialization, operators, and expressions to make our math
    game generate a question for the player. We can then link the start menu and game
    screens together with a push button.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了所有这些知识，我们可以利用它来改进我们的数学游戏。首先，我们将创建一个新的Android活动，作为实际的游戏屏幕，而不是开始菜单屏幕。然后，我们将使用UI设计师来布置一个简单的游戏屏幕，以便我们可以使用我们的Java技能来使用变量、类型、声明、初始化、运算符和表达式来使我们的数学游戏为玩家生成一个问题。然后，我们可以使用一个按钮将开始菜单和游戏屏幕连接在一起。
- en: If you want to save typing and just review the finished project, you can use
    the code downloaded from the Packt Publishing website. If you have any trouble
    getting any of the code to work, you can review, compare, or copy and paste the
    code from the already completed code provided in the download bundle.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想节省输入时间，只需查看完成的项目，您可以使用从Packt Publishing网站下载的代码。如果您在使任何代码工作时遇到任何问题，您可以查看、比较或复制并粘贴下载包中提供的已完成代码。
- en: 'The completed code is in the following files that correspond to the filenames
    we will be using in this tutorial:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的代码在以下文件中，这些文件对应于本教程中将使用的文件名：
- en: '`Chapter3/MathGameChapter3a/java/MainActivity.java`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chapter3/MathGameChapter3a/java/MainActivity.java`'
- en: '`Chapter3/MathGameChapter3a/java/GameActivity.java`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chapter3/MathGameChapter3a/java/GameActivity.java`'
- en: '`Chapter3/MathGameChapter3a/layout/activity_main.xml`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chapter3/MathGameChapter3a/layout/activity_main.xml`'
- en: '`Chapter3/MathGameChapter3a/layout/activity_game.xml`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chapter3/MathGameChapter3a/layout/activity_game.xml`'
- en: As usual, I recommend following this tutorial to see how we can create all of
    the code for ourselves.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我建议跟着本教程来看看我们如何为自己创建所有的代码。
- en: Creating the new game activity
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新的游戏活动
- en: We will first need to create a new Java file for the game activity code and
    a related layout file to hold the game activity UI.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要为游戏活动代码创建一个新的Java文件和一个相关的布局文件来保存游戏活动UI。
- en: Run Android Studio and select your `Math Game Chapter 2` project that we built
    in [Chapter 2](ch02.xhtml "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*. It might have been opened by default. Now we will create
    the new Android activity that will contain the actual game screen, which will
    run when the player taps the **Play** button on our main menu screen.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Android Studio并选择我们在[第2章](ch02.xhtml "第2章。开始使用Android")中构建的`Math Game Chapter
    2`项目，*开始使用Android*。它可能已经默认打开了。现在我们将创建一个新的Android活动，该活动将包含实际的游戏屏幕，当玩家点击主菜单屏幕上的**Play**按钮时将运行。
- en: To create a new activity, we now need another layout file and another Java file.
    Fortunately Android Studio will help us do this. To get started with creating
    all the files we need for a new activity, right-click on the `src` folder in the
    Project Explorer and then go to **New** | **Activity**. Now click on **Blank Activity**
    and then on **Next**.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新的活动，我们现在需要另一个布局文件和另一个Java文件。幸运的是，Android Studio会帮助我们做到这一点。要开始创建新活动所需的所有文件，请在项目资源管理器中右键单击`src`文件夹，然后转到**New**
    | **Activity**。现在点击**Blank Activity**，然后点击**Next**。
- en: We now need to tell Android Studio a little bit about our new activity by entering
    information in the above dialog box. Change the **Activity Name** field to `GameActivity`.
    Notice how the **Layout Name** field is automatically changed for us to `activity_game`
    and the **Title** field is automatically changed to `GameActivity`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在上面的对话框中输入一些关于我们的新活动的信息。将**Activity Name**字段更改为`GameActivity`。注意**Layout
    Name**字段会自动更改为`activity_game`，**Title**字段也会自动更改为`GameActivity`。
- en: Click on **Finish**. Android Studio has created two files for us and has also
    registered our new activity in a manifest file, so we don't need to concern ourselves
    with it.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Finish**。Android Studio已经为我们创建了两个文件，并且还在清单文件中注册了我们的新活动，所以我们不需要关心它。
- en: If you look at the tabs at the top of the editor window, you will see that `GameActivity.java`
    has been opened up ready for us to edit, as shown in the following screenshot:![Creating
    the new game activity](img/8859OS_03_02.jpg)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您查看编辑窗口顶部的选项卡，您会看到`GameActivity.java`已经准备好供我们编辑，如下面的屏幕截图所示：![Creating the
    new game activity](img/8859OS_03_02.jpg)
- en: Ensure that `GameActivity.java` is active in the editor window by clicking on
    the **GameActivity.java** tab shown previously.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击之前显示的**GameActivity.java**选项卡，确保`GameActivity.java`在编辑窗口中处于活动状态。
- en: Back in [Chapter 2](ch02.xhtml "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*, we talked about how Android overrides some methods for
    us by default, and that most of them were not necessary. Here again, we can see
    the code that is unnecessary. If we remove it, then it will make our working environment
    simpler and cleaner. You might also remember from [Chapter 2](ch02.xhtml "Chapter 2. Getting
    Started with Android"), *Getting Started with Android*, that the process of deleting
    and amending sections of code, although not complex, is a fairly long process.
    To avoid this here, we will simply use the code from `MainActivity.java` as a
    template for `GameActivity.java`. We can then make some minor changes.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到[第2章](ch02.xhtml "第2章。开始使用Android")*开始使用Android*，我们谈到了Android默认覆盖了一些方法，其中大多数是不必要的。在这里，我们可以看到不必要的代码。如果我们删除它，那么它将使我们的工作环境更简单、更清洁。你可能还记得从[第2章](ch02.xhtml
    "第2章。开始使用Android")*开始使用Android*，删除和修改代码部分的过程虽然不复杂，但是相当长。为了避免这种情况，我们将简单地使用`MainActivity.java`中的代码作为`GameActivity.java`的模板。然后我们可以进行一些小的修改。
- en: Click on the **MainActivity.java** tab in the editor window. Highlight all of
    the code in the editor window using *Ctrl* + *A* on the keyboard.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击编辑器窗口中的**MainActivity.java**选项卡。使用键盘上的*Ctrl* + *A*突出显示编辑器窗口中的所有代码。
- en: Now copy all of the code in the editor window using the *Ctrl* + *C* on the
    keyboard.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用键盘上的*Ctrl* + *C*复制编辑器窗口中的所有代码。
- en: Now click on the **GameActivity.java** tab.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击**GameActivity.java**选项卡。
- en: Highlight all of the code in the editor window using *Ctrl* + *A* on the keyboard.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用键盘上的*Ctrl* + *A*突出显示编辑器窗口中的所有代码。
- en: Now paste the copied code and overwrite the currently highlighted code using
    *Ctrl* + *V* on the keyboard.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在粘贴复制的代码，并使用键盘上的*Ctrl* + *V*覆盖当前高亮显示的代码。
- en: Notice that there is an error in our code denoted by the red underlining as
    shown in the following screenshot. This is because we pasted the code referring
    to `MainActivity` in our file that is called `GameActivity`.![Creating the new
    game activity](img/8859OS_03_03.jpg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们的代码中有一个错误，如下截图所示，用红色下划线表示。这是因为我们将引用`MainActivity`的代码粘贴到名为`GameActivity`的文件中。
- en: Simply change the text **MainActivity** to **GameActivity** and the error will
    disappear. Take a moment to see if you can work out what other minor change is
    necessary, before I tell you.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将文本**MainActivity**更改为**GameActivity**，错误就会消失。在我告诉你之前，花点时间看看还需要做出什么其他小的改变。
- en: Remember that `setContentView` loads our UI design. Well what we need to do
    is change `setContentView` to load the new design (that we will build next) instead
    of the home screen design. Change `setContentView(R.layout.activity_main);` to
    `setContentView(R.layout.activity_game);`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，`setContentView`加载我们的UI设计。我们需要做的是将`setContentView`更改为加载新设计（我们将在下面构建的）而不是主屏幕设计。将`setContentView(R.layout.activity_main);`更改为`setContentView(R.layout.activity_game);`。
- en: Save your work and we are ready to move on.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的工作，我们准备继续。
- en: Note the Project Explorer where Android Studio puts the two new files it created
    for us. I have highlighted two folders in the next screenshot. In future, I will
    simply refer to them as our `java` code folder or `layout` files folder.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意项目资源管理器，Android Studio将我们创建的两个新文件放在其中。在下一个截图中，我已经突出显示了两个文件夹。将来，我将简单地称它们为我们的`java`代码文件夹或`layout`文件夹。
- en: '![Creating the new game activity](img/8859OS_03_04.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![创建新游戏活动](img/8859OS_03_04.jpg)'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might wonder why we didn't simply copy and paste the `MainActivity.java`
    file to begin with and saved going through the process of creating a new activity?
    The reason is that Android Studio does things behind the scenes. Firstly, it makes
    the layout template for us. It also registers the new activity for use through
    a file we will see later, called `AndroidManifest.xml`. This is necessary for
    the new activity to be able to work in the first place. All things considered,
    the way we did it is probably the quickest.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么我们不直接复制和粘贴`MainActivity.java`文件，而是要经过创建新活动的过程？原因是Android Studio在幕后做了一些事情。首先，它为我们制作了布局模板。它还通过一个稍后会看到的名为`AndroidManifest.xml`的文件注册了新的活动供使用。这对于新的活动能够首先工作是必要的。综上所述，我们的做法可能是最快的。
- en: 'The code at this stage is exactly the same as the code for the home menu screen.
    We state the package name and import some useful classes provided by Android:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此阶段的代码与主菜单屏幕的代码完全相同。我们声明包名并导入一些Android提供的有用类：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We create a new activity, this time called `GameActivity`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的活动，这次叫做`GameActivity`：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we override the `onCreate` method and use the `setContentView` method
    to set our UI design as the contents of the player''s screen. Currently, however,
    this UI is empty:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们覆盖`onCreate`方法，并使用`setContentView`方法将我们的UI设计设置为玩家屏幕的内容。然而，目前，这个UI是空的：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can now think about the layout of our actual game screen.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以考虑实际游戏屏幕的布局。
- en: Laying out the game screen UI
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布置游戏屏幕UI
- en: As we know, our math game will ask questions and offer the player some multiple
    choices to choose answers from. There are lots of extra features we could add,
    such as difficulty levels, high scores, and much more. But for now, let's just
    stick to asking a simple, predefined question and offering a choice of three predefined
    possible answers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，我们的数学游戏将提出问题，并为玩家提供一些多个选择来选择答案。我们可以添加许多额外的功能，例如难度级别、高分和更多。但现在，让我们只问一个简单的、预定义的问题，并提供三个预定义的可能答案选择。
- en: 'Keeping the UI design to the bare minimum suggests a layout. Our target UI
    will look somewhat like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 保持UI设计尽可能简单暗示着布局。我们的目标UI将看起来有点像这样：
- en: '![Laying out the game screen UI](img/8859OS_03_10.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![布置游戏屏幕UI](img/8859OS_03_10.jpg)'
- en: 'The layout is hopefully self-explanatory, but let''s ensure that we are really
    clear; when we come to building this layout in Android Studio, the section in
    the mock-up that displays **2 x 2** is the question and will be made up of three
    text views (both numbers, and the **=** sign is also a separate view). Finally,
    the three options for the answer are made up of **Button** layout elements. We
    used all of these UI elements in the previous chapter, but this time, as we are
    going to be controlling them using our Java code, there are a few extra things
    we need to do to them. So let''s go through it step by step:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 布局希望是不言自明的，但让我们确保我们真的清楚；当我们在Android Studio中构建这个布局时，显示**2 x 2**的部分是问题，将由三个文本视图组成（两个数字和**=**号也是一个单独的视图）。最后，答案的三个选项由**按钮**布局元素组成。我们在上一章中使用了所有这些UI元素，但这一次，因为我们将使用我们的Java代码来控制它们，我们需要对它们做一些额外的事情。因此，让我们一步一步地进行：
- en: Open the file that will hold our game UI in the editor window. Do this by double-clicking
    on `activity_game.xml`. This is located in our UI `layout` folder, which can be
    found in the project explorer.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器窗口中打开将保存我们游戏UI的文件。通过双击`activity_game.xml`来执行此操作。这个文件位于项目资源管理器中的UI `layout`文件夹中。
- en: Delete the **Hello World** TextView, as it is not required.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除**Hello World** TextView，因为它不是必需的。
- en: Find the **Large Text** element on the palette. It can be found under the **Widgets**
    section. Drag three elements onto the UI design area and arrange them near the
    top of the design as shown in the next screenshot. It does not have to be exact;
    just ensure that they are in a row and not overlapping, as shown in the following
    screenshot:![Laying out the game screen UI](img/8859OS_03_11.jpg)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调色板中找到**大文本**元素。它可以在**小部件**部分下找到。将三个元素拖放到UI设计区域并排列在设计的顶部附近，如下一张截图所示。它不必完全相同；只需确保它们在一行上，不重叠，如下一张截图所示：![布局游戏屏幕UI](img/8859OS_03_11.jpg)
- en: Notice in the **Component Tree** window that each of the three TextViews has
    been assigned a name automatically by Android Studio. They are **textView** ,
    **textView2**, and **textView3**:![Laying out the game screen UI](img/8859OS_03_12.jpg)
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，在**组件树**窗口中，每个三个TextView都已被Android Studio自动分配了一个名称。它们是**textView**，**textView2**和**textView3**：![布局游戏屏幕UI](img/8859OS_03_12.jpg)
- en: Android Studio refers to these element names as an **id**. This is an important
    concept that we will be making use of. So to confirm this, select any one of the
    textViews by clicking on its name (id), either in the component tree as shown
    in the preceding screenshot or directly on it in the UI designer shown previously.
    Now look at the **Properties** window and find the **id** property. You might
    need to scroll a little to do this:![Laying out the game screen UI](img/8859OS_03_15.jpg)
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android Studio将这些元素名称称为**id**。这是一个重要的概念，我们将会用到。因此，为了确认这一点，通过单击组件树中的任何一个textView的名称（id）或直接在UI设计器中单击它，查看**属性**窗口并找到**id**属性。您可能需要滚动一下来做到这一点：![布局游戏屏幕UI](img/8859OS_03_15.jpg)
- en: Notice that the value for the **id** property is **textView**. It is this `id`
    that we will use to interact with our UI from our Java code. So we want to change
    all the IDs of our TextViews to something useful and easy to remember.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，**id**属性的值是**textView**。正是这个`id`，我们将用它来与我们的Java代码交互。因此，我们希望将所有TextView的ID更改为一些有用且易于记忆的内容。
- en: If you look back at our design, you will see that the UI element with the **textView**
    id is going to hold the number for the first part of our math question. So change
    the id to `textPartA`. Notice the lowercase `t` in `text`, the uppercase `P` in
    `Part`, and the uppercase `A`. You can use any combination of cases and you can
    actually name the IDs anything you like. But just as with naming conventions with
    Java variables, sticking to conventions here will make things less error-prone
    as our program gets more complicated.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您回顾我们的设计，您会发现具有**textView** id的UI元素将保存我们数学问题的第一部分的数字。因此，将id更改为`textPartA`。注意`text`中的小写`t`，`Part`中的大写`P`和大写`A`。您可以使用任何大小写组合，实际上可以将ID命名为任何您喜欢的名称。但是，就像Java变量的命名约定一样，在这里遵循约定将使得当我们的程序变得更加复杂时，减少错误的可能性。
- en: Now select **textView2** and change **id** to `textOperator`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在选择**textView2**并将**id**更改为`textOperator`。
- en: Select the element currently with id **textView3** and change it to `textPartB`.
    This TextView will hold the later part of our question.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择当前具有id **textView3**的元素并将其更改为`textPartB`。这个TextView将保存我们问题的后半部分。
- en: Now add another **Large Text** from the palette. Place it after the row of the
    three TextViews that we have just been editing.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在从调色板中添加另一个**大文本**。将其放在我们刚刚编辑的三个TextView的行后面。
- en: This **Large Text** will simply hold our equals to sign and there is no plan
    to ever change it. So we don't need to interact with it in our Java code. We don't
    even need to concern ourselves with changing the ID or knowing what it is. If
    this situation changed, we could always come back at a later time and edit its
    ID.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个**大文本**将简单地保存我们的等于号，而且没有计划去改变它。因此，我们不需要在我们的Java代码中与它交互。我们甚至不需要关心更改ID或知道它是什么。如果情况改变，我们随时可以在以后的时间回来编辑它的ID。
- en: However, this new TextView currently displays **Large Text** and we want it
    to display an equals to sign. So in the **Properties** window, find the **text**
    property and enter the value **=**. We have changed the **text** property before
    in [Chapter 2](ch02.xhtml "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*, and you might also like to change the text property for
    `textPartA`, `textPartB`, and `textOperator`. This is not absolutely essential
    because we will soon see how we can change it via our Java code; however, if we
    change the **text** property to something more appropriate, then our UI designer
    will look more like it will when the game runs on a real device.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，这个新的TextView目前显示**大文本**，我们希望它显示一个等于号。因此，在**属性**窗口中，找到**text**属性，并输入值**=**。我们之前在[第2章](ch02.xhtml
    "第2章。开始使用Android")中更改了**text**属性，*开始使用Android*，你可能也想更改`textPartA`，`textPartB`和`textOperator`的文本属性。这并非绝对必要，因为我们很快就会看到如何通过我们的Java代码来更改它；然而，如果我们将**text**属性更改为更合适的内容，那么我们的UI设计师看起来将更像在真实设备上运行游戏时的样子。
- en: So change the text property of **textPartA** to `2`, **textPartB** to `2`, and
    **textOperator** to `x`. Your UI design and Component tree should now look like
    this:![Laying out the game screen UI](img/8859OS_03_14.jpg)
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以将**textPartA**的文本属性更改为`2`，**textPartB**更改为`2`，**textOperator**更改为`x`。现在你的UI设计和组件树应该是这样的：![布局游戏屏幕UI](img/8859OS_03_14.jpg)
- en: For the buttons to contain our multiple choice answers, drag three buttons in
    a row, below the **=** sign. Line them up neatly like our target design.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了包含我们的多项选择答案，将三个按钮依次拖到**=**符号下面。将它们整齐地排列，就像我们的目标设计一样。
- en: Now, just as we did for the TextViews, find the **id** properties of each button,
    and from left to right, change the **id** properties to `buttonChoice1`, `buttonChoice2`,
    and `buttonChoice3`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，就像我们为TextViews所做的那样，找到每个按钮的**id**属性，并从左到右，将**id**属性更改为`buttonChoice1`，`buttonChoice2`和`buttonChoice3`。
- en: Why not enter some arbitrary numbers for the **text** property of each button
    so that the designer more accurately reflects what our game will look like, just
    as we did for our other TextViews? Again, this is not absolutely essential as
    our Java code will control the button appearance.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么不为每个按钮的**text**属性输入一些任意的数字，以便设计更准确地反映我们的游戏将是什么样子，就像我们为其他TextView所做的那样？同样，这并非绝对必要，因为我们的Java代码将控制按钮的外观。
- en: We are now actually ready to move on. But you probably agree that the UI elements
    look a little lost. It would look better if the buttons and text were bigger.
    All we need to do is adjust the textSize property for each TextView and for each
    Button. Then, we just need to find the textSize property for each element and
    enter a number with the sp syntax. If you want your design to look just like our
    target design from earlier, enter `70sp` for each of the TextView textSize properties
    and `40sp` for each of the Buttons textSize properties. When you run the game
    on your real device, you might want to come back and adjust the sizes up or down
    a bit. But we have a bit more to do before we can actually try out our game.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在实际上已经准备好继续了。但你可能会同意UI元素看起来有点迷失。如果按钮和文本更大会更好看。我们只需要调整每个TextView和每个Button的textSize属性。然后，我们只需要找到每个元素的textSize属性，并输入带有sp语法的数字。如果你希望你的设计看起来就像我们之前的目标设计一样，那么为每个TextView的textSize属性输入`70sp`，为每个按钮的textSize属性输入`40sp`。当你在真实设备上运行游戏时，你可能需要回来调整一下大小。但在我们实际尝试游戏之前，我们还有更多的工作要做。
- en: Save the project and then we can move on.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存项目，然后我们可以继续。
- en: As before, we have built our UI. This time, however, we have given all the important
    parts of our UI a unique, useful, and easy to identify ID. As we will see we are
    now able to communicate with our UI through our Java code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们已经构建了我们的用户界面。然而，这一次，我们为UI的所有重要部分提供了一个独特的、有用的、易于识别的ID。正如我们将看到的，我们现在能够通过我们的Java代码与我们的UI进行通信。
- en: Coding a question in Java
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Java中编写问题
- en: With our current knowledge of Java, we are not yet able to complete our math
    game but we can make a significant start. We will look at how we can ask the player
    a question and offer them some multiple choice answers (one correct and two incorrect).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借我们目前对Java的了解，我们还不能完成我们的数学游戏，但我们可以有一个重要的开始。我们将看看如何向玩家提问并提供一些多项选择答案（一个正确答案和两个错误答案）。
- en: 'At this stage, we know enough of Java to declare and initialize some variables
    that will hold the parts of our question. For example, if we want to ask the times
    tables question *2 x 2*, we could have the following variable initializations
    to hold the values for each part of the question:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经了解了足够的Java知识，可以声明和初始化一些变量来存储我们问题的各个部分。例如，如果我们想要问乘法表问题*2 x 2*，我们可以有以下变量初始化来存储问题的每个部分的值：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code declares and initializes two variables of the `int` type,
    each to the value of 2\. We use `int` because we will not be dealing with any
    decimal fractions. Remember that the variable names are arbitrary and were just
    chosen because they seemed appropriate. Clearly, any math game worth downloading
    is going to need to ask more varied and advanced questions than *2 x 2*, but it
    is a start.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码声明并初始化了两个`int`类型的变量，每个变量的值都为2。我们使用`int`，因为我们不会处理任何小数。请记住，变量名是任意的，只是因为它们看起来合适才选择的。显然，任何值得下载的数学游戏都需要提出比*2
    x 2*更多样化和高级的问题，但这是一个开始。
- en: 'Now we know that our math game will offer multiple choices as answers. So,
    we need a variable for the correct answer and two variables for two incorrect
    answers. Take a look at these combined declarations and initializations:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们的数学游戏将提供多个选择作为答案。因此，我们需要一个变量来存储正确答案，以及两个变量来存储两个错误答案。看一下这些组合声明和初始化：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that the initialization of the variables for the wrong answers depends
    on the value of the correct answer, and the variables for the wrong answers are
    initialized after initializing the `correctAnswer` variable.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，错误答案的变量初始化取决于正确答案的值，并且在初始化`correctAnswer`变量之后初始化错误答案的变量。
- en: 'Now we need to put these values, held in our variables, into the appropriate
    elements on our UI. The question variables (`partA` and `partB`) need to be displayed
    in our UI elements, `textPartA` and `textPartB`, and the answer variables (`correctAnswer`,
    `wrongAnswer1`, and `wrongAnswer2`) need to be displayed in our UI elements with
    the following IDs: `buttonChoice1`, `buttonChoice2`, and `buttonChoice3`. We will
    see how we do this in the next step-by-step tutorial. We will also implement the
    variable declaration and initialization code that we discussed a moment ago:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将我们变量中保存的这些值放入我们UI上的适当元素中。问题变量（`partA`和`partB`）需要显示在我们的UI元素`textPartA`和`textPartB`中，答案变量（`correctAnswer`，`wrongAnswer1`和`wrongAnswer2`）需要显示在具有以下ID的UI元素中：`buttonChoice1`，`buttonChoice2`和`buttonChoice3`。我们将在下一个逐步教程中看到如何做到这一点。我们还将实现我们刚才讨论过的变量声明和初始化代码：
- en: First, open `GameActivity.java` in the editor window. Remember that you can
    do this by double-clicking on **GameActivity** in our `java` folder or clicking
    on its tab above the editor window if `GameActivity.java` is already open.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在编辑窗口中打开`GameActivity.java`。请记住，您可以通过双击`java`文件夹中的**GameActivity**或单击编辑窗口上方的选项卡来执行此操作，如果`GameActivity.java`已经打开。
- en: 'All of our code will go into the `onCreate` method. It will go after the `setContentView(R.layout.activity_game);`
    line but before the closing curly brace `}` of the `onCreate` method. Perhaps,
    it''s a good idea to leave a blank line for clarity and a nice explanatory comment
    as shown in the following code. We can see the entire `onCreate` method as it
    stands after the latest amendments. The parts in bold are what you need to add.
    Feel free to add helpful comments like mine if you wish:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们所有的代码都将放在`onCreate`方法中。它将放在`setContentView(R.layout.activity_game);`行之后，但在`onCreate`方法的结束大括号`}`之前。也许，为了清晰起见，最好留一行空白，并添加一个好的解释性注释，如下面的代码所示。我们可以看到整个`onCreate`方法在最新的修改之后的样子。粗体部分是你需要添加的部分。如果愿意，可以像我一样添加有用的注释：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we need to add the values contained within the variables to the `TextView`
    and `Button` of our UI. But first, we need to get access to the UI elements we
    created. We do that by creating a variable of the appropriate class and linking
    it via the ID property of the appropriate UI element. We already know the class
    of our UI elements: `TextView` and `Button`. Here is the code that creates our
    special class variables for each of the necessary UI elements. Take a close look
    at the code, but don''t worry if you don''t understand all of it now. We will
    dissect the code in detail once everything is working. Enter the code immediately
    after the code entered in the previous step. You can leave a blank line for clarity
    if you wish. Just before you proceed, note that at two points while typing in
    this code, you will be prompted to import another class. Go ahead and do so on
    both occasions:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要将变量中包含的值添加到我们UI的`TextView`和`Button`中。但首先，我们需要访问我们创建的UI元素。我们通过创建适当类的变量并通过适当UI元素的ID属性进行链接来实现这一点。我们已经知道我们UI元素的类：`TextView`和`Button`。以下是为每个必要的UI元素创建我们特殊类变量的代码。仔细看看这段代码，但如果现在不理解所有内容也不要担心。一切正常后，我们将详细解析代码。在上一步输入的代码之后立即输入这段代码。如果愿意，可以留一行空白以便清晰。在继续之前，请注意，在键入此代码时，有两个地方会提示您导入另一个类。在这两种情况下都可以继续操作：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding code, if you read the multiline comment, you will see that
    I used the term **object**. When we create a variable type based on a class, we
    call it an object. Once we have an object of a class, we can do anything that
    that class was designed to do. This is very powerful and is explored thoroughly
    in [Chapter 6](ch06.xhtml "Chapter 6. OOP – Using Other People's Hard Work"),
    *OOP – Using Other People's Hard Work*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，如果您阅读多行注释，您会看到我使用了术语**对象**。当我们基于类创建变量类型时，我们称之为对象。一旦我们有了类的对象，我们就可以做任何该类设计的事情。这是非常强大的，并且在[第6章](ch06.xhtml
    "第6章。OOP – Using Other People's Hard Work")中得到了充分探讨，*OOP – Using Other People's
    Hard Work*。
- en: 'Now we have five new objects linked to the elements of our UI that we need
    to manipulate. What precisely are we going to do with them? We need to display
    the values of our variables in the text of the UI elements. We can use the objects
    we just created combined with a method provided by the class, and use our variables
    as values for that text. As usual, we will dissect this code further at the end
    of this tutorial. Here is the code to enter directly after the code in the previous
    step. Try and work out what is going on before we look at it together:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有五个新对象与我们需要操作的UI元素相关联。我们要用它们做什么？我们需要在UI元素的文本中显示变量的值。我们可以使用我们刚刚创建的对象，结合类提供的方法，并将我们的变量作为文本的值。像往常一样，我们将在本教程结束时进一步解析这段代码。以下是要直接输入到上一步代码之后的代码。在我们一起查看之前，试着弄清楚发生了什么：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Save your work.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的工作。
- en: If you play with the assignment values for `partA` and `partB`, you can make
    them whatever you like and the game adjusts the answers accordingly. Obviously,
    we shouldn't need to reprogram our game each time we want a new question and we
    will solve that problem soon. All we need to do now is link the game section we
    have just made to the start screen menu. We will do that in the next tutorial.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您玩转`partA`和`partB`的赋值，您可以随意设置它们，游戏会相应地调整答案。显然，我们不应该每次想要一个新问题时都需要重新编写我们的游戏，我们很快就会解决这个问题。现在我们需要做的就是将我们刚刚制作的游戏部分与开始屏幕菜单连接起来。我们将在下一个教程中完成这一点。
- en: Now let's explore the trickier and newer parts of our code in more detail.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更详细地探讨我们代码中更棘手和更新的部分。
- en: 'In step 2, we declared and initialized the variables required so far:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，我们声明并初始化了到目前为止所需的变量：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then in step 3, we got a reference to our UI design through our Java code.
    For the TextViews, it was done like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在第3步，我们通过Java代码获得了对我们UI设计的引用。对于TextView，是这样完成的：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For each of the buttons, a reference to our UI design was obtained like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个按钮，获得对我们UI设计的引用是这样完成的：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In step 4, we did something new. We used a the `setText` method to show the
    values of our variables on our UI elements (`TextView` and `Button`) to the player.
    Let's break down one line completely to see how it works. Here is the code that
    shows the `correctAnswer` variable being displayed on `buttonObjectChoice1`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们做了一些新的事情。我们使用`setText`方法在UI元素（`TextView`和`Button`）上向玩家显示我们的变量的值。让我们完全分解一行，看看它是如何工作的。这是显示`correctAnswer`变量显示在`buttonObjectChoice1`上的代码。
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'By typing `buttonObjectChoice1` and adding a period, as shown in the following
    line of code, we have access to all the preprogrammed methods of that object''s
    class type that are provided by Android:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入`buttonObjectChoice1`并添加一个句点，如下面的代码行所示，我们可以访问Android提供的该对象类类型的所有预编程方法：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**The power of Button and the Android API**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**按钮和Android API的力量**'
- en: There are actually lots of methods that we can perform on an object of the Button
    type. If you are feeling brave, try this to get a feeling of just how much functionality
    there is in Android.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以在Button类型的对象上执行许多方法。如果您感到勇敢，尝试一下，看看Android有多少功能。
- en: 'Type the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下代码：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Be sure to type the period on the end. Android Studio will pop up a list of
    possible methods to use on this object. Scroll through the list and get a feel
    of the number and variety of options:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在末尾输入句点。Android Studio将弹出一个可能要在此对象上使用的方法列表。浏览列表，了解选项的数量和多样性：
- en: '![Coding a question in Java](img/8859OS_03_09.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![在Java中编写问题](img/8859OS_03_09.jpg)'
- en: If a mere button can do all of this, think of the possibilities for our games
    once we have mastered all the classes contained in Android. A collection of classes
    designed to be used by others is collectively known as an **Application Programmers
    Interface** (**API**). Welcome to the Android API!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个简单的按钮可以做到这一切，想象一下一旦我们掌握了Android中包含的所有类，我们的游戏的可能性。一个供他人使用的类集合被称为**应用程序员接口**（**API**）。欢迎来到Android
    API！
- en: 'In this case, we just want to set the button''s text. So, we use `setText`
    and concatenate the value stored in our `correctAnswer` variable to the end of
    an empty string, like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只想设置按钮的文本。因此，我们使用`setText`并将存储在我们的`correctAnswer`变量中的值连接到空字符串的末尾，就像这样：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We do this for each of the UI elements we require to show our variables.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个需要显示我们的变量的UI元素执行此操作。
- en: Tip
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Playing with autocomplete**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用自动完成玩耍**'
- en: 'If you tried the previous tip, *The power of Button and the Android API*, and
    explored the methods available for objects of the Button type, you will already
    have some insight into autocomplete. Note that as you type, Android Studio is
    constantly making suggestions for what you might like to type next. If you pay
    attention to this, you can save a lot of time. Simply select the correct code
    completion statement that is suggested and press *Enter*. You can even see how
    much time you saved by selecting **Help** | **Productivity Guide** from the menu
    bar. Here you will see statistics for every aspect of code completion and more.
    Here are a few entries from mine:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试了前面的提示，*按钮和Android API的力量*，并探索了Button类型对象可用的方法，您可能已经对自动完成有所了解。请注意，当您输入时，Android
    Studio会不断地为您提供建议。如果您留意这一点，您可以节省很多时间。只需选择建议的正确代码完成语句并按*Enter*。您甚至可以通过选择**帮助** |
    **生产力指南**来查看您节省了多少时间。在这里，您将看到有关代码完成和更多内容的统计数据。以下是我的一些条目：
- en: '![Coding a question in Java](img/8859OS_03_08.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![在Java中编写问题](img/8859OS_03_08.jpg)'
- en: As you can see, if you get used to using shortcuts early on, you can save a
    lot of time in the long run.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，如果您早期习惯使用快捷方式，您可以从长远来看节省很多时间。
- en: Linking our game from the main menu
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从主菜单链接我们的游戏
- en: 'At the moment, if we run the app, we have no way for the player to actually
    arrive at our new game activity. We want the game activity to run when the player
    clicks on the **Play** button on the main `MainActivity` UI. Here is what we need
    to do to make that happen:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果我们运行应用程序，玩家实际上没有办法到达我们的新游戏活动。我们希望当玩家点击主`MainActivity` UI上的**Play**按钮时，游戏活动会运行。这是我们需要做的：
- en: Open the file `activity_main.xml`, either by double-clicking on it in the Project
    Explorer or by clicking on its tab in the editor window.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件`activity_main.xml`，可以通过在项目资源管理器中双击它或者在编辑窗口中点击它的选项卡来打开。
- en: Now, just like we did when building the game UI, assign an ID to the **Play**
    button. As a reminder, click on the **Play** button either on the UI design or
    in the component tree. Find the **id** property in the **Properties** window.
    Assign the `buttonPlay` value to it. We can now make this button do stuff by referring
    to it in our Java code.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，就像我们构建游戏UI时所做的那样，为**Play**按钮分配一个ID。作为提醒，在UI设计或组件树中点击**Play**按钮。在**属性**窗口中找到**id**属性。将`buttonPlay`值分配给它。现在我们可以通过在我们的Java代码中引用它来使这个按钮做一些事情。
- en: Open the file `MainActivity.java`, either by double-clicking on it in the Project
    Explorer or clicking on its tab in the editor window.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件`MainActivity.java`，可以通过在项目资源管理器中双击它或者在编辑窗口中点击它的选项卡来打开。
- en: 'In our `onCreate` method, just after the line where we `setContentView`, add
    the following highlighted line of code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`onCreate`方法中，在我们`setContentView`的行后面，添加以下突出显示的代码行：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We will dissect this code in detail once we have got this working. Basically
    we are making a connection to the **Play** button by creating a reference variable
    to a `Button` object. Notice that both words are highlighted in red indicating
    an error. Just as before, we need to import the Button class to make this code
    work. Use the *Alt* + *Enter* keyboard combination. Now click on **Import class**
    from the popped-up list of options. This will automatically add the required import
    directive at the top of our `MainActivity.java` file.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们让它工作起来，我们将详细解剖这段代码。基本上，我们正在通过创建对`Button`对象的引用变量来连接到**Play**按钮。注意到两个词都是红色高亮显示的，表示有错误。就像之前一样，我们需要导入Button类来使这段代码工作。使用*Alt*
    + *Enter*键盘组合。现在点击弹出的选项列表中的**Import class**。这将自动在我们的`MainActivity.java`文件顶部添加所需的导入指令。
- en: 'Now for something new. We will give the button the ability to *listen* to the
    user clicking on it. Type this immediately after the last line of code we entered:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是新的内容。我们将使按钮能够*监听*用户点击它。在我们输入的最后一行代码之后立即输入以下内容：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Notice how the `this` keyword is highlighted in red indicating an error. This
    introduces another Java feature that will be more thoroughly explored in [Chapter
    6](ch06.xhtml "Chapter 6. OOP – Using Other People''s Hard Work"),*OOP – Using
    Other People''s Hard Work*. Setting that aside, we need to make a modification
    to our code now in order to allow the use of an interface that is a special code
    element that allows us to add a functionality, such as listening for button clicks.
    Edit the line as follows. When prompted to import another class, click on **OK**:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到`this`关键字是红色高亮显示的，表示有一个错误。这引入了另一个Java特性，将在[第6章](ch06.xhtml "第6章。OOP – Using
    Other People's Hard Work")中更加深入地探讨，*OOP – Using Other People's Hard Work*。暂且不谈这个，我们现在需要对我们的代码进行修改，以允许使用一个特殊的代码元素，即接口，它允许我们添加功能，比如监听按钮点击。编辑以下行。在提示导入另一个类时，点击**OK**：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: to
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: to
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now we have the entire line underlined in red. This indicates an error but it's
    where we should be at this point. We mentioned that by adding `implements View.OnClickListener`,
    we have implemented an interface. We can think of this like a class that we can
    use but with extra rules. The rules of the `OnClickListener` interface state that
    we *must* implement/use one of its methods. Notice that until now, we have optionally
    overridden/used methods as and when they have suited us. If we wish to use the
    functionality this interface provides, namely listening for button presses, then
    we have to add/implement the `onClick` method.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用红色下划线标出了整行。这表示了一个错误，但这是我们目前应该在的位置。我们提到通过添加`implements View.OnClickListener`，我们已经实现了一个接口。我们可以把它想象成一个我们可以使用的类，但有额外的规则。`OnClickListener`接口的规则规定我们*必须*实现/使用它的一个方法。注意到到目前为止，我们已经根据需要选择性地重写/使用方法。如果我们希望使用这个接口提供的功能，即监听按钮按下，那么我们必须添加/实现`onClick`方法。
- en: 'This is how we do it. Notice the opening curly brace, `{`, and the closing
    curly brace, `}`. These denote the start and end of the method. Notice that the
    method is empty and it doesn''t do anything, but an empty method is enough to
    comply with the rules of the `OnClickListener` interface, and the red line indicating
    that our code has an error has gone. The syntax of these methods we have been
    using, as promised, will be explained in the next chapter when we start to write
    our own methods. Make sure that you type the following code, outside the closing
    curly brace (`}`) of the `onCreate` method but inside the closing curly brace
    of our `MainActivity` class:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是我们的做法。注意到开放的大括号`{`和闭合的大括号`}`。这表示方法的开始和结束。注意到这个方法是空的，它什么也不做，但一个空的方法足以符合`OnClickListener`接口的规则，红线表示我们的代码有错误已经消失。我们一直在使用的这些方法的语法，将在下一章中承诺时解释。确保你在`onCreate`方法的闭合大括号(`}`)之外但在`MainActivity`类的闭合大括号之内输入以下代码：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Notice that we have an empty line between `{` and `}` of the `onClick` method.
    We can now add code in here to make the button actually do something. Type the
    following highlighted code between `{` and `}` of `onClick`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到`onClick`方法的`{`和`}`之间有一行空白。我们现在可以在这里添加代码，使按钮实际上做一些事情。在`onClick`的`{`和`}`之间输入以下高亮显示的代码：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: OK, so that code is a bit of a mouthful to comprehend all at once. See if you
    can guess what is happening. The clue is in the method named `startActivity` and
    the hopefully familiar term, `GameActivity`. Notice that we are assigning something
    to `i`. We will quickly get our app working and then diagnose the code in full.
    Its understanding will be complete when we explore how classes work in [Chapter
    6](ch06.xhtml "Chapter 6. OOP – Using Other People's Hard Work"), *OOP – Using
    Other People's Hard Work*.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，这段代码一次理解起来有点费劲。看看你能否猜到发生了什么。提示在名为`startActivity`的方法和熟悉的术语`GameActivity`中。注意到我们正在给`i`赋值。我们将快速让我们的应用程序工作，然后全面诊断代码。当我们探索类在[第6章](ch06.xhtml
    "第6章。OOP – Using Other People's Hard Work")中的工作方式时，我们的理解将是完整的，*OOP – Using Other
    People's Hard Work*。
- en: 'Notice that we have an error: all instances of the word `Intent` are red. We
    can solve this by importing the classes required to make `Intent` work. As before
    press *Alt* + *Enter*.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到我们有一个错误：所有`Intent`一词的实例都是红色的。我们可以通过导入所需的类来解决这个问题，使`Intent`工作。和之前一样，按下*Alt*
    + *Enter*。
- en: Run the game in the emulator or on your device.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器或设备上运行游戏。
- en: 'Our app will now work. This is what the new game screen looks like after pressing
    **Play** on the menu screen:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用现在将工作。这是在菜单屏幕上按下**Play**后新游戏屏幕的样子：
- en: '![Linking our game from the main menu](img/8859OS_03_20.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![从主菜单链接到我们的游戏](img/8859OS_03_20.jpg)'
- en: 'Almost every part of our code has changed a little and we have added a lot
    to it as well. Let''s go over the contents of `MainActivity.java` and look at
    it line by line. For context, here it is in full:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码的几乎每个部分都有一些变化，我们也添加了很多内容。让我们逐行查看`MainActivity.java`的内容。为了上下文，这是完整的代码：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We have seen much of this code before, but let''s just go over it a chunk at
    a time before moving on so that it is absolutely clear. The code works like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到了大部分这段代码，但在继续之前，让我们一块一块地复习一下，以确保它绝对清晰。代码的工作方式如下：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You would probably remember that this first block of code defines what our package
    is called and makes available all the Android API stuff we need for Button, TextView,
    and Activity.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这个代码块定义了我们的包叫什么，并且使得所有Android API的东西对Button、TextView和Activity都是可用的。
- en: 'From our `MainActivity.java` file, we have this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的`MainActivity.java`文件中，我们有这样的内容：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Our `MainActivity` declaration with our new bit of code implements `View.OnClickListener`
    that gives us the ability to detect button clicks.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`MainActivity`声明与我们的新代码一起实现了`View.OnClickListener`，这使我们能够检测按钮点击。
- en: 'Next in our code is this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码中的下一步是这样的：
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This previous bit of code hasn't changed since [Chapter 2](ch02.xhtml "Chapter 2. Getting
    Started with Android"), *Getting Started with Android*. It is at the start of
    our `onCreate` method where we first ask the hidden code of `onCreate` to do its
    stuff using `super.onCreate(savedInstanceState);`. Then we set our UI to the screen
    with `setContentView(R.layout.activity_main);`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 自[第2章](ch02.xhtml "第2章. 开始使用Android")以来，这段代码就没有改变过，*开始使用Android*。它位于我们的`onCreate`方法的开头，我们首先要求`onCreate`的隐藏代码使用`super.onCreate(savedInstanceState);`来执行其操作。然后我们使用`setContentView(R.layout.activity_main);`将我们的UI设置到屏幕上。
- en: 'Next, we get a reference to our button with an ID of `buttonPlay`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们获取了一个ID为`buttonPlay`的按钮的引用：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, our `onClick` method uses the `Intent` class to send the player to
    our `GameActivity` class and the related UI when the user clicks on the **Play**
    button:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的`onClick`方法使用`Intent`类将玩家发送到我们的`GameActivity`类和相关的UI，当用户点击**Play**按钮时：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you run the app, you will notice that we can now click on the **Play** button
    and our math game will ask us a question. Of course, we can't answer it yet. Although
    we have very briefly looked at how to deal with button presses, we need to learn
    more of Java in order to intelligently react to them. We will also reveal how
    to write code to handle presses from several buttons. This will be necessary to
    receive input from our multiple-choice-centric `game_activity` UI.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个应用，你会注意到我们现在可以点击**Play**按钮，我们的数学游戏会问我们一个问题。当然，我们现在还不能回答。虽然我们已经非常简要地看过如何处理按钮按下，但我们需要学习更多的Java知识才能对其做出智能反应。我们还将揭示如何编写代码来处理来自多个按钮的按下。这对于从我们的多选中心的`game_activity`
    UI接收输入是必要的。
- en: Decisions in Java
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java中做决定
- en: We can now summon enough of Java prowess to ask a question but a real math game
    must obviously do much more than this. We need to capture the player's answer,
    and we are nearly there with that—we can detect button presses. From there, we
    need to be able to **decide** whether their answer is right or wrong. Then, based
    on this decision, we have to **choose** an appropriate course of action.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以召唤足够的Java技能来提问，但一个真正的数学游戏显然需要做的远不止这些。我们需要捕获玩家的答案，我们几乎已经做到了——我们可以检测按钮按下。然后，我们需要能够**决定**他们的答案是对还是错。然后，根据这个决定，我们必须**选择**适当的行动方针。
- en: Let's leave the math game aside for now and look at how Java might help us by
    learning some more fundamentals and syntax of the Java language.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时把数学游戏放在一边，看看Java如何帮助我们学习一些更基本的Java语言的基础知识和语法。
- en: More operators
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多的运算符
- en: 'Let''s look at some more operators: we can already add (+), take away (-),
    multiply (*), divide (/), assign (=), increment (++), compare (==), and decrement
    (--) with operators. Let''s introduce some more super-useful operators, and then
    we will go straight to actually understanding how to use them in Java.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看一些运算符：我们已经可以使用运算符进行加法（+）、减法（-）、乘法（*）、除法（/）、赋值（=）、递增（++）、比较（==）和递减（--）。让我们介绍一些更加超级有用的运算符，然后我们将直接理解如何在Java中使用它们。
- en: Tip
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't worry about memorizing every operator given here. Glance at them and their
    explanations and then move quickly on to the next section. There, we will put
    some operators to use and they will become much clearer as we see a few examples
    of what they allow us to do. They are presented here in a list just to make the
    variety and scope of operators plain from the start. The list will also be more
    convenient to refer back to when not intermingled with the discussion about implementation
    that follows it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心记住这里给出的每个运算符。浏览它们和它们的解释，然后快速转到下一节。在那里，我们将使用一些运算符，当我们看到它们允许我们做些什么的几个例子时，它们将变得更加清晰。它们在这里以列表的形式呈现，只是为了从一开始就清楚地展示运算符的种类和范围。当不与随后的实现讨论混在一起时，这个列表也更方便作为参考。
- en: '**==**: This is a comparison operator we saw this very briefly before. It tests
    for equality and is either true or false. An expression like `(10 == 9);`, for
    example, is false.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**==**：这是一个我们之前非常简要看到的比较运算符。它用于测试相等，结果要么是真要么是假。例如，表达式`(10 == 9);`是假的。'
- en: '**!**: The logical NOT operator. The expression, `! (2+2==5)`.`)`, is true
    because 2+2 is NOT 5.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**!**：逻辑非运算符。表达式`! (2+2==5)`.`)`是真的，因为2+2不等于5。'
- en: '**!=**: This is another comparison operator, which tests if something is NOT
    equal. For example, the expression, `(10 != 9);)`, is true, that is, 10 is not
    equal to 9.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**!=**：这是另一个比较运算符，用于测试某物是否不相等。例如，表达式`(10 != 9);)`是真的，也就是说，10不等于9。'
- en: '**>**: This is another comparison operator, which tests if something is greater
    than something else. The expression, `(10 > 9);)`, is true. There are a few more
    comparison operators as well.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**>**：这是另一个比较运算符，用于测试某物是否大于另一物。表达式`(10 > 9);)`是真的。还有一些其他的比较运算符。'
- en: '**<**: You guessed it. This tests whether the value to the left is less than
    the value to the right or not. The expression, `(10 < 9);`, is false.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<**：你猜对了。这个测试左边的值是否小于右边的值。表达式`(10 < 9);`是假的。'
- en: '**>=**: This operator tests whether one value is greater than or equal to the
    other, and if either is true, the result is true. For example, the expression,
    `(10 >= 9);`, is true. The expression, `(10 >= 10);`, is also true.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**>=**：这个运算符测试一个值是否大于或等于另一个值，如果其中一个条件成立，结果就是真。例如，表达式`(10 >= 9);`是真的。表达式`(10
    >= 10);`也是真的。'
- en: '**<=**: Like the preceding operator, this operator tests for two conditions
    but this time, less than and equal to. The expression, `(10 <= 9);`, is false.
    The expression, `(10 <= 10);`, is true.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<=**：与前一个运算符类似，这个运算符测试两个条件，这次是小于或等于。表达式`(10 <= 9);`为假。表达式`(10 <= 10);`为真。'
- en: '**&&**: This operator is known as logical AND. It tests two or more separate
    parts of an expression and all parts must be true in order for the result to be
    true. Logical AND is usually used in conjunction with the other operators to build
    more complex tests. The expression, `((10 > 9) && (10 < 11));`, is true because
    both parts are true. The expression, `((10 > 9) && (10 < 9));`, is false because
    only one part of the expression is true and the other is false.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**&&**：这个运算符称为逻辑与。它测试表达式的两个或多个独立部分，所有部分必须为真才能使结果为真。逻辑与通常与其他运算符一起使用，以构建更复杂的测试。表达式`((10
    > 9) && (10 < 11));`是真的，因为两部分都为真。表达式`((10 > 9) && (10 < 9));`是假的，因为表达式的一部分为真，另一部分为假。'
- en: '**||**: This operator is called logical OR. It is just like logical AND except
    that only one of two or more parts of an expression need to be true for the expression
    to be true. Let''s look at the last example we used but replace the && sign with
    ||. The expression, `((10 > 9) || (10 < 9));`, is now true because one part of
    the expression is true.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**||**：这个运算符称为逻辑或。它与逻辑与类似，只是表达式中的两个或多个部分中只有一个为真，表达式才为真。让我们看看我们之前使用的最后一个例子，但是用`||`代替`&&`。表达式`((10
    > 9) || (10 < 9));`现在为真，因为表达式的一部分为真。'
- en: All of these operators are virtually useless without a way of properly using
    them to make real decisions that affect real variables and code. Let's look at
    how to make decisions in Java.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些运算符如果没有正确使用它们来影响真实变量和代码的决策，就几乎没有用。让我们看看如何在Java中做出决策。
- en: Decision 1 – If they come over the bridge, shoot them
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决策1 - 如果他们过桥，就射击他们
- en: As we saw, operators serve hardly any purpose on their own but it was probably
    useful to see just a part of the wide and varied range available to us. Now, when
    we look at putting the most common operator, `==`, to use, we can start to see
    the powerful yet fine control that operators offer us.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，运算符单独使用几乎没有任何意义，但是可能有用的是看到我们可以使用的广泛和多样的范围的一部分。现在，当我们开始使用最常见的运算符`==`时，我们可以开始看到运算符提供给我们的强大而精细的控制。
- en: Let's make the previous examples less abstract using the Java `if` keyword and
    a few conditional operators with a fun story and some code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Java的`if`关键字和一些条件运算符以及一个有趣的故事和一些代码来使之前的例子不那么抽象。
- en: The captain is dying and, knowing that his remaining subordinates are not very
    experienced, he decides to write a Java program to convey his last orders after
    he has died. The troops must hold one side of a bridge while awaiting reinforcements.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 船长垂危，知道剩下的部下经验不足，他决定在自己死后写一个Java程序来传达他的最后命令。部队必须在等待增援的同时守住桥的一侧。
- en: 'The first command the captain wants to make sure his troops understand is this:
    If they come over the bridge, shoot them.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 船长想要确保他的部队理解的第一个命令是：如果他们过桥，就射击他们。
- en: So how do we simulate this situation in Java? We need a Boolean variable `isComingOverBridge`.
    The next bit of code assumes that the `isComingOverBridge` variable has been declared
    and initialized.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何在Java中模拟这种情况呢？我们需要一个布尔变量`isComingOverBridge`。下一段代码假设`isComingOverBridge`变量已经被声明和初始化。
- en: 'We can then use it like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用它：
- en: '[PRE42]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If the `isComingOverBridge` Boolean is true, the code inside the opening and
    closing curly braces will run. If not, the program continues after the `if` block
    without running it.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`isComingOverBridge`布尔值为真，则大括号内的代码将运行。如果不是，则程序在`if`块之后继续运行而不运行它。
- en: Decision 2 – Else, do this
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决策2 - 否则，执行这个操作
- en: The captain also wants to tell his troops what to do (stay put) if the enemy
    is not coming over the bridge.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 船长还想告诉他的部队，如果敌人没有过桥，他们应该待在原地。
- en: Now we introduce another Java keyword, `else`. When we want to explicitly do
    something and the `if` block does not evaluate to true, we can use `else`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们介绍另一个Java关键字，`else`。当我们想要明确执行某些操作，而`if`块的条件不成立时，我们可以使用`else`。
- en: 'For example, to tell the troops to stay put if the enemy is not coming over
    the bridge, we use `else`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果敌人没有过桥，我们使用`else`命令部队留在原地：
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The captain then realized that the problem wasn''t as simple as he first thought.
    What if the enemy comes over the bridge and has more troops? His squad will be
    overrun. So, he came up with this code (we''ll use some variables as well this
    time):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后船长意识到问题并不像他最初想的那么简单。如果敌人过桥并且有更多的部队怎么办？他的小队将被压垮。因此，他想出了这段代码（这次我们也将使用一些变量）：
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, the captain''s last concern was that if the enemy came over the bridge
    waving the white flag of surrender and were promptly slaughtered, then his men
    would end up as war criminals. The Java code needed was obvious. Using the `wavingWhiteFlag`
    Boolean variable he wrote this test:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，船长最后的担心是，如果敌人拿着白旗过桥投降，然后被立即屠杀，那么他的部队将成为战争罪犯。所需的Java代码是显而易见的。使用`wavingWhiteFlag`布尔变量，他写下了这个测试：
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'But where to put this code was less clear. In the end, the captain opted for
    the following nested solution and changing the test for `wavingWhiteFlag` to logical
    NOT, like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在哪里放置这段代码并不太清楚。最后，船长选择了以下嵌套解决方案，并将`wavingWhiteFlag`的测试更改为逻辑非，就像这样：
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This demonstrates that we can nest `if` and `else` statements inside of one
    another to create even deeper decisions.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们可以嵌套`if`和`else`语句以创建更深层次的决策。
- en: We could go on making more and more complicated decisions but what we have seen
    is more than sufficient as an introduction. Take the time to reread this if anything
    is unclear. Who knows, there might even be a tricky logic question in the self-test
    at the end of the chapter. It is also important to point out that very often,
    there are two or more ways to arrive at the solution. The *right* way will usually
    be the way that solves the problem in the clearest and simplest manner.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续做出更多更复杂的决定，但我们已经看到的已经足够作为介绍。如果有任何不清楚的地方，请花时间重新阅读。谁知道，也许在本章末尾的自测中甚至会有一个棘手的逻辑问题。还要指出的是，很多时候，有两种或更多种方法可以得出解决方案。*正确*的方法通常是以最清晰和最简单的方式解决问题的方法。
- en: Switching to make decisions
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切换以做出决策
- en: We have seen the vast and virtually limitless possibilities of combining the
    Java operators with `if` and `else` statements. But sometimes a decision in Java
    can be better made in other ways.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了将Java运算符与`if`和`else`语句相结合的广阔而几乎无限的可能性。但有时，在Java中做出决定可能有其他更好的方法。
- en: When we have to make a decision based on a clear list of possibilities that
    doesn't involve complex combinations, then **switch** is usually the way to go.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们必须根据一个清晰的可能性列表做出决定，而不涉及复杂的组合时，**switch**通常是最好的选择。
- en: 'We start a `switch` decision like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始一个`switch`决定就像这样：
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the previous example, an argument could be an expression or a variable.
    Then within the curly braces, we can make decisions based on the argument with
    case and break elements:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，参数可以是表达式或变量。然后在大括号内，我们可以根据参数使用case和break元素做出决定：
- en: '[PRE48]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can see that in the previous example, each case states a possible result
    and each break denotes the end of that case as well as the point at which no further
    case statements should be evaluated. The first break encountered takes us out
    of the switch block to proceed with the next line of code.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到在前面的例子中，每个case都陈述了可能的结果，每个break都表示该case的结束以及不再评估进一步case语句的点。遇到的第一个break将我们带出switch块，继续执行下一行代码。
- en: 'We can also use **default** without a value to run some code if none of the
    case statements evaluate to true, like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用没有值的**default**来运行一些代码，如果没有一个case语句计算为true，就像这样：
- en: '[PRE49]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Supposing we are writing an old-fashioned text adventure game—the kind of game
    where the player types commands such as `"Go East"`, `"Go West"`, `"Take Sword"`,
    and so on. In this case, switch could handle that situation like this example
    code and we could use `default` to handle the case of the player typing a command
    that is not specifically handled:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在编写一个老式的文本冒险游戏-玩家输入命令，比如“向东走”，“向西走”，“拿剑”等。在这种情况下，switch可以像这个例子代码一样处理这种情况，我们可以使用`default`来处理玩家输入的未经特别处理的命令的情况：
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the next section, we will use `switch` so that our `onClick` method can handle
    the different multiple-choice buttons of our math game.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将使用`switch`，这样我们的`onClick`方法就可以处理数学游戏中不同的多选按钮。
- en: Tip
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Java has even more operators than we have covered here. We have looked at all
    the operators we are going to need in this book and probably the most used in
    general. If you want the complete lowdown on operators, take a look at the official
    Java documentation at [http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Java甚至有比我们在这里介绍的更多的运算符。我们已经看过了本书中需要的所有运算符，也可能是一般情况下使用最多的运算符。如果您想了解有关运算符的完整信息，请查看官方Java文档[http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html)。
- en: Math game – getting and checking the answer
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学游戏-获取和检查答案
- en: Here we will detect the right or wrong answer and provide a pop-up message to
    the player. Our Java is getting quite good now, so let's dive in and add these
    features. I will explain things as we go and then, as usual, dissect the code
    thoroughly at the end.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将检测正确或错误的答案，并向玩家提供弹出消息。我们的Java现在已经相当不错了，所以让我们深入研究并添加这些功能。我会在我们进行的过程中解释事情，然后像往常一样，在最后彻底解剖代码。
- en: 'The already completed code is in the download bundle, in the following files
    that correspond to the filenames we will create/autogenerate in Android Studio
    in a moment:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 已经完成的代码在下载包中，对应于我们将在Android Studio中创建/自动生成的文件名：
- en: '`Chapter3/MathGameChapter3b/java/MainActivity.java`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chapter3/MathGameChapter3b/java/MainActivity.java`'
- en: '`Chapter3/MathGameChapter3b/java/GameActivity.java`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chapter3/MathGameChapter3b/java/GameActivity.java`'
- en: '`Chapter3/MathGameChapter3b/layout/activity_main.xml`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chapter3/MathGameChapter3b/layout/activity_main.xml`'
- en: '`Chapter3/MathGameChapter3b/layout/activity_game.xml`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chapter3/MathGameChapter3b/layout/activity_game.xml`'
- en: As usual, I recommend following this tutorial step by step to see how we can
    create all of the code for ourselves.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我建议按步骤跟着本教程，看看我们如何为自己创建所有的代码。
- en: Open the `GameActivity.java` file visible in the editor window.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开编辑器窗口中可见的`GameActivity.java`文件。
- en: 'Now we need to add the click detection functionality to our `GameActivity`,
    just as we did for our `MainActivity`. However, we will go a little further than
    the last time. So let''s do it step by step as if it is totally new. Once again,
    we will give the buttons the ability to *listen* to the user clicking on them.
    Type this immediately after the last line of code we entered in the `onCreate`
    method but before the closing `}`. This time of course, we need to add some code
    to listen to three buttons:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要将点击检测功能添加到我们的`GameActivity`中，就像我们为`MainActivity`做的那样。但是，这次我们会比上次更进一步。所以让我们一步一步地做，就像它是全新的一样。再一次，我们将让按钮有能力*监听*用户点击它们。在我们输入`onCreate`方法中的最后一行代码之后，但在`}`之前立即输入这个。当然，这次我们需要添加一些代码来监听三个按钮：
- en: '[PRE51]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Notice how the `this` keyword is highlighted in red indicating an error. Again,
    we need to make a modification to our code in order to allow the use of an interface,
    the special code element that allows us to add functionalities such as listening
    to button clicks. Edit the line as follows. When prompted to import another class,
    click on **OK**. Consider this line of code:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意`this`关键字被标记为红色，表示错误。同样，我们需要对代码进行修改，以便允许使用接口，这是一种特殊的代码元素，允许我们添加诸如监听按钮点击之类的功能。编辑以下行。在提示要导入另一个类时，点击**OK**。考虑以下代码行：
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Change it to the following line:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为以下行：
- en: '[PRE53]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now we have the entire preceding line underlined in red. This indicates an error
    but it is where we should be at this point. We mentioned that by adding `implements
    View.OnClickListener`, we have implemented an interface. We can think of this
    like a class that we can use, but with extra rules. One of the rules of the `OnClickListener`
    interface is that we must implement one of its methods, as you might remember.
    Now we will add the `onClick` method.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们在整个前一行下划线标记为红色。这表示错误，但这是我们目前应该在的位置。我们提到通过添加`implements View.OnClickListener`，我们已经实现了一个接口。我们可以将其视为一个我们可以使用的类，但带有额外的规则。`OnClickListener`接口的规则之一是我们必须实现其方法之一，您可能还记得。现在我们将添加`onClick`方法。
- en: 'Type the following code. Notice the opening curly brace, `{`, and the closing
    curly brace, `}`. These denote the start and end of the method. Notice that the
    method is empty; it doesn''t do anything but an empty method is enough to comply
    with the rules of the `OnClickListener` interface and the red line that indicated
    an error has gone. Make sure that you type the following code outside the closing
    curly brace (`}`) of the `onCreate` method but inside the closing curly brace
    of our `MainActivity` class:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码。注意开头的大括号`{`和结尾的大括号`}`。这些表示方法的开始和结束。注意方法是空的；它什么也不做，但是一个空方法足以符合`OnClickListener`接口的规则，指示错误的红线已经消失。确保您在`onCreate`方法的结束大括号(`}`)之外输入以下代码，但在我们的`MainActivity`类的结束大括号内部：
- en: '[PRE54]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Notice that we have an empty line between the `{` and `}` braces of our `onClick`
    method. We can now put some code in here to make the buttons actually do something.
    Type the following in between `{` and `}` of `onClick`. This is where things get
    different from our code in `MainActivity`. We need to differentiate between the
    three possible buttons that could be pressed. We will do this with the `switch`
    statement that we discussed earlier. Look at the `case` criteria; they should
    look familiar. Here is the code that uses the switch statements:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意我们的`onClick`方法的`{`和`}`括号之间有一行空行。现在我们可以在这里放一些代码，使按钮实际上做一些事情。在`onClick`的`{`和`}`之间输入以下内容。这是与我们在`MainActivity`中的代码不同的地方。我们需要区分可能被按下的三个按钮。我们将使用我们之前讨论过的`switch`语句来做到这一点。看一下`case`条件；它们应该看起来很熟悉。以下是使用`switch`语句的代码：
- en: '[PRE55]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Each `case` element handles a different button. For each button case, we need
    to get the value stored in the button that was just pressed and see if it matches
    our `correctAnswer` variable. If it does, we must tell the player they got it
    right, and if not, we must tell them they got it wrong. However, there is still
    one problem we have to solve. The `onClick` method is separate from the `onCreate`
    method and the Button objects. In fact, all the variables are declared in the
    `onCreate` method. If you try typing the code from step 9 now, you will get lots
    of errors. We need to make all the variables that we need in `onClick` available
    in `onClick`. To do this, we will move their declarations from above the `onCreate`
    method to just below the opening `{` of `GameActivity`. This means that these
    variables become variables of the `GameActivity` class and can be seen anywhere
    within `GameActivity`. Declare the following variables like this:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个`case`元素处理不同的按钮。对于每个按钮情况，我们需要获取刚刚按下的按钮中存储的值，并查看它是否与我们的`correctAnswer`变量匹配。如果匹配，我们必须告诉玩家他们答对了，如果不匹配，我们必须告诉他们答错了。然而，我们仍然有一个问题需要解决。`onClick`方法是单独的，与`onCreate`方法和Button对象分开。事实上，所有变量都是在`onCreate`方法中声明的。如果现在尝试输入第9步的代码，将会出现很多错误。我们需要使`onClick`中需要的所有变量在`onClick`中可用。为此，我们将它们的声明从`onCreate`方法上方移动到`GameActivity`的开头`{`下方。这意味着这些变量成为`GameActivity`类的变量，并且可以在`GameActivity`中的任何地方看到。像这样声明以下变量：
- en: '[PRE56]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now change the initialization of these variables within `onCreate` as follows.
    The actual parts of code that need to be changed are highlighted. The rest is
    shown for context:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更改`onCreate`中这些变量的初始化如下。需要更改的实际代码部分已经突出显示。其余部分仅用于上下文显示：
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: and
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE58]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here is the top of our `onClick` method as well as the first `case` statement
    for our `onClick` method:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们的`onClick`方法的顶部以及我们的`onClick`方法的第一个`case`语句：
- en: '[PRE59]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here are the rest of the `case` statements that do the same steps as the code
    in the previous step except handling the last two buttons. Enter the following
    code after the code entered in the previous step:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是执行与上一步中的代码相同步骤的其余`case`语句，除了处理最后两个按钮。在上一步输入的代码之后输入以下代码：
- en: '[PRE60]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Run the program, and then we will look at the code carefully, especially that
    odd-looking `Toast` thing. Here is what happens when we click on the leftmost
    button:![Math game – getting and checking the answer](img/8859OS_03_25.jpg)
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序，然后我们将仔细查看代码，特别是那个看起来奇怪的`Toast`东西。当我们点击最左边的按钮时会发生什么：![数学游戏-获取和检查答案](img/8859OS_03_25.jpg)
- en: 'This is how we did it: In steps 1 through 6, we set up handling for our multi-choice
    buttons, including adding the ability to listen to clicks using the `onClick`
    method and a `switch` block to handle decisions depending on the button pressed.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们做的：在步骤1到6中，我们设置了处理多选按钮的方法，包括使用`onClick`方法和`switch`块来处理根据按下的按钮做出的决定的能力。
- en: In steps 7 and 8, we had to alter our code to make our variables available in
    the `onClick` method. We did this by making them member variables of our `GameActivity`
    class.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7和第8步中，我们不得不修改我们的代码，以使我们的变量在`onClick`方法中可用。我们通过将它们作为`GameActivity`类的成员变量来实现这一点。
- en: Tip
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When we make a variable a member of a class, we call it a **field**. We will
    discuss exactly when a variable should be a field and when it shouldn't in [Chapter
    6](ch06.xhtml "Chapter 6. OOP – Using Other People's Hard Work"), *OOP – Using
    Other People's Hard Work*.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将变量作为类的成员时，我们称之为**字段**。我们将在[第6章](ch06.xhtml "第6章。OOP – Using Other People's
    Hard Work")中讨论变量何时应该是字段，何时不应该是字段。
- en: In steps 9 and 10, we implemented the code that actually does the work in our
    switch statement in `onClick`. Let's take a line-by-line look at the code that
    runs when `button1` is pressed.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9和第10步中，我们实现了在`onClick`中执行实际工作的代码。让我们逐行查看当`button1`被按下时运行的代码。
- en: '[PRE61]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'First, the `case` statement is true when the button with an id of `buttonChoice1`
    is pressed. Then the next line of code to execute is this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`case`语句在按下id为`buttonChoice1`的按钮时为真。然后执行的下一行代码是这样的：
- en: '[PRE62]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The preceding line gets the value on the button using two methods. First, `getText`
    gets the number as a string and then `Integer.parseInt` converts it to an integer.
    The value is stored in our `answerGiven` variable. The following code executes
    next:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行使用了两个方法来获取按钮上的值。首先，`getText`以字符串形式获取数字，然后`Integer.parseInt`将其转换为整数。该值存储在我们的`answerGiven`变量中。接下来执行以下代码：
- en: '[PRE63]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `if` statement tests to see if the `answerGiven` variable is the same as
    `correctAnswer` using the `==` operator. If so, the `makeText` method of the `Toast`
    object is used to display a congratulatory message. If the values of the two variables
    are not the same, the message displayed is a bit more negative one.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句测试`answerGiven`变量是否与`correctAnswer`相同，使用`==`运算符。如果是，`Toast`对象的`makeText`方法用于显示祝贺消息。如果两个变量的值不同，显示的消息会更消极一些。'
- en: Note
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `Toast` line of code is possibly the most evil thing we have seen thus
    far. It looks exceptionally complicated and it does need a greater knowledge of
    Java than we have at the moment to understand. All we need to know for now is
    that we can use the code as it is and just change the message, and it is a great
    tool to announce something to the player. By the end of [Chapter 6](ch06.xhtml
    "Chapter 6. OOP – Using Other People''s Hard Work"), *OOP – Using Other People''s
    Hard Work*, the code for `Toast` will be clear. If you really want an explanation
    now, you can think of it like this: when we made button objects, we got to use
    all the button methods. But with Toast, we used the class directly to access its
    `makeText` method without creating an object first. We can do this process when
    the class and its methods are designed to allow it.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`Toast`代码行可能是我们迄今为止见过的最邪恶的东西。它看起来异常复杂，需要比我们目前所掌握的Java知识更多才能理解。我们现在只需要知道我们可以直接使用代码并只改变消息，这是一个向玩家宣布消息的好工具。到[第6章](ch06.xhtml
    "第6章。OOP – Using Other People''s Hard Work")结束时，`Toast`的代码将会清晰明了。如果你现在真的想要解释，你可以这样想：当我们创建按钮对象时，我们可以使用所有按钮方法。但是对于Toast，我们直接使用类来访问其`makeText`方法，而不需要先创建对象。当类及其方法被设计允许这样做时，我们可以进行这个过程。'
- en: 'Finally, we break out of the whole `switch` statement as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过以下方式跳出整个`switch`语句：
- en: '[PRE64]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now that we have improved the project as far as we can with what we learned
    in this chapter, why not test your understanding of everything you've learned
    so far?
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经根据本章学到的知识改进了项目，为什么不测试一下你迄今为止所学到的一切呢？
- en: Self-test questions
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: Q1) What does this code do?
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 这段代码做什么？
- en: '[PRE65]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Q2) Which of these lines causes an error?
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Q2) 以下哪行会导致错误？
- en: '[PRE66]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Q3) We talked a lot about operators and how different operators can be used
    together to build complicated expressions. Expressions, at a glance, can sometimes
    make the code look complicated. However, when looked at closely, they are not
    as tough as they seem. Usually, it is just a case of splitting the expressions
    into smaller pieces to work out what is going on. Here is an expression that is
    more convoluted than anything else you will ever see in this book. As a challenge,
    can you work out: what will `x` be?'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Q3) 我们谈了很多关于运算符以及不同运算符如何一起构建复杂表达式。表达式乍一看有时会让代码看起来复杂。然而，仔细观察时，它们并不像看起来那么难。通常，只是将表达式分成较小的部分来弄清楚发生了什么。这是一个比本书中你将看到的任何其他东西都更复杂的表达式。作为挑战，你能计算出：`x`将是什么吗？
- en: '[PRE67]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We covered a lot in this chapter. We went from knowing nothing about Java syntax
    to learning about comments, variables, operators, and decision making.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们涵盖了很多内容。我们从不了解Java语法到学习注释、变量、运算符和决策过程。
- en: As with any language, mastery of Java can be achieved by simply practicing,
    learning, and increasing our vocabulary. At this point, the temptation might be
    to hold back until mastery of the current Java syntax has been achieved, but the
    best way is to move on to new syntax at the same time as revisiting what we have
    already begun to learn.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何语言一样，掌握Java可以通过简单的练习、学习和扩展词汇量来实现。此时，诱惑可能是要等到掌握当前Java语法后再继续，但最好的方法是同时学习新的语法，同时重新学习我们已经开始学习的内容。
- en: In the next chapter, we will finally finish our math game by adding random questions
    of multiple difficulties as well as using more appropriate and random wrong answers
    for the multiple choice buttons.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过添加多种难度的随机问题以及为多选按钮使用更合适和随机的错误答案，最终完成我们的数学游戏。
- en: To enable us to do this, we will first learn some more Java.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们能够做到这一点，我们将首先学习更多的Java。
- en: Methods
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: So what exactly are Java methods? A method is a collection of variables, expressions,
    and control flow statements. We have already been using lots of methods; we just
    haven't looked inside any yet.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 那么Java方法到底是什么？方法是一组变量、表达式和控制流语句。我们已经在使用很多方法；我们只是还没有深入研究过。
- en: Learning about Java methods will be the last topic for this chapter before we
    get practical and use what we have learned to enhance our math game.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 学习Java方法将是本章最后一个主题，在此之前我们将实际应用我们所学到的知识来增强我们的数学游戏。
- en: The structure of a method
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法的结构
- en: 'The first part of a method that we write is called the **signature**. Here
    is a made-up example of a signature:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的方法的第一部分称为**签名**。以下是一个虚构的签名示例：
- en: '[PRE68]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Add an opening and closing pair of curly braces with some code that the method
    performs, and we have a complete method, or a **definition**. Here is a made-up
    but syntactically correct method:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一对大括号并包含一些方法执行的代码，我们就有了一个完整的方法，或者**定义**。以下是一个虚构但语法正确的方法：
- en: '[PRE69]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We could then use our new method from another part of our code, like this:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在我们代码的另一个部分中使用我们的新方法，就像这样：
- en: '[PRE70]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: At the point where we call `setCoordinates`, our program's execution would branch
    to the code contained within that method, which would run until it reaches its
    end or is told to return. Then the code would continue running from the first
    line after the method call.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用`setCoordinates`的地方，我们程序的执行将分支到该方法中包含的代码，直到它达到结束或被告知返回为止。然后代码将从方法调用后的第一行继续运行。
- en: 'Here is another example of a method, complete with the code to make the method
    return to the code that called it:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是另一个方法的示例，包括使方法返回到调用它的代码的代码：
- en: '[PRE71]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The call to use the preceding method could look like this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的方法的调用可能如下所示：
- en: '[PRE72]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Clearly, we don't need to write methods to add two `int` variables together,
    but the preceding example helps us see a little more of the working of methods.
    First, we pass the values `2` and `4`. In the signature of the method, the value,
    `2`, is assigned to `int a` and the value, `4`, is assigned to `int b`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不需要编写方法来将两个`int`变量相加，但前面的示例帮助我们更多地了解了方法的工作原理。首先，我们传递值`2`和`4`。在方法的签名中，值`2`被赋给`int
    a`，值`4`被赋给`int b`。
- en: Within the method body, the `a` and `b` variables are added and used to initialize
    a new variable, which is the `int` answer. The `return answer` line does just
    that. It returns the value stored in `answer` to the calling code, causing `myAnswer`
    to be initialized with the value of `6`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法体内，`a`和`b`变量被相加并用于初始化一个新变量，即`int`答案。`return answer`行就是这样做的。它将存储在`answer`中的值返回给调用代码，导致`myAnswer`被初始化为`6`的值。
- en: Notice that each of the method signatures in the preceding examples varies a
    little. The reason for this is that the Java method signature is quite flexible,
    allowing us to build exactly the methods we require.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面示例中的每个方法签名都有所不同。其原因是Java方法签名非常灵活，允许我们精确构建我们需要的方法。
- en: Exactly how the method signature defines how the method must be called and how
    a method must return a value, if it must, deserves further discussion. Let's give
    each part of that signature a name so that we can break it into chunks and learn
    about the parts separately.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 方法签名如何定义方法必须如何调用以及方法必须返回值（如果必须返回值）的方式，值得进一步讨论。让我们给签名的每个部分命名，以便我们可以将其分成块并分别学习。
- en: Tip
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Here is a method signature with its parts labeled and ready for discussion.
    You can also take a look at the following table to further identify which part
    of the signature is which. This will make the rest of our discussion on methods
    straightforward.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个带有标签并准备讨论的方法签名。您还可以查看以下表格，进一步确定签名的哪个部分是哪个。这将使我们对方法的讨论变得简单明了。
- en: '**Modifier** | **return type** | **name of the method** (**parameters**)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**修饰符** | **返回类型** | **方法名称**（**参数**）'
- en: 'Here are a few examples that we have used so far so that you can clearly identify
    the part of the signature under discussion:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们迄今为止使用的一些示例，以便您可以清楚地确定正在讨论的签名的部分：
- en: '| Part of signature | Examples |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| 签名的一部分 | 示例 |'
- en: '| --- | --- |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Modifier | `public`, `private`, and so on |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| 修饰符 | `public`，`private`等 |'
- en: '| Return type | `int`, `boolean`, `float`, and so on, or any Java type, expression,
    or object |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 返回类型 | `int`，`boolean`，`float`等，或任何Java类型，表达式或对象 |'
- en: '| Name of the method | `shootLazers`, `setCoordinates`, `addAToB`, and so on
    |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| 方法名称 | `shootLazers`，`setCoordinates`，`addAToB`等 |'
- en: '| Parameters | (`int number`, `string type`), (`int x`, `int y`), (`int a`,
    `int b`), and so on |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | （`int number`，`string type`），（`int x`，`int y`），（`int a`，`int b`）等 |'
- en: Modifier
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修饰符
- en: 'In our previous examples, we only used a modifier twice, partly because the
    method doesn''t have to use the modifier. The modifier is a way of specifying
    which code can use your method. Some of the types of modifiers are `public` and
    `private`. Actually, regular variables can have modifiers too, such as these:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，我们只使用了修饰符两次，部分原因是方法不必使用修饰符。修饰符是指定哪些代码可以使用您的方法的一种方式。一些修饰符的类型是`public`和`private`。实际上，常规变量也可以有修饰符，例如：
- en: '[PRE73]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Modifiers (for methods and variables) are an essential Java topic but they are
    best dealt with when we discuss the other vital Java topic we have skirted around
    a few times so far—objects and classes.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符（用于方法和变量）是一个重要的Java主题，但最好在我们讨论其他重要的Java主题时处理，这些主题我们迄今为止已经绕了几次——对象和类。
- en: Note
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As previously promised, these mysterious objects will be revealed in [Chapter
    6](ch06.xhtml "Chapter 6. OOP – Using Other People's Hard Work"), *OOP – Using
    Other People's Hard Work*. However, as we can see from our example methods and
    from the fact that all the examples we have written so far work just fine, modifiers
    are not necessary to facilitate our learning so far.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前承诺的那样，这些神秘的对象将在[第6章](ch06.xhtml "第6章。OOP – 使用他人的辛勤工作")中揭示，*OOP – 使用他人的辛勤工作*。然而，正如我们从我们的示例方法和迄今为止我们编写的所有示例都可以正常工作的事实中看到的，修饰符并不是必要的，以便促进我们迄今为止的学习。
- en: Return type
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回类型
- en: 'Next up is the `return` type. Like a modifier, a `return` type is also optional,
    although it is more immediately useful to us. So let''s look a bit closer. We
    have seen that our methods can get anything done. But what if we need the result
    from what they have done? The simplest example of a return type we have seen so
    far was this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`return`类型。像修饰符一样，`return`类型也是可选的，尽管它对我们来说更有用。所以让我们仔细看一下。我们已经知道我们的方法可以完成任何事情。但是如果我们需要从它们所做的事情中得到结果呢？到目前为止，我们看到的最简单的返回类型示例是这样的：
- en: '[PRE74]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In this code, the `return` type in the signature is highlighted. So the `return`
    type is `int`. The `addAToB` method sends back (returns) to the code that called
    it a value that will fit in an `int` variable.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，签名中的`return`类型被突出显示。所以`return`类型是`int`。`addAToB`方法将一个值返回给调用它的代码，这个值将适合一个`int`变量。
- en: 'The `return` type can be any Java type we have seen so far. The method, however,
    does not have to return a value at all. In this case, the signature must use the
    `void` keyword as the `return` type. When the `void` keyword is used, the method
    body must not attempt to return a value as this will cause a compiler error. It
    can, however, use the `return` keyword without a value. Here are some combinations
    of return type and uses of the `return` keyword that are valid:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`类型可以是我们到目前为止见过的任何Java类型。然而，方法不一定要返回一个值。在这种情况下，签名必须使用`void`关键字作为`return`类型。当使用`void`关键字时，方法体不得尝试返回一个值，否则会导致编译器错误。但是，它可以使用没有值的`return`关键字。以下是一些有效的返回类型组合和`return`关键字的用法：'
- en: '[PRE75]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Another combination of `return` and `void` is as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`和`void`的另一种组合如下：'
- en: '[PRE76]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The following code is yet another combination of `return` and `void`:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`return`和`void`的另一种组合：
- en: '[PRE77]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We can call each of the preceding methods one by one, like this:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以依次调用前面的每个方法，就像这样：
- en: '[PRE78]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding code would execute all the code statements in each method one
    by one. If the method signature had parameters, the code that calls the method
    would look slightly different.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将依次执行每个方法中的所有代码语句。如果方法签名有参数，调用方法的代码会略有不同。
- en: Name of a method
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法的名称
- en: 'When we design our own methods, the method name is arbitrary, but there is
    a convention to use verbs that clearly explain what the method will do. Another
    convention is of the first letter of the first word in the name being lower case,
    and the first letter of each of the subsequent words being uppercase. This is
    called **camel case** because the shape the name can form has a hump in it:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计自己的方法时，方法名是任意的，但有一个约定是使用能清楚解释方法将要做什么的动词。另一个约定是名称中第一个单词的第一个字母小写，后续单词的第一个字母大写。这被称为**驼峰命名法**，因为名称的形状中有一个驼峰：
- en: '[PRE79]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This name is perfectly legitimate and will work. However, let''s take a look
    at a much clearer example that uses the conventions:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名称是完全合法的，并且可以工作。然而，让我们看一个更清晰的示例，使用约定：
- en: '[PRE80]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: These are much clearer method names.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法名更清晰。
- en: Now let's take a look at parameters.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下参数。
- en: Parameters
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: 'We know that a method can return a result to the calling code. What if we need
    to share some data values from the calling code with the method? Parameters allow
    us to share values with the method. We have already seen an example with parameters
    when looking at return types. We will look at the same example but a little more
    closely:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道方法可以将结果返回给调用代码。如果我们需要将一些数据值从调用代码与方法共享呢？参数允许我们与方法共享值。在查看返回类型时，我们已经看到了一个带有参数的示例。我们将仔细看一下相同的示例：
- en: '[PRE81]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The parameters in this code are highlighted. Notice that in the first line
    of the method body, we use `a + b` as if they are already declared and initialized.
    Well, that''s because they are. The parameters of the method signature is their
    declaration, and the code that calls the method initializes them:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中的参数被突出显示。请注意，在方法体的第一行中，我们使用`a + b`，好像它们已经声明并初始化了。那是因为它们确实是。方法签名的参数就是它们的声明，调用方法的代码初始化它们：
- en: '[PRE82]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Also, as we have partly seen in previous examples, we don''t have to use `int`
    in our parameters. We can use any Java type, including types we design ourselves.
    We can mix and match types as well. We can also use as many parameters as necessary
    to solve our problem. An example of mixed Java types might help:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如我们在之前的示例中部分看到的那样，我们不必在参数中使用`int`。我们可以使用任何Java类型，包括我们自己设计的类型。我们也可以混合和匹配类型。我们还可以使用尽可能多的参数来解决我们的问题。混合Java类型的示例可能会有所帮助：
- en: '[PRE83]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: It's now time to get serious about our body.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候认真对待我们的方法体了。
- en: Getting things done in the method body
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在方法体中完成任务
- en: 'The body is the part we have been avoiding so far with comments like this:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在避免的部分是方法体，有这样的注释：
- en: '[PRE84]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: But actually, we know exactly what to do here already. Any Java syntax we have
    learned so far will work in the body of a method. In fact, if we look back, all
    of the code we have written so far has been in a method, albeit somebody else's
    method. For example, we wrote code in the `onCreate` and `onClick` methods.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，我们已经完全知道在这里该做什么。到目前为止，我们学到的任何Java语法都可以在方法体中使用。事实上，如果我们回顾一下，到目前为止我们写的所有代码都是在一个方法中，尽管是别人的方法。例如，我们在`onCreate`和`onClick`方法中编写了代码。
- en: The best thing we can do next is write some methods that actually do something
    in the body.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来最好做的事情是在方法体中写一些真正有用的方法。
- en: Using methods
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用方法
- en: We don't have to mess around with our math game project. We will quickly create
    a new blank project for each of the next two explorations into methods.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必在我们的数学游戏项目中瞎搞。我们将快速为接下来的两个探索方法创建一个新的空白项目。
- en: We also don't need to spend time making a UI. We will use the Android console
    to view the results and discuss the implications of our examples of methods. As
    we are using the Android console to view the results of our work with methods,
    we will need to run all of these examples on the Android emulator, not on a real
    device.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不需要花时间制作UI。我们将使用Android控制台查看结果，并讨论我们的方法示例的影响。由于我们正在使用Android控制台查看我们使用方法的工作结果，我们需要在Android模拟器上运行所有这些示例，而不是在真实设备上。
- en: Note
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible to set up a real device to output to the console, but we have
    not covered that in this book. If you want to find out more about using your actual
    device for debugging, take a look at the article at [http://developer.android.com/tools/device.html](http://developer.android.com/tools/device.html).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置真实设备输出到控制台，但我们在本书中没有涵盖这一点。如果您想了解更多关于使用实际设备进行调试的信息，请查看[http://developer.android.com/tools/device.html](http://developer.android.com/tools/device.html)上的文章。
- en: As usual, you can open the already typed code files in the usual way. The next
    two examples on methods can be found in the Packt Publishing code download in
    the `Chapter4` folder and the `AWorkingMethod` and `ExploringMethodOverloading`
    subfolders.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您可以以通常的方式打开已输入的代码文件。关于方法的下两个示例可以在`Chapter4`文件夹和`AWorkingMethod`和`ExploringMethodOverloading`子文件夹中的Packt
    Publishing代码下载中找到。
- en: Tip
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The following is a quick reminder on how to create a new blank project.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何创建一个新的空白项目的快速提醒。
- en: Close any currently open projects by navigating to **File** | **Close Project**.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**File** | **Close Project**关闭当前打开的任何项目。
- en: Click on **New Project...**.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**New Project...**。
- en: The **Create New Project** configuration window will appear. Fill in the **Application
    name** field and **Company Domain** with `packtpub.com`, or you could use your
    own company website's name here instead.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出现**Create New Project**配置窗口。在**Application name**字段和**Company Domain**中填写`packtpub.com`，或者您可以在此处使用您自己公司的网站名称。
- en: 'Now click on the **Next** button. On the next screen, ensure that the **Phone
    and tablet** checkbox has a tick in it. Now we have to choose the earliest version
    of Android we want to build our app for. Go ahead and play with a few options
    in the drop-down selector. You will see that the earlier the version we select,
    the greater the percentage of devices our app can support. However, the trade-off
    here is that the earlier the version we select, the fewer cutting-edge Android
    features we can have in our apps. A good balance is to select **API 8: Android
    2.2 (Froyo)**. Go ahead and do that now as shown in the next screenshot.'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在点击**Next**按钮。在下一个屏幕上，确保**Phone and tablet**复选框中有一个勾。现在我们必须选择我们想要为其构建应用程序的最早版本的Android。随意在下拉选择器中尝试几个选项。您会发现，我们选择的版本越早，我们的应用程序支持的设备百分比就越大。然而，这里的权衡是，我们选择的版本越早，我们的应用程序中可以拥有的最新Android功能就越少。一个很好的平衡是选择**API
    8: Android 2.2 (Froyo)**。按照下一个截图中所示进行操作。'
- en: Click on **Next**. Now select **Blank Activity** and click on **Next** again.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Next**。现在选择**Blank Activity**，然后再次点击**Next**。
- en: On the next screen, simply change **Activity Name** to `MainActivity` and click
    on **Finish**.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，只需将**Activity Name**更改为`MainActivity`，然后点击**Finish**。
- en: As we did in [Chapter 2](ch02.xhtml "Chapter 2. Getting Started with Android"),
    *Getting Started with Android*, to keep our code clear and simple, you can delete
    the two unneeded methods (`onCreateOptionsMenu` and `onOptionsItemSelected`) and
    their associated `@override` and `@import` statements, but this is not necessary
    for the example to work.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与我们在[第2章](ch02.xhtml "第2章。开始使用Android")中所做的一样，为了保持我们的代码清晰简单，您可以删除两个不需要的方法（`onCreateOptionsMenu`和`onOptionsItemSelected`）及其相关的`@override`和`@import`语句，但这对示例的工作并不是必需的。
- en: For a detailed explanation and images of creating a new project, see [Chapter
    2](ch02.xhtml "Chapter 2. Getting Started with Android"), *Getting Started with
    Android*.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 有关创建新项目的详细说明和图像，请参见[第2章](ch02.xhtml "第2章。开始使用Android")，*开始使用Android*。
- en: A working method
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个工作方法
- en: First, let's make ourselves a simple working method, complete with return types
    and a fully functioning body.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个简单的工作方法，包括返回类型和完全功能的主体。
- en: 'This method will take three numbers as parameters and return a `true` or `false`
    value to the calling code depending upon whether one of the three numbers was
    randomly generated within the method or not:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将接受三个数字作为参数，并根据这三个数字中是否有一个是在方法中随机生成的，返回一个`true`或`false`值给调用代码：
- en: Create a new blank project called `A Working Method`.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`A Working Method`的新空白项目。
- en: 'In this method, we will use the `Random` class we saw earlier and its `randInt`
    method as a part of the demonstration. Copy the code for this method after the
    closing bracket of `onCreate` but before the closing bracket of `MainActivity`.
    When you are prompted to import any classes, simply click on **OK**:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在这个方法中，我们将使用我们之前看到的`Random`类及其`randInt`方法作为演示的一部分。将此方法的代码复制到`onCreate`的结束括号之后，但在`MainActivity`的结束括号之前。当提示导入任何类时，只需点击**OK**： '
- en: '[PRE85]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now we declare a Boolean variable called `found` and initialize it to `false`.
    We will change `found` to `true` if and when we guess the random number correctly.
    Next, we declare our random number and print some useful values to the console:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们声明一个名为`found`的布尔变量，并将其初始化为`false`。如果我们猜对了随机数，我们将把`found`更改为`true`。接下来，我们声明我们的随机数，并将一些有用的值打印到控制台：
- en: '[PRE86]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The last portion of code in our method tests to see whether there is a match
    for any of our passed-in parameters, prints some output, and then returns `true`
    or `false` using the `found` variable to the calling code in the `onCreate` method:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们方法中的最后一部分代码测试是否有任何匹配我们传入参数的内容，打印一些输出，然后使用`found`变量将`true`或`false`返回给`onCreate`方法中的调用代码：
- en: '[PRE87]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now write this code just before the closing bracket of the `onCreate` method
    to call the code and print some values to the Android console:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在`onCreate`方法的结束括号之前编写以下代码，以调用代码并将一些值打印到Android控制台：
- en: '[PRE88]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Launch an emulator.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动模拟器。
- en: Run the app on the emulator.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上运行应用程序。
- en: All our console messages have a tag called **info**. The console window will
    already have appeared underneath the editor window. We can filter its contents
    to only show our messages by typing `info` in the search box, as shown in the
    following screenshot:![A working method](img/8859OS_04_02.jpg)
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们所有的控制台消息都有一个名为**info**的标签。控制台窗口已经出现在编辑窗口下方。我们可以通过在搜索框中输入`info`来过滤其内容，只显示我们的消息，如下面的截图所示：![A
    working method](img/8859OS_04_02.jpg)
- en: In the preceding screenshot, you can see the search filter and the console output.
    We will now run through the code and explain the output.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，您可以看到搜索过滤器和控制台输出。我们现在将运行代码并解释输出。
- en: 'For clarity, here is the precise console output, without the extraneous date,
    time, and package name added to the beginning of each line. Remember that we are
    dealing with a random number, so your output may vary:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，这是精确的控制台输出，没有在每行开头添加多余的日期、时间和包名。请记住，我们正在处理一个随机数，因此您的输出可能会有所不同：
- en: '[PRE89]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Here is what is happening. In step 2, we started writing our first method.
    We called it `guessANumber`. It has three `int` parameters and will return a Boolean.
    Remember that these three `int` parameters become fully initialized variables.
    First of all, however, in our method, we simply output the values of the new variables
    passed in as parameters as well as a message confirming that the code in our method
    is currently being executed:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么。在第2步中，我们开始编写我们的第一个方法。我们称它为`guessANumber`。它有三个`int`参数，并将返回一个布尔值。请记住，这三个`int`参数将成为完全初始化的变量。然而，首先在我们的方法中，我们只是输出传入参数的新变量的值，以及一个确认我们的方法中的代码当前正在执行的消息：
- en: '[PRE90]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In step 3, we added more code to our method. We declared and initialized a
    Boolean variable called `found`, which we will use to return a value to the calling
    code and let the calling code know whether one of the parameters passed in was
    the same as the random number:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，我们向我们的方法添加了更多代码。我们声明并初始化了一个名为`found`的布尔变量，我们将使用它来返回一个值给调用代码，并让调用代码知道传入的参数中是否有一个与随机数相同：
- en: '[PRE91]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Next (still in step 3), we generated a random number in the same way as we
    did earlier in the chapter. We also used `Log` to output the random number so
    that we can examine what went on:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来（仍然是第3步），我们以与本章前面相同的方式生成了一个随机数。我们还使用`Log`输出随机数，以便我们可以检查发生了什么：
- en: '[PRE92]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'In step 4, we used an `if` statement with the logical OR operator to detect
    whether any of the passed-in parameters matches the random number we just generated,
    as shown in the following code:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们使用了一个带有逻辑或运算符的`if`语句来检测传入的参数中是否有任何一个与我们刚生成的随机数匹配，如下面的代码所示：
- en: '[PRE93]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'If the condition is true, that is, if any of `try1`, `try2`, or `try3` equals
    `randNum`, then the following code is run. Our `found` Boolean value is set to
    `true` and a message is printed:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件成立，也就是说，如果`try1`、`try2`或`try3`中的任何一个等于`randNum`，则运行以下代码。我们的`found`布尔值设置为`true`，并打印一条消息：
- en: '[PRE94]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'If the condition is not true, the `else` statement is executed, a different
    message is printed, and the `found` variable is left the same as it was—`false`:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件不成立，将执行`else`语句，打印不同的消息，并且`found`变量保持不变，仍为`false`：
- en: '[PRE95]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Finally, in our method, we return the `found` variable, which will be either
    `true` or `false`, to the calling code:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的方法中，我们返回`found`变量，它将是`true`或`false`，返回给调用代码：
- en: '[PRE96]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now we look at step 5, which is the code in the `onCreate` method, which calls
    our `guessANumber` method in the first place. We start by simply printing a message
    saying that we are in `onCreate` at the moment:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看第5步，即`onCreate`方法中调用我们的`guessANumber`方法的代码。我们首先简单地打印一条消息，说明我们目前正在`onCreate`中：
- en: '[PRE97]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Then we make the call to `guessANumber` with the three parameters. In this
    case, we use 1, 2, and 3, but any `int` values would have worked. However, we
    wrap the call in an `if` statement. This means that the `return` value from the
    method will be used to evaluate the `if` statement. Simply put, if `true` is returned,
    the `if` statement will be executed and "**Found It**!" will be printed:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用`guessANumber`并传入三个参数。在这种情况下，我们使用了1、2和3，但任何`int`值都可以工作。但是，我们将调用包装在一个`if`语句中。这意味着方法的`return`值将用于评估`if`语句。简而言之，如果返回`true`，则将执行`if`语句，并打印“**Found
    It**”：
- en: '[PRE98]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'On the contrary, if `false` is returned, the `else` statement gets executed
    and "**Can''t find it**" is printed:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果返回`false`，则执行`else`语句，并打印“**Can't find it**”：
- en: '[PRE99]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Remember that we are dealing with random numbers, so you might need to run
    it a few times before you see this output:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们正在处理随机数，因此您可能需要运行几次才能看到这个输出：
- en: '![A working method](img/8859OS_04_03.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![A working method](img/8859OS_04_03.jpg)'
- en: Of course, you should note that the guesses sent to the function as parameters
    are arbitrary. As long as all the numbers are between 0 and 5 and are not duplicated,
    they will together have a 50 percent chance of finding the random number.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您应该注意，作为参数发送到函数的猜测是任意的。只要所有数字都在0到5之间，且不重复，它们一起有50%的几率找到随机数。
- en: On a closing note, if you've to read only one tip in this whole book, it should
    be this one.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您只想读这本书中的一个提示，那就是这个。
- en: Tip
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Printing variable values to the console is a great way to examine what is going
    on inside your game and to find bugs.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量值打印到控制台是检查游戏内部发生了什么以及查找错误的好方法。
- en: Let's look at another example of methods.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个方法的另一个例子。
- en: Exploring method overloading
  id: totrans-461
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索方法重载
- en: As we are learning, methods are really diverse and deep as a topic, but hopefully,
    taking a step at a time, we will see they are not daunting in any way. We will
    be using what we have learned about methods when we enhance our math game. We
    will be exploring methods even more deeply in [Chapter 6](ch06.xhtml "Chapter 6. OOP
    – Using Other People's Hard Work"), *OOP – Using Other People's Hard Work*. For
    now, however, it will serve us well to look at one more topic on methods. Let's
    create a new project to explore **method** **overloading**.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学到的，方法作为一个主题确实是多样且深刻的，但希望一步一步地，我们会发现它们并不令人畏惧。当我们增强我们的数学游戏时，我们将使用我们对方法的了解。在[第6章](ch06.xhtml
    "第6章。OOP – 使用他人的辛勤工作")*OOP – 使用他人的辛勤工作*中，我们将更深入地探索方法。然而，现在，我们将看一看关于方法的另一个主题。让我们创建一个新项目来探索**方法重载**。
- en: 'As we will now see, we can create more than one method with the same name,
    provided the parameters are different. The code in this project is vastly simpler
    than that of the last project. It is how this code works that might appear slightly
    curious until we analyze it later:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将要看到的，我们可以创建多个具有相同名称的方法，只要参数不同。这个项目中的代码比上一个项目简单得多。直到我们稍后分析它的工作原理，这段代码可能看起来有点奇怪：
- en: Create a new blank project called `Exploring Method Overloading`.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为“探索方法重载”的新空项目。
- en: 'In the first method, we will simply call it `printStuff` and pass an `int`
    variable via a parameter to be printed. Copy the code for this method after the
    closing bracket of `onCreate` but before the closing bracket of `MainActivity`.
    When you are prompted to import any classes, simply click on **OK**:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个方法中，我们将简单地调用它`printStuff`并通过参数传递一个`int`变量进行打印。将此方法的代码复制到`onCreate`的结束括号之后，但在`MainActivity`的结束括号之前。当提示导入任何类时，只需点击**确定**：
- en: '[PRE100]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We will also call the second method `printStuff` but pass a `string` variable
    to be printed. Copy the code for this method after the closing bracket of `onCreate`
    but before the closing bracket of `MainActivity`. Again, when you are prompted
    to import any classes, simply click on **OK**:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将调用第二个方法`printStuff`，但传递一个要打印的`string`变量。将此方法的代码复制到`onCreate`的结束括号之后，但在`MainActivity`的结束括号之前。同样，当提示导入任何类时，只需点击**确定**：
- en: '[PRE101]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Yet again, we will call this third method `printStuff` but pass a `string`
    variable and an `int` variable to be printed. As before, copy the code for this
    method after the closing bracket of `onCreate` but before the closing bracket
    of `MainActivity`:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再一次，我们将调用这第三个方法`printStuff`，但传递一个要打印的`string`变量和一个`int`变量。与之前一样，将此方法的代码复制到`onCreate`的结束括号之后，但在`MainActivity`的结束括号之前：
- en: '[PRE102]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now write this code just before the closing bracket of the `onCreate` method
    to call the methods and print some values to the Android console:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`onCreate`方法的结束括号之前编写这段代码，以调用方法并将一些值打印到Android控制台：
- en: '[PRE103]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Launch an emulator.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动模拟器。
- en: Run the app on the emulator.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上运行应用程序。
- en: 'Here is the console output:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是控制台输出：
- en: '[PRE104]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: As you can see, Java has treated three methods with the same name as totally
    different methods. This, as we have just demonstrated, can be really useful. It
    is called **method overloading**.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Java已经将具有相同名称的三个方法视为完全不同的方法。正如我们刚刚演示的那样，这可能非常有用。这被称为**方法重载**。
- en: Tip
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Method overloading and overriding confusion**'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法重载和覆盖的混淆**'
- en: 'Overloading and overriding are defined as follows:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 重载和覆盖的定义如下：
- en: Overloading occurs when we have more than one method with the same name but
    different parameters
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载发生在我们有多个具有相同名称但不同参数的方法时
- en: Overriding occurs when we essentially replace a method with the same name and
    the same parameter list
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖发生在我们实质上用相同名称和相同参数列表替换方法时
- en: We know enough about overloading and overriding to complete this book, but if
    you are brave and your mind is wandering, you can override an overloaded method.
    However, that is something for another time.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对重载和覆盖的了解已经足够完成本书，但如果你勇敢而且心神游荡，你可以覆盖重载的方法。然而，这是另一个时间的事情。
- en: 'This is how the preceding code works. In each of the three steps (2, 3, and
    4), we create a method called `printStuff`, but each `printStuff` method has different
    parameters, so each is a different method that can be called individually:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是前面的代码是如何工作的。在三个步骤（2、3和4）中，我们分别创建了一个名为`printStuff`的方法，但每个`printStuff`方法都有不同的参数，因此每个方法都是可以单独调用的不同方法：
- en: '[PRE105]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The body of each of the methods is simple. It just prints the passed-in parameters
    and confirms which version of the method is being called currently.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法的主体都很简单。它只是打印传入的参数，并确认当前调用的方法版本。
- en: 'The next important part of our code is when we make it plain which method we
    want to call, using the appropriate parameters. In step 5, we call each of them
    in turn, using the appropriate parameters so that Java knows the exact method
    required:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码的下一个重要部分是当我们明确指出要调用哪个方法时，使用适当的参数。在第5步中，我们依次调用它们，使用适当的参数，以便Java知道所需的确切方法：
- en: '[PRE106]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Now we know more than enough about methods, loops, and random numbers to make
    some improvements to our math game.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对方法、循环和随机数的了解已经足够多，可以对我们的数学游戏进行一些改进了。
- en: Enhancing our math game
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强我们的数学游戏
- en: We are going to add some features to our math game using what we have just learned
    about methods and loops.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们刚刚学到的关于方法和循环的知识，为我们的数学游戏添加一些功能。
- en: As usual, the code is available for copying in the `Chapter4` folder of the
    code download. The project is in the `MathGameChapter4` subfolder and encompasses
    all the remaining phases of improvement covered in this chapter, including enhancing
    the UI, amending our game activity, `setQuestion`, `updateScoreAndLevel`, `isCorrect`,
    and calling our new methods.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，代码可以在代码下载的`Chapter4`文件夹中找到。该项目位于`MathGameChapter4`子文件夹中，包括本章中涵盖的所有改进阶段，包括增强UI、修改游戏活动、`setQuestion`、`updateScoreAndLevel`、`isCorrect`和调用我们的新方法。
- en: We will make the game change the question after each time we attempt the answer.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使游戏在每次尝试答案后更改问题。
- en: We will also add difficulty levels to questions and random questions but within
    a range appropriate for that difficulty level.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为问题添加难度级别和随机问题，但在适当难度级别范围内。
- en: We will show and update our score. The score goes up faster depending on the
    difficulty level of the question answered correctly.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将显示和更新我们的分数。正确回答问题的难度级别越高，分数上升得越快。
- en: If the player gets a question wrong, the difficulty goes back to the easiest
    level and the score to zero.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家答错问题，难度将回到最简单的级别，分数将变为零。
- en: Enhancing the UI
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强UI
- en: Let's get on with modifying our math game UI to incorporate our new game features.
    We will be adding a TextView to display the score and another TextView to display
    the level.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续修改我们的数学游戏UI，以整合我们的新游戏功能。我们将添加一个TextView来显示分数，另一个TextView来显示级别。
- en: Open the `activity_game.xml` file in the editor window. We will add a new TextView
    to the very bottom of our UI for our score.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑窗口中打开`activity_game.xml`文件。我们将在UI的底部添加一个新的TextView来显示我们的分数。
- en: Drag a **Large Text** element from **Palette** and place it to the left, below
    our three answer buttons.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Palette**中拖动一个**Large Text**元素，并将其放置在左侧，放置在我们的三个答案按钮下方。
- en: Now we need to change the **id** property so that we can access our new TextView
    from our Java code. Ensure that the new TextView is selected by clicking on it.
    Now, in the **Properties** window, change the **id** property to `textScore`.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要更改**id**属性，以便我们可以从Java代码中访问我们的新TextView。确保通过单击它来选择新的TextView。现在，在**Properties**窗口中，将**id**属性更改为`textScore`。
- en: For the sake of clarity (although this step serves no use in programming), change
    the **text** property to `Score:999`.
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了清晰起见（尽管这一步在编程中没有用处），将**text**属性更改为`Score:999`。
- en: Now put another **Large Text** element to the right of the one we just configured
    and change the **id** property to `textLevel`. The lower part of our UI should
    now look like this:![Enhancing the UI](img/8859OS_04_10.jpg)
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将另一个**Large Text**元素放置在我们刚刚配置的元素的右侧，并将**id**属性更改为`textLevel`。我们的UI的下半部分现在应该是这样的：![Enhancing
    the UI](img/8859OS_04_10.jpg)
- en: Once again, for the sake of clarity (although this step serves no use in programming),
    change the **text** property to `Level:4`.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次为了清晰起见（尽管这一步在编程中没有用处），将**text**属性更改为`Level:4`。
- en: Save the project.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存项目。
- en: We have just added two new TextView elements and assigned them both an ID that
    we can refer to in our Java code.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加了两个新的TextView元素，并为它们分配了一个我们可以在Java代码中引用的ID。
- en: Tip
  id: totrans-507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You have probably realized by now that the precise layout and size of our UI
    elements are unimportant as far as getting the game to work is concerned. This
    gives us a lot of flexibility in designing layouts for different screen sizes.
    As long as each layout for each screen size contains the same element types with
    the same IDs, the same Java code will work for different layouts. If you want
    to know more about designing for multiple screen sizes, take a look at [http://developer.android.com/training/multiscreen/screensizes.html](http://developer.android.com/training/multiscreen/screensizes.html).
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到，就让游戏运行而言，我们的UI元素的精确布局和大小并不重要。这为我们在设计不同屏幕尺寸的布局时提供了很大的灵活性。只要每个屏幕尺寸的布局包含相同的元素类型和相同的ID，相同的Java代码就可以用于不同的布局。如果你想了解更多关于为多个屏幕尺寸设计的信息，请查看[http://developer.android.com/training/multiscreen/screensizes.html](http://developer.android.com/training/multiscreen/screensizes.html)。
- en: Now that we have our enhanced UI and an understanding of how the Java `Random`
    class works, we can add the Java code to implement our new features.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了增强的UI和对Java的`Random`类如何工作的理解，我们可以添加Java代码来实现我们的新功能。
- en: The new Java code
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的Java代码
- en: As previously explained, the project code is available in the `Chapter4` folder
    of the downloadable code. The project is called `MathGameChapter4` and encompasses
    all the improvements covered in this chapter.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，项目代码可在可下载代码的`Chapter4`文件夹中找到。该项目称为`MathGameChapter4`，包含了本章涵盖的所有改进。
- en: In this phase, we will be adding lots of new code, moving some existing code,
    and modifying some existing code too. As so much is changing, we are going to
    approach the code from the very beginning. The new code will be explained completely,
    the code that has moved will be pointed out with a reason, and the code that has
    stayed the same and in the same place will have the least explanation.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们将添加大量新代码，移动一些现有代码，并修改一些现有代码。由于变化如此之大，我们将从头开始处理代码。新代码将被完全解释，移动的代码将被指出原因，保持不变且位置不变的代码将有最少的解释。
- en: We will first make some modifications and deletions to our existing code. We
    will then look at designing and implementing each of our new methods to improve
    our code and add our new features.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先对我们现有的代码进行一些修改和删除。然后，我们将着手设计和实现每个新方法，以改进我们的代码并添加新功能。
- en: Amending GameActivity
  id: totrans-514
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改GameActivity
- en: 'First, let''s perform the necessary amendments and deletions to our current
    code:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们对我们当前的代码进行必要的修改和删除：
- en: Open the `GameActivity.java` file in the editor window.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑窗口中打开`GameActivity.java`文件。
- en: 'We now need to consider the scope of the objects that represent our UI elements.
    Both `textObjectPartA` and `textObjectPartB` need to be accessible from the methods
    we will be creating soon. So let''s move their declarations, as we did with the
    multi-choice buttons in the previous chapter, out of the `onCreate` method so
    that they are accessible everywhere in our `GameActivity` class. The following
    code shows all our declarations so far. They are present immediately after the
    start of the `GameActivity` class. The recently added (or moved) declarations
    are highlighted. Notice that we have also added declarations for our two new TextViews
    and for the score and level displays. In addition, there are two new `int` variables
    that we can manipulate for our score and to keep track of our level. They are
    `currentScore` and `currentLevel`:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要考虑代表我们UI元素的对象的范围。`textObjectPartA`和`textObjectPartB`都需要从我们即将创建的方法中访问。因此，让我们像在上一章中对多选按钮所做的那样，将它们的声明移到`onCreate`方法之外，以便它们在`GameActivity`类的任何地方都可以访问。以下代码显示了到目前为止所有我们的声明。它们出现在`GameActivity`类开始之后。最近添加（或移动）的声明已经被突出显示。请注意，我们还为我们的两个新文本视图和分数和等级显示添加了声明。此外，还有两个新的`int`变量，我们可以用来操作我们的分数和跟踪我们的等级。它们是`currentScore`和`currentLevel`：
- en: '[PRE107]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'All of the code that assigns text to our Buttons or TextViews objects, and
    the code that initializes the parts of our question and assigns the values for
    our wrong answers, are now going to change and move, so we need to delete it all.
    Everything shown in the following code is to be deleted:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的按钮或文本视图对象分配文本的所有代码，以及初始化问题部分并为错误答案分配值的代码，现在都要更改和移动，所以我们需要全部删除。以下代码中显示的所有内容都将被删除：
- en: '[PRE108]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The following code snippet needs to be deleted too:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段也需要被删除：
- en: '[PRE109]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'For clarity and context, here is the entire `onCreate` method as it currently
    stands. There is nothing new here, but you can see your code, which links our
    Button and TextView objects that we declared in step 2\. Again, this code includes
    our two new TextViews, which are highlighted, but everything else, which is described
    in steps 3 and 4, is deleted. As before, there is a piece of code that makes our
    game listen to button clicks:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了清晰和上下文，以下是整个`onCreate`方法的当前状态。这里没有新内容，但你可以看到我们在第2步中声明的按钮和文本视图对象的代码。再次强调，这段代码包括我们的两个新文本视图，但其他所有内容，即第3步和第4步中描述的内容，都已被删除。与以前一样，有一段代码使我们的游戏监听按钮点击：
- en: '[PRE110]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Now we will delete some more code that we don''t need because we are going
    to make it more efficient by compartmentalizing it into our new methods and adding
    our new features at the same time. So in our `onClick` method, in each case of
    our `switch` statement, we want to delete the `if` and the `else` statements.
    We will be completely rewriting these, but we will leave in place the code that
    initializes our `answerGiven` variable. Our `onClick` method will now look like
    this:'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将删除一些不需要的代码，因为我们将通过将其分隔到我们的新方法中并同时添加新功能来使其更有效。因此，在我们的`onClick`方法中，在`switch`语句的每种情况下，我们要删除`if`和`else`语句。我们将完全重写这些内容，但我们将保留初始化`answerGiven`变量的代码。我们的`onClick`方法现在将如下所示：
- en: '[PRE111]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Save your project.
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的项目。
- en: Wow! That was a lot of code, but as we saw along the way, there were no new
    concepts. In step 2, we simply moved the initialization of our Button and TextView
    objects to a place where they will now be visible from anywhere within our class.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！那是很多代码，但正如我们一路看到的那样，没有新概念。在第2步中，我们只是将按钮和文本视图对象的初始化移到了一个现在可以从我们的类中的任何地方看到的地方。
- en: In steps 3 and 4, we did a fair bit of deletion because we will no longer be
    making the question or populating the multi-choice buttons in `onCreate`, as this
    is not flexible enough. We will soon see how we improve on this.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步和第4步中，我们进行了相当多的删除，因为我们将不再在`onCreate`中提出问题或填充多选按钮，因为这样做不够灵活。我们很快就会看到我们如何改进这一点。
- en: In step 6, we deleted the code that tested whether the answer was correct or
    incorrect. However, as we saw, we still initialized the `answerGiven` variable
    in the same way—in the appropriate case of our `switch` statement in the `onClick`
    method.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步中，我们删除了测试答案是否正确或不正确的代码。然而，正如我们所看到的，我们仍然以相同的方式初始化了`answerGiven`变量——在`onClick`方法的`switch`语句的适当情况下。
- en: Great! Now we are ready to consider and design some new methods to compartmentalize
    our code, avoid repetitions in it, and add our extra features. Consider the following
    methods that we will soon implement.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们准备考虑并设计一些新方法，将我们的代码分隔开，避免重复，并添加我们的额外功能。考虑一下我们很快将实现的以下方法。
- en: The methods
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法
- en: 'We will now walk through writing some methods. As we will see, the methods
    will compartmentalize our code and prevent the implementation of our new features
    from causing the code to become too long and sprawling:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将逐步编写一些方法。正如我们将看到的那样，这些方法将把我们的代码分隔开，并防止我们的新功能的实现导致代码变得过长和杂乱：
- en: We will write a `setQuestion` method to prepare a question of appropriate difficulty.
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将编写一个`setQuestion`方法来准备一个适当难度的问题。
- en: We will write an `updateScoreAndLevel` method that will do just that. We will
    also write an `isCorrect` method that one of our other methods will use to evaluate
    the correctness of the answer.
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将编写一个`updateScoreAndLevel`方法来实现这一点。我们还将编写一个`isCorrect`方法，我们的其他方法将使用它来评估答案的正确性。
- en: Then we will strategically place the code that calls our new methods.
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们将策略性地放置调用我们新方法的代码。
- en: We will do each of these tasks one at a time and explain the code along the
    way, as leaving the explanation to the end will make referring to individual steps
    cumbersome.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个执行这些任务，并在此过程中解释代码，因为将解释留到最后会使参考各个步骤变得麻烦。
- en: 'We will use many of the features of Java that we learned in this chapter and
    the previous chapter. These include the following:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用本章和上一章学到的许多Java特性。这些包括以下内容：
- en: Methods
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法
- en: A `for` loop
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`for`循环
- en: The switch control structure
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开关控制结构
- en: So let's get started with our first method.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们开始我们的第一个方法。
- en: The setQuestion method
  id: totrans-543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: setQuestion方法
- en: We determined that we needed a method to prepare a question for us; `setQuestion`
    seems like a decent name for such a method. Every time our player gives an answer
    by tapping one of the three multi-choice buttons, a new question will need to
    be prepared.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确定我们需要一个方法来为我们准备一个问题；`setQuestion`似乎是这样一个方法的不错名称。每当我们的玩家通过点击三个多选按钮之一给出答案时，都需要准备一个新的问题。
- en: This method will need to generate values for our `partA` and `partB` variables
    as well as show them in our TextViews referenced by the `textObjectPartA` and
    `textObjectPartB` objects. In addition, the method will need to assign the new
    correct answer to our `correctAnswer` variable, which will then be used to calculate
    some suitable incorrect answers. Finally, the method will show both the correct
    and incorrect answers on our multi-choice buttons.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将需要为我们的`partA`和`partB`变量生成值，并在由`textObjectPartA`和`textObjectPartB`对象引用的TextViews中显示它们。此外，该方法将需要将新的正确答案分配给我们的`correctAnswer`变量，然后用它来计算一些合适的错误答案。最后，该方法将在我们的多选按钮上显示正确和错误答案。
- en: 'Furthermore, our `setQuestion` method will need to take into account the level
    held in `currentLevel` to determine the range or difficulty of the question it
    will ask. Let''s go through the code. If you want to type this code as we go,
    then just make sure you place it after the closing bracket of `onClick` but before
    the closing bracket of our `GameActivity` class:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的`setQuestion`方法将需要考虑`currentLevel`中保存的级别，以确定它将提出的问题的范围或难度。让我们来看看代码。如果你想一边跟着我们打这段代码，那么请确保你把它放在`onClick`的闭合括号之后，但在我们的`GameActivity`类的闭合括号之前：
- en: 'First of all, we have the method signature and the opening curly brace before
    the body of our method:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们有方法签名和方法体之前的左花括号：
- en: '[PRE112]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'This tells us that the return type is `void`, so `setQuestion` will not return
    a value to the code that calls it. Also, there are no parameters here, so it does
    not need any value passed for it to work. Let''s see what it does. Now we enter
    the code to generate the two parts of the question:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这告诉我们返回类型是`void`，所以`setQuestion`不会向调用它的代码返回值。此外，这里没有参数，所以它不需要任何值来工作。让我们看看它做了什么。现在我们输入代码来生成问题的两个部分：
- en: '[PRE113]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'In the previous step, we declared a new `int` variable, `numberRange`, and
    initialized it by multiplying the player''s `currentLevel` value by `3`. Then
    we got a new `Random` object called `randInt` and used it to generate new values
    based on `numberRange`. We did this to the `partA` and `partB` variables. As the
    value of `currentLevel` increases, so potentially does the difficulty of the question.
    Now, just as we have written in the past, we write this:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步中，我们声明了一个新的`int`变量`numberRange`，并通过将玩家的`currentLevel`值乘以`3`来初始化它。然后我们得到了一个名为`randInt`的新的`Random`对象，并用它来生成基于`numberRange`的新值。我们对`partA`和`partB`变量做了这个。随着`currentLevel`的值的增加，问题的难度也可能增加。现在，就像我们过去写的那样，我们写了这个：
- en: '[PRE114]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'We assigned the answer of our new multiplication question to `correctAnswer`.
    Then we declared and assigned two incorrect answers to the new `int` variables,
    `wrongAnswer1` and `wrongAnswer2`. We also used the `setText` method of our TextView
    objects to display the question to the player. Notice that we have not yet displayed
    the correct and incorrect answers. Here it is. Try to work out what is happening
    here:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将我们新的乘法问题的答案赋给`correctAnswer`。然后我们声明并赋值了两个错误答案给新的`int`变量`wrongAnswer1`和`wrongAnswer2`。我们还使用了我们的TextView对象的`setText`方法来向玩家显示问题。注意我们还没有显示正确和错误答案。这就是它。试着弄清楚这里发生了什么：
- en: '[PRE115]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'In the preceding code, we used our `Rando`m object, `randInt`, to generate
    a number between 0 and 2, and assigned the value to a new `int` variable called
    `buttonLayou`t. We then used `buttonLayou`t to switch between all its possible
    values: 0, 1, or 2\. Each `case` statement sets the correct and incorrect answers
    to the multi-choice buttons in a slightly different order, so the player can''t
    just keep tapping the same button over and over to achieve a massive score. Notice
    the extra closing bracket after the closing bracket of the switch. This is the
    end of our `setQuestion` method.'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了我们的`Random`对象`randInt`来生成0到2之间的数字，并将该值赋给一个名为`buttonLayout`的新的`int`变量。然后我们使用`buttonLayout`来在它的所有可能值之间进行切换：0、1或2。每个`case`语句将正确和错误答案设置为多选按钮上的略有不同的顺序，这样玩家就不能一直点击同一个按钮来获得大量分数。注意在`switch`结束括号之后有一个额外的闭合括号。这是我们`setQuestion`方法的结束。
- en: We explained the code fairly thoroughly as we went through it but it might be
    worthwhile to just take a closer look at some parts again.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在通过代码时相当彻底地解释了代码，但再仔细看一些部分可能是值得的。
- en: 'In step 1, we saw our method signature with a `void` return type and no parameters.
    In step 2, we generated some random numbers that will be within a certain range.
    This range isn''t as obvious as it might seem at first. First, we assigned, declared,
    and initialized `numberRange` like this:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1中，我们看到了我们的方法签名，返回类型为`void`，没有参数。在步骤2中，我们生成了一些将在一定范围内的随机数。这个范围并不像乍看起来那么明显。首先，我们这样赋值、声明和初始化了`numberRange`：
- en: '[PRE116]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'So if the player is at the first question, then `currentLevel` will hold the
    value `1` and `numberRange` will be initialized as `3`. Then we made a new `Random`
    object as previously discussed and entered this line of code:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果玩家在第一个问题上，那么`currentLevel`将保存值`1`，`numberRange`将被初始化为`3`。然后我们创建了一个新的`Random`对象，就像之前讨论的那样，并输入了这行代码：
- en: '[PRE117]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'What occurs here is that the `nextInt` method of the `Random` object, `randInt`,
    will return a value of either 0, 1, or 2 because we have given it a seed of 3\.
    We don''t want any zeros in our game because they result in very easy multiplication,
    so we enter this:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的是`Random`对象`randInt`的`nextInt`方法将返回0、1或2的值，因为我们给它一个种子3。我们不希望游戏中有任何零，因为它们会导致非常简单的乘法，所以我们输入了这个：
- en: '[PRE118]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'This operator, which you probably remember from [Chapter 3](ch03.xhtml "Chapter 3. Speaking
    Java – Your First Game"), *Speaking Java – Your First Game*, when we discussed
    operators, adds 1 to `partA`. We then do exactly the same to our `partB` variable,
    which means that assuming that the player is still on level 1, they will have
    a question that will be one of the following:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符，你可能还记得来自[第3章](ch03.xhtml "第3章。说Java-你的第一个游戏")，“说Java-你的第一个游戏”，当我们讨论操作符时，将1添加到`partA`。然后我们对`partB`变量做完全相同的操作，这意味着假设玩家仍然处于1级，他们将有一个以下问题之一：
- en: 1 x 1, 1 x 2, 1 x 3, 2 x 1, 2 x 2, 2 x 3, 3 x 1, 3 x 2, or 3 x 3
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 1 x 1, 1 x 2, 1 x 3, 2 x 1, 2 x 2, 2 x 3, 3 x 1, 3 x 2, 或 3 x 3
- en: As the level increases, the potential range of the question increases significantly.
    So at level 2, the options are that either part of the question could be from
    1 to 6; for level 3, from 1 to 9; and so on. It is still possible to get an easy
    question on a higher level but it becomes less likely as the levels advance. Finally
    in this step, we display the question to the player using the `setText` method.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 随着级别的提高，问题的潜在范围显着增加。因此，在第2级，问题的选项可能是1到6;对于第3级，从1到9;等等。在更高的级别仍然可能得到一个简单的问题，但随着级别的提高，这种可能性变得越来越小。最后，在这一步中，我们使用`setText`方法向玩家显示问题。
- en: In step 3, we have seen before but this time we varied it slightly. We calculate
    and assign a value for `correctAnswer`, and declare and assign values to `wrongAnswer1`
    and `wrongAnswer2`, which will hold the wrong answer choices for our buttons.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，我们之前已经见过，但这次我们稍微改变了它。我们计算并为`correctAnswer`分配一个值，并声明并为`wrongAnswer1`和`wrongAnswer2`分配值，它们将保存按钮的错误答案选择。
- en: Part 3 varies very slightly from what we did in `onCreate` in the previous chapter
    because we subtract and add 2 to `wrongAnswer1` and `wrongAnswer2`, respectively.
    This makes guessing the answer to multiplication questions a little harder because
    you can't eliminate answers based on whether they are odd or even.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 第3部分与上一章的`onCreate`稍有不同，因为我们分别从`wrongAnswer1`和`wrongAnswer2`中减去和加上2。这使得猜测乘法问题的答案变得更难，因为你不能根据答案是奇数还是偶数来排除答案。
- en: Step 4 simply randomizes which buttons the correct and incorrect answers will
    be placed on. We don't need to keep track of this because when the time comes
    to compare the value on the button pressed with the correct answer, we can simply
    use our Java code to discover it as we did in [Chapter 3](ch03.xhtml "Chapter 3. Speaking
    Java – Your First Game"), *Speaking Java – Your First Game*.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 第4步只是随机确定正确和错误答案将放在哪些按钮上。我们不需要跟踪这一点，因为当比较按钮上的值与正确答案时，我们可以简单地使用我们的Java代码来发现它，就像我们在[第3章](ch03.xhtml
    "第3章。说Java-你的第一个游戏")，“说Java-你的第一个游戏”中所做的那样。
- en: The updateScoreAndLevel method
  id: totrans-569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新`updateScoreAndLevel`方法
- en: The name of this method speaks for itself. Because the keeping of the score
    is not simple and because we want higher levels to yield higher scores, we will
    compartmentalize the code to keep our program readable. If we then want to make
    modifications to the scoring system, they can all take place in there.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的名称说明了它自己。因为得分的保持并不简单，而且我们希望更高的级别能够产生更高的分数，我们将把代码分隔开来保持我们的程序可读性。如果我们想对记分系统进行修改，它们都可以在那里进行。
- en: Let's write the code.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写代码。
- en: 'This code can go anywhere within the opening and closing braces of `GameActivity
    {}`, but it is good practice to place them in the approximate order they will
    be used. So why not start adding your code after the closing brace of `setQuestion`
    but obviously before the closing brace of `GameActivity`? Here is the method signature
    with the opening brace:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码可以放在`GameActivity {}`的大括号的任何位置，但最好的做法是按照它们将被使用的大致顺序放置。那么为什么不在`setQuestion`的结束大括号之后开始添加你的代码，但显然在`GameActivity`的结束大括号之前？这是带有开始大括号的方法签名：
- en: '[PRE119]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'This tells us that our method does not return a value but that it does receive
    an `int`, which it will require to do its stuff. The name of the parameter is
    a big clue to what we will be passing. We will see that in action in the body
    in a minute, but if passing the player''s answer to this method instead of the
    `isCorrect` method is a bit confusing, we will see things become clearer in the
    next chunk of code. Here is the next part of the code to add:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这告诉我们，我们的方法不返回值，但它接收一个`int`，它将需要执行其操作。参数的名称是我们将要传递的一个重要线索。我们将在一分钟内在主体中看到它的作用，但如果将玩家的答案传递给这个方法而不是`isCorrect`方法有点困惑，我们将在下一段代码中看到事情变得更清晰。这是要添加的代码的下一部分：
- en: '[PRE120]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'There is a lot happening here, so we will dissect it more once we have the
    method completed. Basically, it calls the `isCorrect` method (which we will write
    soon) and if the response is `true`, adds to the player''s score in a `for` loop.
    After that, the method adds 1 to `currentLevel`. Here comes the `else` part of
    the code in case the response from `isCorrect` is `false`:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里发生了很多事情，所以一旦我们完成了这个方法，我们将更详细地解剖它。基本上，它调用`isCorrect`方法（我们很快将写出来），如果响应是`true`，则在`for`循环中增加玩家的分数。之后，该方法将`currentLevel`增加1。这是代码的`else`部分，以防`isCorrect`的响应是`false`：
- en: '[PRE121]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'If the response is `false`, that is, if the player got the answer wrong, the
    `currentScore` variable is set to `0` and the level back to `1`. Finally for this
    method, we type the following:'
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果响应是`false`，也就是说，如果玩家答错了，`currentScore`变量将设置为`0`，级别回到`1`。最后，对于这个方法，我们输入以下内容：
- en: '[PRE122]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: In the previous step, we updated the actual TextViews that the player sees with
    the newly determined score and level. The method then ended and the control of
    the program returned to the code that called `updateScoreAndLevel` to begin with.
    Save your project.
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步中，我们更新了玩家看到的实际TextViews，显示了新确定的分数和级别。然后方法结束，程序的控制返回到最初调用`updateScoreAndLevel`的代码。保存你的项目。
- en: We explained most of the code as we went but it might be good to quickly review
    it and dig a bit deeper into certain parts, especially the call to `isCorrect`
    in that odd-looking `if` statement.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在进行代码编写时已经解释了大部分代码，但快速回顾并深入研究某些部分可能会有好处，特别是在那个看起来很奇怪的`if`语句中调用`isCorrect`。
- en: 'In step 1, we began with the method signature. Then in step 2, we began with
    the aforementioned curious `if`:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1中，我们从方法签名开始。然后在步骤2中，我们从上述奇怪的`if`开始：
- en: '[PRE123]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: We have seen this type of statement before in the *A working method* example
    in the *Methods* section of this chapter. What is happening here is that the call
    to `isCorrect` is replacing the statement to be evaluated, or rather it *is* the
    statement to be evaluated. So `isCorrect` is called with the `answerGiven` variable.
    The `answerGiven` variable, as you might remember, was passed to `updateScoreAndLevel`.
    This time, it is passed to the `isCorrect` method, which will do some work with
    it and perhaps a few other things. Then it will return to the `if` statement a
    value of `true` or `false`. The value will be true if the question is answered
    correctly and false if not.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的*方法*部分的*一个有效的方法*示例中已经见过这种类型的语句。这里发生的是`isCorrect`的调用正在替换要评估的语句，或者更确切地说，*是*要评估的语句。因此，`isCorrect`被`answerGiven`变量调用。您可能还记得，`answerGiven`变量被传递给`updateScoreAndLevel`。这次，它被传递给`isCorrect`方法，它将对其进行一些处理，也许还有其他一些事情。然后它将返回`true`或`false`的值给`if`语句。如果问题回答正确，则该值为true，否则为false。
- en: 'Assuming the `if` statement evaluates to true, the program runs this bit of
    code (also from step 2):'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`if`语句评估为true，则程序运行此代码段（也来自步骤2）：
- en: '[PRE124]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The code enters a `for` loop where the starting variable `i` is initialized
    to 1 like this: `int i = 1;`. Furthermore, the loop is instructed to continue
    as long as `i` is less than or equal to our `currentLevel` variable. Then within
    the `for` loop, we add `i` to the current score. As an example, let''s assume
    that the player has just got a question correct and we enter the `for` loop with
    `currentLevel` at 1\. The player''s score is still at 0 because this is their
    first correct answer.'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 代码进入一个`for`循环，其中起始变量`i`被初始化为1，如此：`int i = 1;`。此外，循环被指示只要`i`小于或等于我们的`currentLevel`变量就继续。然后在`for`循环内，我们将`i`添加到当前分数。例如，假设玩家刚刚回答了一个问题正确，我们以`currentLevel`为1进入`for`循环。玩家的分数仍然为0，因为这是他们的第一个正确答案。
- en: 'At pass 1, we get the following:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1次通过时，我们得到以下结果：
- en: '`i = 1`, so it is equal to `currentLevel`, which is also 1\. So we enter the
    `for` loop'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i = 1`，所以它等于`currentLevel`，也是1。所以我们进入`for`循环'
- en: '`i = 1`, so `currentScore` equals 0'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i = 1`，所以`currentScore`等于0'
- en: We add `i`, which is `1`, to `currentScore`
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`i`，即`1`，加到`currentScore`
- en: Our `currentScore` variable is now equal to `1`
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`currentScore`变量现在等于`1`
- en: 'At pass 2, the following steps take place:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2次通过时，发生以下步骤：
- en: '`i` is incremented to 2, so it is now greater than `currentLevel`, which is
    1'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`增加到2，所以现在大于`currentLevel`，即1'
- en: The `for` loop condition evaluates to `false` and we continue with the code
    after the `for` loop
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`循环条件评估为`false`，我们继续`for`循环后的代码'
- en: '`currentLevel` is increased by 1 to 2'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentLevel`增加1到2'
- en: Now let's look at that `for` loop again assuming that the player gets the next
    question correct as well, and we are back in `updateScoreAndLevel`. This time,
    `isCorrect` has evaluated true and we enter the `for` loop but with a slightly
    different situation than the last time.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再次看看`for`循环，假设玩家下一个问题也回答正确，我们回到`updateScoreAndLevel`。这次，`isCorrect`评估为true，我们进入`for`循环，但情况与上次略有不同。
- en: 'At pass 1, the following steps take place:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1次通过时，发生以下步骤：
- en: '`i = 1`, so `i` is less than `currentLevel` is 2 and we enter the `for` loop'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i = 1`，所以`i`小于`currentLevel`是2，我们进入`for`循环'
- en: '`i = 1`, `currentScore` `= 1`'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i = 1`，`currentScore` `= 1`'
- en: We add `i`, which is equal to 1, to `currentScore`
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`i`，即1，加到`currentScore`
- en: Our `currentScore` variable is now equal to 2
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`currentScore`变量现在等于2
- en: 'At pass 2, we have the following steps happening:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2次通过时，发生以下步骤：
- en: '`i` is incremented to 2 and it is now equal to `currentLevel`, which is also
    2'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`增加到2，现在等于`currentLevel`，也是2'
- en: '`i = 2`, `currentScore = 2`'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i = 2`，`currentScore = 2`'
- en: We add `i`, which is now equal to 2, to `currentScore`
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`i`，现在等于2，加到`currentScore`
- en: Our `currentScore` variable is now equal to 4
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`currentScore`变量现在等于4
- en: 'At pass 3, the following steps take place:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3次通过时，发生以下步骤：
- en: '`i` is incremented to 3 and it is now greater than `currentLevel`, which is
    2.'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`增加到3，现在大于`currentLevel`，即2。'
- en: The `for` loop condition evaluates to false and we continue with the code after
    the `for` loop.
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`循环条件评估为false，我们继续`for`循环后的代码。'
- en: The value of `currentLevel` is increased by 1 to 3\. So the next time, we will
    have an extra pass through our `for` loop.
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentLevel`的值增加1到3。所以下次，我们将有额外的通过我们的`for`循环。'
- en: 'What is happening is that with each level, the player is being rewarded with
    another pass through the `for` loop, and each pass through the `for` loop adds
    a greater value to their score. To summarize what happens in the `for` loop, here
    is a brief table of values showing how the player''s score is increased based
    on the `currentLevel` variable:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每个级别，玩家将获得通过`for`循环的另一个奖励，并且每次通过`for`循环都会为他们的分数增加更大的值。总结一下`for`循环中发生的情况，这里是一个简短的值表，显示了玩家的分数如何基于`currentLevel`变量增加：
- en: '| currentLevel | Added to currentScore | currentScore after for loop |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '| currentLevel | 添加到currentScore | for循环后的currentScore |'
- en: '| --- | --- | --- |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | 1 | 1 |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: '| 2 | 3 (1 + 2) | 4 |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 3 (1 + 2) | 4 |'
- en: '| 3 | 6 (1 + 2 + 3) | 10 |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 6 (1 + 2 + 3) | 10 |'
- en: '| 4 | 10 (1 + 2 + 3 + 4) | 20 |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 10 (1 + 2 + 3 + 4) | 20 |'
- en: '| 5 | 15 (1 + 2 + 3 + 4 + 5) | 35 |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 15 (1 + 2 + 3 + 4 + 5) | 35 |'
- en: Note
  id: totrans-620
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of course, we could have kept it really simple and not used a `for` loop. We
    could just use `currentScore = currentScore + level` perhaps, but that doesn't
    offer an ever increasing reward in the same way as our current solution does and
    we wouldn't have been able to practice our `for` loops either.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们本可以保持非常简单，不使用`for`循环。也许我们只需使用`currentScore = currentScore + level`，但这并不像我们当前的解决方案那样提供不断增加的奖励，并且我们也无法练习`for`循环。
- en: If `if(isCorrect(answerGiven))` evaluates to `false`, it simply resets the score
    to 0 and the level to 1 in step 3\. Step 4 then updates our TextViews for the
    score and the level using the variables we have just discussed.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`if(isCorrect(answerGiven))`评估为`false`，则在第3步中它只是将分数重置为0，将级别重置为1。然后在第4步中，使用我们刚讨论过的变量更新我们的分数和级别的TextView。
- en: Now we have just one more method to write. Of course, this is the `isCorrect`
    method, which we just called.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要编写一个方法。当然，这就是我们刚刚调用的`isCorrect`方法。
- en: The isCorrect method
  id: totrans-624
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isCorrect方法
- en: 'This method is nice and simple because we have seen all of the relevant code
    before. It is just the method signature and the return value that we need to look
    at carefully:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法很简单，因为我们之前已经看到了所有相关的代码。我们只需要仔细查看方法签名和返回值：
- en: 'Enter the code just after the closing brace of the `updateScoreAndLevel` method
    but before the closing brace of the `GameActivity` class. Type the method signature
    like this:'
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`updateScoreAndLevel`方法的右括号之后，但在`GameActivity`类的右括号之前输入代码。像这样输入方法签名：
- en: '[PRE125]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Here we can see that the method must return a Boolean value, `true` or `false`.
    If it doesn''t, then the program won''t compile. This guarantees that when we
    use this method as the evaluation expression in the `updateScoreAndLevel` method,
    we will definitely get a result. It can be true or false. The signature also shows
    us the `answerGiven` variable passed in, ready for us to use. Type this code,
    which will determine that result:'
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到该方法必须返回一个布尔值，`true`或`false`。如果没有，程序就无法编译。这保证了当我们将这个方法用作`updateScoreAndLevel`方法中的评估表达式时，我们一定会得到一个结果。它可以是true或false。方法签名还向我们展示了传入的`answerGiven`变量，准备供我们使用。输入这段代码，它将确定结果：
- en: '[PRE126]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'We have seen almost all of the preceding code before. The exception is that
    we declare a Boolean variable, `correctTrueOrFalse`, which we assign to `true`
    if the player answers correctly and to `false` if not. We know whether the player
    is correct or not because we compare `answerGiven` to `correctAnswer` in the `if`
    statement. Notice that we have also triggered the appropriate Android pop-up toast
    message as we did before. Finally, we do this:'
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎已经看到了前面的所有代码。唯一的例外是，我们声明了一个布尔变量`correctTrueOrFalse`，如果玩家回答正确则赋值为`true`，如果不正确则赋值为`false`。我们知道玩家是否正确，因为我们在`if`语句中将`answerGiven`与`correctAnswer`进行比较。请注意，我们还触发了适当的Android弹出式提示消息，就像以前一样。最后，我们这样做：
- en: '[PRE127]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: We just returned whatever value is contained within `correctTrueOrFalse`. So
    the critical `if` statement in `updateScoreAndLevel`, which we discussed in detail,
    will know what to do next.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只返回`correctTrueOrFalse`中包含的任何值。因此，在我们详细讨论过的`updateScoreAndLevel`中的关键`if`语句将知道接下来该做什么。
- en: To make sure we understand what is happening in `isCorrect`, let's go through
    the sequence of events in our code. In step 1 we have the method signature. We
    see that we will return a `true` or `false` value and receive `int`.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们理解`isCorrect`中发生了什么，让我们通过代码中的事件顺序进行一遍。在第1步中，我们有方法签名。我们看到我们将返回一个`true`或`false`值，并接收`int`。
- en: In step 2, we declare a Boolean variable called `correctTrueOrFalse` to hold
    the value we will soon return. Then we test for a right or wrong answer with `if(answerGiven
    == correctAnswer)`. If the two compared values match, a congratulatory message
    pops up and we assign `true` to our Boolean variable. Of course, if the `if` statement
    is `false`, we offer commiserations to the player and assign `false` to our important
    Boolean.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，我们声明一个名为`correctTrueOrFalse`的布尔变量来保存我们即将返回的值。然后我们用`if(answerGiven == correctAnswer)`来测试答案是否正确。如果两个比较的值匹配，将弹出祝贺消息，并将`true`赋给我们的布尔变量。当然，如果`if`语句为`false`，我们会向玩家表示慰问，并将`false`赋给我们重要的布尔变量。
- en: Finally in step 3, we send back `true` or `false` so that the `updateScoreAndLevel`
    method can proceed with its work.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第3步中，我们发送`true`或`false`，以便`updateScoreAndLevel`方法可以继续工作。
- en: We have now implemented all our methods. It's time to put them to work.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经实现了所有的方法。是时候让它们发挥作用了。
- en: Calling our new methods
  id: totrans-637
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用我们的新方法
- en: 'Of course, our shiny new methods won''t do anything until we call them. So
    here is the plan to call these methods:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们闪亮的新方法在我们调用它们之前不会做任何事情。因此，这是调用这些方法的计划：
- en: 'When the game starts, we want to set a new question for the player. Therefore,
    as the last line of code in our `onCreate` method, we can call our `setQuestion`
    method like this:'
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏开始时，我们希望为玩家设置一个新问题。因此，在我们的`onCreate`方法中的最后一行代码中，我们可以这样调用我们的`setQuestion`方法：
- en: '[PRE128]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Then we turn our attention to the `onClick` method, which already detects which
    button has been pressed and loads the player''s answer into our `answerGiven`
    variable. So at the end of the `onClick` method, after the closing brace of the
    `switch` statement, we just call this function:'
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们转向`onClick`方法，它已经检测到哪个按钮被按下，并将玩家的答案加载到我们的`answerGiven`变量中。因此，在`onClick`方法的结尾，在`switch`语句的右括号之后，我们只需调用这个函数：
- en: '[PRE129]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'This sends our player''s attempted answer to `updateScoreAndLevel`, which evaluates
    the answer using `isCorrect`, adds points, and increments the score if the answer
    is correct or resets the score and level if not. All that we need now is another
    question. Add this line. It will ask another question:'
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将我们玩家尝试的答案发送到`updateScoreAndLevel`，它使用`isCorrect`来评估答案，添加分数，并在答案正确时增加分数，如果答案不正确，则重置分数和级别。现在我们只需要另一个问题。添加这行。它会问另一个问题：
- en: '[PRE130]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'So now what happens is that the player starts our math game by clicking on
    its icon on their Android device. Our `GameActivity` class declares a few variables
    that we need access to throughout:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家通过在其Android设备上点击其图标来开始我们的数学游戏。我们的`GameActivity`类声明了一些我们需要访问的变量：
- en: '[PRE131]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Then `onCreate` initializes some variables and gets our buttons ready to receive
    clicks from the player before asking the first question by calling `setQuestion`.
    The game then waits for the player to attempt an answer. When the player attempts
    an answer, it is dealt with by `onClick`, `updateScoreAndLevel`, and `isCorrect`.
    Then the program control comes back to `onClick` again, `setQuestion` is called
    again, and we wait for the player's answer once more.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`onCreate`初始化一些变量，并准备好接收玩家点击的按钮，然后通过调用`setQuestion`来询问第一个问题。游戏然后等待玩家尝试回答。当玩家尝试回答时，它将由`onClick`，`updateScoreAndLevel`和`isCorrect`处理。然后程序控制再次回到`onClick`，再次调用`setQuestion`，然后我们再次等待玩家的答案。
- en: Finishing touches
  id: totrans-648
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的修饰
- en: Our math game is coming along nicely. Unfortunately, we have to move on soon.
    The project has served its purpose to demonstrate some fundamentals of Java programming
    as well as some key Android features. Now we need to start introducing some more
    game-related topics.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数学游戏进展顺利。不幸的是，我们很快就要继续了。该项目已经达到了它展示一些Java编程基础以及一些关键Android功能的目的。现在我们需要开始介绍一些更多与游戏相关的主题。
- en: Before we go on, there are two really easy things to make our game a bit more
    cool and complete. In case you are wondering about the High Scores button, we
    will see how that can be implemented when we look at our next game project in
    [Chapter 5](ch05.xhtml "Chapter 5. Gaming and Java Essentials"), *Gaming and Java
    Essentials*. You will then have enough information to easily come back and implement
    high scores on your own.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，有两件非常容易的事情可以使我们的游戏变得更酷更完整。如果你想知道高分按钮，我们将在[第5章](ch05.xhtml "第5章。游戏和Java基础")中看到如何实现它，*游戏和Java基础*。然后你将有足够的信息来轻松地回来并自己实现高分。
- en: The other feature that would really round off our game and make it more playable
    is an overall or per question time limit. Perhaps even increasing the score based
    on how quickly the correct answer is given will help. We need some new Java tricks
    up our sleeves before we can do that, but we will see how we can measure and respond
    to time in [Chapter 5](ch05.xhtml "Chapter 5. Gaming and Java Essentials"), *Gaming
    and Java Essentials*, when we talk about threads.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个真正完善我们的游戏并使其更具可玩性的功能是整体或每个问题的时间限制。也许根据正确答案给出的速度来增加分数会有所帮助。在我们谈论线程时，我们需要一些新的Java技巧，但我们将在[第5章](ch05.xhtml
    "第5章。游戏和Java基础")中看到我们如何测量和响应时间，*游戏和Java基础*。
- en: 'Now we will quickly learn two improvements:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将快速学习两个改进：
- en: Locking the screen orientation
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定屏幕方向
- en: Changing the home screen image
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改主屏幕图像
- en: Going full screen and locking orientation
  id: totrans-655
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全屏和锁定方向
- en: You might have noticed that if you rotate your device while the app is running,
    not only does your game UI get distorted but the game progress is also lost. What
    goes wrong is that when the device is rotated, the `onPause` and `onStop` methods
    are called. Then the app is restarted. We could handle this by overriding the
    `onPause` method and saving our data. We will do this later. For now we don't
    want the screen to rotate anyway, so if we stop it we solve two problems in one.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，如果在应用程序运行时旋转设备，不仅游戏UI会变形，而且游戏进度也会丢失。出现问题的原因是当设备旋转时，将调用`onPause`和`onStop`方法。然后应用程序将重新启动。我们可以通过重写`onPause`方法并保存我们的数据来处理这个问题。我们稍后会这样做。现在无论如何我们都不希望屏幕旋转，所以如果我们停止它，我们就解决了两个问题。
- en: 'While adding code to this file, Android Studio may try to "help" by adding
    extra formatting. If you get red error indicators, you can compare your `AndroidManifest.xml`
    file with the one in the code download in the `Chapter4/MathGameChapter4` folder.
    Alternatively, you can simply replace the contents of your file with the contents
    of the file in the download. The step-by-step changes are detailed in this guide
    just to highlight what is changing:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 在向此文件添加代码时，Android Studio可能会尝试通过添加额外的格式来“帮助”。如果出现红色错误指示器，您可以将您的`AndroidManifest.xml`文件与`Chapter4/MathGameChapter4`文件夹中的代码下载中的文件进行比较。或者，您可以简单地用下载文件中的文件内容替换您的文件内容。这个指南详细说明了逐步的更改，只是为了突出发生了什么变化：
- en: This is the first step in locking the app to portrait. Open the `AndroidManifest.xml`
    file. It is located directly below the `res` folder in the Project Explorer. Find
    the first opening `<activity` in the code.
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是将应用程序锁定为纵向的第一步。打开`AndroidManifest.xml`文件。它位于项目资源资源管理器中的`res`文件夹直接下方。在代码中找到第一个开放的`<activity`。
- en: 'Enter a new line as follows:'
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下新行：
- en: '[PRE132]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Repeat step 2 after the second instance of `<activity`. We have now locked both
    the menu and game screens in portrait mode.
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个`<activity`实例之后重复步骤2。我们现在已经将菜单和游戏屏幕都锁定在纵向模式下。
- en: 'To make the game full screen, in the same file, find the following text and
    add the line in bold after it but before the closing `>` sign:'
  id: totrans-662
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使游戏全屏，在同一文件中，找到以下文本，并在其后添加粗体行，但在关闭`>`符号之前：
- en: '[PRE133]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Make the same change to the `GameActivity` activity like this. Again, here
    is the code in context in order to avoid mistakes with these `>` signs:'
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`GameActivity`活动进行相同的更改。同样，这里是上下文中的代码，以避免出现这些`>`符号的错误：
- en: '[PRE134]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Save the project.
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存项目。
- en: Now, when you rotate the device during gameplay, the portrait orientation will
    be fixed.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在游戏过程中旋转设备时，纵向方向将被固定。
- en: Adding a custom image (instead of the Android icon)
  id: totrans-668
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加自定义图像（而不是Android图标）
- en: 'We probably don''t want to have the Android image on our finished game home
    screen, so here is the procedure to change it. This quick guide relies on you
    having an image you would like to use:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能不希望在我们完成的游戏主屏幕上有Android图像，所以这是更改它的过程。这个快速指南依赖于您是否有想要使用的图像：
- en: First, we need to add the required image to the layout folder. Copy your image
    file by clicking on it in **Windows Explorer** and using *Ctrl* + *C*.
  id: totrans-670
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将所需的图像添加到布局文件夹中。通过在**Windows资源管理器**中单击图像文件，然后使用*Ctrl* + *C*进行复制。
- en: Now find the `drawable-mdpi` folder in the Android Studio Project Explorer.
    Click on the folder.
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在Android Studio项目资源管理器中找到`drawable-mdpi`文件夹。点击该文件夹。
- en: Paste the image to the folder using *Ctrl* + *V*.
  id: totrans-672
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *V*将图像粘贴到文件夹中。
- en: Now the image is a part of our project. We simply need to choose it in the same
    way as we chose the image of the Android robot previously. Open `activity_main.xml`
    in the editor window and click on **ImageView** (currently an Android robot).
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在图像已经成为我们项目的一部分。我们只需要像之前选择Android机器人的图像一样选择它。在编辑窗口中打开`activity_main.xml`，然后点击**ImageView**（当前是一个Android机器人）。
- en: In the **Properties** window, find the **src** property. Click on it and then
    on **...**.
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**属性**窗口中，找到**src**属性。点击它，然后点击**...**。
- en: Search for your image and select it.
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索你的图像并选择它。
- en: Save your project.
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的项目。
- en: You now have the image of your choice on the home screen.
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你在主屏幕上有了你选择的图像。
- en: Self-test questions
  id: totrans-678
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: 'Q1) Guess what is wrong with this method:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: Q1）猜猜这个方法有什么问题：
- en: '[PRE135]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Q2) What will `x` be equal to at the end of this code snippet?
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: Q2）在这段代码结束时，`x`将等于多少？
- en: '[PRE136]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Summary
  id: totrans-683
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We came a really long way in this chapter. You got a serious handle on Java
    loops and took your first, fairly deep look into Java methods and how to use them.
    You learned how to generate random numbers and significantly enhanced your math
    game using all of the knowledge you gained.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们走了很长的路。你对Java循环有了深入的了解，并且第一次深入地了解了Java方法以及如何使用它们。你学会了如何生成随机数，并且利用你所学到的知识显著增强了你的数学游戏。
- en: As the chapters proceed, the games will get more and more real-game-like. In
    the next chapter, we will make a game to test the player's memory. It will have
    sound, animation and will actually save the player's high scores too.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 随着章节的进行，游戏会变得越来越像真正的游戏。在下一章中，我们将制作一个测试玩家记忆的游戏。它将有声音、动画，并且实际上还会保存玩家的最高分。
- en: Congratulations on your progress so far but let's keep going.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你迄今为止的进步，但让我们继续前进。
