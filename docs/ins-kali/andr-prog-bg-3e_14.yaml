- en: '*Chapter 14*: Android Dialog Windows'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第14章*：Android对话框窗口'
- en: In this chapter, we will look at how to present the user with a pop-up dialog
    window. We can then put all that we know into the first phase of our first app,
    **Note to Self**. We will then explore the latest Android and Java features in
    this chapter and the next four (up to [*Chapter 18*](B16773_18_ePub_RK.xhtml#_idTextAnchor320)*,*
    *Localization*), and use our newly acquired knowledge to enhance the Note to Self
    app at each stage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何向用户呈现弹出对话框窗口。然后，我们可以将我们所知道的全部内容放入我们的第一个应用程序**Note to Self**的第一阶段。接下来的四章（直到[*第18章*](B16773_18_ePub_RK.xhtml#_idTextAnchor320)*,*
    *本地化*）中，我们将探索最新的Android和Java功能，并利用我们新获得的知识来增强Note to Self应用程序的每个阶段。
- en: 'Each chapter will also build a selection of smaller apps that are separate
    from this main app. So, what does this chapter hold in store for you? Well, we
    will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每一章还将构建一系列与此主要应用程序分开的较小的应用程序。那么，这一章对您有什么意义呢？好吧，我们将涵盖以下主题：
- en: Implementing a simple app with a pop-up dialog box
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用弹出对话框框架创建一个简单的应用程序
- en: Using the `DialogFragment` class to begin the Note to Self app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`DialogFragment`类开始Note to Self应用程序
- en: Adding string resources in our projects instead of hardcoding text in our layouts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的项目中添加字符串资源，而不是在布局中硬编码文本
- en: Using Android naming conventions for the first time to make our code more readable
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首次使用Android命名约定，使我们的代码更易读
- en: Implementing more complex dialog boxes to capture input from the user
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现更复杂的对话框以捕获用户输入
- en: Let's get started.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2014](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2014).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中的代码文件，网址为[https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2014](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2014)。
- en: Dialog windows
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对话框窗口
- en: On many occasions, in our apps, we will want to show the user some information
    or even ask for confirmation of an action in a pop-up window. This is known as
    a **dialog** window. If you quickly scan the palette in Android Studio, then you
    might be surprised to see that there is no mention whatsoever of dialogs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们经常需要在弹出窗口中向用户显示一些信息，甚至要求确认某个操作。这就是所谓的**对话框**窗口。如果您快速扫描Android Studio中的调色板，您可能会惊讶地发现根本没有提到对话框。
- en: Dialogs in Android are more advanced than a simple widget or even a whole layout.
    They are classes that can have layouts and other **User Interface** (**UI**) elements
    of their own.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，对话框比简单的小部件甚至整个布局更高级。它们是可以拥有自己的布局和其他**用户界面**（**UI**）元素的类。
- en: The best way to create a dialog window in Android is to use the `FragmentDialog`
    class.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中创建对话框窗口的最佳方式是使用`FragmentDialog`类。
- en: Note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Fragments are a wide and vital topic in Android, and we will spend much of the
    second half of this book exploring and using them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 片段是Android中一个广泛而重要的主题，我们将在本书的后半部分花费大量时间来探索和使用它们。
- en: Creating a neat pop-up dialog (using `FragmentDialog`) for our user to interact
    with is a great introduction to fragments, and it's not overly complicated at
    all.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为用户创建一个整洁的弹出对话框（使用`FragmentDialog`）是对片段的一个很好的介绍，而且一点也不复杂。
- en: Creating the Dialog Demo project
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建对话框演示项目
- en: We previously mentioned that the best way to create a dialog in Android is via
    the `FragmentDialog` class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，在Android中创建对话框的最佳方式是通过`FragmentDialog`类。
- en: To do this, create a new project in Android Studio using the Empty Activity
    template and call it `Dialog Demo`. As you have come to expect, the completed
    code for this project is in the [*Chapter 14*](B16773_14_ePub_RK.xhtml#_idTextAnchor249)`/Dialog
    Demo` folder of the download bundle.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，在Android Studio中使用空活动模板创建一个新项目，并将其命名为`Dialog Demo`。正如您所期望的那样，该项目的完整代码位于下载包的[*第14章*](B16773_14_ePub_RK.xhtml#_idTextAnchor249)`/Dialog
    Demo`文件夹中。
- en: Coding a DialogFragment class
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一个DialogFragment类
- en: Create a new class in Android Studio by right-clicking on the folder with the
    name of your package (the same one that has the `MainActivity.java` file). Select
    `MyDialog`. Press the *Enter* key to create the class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过右键单击包含`MainActivity.java`文件的包名称（与`MainActivity.java`文件相同的包名称）在Android Studio中创建一个新类。选择`MyDialog`。按下*Enter*键创建类。
- en: 'The first thing to do is to change the class declaration to extend `DialogFragment`.
    When you have done so, your new class should look similar to the following code
    block:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是将类声明更改为扩展`DialogFragment`。完成后，您的新类应该类似于以下代码块：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s add code to this class, a little bit at a time, and explain what
    is happening at each step. Now, we need to import the `DialogFragment` class.
    You can do this by holding down the *Alt* key and then tapping on *Enter* or by
    adding the following line of highlighted code after the package declaration at
    the top of the `MyDialog.java` file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们一点一点地向这个类添加代码，并解释每一步发生了什么。现在，我们需要导入`DialogFragment`类。您可以通过按住*Alt*键然后点击*Enter*，或者在`MyDialog.java`文件顶部的包声明之后添加以下突出显示的代码行来实现这一点：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Just like so many classes in the Android API, `DialogFragment` provides us with
    methods that we can override in order to interact with the different events that
    will occur with the class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在Android API中的许多类一样，`DialogFragment`为我们提供了可以重写以与该类发生的不同事件交互的方法。
- en: 'Add the following highlighted code to override the `onCreateDialog` method.
    Study it carefully, and we will examine what is happening next:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下突出显示的代码以重写`onCreateDialog`方法。仔细研究它，我们将在下一步中检查发生了什么：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You will need to import the `Dialog`, `Bundle`, and `AlertDialog` classes in
    the usual way or by adding the following highlighted code manually:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要按照通常的方式导入`Dialog`、`Bundle`和`AlertDialog`类，或者通过手动添加以下突出显示的代码来导入：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is still one error in the code because we are missing the `return` statement
    for the `onCreateDialog` method. We will add this later on when we have finished
    coding the rest of the method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中仍然有一个错误，因为我们忘记了onCreateDialog方法的return语句。当我们完成了方法的其余部分编码后，我们将在稍后添加这个return语句。
- en: In the preceding code, we first added the overridden `onCreateDialog` method.
    This will be called by Android when we later show the dialog to the user via code
    in the `MainActivity` class.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先添加了重写的onCreateDialog方法。当我们稍后通过MainActivity类中的代码向用户显示对话框时，Android将调用此方法。
- en: Then, inside the `onCreateDialog` method, we get our hands on a new class. We
    declare and initialize an object of the `AlertDialog.Builder` type, which needs
    a reference to `MainActivity` passed into its constructor. This is why we use
    the `getActivity()` method as the argument.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在onCreateDialog方法内部，我们得到了一个新的类。我们声明并初始化了一个AlertDialog.Builder类型的对象，它需要MainActivity的引用传递给它的构造函数。这就是为什么我们使用getActivity()方法作为参数。
- en: The `getActivity` method is part of the `Fragment` class (and, therefore, `DialogFragment`
    too), and it returns a reference to `Activity`, which will create `DialogFragment`.
    In this case, that is our `MainActivity` class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: getActivity方法是Fragment类（因此也是DialogFragment）的一部分，它返回一个对Activity的引用，该Activity将创建DialogFragment。在这种情况下，就是我们的MainActivity类。
- en: Let's examine what we can do with `builder` now that we have declared and initialized
    it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经声明并初始化了builder，让我们看看我们可以用builder做些什么。
- en: Using chaining to configure DialogFragment
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用链接配置DialogFragment
- en: Now we can use our `builder` object to do the remainder of the work. There is
    something slightly odd in the following code snippet. If you quickly scan the
    next three blocks of code, you will notice that there is a distinct lack of semicolons,
    `;`. These three blocks of code are, in fact, just one line to the compiler.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用builder对象来完成其余的工作。在下面的代码片段中有一些奇怪的地方。如果您快速扫描下面的三个代码块，您会注意到缺少分号`;`。事实上，这三个代码块对于编译器来说只是一行。
- en: We have seen this before but in a less pronounced situation; that is, when we
    created a `Toast` message and added a `.show()` method to the end of it. This
    is called **chaining**. This is where we call more than one method, in sequence,
    on the same object. This is equivalent to writing multiple lines of code; it is
    just more succinct this way.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以前见过这种情况，但情况没有那么明显；也就是说，当我们创建一个Toast消息并在其末尾添加.show()方法时。这被称为链接。这是指我们在同一个对象上按顺序调用多个方法。这相当于编写多行代码；只是这种方式更简洁。
- en: 'Add the following code (which uses chaining) inside the `onCreateDialog` method
    right after the previous code we added. Examine the new code, and we will discuss
    it next:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加的先前代码之后，在onCreateDialog方法中添加以下代码（使用链接）。检查新代码，我们将在下面讨论它：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At this point, you will need to import the `DialogInterface` class. Use the
    *Alt* | *Enter* technique, or add this line of code among the other `import` statements:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您需要导入DialogInterface类。使用Alt | Enter技术，或者在其他import语句中添加以下代码行：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is an explanation for each of the three parts of the code that we just
    added:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们刚刚添加的代码的每个部分的解释：
- en: In the first of the three blocks (which uses chaining), we call `builder.setMessage`.
    This sets the main message that the user will see in the dialog box. Additionally,
    note that it is fine to have comments between parts of the chained method calls
    since these are ignored by the compiler.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在三个使用链接的代码块中的第一个代码块中，我们调用builder.setMessage。这将设置用户在对话框中看到的主要消息。另外，请注意，可以在链接方法调用的各个部分之间添加注释，因为编译器会忽略这些注释。
- en: Then, we add a button to our dialog with the `.setPositiveButton` method, and
    the first argument of this method sets the text of the button to `OK`. The second
    argument is an anonymous class, called `DialogInterface.OnClickListener`, which
    handles any clicks on the button. Notice that we are not going to add any code
    to the `onClick` method. Here, we just want to see this simple dialog; we will
    take things a step further in the next project.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用.setPositiveButton方法向对话框添加一个按钮，该方法的第一个参数将按钮的文本设置为“确定”。第二个参数是一个匿名类，称为DialogInterface.OnClickListener，它处理按钮的任何点击。请注意，我们不打算向onClick方法添加任何代码。在这里，我们只是想看到这个简单的对话框；我们将在下一个项目中进一步进行。
- en: Next, we call yet another method on the same `builder` object. This time, it's
    the `setNegativeButton` method. Again, the two arguments set `Cancel` as the text
    for the button and an anonymous class to listen for clicks. Again, for the purpose
    of this demonstration, we are not taking any action in the overridden `onClick`
    method. After the call to the `setNegativeButton` method, we finally see a semicolon
    marking the end of the line of code.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在同一个builder对象上调用另一个方法。这次是setNegativeButton方法。同样，两个参数将“取消”设置为按钮的文本，并添加一个匿名类来监听点击。同样，出于演示目的，我们不会在重写的onClick方法中采取任何行动。在调用setNegativeButton方法之后，我们最终看到一个分号标记着代码行的结束。
- en: 'We will finally code the `return` statement to complete the method and remove
    the error that we have had from the start. Add the `return` statement, as shown
    in the following snippet, to the end (but inside the final curly brace) of the
    `onCreateDialog` method:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将编写return语句以完成该方法，并消除我们一开始就有的错误。在onCreateDialog方法的最后（但在最终大括号内部）添加return语句，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This last line of code has the effect of returning to the `MainActivity` class
    (which calls the `onCreateDialog` method in the first place) our new, fully configured,
    dialog window. We will examine and add this calling code later on.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码的最后效果是将我们新的、完全配置好的对话框窗口返回给MainActivity类（它首先调用onCreateDialog方法）。我们将稍后检查并添加这个调用代码。
- en: Now, we have our `MyDialog` class that extends `FragmentDialog`. All we need
    to do is to declare an instance of `MyDialog`, instantiate it, and call its overridden
    `createDialog` method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了扩展FragmentDialog的MyDialog类。我们所需要做的就是声明一个MyDialog的实例，实例化它，并调用它重写的createDialog方法。
- en: Using the DialogFragment class
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用DialogFragment类
- en: 'Before we turn to the code, let''s add a button to our layout. Perform the
    following steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在转向代码之前，让我们向布局中添加一个按钮。执行以下步骤：
- en: Switch to the `activity_main.xml` tab and then switch to the **Design** tab.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`activity_main.xml`标签，然后切换到**设计**标签。
- en: Drag a `id` attribute is set to `button`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动`id`属性设置为`button`。
- en: Click on the `MyDialog` class is the key lesson for now.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`MyDialog`类是目前的关键课程。
- en: Now switch to the `MainActivity.java` tab, and we will handle a click on this
    new button by using an anonymous class just as we did in [*Chapter 13*](B16773_13_ePub_RK.xhtml#_idTextAnchor228),
    *Anonymous Classes – Bringing Android Widgets to Life*, during the Widget Exploration
    app. We do it this way because we only have one button in the layout, and it seems
    sensible and more compact than implementing the more complicated `OnClickListener`
    interface alternative (as we did for the Java Meet UI demo app in [*Chapter 12*](B16773_12_ePub_RK.xhtml#_idTextAnchor218),
    *The Stack, the Heap, and the Garbage Collector*).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在切换到`MainActivity.java`标签，我们将使用匿名类处理对这个新按钮的点击，就像我们在[*第13章*](B16773_13_ePub_RK.xhtml#_idTextAnchor228)中的*匿名类
    - 让Android小部件活跃*中的Widget Exploration应用程序中所做的那样。我们这样做是因为布局中只有一个按钮，这似乎比实现更复杂的`OnClickListener`接口替代方案更合理和更紧凑（就像我们在[*第12章*](B16773_12_ePub_RK.xhtml#_idTextAnchor218)中为Java
    Meet UI演示应用程序所做的那样，*堆栈、堆和垃圾收集器*）。
- en: 'Notice, in the following code block, that the anonymous class is exactly the
    same type that we previously implemented an interface for. Add this code to the
    `onCreate` method:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在以下代码块中，匿名类与我们先前为其实现了接口的类型完全相同。将此代码添加到`onCreate`方法中：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following `import` statements are needed for this code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`import`语句是此代码所需的：
- en: '`import android.view.View;`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.view.View;`'
- en: '`import android.widget.Button;`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.widget.Button;`'
- en: Notice that the only thing that happens in the code is that the `onClick` method
    creates a new instance of `MyDialog` and calls its `show` method. This, unsurprisingly,
    will show our dialog window just as we configured it in the `MyDialog` class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码中唯一发生的事情是`onClick`方法创建了`MyDialog`的一个新实例，并调用了它的`show`方法。毫不奇怪，这将显示我们的对话框窗口，就像我们在`MyDialog`类中配置的那样。
- en: 'The `show` method needs a reference to `FragmentManager`, which we can get
    with `getSupportFragmentManager`. This is the class that tracks and controls all
    `Fragment` instances for an activity. We also pass in an identifier: `"123"`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`show`方法需要一个对`FragmentManager`的引用，我们可以使用`getSupportFragmentManager`来获取。这是跟踪和控制活动的所有`Fragment`实例的类。我们还传入一个标识符：“123”。'
- en: More details on the `FragmentManager` will be revealed when we look more closely
    at fragments. We will do so in the *Android Fragments* section in [*Chapter 20*](B16773_20_ePub_RK.xhtml#_idTextAnchor345),
    *Drawing Graphics*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更仔细地查看片段时，将会透露有关`FragmentManager`的更多细节。我们将在[*第20章*](B16773_20_ePub_RK.xhtml#_idTextAnchor345)的*Android片段*部分进行。*绘图图形*。
- en: Note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The reason we use the `getSupportFragmentManager` method is that we are supporting
    older devices by extending `AppCompatActivity`. If we simply extended `Activity`,
    then we could use the `getFragmentManager` class. The downside is that the app
    wouldn't run on as many devices.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`getSupportFragmentManager`方法的原因是，我们通过扩展`AppCompatActivity`来支持旧设备。如果我们简单地扩展`Activity`，那么我们可以使用`getFragmentManager`类。缺点是应用程序将无法在许多设备上运行。
- en: 'Now we can run the app and admire our new dialog window, which appears when
    we click on the button in the layout. Notice that clicking on either of the buttons
    in the dialog window will close it. This is the default behavior. The following
    screenshot shows our dialog in action on the Pixel C tablet emulator:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行应用程序，并欣赏我们的新对话框窗口，当我们点击布局中的按钮时它会出现。请注意，单击对话框窗口中的任一按钮都将关闭它。这是默认行为。以下截图显示了我们的对话框在Pixel
    C平板模拟器上的运行情况：
- en: '![Figure 14.01 – Dialog in action'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.01 - 对话框在运行中'
- en: '](img/Figure_14.01_B16773.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.01_B16773.jpg)'
- en: Figure 14.01 – Dialog in action
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.01 - 对话框在运行中
- en: Next, we will make two more classes that implement dialogs, as part of the first
    phase of our multi-chapter Note to Self app. We will learn that a dialog window
    can have almost any layout we choose and that we don't have to rely on simple
    layouts like those that the `Dialog.Builder` class gave us.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将制作另外两个实现对话框的类，作为我们多章节的*Note to Self*应用的第一阶段。我们将了解到对话框窗口几乎可以有我们选择的任何布局，而不必依赖于`Dialog.Builder`类给我们的简单布局。
- en: The Note to Self app
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*Note to Self*应用程序'
- en: Welcome to the first of three major apps that we will implement in this book.
    When we carry out these projects, we will execute them more professionally than
    the smaller apps. We will use Android naming conventions, string resources, and
    proper encapsulation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们将在本书中实施的三个主要应用程序中的第一个。当我们执行这些项目时，我们将比较专业地执行它们。我们将使用Android命名约定、字符串资源和适当的封装。
- en: Sometimes, these things can be overkill when you are trying to learn a new Android/Java
    topic. However, they are useful, and it is important to start using them as soon
    as possible in real projects. Eventually, they become second nature, and the quality
    of our apps will benefit.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当您试图学习新的Android/Java主题时，这些东西可能会有些过度。然而，它们是有用的，尽快在真实项目中开始使用它们是很重要的。最终，它们会变得自然而然，我们的应用程序质量会受益。
- en: Using naming conventions and string resources
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命名约定和字符串资源
- en: In [*Chapter 3*](B16773_03_ePub_RK.xhtml#_idTextAnchor064), *Exploring Android
    Studio and the Project Structure*, we talked about using string resources instead
    of hardcoding text in our layout files. There are a few benefits to doing things
    this way, but it is also relatively long-winded.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B16773_03_ePub_RK.xhtml#_idTextAnchor064)中，*探索Android Studio和项目结构*，我们讨论了在布局文件中使用字符串资源而不是硬编码文本。这样做有一些好处，但也相对冗长。
- en: As this is our first real-world project, it would be a good time to do things
    the right way so that we can get the experience of doing so. If you want a quick
    refresher on the benefits of string resources, check back to [*Chapter 3*](B16773_03_ePub_RK.xhtml#_idTextAnchor064),
    *Exploring Android Studio and the Project Structure*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们的第一个真实项目，现在是一个很好的时机以正确的方式做事，这样我们就可以获得这样做的经验。如果您想快速了解字符串资源的好处，请返回[*第3章*](B16773_03_ePub_RK.xhtml#_idTextAnchor064)，*探索Android
    Studio和项目结构*。
- en: Naming conventions are the conventions or rules used for naming the variables,
    methods, and classes in our code. Throughout this book, we have loosely applied
    Android's naming conventions. As this is our first real-world app, we will be
    slightly stricter in applying these naming conventions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 命名约定是我们代码中用于命名变量、方法和类的约定或规则。在本书中，我们已经宽松地应用了Android的命名约定。由于这是我们的第一个真实应用程序，我们将在应用这些命名约定时稍微严格一些。
- en: Most notably, when a variable is a member of a class, we will prefix the name
    with a lowercase `m`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 特别要注意的是，当变量是类的成员时，我们将使用小写的`m`作为前缀。
- en: Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information about Android's naming conventions and code styles
    at https://source.android.com/source/code-style.html.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在https://source.android.com/source/code-style.html找到有关Android命名约定和代码风格的更多信息。
- en: How to get the code files for the Note to Self app
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何获取“Note to Self”应用程序的代码文件
- en: 'The fully completed app, including all the code and resources, can be found
    in the [*Chapter 18*](B16773_18_ePub_RK.xhtml#_idTextAnchor320)`/Note to self`
    folder within the download bundle. As we are implementing this app over the next
    five chapters, it will probably be useful to view the part-completed, runnable
    app at the end of every chapter as well. The part-completed runnable apps and
    all their associated code and resources can be found in their respective folders:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序，包括所有代码和资源，可以在[*第18章*](B16773_18_ePub_RK.xhtml#_idTextAnchor320)`/Note
    to self`文件夹中找到下载包中。由于我们将在接下来的五章中实现此应用程序，因此在每章结束时查看部分完成的可运行应用程序可能会有所帮助。部分完成的可运行应用程序及其所有相关代码和资源可以在各自的文件夹中找到：
- en: '[*Chapter 14*](B16773_14_ePub_RK.xhtml#_idTextAnchor249)`/Note to self`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第14章*](B16773_14_ePub_RK.xhtml#_idTextAnchor249)`/Note to self`'
- en: '[*Chapter 16*](B16773_16_ePub_RK.xhtml#_idTextAnchor285)`/Note to self`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第16章*](B16773_16_ePub_RK.xhtml#_idTextAnchor285)`/Note to self`'
- en: '[*Chapter 17*](B16773_17_ePub_RK.xhtml#_idTextAnchor300)`/Note to self`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第17章*](B16773_17_ePub_RK.xhtml#_idTextAnchor300)`/Note to self`'
- en: '[*Chapter 18*](B16773_18_ePub_RK.xhtml#_idTextAnchor320)`/Note to self`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第18章*](B16773_18_ePub_RK.xhtml#_idTextAnchor320)`/Note to self`'
- en: Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is no Note to Self code in [*Chapter 15*](B16773_15_ePub_RK.xhtml#_idTextAnchor267),
    *Arrays Maps, and Random Numbers*. This is because, even though we will learn
    about topics we use in Note to Self, we won't make any changes until [*Chapter
    16*](B16773_16_ePub_RK.xhtml#_idTextAnchor285), *Adapters and Recyclers*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第15章*](B16773_15_ePub_RK.xhtml#_idTextAnchor267)中没有“Note to Self”代码，*数组映射和随机数*。这是因为，即使我们将学习“Note
    to Self”中使用的主题，我们也不会在[*第16章*](B16773_16_ePub_RK.xhtml#_idTextAnchor285)中进行任何更改，*适配器和回收器*。'
- en: If you are following along and intend to build the Note to Self app from start
    to finish, we will build a project simply called `Note to self`. However, there
    is still nothing stopping you from dipping into the code files of the projects
    from each chapter to do a bit of copying and pasting at any time. Just be aware
    that at various points in the instructions, you will be asked to remove or replace
    the occasional line of code from a previous chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在跟着做，并打算从头到尾构建“Note to Self”应用程序，我们将构建一个名为`Note to self`的项目。但是，这并不妨碍您随时查看每章项目的代码文件，进行一些复制和粘贴。只是要注意，在说明的各个时间点，您将被要求删除或替换前一章的偶尔一行代码。
- en: So, even if you are copying and pasting more than you are typing in code, be
    sure to read the instructions in full, and refer to the code in the book for extra
    comments that might be useful.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使您复制和粘贴的次数多于编写代码的次数，请务必全文阅读说明，并参考书中的代码，以获取可能有用的额外注释。
- en: In each chapter, the code will be presented as if you have completed the last
    chapter in full, showing code from earlier chapters, where necessary, as useful
    context for our new code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一章中，代码将被呈现为如果您已经完全完成了上一章，将显示来自早期章节的代码，必要时作为我们新代码的有用上下文。
- en: Each chapter will not be solely devoted to the Note to Self app – we will learn
    about other, usually related, things and build some smaller/simpler apps as well.
    So, when we come to the Note to Self implementation, we will, in theory, be prepared
    for it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每一章都不会完全致力于“Note to Self”应用程序 - 我们将学习其他通常相关的事物，并构建一些更小/更简单的应用程序。因此，当我们开始“Note
    to Self”实现时，理论上我们将为此做好准备。
- en: The completed app
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成的应用程序
- en: The following screenshots are from the completed app. It will, of course, look
    slightly different at the various stages of development. Where necessary, we will
    refer to more screenshots either as a reminder or to see the differences throughout
    the development process.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图来自已完成的应用程序。当然，在开发的各个阶段，它看起来会略有不同。必要时，我们将参考更多屏幕截图，作为提醒或查看开发过程中的差异。
- en: 'The completed app will allow the user to tap on the floating action button
    in the lower-right corner of the app to open a dialog window to add a new note.
    The following screenshot shows this feature highlighted:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的应用程序将允许用户点击应用程序右下角的浮动操作按钮，以打开对话框窗口添加新的便签。以下屏幕截图显示了此功能的突出显示：
- en: '![Figure 14.02 – Floating action button'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.02 - 浮动操作按钮'
- en: '](img/Figure_14.02_B16773.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.02_B16773.jpg)'
- en: Figure 14.02 – Floating action button
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.02 - 浮动操作按钮
- en: On the left, you can view the button to tap on, and on the right, you can view
    the dialog window where the user can add a new note.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，您可以查看要点击的按钮，在右侧，您可以查看用户可以添加新便签的对话框窗口。
- en: 'Eventually, as the user adds more notes, they will have a list of all the notes
    they have added on the main screen of the app, as shown in the following screenshot.
    The user can select whether the note is **Important**, an **Idea**, and/or a **Todo**:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，随着用户添加更多的笔记，他们将在应用程序的主屏幕上拥有所有已添加的笔记的列表，如下屏幕截图所示。用户可以选择笔记是**重要**，**想法**和/或**待办事项**：
- en: '![Figure 14.03 – Notes on the main screen'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.03 –主屏幕上的笔记'
- en: '](img/Figure_14.03_B16773.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.03_B16773.jpg)'
- en: Figure 14.03 – Notes on the main screen
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.03 –主屏幕上的笔记
- en: 'You will be able to scroll down the list and tap on a note to see it shown
    in another dialog window that is dedicated to that note. The following screenshot
    shows a dialog window displaying a note:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您将能够滚动列表并点击一个笔记，以在专门用于该笔记的另一个对话框窗口中查看它。以下屏幕截图显示了显示笔记的对话框窗口：
- en: '![Figure 14.04 – Display of the selected note'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.04 –显示所选笔记'
- en: '](img/Figure_14.04_B16773.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.04_B16773.jpg)'
- en: Figure 14.04 – Display of the selected note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.04 –显示所选笔记
- en: 'There will also be a simple (that is, very simple) **Settings** screen, which
    will be accessible from the menu. It will allow the user to configure whether
    the note list is formatted with a dividing line. Here is the **Settings** menu
    option in action:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 还将有一个简单（即非常简单）的**设置**屏幕，可以从菜单中访问。它将允许用户配置笔记列表是否以分隔线格式化。以下是**设置**菜单选项的操作：
- en: '![Figure 14.05 –Settings menu option'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.05 –设置菜单选项'
- en: '](img/Figure_14.05_B16773.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.05_B16773.jpg)'
- en: Figure 14.05 –Settings menu option
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.05 –设置菜单选项
- en: Now that we know exactly what we are going to build, we can go ahead and start
    to implement it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们确切地知道我们要构建什么，我们可以继续并开始实施它。
- en: Building the project
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建项目
- en: Let's create our new project now. Use the Basic Activity template. As we discussed
    in [*Chapter 3*](B16773_03_ePub_RK.xhtml#_idTextAnchor064), *Exploring Android
    Studio and the Project Structure*, this template will generate a simple menu and
    a floating action button, which are both used in this project. Call the project
    `Note to Self`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建我们的新项目。使用基本活动模板。正如我们在[*第3章*](B16773_03_ePub_RK.xhtml#_idTextAnchor064)中讨论的那样，*探索Android
    Studio和项目结构*，此模板将生成一个简单的菜单和一个浮动操作按钮，这两者都在此项目中使用。将项目命名为`Note to Self`。
- en: Preparing the string resources
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备字符串资源
- en: Here, we will create all the string resources that we will refer to from our
    layout files instead of hardcoding the `text` property of the UI widgets, which
    we have been doing up until now.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建所有的字符串资源，我们将从布局文件中引用它们，而不是硬编码UI小部件的`text`属性，这是我们一直在做的。
- en: 'To get started, open the `strings.xml` file from the `res/values` folder in
    the project explorer. You will see the autogenerated resources. Add the following
    highlighted string resources that we will use in our app throughout the rest of
    the project. Add the code before the closing `</resources>` tag:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请在项目资源管理器中的`res/values`文件夹中打开`strings.xml`文件。您将看到自动生成的资源。添加以下突出显示的字符串资源，我们将在项目的其余部分中在应用程序中使用它们。在闭合的`</resources>`标签之前添加以下代码：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, notice that each string resource has a `name` attribute
    that is unique and distinguishes it from all the others while also providing a
    meaningful and, hopefully, memorable clue as to the actual string value it represents.
    It is these name values that we will use to refer to from within our layout files.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，请注意每个字符串资源都有一个唯一的`name`属性，它使其与所有其他字符串资源区分开，并提供一个有意义的、有希望的、可记住的线索，以表示它所代表的实际字符串值。正是这些名称值，我们将在布局文件中引用。
- en: We will not need to revisit this file for the rest of the app.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不需要再访问这个文件了。
- en: Coding the Note class
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Note类
- en: This is the fundamental data structure of the app. It is a class that we will
    write ourselves from scratch and has all the member variables we need to represent
    one of the user's notes. In [*Chapter 15*](B16773_15_ePub_RK.xhtml#_idTextAnchor267),
    *Arrays Maps, and Random Numbers*, we will learn some new Java in order to understand
    how we can let the user have dozens, hundreds, or even thousands of notes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序的基本数据结构。这是一个我们将从头开始编写的类，它具有我们需要表示用户笔记之一的所有成员变量。在[*第15章*](B16773_15_ePub_RK.xhtml#_idTextAnchor267)中，*数组映射和随机数*，我们将学习一些新的Java，以便了解如何让用户拥有数十、数百甚至数千条笔记。
- en: Create a new class by right-clicking on the folder with the same name as your
    package. As expected, it is the one that also contains the `MainActivity.java`
    file. Select `Note`. Press the *Enter* key to create the class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过右键单击与您的包名称相同的文件夹来创建一个新类。预期的是，它也包含`MainActivity.java`文件。选择`Note`。按下*Enter*键创建类。
- en: 'Add the following highlighted code to the new `Note` class:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下突出显示的代码添加到新的`Note`类中：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that our member variable names are prefixed with `m` as per the Android
    convention. Additionally, we don't want any other class to access these variables
    directly, so they are all declared `private`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，根据Android约定，我们的成员变量名都以`m`为前缀。另外，我们不希望任何其他类直接访问这些变量，所以它们都声明为`private`。
- en: 'Therefore, we will need a getter and a setter method for each of our members.
    Add the following getter and setter methods to the `Note` class:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将需要为我们的每个成员添加一个getter和一个setter方法。将以下getter和setter方法添加到`Note`类中：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is quite a lot of code in this preceding list, but there is nothing complicated.
    Each of the methods has `public` access specified, so it can be used by any other
    class that has a reference to an object of the `Note` type. Furthermore, for each
    variable, there is a method with the name of `get...` and a method with the name
    of `set...`. The getters for the Boolean type variables are named `is...`. This
    is a logical name if you think about it because the returned answer will be either
    true or false.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述列表中有相当多的代码，但没有什么复杂的。每个方法都指定了`public`访问权限，因此可以被任何具有对`Note`类型对象的引用的其他类使用。此外，对于每个变量，都有一个名为`get...`的方法和一个名为`set...`的方法。布尔类型变量的getter命名为`is...`。如果你仔细想想，这是一个合乎逻辑的名字，因为返回的答案要么是true，要么是false。
- en: Each of the getters simply returns the value of the related variable. And each
    of the setters sets the value of the related variable to whatever value is passed
    into the method.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每个getter都只返回相关变量的值。每个setter都将相关变量的值设置为传递给方法的任何值。
- en: Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In fact, we should really enhance our setters a little to do a bit of checking
    to make sure that the values passed in are within reasonable limits. For example,
    we might want to check on and enforce a maximum or minimum length for `String
    mTtile` and `String mDescription`. This is left as an exercise for the reader
    to come back to.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们应该稍微增强我们的setter，以确保传入的值在合理范围内。例如，我们可能希望检查并强制执行`String mTtile`和`String
    mDescription`的最大或最小长度。这留作读者的练习回来完成。
- en: Let's design the layout of the two dialog windows.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设计这两个对话框窗口的布局。
- en: Implementing the dialog designs
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施对话框设计
- en: 'Now, we will do something that we have done many times before, but this time,
    for a new reason. As we know, we will have two dialog windows: one for the user
    to enter a new note and one for the user to view a note of their choice.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将做一些我们以前做过很多次的事情，但这次是出于新的原因。正如我们所知，我们将有两个对话框窗口：一个用于用户输入新的笔记，另一个用于查看他们选择的笔记。
- en: We can design the layouts of these two dialog windows in the same way that we
    designed all our previous layouts. When we come to create the Java code for the
    `FragmentDialog` classes, we will then learn how to incorporate these layouts.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以与我们设计所有先前布局相同的方式设计这两个对话框窗口的布局。当我们开始为`FragmentDialog`类创建Java代码时，我们将学习如何将这些布局结合起来。
- en: 'First, let''s add a layout for our "new note" dialog. Perform the following
    steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为“新笔记”对话框添加一个布局。执行以下步骤：
- en: Right-click on the `dialog_new_note` for the **File name:** field.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击“dialog_new_note”以选择**文件名：**字段。
- en: Left-click on `ConstraintLayout` type, by default, as its root element.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，左键单击`ConstraintLayout`类型，作为其根元素。
- en: Refer to the target design, in the following diagram, as you follow the rest
    of these instructions. I have Photoshopped the finished layout, including the
    constraints that we will soon autogenerate, next to the layout with the constraints
    hidden for extra clarity:![Figure 14.06 – Finished layout for new note
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按照以下说明进行操作时，请参考目标设计图。我已经使用Photoshop完成了布局，包括我们即将自动生成的约束条件，以及隐藏约束条件以增加清晰度的布局：![图14.06
    – 新笔记的完成布局
- en: '](img/Figure_14.06_B16773.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.06_B16773.jpg)'
- en: Figure 14.06 – Finished layout for new note
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.06 – 新笔记的完成布局
- en: Drag and drop a **Plain Text** widget (from the **Text** category) to the upper-left
    corner of the layout. Then, add another **Plain Text** widget below it. Don't
    worry about any of the attributes for now.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**文本**类别中拖放一个**纯文本**小部件到布局的左上角。然后，在其下方添加另一个**纯文本**小部件。暂时不用担心任何属性。
- en: Drag and drop three **CheckBox** widgets from the **Button** category, one below
    the other. Look at the earlier reference diagram for guidance. Again, don't worry
    about any attributes for now.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**按钮**类别中拖放三个**复选框**小部件，一个放在另一个下面。查看之前的参考图以获得指导。现在，暂时不用担心任何属性。
- en: Drag and drop two **Buttons** onto the layout. The first will go directly below
    the last **CheckBox** widget from the previous step; the second will fall horizontally,
    in line with the first **Button**, but to the right of the layout.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个**按钮**拖放到布局中。第一个将直接放在上一步中最后一个**复选框**小部件的下方；第二个将水平放置，与第一个**按钮**对齐，但在布局的右侧。
- en: Tidy up the layout so that it looks as close to the reference diagram as possible.
    Then, click on the **Infer Constraints** button to fix the positions you have
    chosen.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整理布局，使其尽可能接近参考设计图。然后，点击**推断约束条件**按钮来修复您选择的位置。
- en: 'Now, we can set up all of our `text`, `id`, and `hint` properties. You can
    do this by using the values from the following table. Remember that we are using
    our string resources for the `text` and `hint` properties:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以设置所有的`text`、`id`和`hint`属性。您可以使用以下表格中的值来完成这一步。请记住，我们正在使用字符串资源来为`text`和`hint`属性赋值：
- en: Note
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'When you edit the first `id` property (which we will do next), you might be
    shown a pop-up window asking for a confirmation of your changes. Check the **Don''t
    ask again during this session** box and click on **Yes** to continue:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编辑第一个`id`属性（接下来我们将要做的）时，可能会弹出一个窗口询问您是否确认更改。勾选**本次会话中不再询问**框，然后点击**是**继续：
- en: '![Figure 14.07 – Confirmation of changes'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.07 – 确认更改'
- en: '](img/Figure_14.07_B16773.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.07_B16773.jpg)'
- en: Figure 14.07 – Confirmation of changes
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.07 – 确认更改
- en: '![](img/B16773_14_Table_01.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16773_14_Table_01.jpg)'
- en: We now have an organized layout that is ready for our Java code to display.
    Make sure that you keep the `id` property values of the different widgets in mind.
    We will see them in action when we write our Java code. The important thing is
    that our layout looks nice and has an `id` property value for every relevant item,
    so we can get a reference to it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个有组织的布局，准备好供我们的Java代码显示。确保您记住不同小部件的`id`属性值。当我们编写Java代码时，我们将看到它们的作用。重要的是，我们的布局看起来很好，并且每个相关项目都有一个`id`属性值，这样我们就可以引用它。
- en: 'Let''s create the layout for the "show note" dialog:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建“显示笔记”对话框的布局：
- en: Right-click on the `dialog_show_note` for the **File name:** field.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击“dialog_show_note”以选择**文件名：**字段。
- en: Left-click on `ConstraintLayout` type as its root element by default.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，左键单击`ConstraintLayout`类型以选择其根元素。
- en: Refer to the target design, in the following diagram, as you follow the rest
    of these instructions. I have Photoshopped the finished layout, including the
    constraints we will soon autogenerate, next to the layout with the constraints
    hidden for extra clarity:![Figure 14.08 – Finished layout for the show note dialog
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按照以下说明进行操作时，请参考目标设计图。我已经使用Photoshop完成了布局，包括我们即将自动生成的约束条件，以及隐藏约束条件以增加清晰度的布局：![图14.08
    – 显示笔记对话框的完成布局
- en: '](img/Figure_14.08_B16773.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.08_B16773.jpg)'
- en: Figure 14.08 – Finished layout for the show note dialog
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.08 - 显示笔记对话框的完成布局
- en: First of all, drag and drop three **TextView** widgets so that they are vertically
    aligned across the top of the layout.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，拖放三个**TextView**小部件，使它们在布局顶部垂直对齐。
- en: Next, drag and drop another `TextView` widgets.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，拖放另一个`TextView`小部件。
- en: Add another **TextView** widget just below the previous widget but over to the
    left.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一个小部件的下方但靠左添加另一个**TextView**小部件。
- en: Now add a **Button** horizontally in the center, but near the bottom of the
    layout.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在布局的中心水平放置一个**Button**，但靠近底部。
- en: Tidy up the layout so that it looks as close to the reference diagram as possible,
    Then, click on the **Infer Constraints** button to fix the positions you have
    chosen.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整理布局，使其尽可能接近参考图表，然后点击**Infer Constraints**按钮来修复你选择的位置。
- en: 'Configure the attributes from the following table:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置以下表中的属性：
- en: '![](img/B16773_14_Table_02.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16773_14_Table_02.jpg)'
- en: Note
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You might want to tweak the final positions of some of the UI elements by dragging
    them about slightly since we adjusted their size and contents. First, click on
    `btnOK` to the button ID there might be a dialog box saying this ID already exist,
    click on **Continue** to ignore the pop up.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要通过稍微拖动它们来调整一些UI元素的最终位置，因为我们调整了它们的大小和内容。首先，点击`btnOK`到按钮ID，可能会弹出一个对话框说这个ID已经存在，点击**Continue**来忽略弹出窗口。
- en: Now we have a layout that we can use to show a note to the user. Notice that
    we get to reuse some string resources. The bigger our apps get, the more beneficial
    it is to do things in this way.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个布局，可以用来向用户显示一个笔记。请注意，我们可以重复使用一些字符串资源。我们的应用程序变得越来越大，以这种方式做事情就越有益处。
- en: Coding the dialog boxes
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写对话框
- en: Now we have a design for both of our dialog windows ("show note" and "new note"),
    we can use what we know about the `FragmentDialog` class to implement a class
    to represent each of the dialog windows that the user can interact with.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的两个对话框窗口（“显示笔记”和“新笔记”）设计好了，我们可以利用我们对`FragmentDialog`类的了解来实现一个类来代表用户可以交互的每个对话框窗口。
- en: We will start with the "new note" screen.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从“新笔记”屏幕开始。
- en: Coding the DialogNewNote class
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写DialogNewNote类
- en: Create a new class by right-clicking on the project folder that has all the
    `.java` files and choose `DialogNewNote`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过右键单击包含所有`.java`文件的项目文件夹，选择`DialogNewNote`来创建一个新类。
- en: 'First, change the class declaration and extend `DialogFragment`. Then, override
    the `onCreateDialog` method, which is where all the rest of the code in this class
    will go. To achieve this, make your code is the same as the following snippet:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更改类声明并扩展`DialogFragment`。然后，重写`onCreateDialog`方法，这是这个类中所有其余代码的位置。为了实现这一点，确保你的代码与以下代码片段相同：
- en: '[PRE11]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You will also need to add these new imports:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要添加这些新的导入：
- en: '`import androidx.fragment.app.DialogFragment;`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`import androidx.fragment.app.DialogFragment;`'
- en: '`import android.app.Dialog;`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.app.Dialog;`'
- en: '`import android.os.Bundle;`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.os.Bundle;`'
- en: We temporarily have an error in the new class because we need a `return` statement;
    however, we will get to that in just a moment.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暂时在新类中有一个错误，因为我们需要一个`return`语句；然而，我们马上就会解决这个问题。
- en: In the next block of code, first, we declare and initialize an `AlertDialog.Builder`
    object, in the same way we did earlier when creating dialog windows. However,
    this time, we will rely on this object far less than we previously did.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一段代码中，首先，我们声明并初始化一个`AlertDialog.Builder`对象，方式与我们之前创建对话框窗口时一样。然而，这一次，我们将比以前更少地依赖这个对象。
- en: Next, we initialize a `LayoutInflater` object, which we will use to inflate
    our XML layout. By "inflate," we are simply referring to how we turn our XML layout
    into a Java object. Once this has been done, we can then access all our widgets
    in the usual way. We can think of the `inflater.inflate` method as replacing the
    `setContentView` method for our dialog. Then, in the second line, we do just that
    using the `inflate` method.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化一个`LayoutInflater`对象，我们将使用它来填充我们的XML布局。通过“填充”，我们只是指的是如何将我们的XML布局转换为Java对象。一旦完成了这一步，我们就可以以通常的方式访问所有的小部件。我们可以将`inflater.inflate`方法视为替换对话框的`setContentView`方法。然后，在第二行，我们使用`inflate`方法做到了这一点。
- en: 'Add the three lines of code that we just discussed:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 添加我们刚刚讨论的三行代码：
- en: '[PRE12]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To use the new classes in the preceding three lines of code, you will need
    to add the following `import` statements:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用前面三行代码中的新类，你需要添加以下`import`语句：
- en: '`import androidx.appcompat.app.AlertDialog;`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`import androidx.appcompat.app.AlertDialog;`'
- en: '`import android.view.View;`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.view.View;`'
- en: '`import android.view.LayoutInflater;`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.view.LayoutInflater;`'
- en: We now have a `View` object, called `dialogView`, that has all of the UI elements
    from our `dialog_new_note.xml` layout file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个名为`dialogView`的`View`对象，它包含了我们的`dialog_new_note.xml`布局文件中的所有UI元素。
- en: Immediately after the previous block of code, we will add the following block
    of code, which we explain next.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段代码之后，我们将添加下面的代码块，接下来我们将解释。
- en: This code will get a reference to each of the UI widgets in the usual way. Many
    of the objects in the following code are declared as `final` because they will
    be used in an anonymous class, and as we learned previously, this is necessary.
    Remember that it is the reference that is `final` (that is, it cannot change);
    we can still change the objects on the heap to which they are a reference.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '这段代码将以通常的方式获取每个UI小部件的引用。以下代码中的许多对象被声明为`final`，因为它们将被用于匿名类，正如我们之前学到的那样，这是必要的。请记住，它是引用是`final`的（也就是说，它不能改变）；我们仍然可以改变它们指向的堆上的对象。 '
- en: 'Add the following code just after the previous block of code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段代码之后添加以下代码：
- en: '[PRE13]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Add the following `import` code statements to make the code that you just added
    error-free:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下`import`代码语句，使你刚刚添加的代码无错误：
- en: '`import android.widget.Button;`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.widget.Button;`'
- en: '`import android.widget.CheckBox;`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.widget.CheckBox;`'
- en: '`import android.widget.EditText;`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.widget.EditText;`'
- en: In the next code block, we will set the message of the dialog using `builder`,
    which is our builder instance. Then, we will write an anonymous class to handle
    clicks on the `btnCancel` button. In the overridden `onClick` method, we will
    simply call `dismiss()`, which is a public method of `DialogFragment`, to close
    the dialog window. This is just what we need if the user clicks on **Cancel**.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码块中，我们将使用`builder`（我们的构建器实例）设置对话框的消息。然后，我们将编写一个匿名类来处理对`btnCancel`按钮的点击。在重写的`onClick`方法中，我们将简单地调用`dismiss()`，这是`DialogFragment`的一个公共方法，用于关闭对话框窗口。如果用户单击**取消**，这正是我们需要的。
- en: 'Add the following code that we have just discussed:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 添加我们刚讨论过的以下代码：
- en: '[PRE14]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, we will add an anonymous class to handle what happens when the user clicks
    on the `btnOK`).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个匿名类来处理用户单击`btnOK`时发生的情况。
- en: First, we create a new `Note` instance, called `newNote`. Then, we set each
    of the member variables from `newNote` to the appropriate contents of the form.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个名为`newNote`的新`Note`实例。然后，我们将`newNote`的每个成员变量设置为表单的适当内容。
- en: After this, we do something new. We create a reference to the `MainActivity`
    class using the `getActivity` method. Then, we use that reference to call the
    `createNewNote` method in `MainActivity`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们做了一些新的事情。我们使用`getActivity`方法创建对`MainActivity`类的引用。然后，我们使用该引用调用`MainActivity`中的`createNewNote`方法。
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we have not written this `createNewNote` method yet, and it will show
    up as an error until we do so later in this chapter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还没有编写`createNewNote`方法，直到本章后面我们才会这样做。
- en: The argument sent in this method is our newly initialized `newNote` object.
    This has the effect of sending the user's new note back to `MainActivity`. We
    will learn what to do with this later on in the chapter.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到此方法的参数是我们新初始化的`newNote`对象。这将使用户的新笔记发送回`MainActivity`。我们将在本章后面学习如何处理这个。
- en: Finally, we call `dismiss` to close the dialog window.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`dismiss`来关闭对话框窗口。
- en: 'Add the following code that we have been discussing after the preceding code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码之后添加我们刚讨论过的以下代码：
- en: '[PRE15]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That's our first dialog done. We haven't wired it up to appear in `MainActivity`
    yet, and we still need to implement the `createNewNote` method too. We will do
    this straight after we create the next dialog.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个对话框。我们还没有将其连接到`MainActivity`中，我们还需要实现`createNewNote`方法。我们将在创建下一个对话框后立即执行此操作。
- en: Coding the DialogShowNote class
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写DialogShowNote类
- en: Create a new class by right-clicking on the project folder that contains all
    of the `.java` files and choose `DialogShowNote`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通过右键单击包含所有`.java`文件的项目文件夹并选择`DialogShowNote`来创建一个新类。
- en: First, change the class declaration and extend `DialogFragment`. Then, override
    the `onCreateDialog` method. As most of the code for this class goes in the `onCreateDialog`
    method, implement the signature and empty body, as shown in the following code
    snippet, and we will revisit it later.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更改类声明并扩展`DialogFragment`。然后，重写`onCreateDialog`方法。由于该类的大部分代码都在`onCreateDialog`方法中，因此实现签名和空主体，如下面的代码片段所示，我们稍后会重新访问它。
- en: Notice that we declare a member variable, `mNote`, of the `Note` type. Add the
    `sendNoteSelected` method and the one line of code that initializes `mNote`. This
    method will be called by `MainActivity`, and it will pass to the `Note` object
    the user has clicked on.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们声明了一个`Note`类型的成员变量`mNote`。添加`sendNoteSelected`方法和初始化`mNote`的一行代码。此方法将由`MainActivity`调用，并将用户单击的`Note`对象传递给它。
- en: 'Add the code we just discussed. Then, we can view and code the details of `onCreateDialog`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 添加我们刚讨论过的代码。然后，我们可以查看并编写`onCreateDialog`的细节：
- en: '[PRE16]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'At this point, you will need to import the following classes:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您需要导入以下类：
- en: '`import android.app.Dialog;`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.app.Dialog;`'
- en: '`import android.os.Bundle;`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.os.Bundle;`'
- en: '`import androidx.fragment.app.DialogFragment;`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`import androidx.fragment.app.DialogFragment;`'
- en: Next, we declare and initialize an instance of `AlertDialog.Builder`. Additionally,
    as we did for the `DialogNewNote` class, we declare and initialize a `LayoutInflater`
    instance and then use it to create a `View` object that has the layout for the
    dialog. In this case, it is the layout from `dialog_show_note.xml`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明并初始化了一个`AlertDialog.Builder`的实例。另外，就像我们对`DialogNewNote`类所做的那样，我们声明并初始化了一个`LayoutInflater`实例，然后使用它来创建一个具有对话框布局的`View`对象。在这种情况下，它是来自`dialog_show_note.xml`的布局。
- en: Finally, in the following code, we get a reference to each of the UI widgets
    and set the `text` attributes to `txtTitle` and `textDescription` from the appropriate
    member variables of `mNote`, which was initialized in the `sendNoteSelected` method.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在以下代码中，我们获取对每个UI小部件的引用，并将`text`属性设置为`mNote`的适当成员变量的`txtTitle`和`textDescription`，该成员变量在`sendNoteSelected`方法中初始化。
- en: 'Add the code that we just discussed to the `onCreateDialog` method:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们刚讨论过的代码添加到`onCreateDialog`方法中：
- en: '[PRE17]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Add the following `import` statements so that all of the classes in the preceding
    code are available:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下`import`语句，以便前面代码中的所有类都可用：
- en: '`import android.view.LayoutInflater;`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.view.LayoutInflater;`'
- en: '`import android.view.View;`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.view.View;`'
- en: '`import android.widget.TextView;`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.widget.TextView;`'
- en: '`import androidx.appcompat.app.AlertDialog;`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`import androidx.appcompat.app.AlertDialog;`'
- en: The following code that we will add is also in the `onCreateDialog` method.
    It checks whether the note being shown is "important" and then shows or hides
    the `txtImportant TextView` accordingly. We then do the same for `txtTodo` and
    `txtIdea`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加的以下代码也在`onCreateDialog`方法中。它检查所显示的笔记是否“重要”，然后相应地显示或隐藏`txtImportant TextView`。然后我们对`txtTodo`和`txtIdea`做同样的事情。
- en: 'Add this code after the previous block of code while you are still in the `onCreateDialog`
    method:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在仍然在`onCreateDialog`方法中时，在前一个代码块之后添加此代码：
- en: '[PRE18]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All we need to do now is `dismiss` (close) the dialog window when the user clicks
    on the `onClick` method simply calls the `dismiss` method, which closes the dialog
    window.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户单击`onClick`方法时，我们只需要`dismiss`（关闭）对话框窗口，该方法简单地调用`dismiss`方法，关闭对话框窗口。
- en: 'Add this code to the `onCreateDialog` method after the previous block of code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个代码块之后，将此代码添加到`onCreateDialog`方法中：
- en: '[PRE19]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Import the `Button` class using this line of code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这行代码导入`Button`类：
- en: '`import android.widget.Button;`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.widget.Button;`'
- en: We now have two dialog windows ready to roll. We just need to add some code
    to the `MainActivity` class to finish the job. First, let's do a bit of project
    housekeeping.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有两个准备就绪的对话框窗口。我们只需要向`MainActivity`类添加一些代码来完成工作。首先，让我们进行一些项目清理。
- en: Removing the unwanted autogenerated fragments
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除不需要的自动生成片段
- en: We will now tidy up the files and structure of our project. Remember that the
    Basic Activity template we used to generate this project has quite a few features.
    Some of these we need, while some we don't. We want the floating action button
    to be in the lower-right corner of the layout, and we want the main menu with
    the `content_main.xml` file, we will delete the reference to the fragment along
    with all of its navigation options.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将整理项目的文件和结构。请记住，我们用于生成此项目的基本活动模板具有许多功能。有些是我们需要的，而有些则不需要。我们希望浮动操作按钮位于布局的右下角，并且希望主菜单与`content_main.xml`文件一起，我们将删除对片段的引用以及其所有导航选项。
- en: Open the `content_main.xml` layout file. In the `content_main.xml` file, find
    the **nav_host_fragment** element. Select it and then press the *Delete* key on
    the keyboard. Now, we have a cleaner UI that is ready for future development.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`content_main.xml`布局文件。在`content_main.xml`文件中，找到**nav_host_fragment**元素。选择它，然后按键盘上的*Delete*键。现在，我们有一个更干净的UI，可以用于未来的开发。
- en: Showing our new dialogs
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示我们的新对话框
- en: 'Open the `MainActivity.java` file. Add a new temporary member variable just
    after the `MainActivity` class declaration. This won''t be in the final app; it
    is so we can test our dialog windows as soon as possible:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`文件。在`MainActivity`类声明之后添加一个新的临时成员变量。这不会出现在最终的应用程序中；这样我们就可以尽快测试我们的对话框窗口：
- en: '[PRE20]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, add this method to the `MainActivity` class so that we can receive a new
    note from the `DialogNewNote` class:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将此方法添加到`MainActivity`类中，以便我们可以从`DialogNewNote`类接收一个新的笔记：
- en: '[PRE21]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To send a note to the `DialogShowNote` method, we need to add a button with
    an ID of `button` to the `content_main.xml` layout file. Open the `content_main.xml`
    layout file.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要将笔记发送到`DialogShowNote`方法，我们需要在`content_main.xml`布局文件中添加一个ID为`button`的按钮。打开`content_main.xml`布局文件。
- en: 'Just so that it is clear what this button is for, we will change its `text`
    attribute to `Show Note`, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚起见，我们将把这个按钮的`text`属性更改为`Show Note`，如下所示：
- en: Drag a button onto the `content_main.xml` layout and configure the `id` property
    as `button` and the `text` property as `Show Note`.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个按钮拖放到`content_main.xml`布局中，并将`id`属性配置为`button`，`text`属性配置为`Show Note`。
- en: Click on the **Infer Constraints** button so that the button stays where you
    put it. The exact position of this button is not important at this stage.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击**推断约束**按钮，使按钮停留在您放置的位置。此时此刻，此按钮的确切位置并不重要。
- en: Note
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Just to clarify, this is a temporary button for testing purposes and will not
    be in the final app. At the end of development, we will be able to click on a
    note's title from a scrolling list.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了澄清，这是一个用于测试目的的临时按钮，不会出现在最终的应用程序中。在开发结束时，我们将能够从滚动列表中点击笔记的标题。
- en: 'In the `onCreate` method, we will set up an anonymous class to handle clicks
    on our temporary button. The code in the `onClick` method will do the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中，我们将设置一个匿名类来处理我们临时按钮的点击。`onClick`方法中的代码将执行以下操作：
- en: Create a new `DialogShowNote` instance that is simply called `dialog`.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`dialog`的新`DialogShowNote`实例。
- en: Call the `sendNoteSelected` method on `dialog` to pass in `mTempNote` as a parameter,
    which is our `Note` object.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`dialog`上调用`sendNoteSelected`方法，将`mTempNote`作为参数传入，这是我们的`Note`对象。
- en: Finally, it will call `show`, which breathes life into our new dialog and reveals
    it to the user.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它将调用`show`，为我们的新对话框注入生命并展示给用户。
- en: 'Add the code that we just described to `onCreate`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们刚刚描述的代码添加到`onCreate`中：
- en: '[PRE22]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Add the `Button` class using this line of code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这行代码添加`Button`类：
- en: '`import android.widget.Button;`'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.widget.Button;`'
- en: 'We can now summon our `DialogShowNote` dialog window at the click of a button.
    Run the app and click on the `DialogShowNote` dialog with the `dialog_show_note.xml`
    layout:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在点击按钮时召唤我们的`DialogShowNote`对话框窗口。运行应用程序，并点击具有`dialog_show_note.xml`布局的`DialogShowNote`对话框：
- en: '![Figure 14.09 – DialogShowNote dialog'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.09 – DialogShowNote对话框'
- en: '](img/Figure_14.09_B16773.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.09_B16773.jpg)'
- en: Figure 14.09 – DialogShowNote dialog
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.09 – DialogShowNote对话框
- en: Admittedly, this is not much to look at considering how much coding we have
    done in this chapter. However, when we get the `DialogNewNote` class working,
    we will be able to see how the `MainActivity` class interacts and shares data
    between the two dialogs.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 承认，考虑到我们在本章中所做的大量编码，这并不是什么了不起的东西。然而，当我们让`DialogNewNote`类工作时，我们将能够看到`MainActivity`类如何在这两个对话框之间交互和共享数据。
- en: Next, let's make the `DialogNewNote` dialog useable.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让`DialogNewNote`对话框可用。
- en: Coding the floating action button
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写浮动操作按钮
- en: This is going to be easy. The floating action button is provided for us in the
    layout. As a reminder, the floating action button is the round icon with an envelope
    image on it, as pictured in the lower-right corner of the preceding screenshot.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这将很容易。浮动操作按钮已经在布局中为我们提供。提醒一下，浮动操作按钮是圆形图标，上面有一个信封图像，就像前面截图的右下角所示。
- en: 'It is in the `activity_main.xml` file. This is the XML code that positions
    and defines its appearance. Notice that just before the code for the floating
    action button, there is a line of code (highlighted) that includes the `content_main.xml`
    file. This currently contains our **Show Note** button and will eventually contain
    our sophisticated scrolling list:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 它在`activity_main.xml`文件中。这是定位和定义其外观的XML代码。请注意，在浮动操作按钮的代码之前，有一行代码（已突出显示）包括`content_main.xml`文件。这目前包含我们的**Show
    Note**按钮，并最终将包含我们复杂的滚动列表：
- en: '[PRE23]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Android Studio has even provided an anonymous class to handle any clicks on
    the floating action button. All we need to do is add some code to the `onClick`
    method of this already provided class, and we can use the `DialogNewNote` class.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio甚至提供了一个匿名类来处理浮动操作按钮上的任何点击。我们只需要向这个已提供的类的`onClick`方法添加一些代码，就可以使用`DialogNewNote`类。
- en: The floating action button is usually used for a core action within an app.
    For example, in an email app, it would probably be used to start a new email.
    Alternatively, in a note-keeping app, it would probably be used to add a new note.
    So, let's do that now.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 浮动操作按钮通常用于应用程序中的核心操作。例如，在电子邮件应用程序中，它可能用于启动新的电子邮件。或者，在笔记应用程序中，它可能用于添加新的笔记。所以，现在让我们这样做。
- en: 'In the `MainActivity.java` file, find the autogenerated code provided by Android
    Studio in the `MainActivity` class of the `onCreate` method. Here it is in its
    entirety:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity.java`文件中，找到Android Studio在`MainActivity`类的`onCreate`方法中提供的自动生成代码。以下是完整的代码：
- en: '[PRE24]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding code snippet, note the highlighted line and delete it. Now,
    add the following code in place of the deleted code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，请注意突出显示的行并将其删除。现在，在删除的代码位置添加以下代码：
- en: '[PRE25]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The new code creates a new dialog window of the `DialogNewNote` variety and
    then shows it to the user.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码创建了一个`DialogNewNote`类型的新对话框窗口，然后显示给用户。
- en: 'We can now run the app. Tap on the floating action button, and add a note that
    is similar to the following screenshot:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行应用程序。点击浮动操作按钮，并添加一个类似于以下截图的笔记：
- en: '![Figure 14.10 – Add new note'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.10 – 添加新笔记'
- en: '](img/Figure_14.10_B16773.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.10_B16773.jpg)'
- en: Figure 14.10 – Add new note
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10 – 添加新笔记
- en: 'Next, we can tap on the **Show Note** button in order to view it in a dialog
    window, as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以点击**显示笔记**按钮，以在对话框中查看它，如下所示：
- en: '![Figure 14.11 – Show note dialog window'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.11 – 显示笔记对话框窗口'
- en: '](img/Figure_14.11_B16773.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.11_B16773.jpg)'
- en: Figure 14.11 – Show note dialog window
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11 – 显示笔记对话框窗口
- en: Note that if you add a second note, it will overwrite the first because we only
    have one `Note` object. We will need to learn some more Java in order to solve
    this problem.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您添加第二个笔记，它将覆盖第一个，因为我们只有一个`Note`对象。我们需要学习更多的Java知识来解决这个问题。
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed and implemented a common UI design with dialog
    windows using the `DialogFragment` class.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论并实现了使用`DialogFragment`类的对话框窗口的常见UI设计。
- en: Then, we went a step further and started the Note to Self app by implementing
    more complicated dialogs that can capture information from the user. We saw that
    the `DialogFragment` class enables us to have any UI we design inside a dialog
    box.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们更进一步，通过实现更复杂的对话框来启动Note to Self应用程序，这些对话框可以从用户那里获取信息。我们看到`DialogFragment`类使我们能够在对话框中设计任何UI。
- en: In the next chapter, we will deal with the obvious problem that the user can
    only have one note. We will solve this problem by exploring Java arrays and their
    close cousin, `ArrayList`, along with another data-related Java class, `Map`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将处理一个明显的问题，即用户只能有一个笔记。我们将通过探索Java数组及其近亲`ArrayList`，以及另一个与数据相关的Java类`Map`来解决这个问题。
