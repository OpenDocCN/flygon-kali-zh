- en: Spring Cloud Overview
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud概述
- en: 'In [Chapter 1](33ddbb93-e658-4d91-97f5-06d6167ef89e.xhtml), *Introduction to
    Microservices*, I mentioned the cloud-native development style and also that Spring
    Cloud helps you in the easy adoption of the best practices associated with this
    concept. The most commonly used best practices have been collected together in
    an interesting initiative called **The Twelve-Factor App**. As you might read
    on their website ([https://12factor.net/](https://12factor.net/)), this is a methodology
    for building **Software as a Service** (**SaaS**) modern applications, which must
    be scalable, easily deployable on cloud platforms, and delivered in the continuous
    deployment process. It is worth being familiar with these principles, especially
    if you are a developer who builds applications running as a service. Spring Boot
    and Spring Cloud provide features and components that make your application compliant
    with *Twelve-Factor rules*. We can distinguish some typical features that the
    most modern distributed systems usually use. Every opinionated framework should
    provide them and there is no difference for Spring Cloud. Those features are as
    follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](33ddbb93-e658-4d91-97f5-06d6167ef89e.xhtml)中，*微服务简介*，我提到了云原生开发风格，以及Spring
    Cloud如何帮助您轻松采用与此概念相关的最佳实践。最常用的最佳实践已经汇集在一个有趣的倡议中，称为**十二要素应用**。正如您可能在他们的网站上所读到的([https://12factor.net/](https://12factor.net/))，这是一种构建**软件即服务**（**SaaS**）现代应用程序的方法，必须具有可扩展性，可以轻松部署在云平台上，并在持续部署过程中交付。熟悉这些原则是值得的，特别是如果您是作为服务运行的应用程序的开发人员。Spring
    Boot和Spring Cloud提供了功能和组件，使您的应用程序符合*十二要素规则*。我们可以区分出大多数现代分布式系统通常使用的一些典型功能。每个有偏见的框架都应该提供它们，对于Spring
    Cloud也是如此。这些功能包括：
- en: Distributed/versioned configuration
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式/版本化配置
- en: Service registration and discovery
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务注册和发现
- en: Routing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由
- en: Service-to-service calls
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务对服务的调用
- en: Load balancing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载平衡
- en: Circuit breakers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器
- en: Distributed messaging
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式消息传递
- en: Beginning with the basics
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从基础开始
- en: 'Let''s go back to the previous chapter for a moment. There I have already described
    in detail the structure of a Spring Boot project. Configuration should be provided
    in YAML or a properties file with the application or the `application-{profile}`
    name. In contrast to a standard Spring Boot application, Spring Cloud is based
    on the configuration taken from a remote server. However, minimal settings are
    needed inside the application; for example, its name and config server address.
    That''s why a Spring Cloud application creates a bootstrap context, which is responsible
    for loading properties from the external sources. Bootstrap properties are added
    with the highest priority and they cannot be overridden by local configuration.
    Bootstrap context, which is a parent for the main application context, uses `bootstrap.yml`
    instead of `application.yml`. Usually, we put the application name and Spring
    Cloud Config settings, as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到上一章。在那里，我已经详细描述了Spring Boot项目的结构。配置应该在YAML或属性文件中提供，使用应用程序或`application-{profile}`名称。与标准的Spring
    Boot应用程序相反，Spring Cloud基于从远程服务器获取的配置。但是，应用程序内部需要最少的设置；例如，其名称和配置服务器地址。这就是为什么Spring
    Cloud应用程序创建一个引导上下文，负责从外部源加载属性。引导属性具有最高优先级，不能被本地配置覆盖。引导上下文是主应用程序上下文的父级，使用`bootstrap.yml`而不是`application.yml`。通常，我们将应用程序名称和Spring
    Cloud配置设置放在其中，如下所示：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Bootstrap context startup can be easily disabled by setting the `spring.cloud.bootstrap.enabled` property
    to `false`. We can also change the name of the bootstrap configuration file using
    the `spring.cloud.bootstrap.name` property or even changing the location by setting
    `spring.cloud.bootstrap.location`. The profile mechanisms are also available here,
    so we are allowed to create, for example, `bootstrap-development.yml`, which is
    loaded on an active development profile. This and some other features are available
    in the Spring Cloud Context library, which is added as a parent dependency to
    the project classpath together with any other Spring Cloud library. One of these
    features is some additional management endpoints included with the Spring Boot
    Actuator:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`spring.cloud.bootstrap.enabled`属性设置为`false`，可以轻松禁用引导上下文启动。我们还可以使用`spring.cloud.bootstrap.name`属性更改引导配置文件的名称，甚至通过设置`spring.cloud.bootstrap.location`更改位置。配置文件还可以使用配置文件机制，因此我们可以创建例如`bootstrap-development.yml`，它在活动开发配置文件上加载。这些以及其他一些功能都可以在Spring
    Cloud Context库中找到，该库作为父依赖项添加到项目类路径中，以及任何其他Spring Cloud库。其中一个功能是Spring Boot执行器中包含的一些额外的管理端点：
- en: '`env`: A new `POST` method for `Environment`, log levels update, and `@ConfigurationProperties`
    rebind'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env`：`Environment`的新`POST`方法，日志级别更新和`@ConfigurationProperties`重新绑定'
- en: '`refresh`: This reloads bootstrap context and refreshes all beans annotated
    with `@RefreshScope`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`refresh`：这将重新加载引导上下文并刷新所有带有`@RefreshScope`注释的bean'
- en: '`restart`: This restarts Spring `ApplicationContext`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart`：这将重新启动Spring `ApplicationContext`'
- en: '`pause`: This stops Spring `ApplicationContext`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pause`：这将停止Spring `ApplicationContext`'
- en: '`resume`: This starts Spring `ApplicationContext`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resume`：这将启动Spring `ApplicationContext`'
- en: The next library together with Spring Cloud Context, which is included as a
    parent dependency with Spring Cloud projects, is Spring Cloud Commons. It provides
    a common abstraction layer for mechanisms such as service discovery, load balancing, and
    circuit breakers. These include, among other things, frequently used annotations
    such as `@EnableDiscoveryClient` or `@LoadBalanced`. I'll present more details
    about them in the following chapters.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与Spring Cloud项目一起作为父依赖项包含的下一个库是Spring Cloud Commons。它为诸如服务发现、负载平衡和断路器等机制提供了一个通用的抽象层。其中包括诸如`@EnableDiscoveryClient`或`@LoadBalanced`等经常使用的注释。我将在接下来的章节中详细介绍它们。
- en: Netflix OSS
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Netflix OSS
- en: On reading the first two chapters, you have probably noticed the appearance
    of many keywords related to microservice architecture. For some of you, it might
    be a new term, for others, it is well known. But so far, one important word to
    the microservices community has not been mentioned yet. It is definitely known
    by most of you, this word is *Netflix*. Well, I also like their TV shows and other
    productions, but for developers, they are famous for another reason. This reason
    is microservices. Netflix is one of the earliest pioneers of migration from a
    traditional development model where we created monolithic applications for a cloud-native
    microservices development approach. This company shares their expertise with the
    community by pushing a great part of the source code into the public repository,
    speaking in conference presentations, and publishing blog posts. Netflix has been
    so successful with its architecture concept that they became a role model for
    other large organizations and their IT architects such as Adrian Cockcroft are
    now prominent evangelists for microservices. In turn, many open source frameworks
    based their libraries on the solutions available under the code shared by Netflix.
    It is no different for Spring Cloud, which provides integrations with the most
    popular Netflix OSS features such as Eureka, Hystrix, Ribbon, or Zuul.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读前两章时，您可能已经注意到了与微服务架构相关的许多关键字的出现。对于一些人来说，这可能是一个新术语，对于其他人来说，它是众所周知的。但到目前为止，微服务社区中的一个重要词还没有被提到。这个词绝对为大多数人所知，这个词是*Netflix*。嗯，我也喜欢他们的电视节目和其他作品，但对于开发人员来说，他们以另一个原因而闻名。这个原因就是微服务。Netflix是从传统的开发模式迁移到云原生微服务开发方法的最早先驱之一。这家公司通过将大部分源代码推送到公共存储库、在会议演示中发表讲话和发布博客文章来与社区分享他们的专业知识。Netflix在其架构概念上取得了如此成功，以至于它成为了其他大型组织和其IT架构师的榜样，例如Adrian
    Cockcroft现在是微服务的杰出传道者。反过来，许多开源框架都基于Netflix共享的代码提供了其库。Spring Cloud也不例外，它提供了与最受欢迎的Netflix
    OSS功能（如Eureka、Hystrix、Ribbon或Zuul）的集成。
- en: 'By the way, I don''t know if you have been following Netflix, but they shed
    some light on the reasons why they decided to open source much of their code. I
    think it is worth quoting because that partly explains the success and unwaning
    popularity of their solutions in the IT world:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我不知道你是否一直在关注Netflix，但他们解释了为什么决定开源他们的大部分代码。我认为值得引用，因为这在一定程度上解释了他们的解决方案在IT世界中的成功和持续受欢迎程度：
- en: '"When we said we were going to move all of Netflix to the cloud everyone said
    we were completely crazy. They didn''t believe we were actually doing that, they
    thought we were just making stuff up."'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '"当我们说我们要将Netflix全部迁移到云端时，每个人都说我们完全疯了。他们不相信我们真的在做那件事，他们以为我们只是在编造东西。"'
- en: Service discovery with Eureka
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Eureka进行服务发现
- en: The first pattern provided by Spring Cloud Netflix is the service discovery
    with Eureka. This package is divided into client and server.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Netflix提供的第一个模式是使用Eureka进行服务发现。这个包分为客户端和服务器。
- en: To include a Eureka Client in your project you should use the `spring-cloud-starter-eureka` starter.
    The client is always a part of an application and is responsible for connecting
    to a remote discovery server. Once the connection is established it should send
    a registration message with a service name and network location. In case the current
    microservice has to call an endpoint from another microservice, the client should
    retrieve the newest configuration with a list of registered services from the server.
    The server can be configured and run as an independent Spring Boot application
    and it is supposed to be highly available with each server replicating its state
    to other nodes. To include a Eureka Server in your project you need to use the
    `spring-cloud-starter-eureka-server` starter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中包含Eureka Client，您应该使用`spring-cloud-starter-eureka`启动器。客户端始终是应用程序的一部分，并负责连接到远程发现服务器。一旦建立连接，它应该发送一个带有服务名称和网络位置的注册消息。如果当前的微服务需要调用另一个微服务的端点，客户端应该从服务器检索包含注册服务列表的最新配置。服务器可以配置并作为独立的Spring
    Boot应用程序运行，并且应该具有高可用性，每个服务器都将其状态复制到其他节点。要在项目中包含Eureka Server，您需要使用`spring-cloud-starter-eureka-server`启动器。
- en: Routing with Zuul
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Zuul进行路由
- en: The next popular pattern available under the Spring Cloud Netflix project is
    intelligent routing with Zuul. It is not only a JVM-based router but it also acts
    as a server-side load balancer and/or performs some filtering. It can also have
    a wide variety of applications. Netflix uses it for cases such as authentication,
    load shedding, static response handling, or stress testing. It is the same as
    Eureka Server in that it can be configured and run as an independent Spring Boot
    application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Netflix项目下的下一个流行模式是Zuul的智能路由。它不仅是基于JVM的路由器，还充当服务器端的负载均衡器和/或执行一些过滤。它还可以有各种各样的应用。Netflix将其用于身份验证、负载分配、静态响应处理或压力测试等情况。它与Eureka
    Server一样，可以配置并作为独立的Spring Boot应用程序运行。
- en: To include Zuul in your project use the `spring-cloud-starter-zuul` starter.
    In the microservices architecture, Zuul has a vital role of the API gateway, which
    is an entry point to the whole system. It needs to have knowledge of the network
    location of each service, so it is able to interact with the Eureka Server by
    including the discovery client to the classpath.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中包含Zuul，使用`spring-cloud-starter-zuul`启动器。在微服务架构中，Zuul扮演着API网关的重要角色，它是整个系统的入口点。它需要了解每个服务的网络位置，以便能够通过将发现客户端包含到类路径中与Eureka
    Server进行交互。
- en: Load balancing with Ribbon
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ribbon进行负载均衡
- en: We cannot ignore the next Spring Cloud Netflix feature used for client-side
    load balancing—Ribbon. It supports the most popular protocols such as TCP, UDP,
    and HTTP. It can be used not only for synchronous REST calls, but also in asynchronous
    and reactive models. In addition to load balancing, it provides integration with
    service discovery, caching, batching, and fault tolerance. Ribbon is the next
    abstraction level over basic HTTP and TCP clients.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能忽视Spring Cloud Netflix用于客户端负载均衡的下一个功能——Ribbon。它支持TCP、UDP和HTTP等最流行的协议。它不仅可以用于同步REST调用，还可以用于异步和响应式模型。除了负载均衡，它还提供与服务发现、缓存、批处理和容错的集成。Ribbon是基本HTTP和TCP客户端的下一个抽象级别。
- en: To include it in your project use the `spring-cloud-starter-ribbon` starter. Ribbon
    supports round robin, availability filtering, and weighted response time load
    balancing rules out-of-the-box and can be easily extended with custom defined
    rules. It is based on the *named client* concept, where servers included for the
    load balancing should be provided with a name.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中包含它，请使用`spring-cloud-starter-ribbon` starter。Ribbon支持轮询、可用性过滤和加权响应时间负载均衡规则，并且可以很容易地扩展为自定义规则。它基于“命名客户端”的概念，其中应该为负载均衡包括的服务器提供一个名称。
- en: Writing Java HTTP clients
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Java HTTP客户端
- en: Feign is a slightly less popular Netflix OSS package. It is a declarative REST
    client, which helps us in writing web service clients more easily. With Feign,
    a developer only needs to declare and annotate an interface while the actual implementation
    will be generated at runtime.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Feign是一个稍微不那么流行的Netflix OSS包。它是一个声明式的REST客户端，可以帮助我们更轻松地编写Web服务客户端。使用Feign，开发人员只需要声明和注释一个接口，实际的实现将在运行时生成。
- en: To include Feign in your project you need to use the `spring-cloud-starter-feign` starter.
    It integrates with the Ribbon client, so it supports, by default, load balancing
    and other Ribbon features including communication with the discovery service.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中包含Feign，您需要使用`spring-cloud-starter-feign` starter。它与Ribbon客户端集成，因此默认支持负载均衡和其他Ribbon功能，包括与发现服务的通信。
- en: Latency and fault tolerance with Hystrix
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hystrix进行延迟和容错处理
- en: I have already mentioned the circuit breaker pattern in [Chapter 1](33ddbb93-e658-4d91-97f5-06d6167ef89e.xhtml),
    *Introduction to Microservices*, and Spring Cloud provides a library that implements
    this pattern. It is based on the Hystrix package created by Netflix as a circuit
    breaker implementation. Hystrix is by default integrated with the Ribbon and Feign
    clients. Fallback is closely related to the circuit breaker concept. With Spring
    Cloud libraries you can easily configure fallback logic, which should be performed
    if there is a read or circuit breaker timeout. To include Hystrix in your project
    you should use the `spring-cloud-starter-hystrix` starter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在《第1章》《微服务简介》中提到了断路器模式，Spring Cloud提供了一个实现这种模式的库。它基于Netflix创建的Hystrix包作为断路器实现。Hystrix默认与Ribbon和Feign客户端集成。备用方案与断路器概念密切相关。使用Spring
    Cloud库，您可以轻松配置备用逻辑，如果发生读取或断路器超时，应执行该逻辑。要在项目中包含Hystrix，您应该使用`spring-cloud-starter-hystrix`
    starter。
- en: Configuration management with Archaius
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Archaius进行配置管理
- en: The last important feature provided under the Spring Cloud Netflix project is
    Archaius. Personally, I haven't touched this library, but it might be useful in
    some cases. The Spring Cloud reference Archaius is an extension of the Apache
    Commons Configuration project. It allows updating the configuration by either
    polling a source for changes or pushing changes to the client.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Netflix项目提供的最后一个重要功能是Archaius。就我个人而言，我还没有接触过这个库，但在某些情况下它可能会有用。Spring
    Cloud参考Archaius是Apache Commons Configuration项目的扩展。它允许通过轮询源以获取更改或将更改推送到客户端来更新配置。
- en: Discovery and distributed configuration
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现和分布式配置
- en: Service discovery and distributed configuration management are vital parts of
    the microservices architecture. The technical implementation of these two different
    mechanisms is pretty similar. It comes down to storing parameters under specific
    keys in a flexible key-value storage. Actually, there are several interesting
    solutions available on the market which provide both of these functionalities.
    Spring Cloud integrates with the most popular of them. But there is also one exception
    where Spring Cloud has its own implementation created only for distributed configuration.
    This feature is available under the Spring Cloud Config project. In contrast,
    Spring Cloud does not provide its own implementation for service registration
    and discovery.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现和分布式配置管理是微服务架构的重要组成部分。这两种不同机制的技术实现非常相似。它归结为在灵活的键值存储中存储特定键下的参数。实际上，市场上有几种提供这两种功能的有趣解决方案。Spring
    Cloud与其中最受欢迎的解决方案集成。但是Spring Cloud也有一个例外，它为分布式配置创建了自己的实现。这个功能在Spring Cloud Config项目下可用。相比之下，Spring
    Cloud没有为服务注册和发现提供自己的实现。
- en: As usual, we can divide this project into the server and client-side support. The
    server is the one, central place where all of the external properties for applications
    are managed across all of the environments. Configuration can be maintained simultaneously
    in several versions and profiles. This is achieved by using Git as a storage backend.
    The mechanism is really smart and we will discuss it in detail in [Chapter 5](37142825-02d0-48a0-99df-1a1a88a1bbd4.xhtml), *Distributed
    Configuration with Spring Cloud Config*. The Git backend is not the only one option
    for storing properties. The config files could also be located on a file system
    or server classpath. The next option is to use Vault as a backend. Vault is an
    open source tool for managing secrets such as tokens, passwords, or certificates
    released by HashiCorp. I know that many organizations pay particular attention
    to security issues such as storing credentials in a secure place, so it could
    be the right solution for them. Generally, we can also manage security on the
    configuration server access level. No matter which backend is used for storing
    properties, Spring Cloud Config Server exposes an HTTP, resource-based API which
    provides easy access to them. By default, this API is secured with basic authentication,
    but it is also available to set an SSL connection with private/public key authentication.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们可以将这个项目分为服务器和客户端支持。服务器是所有外部属性的中心位置，跨所有环境管理应用程序。配置可以同时在几个版本和配置文件中维护。这是通过使用Git作为存储后端实现的。这个机制非常聪明，我们将在[第5章](37142825-02d0-48a0-99df-1a1a88a1bbd4.xhtml)中详细讨论，*使用Spring
    Cloud Config进行分布式配置*。Git后端不是存储属性的唯一选项。配置文件也可以位于文件系统或服务器类路径上。下一个选项是使用Vault作为后端。Vault是一个由HashiCorp发布的用于管理令牌、密码或证书等秘密的开源工具。我知道许多组织特别关注存储凭据在安全位置的安全问题，所以这可能是他们的正确解决方案。通常情况下，我们也可以在配置服务器访问级别上管理安全性。无论使用哪种后端来存储属性，Spring
    Cloud Config Server都会公开一个基于HTTP的资源API，以便轻松访问它们。默认情况下，此API受基本身份验证保护，但也可以设置使用私钥/公钥身份验证的SSL连接。
- en: A server can be run as an independent Spring Boot application with properties
    exposed over the REST API. To enable it for our project we should add the `spring-cloud-config-server`
    dependency. There is also support on the client-side. Every microservice that
    uses a configuration server as a properties source needs to connect to it just
    after startup, before creating any Spring beans. Interestingly, the Spring Cloud
    Config Server can be used by non Spring applications. There are some popular microservice
    frameworks that integrate with it on the client side. To enable Spring Cloud Config
    Client for your application you need to include the `spring-cloud-config-starter`
    dependency.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以作为独立的Spring Boot应用程序运行，并通过REST API公开属性。要为我们的项目启用它，我们应该添加`spring-cloud-config-server`依赖项。客户端也有支持。每个使用配置服务器作为属性源的微服务在启动后需要立即连接到它，然后再创建任何Spring
    bean。有趣的是，Spring Cloud Config Server也可以被非Spring应用程序使用。一些流行的微服务框架在客户端集成了它。要为您的应用程序启用Spring
    Cloud Config Client，您需要包含`spring-cloud-config-starter`依赖项。
- en: An alternative – Consul
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一种替代方案 - Consul
- en: An interesting alternative for Netflix discovery and Spring distributed configuration seems
    to be Consul created by Hashicorp. Spring Cloud provides integrations with this
    popular tool for discovering and configuring services in your infrastructure.
    As usual, this integration can be enabled using a few simple common annotations
    and the only difference in comparison with an earlier presented solution is in
    configuration settings. In order to establish communication with a Consul server,
    its agent needs to be available for the application. It has to be able to run
    as a separated process, which is available by default at the `http://localhost:8500`
    address. Consul also provides REST API, which can be directly used for registration,
    collecting a list of services, or configuration of properties.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Netflix发现和Spring分布式配置的一个有趣的替代方案似乎是Hashicorp创建的Consul。Spring Cloud为这个流行的工具提供了集成，用于发现和配置基础设施中的服务。通常情况下，可以使用一些简单的常见注释来启用此集成，与之前介绍的解决方案唯一的区别在于配置设置。为了与Consul服务器建立通信，其代理需要对应用程序可用。它必须能够作为一个独立的进程运行，默认情况下在`http://localhost:8500`地址可用。Consul还提供REST
    API，可以直接用于注册、收集服务列表或配置属性。
- en: To activate Consul Service Discovery we need to use the `spring-cloud-starter-consul-discovery` starter.
    After application startup and registration, a client would query Consul in order
    to locate other services. It supports both the client-side load balancer with
    Netflix Ribbon and dynamic router and filter with Netflix Zuul.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活Consul服务发现，我们需要使用`spring-cloud-starter-consul-discovery`启动器。应用程序启动和注册后，客户端将查询Consul以定位其他服务。它支持Netflix
    Ribbon的客户端负载均衡器和Netflix Zuul的动态路由器和过滤器。
- en: Apache Zookeeper
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apache Zookeeper
- en: The next popular solution within this area supported by Spring Cloud is Apache
    Zookeeper. Following its documentation, it is a centralized service for maintaining
    configuration, naming, which also provides distributed synchronization, and is
    able to group services. Everything that has previously applied to Consul regarding
    support in Spring Cloud is also true for Zookeeper. I'm thinking here about simple
    common annotations, which have to be used to enable integration, configuration
    though properties inside settings files and auto-configuration for interacting
    with Ribbon or Zuul. To enable service discovery with Zookeeper on the client
    side we need not only include `spring-cloud-starter-zookeeper-discovery`, but
    also Apache Curator. It provides an API framework and utilities to make integration
    easy and more reliable. It is not needed for distributed configuration clients
    where we only have to include the `spring-cloud-starter-zookeeper-config` for
    our project dependencies.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud支持的下一个受欢迎的解决方案是Apache Zookeeper。根据其文档，它是一个集中的服务，用于维护配置、命名，还提供分布式同步，并能够对服务进行分组。之前适用于Consul的所有内容在Spring
    Cloud中也适用于Zookeeper。我在这里考虑的是简单的通用注释，必须使用它们来启用集成，尽管在设置文件中的属性内配置和与Ribbon或Zuul交互的自动配置。要在客户端上使用Zookeeper进行服务发现，我们不仅需要包含`spring-cloud-starter-zookeeper-discovery`，还需要Apache
    Curator。它提供了一个API框架和实用程序，使集成更加容易和可靠。对于仅需要包含`spring-cloud-starter-zookeeper-config`作为项目依赖项的分布式配置客户端，它是不需要的。
- en: Miscellaneous projects
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他项目
- en: It is worth mentioning two other projects, which are now in the incubation stage.
    All such projects are available in the GitHub repository, [https://github.com/spring-cloud-incubator](https://github.com/spring-cloud-incubator).
    Some of them will probably be officially attached to the Spring Cloud package
    in the short term. The first of them is Spring Cloud Kubernetes, which provides
    integration with this very popular tool. We could talk about it for a long time,
    but let's try to introduce it in a few words. It is a system for automating deployment,
    scaling, and management of containerized applications originally designed by Google.
    It is used for container orchestration and has many interesting features including
    service discovery, configuration management, and load balancing. In some cases,
    it might be treated as Spring Cloud's competition. The configuration is provided
    with the usage of YAML files.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，还有两个项目目前处于孵化阶段。所有这些项目都可以在GitHub存储库[https://github.com/spring-cloud-incubator](https://github.com/spring-cloud-incubator)中找到。其中一些项目可能会在短期内正式附属于Spring
    Cloud包。其中一个是Spring Cloud Kubernetes，它提供了与这个非常流行的工具的集成。我们可能会长时间地谈论它，但让我们试着用几句话来介绍它。这是一个由Google最初设计用于自动化部署、扩展和管理容器化应用程序的系统。它用于容器编排，并具有许多有趣的功能，包括服务发现、配置管理和负载平衡。在某些情况下，它可能被视为Spring
    Cloud的竞争对手。配置是使用YAML文件提供的。
- en: Important features from the Spring Cloud point of view are service discovery
    and distributed configuration mechanisms, which are available on the Kubernetes
    platform. To use them in your application you should include `spring-cloud-starter-kubernetes`
    starter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从Spring Cloud的角度来看，Kubernetes平台上可用的服务发现和分布式配置机制是重要的功能。要在应用程序中使用它们，您应该包含`spring-cloud-starter-kubernetes`启动器。
- en: The second interesting project at the incubation stage is Spring Cloud Etcd.
    Exactly the same as before, its main features are distributed configuration, service
    registration, and discovery. Etcd is not a powerful tool like Kubernetes. It just
    provides a distributed key-value store with a reliable way to store data in a
    clustered environment. And a little trivia—Etcd is the backend for service discovery,
    cluster state, and configuration management in Kubernetes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 孵化阶段的第二个有趣项目是Spring Cloud Etcd。与之前完全相同，其主要特点是分布式配置、服务注册和发现。Etcd不像Kubernetes那样强大。它只是提供了一个可靠的分布式键值存储，用于在集群环境中存储数据。还有一个小趣闻——Etcd是Kubernetes中服务发现、集群状态和配置管理的后端。
- en: Distributed tracing with Sleuth
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Sleuth进行分布式跟踪
- en: Another one of Spring Cloud's essential functionalities is distributed tracing.
    It is implemented in the Spring Cloud Sleuth library. Its primary purpose is to
    associate subsequent requests dispatched between different microservices under
    processing single input request. As in most cases, these are HTTP requests that
    implement tracing mechanisms based on HTTP headers. The implementation is built
    over Slf4j and MDC. Slf4j provides facade and abstraction for specific logging
    frameworks such as logback, log4j, or `java.util.logging`. **MDC** or **mapped
    diagnostic context** in full, is a solution for distinguishing log output from
    different sources and enriching them with additional information that could be
    not available in the actual scope.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud的另一个重要功能是分布式跟踪。它是在Spring Cloud Sleuth库中实现的。其主要目的是将在单个输入请求处理下分派的后续请求关联起来。在大多数情况下，这些是基于HTTP头的跟踪机制的HTTP请求。实现是建立在Slf4j和MDC之上。Slf4j为特定的日志记录框架提供了外观和抽象，例如logback、log4j或`java.util.logging`。MDC或全称为映射诊断上下文，是用于区分不同来源的日志输出并丰富它们的附加信息的解决方案，这些信息在实际范围内可能不可用。
- en: Spring Cloud Sleuth adds trace and span IDs to the Slf4J MDC, so that we are
    able to extract all of the logs with a given trace or span. It also adds some
    other entries such as application name or exportable flag. It integrates with
    the most popular messaging solutions such as Spring REST template, Feign client,
    Zuul filters, Hystrix, or Spring Integration message channels. It can also be
    used together with RxJava or scheduled tasks. To enable it in your project you
    should add the `spring-cloud-starter-sleuth` dependency. The usage of basic span
    and trace IDs mechanisms is completely transparent for a developer.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Sleuth将跟踪和跨度ID添加到Slf4J MDC中，以便我们能够提取具有给定跟踪或跨度的所有日志。它还添加了一些其他条目，如应用程序名称或可导出标志。它集成了最流行的消息传递解决方案，如Spring
    REST模板，Feign客户端，Zuul过滤器，Hystrix或Spring Integration消息通道。它还可以与RxJava或定时任务一起使用。要在项目中启用它，您应该添加`spring-cloud-starter-sleuth`依赖项。基本跨度和跟踪ID机制的使用对开发人员来说是完全透明的。
- en: Adding tracing headers is not the only feature of Spring Cloud Sleuth. It is
    also responsible for recording timing information, which is useful in latency
    analysis. Such statistics can be exported to Zipkin, a tool that can be used for
    querying and visualization timing data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 添加跟踪标头并不是Spring Cloud Sleuth的唯一功能。它还负责记录时间信息，这在延迟分析中非常有用。这样的统计数据可以导出到Zipkin，这是一个用于查询和可视化时间数据的工具。
- en: Zipkin is a distributing tracing system specially designed for analyzing latency
    problems inside microservices architecture. It exposes HTTP endpoints used for
    collecting input data. To enable generating and sending traces to Zipkin we should
    include the `spring-cloud-starter-zipkin` dependency to the project.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Zipkin是一个专为分析微服务架构内部延迟问题而设计的分布式跟踪系统。它公开了用于收集输入数据的HTTP端点。要启用生成和发送跟踪到Zipkin，我们应该将`spring-cloud-starter-zipkin`依赖项包含到项目中。
- en: Frequently, there is no need to analyze everything; the input traffic volume
    is so high that we would need to collect only a certain percentage of data. For
    that purpose, Spring Cloud Sleuth provides a sampling policy, where we can decide
    how much input traffic is sent to Zipkin. The second smart solution to the big
    data problem is to send statistics using the message broker instead of the default
    HTTP endpoint. To enable this feature we have to include the `spring-cloud-sleuth-stream` dependency,
    which allows your application to become a producer of messages sent to Apache
    Kafka or RabbitMQ.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，没有必要分析一切；输入流量量往往如此之高，以至于我们只需要收集一定百分比的数据。为此，Spring Cloud Sleuth提供了采样策略，我们可以决定将多少输入流量发送到Zipkin。解决大数据问题的第二个聪明解决方案是使用消息代理而不是默认的HTTP端点发送统计数据。要启用此功能，我们必须包含`spring-cloud-sleuth-stream`依赖项，这允许您的应用程序成为发送到Apache
    Kafka或RabbitMQ的消息的生产者。
- en: Messaging and integration
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息和集成
- en: I have already mentioned messaging brokers and their usage for communication
    between your application and Zipkin server. Generally, Spring Cloud supports two
    types of communications via synchronous/asynchronous HTTP and with messaging brokers.
    The first project from this area is Spring Cloud Bus. It allows you to send broadcast
    events to applications informing them about state changes such as configuration
    property updates or other management commands. Actually, we might want to use
    starters for AMQP with a RabbitMQ broker or for Apache Kafka. As usual, we only
    need to include `spring-cloud-starter-bus-amqp` or `spring-cloud-starter-bus-kafka`
    to the dependency management and all other necessary operations are performed
    through auto-configuration.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到了消息代理和它们在应用程序与Zipkin服务器之间通信的用途。一般来说，Spring Cloud支持通过同步/异步HTTP和消息代理两种类型的通信。这个领域的第一个项目是Spring
    Cloud Bus。它允许您向应用程序发送广播事件，通知它们有关状态更改，如配置属性更新或其他管理命令。实际上，我们可能希望使用带有RabbitMQ代理的AMQP或Apache
    Kafka的启动器。通常情况下，我们只需要在依赖管理中包含`spring-cloud-starter-bus-amqp`或`spring-cloud-starter-bus-kafka`，所有其他必要的操作都通过自动配置执行。
- en: Spring Cloud Bus is a rather small project allowing you to use distributed messaging
    features for common operations such as broadcasting configuration change events.
    The right framework for building a system consisting of message-driven microservices
    is the Spring Cloud Stream. This is a really powerful framework and one of the
    biggest Spring Cloud projects, to which I have dedicated an entire chapter, [Chapter
    11](554c4049-1dc9-430d-8fe7-19f3b9ac99a3.xhtml), *Message Driven Microservices*,
    of the book. The same as for Spring Cloud Bus, there are two binders available,
    first for AMQP with RabbitMQ, and second for Apache Kafka. Spring Cloud Stream
    is based on Spring Integration, which is another large project part of Spring.
    It provides a programming model, supporting most Enterprise Integration Patterns
    such as endpoint, channel, aggregator, or transformer. The applications included
    in the whole microservice system communicate with each other through the Spring
    Cloud Stream input and output channels. The main communication model between them
    is Publish/Subscribe, where messages are broadcast through shared topics. Additionally,
    it is important to support multi instances of every microservice. In most cases,
    a message should be processed only by a single instance, which is not supported
    in a Publish/Subscribe model. That's why Spring Cloud Stream introduces grouping
    mechanisms where only one member of the group receives a message from a destination.
    The same as earlier, these are two starters that can include a project depending
    on the binder type `spring-cloud-starter-stream-kafka` or `spring-cloud-starter-stream-rabbit`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Bus是一个相当小的项目，允许您使用分布式消息传递功能进行常见操作，例如广播配置更改事件。构建由消息驱动的微服务系统的正确框架是Spring
    Cloud Stream。这是一个非常强大的框架，也是最大的Spring Cloud项目之一，我已经在书中专门撰写了一整章[第11章](554c4049-1dc9-430d-8fe7-19f3b9ac99a3.xhtml)，*消息驱动的微服务*。与Spring
    Cloud Bus一样，有两个可用的绑定器，第一个是用于RabbitMQ的AMQP，第二个是用于Apache Kafka。Spring Cloud Stream基于Spring
    Integration，这是Spring的另一个大型项目的一部分。它提供了一个编程模型，支持大多数企业集成模式，如端点、通道、聚合器或转换器。整个微服务系统中包含的应用程序通过Spring
    Cloud Stream输入和输出通道进行通信。它们之间的主要通信模型是发布/订阅，其中消息通过共享主题进行广播。此外，支持每个微服务的多个实例是很重要的。在大多数情况下，消息应该只由一个实例处理，这在发布/订阅模型中是不支持的。这就是为什么Spring
    Cloud Stream引入了分组机制，只有组的一个成员从目的地接收消息。与之前一样，这些是两个starter，可以根据绑定器类型包含项目`spring-cloud-starter-stream-kafka`或`spring-cloud-starter-stream-rabbit`。
- en: There are two more projects related to Spring Cloud Stream. First, Spring Cloud
    Stream App Starters defines a set of Spring Cloud Stream applications that can
    be run independently or using the second project, Spring Cloud Data Flow. Among
    these applications, we can distinguish connectors, adapters for network protocols,
    and generic protocols. Spring Cloud Data Flow is another extensive and powerful
    Spring Cloud toolkit. It simplifies development and deployment by providing a
    smart solution for building data integration and real-time data processing pipelines.
    The orchestration of microservice-based data pipelines is achieved with simple
    DSL, a drag-and-drop UI dashboard, and REST APIs together.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个与Spring Cloud Stream相关的项目。首先，Spring Cloud Stream App Starters定义了一组可以独立运行或使用第二个项目Spring
    Cloud Data Flow的Spring Cloud Stream应用程序。在这些应用程序中，我们可以区分连接器、网络协议的适配器和通用协议。Spring
    Cloud Data Flow是另一个广泛而强大的Spring Cloud工具包。它通过提供智能解决方案来简化开发和部署，用于构建数据集成和实时数据处理管道。基于微服务的数据管道的编排是通过简单的DSL、拖放UI仪表板和REST
    API实现的。
- en: Cloud platform support
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云平台支持
- en: 'Pivotal Cloud Foundry is a cloud-native platform for deploying and managing
    modern applications. Pivotal Software, as some of you probably already know, is
    an owner of the Spring framework trademark. The patronage of a large, commercial
    platform is one of the important reasons for Spring''s growing popularity. What
    is obvious is that PCF fully supports both Spring Boot''s executable JAR files,
    and all of Spring Cloud microservices patterns such as Config Server, service
    registry, and circuit breaker. These types of tools can be easily run and configured
    using the marketplace available on the UI dashboard or client command line. Development
    for PCF is even simpler than with standard Spring Cloud application. The only
    thing we have to do is to include the right starters to project dependencies:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Pivotal Cloud Foundry是一个用于部署和管理现代应用程序的云原生平台。Pivotal Software，你们中的一些人可能已经知道，是Spring框架商标的所有者。一个大型商业平台的赞助是Spring日益流行的重要原因之一。显而易见的是，PCF完全支持Spring
    Boot的可执行JAR文件，以及Spring Cloud的所有微服务模式，如Config Server、服务注册表和断路器。这些类型的工具可以在UI仪表板或客户端命令行上的市场中轻松运行和配置。与标准的Spring
    Cloud应用程序相比，为PCF进行开发甚至更简单。我们唯一需要做的就是将正确的starter包含到项目依赖中：
- en: '`spring-cloud-services-starter-circuit-breaker`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud-services-starter-circuit-breaker`'
- en: '`spring-cloud-services-starter-config-client`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud-services-starter-config-client`'
- en: '`spring-cloud-services-starter-service-registry`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud-services-starter-service-registry`'
- en: 'It''s difficult to find an opinionated cloud framework that does not have support
    for AWS. The same is true for Spring Cloud. Spring Cloud for Amazon Web Services
    provides integration with the most popular web tools available there. This includes
    modules for communication with **Simple Queueing Service** (**SQS**),  **Simple
    Notification Service** (**SNS**), **ElasticCache**, and **Relational Database
    Service** (**RDS**) that offer engines such as Aurora, MySQL, or Oracle. The remote
    resources can be accessed using their name defined in the CloudFormation stack.
    Everything is opaque in well-known Spring convention and patterns. There are four
    main modules available:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 很难找到一个不支持AWS的有主见的云框架。对于Spring Cloud也是如此。Spring Cloud for Amazon Web Services提供了与那里最流行的网络工具集成。这包括用于与Simple
    Queueing Service（SQS）、Simple Notification Service（SNS）、ElasticCache和Relational
    Database Service（RDS）通信的模块，这些模块提供了Aurora、MySQL或Oracle等引擎。远程资源可以使用在CloudFormation堆栈中定义的名称进行访问。一切都遵循着众所周知的Spring约定和模式。有四个主要模块可用：
- en: '**Spring Cloud AWS Core**: Included using the `spring-cloud-starter-aws` starter,
    provides core components enabling direct access to the EC2 instance'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud AWS Core：使用`spring-cloud-starter-aws` starter包含的核心组件，提供直接访问EC2实例的功能
- en: '**Spring Cloud AWS Context**: Delivers access to the Simple Storage Service,
    Simple E-mail Service, and caching service'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud AWS Context：提供对简单存储服务、简单电子邮件服务和缓存服务的访问
- en: '**Spring Cloud AWS JDBC**: Included using starter `spring-cloud-starter-aws-jdbc` starter, provides data
    source lookup and configuration, which can be used with any data access technology
    supported by Spring'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud AWS JDBC：使用starter `spring-cloud-starter-aws-jdbc`包含的组件，提供数据源查找和配置，可与Spring支持的任何数据访问技术一起使用
- en: '**Spring Cloud AWS Messaging**: Included using `starter spring-cloud-starter-aws-messaging`
    starter, allows an application to send and receive messages with SQS (point-to-point)
    or SNS (Publish/Subscribe)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud AWS Messaging：使用`starter spring-cloud-starter-aws-messaging` starter包含的组件，允许应用程序使用SQS（点对点）或SNS（发布/订阅）发送和接收消息
- en: There is another project that is worth mentioning although it is still at an
    early stage of development. That is Spring Cloud Function, which offers support
    for serverless architecture. Serverless is also known as **FaaS** (**Function-as-a-Service**),
    where a developer creates only very small modules that are deployed on containers fully
    managed by a third-party provider. Actually, Spring Cloud Functions implemented
    adapters for AWS Lambda and Apache OpenWhisk, the most popular FaaS providers.
    I will be following the development of this project designed for supporting a
    serverless approach.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个项目值得一提，尽管它仍处于早期开发阶段。那就是Spring Cloud Function，它支持无服务器架构。无服务器也被称为FaaS（函数即服务），开发人员只创建部署在由第三方提供商完全管理的容器上的非常小的模块。实际上，Spring
    Cloud Functions为AWS Lambda和Apache OpenWhisk实现了适配器，这是最流行的FaaS提供商之一。我将密切关注这个旨在支持无服务器方法的项目的发展。
- en: In this section, we should not forget about the Spring Cloud Connectors project, formerly
    known as **Spring Cloud**. It provides an abstraction for JVM-based applications
    deployed on a cloud platform. Actually, it has support for Heroku and Cloud Foundry,
    where our application could connect SMTP, RabbitMQ, Redis, or one of the available
    relational databases using one of the Spring Cloud Heroku Connectors and Spring
    Cloud Foundry Connector modules.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们不应忘记Spring Cloud Connectors项目，以前被称为Spring Cloud。它为部署在云平台上的基于JVM的应用程序提供了一个抽象。实际上，它支持Heroku和Cloud
    Foundry，在那里我们的应用程序可以使用Spring Cloud Heroku Connectors和Spring Cloud Foundry Connector模块之一连接SMTP、RabbitMQ、Redis或其中一个可用的关系数据库。
- en: Other useful libraries
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他有用的库
- en: There are some important aspects surrounding microservices architecture, which
    can't be considered its core features, but are also very important. The first
    of them is security.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些围绕微服务架构的重要方面，虽然不能被视为其核心特性，但也非常重要。其中之一是安全性。
- en: Security
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全
- en: The big part of standard implementation for securing APIs with mechanisms such
    as OAuth2, JWT, or basic authentication is available in Spring Security and Spring
    Web projects. Spring Cloud Security uses those libraries to allow us to easily
    create systems that implement common patterns such as single sign-on and token
    relay. To enable security management for our application we should include the `spring-cloud-starter-security`
    starter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 用于使用OAuth2、JWT或基本身份验证等机制保护API的标准实现的大部分功能在Spring Security和Spring Web项目中都可以找到。Spring
    Cloud Security使用这些库，使我们能够轻松创建实现单点登录和令牌中继等常见模式的系统。为了启用应用程序的安全管理，我们应该包含`spring-cloud-starter-security`
    starter。
- en: Automated testing
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试
- en: 'The next important area in microservices development is automated testing.
    For microservices architecture, contact tests are growing in importance. Martin
    Fowler gave the following definition:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务开发中的下一个重要领域是自动化测试。对于微服务架构，接触测试的重要性正在增加。Martin Fowler给出了以下定义：
- en: '"An integration contract test is a test at the boundary of an external service
    verifying that it meets the contract expected by a consuming service."'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '"集成契约测试是对外部服务边界的测试，验证其是否符合消费服务期望的契约。"'
- en: Spring Cloud has a very interesting implementation for that approach to unit
    testing, Spring Cloud Contract. It uses WireMock for traffic recording and Maven
    plugin for generating stubs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud对于单元测试有一个非常有趣的实现，Spring Cloud Contract。它使用WireMock进行流量记录，并使用Maven插件生成存根。
- en: It is also possible that you get the opportunity to use Spring Cloud Task. It
    helps a developer to create short lived microservices using Spring Cloud, and
    run them locally or in the cloud environment. To enable it in the project we should
    include the `spring-cloud-starter-task` starter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 还有可能你会有机会使用Spring Cloud Task。它帮助开发人员使用Spring Cloud创建短暂的微服务，并在本地或云环境中运行。为了在项目中启用它，我们应该包含`spring-cloud-starter-task`
    starter。
- en: Cluster features
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群功能
- en: Finally, the last project, Spring Cloud Cluster. It provides a solution for
    the leadership election and common stateful patterns with an abstraction and implementation
    for Zookeeper, Redis, Hazelcast, and Consul.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一个项目，Spring Cloud Cluster。它为选举领导和常见有状态模式提供了一个解决方案，具有Zookeeper、Redis、Hazelcast和Consul的抽象和实现。
- en: Projects overview
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: 'As you can see, Spring Cloud contains many subprojects providing integration
    with lots of different tools and solutions. I think it is easy to lose track,
    especially if you are using Spring Cloud for the first time. In accordance with
    the principle that one diagram might express things better than a thousand words,
    I''m presenting the most important projects divided into categories as shown in
    the following diagram:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Spring Cloud包含许多子项目，与许多不同的工具和解决方案集成。我认为很容易迷失方向，特别是如果你是第一次使用Spring Cloud。根据一个图表可能比千言万语更好地表达事物的原则，我将最重要的项目分成如下图表所示的类别：
- en: '![](img/b90c6536-0be0-4d4c-89ea-0aabea5a5eec.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b90c6536-0be0-4d4c-89ea-0aabea5a5eec.png)'
- en: Release trains
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布列车
- en: 'As we can see in the preceding diagram, there are many projects inside Spring
    Cloud and there are many relationships between them. By definition, these are
    all independent projects with different release cascades and version numbers.
    In a situation like this, dependency management in our application might be problematic
    and that will require knowledge about relationships between versions of all projects.
    To help make it easier, Spring Cloud introduced the starter mechanism, which we
    have already discussed, and release trains. The release trains are identified
    by names, not versions, to avoid confusion with the subprojects. What is interesting
    is that they are named after London tube stations and they are alphabetically
    ordered. The first release was Angel,  the second was Brixton, and so on. The
    whole mechanism of dependency management is based on **BOM** (**bill of materials**),
    which is a standard Maven concept for managing artifacts versioned independently.
    Here''s an actual table with Spring Cloud project versions assigned to release
    trains. Names with the suffix M[*X*], where [*X*] is the version number, means
    **milestone**, SR[*X*] means **service release**, which refers to changes that
    fix critical bugs. As you can see in the following table, Spring Cloud Stream
    has it own release trains, which groups its subprojects using the same rules as
    Spring Cloud project:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的图表所示，Spring Cloud 中有许多项目，它们之间存在许多关系。根据定义，这些都是具有不同发布级联和版本号的独立项目。在这种情况下，我们应用程序中的依赖管理可能会有问题，这将需要了解所有项目版本之间的关系。为了帮助简化，Spring
    Cloud 引入了 starter 机制，我们已经讨论过了，并且发布了列车。发布列车由名称而不是版本来标识，以避免与子项目混淆。有趣的是，它们以伦敦地铁站命名，并按字母顺序排列。第一个发布是
    Angel，第二个是 Brixton，依此类推。整个依赖管理机制都是基于 BOM（bill of materials）的，这是管理独立版本化的标准 Maven
    概念。下面是一个实际的表格，其中列出了分配给发布列车的 Spring Cloud 项目版本。带有后缀 M[*X*]的名称，其中[*X*]是版本号，表示里程碑，SR[*X*]表示服务发布，指的是修复关键错误的更改。正如下表所示，Spring
    Cloud Stream 有自己的发布列车，它使用与 Spring Cloud 项目相同的规则对其子项目进行分组：
- en: '| **Component** | **Camden.SR7** | **Dalston.SR4** | **Edgware.M1** | **Finchley.M2**
    | **Finchley.BUILD-SNAPSHOT** |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '**Component** | **Camden.SR7** | **Dalston.SR4** | **Edgware.M1** | **Finchley.M2**
    | **Finchley.BUILD-SNAPSHOT** |'
- en: '| `spring-cloud-aws` | 1.1.4.RELEASE | 1.2.1.RELEASE | 1.2.1.RELEASE | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '`spring-cloud-aws` | 1.1.4.RELEASE | 1.2.1.RELEASE | 1.2.1.RELEASE | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-bus` | 1.2.2.RELEASE | 1.3.1.RELEASE | 1.3.1.RELEASE | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '`spring-cloud-bus` | 1.2.2.RELEASE | 1.3.1.RELEASE | 1.3.1.RELEASE | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-cli` | 1.2.4.RELEASE | 1.3.4.RELEASE | 1.4.0.M1 | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '`spring-cloud-cli` | 1.2.4.RELEASE | 1.3.4.RELEASE | 1.4.0.M1 | 2.0.0.M1 |
    2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-commons` | 1.1.9.RELEASE | 1.2.4.RELEASE | 1.3.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '`spring-cloud-commons` | 1.1.9.RELEASE | 1.2.4.RELEASE | 1.3.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-contract` | 1.0.5.RELEASE | 1.1.4.RELEASE | 1.2.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '`spring-cloud-contract` | 1.0.5.RELEASE | 1.1.4.RELEASE | 1.2.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-config` | 1.2.3.RELEASE | 1.3.3.RELEASE | 1.4.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '`spring-cloud-config` | 1.2.3.RELEASE | 1.3.3.RELEASE | 1.4.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-netflix` | 1.2.7.RELEASE | 1.3.5.RELEASE | 1.4.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '`spring-cloud-netflix` | 1.2.7.RELEASE | 1.3.5.RELEASE | 1.4.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-security` | 1.1.4.RELEASE | 1.2.1.RELEASE | 1.2.1.RELEASE |
    2.0.0.M1 | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '`spring-cloud-security` | 1.1.4.RELEASE | 1.2.1.RELEASE | 1.2.1.RELEASE | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-cloudfoundry` | 1.0.1.RELEASE | 1.1.0.RELEASE | 1.1.0.RELEASE
    | 2.0.0.M1 | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '`spring-cloud-cloudfoundry` | 1.0.1.RELEASE | 1.1.0.RELEASE | 1.1.0.RELEASE
    | 2.0.0.M1 | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-consul` | 1.1.4.RELEASE | 1.2.1.RELEASE | 1.2.1.RELEASE | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '`spring-cloud-consul` | 1.1.4.RELEASE | 1.2.1.RELEASE | 1.2.1.RELEASE | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-sleuth` | 1.1.3.RELEASE | 1.2.5.RELEASE | 1.3.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '`spring-cloud-sleuth` | 1.1.3.RELEASE | 1.2.5.RELEASE | 1.3.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-stream` | Brooklyn.SR3 | Chelsea.SR2 | Ditmars.M2 | Elmhurst.M1
    | Elmhurst.BUILD-SNAPSHOT |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '`spring-cloud-stream` | Brooklyn.SR3 | Chelsea.SR2 | Ditmars.M2 | Elmhurst.M1
    | Elmhurst.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-zookeeper` | 1.0.4.RELEASE | 1.1.2.RELEASE | 1.2.0.M1 | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '`spring-cloud-zookeeper` | 1.0.4.RELEASE | 1.1.2.RELEASE | 1.2.0.M1 | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-boot` | 1.4.5.RELEASE | 1.5.4.RELEASE | 1.5.6.RELEASE | 2.0.0.M3
    | 2.0.0.M3 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '`spring-boot` | 1.4.5.RELEASE | 1.5.4.RELEASE | 1.5.6.RELEASE | 2.0.0.M3 |
    2.0.0.M3 |'
- en: '| `spring-cloud-task` | 1.0.3.RELEASE | 1.1.2.RELEASE | 1.2.0.RELEASE | 2.0.0.M1
    | 2.0.0.RELEASE |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '`spring-cloud-task` | 1.0.3.RELEASE | 1.1.2.RELEASE | 1.2.0.RELEASE | 2.0.0.M1
    | 2.0.0.RELEASE |'
- en: 'Now, all we need to do is provide the right release train name in the dependency
    management section in the Maven `pom.xml` and then include projects using starters:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要做的就是在 Maven 的 `pom.xml` 中的依赖管理部分提供正确的发布列车名称，然后使用 starters 包含项目。
- en: '[PRE1]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here''s the same sample for Gradle:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Gradle 的相同示例：
- en: '[PRE2]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Summary
- en: In this chapter, I have introduced the most important projects that are part
    of Spring Cloud. I have pointed out several areas to which I assigned each of
    those projects. After reading this chapter, you should be able to recognize which
    library has to be included in your application to able to implement patterns such
    as service discovery, distributed configuration, circuit breaker, or load balancer.
    You should also recognize the differences between application context, and bootstrap
    context and understand how to include dependencies in the project using dependency
    management based on the release trains concept. The last thing I wanted to draw
    your attention to in this chapter were some tools integrated with Spring Cloud
    such as Consul, Zookeeper, RabbitMQ, or Zipkin. I described all of them in some
    details. I also pointed out the projects responsible for interaction with those
    tools.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我介绍了Spring Cloud中最重要的项目。我指出了我分配给这些项目的几个领域。阅读完本章后，你应该能够识别出必须包含在你的应用程序中的库，以便能够实现诸如服务发现、分布式配置、断路器或负载均衡器等模式。你还应该能够识别应用程序上下文和引导上下文之间的区别，并了解如何使用基于发布列车概念的依赖管理在项目中包含依赖项。我在本章中还想要引起你的注意的最后一件事是一些与Spring
    Cloud集成的工具，如Consul、Zookeeper、RabbitMQ或Zipkin。我对它们进行了详细描述。我还指出了负责与这些工具进行交互的项目。
- en: This chapter completes the first part of the book. In this part, the main goal
    was to get you into the basics related to Spring Cloud project. After reading
    it you should be able to recognize the most important elements of microservices-based
    architecture, effectively use Spring Boot to create simple and more advanced microservices,
    and finally, you should also be able to list all of the most popular subprojects
    being that are a part of Spring Cloud. Now, we may proceed to the next part of
    the book and discuss in detail those subprojects, which are responsible for implementing
    common patterns of distributed systems in Spring Cloud. Most of them are based
    on Netflix OSS libraries. We will begin with the solution providing service registry,
    Eureka discovery server.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成了本书的第一部分。在这一部分中，主要目标是让你了解与Spring Cloud项目相关的基础知识。阅读完后，你应该能够识别基于微服务架构的最重要元素，有效地使用Spring
    Boot来创建简单和更高级的微服务，最后，你还应该能够列出Spring Cloud中最受欢迎的子项目。现在，我们可以继续阅读本书的下一部分，并详细讨论那些负责在Spring
    Cloud中实现分布式系统常见模式的子项目。其中大部分基于Netflix OSS库。我们将从提供服务注册的解决方案Eureka发现服务器开始。
