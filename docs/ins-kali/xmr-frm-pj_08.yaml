- en: Creating an Augmented-Reality Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建增强现实游戏
- en: In this chapter, we will be exploring **augmented reality** (**AR**) using Xamarin.Forms.
    We will be using custom renderers to inject platform-specific code, **UrhoSharp** to
    render the scene and handle input, and `MessagingCenter` to pass internal messages
    around in the app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Xamarin.Forms探索**增强现实**（**AR**）。我们将使用自定义渲染器注入特定于平台的代码，使用**UrhoSharp**来渲染场景和处理输入，并使用`MessagingCenter`在应用程序中传递内部消息。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Setting up a project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置项目
- en: Using ARKit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ARKit
- en: Using ARCore
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ARCore
- en: Learning how to use UrhoSharp to render graphics and handle input
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用UrhoSharp来渲染图形和处理输入
- en: Using custom renderers to inject platform-specific code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义渲染器注入特定于平台的代码
- en: Using `MessagingCenter` to send messages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`MessagingCenter`发送消息
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To be able to complete this project, we need to have Visual Studio for Mac or
    PC installed, as well as the Xamarin components. See [Chapter 1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml), *Introduction
    to Xamarin*, for more details on how to set up your environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够完成这个项目，我们需要安装Visual Studio for Mac或PC，以及Xamarin组件。有关如何设置您的环境的更多详细信息，请参见[第1章](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml)，*Xamarin简介*。
- en: 'You cannot run AR on an emulator. To run AR, you need a physical device, along
    with the following software:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能在模拟器上运行AR。要运行AR，您需要一个物理设备，以及以下软件：
- en: On iOS, you need iOS 11 or higher and a device that has an A9 processor or above
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在iOS上，您需要iOS 11或更高版本，以及一个A9处理器或更高版本的设备
- en: On Android, you need Android 8.1 and a device that supports ARCore
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android上，您需要Android 8.1和支持ARCore的设备
- en: Essential theory
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本理论
- en: This section will describe how AR works. The implementation differs slightly
    between platforms. Google's implementation is called **ARCore,** and Apple's implementation
    is called **ARKit**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将描述AR的工作原理。实现在不同平台之间略有不同。谷歌的实现称为**ARCore**，苹果的实现称为**ARKit**。
- en: AR is all about superimposing computer graphics on top of a camera feed. This
    sounds like a simple thing to do, except that you have to track the camera position
    with great accuracy. Both Google and Apple have written some great APIs to do
    this magic for you, with the help of the motion sensors in your phone and data
    from the camera. The computer graphics that we add on top of the camera feed are
    synced to be in the same coordinate space as the surrounding real-life objects,
    making them appear as if they are part of the image you see on your phone.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: AR的全部内容都是关于在相机反馈的基础上叠加计算机图形。这听起来是一件简单的事情，除了您必须以极高的精度跟踪相机位置。谷歌和苹果都编写了一些很棒的API来为您完成这个魔术，借助手机的运动传感器和相机数据。我们添加到相机反馈上的计算机图形与周围真实物体的坐标空间同步，使它们看起来就像是图像上看到的一部分。
- en: An overview of the project
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, we are going to create a game that explores the fundamentals
    of AR. We are also going to learn how to integrate AR control in Xamarin.Forms.
    Android and iOS implement AR differently, so we will need to unify the platforms
    along the way. We will do this using UrhoSharp, an open source 3D game engine,
    which will do the rendering for us. This is simply made up of bindings to the **Urho3D** engine,
    which allows us to use Urho3D with .NET and C#.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个探索AR基础知识的游戏。我们还将学习如何在Xamarin.Forms中集成AR控制。Android和iOS以不同的方式实现AR，因此我们需要在途中统一平台。我们将使用UrhoSharp，一个开源的3D游戏引擎，来进行渲染。这只是使用.NET和C#与Urho3D绑定的**Urho3D**引擎。
- en: The game will render boxes in AR that the user needs to tap to make disappear.
    You can then extend the game yourself by learning about the Urho3D engine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏将在AR中渲染盒子，用户需要点击以使其消失。然后，您可以通过学习Urho3D引擎来扩展游戏。
- en: The shared code will be placed in a shared project. This is different than the
    usual .NET Standard library approach we have taken so far. The reason for this
    is that UrhoSharp doesn't support .NET Standard (at the time of writing this book).
    It's also a good idea to learn how to create a shared project. The code in a shared
    library will not compile by itself. It needs to be linked to a platform project
    (such as iOS or Android) and then the compiler can compile all the source files
    along with the platform project. This is exactly the same thing as copying the
    files directly into that project. So, by defining a shared project, we don't need
    to write code twice.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 共享代码将放置在一个共享项目中。这与我们迄今为止采取的通常的.NET标准库方法不同。这样做的原因是，UrhoSharp在撰写本书时不支持.NET标准。学习如何创建共享项目也是一个好主意。共享库中的代码本身不会编译。它需要链接到平台项目（如iOS或Android），然后编译器可以编译所有源文件以及平台项目。这与直接将文件复制到该项目中完全相同。因此，通过定义一个共享项目，我们不需要重复编写代码。
- en: 'This strategy also unlocks another powerful feature: **conditional compilation.**
    Consider the following example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略还解锁了另一个强大的功能：**条件编译**。考虑以下示例：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code shows how you can insert platform-specific code inside a
    shared code file. This will come in very handy in this project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示了如何在共享代码文件中插入特定于平台的代码。这在这个项目中将非常有用。
- en: The estimated build time for this project is 90 minutes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的预计构建时间为90分钟。
- en: Beginning the project
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始项目
- en: It's time to start coding! First, however, make sure you have your development
    environment set up as described in [Chapter 1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml), *Introduction
    to Xamarin*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始编码了！但首先，请确保您已经按照[第1章](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml)中描述的设置好了开发环境，*Xamarin简介*。
- en: This chapter will be a classic File | New Project chapter, guiding you step-by-step
    through the process of creating the app. There will be no downloads required whatsoever.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将是一个经典的*文件|新建项目*章节，将逐步指导您完成创建应用程序的过程。完全不需要下载。
- en: Creating the project
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'Open Visual Studio and click on File | New | Project, as shown in the following
    screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Visual Studio，然后点击“文件”|“新建”|“项目”，如下截图所示：
- en: '![](img/6fca819a-f5c0-424e-a0b6-26d2133d2da9.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fca819a-f5c0-424e-a0b6-26d2133d2da9.png)'
- en: 'This will open the New Project dialog. Expand the Visual C# node and click
    on Cross-Platform. Select the Mobile App (Xamarin.Forms) item in the list. Complete
    the form by naming your project. We will be calling our application `WhackABox`
    in this example. Move on to the next dialog box by clicking OK, as shown in the
    following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开“新建项目”对话框。展开“Visual C#”节点，然后单击“跨平台”。在列表中选择“移动应用程序（Xamarin.Forms）”项目。通过为您的项目命名来完成表单。在本示例中，我们将称我们的应用程序为“WhackABox”。点击“确定”继续到下一个对话框，如下截图所示：
- en: '![](img/e3f05ec6-796d-4724-b354-c25d2171e43c.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3f05ec6-796d-4724-b354-c25d2171e43c.png)'
- en: 'The next step is to select a project template and a Code Sharing Strategy.
    Select the Blank template option to create a bare minimum Xamarin.Forms app and
    make sure that the Code Sharing Strategy is set to Shared Project. Uncheck the Windows
    (UWP) checkbox under the Platform heading, since this app will only be supporting
    **iOS** and Android. Finish the setup wizard by clicking OK and let Visual Studio
    scaffold the project for you. This might take a couple of minutes. Please note
    that we will be using a Shared Project for this chapter—this is very important!
    You can see the aforementioned fields and options that you need to select in the
    following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是选择项目模板和代码共享策略。选择“空白模板”选项以创建最基本的Xamarin.Forms应用程序，并确保代码共享策略设置为“共享项目”。在“平台”标题下取消选中“Windows（UWP）”复选框，因为此应用程序只支持**iOS**和Android。点击“确定”完成设置向导，让Visual
    Studio为您创建项目。这可能需要几分钟。请注意，本章我们将使用共享项目——这一点非常重要！您可以在以下截图中看到需要选择的字段和选项：
- en: '![](img/78e4bcf2-f5d5-49a6-a4c1-e3dbefafd2df.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78e4bcf2-f5d5-49a6-a4c1-e3dbefafd2df.png)'
- en: Just like that, the app has been created. Let's move on to updating Xamarin.Forms
    to the latest version.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，应用程序已经创建好了。让我们继续更新Xamarin.Forms到最新版本。
- en: Updating the Xamarin.Forms NuGet packages
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新Xamarin.Forms NuGet包
- en: 'Currently, the Xamarin.Forms version that your project has been created with
    is most likely a bit old. To rectify this, we need to update the NuGet packages.
    Please note that you should only update the Xamarin.Forms packages and not the
    Android packages; updating the Android packages might cause your packages to get
    out of sync with each other, resulting in the app not building at all. To update
    the NuGet packages, go through the following steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您的项目创建时使用的Xamarin.Forms版本很可能有点过时。为了纠正这一点，我们需要更新NuGet包。请注意，您应该只更新Xamarin.Forms包，而不是Android包；更新Android包可能导致包不同步，导致应用程序根本无法构建。要更新NuGet包，请按以下步骤操作：
- en: Right-click on our Solution in the Solution Explorer.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“解决方案资源管理器”中右键单击我们的解决方案。
- en: 'Click Manage NuGet Packages for Solution..., as shown in the following screenshot:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“管理解决方案的NuGet包...”，如下截图所示：
- en: '![](img/542a5038-c9cb-4647-b14f-c940a60a2f88.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/542a5038-c9cb-4647-b14f-c940a60a2f88.png)'
- en: 'This will open the NuGet Package Manager in Visual Studio, as shown in the
    following screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Visual Studio中打开NuGet包管理器，如下截图所示：
- en: '![](img/3a9e444d-fd64-499a-bcc6-afb117c82756.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a9e444d-fd64-499a-bcc6-afb117c82756.png)'
- en: 'To update Xamarin.Forms to the latest version, go through the following steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Xamarin.Forms更新到最新版本，请按以下步骤操作：
- en: Click the Updates tab.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“更新”选项卡。
- en: Check the Xamarin.Forms checkbox and click Update.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选“Xamarin.Forms”复选框，然后点击“更新”。
- en: Accept any license agreements.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受任何许可协议。
- en: The update takes at most a few minutes. Look at the output pane to find information
    about the update. At this point, we can run the app to make sure it works. We
    should see the text Welcome to Xamarin.Forms! in the middle of the screen.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 更新最多需要几分钟。查看输出窗格以获取有关更新的信息。此时，我们可以运行应用程序以确保其正常工作。我们应该在屏幕中央看到“欢迎使用Xamarin.Forms！”的文本。
- en: Setting the Android target to 8.1
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Android目标设置为8.1
- en: 'ARCore is available from Android version 8.1 and later. We will, therefore,
    verify the Target Framework for the Android project by going through the following
    steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ARCore可用于Android 8.1及更高版本。因此，我们将通过以下步骤验证Android项目的目标框架：
- en: Double-click on the Properties node under the Android project in the Solution
    Explorer.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“解决方案资源管理器”中的Android项目下双击“属性”节点。
- en: 'Verify that the Target Framework version is at least Android 8.0 (Oreo), as
    shown in the following screenshot:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证目标框架版本至少为Android 8.0（Oreo），如下截图所示：
- en: '![](img/09fe6cca-4790-4b04-8d7e-d6b20d0c4706.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09fe6cca-4790-4b04-8d7e-d6b20d0c4706.png)'
- en: 'If it''s not at least Android 8.0 (Oreo), you will need to select Android 8.1 (or
    above). If there is an asterisk next to the Target Framework name, then you will
    need to install that SDK by going through the following steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标框架不是至少Android 8.0（Oreo），则需要选择Android 8.1（或更高版本）。如果目标框架名称旁边有一个星号，则需要通过以下步骤安装该SDK：
- en: Locate the Android SDK Manager in the toolbar.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具栏中找到Android SDK Manager。
- en: 'Click the highlighted button to open the SDK Manager, as shown in the following
    screenshot:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击突出显示的按钮打开SDK Manager，如下截图所示：
- en: '![](img/5c98de95-7c5c-4683-8f35-e1186ecf9de8.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c98de95-7c5c-4683-8f35-e1186ecf9de8.png)'
- en: 'This is the control center for all SDK versions of Android that are installed
    on the system:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是系统上安装的所有Android SDK版本的控制中心：
- en: Expand the SDK version you want to install. In our case, this should be at least
    Android 8.1 - Oreo.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开您想要安装的SDK版本。在我们的情况下，这应该至少是Android 8.1 - Oreo。
- en: Select the Android SDK Platform <version number> node. You can also to install emulator
    images that will be used by the emulator to run the selected version of Android.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Android SDK平台<版本号>节点。您还可以安装模拟器映像，供模拟器运行所选版本的Android。
- en: 'Click Apply Changes, as shown in the following screenshot:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“应用更改”，如下截图所示：
- en: '![](img/17c557be-4452-4ce7-83c0-23a5e57fd5ab.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17c557be-4452-4ce7-83c0-23a5e57fd5ab.png)'
- en: Adding the camera permission to Android
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Android添加相机权限
- en: 'In order to get access to the camera in Android we must add a required permission
    in the Android manifest. This can be done by following these steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Android中访问相机，我们必须在Android清单中添加所需的权限。可以通过以下步骤完成：
- en: Open up the Android project node in the Solution Explorer.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中打开Android项目节点。
- en: Double-click the Properties node to open the properties for Android.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击属性节点以打开Android的属性。
- en: Click the Android Manifest tab on the left and scroll down until you see the
    Required permissions section.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击左侧的Android清单选项卡，然后向下滚动，直到看到所需权限部分。
- en: Locate the CAMERA permission and check the box.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位相机权限并选中复选框。
- en: Save the file by clicking *Ctrl* +* S* or File and the Save.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击*Ctrl* +* S*或文件和保存来保存文件。
- en: '![](img/5be70e8f-186b-4838-8e0c-a49cd316f4a7.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5be70e8f-186b-4838-8e0c-a49cd316f4a7.png)'
- en: Now that we have configured Android, we only have one small change to make on
    iOS before we are ready to write some code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了Android，在准备编写一些代码之前，我们只需要在iOS上做一个小小的改变。
- en: Adding Camera Usage Description for iOS
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为iOS添加相机使用说明
- en: In iOS, you need to specify why you need access to the camera. The way to do
    this is to add an entry to the `info.plist` file in the root folder of the iOS
    project. The `info.plist` file is an XML file that you can edit in any text editor.
    A simpler way to this, however, is by using the Generic PList Editor provided
    by Visual Studio.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS中，您需要指定为什么需要访问相机。这样做的方法是在iOS项目的根文件夹中的`info.plist`文件中添加条目。`info.plist`文件是一个XML文件，您可以在任何文本编辑器中编辑。但是，更简单的方法是使用Visual
    Studio提供的通用PList编辑器。
- en: 'Add the required Camera Usage Description using the Generic PList Editor, as
    follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通用PList编辑器添加所需的相机使用说明，如下所示：
- en: Locate the `WhackABox.iOS` project.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位`WhackABox.iOS`项目。
- en: 'Right-click on `info.plist` and click Open With..., as shown in the following
    screenshot:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`info.plist`，然后单击“使用...”，如下面的屏幕截图所示：
- en: '![](img/f854d634-aaab-4c4c-bdcb-6b714cb06938.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f854d634-aaab-4c4c-bdcb-6b714cb06938.png)'
- en: 'Select Generic PList Editor and click OK, as shown in the following screenshot:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择通用PList编辑器，然后单击确定，如下面的屏幕截图所示：
- en: '![](img/98665692-d865-434f-9658-4389050799c0.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98665692-d865-434f-9658-4389050799c0.png)'
- en: Locate the plus (+) icon at the bottom of the property list.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在属性列表的底部找到加号（+）图标。
- en: 'Click the plus (+) icon to add a new key. Make sure that the key is in the
    root of the document and not under another property, as shown in the following
    screenshot:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击加号（+）图标以添加新键。确保密钥位于文档的根目录下，而不是在另一个属性下，如下面的屏幕截图所示：
- en: '![](img/abd89c94-b4d9-419f-af0e-8f374d027598.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/abd89c94-b4d9-419f-af0e-8f374d027598.png)'
- en: 'The Generic PList Editor helps you to find the right property by giving it
    a more user-friendly name. Let''s add the value we need to describe why we want
    to use the camera:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通用PList编辑器通过给属性提供更用户友好的名称来帮助您找到正确的属性。让我们添加我们需要的值来描述我们为什么要使用相机：
- en: Open the drop-down menu on the newly created row.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的行上打开下拉菜单。
- en: Select Privacy - Camera Usage Description.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择隐私-相机使用说明。
- en: 'Write a good reason in the values field to the right, as shown in the following
    screenshot. The field for the reason is a free-text field, so use plain English
    to describe why your app needs access to the camera:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧的值字段中写一个好的理由，如下面的屏幕截图所示。原因字段是一个自由文本字段，因此请使用简单的英语描述您的应用程序为什么需要访问相机：
- en: '![](img/14005e35-6acb-427d-be52-79da6f75f4e3.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14005e35-6acb-427d-be52-79da6f75f4e3.png)'
- en: That's it. The setup of both Android and iOS is complete, and we can now focus
    on the fun part—writing code!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。 Android和iOS的设置已经完成，现在我们可以专注于有趣的部分-编写代码！
- en: You can also open the `Info.plist` file in any text editor, since it's an XML
    file. The key's name is
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在任何文本编辑器中打开`Info.plist`文件，因为它是一个XML文件。密钥的名称是
- en: '`NSCameraUsageDescription`, and it must be added as a direct child of the root
    node.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSCameraUsageDescription`，并且必须作为根节点的直接子节点添加。'
- en: Defining the user interface
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义用户界面
- en: We are going to start off by defining the user interface that will wrap the
    AR components. First, we will define a custom control that we will use as a placeholder
    for injecting an `UrhoSurface` that will contain the AR components. Then, we will
    add this control in a grid that will contain some statistics about how many planes
    we have found and how many boxes are active in the world. The goal of the game
    is to find boxes in AR using your phone and tapping on them to make them disappear.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义将包装AR组件的用户界面。首先，我们将定义一个自定义控件，我们将使用它作为注入包含AR组件的`UrhoSurface`的占位符。然后，我们将在包含有关我们在AR中找到多少平面以及世界中有多少活动箱子的网格中添加此控件。游戏的目标是在AR中使用手机找到箱子，并点击它们使它们消失。
- en: Let's start by defining the custom `ARView` control.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义自定义的`ARView`控件。
- en: Creating the ARView control
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ARView控件
- en: The `ARView` control belongs in the shared project, since it will be a part
    of both applications. It's a standard Xamarin.Forms control that inherits directly
    from `Xamarin.Forms.View`. It will not load any XAML (so it will simply be a single
    class), nor will it contain any functionality other than simply being defined,
    so we can add it to the main grid.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARView`控件属于共享项目，因为它将成为两个应用程序的一部分。它是一个标准的Xamarin.Forms控件，直接从`Xamarin.Forms.View`继承。它不会加载任何XAML（因此它只是一个单一的类），也不会包含任何功能，只是简单地被定义，因此我们可以将它添加到主网格中。'
- en: 'Go over to Visual Studio and go through the following three steps to create
    an `ARView` control:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 转到Visual Studio，并按照以下三个步骤创建`ARView`控件：
- en: In the `WhackABox` project, add a folder called `Controls`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，添加一个名为`Controls`的文件夹。
- en: Create a new class called `ARView` in the `Controls` folder.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Controls`文件夹中创建一个名为`ARView`的新类。
- en: 'Add the following code to the `ARView` class:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`ARView`类中：
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What we have created here is a simple class, without implementation, that inherits
    from `Xamarin.Forms.View`. The point of this is to make use of custom renderers
    for each platform, allowing us to specify platform-specific code to be inserted
    at the place in the XAML where we put this control. Your project should now look
    as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建了一个简单的类，没有实现，它继承自`Xamarin.Forms.View`。这样做的目的是利用每个平台的自定义渲染器，允许我们指定特定于平台的代码插入到我们放置这个控件的XAML中。您的项目现在应该如下所示：
- en: '![](img/3dc949c2-7455-4476-b9c9-3b7018741a3b.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3dc949c2-7455-4476-b9c9-3b7018741a3b.png)'
- en: The `ARView` control is no good just sitting there. We need to add it to the
    `MainPage`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARView`控件就那样坐在那里是不行的。我们需要将它添加到`MainPage`中。'
- en: Modifying the MainPage
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改MainPage
- en: 'We will be replacing the entire contents of the `MainPage` and adding a reference
    to the `WhackABox.Controls` namespace so that we can use the `ARView` control.
    Let''s set this up by going through the following steps:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将替换`MainPage`的全部内容，并添加对`WhackABox.Controls`命名空间的引用，以便我们可以使用`ARView`控件。让我们通过以下步骤来设置这个：
- en: In the `WhackABox` project, open the `MainPage.xaml` file.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`MainPage.xaml`文件。
- en: 'Edit the XAML to look like the following code. The XAML in bold represents
    the new elements that must be added:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑XAML以使其看起来像以下代码。粗体的XAML表示必须添加的新元素：
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Now that we have the code, let''s go through it step by step:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了代码，让我们一步一步地来看：
- en: First, we define a controls namespace that points to the `WhackABox.Controls`
    namespace in code. This namespace is used at the end of the XAML to locate the
    `ARView` control.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个控件命名空间，指向代码中的`WhackABox.Controls`命名空间。这个命名空间用于在XAML末尾定位`ARView`控件。
- en: We then define the content element by setting it to a `Grid`. A page can only
    have one child, which, in this case, is a `Grid`. The `Grid` defines two columns
    and two rows. The columns split the `Grid` into two equal parts, where we have
    one row that is `100` units high at the top and one row that takes up all the
    available space below it.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们通过将其设置为`Grid`来定义内容元素。一个页面只能有一个子元素，在这种情况下是一个`Grid`。`Grid`定义了两列和两行。列将`Grid`分成两个相等的部分，其中有一行在顶部高度为`100`个单位，另一行占据了下面所有可用的空间。
- en: We use the top two cells to add instances of `StackLayout` that contain the
    information about the number of planes and the number of boxes in the game. The
    location of those instances of `StackLayout` in the grid is defined by the `Grid.Row=".."`
    and `Grid.Column=".."` attributes. Remember that the rows and columns are zero
    based. You don't actually have to add attributes for row or column `0`, but it
    can sometimes be a good practice to improve code readability.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用前两个单元格来添加`StackLayout`的实例，其中包含游戏中平面数量和箱子数量的信息。这些`StackLayout`的实例在网格中的位置由`Grid.Row=".."`和`Grid.Column=".."`属性定义。请记住，行和列是从零开始的。实际上，您不必为行或列`0`添加属性，但有时为了提高代码可读性，这样做可能是一个好习惯。
- en: Finally, we have the `ARView` control, which resides in row `1` but spans both
    columns by specifying `Grid.ColumnSpan="2"`.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有`ARView`控件，它位于第1行，但通过指定`Grid.ColumnSpan="2"`跨越了两列。
- en: The next step is to install UrhoSharp, which will be our library for rendering
    graphics to represent the augmented part of our reality.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是安装UrhoSharp，它将是我们用来渲染表示现实增强部分的图形的库。
- en: Adding Urhosharp
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Urhosharp
- en: Urho is an open source 3D game engine. UrhoSharp is a package that contains
    bindings to iOS and Android binaries, enabling us to use Urho in .NET. It is a
    very competent piece of software, and we will only be using a very small part
    of it to do the heavy lifting when it comes to rendering planes and boxes in the
    app. We urge you to find out more about UrhoSharp to add your own cool features
    to the app.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Urho是一个开源的3D游戏引擎。UrhoSharp是一个包，其中包含了对iOS和Android二进制文件的绑定，使我们能够在.NET中使用Urho。这是一个非常有竞争力的软件，我们只会使用它的一小部分来在应用程序中渲染平面和箱子。我们建议您了解更多关于UrhoSharp的信息，以添加您自己的酷功能到应用程序中。
- en: All you have to do to install UrhoSharp is download a NuGet package for each
    platform. The iOS platform uses the UrhoSharp NuGet package, and Android uses
    the UrhoSharp.ARCore package. Also, in Android, we need to add some code to wire
    up life cycle events, but we will get to that later. Basically, we will set up
    an `UrhoSurface` on each platform. We will access this to add nodes to the node
    tree. These nodes will then be rendered based on their type and properties.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 安装UrhoSharp只需要为每个平台下载一个NuGet包。iOS平台使用UrhoSharp NuGet包，Android使用UrhoSharp.ARCore包。此外，在Android中，我们需要添加一些代码来连接生命周期事件，但我们稍后会讲到。基本上，我们将在每个平台上设置一个`UrhoSurface`。我们将访问这个平台以向节点树添加节点。然后根据它们的类型和属性来渲染这些节点。
- en: First, however, we need to install the packages.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要安装这些包。
- en: Installing the UrhoSharp NuGet package for iOS
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为iOS安装UrhoSharp NuGet包
- en: 'All we need to do for iOS is to add the UrhoSharp NuGet package. This contains
    everything we need for our AR app. You can add the package as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于iOS，我们只需要添加UrhoSharp NuGet包。这个包包含了我们AR应用所需的一切。您可以按照以下步骤添加该包：
- en: Right-click on the `WhackABox.iOS` project.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`WhackABox.iOS`项目。
- en: 'Click Manage NuGet Packages..., as shown in the following screenshot:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“管理NuGet包...”，如下截图所示：
- en: '![](img/7beed9e8-ee72-4937-8275-18b877598992.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7beed9e8-ee72-4937-8275-18b877598992.png)'
- en: This opens the NuGet Package Manager. Click the Browse link on the top-left
    of the window.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开NuGet包管理器。点击窗口左上角的“浏览”链接。
- en: Enter `UrhoSharp`in the search box and hit *Enter*.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入`UrhoSharp`，然后按*Enter*。
- en: 'Select the UrhoSharppackage and click `Install` on the right side of the window,
    as shown in the following screenshot:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择UrhoSharp包，并在窗口右侧点击“安装”，如下截图所示：
- en: '![](img/30731bb9-fc86-4d9b-aa35-cbb970ec2fef.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30731bb9-fc86-4d9b-aa35-cbb970ec2fef.png)'
- en: That's it for iOS. Android is a little bit trickier to set up, since it needs
    a special UrhoSharp package and some code to be written to wire everything up.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是iOS的全部内容。Android设置起来有点棘手，因为它需要一个特殊的UrhoSharp包和一些代码来连接一切。
- en: Installing the UrhoSharp.ARCore Nuget Package for Android
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Android安装UrhoSharp.ARCore Nuget包
- en: 'For Android, we will be adding the UrhoSharp.ARCore package, which contains
    extensions for ARCore. It has a dependency on UrhoSharp, so we don''t have to
    add that package specifically. You can add theUrhoSharp.ARCore package as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，我们将添加UrhoSharp.ARCore包，其中包含ARCore的扩展。它依赖于UrhoSharp，因此我们不必专门添加该包。您可以按照以下方式添加UrhoSharp.ARCore包：
- en: Right-click on the `WhackABox.Android` project.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`WhackABox.Android`项目。
- en: 'Click Manage NuGet Packages..., as shown in the following screenshot:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“管理NuGet包...”，如下截图所示：
- en: '![](img/39392973-f2c7-4730-8438-00c3ac2c14fd.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39392973-f2c7-4730-8438-00c3ac2c14fd.png)'
- en: This opens the NuGet Package Manager. Click the Browse link on the top-left
    of the window.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开NuGet包管理器。单击窗口左上角的“浏览”链接。
- en: Enter `UrhoSharp.ARCore` in the search box and hit *Enter*.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入`UrhoSharp.ARCore`，然后按*Enter*。
- en: 'Select the UrhoSharp.ARCore package and click Install on the right side of
    the window, as shown in the following screenshot:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择UrhoSharp.ARCore包，然后单击窗口右侧的“安装”，如下截图所示：
- en: '![](img/54863d4c-bb64-4284-a05e-97865506710e.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54863d4c-bb64-4284-a05e-97865506710e.png)'
- en: That's it—all your dependencies on UrhoSharp have been installed in the project.
    We now have to wire up some life cycle events.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部——您的项目中所有对UrhoSharp的依赖项都已安装。现在我们必须连接一些生命周期事件。
- en: Adding the Android life cycle events
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Android生命周期事件
- en: 'In Android, `Urho` needs to know about some specific events and be able to
    respond to them accordingly. We also need to add an internal message using `MessagingCenter`
    so that we can react to the `OnResume` event later on in the app. We will get
    to that when we add the code to initialize ARCore. But for now, add the five required
    overrides for Android events, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，`Urho`需要知道一些特定事件，并能够相应地做出响应。我们还需要使用`MessagingCenter`添加内部消息，以便稍后在应用程序中对`OnResume`事件做出反应。在初始化ARCore时我们将会做到这一点。但现在，按照以下方式添加Android事件的五个必需重写：
- en: In the Android project, open `MainActivity.cs`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android项目中，打开`MainActivity.cs`。
- en: Add the five overrides from the following code anywhere in the `MainActivity`
    class.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`类的任何位置添加以下代码中的五个重写。
- en: 'Resolve the unresolved references by adding `using` statements for `Urho.Droid`
    and `Xamarin.Forms`, as shown in the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过为`Urho.Droid`和`Xamarin.Forms`添加`using`语句来解决未解析的引用，如下所示：
- en: '[PRE3]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The events map one-on-one to internal UrhoSharp events, except for `OnBackPressed`,
    which calls `UrhoSharp.OnDestroy()`. The reason for this is memory management,
    so that UrhoSharp knows when to clean up.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件一一映射到内部的UrhoSharp事件，除了`OnBackPressed`，它调用`UrhoSharp.OnDestroy()`。这样做是为了内存管理，以便UrhoSharp知道何时清理。
- en: The `MessagingCenter` library is a built-in Xamarin.Forms pub-sub library for
    passing internal messages in an app. It has a dependency on Xamarin.Forms. We
    have created a library of our own called `TinyPubSub` that breaks this dependency
    and has a slightly easier API (as well as some additional features). You can check
    it out on GitHub at [https://github.com/TinyStuff/TinyPubSub](https://github.com/TinyStuff/TinyPubSub).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessagingCenter`库是一个内置的Xamarin.Forms发布-订阅库，用于在应用程序中传递内部消息。它依赖于Xamarin.Forms。我们创建了一个名为`TinyPubSub`的自己的库，它打破了这种依赖关系，并且具有稍微更容易的API（以及一些附加功能）。您可以在GitHub上查看它：[https://github.com/TinyStuff/TinyPubSub](https://github.com/TinyStuff/TinyPubSub)。'
- en: Defining the PlaneNode
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义PlaneNode
- en: In `Urho`, you work with scenes that contain a tree of nodes. A node can be
    just about anything in the game, such as a renderer, a sound player, or simply
    a placeholder for subnodes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Urho`中，您将使用包含节点树的场景。节点可以是游戏中的几乎任何东西，比如渲染器、声音播放器，或者只是子节点的占位符。
- en: As we talked about earlier when discussing AR fundamentals, planes are a common
    entity that is shared between the platforms. We need to create a common ground
    that represents a plane, which we can do by extending an `Urho` node. The position
    and the rotation will be tracked by the node itself, but we need to add a property
    to track the origin and the size of the plane, expressed by ARKit and ARCore as
    the extent of the plane.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在讨论AR基础知识时所说的，平面是在平台之间共享的常见实体。我们需要创建一个代表平面的共同基础，这可以通过扩展`Urho`节点来实现。位置和旋转将由节点本身跟踪，但我们需要添加一个属性来跟踪平面的原点和大小，由ARKit和ARCore表示为平面的范围。
- en: 'We will add this class now and put it to use when we implement the AR-related
    code on each platform. The code to do this is straightforward, and can be set
    up by going through the following steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将添加这个类，并在每个平台上实现AR相关代码时使用它。这样做的代码很简单，可以通过以下步骤设置：
- en: In the `WhackABox` project, create a new file called `PlaneNode.cs` in the root
    of the project.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，在项目的根目录创建一个名为`PlaneNode.cs`的新文件。
- en: 'Add the following implementation of the class:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下类的实现：
- en: '[PRE4]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `PlaneId` will be an identifier that allows us to track which platform-specific
    plane this node represents. In iOS, this will be a string, while in Android, it
    will be the hashcode of the plane-object that is converted to a string. The `ExtentY`
    and `ExtentZ` properties represent the size of the plane in meters. We are now
    ready to start creating the game logic and hooking up our application to the AR
    SDKs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlaneId`将是一个标识符，允许我们跟踪此节点代表的特定于平台的平面。在iOS中，这将是一个字符串，而在Android中，它将是转换为字符串的平面对象的哈希码。`ExtentY`和`ExtentZ`属性表示平面的大小（以米为单位）。我们现在准备开始创建游戏逻辑，并将我们的应用程序连接到AR
    SDK。'
- en: Adding custom renderers for the ARView control
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为ARView控件添加自定义渲染器
- en: Custom renderers are a very smart way of extending platform-specific behaviors
    to custom controls. They can also be used to override behaviors on controls that
    are already defined. In fact, all of the controls in Xamarin.Forms use renderers
    to translate the Xamarin.Forms control into a platform-specific control.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义渲染器是将特定于平台的行为扩展到自定义控件的一种非常聪明的方式。它们还可以用于覆盖已定义的控件上的行为。事实上，Xamarin.Forms中的所有控件都使用渲染器将Xamarin.Forms控件转换为特定于平台的控件。
- en: We are going to create two renderers, one for iOS and one for Android, that
    initialize the `UrhoSurface` on which we are going to render. The instantiation
    of the `UrhoSurface` differs on each platform, which is why we need two different
    implementations.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个渲染器，一个用于iOS，一个用于Android，它们将初始化我们将要渲染的`UrhoSurface`。`UrhoSurface`的实例化在每个平台上都有所不同，这就是为什么我们需要两种不同的实现。
- en: For iOS
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于iOS
- en: 'A custom renderer is a class that inherits from another renderer. It allows
    us to add custom code for important events, such as when an element in XAML is
    created when the XAML file is parsed. Since the `ARView` control inherits from
    the `View`, we will be using the `ViewRenderer` as a base class. Let''s create
    the `ARViewRenderer` by going through the following steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义渲染器是从另一个渲染器继承的类。它允许我们为重要事件添加自定义代码，例如在解析XAML文件时创建XAML元素时。由于`ARView`控件继承自`View`，我们将使用`ViewRenderer`作为基类。通过以下步骤创建`ARViewRenderer`：
- en: In the iOS project, create a folder called `Renderers`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在iOS项目中，创建一个名为`Renderers`的文件夹。
- en: Add a new class called `ARViewRenderer` to that folder.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件夹中添加一个名为`ARViewRenderer`的新类。
- en: 'Add the following code to the class:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类中：
- en: '[PRE5]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `ExportRenderer` attribute registers this renderer to Xamarin.Forms so
    that it knows that when it parses (or compiles) an `ARView` element, it should
    render it using this specific renderer. It takes two arguments: the first is the
    `Control` that we want to register a renderer to and the second is the type of
    the renderer. This attribute must be placed outside the namespace declarations.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExportRenderer`属性将此渲染器注册到Xamarin.Forms，以便它知道当解析（或编译）`ARView`元素时，应该使用此特定的渲染器进行渲染。它接受两个参数：第一个是我们要注册渲染器的`Control`，第二个是渲染器的类型。此属性必须放在命名空间声明之外。'
- en: The `ARViewRenderer` class inherits `ViewRenderer<ARView, UrhoSurface>`. This
    specifies which control this renderer is created for and which native control
    it should render. In this case, the `ARView` will be natively replaced by a `UrhoSurface`
    control that in itself is an iOS-specific `UIView`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARViewRenderer`类继承自`ViewRenderer<ARView, UrhoSurface>`。这指定了此渲染器为哪个控件创建，以及它应该渲染哪个本地控件。在这种情况下，`ARView`将被一个`UrhoSurface`控件本地替换，这本身是一个iOS特定的`UIView`。'
- en: We override the `OnElementChanged()` method that is called every time the `ARView`
    element changes, either when it is created or when it is replaced. We can then
    check whether the `Control` property is set. The control is of the `UrhoSurface` type, since
    we declared that in the class definition. If it's `null`, then we make a call
    to `Initialize()` to create it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写`OnElementChanged()`方法，该方法在`ARView`元素每次更改时被调用，无论是创建还是替换。然后我们可以检查`Control`属性是否已设置。控件是`UrhoSurface`类型，因为我们在类定义中声明了它。如果它是`null`，那么我们就调用`Initialize()`来创建它。
- en: The creation is straightforward. We simply create a new `UrhoSurface` control
    and set the native control to this newly created object. We then call the `Show<Game>()`
    method to start the game by specifying which class represents our `Urho` game.
    Note that the `Game` class is not defined yet, but it will be very soon, right
    after we create the custom renderer for Android.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 创建非常简单。我们只需创建一个新的`UrhoSurface`控件，并将本地控件设置为这个新创建的对象。然后我们调用`Show<Game>()`方法来启动游戏，指定代表我们的`Urho`游戏的类。请注意，`Game`类尚未定义，但它将很快定义，就在我们为Android创建自定义渲染器之后。
- en: For Android
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于Android
- en: 'The custom renderer for Android does the same thing as it does for iOS, but
    with the additional step of checking permissions. Let''s create the `ARViewRenderer`
    for Android by going through the following steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Android的自定义渲染器与iOS的自定义渲染器做的事情相同，但还需要检查权限。通过以下步骤创建Android的`ARViewRenderer`：
- en: In the Android project, create a folder called `Renderers`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android项目中，创建一个名为`Renderers`的文件夹。
- en: Add a new class called `ARViewRenderer` to that folder.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件夹中添加一个名为`ARViewRenderer`的新类。
- en: 'Add the following code to the class:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类中：
- en: '[PRE6]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This custom renderer also inherits from `ViewRenderer<T1, T2>`, where the first
    type is the type of the renderer itself and the second is the native control that
    the renderer will produce. In this case, the native control will be a control
    that inherits from `Android.Views.View`. The renderer creates a `UrhoSurfacePlaceholder`
    instance, which it assigns as the native control. The `UrhoSurfacePlaceholder`
    is a class that wraps some functionality of the **Simple DirectMedia Layer** (**SDL**)
    library that `Urho` uses on Android to access media functionality. The last thing
    it does is to start the game based on the soon-to-exist `Game`class. We will define
    this in the next section of this chapter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自定义渲染器也继承自`ViewRenderer<T1, T2>`，其中第一个类型是渲染器本身的类型，第二个是渲染器将生成的本地控件的类型。在这种情况下，本地控件将是一个继承自`Android.Views.View`的控件。渲染器创建一个`UrhoSurfacePlaceholder`实例，并将其分配为本地控件。`UrhoSurfacePlaceholder`是一个包装`Urho`在Android上使用的**Simple
    DirectMedia Layer**（**SDL**）库的一些功能的类，用于访问媒体功能。它的最后一步是基于即将存在的`Game`类启动游戏。我们将在本章的下一部分中定义这个类。
- en: Creating the game
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建游戏
- en: 'To write an application that uses `Urho`, we need to create a class that inherits
    from `Urho.Application`. This class defines some virtual methods that we can use
    to set up the scene. The method we will use is `Start()`. Before that, however,
    we need to create the class. The class will be split into three files using partial
    classes, as described in the following list:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个使用`Urho`的应用程序，我们需要创建一个从`Urho.Application`继承的类。这个类定义了一些虚拟方法，我们可以用来设置场景。我们将使用的方法是`Start()`。然而，在那之前，我们需要创建这个类。这个类将被分成三个文件，使用部分类来描述，如下列表所述：
- en: The `Game.cs` file, which will contain code that is cross platform
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Game.cs`文件中将包含跨平台的代码'
- en: The `Game.iOS.cs` file, which will contain code that will only be compiled in
    the iOS version of the app
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Game.iOS.cs`文件中将包含仅在应用的iOS版本中编译的代码'
- en: The `Game.Android.cs` file, which will contain code that will only be compiled
    in the Android version of the app
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Game.Android.cs`文件中将包含仅在应用的Android版本中编译的代码'
- en: We will be using a conditional compile to do so. We discussed conditional compiling
    in the introduction to this project. Simply put, this means that we can use something
    called **preprocessor directives** to determine at compile time whether the code
    should be included. In practice, this means that we will be compiling different
    code in Android and iOS by defining the same `InitializeAR()` method in both `Game.iOS.cs`
    and `Game.Android.cs`. During initialization, we will call this method, and, depending
    on which platform we run it on, it will be implemented differently. This can only
    be done with a shared project.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用条件编译来实现。我们在项目介绍中讨论了条件编译。简单来说，这意味着我们可以使用称为**预处理指令**的东西来确定在编译时是否应该包含代码。实际上，这意味着我们将通过在`Game.iOS.cs`和`Game.Android.cs`中定义相同的`InitializeAR()`方法来在Android和iOS中编译不同的代码。在初始化期间，我们将调用此方法，并且根据我们在其上运行的平台，它将以不同的方式实现。这只能通过共享项目完成。
- en: Visual Studio has excellent support for conditional compiling and will resolve
    the correct references depending on which project you have set as the startup
    project or what you select in the toolbar above the code file itself.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio对条件编译有很好的支持，并且将根据您设置为启动项目的项目或您在代码文件本身上方的工具栏中选择的项目来解析正确的引用。
- en: For this project, we could have moved the `Game.iOS.cs` file to the iOS project
    and the `Game.Android.cs` and removed the conditional compile preprocessor statements.
    The app would compile just fine, but for the purposes of learning how this works,
    we will include them in the shared project. This could also be a positive thing,
    since we are gathering related code in one place, making it easier to understand
    the architecture.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们可以将`Game.iOS.cs`文件移动到iOS项目中，将`Game.Android.cs`文件移动到Android项目中，并删除条件编译预处理语句。应用程序将编译正常，但为了学习如何工作，我们将把它们包含在共享项目中。这也可能是一个积极的事情，因为我们将相关代码聚集在一起，使架构更容易理解。
- en: Adding the shared partial Game class
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加共享的部分Game类
- en: 'We start by creating the `Game.cs` file that will contain shared code. Let''s
    set this up by going through the following steps:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建包含共享代码的`Game.cs`文件。让我们通过以下步骤设置这个：
- en: In the `WhackABox` project, create a new file called `Game.cs` in the root of
    the project.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，在项目的根目录下创建一个名为`Game.cs`的新文件。
- en: 'Add the following code to the class:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类中：
- en: '[PRE7]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first thing to notice is the `partial` keyword in the class. This indicates
    to the compiler that this is not the entire implementation, and that more code
    will be present in other files. The code in those files will be treated as if
    it were in this file; it's a nice way to split large implementations into different
    files.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是类中的`partial`关键字。这告诉编译器这不是整个实现，还会在其他文件中存在更多的代码。那些文件中的代码将被视为在这个文件中; 这是将大型实现拆分成不同文件的好方法。
- en: The `Game` inherits from `Urho.Application`, which will do most of the work
    regarding the game itself. We define a property called `scene` of the `Scene`type.
    A `Scene` in `Urho` represents one screen of the game (we could have different
    scenes for different parts of a game or for a menu, for example). In this game,
    we will only be defining one scene, which will be initialized later. A `scene`
    maintains a hierarchy of nodes that compose it, and each node can have any number
    of children and any number of components. It's the components that do the work.
    Later on, for example, we will be rendering boxes, which will be represented by
    a node that will have a `Box` component attached.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game`继承自`Urho.Application`，它将处理关于游戏本身的大部分工作。我们定义了一个名为`scene`的`Scene`类型的属性。在`Urho`中，`Scene`代表游戏的一个屏幕（例如，我们可以为游戏的不同部分或菜单定义不同的场景）。在这个游戏中，我们只会定义一个场景，稍后将对其进行初始化。一个`scene`维护了组成它的节点的层次结构，每个节点可以有任意数量的子节点和任意数量的组件。它是组件在工作。例如，稍后我们将渲染盒子，这将由一个附加了`Box`组件的节点表示。'
- en: The `Game` class itself is instantiated from the custom renderers that we defined
    in the earlier section, and it takes an `ApplicationOptions` instance as a parameter
    in the constructor. This needs to be passed to the base class. We now need to
    write some methods that will be AR specific and used by the code we will write
    later on.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game`类本身是从我们在前面部分定义的自定义渲染器中实例化的，并且它在构造函数中以`ApplicationOptions`实例作为参数。这需要传递给基类。现在我们需要编写一些将是AR特定的并且将在以后编写的代码中使用的方法。'
- en: CreateSubPlane
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CreateSubPlane
- en: The first method is the `CreateSubPlane()` method. When the application finds
    a plane on which we can place objects, it will create a node. We will write that
    code specifically for each platform soon. This node also defines a subplane that
    will position a box, representing the position and size of that plane. We have
    already defined the `PlaneNode` class earlier in this chapter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法是`CreateSubPlane()`方法。当应用程序找到可以放置对象的平面时，它将创建一个节点。我们很快将为每个平台编写该代码。该节点还定义了一个子平面，将定位一个代表该平面位置和大小的盒子。我们已经在本章前面定义了`PlaneNode`类。
- en: 'Let''s add the code by going through the following steps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤添加代码：
- en: In the `WhackABox` project, open the `Game.cs` class.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.cs`类。
- en: 'Add the following `CreateSubPlane()` method to the class:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`CreateSubPlane()`方法添加到类中：
- en: '[PRE8]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Any class inheriting from **`Urho.Node`**, such as `PlaneNode`, has the `CreateChild()` method.
    This allows us to create a child node and specify a name for that node. That name
    will be used later on to find specific children to perform operations on. We position
    the node at the same position as the parent node, except that we raise it `0.05`
    meters (5 cm) above the plane.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 任何从**`Urho.Node`**继承的类，比如`PlaneNode`，都有`CreateChild()`方法。这允许我们创建一个子节点并为该节点指定一个名称。稍后将使用该名称来查找特定的子节点执行操作。我们将节点定位在与父节点相同的位置，只是将其提高`0.05`米（5厘米）以上平面。
- en: To see the plane, we add a `box` component with a semitransparent red color.
    The `box` is a component that is created with a call to `CreateComponent()` on
    our node. The color is defined in the AARRGGBB pattern, where AA is the alpha
    component (the transparency) and RRGGBB is the standard red-green-blue format.
    We use hexadecimal representation of the colors.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到平面，我们添加了一个半透明红色的`box`组件。`box`是通过在我们的节点上调用`CreateComponent()`创建的组件。颜色以AARRGGBB模式定义，其中AA是alpha分量（透明度），RRGGBB是标准的红绿蓝格式。我们使用颜色的十六进制表示。
- en: UpdateSubPlane
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UpdateSubPlane
- en: 'Both ARKit and ARCore update planes continuously. What we are interested in
    are changes in the position of a subplane and the extent of it. By extension,
    we are referring to the size of the plane. Let''s set this up by going through
    the following steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ARKit和ARCore都会持续更新平面。我们感兴趣的是子平面位置和其范围的变化。通过扩展，我们指的是平面的大小。让我们通过以下步骤来设置这个：
- en: In the `WhackABox` project, open the `Game.cs` class.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.cs`类。
- en: 'Add the `UpdateSubPlane()` method in the code anywhere in the `Game.cs` class,
    as shown in the following code:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Game.cs`类的任何位置添加`UpdateSubPlane()`方法，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The method takes the `PlaneNode` that we want to update, along with a new position
    for it. We locate the subplane by querying the current node for any node called
    `"subplane"`. Remember that we named the subplane in the `AddSubPlane()` method.
    We can now easily access the node by name. We update the scale of the subplane
    node by taking the `ExtentX` and `ExtentZ` properties from the `PlaneNode`. The
    plane node will be updated by some platform-specific code before we call `UpdateSubPlane().` Finally,
    we set the position of the subplane to the passed `position `parameter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受我们想要更新的`PlaneNode`以及一个新的位置。我们通过查询当前节点中名为“subplane”的任何节点来定位子平面。请记住，我们在`AddSubPlane()`方法中命名了子平面。现在我们可以很容易地通过名称访问节点。我们通过从`PlaneNode`中获取`ExtentX`和`ExtentZ`属性来更新子平面节点的比例。在调用`UpdateSubPlane()`之前，平面节点将通过一些特定于平台的代码进行更新。最后，我们将子平面的位置设置为传递的`position`参数。
- en: FindNodeByPlaneId
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FindNodeByPlaneId
- en: We need a method to quickly find nodes. Both ARKit and ARCore keep an internal
    track of their planes, and to map those internal representations of planes to
    our `PlaneNode`, we have to assign a custom ID to a plane when it's created. This
    will be done in the platform-specific code, but we can still write the function
    to query the scene for `PlaneNode`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个快速找到节点的方法。ARKit和ARCore都会持续更新平面。我们感兴趣的是子平面位置和其范围的变化。通过扩展，我们指的是平面的大小。让我们通过以下步骤来设置这个：
- en: 'The `PlaneNode` is a `string`, since ARKit defines the plane ID in a form that
    resembles a **Global Unique Identifier** (**GUID**). A GUID is a structured sequence
    of hexadecimal numbers that can be represented in a `string` format, as shown
    in the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlaneNode`是一个`string`，因为ARKit以类似**全局唯一标识符**（**GUID**）的形式定义了平面ID。GUID是一系列十六进制数字的结构化序列，可以以`string`格式表示，如下面的代码所示：'
- en: '[PRE10]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The method queries the scene by using `Linq` and looks for the first child with
    the plane ID that it was given. If it can't find one, it returns `null`, since
    `null` is the default value of a reference type object.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法使用`Linq`查询场景，并查找具有给定平面ID的第一个子节点。如果找不到，则返回`null`，因为`null`是引用类型对象的默认值。
- en: These are all of the methods that we need in the shared code before dropping
    down into ARKit and ARCore.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我们在共享代码中下降到ARKit和ARCore之前需要的所有方法。
- en: Adding platform-specific partial classes
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加特定于平台的部分类
- en: It's now time to take advantage of conditional compiling. We will create two
    partial classes, one for iOS and one for Android, that will be conditionally compiled
    into the `Game` class.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是利用条件编译的时候了。我们将创建两个部分类，一个用于iOS，一个用于Android，它们将有条件地编译到`Game`类中。
- en: In this section, we will simply set up the skeleton code for these files.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将简单地为这些文件设置骨架代码。
- en: Adding the iOS-specific partial class
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加特定于iOS的部分类
- en: 'Let''s start by creating the `partial` class for `Game` on iOS and wrapping
    the whole code file within a preprocessor directive that specifies that this code
    will only be compiled on iOS:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在iOS上创建`Game`的`partial`类开始，并将整个代码文件包装在一个预处理指令中，指定这段代码只会在iOS上编译：
- en: In the `WhackABox` project, add a new file called `Game.iOS.cs`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，添加一个名为`Game.iOS.cs`的新文件。
- en: Rename the class `Game` in the code, if Visual Studio doesn't do it automatically.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Visual Studio没有自动完成，可以在代码中重命名`Game`类。
- en: Make the class `public` and `partial`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使类`public`和`partial`。
- en: 'Add the `#if`and `#endif` preprocessor directives to allow for conditional
    compiling, as shown in the following code:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`#if`和`#endif`预处理指令，以允许条件编译，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first line of code is a preprocessor directive that the compiler will use
    to determine whether the code within the `#if` and `#endif` directives should
    be included in the compilation. If it is included, a `partial` class will be defined.
    The code in this class can be iOS specific, even though we are defining it in
    the shared project. Visual Studio is smart enough to treat any code within this
    section as if it were present directly in the iOS project. There will be no problem
    with instantiating a `UIView` here, since the code will never be compiled for
    any platform other than iOS.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一行是一个预处理指令，编译器将使用它来确定`#if`和`#endif`指令内的代码是否应该包含在编译中。如果包含，将定义一个`partial`类。这个类中的代码可以是特定于iOS的，即使我们在共享项目中定义它。Visual
    Studio足够智能，可以将这个部分中的任何代码视为直接存在于iOS项目中。在这里实例化`UIView`不会有问题，因为该代码永远不会被编译到除iOS之外的任何平台。
- en: Adding the Android-specific partial class
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加特定于Android的部分类
- en: 'The same goes for Android: only the name of the file and the preprocessor directive changes.
    Let''s set this up by going through the following steps:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于Android：只有文件名和预处理指令会改变。让我们通过以下步骤来设置这个：
- en: In the `WhackABox` project, add a new file called `Game.Android.cs`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，添加一个名为`Game.Android.cs`的新文件。
- en: Rename the class `Game` in the code, if Visual Studio doesn't do it automatically.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Visual Studio没有自动完成，就在代码中重命名`Game`类。
- en: Make the class `public` and `partial`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使类`public`和`partial`。
- en: 'Add the `#if` and `#endif` conditional compile statements, as shown in the
    following code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`#if`和`#endif`条件编译语句，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As with iOS, only code for Android will ever be compiled between the `#if` and
    `#endif` statements.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与iOS一样，只有在`#if`和`#endif`语句之间才会编译Android的代码。
- en: Let's now start adding some platform-specific code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始添加一些特定于平台的代码。
- en: Writing the ARKit-specific code
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写ARKit特定的代码
- en: In this section, we will write the platform-specific code for iOS that will
    initialize ARKit, find planes, and create nodes for UrhoSharp to render on the
    screen. We will be taking advantage of an `Urho` component that wraps ARKit in
    iOS. We will also be writing all the functions that will position, add, and remove
    nodes. ARKit uses  `anchors`, which act as virtual points that glue the overlaid
    graphics to the real world. We are specifically looking for `ARPlaneAnchor`, which represents
    a plane in the AR world. There are other types of anchors available, but for this
    app, we only need to find horizontal planes.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为iOS编写特定于平台的代码，该代码将初始化ARKit，查找平面，并创建节点以供UrhoSharp在屏幕上渲染。我们将利用一个在iOS中包装ARKit的`Urho`组件。我们还将编写所有将定位、添加和移除节点的函数。ARKit使用`anchors`，它们充当将叠加的图形粘合到现实世界的虚拟点。我们特别寻找`ARPlaneAnchor`，它代表AR世界中的平面。还有其他类型的锚点可用，但对于这个应用程序，我们只需要找到水平平面。
- en: Let's start off by defining the `ARKitComponent` so that we can use it later.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义`ARKitComponent`，以便以后可以使用它。
- en: Defining the ARKitComponent
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义ARKitComponent
- en: 'We start by adding a `private` field to an `ARKitComponent` that will be initialized
    later on. Let''s set this up by going through the following steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加一个将在稍后初始化的`ARKitComponent`的`private`字段。让我们通过以下步骤设置这一点：
- en: In the `WhackABox` project, open `Game.iOS.cs`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.iOS.cs`。
- en: 'Add a `private` field that holds an `ARKitComponent`, as shown in bold in the
    following code :'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个持有`ARKitComponent`的`private`字段，如下面的代码中所示：
- en: '[PRE13]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Make sure that you add all the `using` statements to ensure that all the code
    we later use resolves the correct types.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 确保添加所有`using`语句，以确保我们后来使用的所有代码都解析正确的类型。
- en: Writing handlers for adding and updating anchors
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写用于添加和更新锚点的处理程序
- en: We will now add the necessary code that will add and update anchors. We will
    also add some methods to help set the orientation of the nodes after ARKit updates
    the anchors.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加必要的代码，以添加和更新锚点。我们还将添加一些方法来帮助设置节点在ARKit更新锚点后的方向。
- en: SetPositionAndRotation
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SetPositionAndRotation
- en: 'The `SetPositionAndRotation()` method will be used by both the add and update
    anchors, so we need to define it before creating the handlers for the events that
    will be raised by ARKit. Let''s set this up by going through the following steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetPositionAndRotation()`方法将被添加和更新锚点使用，因此我们需要在创建由ARKit引发的事件处理程序之前定义它。让我们通过以下步骤设置这一点：'
- en: In the `WhackABox` project, open the `Game.iOS.cs` file.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.iOS.cs`文件。
- en: 'Add the `SetPositionAndRotation()` method to the class, as shown in the following
    code:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照下面的代码，在类中添加`SetPositionAndRotation()`方法：
- en: '[PRE14]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The method takes two parameters. The first is an `ARPlaneAnchor` defined by
    ARKit and the second is the `PlaneNode` that we have in the scene. The purpose
    of the method is to make sure that the `PlaneNode` is in sync with the `ARPlaneAnchor`
    object passed by ARKit. The `arkitComponent` has a helper method called `ApplyOpenTkTransform()`
    to translate the position and rotation of the `ARPlaneAnchor` object into the
    position and rotation objects used by `Urho`. We then update the `Extent` (size)
    of the plane to the `PlaneNode` and get the `anchor` center position from the
    `ARPlaneAnchor`. Finally, we call a method that we defined earlier to update the
    subplane node that holds the `Box` component that will do the actual rendering
    of the plane as a semitransparent red box.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受两个参数。第一个是由ARKit定义的`ARPlaneAnchor`，第二个是我们在场景中拥有的`PlaneNode`。该方法的目的是确保`PlaneNode`与ARKit传递的`ARPlaneAnchor`对象同步。`arkitComponent`有一个名为`ApplyOpenTkTransform()`的辅助方法，将`ARPlaneAnchor`对象的位置和旋转转换为`Urho`使用的位置和旋转对象。然后我们更新平面的`Extent`（大小）到`PlaneNode`，并从`ARPlaneAnchor`获取`anchor`中心位置。最后，我们调用之前定义的方法来更新持有`Box`组件的子平面节点，该组件将实际将平面渲染为半透明红色框。
- en: We need one more method to handle the update and add functionality.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个处理更新和添加功能的方法。
- en: UpdateOrAddPlaneNode
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新或添加平面节点
- en: 'The `UpdateOrAddPlaneNode()` does exactly what the name implies: it takes an
    `ARPlaneAnchor` as an argument and either updates or adds a new `PlaneNode` to
    the `scene`. Let''s set this up by going through the following steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateOrAddPlaneNode()`正如其名称所示：它以`ARPlaneAnchor`作为参数，要么更新要么添加一个新的`PlaneNode`到`scene`。让我们通过以下步骤设置这一点：'
- en: In the `WhackABox` project, open the `Game.iOS.cs` file.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.iOS.cs`文件。
- en: 'Add the `UpdateOrAddPlaneNode()` method, as described in the following code:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照下面的代码描述，添加`UpdateOrAddPlaneNode()`方法：
- en: '[PRE15]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A node is either already present in the scene or it needs to be added. The first
    line of code calls the `FindNodeByPlaneId()` to query the scene for an object
    with the given `PlaneId`. For iOS, we use the `anchor.Identifier` property to
    track planes defined by iOS. If this call returns `null`, it means that the plane
    is not present in the scene and we need to create it. To do this, we instantiate
    a new `PlaneNode`, giving it a `PlaneId` and a user-friendly name for debugging
    purposes. We then create the subplane to visualize the plane itself by calling
    `CreateSubPlane()`, which we defined earlier, and add the node to the `scene`. Lastly,
    we update the position and rotation. We do this for every call to the `UpdateOrAddPlaneNode()`
    method, since it's the same for both new and existing nodes. It's now time to
    write the handlers that we will eventually hook up to ARKit directly.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一个节点要么已经存在于场景中，要么需要被添加。代码的第一行调用`FindNodeByPlaneId()`来查询具有给定`PlaneId`的对象。对于iOS，我们使用`anchor.Identifier`属性来跟踪iOS定义的平面。如果这个调用返回`null`，这意味着该平面不在场景中，我们需要创建它。为此，我们实例化一个新的`PlaneNode`，给它一个`PlaneId`和一个用于调试目的的用户友好的名称。然后我们通过调用`CreateSubPlane()`来创建子平面来可视化平面本身，我们之前定义过，并将节点添加到`scene`中。最后，我们更新位置和旋转。对于每次调用`UpdateOrAddPlaneNode()`方法，我们都这样做，因为对于新节点和现有节点来说都是一样的。现在是时候编写我们最终将直接连接到ARKit的处理程序了。
- en: OnAddAnchor
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OnAddAnchor
- en: Let's add some code. The `OnAddAnchor()` method will be called each time ARKit updates
    its collection of anchors that describe points that we will use to relate to within
    our virtual world. We are specifically looking for anchors of the `ARPlaneAnchor` type.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些代码。`OnAddAnchor()`方法将在每次ARKit更新描述我们在虚拟世界中使用的点的锚点集合时被调用。我们特别寻找`ARPlaneAnchor`类型的锚点。
- en: 'Add the `OnAddAnchor()` method to the `Game.iOS.cs` class by going through
    the following two steps:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下两个步骤在`Game.iOS.cs`类中添加`OnAddAnchor()`方法：
- en: In the `WhackABox` project, open the `Game.iOS.cs` file.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.iOS.cs`文件。
- en: 'Add the `OnAddAnchor()` method anywhere in the class, as shown in the following
    code:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中的任何地方添加`OnAddAnchor()`方法，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The method takes an array of `ARAnchors` as a parameter. We filter out the anchors
    that are of the `ARPlaneAnchor` type and iterate through the list. For each `ARPlaneAnchor`,
    we call the `UpdateOrAddPlaneNode()` method that we created earlier to add a node
    to the scene. Let's now do the same for when ARKit wants to update anchors.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法以`ARAnchors`数组作为参数。我们过滤出`ARPlaneAnchor`类型的锚点，并遍历列表。对于每个`ARPlaneAnchor`，我们调用之前创建的`UpdateOrAddPlaneNode()`方法来向场景中添加一个节点。现在让我们为ARKit想要更新锚点时做同样的事情。
- en: OnUpdateAnchors
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OnUpdateAnchors
- en: 'Each time ARKit receives new information about an anchor, it will call this
    method. We do the same as we did with the previous code and iterate through the
    list to update the extent and position of the `anchor` in the scene:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 每当ARKit接收到关于锚点的新信息时，它将调用此方法。我们与之前的代码一样，遍历列表以更新场景中`anchor`的范围和位置：
- en: In the `WhackABox` project, open the `Game.iOS.cs` file.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.iOS.cs`文件。
- en: 'Add the `OnUpdateAnchors()` method anywhere in the class, as shown in the following
    code:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中的任何地方添加`OnUpdateAnchors()`方法，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code is a copy of the `OnAddAnchors()` method. It updates all nodes in the
    scene based on the information provided by ARKit.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码是`OnAddAnchors()`方法的副本。它根据ARKit提供的信息更新场景中的所有节点。
- en: We also need to write some code to remove the anchors that ARKit has removed.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要编写一些代码来移除ARKit已经移除的锚点。
- en: Writing a handler for removing anchors
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个处理移除锚点的处理程序
- en: When ARKit decides that an anchor is invalid, it will remove it from the scene.
    This does not happen very often, but it's a good practice to handle this call
    anyway.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当ARKit决定一个锚点无效时，它将从场景中移除它。这种情况并不经常发生，但处理这个调用是一个好习惯。
- en: OnRemoveAnchors
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OnRemoveAnchors
- en: 'Let''s add a method to handle the removal of an `ARPlaneAnchor` by going through
    the following steps:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤添加一个处理移除`ARPlaneAnchor`的方法：
- en: In the `WhackABox` project, open the `Game.iOS.cs` file.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.iOS.cs`文件。
- en: 'Add the `OnRemoveAnchors()` method anywhere in the class, as shown in the following
    code:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中的任何地方添加`OnRemoveAnchors()`方法，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As with the `Add` and `Remove` functions, this method accepts an array of `ARAnchor`.
    We iterate through this array, looking for anchors of the `ARPlaneAnchor` type.
    We then look for a node that represents this plane by calling the `FindNodeByPlaneId()`
    method. If it's not `null`, then we call for that node to be removed. Note the
    null-check operator before the `Remove()` call.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Add`和`Remove`函数一样，这个方法接受一个`ARAnchor`数组。我们遍历这个数组，寻找`ARPlaneAnchor`类型的锚点。然后我们调用`FindNodeByPlaneId()`方法寻找表示这个平面的节点。如果不是`null`，那么我们调用移除该节点。请注意在`Remove()`调用之前的空值检查运算符。
- en: Initializing ARKit
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化ARKit
- en: We've now come to the last part of the iOS-specific code, which is where we
    initialize ARKit. This method is called `InitializeAR()`, and takes no parameters.
    It is the same as the method for Android, but since they are never compiled simultaneously
    because of the use of conditional compiling, the code calling this method will
    not know the difference.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了iOS特定代码的最后部分，这是我们初始化ARKit的地方。这个方法叫做`InitializeAR()`，不需要参数。它与Android的方法相同，但由于它们永远不会同时编译，因为使用了条件编译，调用这个方法的代码将不会知道区别。
- en: 'The code to initialize ARKit is straightforward, and the `ARKitComponent` does
    a lot of work for us. Let''s set it up by going through the following steps:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化ARKit的代码很简单，`ARKitComponent`为我们做了很多工作。让我们通过以下步骤设置它：
- en: In the `WhackABox` project, open the `Game.iOS.cs` file.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.iOS.cs`文件。
- en: 'Add the `InitializeAR()` method anywhere in the class, as shown in the following
    code:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中的任何地方添加`InitializeAR()`方法，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code starts by creating an `ARKitComponent`. We then set the allowed orientation
    and create an `ARWorldTrackingConfiguration` class that states that we are only
    interested in horizontal planes. To respond to the addition, updating, and removal
    of planes, we attach the event handlers we created earlier.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先创建了一个`ARKitComponent`。然后我们设置了允许的方向，并创建了一个`ARWorldTrackingConfiguration`类，说明我们只对水平平面感兴趣。为了响应平面的添加、更新和移除，我们附加了之前创建的事件处理程序。
- en: We instruct the ARKit component to delay calling the callbacks to allow ARKit
    to initialize properly. Note the spelling error in the `RunEngineFramesInARKitCallbakcs`
    property. This is a good example of why you need to carry out a review of your
    code, since it will be hard to change this name without breaking backward compatibility.
    Naming is hard.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指示ARKit组件延迟调用回调函数，以便ARKit能够正确初始化。请注意`RunEngineFramesInARKitCallbakcs`属性中的拼写错误。这是一个很好的例子，说明为什么需要对代码进行审查，因为更改这个名称将很难保持向后兼容。命名是困难的。
- en: The last thing is to tell ARKit to start running. We do this by calling the `arkitComponent.Run()`
    method.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事是告诉ARKit开始运行。我们通过调用`arkitComponent.Run()`方法来实现这一点。
- en: Writing ARCore-specific code
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写特定于ARCore的代码
- en: It's now time to do the same for Android with ARCore. Just as with iOS, we are
    going to put all Android-specific code in a file of its own. This file is the
    `Game.Android.cs` that we created earlier.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候为Android与ARCore做同样的事情了。就像iOS一样，我们将把所有特定于Android的代码放在自己的文件中。这个文件就是我们之前创建的`Game.Android.cs`。
- en: Defining the ARCoreComponent
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义ARCoreComponent
- en: First, we are going to add a field that stores a reference to the `ARCoreComponent`.
    This wraps most of the interaction with ARCore. The `ARCoreComponent` is defined
    in the UrhoSharp.ARCore NuGet package that we installed at the beginning of the
    chapter.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加一个字段，用于存储对`ARCoreComponent`的引用。这个组件包装了与ARCore的大部分交互。`ARCoreComponent`定义在我们在本章开头安装的UrhoSharp.ARCore
    NuGet包中。
- en: 'Let''s add some `using` statements and the field by going through the following
    steps:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤添加一些`using`语句和字段：
- en: In the `WhackABox` project, open the `Game.Android.cs` file.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.Android.cs`文件。
- en: 'Add the `arCore`private field, as described in the following code. Also, make
    sure that you add the `using` statements marked in bold:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码描述添加`arCore`私有字段。同时确保添加了粗体标记的`using`语句：
- en: '[PRE20]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `using` statements will allow us to resolve the types that we need in this
    file and the `arCore` property will be a shorthand when we want to access ARCore
    functions.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`语句将允许我们在这个文件中解析所需的类型，而`arCore`属性将是我们在访问ARCore函数时的简写。'
- en: We'll continue by adding some methods to this class.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续向这个类添加一些方法。
- en: SetPositionAndRotation
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SetPositionAndRotation
- en: 'We need to add or update a `PlaneNode` whenever a plane is detected or updated.
    The `SetPositionAndRotation()` method updates the passed `PlaneNode` and sets
    properties on that node based on the content of the `AR.Core.Plane` object. Let''s
    set this up by going through the following steps:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 每当检测到或更新平面时，我们需要添加或更新一个`PlaneNode`。`SetPositionAndRotation()`方法会更新传递的`PlaneNode`，并根据`AR.Core.Plane`对象的内容设置该节点的属性。让我们通过以下步骤来设置这一点：
- en: In the `WhackABox` project, open the `Game.Android.cs` file.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.Android.cs`文件。
- en: 'Add the `SetPositionAndRotation()` method to the class, as shown in the following
    code:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码在类中添加`SetPositionAndRotation()`方法：
- en: '[PRE21]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The previous code updates the extent of the plane for the node and creates a
    rotation, `Quaternion`. Don't worry if you don't know what a `Quaternion` is—few
    people do—but they seem to magically hold the rotation information of the model
    in a very flexible way. The `plane.CenterPose` property is a matrix that holds
    the position and orientation of the plane. Finally, we update the position of
    the node from the `CenterPose` property.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码更新了节点的平面范围并创建了一个旋转`Quaternion`。如果你不知道`Quaternion`是什么，不要担心，很少有人知道，但它们似乎以一种非常灵活的方式神奇地保存了模型的旋转信息。`plane.CenterPose`属性是一个包含平面位置和方向的矩阵。最后，我们根据`CenterPose`属性更新节点的位置。
- en: The next step is to create a method that handles frame updates from ARCore.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个处理来自ARCore的帧更新的方法。
- en: Writing a handler for ARFrame updates
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写ARFrame更新的处理程序
- en: Android handles updates from ARCore a little bit differently than ARKit, which
    exposes three different events for added, updated, and removed nodes. When using
    ARCore, we get called whenever any changes occur, and the handler that will take
    care of this is the one we are about to add.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Android处理来自ARCore的更新与ARKit有些不同，后者暴露了三种不同的事件，用于添加、更新和移除节点。当使用ARCore时，我们会在任何更改发生时被调用，而将处理这些更改的处理程序将是我们即将添加的处理程序。
- en: 'Let''s add the method by going through the following steps:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤添加该方法：
- en: In the `WhackABox` project, open the `Game.Android.cs` file.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.Android.cs`文件。
- en: 'Add the `OnARFrameUpdated()` method anywhere in the class, as shown in the
    following code:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码在类中的任何位置添加`OnARFrameUpdated()`方法：
- en: '[PRE22]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We start by querying the `arCore` component for all the planes that it keeps
    track of. We then iterate through this list and see whether we have any nodes
    in the scene by calling the `FindNodeByPlaneId()` method, using the hash code
    of the plane as the identifier. If we can't find any, we create a new `PlaneNode`
    and assign the hash code as the `PlaneId`. We then create a subplane that contains
    the `Box` component to visualize the plane, and, finally, we add it to the scene. We
    then update the position and the rotation of the plane and make a call to update
    the subplane as well. Now that we have the handler written, we need to hook it
    up.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查询`arCore`组件跟踪的所有平面。然后我们遍历这个列表，通过调用`FindNodeByPlaneId()`方法，使用平面的哈希码作为标识符，来查看我们在场景中是否有任何节点。如果找不到任何节点，我们就创建一个新的`PlaneNode`，并将哈希码分配为`PlaneId`。然后我们创建一个包含`Box`组件以可视化平面的子平面，最后将其添加到场景中。然后我们更新平面的位置和旋转，并调用更新子平面。现在我们已经编写了处理程序，需要将其连接起来。
- en: Initializing ARCore
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化ARCore
- en: To initialize ARCore, we will add two methods. The first one is a method that
    will take care of the configuration of ARCore, called `OnConfigRequested()`. The
    second one is the `InitializeAR()` method that will be called from the shared
    `Game` class later on. This method is also defined in the iOS-specific code, but,
    as we talked about earlier, this method in iOS will never be compiled when we
    compile for Android, since we are using conditional compiling, which filters out
    code from the platform that isn't selected.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化ARCore，我们将添加两种方法。第一种是一个方法，负责ARCore的配置，称为“OnConfigRequested（）”。第二种是将从共享的“Game”类中稍后调用的“InitializeAR（）”方法。这个方法也在iOS特定的代码中定义，但是正如我们之前讨论的，当我们为Android编译时，这个方法在iOS中永远不会被编译，因为我们使用条件编译，它会过滤掉未选择平台的代码。
- en: OnConfigRequested
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OnConfigRequested
- en: 'ARCore needs to know a few things, just like iOS. In Android, this is done
    by defining a method that the ARCore component will call upon initialization.
    To create the method, go through the following steps:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ARCore需要知道一些东西，就像iOS一样。在Android中，这是通过定义一个ARCore组件在初始化时调用的方法来完成的。要创建该方法，请按照以下步骤进行：
- en: In the `WhackABox` project, open the `Game.Android.cs` file.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“WhackABox”项目中，打开“Game.Android.cs”文件。
- en: 'Add the `OnConfigRequested()` method anywhere in the class, as shown in the 
    following code:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中的任何位置添加“OnConfigRequested（）”方法，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The method takes a `Config` object, which will store any configuration you make
    in this method. First, we set which type of plane we want to find. We are interested
    in `Horizontal` planes for this game. We define which kind of light-estimation
    mode we want to use and, finally, we select which update mode we want. In this
    case, we want to use the latest camera image available. You can do a lot of fine-tuning
    during configuration, but this is out of the scope of this book. Be sure to check
    out the documentation for ARCore to learn more about its awesome power.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个“Config”对象，该对象将存储您在此方法中进行的任何配置。首先，我们设置要查找的平面类型。对于这个游戏，我们对“水平”平面感兴趣。我们定义要使用的光估计模式的类型，最后，我们选择要使用的更新模式。在这种情况下，我们要使用最新的相机图像。您可以在配置期间进行很多微调，但这超出了本书的范围。一定要查看ARCore的文档，了解更多关于它强大功能的信息。
- en: We now have all the code we need to initialize ARCore.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了初始化ARCore所需的所有代码。
- en: InitializeAR
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InitializeAR
- en: 'As mentioned previously, the `InitializeAR()` method shares the same name as
    the iOS-specific code, but the compiler will only include one of them in the build
    because of the use of conditional compiling. Let''s set this up by going through
    the following steps:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，“InitializeAR（）”方法与iOS特定的代码共享相同的名称，但由于使用条件编译，编译器只会在构建中包含其中一个。让我们按照以下步骤设置这个：
- en: In the `WhackABox` project, open the `Game.Android.cs` file.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“WhackABox”项目中，打开“Game.Android.cs”文件。
- en: 'Add the `InitializeAR()` method anywhere in the class, as shown in the following
    code:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中的任何位置添加“InitializeAR（）”方法，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first step is to create the `ARCoreComponent` provided by UrhoSharp. This
    component wraps the initialization of the native ARCore classes. We then add two
    event handlers: one for taking care of frame updates and one that will be called
    during initialization. The last thing we do is call the `Run()` method on the
    `ARCoreComponent` to start tracking the world.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建UrhoSharp提供的“ARCoreComponent”。这个组件包装了本地ARCore类的初始化。然后我们添加两个事件处理程序：一个用于处理帧更新，一个在初始化期间调用。我们做的最后一件事是在“ARCoreComponent”上调用“Run（）”方法，以开始跟踪世界。
- en: Now that we have both ARKit and ARCore configured and ready to go, it's time
    to write the actual game.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置好了ARKit和ARCore，准备开始编写实际的游戏了。
- en: Writing the game
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写游戏
- en: In this section, we will initialize `Urho` by setting up the camera, lighting,
    and a renderer. The camera is the object that determines where objects will be
    rendered. The AR components take care of updating the position of the camera to
    virtually track your phone so that any object we render will be in the same coordinate
    space as what you are looking at. First, we need a camera that will be the viewing
    point of the scene.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将通过设置相机、灯光和渲染器来初始化Urho。相机是确定对象渲染位置的对象。AR组件负责更新相机的位置，以虚拟跟踪您的手机，以便我们渲染的任何对象都在与您所看到的相同的坐标空间中。首先，我们需要一个相机，它将是场景的观察点。
- en: Adding a camera
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加相机
- en: 'Adding a camera is a straightforward process, as shown in the following steps:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 添加相机是一个简单的过程，如下面的步骤所示：
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“WhackABox”项目中，打开“Game.cs”文件。
- en: Add the `camera` property to the class, as shown in the following code. You
    should place it right after the declaration of the class itself, but placing it
    anywhere within the class will work.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加“相机”属性，如下面的代码所示。您应该将其放在类本身的声明之后，但在类内的任何位置放置它都可以。
- en: 'Add the `InitializeCamera()` method anywhere in the class, as shown in the
    following code:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中的任何位置添加“InitializeCamera（）”方法，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In UrhoSharp, everything is a node just like everything is a GameObject in Unity,
    including the `camera`. We create a new node, which we call `camera`, and then
    we create a `Camera` component on that node and keep the reference to it for later
    use.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在UrhoSharp中，一切都是一个节点，就像在Unity中一切都是一个GameObject，包括“相机”。我们创建一个新节点，称为“相机”，然后在该节点上创建一个“相机”组件，并保留对它的引用以供以后使用。
- en: Configuring a renderer
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置渲染器
- en: 'UrhoSharp needs to render the scene to a `viewport`. A game can have multiple
    viewports, based on multiple cameras. Think of a game where you drive a car. The
    main `viewport` will be the game from the perspective of the driver. Another `viewport`
    might be the rear-view mirrors, which would actually be cameras themselves that
    render what they see on to the main `viewport`. Let''s set this up by going through
    the following steps:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: UrhoSharp需要将场景渲染到一个“视口”中。一个游戏可以有多个视口，基于多个摄像头。想象一下你开车的游戏。主要的“视口”将是驾驶员视角的游戏。另一个“视口”可能是后视镜，实际上它们本身就是摄像头，将它们所看到的渲染到主“视口”上。让我们按照以下步骤设置这个：
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.cs`文件。
- en: Add the `viewport` property to the class, as shown in the following code. You
    should place it right after the declaration of the class itself, but placing it
    anywhere within the class will work.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`viewport`属性到类中，如下面的代码所示。您应该将其放在类本身的声明之后，但在类内的任何位置放置它都可以。
- en: 'Add the `InitializeRenderer()` method anywhere in the class, as shown in the
    following code:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中的任何位置添加`InitializeRenderer()`方法，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `viewport` property will hold a reference to the `viewport` for later use. The
    `viewport` is created by instantiating a new `viewport` class. The constructor
    of that class needs a `Context` provided by the base class, the `scene` that we
    will create while initializing the game, a camera to know which point in space
    to render from, and a render path, which we default to `null`. A render path allows
    for post-processing of the frame created while rendering. This is also outside
    the scope of this book, but it is worth checking out as well.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewport`属性将保存对`viewport`的引用，以备后用。`viewport`是通过实例化一个新的`viewport`类来创建的。该类的构造函数需要基类提供的`Context`，在初始化游戏时我们将创建的`scene`，一个相机以知道从空间的哪个点进行渲染，以及一个渲染路径，默认为`null`。渲染路径允许在渲染时对帧进行后处理。这也超出了本书的范围，但也值得一看。'
- en: Now, let there be light.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让光明存在。
- en: Adding lights
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加光
- en: 'To make objects visible, we need to define some lighting. We do this by creating
    a method that defines which type of lighting we want in the game. Let''s set this
    up by going through the following steps:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使对象可见，我们需要定义一些光照。我们通过创建一个定义游戏中我们想要的光照类型的方法来实现这一点。让我们通过以下步骤来设置这一点：
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.cs`文件。
- en: 'Add the `InitializeLights()` method anywhere in the class, as shown in the
    following code:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中的任何位置添加`InitializeLights()`方法，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Again, everything in UrhoSharp is a node, and lights are no exception to that
    rule. We create a generic node on the camera node by accessing the stored camera
    component and accessing the node it belongs to. We then set a direction of that
    node and create a `Light` component to define a light. The range of the light
    will be 10 units in length. The type is directional, meaning that it will shine
    from the position of the node in its defined direction. It will also cast shadows.
    We set the `ShadowMapSize` to four times the default value to give the shadow
    map some more resolution.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，UrhoSharp中的一切都是节点，光也不例外。我们通过访问存储的相机组件并访问它所属的节点，在相机节点上创建一个通用节点。然后我们设置该节点的方向并创建一个`Light`组件来定义光。光的范围将是10个单位的长度。类型是方向性的，这意味着它将从节点的位置沿着定义的方向发光。它还将投射阴影。我们将`ShadowMapSize`设置为默认值的四倍，以给阴影贴图更多的分辨率。
- en: At this point, we have all we need to initialize UrhoSharp and the AR components.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经有了初始化UrhoSharp和AR组件所需的一切。
- en: Implementing the game startup
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现游戏启动
- en: The base class of the `Game` class provides some virtual methods that we can
    override. One of these is `Start()`, which will be called shortly after the custom
    renderer has set up the `UrhoSurface`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game`类的基类提供了一些虚拟方法，我们可以重写。其中之一是`Start()`，它将在自定义渲染器设置`UrhoSurface`后不久被调用。'
- en: 'Add the method by going through the following steps:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤添加方法：
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.cs`文件。
- en: 'Add the `Start()` method anywhere in the class, as shown in the following code:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中的任何位置添加`Start()`方法，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The scene that we have been talking about is created here in the first line
    of the method. This is the scene that we look at when UrhoSharp is running. It keeps
    track of all nodes that we add to it. All 3D games in UrhoSharp need an `Octree`,
    which is a component that implements spatial partitioning. It is used by the 3D
    engine to quickly find objects in a 3D space without having to query every single
    one in each frame. The second line of the method creates this component directly
    on the scene.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在谈论的场景是在这个方法的第一行创建的。这是我们在运行UrhoSharp时看到的场景。它跟踪我们添加到其中的所有节点。UrhoSharp中的所有3D游戏都需要一个`Octree`，这是一个实现空间分区的组件。它被3D引擎用来在3D空间中快速找到对象，而不必在每一帧中查询每一个对象。方法的第二行直接在场景上创建了这个组件。
- en: Following this, we have the four methods that initialize the camera, the lights,
    and the renderer, and that make a call to one of the two `InitializeAR()` methods,
    based on which platform we are compiling for. If you start the app at this point,
    you should see that it finds planes and renders them, but that nothing more happens.
    It's time to add something to interact with.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有四种方法来初始化相机、灯光和渲染器，并调用两种`InitializeAR()`方法中的一种，这取决于我们正在编译的平台。如果此时启动应用程序，您应该会看到它找到平面并对其进行渲染，但没有其他操作。是时候添加一些与之交互的东西了。
- en: Adding boxes
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加框
- en: We are now going to focus on adding virtual boxes to our augmented world. We
    are going to write two methods. The first one is the `AddBox()` method, which
    will add a new box at a random position on a plane. The second is an override
    of the `OnUpdate()` method that UrhoSharp calls with each frame to perform game
    logic.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要专注于向我们的增强现实世界添加虚拟框。我们将编写两种方法。第一个是`AddBox()`方法，它将在平面上的随机位置添加一个新框。第二个是`OnUpdate()`方法的重写，UrhoSharp在每帧调用它来执行游戏逻辑。
- en: AddBox()
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AddBox()
- en: 'To add boxes to a plane, we need to add a method to do so. This method is called
    `AddBox()`. Let''s set this up by going through the following steps:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 要向平面添加框，我们需要添加一个方法来实现。这个方法叫做`AddBox()`。让我们通过以下步骤来设置这一点：
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.cs`文件。
- en: Add the `random` property to the class (preferably at the top, but anywhere
    in the class will work).
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加`random`属性（最好在顶部，但在类的任何位置都可以）。
- en: 'Add the `AddBox()` method anywhere in the class, as shown in the following
    code:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中的任何位置添加`AddBox()`方法，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The static `random` object that we create will be used for randomizing the location
    of a box on a plane. We want to use a static `Random` instance, since we don't
    want to risk creating multiple instances that may be seeded with the same value,
    and that therefore return the exact same sequence of random numbers. The method
    starts by finding the subplane child of the `PlaneNode` instance that we pass
    in by calling `planeNode.GetChild("subplane")`. We then create a node that will
    render the box. To make the box fit the world, we need to set the scale to `0.1`,
    which will make it 10 cm in size.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的静态`random`对象将用于随机化平面上方块的位置。我们想要使用静态的`Random`实例，因为我们不想冒险创建可能以相同值进行种子化的多个实例，因此返回完全相同的随机数序列。该方法首先通过调用`planeNode.GetChild("subplane")`找到我们传入的`PlaneNode`实例的子平面。然后我们创建一个将渲染方块的节点。为了使方块适应世界，我们需要将比例设置为`0.1`，这将使其大小为10厘米。
- en: We then randomize the position of the box using the `ExtentX` and `ExtentZ`
    properties, multiplied by a new random value between `0` and `1` that we first
    subtract `0.5` from. This is to center the position, since the position of the
    parent node is the center of the plane. Then, we set the position of the box node
    at the randomized position and 0.1 units above the plane. We also need to add
    the subplanes position, since it might be a little bit offset from the parent
    node. Finally, we add the actual box to be rendered and set the color to blue.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`ExtentX`和`ExtentZ`属性随机化方块的位置，乘以一个介于`0`和`1`之间的新随机值，我们首先从中减去`0.5`。这是为了使位置居中，因为父节点的位置是平面的中心。然后，我们将方块节点的位置设置为随机位置，并且在平面上方0.1个单位。我们还需要添加子平面的位置，因为它可能与父节点有一点偏移。最后，我们添加要渲染的实际方块，并将颜色设置为蓝色。
- en: Let's now add code to call the `AddBox()` method, based on some game logic.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加代码来调用`AddBox()`方法，基于一些游戏逻辑。
- en: OnUpdate()
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OnUpdate()
- en: Most games use a game loop. This calls an `Update()` method, which takes an
    input and calculates the state of the game. UrhoSharp is no exception. The base
    class of our game has a virtual `OnUpdate()` method that we can override so that
    we can write code that will be executed with each frame. This method is called
    frequently, usually about 50 times per second.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏使用游戏循环。这会调用一个`Update()`方法，该方法接受输入并计算游戏的状态。UrhoSharp也不例外。我们游戏的基类有一个虚拟的`OnUpdate()`方法，我们可以覆盖它，以便我们可以编写每帧都会执行的代码。这个方法经常被调用，通常大约每秒50次。
- en: 'We will now override the `Update()` method to add game logic that adds a new
    box every other second. Let''s set this up by going through the following steps:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将覆盖`Update()`方法，添加游戏逻辑，每隔一秒添加一个新的方块。让我们通过以下步骤设置这个逻辑：
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.cs`文件。
- en: Add the `newBoxTtl` field and the `newBoxIntervalInSeconds` field to the class
    at the top of the code.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`newBoxTtl`字段和`newBoxIntervalInSeconds`字段添加到代码顶部的类中。
- en: 'Add the `OnUpdate()` method anywhere in the class, as shown in the following
    code:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中的任何位置添加`OnUpdate()`方法，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first field, `newBoxTtl` where `Ttl` is **time to live** (**TTL**), is an
    internal counter that will be reduced by the number of milliseconds that have
    passed since the last frame. When it fall below `0`, we will add a new box to
    each plane of the scene. We find all instances of `PlaneNode` by querying the
    `Children` collection of the scene and returning only the children of the `PlaneNode`
    type. The second field, `newBoxIntervalInSeconds`, indicates how many seconds
    we will add to the `newBoxTtl` once it reaches `0`. To know how much time has
    passed since the last frame, we use the `timeStep `parameter that is passed into
    the `OnUpdate()` method by UrhoSharp. The value of this parameter is the number
    of seconds since the last frame. It's usually a small value, which will be something
    like `0.016` if the update loop runs at 50 frames per second. It could vary though,
    which is why you will want to use this value to carry out the subtraction from
    `newBoxTtl`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字段`newBoxTtl`，其中`Ttl`是**存活时间**（**TTL**），是一个内部计数器，将减去自上一帧以来经过的毫秒数。当它低于`0`时，我们将向场景的每个平面添加一个新的方块。我们通过查询场景的`Children`集合并仅返回`PlaneNode`类型的子项来找到所有`PlaneNode`的实例。第二个字段`newBoxIntervalInSeconds`表示`newBoxTtl`达到`0`后我们将添加多少秒到`newBoxTtl`。为了知道自上一帧以来经过了多少时间，我们使用UrhoSharp传递给`OnUpdate()`方法的`timeStep`参数。该参数的值是自上一帧以来的秒数。通常是一个小值，如果更新循环以每秒50帧运行，它将是`0.016`。它可能会有所不同，这就是为什么您会想要使用这个值来进行`newBoxTtl`的减法运算。
- en: If you run the game now, you will see that boxes appear on the detected planes.
    We still cannot interact with them, however, and they look pretty boring. Let's
    continue by making them rotate.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行游戏，您将看到方块出现在检测到的平面上。但是，我们仍然无法与它们交互，它们看起来相当无聊。让我们继续使它们旋转。
- en: Making boxes rotate
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使方块旋转
- en: You can add your own components to UrhoSharp by creating a class that inherits
    from `Urho.Component`. We will be creating a component that will make the boxes
    spin around all three axes.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过创建一个从`Urho.Component`继承的类来向UrhoSharp添加自己的组件。我们将创建一个组件，使方块围绕三个轴旋转。
- en: Creating the rotate component
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建旋转组件
- en: As we mentioned, a component is a class that inherits from `Urho.Component`.
    This base class defines a virtual method called `OnUpdate()` that behaves the
    same way as the `Update()` method on the `Game` class itself. This allows us to
    add logic to the component so that it can modify the state of the node it belongs
    to.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，组件是从`Urho.Component`继承的类。这个基类定义了一个名为`OnUpdate()`的虚拟方法，其行为与`Game`类本身的`Update()`方法相同。这使我们能够向组件添加逻辑，以便它可以修改它所属节点的状态。
- en: 'Let''s create the `rotate` component by going through the following steps:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤创建`rotate`组件：
- en: In the `WhackABox` project, create a new class called `Rotator.cs` in the root
    of the project.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，在项目的根目录中创建一个名为`Rotator.cs`的新类。
- en: 'Add the following code:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE31]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `RotationSpeed` property will be used to determine the speed of rotation
    around any specific axis. It will be set when we assign the component to the box
    node in the next step. To enable the component to receive calls to the `OnUpdate()`
    method on each frame, we need to set the `ReceiveSceneUpdates` property to `true`.
    If we don't do this, the component will not be called by UrhoSharp at each update.
    It's set to `false` by default for performance reasons.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`RotationSpeed`属性将用于确定围绕任何特定轴的旋转速度。当我们在下一步中将组件分配给箱子节点时，它将被设置。为了使组件能够在每一帧接收到对`OnUpdate()`方法的调用，我们需要将`ReceiveSceneUpdates`属性设置为`true`。如果不这样做，组件将不会在每次更新时被UrhoSharp调用。出于性能原因，默认情况下它被设置为`false`。'
- en: All the fun happens in the `override` of the `OnUpdate()` method. We create
    a new quaternion to represent a new rotation state. Again, we don't need to know
    how this works in detail, only that quaternions belong to the mystical world of
    advanced mathematics. We multiply each axis in the `RotationSpeed` vector by the
    `timeStep` to generate a new value. The `timeStep` parameter is the number of
    seconds that have passed since the last frame. We also define the rotation as
    being around the local coordinate space of this box.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 所有有趣的事情都发生在`OnUpdate()`方法的`override`中。我们创建一个新的四元数来表示新的旋转状态。同样，我们不需要详细了解这是如何工作的，只需要知道四元数属于高等数学的神秘世界。我们将`RotationSpeed`向量中的每个轴乘以`timeStep`来生成一个新值。`timeStep`参数是自上一帧以来经过的秒数。我们还将旋转定义为围绕此框的本地坐标空间。
- en: Now that the component is created, we need to add it to the boxes.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在组件已经创建，我们需要将它添加到箱子中。
- en: Assigning the Rotator component
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配Rotator组件
- en: 'Adding the `Rotator` component is as simple as adding any other component.
    Let''s set this up by going through the following steps:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`Rotator`组件就像添加任何其他组件一样简单。让我们通过以下步骤来设置这个：
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.cs`文件。
- en: 'Update the `AddBox()` method by adding the code marked in bold in the following
    code:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`AddBox()`方法，通过在以下代码中加粗标记的代码来添加：
- en: '[PRE32]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We begin by defining how we want the box to rotate by creating a new `Vector3`
    struct and assigning it to a new variable called `rotationSpeed`. In this case,
    we want it to rotate `10` units around the *x *axis, `20` units around the *y *axis,
    and `30` units around the *z *axis. We use the `rotationSpeed` variable to set
    the `RotationSpeed` property of the `Rotator` component that we instantiate in
    the second row of the code we added.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过创建一个新的`Vector3`结构并将其分配给一个名为`rotationSpeed`的新变量来定义我们希望箱子如何旋转。在这种情况下，我们希望它围绕*x*轴旋转`10`个单位，围绕*y*轴旋转`20`个单位，围绕*z*轴旋转`30`个单位。我们使用`rotationSpeed`变量来设置我们在添加的代码的第二行中实例化的`Rotator`组件的`RotationSpeed`属性。
- en: Finally, we add the component to the `box` node. The boxes should now rotate
    in an interesting way.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将组件添加到`box`节点。现在箱子应该以有趣的方式旋转。
- en: Adding box hit-test
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加箱子命中测试
- en: 'We now have rotating boxes that keep piling up. We need to add a way to remove
    boxes. The simplest thing would be to add a feature that removes boxes when we
    touch them, but we are going to make it a little fancier than that: whenever we
    touch a box, we want it to shrink and disappear before we remove it from the scene.
    To do this, we are going to use our newly acquired knowledge of components and
    then add some code to determine whether we are touching a box.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了不断堆叠的旋转箱子。我们需要添加一种方法来移除箱子。最简单的方法是添加一个功能，当我们触摸它们时移除箱子，但我们要比这更花哨一点：每当我们触摸一个箱子时，我们希望它在从场景中移除之前缩小并消失。为此，我们将使用我们新获得的组件知识，然后添加一些代码来确定我们是否触摸到一个箱子。
- en: Adding a death animation
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加死亡动画
- en: 'The `Death` component that we are about to add has the same template as the
    `Rotator` component that we created in the last section. Let''s add it by going
    through the following steps and taking a look at the code:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将添加的`Death`组件与我们在上一节中创建的`Rotator`组件具有相同的模板。让我们通过以下步骤来添加它并查看代码：
- en: In the `WhackABox` project, create a new class called `Death.cs`.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，创建一个名为`Death.cs`的新类。
- en: 'Replace the code in the class with the following code:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换类中的代码：
- en: '[PRE33]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We first define two fields. The `deathTtl` field determines how long the animation
    will be in seconds. The `initialScale` field keeps track of the scale of the node
    when the component is attached to the node. To receive updates, we need to set
    `ReceiveSceneUpdates` to `true` in the constructor. The overridden `OnAttachedToNode()`
    method is called when the component is attached to a node. We use this method
    to set the `initialScale` field. After the component is attached, we start getting
    calls on each frame to `OnUpdate()`. On each call, we set a new scale of the node
    based on the `deathTtl` field multiplied by the `initialScale`field. When the
    `deathTtl` field reaches zero, we remove the node from the scene. If we don't
    reach zero, then we subtract the amount of time since the last frame was called,
    which is given to us by the `timeStep` parameter. All we need to do now is figure
    out when to add the `Death` component to a box.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义两个字段。`deathTtl`字段确定动画持续的时间（以秒为单位）。`initialScale`字段在组件附加到节点时跟踪节点的比例。为了接收更新，我们需要在构造函数中将`ReceiveSceneUpdates`设置为`true`。当组件附加到节点时，将调用重写的`OnAttachedToNode()`方法。我们使用这个方法来设置`initialScale`字段。组件附加后，我们开始在每一帧上调用`OnUpdate()`。在每次调用时，我们根据`deathTtl`字段乘以`initialScale`字段设置节点的新比例。当`deathTtl`字段达到零时，我们将节点从场景中移除。如果我们没有达到零，那么我们减去自上一帧被调用以来的时间量，这是由`timeStep`参数给出的。现在我们需要做的就是弄清楚何时向箱子添加`Death`组件。
- en: DetermineHit()
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DetermineHit()
- en: 'We need a method that can interpret a touch on the 2D surface of the screen
    and figure out which boxes we are hitting using an imaginary ray travelling from
    the camera toward the scene we are looking at. This method is called `DetemineHit`.
    Let''s set this up by going through the following steps:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个方法，可以解释屏幕2D表面上的触摸，并使用从摄像机到我们正在查看的场景的虚拟射线来找出我们击中的箱子。这个方法叫做`DetemineHit`。让我们通过以下步骤来设置这个方法：
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.cs`文件。
- en: 'Add the `DetemineHit()` method anywhere in the class, as shown in the following
    code:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中的任何位置添加`DetemineHit()`方法，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `x` and `y` parameters that are passed into the method range from `0` to
    `1`, where `0` represents the left edge or top edge of the screen and `1` represents
    the right edge or bottom edge of the screen. The exact center of the screen would
    be `x=0.5` and `y=0.5`. Since we want to get a ray from the camera, we can use
    a method directly on the camera component called `GetScreenRay()`. It returns
    a ray from the camera in the scene in the same direction that the camera is set
    to. We use this ray and pass it to the `Octree` component's `RaycastSingle()`
    method, which returns a result that will contain a single node, if one is hit.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给方法的`x`和`y`参数的范围是从`0`到`1`，其中`0`表示屏幕的左边缘或顶部边缘，`1`表示屏幕的右边缘或底部边缘。屏幕的确切中心将是`x=0.5`和`y=0.5`。由于我们想从相机获取一个射线，我们可以直接在相机组件上使用一个叫做`GetScreenRay()`的方法。它返回一个从场景中相机的射线，与相机设置的方向相同。我们使用这个射线，并将其传递给`Octree`组件的`RaycastSingle()`方法，如果命中，则返回一个包含单个节点的结果。
- en: We examine the results, perform multiple null checks, and finally check whether
    the name of the node starts with `Box`. If this is true, we check to see whether
    the box we hit is already doomed by examining whether there is a `Death` component
    attached. If there is, we `return`. If there isn't, we create a `Death` component
    and leave the box to die.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查结果，执行多个空值检查，最后检查节点的名称是否以`Box`开头。如果是这样，我们检查我们击中的箱子是否已经注定，通过检查是否附加了`Death`组件来判断。如果有，我们`return`。如果没有，我们创建一个`Death`组件并让箱子死去。
- en: This all looks good so far. We now need something to call the `DetermineHit()`
    method.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切看起来都很好。现在我们需要一些东西来调用`DetermineHit()`方法。
- en: OnTouchBegin()
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OnTouchBegin()
- en: 'Touches are handled as events in UrhoSharp, and this means that they require
    event handlers. Let''s create a handler for the `TouchBegin` event by going through
    the following steps:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在UrhoSharp中，触摸被处理为事件，这意味着它们需要事件处理程序。让我们通过以下步骤为`TouchBegin`事件创建一个处理程序：
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.cs`文件。
- en: 'Add the `OnTouchBegin()` method anywhere in the code, as shown in the following:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中的任何位置添加`OnTouchBegin()`方法，如下所示：
- en: '[PRE35]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When a touch is registered, this method will be called and information about
    that touch event will be sent as a parameter. This parameter has an `X` and a `Y`
    property, which represent the point on the screen that we have touched. Since
    the `DetermineHit()` method wants the values in the range of `0` to `1`, we need
    to divide the `X` and `Y` coordinates by the width and height of the screen.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 当触摸被注册时，将调用此方法，并将有关该触摸事件的信息作为参数发送。此参数有一个`X`和一个`Y`属性，表示我们触摸的屏幕上的点。由于`DetermineHit()`方法希望值在`0`到`1`的范围内，我们需要将屏幕的宽度和高度除以`X`和`Y`坐标。
- en: Once that is done, we call the `DetermineHit()` method. To complete this section,
    we just have to wire up the event.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们调用`DetermineHit()`方法。要完成这一部分，我们只需要连接事件。
- en: Wiring up input
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接输入
- en: 'All that''s left now is to wire up the event to the `Input` subsystem of UrhoSharp.
    This is done by adding a single line of code to the `Start()` method, as shown
    in the following steps:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是将事件连接到UrhoSharp的`Input`子系统。这是通过在`Start()`方法中添加一行代码来完成的，如下所示的步骤：
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.cs`文件。
- en: 'In the `Start()` method, add the code highlighted in bold in the following
    code fragment:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start()`方法中，添加以下代码片段中加粗的代码：
- en: '[PRE36]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This wires up the `TouchBegin` event to our `OnTouchBegin` event handler.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`TouchBegin`事件连接到我们的`OnTouchBegin`事件处理程序。
- en: If you run the game now, the boxes should animate and disappear when you tap
    on them. What we need now is some kind of statistic that shows how many planes
    there are and how many boxes are still alive.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行游戏，当你点击它们时，箱子应该会动画并消失。现在我们需要一些统计数据，显示有多少飞机和有多少箱子还活着。
- en: Updating statistics
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新统计数据
- en: At the beginning of the chapter, we added some controls to the XAML that displayed
    the number of planes and boxes that were present in the game. It's now time to
    add some code to update those numbers. We will be using internal messaging to
    decouple the game from the Xamarin.Forms page that we use to display this information.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们在XAML中添加了一些控件，显示了游戏中存在的飞机和箱子的数量。现在是时候添加一些代码来更新这些数字了。我们将使用内部消息传递来解耦游戏和我们用来显示这些信息的Xamarin.Forms页面。
- en: The game will send a message to the main page that will contain a class that
    has all the information we need. The main page will receive this message and update
    the labels.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏将向主页发送一个包含我们需要的所有信息的类的消息。主页将接收此消息并更新标签。
- en: Defining a statistics class
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个统计类
- en: 'We are going to use `MessagingCenter` in Xamarin.Forms, which allows us to
    send an object along with the message. We need to create a class that can carry
    the information we want to pass. Let''s set this up by going through the following
    steps:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Xamarin.Forms中使用`MessagingCenter`，它允许我们发送消息的同时发送一个对象。我们需要创建一个可以携带我们想要传递的信息的类。让我们通过以下步骤来设置这个：
- en: In the `WhackABox` project, create a new class called `GameStats.cs`.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，创建一个名为`GameStats.cs`的新类。
- en: 'Add the following code to the class:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类中：
- en: '[PRE37]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The class will be a simple data carrier that indicates how many planes and boxes
    we have.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将是一个简单的数据载体，指示我们有多少飞机和箱子。
- en: Sending updates via MessagingCenter
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过MessagingCenter发送更新
- en: 'When a node is created or removed, we need to send statistics to anything that
    is listening. To do this, we need a new method that will go through the scene
    and count how many planes and boxes we have, and then send a message. Let''s set
    this up by going through the following steps:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个节点被创建或移除时，我们需要将统计信息发送给任何正在监听的东西。为了做到这一点，我们需要一个新的方法，它将遍历场景并计算我们有多少飞机和箱子，然后发送一条消息。让我们通过以下步骤来设置这个方法：
- en: In the `WhackABox` project, open the `Game.cs`file.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.cs`文件。
- en: 'Add a method called `SendStats()` anywhere in the class, as shown in the following
    code:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中的任何地方添加一个名为`SendStats()`的方法，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The method checks all children of the `scene` object to find nodes of the `PlaneNode`
    type. We iterate through all of these nodes and count how many of the node's children
    have the name `Box`, and then indicate this number in a variable called `boxCount`.
    When we have this information, we create a `GameStats` object and initialize it
    with the box count and the plane count.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法检查`scene`对象的所有子节点，以查找`PlaneNode`类型的节点。我们遍历所有这些节点，并计算节点的子节点中有多少个名称为`Box`，然后在名为`boxCount`的变量中指示这个数字。当我们有了这个信息，我们创建一个`GameStats`对象，并用盒子计数和平面计数进行初始化。
- en: The last step is to send the message. We have to make sure that we are using
    the UI thread (the `MainThread`) since we are going to update the GUI. Only the
    UI thread is allowed to touch the GUI. This is done by wrapping the `MessagingCenter.Send()`
    call in `BeginInvokeOnMainThread().`
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是发送消息。我们必须确保我们正在使用UI线程（`MainThread`），因为我们将要更新GUI。只有UI线程才允许触摸GUI。这是通过将`MessagingCenter.Send()`调用包装在`BeginInvokeOnMainThread()`中来完成的。
- en: The message that is sent is `stats_updated`. It contains the stats information
    as an argument. Let's now make use of the `SendStats()` method.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 发送的消息是`stats_updated`。它包含统计信息作为参数。现在让我们使用`SendStats()`方法。
- en: Wiring up events
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接事件
- en: 'The scene has a lot of events that we can wire up. We will hook up to `NodeAdded`
    and `NodeRemoved` to determine when we need to send statistics information. Let''s
    set this up by going through the following steps:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 场景中有很多事件可以连接。我们将连接到`NodeAdded`和`NodeRemoved`以确定何时需要发送统计信息。让我们通过以下步骤设置这一点：
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.cs`文件。
- en: 'In the `Start()` method, add the code that is highlighted in bold in the following
    fragment:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start()`方法中，添加以下代码中加粗的行：
- en: '[PRE39]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Each time a node is either added or removed, a new message will be sent to the
    GUI.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 每当节点被添加或移除时，都会向GUI发送一个新消息。
- en: Updating the GUI
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新GUI
- en: 'This will be the last method we add to the game. It handles the information updates
    and also updates the labels in the GUI. Let''s add it by going through the following
    steps:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们添加到游戏中的最后一个方法。它处理信息更新，并更新GUI中的标签。让我们通过以下步骤添加它：
- en: In the `WhackABox` project, open the `MainPage.xaml.cs` file.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`MainPage.xaml.cs`文件。
- en: 'Add a method called `StatsUpdated()` anywhere in the code, as shown in the
    following fragment:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中的任何地方添加一个名为`StatsUpdated()`的方法，如下面的片段所示：
- en: '[PRE40]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The method receives the `GameStats` object that we sent and updates the two
    labels in the GUI.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接收我们发送的`GameStats`对象，并更新GUI中的两个标签。
- en: Subscribing to the updates in the MainForm
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅MainForm中的更新
- en: 'The last line of code to add will wire up the `StatsUpdated` handler to an
    incoming message. Let''s set this up by going through the following steps:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加的最后一行代码将`StatsUpdated`处理程序连接到传入的消息。让我们通过以下步骤设置这一点：
- en: In the `WhackABox` project, open the `MainPage.xaml.cs` file.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`MainPage.xaml.cs`文件。
- en: 'In the constructor, add the line of code that is highlighted in bold in the
    following fragment:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，添加以下代码中加粗的行：
- en: '[PRE41]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This line of code hooks up an incoming message with the content `stats_updated`
    to the `StatsUpdated` method. Now run the game and go out into the world to hunt
    down those boxes!
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将传入消息与内容`stats_updated`连接到`StatsUpdated`方法。现在运行游戏，走出去寻找那些方块吧！
- en: 'The completed app looks something like the following screenshot, with spinning
    boxes popping up at random locations:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的应用程序看起来像以下截图，随机出现旋转的方块：
- en: '![](img/b06e11ed-7438-49eb-b0c0-2de12f314dd6.png)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b06e11ed-7438-49eb-b0c0-2de12f314dd6.png)'
- en: Summary
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to integrate AR into Xamarin.Forms by using
    custom renderers. We took advantage of UrhoSharp to use cross-platform rendering,
    components, and input management to interact with the world. We also learned a
    bit about `MessagingCenter`, which can be used to send internal in-process messages
    between different parts of an application to reduce coupling.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过使用自定义渲染器将AR集成到Xamarin.Forms中。我们利用了UrhoSharp来使用跨平台渲染、组件和输入管理来与世界交互。我们还学习了一些关于`MessagingCenter`的知识，它可以用于在应用程序的不同部分之间发送内部进程消息，以减少耦合。
- en: Next up, we are going to dive into machine learning and create an app that can
    recognize a hotdog in an image.**
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入机器学习，并创建一个可以识别图像中的热狗的应用程序。
