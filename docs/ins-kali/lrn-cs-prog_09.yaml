- en: '*Chapter 9*: Resource Management'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：资源管理'
- en: In previous chapters, we discussed and worked with value types and reference
    types and have also seen how they differ. We also briefly talked about how the
    runtime is managing the allocated memory.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们讨论并使用了值类型和引用类型，并且也看到了它们的不同之处。我们也简要讨论了运行时如何管理分配的内存。
- en: In this chapter, we will get into more details of this topic and look at the
    language features and best practices for managing memory and resources.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更详细地讨论这个主题，并查看管理内存和资源的语言特性和最佳实践。
- en: 'The topics that will be discussed in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论以下主题：
- en: Garbage collection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Finalizers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终结器
- en: The IDisposable interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDisposable接口
- en: The `using` statement
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`using`语句'
- en: Platform invoke
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台调用
- en: Unsafe code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不安全的代码
- en: By the end of this chapter, you will have learned how to implement disposable
    types and how to dispose of objects when they are no longer needed. You will have
    also learned how to call native APIs and write unsafe code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将学会如何实现可处理的类型以及在不再需要时如何处理对象。您还将学会如何调用本机API并编写不安全的代码。
- en: Garbage collection
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: The **Common Language Runtime** (**CLR**) is responsible for managing the lifetime
    of objects and freeing memory when it's no longer used so that new objects can
    be allocated within the process. It does so through a component called the **garbage
    collector** (**GC**), which allocates objects on the managed heap in an efficient
    manner and clears memory by reclaiming objects that are no longer used. The garbage
    collector makes developing applications easier because you do not have to worry
    about manually freeing memory. This is what makes applications written for .NET
    to be known as *managed*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**公共语言运行时**（**CLR**）负责管理对象的生命周期，并在不再使用时释放内存，以便在进程内分配新对象。它通过一个名为**垃圾收集器**（**GC**）的组件来实现这一点，该组件以高效的方式在托管堆上分配对象，并通过回收不再使用的对象来清除内存。垃圾收集器使得开发应用程序更容易，因为您不必担心手动释放内存。这就是使为.NET编写的应用程序被称为*托管*的原因。'
- en: Before we discuss how all this happens, you need to understand the difference
    between **stack** and **heap**, as well as the differences between **types**,
    **objects**, and **references**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论所有这些是如何发生之前，你需要理解**栈**和**堆**之间的区别，以及**类型**、**对象**和**引用**之间的区别。
- en: A type (whether introduced with the `class` or `struct` keyword in C#) is a
    blueprint for constructing objects. It is described in the source code using language
    features. An object is an instantiation of a type and lives in memory. A reference
    is a sort of handle (basically, a storage location) that points to an object.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 类型（无论是在C#中使用`class`还是`struct`关键字引入的）是构造对象的蓝图。它在源代码中使用语言特性描述。对象是类型的实例化，并存在于内存中。引用是一种句柄（基本上是一个存储位置），指向一个对象。
- en: Now, let's discuss memory. The stack is a relatively small segment of memory
    allocated by the compiler that keeps track of the memory necessary for running
    the application. The stack has **Last In First Out (LIFO)** semantics and grows
    and shrinks as the program execution is invoking functions or returning from functions.
    The heap, on the other hand, is a large segment of memory that the program may
    use to allocate memory at runtime, and which, in .NET, is managed by the CLR.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论内存。栈是编译器分配的一个相对较小的内存段，用于跟踪运行应用程序所需的内存。栈具有**后进先出（LIFO）**语义，并且随着程序执行调用函数或从函数返回而增长和缩小。另一方面，堆是程序可能在运行时分配内存的一个大内存段，在.NET中由CLR管理。
- en: Objects of value types may be stored in multiple locations. They are typically
    stored on the stack, but they can also be stored on CPU registers. Value types
    that are a part of a reference type are stored on the heap as part of the *enclosing
    object*. Objects of reference types are always stored on the heap, but references
    to objects are stored on the stack or CPU registers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型的对象可以存储在多个位置。它们通常存储在栈上，但也可以存储在CPU寄存器上。作为引用类型的值类型存储在堆上作为*封闭对象*的一部分。引用类型的对象总是存储在堆上，但对象的引用存储在栈或CPU寄存器上。
- en: 'To understand this better, let''s consider the following short program, where
    `Point2D` is a value type and `Engine` is a reference type:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们考虑下面的短程序，其中`Point2D`是一个值类型，`Engine`是一个引用类型：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Conceptually (because this is a very simplistic representation), the stack
    and heap will contain the following values:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在概念上（因为这是一个非常简单的表示），栈和堆将包含以下值：
- en: '![Figure 9.1 – The conceptual representation of the stack and heap content
    during the execution of the preceding program'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 - 在上述程序执行期间栈和堆内容的概念表示'
- en: '](img/Figure_9.1_B12346.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.1_B12346.jpg)'
- en: Figure 9.1 – The conceptual representation of the stack and heap content during
    the execution of the preceding program
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 - 在上述程序执行期间栈和堆内容的概念表示
- en: 'The stack is managed by the compiler and, for the rest of this chapter, we
    will discuss the heap and how the runtime manages it. The .NET runtime divides
    objects into two groups:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 栈由编译器管理，本章的其余部分我们将讨论堆以及运行时如何管理它。.NET运行时将对象分为两组：
- en: '**Large**: These objects are those objects that are larger than 85 KB; multidimensional
    objects are also included in this category.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大型**：这些对象是大于85 KB的对象；多维对象也包括在此类别中。'
- en: '**Small**: These objects are all other objects.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小型**：这些对象是所有其他对象。'
- en: 'The heap is composed of several memory segments called **generations**. There
    are three generations of memory – **0**, **1**, and **2**:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 堆由称为**代**的几个内存段组成。内存有三代 - **0**，**1**和**2**：
- en: Generation 0 contains *small*, and usually *short-lived, objects,* such as local
    variables or objects instantiated for the lifetime of a function call.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第0代包含*小*，通常是*短寿命的对象*，比如局部变量或在函数调用的生命周期内实例化的对象。
- en: Generation 1 contains *small objects* that have survived a garbage collection
    of memory from generation 0.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一代包含*小对象*，它们在对第0代内存进行垃圾收集后幸存下来。
- en: Generation 2 contains *long-lived small objects* that have survived a garbage
    collection of memory from generation 1 and large objects (which are always allocated
    on this segment).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2代包含*长寿命的小对象*，它们在对第1代内存进行垃圾收集后幸存下来，以及大对象（总是分配在这个段上）。
- en: 'When the runtime needs to allocate objects on the managed heap and there is
    not enough memory, it triggers a garbage collection. A garbage collection has
    three phases:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时需要在托管堆上分配对象而内存不足时，它会触发垃圾收集。垃圾收集有三个阶段：
- en: First, the garbage collector builds a graph of all live objects in order to
    figure out what is still used and what may be deleted.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，垃圾收集器构建了所有活动对象的图形，以便弄清楚什么仍在使用，什么可以被删除。
- en: Second, references to objects that will be compacted are updated.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，更新将被压缩的对象的引用。
- en: Third, the dead objects are removed, and the surviving objects are compacted.
    Typically, the large object heap containing large objects is not compacted because
    moving large chunks of data incurs performance costs.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，死对象被移除，幸存对象被压缩。通常，包含大对象的大对象堆不会被压缩，因为移动大块数据会产生性能成本。
- en: When the garbage collection starts, all the managed threads are suspended, with
    the exception of the thread that started the collection. The threads are resumed
    when the garbage collection ends. The garbage collection's first phase starts
    from the so-called **application roots**, which are storage locations that contain
    references to objects on the heap. Application roots include references to global
    objects, static objects, fields, local objects, objects passed as function arguments,
    objects waiting to be finalized, and CPU registers that contain references to
    objects on the heap.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当垃圾收集开始时，所有托管线程都被暂停，除了启动收集的线程。当垃圾收集结束时，线程会恢复。垃圾收集的第一阶段从所谓的**应用根**开始，这些是包含对堆上对象引用的存储位置。应用根包括对全局对象、静态对象、字段、局部对象、作为函数参数传递的对象、等待终结的对象以及包含对堆上对象引用的CPU寄存器的引用。
- en: The CLR builds a graph of reachable heap objects; everything that is not reachable
    will be deleted. If all generation 0 objects have been evaluated, but the freed
    memory is not enough, the garbage collection proceeds to evaluate generation 1\.
    If more memory is required after this, the garbage collection proceeds to evaluate
    generation 2.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: CLR构建了可达堆对象的图形；所有不可达的对象将被删除。如果所有第0代对象都已经被评估，但释放的内存还不够，垃圾收集将继续评估第1代。如果之后需要更多内存，垃圾收集将继续评估第2代。
- en: Objects that survived the garbage collection of generation 0 are assigned to
    generation 1, and objects that survived from generation 1 are assigned to generation
    2\. However, objects that survive the garbage collection of generation 2 remain
    in generation 2\. If the garbage collection process is finished and there is not
    enough memory on the large object heap (that's always part of generation 2) to
    allocate as requested, the CLR throws an exception of the `OutOfMemoryException`
    type. This does not necessarily mean there is no more memory, but that the uncompacted
    memory on this segment does not contain a chunk large enough for the new object.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 幸存下来的第0代垃圾收集的对象被分配到第1代，幸存下来的第1代对象被分配到第2代。然而，幸存下来的第2代垃圾收集的对象仍然留在第2代。如果垃圾收集过程结束后，在大对象堆上没有足够的内存（总是属于第2代）来分配所请求的内存，CLR会抛出`OutOfMemoryException`类型的异常。这并不一定意味着没有更多的内存，而是这个段上未压缩的内存不包含足够大的块来存放新对象。
- en: 'The base class library contains a class called `System.GC` that enables us
    to interact with the garbage collector. However, this is seldom the case, apart
    from implementing the disposable pattern that we will see later in this chapter,
    in the *The IDisposable interface* section. Here are several members of this class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 基类库包含一个名为`System.GC`的类，它使我们能够与垃圾收集器交互。然而，除了在本章后面将看到的*IDisposable接口*部分中实现的可释放模式之外，这很少发生。这个类有几个成员：
- en: '![](img/Chapter_09_Table_1_01.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_09_Table_1_01.png)'
- en: 'The following program uses the `System.GC` class to show the current generation
    of the `Engine` object, as well as the estimated size of the managed heap, at
    the time of the call:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序使用`System.GC`类来显示`Engine`对象的当前代数，以及调用时托管堆的估计大小：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of the program is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '![Figure 9.2 – A console screenshot showing the output of the preceding program'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 – 一个控制台截图显示了前面程序的输出'
- en: '](img/Figure_9.2_B12346.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.2_B12346.jpg)'
- en: Figure 9.2 – A console screenshot showing the output of the preceding program
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 一个控制台截图显示了前面程序的输出
- en: We'll learn about finalizers in the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节学习终结器。
- en: Finalizers
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终结器
- en: The garbage collector provides the automatic disposal of managed resources.
    However, there are cases when you have to work with unmanaged resources such as
    raw file handles, windows, or other operating system resources retrieved with
    **Platform Invocation Services** (**P/Invoke**) calls, as well as COM object references
    in some advanced scenarios. These resources need to be explicitly released before
    the object is destroyed by the garbage collector; otherwise, resource leaks occur.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集器提供了托管资源的自动释放。然而，有些情况下你必须处理非托管资源，比如原始文件句柄、窗口或其他通过**平台调用服务**（**P/Invoke**）调用检索的操作系统资源，以及一些高级场景中的COM对象引用。这些资源在对象被垃圾收集器销毁之前必须显式释放，否则会发生资源泄漏。
- en: 'Every object has a special method called the `System.Object` class has a virtual
    and protected member called `Finalize()`, with an empty implementation. This is
    shown in the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都有一个特殊的方法，称为`System.Object`类有一个虚拟的受保护成员叫做`Finalize()`，带有一个空的实现。下面的代码展示了这一点：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Although this is a virtual method, you cannot actually override it directly.
    Instead, the C# language offers a syntax identical to the one for destructors
    in C++ to create a finalizer and override the `System.Object` method. However,
    this is only possible to implement for reference types; value types cannot have
    finalizers since they are not garbage collected. This is shown in the following
    code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个虚方法，但你实际上不能直接重写它。相反，C#语言提供了一个与C++中析构函数相同的语法来创建一个终结器并重写`System.Object`方法。然而，这只对引用类型实现是可能的；值类型不能有终结器，因为它们不会被垃圾收集。以下代码展示了这一点：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The reason you cannot explicitly override the `Finalize()` method is that the
    C# compiler will add additional code to ensure that the base class implementation
    is actually called during finalization (this means the `Finalize()` method is
    called on all instances in the inheritance chain). Therefore, the code shown earlier
    for the finalizer is replaced by the compiler with the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能显式重写`Finalize()`方法的原因是，C#编译器会添加额外的代码来确保在终结时实际上调用基类的实现（这意味着在继承链中的所有实例上都调用`Finalize()`方法）。因此，编译器用以下代码替换了之前显示的终结器：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Although a class may have multiple constructors, it can only have *one finalizer*.
    Finalizers cannot, therefore, be overloaded or have modifiers and parameters;
    they also cannot be inherited. Finalizers are not called directly, but are invoked
    by the garbage collector.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一个类可能有多个构造函数，但它只能有*一个终结器*。因此，终结器不能被重载或具有修饰符和参数；它们也不能被继承。终结器不会被直接调用，而是由垃圾收集器调用。
- en: The way the garbage collector invokes the finalizers is as follows. When an
    object that has a finalizer is created, the garbage collector adds a reference
    to it to an internal structure called the *finalization queue*. When proceeding
    with collecting objects, the garbage collector calls the finalizers on all the
    objects on the finalization queue, unless they have been exempted from finalization
    with a call to `GC.SupressFinalize()`. This is also done when the application
    domain is being unloaded, but only for .NET Framework; for .NET Core, this is
    not the case. The invocation of the finalizers is still non-deterministic. The
    exact moment of the call is undefined as well as the thread on which the invocation
    occurs. Also, the finalizers of two objects, even when referring to one another,
    is not guaranteed to happen in any particular order.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集器调用终结器的方式如下。当创建一个具有终结器的对象时，垃圾收集器将其引用添加到一个名为*终结队列*的内部结构中。在收集对象时，垃圾收集器调用终结队列中所有对象的终结器，除非它们已经通过调用`GC.SupressFinalize()`免除了终结。这也是在应用程序域被卸载时进行的操作，但仅适用于.NET
    Framework；对于.NET Core来说，情况并非如此。终结器的调用仍然是不确定的。调用的确切时刻以及调用发生的线程都是未定义的。此外，即使两个对象的终结器相互引用，也不能保证以任何特定顺序发生。
- en: Information box
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 信息框
- en: Because finalizers incur a performance loss, make sure that you do not create
    empty finalizers. Implement a finalizer if, and only if, your object must dispose
    of an unmanaged resource.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于终结器会导致性能损失，请确保不要创建空的终结器。只有在对象必须处理未托管资源时才实现终结器。
- en: 'The `HandleWrapper` class shown in the following code is a wrapper for a native
    handler. An actual implementation may be more complex; this is shown for teaching
    purposes only. The raw handle may be created in native code and passed to a managed
    application. This class takes ownership of the handle and therefore needs to release
    it when the object is no longer needed. This is done with a call to the `CloseHandle()`
    system API using *P/Invoke*. The class defines a finalizer to do so. Let''s take
    a look at the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码中显示的`HandleWrapper`类是一个本机句柄的包装器。实际的实现可能更复杂；这只是为教学目的而显示的。原始句柄可能是在本机代码中创建并传递给托管应用程序。这个类拥有句柄的所有权，因此在对象不再需要时需要释放它。这是通过使用*P/Invoke*调用`CloseHandle()`系统API来完成的。该类定义了一个终结器来实现这一点。让我们看一下以下代码：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is seldom the case when you actually need to create a finalizer. For scenarios
    such as the one mentioned previously, there are system wrappers available for
    handling unmanaged resources. You should use one of the following safe handles:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有情况下你实际上需要创建一个终结器。对于前面提到的情景，有系统包装器可用于处理未托管资源。你应该使用以下安全句柄之一：
- en: '`SafeFileHandle`: A wrapper for a file handle'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SafeFileHandle`：文件句柄的包装器'
- en: '`SafeMemoryMappedFileHandle`, a wrapper for memory-mapped file handles'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SafeMemoryMappedFileHandle`，内存映射文件句柄的包装器'
- en: '`SafeMemoryMappedViewHandle`, a wrapper for a pointer to a block of unmanaged
    memory'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SafeMemoryMappedViewHandle`，一个对未托管内存块的指针的包装器'
- en: '`SafeNCryptKeyHandle`, `SafeNCryptProviderHandle`, and `SafeNCryptSecretHandle`,
    wrappers for cryptographic handles'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SafeNCryptKeyHandle`，`SafeNCryptProviderHandle`和`SafeNCryptSecretHandle`，加密句柄的包装器'
- en: '`SafePipeHandle`, a wrapper for pipe handles'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SafePipeHandle`，管道句柄的包装器'
- en: '`SafeRegistryHandle`, a wrapper for a handle to a registry key'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SafeRegistryHandle`，对注册表键句柄的包装器'
- en: '`SafeWaitHandle`, a wrapper for a wait handle'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SafeWaitHandle`，等待句柄的包装器'
- en: As already mentioned, finalizers are still non-deterministic. To ensure the
    deterministic release of resources, either managed or unmanaged, a type should
    provide a `Close()` method or implement the `IDisposable` interface. In this case,
    the finalizer could be used only to free unmanaged resources in the event the
    `Dispose()` method was not called.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，终结器仍然是不确定的。为了确保资源的确定性释放，无论是托管的还是未托管的，一个类型应该提供一个`Close()`方法或实现`IDisposable`接口。在这种情况下，终结器只能用于在未调用`Dispose()`方法时释放未托管资源。
- en: We'll learn about the `IDisposable` interface in the next section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节学习`IDisposable`接口。
- en: The IDisposable interface
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`IDisposable`接口'
- en: 'Deterministic disposal of resources can be done by implementing the `System.IDisposable`
    interface. This interface has a single method called `Dispose()` that can be explicitly
    called by users when an object is no longer used and its resources can be disposed
    of. However, you should only implement this interface in the following circumstances:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的确定性处理可以通过实现`System.IDisposable`接口来完成。这个接口有一个叫做`Dispose()`的方法，当一个对象不再被使用并且它的资源可以被处理时，用户可以显式调用这个方法。然而，你只应该在以下情况下实现这个接口：
- en: The class has ownership of *unmanaged resources*
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类拥有*非托管资源*
- en: The class has ownership of *managed resources* that are themselves disposable
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类拥有*托管资源*，它们本身是可处理的
- en: 'The way this interface should be implemented depends on whether the class has
    ownership of unmanaged resources. The general pattern, when you have both managed
    and unmanaged resources, is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口应该如何实现取决于这个类是否拥有非托管资源。当你既有托管资源又有非托管资源时，通常的模式如下：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: From the `Dispose()` method of the `IDisposable` interface, we call a protected
    virtual method with the same name (although it can have any name) and a parameter
    specifying that the object is being destroyed. To ensure that the disposal of
    resources is done only once, a Boolean field (called `disposed` here) is used.
    The Boolean parameter to the overloaded `Dispose()` method indicates whether the
    method is being called in a deterministic manner by the user or in a non-deterministic
    manner by the garbage collector when the object is finalized.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从`IDisposable`接口的`Dispose()`方法中，我们调用一个受保护的虚拟方法，方法名相同（尽管可以有任何名字），并且有一个参数指定对象正在被销毁。为了确保资源的处理只发生一次，使用了一个布尔字段（这里叫做`disposed`）。重载的`Dispose()`方法的布尔参数指示这个方法是由用户以确定性方式调用的，还是由垃圾收集器在对象终结时以非确定性方式调用的。
- en: In the former case, both managed and unmanaged resources should be disposed
    of and the finalization of the object should be suppressed with a call to `GC.SupressFinalize()`.
    In the latter case, only unmanaged resources must be disposed of, because the
    disposal was not invoked by the user, but by the garbage collector. The reason
    this function is virtual and protected is that it should be possible for derived
    classes to override it, but it should not be possible to call it directly from
    outside the class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一种情况下，托管和非托管资源都应该被处理，并且对象的终结应该被抑制，通过调用`GC.SupressFinalize()`。在后一种情况下，只有非托管资源必须被处理，因为处理不是由用户调用的，而是由垃圾收集器调用的。这个函数是虚拟的和受保护的原因是，派生类应该能够重写它，但不应该能够直接从类外部调用它。
- en: 'Let''s see how to implement this for different scenarios. For starters, we
    will consider the case where the class has only disposable managed resources.
    In the following example, the `Engine` class implements `IDisposable`. What it
    does exactly, what resources it manages, and how it disposes of them is not important.
    However, the `Car` class has an owning reference to an `Engine` object, which
    should be destroyed as soon as the `Car` object is destroyed. Moreover, this should
    be done in a deterministic manner, when the `Car` is no longer needed. In this
    case, the `IDisposable` interface must be implemented as follows in the `Car`
    class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何为不同的情况实现这个。首先，我们将考虑这样一个情况，即类只有可处理的托管资源。在下面的例子中，`Engine`类实现了`IDisposable`。它具体做什么，管理什么资源，以及如何处理它们并不重要。然而，`Car`类拥有对`Engine`对象的拥有引用，这个引用应该在`Car`对象被销毁时立即销毁。此外，这应该以确定性的方式进行，当`Car`不再需要时。在这种情况下，`Car`类必须按照以下方式实现`IDisposable`接口：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Since this class does not have a finalizer, the overloaded `Dispose()` method
    is of little use here, and the code can be further simplified. However, a derived
    class can override it and dispose of further resources.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个类没有终结器，重载的`Dispose()`方法在这里用处不大，代码可以进一步简化。然而，派生类可以重写它并处理更多的资源。
- en: 'In the previous section, we implemented a class called `HandleWrapper` that
    had a finalizer to close the system handle that it owned. In the following listing,
    you can see a modified version of this class that implements the `IDisposable`
    interface:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们实现了一个叫做`HandleWrapper`的类，它有一个终结器来关闭它拥有的系统句柄。在下面的清单中，你可以看到这个类的修改版本，它实现了`IDisposable`接口：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This class has both a `Dispose()` method (that can be called by the user) and
    a finalizer (called by the garbage collector in case the user did not call the
    `Dispose()` method). There are no managed resources to release in this example,
    so the Boolean parameter of the overloaded `Dispose()` method is basically unused.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类既有一个`Dispose()`方法（可以被用户调用），又有一个终结器（在用户没有调用`Dispose()`方法的情况下，由垃圾收集器调用）。在这个例子中没有托管资源需要释放，所以重载的`Dispose()`方法的布尔参数基本上是没有用的。
- en: The language provides us with a way to automatically dispose of objects that
    implement the `IDisposable` interface when they are no longer needed. We will
    learn about this in the following section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 语言为我们提供了一种自动处理实现`IDisposable`接口的对象的方式，当它们不再需要时。我们将在下一节中了解这个。
- en: The using statement
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: using语句
- en: Before we introduce the `using` statement, let's see how explicit resource management
    is done in a proper manner. This will help you to better understand the need and
    workings of the `using` statements.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们介绍`using`语句之前，让我们看看如何以正确的方式进行显式资源管理。这将帮助你更好地理解`using`语句的需要和工作原理。
- en: 'The `Car` class we looked at in the previous section can be used as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节中看到的`Car`类可以这样使用：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A `try-catch-finally` block (although `catch` is not explicitly shown here)
    should be used in order to ensure proper disposal of the object when it is no
    longer needed. However, the C# language provides a convenient syntax for ensuring
    the correct disposal of an object with the `using` statement. This has the following
    form:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用`try-catch-finally`块（尽管这里没有明确显示`catch`）来确保在不再需要对象时正确处理对象。然而，C#语言提供了一个方便的语法来确保使用`using`语句正确处理对象的释放。它的形式如下：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The compiler transforms this into the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将其转换为以下代码：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `using` statement introduces a scope for the variable defined in the statement
    and ensures that the object is properly disposed of before the scope is exited.
    The actual disposal depends on whether the resource is a value type, a nullable
    value type, a reference type, or a dynamic type. The call to `resource.Dispose()`
    earlier is actually one of the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`语句引入了一个变量的作用域，并确保在退出作用域之前正确处理对象。实际的处理取决于资源是值类型、可空值类型、引用类型还是动态类型。之前对`resource.Dispose()`的调用实际上是以下之一：'
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For the car example, we can use it as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于汽车示例，我们可以如下使用它：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Multiple objects can be instantiated into the same `using` statement, as shown
    in the following example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 多个对象可以实例化到同一个`using`语句中，如下例所示：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On the other hand, multiple `using` statements can be chained together, as
    shown here, which is equivalent to the previous code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，多个`using`语句可以链接在一起，如下所示，这等效于前面的代码：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In C# 8, the `using` statement can be written as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 8中，`using`语句可以写成如下形式：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For more information about this, refer to [*Chapter 15*](B12346_15_Final_JC_ePub.xhtml#_idTextAnchor271),
    *New Features of C# 8*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅[*第15章*](B12346_15_Final_JC_ePub.xhtml#_idTextAnchor271)，*C# 8的新功能*。
- en: Platform invoke
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台调用
- en: Earlier in this chapter, we implemented a handle wrapper class that used a Windows
    API function, `CloseHandle()`, to delete system handles when the object was disposed
    of. The way a C# program can invoke Windows APIs, but also any function exported
    from a native **dynamic-linked library (DLL)**, is done through **Platform Invocation
    Services**, also known as **Platform Invoke** or **P/Invoke**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早些时候，我们实现了一个句柄包装类，该类使用Windows API函数`CloseHandle()`在对象被处理时删除系统句柄。C#程序可以调用Windows
    API，也可以调用从本机**动态链接库（DLL）**导出的任何函数，都是通过**平台调用服务**，也称为**平台调用**或**P/Invoke**。
- en: 'P/Invoke locates and invokes an exported function and marshals the arguments
    between the managed and unmanaged boundaries. In order to be able to call a function
    using P/Invoke, you must know the name and signature of the function, as well
    as the name of the DLL from where it is exported. Then, you must create a managed
    definition of the unmanaged function. To understand how this works, we will look
    at an example of the `MessageBox()` function, available in `user32.dll`. The function
    signature is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: P/Invoke定位并调用导出的函数，并在托管和非托管边界之间进行参数传递。为了能够使用P/Invoke调用函数，您必须知道函数的名称和签名，以及它所在的DLL的名称。然后，您必须创建非托管函数的托管定义。为了理解这是如何工作的，我们将看一个`user32.dll`中可用的`MessageBox()`函数的示例。函数签名如下：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can create the following manage definition for the function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为函数创建以下托管定义：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There are several things to notice here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几件事情需要注意：
- en: The signature of the managed definition must match the native one, using the
    equivalent managed types for the parameters.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管定义的签名必须与本机定义匹配，使用等效的托管类型作为参数。
- en: The function must be defined as `static` and `extern`.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数必须定义为`static`和`extern`。
- en: The function must be decorated with `DllImportAttribute`. This attribute defines
    the necessary information for the runtime to call the native function.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数必须用`DllImportAttribute`修饰。此属性为运行时调用本机函数定义了必要的信息。
- en: '`DllImportAttribute` requires at least the name of the DLL from which the native
    function is exported. You can omit the name of the entry point in the DLL, in
    which case the name of the managed function is used to identify it. However, you
    can also specify it explicitly using the `EntryPoint` property of the attribute.
    The other properties you can specify are as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`DllImportAttribute`至少需要指定从中导出本机函数的DLL的名称。您可以省略DLL中入口点的名称，此时将使用托管函数的名称来标识它。但是，您也可以使用属性的`EntryPoint`显式指定它。您可以指定的其他属性如下：'
- en: '`BestFitMapping`: A Boolean flag that indicates whether best-fit mapping is
    enabled. This is used when converting from Unicode to ANSI characters. Best-fit
    mapping enables the interop marshaler to use close-matching characters when an
    exact match does not exist (for instance, the copyright character is replaced
    with *c*).'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BestFitMapping`：一个布尔标志，指示是否启用最佳匹配映射。在从Unicode到ANSI字符的转换时使用。最佳匹配映射使得互操作编组器在不存在精确匹配时使用最接近的字符（例如，版权字符被替换为*c*）。'
- en: '`CallingConvention`: The calling convention for an entry point. The default
    value is `Winapi`, which defaults to `StdCall`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CallingConvention`：入口点的调用约定。默认值为`Winapi`，默认为`StdCall`。'
- en: '`CharSet`: Specifies the marshaling behavior for string parameters. It is also
    used to specify the entry point name to invoke. For instance, for the message
    box example, Windows has two functions actually—`MessageBoxA()` and `MessageBoxW()`.
    The value of the `CharSet` parameter enables the runtime to choose between one
    or the other; more precisely, the name ending in `A` for `CharSet.Ansi` (which
    is the default for C#) and the name ending in `W` for `CharSet.Unicode`.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CharSet`：指定字符串参数的编组行为。它还用于指定要调用的入口点名称。例如，对于消息框示例，Windows实际上有两个函数—`MessageBoxA()`和`MessageBoxW()`。`CharSet`参数的值使运行时能够在其中选择一个；更准确地说，以`CharSet.Ansi`结尾的名称用于`CharSet.Ansi`（这是C#的默认值），以`CharSet.Unicode`结尾的名称用于`CharSet.Unicode`。'
- en: '`EntryPoint`: The entry point name or ordinal.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EntryPoint`：入口点名称或序数。'
- en: '`ExactSpelling`: Indicates whether the `CharSet` field determines the CLR to
    search the unmanaged DLL for entry-point names other than the one that has been
    specified.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExactSpelling`：指示`CharSet`字段是否确定CLR搜索非托管DLL以查找除已指定的之外的入口点名称。'
- en: '`PreserveSig`: A Boolean flag that indicates whether the `HRESULT` or `retval`
    values are translated directly (if `true`) or automatically converted into exceptions
    (if `false`). The default value is `true`.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PreserveSig`：一个布尔标志，指示`HRESULT`或`retval`值是直接翻译（如果为`true`）还是自动转换为异常（如果为`false）。默认值为`true`。'
- en: '`SetLastError`: Indicates, if `true`, that the callee calls `SetLastError()`
    before returning. In this case, the CLR calls `GetLastError()` and caches the
    value to prevent it from being overwritten, and therefore lost, by other Windows
    API calls. To retrieve the value, you can call `Marshal.GetLastWin32Error()`.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetLastError`：如果为`true`，则表示被调用者在返回之前调用`SetLastError()`。在这种情况下，CLR调用`GetLastError()`并缓存该值，以防止被其他Windows
    API调用覆盖和丢失。要检索该值，可以调用`Marshal.GetLastWin32Error()`。'
- en: '`ThrowOnUnmappableChar`: Indicates (when `true`) whether the marshaler should
    throw an error when converting a Unicode character into ANSI ''`?`''. The default
    value is `false`.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThrowOnUnmappableChar`：指示（当为`true`时）编组器在将Unicode字符转换为ANSI ''`?`''时是否应抛出错误。默认值为`false`。'
- en: 'The following table shows the data types in the Windows API and C-style functions,
    as well as their corresponding C# or .NET Framework types:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了Windows API和C风格函数中的数据类型，以及它们对应的C#或.NET Framework类型：
- en: '![](img/Chapter_09_Table_2_01.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_09_Table_2_01.jpg)'
- en: Important note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '[1] Decorate with `CharSet.Ansi` or use the `[MarshalAs(UnmanagedType.LPStr)]`
    attribute on the `string` parameter.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 在`string`参数上使用`CharSet.Ansi`修饰或使用`[MarshalAs(UnmanagedType.LPStr)]`属性。'
- en: '[2] Decorate with `CharSet.Unicode` or use the `[MarshalAs(UnmanagedType.LPWStr)]`
    attribute on the `string` parameter.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] 在`string`参数上使用`CharSet.Unicode`修饰或使用`[MarshalAs(UnmanagedType.LPWStr)]`属性。'
- en: 'To be able to properly call the `MessageBox()` function we defined earlier,
    we should also define constants for the possible arguments and return values.
    A snippet is shown here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够正确调用我们之前定义的`MessageBox()`函数，我们还应该为可能的参数和返回值定义常量。下面是一个片段：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With this all set, we can call the `MessageBox()` function, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好这一切后，我们可以调用`MessageBox()`函数，如下所示：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Many Windows APIs require a buffer to be used to return data. For instance,
    the `GetUserName()` function from `advapi32.dll` returns the name of the user
    associated with the current thread of execution. The function signature is as
    follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Windows API需要使用缓冲区来返回数据。例如，`advapi32.dll`中的`GetUserName()`函数返回与当前执行线程关联的用户的名称。函数签名如下：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first argument is a pointer to an array of characters, which is used to
    receive the name of the user, while the second is a pointer to an unsigned integer,
    which is used to specify the size of the buffer. The buffer needs to be large
    enough to receive the username. Otherwise, the function returns `false`, sets
    the required size in the `pcbBuffer` argument, and sets the last error to `ERROR_INSUFFICIENT_BUFFER`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个指向字符数组的指针，用于接收用户的名称，而第二个参数是一个指向无符号整数的指针，用于指定缓冲区的大小。缓冲区需要足够大以接收用户名。否则，函数将返回`false`，在`pcbBuffer`参数中设置所需的大小，并将最后的错误设置为`ERROR_INSUFFICIENT_BUFFER`。
- en: 'Although you could allocate a buffer large enough to hold the result (some
    functions impose limits on the size of the return value), you cannot always be
    sure. Therefore, typically, you call such a function twice:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以分配一个足够大的缓冲区来容纳结果（一些函数对返回值的大小施加限制），但您并不总是能确定。因此，通常，您会调用这样的函数两次：
- en: First, with an empty buffer to get back the actual size required for the buffer
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，使用一个空缓冲区来获取实际所需的缓冲区大小
- en: Then, after allocating the necessary memory, a second time with a buffer large
    enough to receive the result
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，分配必要的内存后，再次调用，使用足够大的缓冲区来接收结果
- en: 'To see how this works, we will P/Invoke the `GetUserName()` function, whose
    managed definition looks like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这是如何工作的，我们将P/Invoke`GetUserName()`函数，其托管定义如下：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Notice that we use `StringBuilder` for the buffer parameter. Although this
    can grow to any capacity, we will need to know what size to specify. Instead of
    specifying a random large size, we call the function twice, as shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在缓冲区参数中使用`StringBuilder`。虽然这可以增长到任何容量，但我们需要知道要指定的大小。而不是指定一个随机的大尺寸，我们调用函数两次，如下所示：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, the `StringBuffer` object is created with an initial capacity,
    although this is not really necessary. You don't have to specify its capacity;
    it will grow to the required one and receive the correct result.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`StringBuffer`对象是用初始容量创建的，尽管这并不是真正必要的。您不必指定其容量；它将增长到所需的容量并接收正确的结果。
- en: 'Let''s summarize Platform Invocation Services using the following points:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下平台调用服务，使用以下几点：
- en: Allows calling functions exported from native DLLs.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许调用从本地DLL导出的函数。
- en: You must create a managed definition for a function, with the same signature
    and the equivalent managed types for the native ones.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须为函数创建一个托管定义，具有相同的签名和本机类型的等效托管类型。
- en: You must specify at least the function entry point and the name of the exporting
    DLL when defining the managed function.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义托管函数时，您必须至少指定函数入口点和导出DLL的名称。
- en: 'There are some drawbacks when you use P/Invoke, so you should keep the following
    in mind:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用P/Invoke时存在一些缺点，因此您应该牢记以下几点：
- en: If you use P/Invoke to call functions from the Windows API, then your application
    will only work on Windows. This is not a problem if you don't intend to make it
    cross-platform. Otherwise, you have to avoid that altogether.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用P/Invoke调用Windows API中的函数，则您的应用程序将仅在Windows上运行。如果您不打算使其跨平台，这不是问题。否则，您必须完全避免这种情况。
- en: If you need to call functions from a C++ library, you must specify the decorated
    names in your import declarations, which can be troublesome. If you are also authoring
    the C++ library, you can export functions with the `extern "C"` linkage to prevent
    the linker from decorating the names.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要调用C++库中的函数，您必须在导入声明中指定装饰名称，这可能会很麻烦。如果您还要编写C++库，可以导出具有`extern "C"`链接的函数，以防止链接器对名称进行装饰。
- en: There is a slight overhead for marshaling between the managed and unmanaged
    types.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在托管类型和非托管类型之间进行编组会有一些轻微的开销。
- en: This may not be very intuitive at times; for instance, what types to use for
    pointers and handles.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时这可能不太直观；例如，指针和句柄使用什么类型。
- en: In the last section of this chapter, we will discuss unsafe code and pointer
    types, which is the third category of types in C#.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一节中，我们将讨论不安全的代码和指针类型，这是C#中的第三类类型。
- en: Unsafe code
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全的代码
- en: When we discuss the types of .NET Framework and C# language support, we refer
    to value types (structures) and reference types (classes). However, there is yet
    another type that is supported, and that is **pointer types**. If you are not
    familiar with the C or C++ programming languages and pointers in particular, then
    you should know pointers are like *references*—they are storage locations that
    contain the addresses of objects. A reference is basically a *safe pointer* that
    is managed by the CLR.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论.NET Framework和C#语言支持的类型时，我们指的是值类型（结构）和引用类型（类）。然而，还有一种类型得到了支持，那就是**指针类型**。如果你不熟悉C或C++编程语言，特别是指针，那么你应该知道指针就像*引用*——它们是包含对象地址的存储位置。引用基本上是由CLR管理的*安全指针*。
- en: To work with pointer types, you must establish a so-called *unsafe context*.
    In CLR terms, this is called *unverifiable code* because the CLR cannot verify
    its safety. Unsafe code is not necessarily dangerous, but it's your entire responsibility
    to ensure that you do not introduce pointer errors or security risks.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用指针类型，你必须建立所谓的*不安全上下文*。在CLR术语中，这被称为*不可验证的代码*，因为CLR无法验证其安全性。不安全的代码不一定是危险的，但你完全有责任确保你不会引入指针错误或安全风险。
- en: 'In truth, there are very rare cases where you actually have to work with pointers
    in unsafe contexts in C#. There are two common scenarios when this could be the
    case:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在C#中，有很少的情况下你实际上需要在不安全的上下文中使用指针。有两种常见的情况可能会出现这种情况：
- en: Calling functions exported from a native DLL or COM server that require pointer
    types as parameters. However, in most cases, you still can do this with a safe
    code using `System.IntPtr` and members of the `System.Runtime.InteropServices.Marshal`
    type.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用从本机DLL或COM服务器导出的需要指针类型作为参数的函数。然而，在大多数情况下，你仍然可以使用`System.IntPtr`和`System.Runtime.InteropServices.Marshal`类型的成员来使用安全代码。
- en: Optimizing particular algorithms where performance is critical.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化特定算法，性能至关重要。
- en: 'You can define an unsafe context using the `unsafe` keyword. This can be applied
    to the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`unsafe`关键字定义不安全的上下文。这可以应用于以下情况：
- en: 'Types (class, struct, interface, delegate), in which case the entire textual
    context of the type is considered unsafe:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型（类、结构、接口、委托），在这种情况下，整个类型的文本上下文被视为不安全：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Methods, fields, properties, events, indexers, operators, instance and static
    constructors, and destructors, in which case the entire textual context of the
    member is considered unsafe:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法、字段、属性、事件、索引器、运算符、实例和静态构造函数以及析构函数，在这种情况下，成员的整个文本上下文被视为不安全：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A statement (block), in which case the entire textual context of the block
    is considered unsafe:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个语句（块），在这种情况下，整个块的文本上下文被视为不安全：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, in order to be able to compile code that uses unsafe contexts, you
    must explicitly use the `/unsafe` compiler switch. In Visual Studio, you can check
    the **Allow unsafe code** option from **Project properties** | **Build**, under
    the **General** section, as shown in the following screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了能够编译使用不安全上下文的代码，你必须显式地使用`/unsafe`编译器开关。在Visual Studio中，你可以在**项目属性** | **构建**下的**常规**部分中勾选**允许不安全代码**选项，如下截图所示：
- en: '![Figure 9.3 – Visual Studio''s Project Properties page that allows enabling
    the Allow unsafe code option'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3 – Visual Studio的项目属性页面，允许启用不安全代码选项'
- en: '](img/Figure_9.3_B12346.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.3_B12346.jpg)'
- en: Figure 9.3 – Visual Studio's Project Properties page that allows enabling the
    Allow unsafe code option
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – Visual Studio的项目属性页面，允许启用不安全代码选项
- en: 'Unsafe code can only be executed from another unsafe context. For instance,
    if you have a method that is declared as `unsafe`, you may only call it from an
    unsafe context. This is shown in the following example, where the unsafe `Increment()`
    method (introduced previously) is called from an `unsafe` context. An attempt
    to do this from a safe context results in a compiler error:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 不安全的代码只能从另一个不安全的上下文中执行。例如，如果你有一个声明为`unsafe`的方法，你只能从不安全的上下文中调用它。这在下面的例子中得到了展示，其中不安全的`Increment()`方法（之前介绍过）从一个`unsafe`上下文中被调用。在安全的上下文中尝试这样做会导致编译错误：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you are familiar with C or C++, you know that the pointer symbol (`*`) can
    be put either next to the type, the variable, or in between. The following are
    all equivalent in C/C++:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉C或C++，你会知道指针符号（`*`）可以放在类型旁边、变量旁边或者中间。在C/C++中，以下都是等价的：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, in C#, you always put `*` next to the type, as in the following example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在C#中，你总是在类型旁边放上`*`，就像下面的例子一样：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Variables can be of two types—**fixed** and **movable**. Movable variables reside
    in storage locations that are controlled by the garbage collector and therefore
    can be moved or collected. Fixed variables reside in storage locations that are
    unaffected by the operations of the garbage collector.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以是两种类型——**固定的**和**可移动的**。可移动的变量驻留在由垃圾收集器控制的存储位置中，因此可以移动或收集。固定的变量驻留在不受垃圾收集器操作影响的存储位置中。
- en: In unsafe code, you can take the address of a fixed variable using the `&` operator
    without restrictions. However, you can only do so with movable variables using
    a fixed statement. A fixed statement is introduced with the `fixed` keyword and
    is, in many aspects, similar to a `using` statement.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在不安全的代码中，你可以使用`&`运算符无限制地获取固定变量的地址。然而，你只能使用固定语句来处理可移动变量。固定语句是用`fixed`关键字引入的，在许多方面类似于`using`语句。
- en: 'The following is an example of using a fixed statement:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用固定语句的一个例子：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `SetTransparency()` function changes the alpha value of a `Color` object
    using a pointer to the `Alpha` field. Although this is of the `byte` type, which
    is a value type, it resides on the managed heap because it is part of a reference
    type. The garbage collector may move or collect the `Color` object before the
    `Alpha` field is accessed. Therefore, the only possible way to retrieve its address
    is to use the `fixed` statement. This basically pins the managed object so that
    the garbage collector will not move or collect it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetTransparency()`函数使用指向`Alpha`字段的指针来更改`Color`对象的alpha值。尽管这是值类型的`byte`类型，但它位于托管堆上，因为它是引用类型的一部分。垃圾回收器可能会在访问`Alpha`字段之前移动或收集`Color`对象。因此，检索其地址的唯一可能方法是使用`fixed`语句。这基本上固定了托管对象，以便垃圾回收器不会移动或收集它。'
- en: 'Apart from `usafe` and `fixed`, there are two more keywords that can be used
    in unsafe contexts:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`usafe`和`fixed`，还有两个关键字可以在不安全的上下文中使用：
- en: '`stackalloc`, which is used to declare a variable that allocates memory on
    the call stack (similar to `_alloca()` in C):'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stackalloc`用于声明在调用堆栈上分配内存的变量（类似于C中的`_alloca()`）：'
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`sizeof`, which is used to obtain the size in bytes of a value type. For primitive
    types and enum types, the `sizeof` operator can actually be called in safe contexts
    too:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sizeof`用于获取值类型的字节大小。对于原始类型和枚举类型，`sizeof`运算符实际上也可以在安全的上下文中调用：'
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s summarize the unsafe code by taking a look at the following key points:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看以下关键点来总结不安全代码：
- en: It can only be executed in unsafe contexts, introduced with the `unsafe` keyword
    when compiling with the `/unsafe` switch.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只能在不安全的上下文中执行，使用`unsafe`关键字在使用`/unsafe`开关编译时引入。
- en: Types, members, and code blocks can be unsafe contexts.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型、成员和代码块可以是不安全的上下文。
- en: It introduces security and stability risks that you are solely responsible for.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它引入了安全性和稳定性风险，你需要对此负责。
- en: There are very rare cases where you have to use it.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有极少数情况下需要使用它。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter focused on the way the runtime (through the garbage collector)
    manages the lifetime of objects and resources. We learned how the garbage collector
    works and how to write finalizers to dispose of native resources. We have seen
    how to properly implement patterns for the deterministic release of objects with
    the `IDisposable` interface and `using` statements. We also looked at Platform
    Invocation Services, which enable us to make native calls from managed code, as
    well as writing unsafe code—which is code that the CLR cannot verify for safety.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了运行时（通过垃圾回收器）如何管理对象和资源的生命周期。我们学习了垃圾回收器的工作原理，以及如何编写终结器来处理本机资源。我们已经看到了如何正确实现`IDisposable`接口和`using`语句的模式，以确定性地释放对象。我们还研究了平台调用服务，它使我们能够从托管代码中进行本机调用，以及编写不安全的代码——这是CLR无法验证安全性的代码。
- en: In the next chapter of this book, we will look at a different programming paradigm,
    functional programming, and see what its key concepts are in C# and what they
    enable us to do.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一章中，我们将研究不同的编程范式，函数式编程，并了解它在C#中的关键概念以及它们能够让我们做什么。
- en: Test what you learned
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你学到的东西
- en: What are the stack and the heap? What is allocated on each?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 栈和堆是什么？每个上面分配了什么？
- en: What are the memory segments of the heap and what is allocated on each?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 堆的内存段是什么，每个上面分配了什么？
- en: How does garbage collection work?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垃圾回收是如何工作的？
- en: What are finalizers? What is the difference between disposing and finalizing?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终结器是什么？处理和终结之间有什么区别？
- en: What does the `GC.SupressFinalize()` method do?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GC.SupressFinalize()`方法是做什么的？'
- en: What is `IDisposable` and when should it be used?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IDisposable`是什么，何时应该使用它？'
- en: What is the `using` statement?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`using`语句是什么？'
- en: How do you invoke a function from a native DLL in C#?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在C#中从本机DLL调用函数？
- en: What is unsafe code and what are the typical scenarios where it could be used?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不安全代码是什么，它通常在哪些场景中使用？
- en: What program elements can you declare as unsafe?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以声明哪些程序元素为不安全？
- en: Further reading
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Garbage Collection: Automatic Memory Management in the Microsoft .NET Framework*,
    Jeffrey Richter – MSDN Magazine: [https://docs.microsoft.com/en-us/archive/msdn-magazine/2000/november/garbage-collection-automatic-memory-management-in-the-microsoft-net-framework](https://docs.microsoft.com/en-us/archive/msdn-magazine/2000/november/garbage-collection-automatic-memory-management-in-the-microsoft-net-framework)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*垃圾回收：Microsoft .NET Framework中的自动内存管理*，Jeffrey Richter – MSDN Magazine: [https://docs.microsoft.com/en-us/archive/msdn-magazine/2000/november/garbage-collection-automatic-memory-management-in-the-microsoft-net-framework](https://docs.microsoft.com/en-us/archive/msdn-magazine/2000/november/garbage-collection-automatic-memory-management-in-the-microsoft-net-framework)'
- en: '*Garbage Collection: Part 2: Automatic Memory Management in the Microsoft .NET
    Framework*, Jeffrey Richter – MSDN Magazine: [https://docs.microsoft.com/en-us/archive/msdn-magazine/2000/december/garbage-collection-part-2-automatic-memory-management-in-the-microsoft-net-framework](https://docs.microsoft.com/en-us/archive/msdn-magazine/2000/december/garbage-collection-part-2-automatic-memory-management-in-the-microsoft-net-framework)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*垃圾回收：第2部分：Microsoft .NET Framework中的自动内存管理*，Jeffrey Richter – MSDN Magazine:
    [https://docs.microsoft.com/en-us/archive/msdn-magazine/2000/december/garbage-collection-part-2-automatic-memory-management-in-the-microsoft-net-framework](https://docs.microsoft.com/en-us/archive/msdn-magazine/2000/december/garbage-collection-part-2-automatic-memory-management-in-the-microsoft-net-framework)'
