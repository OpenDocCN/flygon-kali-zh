- en: Docker and Jenkins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker和Jenkins
- en: In this chapter, we will learn how to leverage Jenkins to build our Docker images
    and deploy our Docker containers. Next, we will learn how to deploy our Jenkins
    server as a Docker container. We will follow that by learning how to build Docker
    images within the Dockerized Jenkins server. This is what is often called Docker
    in Docker. Finally, we will see how to utilize Docker containers as Jenkins build
    agents, allowing every build to be run in a pristine, ephemeral Docker container.
    Of course, we will show how to build Docker images, test applications, and push
    tested images to a Docker registry, all within our Dockerized Jenkins build agents.
    This will provide you will all the tools you will need to set up your CI/CD systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何利用Jenkins来构建我们的Docker镜像并部署我们的Docker容器。接下来，我们将学习如何将我们的Jenkins服务器部署为Docker容器。然后，我们将学习如何在Docker化的Jenkins服务器中构建Docker镜像。这通常被称为Docker中的Docker。最后，我们将看到如何利用Docker容器作为Jenkins构建代理，允许每个构建在一个原始的、短暂的Docker容器中运行。当然，我们将展示如何在我们的Docker化的Jenkins构建代理中构建Docker镜像、测试应用程序，并将经过测试的镜像推送到Docker注册表中。这将为您提供设置CI/CD系统所需的所有工具。
- en: If all the containers in the world were laid end to end, they would go around
    the earth more than twice.– [https://www.bigboxcontainers.co.za/](https://www.bigboxcontainers.co.za/)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果世界上所有的集装箱都被排成一排，它们将绕地球超过两次。- [https://www.bigboxcontainers.co.za/](https://www.bigboxcontainers.co.za/)
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using Jenkins to build Docker images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jenkins构建Docker镜像
- en: Setting up a Dockerized Jenkins server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Docker化的Jenkins服务器
- en: Building Docker images inside a Dockerized Jenkins server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker化的Jenkins服务器中构建Docker镜像
- en: Using Docker containers for your Jenkins build nodes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker容器作为您的Jenkins构建节点
- en: Building, testing, and pushing Docker images inside Dockerized build nodes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker化的构建节点中构建、测试和推送Docker镜像
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be pulling Docker images from Docker's public repo, and installing
    the Jenkins server software, so basic internet access is required to execute the
    examples within this chapter. Note also that these examples have higher system
    requirements than those presented in previous chapters. The server used in this
    chapter's examples has 8 GB ram, 2 CPUs, and 20 GB of HDD.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您将从Docker的公共仓库中拉取Docker镜像，并安装Jenkins服务器软件，因此执行本章示例需要基本的互联网访问。还要注意，这些示例的系统要求比前几章中介绍的要高。本章示例中使用的服务器具有8GB的内存、2个CPU和20GB的硬盘。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter08](https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter08)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter08](https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter08)'
- en: 'Check out the following video to see the code in action: [http://bit.ly/2AyRz7k](http://bit.ly/2AyRz7k)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[http://bit.ly/2AyRz7k](http://bit.ly/2AyRz7k)
- en: Using Jenkins to build Docker images
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jenkins构建Docker镜像
- en: You probably already know that Jenkins is a widely-used tool for continuous
    integration/continuous delivery (CI/CD) systems. Virtually every company, both
    large and small, is using it in some capacity. It is extremely effective, and
    highly configurable, especially with the variety of plugins that can be used with
    it. So, it is very natural to expand its use to create Docker images. This first
    step in using Jenkins with Docker is pretty easy to accomplish. If you have an
    existing Jenkins server in use today, all you need to do to use it to build Docker
    images is to install Docker on the Jenkins server. You use the exact same installation
    techniques that we saw and used in Chapter 1, *Setting up a Docker Development
    Environment*. Based on the OS of the system that is running your Jenkins server,
    you follow the install steps you learned in [Chapter 1](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml),
    S*etting up a Docker Development Environment*; when you are done, you can use
    Jenkins to build Docker images.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经知道Jenkins是一个广泛使用的持续集成/持续交付（CI/CD）系统工具。几乎每家公司，无论大小，都在某种程度上使用它。它非常有效，高度可配置，特别是可以与之一起使用的各种插件。因此，将其用于创建Docker镜像是非常自然的。使用Jenkins与Docker的第一步相当容易完成。如果您今天正在使用现有的Jenkins服务器，要使用它来构建Docker镜像，您只需要在Jenkins服务器上安装Docker。您可以使用我们在第1章“设置Docker开发环境”中看到和使用的完全相同的安装技术。根据运行Jenkins服务器的系统的操作系统，您可以按照[第1章](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml)中学到的安装步骤，设置Docker开发环境；完成后，您可以使用Jenkins构建Docker镜像。
- en: 'If you don''t already have a Jenkins server up and running, you can follow
    the guide found in the *Installing Jenkins* web page link in the following *References*
    section and install Jenkins on whatever OS you''re using. As an example, we will
    be using the information from that page to set up a Jenkins server on an Ubuntu
    system. Start by opening a terminal window. Now get the apt-key for Jenkins packages.
    Next, you will add the Debian Jenkins source to the apt sources list. Next, you
    will update the packages on the system, and finally, you will install Jenkins
    using apt-get. The commands look like the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有运行的Jenkins服务器，您可以按照以下“参考”部分中的*安装Jenkins*网页链接中找到的指南进行操作，并在您正在使用的任何操作系统上安装Jenkins。例如，我们将使用该页面的信息在Ubuntu系统上设置Jenkins服务器。首先打开一个终端窗口。现在获取Jenkins软件包的apt-key。接下来，您将向apt源列表中添加Debian
    Jenkins源。然后，您将更新系统上的软件包，最后，您将使用apt-get安装Jenkins。命令看起来像下面这样：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Running these commands on my system looks like the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统上运行这些命令看起来像下面这样：
- en: '![](Images/9ffd1d7c-3383-4e84-acf8-771ca376e97c.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9ffd1d7c-3383-4e84-acf8-771ca376e97c.png)'
- en: 'When the install completes, you will want to open your browser and browse to
    port `8080` on the system to finish the setup and configuration of your Jenkins
    system. This will include entering the admin password and then deciding which
    plugins to install as part of the initial deployment of your Jenkins server. I
    recommend using the set recommended by Jenkins as it is a great starting point:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您将要打开浏览器，并浏览到系统上的端口`8080`，完成Jenkins系统的设置和配置。这将包括输入管理员密码，然后决定在Jenkins服务器的初始部署中安装哪些插件。我建议使用Jenkins建议的设置，因为这是一个很好的起点：
- en: '![](Images/95c474c0-2d10-402b-af99-71ad922f7dd7.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/95c474c0-2d10-402b-af99-71ad922f7dd7.png)'
- en: 'Now that you have a Jenkins server, you can begin creating jobs for it to execute
    to confirm that it is working as desired. Let''s start out with a trivial Hello
    world! job to confirm that Jenkins is working. Log into your Jenkins server and
    click on the New Item link. In the new item page, enter the name for our job.
    I''m using `hello-test`. Select the type of job that we want to create as pipeline.
    Next, click the OK button near the bottom left of the page. This will take you
    to the configuration screen for our new job. This one is going to be very simple.
    We are going to create a pipeline script, so scroll down until you see the Pipeline
    script input box, and enter the following script (note that the pipeline script
    is written in groovy, which uses the Java (and C) form of comments):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你有了一个Jenkins服务器，你可以开始创建工作来执行确认它是否按预期工作。让我们从一个微不足道的Hello world!工作开始，以确认Jenkins正在工作。登录到你的Jenkins服务器，点击“新建项目”链接。在新项目页面中，输入我们的工作名称。我使用`hello-test`。选择我们要创建的工作类型为pipeline。接下来，点击页面左下角附近的“确定”按钮。这将带你到我们新工作的配置屏幕。这个将会非常简单。我们将创建一个pipeline脚本，所以向下滚动直到看到Pipeline脚本输入框，并输入以下脚本（注意pipeline脚本是用groovy编写的，它使用Java（和C）形式的注释）：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That''s all for now, so click on the Save button to save the updated configuration
    of our Jenkins job. Once the configuration has been saved, let''s test the job
    by clicking on the Build now link. If everything is functioning as expected, we
    should see the job complete successfully. It will look something like the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就这样吧，点击“保存”按钮保存我们Jenkins工作的更新配置。一旦配置保存了，让我们通过点击“立即构建”链接来测试工作。如果一切都按预期运行，我们应该看到工作成功完成。它会看起来像下面这样：
- en: '![](Images/076b8ce5-1c78-4a28-9822-c898bf0ef082.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/076b8ce5-1c78-4a28-9822-c898bf0ef082.png)'
- en: 'Now let''s create another job. Click the link to go back to the dashboard and
    then click the New Item link again. This time, let''s name the job `hello-docker-test`.
    Again, select the pipeline for the type of job you want to create and then click
    the OK button. Again, scroll down to the Pipeline script input and enter the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建另一个工作。点击链接返回仪表板，然后再次点击“新建项目”链接。这次，让我们把工作命名为`hello-docker-test`。同样，选择pipeline作为你想要创建的工作类型，然后点击“确定”按钮。再次向下滚动到Pipeline脚本输入框，并输入以下内容：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Click on the Save button to save the configuration for the new job, and then
    click the Build Now link to launch the Jenkins job. The following is what it might
    look like this time:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“保存”按钮保存新工作的配置，然后点击“立即构建”链接启动Jenkins工作。以下是这次可能看起来的样子：
- en: '![](Images/140e4cd5-a668-4c00-928e-d2f9dd279357.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/140e4cd5-a668-4c00-928e-d2f9dd279357.png)'
- en: 'What happened this time? This one didn''t complete successfully. Well, obviously
    it failed because we don''t have Docker installed on our Jenkins server yet. So
    let''s go ahead and follow the instructions found in Chapter 1, S*etting up a
    Docker Development Environment*, for installing Docker, and install it on our
    Jenkins server. Once you have it installed, there is one additional step you will
    want to do, which is to add the Jenkins user to the Docker group. The following
    is the command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这次发生了什么？这次没有成功完成。显然失败了，因为我们的Jenkins服务器上还没有安装Docker。所以让我们继续按照第1章“设置Docker开发环境”中找到的指令，安装Docker，并将其安装在我们的Jenkins服务器上。一旦安装好了，还有一个额外的步骤你会想要做，那就是将Jenkins用户添加到Docker组中。命令如下：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is very much like the command we used to add the current user of our Docker
    server to the docker group so that it was unnecessary to use `sudo` for Docker
    commands. OK, now let's go back to our Jenkins server UI and to our `hello-docker-test`
    job and click the Build now button again.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们用来将我们的Docker服务器的当前用户添加到docker组的命令非常相似，因此在Docker命令中不需要使用`sudo`。好的，现在让我们回到我们的Jenkins服务器UI和我们的`hello-docker-test`作业，再次点击“立即构建”按钮。
- en: '![](Images/6ab728c9-55d5-4d7f-a12e-43f03623c137.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6ab728c9-55d5-4d7f-a12e-43f03623c137.png)'
- en: Congratulations! You have a shiny, new Jenkins server, properly configured to
    build (test, push, and deploy) Docker images. Well done. Still, while this is
    a great accomplishment, it was kind of a lot of work. Don't you wish there was
    an easier way to set up a new Jenkins server? So, you know how you already have
    a nice set of servers running Docker? Do you think you can use that environment
    to stand up your Jenkins server in an easier way? You betcha! Let's take a look.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您有一个全新的Jenkins服务器，已正确配置为构建（测试、推送和部署）Docker映像。干得好。尽管这是一个伟大的成就，但工作量还是有点大。您难道不希望有更简单的方法来设置新的Jenkins服务器吗？所以，您知道您已经有一组运行Docker的服务器？您认为您可以使用该环境以更简单的方式建立起您的Jenkins服务器吗？当然可以！让我们来看看。
- en: References
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: The following is the web page to install Jenkins: [https://jenkins.io/doc/book/installing/](https://jenkins.io/doc/book/installing/).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是安装Jenkins的网页：[https://jenkins.io/doc/book/installing/](https://jenkins.io/doc/book/installing/)。
- en: Setting up a Dockerized Jenkins server
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Docker化的Jenkins服务器
- en: 'You have just seen how much work it is to set up a new Jenkins server. While
    it is not a Herculean effort, there are at least five steps you have to do before
    you can pick your plugins and log in to get to work. And in the spirit of the
    game show *Name That Tune*, I can deploy a Jenkins server in three steps, and
    the first two are just to allow our Jenkins data to persist beyond the life of
    the Docker container that hosts the Jenkins server. Assuming you have a Docker
    host set up-and-running as per the instructions in Chapter 1, S*etting up a Docker
    Development Environment*, we want to create a location for the Jenkins server
    to store its data. We will create a folder and assign ownership to it. It will
    look like the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚看到了设置新的Jenkins服务器有多少工作。虽然这并不是一个艰巨的工作，但至少有五个步骤您必须完成，然后才能选择您的插件并登录开始工作。并且在游戏节目*猜猜这首歌*的精神下，我可以在三个步骤内部署一个Jenkins服务器，前两个步骤只是为了让我们的Jenkins数据在托管Jenkins服务器的Docker容器的生命周期之外持久存在。假设您已经按照第1章“设置Docker开发环境”的说明设置并运行了Docker主机，我们希望创建一个位置，让Jenkins服务器存储其数据。我们将创建一个文件夹并分配所有权。它将如下所示：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The owner `1000` is the user ID that will be used for the jenkins user inside
    the Docker container.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有者`1000`是将在Docker容器内用于jenkins用户的用户ID。
- en: 'The third step is to deploy our container. Before I show you the command, let
    me talk a little about which container image to use. I am including a link for
    searching on the Docker hub for Jenkins images. If you use that link or search
    on your own, you will see that there are a lot of options to choose from. Initially,
    you might think about using the official Jenkins image. However, if you browse
    to that repo, you will find what I feel is kind of odd, which is that the official
    image is deprecated. It has stopped being updated past version LTS 2.60.x:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是部署我们的容器。在我向您展示命令之前，让我稍微谈一下要使用哪个容器映像。我包含了一个链接，可以在Docker hub上搜索Jenkins映像。如果您使用该链接或自行搜索，您会发现有很多选择。最初，您可能会考虑使用官方的Jenkins映像。然而，如果您浏览该存储库，您会发现我觉得有点奇怪的是，官方映像已经被弃用。它已经停止更新到LTS
    2.60.x版本：
- en: '![](Images/69a04bfa-7556-4017-9b3a-dad4edb474a7.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/69a04bfa-7556-4017-9b3a-dad4edb474a7.png)'
- en: 'It recommends using the image found in the jenkins/jenkins:lts Jenkins repo,
    which at the time of writing is version 2.149.x. This is the image we will use
    in the following example. The following is the command we are going to use to
    deploy our Jenkins server container:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它建议使用在jenkins/jenkins:lts Jenkins镜像库中找到的镜像，目前的版本是2.149.x。这是我们将在下面的示例中使用的镜像。以下是我们将使用的命令来部署我们的Jenkins服务器容器：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Taking a closer look at this command, we see that we are launching the container
    as a daemon (non-interactively). We see that we are opening two ports on the host,
    which are mapped to the same port numbers on the container, specifically `8080`
    and `50000`. Next, we see that we are using a volume, and it is mapping to the
    folder we created earlier. This is where Jenkins will store its data, such as
    the jobs we create and the status of their execution. Then you will notice we
    are nameing the container `jenkins`. After that, we tell Docker to remove the
    container when it exits using the `--rm` flag. Finally, we tell Docker what image
    we want to run.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看这个命令，我们可以看到我们正在将容器作为守护进程（非交互式）启动。我们看到我们在主机上打开了两个端口，它们映射到容器上的相同端口号，具体是`8080`和`50000`。接下来，我们看到我们正在使用一个卷，并且它映射到我们之前创建的文件夹。这是Jenkins将存储其数据的地方，比如我们创建的作业和它们执行的状态。然后您会注意到我们给容器命名为`jenkins`。之后，我们告诉Docker在退出时删除容器，使用`--rm`标志。最后，我们告诉Docker我们要运行哪个镜像。
- en: When you run this container, giving it a minute or two to start up and browse
    to port `8080` on the Docker host, you will see the same prompt for a password
    that you see when you deploy Jenkins as a standalone application. That will be
    followed by the create-the-first-user screen and the default-plugin-configuration
    screen. Go ahead and give it a try.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此容器时，请给它一两分钟来启动，并浏览到Docker主机上的端口`8080`，您将看到与在部署Jenkins作为独立应用程序时看到的密码提示相同。然后会出现创建第一个用户的屏幕和默认插件配置屏幕。试试看吧。
- en: Since we have created a volume for the Jenkins data (written to `/var/jenkins_home`),
    our Jenkins configuration data is being saved to the host and will live beyond
    the life of the container itself. Of course, you can use a storage driver and
    have this data somewhere more permanent than the Docker host, but you get the
    idea, right?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为Jenkins数据创建了一个卷（写入`/var/jenkins_home`），我们的Jenkins配置数据被保存到主机上，并且将超出容器本身的生命周期。当然，您可以使用存储驱动程序，并将这些数据保存在比Docker主机更持久的地方，但您明白我的意思，对吧？
- en: The only problem is that neither the official Jenkins image nor the `jenkins/jenkins`
    image supports creating jobs that will build a Docker image. And since this book
    is all about Docker, we need to do something more than just run our Jenkins server
    using the aforementioned images. Don't worry, I have a plan for that… Keep reading.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是，官方的Jenkins镜像和`jenkins/jenkins`镜像都不支持创建将构建Docker镜像的作业。而且由于本书都是关于Docker的，我们需要做的不仅仅是使用上述镜像运行我们的Jenkins服务器。别担心，我有个计划……继续阅读。
- en: References
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: Docker hub search for Jenkins images: [https://hub.docker.com/search/?isAutomated=0&isOfficial=0&page=1&pullCount=0&q=jenkins&starCount=0](https://hub.docker.com/search/?isAutomated=0&isOfficial=0&page=1&pullCount=0&q=jenkins&starCount=0)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker hub搜索Jenkins镜像：[https://hub.docker.com/search/?isAutomated=0&isOfficial=0&page=1&pullCount=0&q=jenkins&starCount=0](https://hub.docker.com/search/?isAutomated=0&isOfficial=0&page=1&pullCount=0&q=jenkins&starCount=0)
- en: Official Jenkins image repo: [https://hub.docker.com/_/jenkins/](https://hub.docker.com/_/jenkins/)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方的Jenkins镜像库：[https://hub.docker.com/_/jenkins/](https://hub.docker.com/_/jenkins/)
- en: Jenkins/jenkins repo: [https://hub.docker.com/r/jenkins/jenkins/](https://hub.docker.com/r/jenkins/jenkins/)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins/jenkins镜像库：[https://hub.docker.com/r/jenkins/jenkins/](https://hub.docker.com/r/jenkins/jenkins/)
- en: Building Docker images inside of a Dockerized Jenkins server
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker化的Jenkins服务器内构建Docker镜像
- en: Alright. Now you know how to deploy Jenkins as a Docker container, but we really
    want to be able to use Jenkins to build Docker images, as we did in the standalone
    deployment of Jenkins. To do that, we could deploy the same Jenkins image, and
    exec into it and install Docker and could probably get it to work, but we don't
    need to go to that much trouble. We're not the first pioneers to go down this
    road. There are several Docker images that have been created to do just what we
    are looking to do. One such image is `h1kkan/jenkins-docker:lts`. You can read
    about it by following the link in the following *References* section, but for
    now just know that it is an image that has been set up as a Jenkins server, and
    has Docker already installed in it. In fact, it also has Ansible and the AWSCLI
    pre-installed so you can do more than just build Docker images using it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 好了。现在你知道如何将Jenkins部署为Docker容器，但我们真的希望能够使用Jenkins来构建Docker镜像，就像我们在独立部署Jenkins时所做的那样。为了做到这一点，我们可以部署相同的Jenkins镜像，并在其中安装Docker，可能可以让它工作，但我们不需要那么麻烦。我们不是第一个走上这条路的先驱。已经创建了几个Docker镜像，可以做我们想做的事情。其中一个镜像是`h1kkan/jenkins-docker:lts`。您可以通过以下*参考*部分中的链接阅读有关它的信息，但现在只需知道它是一个已设置为Jenkins服务器的镜像，并且其中已经安装了Docker。实际上，它还预先安装了Ansible和AWSCLI，因此您可以使用它来构建Docker镜像以外的其他操作。
- en: 'To begin, we will create a location on the Docker host to mount a Docker volume
    to store and preserve the Jenkins configuration. If you are using the same Docker
    host as you used in the previous section, you should already have created your
    folder and assigned ownership of it to ID `1000`. If not, the following are the
    commands you use to do so:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在Docker主机上创建一个位置，以挂载Docker卷来存储和保留Jenkins配置。如果您正在使用与上一节相同的Docker主机，您应该已经创建了文件夹并将其分配给ID“1000”。如果没有，以下是您可以使用的命令：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also, if you haven''t done so already, you can use the `docker container stop
    jenkins` command to stop (and remove) the Jenkins container that we created in
    the previous section to clear the way for our new and improved Jenkins server.
    When you are ready to create the new container, you can use these commands:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果您还没有这样做，您可以使用`docker container stop jenkins`命令来停止（并删除）我们在上一节中创建的Jenkins容器，以为我们的新的、改进的Jenkins服务器腾出空间。当您准备创建新的容器时，您可以使用以下命令：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You will have noticed a couple of differences in this code block. The first
    is the use of a second volume. This is a well-known trick, of sorts, that allows
    a container to issue Docker commands to its host. This essentially allows what
    is known as Docker-in-Docker. The next difference is an extra Docker command that
    will start the Docker service inside the running container. Because each container
    starts up with a single process, having both a Jenkins server process and a Docker
    daemon running requires this extra step.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到了这个代码块中的一些不同之处。第一个是使用了第二个卷。这是一种众所周知的技巧，允许容器向其主机发出Docker命令。这本质上允许了所谓的Docker-in-Docker。下一个不同之处是额外的Docker命令，它将在运行的容器内启动Docker服务。因为每个容器都会启动一个单一进程，所以同时运行Jenkins服务器进程和Docker守护程序需要这一额外步骤。
- en: Once the Docker service has started within the Jenkins container, you are all
    set to create new Jenkins jobs that use and build Docker images. You can test
    it out yourself by recreating the second example above, `hello-docker-test`, in
    your new Jenkins server. And since we are using the Docker volume mounted on the
    host at `$HOME/jenkins_home` to store our Jenkins data, this should be the last
    time you need to create this job.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在Jenkins容器内启动了Docker服务，您就可以创建使用和构建Docker镜像的新Jenkins作业。您可以通过在新的Jenkins服务器中重新创建上面的第二个示例`hello-docker-test`来自行测试。由于我们使用的是挂载在主机上的Docker卷`$HOME/jenkins_home`来存储我们的Jenkins数据，这应该是您需要创建此作业的最后一次。
- en: This is all working wonderfully, but you may recall from Chapter 7, *Docker
    Stacks*, that we have a better way to deploy apps than by using the `docker container
    run` command, namely using Docker stacks. So would you like to see our example
    re-imagined as a Docker stack? Me too! OK then, let's do it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都运作得很好，但您可能还记得第7章*Docker Stacks*中我们有一个比使用`docker container run`命令更好的部署应用程序的方法，即使用Docker堆栈。那么，您想看到我们的示例重新构想为Docker堆栈吗？我也是！好的，那么，让我们来做吧。
- en: 'First off, use the container stop command to stop your current Jenkins container.
    It will leave behind the `jenkins_home` folder with our Jenkins server''s data,
    but if for some reason you skipped ahead to this part of the chapter and haven''t
    created that yet, the following are the commands to use:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用容器停止命令停止当前的Jenkins容器。它将保留我们的Jenkins服务器数据的`jenkins_home`文件夹，但如果由于某种原因您跳到本章的这一部分并且还没有创建它，以下是要使用的命令：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Again, if you did those two commands for one of the previous examples, and you
    are using the same Docker host, you don't have to do that again because the folder
    already exists and has the right ownership.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果您对先前的示例中的这两个命令进行了操作，并且您正在使用相同的Docker主机，您就不必再次执行这些操作，因为该文件夹已经存在并且具有正确的所有权。
- en: 'Next, you need to create a compose file for our Jenkins stack. I called mine
    `jenkins-stack.yml` and entered the following YML code into it:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要为我们的Jenkins堆栈创建一个compose文件。我把我的命名为`jenkins-stack.yml`，并输入以下YML代码：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You will notice that we are creating two services; one is our Jenkins server,
    and the other is a Docker registry. We will use the registry service in an upcoming
    example, so keep that in your back pocket for now. Looking at the Jenkins service
    description, there is nothing we did not see already in Chapter 7, *Docker Stacks*,
    when we learned about Docker stacks. You will notice our two port mappings and
    the two volumes that were used in the last example. We are confining the single
    Jenkins replica to our manager node.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您将注意到我们正在创建两个服务；一个是我们的Jenkins服务器，另一个是Docker注册表。我们将在即将到来的示例中使用注册表服务，所以现在把它放在心里。查看Jenkins服务描述时，我们没有看到在第7章*Docker
    Stacks*中学到的任何内容。您将注意到我们的两个端口映射和上一个示例中使用的两个卷。我们将把单个Jenkins副本限制在我们的管理节点上。
- en: Remember that to use Docker stacks we have to be running in swarm mode, so if
    you have not done so already, create your swarm with the `docker swarm init` command
    that we learned in Chapter 5,  *Docker Swarm*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，要使用Docker堆栈，我们必须在集群模式下运行，因此，如果您还没有这样做，请使用我们在第5章学到的`docker swarm init`命令创建您的集群，*Docker
    Swarm*。
- en: Understand that if your swarm has more than one manager node, you will need
    to further confine the Jenkins replica to just the single manager that has your
    `jenkins_home` volume mount point. This can be accomplished with a combination
    of roles and labels. Alternatively, you can use a storage driver and mount a volume
    that can be shared among swarm managers. For simplicity, we are assuming a single
    manager node for our example.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您的集群有多个管理节点，您需要进一步将Jenkins副本限制在只有您的`jenkins_home`卷挂载点的单个管理节点上。这可以通过角色和标签的组合来实现。或者，您可以使用存储驱动程序并挂载一个可以在集群管理节点之间共享的卷。为了简单起见，我们假设我们的示例中有一个单独的管理节点。
- en: 'Now use the stack deploy command to set up the Jenkins application. The following
    is an example of the command to use:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用堆栈部署命令来设置Jenkins应用程序。以下是要使用的命令的示例：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once the stack is deployed and the services up and running, you can browse to
    any node in your swarm, on port 8080, and get to your Jenkins server. What's more,
    if you are reusing the `jenkins_home` folder from our previous example, you will
    not have to supply the admin password, create a new user, and select your plugins
    because all of the data related to those tasks was stored in the `jenkins_home`
    folder and is reused now by your stack-based Jenkins service. One more interesting
    note is that you do not have to start the Docker service when you use this image
    in a stack application. Bonus!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦堆栈部署并且服务正在运行，您可以浏览到您集群中的任何节点，端口为8080，并访问您的Jenkins服务器。更重要的是，如果您正在重用我们之前示例中的`jenkins_home`文件夹，您将不必提供管理员密码，创建新用户和选择插件，因为所有与这些任务相关的数据都存储在`jenkins_home`文件夹中，并且现在由基于堆栈的Jenkins服务重用。另一个有趣的事实是，当您在堆栈应用程序中使用此镜像时，您无需启动Docker服务。奖励！
- en: 'OK, we now have a sweet stack-based Jenkins service that is capable of using
    and building Docker images. Everything seems right with the World. But there is
    one thing that could make this better. And by better, I mean more Docker-y: instead
    of using the normal Jenkins agents for our build jobs, what if we wanted to spin
    up a new, pristine Docker container to use for each execution of our Jenkins jobs?
    This would ensure that every build was built from scratch in a clean, consistent
    environment. Plus, it really takes the Docker inception level up a notch, so I
    like it a lot. If you want to see how it''s done, keep reading.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们有一个甜蜜的基于堆栈的Jenkins服务，可以使用和构建Docker镜像。一切看起来都很好。但有一件事可以让这更好。通过更好，我指的是更加Docker化：而不是使用普通的Jenkins代理进行我们的构建作业，如果我们想要为每次执行Jenkins作业都启动一个新的原始Docker容器呢？这将确保每个构建都是在一个干净、一致的环境中从头构建的。此外，这真的可以提升Docker的内在水平，所以我非常喜欢。如果您想看看如何做到这一点，请继续阅读。
- en: References
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: H1kkan/jenkins-docker repo: [https://hub.docker.com/r/h1kkan/jenkins-docker/](https://hub.docker.com/r/h1kkan/jenkins-docker/)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: H1kkan/jenkins-docker仓库：[https://hub.docker.com/r/h1kkan/jenkins-docker/](https://hub.docker.com/r/h1kkan/jenkins-docker/)
- en: Using Docker containers for your Jenkins build nodes
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker容器作为Jenkins构建节点
- en: 'To use Docker containers for the Jenkins build agents, you need to do a few
    things to your Jenkins configuration:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Docker容器用于Jenkins构建代理，您需要对Jenkins配置进行一些操作：
- en: Build a new Docker image that can act as a Jenkins build agent, and is capable
    of building Docker images (of course)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个新的Docker镜像，可以作为Jenkins构建代理，并能够构建Docker镜像（当然）
- en: Push the new image to a Docker registry
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新镜像推送到Docker注册表
- en: Turn off the default Jenkins build agents
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭默认的Jenkins构建代理
- en: Install the Docker plugin for Jenkins
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Jenkins的Docker插件
- en: Configure a new cloud to enable Dockerized build agents
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置一个新的云以启用Docker化的构建代理
- en: Building the Docker image
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Docker镜像
- en: 'Let''s get started. The first thing we want to do is build our specialized
    Docker image that can be used for our Jenkins agents. To do this, we are going
    to use the skills we learned in Chapter 3, *Creating Docker Images*, to create
    Docker images. Start by creating a new folder on your development system, and
    then change your working directory to that folder. I named mine `jenkins-agent`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。我们要做的第一件事是构建我们专门的Docker镜像，用于我们的Jenkins代理。为此，我们将使用第3章“创建Docker镜像”中学到的技能来创建Docker镜像。首先在您的开发系统上创建一个新文件夹，然后将工作目录更改为该文件夹。我把我的命名为`jenkins-agent`：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now create a new file, named `Dockerfile`, using your favorite editor, enter
    the following code into it, and then save it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个新文件，命名为`Dockerfile`，使用您喜欢的编辑器，输入以下代码，然后保存：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is what our new Dockerfile is doing: in our `FROM` instruction, we are
    using the same Docker image that we used in our Docker-in-Docker example above
    so that we have a base image that will allow us to build Docker images. Next,
    we use the `USER` command to set the current user to root. Next, we create an
    `ARG` named user and set it to a value of `jenkins`. After that, we set an environment
    variable named `HOME` that has a value for the Jenkins user''s home folder. Then,
    we set two more `ARGs`, one for the version and one for the Jenkins agent''s working
    directory. The next one is where the magic happens. We are using a `RUN` command
    to set up and curl the Jenkins `slave.jar` file. This is the bit that is required
    to run as a Jenkins agent. We also set some permissions on the folder and file,
    and then clean up a bit by deleting curl. After that, we set another environment
    variable, this one for `AGENT_WORKDIR`. Next up, we create a couple of folders
    in the container. Then, we use the `USER` instruction again, this time setting
    the current user to our Jenkins user. We round out the Dockerfile by creating
    a couple of `VOLUME` instances and, finally, we set the current working directory
    to the home directory for our Jenkins user. Phew! That seems like a lot, but really
    it''s not so bad, and all you have to do copy and paste the preceding code into
    your Dockerfile and save it.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新Dockerfile正在做什么：在我们的`FROM`指令中，我们使用了与上面的Docker-in-Docker示例中相同的Docker镜像，以便我们有一个基础镜像，可以让我们构建Docker镜像。接下来，我们使用`USER`命令将当前用户设置为root。然后，我们创建一个名为用户的`ARG`并将其设置为`jenkins`的值。之后，我们设置了一个名为`HOME`的环境变量，该变量具有Jenkins用户的主目录的值。然后，我们设置了另外两个`ARGs`，一个用于版本，一个用于Jenkins代理的工作目录。接下来是魔术发生的地方。我们使用`RUN`命令来设置并获取Jenkins的`slave.jar`文件。这是作为Jenkins代理所需的部分。我们还在文件夹和文件上设置了一些权限，然后通过删除curl来进行一些清理。之后，我们设置了另一个环境变量，这个环境变量是`AGENT_WORKDIR`。接下来，我们在容器中创建了一些文件夹。然后，我们再次使用`USER`指令，这次将当前用户设置为我们的Jenkins用户。最后，我们通过创建一些`VOLUME`实例来完成Dockerfile，并将当前工作目录设置为我们的Jenkins用户的主目录。哦！这似乎很多，但实际上并不那么糟糕，您只需将上述代码复制粘贴到您的Dockerfile中并保存即可。
- en: 'Now that we have our Dockerfile ready to use, it might be a good time to create
    a git repo and save your code to it. Once you are satisfied that your project
    has been properly set up with git, we can build our new Docker image. The following
    is the command you will use for that:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的Dockerfile准备好使用了，现在是创建一个git仓库并将代码保存到其中的好时机。一旦您确认您的项目已经正确地使用git设置好，我们就可以构建我们的新Docker镜像。以下是您将用于此目的的命令：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It should build successfully and create a locally-cached image tagged as `jenkins-agent:latest`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该成功构建并创建一个本地缓存的镜像，标记为`jenkins-agent:latest`。
- en: Pushing the new image to a Docker registry
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将新镜像推送到Docker注册表。
- en: 'Next, we need to push our new image to a Docker registry. Of course, we could
    push it to our repo within hub.docker.com, but since we have an application stack
    that just so happens to have deployed a Docker registry, why don''t we utilize
    it for our Jenkins agent image? First, we need to tag our new image with the registry.
    Your tag command will differ from mine based on the domain name of your Docker
    swarm, but for my example, the following is what my tag command looks like:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将我们的新镜像推送到Docker注册表。当然，我们可以将其推送到hub.docker.com中的我们的仓库，但由于我们恰好部署了一个Docker注册表的应用程序堆栈，为什么不利用它来存储我们的Jenkins代理镜像呢？首先，我们需要使用注册表为我们的新镜像打标签。基于您的Docker
    Swarm的域名，您的标签命令将与我的不同，但对于我的示例，以下是我的标签命令的样子：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that the image is tagged locally, we can push it to the registry with the
    following command; again, your command will be different based on the domain name
    of your swarm:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在镜像已经在本地标记，我们可以使用以下命令将其推送到注册表；同样，基于您的Swarm的域名，您的命令将有所不同：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All of these commands might utilize a better version scheme than the oversimplified
    use of the `latest` tag, but you should be able to address that on your own. With
    our image built, tagged, and pushed to the Docker registry, we are ready to update
    our Jenkins configuration to use it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些命令可能会使用比`latest`标签更好的版本方案，但您应该能够自行解决这个问题。随着我们的镜像构建、标记和推送到Docker注册表，我们准备好更新Jenkins配置以使用它。
- en: Turning off the default Jenkins build agents
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭默认的Jenkins构建代理
- en: 'Now we are ready to update our Jenkins configuration to support our Dockerized
    build agents. The first configuration change we are going to make is to turn off
    the default build agents. To do this, log into your Jenkins server, and click
    the Manage Jenkins menu link. This will take you to a variety of configuration
    groups you can manage, such as system, plugins, and CLI settings. For now, we
    will need to go to the Configure System management group:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备更新Jenkins配置以支持我们的Docker化构建代理。我们要做的第一个配置更改是关闭默认的构建代理。要做到这一点，登录到您的Jenkins服务器，然后单击“管理Jenkins”菜单链接。这将带您进入各种配置组，例如系统、插件和CLI设置。现在，我们需要进入“配置系统”管理组：
- en: '![](Images/ca007e0f-82ae-4c3e-a93a-cd1c22f5d9d4.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ca007e0f-82ae-4c3e-a93a-cd1c22f5d9d4.png)'
- en: 'Once you are in the Configure System management group, you are going to change
    the value for # of executors to `0`. It should look something like the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您进入“配置系统”管理组，您将更改“执行器数量”的值为`0`。它应该看起来像下面这样：
- en: '![](Images/930fbb65-4fa9-4fd7-b80e-7166516f870c.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/930fbb65-4fa9-4fd7-b80e-7166516f870c.png)'
- en: 'When you have changed the # of executors value to `0`, you can go ahead and
    save the settings by clicking the Save button in the lower-left part of the screen.
    At this point, with this change in place, your Jenkins server will not be able
    to run any jobs because there are no Jenkins agents configured to run them. So
    let''s move on quickly to the next step, which is to install the Docker plugin.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将“执行器数量”更改为`0`后，您可以点击屏幕左下角的保存按钮保存设置。在这一点上，由于没有配置Jenkins代理来运行作业，您的Jenkins服务器将无法运行任何作业。因此，让我们快速进行下一步，即安装Docker插件。
- en: Installing the Docker plugin for Jenkins
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Jenkins的Docker插件
- en: 'Now we need to install the Docker plugin for Jenkins. You accomplish this as
    you would other plugin installations. Click on the Manage Jenkins menu link, and
    from the list of configuration groups, click the link for the Manage Plugins group:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为Jenkins安装Docker插件。您可以像安装其他插件一样完成此操作。单击“管理Jenkins”菜单链接，然后从配置组列表中，单击“管理插件”组的链接：
- en: '![](Images/b844e146-e6c0-45f3-9795-d35802f31383.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b844e146-e6c0-45f3-9795-d35802f31383.png)'
- en: 'Once you are in the Manage Plugins configuration group, select the tab for
    Available plugins, and then in the filter box, type `docker` to narrow down the
    list of available plugins to those related to Docker:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您进入“管理插件”配置组，选择“可用插件”选项卡，然后在筛选框中输入`docker`以缩小可用插件的列表，以便找到与Docker相关的插件：
- en: '![](Images/8ac3ae3c-383f-4ec3-8cfe-de0d89fe93f2.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8ac3ae3c-383f-4ec3-8cfe-de0d89fe93f2.png)'
- en: 'Even with a filtered list, there are still a lot of plugins to choose from.
    Find and check the box for the Docker plugin. It looks like the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有一个经过筛选的列表，仍然有很多插件可供选择。找到并勾选Docker插件。它看起来像下面这样：
- en: '![](Images/a78b0276-360d-4e6c-aaeb-686e4b69ef4e.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a78b0276-360d-4e6c-aaeb-686e4b69ef4e.png)'
- en: 'With the Docker plugin checkbox checked, scroll down and click the Install
    without restart button. This will download and install the plugin for you, and
    then enable it as soon as Jenkins restarts. On the install screen, you have the
    option to execute a restart as soon as the plugin is installed. To do this, check
    the Restart Jenkins when installation is complete and no jobs are running checkbox:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 勾选Docker插件复选框，向下滚动并单击“无需重新启动安装”按钮。这将为您下载并安装插件，然后在Jenkins重新启动时启用它。在安装屏幕上，您可以选择在插件安装完成后立即执行重新启动的选项。要执行此操作，请勾选“安装完成后重新启动Jenkins并且没有作业正在运行”复选框：
- en: '![](Images/df355ed4-fc95-4e7d-90f8-7ad906a74f02.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/df355ed4-fc95-4e7d-90f8-7ad906a74f02.png)'
- en: 'Since we set the # of executors to `0` a few minutes ago, there will not be
    any jobs running now, so as soon as the plugin is installed, Jenkins will restart.
    As soon as Jenkins comes back online, the plugin will be installed. We need to
    log back in to Jenkins and set up our Cloud.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们几分钟前将执行器数量设置为`0`，现在不会有任何作业正在运行，因此一旦安装插件，Jenkins将重新启动。Jenkins一旦恢复在线，插件将被安装。我们需要重新登录Jenkins并设置我们的云。
- en: Creating a new Cloud to enable our Dockerized build agents
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的云，以启用我们的Docker化构建代理
- en: 'Now we will tell Jenkins to use our custom Docker image to run containers as
    Jenkins build agents. Once more, click on the Manage Jenkins menu link. From the
    list of configuration groups, you will again click the link for the Configure
    System group. You will find the Cloud configuration near the bottom of the configuration
    options. Click on the Add a new cloud dropdown and select `Docker`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将告诉Jenkins使用我们的自定义Docker镜像来作为Jenkins构建代理运行容器。再次，单击“管理Jenkins”菜单链接。从配置组列表中，您将再次单击“配置系统”组的链接。您将在配置选项的底部附近找到云配置。单击“添加新云”下拉菜单，并选择`Docker`：
- en: '![](Images/85ccfde1-560f-4fcd-8957-d8bb1409904d.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/85ccfde1-560f-4fcd-8957-d8bb1409904d.png)'
- en: 'The screen will update and you will have two new configuration groups: Docker
    Cloud details... and Docker Agent templates...:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕将更新，您将看到两个新的配置组：Docker Cloud详细信息...和Docker代理模板...：
- en: '![](Images/bd8072d5-822e-4414-9048-d83ba0de2a74.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bd8072d5-822e-4414-9048-d83ba0de2a74.png)'
- en: 'Let''s take care of the Docker Cloud details first. Click on that button now.
    You can leave the Name value as the default for `docker`. In the Docker Host URI
    field, enter `unix:///var/run/docker.sock`. You can find this value by clicking
    the question mark help icon and copying and pasting it into the input field. Next,
    click the Test Connection button and you should see a version line show up, similar
    to the one you will see in the following screenshot. Make note of the API Version
    number as you will need it for the Advanced... setup. Click the Advanced... button
    and enter the API Version number in the Docker API Version field. You need to
    check the Enabled checkbox to enable this feature, so be sure to do so. Finally,
    you may want to change the number of containers that the system can run concurrently.
    The default is 100\. For my example, I reduced the value to `10`. When you are
    done, your configuration should look something like the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先处理Docker Cloud的细节。现在点击该按钮。您可以将名称值保留为`docker`的默认值。在Docker主机URI字段中，输入`unix:///var/run/docker.sock`。您可以通过单击问号帮助图标并将其复制粘贴到输入字段中来找到此值。接下来，单击“测试连接”按钮，您应该会看到一个版本行显示出来，类似于您将在以下屏幕截图中看到的内容。记下API版本号，因为您将需要它进行高级设置。单击“高级”按钮，并在Docker
    API版本字段中输入API版本号。您需要勾选“已启用”复选框以启用此功能，所以一定要这样做。最后，您可能需要更改系统可以同时运行的容器数量。默认值为100。例如，我将该值减少到`10`。完成后，您的配置应该看起来类似于以下内容：
- en: '![](Images/f2e0d7ea-7952-4496-a6d5-fd3a9cf456a7.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f2e0d7ea-7952-4496-a6d5-fd3a9cf456a7.png)'
- en: 'Next, click the Docker Agent templates... button and then click the Add Docker
    template button that appears so that we can to configure the Jenkins agent settings.
    Here, you will want to click the agent''s Enabled checkbox to enable our new agent
    template. You can give a name to use as the prefix for the containers that are
    run by Jenkins as the build agents, or you can leave the name blank and the `docker`
    prefix will be used. Next, enter the repository and the name tag for the image
    you want to use for the build agent containers. We created our custom image, tagged
    it, and pushed it to our Jenkins stack application repo using the `ubuntu-node01:5000/jenkins-agent:latest`
    image name, so enter that value into the Docker Image field. Set the Instance
    Capacity value to `1`, and the Remote File System Root value to `/home/jenkins/agent`.
    Make sure the Usage value is set to `Use this node as much as possible`, and use
    the `Attach Docker container` value for the Connect method. Set the User to `root`.
    Change the Pull strategy value to `Pull once and update latest`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击Docker代理模板...按钮，然后点击出现的添加Docker模板按钮，以便配置Jenkins代理设置。在这里，您将要点击代理的已启用复选框，以启用我们的新代理模板。您可以给一个名称，用作由Jenkins作为构建代理运行的容器的前缀，或者您可以将名称留空，将使用`docker`前缀。接下来，输入您要用于构建代理容器的镜像的存储库和名称标签。我们创建了我们的自定义镜像，标记了它，并将其推送到我们的Jenkins堆栈应用程序存储库，使用`ubuntu-node01:5000/jenkins-agent:latest`镜像名称，因此将该值输入到Docker镜像字段中。将实例容量值设置为`1`，将远程文件系统根值设置为`/home/jenkins/agent`。确保使用值设置为`尽可能多地使用此节点`，并使用`连接方法`的`附加Docker容器`值。将用户设置为`root`。将拉取策略值更改为`拉取一次并更新最新`：
- en: '![](Images/79d3e2f7-bed3-4876-8839-acd362836905.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/79d3e2f7-bed3-4876-8839-acd362836905.png)'
- en: 'Finally, we need to configure some Container settings..., so click to expand
    that section. The value we need to enter here is the command we want to use when
    the container is run. The value you need in the Docker Command field is `java
    -jar /usr/share/jenkins/slave.jar`. The value you need in the Volumes field is
    `/var/run/docker.sock:/var/run/docker.sock`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要配置一些容器设置..., 所以点击展开该部分。我们需要在这里输入的值是容器运行时要使用的命令。Docker命令字段中需要的值是 `java
    -jar /usr/share/jenkins/slave.jar`。卷字段中需要的值是 `/var/run/docker.sock:/var/run/docker.sock`：
- en: '![](Images/91b7b76b-f375-4e9a-96dd-fc80c59193a3.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/91b7b76b-f375-4e9a-96dd-fc80c59193a3.png)'
- en: 'And lastly, check the checkbox for Allocate a pseudo-TTY:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，勾选分配伪TTY的复选框：
- en: '![](Images/2361d7a1-efdd-4143-a14a-91c14c5be184.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2361d7a1-efdd-4143-a14a-91c14c5be184.png)'
- en: 'Scroll down to the bottom of the configuration screen and click the Save button
    to save all of the Cloud settings. That was some serious configuration Kung Fu—great
    job! However, just in case you want a quick reference for all of the values entered,
    here are all of the custom (or non-default) values entered to configure the Docker
    Cloud in our example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动到配置屏幕底部，然后单击保存按钮以保存所有云设置。这是一些严肃的配置功夫 - 做得好！但是，以防万一您想要所有输入值的快速参考，这里是我们示例中用于配置Docker云的所有自定义（或非默认）值：
- en: '| **Field name** | **Value used** |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **字段名称** | **使用的值** |'
- en: '| Docker Host URI | `unix:///var/run/docker.sock` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: Docker主机URI | `unix:///var/run/docker.sock` |
- en: '| Docker API Version | `1.38` (match the version shown in the connection test)
    |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: Docker API版本 | `1.38`（与连接测试中显示的版本匹配）
- en: '| Docker Cloud Enabled | Checked |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: Docker云已启用 | 已勾选 |
- en: '| Container Cap | `10` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: 容器容量 | `10` |
- en: '| Docker Agent Enabled | Checked |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: Docker代理已启用 | 已勾选 |
- en: '| Docker Agent Template Name | `agent` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: Docker代理模板名称 | `agent` |
- en: '| Docker Image | `ubuntu-node01:5000/jenkins-agent:latest` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: Docker镜像 | `ubuntu-node01:5000/jenkins-agent:latest` |
- en: '| Instance Capacity | `1` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: 实例容量 | `1` |
- en: '| Remote File System Root | `/home/jenkins/agent` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: 远程文件系统根 | `/home/jenkins/agent` |
- en: '| Usage | `Use this node as much as possible` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: 用途 | `尽可能多地使用此节点` |
- en: '| Connection Method | `Attach Docker container` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 连接方法 | `附加Docker容器` |'
- en: '| User | `root` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 用户 | `root` |'
- en: '| Pull Strategy | `Pull once and update latest` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 拉取策略 | `拉取一次并更新最新` |'
- en: '| Docker Command | `java -jar /usr/share/jenkins/slave.jar` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| Docker命令 | `java -jar /usr/share/jenkins/slave.jar` |'
- en: '| Volumes | `/var/run/docker.sock:/var/run/docker.sock` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 卷 | `/var/run/docker.sock:/var/run/docker.sock` |'
- en: '| Allocate a pseudo-TTY | Checked |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 分配伪TTY | 已选中 |'
- en: Now that everything is configured, let's give our newly-defined Jenkins agents
    a test.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都配置好了，让我们测试一下我们新定义的Jenkins代理。
- en: Testing our new build agents
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的新构建代理
- en: 'Head back to the Jenkins dashboard and click on the Schedule a Build button
    for our `hello-docker-test` job. This will start a new build for our job, which
    in turn will create a new Dockerized build agent. It uses the configuration we
    set to execute a `docker container run` command to run a new container based on
    the image we specified. Initially, the executor will be offline as the container
    spins up:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 返回Jenkins仪表板，点击“计划构建”按钮，为我们的`hello-docker-test`作业。这将为我们的作业启动一个新的构建，然后将创建一个新的Docker化构建代理。它使用我们设置的配置来执行`docker
    container run`命令，以运行一个基于我们指定的镜像的新容器。最初，执行器将处于离线状态，因为容器正在启动：
- en: '![](Images/5ef3cfa0-9f85-4bd8-9f0d-8033edc1ab22.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5ef3cfa0-9f85-4bd8-9f0d-8033edc1ab22.png)'
- en: 'Notice that the executor name has the agent prefix that we specified. Once
    the container is running, the Jenkins job will be initiated within it, essentially
    using the `docker container exec` command. When the Jenkins job has started, the
    normal job-progress graphic will display, and the executor will no longer show
    as offline. The status will then look something like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，执行器名称具有我们指定的代理前缀。一旦容器运行起来，Jenkins作业将在其中启动，基本上使用`docker container exec`命令。当Jenkins作业启动时，正常的作业进度图形将显示，并且执行器将不再显示为离线状态。状态然后会看起来像这样：
- en: '![](Images/fe9dfbb5-5374-4b37-8847-010948778f6f.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fe9dfbb5-5374-4b37-8847-010948778f6f.png)'
- en: 'If you click on the progress bar of the executing job, you can view the job''s
    console output, and after a short while the job will show the finished: SUCCESS
    status, like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击正在执行的作业的进度条，您可以查看作业的控制台输出，不久后，作业将显示已完成：成功状态，如下所示：
- en: '![](Images/5b261ded-6411-40af-affc-42214a2e25ed.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5b261ded-6411-40af-affc-42214a2e25ed.png)'
- en: A job well done! Let's examine one last example Jenkins job to show a pipeline
    script that has more stages, and represents a real-world example of a Docker job.
    Are you ready? Read on.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 工作完成得很好！让我们检查最后一个例子Jenkins作业，展示一个具有更多阶段的流水线脚本，代表了一个真实世界的Docker作业的例子。你准备好了吗？继续阅读。
- en: Building, testing, and pushing Docker images inside Dockerized build nodes
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker化构建节点内构建、测试和推送Docker镜像
- en: 'To wrap up this chapter on Docker and Jenkins, let''s walk through the steps
    of creating a template for a real-world Dockerized node application. The following
    is what we will do:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker和Jenkins的这一章结束之前，让我们走一遍为真实世界的Docker化节点应用程序创建模板的步骤。以下是我们将要做的：
- en: 'Prepare our application:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 准备我们的应用程序：
- en: Create a new repo on GitHub
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GitHub上创建一个新的存储库
- en: Clone the repo to our development workstation
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆存储库到我们的开发工作站
- en: Create our application files
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的应用程序文件
- en: Push our application files up to GitHub
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的应用程序文件上传到GitHub
- en: 'Create and test the Jenkins job that will build our Dockerized node application:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并测试将构建我们的Docker化节点应用程序的Jenkins作业：
- en: Create a new Jenkins job that utilizes the GitHub repo
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个利用GitHub存储库的新Jenkins作业
- en: Test our Jenkins job that will pull the repo, build the app, test it, and publish
    the image
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试我们的Jenkins作业，将拉取存储库，构建应用程序，测试它，并发布镜像
- en: Celebrate our success!
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 庆祝我们的成功！
- en: Let's begin by preparing our application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始准备我们的应用程序。
- en: 'The first thing we want to do is create our application repo on GitHub. Browse
    and log into [github.com](http://www.github.com), go to your repositories page,
    and click on the Create New Repo button. Enter a name for the new repository.
    For our example, I used `dqs-example-app`. Enter an appropriate description. You
    can make your repo public or private. For this example, I am keeping it public
    for the simplicity of not needing to authenticate to pull the repo later. Check
    the Initialize the repository checkbox so you can immediately clone the empty
    repo on your workstation. You can select the project type to use when creating
    the `.gitignore` file. I selected `Node`. When you have entered and selected all
    this, it will look much like the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是在GitHub上创建我们的应用程序存储库。浏览并登录[github.com](http://www.github.com)，转到你的存储库页面，然后点击创建新存储库按钮。输入新存储库的名称。在我们的示例中，我使用了`dqs-example-app`。输入一个合适的描述。你可以将你的存储库设置为公开或私有。在这个示例中，我将其设置为公开，以简化后续不需要身份验证即可拉取存储库的过程。勾选初始化存储库复选框，这样你就可以立即在你的工作站上克隆空的存储库。你可以选择创建`.gitignore`文件时要使用的项目类型。我选择了`Node`。当你输入并选择了所有这些内容后，它会看起来像下面这样：
- en: '![](Images/48bc3985-be57-41e8-a45e-e19d7f4998e0.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/48bc3985-be57-41e8-a45e-e19d7f4998e0.png)'
- en: 'Click on the Create repository button to create your new application repo.
    Now that it is created on GitHub, you will want to clone it to your workstation.
    Use the Clone or download button and then the copy button to copy the repo''s
    URL for the cloning step:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 点击创建存储库按钮来创建你的新应用程序存储库。现在它在GitHub上创建好了，你会想要将它克隆到你的工作站上。使用克隆或下载按钮，然后使用复制按钮来复制存储库的URL以进行克隆步骤：
- en: '![](Images/44409c48-3703-4a37-a8ef-bb67901d05a2.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/44409c48-3703-4a37-a8ef-bb67901d05a2.png)'
- en: 'Now, return to your workstation and, in the location where you keep your local
    repos, clone the new (mostly) empty repo. Then change directory into the new repo''s
    folder. For me, that looked like the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到你的工作站，在你保存本地存储库的位置，克隆这个新的（大部分是）空的存储库。然后切换到新存储库的文件夹中。对我来说，看起来像下面这样：
- en: '![](Images/983a1f97-6082-47e2-85df-40b296775617.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/983a1f97-6082-47e2-85df-40b296775617.png)'
- en: 'Now we are going to create the application''s scaffolding. This will consist
    of creating a `Dockerfile`, a `Jenkinsfile`, the `main.js` and `test.js` files,
    and the `package.json` file. Use your favorite editor to create each of these
    files in your application folder. The following are the contents for the files:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要创建应用程序的脚手架。这将包括创建一个`Dockerfile`，一个`Jenkinsfile`，`main.js`和`test.js`文件，以及`package.json`文件。使用你喜欢的编辑器在你的应用程序文件夹中创建这些文件。以下是这些文件的内容：
- en: 'The following are the contents of the `Dockerfile` file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Dockerfile`文件的内容：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following are the contents of the `Jenkinsfile` file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Jenkinsfile`文件的内容：
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following are the contents of the `main.js` file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`main.js`文件的内容：
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following are the contents of the `package.json` file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`package.json`文件的内容：
- en: '[PRE19]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And finally, the following are the contents of the `test.js` file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是`test.js`文件的内容：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you are all done, your repo folder should look something like the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成所有操作后，你的存储库文件夹应该看起来像下面这样：
- en: '![](Images/94cd891d-3d0f-44a1-87bd-a5b1d51a81cf.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/94cd891d-3d0f-44a1-87bd-a5b1d51a81cf.png)'
- en: 'Now, let''s push our work up to the GitHub repo. You will use standard git
    commands to add the files, commit the files, and then push the files up to the
    repo. The following are the commands I used:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们的工作推送到GitHub存储库。你将使用标准的git命令来添加文件，提交文件，然后将文件推送到存储库。以下是我使用的命令：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is what that looked like for me:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，情况是这样的：
- en: '![](Images/f01fd31d-6e5e-42cd-8382-a8657926144b.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f01fd31d-6e5e-42cd-8382-a8657926144b.png)'
- en: Now that the initial version of our application has been created and pushed
    to our GitHub repo, we are ready to create the Jenkins job to pull our repo code,
    build our application image, test it, and then publish our application's Docker
    image. Start off by creating a new Jenkins job, by logging into your Jenkins server
    and clicking on the New Item link. Next, enter the name you want to use for the
    job in the Enter an item name input box. I am using `dqs-example-app`. Select
    `Pipeline` for the type of job we are creating, and then click the OK button.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序的初始版本已经创建并推送到我们的GitHub仓库，我们准备创建Jenkins作业来拉取我们的仓库代码，构建我们的应用程序镜像，对其进行测试，然后发布我们应用程序的Docker镜像。首先，通过登录到Jenkins服务器并单击“新项目”链接来创建一个新的Jenkins作业。接下来，在“输入项目名称”输入框中输入要用于作业的名称。我正在使用`dqs-example-app`。选择“流水线”作为我们正在创建的作业类型，然后单击“确定”按钮。
- en: 'You can, and probably should, provide a meaningful description for the build
    job we are creating. Just enter it into the Description: input box at the top
    of the configuration screen. For our example, I have entered the somewhat terse
    description `Build the dqs-example-app using a pipeline script from SCM`. You
    can probably do a lot better.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以并且可能应该为我们正在创建的构建作业提供有意义的描述。只需将其输入到配置屏幕顶部的“描述：”输入框中。对于我们的示例，我输入了略显简洁的描述“使用来自SCM的管道脚本构建dqs-example-app”。您可能可以做得更好。
- en: 'We are going to set up the Jenkins job to poll the GitHub repo every five minutes
    to look for changes to the master branch. There are better options where changes
    to the repo can trigger the build job without scheduled polling, but for the simplicity
    of this example, we will just use a poll method. So scroll down to the Build Triggers
    section of the job''s configuration and check Poll SCM. Then in the schedule,
    enter a value of `H/5 * * * *`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置Jenkins作业，每五分钟轮询GitHub仓库，以查找主分支的更改。有更好的选项，可以在仓库更改时触发构建作业，而不是定期轮询，但为了简单起见，我们将只使用轮询方法。因此，请滚动到作业配置的“构建触发器”部分，并选中“轮询SCM”。然后在计划中输入值`H/5
    * * * *`：
- en: '![](Images/2edd77ba-1fd9-43c2-a54b-c0721a69ebd8.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2edd77ba-1fd9-43c2-a54b-c0721a69ebd8.png)'
- en: 'Next, we want to set up our pipeline. Unlike the previous examples, this time
    we will select the Pipeline script from SCM option. We will select `Git` for our
    SCM, and then enter the Repository URL for our application''s repo on GitHub.
    For this example, that URL is `https://github.com/EarlWaud/dqs-example-app.git`.
    Make sure that the Branches to build value is set to `*/master`, which is the
    default value. Your pipeline definition should like a lot like the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要设置我们的流水线。与以前的示例不同，这次我们将选择“来自SCM的管道脚本”选项。我们将为我们的SCM选择`Git`，然后输入GitHub上我们应用程序仓库的存储库URL。对于此示例，该URL为`https://github.com/EarlWaud/dqs-example-app.git`。确保“要构建的分支”值设置为`*/master`，这是默认值。您的流水线定义应该看起来很像以下内容：
- en: '![](Images/c00bff59-f503-4d42-a9b0-5ace6f9aaf57.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c00bff59-f503-4d42-a9b0-5ace6f9aaf57.png)'
- en: 'There is one more key setting for the pipeline, and that is the Script Path.
    This is the (path and) filename to the Jenkins script file. In our case, that
    is literally just `Jenkinsfile` because the name we gave the file is `Jenkinsfile` and
    it is in the root of our repo. This is what our example''s input looks like:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线的另一个关键设置是脚本路径。这是Jenkins脚本文件的（路径和）文件名。在我们的情况下，这实际上只是`Jenkinsfile`，因为我们给文件的名称是`Jenkinsfile`，它位于我们仓库的根目录。这是我们示例的输入样子：
- en: '![](Images/50c3760a-1450-49fd-9276-ab3def3f10a4.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/50c3760a-1450-49fd-9276-ab3def3f10a4.png)'
- en: 'That is all the configuration needed at this time. Everything else is already
    set up in our source files, and they will be pulled from our application repo.
    All that''s left to do for the configuration is to click the Save button. Back
    at the job''s page, we are ready to execute our first build. The newly-created
    job screen looks like this in our example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是目前所需的所有配置。其他一切都已经在我们的源文件中设置好了，它们将从我们的应用程序存储库中拉取。配置所需做的就是点击保存按钮。回到作业页面，我们已经准备好执行我们的第一个构建。在我们的示例中，新创建的作业屏幕看起来像这样：
- en: '![](Images/33667e7a-61d6-4fa0-8c47-8deffb2a9522.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/33667e7a-61d6-4fa0-8c47-8deffb2a9522.png)'
- en: 'Now, just wait. In five minutes or fewer, the first build of the job will kick
    off automatically because we have set up polling the repo at five-minute intervals.
    We will take a look at the console log when the job has finished, but first here
    is our Jenkins job view after the job completes (successfully, of course!):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需等待。在五分钟或更短的时间内，作业的第一个构建将自动启动，因为我们已经设置了每五分钟轮询存储库。当作业完成后，我们将查看控制台日志，但首先让我们看一下作业完成后的
    Jenkins 作业视图（当然是成功的）：
- en: '![](Images/2d26df0f-15ab-4df0-908a-45787221ef31.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2d26df0f-15ab-4df0-908a-45787221ef31.png)'
- en: 'The following is an edited view of the console log output for reference (the
    full log output can be found in the source bundle):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是控制台日志输出的编辑视图，供参考（完整的日志输出可以在源代码包中找到）：
- en: '[PRE22]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'All that is left to do now is celebrate our success:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是庆祝我们的成功：
- en: '![](Images/0d4fb92f-733c-4808-bc8a-904b799a8bd6.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0d4fb92f-733c-4808-bc8a-904b799a8bd6.png)'
- en: Seriously, this is a great foundation for creating your own Dockerized applications
    and building, testing and publishing them using Jenkins. Consider it as a template
    that you can reuse and build from. You are now ready to utilize Docker with Jenkins
    in any way you desire.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 说真的，这是创建自己的 Docker 应用程序并使用 Jenkins 构建、测试和发布它们的一个很好的基础。把它看作一个模板，你可以重复使用并构建。现在你已经准备好以任何你想要的方式在
    Jenkins 中使用 Docker 了。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Well, here we are, at the end of the chapter. I hope you had as much fun reading
    this chapter as I had writing it. We had the opportunity to use many of the skills
    that we learned in the previous chapters. Not only that, there are some really
    useful Jenkins lessons in this chapter as well. So much so that you could seriously
    consider skipping any planned Jenkins training or book-reading because pretty
    much everything you need to know about using Jenkins is right here.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们到了本章的结尾。我希望你阅读本章的乐趣和我写作时一样多。我们有机会运用我们在之前章节学到的许多技能。不仅如此，本章还包含一些非常有用的 Jenkins
    知识。以至于你可以认真考虑跳过任何计划中的 Jenkins 培训或书籍阅读，因为你几乎可以在这里找到关于使用 Jenkins 的一切知识。
- en: 'Let''s recap: first, we learned how to set up a standalone Jenkins server.
    We quickly transitioned into deploying a Jenkins server as a Docker container.
    That''s the kind of thing you''re reading this book for, right? Then we learned
    how to build a Docker image in a Dockerized Jenkins server. Next, we found out
    how to replace the boring Jenkins agents with super-cool Docker containers that
    can build our Docker image. You might think about this and Docker-in-Docker-in-Docker.
    Have you seen the movie Inception? Well, you just lived it. Finally, to wrap up
    the chapter, we created an example dockerized app and the Jenkins job that builds,
    tests, and publishes that app''s image. It''s an example that you can use as a
    template and foundation for the real-world applications you will create in the
    future.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下：首先，我们学习了如何设置独立的Jenkins服务器。我们很快过渡到将Jenkins服务器部署为Docker容器。这就是你阅读这本书的目的，对吧？然后我们学会了如何在Docker化的Jenkins服务器中构建Docker镜像。接下来，我们找出了如何用超酷的Docker容器替换无聊的Jenkins代理，这些容器可以构建我们的Docker镜像。你可能会考虑这个以及Docker中的Docker中的Docker。你看过电影《盗梦空间》吗？嗯，你刚刚经历了它。最后，在本章的总结中，我们创建了一个示例的Docker化应用程序和构建、测试和发布该应用程序镜像的Jenkins作业。这是一个示例，你可以将其用作未来创建的真实应用程序的模板和基础。
- en: And, here we are at the end of the book. I'll say it again… I hope you had as
    much fun reading it as I had writing it. And I hope you learned as much reading
    it as I did writing it. We covered a lot of Docker information throughout these
    chapters. We nailed Docker workstation setup in the [Chapter 1](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml),
    *Setting up a Dockerized Development Environment*, regardless of the type of OS
    you prefer. In [Chapter 2](e66034ed-dcc0-48a8-a2ec-9466669e6649.xhtml), *Learning
    Docker Commands*, we learned just about everything there is to know about the
    Docker command set. In [Chapter 3](ab7747ed-23c9-462c-98cb-c70e330c5d87.xhtml),
    *Creating Docker Images*, we studied the `Dockerfile` instruction set in depth
    and learned how to create just about any Docker image you could want to build.
    Chapter 4, *Docker Volumes*, showed us the power and usefulness of Docker volumes.
    We started putting several of the lessons from the earlier chapters to use when
    we exercised the features of the almost magical Docker swarm in [Chapter 5](f1681897-580b-44fb-9e43-4aed37e67529.xhtml),
    *Docker Swarm*. Then, in [Chapter 6](873454a4-2f8e-42df-93ab-7648545167bb.xhtml),
    *Docker Networking*, we continued our Docker education, this time learning how
    Docker has simplified the complex topic of networking for us. And in [Chapter
    7](1a206f3a-faf8-43cb-9413-d1e451bd2a35.xhtml), *Docker Stacks*, we saw more Docker
    magic and power when we learned about Docker stacks. Finally, in [Chapter 8](88652c62-a041-4cec-b42c-0aaa414d7083.xhtml),
    *Docker and Jenkins*, we put all of our learning to use and leveraged Docker with
    Jenkins to prepare us to create real-world applications.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来到了书的结尾。我再说一遍……我希望你阅读这本书和我写这本书一样开心。我也希望你从中学到的和我写这本书一样多。在这些章节中，我们涵盖了大量关于Docker的信息。在[第1章](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml)中，*设置Docker化的开发环境*，我们成功搭建了Docker工作站，无论你喜欢的操作系统类型是什么。在[第2章](e66034ed-dcc0-48a8-a2ec-9466669e6649.xhtml)中，*学习Docker命令*，我们学到了几乎所有关于Docker命令集的知识。在[第3章](ab7747ed-23c9-462c-98cb-c70e330c5d87.xhtml)中，*创建Docker镜像*，我们深入研究了`Dockerfile`指令集，并学会了如何创建几乎任何你想构建的Docker镜像。第4章，*Docker卷*，向我们展示了Docker卷的强大和实用性。在[第5章](f1681897-580b-44fb-9e43-4aed37e67529.xhtml)中，*Docker
    Swarm*，我们开始运用前几章的几个教训，练习了几乎神奇的Docker swarm的功能。然后，在[第6章](873454a4-2f8e-42df-93ab-7648545167bb.xhtml)中，*Docker网络*，我们继续学习Docker知识，这次学习了Docker如何为我们简化了复杂的网络主题。在[第7章](1a206f3a-faf8-43cb-9413-d1e451bd2a35.xhtml)中，*Docker堆栈*，我们看到了更多Docker的魔力和力量，当我们了解了Docker堆栈。最后，在[第8章](88652c62-a041-4cec-b42c-0aaa414d7083.xhtml)中，*Docker和Jenkins*，我们将所有学到的知识应用起来，利用Docker和Jenkins为我们准备好创建真实世界的应用程序。
- en: All that is left is for me to say thanks and wish you success in your Docker
    journey.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我所能做的就是说声谢谢，并祝愿你在Docker之旅中取得成功。
