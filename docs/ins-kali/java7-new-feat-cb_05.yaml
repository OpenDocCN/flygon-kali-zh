- en: Chapter 5. Managing Filesystems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。管理文件系统
- en: 'In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Getting FileStore information
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取FileStore信息
- en: Getting FileSystem information
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取FileSystem信息
- en: Using the SimpleFileVisitor class to traverse filesystems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SimpleFileVisitor类遍历文件系统
- en: Deleting a directory using the SimpleFileVisitor class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SimpleFileVisitor类删除目录
- en: Copying a directory using the SimpleFileVisitor class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SimpleFileVisitor类复制目录
- en: Processing the contents of a directory by using the DirectoryStream interface
    as explained in the *Filtering a directory using globbing* recipe
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DirectoryStream接口处理目录的内容，如*使用globbing过滤目录*教程中所述
- en: Writing your own directory filter
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自己的目录过滤器
- en: Monitoring file events using WatchEvents
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WatchEvents监视文件事件
- en: Understanding the ZIP filesystem provider
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解ZIP文件系统提供程序
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: A **filesystem** is one or more top-level root directories containing a hierarchy
    of files. A filesystem is supported by a file store that is the provider for the
    storage of the files. This chapter is concerned with obtaining information about
    these entities and typical filesystem tasks, such as determining the contents
    of a directory or monitoring filesystem events.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件系统**是一个或多个顶级根目录，包含文件层次结构。文件系统由文件存储支持，该文件存储是文件存储的提供者。本章涉及获取有关这些实体和典型文件系统任务的信息，例如确定目录的内容或监视文件系统事件。'
- en: A file store represents a unit of storage. For example, it might represent a
    device, such as a `C` drive, a partition of a drive, or a volume. The `java.nio.file.FileStore`
    class supports file stores and provides several methods to this end. The *Getting
    FileStore information* recipe covers how to obtain basic information about a specific
    file store.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 文件存储表示存储单元。例如，它可能表示设备，比如`C`驱动器，驱动器的分区或卷。`java.nio.file.FileStore`类支持文件存储，并提供了几种方法。*获取FileStore信息*教程介绍了如何获取有关特定文件存储的基本信息。
- en: A filesystem supports access to a hierarchy of directories and files. It is
    represented in Java 7 with the `java.nio.file.FileSystem` class. Obtaining general
    information about a filesystem is covered in the *Getting FileSystem information*
    recipe. This includes how to obtain a list of root directories for a filesystem
    and the underlying file stores.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统支持访问目录和文件的层次结构。它在Java 7中用`java.nio.file.FileSystem`类表示。获取有关文件系统的一般信息在*获取FileSystem信息*教程中介绍。这包括如何获取文件系统的根目录列表和底层文件存储。
- en: Traversing a directory hierarchy is useful for many applications. The *Using
    the SimpleFileVisitor class to traverse filesystems* recipe details the basic
    approach. This approach is used in the *Deleting a directory using the SimpleFileVisitor
    class* and *Copying a directory using the SimpleFileVisitor class* recipes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历目录层次结构对许多应用程序很有用。*使用SimpleFileVisitor类遍历文件系统*教程详细介绍了基本方法。这种方法在*使用SimpleFileVisitor类删除目录*和*使用SimpleFileVisitor类复制目录*教程中使用。
- en: When an operation is restricted to a single directory, the `java.nio.file.DirectoryStream`
    interface provides a convenient technique for examining each element in the directory
    as a `java.nio.file.Path` object. It is very easy to use a for each loop to process
    these paths. This approach is explored in the *Using the DirectoryStream interface
    to process the contents of a directory* recipe.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作限制在单个目录时，`java.nio.file.DirectoryStream`接口提供了一种方便的技术，用于将目录中的每个元素作为`java.nio.file.Path`对象进行检查。使用for
    each循环处理这些路径非常容易。这种方法在*使用DirectoryStream接口处理目录的内容*教程中探讨。
- en: Sometimes we don't need the entire contents of a directory, but rather a subset
    of its elements. Java 7 provides a few approaches to filtering the contents of
    a directory as described in the *Filtering a directory using globbing* and *Writing
    your own directory filter* recipes. **Globbing** is a pattern-matching technique
    that is similar to regular expressions but is easier to use.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不需要整个目录的内容，而是需要其元素的子集。Java 7提供了几种过滤目录内容的方法，如*使用globbing过滤目录*和*编写自己的目录过滤器*教程中所述。**Globbing**是一种类似于正则表达式但更容易使用的模式匹配技术。
- en: In the *Monitoring file events using WatchEvents* recipe we learn how Java 7
    supports the detection of file creation, modification, and deletion within a directory
    by external processes. This can be very useful when it is necessary to know when
    changes to a directory are made.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用WatchEvents监视文件事件*教程中，我们了解到Java 7支持通过外部进程检测目录中文件的创建、修改和删除。当需要知道对目录进行更改时，这可能非常有用。
- en: With Java 7, it is now possible to treat the contents of a ZIP file as a filesystem.
    This makes it easier to manage the contents of a ZIP file and to manipulate the
    files contained within the ZIP file. This technique is demonstrated in the *Understanding
    the zip filesystem provider* recipe.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java 7，现在可以将ZIP文件的内容视为文件系统。这使得更容易管理ZIP文件的内容并操作ZIP文件中包含的文件。这种技术在*理解zip文件系统提供程序*教程中进行了演示。
- en: Getting FileStore information
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取FileStore信息
- en: Each filesystem supports a file storage mechanism. This may be a device, such
    as a `C` drive, a partition of a drive, a volume, or some other way of organizing
    a filesystem's space. The `java.nio.file.FileStore` class represents one of these
    storage divisions. This recipe details the methods available to obtain information
    about the file store.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件系统都支持文件存储机制。这可能是一个设备，比如`C`驱动器，一个驱动器的分区，一个卷，或者其他组织文件系统空间的方式。`java.nio.file.FileStore`类代表其中一个存储分区。本教程详细介绍了获取有关文件存储的信息的方法。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To obtain and use a `FileStore` object:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取并使用`FileStore`对象：
- en: Obtain an instance of the `java.nio.file.FileSystem` in use.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取正在使用的`java.nio.file.FileSystem`的实例。
- en: Use the `FileSystem` class' `getFileStores` method to return the available file
    stores.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`FileSystem`类的`getFileStores`方法返回可用的文件存储。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Create a new console application. In the `main` method, we will use several
    methods of the `FileStore` class to demonstrate the support provided by this class.
    Let's start by adding the first part of the `main` method, where we display an
    initial header and get a `FileSystem` object. Also, define a `long` variable called
    `kiloByte:`
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序。在`main`方法中，我们将使用`FileStore`类的几种方法来演示该类提供的支持。让我们从添加`main`方法的第一部分开始，其中我们显示初始标题并获取一个`FileSystem`对象。还定义一个名为`kiloByte`的`long`变量：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we need to use the `getFileStores` method to retrieve the available file
    stores and then display them. In the first part of the block, we use several `FileStore`
    methods to get relevant information. In the last part, we display the information
    as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用`getFileStores`方法检索可用的文件存储，并显示它们。在代码块的第一部分中，我们使用了几个`FileStore`方法来获取相关信息。在最后一部分，我们按以下方式显示信息：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Execute the application. Your output will differ from the following, but should
    reflect the drives on your system:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。您的输出将与以下内容不同，但应反映系统上的驱动器：
- en: '**Name Filesystem Type Readonly Size(KB) Used(KB) Available(KB)**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称 文件系统类型 只读 大小（KB）已用（KB）可用（KB）**'
- en: '**HP HP (C:) NTFS false 301,531,984 163,041,420 138,490,564**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**HP HP (C:) NTFS false 301,531,984 163,041,420 138,490,564**'
- en: '**FACTORY_IMAGE FACTORY_IMAGE (D:) NTFS false 11,036,652 9,488,108 1,548,544**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**FACTORY_IMAGE FACTORY_IMAGE (D:) NTFS false 11,036,652 9,488,108 1,548,544**'
- en: '**HP_PAVILION HP_PAVILION (E:) NTFS false 312,568,640 66,489,184 246,079,456**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**HP_PAVILION HP_PAVILION (E:) NTFS false 312,568,640 66,489,184 246,079,456**'
- en: '**TOSHIBA TOSHIBA (H:) FAT32 false 15,618,080 3,160,768 12,457,312**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**TOSHIBA TOSHIBA (H:) FAT32 false 15,618,080 3,160,768 12,457,312**'
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: A format string was created to simplify the display of the file store information.
    This string was used in both of the `printf` methods. Using the same string twice
    ensures consistent spacing of the output. A simple title was displayed using this
    string.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个格式化字符串，以简化文件存储信息的显示。此字符串在两个`printf`方法中都使用。两次使用相同的字符串可以确保输出的一致间距。使用此字符串显示了一个简单的标题。
- en: A `FileSystem` object was obtained using the `FileSystems` class' `getDefault`
    method. The `getFileStores` method was executed against this object to obtain
    a list of `FileStore` objects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`FileSystems`类的`getDefault`方法获取了一个`FileSystem`对象。对该对象执行`getFileStores`方法以获取`FileStore`对象的列表。
- en: 'Within the loop, a try block was used to catch exceptions that might have been
    thrown. Several methods were invoked as detailed in the following table. An instance
    of the `NumberFormat` class was created to format file store size information.
    The last `printf` method displayed the file store information for each file store:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，使用try块捕获可能抛出的异常。按照下表详细说明的方式调用了几个方法。创建了`NumberFormat`类的实例以格式化文件存储大小信息。最后的`printf`方法显示了每个文件存储的文件存储信息：
- en: '| Method | Meaning |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 含义 |'
- en: '| --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `getTotalSpace` | The total space available on the file store in bytes |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `getTotalSpace` | 文件存储中可用的总空间（以字节为单位） |'
- en: '| `getUnallocatedSpace` | The number of unallocated bytes |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `getUnallocatedSpace` | 未分配的字节数 |'
- en: '| `getUsableSpace` | The number of usable bytes available to the JVM |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `getUsableSpace` | JVM可用的可用字节数 |'
- en: '| `name` | An implementation-specific string representing the file store name
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `name` | 表示文件存储名称的特定于实现的字符串 |'
- en: '| `type` | An implementation-specific string representing the file store type
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `type` | 表示文件存储类型的特定于实现的字符串 |'
- en: '| `isReadOnly` | If the method returns `true`, then attempts to create a file
    or open a file for writing will result in an `IOException` being thrown |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `isReadOnly` | 如果方法返回`true`，则尝试创建文件或打开文件进行写入将导致抛出`IOException` |'
- en: The values returned by the `getUnallocatedSpace` or `getUsableSpace` methods
    can change if an external operation uses or releases space on the file store.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`getUnallocatedSpace`或`getUsableSpace`方法返回的值可能会在外部操作使用或释放文件存储空间时发生变化。'
- en: See also
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The attribute views as supported by a `FileStore` are determined using one of
    the two `supportsFileAttributeView` methods. These are illustrated in the *There's
    more..*. section of the *Determining operating system support for attribute views*
    recipe in [Chapter 3](ch03.html "Chapter 3. Obtaining File and Directory Information"),
    *Obtaining File and Directory Information*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两种`supportsFileAttributeView`方法之一来确定`FileStore`支持的属性视图。这些方法在[第3章](ch03.html
    "第3章。获取文件和目录信息")的*确定操作系统对属性视图的支持*食谱的*还有更多..*部分中进行了说明，*获取文件和目录信息*。
- en: Getting Filesystem information
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取文件系统信息
- en: A filesystem is composed of a hierarchy of directories and files. There is a
    limited amount of information regarding a filesystem that is normally useful.
    For example, we may want to know whether the filesystem is read-only or who the
    provider is. In this recipe we will examine the methods available to retrieve
    filesystem attributes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统由一系列目录和文件组成。通常有一些关于文件系统的有限信息是有用的。例如，我们可能想知道文件系统是否为只读，或者提供者是谁。在本示例中，我们将研究用于检索文件系统属性的可用方法。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To access the method of a filesystem we need to:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问文件系统的方法，我们需要：
- en: Obtain a reference to a `java.nio.file.FileSystem` object.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取对`java.nio.file.FileSystem`对象的引用。
- en: Use the methods of this object to access filesystem information.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此对象的方法来访问文件系统信息。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new console application. Add the following code to the `main` method
    of the application. This sequence displays several `fileSystem` attributes, including
    the filesystem provider, file open status, whether the file is available to be
    read-only, the root directories, and the names of the file stores:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序。将以下代码添加到应用程序的`main`方法中。此序列显示了几个`fileSystem`属性，包括文件系统提供程序、文件打开状态、文件是否可读写、根目录和文件存储的名称：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Execute the application. Your output will depend upon the configuration of
    your system. However, it should mimic the output that follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。您的输出将取决于系统的配置。但是，它应该与以下输出类似：
- en: '**Provider: sun.nio.fs.WindowsFileSystemProvider@7b60e796**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**提供程序：sun.nio.fs.WindowsFileSystemProvider@7b60e796**'
- en: '**Open: true**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**打开：true**'
- en: '**Read Only: false**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**只读：false**'
- en: '**Root Directories**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**根目录**'
- en: '**C:\**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**C:\**'
- en: '**D:\**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**D:\**'
- en: '**E:\**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**E:\**'
- en: '**F:\**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**F:\**'
- en: '**G:\**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**G:\**'
- en: '**H:\**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**H:\**'
- en: '**I:\**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**I:\**'
- en: '**J:\**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**J:\**'
- en: '**K:\**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**K:\**'
- en: '**L:\**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**L:\**'
- en: '**File Stores**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件存储**'
- en: '**HP**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**HP**'
- en: '**FACTORY_IMAGE**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**FACTORY_IMAGE**'
- en: '**HP_PAVILION**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**HP_PAVILION**'
- en: '**TOSHIBA**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**TOSHIBA**'
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The `getDefault` method returned the default filesystem used by the JVM. Next,
    several methods were invoked against this object:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`getDefault`方法返回JVM使用的默认文件系统。接下来，针对此对象执行了几种方法：'
- en: The `provider` method returned the provider, that is, implementer of the filesystem.
    In this case, it was a Windows filesystem provider that came bundled with the
    JVM.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`provider`方法返回提供程序，即文件系统的实现者。在这种情况下，它是与JVM捆绑在一起的Windows文件系统提供程序。'
- en: The `isOpen` method indicated that the filesystem is open and ready for use.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isOpen`方法指示文件系统已打开并准备就绪。'
- en: The `isReadOnly` method returned `false`, meaning that we can read and write
    to the system.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isReadOnly`方法返回`false`，这意味着我们可以读写系统。'
- en: We used the `getRootDirectories` method to create an `Iterable` object that
    permitted us to list each root directory.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`getRootDirectories`方法创建了一个`Iterable`对象，允许我们列出每个根目录。
- en: The `getFileStores` method returned another `Iterable` object, which was used
    to display the names of the file stores.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFileStores`方法返回另一个`Iterable`对象，用于显示文件存储的名称。'
- en: There's more...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有...
- en: While we do not normally need to close a filesystem, the `close` method can
    be used to close the filesystem. Any subsequent methods executed against the filesystem
    will result in a `ClosedFileSystemException` being thrown. Any open channels,
    directory streams, and watch services associated with the filesystem will also
    be closed. Note that the default filesystem cannot be closed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们通常不需要关闭文件系统，但是`close`方法可以用于关闭文件系统。对文件系统执行的任何后续方法都将导致抛出`ClosedFileSystemException`。与文件系统关联的任何打开通道、目录流和监视服务也将被关闭。请注意，默认文件系统无法关闭。
- en: The `FileSystems` class' `getFileSystem` method can be used to access a specific
    filesystem. In addition, the overloaded `newFileSystem` method will create new
    filesystems. The `close` method can be used with these instances.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileSystems`类的`getFileSystem`方法可用于访问特定的文件系统。此外，重载的`newFileSystem`方法将创建新的文件系统。`close`方法可以用于这些实例。'
- en: Filesystems are thread-safe. However, if one thread attempts to close the filesystem
    while another thread is accessing the `filesystem` object, the close operation
    may be blocked
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统是线程安全的。但是，如果一个线程尝试关闭文件系统，而另一个线程正在访问`filesystem`对象，关闭操作可能会被阻塞。
- en: until the access is complete.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 直到访问完成。
- en: Using the SimpleFileVisitor class to traverse filesystems
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`SimpleFileVisitor`类来遍历文件系统
- en: When working with directory systems, a common need is to traverse the filesystem
    examining each subdirectory within a file hierarchy. This task has been made easy
    with the `java.nio.file.SimpleFileVisitor` class. This class implements methods
    that execute before and after a directory is visited. In addition, callback methods
    are invoked for each instance a file is visited in a directory and if an exception
    occurs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理目录系统时，常见的需求是遍历文件系统，检查文件层次结构中的每个子目录。使用`java.nio.file.SimpleFileVisitor`类可以轻松完成这项任务。该类实现了在访问目录之前和之后执行的方法。此外，对于在目录中访问每个文件实例以及发生异常的情况，还会调用回调方法。
- en: The `SimpleFileVisitor` class or a derived class is used in conjunction with
    the `java.nio.file.Files` class' `walkFileTree` method. It performs a depth first
    traversal, starting at a specific root directory.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleFileVisitor`类或派生类与`java.nio.file.Files`类的`walkFileTree`方法一起使用。它执行深度优先遍历，从特定的根目录开始。'
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To traverse a directory we need to:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历目录，我们需要：
- en: Create a `Path` object representing the root directory.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个代表根目录的`Path`对象。
- en: Create an instance of a class derived from `SimpleFileVisitor`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个派生自`SimpleFileVisitor`的类的实例。
- en: Use these objects as arguments to the `Files` class' `walkFileTree` method.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些对象用作`Files`类的`walkFileTree`方法的参数。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new console application and use the following `main` method. Here,
    we will traverse the `home` directory and list each of its elements as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序，并使用以下`main`方法。在这里，我们将遍历`home`目录，并列出其每个元素如下：
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following `ListFiles` class to your project. It illustrates the use
    of each of the `SimpleFileVisitor` methods:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`ListFiles`类添加到您的项目中。它说明了每个`SimpleFileVisitor`方法的用法：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Execute the application. Depending on the structure of your `home` directory,
    you may get results different from the following:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。根据您的`home`目录的结构，您可能会得到与以下不同的结果：
- en: '**About to traverse the directory: home**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 即将遍历目录：home
- en: '**About to traverse the directory: docs**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**即将遍历目录：docs**'
- en: '**Visiting file:users.bak**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问文件：users.bak**'
- en: '**Visiting file:users.txt**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问文件：users.txt**'
- en: '**Finished with the directory: docs**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成目录：docs**'
- en: '**About to traverse the directory: music**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**即将遍历目录：music**'
- en: '**Visiting file:Future Setting A.mp3**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问文件：Future Setting A.mp3**'
- en: '**Visiting file:Robot Brain A.mp3**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问文件：Robot Brain A.mp3**'
- en: '**Visiting file:Space Machine A.mp3**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问文件：Space Machine A.mp3**'
- en: '**Finished with the directory: music**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成目录：music**'
- en: '**Finished with the directory: home**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成目录：home**'
- en: Examine the `backup` directory to verify that it was created successfully.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`backup`目录，以验证它是否成功创建。
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the `main` method, we created a `Path` object for the `home` directory. Next,
    an instance of the `ListFiles` class was created. These objects were used as the
    arguments of the `walkFileTree` method. This method affected the traversal of
    the `home` directory and invoked the methods of the `ListFiles` class as required.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`方法中，我们为`home`目录创建了一个`Path`对象。接下来，创建了`ListFiles`类的一个实例。这些对象被用作`walkFileTree`方法的参数。该方法影响了`home`目录的遍历，并根据需要调用了`ListFiles`类的方法。
- en: The `walkFileTree` method started at a root directory, and performed a depth
    first traversal of the directory hierarchy. Before a directory was traversed,
    the `preVisitDirectory` method was invoked. Next, each element of the directory
    was processed. If it was a file, then the `visitFile` method was invoked. Once
    all of the elements of the directory had been processed, the `postVisitDirectory`
    method was invoked. If an exception had occurred, then the `visitFileFailed` method
    would have been invoked.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`walkFileTree`方法从根目录开始，并对目录层次结构进行深度优先遍历。在遍历目录之前，将调用`preVisitDirectory`方法。接下来，处理目录的每个元素。如果是文件，则调用`visitFile`方法。一旦处理了目录的所有元素，将调用`postVisitDirectory`方法。如果发生异常，则将调用`visitFileFailed`方法。'
- en: Private helper methods were added, which made the output more readable. The
    `indentionAmount` variable controlled the depth of each indention. The `indentionLevel`
    variable was incremented and decremented as each subdirectory was visited. The
    `indent` method preformed the actual indention.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了私有辅助方法，使输出更易读。`indentionAmount`变量控制了每个缩进的深度。`indentionLevel`变量在访问每个子目录时递增和递减。`indent`方法执行实际的缩进。
- en: There's more...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are two overloaded `walkFileTree` methods. One takes a `Path` and a `FileVisitor`
    object, which was illustrated previously. It will not follow links and will visit
    all levels of the directory. The second method takes two additional arguments:
    one that specifies the number of directory levels to be visited and a second one
    to configure the traversal. Currently, the only configuration option available
    is `FileVisitOption.FOLLOW_LINKS`, which directs the method to follow symbolic
    links.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个重载的`walkFileTree`方法。一个接受`Path`和`FileVisitor`对象，之前已经说明过。它不会跟踪链接，并将访问目录的所有级别。第二个方法接受两个额外的参数：一个指定要访问的目录级别的数量，另一个用于配置遍历。目前，唯一可用的配置选项是`FileVisitOption.FOLLOW_LINKS`，它指示方法跟随符号链接。
- en: Symbolic links are not followed by default. If they are followed when specified
    by an argument of the `walkFileTree` method, then care is taken to detect circular
    links. If a circular link is detected, it is treated as an error condition.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下不会跟随符号链接。如果在`walkFileTree`方法的参数中指定了跟随它们，则会注意检测循环链接。如果检测到循环链接，则将其视为错误条件。
- en: The number of levels of directories to visit is controlled by an integer argument.
    A value of 0 will result in only the top-level directory being visited. A value
    of `Integer.MAX_VALUE` means that all of the levels will be visited. A value of
    two means only the first two directory levels are traversed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问的目录级别的数量由整数参数控制。值为0将导致只访问顶级目录。值为`Integer.MAX_VALUE`表示将访问所有级别。值为2表示只遍历前两个目录级别。
- en: 'The traversal will terminate when one of the following conditions occurs:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历将在以下条件之一发生时终止：
- en: All files have been traversed
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有文件都已被遍历
- en: A `visit` method returns `FileVisitResult.TERMINATE`
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visit`方法返回`FileVisitResult.TERMINATE`'
- en: A `visit` method terminates with an `IOException`, or other exception is propagated
    back
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visit`方法以`IOException`或其他异常终止时，将被传播回来'
- en: Any unsuccessful action will generally result in the `visitFileFailed` method
    being invoked and an `IOException` being thrown.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 任何不成功的操作通常会导致调用`visitFileFailed`方法并抛出`IOException`。
- en: When a file is encountered, and if it is not a directory, then an attempt is
    made to read its `BasicFileAttributes`. If successful, the attribute is passed
    to the `visitFile` method. If unsuccessful, the `visitFileFailed` method is invoked,
    and it will throw an `IOException` unless it is dealt with.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到文件时，如果它不是目录，则尝试读取其`BasicFileAttributes`。如果成功，将属性传递给`visitFile`方法。如果不成功，则调用`visitFileFailed`方法，并且除非处理，否则会抛出`IOException`。
- en: If the file is a directory and the directory can be opened, then the `preVisitDirectory`
    is invoked and the elements of the directory and their descendants are visited.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件是目录并且目录可以打开，则调用`preVisitDirectory`，并访问目录及其后代的元素。
- en: If the file is a directory and the directory could not be opened, the `visitFileFailed`
    method is invoked and it will throw an `IOException`. However, the depth-first
    search will continue with the next sibling.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件是目录且无法打开该目录，则将调用`visitFileFailed`方法，并将抛出`IOException`。但是，深度优先搜索将继续进行下一个兄弟节点。
- en: The following table summarizes the traversal process.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表总结了遍历过程。
- en: '| Element encountered | Can be opened | Fails to open |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 遇到的元素 | 可以打开 | 无法打开 |'
- en: '| --- | --- | --- |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| File | `visitFile` is invoked | `visitFileFailed` is invoked |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 文件 | 调用`visitFile` | 调用`visitFileFailed` |'
- en: '| Directory | `preVisitDirectory` is calledDirectory elements are processed`postVisitDirectory`
    is invoked | `visitFileFailed` is invoked |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 目录 | 调用`preVisitDirectory`目录元素被处理调用`postVisitDirectory` | 调用`visitFileFailed`
    |'
- en: 'For convenience, the enumeration constants for the enumeration `FileVisitResult`
    are listed as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为方便起见，列出了枚举`FileVisitResult`的枚举常量如下：
- en: '| Value | Meaning |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 含义 |'
- en: '| --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CONTINUE` | Continue the traversal |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `CONTINUE` | 继续遍历 |'
- en: '| `SKIP_SIBLINGS` | Continue without visiting the siblings of this file or
    directory |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `SKIP_SIBLINGS` | 继续而不访问此文件或目录的兄弟节点 |'
- en: '| `SKIP_SUBTREE` | Continue without visiting the entries in this directory
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `SKIP_SUBTREE` | 继续而不访问此目录中的条目 |'
- en: '| `TERMINATE` | Terminate |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `TERMINATE` | 终止 |'
- en: See also
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Deleting a directory using the SimpleFileVisitor class* and *Copying a
    directory using the SimpleFileVisitor class* recipes utilize the approach described
    in this recipe to delete and copy a directory respectively.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用SimpleFileVisitor类删除目录*和*使用SimpleFileVisitor类复制目录*的方法利用了本方法中描述的方法来分别删除和复制目录。'
- en: Deleting a directory using the SimpleFileVisitor class
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SimpleFileVisitor类删除目录
- en: The ability to delete a directory is a requirement of some applications. This
    can be achieved using the `walkFileTree` method and a `java.nio.file.SimpleFileVisitor`
    derived class. This recipe builds on the foundation provided in the *Using the
    SimpleFileVisitor class to traverse filesystems* recipe.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 删除目录是一些应用程序的要求。这可以通过使用`walkFileTree`方法和一个`java.nio.file.SimpleFileVisitor`派生类来实现。这个示例建立在*使用SimpleFileVisitor类遍历文件系统*示例提供的基础上。
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To delete a directory, we need to:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个目录，我们需要：
- en: Create a `Path` object representing the root directory.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个代表根目录的`Path`对象。
- en: 'Create an instance of a class derived from `SimpleFileVisitor` as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从`SimpleFileVisitor`派生的类的实例如下：
- en: Override the `visitFile` method to delete the file
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写`visitFile`方法来删除文件
- en: Override the `postVisitDirectory` method to delete the directory
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写`postVisitDirectory`方法来删除目录
- en: Use these objects as arguments to the `Files` class' `walkFileTree` method.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些对象作为参数传递给`Files`类的`walkFileTree`方法。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new console application. Here, we will delete the `home` directory
    and all of its elements. Add the following code to the `main` method:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序。在这里，我们将删除`home`目录及其所有元素。将以下代码添加到`main`方法中：
- en: '[PRE5]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `DeleteDirectory` class is shown as follows. As each file and directory
    is deleted, a message is displayed to that effect:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DeleteDirectory`类如下所示。在删除每个文件和目录时，都会显示相应的消息：'
- en: '[PRE6]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Back up the `home` directory and then execute the application. You should get
    the following output depending on the actual directory structure:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 备份`home`目录，然后执行应用程序。根据实际的目录结构，你应该会得到以下输出：
- en: '**Deleting users.bak**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除users.bak**'
- en: '**Deleting users.txt**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除users.txt**'
- en: '**Deleting docs**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除docs**'
- en: '**Deleting Future Setting A.mp3**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除Future Setting A.mp3**'
- en: '**Deleting Robot Brain A.mp3**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除Robot Brain A.mp3**'
- en: '**Deleting Space Machine A.mp3**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除Space Machine A.mp3**'
- en: '**Deleting music**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除音乐**'
- en: '**Deleting home**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除home**'
- en: Verify that the directory was deleted.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 验证目录是否已被删除。
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `main` method, we created a `Path` object representing the `home` directory.
    Next, we created an instance of the `DeleteDirectory` class. These two objects
    were used as arguments to the `walkFileTree` method, which started the traversal
    process.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`方法中，我们创建了一个代表`home`目录的`Path`对象。接下来，我们创建了`DeleteDirectory`类的一个实例。这两个对象被用作`walkFileTree`方法的参数，该方法启动了遍历过程。
- en: When a file is encountered, the `visitFile` method was executed. In this method,
    we displayed a message indicating that the file was being deleted, and then used
    the `Files` class' `delete` method to delete the file. When a directory was encountered,
    the `postVisitDirectory` method was invoked. A test was made to ensure that no
    errors had occurred, and then a message was displayed indicating that the directory
    was being deleted followed by the invocation of the `delete` method for that directory.
    Both of the methods returned `FileVisitResult.CONTINUE`, which continues the deletion
    process.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到一个文件时，`visitFile`方法被执行。在这个方法中，我们显示了一个指示文件正在被删除的消息，然后使用`Files`类的`delete`方法来删除文件。当遇到一个目录时，`postVisitDirectory`方法被调用。进行了一个测试以确保没有发生错误，然后显示了一个指示目录正在被删除的消息，随后调用了该目录的`delete`方法。这两个方法都返回了`FileVisitResult.CONTINUE`，这将继续删除过程。
- en: See also
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using the SimpleFileVisitor class to traverse filesystems* recipe provides
    more detail on the use of the `walkFileTree` method and the `SimpleFileVisitor`
    class. The *Copying a directory using the SimpleFileVisitor class* recipe also
    provides a variation of the use of this approach.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用SimpleFileVisitor类遍历文件系统*示例提供了关于使用`walkFileTree`方法和`SimpleFileVisitor`类的更多细节。*使用SimpleFileVisitor类复制目录*示例也提供了这种方法的变体。'
- en: Copying a directory using the SimpleFileVisitor class
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SimpleFileVisitor类复制目录
- en: The ability to copy a directory is a requirement of some applications. This
    can be achieved using the `walkFileTree` method and a `java.nio.file.SimpleFileVisitor`
    derived class. This recipe builds on the foundation provided in the *Using the
    SimpleFileVisitor class to traverse filesystems* recipe.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 复制目录是一些应用程序的要求。这可以通过使用`walkFileTree`方法和一个`java.nio.file.SimpleFileVisitor`派生类来实现。这个示例建立在*使用SimpleFileVisitor类遍历文件系统*示例提供的基础上。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To delete a directory, we need to:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个目录，我们需要：
- en: Create a `Path` object representing the root directory.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个代表根目录的`Path`对象。
- en: 'Create an instance of a class derived from the `SimpleFileVisitor` as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从`SimpleFileVisitor`派生的类的实例如下：
- en: Override the `visitFile` method to copy the file
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写`visitFile`方法来复制文件
- en: Override the `preVisitDirectory` method to copy the directory
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写`preVisitDirectory`方法来复制目录
- en: Use these objects as arguments to the `Files` class' `walkFileTree` method.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些对象作为参数传递给`Files`类的`walkFileTree`方法。
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new console application. Here, we will copy the `home` directory and
    all of its elements to a `backup` directory. Add the following code to the `main`
    method:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序。在这里，我们将把`home`目录及其所有元素复制到一个`backup`目录中。将以下代码添加到`main`方法中：
- en: '[PRE7]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `CopyDirectory` class is shown as follows. As each file and directory is
    deleted, a message is displayed to that effect:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CopyDirectory`类如下所示。在删除每个文件和目录时，都会显示相应的消息：'
- en: '[PRE8]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Execute the application. The exact output is dependent on the source file structure
    you used, but should be similar to the following:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。确切的输出取决于你使用的源文件结构，但应该类似于以下内容：
- en: '**Copying**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**复制**'
- en: '**Copying docs**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**复制docs**'
- en: '**Copying docs\users.bak**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**复制docs\users.bak**'
- en: '**Copying docs\users.txt**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**复制docs\users.txt**'
- en: '**Copying music**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**复制音乐**'
- en: '**Copying music\Future Setting A.mp3**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**复制music\Future Setting A.mp3**'
- en: '**Copying music\Robot Brain A.mp3**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**复制music\Robot Brain A.mp3**'
- en: '**Copying music\Space Machine A.mp3**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**复制music\Space Machine A.mp3**'
- en: How it works...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `main` method, we created `Path` objects for the `home` and `backup`
    directories. We used these objects to create a `CopyDirectory` object. We used
    a two-argument `CopyDirectory` constructor, so that its methods would have direct
    access to the two paths.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`方法中，我们为`home`和`backup`目录创建了`Path`对象。我们使用这些对象创建了一个`CopyDirectory`对象。我们使用了一个两参数的`CopyDirectory`构造函数，这样它的方法就可以直接访问这两个路径。
- en: The `walkFileTree` method was invoked with the source `Path`. It was also passed
    as the second argument, an `EnumSet`, which specified that symbolic links were
    not to be followed. This argument required a set of options. The `EnumSet` class'
    static method created the set.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用源`Path`调用了`walkFileTree`方法。它还作为第二个参数传递，一个`EnumSet`，指定不要跟随符号链接。这个参数需要一组选项。`EnumSet`类的静态方法创建了这个集合。
- en: The third argument of the `walkFileTree` method was a value indicating how many
    levels to follow. We passed a value of `Integer.MAX_VALUE`, which results in all
    of the levels of the `home` directory being copied. The last argument was an instance
    of the `CopyDirectory` object.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`walkFileTree`方法的第三个参数是一个值，表示要跟随多少级。我们传递了一个`Integer.MAX_VALUE`的值，这将导致复制`home`目录的所有级别。最后一个参数是`CopyDirectory`对象的一个实例。'
- en: When a file was encountered during the traversal, the `CopyDirectory` class'
    `visitFile` method was invoked. A message was displayed indicating that the file
    was being copied, followed by the use of the `copy` method to copy the source
    file to the target directory. The `relativize` method was used to obtain a relative
    path to the source, which was used as the argument of the `resolve` method. The
    result is a `Path` object representing the target directory with the source filename.
    These methods are discussed in the *Combining paths using path resolution* and
    *Creating a path between two locations* recipes in [Chapter 2](ch02.html "Chapter 2. Locating
    Files and Directories Using Paths"), *Locating Files and Directories Using Paths*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历过程中遇到文件时，将调用`CopyDirectory`类的`visitFile`方法。显示一个消息指示正在复制文件，然后使用`copy`方法将源文件复制到目标目录。使用`relativize`方法获取到源文件的相对路径，然后用作`resolve`方法的参数。结果是一个代表目标目录和源文件名的`Path`对象。这些方法在[第2章](ch02.html
    "第2章.使用路径定位文件和目录")的*使用路径解析组合路径*和*在两个位置之间创建路径*示例中进行了讨论，*使用路径定位文件和目录*。
- en: When a directory was encountered during the traversal, the `preVisitDirectory`
    method was invoked. It works the same way as the `visitFile` method, except we
    copied a directory instead of a file. Both of the methods returned `FileVisitResult.CONTINUE`,
    which continues the copying process. It is still necessary to copy the individual
    files of a directory, since the `copy` method only copies a single file.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当在遍历过程中遇到一个目录时，将调用`preVisitDirectory`方法。它的工作方式与`visitFile`方法相同，只是我们复制的是一个目录而不是一个文件。这两种方法都返回`FileVisitResult.CONTINUE`，这将继续复制过程。仍然需要复制目录的各个文件，因为`copy`方法只能复制单个文件。
- en: Notice that the `CopyDirectory` class extended the `SimpleFileVisitor` class
    using `Path` as the generic value. The `walkFileTree` method requires an object
    that implements the `Path` interface. Thus we had to use `Path` or an interface
    that extended `Path`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`CopyDirectory`类扩展了`SimpleFileVisitor`类，使用`Path`作为通用值。`walkFileTree`方法需要一个实现`Path`接口的对象。因此，我们必须使用`Path`或扩展`Path`的接口。
- en: See also
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using the SimpleFileVisitor class to traverse filesystems* recipe provides
    more detail on the use of the `walkFileTree` method and the `SimpleFileVisitor`
    class. The *Deleting a directory using the SimpleFileVisitor class* recipe also
    provides a variation on the use of this approach.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用SimpleFileVisitor类遍历文件系统*示例提供了更多关于`walkFileTree`方法和`SimpleFileVisitor`类的使用细节。*使用SimpleFileVisitor类删除目录*示例也提供了这种方法的变体。'
- en: Processing the contents of a directory by using the DirectoryStream interface
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`DirectoryStream`接口处理目录的内容
- en: Determining the contents of a directory is a fairly common requirement. There
    are several approaches to doing this. In this recipe, we will examine the use
    of the `java.nio.file.DirectoryStream` interface in support of this task.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 确定目录的内容是一个相当常见的需求。有几种方法可以做到这一点。在这个示例中，我们将研究使用`java.nio.file.DirectoryStream`接口来支持这个任务。
- en: A directory will consist of files or subdirectories. These files may be regular
    files or possibly linked or hidden. The `DirectoryStream` interface will return
    all of these element types. We will use the `java.nio.file.Files` class' `newDirectoryStream`
    method to obtain a `DirectoryStream` object. There are three overloaded versions
    of this method. The simplest use of the method is illustrated first. The versions
    used to filter the contents of the directory are shown in the *Filtering a directory
    using globbing* recipe and the *Writing your own directory filter* recipe.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 目录将包含文件或子目录。这些文件可能是常规文件，也可能是链接或隐藏文件。`DirectoryStream`接口将返回所有这些元素类型。我们将使用`java.nio.file.Files`类的`newDirectoryStream`方法来获取`DirectoryStream`对象。这个方法有三个重载版本。首先演示了这个方法的最简单用法。用于过滤目录内容的版本在*使用globbing过滤目录*示例和*编写自己的目录过滤器*示例中展示。
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to use the `DirectoryStream`, we need to:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`DirectoryStream`，我们需要：
- en: Obtain an instance of a `DirectoryStream` object.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`DirectoryStream`对象的实例。
- en: Iterate through the `DirectoryStream` to process its elements.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`DirectoryStream`迭代处理其元素。
- en: How to do it...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new console application and add the following `main` method. We create
    a new `DirectoryStream` object and then use a for each loop to iterate through
    the directory elements as follows:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序，并添加以下`main`方法。我们创建了一个新的`DirectoryStream`对象，然后使用for each循环来迭代目录元素，如下所示：
- en: '[PRE9]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Execute the application. Your output should reflect the contents of your `home`
    directory and should be similar to the following:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。您的输出应该反映出您的`home`目录的内容，并且应该类似于以下内容：
- en: '**docs**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**文档**'
- en: '**music**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**音乐**'
- en: How it works...
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A `Path` object was created for the `home` directory. This object was used
    with the `newDirectoryStream` method, which returned a `DirectoryStream` object
    for the directory. The `DirectoryStream` interface extends the `Iterable` interface.
    This allowed the `DirectoryStream` object to be used with a for each statement,
    which simply printed the name of each element of the `home` directory. In this
    case, there were only two subdirectories: `docs` and `music`.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为`home`目录创建了一个`Path`对象。这个对象与`newDirectoryStream`方法一起使用，该方法返回了一个目录的`DirectoryStream`对象。`DirectoryStream`接口扩展了`Iterable`接口。这允许`DirectoryStream`对象与for
    each语句一起使用，它简单地打印了`home`目录的每个元素的名称。在这种情况下，只有两个子目录：`docs`和`music`。
- en: Notice the use of the try-with-resource block. This is new to Java 7 and is
    discussed in the *Using the try-with-resource block to improve exception handling
    code* recipe found in [Chapter 1](ch01.html "Chapter 1. Java Language Improvements"),
    *Java Language Improvements*. This guarantees that the directory stream will be
    closed. If this type of try block was not used, then it is important to close
    the stream after it is no longer needed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用try-with-resource块。这是Java 7中的新功能，并在[第1章](ch01.html "第1章. Java语言改进")中的*使用try-with-resource块改进异常处理代码*中进行了讨论，*Java语言改进*。这保证了目录流将被关闭。如果没有使用这种try块，则在不再需要流之后关闭流是很重要的。
- en: 'The `Iterable` object used is not a general-purpose `iterator`. It differs
    in several important aspects as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的`Iterable`对象不是通用的`iterator`。它在几个重要方面有所不同，如下所示：
- en: It only supports a single `Iterator`
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只支持单个`Iterator`
- en: The `hasNext` method performs a read-ahead of at least one element
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasNext`方法执行至少一个元素的预读'
- en: It does not support the `remove` method
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不支持`remove`方法
- en: The `DirectoryStream` interface has a single method, `iterator`, which returns
    an `Iterator` type object. The first time the method is invoked, an `Iterator`
    object is returned. Subsequent invocation of the method will throw an `IllegalStateException`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`DirectoryStream`接口有一个方法`iterator`，它返回一个`Iterator`类型的对象。第一次调用该方法时，将返回一个`Iterator`对象。对该方法的后续调用将抛出`IllegalStateException`。'
- en: The `hasNext` method will read ahead by at least one element. If the method
    returns `true`, then the next invocation of its next method is guaranteed to return
    an element. The order of the elements returned is not specified. Also, many operating
    systems have links to themselves and/or their parent as represented by a `".`"
    or `"..`" in many shells. These entries are not returned.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasNext`方法将至少提前读取一个元素。如果该方法返回`true`，则对其next方法的下一次调用将保证返回一个元素。返回的元素的顺序没有指定。此外，许多操作系统在许多shell中以`"."`或`"..`"表示对自身和/或其父级的链接。这些条目不会被返回。'
- en: The `iterator` returned is sometimes referred to as **weakly consistent**. This
    means that while the `iterator` is thread-safe, any updates to the directory after
    the `iterator` has returned will not result in a change to the `iterator`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterator`有时被称为**弱一致**。这意味着虽然`iterator`是线程安全的，但在`iterator`返回后对目录的任何更新都不会导致`iterator`的更改。'
- en: There's more...
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are two overloaded `newDirectoryStream` methods, which allow the results
    of the method to be filtered either by a globbing pattern or a `DirectoryStream.Filter`
    object. A **globbing pattern** is a string containing a series of characters that
    define a pattern. The pattern is used to determine which directory elements to
    return. A `DirectoryStream.Filter` interface has a single method, `accept`, which
    returns a Boolean value indicating whether the directory element should be returned
    or not.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个重载的`newDirectoryStream`方法，允许该方法的结果通过通配符模式或`DirectoryStream.Filter`对象进行过滤。**通配符模式**是一个包含一系列字符的字符串，用于定义模式。该模式用于确定要返回哪些目录元素。`DirectoryStream.Filter`接口有一个方法`accept`，它返回一个布尔值，指示是否应返回目录元素。
- en: See also
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Filtering a directory using globbing* recipe illustrates the use of the
    globbing pattern. The *Writing your own directory filter* recipe shows how to
    create and use a `DirectoryStream.Filter` object to filter the contents of a directory.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用通配符过滤目录*示例说明了通配符模式的使用。*编写自己的目录过滤器*示例展示了如何创建和使用`DirectoryStream.Filter`对象来过滤目录的内容。'
- en: Filtering a directory using globbing
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通配符过滤目录
- en: A globbing pattern is similar to a regular expression but it is simpler. Like
    a regular expression it can be used to match specific character sequences. We
    can use globbing in conjunction with the `newDirectoryStream` method to filter
    the contents of a directory. The use of this method is demonstrated in the *Using
    the DirectoryStream interface to process the contents of a directory* recipe.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符模式类似于正则表达式，但更简单。与正则表达式一样，它可以用于匹配特定的字符序列。我们可以将通配符与`newDirectoryStream`方法结合使用，以过滤目录的内容。该方法的使用在*使用DirectoryStream接口处理目录的内容*示例中进行了演示。
- en: Getting ready
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To use this technique we need to:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这种技术，我们需要：
- en: Create a globbing string that meets our filtering requirements.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个符合我们过滤要求的globbing字符串。
- en: Create a `java.nio.file.Path` object for the directory of interest.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为感兴趣的目录创建一个`java.nio.file.Path`对象。
- en: Use these two objects as arguments to the `newDirectoryStream` method.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这两个对象用作`newDirectoryStream`方法的参数。
- en: How to do it...
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new console application and use the following `main` method. In this
    example, we will list only those directory elements that start with `java` and
    end with `.exe`. We will use the Java 7 `bin` directory. The `globbing` string
    uses the special character, `*` to represent zero or more characters as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序，并使用以下`main`方法。在这个例子中，我们将只列出那些以`java`开头并以`.exe`结尾的目录元素。我们将使用Java
    7的`bin`目录。`globbing`字符串使用特殊字符`*`来表示零个或多个字符，如下所示：
- en: '[PRE10]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Execute the application. The output should be similar to the following:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。输出应该类似于以下内容：
- en: '**java-rmi.exe**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**java-rmi.exe**'
- en: '**java.exe**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**java.exe**'
- en: '**javac.exe**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**javac.exe**'
- en: '**javadoc.exe**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**javadoc.exe**'
- en: '**javah.exe**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**javah.exe**'
- en: '**javap.exe**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**javap.exe**'
- en: '**javaw.exe**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**javaw.exe**'
- en: '**javaws.exe**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**javaws.exe**'
- en: How it works...
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, a `Path` object representing the `bin` directory was created. It was
    then used as the first argument to the `newDirectoryStream` method. The second
    argument was the `globbing` string. In this case, it matched a directory element
    which started with `java` and ended with `.exe`. Any number of intermediate characters
    were allowed. A for each loop was then used to display the filtered files.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建了一个代表`bin`目录的`Path`对象。然后将其用作`newDirectoryStream`方法的第一个参数。第二个参数是`globbing`字符串。在这种情况下，它匹配以`java`开头并以`.exe`结尾的目录元素。允许任意数量的中间字符。然后使用for
    each循环显示过滤后的文件。
- en: There's more...
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Globbing strings are based on patterns, which use special characters to match
    string sequences. These are defined in the documentation for the `Files` class''
    `getPathMatcher` method. Here, we will examine those strings in more depth. There
    are several special characters summarized in the following table:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Globbing字符串基于模式，使用特殊字符来匹配字符串序列。这些特殊字符在`Files`类的`getPathMatcher`方法的文档中定义。在这里，我们将更深入地研究这些字符串。以下表格总结了几个特殊字符：
- en: '| Special Symbols | Meaning |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 特殊符号 | 意义 |'
- en: '| --- | --- |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| * | Matches zero or more characters of a name component without crossing
    directory boundaries |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| * | 匹配不跨越目录边界的名称组件的零个或多个字符 |'
- en: '| ** | Matches zero or more characters crossing directory boundaries |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| ** | 匹配跨越目录边界的零个或多个字符 |'
- en: '| ? | Matches exactly one character of a name component |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| ? | 匹配名称组件的一个字符 |'
- en: '| \ | The escape character used to match the special symbols |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| \ | 用于匹配特殊符号的转义字符 |'
- en: '| [ ] | Matches a single character found within the brackets. A - matches a
    range. A ! means negation. The *, ?, and \ characters match themselves, and a
    - matches itself if it is the first character within the brackets or the first
    character after the !. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| [ ] | 匹配括号内找到的单个字符。A - 匹配一个范围。!表示否定。*、?和\字符匹配它们自己，-如果是括号内的第一个字符或!后的第一个字符，则匹配它自己。
    |'
- en: '| { } | Multiple subpatterns can be specified at the same time. These patterns
    are grouped together using the curly braces, but are separated within the curly
    braces by commas. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| { } | 可以同时指定多个子模式。这些模式使用花括号分组在一起，但在花括号内部用逗号分隔。 |'
- en: Matching is typically performed in an implementation-dependent manner. This
    includes whether matching is case sensitive or not. The `**` symbol is not applicable
    here, since the `newDirectoryStream` method returns individual elements. There
    is no opportunity here to match sequences that cross directory boundaries. Other
    methods will use this capability.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配通常以实现相关的方式执行。这包括匹配是否区分大小写。`**`符号在这里不适用，因为`newDirectoryStream`方法返回单独的元素。在这里没有机会匹配跨越目录边界的序列。其他方法将使用这种能力。
- en: 'The following table presents several examples of potentially useful globbing
    patterns:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了几个可能有用的glob模式示例：
- en: '| Globbing String | Will Match |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| Globbing字符串 | 将匹配 |'
- en: '| --- | --- |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `*.java` | Any filename that ends with `.java` |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `*.java` | 以`.java`结尾的任何文件名 |'
- en: '| `*.{java,class,jar}` | Any file that ends with `.java, .class`, or `.jar`
    |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `*.{java,class,jar}` | 以`.java, .class`或`.jar`结尾的任何文件 |'
- en: '| `java*[ph].exe` | Only those files that start with java and are terminated
    with either a `p.exe` or `h.exe` |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `java*[ph].exe` | 仅匹配以java开头并以`p.exe`或`h.exe`结尾的文件 |'
- en: '| `j*r.exe` | Those files that start with a `j` and end with an `r.exe` |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `j*r.exe` | 以`j`开头并以`r.exe`结尾的文件 |'
- en: Now, let's discuss the use of the `PathMatcher` interface.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论`PathMatcher`接口的使用。
- en: Using the PathMatcher interface to filter a directory
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用PathMatcher接口来过滤目录
- en: The `java.nio.file.PathMatcher` interface provides a method of matching a filename
    using a **glob**. It has a single method `matches`, which accepts a `Path` argument.
    If the file matches the glob pattern, then it returns `true`. Otherwise, it returns
    `false`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio.file.PathMatcher`接口提供了使用**glob**匹配文件名的方法。它有一个名为`matches`的方法，接受一个`Path`参数。如果文件与glob模式匹配，则返回`true`。否则返回`false`。'
- en: 'In the following code sequence, we modify the previous example by creating
    a `PathMatcher` object using the glob pattern: `glob:java?.exe`. Within the for
    loop, we use the `matches` method to further filter a subset of the file that
    starts with `java` and is followed by a single character and then ends with `.exe:`'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码序列中，我们通过使用glob模式`glob:java?.exe`创建了一个`PathMatcher`对象。在for循环中，我们使用`matches`方法进一步过滤以`java`开头，后跟一个字符，然后以`.exe`结尾的文件的子集：
- en: '[PRE11]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When you execute this sequence, you should get the following output:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行此序列时，您应该得到以下输出：
- en: '**javac.exe**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**javac.exe**'
- en: '**javah.exe**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**javah.exe**'
- en: '**javap.exe**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**javap.exe**'
- en: '**javaw.exe**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**javaw.exe**'
- en: Notice the use of the **glob:** prefix used with the `matches` method. Its use
    is required with this method, but not with the `newDirectoryStream` method. Also,
    the `matches` method takes a `Path` argument. However, notice that we used the
    `String` returned from the `Path` class' `getFileName` method. Using the `Path`
    object only or using a `String` literal does not work.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`matches`方法中使用的**glob:**前缀。这种方法需要使用这个前缀，但`newDirectoryStream`方法不需要。此外，`matches`方法接受一个`Path`参数。但是，请注意我们使用了从`Path`类的`getFileName`方法返回的`String`。仅使用`Path`对象或使用`String`文字均不起作用。
- en: 'Instead of using the glob: prefix, we can use regular expressions instead.
    To do this, use a **reg:** prefix followed by a regular expression.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用glob:前缀不同，我们可以改用正则表达式。为此，请使用**reg:**前缀，后跟正则表达式。
- en: Normally, for a simple filtering of a directory, we would use the more restrictive
    glob pattern as part of the `newDirectoryStream` method. We used it here for illustrative
    purposes. However, if we wanted to perform more than one filtering operation as
    part of a loop, then using a pattern as part of the `newDirectoryStream` method,
    and later with the use of one or more `matches` method invocations is a viable
    strategy.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于简单的目录过滤，我们会在`newDirectoryStream`方法中使用更严格的glob模式。我们在这里使用它是为了举例说明。然而，如果我们想要在循环的一部分执行多个过滤操作，那么使用模式作为`newDirectoryStream`方法的一部分，然后使用一个或多个`matches`方法调用是一种可行的策略。
- en: See also
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Writing your own directory filter* recipe explores how to create more powerful
    filters to match filenames based on attributes other than the filename.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*编写自己的目录过滤器*配方探讨了如何创建更强大的过滤器，以匹配基于文件名以外的属性的文件名。'
- en: Writing your own directory filter
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自己的目录过滤器
- en: A directory filter is used to control which directory elements are returned,
    when using the `java.nio.file.Files` class' `newDirectoryStream` method. This
    is useful when we need to limit the stream's output. For example, we may only
    be interested in those files that exceed a certain size or were last modified
    after a certain date. The `java.nio.file.DirectoryStream.Filter` interface, as
    described in this recipe will restrict the stream's output. It is more powerful
    than using globbing as described in the *Filtering a directory using globbing*
    recipe because decisions can be based on factors other than the filename.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`java.nio.file.Files`类的`newDirectoryStream`方法时，目录过滤器用于控制返回哪些目录元素。当我们需要限制流的输出时，这是很有用的。例如，我们可能只对超过一定大小或在某个日期后修改的文件感兴趣。正如本配方中描述的`java.nio.file.DirectoryStream.Filter`接口，它将限制流的输出。它比使用globbing更强大，因为决策可以基于文件名以外的因素。
- en: Getting ready
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To use this technique we need to:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这种技术，我们需要：
- en: Create a `DirectoryStream.Filter` object that meets our filtering requirements.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个满足我们过滤要求的`DirectoryStream.Filter`对象。
- en: Create a `Path` object for the directory of interest.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为感兴趣的目录创建一个`Path`对象。
- en: Use these two objects as arguments to the `newDirectoryStream` method.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这两个对象作为`newDirectoryStream`方法的参数。
- en: How to do it...
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new console application and add the following sequence to the `main`
    method. In this example, we will filter out only those directory elements that
    are hidden. We will use the Windows system directory. However, any other appropriate
    directory will work:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序，并将以下序列添加到`main`方法中。在这个例子中，我们将只过滤出那些隐藏的目录元素。我们将使用Windows系统目录。然而，任何其他适当的目录都可以工作：
- en: '[PRE12]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When executed, your output should list only those files that are hidden. The
    following is one possible output:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行时，您的输出应该只列出那些隐藏的文件。以下是一个可能的输出：
- en: '**SwSys1.bmp**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**SwSys1.bmp**'
- en: '**SwSys2.bmp**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**SwSys2.bmp**'
- en: '**WindowsShell.Manifest**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**WindowsShell.Manifest**'
- en: How it works...
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: First, we created an anonymous inner class to define an object that implements
    the `DirectoryStream.Filter` interface. In the `accept` method, the `isHidden`
    method was used to determine whether the element file was hidden or not. The `DirectoryStream.Filter`
    interface used its `accept` method to determine whether a directory element should
    be returned or not. This method returned either a `true` or a `false` indicating
    whether the element should or should not be returned by the `newDirectoryStream`
    method, respectively. Thus, it filters out the **undesirables**, which in this
    case were non-hidden elements. A for each loop was used to display the hidden
    elements. When the `filter` variable was declared, it was declared using `Path`
    as its generic value. Interfaces that extended the `Path` interface could also
    be used.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个匿名内部类来定义一个实现`DirectoryStream.Filter`接口的对象。在`accept`方法中，使用`isHidden`方法来确定元素文件是否隐藏。`DirectoryStream.Filter`接口使用其`accept`方法来确定是否应该返回目录元素。该方法返回`true`或`false`，指示`newDirectoryStream`方法是否应该返回该元素。因此，它过滤掉了不需要的元素，这种情况下是非隐藏元素。使用for
    each循环来显示隐藏元素。当声明`filter`变量时，它是使用`Path`作为其泛型值声明的。扩展`Path`接口的接口也可以使用。
- en: See also
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: This technique filters a single directory. If more than one directory needs
    to be filtered, then the example used in the *Using the SimpleFileVisitor class
    to traverse filesystems* recipe can be adapted to address multiple directories.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术过滤单个目录。如果需要过滤多个目录，则可以根据*使用SimpleFileVisitor类遍历文件系统*配方中使用的示例来适应多个目录。
- en: Monitoring file events using WatchEvents
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WatchEvents监视文件事件
- en: When an application needs to be aware of changes in a directory, a watch service
    can listen to the changes and then inform the application of these changes. The
    service will register a directory to be monitored based on the type of event that
    is of interest. When the event occurs, a watch event is queued and can subsequently
    be processed as dictated by the needs of the application.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序需要了解目录中的更改时，监视服务可以监听这些更改，然后通知应用程序这些更改。服务将根据感兴趣的事件类型注册要监视的目录。事件发生时，将排队一个监视事件，随后可以根据应用程序的需求进行处理。
- en: Getting ready
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To monitor a directory for events, we need to do the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要监视目录的事件，我们需要执行以下操作：
- en: Create a `java.nio.file.Path` object representing the directory.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个代表目录的`java.nio.file.Path`对象。
- en: Create a new watch service using the `java.nio.file.FileSystem` class' `newWatchService`
    method.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`java.nio.file.FileSystem`类的`newWatchService`方法创建一个新的监视服务。
- en: Determine which events we are interested in monitoring.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定我们感兴趣监视的事件。
- en: Register the directory and events with the watch service.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用监视服务注册目录和事件。
- en: Process the events as they occur.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理事件发生时的事件。
- en: How to do it...
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new console application. We will add code to the `main` method to
    create a watch service, determine the events we want to watch, register the `docs`
    directory with the service, and then process the events. Let''s start by creating
    the watch service and a `Path` object for the directory. Add the following code
    to the `main` method:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序。我们将在`main`方法中添加代码来创建一个观察服务，确定我们想要观察的事件，将`docs`目录注册到服务中，然后处理事件。让我们从创建观察服务和目录的`Path`对象开始。将以下代码添加到`main`方法中：
- en: '[PRE13]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, create an array of watch events to monitor for file creation, deletion,
    and modification as follows:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个监视文件创建、删除和修改的事件数组，如下所示：
- en: '[PRE14]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following while loop to monitor and process any directory events:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下while循环以监视和处理任何目录事件：
- en: '[PRE15]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Execute the application. You should get the following output:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。您应该得到以下输出：
- en: '**Waiting for a watch event**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 等待观察事件
- en: 'Using a text editor, create a new file called `temp.txt` and save it in the
    `docs` directory. The application should then display output similar to the following.
    Your output may differ if this is the first time you created the file in the directory.
    These entries indicate that the file has been created and its contents are then
    saved:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用文本编辑器，在`docs`目录中创建一个名为`temp.txt`的新文件并保存。然后应用程序应该显示类似以下的输出。如果这是您第一次在目录中创建文件，则您的输出可能会有所不同。这些条目表示文件已被创建，其内容随后被保存：
- en: '**Path being watched: \home\docs**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 正在观察的路径：\home\docs
- en: '**Kind: ENTRY_CREATE**'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：ENTRY_CREATE
- en: '**Context: temp.txt**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文：temp.txt
- en: '**Count: 1**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 计数：1
- en: '**Waiting for a watch event**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 等待观察事件
- en: '**Path being watched: \home\docs**'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 正在观察的路径：\home\docs
- en: '**Kind: ENTRY_MODIFY**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：ENTRY_MODIFY
- en: '**Context: temp.txt**'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文：temp.txt
- en: '**Count: 2**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 计数：2
- en: '**Waiting for a watch event**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 等待观察事件
- en: 'Next, save the file again. You should now get the following output:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，再次保存文件。现在您应该得到以下输出：
- en: '**Path being watched: \home\docs**'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 正在观察的路径：\home\docs
- en: '**Kind: ENTRY_MODIFY**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：ENTRY_MODIFY
- en: '**Context: temp.txt**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文：temp.txt
- en: '**Count: 1**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 计数：1
- en: '**Waiting for a watch event**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 等待观察事件
- en: 'From file manager, delete the file. Your output should reflect its deletion:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件管理器中删除文件。您的输出应该反映出它的删除：
- en: '**Kind: ENTRY_DELETE**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：ENTRY_DELETE
- en: '**Context: temp1.txt**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文：temp1.txt
- en: '**Count: 1**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 计数：1
- en: '**Waiting for a watch event**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 等待观察事件
- en: How it works...
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first thing we needed was a `WatchService` object. This was acquired by
    obtaining the default filesystem and then applying the `newWatchService` method
    to it. Next, we created a `Path` object representing the `docs` directory and
    an array of events that cover creation, deletion, and modification type events.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的第一件事是一个`WatchService`对象。这是通过获取默认文件系统，然后对其应用`newWatchService`方法来获得的。接下来，我们创建了一个代表`docs`目录的`Path`对象和一个涵盖创建、删除和修改类型事件的事件数组。
- en: An infinite loop was then entered to monitor and handle file events that occur
    in the `docs` directory. The loop started by displaying a message indicating that
    it was waiting for events. The `WatchService` class' `take` method was executed.
    This method will block until an event occurs.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 然后进入了一个无限循环，以监视和处理`docs`目录中发生的文件事件。循环开始时显示一个消息，指示它正在等待事件。执行了`WatchService`类的`take`方法。此方法将阻塞，直到发生事件。
- en: When an event occurred, it returned with a `WatchKey` object, which contained
    information about the event. Its `watchable` method returned the object being
    watched, which was then displayed for informational purposes.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件发生时，它返回一个`WatchKey`对象，其中包含有关事件的信息。它的`watchable`方法返回被观察的对象，然后为了信息目的而显示。
- en: The watch key was verified to be valid using the `isValid` method, and its `pollEvents`
    method was used as part of a for each loop. The `pollEvents` method returned a
    list of all pending events. The type, context, and count value associated with
    the event were displayed.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`isValid`方法验证了观察键的有效性，并且它的`pollEvents`方法被用作for each循环的一部分。`pollEvents`方法返回所有待处理事件的列表。显示了与事件相关的类型、上下文和计数值。
- en: The context for the events that we monitored was the relative path between the
    target directory and the entry that caused the event. The count value depends
    on the event and is addressed in the next section.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们监视的事件的上下文是目标目录和引起事件的条目之间的相对路径。计数值取决于事件，并在下一节中讨论。
- en: The last activity reset the watch key. This was needed to put the key back into
    a ready state until it is needed again. If the method returned `false`, then the
    key is no longer valid.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的活动重置了观察键。这是为了将键重新置于就绪状态，直到再次需要它。如果方法返回`false`，则键不再有效。
- en: There's more...
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `WatchService` interface possesses methods to get a watch key and to close
    the service. The `poll` and `take` methods retrieve the next watch key as we saw
    earlier. The `poll` method will return `null` if there are none present. However,
    the `take` method will block until a watch key is available. There is an overloaded
    `poll` method that takes additional arguments to specify how long to wait for
    an event before returning. These arguments include a time out value and a `TimeUnit`
    value. The use of the `TimeUnit` enumeration is discussed in the *Understanding
    the FileTime class section of the Setting time related attributes of a file or
    directory* recipe in [Chapter 4](ch04.html "Chapter 4. Managing Files and Directories"),
    *Managing Files and Directories*.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`WatchService`接口具有获取观察键和关闭服务的方法。`poll`和`take`方法检索下一个观察键，就像我们之前看到的那样。如果没有观察键存在，`poll`方法将返回`null`。但是，`take`方法将阻塞，直到观察键可用。有一个重载的`poll`方法，它接受额外的参数来指定在返回之前等待事件的时间。这些参数包括超时值和`TimeUnit`值。`TimeUnit`枚举的使用在[第4章](ch04.html
    "第4章。管理文件和目录")的*理解FileTime类部分*中讨论，*管理文件和目录*。'
- en: 'The `Path` class'' `register` method will register a file specified by the
    `Path` object that it is executing against. The method takes arguments that:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`类的`register`方法将注册由其执行的`Path`对象指定的文件。该方法接受参数：'
- en: Specify the watch service
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定监视服务
- en: The kind of events it is to monitor
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要监视的事件类型
- en: Modifiers that determine how the `Path` object is registered
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定`Path`对象注册方式的修饰符
- en: The `WatchEvent.Modifier` interface specifies how a `Path` object is to be registered
    with a watch service. In this release of Java, there are no defined modifiers.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`WatchEvent.Modifier`接口指定了如何使用监视服务注册`Path`对象。在此版本的Java中，没有定义修饰符。'
- en: 'The `java.nio.file.StandardWatchEventKinds` class defines the standard event
    types. The fields of this interface are summarized in the following table:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio.file.StandardWatchEventKinds`类定义了标准事件类型。此接口的字段总结在以下表中：'
- en: '| Kind | Meaning | Count |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 含义 | 计数 |'
- en: '| --- | --- | --- |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ENTRY_CREATE` | Directory entry created | Always a 1 |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| `ENTRY_CREATE` | 创建目录条目 | 总是1 |'
- en: '| `ENTRY_DELETE` | Directory entry deleted | Always a 1 |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| `ENTRY_DELETE` | 删除目录条目 | 总是1 |'
- en: '| `ENTRY_MODIFY` | Directory entry modified | 1 or greater |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `ENTRY_MODIFY` | 修改目录条目 | 大于1 |'
- en: '| `OVERFLOW` | A special event to indicate that events may have been lost or
    discarded | Greater than 1 |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| `OVERFLOW` | 表示事件可能已丢失或被丢弃的特殊事件 | 大于1 |'
- en: When an event occurs, the watch service will return a `WatchKey` object representing
    the event. This key is reused for multiple occurrences of the same event type.
    When an event of that type occurs, the count associated with the event is incremented.
    If multiple events of that type occur before the events are processed, the count
    value is incremented each time by some amount. The amount is dependent on the
    type of event.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件发生时，监视服务将返回一个代表事件的`WatchKey`对象。此键用于同一类型事件的多次发生。当发生该类型的事件时，与事件关联的计数将增加。如果在处理事件之前发生了该类型的多个事件，则每次增加的计数值取决于事件类型。
- en: The use of the `reset` method in the previous example will re-queue the watch
    key and reset the count to zero. For repeated events, the context is the same.
    Each directory entry will have its own watch key for that event type.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中使用`reset`方法将重新排队监视键并将计数重置为零。对于重复事件，上下文是相同的。每个目录条目将为该事件类型拥有自己的监视键。
- en: An event can be canceled using the `WatchKey` interface's `cancel` method. This
    will unregister the event with the watch service. Any pending events in the queue
    will remain in the queue until removed. Watch events are also canceled if the
    watch service is closed.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`WatchKey`接口的`cancel`方法取消事件。这将取消事件在监视服务中的注册。队列中的任何待处理事件将保留在队列中，直到被移除。如果监视服务关闭，监视事件也将被取消。
- en: The watch service is thread-safe. This implies that if multiple threads are
    accessing events, then care should be taken when using the `reset` method. The
    method should not be used until all of the threads using that event have completed
    processing the event.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 监视服务是线程安全的。这意味着如果多个线程正在访问事件，那么在使用`reset`方法时应该小心。在所有使用该事件的线程完成处理事件之前，不应该使用该方法。
- en: The watch service can be closed using the `close` method. If multiple threads
    are using this service, then subsequent attempts to retrieve a watch key will
    result in a `ClosedWatchServiceException`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`close`方法关闭监视服务。如果多个线程正在使用此服务，那么后续尝试检索监视键将导致`ClosedWatchServiceException`。
- en: A filesystem may be able to report events faster than the watch service can
    handle them. Some implementations of a watch service may impose a limit of the
    number of events queued. When events are intentionally ignored, then an event
    of the type `OVERFLOW` is used to report this problem. Overflow events are automatically
    registered for a target. The context of an overflow event is implementation-dependent.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统可能能够比监视服务更快地报告事件。一些监视服务的实现可能会对排队的事件数量施加限制。当有意忽略事件时，将使用`OVERFLOW`类型的事件来报告此问题。溢出事件会自动为目标注册。溢出事件的上下文取决于实现。
- en: 'Many aspects of the watch service are implementation-dependent including:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 监视服务的许多方面都依赖于实现，包括：
- en: Whether a native event notification service is used or simulated
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否使用本机事件通知服务或模拟
- en: How timely the events are enqueued
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件被排队的及时性
- en: The order in which events are handled
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理事件的顺序
- en: Whether short-lived events are even reported
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否报告短暂事件
- en: Understanding the ZIP filesystem provider
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解ZIP文件系统提供程序
- en: Handling ZIP files is much simpler than it was prior to Java 7\. The ZIP filesystem
    provider introduced in this release handles ZIP and JAR files as though they were
    filesystems and, as a result, you can easily access the contents of the file.
    You can manipulate the file as you would do ordinary files, including copying,
    deleting, moving, and renaming the file. You also have the ability to modify certain
    attributes of the file. This recipe will show you how to create an instance of
    a ZIP filesystem and add directories to the system.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 处理ZIP文件比Java 7之前要简单得多。在这个版本中引入的ZIP文件系统提供程序处理ZIP和JAR文件，就好像它们是文件系统一样，因此您可以轻松访问文件的内容。您可以像处理普通文件一样操作文件，包括复制、删除、移动和重命名文件。您还可以修改文件的某些属性。本教程将向您展示如何创建ZIP文件系统的实例并向系统添加目录。
- en: Getting ready
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We must first create an instance of a `java.net.URI` object to represent our
    ZIP file, and then create the new `java.nio.file.FileSystem` before we can do
    any manipulations of the contents of the ZIP file. In this example, we will also
    use a `java.util.HashMap` to set an optional property of the `FileSystem` as follows:.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须首先创建一个`java.net.URI`对象的实例来表示我们的ZIP文件，然后创建新的`java.nio.file.FileSystem`，然后才能对ZIP文件的内容进行任何操作。在这个例子中，我们还将使用`java.util.HashMap`来设置`FileSystem`的可选属性如下：。
- en: Create a `URI` object to represent the ZIP file.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`URI`对象来表示ZIP文件。
- en: Create a `HashMap` object to specify the `create` property as `true`.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`HashMap`对象来指定`create`属性为`true`。
- en: Create a `FileSystem` object using the `newFileSystem` method.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`newFileSystem`方法创建`FileSystem`对象。
- en: How to do it...
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a console application with a `main` method. In the `main` method, add
    the following code sequence. We will create a new filesystem within a ZIP file,
    and then add a directory to it as follows:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有“main”方法的控制台应用程序。在“main”方法中，添加以下代码序列。我们将在ZIP文件中创建一个新的文件系统，然后将一个目录添加到其中，如下所示：
- en: '[PRE16]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Execute the program. Your output should appear as follows:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行程序。您的输出应如下所示：
- en: '**docs/**'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**docs/**'
- en: How it works...
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `URI` object specifies the location of your ZIP file by using a `HashMap`
    object, we specified that if the ZIP file does not exist, it should be created.
    The `FileSystem` object, `zipFileSys`, was created in the try-with-resources block,
    so the resource will automatically be closed, but if you do not wish to use the
    nested try-with-resources block you must use the `FileSystem` class'' `close`
    method to close the resource manually. The try-with-resources block is detailed
    in [Chapter 1](ch01.html "Chapter 1. Java Language Improvements"), *Java Language
    Improvements*, recipe: *Using the try-with-resources block to improve exception
    handling code*.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: “URI”对象通过使用“HashMap”对象指定了ZIP文件的位置，我们指定如果ZIP文件不存在，它应该被创建。“FileSystem”对象“zipFileSys”是在try-with-resources块中创建的，因此资源将自动关闭，但如果您不希望使用嵌套的try-with-resources块，您必须使用“FileSystem”类的“close”方法手动关闭资源。try-with-resources块在[第1章](ch01.html
    "第1章。Java语言改进")中有详细介绍，*Java语言改进*，配方：*使用try-with-resources块改进异常处理代码*。
- en: To demonstrate how ZIP files can be manipulated as `FileSystem` objects, we
    invoked the `createDirectory` method to add a folder within our ZIP file. At this
    point, we also had the option to perform other `FileSystem` operations, such as
    copying files, renaming files, and deleting files. We used a `java.nio.file.DirectoryStream`
    to navigate through our ZIP file structure and print out our `docs` directory,
    but you can also navigate on your computer to the location of the ZIP file to
    verify its creation.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何将ZIP文件作为“FileSystem”对象进行操作，我们调用了“createDirectory”方法在我们的ZIP文件中添加了一个文件夹。在这一点上，我们还有选择执行其他“FileSystem”操作的选项，比如复制文件、重命名文件和删除文件。我们使用了一个“java.nio.file.DirectoryStream”来浏览我们的ZIP文件结构并打印出我们的“docs”目录，但您也可以在计算机上导航到ZIP文件的位置来验证其创建。
- en: See also
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the *Using the DirectoryStream interface to process the contents of a directory*
    recipe for more information on the `DirectoryStream` class.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 有关“DirectoryStream”类的更多信息，请参阅*使用DirectoryStream接口处理目录的内容*配方。
