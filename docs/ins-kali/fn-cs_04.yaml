- en: Chapter 4. Extending Object Functionality with Extension Methods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用扩展方法扩展对象功能
- en: 'As we have already mentioned in the previous chapter, we are going to discuss
    extension methods in greater detail in this chapter. It will be helpful when we
    talk about LINQ, the essential technique of functional programming in C#, in the
    next chapter. The following are the topics we will cover in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中已经提到的，我们将在本章中更详细地讨论扩展方法。当我们在下一章中讨论LINQ时，这将是有帮助的，LINQ是C#中函数式编程的基本技术。以下是本章我们将涵盖的主题：
- en: Practicing the use of extension methods and getting this new method in IntelliSense
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习使用扩展方法并在IntelliSense中获得这个新方法
- en: Invoking extension methods from other assemblies
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其他程序集调用扩展方法
- en: Creating new methods for an interface, collection, enumeration, and other objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为接口、集合、枚举和其他对象创建新方法
- en: The advantages of extension methods in relation to functional programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与函数式编程相关的扩展方法的优势
- en: The limitations of extension methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展方法的限制
- en: Getting closer to extension methods
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接近扩展方法
- en: An extension method is a capability that can extend the ability of an existing
    class or type without making any modification to the existing class or type. This
    means that an extension method enables us to add methods to the existing class
    or type without having to either create a new derived type or recompile.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法是一种能够扩展现有类或类型的能力，而不对现有类或类型进行任何修改。这意味着扩展方法使我们能够向现有类或类型添加方法，而无需创建新的派生类型或重新编译。
- en: Extension methods were introduced in C# 3.0 and can be applied to our own types
    or existing types in .NET. The extension method will be used a lot in functional
    programming since it suits the method chaining concept, which we have already
    used in [Chapter 1](text00016.html#ch01 "Chapter 1. Tasting Functional Style in
    C#") , *Tasting Functional Style in C#* , when refactoring code in a functional
    style.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法是在C# 3.0中引入的，可以应用于我们自己的类型或.NET中现有的类型。扩展方法在函数式编程中将被广泛使用，因为它符合方法链的概念，我们在[第1章](text00016.html#ch01
    "第1章。在C#中品尝函数式风格")中已经使用了*在C#中品尝函数式风格*，在以函数式风格重构代码时。
- en: Creating an extension method
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建扩展方法
- en: 'Extension methods have to be declared in a static, nongeneric, and non-nested
    class. They are a static method inside a static class. To create an extension
    method, first we have to create a `public static` class since the extension methods
    have to be included in the `static` class. After the `public static` class is
    successfully created, we define a method inside the class and add the `this` keyword
    to the first method argument to indicate that it is an `extension` method. The
    first argument in the method that has the `this` keyword has to refer to a specific
    instance of the class we want to extend. In order to make the explanation clearer,
    let''s take a look at the following code, creating a extension method that we
    can find in the `Palindrome.csproj` project:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法必须声明在一个静态、非泛型和非嵌套的类中。它们是静态类中的静态方法。要创建扩展方法，首先我们必须创建一个`public static`类，因为扩展方法必须包含在`static`类中。成功创建`public
    static`类后，我们在类中定义一个方法，并在第一个方法参数中添加`this`关键字，以指示它是一个`扩展`方法。具有`this`关键字的方法中的第一个参数必须引用我们要扩展的类的特定实例。为了使解释更清晰，让我们看一下以下代码，创建一个扩展方法，我们可以在`Palindrome.csproj`项目中找到：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now let''s dissect the preceding code to understand how the extension method
    is created. First, we have to successfully create the `public static` class, as
    shown in the following code snippet:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们解剖上述代码，以了解如何创建扩展方法。首先，我们必须成功创建`public static`类，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we create a `static` method inside the class, as shown in the following
    code snippet:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在类中创建一个`static`方法，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As we can see in the preceding method, we add the `this` keyword in the first
    argument of the method. This indicates that the method is an `extension` method.
    Also, the type of the first argument, which is string, indicates that the type
    we want to extend is the `string` data type. Now, by defining the `IsPalindrome()`
    extension method for the `string` type, all instances of string have the `IsPalindrome()`
    method. Let''s take a look at the following code to prove this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的方法中所看到的，我们在方法的第一个参数中添加了`this`关键字。这表明该方法是一个`扩展`方法。此外，第一个参数的类型，即字符串，表示我们要扩展的类型是`string`数据类型。现在，通过为`string`类型定义`IsPalindrome()`扩展方法，所有字符串实例都具有`IsPalindrome()`方法。让我们看一下以下代码来证明这一点：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding `Main()` function will examine all members of the `strArray`
    array, whether or not it is palindrome. We can call the `IsPalindrome()` method
    from the `s` variable in which it''s a `string` type variable. The code snippet
    when the `IsPalindrome()` method is invoked from an instance of the string type
    is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的`Main()`函数将检查`strArray`数组的所有成员，无论它是否是回文。我们可以从`string`类型的变量`s`中调用`IsPalindrome()`方法。当从字符串类型的实例调用`IsPalindrome()`方法时，代码片段如下：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we run the `Palindrome.csproj` project, we can get the following output
    on the console:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`Palindrome.csproj`项目，我们可以在控制台上获得以下输出：
- en: '![Creating an extension method](img/Image00037.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![创建扩展方法](img/Image00037.jpg)'
- en: Since the palindrome is a word or another sequence of characters that will be
    the same whether we read backward or forward, only `level` , `madam` , and `radar`
    will return `true` if we invoke the `IsPalindrome()` method to them. Our extension
    method has been successfully created and run.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于回文是一个单词或另一个字符序列，无论我们是向后读还是向前读，只有`level`，`madam`和`radar`如果我们对它们调用`IsPalindrome()`方法，将返回`true`。我们的扩展方法已成功创建并运行。
- en: Extension methods in the code IntelliSense
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码IntelliSense中的扩展方法
- en: 'When we create an extension method for instance, to a type there will be no
    apparent difference compared to the existing methods in a class or type. This
    is because we will do the same thing when invoking extension methods or methods
    that are actually defined in a type. However, we can inspect the code IntelliSense
    to understand whether or not the method inside the type is an extension method
    since the extension method will be displayed in the IntelliSense. The following
    screenshot is the method list for the string instance when the `IsPalindrome()`
    extension method has not been defined yet:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为实例创建扩展方法时，与类或类型中已存在的方法相比，没有明显的区别。这是因为在调用扩展方法或实际在类型中定义的方法时，我们将执行相同的操作。然而，我们可以检查代码智能感知来了解类型内部的方法是否是扩展方法，因为扩展方法将显示在智能感知中。当`IsPalindrome()`扩展方法尚未定义时，以下截图是字符串实例的方法列表：
- en: '![Extension methods in the code IntelliSense](img/Image00038.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![代码智能感知中的扩展方法](img/Image00038.jpg)'
- en: 'And the following screenshot is the method list for the string instance when
    the `IsPalindrome()` extension method has been defined:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当`IsPalindrome()`扩展方法已经定义时，以下截图是字符串实例的方法列表：
- en: '![Extension methods in the code IntelliSense](img/Image00039.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![代码智能感知中的扩展方法](img/Image00039.jpg)'
- en: We can see from the preceding two images that the extension will be listed in
    the code IntelliSense of Visual Studio. However, we can now find the distinction
    between extension methods and methods that are actually defined in a type that
    is the icon. There is an arrow pointing down at the icon of extension methods
    although we cannot find it in the method that is actually defined in a type. This
    is because the icon is different but the way we invoke the method is totally the
    same.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从前面两张图片中看到，扩展方法将在Visual Studio的代码智能感知中列出。然而，我们现在可以找到扩展方法和实际在类型中定义的方法之间的区别。扩展方法的图标有一个向下的箭头，尽管我们在实际定义的方法中找不到它。这是因为图标不同，但我们调用方法的方式完全相同。
- en: Calling extension methods in the other assemblies
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在其他程序集中调用扩展方法
- en: We have successfully created the `IsPalindrome()` extension method in the previous
    section. It's quite easy to call the extension method since it's defined inside
    the same namespace as the caller method. In other words, the `IsPalindrome()`
    extension method and the `Main()` method are in the same namespace. We don't need
    to add a reference to any module since the method is there along with the caller.
    However, in common practice, we can create extension methods in the other assemblies,
    which we usually call class library. The use of the library will ease the use
    of the extension method since it can be reused, so we can use the extension method
    in many projects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功在上一节中创建了`IsPalindrome()`扩展方法。调用扩展方法非常容易，因为它是在与调用方法相同的命名空间中定义的。换句话说，`IsPalindrome()`扩展方法和`Main()`方法在同一个命名空间中。我们不需要添加对任何模块的引用，因为该方法与调用者一起存在。然而，在通常的实践中，我们可以在其他程序集中创建扩展方法，通常称为类库。使用该类库将简化扩展方法的使用，因为它可以被重用，所以我们可以在许多项目中使用该扩展方法。
- en: Referencing a namespace
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用命名空间
- en: 'We are going to create an extension method in the `Class Library` and call
    it in another project. Let''s create a new `Class Library` project named `ReferencingNamespaceLib.csproj`
    and insert the following code into the `ExtensionMethodsClass.cs` file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`类库`中创建一个扩展方法，并在另一个项目中调用它。让我们创建一个名为`ReferencingNamespaceLib.csproj`的新`类库`项目，并将以下代码插入`ExtensionMethodsClass.cs`文件中：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'From the preceding code, we can see that we create the `ConvertToHex()` extension
    method inside the `ExtensionMethodsClass` class in the `ReferencingNamespaceLib`
    namespace. The use of the `ConvertToHex()` extension method is to convert each
    character in the string to ASCII code and store it in the byte array. Now let''s
    take a look at the following code, which will call the extension method, which
    we can find in the `ReferencingNamespace.csproj` project:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到我们在`ReferencingNamespaceLib`命名空间的`ExtensionMethodsClass`类中创建了`ConvertToHex()`扩展方法。`ConvertToHex()`扩展方法的用途是将字符串中的每个字符转换为ASCII码并将其存储在字节数组中。现在让我们看一下以下代码，它将调用我们可以在`ReferencingNamespace.csproj`项目中找到的扩展方法：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'From the preceding code, we can see that we call the `ConvertToHex()` extension
    method from the instance of string, which is `strData` , as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到我们如何从字符串实例`strData`中调用`ConvertToHex()`扩展方法，如下所示：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, in order to invoke the `ConvertToHex()` method from the string instance,
    we have to refer to the `ReferencingNamespaceLib` assembly and also import the
    namespace of the reference assembly. To import the assembly, we have to use `using`
    along with `ReferencingNamespaceLib` as shown in the following code snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了从字符串实例中调用`ConvertToHex()`方法，我们必须引用`ReferencingNamespaceLib`程序集，并且还要导入引用程序集的命名空间。要导入程序集，我们必须使用`using`以及`ReferencingNamespaceLib`，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we run the `ReferencingNamespace.csproj` project, we will get the following
    output on the console:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`ReferencingNamespace.csproj`项目，我们将在控制台上得到以下输出：
- en: '![Referencing a namespace](img/Image00040.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![引用命名空间](img/Image00040.jpg)'
- en: As we can see, each character in C# sentences is converted into ASCII code invoked
    the extension method we created for the string type by referencing a namespace
    in both hexadecimal and decimal formats. This also proves that we have successfully
    in another assembly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，C#句子中的每个字符都被转换为ASCII码，通过引用命名空间调用了我们为字符串类型创建的扩展方法，以十六进制和十进制格式显示。这也证明了我们已经成功在另一个程序集中。
- en: Piggybacking a namespace
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搭便车命名空间
- en: 'We can, if we want, piggyback on the namespace where the string type lives,
    which is the `System` namespace, so that we don''t need to import a custom namespace
    to use the extension method. Piggybacking a namespace is also good for our standard
    programming approach. Let''s refactor our previous `ReferencingNamespaceLib.csproj`
    code using the following code, which we can find in the `PiggybackingNamespaceLib.csproj`
    project:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以依赖存储字符串类型的`System`命名空间，这样我们就不需要导入自定义命名空间来使用扩展方法。依赖命名空间对于我们的标准编程方法也是有好处的。让我们使用`PiggybackingNamespaceLib.csproj`项目中的以下代码重构我们之前的`ReferencingNamespaceLib.csproj`代码：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we observe the class name, the `ConvertToHex()` method signature, or the
    implementation of the method, we will find that there''s no difference between
    the `ReferencingNamespaceLib.csproj` and `PiggybackingNamespaceLib.csproj` projects.
    However, if we look at the namespace name, we will find that now it''s `System`
    instead of `PiggybackingNamespaceLib` . The reason we use the `System` namespace
    is to create an extension method in the selected namespace. Since we want to extend
    the ability of the string type that lives in the `System` namespace, we have to
    extend the `System` namespace as well. We do not need to import the `System` namespace
    using a `using` keyword since the `ConvertToHex()` method lives in the `System`
    namespace. Now, let''s take a look at the following code in order to invoke the
    `ConvertToHex()` method inside the `System` namespace, which we can find in the
    `PiggybackingNamespace.csproj` project:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们观察类名、`ConvertToHex()`方法签名或方法的实现，我们会发现`ReferencingNamespaceLib.csproj`和`PiggybackingNamespaceLib.csproj`项目之间没有区别。但是，如果我们看命名空间名称，我们会发现现在是`System`而不是`PiggybackingNamespaceLib`。我们使用`System`命名空间的原因是在所选命名空间中创建扩展方法。由于我们想要扩展`System`命名空间中的字符串类型的能力，我们也必须扩展`System`命名空间。我们不需要使用`using`关键字导入`System`命名空间，因为`ConvertToHex()`方法位于`System`命名空间中。现在，让我们看一下以下代码，以便在`PiggybackingNamespace.csproj`项目中调用`System`命名空间中的`ConvertToHex()`方法：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We refactor the preceding code from the `ReferencingNamespace.csproj` project,
    and again, we don''t find any differences between the `PiggybackingNamespace.csproj`
    and `ReferencingNamespace.csproj` projects except that there is no import to the
    custom namespace in the `PiggybackingNamespace.csproj` project, which the `ReferencingNamespace.csproj`
    project has:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重构了`ReferencingNamespace.csproj`项目中的前面的代码，再次发现`PiggybackingNamespace.csproj`项目和`ReferencingNamespace.csproj`项目之间没有任何区别，除了`PiggybackingNamespace.csproj`项目中没有导入自定义命名空间，而`ReferencingNamespace.csproj`项目有：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We don''t need to import the custom namespace since we create the extension
    method in the `System` namespace. However, we still need to refer to the assembly
    where the extension method is defined. We can expect an output like what is shown
    in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`System`命名空间中创建了扩展方法，所以我们不需要导入自定义命名空间。但是，我们仍然需要引用定义扩展方法的程序集。我们可以期望得到如下截图所示的输出：
- en: '![Piggybacking a namespace](img/Image00041.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![依赖命名空间](img/Image00041.jpg)'
- en: We have successfully invoked the `ConvertToHex()` extension method and found
    it useful for getting the ASCII code from the string data type.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功调用了`ConvertToHex()`扩展方法，并发现它对从字符串数据类型获取ASCII代码很有用。
- en: Leveraging the interface, collection, and object
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用接口、集合和对象
- en: Not only can classes and types apply an extension method, but interfaces, collections,
    and any other objects can be functionally extended using an extension method as
    well. We are going to discuss this in the upcoming sections.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅类和类型可以应用扩展方法，接口、集合和任何其他对象也可以使用扩展方法进行功能扩展。我们将在接下来的部分讨论这个问题。
- en: Extending the interface
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展接口
- en: 'We can extend the method in an interface in the same way we extend the method
    in a class or type. We still need the `public static` class and the `public static`
    method. By extending the interface abilities, we can use the extension method
    just after we create it without the need to create the implementation inside the
    class that we inherit from the interface, since the implementation is done when
    we declare the extension method. Let''s take a look at the following `DataItem`
    class, which we can find in the `ExtendingInterface.csproj` project:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以与在类或类型中扩展方法相同的方式扩展接口中的方法。我们仍然需要`public static`类和`public static`方法。通过扩展接口的能力，我们可以在创建扩展方法后立即使用它，而无需在我们从接口继承的类中创建实现，因为实现是在我们声明扩展方法时完成的。让我们看一下`ExtendingInterface.csproj`项目中的以下`DataItem`类：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We also have the following `IDataSource` interface:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有以下`IDataSource`接口：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we can see, the `IDataSource` interface has only one signature of the method,
    which is named `GetItems()` , returning `IEnumerable<DataItem>` . Now, we can
    create a class to inherit the `IDataSource` interface, which we give a name, `ClubMember`
    ; it has the implementation of the `GetItems()` method, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`IDataSource`接口只有一个名为`GetItems()`的方法签名，返回`IEnumerable<DataItem>`。现在，我们可以创建一个类来继承`IDataSource`接口，我们给它一个名字`ClubMember`；它有`GetItems()`方法的实现，如下所示：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'From the preceding class, the `GetItems()` method will yield all the data in
    the  `DataItemList` , whose content will be as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的类中，`GetItems()`方法将产生`DataItemList`中的所有数据，其内容将如下所示：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are ten `DataItem` classes in the `DataItemList` . We can display all
    the items in the `DataItemList` with the help of the `GetItems()` method, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DataItemList`中有十个`DataItem`类。我们可以通过`GetItems()`方法显示`DataItemList`中的所有项目，如下所示：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we can can see in the preceding code, since we have inherited the `ClubMember`
    class to the `IDataSource` interface and have implemented the `GetItems()` method,
    the instance of `ClubMember` , which is `cm` , can invoke the `GetItems()` method.
    The output will be like what is shown in the following screenshot when we run
    the project:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上述代码中所看到的，由于我们已将`ClubMember`类继承到`IDataSource`接口，并实现了`GetItems()`方法，因此`ClubMember`的实例`cm`可以调用`GetItems()`方法。当我们运行项目时，输出将如下截图所示：
- en: '![Extending the interface](img/Image00042.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![扩展接口](img/Image00042.jpg)'
- en: 'Now, if we want to add the method to the interface without having to modify
    it, we can create a method extension to the interface. Consider that we are going
    to add the `GetItemsByGender()` method to the `IDataSource` interface; we can
    create the extension method as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要在不修改接口的情况下向其添加方法，我们可以为接口创建一个方法扩展。考虑到我们要向`IDataSource`接口添加`GetItemsByGender()`方法，我们可以创建如下的扩展方法：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'By creating the preceding extension method, the instance of the `ClubMember`
    class now has a method named `GetItemsByGender()` . We can use this extension
    method in the same way as we use the method class, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建上述扩展方法，`ClubMember`类的实例现在有一个名为`GetItemsByGender()`的方法。我们可以像使用方法类一样使用这个扩展方法，如下所示：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `GetItemsByGender()` method will return the `IEnumerable` interface of
    the selected gender of `DataItemList` . Since we only need to get all female members
    in the list, the output will be as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetItemsByGender()`方法将返回`DataItemList`所选性别的`IEnumerable`接口。由于我们只需要获取列表中的所有女性成员，输出将如下所示：'
- en: '![Extending the interface](img/Image00043.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![扩展接口](img/Image00043.jpg)'
- en: We can now extend the method in the interface, and there's no need to implement
    the method in the inherited class since it has been done in the extension method
    definition.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以扩展接口中的方法，而不需要在继承的类中实现该方法，因为在扩展方法定义中已经完成了。
- en: Extending the collection
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展集合
- en: In our previous discussion, we discovered that we apply the `IEnumerable` interface
    in order to collect all the data we need. We can also extend the `IEnumerable`
    interface, which is a collection type, so that we can add a method in an instance
    of a collection type.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的讨论中，我们发现我们应用`IEnumerable`接口以收集所需的所有数据。我们还可以扩展`IEnumerable`接口，这是一种集合类型，以便我们可以在集合类型的实例中添加方法。
- en: 'The following is the code in the `ExtendingCollection.csproj` project and we
    still use `DataItem.cs` and `IDataSource.cs` , which we use in the `ExtendingInterface.csproj`
    project. Let''s take a look at the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`ExtendingCollection.csproj`项目中的代码，我们仍然使用`ExtendingInterface.csproj`项目中使用的`DataItem.cs`和`IDataSource.cs`。让我们看一下以下代码：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code is the extension method for the `IEnumerable` type. To prevent
    the occurrence of an error, we have to cast the type of all sources'' items using
    the following code snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是`IEnumerable`类型的扩展方法。为了防止出现错误，我们必须使用以下代码片段对所有源项的类型进行转换：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can also extend the `IEnumerable<T>` type, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以扩展`IEnumerable<T>`类型，如下所示：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using the preceding method, we can extend the `IEnumerable<T>` type to have
    a method named `GetAllItemsByGender_IEnumTemplate()` , which is used to get the
    items by a specific gender.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述方法，我们可以扩展`IEnumerable<T>`类型，以拥有一个名为`GetAllItemsByGender_IEnumTemplate()`的方法，用于按特定性别获取项目。
- en: 'Now, we are ready to invoke these two extension methods. However, before we
    call them, let''s create the following two classes, named `ClubMember1` and `ClubMember2`
    :'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备调用这两个扩展方法。但在调用它们之前，让我们创建以下两个类，名为`ClubMember1`和`ClubMember2`：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we are going to invoke the `GetAllItemsByGender_IEnum()` and `GetAllItemsByGender_IEnumTemplate()`
    extension methods. The code will be as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将调用`GetAllItemsByGender_IEnum()`和`GetAllItemsByGender_IEnumTemplate()`扩展方法。代码将如下所示：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'From the preceding code, first we create a `sources` variable containing the
    array of `IDataSource` . We get the data for `sources` from the `ClubMember1`
    and `ClubMember2` classes. Since the source is a collection of `IDataSource` ,
    the `GetAllItemsByGender_IEnum()` method can be applied to it. If we run the preceding
    `Main()` method, the following output will be displayed on the console:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码中，首先我们创建一个包含`IDataSource`数组的`sources`变量。我们从`ClubMember1`和`ClubMember2`类获取`sources`的数据。由于源是`IDataSource`的集合，因此可以将`GetAllItemsByGender_IEnum()`方法应用于它。如果我们运行上述`Main()`方法，将在控制台上显示以下输出：
- en: '![Extending the collection](img/Image00044.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![扩展集合](img/Image00044.jpg)'
- en: 'We have successfully invoked the `GetAllItemsByGender_IEnum()` extension method.
    Now, let''s try to invoke the `GetAllItemsByGender_IEnumTemplate` extension method
    using the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功调用了`GetAllItemsByGender_IEnum()`扩展方法。现在，让我们尝试使用以下代码调用`GetAllItemsByGender_IEnumTemplate`扩展方法：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We declare the `sources` variable in the yet-to-be-displayed code, in the same
    way as we declared it in the previous `Main()` method. Also, we can apply the
    `GetAllItemsByGender_IEnumTemplate()` extension method to the source variable.
    The output will be as follows if we run the preceding code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在尚未显示的代码中声明了`sources`变量，方式与之前的`Main()`方法中声明它的方式相同。此外，我们可以将`GetAllItemsByGender_IEnumTemplate()`扩展方法应用于源变量。如果我们运行上述代码，输出将如下所示：
- en: '![Extending the collection](img/Image00045.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![扩展集合](img/Image00045.jpg)'
- en: By comparing the two images of the output, we can see that there's no difference
    between them, although they extend the different collection types.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较输出的两个图像，我们可以看到它们之间没有区别，尽管它们扩展了不同的集合类型。
- en: Extending an object
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展对象
- en: 'Not only can we extend an interface and a collection, we can actually extend
    an object as well, which means that we can extend everything. To discuss this,
    let''s take a look at the following code, which we can find in the `ExtendingObject.csproj`
    project:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以扩展接口和集合，还可以扩展对象，这意味着我们可以扩展一切。为了讨论这一点，让我们看一下在`ExtendingObject.csproj`项目中可以找到的以下代码：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have a method extension named `WriteToConsole()` , which can be applied
    to all objects in C# since it extends the `Object` class. To use it, we can apply
    it to various objects, as shown in the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`WriteToConsole()`的方法扩展，它可以应用于C#中的所有对象，因为它扩展了`Object`类。要使用它，我们可以将它应用于各种对象，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Before we dissect the preceding code, let''s run this `Main()` method, and
    we will get the following output on the console:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们分解前面的代码之前，让我们运行这个`Main()`方法，我们将在控制台上得到以下输出：
- en: '![Extending an object](img/Image00046.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![扩展对象](img/Image00046.jpg)'
- en: From the preceding code, we can see that all objects that are `UInt64` , `DateTime`
    , `DataItem` , and `IEnumerable<IDataSource>` can invoke the `WriteToConsole()`
    extension method that we declare use the `this` object as an argument.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到所有`UInt64`，`DateTime`，`DataItem`和`IEnumerable<IDataSource>`对象都可以调用我们声明的`WriteToConsole()`扩展方法，该方法使用`this`对象作为参数。
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Creating an extension method in the object type causes all types in the framework
    to be able to access the method. We have to ensure that the implementation of
    the method can be applied to the different types supported by the framework.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象类型中创建扩展方法会导致框架中的所有类型都能够访问该方法。我们必须确保该方法的实现可以应用于框架支持的不同类型。
- en: Advantages of using extension methods in functional programming
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在函数式编程中使用扩展方法的优势
- en: 'Method chaining in functional programming relies on extension methods. As we
    have already discussed in [Chapter 1](text00016.html#ch01 "Chapter 1. Tasting
    Functional Style in C#") , *Tasting Functional Style in C#* , method chaining
    will make our code easier to read since it can decrease the lines of code. For
    the sake of code readability in the extension method, let''s take a look at the
    following code, which we can find in the `CodeReadability.csproj` project:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程中的方法链依赖于扩展方法。正如我们在[第1章](text00016.html#ch01 "第1章。在C#中品尝函数式风格")中已经讨论过的那样，*在C#中品尝函数式风格*，方法链将使我们的代码更易于阅读，因为它可以减少代码行数。为了提高扩展方法的代码可读性，让我们看一下以下代码，可以在`CodeReadability.csproj`项目中找到：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding code is the `static` method inside the `static` class. It is
    not an extension method since we don''t use the `this` keyword in the method argument.
    We can find it in the `HelperMethods.cs` file. The use of the `TrimAllSpace()`
    method is to remove all white space characters from the string, while the use
    of the `Capitalize()` method is to make the first letter of a string uppercase
    in the sentence. We also have exactly same methods as `HelperMethods` , which
    we can find in the `ExtensionMethods.cs` file. Let''s look at the following code,
    in which we declare `TrimAllSpace()` and `Capitalize()` as the extension methods:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是`static`类中的`static`方法。它不是扩展方法，因为在方法参数中我们没有使用`this`关键字。我们可以在`HelperMethods.cs`文件中找到它。`TrimAllSpace()`方法的用途是从字符串中删除所有空格字符，而`Capitalize()`方法的用途是将字符串中的第一个字母大写。我们还有完全相同的方法`HelperMethods`，可以在`ExtensionMethods.cs`文件中找到。让我们看一下以下代码，其中我们将`TrimAllSpace()`和`Capitalize()`声明为扩展方法：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we will create code that will trim all the whitespace in the given string
    and then capitalize each string in the sentence. The following is the code implemented
    in the `HelperMethods` class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建代码，将修剪给定字符串中的所有空格，然后将句子中的每个字符串大写。以下是在`HelperMethods`类中实现的代码：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We also declare a string array named `sentences` , as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还声明了一个名为`sentences`的字符串数组，如下所示：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code will give the following output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将产生以下输出：
- en: '![Advantages of using extension methods in functional programming](img/Image00047.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![在函数式编程中使用扩展方法的优势](img/Image00047.jpg)'
- en: 'We can, if we want, simplify the preceding `Main()` method, which uses `HelperMethods`
    , using extension methods we have already created, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以简化前面使用`HelperMethods`的`Main()`方法，使用我们已经创建的扩展方法，如下所示：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we run the preceding `Main()` method, we will get eactly the same output
    on the console. However, we have refactored the following code snippet:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的`Main()`方法，我们将在控制台上得到完全相同的输出。但是，我们已经重构了以下代码片段：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Using the extension method, we just need this one-line code to replace the
    the four lines of code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展方法，我们只需要这一行代码来替换四行代码：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The point is that we have reduced the line of code so it now becomes simpler
    and more readable and the flow of the process is clearer.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是我们已经减少了代码行数，使其变得更简单和更易读，流程也更清晰了。
- en: Limitations of the extension method
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展方法的限制
- en: Although the extension method is a powerful tool to achieve our functional programming,
    this technique still has some limitations. Here, we elaborate on the limitations
    the extension methods face so that we can avoid their use.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管扩展方法是实现函数式编程的强大工具，但这种技术仍然存在一些局限性。在这里，我们详细阐述了扩展方法所面临的限制，以便我们避免使用它们。
- en: Extending a static class
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展静态类
- en: As we discuss extension methods further, we know that an extension method is
    a static method that has public accessibility inside the static class that has
    public accessibility as well. The extension method will appear in the type or
    class we target. However, not all classes can be extended using the extension
    method. The existing static class will not be able to be extended. For example,
    the `Math` class has been provided by .NET. Even though the class has provided
    a mathematical functionality we usually use, it might be that, sometimes, we need
    to add another functionality to the `Math` class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进一步讨论扩展方法，我们知道扩展方法是具有公共可访问性的静态方法，位于具有公共可访问性的静态类内。扩展方法将出现在我们目标的类型或类中。但是，并非所有类都可以使用扩展方法进行扩展。现有的静态类将无法进行扩展。例如，`Math`类是由.NET提供的。即使该类提供了我们通常使用的数学功能，有时我们可能需要向`Math`类添加其他功能。
- en: 'However, since the `Math` class is a static class, it''s nearly impossible
    to extend this class by adding a single method to it. Suppose we want to add the
    `Square()` method to find the result of multiplying a number by itself. Here is
    the code, which we can find in the `ExtendingStaticClass.csproj` project, if we
    try to add the extension method to the `Math` class:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于`Math`类是一个静态类，几乎不可能通过向其添加单个方法来扩展此类。假设我们想要添加`Square()`方法来找到一个数字与自身相乘的结果。以下是代码，我们可以在`ExtendingStaticClass.csproj`项目中找到，如果我们尝试向`Math`类添加扩展方法：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When we compile the preceding code, there will be an error similar to what
    is shown in the following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译上述代码时，将会出现类似于以下截图所示的错误：
- en: '![Extending a static class](img/Image00048.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![扩展静态类](img/Image00048.jpg)'
- en: 'The error message says that the `Math` static method cannot be used as a parameter
    of the `Square()` extension method. What we can do to overcome this limitation
    is now extend the types instead of the `Math` class. We can extend the `int` types
    by adding the `Square()` method instead of extending the `Math` class. Here''s
    the code to extend the `int` class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息显示`Math`静态方法不能作为`Square()`扩展方法的参数使用。为了克服这个限制，我们现在可以扩展类型而不是`Math`类。我们可以通过向`int`类型添加`Square()`方法来扩展`int`类型。以下是扩展`int`类的代码：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As we can see, we extend the `int` types so that if we want to invoke the `Square()`
    method, we can invoke it using the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们扩展了`int`类型，这样如果我们想要调用`Square()`方法，我们可以使用以下代码来调用它：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: However, using this technique, we also need to extend the other types, such
    as `float` and `double` , to accommodate the `Square()` functionality in various
    data types.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用这种技术，我们还需要扩展其他类型，如`float`和`double`，以适应各种数据类型中的`Square()`功能。
- en: Modifying the method implementation in the existing class or type
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改现有类或类型中的方法实现
- en: 'Although the extension method can be applied to the existing classes and types,
    we cannot modify the implementation of the existing method the class or type has.
    We can try it using the following code, which we can find in the `ModifyingExistingMethod.csproj`
    project:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管扩展方法可以应用于现有的类和类型，但我们不能修改现有方法的实现。我们可以尝试使用以下代码，我们可以在`ModifyingExistingMethod.csproj`项目中找到：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the preceding code, we try to replace the existing `ToString()` method,
    which the string type has, with a `ToString()` extension method such as the one
    in the preceding code. Fortunately, the code will be able to be compiled successfully.
    Now, let''s add the following code to the `Main()` method in the project:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们尝试用前面代码中的`ToString()`扩展方法替换字符串类型已有的`ToString()`方法。幸运的是，该代码将能够成功编译。现在，让我们在项目的`Main()`方法中添加以下代码：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: However, if we run the project, the `ToString()` extension method will never
    be executed. We will get the output from the existing `ToString()` method instead.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们运行该项目，`ToString()`扩展方法将永远不会被执行。我们将从现有的`ToString()`方法中获得输出。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Extension methods give us an easy way to add a new method to an existing class
    or type without having to modify the original class or type. Besides, we don't
    need to recompile the code since just after we create the extension method it
    will be recognized by the code in the project. An extension method has to be declared
    as a static method inside a static class. As there is no apparent difference compared
    to the existing methods in a class or type, the method will also appear in the
    IntelliSense.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法为我们提供了一种简单的方法，可以向现有类或类型添加新方法，而无需修改原始类或类型。此外，我们无需重新编译代码，因为在创建扩展方法后，代码将立即识别它。扩展方法必须声明为静态方法，位于静态类中。与类或类型中的现有方法相比，该方法没有明显的区别，该方法也将出现在IntelliSense中。
- en: Extension methods can also be declared in another assembly, and we have to refer
    to the namespace of the static class defined the method stored in the other assemblies.
    However, we can use the piggyback namespace technique, which uses the existing
    namespace so that we don't need to refer to any other namespace anymore. Not only
    can we extend the class and type functionality, but we can also extend the interface,
    collection, and any objects in the framework.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法也可以在另一个程序集中声明，并且我们必须引用定义了该方法的静态类的命名空间，存储在其他程序集中。然而，我们可以使用附加命名空间技术，使用现有命名空间，这样我们就不需要再引用任何其他命名空间了。我们不仅可以扩展类和类型的功能，还可以扩展接口、集合和框架中的任何对象。
- en: Like other C# technologies, extension methods also have their advantages and
    limitations. One of the advantages related to functional programming is that the
    extension method will make our code apply method chaining so that it can apply
    the functional approach. However, we cannot extend a static and we cannot modify
    the method implementation in an existing class or type, which is a limitation
    of the extension method.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他C#技术一样，扩展方法也有其优点和局限性。与函数式编程相关的一个优点是，扩展方法将使我们的代码应用方法链，以便应用函数式方法。然而，我们不能扩展静态类，也不能修改现有类或类型中的方法实现，这是扩展方法的局限性。
- en: In the next chapter, we will dig into LINQ techniques since we already have
    enough understanding of delegates, lambda expressions, and extension methods.
    We will also discuss the convenient way to code a functional program provided
    by LINQ.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究LINQ技术，因为我们已经对委托、Lambda表达式和扩展方法有足够的了解。我们还将讨论LINQ提供的编写函数式程序的便捷方式。
