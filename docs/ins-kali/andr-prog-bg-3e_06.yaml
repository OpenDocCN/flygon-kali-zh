- en: '*Chapter 6*: The Android Lifecycle'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：Android生命周期'
- en: In this chapter, we will get familiar with the lifecycle of an Android app.
    At first, this might sound a bit strange, that a computer program has a lifecycle,
    but it will make sense soon.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将熟悉Android应用程序的生命周期。起初，这可能听起来有点奇怪，一个计算机程序有一个生命周期，但很快就会有意义。
- en: The lifecycle is the way that all Android apps interact with the Android OS.
    Just like the lifecycle of humans interacts with the world around them, we have
    no choice but to interact with it and must be prepared to handle different events
    without notice if we want our apps to survive.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期是所有Android应用程序与Android操作系统交互的方式。就像人类的生命周期与周围世界互动一样，我们别无选择，必须与之互动，并且必须准备好处理不经通知的不同事件，如果我们希望我们的应用程序能够生存下来。
- en: We will see the phases of the lifecycle that an app goes through from creation
    to destruction and how this helps us know where to put our Java code, depending
    on what we are trying to achieve.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到应用程序从创建到销毁经历的生命周期阶段，以及这如何帮助我们知道根据我们想要实现的目标在何处放置我们的Java代码。
- en: 'In brief, in this chapter we will look at the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在本章中我们将看到以下内容：
- en: The life and times of an Android app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android应用程序的生活和时代
- en: What is method overriding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是方法重写
- en: The phases of the Android lifecycle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android生命周期的阶段
- en: What exactly we need to know and do to code our apps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们确切需要了解和做什么来编写我们的应用程序
- en: A lifecycle demonstration mini app.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个生命周期演示迷你应用程序。
- en: A quick look at code structure ready to get Java coding in the next chapter
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速查看代码结构，准备在下一章中进行Java编码
- en: Let's start learning about the Android lifecycle.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始学习Android的生命周期。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2006](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2006).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中的代码文件[https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2006](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2006)。
- en: The life and times of an Android app
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android应用程序的生活和时代
- en: We have talked a bit about the structure of our code; we know that we can write
    classes, and within those classes we have methods, and the methods contain our
    code, which gets things done. We also know that when we want the code within a
    method to run (be executed), we call that method by using its name.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经谈到了我们代码的结构；我们知道我们可以编写类，并且在这些类中我们有方法，方法包含我们的代码，从而完成任务。我们也知道当我们想要方法中的代码运行时，我们通过使用方法的名称来调用该方法。
- en: 'Also, in [*Chapter 2*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*, First Contact:
    Java, XML, and the UI Designer*, we learned that Android itself calls the `onCreate`
    method just before the app is ready to start. We saw this when we output to the
    logcat and used the `Toast` class to send a pop-up message to the user.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在[*第2章*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*，初次接触：Java，XML和UI设计师*中，我们了解到Android本身在应用程序准备启动之前调用`onCreate`方法。当我们输出到logcat并使用`Toast`类向用户发送弹出消息时，我们看到了这一点。
- en: What we will look at in this chapter is what happens throughout the lifecycle
    of every app we write – when it starts and ends as well as a few stages in between
    as well. And what we will see is that Android interacts with our app on numerous
    occasions, each time it is run.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到我们编写的每个应用程序在其生命周期内发生的情况 - 启动和结束以及中间的一些阶段。我们将看到Android在每次运行时都与我们的应用程序进行交互。
- en: How Android interacts with our apps
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android如何与我们的应用程序交互
- en: It does so by calling methods that are contained within the `Activity` class.
    Even if the method is not visible within our Java code, it is still being called
    by Android at the appropriate time. If this doesn't seem to make any sense, then
    read on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过调用包含在`Activity`类中的方法来实现。即使该方法在我们的Java代码中不可见，Android也会在适当的时间调用它。如果这看起来毫无意义，那么请继续阅读。
- en: Did you ever wonder why the `onCreate` method had a strange-looking line of
    code just before it?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾想过为什么`onCreate`方法之前有一行奇怪的代码？
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What is going on here is that we are saying to Android, when you call `onCreate`,
    please use our overridden version because we have some things to do at that time.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的是，我们在告诉Android，当你调用`onCreate`时，请使用我们重写的版本，因为我们在那个时候有一些事情要做。
- en: 'Furthermore, you might remember the odd-looking first line of code in the `onCreate`
    method:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可能还记得`onCreate`方法中奇怪的第一行代码：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is telling Android to call the original/official version of `onCreate`
    before proceeding with our overridden version. This is not just a quirk of Android
    – **method** **overriding** is built into Java.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在告诉Android在继续使用我们重写的版本之前调用`onCreate`的原始/官方版本。这不仅仅是Android的一个怪癖 - **方法** **重写**内置在Java中。
- en: There are also many other methods that we can optionally override, and they
    allow us to add our code at appropriate times within the lifecycle of our Android
    app. Just as `onCreate` is called just before the app is shown to the user, there
    are more methods that are called at other times. We haven't seen them yet, we
    haven't overridden them yet, but they are there, they are called, and their code
    executes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他方法，我们可以选择重写，它们允许我们在Android应用程序的生命周期中的适当时间添加我们的代码。就像`onCreate`在应用程序显示给用户之前被调用一样，还有更多在其他时间被调用的方法。我们还没有看到它们，我们还没有重写它们，但它们存在，它们被调用，它们的代码执行。
- en: The reason we need to care about the methods of **our** app that Android calls
    whenever it wants is they control the very life and death of our code. For instance,
    what if our app allows the user to type an important reminder. Then, halfway through
    typing the reminder their phone rings, our app disappears, and the data (the reminder)
    is gone.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要关心Android在何时调用我们应用程序的方法，因为它们控制着我们代码的生死。例如，如果我们的应用程序允许用户输入重要的提醒。然后，在输入提醒的一半时，他们的手机响了，我们的应用程序消失了，数据（提醒）也消失了。
- en: It is vital and thankfully quite straightforward that we learn when, why, and
    which methods Android will call as part of the lifecycle of our app. We can then
    know where we need to override methods to add our own code and where to add the
    real functionality (code) that defines our app.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要学会何时、为什么以及Android将调用我们应用程序生命周期的哪些方法，这是非常重要的，幸运的是也相当简单。然后我们就知道在哪里需要重写方法来添加我们自己的代码，以及在哪里添加定义我们应用程序的真正功能（代码）。
- en: Let's examine the Android lifecycle, then we can move on to the ins and outs
    of Java and we will know exactly where to put the code that we write.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来研究一下Android的生命周期，然后我们可以继续深入了解Java的方方面面，我们就会知道在哪里放我们编写的代码。
- en: A simplified explanation of the Android lifecycle
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android生命周期的简化解释
- en: If you have ever used an Android device, you have probably noticed it works
    quite differently from many other operating systems. For example, you could be
    using an app – say you're checking what people are doing on Facebook. Then, you
    get an email notification and you tap the notification to read it. Midway through
    reading the email, you might get a Twitter notification and because you're waiting
    on important news from someone you follow, you interrupt your email reading and
    change apps to Twitter with a touch.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过Android设备，你可能已经注意到它的工作方式与许多其他操作系统有很大不同。例如，你可能正在使用一个应用程序——比如你正在查看Facebook上的人在做什么。然后，你收到一封电子邮件通知，你点击通知来阅读它。在阅读电子邮件的过程中，你可能会收到Twitter的通知，因为你正在等待某个关注者的重要消息，所以你中断了阅读电子邮件，触摸屏幕切换到Twitter。
- en: After reading the tweet, you fancy a game of Angry Birds but midway through
    the first fling, you suddenly remember that Facebook post. So, you quit Angry
    Birds and tap the Facebook icon.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完推文后，你想玩愤怒的小鸟，但在第一次投掷的过程中，你突然想起了Facebook的帖子。所以，你退出愤怒的小鸟，点击Facebook图标。
- en: Then you resume Facebook, probably at the exact same point you left it. You
    could have resumed reading the email, decided to reply to the tweet, or started
    an entirely new app.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你恢复Facebook，可能在你离开的地方。你可以恢复阅读电子邮件，决定回复推文，或者开始一个全新的应用程序。
- en: All this backwards and forwards takes quite a lot of management on the part
    of the operating system, independently of the individual apps themselves.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些来回都需要操作系统进行相当多的管理，独立于应用程序本身。
- en: 'The difference between, say, a Windows PC and Android in the context we have
    just discussed is this: with Android, although the user decides which app they
    are using, the OS decides when to close down (destroy) an application and **our
    user''s data** (like the hypothetical note) along with it. We just need to consider
    this when coding our apps. Just because we might write code to do some cool thing
    with our user''s input, it doesn''t mean that Android will let the code execute.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚讨论的情境中，例如Windows PC和Android之间的区别是：在Android中，尽管用户决定使用哪个应用程序，但操作系统决定何时关闭（销毁）应用程序以及**我们用户的数据**（比如假设的笔记）也会一并销毁。我们在编写应用程序时需要考虑到这一点。仅仅因为我们可能编写代码来处理用户的输入，这并不意味着Android会让代码执行。
- en: The lifecycle phases demystified
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期阶段的解密
- en: The Android system has multiple distinct phases that any given app can be in.
    Depending upon the phase, the Android system decides how the app is viewed by
    the user – or whether it is viewed at all.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Android系统有多个不同的阶段，任何给定的应用程序都可能处于其中之一。根据阶段，Android系统决定应用程序如何被用户查看，或者是否被用户查看。
- en: Android has these phases so it can decide which app is in current use and so
    that it can then give the right amount of resources, such as memory and processing
    power.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Android有这些阶段，这样它可以决定哪个应用程序正在使用，并且可以给予正确数量的资源，如内存和处理能力。
- en: In addition, as the user interacts with the device, for example, by touching
    the screen, Android must give the details of that interaction to the correct app.
    For instance, a drag-and-release movement in Angry Birds means taking a shot,
    but in a messaging app, it might mean delete a text message.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当用户与设备进行交互时，例如触摸屏幕，Android必须将该交互的细节传递给正确的应用程序。例如，在愤怒的小鸟中，拖动并释放意味着射击，但在消息应用中，它可能意味着删除短信。
- en: We have already raised the issue of when the user quits our app to answer a
    phone call; will they lose their progress/data/important note?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提出了一个问题，当用户退出我们的应用程序来接听电话时，他们会丢失他们的进度/数据/重要笔记吗？
- en: 'Android has a system that, when simplified a little for the purposes of explanation,
    means that every app on an Android device is in one of the following phases:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Android有一个系统，简化一下以便解释，意味着Android设备上的每个应用程序都处于以下阶段之一：
- en: Being created
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建中
- en: Starting
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动
- en: Resuming
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复
- en: Running
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行
- en: Pausing
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停
- en: Stopping
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止
- en: Being destroyed
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被销毁
- en: The list of phases will hopefully appear logical. As an example, the user presses
    the Facebook app icon and the app is **created**. Then it is **started**. All
    straightforward so far, but next on the list is **resuming**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段列表希望看起来是合乎逻辑的。例如，用户按下Facebook应用程序图标，应用程序被**创建**。然后它被**启动**。到目前为止一切都很简单，但接下来是**恢复**。
- en: It is not as illogical as it might first appear if, for a moment, we can just
    accept that the app resumes after it starts and then all will become clear as
    we continue.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能暂时接受应用程序在启动后恢复，那么这并不像它一开始看起来那么不合逻辑，随着我们的继续，一切都会变得清晰起来。
- en: After **resuming,** the app is **running**. This is when the Facebook app has
    control of the screen and the greater share of system memory and processing power
    and is receiving the details of the user's input.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**恢复**后，应用程序是**运行**的。这时，Facebook应用程序控制着屏幕和大部分系统内存和处理能力，并接收用户输入的细节。'
- en: Now, what about our example when we switched from the Facebook app to the email
    app?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的例子是什么，当我们从Facebook应用切换到电子邮件应用时呢？
- en: As we tap to go to read our email, the Facebook app will have entered the **paused**
    phase, followed by the **stopping** phase, and the email app will enter the **being**
    **created** phase, followed by **resuming**, then **running**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击去阅读我们的电子邮件时，Facebook应用程序将进入**暂停**阶段，然后是**停止**阶段，而电子邮件应用程序将进入**创建中**阶段，然后是**恢复**，然后是**运行**。
- en: If we decide to revisit Facebook, as in the scenario earlier, the Facebook app
    will probably skip being created and go straight to **resume** and then be **running**
    again, most likely exactly in the place we left it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定重新访问Facebook，就像之前的情况一样，Facebook应用程序可能会直接跳过创建并直接**恢复**，然后再次**运行**，很可能会恰好停留在我们离开的地方。
- en: Note that at any time, Android can decide to **stop** then **destroy** an app.
    In which case, when we run the app again, it will need to be **created** at the
    first phase all over again.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，随时，Android都可以决定**停止**然后**销毁**一个应用程序。在这种情况下，当我们再次运行应用程序时，它将需要在第一个阶段重新**创建**。
- en: So, had the Facebook app been inactive long enough, or perhaps Angry Birds had
    needed so many system resources that Android had **destroyed** the Facebook app,
    then our experience of finding the exact post we were previously reading might
    have been different.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果Facebook应用程序长时间不活动，或者Angry Birds需要很多系统资源，以至于Android已经**销毁**了Facebook应用程序，那么我们之前阅读的确切帖子的体验可能会有所不同。
- en: 'If all this phase stuff is starting to get confusing, then you will be pleased
    to know that the only reasons to mention it are the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些阶段的东西开始变得令人困惑，那么您会很高兴地知道提到它的唯一原因是以下：
- en: You know it exists
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您知道它存在
- en: We occasionally need to interact with it
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们偶尔需要与之交互
- en: We will take things step by step when we do
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们这样做时，我们将一步一步地进行
- en: Now we know about the lifecycle phases, let's learn about how we can handle
    them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了生命周期阶段，让我们学习如何处理它们。
- en: How we handle the lifecycle phases
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们如何处理生命周期阶段
- en: When we are programming an app, how do we interact with this complexity? The
    good news is that the Android code that was autogenerated when we created our
    first project does most of it for us.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写应用程序时，我们如何与这种复杂性进行交互？好消息是，当我们创建第一个项目时自动生成的Android代码大部分都为我们完成了。
- en: As we have discussed, we just don't see the methods that handle this interaction,
    but we do have the opportunity to **override** them and add our own code to that
    phase if we need to.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，我们只看不到处理此交互的方法，但是我们有机会**覆盖**它们并在需要时向该阶段添加我们自己的代码。
- en: This means we can get on with learning Java and making Android apps until we
    come to one of the occasional instances where we need to do something in one of
    the phases.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以继续学习Java并制作Android应用程序，直到我们遇到偶尔需要在某个阶段执行某些操作的情况。
- en: Important note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: If our app has more than one activity, they will each have their own lifecycle.
    This doesn't have to complicate things and overall it will make things easier
    for us.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用程序有多个活动，它们将各自拥有自己的生命周期。这并不复杂，总体上对我们来说会更容易。
- en: Coming up is a quick explanation of the methods provided by Android, for our
    convenience, to manage the lifecycle phases. To clarify our discussion of lifecycle
    methods, they are listed next to their corresponding phases that we have been
    discussing. However, as you will see, the method names make it clear on their
    own where they fit in.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是Android提供的方法的简要解释，以方便我们管理生命周期阶段。为了澄清我们对生命周期方法的讨论，它们将列在我们正在讨论的相应阶段旁边。但是，正如您将看到的，方法名称本身清楚地说明了它们在哪个阶段适用。
- en: 'There is also a brief explanation or suggestion for when we might use a given
    method and thereby interact during a specific phase. We will meet most of these
    methods as we progress through the book. We have of course already seen `onCreate`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个简短的解释或建议，说明我们何时可以使用特定的方法，并在特定阶段进行交互。随着我们在书中的进展，我们将遇到大部分这些方法。当然，我们已经看到了`onCreate`：
- en: '`onCreate`: This method is executed when the activity is being `setContentView`),
    graphics, and sound.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreate`：当活动正在`setContentView`（设置内容视图），图形和声音时，将执行此方法。'
- en: '`onStart`: This method is executed when the app is in the **starting** phase.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onStart`：当应用程序处于**启动**阶段时执行此方法。'
- en: '`onResume`: This method runs after `onStart` but can also be entered (most
    logically) after our activity is resumed after being previously paused. We might
    reload previously saved user data (such as an important note) from when the app
    was interrupted, perhaps by a phone call or the user running another app.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResume`：此方法在`onStart`之后运行，但也可以在我们的活动在先前暂停后恢复时（最合理地）进入。我们可能会重新加载先前保存的用户数据（例如重要笔记），这些数据是在应用程序被中断时保存的，例如电话呼叫或用户运行其他应用程序。'
- en: '`onPause`: This occurs when our app is `onResume`. Activities always transition
    into a paused state when another UI element is displayed on top of the current
    activity (for example, a pop-up dialog) or when the activity is about to be stopped
    (for example, when the user navigates to a different activity).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPause`：当我们的应用程序是`onResume`时发生。当另一个UI元素显示在当前活动的顶部（例如弹出对话框）或活动即将停止时（例如，用户导航到不同的活动）时，活动总是转换到暂停状态。'
- en: '`onStop`: This relates to the `onCreate`, such as releasing system resources
    or writing information to a database. If we reach here, we are probably going
    to get destroyed sometime soon.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onStop`：这与`onCreate`有关，例如释放系统资源或将信息写入数据库。如果我们到达这里，我们很可能很快就会被销毁。'
- en: '`onDestroy`: This is when our activity is finally being **destroyed**. There
    is no turning back from this phase. It''s our last chance to dismantle our app
    in an orderly manner. If we reach here, we will be going through the lifecycle
    phases from the beginning next time.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDestroy`：这是当我们的活动最终被**销毁**时。从这个阶段开始就没有回头路了。这是我们有序拆除我们的应用程序的最后机会。如果我们到达这里，下次我们将从头开始经历生命周期阶段。'
- en: 'This diagram shows the likely flows of execution between the methods:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示了方法之间可能的执行流程：
- en: '![Figure 6.1 –  Flow of execution'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 - 执行流程'
- en: '](img/B16773_06_01.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16773_06_01.jpg)'
- en: Figure 6.1 – Flow of execution
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 - 执行流程
- en: All the method descriptions and their related phases should appear straightforward.
    The only real question is what about the running phase? As we will see when we
    write our code in the other methods/phases, the `onCreate`, `onStart`, and `onResume`
    methods will prepare the app, which then persists, forming the running phase.
    Then the `onPause`, `onStop`, and `onDestroy` methods will occur afterward.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的方法描述及其相关阶段应该都很简单。唯一真正的问题是运行阶段是什么？当我们在其他方法/阶段中编写代码时，我们将看到`onCreate`，`onStart`和`onResume`方法将准备应用程序，然后持续形成运行阶段。然后`onPause`，`onStop`和`onDestroy`方法将随后发生。
- en: Now we can look at these lifecycle methods in action with a mini app. We will
    do so by overriding them all and adding a `Log` message and a `Toast` message
    to each. This will visually prove the phases our app passes through.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过一个迷你应用程序来观察这些生命周期方法的作用。我们将通过重写它们并为每个方法添加一个`Log`消息和一个`Toast`消息来做到这一点。这将直观地证明我们的应用程序经过了哪些阶段。
- en: Lifecycle demo app
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期演示应用程序
- en: In this section, we will do a quick experiment that will help familiarize ourselves
    with the lifecycle methods our app uses as well as giving us a chance to play
    around with a bit more Java code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将进行一个快速实验，帮助我们熟悉应用程序使用的生命周期方法，并让我们有机会玩一些更多的Java代码。
- en: 'Follow these steps to start a new project and then we can add some code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤开始一个新项目，然后我们可以添加一些代码：
- en: Start a new project.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新项目。
- en: Choose the **Basic Activity** template.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**基本活动**模板。
- en: Call the project **Lifecycle Demo**. Of course, the code is in the download
    bundle in the [*Chapter 6*](B16773_06_ePub_RK.xhtml#_idTextAnchor119) folder should
    you wish to refer to it or copy and paste it.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为**生命周期演示**。当然，如果您希望参考或复制粘贴，代码在[*第6章*](B16773_06_ePub_RK.xhtml#_idTextAnchor119)文件夹中的下载包中。
- en: Wait for Android Studio to generate the project files and then open the `MainActivity.java`
    file in the code editor.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待Android Studio生成项目文件，然后在代码编辑器中打开`MainActivity.java`文件。
- en: You have created a new project with all the default settings. We will only need
    the `MainActivity.java` file for this demonstration and will not be building a
    UI.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经使用所有默认设置创建了一个新项目。对于这个演示，我们只需要`MainActivity.java`文件，不需要构建UI。
- en: Coding the lifecycle demo app
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写生命周期演示应用程序
- en: 'In the `MainActivity.java` file, find the `onCreate` method and add these two
    lines of code just before the closing curly `}` brace, which marks the end of
    the `onCreate` method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity.java`文件中，找到`onCreate`方法，并在闭合大括号`}`之前添加以下两行代码，标志着`onCreate`方法的结束：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The entire `onCreate` method should now look like this next code, where the
    highlighted code is the two lines we just added and the `…` is where we have skipped
    some lines of autogenerated code to make the book more readable. For the full
    code listing, check the `MainActivity.java` file in the download bundle. Here
    is the code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 整个`onCreate`方法现在应该看起来像下面的代码，其中高亮显示的代码是我们刚刚添加的两行，`…`是我们跳过一些自动生成的代码行，以使书更易读。有关完整的代码清单，请检查下载包中的`MainActivity.java`文件。以下是代码：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Remember you will need to use the *Alt* + *Enter* keyboard combination twice
    to import the classes needed for `Toast` and `Log.`
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您需要使用*Alt* + *Enter*键盘组合两次来导入`Toast`和`Log`所需的类。
- en: 'After the closing curly brace, `}`, of the `onCreate` method, leave one clear
    line and add the following five lifecycle methods and their contained code. Also
    note that it doesn''t matter in what order we add our overridden methods. Android
    will call them in the correct order regardless of the order in which we type them:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`方法的闭合大括号`}`之后，留出一行空白，并添加以下五个生命周期方法及其包含的代码。还要注意，我们添加重写方法的顺序并不重要。Android将根据我们输入的顺序正确调用它们：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, let's talk about the code itself. Notice that the method names all correspond
    to the lifecycle methods and phases we discussed earlier in this chapter. Notice
    that all the method declarations are preceded by the `@Override` line of code.
    Also see that the first line of code inside each method is `super.on...`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈代码本身。请注意，方法名称都对应于我们在本章前面讨论过的生命周期方法和阶段。请注意，所有方法声明都在`@Override`代码行之前。还要看到每个方法内部的第一行代码是`super.on...`。
- en: 'What exactly is going on here is the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里到底发生了什么是以下内容：
- en: Android calls our methods at the various times we have already discussed.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android在我们已经讨论过的各个时间调用我们的方法。
- en: The `@Override` keyword shows that these methods replace/override the original
    version of the method that is provided as part of the Android API. Note that we
    don't see these overridden methods but they are there, and if we didn't override
    them these original versions would be called by Android instead of ours.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Override`关键字表示这些方法替换/重写了作为Android API的一部分提供的方法的原始版本。请注意，我们看不到这些重写的方法，但它们是存在的，如果我们没有重写它们，Android将调用这些原始版本而不是我们的版本。'
- en: The `super.on...`, which is the first line of code within each of the overridden
    methods, then calls these original versions. So, we don't simply override these
    original methods in order to add our own code – we also call them, and their code
    is executed too.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在重写方法的每个方法内部的第一行代码`super.on...`，然后调用这些原始版本。因此，我们不仅仅是重写这些原始方法以添加我们自己的代码 - 我们还调用它们，它们的代码也被执行。
- en: Tip
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: For the curious, the keyword `super` is for super-class. We will explore method
    overriding and super classes in several chapters as we progress.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于好奇的人，关键字`super`是用于超类。随着我们的进展，我们将在几章中探讨方法重写和超类。
- en: Finally, the code that you added will make each of the methods output one `Toast`
    message and one `Log` message. However, the messages that are output vary, as
    can be seen by the text in between the double quote marks `""`. The messages that
    are output will make it clear which method produced them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您添加的代码将使每个方法输出一个`Toast`消息和一个`Log`消息。但是，输出的消息是不同的，可以通过双引号`""`之间的文本看出。输出的消息将清楚地表明是哪个方法产生了它们。
- en: Running the lifecycle demo app
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行生命周期演示应用程序
- en: 'Now that we have looked at the code, we can play with our app and learn about
    the lifecycle from what happens:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了代码，我们可以玩一下我们的应用程序，并从发生的事情中了解生命周期：
- en: Run the app on either a device or an emulator.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行应用程序。
- en: 'Watch the screen of the emulator and you will see the following appear one
    after the other as `Toast` messages on the screen: **In onCreate**, **In onStart**,
    and **In onResume.**'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察模拟器屏幕，您将看到以下`Toast`消息依次出现在屏幕上：**在onCreate**，**在onStart**和**在onResume**。
- en: Notice the following messages in the logcat window. If there are too many messages,
    remember you can filter them by setting the **Log level** drop-down to **Info**.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意日志窗口中的以下消息。如果有太多的消息，请记住您可以通过将**日志级别**下拉菜单设置为**信息**来过滤它们。
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now tap the back button on the emulator or the device. Notice you get the following
    three `Toast` messages in exactly this order: **In onPause**, **In onStop**, and
    **In onDestroy**. Verify that we have matching output in the logcat window.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击模拟器或设备上的返回按钮。注意您会按照以下顺序收到三条`Toast`消息：**在onPause**，**在onStop**和**在onDestroy**。验证我们在logcat窗口中有匹配的输出。
- en: Next, run a different app – perhaps the *Hello Android* app from[*Chapter 1*](B16773_01_ePub_RK.xhtml#_idTextAnchor014)*,
    Beginning Android and Java,* (but any app will do) – by tapping its icon on the
    emulator/device screen.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行另一个应用程序 - 也许是[*第1章*](B16773_01_ePub_RK.xhtml#_idTextAnchor014)*，开始Android和Java*中的*Hello
    Android*应用程序（但任何应用程序都可以）- 通过点击模拟器/设备屏幕上的图标。
- en: 'Now try the following: open the task manager on the emulator.'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试以下操作：在模拟器上打开任务管理器。
- en: See [*Chapter 3*](B16773_03_ePub_RK.xhtml#_idTextAnchor064)*, Exploring Android
    Studio and the Project Structure,* and the *Using the emulator as a real device*
    section for how to do this on the emulator if you are unsure.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您不确定，可以参考[*第3章*](B16773_03_ePub_RK.xhtml#_idTextAnchor064)*，探索Android Studio和项目结构*以及*在模拟器上使用模拟器作为真实设备*部分。
- en: You should now see all the recently run apps on the device.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您应该在设备上看到所有最近运行的应用程序。
- en: Tap the **Lifecycle Demo** app and notice that the usual three starting messages
    are shown. This is because our app was previously destroyed.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Lifecycle Demo**应用程序，注意到通常的三个启动消息被显示出来。这是因为我们的应用程序先前被销毁了。
- en: Now, however, tap the **task manager** button again and switch to the **Hello
    Android** app. Notice that this time, only the **In onPause** and **In onStop**
    messages are shown. Verify that we have matching output in the logcat. The app
    has *not* been destroyed.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，现在再次点击**任务管理器**按钮，并切换到**Hello Android**应用程序。注意这次只显示了**在onPause**和**在onStop**消息。验证我们在logcat中有匹配的输出。应用程序*没有*被销毁。
- en: Now, again using the `onCreate` was not required to get the app running again.
    This is as expected because the app was not previously destroyed, merely stopped.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次使用`onCreate`不需要重新运行应用程序。这是预期的，因为应用程序先前并没有被销毁，只是停止了。
- en: Next, let's talk about what we saw when we ran the app.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈我们运行应用程序时看到的情况。
- en: Examining the lifecycle demo app output
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查生命周期演示应用程序的输出
- en: When we started the lifecycle demo app for the first time, we saw that the `onCreate`,
    `onStart`, and `onResume` methods were called. Then, when we closed the app using
    the `onPause`, `onStop`, and `onDestroy` methods were called.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次启动生命周期演示应用程序时，我们看到`onCreate`，`onStart`和`onResume`方法被调用。然后，当我们使用`onPause`，`onStop`和`onDestroy`方法关闭应用程序时被调用。
- en: Furthermore, we know from our code that the original versions of all these methods
    are also called because we are calling them ourselves with the `super.on...` code,
    which is the first thing we do in each of our overridden methods.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们从我们的代码中知道，所有这些方法的原始版本也被调用了，因为我们在每个重写的方法中都使用了`super.on...`代码，这是我们做的第一件事。
- en: The quirk in our app's behavior came when we used the task manager to switch
    between apps – when switching away from the lifecycle demo, it was not destroyed
    and, subsequently, when switching back, it was not necessary to run `onCreate`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序行为的怪癖出现在我们使用任务管理器在应用程序之间切换时 - 当从生命周期演示切换时，它没有被销毁，因此，当切换回来时，不需要运行`onCreate`。
- en: Where's my Toast?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我的Toast在哪里？
- en: The opening three and closing three `Toast` messages are queued and the methods
    have already completed by the time they are shown. You can verify this by running
    the experiments again and will see that all three starting/closing log messages
    are output before even the second `Toast` message is shown. However, the `Toast`
    messages do reinforce our knowledge about the order, if not the timing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 开头的三个和结尾的三个`Toast`消息被排队了，并且这些方法在它们被显示的时候已经完成了。您可以通过再次运行实验来验证这一点，会发现所有三个启动/关闭日志消息在第二个`Toast`消息甚至显示之前就已经输出了。然而，`Toast`消息确实加强了我们对顺序的了解，尽管不是时机。
- en: It is entirely possible (but not that likely) that you got slightly different
    results when you followed the preceding steps. What we know for sure is that when
    our apps are run on thousands of different devices by millions of different users
    who have different preferences for interacting with their devices, Android will
    call the lifecycle methods at times we cannot easily predict.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当您按照上述步骤进行时，可能会得到略有不同的结果，这是完全可能的（但不太可能）。我们确定的是，当我们的应用程序在成千上万不同的设备上由数百万不同的用户运行时，这些用户对与设备交互的偏好也不同，Android会在我们无法轻易预测的时候调用生命周期方法。
- en: For example, what happens when the user exits the app by pressing the home button?
    When we open two apps one after the other and then use the back button to switch
    to the earlier app, will that destroy or just stop the app? What happens when
    the user has a dozen apps in their task manager and the operating system needs
    to destroy some apps that were previously only stopped; will our app be one of
    the "victims"?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当用户按下主页按钮退出应用程序时会发生什么？当我们连续打开两个应用程序，然后使用返回按钮切换到先前的应用程序时，会销毁还是只是停止应用程序？当用户在任务管理器中有十几个应用程序，操作系统需要销毁一些先前只是停止的应用程序时，我们的应用程序会成为“受害者”之一吗？
- en: You can, of course, test out all the preceding scenarios on the emulator. But
    the results will only be true for the one time you test it. It is not guaranteed
    that the same behavior will be shown every time and certainly not on every different
    Android device.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以在模拟器上测试所有前面的场景。但结果只对你测试的那一次有效。不能保证每次都会显示相同的行为，当然也不会在每个不同的Android设备上显示相同的行为。
- en: 'At last some good news! The solution to all this complexity is to follow a
    few simple rules:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一些好消息！解决所有这些复杂性的方法是遵循一些简单的规则：
- en: Set up your app ready to run in the `onCreate` method.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中设置你的应用程序准备运行。
- en: Load your user's data in the `onResume` method.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`onResume`方法中加载用户的数据。
- en: Save your user's data in the `onPause` method.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`onPause`方法中保存用户的数据。
- en: Tidy up your app and make it a good Android citizen in the `onDestroy` method.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`onDestroy`方法中整理你的应用程序，使其成为一个良好的Android公民。
- en: Watch out throughout the book for a couple of occasions when we might like to
    use `onStart` and `onStop`.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在整本书中要注意一些情况，我们可能会想使用`onStart`和`onStop`。
- en: If we do what we mentioned above (we will see how over the course of the book),
    we can just stop worrying about all this lifecycle stuff and let Android handle
    it! There are a few more methods we can override as well. So, let's look at them.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按照上面提到的做（我们将在本书的过程中看到如何做），我们可以不再担心所有这些生命周期的东西，让Android来处理它！我们还可以重写一些其他方法。所以，让我们来看看它们。
- en: Some other overridden methods
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些其他重写的方法
- en: You may have noticed that there are two other autogenerated methods in the code
    of all our projects using the Basic Activity template. They are `onCreateOptionsMenu`
    and `onOptionsItemSelected`. Most Android apps have a pop-up menu so Android Studio
    generates one by default; including the basic code to make it work.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在使用基本活动模板的所有项目的代码中，还有另外两个自动生成的方法。它们是`onCreateOptionsMenu`和`onOptionsItemSelected`。大多数Android应用程序都有一个弹出菜单，所以Android
    Studio默认生成一个；包括使其工作的基本代码。
- en: 'You can see the XML that describes the menu in `res/menu/menu_main.xml` from
    the project explorer. The key line of XML code is this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在项目资源管理器中的`res/menu/menu_main.xml`中看到描述菜单的XML。XML代码的关键行是这样的：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This describes a menu **item** with the text **Settings**. If you run any of
    the apps built with the Basic Activity template we have created so far, you will
    see the button as shown next:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这描述了一个带有文本**设置**的菜单**项目**。如果你运行使用我们迄今为止创建的基本活动模板构建的任何应用程序，你将会看到下面显示的按钮：
- en: '![Figure 6.2 – Settings button'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 - 设置按钮'
- en: '](img/B16773_06_02.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16773_06_02.jpg)'
- en: Figure 6.2 – Settings button
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 - 设置按钮
- en: 'If you tap the button, you will see it in action as shown next:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击按钮，你将会看到它的动作如下所示：
- en: '![Figure 6.3 – Settings option'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 - 设置选项'
- en: '](img/B16773_06_03.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16773_06_03.jpg)'
- en: Figure 6.3 – Settings option
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 - 设置选项
- en: So, how do the `onCreateOptionsMenu` and `onOptionsItemSelected` methods produce
    these results?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`onCreateOptionsMenu`和`onOptionsItemSelected`方法是如何产生这些结果的呢？
- en: 'The `onCreateOptionsMenu` method loads the menu from the `menu_main.xml` file
    with this line of code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`onCreateOptionsMenu`方法使用以下代码从`menu_main.xml`文件加载菜单：'
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It is called by the default version of the `onCreate` method, which is why we
    don't see it happen.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它是由`onCreate`方法的默认版本调用的，这就是为什么我们没有看到它发生。
- en: Tip
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: We will use the pop-up menu in [*Chapter 17*](B16773_17_ePub_RK.xhtml#_idTextAnchor300)*,*
    *Data Persistence and Sharing,* to switch between different screens of our app.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第17章*](B16773_17_ePub_RK.xhtml#_idTextAnchor300)*，* *数据持久性和共享*中使用弹出菜单，在我们的应用程序的不同屏幕之间切换。
- en: The `onOptionsItemSelected` method is called when the user taps the menu button.
    This method handles what will happen when an item is selected. Now nothing happens
    – it just `returns true`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`onOptionsItemSelected`方法在用户点击菜单按钮时被调用。这个方法处理当项目被选中时会发生什么。现在什么都不会发生 - 它只是`返回true`。'
- en: Feel free to add `Toast` and `Log` messages to these methods to test out the
    order and timing I have just described. I just thought it was a good time to quickly
    introduce these two methods because they have been lurking around in our code
    without an introduction and I didn't want them to feel left out.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 随意在这些方法中添加`Toast`和`Log`消息，以测试我刚刚描述的顺序和时间。我只是觉得现在是一个好时机来快速介绍这两个方法，因为它们一直潜伏在我们的代码中，没有介绍，我不想让它们感到被忽视。
- en: Now we have seen how the Android lifecycle works and been introduced to a whole
    bunch of methods we can override to interact with the lifecycle, we had better
    learn the fundamentals of Java so that we can write some code to go in these methods
    as well as our own methods.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Android生命周期的工作方式，并介绍了一大堆可以重写以与生命周期交互的方法，我们最好学习一下Java的基础知识，这样我们就可以编写一些代码放入这些方法以及我们自己的方法了。
- en: The structure of Java code – revisited
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java代码的结构 - 重新审视
- en: We have already seen that each time we create a new Android project, we also
    create a new Java **package** as a kind of container for the code we write.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，每次创建一个新的Android项目时，我们也会创建一个新的Java**包**作为我们编写的代码的一种容器。
- en: 'We have also learned about and played around with `Log` and `Toast`. We have
    also used the `AppCompatActivity` class, but in a different manner to `Log` and
    `Toast`. You might remember the first line of code in all our projects so far,
    after the `import` statements, used the `extends` keyword:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了并尝试了`Log`和`Toast`。我们还使用了`AppCompatActivity`类，但使用方式与`Log`和`Toast`不同。你可能还记得迄今为止我们所有项目中的第一行代码，在`import`语句之后使用了`extends`关键字：
- en: '[PRE8]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When we extend a class as opposed to just importing it, we are making it our
    own. In fact, if you take another look at the line of code, you can see that we
    are making a new class with a new name, `MainActivity.` but basing it on the `AppCompatActivity`
    class from the Android API.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们扩展一个类而不仅仅是导入它时，我们就把它变成了我们自己的。事实上，如果你再看一下代码行，你会发现我们正在创建一个新的类，名为`MainActivity`，但是基于Android
    API中的`AppCompatActivity`类。
- en: Important note
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `AppCompatActivity` class is a slightly modified version of the `Activity`
    class. It gives extra features for older versions of Android that would otherwise
    not be present. Everything we have discussed regarding `Activity` is equally true
    for `AppCompatActivity`. We will see some more variations in the `Activity` class
    as we progress. It is entirely possible that you have a different class in place
    of `AppCompatActivity`, dependent upon changes that have taken place since this
    was written. Updates of Android Studio will sometimes change the default `Activity`
    class that it uses when it creates a new project. If the name ends in `...Activity`,
    it doesn't matter because everything we have discussed and will discuss is equally
    true. I will just refer to this class simply as `Activity`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppCompatActivity`类是`Activity`类的稍微修改版本。它为较旧版本的Android提供了额外的功能，否则这些功能将不存在。关于`Activity`的所有讨论同样适用于`AppCompatActivity`。随着我们的进展，我们将看到`Activity`类中的一些变化。有可能你的`AppCompatActivity`已经被其他类替代，这取决于自此书写以来发生的变化。Android
    Studio的更新有时会更改创建新项目时使用的默认`Activity`类。如果名称以`...Activity`结尾，那没关系，因为我们讨论过的和将要讨论的一切同样适用。我将简单地将这个类称为`Activity`。'
- en: 'In summary:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 总之：
- en: We can import classes to use them.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以导入类来使用它们。
- en: We can extend classes to use them.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以扩展类来使用它们。
- en: We will eventually make our own classes.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们最终会创建自己的类。
- en: 'The crucial point here is this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键点是：
- en: Classes, in their various forms, are the foundations of every single line of
    code in Java. Everything in Java is or is part of a class.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 类以各种形式是Java代码的基础。Java中的一切都是类或是类的一部分。
- en: Our own classes and those written by others are the building blocks of our code
    and the methods within the classes wrap the functional code – the code that does
    the work.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自己的类和其他人编写的类是我们代码的构建块，类中的方法包装了功能代码 - 执行工作的代码。
- en: 'We can write methods within the classes that we extend; as we did with `topClick`
    and `bottomClick` in [*Chapter 2*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*,*
    *First Contact: Java, XML, and the UI Designer*. Furthermore, we overrode methods
    that are already part of classes written by others – such as `onCreate` and `onPause`
    and so on.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在扩展的类中编写方法；就像我们在[*第2章*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*，初次接触：Java，XML和UI设计师*中所做的`topClick`和`bottomClick`一样。此外，我们还重写了其他人已经编写的类中的方法，比如`onCreate`和`onPause`等等。
- en: The only code, however, that we put in these methods was a few calls using `Toast`
    and `Log`. We aren't going to code the next killer app with just that. But now
    we can take some more steps.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在这些方法中放入的唯一代码是使用`Toast`和`Log`进行了一些调用。我们不会仅凭这些编写下一个杀手级应用程序。但现在我们可以迈出更多的步伐。
- en: Introducing fragments and the lifecycle
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入片段和生命周期
- en: 'You probably remember from [*Chapter 2*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*,
    First Contact: Java, XML, and the UI Designer,* that the Java code in the Basic
    Activity template is not just contained in the `MainActivity.java` file. There
    are also the `FirstFragment.java` and `SecondFragment.java` files. These files,
    we learned, contain the code that controls what happens when the user navigates
    between the two screens of the Basic Activity template app. The code inside these
    two files is different in structure from the `MainActivity.java` file. Here is
    a quick peek at `FirstFragment.java`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得从[*第2章*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*，初次接触：Java，XML和UI设计师*中，Basic
    Activity模板中的Java代码不仅包含在`MainActivity.java`文件中。还有`FirstFragment.java`和`SecondFragment.java`文件。我们了解到，这些文件包含了控制用户在Basic
    Activity模板应用的两个屏幕之间导航时发生的事情的代码。这两个文件中的代码结构与`MainActivity.java`文件中的代码不同。这里快速看一下`FirstFragment.java`：
- en: '[PRE9]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I have omitted much of the code from this file because it is unnecessary for
    the purpose of this introductory discussion. A `Fragment` can, and in this app
    does, represent a screen from the app. The `Fragment` classes of this app and
    other apps that contain them are controlled by the `Activity` class(es). We will
    look closely at the `Fragment` class in [*Chapter 24*](B16773_24_ePub_RK.xhtml#_idTextAnchor411),
    *Design Patterns, Multiple Layouts, and Fragments*. The thing to notice here is
    that the `Fragment` class has an `onCreateView` method.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我从这个文件中省略了大部分代码，因为它对于这个介绍性讨论来说是不必要的。一个`Fragment`可以，而且在这个应用程序中确实代表着应用程序的一个屏幕。这个应用程序和其他包含`Fragment`类的应用程序的`Fragment`类由`Activity`类控制。我们将在[*第24章*](B16773_24_ePub_RK.xhtml#_idTextAnchor411)*，设计模式，多个布局和片段*中仔细研究`Fragment`类。这里需要注意的是`Fragment`类有一个`onCreateView`方法。
- en: When our app uses one or more instances of the `Fragment` class, they will also
    be a part of the Android lifecycle and the `Fragment` class has its own set of
    lifecycle methods, of which `onCreateView` is one.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序使用一个或多个`Fragment`类的实例时，它们也将成为Android生命周期的一部分，`Fragment`类有自己的一组生命周期方法，其中`onCreateView`是其中之一。
- en: Exactly how the OS lifecycle, the `Activity` class, and the `Fragment` class
    interact with each other will be explained in [*Chapter 24*](B16773_24_ePub_RK.xhtml#_idTextAnchor411)*,
    Design Patterns, Multiple Layouts, and Fragments*. It is just worth knowing for
    now that they are all interconnected.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的生命周期、`Activity`类和`Fragment`类之间的交互将在[*第24章*](B16773_24_ePub_RK.xhtml#_idTextAnchor411)*，设计模式，多个布局和片段*中得到解释。现在只需要知道它们是相互关联的。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have learned about the Android lifecycle and how the operating system calls
    set methods at set times.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了Android生命周期以及操作系统在特定时间调用设置方法。
- en: We have also seen that it is not only us that can call our code. The operating
    system can also call the code contained within the methods we have overridden.
    By adding the appropriate code into the various overridden lifecycle methods,
    we can be sure that the right code will be executed at the right time.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到不仅我们可以调用我们的代码。操作系统也可以调用我们重写的方法中包含的代码。通过在各种重写的生命周期方法中添加适当的代码，我们可以确保在正确的时间执行正确的代码。
- en: What we need to do now is learn how to write some more Java code. In the next
    chapter, we'll start to focus on Java, and because we have such a good grounding
    already on Android, we will have no problem practicing and using everything we
    learn.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的是学习如何编写更多的Java代码。在下一章中，我们将开始专注于Java，因为我们已经在Android上有了很好的基础，所以我们将毫无问题地练习和运用我们所学到的一切。
