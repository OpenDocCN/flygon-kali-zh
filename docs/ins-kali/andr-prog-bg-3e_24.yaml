- en: '*Chapter 24*: Design Patterns, Multiple Layouts, and Fragments'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第24章*：设计模式、多种布局和片段'
- en: We have come a long way since the start when we were just setting up Android
    Studio. Back then, we went through everything step by step, but as we have proceeded
    we have tried to show not just how to add x to y or feature a to app b, but to
    enable you to use what you have learned in your own ways to bring your own ideas
    to life.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们刚开始设置Android Studio的时候，我们已经走了很长的路。那时，我们一步一步地进行了所有操作，但随着我们的进展，我们试图展示的不仅仅是如何将x添加到y或将功能a添加到应用程序b，而是让你能够以自己的方式使用所学到的知识来实现自己的想法。
- en: At first glance, this chapter might seem dry and technical, but this chapter
    is more about your future apps than anything in the book so far. We will look
    at a few aspects of Java and Android that you can use as a framework or template
    to make evermore exciting and complex apps at the same time as keeping the code
    manageable. This is the key to successful modern apps. Furthermore, I will suggest
    areas of further study that there is simply not enough room to even scratch the
    surface of in this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这一章可能看起来枯燥而技术性，但这一章更多地关乎你未来的应用程序，而不是迄今为止书中的任何内容。我们将看一下Java和Android的一些方面，你可以将其用作框架或模板，以制作更加令人兴奋和复杂的应用程序，同时保持代码的可管理性。这是成功现代应用程序的关键。此外，我将建议进一步学习的领域，这本书中根本没有足够的空间来涉及。
- en: 'In this chapter, we will learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学习以下内容：
- en: Patterns and model-view-controller
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式和模型-视图-控制器
- en: Android design guidelines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android设计指南
- en: Getting started with real-world designs and handling multiple different devices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用真实世界的设计和处理多种不同的设备
- en: An introduction to Fragments
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 片段简介
- en: Let's get started.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2024](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2024).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件[https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2024](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2024)。
- en: Introducing the model-view-controller pattern
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍模型-视图-控制器模式
- en: The model-view-controller pattern involves the separation of different aspects
    of our app into distinct parts called layers. Android apps commonly use the model-view-controller
    pattern. A pattern is simply a recognized way to structure our code and other
    application resources such as layout files, images, databases, and so on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模型-视图-控制器模式涉及将我们应用程序的不同方面分离成称为层的明确部分。Android应用程序通常使用模型-视图-控制器模式。模式只是一种公认的结构代码和其他应用资源（如布局文件、图像、数据库等）的方式。
- en: Patterns are useful to us because by conforming to a pattern, we can be more
    confident we are doing things right and are less likely to have to undo lots of
    hard work because we have coded ourselves into an awkward situation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 模式对我们很有用，因为通过遵循模式，我们可以更有信心地做正确的事情，也不太可能因为将自己编码到尴尬的境地而不得不撤销大量的辛苦工作。
- en: There are many patterns in computer science but an understanding of **model-view-controller**
    (**MVC**) will be enough to create some professionally built Android apps.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中有许多模式，但了解模型-视图-控制器（MVC）就足以创建一些专业构建的Android应用程序。
- en: 'We have been partly using MVC already, so let''s look at each of the three
    layers in turn:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经部分地使用了MVC，所以让我们依次看看这三个层：
- en: '`Note` class along with its getters, setters, and JSON code was the data and
    logic.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Note`类以及它的getter、setter和JSON代码是数据和逻辑。'
- en: '`View` class hierarchy of the Android API.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android API的`View`类层次结构。
- en: '**Controller**: The controller is the bit in between the view and the model.
    It interacts with both and keeps them separate. It contains what is known in geek
    speak as the application logic. If a user taps a button, the application layer
    decides what to do about it. When the user clicks **OK** to add a new note, the
    application layer listens for the interaction on the view layer. It captures the
    data contained in the view and passes it to the model layer.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器：控制器是视图和模型之间的部分。它与两者进行交互并保持它们分开。它包含了所谓的应用逻辑。如果用户点击按钮，应用层决定如何处理它。当用户点击“确定”以添加新的注释时，应用层监听视图层上的交互。它捕获视图中包含的数据并将其传递给模型层。
- en: Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: 'Design patterns are a huge topic. There are many different design patterns
    and if you want a beginner-friendly introduction to the topic in general, I would
    recommend *Head First Design Patterns*. If you want to really dive into the world
    of design patterns, then you can try *Design Patterns: Elements of Reusable Object-Oriented
    Software*, which is recognized as a kind of design pattern oracle but is much
    harder reading.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '设计模式是一个庞大的主题。有许多不同的设计模式，如果你想对这个主题有一个适合初学者的介绍，我会推荐《Head First Design Patterns》。如果你想深入了解设计模式的世界，那么你可以尝试《Design
    Patterns: Elements of Reusable Object-Oriented Software》，这本书被认为是一种设计模式的权威，但阅读起来要困难得多。'
- en: As the book progresses, we will also begin to utilize more of the object-oriented
    programming aspects we have discussed but not fully benefited from so far. We
    will do so step by step.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 随着书籍的进展，我们还将开始更多地利用我们已经讨论过但尚未充分利用的面向对象编程方面。我们将一步一步地做到这一点。
- en: Android design guidelines
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android设计指南
- en: App design is a vast topic. It is a topic that could only begin to be taught
    in a book of its own. Also, like programming, you can only start to get good at
    app design with constant practice, review, and improvement.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序设计是一个广阔的主题。这是一个只能在一本专门的书中开始教授的主题。而且，就像编程一样，只有通过不断的练习、审查和改进，你才能开始擅长应用程序设计。
- en: So, what exactly do I mean by design? I am talking about where you put the widgets
    on the screen, which widgets, what color should they be, how big should they be,
    how to transition between screens, the best way to scroll a page, when and which
    animation interpolators to use, what screens your app should be divided into,
    and much more besides.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我所说的设计到底是什么意思呢？我指的是您将小部件放在屏幕上的位置，使用哪些小部件，它们应该是什么颜色，大小应该是多少，如何在屏幕之间进行过渡，滚动页面的最佳方式，何时以及使用哪些动画插值器，您的应用程序应该分成哪些屏幕，以及还有更多其他内容。
- en: This book will hopefully leave you well qualified to be able to *implement*
    all your choices for the above questions. It unfortunately doesn't have the space,
    and the author probably doesn't have the skill, to teach you how to *make* those
    choices.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 希望本书能让您有能力*实施*您对上述问题的所有选择。不幸的是，本书没有足够的空间，作者可能也没有足够的技能来教您如何*做出*这些选择。
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You might be wondering, "What should I do?" Keep making apps and don't let a
    lack of design experience and knowledge stop you! Even release your apps to the
    app store. Keep in mind, however, that there is this whole other topic – design
    – that needs some attention if your apps are going to truly be world-class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想，“我应该怎么办？”继续制作应用程序，不要让缺乏设计经验和知识阻止您！甚至将您的应用程序发布到应用商店。但请记住，还有这样一个完全不同的话题
    - 设计 - 如果您的应用程序真的要成为世界一流的应用程序，那就需要一些关注。
- en: In even medium-sized development companies, the designer is rarely also the
    programmer, and even very small companies will often outsource the design of their
    app (or designers might outsource the coding).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在中等规模的开发公司中，设计师很少也是程序员，即使是非常小的公司也经常会外包他们的应用程序的设计（或设计师可能会外包编码）。
- en: Designing is both art and science, and Google has demonstrated that they recognize
    this with high-quality support for both existing designers and aspiring new designers.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 设计既是艺术又是科学，Google已经证明他们认识到这一点，为现有设计师和新设计师提供了高质量的支持。
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'I highly recommend you visit and bookmark this web page: [https://developer.android.com/design/](https://developer.android.com/design/).
    It is quite detailed and comprehensive, is totally Android focused, and has a
    load of resources in the form of images, color palettes, and guidelines.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您访问并收藏这个网页：[https://developer.android.com/design/](https://developer.android.com/design/)。它非常详细和全面，完全专注于Android，并提供了大量的资源，包括图像、调色板和指南。
- en: Make understanding design principles a short-term goal. Make improving your
    actual design skills an ongoing task. Visit and read design-focused websites and
    try and implement the ideas that you find exciting.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使理解设计原则成为短期目标。使提高您的实际设计技能成为一项持续的任务。访问并阅读以设计为重点的网站，并尝试实施您发现令人兴奋的想法。
- en: Most important of all, however, don't wait until you are a design expert to
    make apps. Keep bringing your ideas to life and publishing them. Make a point
    of making each app a little better designed than the last.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最重要的是，不要等到您成为设计专家才开始制作应用程序。继续将您的想法付诸实践并发布它们。要求每个应用程序的设计都比上一个稍微好一点。
- en: We will see in the coming chapters and have seen already, that the Android API
    makes available to us a whole bunch of super-stylish UIs that we can take advantage
    of with very little code or design skill. These UIs go a long way to making your
    apps look like they have been designed by a professional.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中看到，并且已经看到，Android API为我们提供了一整套超时尚的UI，我们可以利用这些UI，只需很少的代码或设计技能。这些UI在很大程度上使您的应用程序看起来就像是由专业人员设计的。
- en: Real-world apps
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现实世界的应用程序
- en: So far, we have built a dozen or more apps of various complexity. Most of them
    we designed and tested on a phone.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了十几个或更多不同复杂度的应用程序。其中大部分我们都是在手机上设计和测试的。
- en: Of course, in the real world, our apps need to work well on any device and must
    be able to handle what happens when in either portrait or landscape view (on all
    devices).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在现实世界中，我们的应用程序需要在任何设备上都能良好运行，并且必须能够处理在纵向或横向视图（在所有设备上）发生的情况。
- en: Furthermore, it is often not enough for our apps to just work and look "OK"
    on different devices. Often, our apps will need to *behave* differently and appear
    with a significantly different UI based on whether the device is a phone or a
    tablet, and in landscape/portrait orientation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的应用程序通常不能只是在不同设备上“正常工作”和“看起来还行”就足够了。通常，我们的应用程序需要根据设备是手机还是平板电脑，以及是横向还是纵向方向，而表现出明显不同的UI和行为。
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Android supports apps for large screen TVs, smartwatches via the Wear API, virtual
    reality and augmented reality, as well as "things" for the Internet of Things.
    We will not be covering the two latter cases in this book, but by the end of the
    book, it is the author's guess that you will be prepared enough to venture into
    these topics should you choose to.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Android支持大屏幕电视、通过Wear API支持智能手表、虚拟现实和增强现实，以及物联网中的“物品”。本书不涵盖后两种情况，但在本书结束时，作者猜测您将准备好涉足这些话题，如果您选择的话。
- en: 'Look at this screenshot of the BBC weather app running on an Android phone
    in portrait orientation. Look at the basic layout but also study the information
    shown as we will compare it to the tablet app in a moment:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 看看BBC天气应用程序在Android手机上以纵向方向运行的截图。看看基本布局，也研究所显示的信息，因为我们将很快将其与平板应用程序进行比较：
- en: '![Figure 24.1 – BBC weather app running on an Android phone in portrait orientation'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图24.1 - BBC天气应用程序在Android手机上以纵向方向运行'
- en: '](img/Figure_24.01_B16773.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_24.01_B16773.jpg)'
- en: Figure 24.1 – BBC weather app running on an Android phone in portrait orientation
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.1 - BBC天气应用程序在Android手机上以纵向方向运行
- en: 'For now, the purpose of the previous screenshot is not so much to show you
    the specific UI features but to allow you to compare it with the next screenshot.
    Look at the exact same app running on a tablet in landscape orientation:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，上一张截图的目的并不是为了向您展示具体的UI功能，而是为了让您能够将其与下一张截图进行比较。看看在平板电脑上以横向方向运行的完全相同的应用程序：
- en: '![Figure 24.2 – BBC weather app running on an Android phone in landscape orientation'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图24.2 - BBC天气应用程序在Android手机上以横向方向运行'
- en: '](img/Figure_24.02_B16773.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_24.02_B16773.jpg)'
- en: Figure 24.2 – BBC weather app running on an Android phone in landscape orientation
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.2 – BBC天气应用在Android手机上横向方向运行
- en: Notice that the tablet UI has an extra panel of information compared to the
    phone app. This extra panel is highlighted in the preceding screenshot.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与手机应用程序相比，平板电脑UI有一个额外的信息面板。这个额外的面板在前面的截图中被突出显示。
- en: The point of this screenshot again is not so much the specific UI or even how
    we might implement one like it, but more that the UIs are so different they could
    easily be considered totally different apps. Yet if you download this app, it
    is the same download for tablet and phone.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个截图的重点再次不是特定的UI，甚至我们如何实现类似的UI，而是UI是如此不同，它们很容易被认为是完全不同的应用程序。然而，如果您下载这个应用程序，平板电脑和手机是相同的下载。
- en: Android allows us to design real-world apps like this where not only is the
    layout different for varying device types/orientations/sizes but also (and this
    is important) the behavior is different. The Android secret weapon that makes
    this possible is `Fragments`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Android允许我们设计这样的真实应用程序，其中不仅布局针对不同的设备类型/方向/大小是不同的，而且（这一点很重要）行为也是不同的。使这一切成为可能的Android秘密武器是`片段`。
- en: 'Google says:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌说：
- en: '"A Fragment represents a behavior or a portion of user interface in an Activity.
    You can combine multiple fragments in a single activity to build a multi-pane
    UI and reuse a fragment in multiple activities.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: “片段代表活动中的行为或用户界面的一部分。您可以在单个活动中组合多个片段，以构建多窗格UI，并在多个活动中重用片段。
- en: You can think of a fragment as a modular section of an activity, which has its
    own lifecycle, receives its own input events, and which you can add or remove
    while the activity is running (sort of like a "sub activity" that you can reuse
    in different activities).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将片段视为活动的模块化部分，它具有自己的生命周期，接收自己的输入事件，并且您可以在活动运行时添加或删除它（有点像可以在不同活动中重复使用的“子活动”）。
- en: A fragment must always be embedded in an activity and the fragment's lifecycle
    is directly affected by the host activity's lifecycle."
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 片段必须始终嵌入在活动中，片段的生命周期受主机活动的生命周期直接影响。
- en: We can design multiple different layouts in different XML files and we will
    do so soon. We can also detect things such as device orientation and screen resolution
    in our Java code, so we can then make decisions about layout, dynamically.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在不同的XML文件中设计多个不同的布局，我们很快就会这样做。我们还可以在我们的Java代码中检测设备方向和屏幕分辨率，因此我们可以动态地做出布局方面的决策。
- en: Let's try this out using device detection and then we will have our first look
    at Fragments.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用设备检测，然后我们将首次查看片段。
- en: Device detection mini-app
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备检测迷你应用
- en: 'The best way to learn about detecting and responding to devices and their varying
    attributes (screens, orientations, and so on) is to make a simple app:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 了解检测和响应设备及其不同属性（屏幕、方向等）的最佳方法是制作一个简单的应用程序：
- en: Create a new `Device Detection`. Leave all the other settings as their defaults.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`设备检测`。将所有其他设置保留为默认设置。
- en: Open the `activity_main.xml` file in the design tab and delete the default `TextView`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设计选项卡中打开`activity_main.xml`文件，并删除默认的`TextView`。
- en: Drag a `detectDevice`. We will code this method in a minute.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动`detectDevice`。我们将在一分钟内编写这个方法。
- en: Drag two `txtOrientation` and `txtResolution`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动两个`txtOrientation`和`txtResolution`。
- en: 'Check you have a layout that looks something like this next screenshot:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查您是否有一个看起来像下一个截图的布局：
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I have stretched my widgets (mainly horizontally) and increased the `textSize`
    attributes to `24sp` to make them clearer on the screen, but this is not required
    for the app to work correctly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我拉伸了我的小部件（主要是水平方向），并增加了`textSize`属性到`24sp`，以使它们在屏幕上更清晰，但这对于应用程序的正确工作并不是必需的。
- en: '![Figure 24.3– Layout check'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图24.3– 布局检查'
- en: '](img/Figure_24.03_B16773.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_24.03_B16773.jpg)'
- en: Figure 24.3– Layout check
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.3– 布局检查
- en: Click the **Infer Constraints** button to secure the positions of the UI elements.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**推断约束**按钮以固定UI元素的位置。
- en: Now we will do something new. We will build a layout specifically for landscape
    orientation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将做一些新的事情。我们将专门为横向方向构建一个布局。
- en: 'In Android Studio, make sure the `activity_main.xml` file is selected in the
    editor and locate the **Orientation for preview** button as shown next:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中，确保在编辑器中选择了`activity_main.xml`文件，并找到如下所示的**预览方向**按钮：
- en: '![Figure 24.4 – Create Landscape Variation'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图24.4 – 创建横向变化'
- en: '](img/Figure_24.04_B16773.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_24.04_B16773.jpg)'
- en: Figure 24.4 – Create Landscape Variation
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.4 – 创建横向变化
- en: Click it and then select **Create Landscape Variation**.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 单击它，然后选择**创建横向变化**。
- en: 'You now have a new layout XML file with the same name but orientated in landscape
    mode. The layout appears blank in the editor, but as we will see, this is not
    the case. Look at the `layout` folder in the Project Explorer and notice that
    there are indeed two files named `activity_main`, and one of them (the new one
    we just created) is postfixed with **land**. This is shown in the next screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有一个新的布局XML文件，名称相同，但是是横向模式。布局在编辑器中看起来是空白的，但正如我们将看到的那样，情况并非如此。查看项目资源管理器中的`layout`文件夹，并注意确实有两个名为`activity_main`的文件，其中一个（我们刚刚创建的新文件）带有**land**后缀。这在下一个截图中显示：
- en: '![Figure 24.5 – activity_main folder'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图24.5 – activity_main文件夹'
- en: '](img/Figure_24.05_B16773.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_24.05_B16773.jpg)'
- en: Figure 24.5 – activity_main folder
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.5 – activity_main文件夹
- en: 'Select this new file (the one postfixed with **land**) and now look at the
    component tree. It is pictured in the next screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 选择这个新文件（带有**land**后缀的文件），现在查看组件树。它在下一个截图中显示：
- en: '![Figure 24.6 – Component tree'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图24.6 – 组件树'
- en: '](img/Figure_24.06_B16773.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_24.06_B16773.jpg)'
- en: Figure 24.6 – Component tree
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.6 – 组件树
- en: It would appear that the layout already contains all our widgets – we just cannot
    see them in the design view. The reason for this anomaly is that when we created
    the landscape layout, Android Studio copied the portrait layout, including all
    the constraints. The portrait constraints rarely match the landscape constraints.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来布局已经包含了我们所有的小部件 - 我们只是无法在设计视图中看到它们。这种异常的原因是，当我们创建横向布局时，Android Studio复制了纵向布局，包括所有的约束。纵向约束很少与横向约束匹配。
- en: 'To solve the problem, click the **Remove all constraints** button; it''s the
    button to the left of the **Infer constraints** button. The UI is now unconstrained.
    All the UI widgets will appear jumbled up in the top-left corner. One at a time,
    rearrange them to look like this next screenshot. I had to add the constraints
    manually to make this design work so I have shown the constraints in the following
    screenshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，点击**删除所有约束**按钮；它是**推断约束**按钮左侧的按钮。现在UI没有约束了。所有的UI小部件将会混乱地出现在左上角。一次一个，重新排列它们，使其看起来像下一个截图。我不得不手动添加约束来使这个设计工作，所以我在下一个截图中展示了约束：
- en: '![Figure 24.7 – Add the constraints'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图24.7 - 添加约束'
- en: '](img/Figure_24.07_B16773.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_24.07_B16773.jpg)'
- en: Figure 24.7 – Add the constraints
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.7 - 添加约束
- en: Click the `/Device Detection/layout-land` folder.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`/Device Detection/layout-land`文件夹。
- en: Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The appearance doesn't really matter as long as you can see the contents of
    both `TextView` widgets and click the button.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 外观并不重要，只要您能看到两个`TextView`小部件的内容并点击按钮即可。
- en: Now we have a basic layout for two different orientations, we can turn our attention
    to coding the Java.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两种不同方向的基本布局，我们可以把注意力转向编写Java代码。
- en: Coding the MainActivity class
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写MainActivity类
- en: 'Add the following member variables just after the `MainActivity` class declaration,
    to hold references to our two `TextView` widgets:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`类声明之后，添加以下成员变量，以保存对我们两个`TextView`小部件的引用：
- en: '[PRE0]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Import the `TextView` class at this point:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此时导入`TextView`类：
- en: '`import android.widget.TextView;`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.widget.TextView;`'
- en: 'Now, in the `onCreate` method of the `MainActivity` class, just after the call
    to `setContentView`, add this code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`MainActivity`类的`onCreate`方法中，在调用`setContentView`之后，添加以下代码：
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After `onCreate`, add the method that handles our button click and runs our
    detection code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`之后，添加处理我们按钮点击并运行检测代码的方法：
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Import the following three classes:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 导入以下三个类：
- en: '`import android.graphics.Point;`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.graphics.Point;`'
- en: '`import android.view.Display;`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.view.Display;`'
- en: '`import android.view.View;`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.view.View;`'
- en: This code works by declaring and initializing an object of type `Display` called
    `display`. This object (`display`) now holds a whole bunch of data about the specific
    display properties of the device.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过声明和初始化一个名为`display`的`Display`类型的对象来工作。这个对象（`display`）现在保存了关于设备特定显示属性的大量数据。
- en: The result of the `getRotation` method is output into the top `TextView` widget.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRotation`方法的结果输出到顶部的`TextView`小部件中。'
- en: The code then initializes an object of type `Point` called `xy`. The `getSize`
    method then loads up the screen resolution into `xy`. The `setText` method is
    then used to output the horizontal (`xy.x`) and vertical (`xy.y`) resolution into
    the `TextView` widget.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码初始化了一个名为`xy`的`Point`类型的对象。`getSize`方法然后将屏幕分辨率加载到`xy`中。然后使用`setText`方法将水平（`xy.x`）和垂直（`xy.y`）分辨率输出到`TextView`小部件中。
- en: Note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You might remember we used the `Display` and `Point` classes in the Kids drawing
    app.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得我们在Kids绘画应用中使用了`Display`和`Point`类。
- en: Each time the button is clicked, the two `TextView` widgets will be updated.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每次点击按钮，两个`TextView`小部件都将被更新。
- en: Unlocking the screen orientation
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解锁屏幕方向
- en: 'Before we run the app, we want to make sure the device isn''t locked in portrait
    mode (most new phones are by default). From the app drawer of the emulator (or
    the device you will be using), tap the **Settings** app and choose **Display**
    and use the switch to set **Auto-rotate screen** to on. I have shown this setting
    in the next screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行应用程序之前，我们要确保设备没有锁定在纵向模式（大多数新手机默认情况下是这样）。从模拟器的应用抽屉（或您将要使用的设备）中，点击**设置**应用程序，选择**显示**，并使用开关将**自动旋转屏幕**设置为开启。我在下一个截图中展示了这个设置：
- en: '![Figure 24.8 – Auto-rotate screen'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图24.8 - 自动旋转屏幕'
- en: '](img/Figure_24.08_B16773.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_24.08_B16773.jpg)'
- en: Figure 24.8 – Auto-rotate screen
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.8 - 自动旋转屏幕
- en: Running the app
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'Now you can run the app and click the button:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以运行应用程序并点击按钮：
- en: '![Figure 24.9 – Click the button'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图24.9 - 点击按钮'
- en: '](img/Figure_24.09_B16773.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_24.09_B16773.jpg)'
- en: Figure 24.9 – Click the button
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.9 - 点击按钮
- en: 'Rotate the device, using one of the rotate buttons on the emulator control
    panel, to landscape:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟器控制面板上的旋转按钮之一，将设备旋转到横向：
- en: '![Figure 24.10 – Rotate the device'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图24.10 - 旋转设备'
- en: '](img/Figure_24.10_B16773.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_24.10_B16773.jpg)'
- en: Figure 24.10 – Rotate the device
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.10 - 旋转设备
- en: Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can also use *Ctrl* + *F11* on a PC or *Ctrl* + *FN* + *F11* on Mac.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在PC上使用*Ctrl* + *F11*，在Mac上使用*Ctrl* + *FN* + *F11*。
- en: 'Now click the button again and you will see the landscape layout in action:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次点击按钮，您将看到横向布局的效果：
- en: '![Figure 24.11 – Landscape layout'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图24.11 - 横向布局'
- en: '](img/Figure_24.11_B16773.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_24.11_B16773.jpg)'
- en: Figure 24.11 – Landscape layout
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.11 - 横向布局
- en: The first thing you will probably notice is that when you rotate the screen,
    it briefly goes blank. This is the Activity restarting and calling the `onCreate`
    method again – just what we need. It calls the `setContentView` method on the
    landscape version of the layout and the code in `MainActivity` refers to widgets
    with the same ID so the exact same code works.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到的第一件事是，当您旋转屏幕时，屏幕会短暂地变空白。这是Activity重新启动并再次调用`onCreate`方法 - 这正是我们需要的。它在横向布局上调用`setContentView`方法，而`MainActivity`中的代码引用具有相同ID的小部件，所以完全相同的代码可以工作。
- en: Note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Don't spend too long pondering this because we will discuss it later in the
    chapter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 不要花太多时间思考这个问题，因为我们将在本章后面讨论它。
- en: If the 0 and 1 results are less than obvious regarding device orientation, they
    refer to `public static final` variables of the `Surface` class – `Surface.ROTATION_0`
    equals 0 and `Surface.ROTATION_180` equals 1.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果0和1的结果对设备方向不够明显，它们指的是`Surface`类的`public static final`变量 - `Surface.ROTATION_0`等于0，`Surface.ROTATION_180`等于1。
- en: Note
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that if you rotated the screen to the left, then your value will be 1 –
    the same as mine, but if you rotated it to the right, you would have seen the
    value 3\. If you rotate the device to portrait mode upside down, you will get
    the value 4.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您将屏幕向左旋转，那么您的值将是1 - 与我的相同，但如果您将其向右旋转，您将看到值3。如果您将设备旋转到倒置的纵向模式，您将获得值4。
- en: And we could code a `switch` block based on the results of these detection tests
    and load up different layouts.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以根据这些检测测试的结果编写一个`switch`块，并加载不同的布局。
- en: But as we have just seen, Android makes this simpler than this for us by allowing
    us to add specific layouts into folders with configuration qualifiers, such as
    **land**, short for Landscape.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如我们刚才看到的，Android通过允许我们将特定布局添加到带有配置限定符的文件夹中（例如**land**，代表横向）来简化这一过程。
- en: Configuration qualifiers
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置限定符
- en: We have already met configuration qualifiers such as `layout-large` and `layout-xhdpi`
    in [*Chapter 3*](B16773_03_ePub_RK.xhtml#_idTextAnchor064), *Exploring Android
    Studio and the Project Structure*. Here, we will refresh and expand our understanding
    of them.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第3章*](B16773_03_ePub_RK.xhtml#_idTextAnchor064)中遇到了配置限定符，例如`layout-large`和`layout-xhdpi`，*探索Android
    Studio和项目结构*。在这里，我们将刷新并扩展对它们的理解。
- en: We can begin to remove reliance on the controller layer to influence app layout
    by using configuration qualifiers. There are configuration qualifiers for size,
    orientation, and pixel density. To take advantage of a configuration qualifier,
    we simply design a layout in the usual way, optimized for our preferred configuration,
    and then place that layout in a folder with a name that Android recognizes as
    being for that particular configuration.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用配置限定符开始减少对控制器层的影响来影响应用程序布局。有关大小、方向和像素密度的配置限定符。要利用配置限定符，我们只需按照通常的方式设计布局，针对我们首选的配置进行优化，然后将该布局放入Android识别为特定配置的文件夹中。
- en: For example, in the previous app, putting a layout in the `land` folder tells
    Android to use the layout when the device is in the landscape orientation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前一个应用程序中，将布局放入`land`文件夹会告诉Android在设备处于横向方向时使用布局。
- en: 'It is likely that the above statement will seem slightly ambiguous. This is
    because the Android Studio `layout` and `layout-land` folder as shown next:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上述声明可能会显得有些模糊。这是因为Android Studio的`layout`和`layout-land`文件夹如下所示：
- en: '![Figure 24.12 – layout and layout-land folder'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图24.12 - 布局和布局-横向文件夹'
- en: '](img/Figure_24.12_B16773.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_24.12_B16773.jpg)'
- en: Figure 24.12 – layout and layout-land folder
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.12 - 布局和布局-横向文件夹
- en: Switch back to the **Android** view or leave it on the **Project Files** view
    – whichever you prefer.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回**Android**视图或保持在**项目文件**视图上 - 任何您喜欢的。
- en: So, if we want to have a different layout for landscape and portrait, we would
    create a folder called `layout-land` in the `res` folder (or use the shortcut
    we used in the previous app) and place our specially designed layout within it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想要为横向和纵向创建不同的布局，我们将在`res`文件夹中创建一个名为`layout-land`的文件夹（或者使用我们在前一个应用程序中使用的快捷方式），并在其中放置我们专门设计的布局。
- en: When the device is in portrait position, the regular layout from the `layout`
    folder will be used and when it is in landscape position, the layout from the
    `layout-land` folder would be used.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备处于纵向位置时，将使用`layout`文件夹中的常规布局，当设备处于横向位置时，将使用`layout-land`文件夹中的布局。
- en: 'If we are designing for different sizes of screen, we place layouts into folders
    with the following names:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要为不同尺寸的屏幕设计，我们将布局放入以下名称的文件夹中：
- en: '`layout-small`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-small`'
- en: '`layout-normal`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-normal`'
- en: '`layout-large`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-large`'
- en: '`layout-xlarge`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-xlarge`'
- en: 'If we are designing for screens with different pixel densities, we can place
    XML layouts into folders with names like these:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要为不同像素密度的屏幕设计，我们可以将XML布局放入文件夹中，文件夹的名称如下：
- en: '`layout-ldpi` for low-DPI devices'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-ldpi` 用于低DPI设备'
- en: '`layout-mdpi` for medium-DPI devices'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-mdpi` 用于中等DPI设备'
- en: '`layout-hdpi` for high-DPI devices'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-hdpi` 用于高DPI设备'
- en: '`layout-xhdpi` for extra-high DPI devices'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-xhdpi` 用于超高DPI设备'
- en: '`layout-xxhdpi` for extra-extra-high DPI devices'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-xxhdpi` 用于超超高DPI设备'
- en: '`layout-xxxhdpi` for extra-extra-extra-high DPI devices'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-xxxhdpi` 用于超高DPI设备'
- en: '`layout-nodpi` for devices with a DPI you have not otherwise catered for'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-nodpi` 用于未另外适配DPI的设备'
- en: '`layout-tvdpi` for TVs'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-tvdpi` 用于电视'
- en: What exactly qualifies as low, high, or extra-high DPI and so on can be researched
    at the link in the next info box. The point here is the principal.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 低、高或超高DPI等的确切资格可以在下一个信息框中的链接中进行研究。这里的重点是原则。
- en: It is worth pointing out that what we have just discussed is a long way from
    being the whole story regarding configuration qualifiers and, as with design,
    it is worth putting this on your list of things to study further.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，我们刚才讨论的远远不是关于配置限定符的全部故事，与设计一样，值得将其列入进一步研究的事项清单。
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Often, the Android developer site has lots of detailed information on handling
    layouts for different devices. Try this link for more information: [https://developer.android.com/guide/practices/screens_support](https://developer.android.com/guide/practices/screens_support).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Android开发者网站上有大量关于处理不同设备布局的详细信息。请尝试此链接以获取更多信息：[https://developer.android.com/guide/practices/screens_support](https://developer.android.com/guide/practices/screens_support)。
- en: The limitation of configuration qualifiers
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置限定符的限制
- en: What the previous app and our discussion on configuration qualifiers have shown
    us is certainly very useful in a number of situations. Unfortunately, however,
    configuration qualifiers and detecting attributes in code only solves the problem
    in the view layer of our MVC pattern.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个应用程序和我们对配置限定符的讨论在许多情况下确实非常有用。然而，不幸的是，配置限定符和在代码中检测属性只解决了我们MVC模式的视图层中的问题。
- en: As discussed, our apps sometimes need to have different *behavior* as well as
    layout. This perhaps implies multiple branches of our Java code in the controller
    layer (`MainActivity` in most of our previous apps) and perhaps summons nightmarish
    visions of having huge great `if` or `switch` blocks with different code for each
    different scenario.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如讨论的那样，我们的应用程序有时需要具有不同的*行为*以及布局。这可能意味着我们的Java代码在控制器层（在我们以前的大多数应用程序中为`MainActivity`）中有多个分支，并且可能召唤出对于每种不同情况都有不同代码的巨大的`if`或`switch`块的可怕愿景。
- en: Fortunately, this is not how it's done. For such situations, in fact for most
    apps, Android has fragments.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这不是这样做的方式。对于这种情况，实际上对于大多数应用程序，Android都有片段。
- en: Fragments
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段
- en: Fragments will likely become a staple of almost every app you make. They are
    so useful, there are so many reasons to use them, and once you get used to them,
    they are so simple, there is almost no reason not to use them.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 片段很可能会成为您制作的几乎每个应用程序的主打。它们非常有用，有很多使用它们的理由，一旦您习惯了它们，它们就变得非常简单，几乎没有理由不使用它们。
- en: Fragments are reusable elements of an app just like any class, but as mentioned
    previously, they have special features, such as the ability to load their own
    view/layout as well as their very own lifecycle methods, which make them perfect
    for achieving the goals we discussed in the *Real-world apps* section and having
    different layouts and code for different devices (like the weather app we looked
    at).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 片段是应用程序的可重用元素，就像任何类一样，但正如之前提到的，它们具有特殊功能，例如能够加载它们自己的视图/布局以及它们自己的生命周期方法，这使它们非常适合实现我们在*真实世界应用程序*部分讨论的目标，并为不同的设备（如我们查看的天气应用程序）拥有不同的布局和代码。
- en: Let's dig a bit deeper into fragments, one feature at a time.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解片段，一次一个特性。
- en: Fragments have a lifecycle too
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 片段也有生命周期
- en: 'We can set up and control fragments very much like we do Activities, by overriding
    the appropriate lifecycle methods:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置和控制片段，就像我们对活动所做的那样，覆盖适当的生命周期方法：
- en: '`onCreate`: In the `onCreate` method, we can initialize variables and do almost
    all the things we would typically have done in the `Activity onCreate` method.
    The big exception to this is initializing our UI.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreate`：在`onCreate`方法中，我们可以初始化变量并几乎可以做所有我们通常在`Activity onCreate`方法中做的事情。这个方法的一个重要例外是初始化我们的UI。'
- en: '`onCreateView`: In this method, we will, as the name suggests, get a reference
    to any of our UI widgets, set up anonymous classes to listen for clicks, and more
    besides, as we will soon see.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreateView`：在这个方法中，我们将像其名称所示一样，获取对我们的任何UI小部件的引用，设置匿名类以监听点击，以及更多其他内容，我们很快就会看到。'
- en: '`onAttach` and `onDetach`: These methods are called just before `Fragment`
    is put into use/taken out of use.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onAttach`和`onDetach`：这些方法在将`Fragment`投入使用/停止使用之前调用。'
- en: '`onResume`, `onStart`, `onPause`, and `onStop`: In these methods, we can take
    certain actions, such as creating or deleting objects or saving data, just like
    we have done with their `Activity` based counterparts.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResume`，`onStart`，`onPause`和`onStop`：在这些方法中，我们可以执行某些操作，例如创建或删除对象或保存数据，就像我们在基于它们的`Activity`中所做的那样。'
- en: Note
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to study the details of the `Fragment` lifecycle, you can do so
    on the Android developer website at this link: [https://developer.android.com/guide/components/fragments](https://developer.android.com/guide/components/fragments).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想详细了解`Fragment`的生命周期，请访问Android开发者网站上的此链接：[https://developer.android.com/guide/components/fragments](https://developer.android.com/guide/components/fragments)。
- en: This is all fine, but we need a way to create our fragments in the first place
    and to be able to call these methods at the right time.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，但我们需要一种方法来首先创建我们的片段，并能够在正确的时间调用这些方法。
- en: Managing Fragments with FragmentManager
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FragmentManager管理片段
- en: The `FragmentManager` class is part of the `Activity`. We use it to initialize
    a `Fragment`, add Fragments to the Activities layout, and to end a `Fragment`.
    We briefly saw `FragmentManager` before when we initialized our `FragmentDialog`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`FragmentManager`类是`Activity`的一部分。我们使用它来初始化`Fragment`，将片段添加到活动的布局中，并结束`Fragment`。我们之前在初始化`FragmentDialog`时简要看到了`FragmentManager`。'
- en: Note
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is very hard to learn much about Android without bumping into the `Fragment`
    class, just as it is tough to learn much about Java without constantly bumping
    into OOP/classes, and so on.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中学习很难避免碰到`Fragment`类，就像在学习Java时不断碰到OOP/类一样困难，等等。
- en: 'The following highlighted code shows how we used `FragmentManager` (which is
    already a part of `Activity`) being passed in as an argument to create the pop-up
    dialog:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下突出显示的代码显示了我们如何使用`FragmentManager`（它已经是`Activity`的一部分）作为参数来创建弹出对话框：
- en: '[PRE3]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At the time, I asked you not to concern yourself with the arguments of the method
    call. The second argument of the method call is an ID for `Fragment`. We will
    see how we use `FragmentManager` more extensively, as well as how to use the `Fragment`
    ID.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，我要求您不要关心方法调用的参数。方法调用的第二个参数是`Fragment`的ID。我们将看到如何更广泛地使用`FragmentManager`，以及如何使用`Fragment`
    ID。
- en: '`FragmentManager` does exactly what its name suggests. What is important here
    is that `Activity` only has one `FragmentManager`, but it can take care of many
    fragments. This is just what we need to have multiple behaviors and layouts within
    a single app.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`FragmentManager`确实做到了其名称所暗示的。这里重要的是`Activity`只有一个`FragmentManager`，但它可以处理许多片段。这正是我们需要在单个应用程序中拥有多个行为和布局的情况。'
- en: '`FragmentManager` also calls the various lifecycle methods of the fragments
    it is responsible for. This is distinct from the `Activity` lifecycle methods
    that are called by Android, yet closely related because `FragmentManager` calls
    many of the `Fragment` lifecycle methods *in response to* the `Activity` lifecycle
    methods being called. As usual, we don''t need to worry too much about when and
    how if we respond appropriately in each situation.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: FragmentManager还调用其负责的片段的各种生命周期方法。这与Android调用的Activity生命周期方法是不同的，但又密切相关，因为FragmentManager调用许多Fragment生命周期方法是作为对Activity生命周期方法的响应。通常情况下，如果我们在每种情况下做出适当的响应，我们就不需要太担心何时以及如何做出响应。
- en: Note
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Fragments are going to be a fundamental part of many, if not all our future
    apps. As we did with naming conventions, string resources, and encapsulation,
    however, we will not use fragments for simple learning purposes or very small
    apps when they would be overkill. The exception to this will of course be when
    we are learning about fragments.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 片段将成为我们未来许多，如果不是所有应用程序的基本部分。然而，就像我们对命名约定、字符串资源和封装性所做的那样，出于简单学习目的或在应用程序很小且使用片段会过度的情况下，我们将不使用片段。当然，学习片段时将是一个例外。
- en: Our first Fragment app
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个Fragment应用程序
- en: Let's build `Fragment` in its simplest possible form so we can understand what
    is going on before, in later chapters, we start producing Fragments all over the
    place that are of genuine usefulness.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以尽可能简单的形式构建Fragment，以便在后面的章节中，在我们开始在各个地方生成真正有用的Fragment之前，我们可以理解正在发生的事情。
- en: Note
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I urge all readers to go through and build this project. There is a lot of jumping
    around from file to file and just reading alone can make it seem more complex
    than it really is. Certainly, you can copy and paste the code from the download
    bundle but please also follow the steps and create your own projects and classes.
    Fragments are not too tough but their implementation, as their name suggests,
    is a little fragmented.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我敦促所有读者浏览并构建此项目。从一个文件跳到另一个文件，仅仅阅读可能会使它看起来比实际复杂得多。当然，你可以从下载包中复制粘贴代码，但也请按照步骤创建自己的项目和类。片段并不太难，但它们的实现，正如它们的名字所暗示的那样，有点分散。
- en: Create a new project called `Simple Fragment` using the Empty Activity template
    and leaving the rest of the settings at their defaults.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空活动模板创建一个名为“Simple Fragment”的新项目，并将其余设置保持默认。
- en: Switch to `activity_main.xml` and delete the default `TextView` widget.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到“activity_main.xml”并删除默认的“TextView”小部件。
- en: Now make sure the root `ConstraintLayout` is selected by left-clicking it in
    the`fragmentHolder`. We will now be able to get a reference to this layout in
    our Java code and as the `id` property implies, we will be adding a `Fragment`
    to it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在确保通过在fragmentHolder中左键单击它来选择根ConstraintLayout。现在我们将能够在我们的Java代码中获取对此布局的引用，并且正如id属性所暗示的那样，我们将向其添加一个Fragment。
- en: Now we will create a layout that will define our fragment's appearance. Right-click
    the `fragment_layout`, in the `LinearLayout`, and left-click `LinearLayout`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个布局，该布局将定义我们片段的外观。右键单击LinearLayout中的fragment_layout，然后左键单击LinearLayout。
- en: Add a single `button`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个单独的按钮。
- en: Now we have a simple layout for our Fragment to use, let's write some Java code
    to make the actual fragment.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个简单的布局供我们的Fragment使用，让我们写一些Java代码来创建实际的片段。
- en: Note
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that you can create a `Fragment` by simply dragging and dropping one from
    the palette, but doing things this way is much less flexible and controllable
    and flexibility and control are the big benefits to fragments, as we will see
    throughout the next chapter. By creating a class that extends `Fragment`, we can
    make as many fragments from it as we like.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以通过从调色板中简单拖放来创建一个片段，但以这种方式做事情会更不灵活和可控，而灵活性和控制性是片段的重要优势，正如我们将在接下来的章节中看到的那样。通过创建一个扩展Fragment的类，我们可以从中制作任意多的片段。
- en: In the Project Explorer, right-click the folder that contains the `MainActivity`
    file. From the context menu, choose `SimpleFragment`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目资源管理器中，右键单击包含“MainActivity”文件的文件夹。从上下文菜单中，选择“SimpleFragment”。
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that there are options to create `Fragment` classes in various pre-coded
    states to implement a `Fragment` more quickly, but now they would slightly cloud
    the learning objectives of this app.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有各种预编码状态的选项可快速实现Fragment类的创建，但现在它们可能会稍微模糊此应用程序的学习目标。
- en: 'In our new `SimpleFragment` class, change the code to extend `Fragment`. As
    you type the code, you will be asked to choose the specific `Fragment` class to
    import, as shown in the next screenshot:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新“SimpleFragment”类中，更改代码以扩展Fragment。在输入代码时，将要求您选择要导入的特定Fragment类，如下一张屏幕截图所示：
- en: '![Figure 24.13 – Choose the specific Fragment class'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图24.13 - 选择特定的Fragment类'
- en: '](img/Figure_24.13_B16773.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_24.13_B16773.jpg)'
- en: Figure 24.13 – Choose the specific Fragment class
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.13 - 选择特定的Fragment类
- en: Choose the top option, which is `androidx.fragment.app`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 选择顶部选项，即“androidx.fragment.app”。
- en: Note
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'We will need all of the following `import` statements in this class. The preceding
    step has already added the `androidx.fragment.app.Fragment` class:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们将需要以下所有的导入语句。之前的步骤已经添加了androidx.fragment.app.Fragment类：
- en: '`import androidx.fragment.app.Fragment;`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 导入androidx.fragment.app.Fragment;
- en: '`import android.os.Bundle;`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 导入android.os.Bundle;
- en: '`import android.view.LayoutInflater;`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 导入android.view.LayoutInflater;
- en: '`import android.view.View;`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 导入android.view.View;
- en: '`import android.view.ViewGroup;`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 导入android.view.ViewGroup;
- en: '`import android.widget.Button;`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 导入android.widget.Button;
- en: '`import android.widget.Toast;`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 导入android.widget.Toast;
- en: Now add a single `String` variable called `myString` and a `Button` variable
    called `myButton` as members.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加一个名为“myString”的单个字符串变量和一个名为“myButton”的按钮变量作为成员。
- en: 'Now override the `onCreate` method. Inside the `onCreate` method, initialize
    `myString` to `Hello from SimpleFragment`. Our code so far (excluding the package
    declaration and `import` statements) will look exactly like this next code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重写`onCreate`方法。在`onCreate`方法内，将`myString`初始化为`Hello from SimpleFragment`。到目前为止我们的代码（不包括包声明和`import`语句）将会像下面的代码一样：
- en: '[PRE4]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the previous code, we created a member variable called `myString`, then in
    the `onCreate` method, we initialized it. This is very much like what we did for
    our previous apps when only using `Activity`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名为`myString`的成员变量，然后在`onCreate`方法中初始化它。这非常像我们在之前的应用程序中只使用`Activity`时所做的事情。
- en: The difference, however, is that we did not set the view or attempt to get a
    reference to our `Button` member variable, `myButton`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不同之处在于我们没有设置视图或尝试获取对我们的`Button`成员变量`myButton`的引用。
- en: When using `Fragment`, we need to do this in the `onCreateView` method. Let's
    override that now and see how we set the view and get a reference to our `Button`
    widget.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`Fragment`时，我们需要在`onCreateView`方法中执行此操作。现在让我们重写一下，看看我们如何设置视图并获取对我们的`Button`小部件的引用。
- en: 'Add this code to the `SimpleFragment` class after the `onCreate` method:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`方法之后将此代码添加到`SimpleFragment`类中：
- en: '[PRE5]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To understand the previous block of code, we must first look at the `onCreateView`
    method signature. First, notice the start of the method states that it must return
    an object of type `View`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解上一段代码，我们首先必须查看`onCreateView`方法的签名。首先，注意方法的开始声明必须返回一个`View`类型的对象：
- en: '[PRE6]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we have three arguments. Let''s look at the first two:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有三个参数。让我们先看前两个：
- en: '[PRE7]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We need a `LayoutInflater` reference as we cannot call the `setContentView`
    method because the `Fragment` class provides no such method. In the body of `onCreateView`,
    we use the `inflate` method of `inflater` to inflate our layout contained in `fragment_layout.xml`
    and initialize `view` (an object of type `View`) with the result.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`LayoutInflater`引用，因为我们不能调用`setContentView`方法，因为`Fragment`类没有提供这样的方法。在`onCreateView`的主体中，我们使用`inflater`的`inflate`方法来充气我们包含在`fragment_layout.xml`中的布局，并用结果初始化`view`（一个`View`类型的对象）。
- en: We use `container`, which was passed into `onCreateView` as an argument, in
    the `inflate` method also. The `container` variable is a reference to the layout
    in `activity_main.xml`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`inflate`方法中也使用了传入`onCreateView`的`container`。`container`变量是对`activity_main.xml`中的布局的引用。
- en: It might seem obvious that `activity_main.xml` is the containing layout, but
    as we will see later in the chapter, the `ViewGroup container` argument allows
    *any* `Activity` with *any* layout to be the container for our fragment. This
    is exceptionally flexible and makes our `Fragment` code reusable to a significant
    extent.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会觉得`activity_main.xml`是包含的布局，但正如我们将在本章后面看到的那样，`ViewGroup container`参数允许*任何*具有*任何*布局的`Activity`成为我们片段的容器。这是非常灵活的，使我们的`Fragment`代码在很大程度上可重用。
- en: The third argument we pass in to `inflate` is `false`, which means that we don't
    want our layout immediately added to the containing layout. We will do this ourselves
    soon from another part of the code.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`inflate`的第三个参数是`false`，这意味着我们不希望我们的布局立即添加到包含的布局中。我们很快将从代码的另一个部分自己做这个。
- en: The third argument of `onCreateView` is `Bundle savedInstanceState`, which is
    there to help us maintain the data that our fragments hold.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`onCreateView`的第三个参数是`Bundle savedInstanceState`，它可以帮助我们维护片段保存的数据。'
- en: 'Now we have an inflated layout contained in `view`, we can use this to get
    a reference to our `Button` widget like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了包含在`view`中的充气布局，我们可以使用它来获取对我们的`Button`小部件的引用，就像这样：
- en: '[PRE8]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And use the `view` instance as the return value to the calling code, as required:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 并将`view`实例用作调用代码的返回值，如有需要：
- en: '[PRE9]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now we can add an anonymous class to listen for clicks on our button in the
    usual manner. In the `onClick` method, we display a pop-up `Toast` message to
    demonstrate that everything is working as expected.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加一个匿名类来监听我们按钮上的点击，就像通常一样。在`onClick`方法中，我们显示一个弹出的`Toast`消息，以演示一切都按预期工作。
- en: 'Add this code just before the `return` statement in the `onCreateView` method
    as highlighted in this next code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreateView`方法的`return`语句之前添加此代码，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As a reminder, the `getActivity()` method call used as an argument in `makeText`
    gets a reference to the `Activity` that contains the `Fragment`. This is required
    to display a `Toast` message. We also used the `getActivity` method in our `FragmentDialog`
    based classes in the Note to Self app.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，`getActivity()`方法调用作为`makeText`中的参数，获取了包含`Fragment`的`Activity`的引用。这是显示`Toast`消息所需的。我们在Note
    to Self应用程序中的`FragmentDialog`类中也使用了`getActivity`方法。
- en: We can't run our app just yet; it will not work because there is one more step
    required. We need to create an instance of our `SimpleFragment` class and initialize
    it appropriately. This is where the `FragmentManager` class will get introduced.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在还不能运行我们的应用程序；它不会工作，因为还需要一步。我们需要创建一个`SimpleFragment`类的实例并适当地初始化它。这就是`FragmentManager`类将被介绍的地方。
- en: This next code creates a new `FragmentManager` by calling `getSupportFragmentManager`.
    The code then creates a new `Fragment`, based on our `SimpleFragment` class using
    the `FragmentManager` and passing in the ID of the layout (within the `Activity`)
    that will hold it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过调用`getSupportFragmentManager`创建了一个新的`FragmentManager`。然后，代码根据我们的`SimpleFragment`类创建了一个新的`Fragment`，并使用`FragmentManager`传入了将容纳它的布局（在`Activity`内部）的ID。
- en: 'Add this code in the `onCreate` method of `MainActivity.java`, just after the
    call to the `setContentView` method:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity.java`的`onCreate`方法中添加此代码，就在调用`setContentView`方法之后：
- en: '[PRE11]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You will need to add the following `import` statements to the `MainActivity`
    class:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将以下`import`语句添加到`MainActivity`类中：
- en: '`import androidx.fragment.app.Fragment;`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`import androidx.fragment.app.Fragment;`'
- en: '`import androidx.fragment.app.FragmentManager;`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`import androidx.fragment.app.FragmentManager;`'
- en: '`import android.os.Bundle;`'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.os.Bundle;`'
- en: 'Now run the app and gaze in wonder at our clickable button that displays a
    message with the `Toast` class and took two layouts and two whole classes to create:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序，惊叹于我们的可点击按钮，它使用`Toast`类显示消息，并且需要两个布局和两个完整的类来创建：
- en: '![Figure 24.14 – Displaying a message with the Toast class'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![图24.14 - 使用Toast类显示消息'
- en: '](img/Figure_24.14_B16773.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_24.14_B16773.jpg)'
- en: Figure 24.14 – Displaying a message with the Toast class
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.14 - 使用Toast类显示消息
- en: 'If you remember achieving more than this way back in [*Chapter 2*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*,
    First Contact: Java, XML, and the UI Designer*, and with far less code, then it
    is clear that we need a fragment reality check to fully understand the answer
    to the question of why we are doing it like this!'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得在[*第2章*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*中实现了更多的功能，而且代码更少，那么很明显我们需要对Fragment进行现实检查，以充分理解为什么我们要这样做的答案！
- en: Fragment reality check
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fragment现实检查
- en: So, what does this `Fragment` stuff really do for us? Our first `Fragment` mini-app
    would have the same appearance and functionality had we not bothered with the
    `Fragment` at all.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个`Fragment`到底对我们有什么作用呢？我们的第一个`Fragment`迷你应用程序如果没有使用`Fragment`，外观和功能将是一样的。
- en: In fact, using the `Fragment` class has made the whole thing more complicated!
    Why would we want to do this?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，使用`Fragment`类使整个事情变得更加复杂！我们为什么要这样做呢？
- en: We know that a `Fragment` instance or fragments can be added to the layout of
    an `Activity`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`Fragment`实例或片段可以添加到`Activity`的布局中。
- en: We know that a `Fragment` not only contains its own layout (view) but also its
    very own code (controller), which, although hosted by an `Activity`, the `Fragment`
    instance is virtually independent.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`Fragment`不仅包含自己的布局（视图），还包含自己的代码（控制器），虽然由`Activity`托管，但`Fragment`实例几乎是独立的。
- en: Our quick app only showed one `Fragment` instance in action, but we could have
    an `Activity` that hosts two or more fragments. We then effectively have two almost
    independent controllers displayed on a single screen.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的快速应用程序只显示了一个`Fragment`实例在运行中，但我们可以有一个`Activity`来托管两个或更多的片段。然后，我们在单个屏幕上有效地有两个几乎独立的控制器。
- en: What is most useful about this, however, is that when the `Activity` starts,
    we can detect attributes of the device our app is running on – perhaps phone or
    tablet; portrait or landscape. We can then use this information to decide to display
    either just one or two of our fragments simultaneously.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最有用的是，当`Activity`启动时，我们可以检测我们的应用程序运行的设备的属性 - 可能是手机或平板电脑；纵向或横向。然后，我们可以使用这些信息来决定同时显示一个或两个片段。
- en: This not only helps us achieve the kind of functionality discussed in the section
    *Real-world apps* at the start of the chapter but it also allows us to do so using
    the exact same `Fragment` code for both possible scenarios!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅帮助我们实现本章开头讨论的*真实应用程序*部分中讨论的功能，而且还允许我们使用完全相同的`Fragment`代码来实现两种可能的情况！
- en: This really is the essence of fragments. We create a whole app by pairing up
    both functionality (controller) and appearance (view) into a bunch of fragments
    that we can reuse in different ways, almost without a care.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是片段的本质。我们通过将功能（控制器）和外观（视图）配对成一堆片段来创建一个完整的应用程序，我们可以以几乎不费吹灰之力的方式以不同的方式重复使用它们。
- en: It is, of course, possible to foresee a few stumbling blocks so take a look
    at this FAQ.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可以预见到一些障碍，所以看看这个常见问题解答。
- en: Frequently asked question
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经常问的问题
- en: The missing link is that if all these fragments are fully functioning independent
    controllers, then we need to learn a bit more about how we would implement our
    model layer. If we simply have, say, an `ArrayList`, like with the Note to Self
    app, where will the `ArrayList` instance go? How would we share it between fragments
    (assuming both/all fragments need access to the same data)?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缺失的环节是，如果所有这些片段都是完全独立的控制器，那么我们需要更多地了解如何实现我们的模型层。如果我们只是有一个`ArrayList`，就像“Note
    to Self”应用程序一样，`ArrayList`实例将会放在哪里？我们如何在片段之间共享它（假设所有片段都需要访问相同的数据）？
- en: There is an entirely more elegant solution we can use to create a model layer
    (both the data itself and the code to maintain the data). We will see this when
    we explore the `NavigationView` layout in [*Chapter 26*](B16773_26_ePub_RK.xhtml#_idTextAnchor439)*,
    Advanced UI with Navigation Drawer and Fragment*, and Android databases in [*Chapter
    27*](B16773_27_ePub_RK.xhtml#_idTextAnchor462)*, Android Databases*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一种更加优雅的解决方案来创建一个模型层（数据本身和维护数据的代码）。当我们探索[*第26章*](B16773_26_ePub_RK.xhtml#_idTextAnchor439)*中的NavigationView布局，以及[*第27章*](B16773_27_ePub_RK.xhtml#_idTextAnchor462)*中的Android数据库*时，我们将看到这一点。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Now we have a broad understanding of what Fragments are for and how we can begin
    to use them, we can start to go deeper into how they are used. In the next chapter,
    we will complete a couple of apps that use multiple Fragments in different ways.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Fragment的用途有了广泛的了解，以及我们如何开始使用它们，我们可以开始深入了解它们的使用方式。在下一章中，我们将完成几个以不同方式使用多个Fragment的应用程序。
