- en: Chapter 5. Combinators, Conditionals, and Error Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。组合器，条件和错误处理
- en: Most of the programs that we write handle data from different sources. These
    sources can be both external (files, databases, servers, and many others) and
    internal (different collections or branches of the same external source). There
    are many cases in which we'll want to have these sources depend on each other
    in one way or another. Defining these dependencies is a necessary step in building
    our programs. The idea of this chapter is to introduce the `Observable` operators
    capable of that.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的大多数程序都处理来自不同来源的数据。这些来源既可以是外部的（文件、数据库、服务器等）也可以是内部的（不同的集合或相同外部来源的分支）。有许多情况下，我们希望这些来源以某种方式相互依赖。定义这些依赖关系是构建我们的程序的必要步骤。本章的目的是介绍能够实现这一点的`Observable`操作符。
- en: We saw an example of combined `Observable` instances in the first and second
    chapters. Our "Reactive Sum" program had one external data source—the user input
    but it branched it into two internal data sources, depending on the custom format.
    We saw how we can use the `filter()` operator instead of procedural `if-else`
    constructions. Later, we combined these data flows into one, with the help of
    a combinator.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一章和第二章中看到了组合的`Observable`实例的例子。我们的“响应式求和”程序有一个外部数据源——用户输入，但它根据自定义格式分成了两个内部数据源。我们看到了如何使用`filter()`操作符而不是过程式的`if-else`构造。后来，我们借助组合器将这些数据流合并成一个。
- en: We'll learn how to react to errors from inside the `Observable` instance chain.
    Remember, being able to react to failures makes our programs resilient.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何在`Observable`实例链中对错误做出反应。记住，能够对失败做出反应使我们的程序具有弹性。
- en: 'In this chapter we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Combining the `Observable` instances using operators such as `combineLatest()`,
    `merge()`, `concat()`, and `zip()`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用操作符（如`combineLatest()`、`merge()`、`concat()`和`zip()`）组合`Observable`实例
- en: Creating dependencies between the `Observable` instances using conditional operators
    such as `takeUntil()`, `skipUntil()`, and `amb()`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条件操作符（如`takeUntil()`、`skipUntil()`和`amb()`）在`Observable`实例之间创建依赖关系
- en: Error handling using operators such as `retry()`, `onErrorResumeNext()`, and
    `onErrorReturn()`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`retry()`、`onErrorResumeNext()`和`onErrorReturn()`等操作符进行错误处理
- en: Combining the Observable instances
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合Observable实例
- en: We'll first look at the `zip(Observable, Observable, <Observable>..., Func)`
    operator, which can *combine* two or more `Observable` instances using a *combining*
    function.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看一下`zip(Observable, Observable, <Observable>..., Func)`操作符，它可以使用*组合*函数*组合*两个或多个`Observable`实例。
- en: The zip operator
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: zip操作符
- en: The function passed to the `zip` operator has as many parameters as the number
    of the `Observable` instances passed to the `zip()` method. When all of these
    `Observable` instances emit at least one item, the function is called with the
    parameter values first emitted by each of the `Observable` instances. Its result
    will be the first emitted item by the `Observable` instance created via the `zip()`
    method. The second item emitted by this `Observable` instance will be a combination
    (computed using the function parameter of the `zip()` method) of the second items
    of the source `Observable` instances. Even if one of the source `Observable` instances
    has emitted three or more items, its second emitted item is used. The resulting
    `Observable` instance always emits the same number of items as the source `Observable`
    instance, which emits the fewest items and then completes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`zip`操作符的函数的参数数量与传递给`zip()`方法的`Observable`实例的数量一样多。当所有这些`Observable`实例至少发出一项时，将使用每个`Observable`实例首次发出的参数值调用该函数。其结果将是通过`zip()`方法创建的`Observable`实例的第一项。由这个`Observable`实例发出的第二项将是源`Observable`实例的第二项的组合（使用`zip()`方法的函数参数计算）。即使其中一个源`Observable`实例已经发出了三项或更多项，它的第二项也会被使用。结果的`Observable`实例总是发出与源`Observable`实例相同数量的项，它发出最少的项然后完成。
- en: 'This behavior can be better seen in this marble diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为在下面的弹珠图中可以更清楚地看到：
- en: '![The zip operator](img/4305_05_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![zip操作符](img/4305_05_01.jpg)'
- en: 'Here is a very simple example of using the `zip()` method:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的使用`zip()`方法的例子：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The example is similar to the marble diagram and outputs the same result. The
    first item emitted by the `Observable` instance created by the `zip()` method
    is emitted by the time all of the sources have emitted at least one item. This
    means that even if one of the sources emits all of its items, the result will
    be emitted only when all of the other sources emit items.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子类似于弹珠图，并输出相同的结果。由`zip()`方法创建的`Observable`实例发出的第一项是在所有源至少发出一项之后发出的。这意味着即使其中一个源发出了所有的项，结果也只会在所有其他源发出项时才会被发出。
- en: 'Now if you remember the `interval()` operator from [Chapter 3](ch03.html "Chapter 3. Creating
    and Connecting Observables, Observers, and Subjects"), *Creating and Connecting
    Observables, Observers, and Subjects*, it is able to create an `Observable` instance
    emitting sequential numbers every `<n>` milliseconds. What if you want to emit
    a sequence of, say, arbitrary objects instead? This is possible by combining the
    `interval()` and `from()` or `just()` methods using the `zip()` method. Let''s
    look at an example of that:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你还记得来自[第3章](ch03.html "第3章。创建和连接Observables，Observers和Subjects")的`interval()`操作符，它能够创建一个`Observable`实例，每`<n>`毫秒发出一个顺序数字。如果你想要发出一系列任意对象，可以通过使用`zip()`方法结合`interval()`和`from()`或`just()`方法来实现。让我们看一个例子：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will output `Z` after 300 milliseconds, `I` after another 300 milliseconds,
    `P` after the same interval , and another `P` after `300` more milliseconds. After
    that, the `timedZip` `Observable` instance will complete. That's because the source
    `Observable` instance, created via the `interval()` method emits, its element
    every `300` milliseconds, and it determines the speed of the `timedZip` parameter
    emissions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在300毫秒后输出`Z`，在另外300毫秒后输出`I`，在相同的间隔后输出`P`，并在另外300毫秒后输出另一个`P`。之后，`timedZip`
    `Observable`实例将完成。这是因为通过`interval()`方法创建的源`Observable`实例每300毫秒发出一个元素，并确定了`timedZip`参数发射的速度。
- en: 'The `zip()` method has an instance method version too. The operator is called
    `zipWith()`. Here is an analogous example to the preceding one but using the `zipWith()`
    operator:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()`方法也有一个实例方法版本。该操作符称为`zipWith()`。以下是一个类似的示例，但使用了`zipWith()`操作符：'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we'll get to know the *combinator* we first saw in [Chapter 1](ch01.html
    "Chapter 1. An Introduction to Reactive Programming"), *An Introduction to Reactive
    Programming*, while implementing *'The Reactive Sum'*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将了解在实现“反应式求和”时在[第1章](ch01.html "第1章。反应式编程简介")中首次看到的*组合器*，*反应式编程简介*。
- en: The combineLatest operator
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: combineLatest操作符
- en: 'The `combineLatest()` operator has the same parameters and overloads as the
    `zip()` operator but behaves a bit differently. The `Observable` instance it creates
    emits the first item as soon as there is at least one of each source, taking the
    last of each. After that, the `Observable` instance it creates emits an item whenever
    any of the source `Observable` instances emits an item. The number of items emitted
    by the `combineLatest()` operator depends entirely on the order of items emitted,
    since multiple items could be emitted from a single source before there is one
    of each source. Its marble diagram looks like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`combineLatest()`操作符具有与`zip()`操作符相同的参数和重载，但行为有些不同。它创建的`Observable`实例在每个源至少有一个时立即发出第一个项目，取每个源的最后一个。之后，它创建的`Observable`实例在任何源`Observable`实例发出项目时发出项目。`combineLatest()`操作符发出的项目数量完全取决于发出的项目顺序，因为在每个源至少有一个之前，单个源可能会发出多个项目。它的弹珠图看起来像这样：'
- en: '![The combineLatest operator](img/4305_05_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![The combineLatest operator](img/4305_05_02.jpg)'
- en: In the preceding diagram, the color of the items emitted by the combining `Observable`
    instance are the same as the colors of those items triggering their emission.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，由组合的`Observable`实例发出的项目的颜色与触发它们发出的项目的颜色相同。
- en: 'In the next few examples, will be using three source `Observable` instances,
    created by the `interval()` and `zipWith()` methods:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个示例中，将使用由`interval()`和`zipWith()`方法创建的三个源`Observable`实例：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is the function used for zipping:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于压缩的函数：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is the same method of inserting delays between emissions as seen in the
    section about the `zip()` method. These three `Observable` instances can be used
    to compare the different combining methods. The `Observable` instance containing
    greetings emits every second, the one containing names emits every second and
    a half, and the one with punctuation signs every 1.1 seconds.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在关于`zip()`方法的部分中看到的在发射之间插入延迟的相同方法。这三个`Observable`实例可以用来比较不同的组合方法。包含问候的`Observable`实例每秒发出一次，包含名称的实例每1.5秒发出一次，包含标点符号的实例每1.1秒发出一次。
- en: 'Using the `combineLatest()` operator, we can combine them like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`combineLatest()`操作符，我们可以这样组合它们：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will combine the different source items in sentences. The first sentence
    will be emitted after a second and a half because all the sources have to emit
    something in order for the combined `Observable` instance to start its emissions.
    This sentence will be `'Hello Meddle.'`. The next sentence will be emitted the
    moment any of the sources emits something. This will happen two seconds after
    subscribing, because the greetings `Observable` instance emits every second; it
    will emit `'Hi'`, and this will make the combined `Observable` instance emit `'Hi
    Meddle.'`. When 2.2 seconds pass, the punctuation `Observable` instance will emit
    `'?'`, so we'll have another sentence—`'Hi Meddle?'`. This will continue until
    all of the sources are completed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将组合不同源的项目成句。第一句将在一秒半后发出，因为所有源都必须发出某些内容，以便组合的`Observable`实例开始发出。这句话将是“Hello
    Meddle.”。下一句将在任何源发出内容时立即发出。这将在订阅后两秒后发生，因为问候`Observable`实例每秒发出一次；它将发出“Hi”，这将使组合的`Observable`实例发出“Hi
    Meddle.”。当经过2.2秒时，标点`Observable`实例将发出“?”，所以我们将有另一句话——“Hi Meddle?”。这将持续到所有源完成为止。
- en: The `combineLatest()` operator is very useful when we need computation or notification
    when any of the data sources we depend on changes. The next method is simpler;
    it just merges the emissions of its sources, *interleaving* them in the process.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要计算或通知依赖的任何数据源发生更改时，`combineLatest()`操作符非常有用。下一个方法更简单；它只是合并其源的发射，*交错*它们的过程。
- en: The merge operator
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并操作符
- en: When we want to get feeds from multiple sources as one stream, we can use the
    `merge()` operator. For example, we can have many `Observable` instances emitting
    data from different `log` files. We don't care which `log` file is the source
    of the current emission, we just want to see all the logs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要从多个源获取数据作为一个流时，我们可以使用`merge()`操作符。例如，我们可以有许多`Observable`实例从不同的`log`文件中发出数据。我们不关心当前发射的数据来自哪个`log`文件，我们只想看到所有的日志。
- en: 'The diagram of the `merge()` operator is pretty simple:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge()`操作符的图表非常简单：'
- en: '![The merge operator](img/4305_05_03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![The merge operator](img/4305_05_03.jpg)'
- en: 'Every item is emitted at its original emission time, and the source doesn''t
    matter. An example using the three `Observable` instances introduced in the previous
    section looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都在其原始发射时间发出，源无关紧要。使用前一节介绍的三个`Observable`实例的示例如下：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It just emits different words/punctuation signs. The first word emitted will
    come from the greetings `Observable` instance, one second after the subscription
    (because greetings emits every second) `'Hello'`; then `'.'` will be emitted after
    100 milliseconds because the punctuation `Observable` instance emits its items
    every 1.1 seconds. After 400 milliseconds, one second and a half after the subscription,
    `'Meddle'` will be emitted. Next is the greeting `'Hi'`. Emissions will continue
    to take place until the source `Observable` instance, which takes the most time,
    completes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它只会发出不同的单词/标点符号。第一个发出的单词将来自问候`Observable`实例，在订阅后一秒钟发出（因为问候每秒发出一次）`'Hello'`；然后在100毫秒后发出`'.'`，因为标点`Observable`实例每1.1秒发出一次。在订阅后400毫秒，也就是一秒半后，将发出`'Meddle'`。接下来是问候`'Hi'`。发射将继续进行，直到最耗时的源`Observable`实例完成。
- en: It is worth mentioning that if any of the sources emits an `OnError` notification,
    the `merge Observable` instance emits the *error* too and completes with it. There
    is a form of `merge()` operator that delays emitting errors until all the error-free
    source `Observable` instances are completed. It is called `mergeDelayError()`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，如果任何源发出`OnError`通知，`merge Observable`实例也会发出*error*并随之完成。有一种`merge()`操作符的形式，延迟发出错误，直到所有无错误的源`Observable`实例都完成。它被称为`mergeDelayError()`。
- en: If we want to combine our sources in such a way that their items don't interleave
    in time and the emissions of the first passed source take precedence over the
    next one, we will be using the last combinator that this chapter introduces—the
    `concat()` operator.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想以这样的方式组合我们的源，使它们的项目不会在时间上交错，并且第一个传递的源的发射优先于下一个源，我们将使用本章介绍的最后一个组合器——`concat()`操作符。
- en: The concat operator
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接运算符
- en: All of the chapters in this book are in different files. We want to concatenate
    the content of all of these files into one big file, representing the whole book.
    We can create an `Observable` instance for each chapter-file with the `from(Path)`
    method that we created earlier, and we can use the `concat()` operator with these
    `Observable` instances as sources to concatenate them in the right order in one
    `Observable` instance. If we subscribe to this `Observable` instance with a method
    that writes everything in a file, we'll have our book-file in the end.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的所有章节都在不同的文件中。我们想要将所有这些文件的内容连接成一个大文件，代表整本书。我们可以为每个章节文件创建一个`Observable`实例，使用我们之前创建的`from(Path)`方法，然后我们可以使用这些`Observable`实例作为源，使用`concat()`操作符将它们按正确的顺序连接成一个`Observable`实例。如果我们订阅这个`Observable`实例，并使用一个将所有内容写入文件的方法，最终我们将得到我们的书文件。
- en: Note that the `conact()` operator won't work well with infinite `Observable`
    instances. It will emit the notifications of the first one, but it will block
    the others. The main difference between the `merge()` and `concat()` operators
    is that `merge()`subscribes to all source `Observable` instances at the same time,
    whereas `concat()`has exactly one subscription at any time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`conact()`操作符不适用于无限的`Observable`实例。它将发出第一个的通知，但会阻塞其他的。`merge()`和`concat()`操作符之间的主要区别在于，`merge()`同时订阅所有源`Observable`实例，而`concat()`在任何时候只有一个订阅。
- en: 'The marble diagram of the `concat()` operator looks like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat()`操作符的弹珠图如下：'
- en: '![The concat operator](img/4305_05_04.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![连接运算符](img/4305_05_04.jpg)'
- en: 'Here is an example of concatenating the three `Observable` instances from the
    previous examples:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是连接前面示例中的三个`Observable`实例的示例：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will output all of the greetings, one by one, every second, then the names
    every second and a half, and finally the punctuation signs every 1.1 seconds.
    Between the greetings and the names there will be a second and a half.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将每秒一个地输出所有的问候，然后每秒半输出名字，最后每1.1秒输出标点符号。在问候和名字之间将有1.5秒的间隔。
- en: 'There is one operator, similar to the `concat()` operator, called `startWith()`.
    It prepends items to an `Observable` instance and has overloads that take one,
    two, three, and so on, up to nine values, with an `Iterable` instance or another
    `Observable` instance. Using the overload taking another `Observable` instance
    as a parameter, we can simulate the `concat()` operator. Here is the preceding
    example implemented in the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个操作符，类似于`concat()`操作符，称为`startWith()`。它将项目前置到`Observable`实例，并具有重载，可以接受一个、两个、三个等等，最多九个值，以及`Iterable`实例或另一个`Observable`实例。使用接受另一个`Observable`实例作为参数的重载，我们可以模拟`concat()`操作符。以下是前面示例在以下代码中的实现：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The greetings `Observable` instance is prepended to the names one, and the result
    of this is prepended to the punctuation of the `Observable` instance, creating
    the same `Observable` instance of concatenated sources as in the preceding example.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 问候`Observable`实例被前置到名字之前，这个结果被前置到标点的`Observable`实例，创建了与前面示例中相同的连接源的`Observable`实例。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code for the preceding and all the previous examples in this chapter
    can be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/CombiningObservables.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/CombiningObservables.java).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中前面和所有之前示例的源代码可以在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/CombiningObservables.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/CombiningObservables.java)找到。
- en: 'Good use of the `startWith()` operator is when it is used with the `combineLatest()`
    operator. If you remember the initial implementation of our *''Reactive Sum''*
    example, you had to enter both the `a` and `b` values in order to calculate the
    initial sum. But suppose we modify the construction of the sum like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`startWith()`操作符的良好使用是与`combineLatest()`操作符一起使用。如果你记得我们*''Reactive Sum''*示例的初始实现，你必须输入`a`和`b`的值才能计算初始和。但是假设我们修改和的构造方式如下：'
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We will have an initial sum of `0.0` even before the user has entered anything
    and the situation in which the user has entered `a` for the first time and not
    yet gave value to `b` in which case we don't see the sum won't occur.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 即使用户还没有输入任何内容，我们将有一个初始总和为`0.0`的情况，以及用户第一次输入`a`但尚未给`b`赋值的情况，这种情况下我们不会看到总和发生。
- en: Again, like with the `merge()` operator, the `concat()` operator has an instance
    form—the `concatWith()` operator.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与`merge()`操作符一样，`concat()`操作符也有一个实例形式——`concatWith()`操作符。
- en: In this section of the chapter, we saw how we can combine different `Observable`
    instances. But combining is not the only interaction between the `Observable`
    instances. They can depend on each other or manage each other. There is a way
    of getting one or more `Observable` instances to create conditions changing the
    behavior of other `Observable` instances. It's achieved through conditional operator/operators.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们看到了如何组合不同的`Observable`实例。但是组合并不是`Observable`实例之间唯一的交互。它们可以相互依赖或管理彼此。有一种方法可以让一个或多个`Observable`实例创建条件，改变其他`Observable`实例的行为。这是通过条件操作符来实现的。
- en: The conditional operators
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件操作符
- en: It is possible to make it so that one `Observable` instance won't begin its
    emissions until another emits, or so that it would emit only if another doesn't
    emit anything. These `Observable` instances are able to emit items under given
    conditions, and these conditions are applied to them using *conditional* operators.
    In this section, we'll take a look at some of the *conditional* operators provided
    by RxJava.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使一个`Observable`实例在另一个发出之前不开始发出，或者只在另一个不发出任何内容时才发出。这些`Observable`实例能够在给定条件下发出项目，并且这些条件是使用*条件*操作符应用到它们上的。在本节中，我们将看一些RxJava提供的*条件*操作符。
- en: The amb operator
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: amb操作符
- en: 'The `amb()` operator has overloads that take from two up to nine source `Observable`
    instances or an `Iterable` instance of the `Observable` instances. It emits the
    items of the source `Observable` instance that starts emitting first. It doesn''t
    matter what this is, whether `OnError`, `OnCompleted` notification, or data. Its
    diagram looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`amb()`操作符有多个重载，可以接受从两个到九个源`Observable`实例，或者是一个包含`Observable`实例的`Iterable`实例。它会发出首先开始发出的源`Observable`实例的项目。无论是`OnError`、`OnCompleted`通知还是数据，都不重要。它的图表看起来像这样：'
- en: '![The amb operator](img/4305_05_05.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![amb操作符](img/4305_05_05.jpg)'
- en: This operator has an instance form too. It is called `ambWith()` and can be
    called on one `Observable` instance in argument with another `Observable` instance.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符也有一个实例形式。它被称为`ambWith()`，可以在一个`Observable`实例上调用，作为参数传入另一个`Observable`实例。
- en: 'This *conditional* operator is good for reading from multiple sources of similar
    data. The subscriber won''t care about the origin of the data. It can be used
    to implement simple caching, for example. Here is a little example of how it may
    be used:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*条件*操作符适用于从多个类似数据源中读取数据。订阅者不需要关心数据的来源。它可以用于实现简单的缓存，例如。这里有一个小例子，展示了它的使用方法：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first `amb()` operator will emit the items of the *words* `Observable` instance,
    because the *interval* `Observable` instance will have to wait for half a second
    before emitting, and the *words* will begin emitting immediately.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`amb()`操作符将发出*words* `Observable`实例的项目，因为*interval* `Observable`实例需要等待半秒钟才能发出，而*words*会立即开始发出。
- en: The emission of the second `amb Observable` instance will be decided at random.
    If the first source `Observable` instance emits its data before the second, its
    emission will be mirrored by the `amb Observable` instance, but if the second
    source emits first, the `amb Observable` instance will emit its data.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`amb Observable`实例的发射将是随机决定的。如果第一个源`Observable`实例在第二个之前发出数据，那么`amb Observable`实例将会发出相同的数据，但如果第二个源先发出，那么`amb
    Observable`实例将发出它的数据。
- en: The takeUntil(), takeWhile(), skipUntil(), and skipWhile() conditional operators
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: takeUntil()、takeWhile()、skipUntil()和skipWhile()条件操作符
- en: 'We saw operators similar to these in the previous chapter. The `take(int)`
    operator filtered only the first *n* items. These operators also filter items,
    but *based on conditions*. The `takeUntil()` operator takes another `Observable`
    instance, and until this other `Observable` instance emits, the source''s items
    are emitted; after that, the `Observable` instance created by the `takeUntil()`
    operator completes. Let''s look at an example of using these operators:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中看到了类似的操作符。`take(int)`操作符仅过滤了前*n*个项目。这些操作符也过滤项目，但是*基于条件*。`takeUntil()`操作符接受另一个`Observable`实例，直到这个其他`Observable`实例发出，源的项目才会被发出；之后，由`takeUntil()`操作符创建的`Observable`实例将完成。让我们看一个使用这些操作符的例子：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s take a look at the following explanation:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下解释：
- en: For these examples, we'll use the *words* and *interval* `Observable` instances.
    The *words* `Observable` instance emits a word every 200 milliseconds, and the
    *interval* `Observable` emits every half a second.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些例子中，我们将使用*words*和*interval* `Observable`实例。*words* `Observable`实例每200毫秒发出一个单词，而*interval*
    `Observable`每半秒发出一次。
- en: As mentioned previously, this overload of the `takeUntil()` operator will emit
    words until the `interval Observable` emits. So, the words `one` and `way` will
    be emitted because the next word, `or`, should be emitted 600 milliseconds after
    the subscription, and the `interval Observable` emits on the 500th millisecond.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，`takeUntil()`操作符的这种重载将在`interval Observable`发出之前发出单词。因此，`one`和`way`将被发出，因为下一个单词`or`应该在订阅后的600毫秒后发出，而`interval
    Observable`在第500毫秒时发出。
- en: 'Here, the `takeWhile()` operator puts a condition on the `words Observable`.
    It will emit only while there are words that contain more than two letters. Because
    ''`or''` has two letters, it won''t be emitted and all the words after it will
    be skipped too. The `takeUntil()` operator has a similar overload, but it emits
    only words containing fewer than three letters. There is no `takeWhile(Observable)`
    operator overload as it would be `zip()` operator essentially: emit only if the
    other emits too.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，`takeWhile()`运算符对`words Observable`设置了条件。它只会在有包含两个以上字母的单词时发出。因为`'or'`有两个字母，所以它不会被发出，之后的所有单词也会被跳过。`takeUntil()`运算符有一个类似的重载，但它只会发出包含少于三个字母的单词。没有`takeWhile(Observable)`运算符重载，因为它本质上是`zip()`运算符：只有在另一个发出时才发出。
- en: The `skip*` operators are analogous to the `take*` ones. The difference is that
    they don't emit until/while a condition is satisfied. In this example, the words
    `one` and `way` are skipped because they are emitted before the 500th millisecond
    of subscribing and the `interval Observable` begins emitting at the 500th millisecond.
    The word `'or'` and all the words coming after it are emitted.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`skip*`运算符类似于`take*`运算符。不同之处在于它们在满足条件之前/之后不会发出。在这个例子中，单词`one`和`way`被跳过，因为它们在订阅的500毫秒之前被发出，而`interval
    Observable`在500毫秒时开始发出。单词`''or''`和之后的所有单词都被发出。'
- en: 'These *conditional* operators can be used, for example, for displaying loading
    animation in GUI applications. The code can be something like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些*条件*运算符可以用于在GUI应用程序中显示加载动画。代码可能是这样的：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: On every emission of the `loadingAnimationObservable` variable, some short-lived
    animation will be displayed to the user. When the request is returned, the animation
    will no longer be displayed. This is another way of branching the logic of a program.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次发出`loadingAnimationObservable`变量时，都会向用户显示一些短暂的动画。当请求返回时，动画将不再显示。这是程序逻辑的另一种分支方式。
- en: The defaultIfEmpty( ) operator
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`defaultIfEmpty()`运算符'
- en: The idea of the `defaultlfEmpty()` operator is to return something useful if
    an unknown source turns out to be empty. For example, we'll use locally stored
    information, if a remote source has nothing new.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultIfEmpty()`运算符的想法是，如果未知的源为空，就返回一些有用的东西。例如，如果远程源没有新内容，我们将使用本地存储的信息。'
- en: 'Here''s a simple example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Of course, this will output `5` and will complete.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这将输出`5`并完成。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code for the `amb()`, `take*`, `skip*`, and `defaultIfEmpty()` operator
    examples can be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/Conditionals.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/Conditionals.java).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`amb()`，`take*`，`skip*`和`defaultIfEmpty()`运算符示例的源代码可以在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/Conditionals.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/Conditionals.java)找到。'
- en: Until now, we have transformed, filtered, and combined data. But what about
    the *errors*? Our applications can enter into error state at any time. Yes, we
    can subscribe for *errors* emitted by the `Observable` instances, but this will
    terminate our logic. In the `subscribe` method, we are outside of the `Observable`
    chain of operators. What if we want to react to an *error* from within the `Observable`
    instances chain and to try to prevent the termination? There are some operators
    that help us do that, and we'll be examining them in the next section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经转换、过滤和组合了数据。但是*错误*呢？我们的应用程序随时可能进入错误状态。是的，我们可以订阅`Observable`实例发出的*错误*，但这将终止我们的逻辑。在`subscribe`方法中，我们已经超出了操作链。如果我们想要在`Observable`实例链内部对*错误*做出反应，并尝试阻止终止怎么办？有一些运算符可以帮助我们做到这一点，我们将在下一节中对它们进行检查。
- en: Handling errors
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误
- en: When dealing with *errors* in RxJava, you should be aware that they terminate
    the `Observable` chain of actions. Much like with your normal procedural code,
    once you are in the catch block, you can't go back to the code that has thrown
    the exception. You can execute some backup logic though and use it instead of
    failing the program. The `return*`, `retry*`, and `resume*` operators do something
    similar.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理RxJava中的*错误*时，您应该意识到它们会终止`Observable`的操作链。就像处理常规的过程代码一样，一旦进入catch块，就无法返回到抛出异常的代码。但是您可以执行一些备用逻辑，并在程序失败时使用它。`return*`，`retry*`和`resume*`运算符做了类似的事情。
- en: The return and resume operators
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回和恢复运算符
- en: 'The `onErrorReturn` operator can be used in order to prevent the `Subscriber`
    instance''s `onError` from being called. Instead, it will emit one last item and
    complete. Here is an example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`onErrorReturn`运算符可用于防止调用`Subscriber`实例的`onError`。相反，它将发出最后一个项目并完成。这是一个例子：'
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Integer::parseInt` method will succeed in converting the strings `1` and
    `2` to `Integer` values, but it will fail on `three` with a `NumberFormatException`
    exception. This exception will be passed to the `onErrorReturn()` method, which
    will return the number -`1`. The `numbers Observable` instance will emit the number
    -`1` and complete. So the output will be `1`, `2`, `-1`, `OnCompleted` notification.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Integer::parseInt`方法将成功地将字符串`1`和`2`转换为`Integer`值，但在`three`上会失败，并引发`NumberFormatException`异常。此异常将传递给`onErrorReturn()`方法，它将返回数字-`1`。`numbers
    Observable`实例将发出数字-`1`并完成。因此输出将是`1`，`2`，`-1`，`OnCompleted`通知。'
- en: 'This is fine, but sometimes we''ll want to switch to another Observable chain
    of operations on exception. For that, we can use the `onExceptionResumeNext()`
    operator, which returns a backup `Observable` instance that will replace the source
    one when an `Exception` occurs. Here is the code modified to use it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但有时我们会希望在发生异常时切换到另一个Observable操作链。为此，我们可以使用`onExceptionResumeNext()`运算符，它在发生`Exception`时返回一个备用的`Observable`实例，用于替换源实例。以下是修改后使用它的代码：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now this will output `1`, `2`, `5`, `4`, `3`, `2`, `1`, `OnCompleted` notification
    because, after the `Exception` raised on `'three'`, the `defaultOnError Observable`
    instance passed to `onExceptionResumeNext()` method will begin emitting, replacing
    the source `Observable` instance for all the `Subscriber` methods.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这将输出`1`、`2`、`5`、`4`、`3`、`2`、`1`、`OnCompleted`通知，因为在`'three'`引发异常后，传递给`onExceptionResumeNext()`方法的`defaultOnError
    Observable`实例将开始发出，替换所有`Subscriber`方法的源`Observable`实例。
- en: There is one other `resuming()` operator very similar to `onExceptionResumeNext()`.
    It is called `onErrorResumeNext()`. It can replace the `onExceptionResumeNext()`
    operator in the preceding example, and the result will be the same. There are
    two differences between these two operators though.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个非常类似于`onExceptionResumeNext()`的`resuming()`操作符。它被称为`onErrorResumeNext()`。它可以替换前面示例中的`onExceptionResumeNext()`操作符，结果将是相同的。不过这两个操作符之间有两个区别。
- en: First, the `onErrorResumeNext()` operator has an additional overload that takes
    a lambda expression, returning the `Observable` instance (similar to the `onErrorReturn()`
    method). Second, it will react to every kind of error. The `onExceptionResumeNext()`
    method reacts only to instances of the `Exception` class and its subclasses.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`onErrorResumeNext()`操作符有一个额外的重载，它接受一个lambda表达式，返回`Observable`实例（类似于`onErrorReturn()`方法）。其次，它将对每种错误做出反应。`onExceptionResumeNext()`方法只对`Exception`类及其子类的实例做出反应。
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, the result will be the same as in the preceding one `(1, 2,
    5, 4, 3, 2, 1, OnCompleted notification b)`; it doesn't matter that there is an
    *assertion error*. But if we've used an `onExceptionResumeNext()` operator, the
    error would have reached the `subscribePrint` method as an `OnError` *notification*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，结果将与前一个示例相同`(1, 2, 5, 4, 3, 2, 1, OnCompleted notification b)`；*断言错误*并不重要。但是如果我们使用了`onExceptionResumeNext()`操作符，错误将作为`OnError`
    *notification*到达`subscribePrint`方法。
- en: The `doOnNext()` operator used in this example is a *side effect generator*.
    It doesn't change the items emitted by the `Observable` instance it is called
    upon. It can be used for logging, caching, asserting, or adding additional logic.
    There are `doOnError()` and `doOnCompleted()` operators too. In addition, there
    is a `finallyDo()` operator, which executes the function passed to it when there
    is an error or when the `Observable` instance has completed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中使用的`doOnNext()`操作符是一个*副作用生成器*。它不会改变被调用的`Observable`实例发出的项目。它可以用于日志记录、缓存、断言或添加额外的逻辑。还有`doOnError()`和`doOnCompleted()`操作符。此外，还有一个`finallyDo()`操作符，当出现错误或`Observable`实例完成时，它会执行传递给它的函数。
- en: The retrying technique
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重试技术
- en: Retrying is an important technique. When an `Observable` instance is emitting
    data from an uncertain source (for example, a remote server), one network problem
    could terminate the whole application. Retrying on *errors* saves us in situations
    like this.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重试是一种重要的技术。当一个`Observable`实例从不确定的来源（例如远程服务器）发出数据时，一个网络问题可能会终止整个应用程序。在*错误*上重试可以在这种情况下拯救我们。
- en: Inserting the `retry()` operator into the `Observable` action chain means that
    if an *error* occurs, the subscribers will resubscribe to the source `Observable`
    instance and try everything from the beginning of the chain. If there is an *error*
    again, everything is restarted once more. The `retry()` operator without parameters
    retries infinitely. There is an overload `retry(int)` method, which takes the
    number of the maximum allowed retry attempts.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将`retry()`操作符插入`Observable`操作链中意味着如果发生*错误*，订阅者将重新订阅源`Observable`实例，并从链的开头尝试一切。如果再次出现*错误*，一切将再次重新开始。没有参数的`retry()`操作符会无限重试。还有一个重载的`retry(int)`方法，它接受最大允许的重试尝试次数。
- en: 'In order to demonstrate the `retry()` method, we will use the following special
    behavior:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`retry()`方法，我们将使用以下特殊行为：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: An `ErrorEmitter` instance can be passed to the `Observable.create()` method.
    If the `throwAnErrorCounter` field is a number greater than four, a `FooException`
    exception is sent; if it's greater than zero, a `BooException` exception is sent,
    and if it's less than or equal to zero, it sends some events and completes normally.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将一个`ErrorEmitter`实例传递给`Observable.create()`方法。如果`throwAnErrorCounter`字段的值大于四，就会发送一个`FooException`异常；如果大于零，就会发送一个`BooException`异常；如果小于或等于零，就会发送一些事件并正常完成。
- en: 'Now let''s look at this example of using the `retry()` operator:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下使用`retry()`操作符的示例：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Because the initial value of the `throwAnErrorCounter` field is five, it will
    retry `five` times, and when the counter becomes zero, the `Observable` instance
    will *complete*. The result will be `1`, `2`, `1`, `2`, `1`, `2`, `1`, `2`, `1`,
    `2`, `1`, `2`, `3`, `4`, `OnCompleted` notification.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`throwAnErrorCounter`字段的初始值是五，它将重试`五`次，当计数器变为零时，`Observable`实例将*完成*。结果将是`1`、`2`、`1`、`2`、`1`、`2`、`1`、`2`、`1`、`2`、`1`、`2`、`3`、`4`、`OnCompleted`通知。
- en: 'The `retry()` operator can be used to retry a set number of times (or indefinitely).
    It even has an overload, taking a function with two arguments—the number of the
    retries until now and cause `Throwable` instance. If this function returns `True`,
    the `Observable` instance is resubscribed to. This is a way of writing custom
    retry logic. But what about delayed retries? For example, retrying every second?
    There is one special operator capable of very complex *retrying logic*, the `retryWhen()`
    operator. Let''s look at an example of using it and the previously mentioned `retry(predicate)`
    operator:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`retry()`操作符可用于重试一组次数（或无限次）。它甚至有一个重载，接受一个带有两个参数的函数——目前的重试次数和`Throwable`实例的原因。如果这个函数返回`True`，`Observable`实例将重新订阅。这是一种编写自定义重试逻辑的方法。但是延迟重试呢？例如，每秒重试一次？有一个特殊的操作符能够处理非常复杂的*重试逻辑*，那就是`retryWhen()`操作符。让我们来看一个使用它以及之前提到的`retry(predicate)`操作符的示例：'
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When the `retryWhen()` operator returns an `Observable` instance, emitting the
    `OnError()` or `OnCompleted()` notifications, the notification is propagated,
    and if there is no other *retry/resume*, the `onError()` or `onCompleted()` methods
    of the subscribers are called. Otherwise, the subscribers will be resubscribed
    to the source observable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当`retryWhen()`操作符返回一个发出`OnError()`或`OnCompleted()`通知的`Observable`实例时，通知被传播，如果没有其他*retry/resume*，则调用订阅者的`onError()`或`onCompleted()`方法。否则，订阅者将重新订阅源observable。
- en: In this example, if the `Exception` is `FooException`, the `retryWhen()` operator
    returns an `Observable` instance emitting after a second. That's how we implement
    retrying with a delay. If the `Exception` is not `FooException`, it is propagated
    to the next `retry(predicate)` operator. It can check the type of the *error*
    and the number of attempts and decide if it should propagate the error or retry
    the source.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果`Exception`是`FooException`，`retryWhen()`操作符返回一个在一秒后发出的`Observable`实例。这就是我们如何实现带有延迟的重试。如果`Exception`不是`FooException`，它将传播到下一个`retry(predicate)`操作符。它可以检查*error*的类型和尝试次数，并决定是否应该传播错误或重试源。
- en: In this example, we'll get one delayed retry, three retries from the `retry(predicate)`
    method, and on the fifth try, the subscribers will receive an `OnError` notification,
    with a `BooException` exception.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将获得一个延迟的重试，从`retry(predicate)`方法获得三次重试，第五次尝试时，订阅者将收到一个`OnError`通知，带有一个`BooException`异常。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code for the `retry`/`resume`/`return` examples can be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/HandlingErrors.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/HandlingErrors.java).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`retry`/`resume`/`return`示例的源代码可以在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/HandlingErrors.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/HandlingErrors.java)找到。'
- en: The last section of this chapter is saved for a more complex example. We'll
    use our knowledge so far to create a request to remote HTTP API and handle the
    result, outputting it to the user.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一节留给了一个更复杂的例子。我们将利用我们迄今为止的知识创建一个对远程HTTP API的请求，并处理结果，将其输出给用户。
- en: An HTTP client example
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个HTTP客户端示例
- en: 'Let''s use RxJava to retrieve information about the GitHub repositories of
    a user by *username*. We will use our `subscribePrint()` function used previously
    to output the information to the system output. The idea of the program is to
    display all of the public repositories of the user that are not forks. The main
    part of the program looks like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用RxJava通过*username*检索有关GitHub用户存储库的信息。我们将使用先前用于将信息输出到系统输出的`subscribePrint()`函数。程序的想法是显示用户的所有公共存储库，这些存储库不是分叉。程序的主要部分如下所示：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This program uses my user (it can be easily reworked to use a *username* passed
    as a parameter) to retrieve information its public repositories. It prints the
    name of each repository and the main programming language used in it. The repositories
    are represented by `Map` instances generated from the incoming JSON file, so we
    can read repository properties from them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序使用了我的用户名（可以很容易地改为使用作为参数传递的*username*）来检索其公共存储库的信息。它打印出每个存储库的名称以及其中使用的主要编程语言。存储库由从传入的JSON文件生成的`Map`实例表示，因此我们可以从中读取存储库属性。
- en: These JSON `Map` instances are emitted by an `Observable` instance, created
    by the `githubUserInfoRequest(client, username)` method. The client parameter
    is an instance of Apache's `HttpAsyncClient` class. The client is capable of performing
    asynchronous HTTP requests, and there is an additional RxJava module, called `RxApacheHttp`,
    that gives us bindings between RxJava and Apache HTTP. We'll be using it for our
    HTTP request implementation; you can find it at [https://github.com/ReactiveX/RxApacheHttp](https://github.com/ReactiveX/RxApacheHttp).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些JSON `Map`实例是由`githubUserInfoRequest(client, username)`方法创建的`Observable`实例发出的。client参数是Apache的`HttpAsyncClient`类的一个实例。客户端能够执行异步HTTP请求，并且还有一个名为`RxApacheHttp`的额外的RxJava模块，它为我们提供了RxJava和Apache
    HTTP之间的绑定。我们将在我们的HTTP请求实现中使用它；你可以在[https://github.com/ReactiveX/RxApacheHttp](https://github.com/ReactiveX/RxApacheHttp)找到它。
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There are many additional RxJava projects, placed at [https://github.com/ReactiveX](https://github.com/ReactiveX).
    Some of them are very useful. For example, most of the `from(Stream/Reader/File)`
    methods that we have implemented in this book have better implementations in the
    `RxJavaString` module.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的RxJava项目，放在[https://github.com/ReactiveX](https://github.com/ReactiveX)。其中一些非常有用。例如，我们在本书中实现的大多数`from(Stream/Reader/File)`方法在`RxJavaString`模块中有更好的实现。
- en: 'The next step is to implement the `githubUserInfoRequest(HttpAsyncClient, String)`
    method:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现`githubUserInfoRequest(HttpAsyncClient, String)`方法：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This method is fairly simple too.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法也相当简单。
- en: First we need to have a GitHub *username* in order to execute our request, so
    we do some checking for it. It should not be `null`. If it's `null`, we'll return
    an *error-emitting* `Observable` instance, emitting an `OnError` notification
    with a `NullPointerException` exception. Our printing subscriber function will
    display it to the users.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要有一个GitHub的*username*来执行我们的请求，所以我们对它进行一些检查。它不应该是`null`。如果是`null`，我们将返回一个发出*error*的`Observable`实例，发出带有`NullPointerException`异常的`OnError`通知。我们的打印订阅函数将把它显示给用户。
- en: In order to do the actual HTTP request, we'll use another method with the signature
    `requestJson(HttpAsyncClient, String)`. It is the one returning the `Observable`
    instance, emitting JSON represented by the Map instances.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实际进行HTTP请求，我们将使用另一个具有签名`requestJson(HttpAsyncClient, String)`的方法。它返回发出JSON的`Map`实例的`Observable`实例。
- en: If the user is not a real GitHub user, or if we've exceeded the GitHub API limit,
    GitHub will send us a JSON message. That's why we need to check whether the JSON
    we've got contains repository data or something else. The JSON representing a
    repository has a `git_url` key. We use this to filter only JSONs that represent
    GitHub repositories.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户不是真正的GitHub用户，或者我们已经超过了GitHub API的限制，GitHub会向我们发送一个JSON消息。这就是为什么我们需要检查我们得到的JSON是否包含存储库数据或其他内容。表示存储库的JSON具有`git_url`键。我们使用这个键来过滤只表示GitHub存储库的JSON。
- en: We need only the non-fork repositories; that's why we filter them.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要非分叉存储库；这就是为什么我们要对它们进行过滤。
- en: 'This is again quite simple to understand. Up until now, we''ve used only the
    `map()` and `filter()` operators in our logic, nothing special. Let''s look at
    the actual HTTP request implementation:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这再次非常容易理解。到目前为止，我们的逻辑中只使用了`map()`和`filter()`运算符，没有什么特别的。让我们看一下实际的HTTP请求实现：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `ObservableHttp` class comes from the `RxApacheHttp` module. It does the
    asynchronous HTTP request for us, using the Apache `HttpClient` instance. The
    `createGet(url, client)` method returns an instance that can be converted into
    an actual `Observable` instance with the `toObservable()` method. We do exactly
    that here.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ObservableHttp`类来自`RxApacheHttp`模块。它为我们执行异步HTTP请求，使用Apache的`HttpClient`实例。`createGet(url,
    client)`方法返回一个实例，可以使用`toObservable()`方法转换为实际的`Observable`实例。我们在这里就是这样做的。'
- en: This `Observable` instance, when it receives the HTTP response, will emit it
    as an `ObservableHttpResponse` instance. This instance has a `getContent()` method,
    which returns an `Observable<byte[]>` object, representing the response as a *sequence
    of bytes*. We turn these *byte arrays* into `String` objects with a simple `map()`
    operator. Now we have a JSON response represented by a `String` object.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当这个`Observable`实例接收到HTTP响应时，它将作为`ObservableHttpResponse`实例发出。这个实例有一个`getContent()`方法，它返回一个`Observable<byte[]>`对象，表示响应为*字节序列*。我们使用简单的`map()`运算符将这些*字节数组*转换为`String`对象。现在我们有一个由`String`对象表示的JSON响应。
- en: If there is some problem connecting to GitHub, we *retry* five times.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果连接到GitHub出现问题，我们将*重试*五次。
- en: The cast to `String` is necessary because of Java's type system. Additionally,
    we remove any trailing/leading white spaces from the response, using the `trim()`
    method.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Java的类型系统，将其转换为`String`是必要的。此外，我们使用`trim()`方法从响应中删除任何尾随/前导空格。
- en: 'We clear the cached information for this URL. We use a simple in-memory Map
    instance from URL to JSON data cache implementation in order to not repeat the
    same request multiple times. How do we fill up this cache? We''ll see soon in
    the following piece of code. Let''s take a look at it:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们清除了此URL的缓存信息。我们使用一个简单的内存中的Map实例从URL到JSON数据缓存实现，以便不重复多次发出相同的请求。我们如何填充这个缓存？我们很快就会在下面的代码中看到。让我们来看一下：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The response can be either a JSON array or a JSON object; we branch our logic
    using the `filter()` operator here. The JSON object is turned to a JSON array
    in order to use common logic later.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应可以是JSON数组或JSON对象；我们在这里使用`filter()`运算符来分支我们的逻辑。将JSON对象转换为JSON数组，以便稍后使用通用逻辑。
- en: Using the `ambWith()` operator, we'll use the one emitting data from the two
    `Observable` instances and treat the result as a JSON array. We will have either
    array or object JSON, and in the end, the result is just an `Observable` instance
    emitting a JSON array as a `String` object.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ambWith()`运算符，我们将使用从两个`Observable`实例中发出数据的那个，并将结果视为JSON数组。我们将有数组或对象JSON，最终结果只是一个作为`String`对象发出JSON数组的`Observable`实例。
- en: We turn this `String` object into actual List of Map instances, using Google's
    JSON library.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用Google的JSON库将这个`String`对象转换为实际的Map实例列表。
- en: The `flatMapIterable()` operator flattens the `Observable` instance emitting
    a `List` instance to one that emits its contents—multiple Map instances representing
    JSON.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`flatMapIterable()`运算符将发出`List`实例的`Observable`实例扁平化为发出其内容的实例，即表示JSON的多个Map实例。'
- en: All of these Map instances are cached by adding them to the in-memory cache.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些Map实例都被添加到内存中的缓存中。
- en: Using the `amb()` operator, we implement the fallback-to-cache mechanism. If
    the cache contains data, it will emit first, and this data will be used instead.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`amb()`运算符，我们实现了回退到缓存的机制。如果缓存包含数据，它将首先发出，这些数据将被使用。
- en: 'We have a real example of HTTP data retrieval, implemented using `Observable`
    instances! The output of this request look like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个使用`Observable`实例实现的HTTP数据检索的真实示例！这个请求的输出看起来像这样：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code for the preceding example can be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/HttpRequestsExample.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/HttpRequestsExample.java).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例的源代码可以在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/HttpRequestsExample.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/HttpRequestsExample.java)找到。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've learned how to combine `Observable` instances, how to
    create dependencies between them, and how to react to errors. As we've seen in
    the final example, we are now capable of creating quite complex logic using just
    `Observable` instances and their operators. Adding to that the RxJava modules
    available on the Internet, we can turn almost every data source into an `Observable`
    instance.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何组合`Observable`实例，如何在它们之间创建依赖关系，以及如何对错误做出反应。正如我们在最后的例子中看到的，我们现在能够使用只有`Observable`实例和它们的运算符来创建相当复杂的逻辑。再加上互联网上可用的RxJava模块，我们几乎可以将每个数据源转换为`Observable`实例。
- en: The next step is to master Schedulers. They will provide us with the power to
    handle multi-threading while coding using this reactive style of programming.
    Java is famous for its concurrency; it is time to add these capabilities of the
    language to our `Observable` chains, doing multiple HTTP requests in parallel
    (for example). Another new thing we'll learn is how to **buffer**, **throttle**,
    and **debounce** our data, techniques that come hand-in-hand with real-time data
    streams.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是掌握调度器。它们将为我们提供处理多线程的能力，同时在编码时使用这种响应式编程风格。Java以其并发性而闻名；现在是时候将语言的这些能力添加到我们的`Observable`链中，以并行方式执行多个HTTP请求（例如）。我们将学习的另一件新事情是如何对我们的数据进行**缓冲**、**节流**和**去抖动**，这些技术与实时数据流息息相关。
