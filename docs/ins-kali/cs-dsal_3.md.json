["```cs\nStack<char> chars = new Stack<char>(); \nforeach (char c in \"LET'S REVERSE!\") \n{ \n    chars.Push(c); \n} \n\nwhile (chars.Count > 0) \n{ \n    Console.Write(chars.Pop()); \n} \nConsole.WriteLine(); \n```", "```cs\n    !ESREVER S'TEL\n```", "```cs\npublic class HanoiTower \n{ \n    public int DiscsCount { get; private set; } \n    public int MovesCount { get; private set; } \n    public Stack<int> From { get; private set; } \n    public Stack<int> To { get; private set; } \n    public Stack<int> Auxiliary { get; private set; } \n    public event EventHandler<EventArgs> MoveCompleted; (...) \n} \n```", "```cs\npublic HanoiTower(int discs) \n{ \n    DiscsCount = discs; \n    From = new Stack<int>(); \n    To = new Stack<int>(); \n    Auxiliary = new Stack<int>(); \n    for (int i = 1; i <= discs; i++) \n    { \n        int size = discs - i + 1; \n        From.Push(size); \n    } \n} \n```", "```cs\npublic void Start() \n{ \n    Move(DiscsCount, From, To, Auxiliary); \n} \n```", "```cs\npublic void Move(int discs, Stack<int> from, Stack<int> to,  \n    Stack<int> auxiliary) \n{ \n    if (discs > 0) \n    { \n        Move(discs - 1, from, auxiliary, to); \n\n        to.Push(from.Pop()); \n        MovesCount++; \n        MoveCompleted?.Invoke(this, EventArgs.Empty); \n\n        Move(discs - 1, auxiliary, to, from); \n    } \n} \n```", "```cs\nprivate const int DISCS_COUNT = 10; \nprivate const int DELAY_MS = 250; \nprivate static int _columnSize = 30; \n```", "```cs\nstatic void Main(string[] args) \n{ \n    _columnSize = Math.Max(6, GetDiscWidth(DISCS_COUNT) + 2); \n    HanoiTower algorithm = new HanoiTower(DISCS_COUNT); \n    algorithm.MoveCompleted += Algorithm_Visualize; \n    Algorithm_Visualize(algorithm, EventArgs.Empty); \n    algorithm.Start(); \n} \n```", "```cs\nprivate static void Algorithm_Visualize( \n    object sender, EventArgs e) \n{ \n    Console.Clear(); \n\n    HanoiTowers algorithm = (HanoiTowers)sender; \n    if (algorithm.DiscsCount <= 0) \n    { \n        return; \n    } \n\n    char[][] visualization = InitializeVisualization(algorithm); \n    PrepareColumn(visualization, 1, algorithm.DiscsCount,  \n        algorithm.From); \n    PrepareColumn(visualization, 2, algorithm.DiscsCount,  \n        algorithm.To); \n    PrepareColumn(visualization, 3, algorithm.DiscsCount,  \n        algorithm.Auxiliary); \n\n    Console.WriteLine(Center(\"FROM\") + Center(\"TO\") +  \n        Center(\"AUXILIARY\")); \n    DrawVisualization(visualization); \n    Console.WriteLine(); \n    Console.WriteLine($\"Number of moves: {algorithm.MovesCount}\"); \n    Console.WriteLine($\"Number of discs: {algorithm.DiscsCount}\"); \n\n    Thread.Sleep(DELAY_MS); \n} \n```", "```cs\nprivate static char[][] InitializeVisualization( \n    HanoiTowers algorithm) \n{ \n    char[][] visualization = new char[algorithm.DiscsCount][]; \n\n    for (int y = 0; y < visualization.Length; y++) \n    { \n        visualization[y] = new char[_columnSize * 3]; \n        for (int x = 0; x < _columnSize * 3; x++) \n        { \n            visualization[y][x] = ' '; \n        } \n    } \n\n    return visualization; \n} \n```", "```cs\nprivate static void PrepareColumn(char[][] visualization,  \n    int column, int discsCount, Stack<int> stack) \n{ \n    int margin = _columnSize * (column - 1); \n    for (int y = 0; y < stack.Count; y++) \n    { \n        int size = stack.ElementAt(y); \n        int row = discsCount - (stack.Count - y); \n        int columnStart = margin + discsCount - size; \n        int columnEnd = columnStart + GetDiscWidth(size); \n        for (int x = columnStart; x <= columnEnd; x++) \n        { \n            visualization[row][x] = '='; \n        } \n    } \n} \n```", "```cs\nprivate static void DrawVisualization(char[][] visualization) \n{ \n    for (int y = 0; y < visualization.Length; y++) \n    { \n        Console.WriteLine(visualization[y]); \n    } \n} \n```", "```cs\nprivate static string Center(string text) \n{ \n    int margin = (_columnSize - text.Length) / 2; \n    return text.PadLeft(margin + text.Length) \n        .PadRight(_columnSize); \n} \n```", "```cs\nprivate static int GetDiscWidth(int size) \n{ \n    return 2 * size - 1; \n} \n```", "```cs\n            FROM                  TO                AUXILIARY\n             ==\n            ====\n           ======\n          ========\n         ==========\n        ============\n       ==============\n      ================\n     ==================\n    ====================\n\n```", "```cs\n            FROM                  TO                AUXILIARY    \n\n            ====\n           ======\n          ========\n         ==========\n        ============\n       ==============\n      ================\n     ==================\n    ====================                               ==\n\n```", "```cs\n            FROM                  TO                AUXILIARY          \n\n            ====\n         ==========\n        ============\n       ==============\n      ================\n     ==================         ======\n    ====================       ========                ==\n\n```", "```cs\n            FROM                  TO                AUXILIARY\n                                  ==\n                                 ====\n                                ======\n                               ========\n                              ==========\n                             ============\n                            ==============\n                           ================\n                          ==================\n                         ====================\n\n```", "```cs\npublic class IncomingCall \n{ \n    public int Id { get; set; } \n    public int ClientId { get; set; } \n    public DateTime CallTime { get; set; } \n    public DateTime StartTime { get; set; } \n    public DateTime EndTime { get; set; } \n    public string Consultant { get; set; } \n} \n```", "```cs\npublic class CallCenter \n{ \n    private int _counter = 0; \n    public Queue<IncomingCall> Calls { get; private set; } \n\n    public CallCenter() \n    { \n        Calls = new Queue<IncomingCall>(); \n    } \n} \n```", "```cs\npublic void Call(int clientId) \n{ \n    IncomingCall call = new IncomingCall() \n    { \n        Id = ++_counter, \n        ClientId = clientId, \n        CallTime = DateTime.Now \n    }; \n    Calls.Enqueue(call); \n} \n```", "```cs\npublic IncomingCall Answer(string consultant) \n{ \n    if (Calls.Count > 0) \n    { \n        IncomingCall call = Calls.Dequeue(); \n        call.Consultant = consultant; \n        call.StartTime = DateTime.Now; \n        return call; \n    } \n    return null; \n} \n```", "```cs\npublic void End(IncomingCall call) \n{ \n    call.EndTime = DateTime.Now; \n} \n```", "```cs\npublic bool AreWaitingCalls() \n{ \n    return Calls.Count > 0; \n} \n```", "```cs\nstatic void Main(string[] args) \n{ \n    Random random = new Random(); \n\n    CallCenter center = new CallCenter(); \n    center.Call(1234); \n    center.Call(5678); \n    center.Call(1468); \n    center.Call(9641); \n\n    while (center.AreWaitingCalls()) \n    { \n        IncomingCall call = center.Answer(\"Marcin\"); \n        Log($\"Call #{call.Id} from {call.ClientId}  \n            is answered by {call.Consultant}.\"); \n        Thread.Sleep(random.Next(1000, 10000)); \n        center.End(call); \n        Log($\"Call #{call.Id} from {call.ClientId}  \n            is ended by {call.Consultant}.\"); \n    } \n} \n```", "```cs\nprivate static void Log(string text) \n{ \n    Console.WriteLine($\"[{DateTime.Now.ToString(\"HH:mm:ss\")}]  \n        {text}\"); \n} \n```", "```cs\n    [15:24:36] Call #1 from 1234 is answered by Marcin.\n    [15:24:40] Call #1 from 1234 is ended by Marcin.\n    [15:24:40] Call #2 from 5678 is answered by Marcin.\n    [15:24:48] Call #2 from 5678 is ended by Marcin.\n    [15:24:48] Call #3 from 1468 is answered by Marcin.\n    [15:24:53] Call #3 from 1468 is ended by Marcin.\n    [15:24:53] Call #4 from 9641 is answered by Marcin.\n    [15:24:57] Call #4 from 9641 is ended by Marcin.\n\n```", "```cs\npublic class IncomingCall \n{ \n    public int Id { get; set; } \n    public int ClientId { get; set; } \n    public DateTime CallTime { get; set; } \n    public DateTime StartTime { get; set; } \n    public DateTime EndTime { get; set; } \n    public string Consultant { get; set; } \n} \n```", "```cs\npublic class CallCenter \n{ \n    private int _counter = 0; \n    public ConcurrentQueue<IncomingCall> Calls  \n        { get; private set; } \n\n    public CallCenter() \n    { \n        Calls = new ConcurrentQueue<IncomingCall>(); \n    } \n} \n```", "```cs\npublic int Call(int clientId) \n{ \n    IncomingCall call = new IncomingCall() \n    { \n        Id = ++_counter, \n        ClientId = clientId, \n        CallTime = DateTime.Now \n    }; \n    Calls.Enqueue(call); \n    return Calls.Count; \n} \n```", "```cs\npublic IncomingCall Answer(string consultant) \n{ \n    if (Calls.Count > 0  \n        && Calls.TryDequeue(out IncomingCall call)) \n    { \n        call.Consultant = consultant; \n        call.StartTime = DateTime.Now; \n        return call; \n    } \n    return null; \n} \n```", "```cs\npublic void End(IncomingCall call) \n{ \n    call.EndTime = DateTime.Now; \n}\n\npublic bool AreWaitingCalls() \n{ \n    return Calls.Count > 0; \n}\n```", "```cs\nstatic void Main(string[] args) \n{ \n    CallCenter center = new CallCenter(); \n    Parallel.Invoke( \n        () => CallersAction(center), \n        () => ConsultantAction(center, \"Marcin\",  \n                  ConsoleColor.Red), \n        () => ConsultantAction(center, \"James\",  \n                  ConsoleColor.Yellow), \n        () => ConsultantAction(center, \"Olivia\",  \n                  ConsoleColor.Green)); \n} \n```", "```cs\nprivate static void CallersAction(CallCenter center) \n{ \n    Random random = new Random(); \n    while (true) \n    { \n        int clientId = random.Next(1, 10000); \n        int waitingCount = center.Call(clientId); \n        Log($\"Incoming call from {clientId},  \n            waiting in the queue: {waitingCount}\"); \n        Thread.Sleep(random.Next(1000, 5000)); \n    } \n}\n```", "```cs\nprivate static void ConsultantAction(CallCenter center,  \n    string name, ConsoleColor color) \n{ \n    Random random = new Random(); \n    while (true) \n    { \n        IncomingCall call = center.Answer(name); \n        if (call != null) \n        { \n            Console.ForegroundColor = color; \n            Log($\"Call #{call.Id} from {call.ClientId} is answered  \n                by {call.Consultant}.\"); \n            Console.ForegroundColor = ConsoleColor.Gray; \n\n            Thread.Sleep(random.Next(1000, 10000)); \n            center.End(call); \n\n            Console.ForegroundColor = color; \n            Log($\"Call #{call.Id} from {call.ClientId}  \n                is ended by {call.Consultant}.\"); \n            Console.ForegroundColor = ConsoleColor.Gray; \n\n            Thread.Sleep(random.Next(500, 1000)); \n        } \n        else \n        { \n            Thread.Sleep(100); \n        } \n    } \n} \n```", "```cs\nprivate static void Log(string text) \n{ \n    Console.WriteLine($\"[{DateTime.Now.ToString(\"HH:mm:ss\")}]  \n        {text}\"); \n} \n```", "```cs\npublic class IncomingCall \n{ \n    public int Id { get; set; } \n    public int ClientId { get; set; } \n    public DateTime CallTime { get; set; } \n    public DateTime StartTime { get; set; } \n    public DateTime EndTime { get; set; } \n    public string Consultant { get; set; } \n    public bool IsPriority { get; set; } \n} \n```", "```cs\npublic class CallCenter \n{ \n    private int _counter = 0; \n    public SimplePriorityQueue<IncomingCall> Calls  \n        { get; private set; } \n\n    public CallCenter() \n    { \n        Calls = new SimplePriorityQueue<IncomingCall>(); \n    } \n} \n```", "```cs\npublic void Call(int clientId, bool isPriority = false) \n{ \n    IncomingCall call = new IncomingCall() \n    { \n        Id = ++_counter, \n        ClientId = clientId, \n        CallTime = DateTime.Now, \n        IsPriority = isPriority \n    }; \n    Calls.Enqueue(call, isPriority ? 0 : 1); \n} \n```", "```cs\npublic IncomingCall Answer(string consultant) \n{ \n    if (Calls.Count > 0) \n    { \n        IncomingCall call = Calls.Dequeue(); \n        call.Consultant = consultant; \n        call.StartTime = DateTime.Now; \n        return call; \n    } \n    return null; \n}\n\npublic void End(IncomingCall call) \n{ \n    call.EndTime = DateTime.Now; \n}\n\npublic bool AreWaitingCalls() \n{ \n    return Calls.Count > 0; \n} \n```", "```cs\nstatic void Main(string[] args) \n{ \n    Random random = new Random(); \n\n    CallCenter center = new CallCenter(); \n    center.Call(1234); \n    center.Call(5678, true); \n    center.Call(1468); \n    center.Call(9641, true); \n\n    while (center.AreWaitingCalls()) \n    { \n        IncomingCall call = center.Answer(\"Marcin\"); \n        Log($\"Call #{call.Id} from {call.ClientId}  \n            is answered by {call.Consultant} /  \n            Mode: {(call.IsPriority ? \"priority\" : \"normal\")}.\"); \n        Thread.Sleep(random.Next(1000, 10000)); \n        center.End(call); \n        Log($\"Call #{call.Id} from {call.ClientId}  \n            is ended by {call.Consultant}.\"); \n    } \n} \nprivate static void Log(string text) \n{ \n    Console.WriteLine($\"[{DateTime.Now.ToString(\"HH:mm:ss\")}]  \n        {text}\"); \n} \n```", "```cs\n    [15:40:26] Call #2 from 5678 is answered by Marcin / Mode:    \n **priority**.\n    [15:40:35] Call #2 from 5678 is ended by Marcin.\n    [15:40:35] Call #4 from 9641 is answered by Marcin / Mode: \n **priority**.\n    [15:40:39] Call #4 from 9641 is ended by Marcin.\n    [15:40:39] Call #1 from 1234 is answered by Marcin / Mode: **normal**.\n    [15:40:48] Call #1 from 1234 is ended by Marcin.\n    [15:40:48] Call #3 from 1468 is answered by Marcin / Mode: **normal**.\n    [15:40:57] Call #3 from 1468 is ended by Marcin.\n\n```"]