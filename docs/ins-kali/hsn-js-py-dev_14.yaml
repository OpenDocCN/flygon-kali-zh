- en: What Is Node.js?
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 Node.js？
- en: Now that we've examined the use of JavaScript on the frontend, let's dive into
    its role in the "JavaScript everywhere" paradigm using Node.js. We discussed Node.js
    in [Chapter 2](94fc54d0-7655-4e18-ac2b-762a0752afaa.xhtml), *Can We Use JavaScript
    Server-Side? Sure!*, so now it's time to dive deeper into how we can use it to
    create rich server-side applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经研究了 JavaScript 在前端的使用，让我们深入探讨它在“JavaScript 无处不在”范式中的作用，使用 Node.js。我们在[第
    2 章](94fc54d0-7655-4e18-ac2b-762a0752afaa.xhtml)，*我们可以在服务器端使用 JavaScript 吗？当然可以！*中讨论了
    Node.js，现在是时候更深入地了解我们如何使用它来创建丰富的服务器端应用程序了。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: History and usage
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 历史和用法
- en: Installation and usage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和用法
- en: Grammar and structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法和结构
- en: Hello, World!
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hello, World!
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Be prepared to work with the code provided in the `Chapter-11` directory of
    the repository: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-11](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-11).
    As we'll be working with command-line tools, also have your Terminal or command-line
    shell available. We'll need a modern browser and a local code editor.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好在存储库的 `Chapter-11` 目录中使用提供的代码：[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-11](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-11)。由于我们将使用命令行工具，还需要准备好终端或命令行
    shell。我们需要一个现代浏览器和一个本地代码编辑器。
- en: History and usage
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 历史和用法
- en: First released in 2009, Node.js has been widely adopted in the industry by major
    corporations and smaller companies alike. There are literally thousands of packages
    available for use in Node.js, creating a rich ecosystem of users and a community
    of developers. As with any open source project, community support is crucial to
    the adoption and longevity of the technology.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 首次发布于 2009 年，已被行业中的大公司和小公司广泛采用。在 Node.js 中有成千上万的可用包，为用户和开发者社区创造了丰富的生态系统。与任何开源项目一样，社区支持对于技术的采用和长期性至关重要。
- en: From a technical standpoint, Node.js is a runtime environment in a single-threaded
    event loop. What this means in practice is that it can handle thousands upon thousands
    of concurrent connections without the overhead of switching between contexts.
    For those who are more familiar with other architectural patterns, a single thread
    might seem counterintuitive, and it used to be held up as an example of Node.js's
    perceived breakpoint. However, it can be argued that the stability and reliability
    of a Node.js system has shown this paradigm to be sustainable. There are ways
    to augment a server's capacity for handling requests, but it should be noted that
    it's a bit more nuanced than just throwing additional hardware resources at the
    problem. How to scale Node.js is a bit out of scope for this book, but there are
    techniques involving the underlying library, called libuv.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，Node.js 是一个单线程事件循环的运行时环境。在实践中，这意味着它可以处理成千上万个并发连接，而无需在上下文之间切换时产生额外开销。对于那些更熟悉其他架构模式的人来说，单线程可能看起来有些违反直觉，过去它曾被视为
    Node.js 感知到的断点的一个例子。然而，可以说 Node.js 系统的稳定性和可靠性已经证明了这种范式是可持续的。有办法增加服务器处理请求的能力，但应该注意的是，这比简单地向问题投入更多硬件资源要复杂一些。如何扩展
    Node.js 超出了本书的范围，但涉及到底层库 libuv 的技术。
- en: At the time of writing, the biggest feather in Node.js's cap might be its powering
    of Twitter. According to SimilarTech, its 4.3 billion monthly visits stand as
    a testament to its power. Now, I'm sure the Twitter team has done some incredible
    architecting over the years to power the platform, and we rarely see the famous
    Twitter "fail whale" anymore; I would argue that the reliance on Node.js is a
    good thing that has helped provide sustainability and reliability.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Node.js 最大的优势可能是推动 Twitter。根据 SimilarTech 的数据，其每月 43 亿次访问证明了其强大的力量。现在，我相信
    Twitter 团队多年来在推动平台方面做了一些令人难以置信的架构工作，我们很少再看到著名的 Twitter “fail whale”；我认为依赖 Node.js
    是一个有助于提供可持续性和可靠性的好事情。
- en: Onward to using it!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用它！
- en: Installation and usage
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和用法
- en: The easiest way to install Node.js is to use the installers provided for you
    at [https://nodejs.org](https://nodejs.org). These packages will guide you through
    the installation of Node.js on your system. Be sure to also install `npm`, Node's
    package manager. You can refer to [Chapter 3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml), *Nitty-Gritty
    Grammar*, for more details on installation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Node.js 的最简单方法是使用 [https://nodejs.org](https://nodejs.org) 提供的安装程序。这些包将指导您在系统上安装
    Node.js。确保还安装了 `npm`，Node 的包管理器。您可以参考[第 3 章](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml)，*细枝末节的语法*，了解更多安装细节。
- en: 'Let''s give it a go:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: Open a Terminal window.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端窗口。
- en: Type `node`. You will see a simple `>` to indicate that Node.js is running.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `node`。您将看到一个简单的 `>`，表示 Node.js 正在运行。
- en: Type `console.log("Hi!")` and hit *Enter*.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `console.log("Hi!")` 并按 *Enter*。
- en: It's really as simple as that! Exit the command prompt either by hitting *Ctrl
    + C* twice or typing `.exit`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单！通过两次按 *Ctrl + C* 或输入 `.exit` 来退出命令提示符。
- en: 'So, that''s fairly basic. Let''s do something a bit more interesting. Here''s
    the contents of `chapter-11/guessing-game/guessing-game.js`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这相当基础。让我们做一些更有趣的事情。这是 `chapter-11/guessing-game/guessing-game.js` 的内容：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Run the program with `node guessing-game.js`. As you can probably tell from
    the code, the program will select a random number between 1 and 10 and then ask
    you to guess it. You can enter numbers at the command prompt in order to guess
    the number.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `node guessing-game.js` 运行程序。从代码中您可能能够看出，程序将在 1 到 10 之间选择一个随机数，然后要求您猜测它。您可以在命令提示符中输入数字来猜测这个数字。
- en: Let's break down this example in the next section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中分解这个示例。
- en: Grammar and structure
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法和结构
- en: 'The great thing about Node.js is that you already know how to write it! Take
    this for example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 的伟大之处在于您已经知道如何编写它！举个例子：
- en: '| **JavaScript** | **Node.js** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **JavaScript** | **Node.js** |'
- en: '| **`console.log("Hello!")`** | **`console.log("Hello!")`** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **`console.log("Hello!")`** | **`console.log("Hello!")`** |'
- en: 'That''s not a trick: it''s identical. Node.js is syntactically almost identical
    to browser-based JavaScript, right down to the fight between ES5 and ES6, as we''ve
    discussed previously. In my experience, there is still a preponderance of ES5-style
    code in use with Node.js, so you will see code with `var` instead of `let` or
    `const`, as well as a healthy use of semicolons. You can review [Chapter 3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml), *Nitty-Gritty
    Grammar* for more information on these distinctions.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个技巧：它是相同的。Node.js在语法上几乎与基于浏览器的JavaScript相同，甚至包括ES5和ES6之间的区别，正如我们之前讨论过的。根据我的经验，Node.js中仍然存在大量使用ES5风格的代码，因此您会看到使用`var`而不是`let`或`const`的代码，以及大量使用分号。您可以查看[第3章](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml)，*细枝末节的语法*，了解更多关于这些区别的信息。
- en: 'In our guessing game example, we see one thing that is new to us – the first
    line:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的猜数字游戏示例中，我们看到了一个对我们来说是新的东西 - 第一行：
- en: '`const readline = require(''readline'')`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`const readline = require(''readline'')`'
- en: 'Node.js is a *modular* system, which means that not all parts of the language
    will be brought in at once. Rather, modules will be included when the `require()`
    statement is issued. Some of these modules will be built-in to Node.js, as `readline`
    is, and some will be installed via npm (more to come on that part). We use the
    `readline.createInterface()` method to create a way to use our input and output,
    and then the rest of the code of our guessing game program should make some sense.
    It''s simply going to ask the question over and over until the number entered
    equals the random number generated by the program:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是一个*模块化*系统，这意味着并非所有语言的部分都会一次性引入。相反，当发出`require()`语句时，将包含模块。其中一些模块将内置到Node.js中，如`readline`，而另一些将通过npm安装（更多内容将在后面介绍）。我们使用`readline.createInterface()`方法创建一种使用我们的输入和输出的方式，然后我们猜数字游戏程序的其余代码应该是有些意义的。它只是会一遍又一遍地问问题，直到输入的数字等于程序生成的随机数：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's take a look at an example that reads files from the filesystem, which
    is something we can't do from an ordinary client-side web application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，从文件系统中读取文件，这是我们无法从普通的客户端Web应用程序中做到的。
- en: Customer lookup
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户查找
- en: 'Take a look at the customer-lookup directory, [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-11/customer-lookup](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-11/customer-lookup),
    and run the script with `node index.js`. It''s fairly simple:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`customer-lookup`目录，[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-11/customer-lookup](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-11/customer-lookup)，并使用`node
    index.js`运行脚本。这很简单：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Some of this will look familiar, like the `readline` interface. Here''s something
    new that we''re working with, though: `const fs = require(''fs'')`. This is bringing
    in the filesystem module so that we can work with files stored on the filesystem.
    If you look in the data directory, you will find four basic JSON files.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些看起来很熟悉，比如`readline`接口。不过，我们正在使用一些新的东西：`const fs = require('fs')`。这是引入文件系统模块，以便我们可以处理存储在文件系统上的文件。如果您查看数据目录，您会发现四个基本的JSON文件。
- en: 'We''re doing three things in the `getCustomers()` function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getCustomers()`函数中，我们要做三件事：
- en: Using `readdirSync` to get a list of files in the data directory. When working
    with filesystems, you can interact with the system in a synchronous or asynchronous
    manner, similar to interacting with APIs and Ajax. For ease of use in this example,
    we'll be working with the synchronous filesystem calls.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`readdirSync`获取数据目录中文件的列表。在处理文件系统时，您可以以同步或异步方式与系统进行交互，类似于与API和Ajax进行交互。为了方便起见，在本例中，我们将使用同步文件系统调用。
- en: Now `files` will be a listing of the files in the data directory. Loop through
    the files and store the contents in the `data` variable.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`files`将是数据目录中文件的列表。循环遍历文件并将内容存储在`data`变量中。
- en: Push the parsed JSON into the `customers` array.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将解析后的JSON推送到`customers`数组中。
- en: So far so good. The `ask()` function should also be easy to understand, as we're
    just seeing whether the number entered by the user exists in the array and then
    returning the data in the associated file.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。`ask()`函数也应该很容易理解，因为我们只是查看用户输入的数字是否存在于数组中，然后返回相关文件中的数据。
- en: 'Now let''s look at how we can use an open source project in Node.js to achieve
    a (rather silly) goal: creating a text-art representation of a photo.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在Node.js中使用开源项目来实现一个（相当愚蠢的）目标：创建照片的文本艺术表示。
- en: ASCII art and packages
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASCII艺术和包
- en: 'We''ll be working with the instructions in the GitHub repository at [https://www.npmjs.com/package/asciify-image](https://www.npmjs.com/package/asciify-image):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用GitHub存储库中的指令[https://www.npmjs.com/package/asciify-image](https://www.npmjs.com/package/asciify-image)：
- en: '![](assets/7553f1bb-1fe2-4e98-bde5-4baa497be6b6.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7553f1bb-1fe2-4e98-bde5-4baa497be6b6.png)'
- en: Figure 11.1 - An ASCII art representation of me!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 - 我的ASCII艺术表示！
- en: 'Here''s the installation step by step:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是逐步安装步骤：
- en: Create a new directory called `ascii-art`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ascii-art`的新目录。
- en: '`cd ascii-art`'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cd ascii-art`'
- en: '`npm init`. You can accept the defaults provided by npm.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`npm init`。您可以接受npm提供的默认值。'
- en: '`npm install asciify-image`'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`npm install asciify-image`'
- en: 'Now, let''s have some fun:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来玩一些游戏：
- en: Place an image in the `ascii-art` directory, such as a JPEG sized to no more
    than 200 x 200 pixels or so. Name it `image.jpg`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ascii-art`目录中放置一张图片，比如一个大小不超过200 x 200像素的JPEG。命名为`image.jpg`。
- en: Create `index.js` in the directory and open it.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目录中创建`index.js`并打开它。
- en: 'Enter this code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入此代码：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Execute the program with `node index.js` and view your wonderful artwork! Depending
    on your terminal colors, you may have to work with some of the options to change
    colors around to display on a light background. These are documented in the GitHub
    repository linked previously.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`node index.js`执行程序，并查看你美妙的艺术作品！根据你的终端颜色，你可能需要使用一些选项来改变颜色以在浅色背景上显示。这些选项在之前链接的GitHub存储库中有文档记录。
- en: 'What have we shown here? First, we used npm to initialize a project and then
    install a dependency. If you noticed, running these created some files and directories
    for you. Your directory structure should look close to this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里展示了什么？首先，我们使用npm初始化了一个项目，然后安装了一个依赖项。如果你注意到了，运行这些命令为你创建了一些文件和目录。你的目录结构应该看起来接近这样：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `node_modules` directory will have a lot more files inside it. If you're
    familiar with source control such as Git, you'll know that the `node_modules`
    directory should always be *ignored* and not committed to source control.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`node_modules`目录里会有更多的文件。如果你熟悉Git等源代码控制，你会知道`node_modules`目录应该始终被*忽略*，不要提交到源代码控制。'
- en: 'Let''s take a look at `package.json`, which will look similar to this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`package.json`，它看起来会类似于这样：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we dissect this a bit, we'll find that this npm entry point into our program
    is actually rather simple. There's some metadata about the project, an object
    of dependencies with their version, and some scripts that we can use to control
    our project.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们稍微分析一下，我们会发现这个npm入口点到我们的程序实际上相当简单。有关项目的一些元数据，一个带有版本的依赖对象，以及一些我们可以用来控制我们的项目的脚本。
- en: If you're familiar with npm, you may have used the `npm start` command to run
    a project instead of manually entering `node`. However, in our `package.json`,
    we don't have a start script. Let's add one.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉npm，你可能已经使用`npm start`命令来运行一个项目，而不是手动输入`node`。然而，在我们的`package.json`中，我们没有一个启动脚本。让我们添加一个。
- en: 'Modify the `scripts` object to look like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`scripts`对象看起来像这样：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Don't forget to pay attention to your commas, as this is valid JSON and will
    break if commas are improperly used. Now, to start our program, we only have to
    type `npm start`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记注意你的逗号，因为这是有效的JSON，如果逗号使用不当，它将会中断。现在，要启动我们的程序，我们只需要输入`npm start`。
- en: 'This is a very basic example of npm scripts. It is conventional in Node.js
    to use `package.json` to control all of the scripts for building and testing.
    You can name your commands as you''d like and execute them like this: `npm run
    my-fun-command`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是npm脚本的一个非常基本的例子。在Node.js中，习惯使用`package.json`来控制所有构建和测试的脚本。你可以按自己的喜好命名你的命令，并像这样执行它们：`npm
    run my-fun-command`。
- en: For our next trick, we'll create a "Hello, World!" application from scratch.
    It will, however, do a bit more than just say hello.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们接下来的技巧，我们将从头开始创建一个“Hello, World!”应用程序。然而，它将做的不仅仅是打招呼。
- en: Hello, World!
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你好，世界！
- en: Create a new directory called `hello-world` and initialize a node project with
    `npm init`, similar to how we did previously. In [Chapter 13](57b3ea57-b927-47f6-b07e-d1dd11796e1a.xhtml),* Using
    Express*, we'll work with Express, a popular web server for Node.js. However,
    for now, we'll use a very bare-bones method of creating a page.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`hello-world`的新目录，并使用`npm init`初始化一个node项目，类似于我们之前的做法。在[第13章](57b3ea57-b927-47f6-b07e-d1dd11796e1a.xhtml)，*使用Express*中，我们将使用Express，一个流行的Node.js网络服务器。然而，现在，我们将使用一种非常简单的方法来创建一个页面。
- en: 'Start off your `index.js` script as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 开始你的`index.js`脚本如下：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As with `fs` and `readline`, `http` is built in to Node, so we don''t have
    to use `npm install` to get it. Rather, this will work out of the box. Add a start
    script in your `package.json` file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与`fs`和`readline`一样，`http`内置在Node中，所以我们不必使用`npm install`来获取它。相反，这将直接使用。在你的`package.json`文件中添加一个启动脚本：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then fire it up!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后启动它！
- en: '![](assets/080f19a7-30c4-4f87-b7a9-7e6da46b72fb.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/080f19a7-30c4-4f87-b7a9-7e6da46b72fb.png)'
- en: Figure 11.2 - Executing npm start
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 - 执行npm start
- en: 'OK, our output isn''t super helpful, but if we read our code, we can see that
    we''ve done this: "Create an HTTP server listening on port `8080`. Send a 200
    OK message and output ''Hello, World!''". Let''s now pull up a browser and go
    to [http://localhost:8080](http://localhost:8080). We should see a simple page
    greeting us.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们的输出并不是特别有用，但是如果我们阅读我们的代码，我们可以看到我们已经做到了这一点：“创建一个监听端口`8080`的HTTP服务器。发送一个200
    OK消息并输出'Hello, World!'”。现在让我们打开浏览器并转到[http://localhost:8080](http://localhost:8080)。我们应该看到一个简单的页面向我们问候。
- en: Great! Easy enough so far. Stop your server with *Ctrl* + *C* and let's code
    some more.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！到目前为止很容易。用*Ctrl* + *C*停止你的服务器，然后让我们继续编码。
- en: What if we could use the ASCII art generator that we used in the previous example
    to ask the user for input and then display the image in the browser? Let's try
    it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够使用我们在上一个例子中使用的ASCII艺术生成器来要求用户输入，然后在浏览器中显示图像，那该多好啊？让我们试试看。
- en: 'First, we need to run `npm install asciify-image`, and then let''s try this
    code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要运行`npm install asciify-image`，然后让我们尝试这段代码：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It''s similar to what we did previously to output to the command line, but
    we''re using the `http` server `res` object to send a reply. Start your server
    with `npm start` and let''s see what we get:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前输出到命令行的方式类似，但是我们使用`http`服务器`res`对象来发送一个回复。用`npm start`启动你的服务器，让我们看看我们得到了什么：
- en: '![](assets/f58391fa-224c-4ea7-9119-01b6d66894ee.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f58391fa-224c-4ea7-9119-01b6d66894ee.png)'
- en: Figure 11.3 - Raw output
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 - 原始输出
- en: 'OK, that''s not even close to what we wanted to see. Here''s the rub: what
    we sent to the browser was *ANSI-encoded text*, not actual HTML. We''ll have to
    do a little work to convert it. Quit the server again and…'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这与我们想要看到的完全不一样。这就是问题所在：我们发送给浏览器的是*ANSI编码的文本*，而不是实际的HTML。我们需要做一些工作来转换它。再次退出服务器然后…
- en: 'One moment. Why do we have to keep starting and stopping the server? It turns
    out we *don''t* *really* have to. There are tools to reload our server when the
    file changes. Let''s install one called **supervisor**:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下。为什么我们必须不断地启动和停止服务器？事实证明，我们*不* *真的*必须这样做。有一些工具可以在文件更改时重新加载我们的服务器。让我们安装一个叫做**supervisor**的工具：
- en: '`npm install supervisor`'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`npm install supervisor`'
- en: Modify your `package.json` start script to read `supervisor index.js`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的`package.json`启动脚本以读取`supervisor index.js`。
- en: Now start your server with `npm start` and, as you code, the server will restart
    itself upon saving, making development much faster.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用`npm start`启动服务器，当你编码时，服务器将在保存后重新启动，使开发速度更快。
- en: 'Back to the code. What we''re going to need is a package to convert ANSI to
    HTML. Install `ansi-to-html` with `npm install` and let''s get going:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 回到代码。我们需要一个将ANSI转换为HTML的包。使用`npm install`安装`ansi-to-html`，然后让我们开始：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you refresh the browser, you'll see that we're getting closer!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果刷新浏览器，你会看到我们离成功更近了！
- en: '![](assets/de16bcff-7512-4268-8e40-11e230153d8e.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/de16bcff-7512-4268-8e40-11e230153d8e.png)'
- en: Figure 11.4 - It's HTML!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 - 这是HTML！
- en: 'Now we really just need a little CSS:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要一点CSS：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add that in our `index.js` and concatenate it to the output, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将其添加到我们的`index.js`中，并连接到输出，如下所示：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now refresh and we should see our image!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在刷新，我们应该能看到我们的图片！
- en: '![](assets/6ca08eed-b3e4-4b0e-8305-121ad05fde11.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6ca08eed-b3e4-4b0e-8305-121ad05fde11.png)'
- en: Figure 11.5 - ANSI to HTML
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 - ANSI转HTML
- en: Fantastic! It's a little more exciting than just printing out "Hello, World!",
    don't you think?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！比只打印“Hello, World!”要令人兴奋多了，你不觉得吗？
- en: Let's build on our Node.js skills by revisiting our Pokémon game from [Chapter
    7](72ec1a13-fd17-4319-8693-8afa18746a72.xhtml), *Events, Event-Driven Design,
    and APIs*, but this time, in Node.js.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过重新访问我们在[第7章](72ec1a13-fd17-4319-8693-8afa18746a72.xhtml)中的宝可梦游戏来增强我们的Node.js技能，*事件，事件驱动设计和API*，但这次是在Node.js中。
- en: Pokéapi, revisited
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pokéapi，重访
- en: We're going to make a little terminal **command-line interface** (**CLI**) game
    using the Pokéapi ([https://pokeapi.co](https://pokeapi.co)). Since we have the
    basic logic of the game at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/pokeapi/solution-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/pokeapi/solution-code),
    we're just going to get the beginnings going and then you can finish the game
    as a challenge by porting over the logic from the frontend to the backend with
    Node.js.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Pokéapi ([https://pokeapi.co](https://pokeapi.co)) 制作一个小型终端**命令行界面**（**CLI**）游戏。由于我们在[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/pokeapi/solution-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/pokeapi/solution-code)中有游戏的基本逻辑，我们只需要开始并将游戏逻辑从前端移植到后端的Node.js中完成游戏。
- en: 'Start with a fresh directory and begin a new project, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始一个新项目，如下所示：
- en: '`mkdir pokecli`'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mkdir pokecli`'
- en: '`npm init`'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`npm init`'
- en: '`npm install asciify-image axios terminal-kit`'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`npm install asciify-image axios terminal-kit`'
- en: Copy the Pokéapi logo from [https://pokeapi.co](https://pokeapi.co) to a new
    `img` directory with Save Image in the browser.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://pokeapi.co](https://pokeapi.co)复制Pokéapi标志到一个新的`img`目录，使用浏览器中的Save
    Image。
- en: Make a new `index.js` file.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`index.js`文件。
- en: 'Modify `package.json` with a start script, as we''ve done previously: `"start":
    "node index.js"`.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '修改`package.json`，添加一个启动脚本，如下所示：`"start": "node index.js"`。'
- en: 'Your file structure should look like this, minus the `node_modules` directory:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你的文件结构应该是这样的，减去`node_modules`目录：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s begin working on our `index.js`. First off, we need to include the packages
    we''re using:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始在我们的`index.js`上工作。首先，我们需要包括我们正在使用的包：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, since we''re going to use the API to retrieve and store our Pokémon,
    let''s create a new object to store them at the top level so that we''ll have
    access to them:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，由于我们将使用API来检索和存储我们的宝可梦，让我们创建一个新对象将它们存储在顶层，这样我们就可以访问它们：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we''re going to work with Terminal Kit ([https://www.npmjs.com/package/terminal-kit](https://www.npmjs.com/package/terminal-kit))
    to create a better CLI experience than the standard `console.log` output and `readline`
    input:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用Terminal Kit ([https://www.npmjs.com/package/terminal-kit](https://www.npmjs.com/package/terminal-kit))
    来创建一个比标准的`console.log`输出和`readline`输入更好的CLI体验：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What we're doing here is first creating a terminate function that will exit
    our Node.js program after stopping `term` from capturing input, for cleanup purposes.
    The next method specifies that when we hit *Ctrl* + *C*, the program will call
    the `terminate()` function to exit. *This is an important part of our program,
    as `term` does not exit with Ctrl + C* *by default.* Lastly, we tell `term` to
    capture input.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的第一件事是创建一个终止函数，它将在停止`term`捕获输入后退出我们的Node.js程序，以进行清理。下一个方法指定当我们按下*Ctrl*
    + *C*时，程序将调用`terminate()`函数退出。*这是我们程序的一个重要部分，因为`term`默认情况下不会在按下Ctrl + C时退出。*最后，我们告诉`term`捕获输入。
- en: 'To start our game, begin with a splash screen of the Pokéapi logo:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 开始我们的游戏，从Pokéapi标志的闪屏开始：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can do this directly using `term` instead of the `asciify-image` library
    (don''t worry, we''ll use that later):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接使用`term`而不是`asciify-image`库（不用担心，我们以后会用到）：
- en: '![](assets/c7fb371b-261a-4275-bb5f-30662794ae8f.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c7fb371b-261a-4275-bb5f-30662794ae8f.png)'
- en: Figure 11.6 - Pokéapi splash screen
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 - Pokéapi闪屏
- en: 'Next, write a function to retrieve information from the API using the Axios
    Ajax library:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编写一个函数，使用Axios Ajax库从API中检索信息：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Axios ([https://www.npmjs.com/package/axios](https://www.npmjs.com/package/axios))
    is a package to make requests easier than `fetch` by reducing the number of promises
    required. As we saw in previous chapters, `fetch` is powerful, but does require
    a bit of chaining of promise resolutions to operate. This time, let's use Axios.
    Note that the function is an `async` function, as it'll return a promise.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Axios ([https://www.npmjs.com/package/axios](https://www.npmjs.com/package/axios))
    是一个使请求比`fetch`更容易的包，通过减少所需的promise数量。正如我们在之前的章节中看到的，`fetch`很强大，但确实需要一些promise解析的链接。这次，让我们使用Axios。请注意，该函数是一个`async`函数，因为它将返回一个promise。
- en: 'Start our game with a `start()` function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 用`start()`函数开始我们的游戏：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We'll keep it simple. Note that this function also uses the async/await pattern
    and calls our function, which uses the API to retrieve a list of Pokémon. At this
    point, it would be a good idea to test our program by using `console.log()` to
    output the value of `pokemon`. You'll need to invoke the `start()` function in
    your program. You should see nice JSON data of 50 Pokémon.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持简单。请注意，此函数还使用了async/await模式，并调用我们的函数，该函数使用API检索宝可梦列表。此时，通过使用`console.log()`输出`pokemon`的值来测试我们的程序是一个好主意。您需要在程序中调用`start()`函数。您应该看到50只宝可梦的漂亮JSON数据。
- en: 'In our `start()` function, we''ll ask the player to choose their Pokémon with
    a message:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`start()`函数中，我们将要求玩家选择他们的宝可梦并显示消息：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we''ll use our `pokemon` variable to create a grid menu with `term` to
    ask our player which Pokémon they''d like, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用我们的`pokemon`变量使用`term`创建一个网格菜单，询问我们的玩家他们想要哪个宝可梦，如下所示：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can read the documentation on `term` to see more about what the options
    are for grid menus. We should run our code now, so in order to do that, add an
    invocation to the `start()` function at the end of the program:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以阅读`term`的文档，了解有关网格菜单的选项更多的信息。现在我们应该运行我们的代码，为了做到这一点，在程序的末尾添加对`start()`函数的调用：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we run our code with `npm start`, we''ll see this new addition:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用`npm start`运行我们的代码，我们将看到这个新的添加：
- en: '![](assets/b8ce5459-6acd-49ca-b053-4544769c5316.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b8ce5459-6acd-49ca-b053-4544769c5316.png)'
- en: Figure 11.7 - Menu
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 - 菜单
- en: 'With the arrow keys, we can navigate around the grid and choose our Pokémon
    by hitting *Enter*. In our code, we''re assigning to our `pokes` object''s two
    entries: `player` and `computer`. Now, `computer` will be a randomly selected
    entry from our `pokemon` variable.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过箭头键，我们可以在网格周围导航，并通过按*Enter*来选择我们的宝可梦。在我们的代码中，我们正在为我们的`pokes`对象的两个条目分配值：`player`和`computer`。现在，`computer`将是从我们的`pokemon`变量中随机选择的条目。
- en: 'We''ll need more than the name and URL of our Pokémon to play, so we''re going
    to make a helper function. Add this to our `start` function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更多的信息来玩我们的宝可梦，所以我们将创建一个辅助函数。将其添加到我们的`start`函数中：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we''ll write the `createPokemon` function like so:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写`createPokemon`函数如下：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let's unpack what this function is doing. First, we're going to get the information
    about our Pokémon (once for the player and once for the computer) from the API.
    The Pokémon moves section is a little more complicated, due to the fact that the
    gameplay is complex. For our purposes, we're simply going to assign the first
    two moves possible for our Pokémon in our `pokes` object.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下这个函数在做什么。首先，我们将从API中获取有关我们的宝可梦的信息（一次为玩家，一次为计算机）。由于游戏玩法复杂，宝可梦的移动部分有点复杂。对于我们的目的，我们将简单地为我们的宝可梦在`pokes`对象中分配前两个可能的移动。
- en: 'For the image, we''re using a small helper function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图像，我们使用了一个小的辅助函数：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''re almost done with the beginnings of our game! We need to add a few lines
    to our `gridMenu` method in `start`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了我们游戏的开始部分！我们需要在`start`中的`gridMenu`方法中添加几行：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now we can play!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以玩了！
- en: '![](assets/dfe94d19-f122-47cf-8d43-a51ccd88f404.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dfe94d19-f122-47cf-8d43-a51ccd88f404.png)'
- en: Figure 11.8 - Introducing your Pokémon!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 - 介绍你的宝可梦！
- en: 'The program continues with the computer''s choice of Pokémon:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 程序继续进行计算机选择宝可梦：
- en: '![](assets/602352a9-38c0-457e-b178-03b787b84a97.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/602352a9-38c0-457e-b178-03b787b84a97.png)'
- en: Figure 11.9 - The scary enemy Pokémon
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 - 可怕的敌人宝可梦
- en: For right now, we haven't included any actual gameplay using the moves and hitpoints.
    That can be a challenge for you to complete the `play()` function based on the
    logic from [Chapter 7](72ec1a13-fd17-4319-8693-8afa18746a72.xhtml),* Events, Event-Driven
    Design, and API**s*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们还没有包括使用移动和生命值进行实际游戏。这可以成为您根据[第7章](72ec1a13-fd17-4319-8693-8afa18746a72.xhtml)*事件、事件驱动设计和API**s*的逻辑来完成`play()`函数的挑战。
- en: 'The full code is here: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-11/pokecli](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-11/pokecli).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码在这里：[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-11/pokecli](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-11/pokecli)。
- en: Congratulations! We've done way more than "Hello, World!".
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们做得比“Hello, World!”要多得多。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've learned in this chapter that Node.js is a full-fledged programming language,
    capable of doing pretty much anything backend-related. We'll get into databases
    with Node.js in [Chapter 18](b36b27d1-f6cf-4382-ac73-f21a1aeabd3d.xhtml)*, Node.js
    and MongoDB*, but, for the meantime, we can rest assured that it can do what we'd
    expect from a modern programming language.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中学到，Node.js是一种完整的编程语言，能够做几乎所有与后端相关的事情。我们将在[第18章](b36b27d1-f6cf-4382-ac73-f21a1aeabd3d.xhtml)*，Node.js和MongoDB*中使用Node.js进行数据库操作，但是目前，我们可以放心地说它可以做现代编程语言所期望的事情。
- en: The great thing about Node.js is that its grammar and structure *is* regular
    JavaScript! A few of the terms are different, but all in all, if you can read
    and write JavaScript, you can read and write Node.js. As with every language,
    there are differences in terminology and usage, but the fact is that Node.js and
    JavaScript are the same language!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的好处在于它的语法和结构*是*普通的JavaScript！一些术语不同，但总的来说，如果你能读写JavaScript，你就能读写Node.js。就像每种语言一样，术语和用法上有差异，但事实是Node.js和JavaScript是同一种语言！
- en: In the next chapter, we'll discuss Node.js and Python and where certain choices
    make sense for using one versus the other.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Node.js和Python以及在何种情况下使用其中之一是有意义的。
- en: Further reading
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, you can refer to the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，您可以参考以下内容：
- en: 'libuv: [https://en.wikipedia.org/wiki/Libuv](https://en.wikipedia.org/wiki/Libuv)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libuv：[https://en.wikipedia.org/wiki/Libuv](https://en.wikipedia.org/wiki/Libuv)
- en: 'Market Share and Web Usage Statistics: [https://www.similartech.com/technologies/nodejs](https://www.similartech.com/technologies/nodejs)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 市场份额和Web使用统计：[https://www.similartech.com/technologies/nodejs](https://www.similartech.com/technologies/nodejs)
