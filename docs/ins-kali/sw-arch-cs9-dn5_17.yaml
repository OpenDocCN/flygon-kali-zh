- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Best Practices in Coding C# 9
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 9的最佳编码实践
- en: When you act as a software architect on a project, it is your responsibility
    to define and/or maintain a coding standard that will direct the team to program
    according to the expectations of the company. This chapter covers some of the
    best practices in coding that will help developers like you program safe, simple,
    and maintainable software. It also includes tips and tricks for coding in C#.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在项目中担任软件架构师时，你有责任定义和/或维护一个编码标准，指导团队按照公司的期望进行编程。本章涵盖了一些编码的最佳实践，将帮助像你这样的开发人员编写安全、简单和可维护的软件。它还包括了在C#中编码的技巧和窍门。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How the complexity of your code can affect performance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的代码复杂性如何影响性能
- en: The importance of using a version control system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用版本控制系统的重要性
- en: Writing safe code in C#
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C#中编写安全代码
- en: .NET core tips and tricks for coding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码的.NET核心技巧和窍门
- en: Book use case – DOs and DON'Ts in writing code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书中用例-编写代码的Dos和Don'ts
- en: C# 9 was launched together with .NET 5\. However, the practices presented here
    can be used in many versions of .NET, but they refer to the basics of programming
    C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: C# 9与.NET 5一起推出。然而，这里介绍的实践可以在许多版本的.NET中使用，但它们涉及C#编程的基础。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the Visual Studio 2019 free Community Edition or better
    with all database tools installed. You will find the sample code for this chapter
    at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要使用Visual Studio 2019免费的社区版或更高版本，并安装所有数据库工具。你可以在[https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5)找到本章的示例代码。
- en: The more complex your code, the worse a programmer you are
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的代码越复杂，你就是一个越糟糕的程序员
- en: For many people, a good programmer is one who writes complex code. However,
    the evolution of maturity in software development means there is a different way
    of thinking about it. Complexity does not mean a good job; it means poor code
    quality. Some incredible scientists and researchers have confirmed this theory
    and emphasize that professional code needs to be focused on time, high quality,
    and within budget.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多人来说，一个优秀的程序员是那种编写复杂代码的人。然而，软件开发成熟度的演变意味着有一种不同的思考方式。复杂性并不意味着工作做得好；它意味着代码质量差。一些令人难以置信的科学家和研究人员已经证实了这一理论，并强调专业代码需要专注于时间、高质量和预算内完成。
- en: Even when you have a complex scenario on your hands, if you reduce ambiguities
    and clarify the process of what you are coding, especially using good names for
    methods and variables, and respecting SOLID principles, you will turn complexity
    into simple code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你手头上有一个复杂的情景，如果你减少模糊不清的地方并澄清你编写的过程，特别是使用良好的方法和变量名称，并遵守SOLID原则，你将把复杂性转化为简单的代码。
- en: So, if you want to write good code, you need to keep the focus on how to do
    it, considering you are not the only one who will read it later. This is a good
    tip that changes the way you write code. This is how we will discuss each point
    of this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想编写优秀的代码，你需要专注于如何做到这一点，考虑到你不是唯一一个以后会阅读它的人。这是一个改变你编写代码方式的好建议。这就是我们将讨论本章的每个要点的方式。
- en: 'If your understanding of the importance of writing good code is aligned to
    the idea of simplicity and clarity while writing it, you should look at the Visual
    Studio tool **Code Metrics**:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对编写优秀代码的重要性的理解与在编写代码时的简单和清晰的想法一致，你应该看一下Visual Studio工具**代码度量**：
- en: '![](img/B16756_17_01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_17_01.png)'
- en: 'Figure 17.1: Calculating code metrics in Visual Studio'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1：在Visual Studio中计算代码度量
- en: 'The **Code Metrics** tool will deliver metrics that will give you insights
    regarding the quality of the software you are delivering. The metrics that the
    tool provides can be found at this link: [https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019).
    The following subsections are focused on describing how they are useful in some
    real-life scenarios.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码度量**工具将提供度量标准，让你了解你正在交付的软件的质量。该工具提供的度量标准可以在此链接找到：[https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019)。以下小节重点描述了它们在一些实际场景中的用途。'
- en: Maintainability index
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可维护性指数
- en: This index indicates how easy it is to maintain the code – the easier the code,
    the higher the index (limited to 100). Easy maintenance is one of the key points
    to keep software in good health. It is obvious that any software will require
    changes in the future, since change is inevitable. For this reason, consider refactoring
    your code if you have low levels of maintainability. Writing classes and methods
    dedicated to a single responsibility, avoiding duplicate code, and limiting the
    number of lines of code of each method are examples of how you can improve the
    maintainability index.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指数表示维护代码的难易程度-代码越容易，指数越高（限制为100）。易于维护是保持软件健康的关键点之一。显然，任何软件都将需要未来的更改，因为变化是不可避免的。因此，如果你的可维护性水平低，考虑重构你的代码。编写专门负责单一职责的类和方法，避免重复代码，限制每个方法的代码行数是你可以提高可维护性指数的例子。
- en: Cyclomatic complexity
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 圈复杂度
- en: 'The author of *Cyclomatic Complexity Metric* is Thomas J. McCabe. He defines
    the complexity of a software function according to the number of code paths available
    (graph nodes). The more paths you have, the more complex your function is. McCabe
    considers that each function must have a complexity score of less than 10\. That
    means that, if the code has more complex methods, you must refactor it, transforming
    parts of these codes into separate methods. There are some real scenarios where
    this behavior is easily detected:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 《圈复杂度指标》的作者是Thomas J. McCabe。他根据软件函数可用的代码路径数量（图节点）来定义函数的复杂性。路径越多，函数就越复杂。McCabe认为每个函数的复杂度得分必须小于10。这意味着，如果代码有更复杂的方法，您必须对其进行重构，将这些代码的部分转换为单独的方法。有一些真实的场景可以很容易地检测到这种行为：
- en: Loops inside loops
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环内的循环
- en: Lots of consecutive `if-else`
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大量连续的`if-else`
- en: '`switch` with code processing for each `case` inside the same method'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一个方法中处理每个`case`的`switch`
- en: 'For instance, look at the first version of this method for processing different
    responses of a credit card transaction. As you can see, the cyclomatic complexity
    is bigger than the number considered by McCabe as a basis. The reason why this
    happens is because of the number of `if-else` inside each case of the main `switch`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看一下处理信用卡交易的不同响应的此方法的第一个版本。正如您所看到的，圈复杂度大于McCabe所考虑的基数。这种情况发生的原因是主`switch`的每个`case`内部的`if-else`的数量：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you calculate the code metrics of this code, you will find a bad result
    when it comes to cyclomatic complexity, as you can see in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计算此代码的代码指标，您将发现在圈复杂度方面的结果很糟糕，正如以下屏幕截图所示：
- en: '![](img/B16756_17_02.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_17_02.png)'
- en: 'Figure 17.2: High level of cyclomatic complexity'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2：高圈复杂度
- en: 'The code itself makes no sense, but the point here is to show you the number
    of improvements that can be made with a view to writing better code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 代码本身没有意义，但这里的重点是向您展示可以通过编写更好的代码来进行多少改进：
- en: The options from `switch-case` could be written using `Enum`
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch-case`中的选项可以使用`Enum`来编写'
- en: Each `case` processing can be done in a specific method
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个`case`处理可以在一个特定的方法中完成
- en: '`switch-case` can be substituted with `Dictionary<Enum, Method>`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch-case`可以用`Dictionary<Enum, Method>`来替换'
- en: 'By refactoring this code with the preceding techniques, the result is a piece
    of code that is much easier to understand, as you can see in the following code
    snippet of its main method:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用前述技术重构此代码，结果是一段更容易理解的代码，如下面的主方法的代码片段所示：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The full code can be found on the GitHub repository of this chapter and demonstrates
    how lower-complexity code can be achieved. The following screenshot shows these
    results according to code metrics:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在本章的GitHub存储库中找到，并演示了如何实现更低复杂度的代码。以下屏幕截图显示了这些结果，根据代码指标：
- en: '![](img/B16756_17_03.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_17_03.png)'
- en: 'Figure 17.3: Cyclomatic complexity reduction after refactoring'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.3：重构后的圈复杂度减少
- en: As you can see in the preceding screenshot, there is a considerable reduction
    in complexity after refactoring. In *Chapter 13*, *Implementing Code Reusability
    in C# 9*, we discussed the importance of refactoring for code reuse. The reason
    why we are doing this here is the same – we want to eliminate duplication.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的屏幕截图中所看到的，重构后复杂性大大减少。在第13章《在C# 9中实现代码重用性》中，我们讨论了重构对于代码重用的重要性。我们在这里做这个的原因是一样的-我们想要消除重复。
- en: The key point here is that with the techniques applied, the understanding of
    the code increased and the complexity decreased, proving the importance of cyclomatic
    complexity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点在于，通过应用这些技术，代码的理解增加了，复杂性减少了，证明了圈复杂度的重要性。
- en: Depth of inheritance
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承深度
- en: 'This metric represents the number of classes connected to the one that is being
    analyzed. The more classes you have inherited, the worse the metric will be. This
    is like class coupling and indicates how difficult it is to change your code.
    For instance, the following screenshot has four inherited classes:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指标代表了与正在分析的类连接的类的数量。您继承的类越多，指标就会越糟。这就像类耦合一样，表明了更改代码有多困难。例如，以下屏幕截图中有四个继承类：
- en: '![](img/B16756_17_04.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_17_04.png)'
- en: 'Figure 17.4: Depth of inheritance sample'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.4：继承深度示例
- en: 'You can see in the following screenshot that the deeper class has the worse
    metric, considering there are three other classes that can change its behavior:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下屏幕截图中看到，更深的类具有更糟糕的指标，因为有三个其他类可以更改其行为：
- en: '![](img/B16756_17_05.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_17_05.png)'
- en: 'Figure 17.5: Depth of inheritance metric'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.5：继承深度指标
- en: Inheritance is one of the basic object-oriented analysis principles. However,
    it can sometimes be bad for your code in that it can cause dependencies. So, if
    it makes sense to do so, instead of using inheritance, consider using composition.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是基本的面向对象分析原则之一。然而，它有时可能对您的代码不利，因为它可能导致依赖性。因此，如果有意义的话，考虑使用组合而不是继承。
- en: Class coupling
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类耦合
- en: 'When you connect too many classes in a single class, obviously you will get
    coupling, and this can cause bad maintenance of your code. For instance, refer
    to the following screenshot. It shows a design where aggregation has been performed
    a lot. There is no sense to the code itself:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在一个类中连接太多类时，显然会产生耦合，这可能会导致代码维护不良。例如，参考以下屏幕截图。它显示了一个已经执行了大量聚合的设计。代码本身没有意义：
- en: '![](img/B16756_17_06.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_17_06.png)'
- en: 'Figure 17.6: Class coupling sample'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.6：类耦合示例
- en: 'Once you have calculated the code metrics for the preceding design, you will
    see that the number of class coupling instances for the `ProcessData()` method,
    which calls `ExecuteTypeA()`, `ExecuteTypeB()`, and `ExecuteTypeC()`, equals three
    (`3`):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您计算了前述设计的代码指标，您将看到`ProcessData()`方法的类耦合实例数，该方法调用`ExecuteTypeA()`、`ExecuteTypeB()`和`ExecuteTypeC()`，等于三（`3`）：
- en: '![](img/B16756_17_07.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_17_07.png)'
- en: 'Figure 17.7: Class coupling metric'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.7：类耦合度指标
- en: 'Some papers indicate that the maximum number of class coupling instances should
    be nine (`9`). With aggregation being a better practice than inheritance, the
    use of interfaces will solve class coupling problems. For instance, the same code
    with the following design will give you a better result:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一些论文指出，类耦合实例的最大数量应为九（`9`）。聚合比继承更好的实践，使用接口将解决类耦合问题。例如，相同的代码在以下设计中将给出更好的结果：
- en: '![](img/B16756_17_08.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_17_08.png)'
- en: 'Figure 17.8: Reducing class coupling'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.8：减少类耦合
- en: 'Notice that using the interface in the design will allow you the possibility
    of increasing the number of execution types without increasing the class coupling
    of the solution:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在设计中使用接口将允许您增加执行类型的数量，而不增加解决方案的类耦合度：
- en: '![](img/B16756_17_09.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_17_09.png)'
- en: 'Figure 17.9: Class coupling results after applying aggregations'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.9：应用聚合后的类耦合结果
- en: As a software architect, you must consider designing your solution to have more
    cohesion than coupling. The literature indicates that good software has low coupling
    and high cohesion. In software development, high cohesion indicates a scenario
    where you should have a software in which each class must have its methods and
    data with good relationships between them. On the other hand, low coupling indicates
    software where the classes are not closely and directly connected. This is a basic
    principle that can guide you to a better architectural model.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，您必须考虑设计您的解决方案具有更多的内聚性而不是耦合性。文献表明，良好的软件具有低耦合和高内聚。在软件开发中，高内聚表示一个场景，其中每个类必须具有其方法和数据，并且它们之间有良好的关系。另一方面，低耦合表示软件中的类不是紧密和直接连接的。这是一个基本原则，可以指导您获得更好的架构模型。
- en: Lines of code
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码行数
- en: This metric is useful in terms of making you understand the size of the code
    you are dealing with. There is no way to connect lines of code and complexity
    since the number of lines is not indicative of that. On the other hand, the lines
    of code show the software size and software design. For instance, if you have
    too many lines of code in a single class (more than 1,000 lines of code – 1KLOC),
    this indicates that it is a bad design.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指标在让您了解您正在处理的代码规模方面是有用的。代码行数和复杂性之间没有联系，因为行数并不表示复杂性。另一方面，代码行数显示了软件的规模和软件设计。例如，如果一个类中有太多的代码行数（超过1000行代码-1KLOC），这表明它是一个糟糕的设计。
- en: Using a version control system
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用版本控制系统
- en: You may find this topic in this book a bit obvious, but many people and companies
    still do not regard having a version control system as a basic tool for software
    development! The idea of writing about it is to force you to understand it. There
    is no architectural model or best practice that can save software development
    if you do not use a version control system.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得这本书中的这个主题有点显而易见，但许多人和公司仍然不将拥有版本控制系统视为软件开发的基本工具！写这个主题的想法是强迫你去理解它。如果你不使用版本控制系统，没有任何架构模型或最佳实践可以拯救软件开发。
- en: In the last few years, we have been enjoying the advantages of online version
    control systems, such as GitHub, BitBucket, and Azure DevOps. The fact is, you
    must have a tool like that in your software development life cycle and there is
    no reason to not have it anymore since most providers offer free versions for
    small groups. Even if you develop by yourself, these tools are useful for tracking
    your changes, managing your software versions, and guaranteeing the consistency
    and integrity of your code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，我们一直在享受在线版本控制系统的优势，比如GitHub、BitBucket和Azure DevOps。事实上，您必须在软件开发生命周期中拥有这样的工具，而且现在没有理由不拥有它，因为大多数提供商为小团队提供免费版本。即使您是独自开发，这些工具也可以用于跟踪您的更改，管理您的软件版本，并保证代码的一致性和完整性。
- en: Dealing with version control systems in teams
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 团队中处理版本控制系统
- en: The use of a version control system tool when you are alone is obvious. You
    want to keep your code safe. But this kind of system was developed to solve team
    problems while writing code. For this reason, some features, such as branching
    and merging, were introduced to keep code integrity even in scenarios where the
    number of developers is quite large.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你独自一人时使用版本控制系统工具是显而易见的。你想保护你的代码。但这种系统是为了解决编写代码时的团队问题而开发的。因此，一些功能，比如分支和合并，被引入以保持代码的完整性，即使在开发人员数量相当大的情况下也是如此。
- en: As a software architect, you will have to decide which branch strategy you will
    conduct in your team. Azure DevOps and GitHub suggest different ways to deliver
    that, and both are useful in some scenarios.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，您将不得不决定在团队中进行哪种分支策略。Azure DevOps和GitHub提出了不同的交付方式，并且在某些场景中都是有用的。
- en: 'Information about how the Azure DevOps team deals with this can be found here:
    [https://devblogs.microsoft.com/devops/release-flow-how-we-do-branching-on-the-vsts-team/](https://devblogs.microsoft.com/devops/release-flow-how-we-do-branching-on-the-vsts-team/).
    GitHub describes its process at [https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/).
    We have no idea of which is the one that best fits your needs, but we do want
    you to understand that you need to have a strategy for controlling your code.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Azure DevOps团队如何处理这个问题，可以在这里找到：[https://devblogs.microsoft.com/devops/release-flow-how-we-do-branching-on-the-vsts-team/](https://devblogs.microsoft.com/devops/release-flow-how-we-do-branching-on-the-vsts-team/)。GitHub在[https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/)中描述了它的流程。我们不知道哪一个最适合您的需求，但我们希望您明白您需要有控制代码的策略。
- en: In *Chapter 20*, *Understanding DevOps Principles*, we will discuss this in
    more detail.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第20章*，*理解DevOps原则*中，我们将更详细地讨论这个问题。
- en: Writing safe code in C#
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#中编写安全的代码
- en: C# can be considered a safe programming language by design. Unless you force
    it, there is no need for pointers, and memory release is, in most cases, managed
    by the garbage collector. Even so, some care should be taken so you can get better
    and safe results from your code. Let us have a look at some common practices to
    ensure safe code in C#.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: C#可以被认为是一种安全的编程语言。除非强制使用，否则不需要指针，并且在大多数情况下，内存释放由垃圾收集器管理。即便如此，您应该小心，以便从代码中获得更好和更安全的结果。让我们看一些确保C#代码安全的常见做法。
- en: try-catch
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: try-catch
- en: 'Exceptions in coding are so frequent that you should have a way to manage them
    whenever they happen. `try-catch` statements are built to manage exceptions and
    they are important for keeping your code safe. There are a lot of cases where
    an application crashes and the reason for that is the lack of using `try-catch`.
    The following code shows an example of the lack of usage of the `try-catch` statement.
    It is worth mentioning that this is just an example for understanding the concept
    of an exception thrown without correct treatment. Consider using `int.TryParse(textToConvert,
    out int result)` to handle cases where a parse is unsuccessful:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 编码中的异常是如此频繁，以至于每当它们发生时，您都应该有一种管理它们的方式。`try-catch`语句是用于管理异常的，并且对于保持代码安全非常重要。有很多情况下，应用程序崩溃的原因是缺乏使用`try-catch`。以下代码显示了缺乏使用`try-catch`语句的示例。值得一提的是，这只是一个例子，用于理解没有正确处理的异常概念。考虑使用`int.TryParse(textToConvert,
    out int result)`来处理解析不成功的情况：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On the other hand, bad `try-catch` usage can cause damage to your code too,
    especially because you will not see the correct behavior of that code and may
    misunderstand the results provided.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，不正确使用`try-catch`也可能对您的代码造成损害，特别是因为您将看不到该代码的正确行为，并且可能会误解提供的结果。
- en: 'The following code shows an example of an empty `try-catch` statement:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了一个空的`try-catch`语句：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`try-catch` statements must always be connected to logging solutions, so that
    you can have a response from the system that will indicate the correct behavior
    and, at the same time, will not cause application crashes. The following code
    shows an ideal `try-catch` statement with logging management. It is worth mentioning
    that specific exceptions should be caught whenever possible, since catching a
    general exception will hide unexpected exceptions:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`try-catch`语句必须始终与日志记录解决方案连接，以便您可以从系统获得响应，指示正确的行为，并且不会导致应用程序崩溃。以下代码显示了具有日志管理的理想`try-catch`语句。值得一提的是，尽可能捕获特定异常，因为捕获一般异常会隐藏意外异常：'
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As a software architect, you should conduct code inspections to fix this kind
    of behavior found in the code. Instability in a system is often connected to the
    lack of `try-catch` statements in the code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，您应该进行代码检查，以修复代码中发现的这种行为。系统的不稳定性通常与代码中缺乏`try-catch`语句有关。
- en: try-finally and using
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: try-finally和using
- en: Memory leaks can be considered one of software's worst behaviors. They cause
    instability, bad usage of computer resources, and undesired application crashes.
    C# tries to solve this with Garbage Collector, which automatically releases objects
    from memory as soon as it realizes the object can be freed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏可以被认为是软件的最糟糕行为之一。它们会导致不稳定性，计算机资源的不良使用和不希望的应用程序崩溃。C#试图通过垃圾收集器解决这个问题，一旦它意识到对象可以被释放，就会自动释放内存中的对象。
- en: 'Objects that interact with I/O are the ones that generally are not managed
    by Garbage Collector: filesystem, sockets, and so on. The following code is an
    example of the incorrect usage of a `FileStream` object, because it thinks Garbage
    Collector will release the memory used, but it will not:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与I/O交互的对象通常不受垃圾收集器管理：文件系统，套接字等。以下代码是`FileStream`对象的不正确使用示例，因为它认为垃圾收集器会释放所使用的内存，但实际上不会：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Besides, it takes a while for Garbage Collector to interact with objects that
    need to be released and sometimes you may want to do it yourself. For both cases,
    the use of `try-finally` or `using` statements is the best practice:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，垃圾收集器与需要释放的对象交互需要一段时间，有时您可能希望自己执行。对于这两种情况，使用`try-finally`或`using`语句是最佳实践：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code shows exactly how to deal with objects that are not managed
    by Garbage Collector. You have both `try-finally` and `using` being implemented.
    As a software architect, you do need to pay attention to this kind of code. The
    lack of `try-finally` or `using` statements can cause huge damage to software
    behavior when it is running. It is worth mentioning that using code analysis tools
    (now distributed with .NET 5) will automatically alert you to these sorts of problems.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码准确显示了如何处理垃圾收集器未管理的对象。您同时实现了`try-finally`和`using`。作为软件架构师，您确实需要注意这种代码。缺乏`try-finally`或`using`语句可能会在运行时对软件行为造成巨大损害。值得一提的是，使用代码分析工具（现在与.NET
    5一起分发）将自动提醒您这类问题。
- en: The IDisposable interface
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDisposable接口
- en: 'In the same way that you will have trouble if you do not manage objects created
    inside a method with `try-finally`/`using` statements, objects created in a class
    that does not properly implement the `IDisposable` interface may cause memory
    leaks in your application. For this reason, when you have a class that deals with
    and creates objects, you should implement the disposable pattern to guarantee
    the release of all resources created by it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与在方法中创建的对象不使用`try-finally`/`using`语句进行管理会导致问题类似，未正确实现`IDisposable`接口的类中创建的对象可能会导致应用程序中的内存泄漏。因此，当您有一个处理和创建对象的类时，应该实现可释放模式以确保释放其创建的所有资源：
- en: '![](img/B16756_17_10.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_17_10.png)'
- en: 'Figure 17.10: IDisposable interface implementation'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.10：IDisposable接口实现
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once you have the code inserted, you need to follow the TODO instructions so
    that you have the correct pattern implemented.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 插入代码后，您需要按照TODO说明执行，以实现正确的模式。
- en: .NET 5 tips and tricks for coding
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET 5编码技巧和窍门
- en: .NET 5 implements some good features that help us to write better code. One
    of the most useful for having safer code is **dependency injection** (**DI**),
    which was already discussed in *Chapter 11*, *Design Patterns and .NET 5 Implementation*.
    There are some good reasons for considering this. The first one is that you will
    not need to worry about disposing the injected objects since you are not going
    to be the creator of them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 5实现了一些有助于我们编写更好代码的好功能。其中最有用的之一是**依赖注入**（**DI**），这已经在*第11章*，*设计模式和.NET 5实现*中讨论过。有一些很好的理由可以考虑这一点。首先，您不需要担心处理注入的对象，因为您不会是它们的创建者。
- en: 'Besides, DI enables you to inject `ILogger`, a useful tool for debugging exceptions
    that will need to be managed by `try-catch` statements in your code. Furthermore,
    programming in C# with .NET 5 must follow the common good practices of any programming
    language. The following list shows some of these:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，DI使您能够注入`ILogger`，这是一个用于调试异常的有用工具，需要在代码中通过`try-catch`语句进行管理。此外，在C#中使用.NET
    5进行编程必须遵循任何编程语言的通用最佳实践。以下列表显示了其中一些：
- en: '**Classes, methods, and variables should have understandable names**: The name
    should explain everything that the reader needs to know. There should be no need
    for an explanatory comment unless these declarations are public.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类、方法和变量应具有可理解的名称**：名称应该解释读者需要了解的一切。除非这些声明是公共的，否则不应该需要解释性注释。'
- en: '**Methods cannot have high complexity levels**: Cyclomatic complexity should
    be checked so that methods do not have too many lines of code.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法不能具有高复杂性级别**：应检查圈复杂度，以便方法不具有太多行的代码。'
- en: '**Members must have the correct visibility**: As an object-oriented programming
    language, C# enables encapsulation with different visibility keywords. C# 9.0
    is presenting *Init-only setters* so you can create `init` property/index accessors
    instead of `set`, defining these members as read-only following construction of
    the object.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成员必须具有正确的可见性**：作为面向对象的编程语言，C#允许使用不同的可见性关键字进行封装。C# 9.0正在提供*Init-only setters*，因此您可以创建`init`属性/索引访问器而不是`set`，在对象构造后将这些成员定义为只读。'
- en: '**Duplicate code should be avoided**: There is no reason for having duplicate
    code in a high-level programming language such as C#.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应避免重复的代码**：在C#等高级编程语言中没有理由存在重复的代码。'
- en: '**Objects should be checked before usage**: Since null objects can exist, the
    code must have null-type checking. It is worth mentioning that since C# 8, we
    have nullable reference types to avoid errors related to nullable objects.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在使用之前应检查对象**：由于可能存在空对象，代码必须进行空类型检查。值得一提的是，自C# 8以来，我们有可空引用类型，以避免与可空对象相关的错误。'
- en: '**Constants and enumerators should be used**: A good way of avoiding magic
    numbers and text inside code is to transform this information into constants and
    enumerators, which generally are more understandable.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应使用常量和枚举器**：避免在代码中使用魔术数字和文本的一个好方法是将这些信息转换为常量和枚举器，这通常更容易理解。'
- en: '**Unsafe code should be avoided**: Unsafe code enables you to deal with pointers
    in C#. Unless there is no other way to implement the solution, unsafe code should
    be avoided.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应避免使用不安全的代码**：不安全的代码使您能够在C#中处理指针。除非没有其他实现解决方案的方法，否则应避免使用不安全的代码。'
- en: '**try-catch statements cannot be empty**: There is no reason for a `try-catch`
    statement without treatment in the `catch` area. More than that, the caught exceptions
    should be as specific as possible, and not just an "exception," to avoid swallowing
    unexpected exceptions.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**try-catch语句不能是空的**：`try-catch`语句在`catch`区域没有处理是没有理由的。此外，捕获的异常应尽可能具体，而不仅仅是一个“异常”，以避免吞噬意外的异常。'
- en: '**Dispose of the objects that you have created, if they are disposable**: Even
    for objects where Garbage Collector will take care of the disposed-of object,
    consider disposing of objects that you were responsible for creating yourself.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理您创建的对象，如果它们是可处置的**：即使对于垃圾收集器将处理已处置对象的对象，也要考虑处理您自己负责创建的对象。'
- en: '**At least public methods should be commented**: Considering that public methods
    are the ones used outside your library, they must be explained for their correct
    external usage.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**至少应该对公共方法进行注释**：考虑到公共方法是在您的库之外使用的方法，必须对其进行解释以进行正确的外部使用。'
- en: '**switch-case statements must have a default treatment**: Since the `switch-case`
    statement may receive an entrance variable unknown in some cases, the default
    treatment will guarantee that the code will not break in such a situation.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**switch-case语句必须有默认处理**：由于`switch-case`语句可能在某些情况下接收到未知的入口变量，因此默认处理将确保在这种情况下代码不会中断。'
- en: You may refer to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-reference-types](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-reference-t)
    for more information about nullable reference types.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-reference-types](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-reference-t)获取有关可空引用类型的更多信息。
- en: As a software architect, you may consider a good practice of providing a code
    pattern for your developers that will be used to keep the style of the code consistent.
    You can also use this code pattern as a checklist for coding inspection, which
    will enrich software code quality.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，您可以考虑为开发人员提供代码模式的良好实践，以保持代码风格的一致性。您还可以将此代码模式用作编码检查的检查表，从而提高软件代码质量。
- en: WWTravelClub – DOs and DON'Ts in writing code
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WWTravelClub - 编写代码的DOs和DON'Ts
- en: As a software architect, you must define a code standard that matches the needs
    of the company you are working for.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，您必须定义符合您所工作公司需求的代码标准。
- en: In the sample project of this book (check out more about the WWTravelClub project
    in *Chapter 1*, *Understanding the Importance of Software Architecture*), this
    is no different. The way we decided to present the standard for it is by describing
    a list of DOs and DON'Ts that we followed while writing the samples we produced.
    It is worth mentioning that the list is a good way to start your standard and,
    as a software architect, you should discuss this list with the developers you
    have in the team so that you can evolve it in a practical and good manner.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的示例项目中（在*第1章*，*了解软件架构的重要性*中了解更多关于WWTravelClub项目的信息），情况并无不同。我们决定为其制定标准的方式是描述我们在编写生成的示例时遵循的DO和DON'T的列表。值得一提的是，这个列表是开始制定标准的好方法，作为软件架构师，您应该与团队中的开发人员讨论这个列表，以便以实际和良好的方式发展它。
- en: 'In addition, these statements are designed to clarify the communication between
    team members and improve the performance and maintenance of the software you are
    developing:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些语句旨在澄清团队成员之间的沟通，并改善您正在开发的软件的性能和可维护性：
- en: DO write your code in English
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用英文编写代码
- en: DO follow C# coding standards with CamelCase
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循C#编码规范，使用驼峰命名法
- en: DO write classes, methods, and variables with understandable names
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用易懂的名称编写类、方法和变量
- en: DO comment public classes, methods, and properties
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释公共类、方法和属性
- en: DO use the `using` statement whenever possible
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用`using`语句
- en: DO use `async` implementation whenever possible
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用`async`实现
- en: DON'T write empty `try-catch` statements
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要编写空的`try-catch`语句
- en: DON'T write methods with a cyclomatic complexity score of more than 10
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要编写循环复杂度得分超过10的方法
- en: DON'T use `break` and `continue` inside `for/while/do-while/foreach` statements
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在`for/while/do-while/foreach`语句中使用`break`和`continue`
- en: These DOs and DON'Ts are simple to follow and, better than that, will yield
    great results for the code your team produces. In *Chapter 19*, *Using Tools to
    Write Better Code*, we will discuss the tools to help you implement these rules.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些DO和DON'T非常简单，而且比这更好的是，将为您的团队编写的代码产生很好的结果。在*第19章*，*使用工具编写更好的代码*中，我们将讨论帮助您实施这些规则的工具。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: During this chapter, we discussed some important tips for writing safe code.
    This chapter introduced a tool for analyzing code metrics so that you can manage
    the complexity and maintainability of the software you are developing. To finish,
    we presented some good tips to guarantee that your software will not crash due
    to memory leaks and exceptions. In real life, a software architect will always
    be asked to solve this kind of problem.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了编写安全代码的一些重要提示。本章介绍了一个用于分析代码指标的工具，以便您可以管理正在开发的软件的复杂性和可维护性。最后，我们提出了一些好的建议，以确保您的软件不会因内存泄漏和异常而崩溃。在现实生活中，软件架构师总是会被要求解决这类问题。
- en: In the next chapter, we will learn about some unit testing techniques, the principles
    of unit testing, and a software process model that focuses on C# test projects.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习一些单元测试技术，单元测试的原则，以及一个专注于C#测试项目的软件过程模型。
- en: Questions
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why do we need to care about maintainability?
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为什么需要关注可维护性？
- en: What is cyclomatic complexity?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环复杂度是什么？
- en: List the advantages of using a version control system.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出使用版本控制系统的优势。
- en: What is Garbage Collector?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垃圾收集器是什么？
- en: What is the importance of implementing the `IDisposable` interface?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`IDisposable`接口的重要性是什么？
- en: What advantages do we gain from .NET 5 when it comes to coding?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编码方面，.NET 5给我们带来了哪些优势？
- en: Further reading
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'These are some books and websites where you will find more information about
    the topics of this chapter:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些书籍和网站，您可以在本章的主题中找到更多信息：
- en: '*Clean Code: A Handbook of Agile Software Craftmanship*, by Martin, Robert
    C. Pearson Education, 2012.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码整洁之道：敏捷软件工艺的手册*，作者Martin, Robert C. Pearson Education, 2012。'
- en: '*The Art of Designing Embedded Systems*, by Jack G. Ganssle. Elsevier, 1999.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*嵌入式系统设计艺术*，作者Jack G. Ganssle。Elsevier, 1999。'
- en: '*Refactoring*, by Martin Fowler. Addison-Wesley, 2018.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重构*，作者Martin Fowler。Addison-Wesley, 2018。'
- en: '*A Complexity Measure*, by Thomas J. McCabe. IEEE Trans. Software Eng. 2(4):
    308-320, 1976 ([https://dblp.uni-trier.de/db/journals/tse/tse2.html](https://dblp.uni-trier.de/db/journals/tse/tse2.html)).'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*复杂度测量*，作者Thomas J. McCabe。IEEE Trans. Software Eng. 2(4): 308-320, 1976 ([https://dblp.uni-trier.de/db/journals/tse/tse2.html](https://dblp.uni-trier.de/db/journals/tse/tse2.html))。'
- en: '[https://blogs.msdn.microsoft.com/zainnab/2011/05/25/code-metrics-class-coupling/](https://blogs.msdn.microsoft.com/zainnab/2011/05/25/code-metrics-class-coupling/)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://blogs.msdn.microsoft.com/zainnab/2011/05/25/code-metrics-class-coupling/](https://blogs.msdn.microsoft.com/zainnab/2011/05/25/code-metrics-class-coupling/)'
- en: '[https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019)'
- en: '[https://github.com/](https://github.com/)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/](https://github.com/)'
- en: '[https://bitbucket.org/](https://bitbucket.org/)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://bitbucket.org/](https://bitbucket.org/)'
- en: '[https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/)'
- en: '[https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/)'
- en: '[https://blogs.msdn.microsoft.com/devops/2018/04/19/release-flow-how-we-do-branching-on-the-vsts-team/](https://blogs.msdn.microsoft.com/devops/2018/04/19/release-flow-how-we-do-branching-on-the-vsts-team)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://blogs.msdn.microsoft.com/devops/2018/04/19/release-flow-how-we-do-branching-on-the-vsts-team/](https://blogs.msdn.microsoft.com/devops/2018/04/19/release-flow-how-we-do-branching-on-the-vsts-team)'
- en: '[https://docs.microsoft.com/aspnet/core/fundamentals/logging/](https://docs.microsoft.com/aspnet/core/fundamentals/logging/)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/aspnet/core/fundamentals/logging/](https://docs.microsoft.com/aspnet/core/fundamentals/logging/)'
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9)'
