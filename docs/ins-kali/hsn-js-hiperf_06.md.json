["```js\nimport { Worker } from 'worker_threads';\n\nconst data = {what: 'this', huh: 'yeah'};\nconst worker = new Worker('./worker.js');\nworker.postMessage(data);\nworker.on('message', (data) => {\n    worker.terminate();\n});\nworker.on('exit', (code) => {\n    console.log('our worker stopped with the following code: ', \n     code);\n});\n```", "```js\nimport { parentPort } from 'worker_threads'\n\nparentPort.on('message', (msg) => {\n    console.log('we received a message from our parent: ', msg);\n    parentPort.postMessage({RECEIVED: true});\n});\n```", "```js\n{\n    \"name\" : \"Chapter6_Local\",\n    \"version\" : \"0.0.1\",\n    \"type\" : \"module\",\n    \"main\" : \"main.js\"\n}\n```", "```js\nimport net from 'net';\nimport pipeName from './helper.js';\n\nlet count = 0;\nlet cacheTable = new Map();\n// these correspond to !!!BEGIN!!!, !!!END!!!, !!!GET!!!, and \n// !!!DELETE!!! respectively\nconst begin, end, get, del; //shortened for readability they will use the Buffer.from() methods\nlet currData = [];\n\nconst socket = new net.Socket().connect(pipeName());\nsocket.on('data', (data) => {\n    if( data.toString('utf8') === 'WHOIS' ) {\n        return socket.write('cache');\n    }\n    if( data.includes(get) ) {\n        const loc = parseInt(data.slice(get.byteLength).toString('utf8'));\n        const d = cacheTable.get(loc);\n        if( typeof d !== 'undefined' ) {\n            socket.write(begin.toString('utf8') + d + \n             end.toString('utf8'));\n        }\n    }\n    if( data.includes(del) ) {\n        if( data.byteLength === del.byteLength ) {\n            cacheTable.clear();\n        } else {\n            const loc = parseInt(data.slice(del.byteLength).toString('utf8'));\n            cacheTable.delete(loc);\n        }\n    }\n    if( data.includes(begin) ) {\n        currData.push(data.slice(begin.byteLength).toString('utf8'));\n    }\n    if( currData.length ) {\n        currData.push(data.toString('utf8'));\n    }\n    if( data.includes(end) ) {\n        currData.push(data.slice(0, data.byteLength - \n         end.byteLength).toString('utf8'));\n        cacheTable.set(count, currData.join(''));\n        currData = [];\n    }\n});\n```", "```js\nimport net from 'net'\nimport https from 'https'\nimport pipeName from './helpers.js'\n\nconst socket = new net.Socket().connect(pipeName());\nsocket.on('data', (data) => {\n    if( data.toString('utf8') === 'WHOIS' ) {\n        return socket.write('send');\n    }\n    const all = [];\n    https.get(data.toString('utf8'), (res) => {\n        res.on('data', (data) => {\n            all.push(data.toString('utf8'));\n        });\n        res.on('end', () => {\n            socket.write('!!!BEGIN!!!');\n            socket.write(all.join(''));\n            socket.write('!!!END!!!');\n        });\n    }).on('error', (err) => {\n        socket.write('!!!FALSE!!!');\n    });\n    console.log('we received data from the main application',  \n     data.toString('utf8'));\n});\n```", "```js\n// import required modules and methods\nconst table = new Map();\nlet currData = [];\n// These three items correspond to the buffers for: !!!FALSE!!!, \n// !!!BEGIN!!!, and !!!END!!! respectively\nconst failure, begin, end;\nconst methodTable = new WeakMap();\n```", "```js\n\nconst cacheHandler = function(data) {\n    if( data.includes(begin) || currData.length ) {\n        currData.push(data.toString('utf8'));\n    }\n    if( data.includes(end) ) {\n        currData.push(data.toString('utf8'));\n        const final = currData.join('');\n        console.log(final.substring(begin.byteLength, \n         final.byteLength - end.byteLength));\n        currData = [];\n    }\n}\n```", "```js\n\nconst sendHandler = function(data) {\n    if( data.equals(failure) ) { //failure }\n    if( data.includes(begin) ) { \n     currData.push(data.toString('utf8')); }\n    if( currData.length ) { currData.push(data.toString('utf8')); }\n    if( data.includes(end) ) { \n        table.get('cache').write(currData.join(''));\n        currData = [];\n    }\n}\n```", "```js\n\nconst testConnections = function() {\n    return table.size === 2;\n}\nconst setupHandler = function() {\n    table.forEach((value, key) => {\n        value.on('data', methodTable.get(value.bind(value));\n    });\n}\n```", "```js\nconst startCLIMode = function() {\n    process.stdin.on('data', function(data) {\n        const d = data.toString('utf8');\n        const instruction = d.trim().split(/\\s/ig);\n        switch(instruction[0]) {\n            case 'delete': {\n                table.get('cache').write(`!!!DELETE!!!${instruction[1] || ''}`);\n                break; }\n            case 'get': {\n                if( typeof instruction[1] === 'undefined' ) {\n                    return console.log('get needs a number \n                     associated with it!');\n                }\n                table.get('cache').write(`!!!GET!!!${instruction[1]}`);\n                break; }\n            case 'grab': {\n                table.get('send').write(instruction[1]);\n                break; }\n            case 'stop': {\n                table.forEach((value, key) => value.end());\n                process.exit();\n                break; }\n    }});\n}\n```", "```js\nconst server = net.createServer().listen(pipeName());\nserver.on('connection', (socket) => {\n    socket.once('data', (data) => {\n        const type = data.toString('utf8');\n        table.set(type, socket);\n        if( testConnections() ) {\n            setupHandlers();\n            startCLIMode();\n        }\n    });\n    socket.once('close', () => {\n        table.delete(type);\n    });\n    socket.write('WHOIS');\n});\n\nconst cache = new Worker('./cache.js');\nconst send = new Worker('./send.js');\n```", "```js\nimport cluster from 'cluster';\nimport https from 'https';\nimport http from 'http';\nimport { URL } from 'url';\n```", "```js\nconst numWorkers = 2;\nconst CACHE = 0;\nconst SEND = 1;\nconst server = '127.0.0.1';\nconst port = 3000;\n```", "```js\nif( cluster.isMaster ) {\n    // do master work\n} else {\n    // handle incoming connections\n}\n```", "```js\nlet count = 1; //where our current record is at. We start at 1\nconst cache = new Map();\nfor(let i = 0; i < numWorkers; i++ ) {\n    const worker = cluster.fork();\n    worker.on('message', (msg) => {\n        // handle incoming cache request\n    });\n}\n```", "```js\n// inside of the worker message handler\nswitch(msg.cmd) {\n    case 'STOP': {\n        process.exit();\n        break;\n    }\n    case 'DELETE': {\n        if( msg.opt != 'all' ) {\n            cache.delete(parseInt(msg.opt);\n        } else {\n            cache.clear();\n        }\n        worker.send({cmd : 'GOOD' });\n        break;\n    }\n    case 'GET': {\n        worker.send(cache.get(parseInt(msg.opt));\n        break;\n    }\n    case 'GRAB': {\n        // grab the information\n        break;\n    }\n}\n```", "```js\n// inside the GRAB case statement\nconst buf = [];\nhttps.get(msg.opt, (res) => {\n    res.on('data', (data) => {\n        buf.push(data.toString('utf8'));\n    });\n    res.on('end', () => {\n        const final = buf.join('');\n        cache.set(count, final);\n        count += 1;\n        worker.send({cmd : 'GOOD' });\n    });\n});\n```", "```js\n// inside of the else block\nhttp.Server((req, res) => {\n    const search = new URL(`${location}${req.url}`).searchParams;\n    const command = search.get('command');\n    const params = search.get('options');\n    // handle the command\n    handleCommand(res, command, params);\n}).listen(port);\n```", "```js\nconst handleCommand = function(res, command, params=null) {\n    switch(command) {\n        case 'get': {\n            process.send({cmd: 'GET', opt : params});\n            process.once('message', (msg) => {\n                res.writeHead(200, { 'Content-Type' : 'text/plain' });\n                res.end(msg);\n            });\n            break;\n        }\n    }\n}\n```", "```js\nimport dgram from 'dgram';\nimport { Socket } from 'net';\nconst multicastAddress = '239.192.0.0';\nconst sendMessageBadOutput = 'message needs to be formatted as follows: BUY|SELL <SYMBOL> <NUMBER>';\nconst recvClient = dgram.createSocket({type : 'udp4', reuseAddr: true }); //1.\nconst sendClient = new Socket().connect(3000, \"127.0.0.1\");\n// receiving client code seen below\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', (msg) => {\n    const input = msg.split(' ');\n    if( input.length !== 3 ) {\n        console.log(sendMessageBadOutput);\n        return;\n    }\n    const num = parseInt(input[2]);\n    if( num.toString() === 'NaN' ) {\n        console.log(sendMessageBadOutput);\n        return;\n    }\n    sendClient.write(msg);\n});\nsendClient.on('data', (data) => {\n    console.log(data.toString('utf8'));\n});\n```", "```js\nrecvClient.on('connect', () => {\n    console.log('client is connected to the server');\n});\nrecvClient.on('message', (msg) => {\n    console.log('client received message', msg.toString('utf8'));\n});\nrecvClient.bind(3000, () => {\n    recvClient.addMembership(multicastAddress);\n});\n```", "```js\nimport dgram from 'dgram';\nimport net from 'net';\n```", "```js\nconst multicastAddress = '239.192.0.0';\nconst badListingNumMessage = 'to list a new ticker the following format needs to be followed <SYMBOL>\n<NUMBER>';\nconst symbolTable = new Map();\nconst clientTable = new Map();\n```", "```js\nconst server = dgram.createSocket({type : 'udp4', reuseAddr : true}).bind(3000);\nconst recvServer = net.createServer().listen(3000, '127.0.0.1');\n```", "```js\nrecvServer.on('connection', (socket) => {\n    const temp = new Map();\n    clientTable.set(socket, temp);\n});\n```", "```js\n// inside of the connection callback for recvServer\nsocket.on('data', (msg) => {\n    const input = msg.toString('utf8').split(' ');\n    const buyOrSell = input[0];\n    const tickerSymbol = input[1];\n    const num = parseInt(input[2]);\n});\n```", "```js\n// inside the socket 'data' handler\nconst numHeld = symbolTable.get(input[1]);\nif( buyOrSell === \"BUY\" && (num <= 0 || numHeld - num <= 0) ) {\n    socket.write(\"ERROR!\");\n    return;\n} \nconst clientBook = clientTable.get(socket);\nconst clientAmount = clientBook.get(tickerSymbol);\nif( buyOrSell === \"SELL\" && clientAmount - num < 0 ) {\n    socket.write(\"ERROR!\");\n    return;\n}\nif( buyOrSell === \"BUY\" ) {\n    clientBook.set(tickerSymbol, clientAmount + num);\n    symbolTable.set(tickerSymbol, numHeld - num);\n} else if( buyOrSell === \"SELL\" ) {\n    clientBook.set(tickerSymbol, clientAmount - num);\n    symbolTable.set(tickerSymbol, numHeld + num);\n}\nsocket.write(`successfully processed request. You now hold ${clientBook.get(tickerSymbol)}` of ${tickerSymbol}`);\n```", "```js\n// after the socket.write from above\nconst msg = Buffer.from(`${tickerSymbol} ${symbolTable.get(tickerSymbol)}`);\nserver.send(msg, 0, msg.byteLength, 3000, multicastAddress);\n```", "```js\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', (data) => {\n    const input = data.split(' ');\n    const num = parseInt(input[1]);\n    symbolTable.set(input[0], num);\n    for(const client of clientTable) {\n        client[1].set(input[0], 0);\n    }\n\n    server.send(Buffer.from(data), 0, data.length, 3000, multicastAddress);\n});\n```", "```js\nimport http2 from 'http2';\nimport fs from 'fs';\nconst server = http2.createSecureServer({\n    key : fs.readFileSync('server.key.pem'),\n    cert : fs.readFileSync('server.crt.pem')\n});\nserver.on('error', (err) => console.error(err));\nserver.on('stream', (stream, headers) => {\n    stream.respond({\n        'content-type': 'text/plain',\n        ':status' : 200\n    });\n    stream.end('Hello from Http2 server');\n});\nserver.listen(8081, '127.0.0.1');\n```", "```js\n> openssl req -x509 -newkey rsa:4096 -keyout server.key.pem -out server.crt.pem -days 365\n```", "```js\nimport http2 from 'http2';\nimport fs from 'fs';\nimport path from 'path';\n\nconst basePath = process.env.npm_package_config_static; //1.\nconst supportedTypes = new Set(['.ico', '.html', '.css', '.js']);\nconst server = http2.createSecureServer({\n    key : fs.readFileSync(process.env.npm_package_config_key),\n    cert : fs.readFileSync(process.env.npm_package_config_cert),\n    allowHTTP1 : true //2.\n});\nserver.on('error', (err) => console.error(err));\nserver.on('stream', (stream, header) => {\n    const fileLoc = header[':path'];\n    const extension = path.extname(fileLoc); //3.\n    if(!supportedTypes.has(extension)) {\n        stream.respond({\n            ':status' : 400,\n            'content-type' : 'application/json'\n        });\n        stream.end(JSON.stringify({\n            error : 'unsupported data type!',\n            extension\n        }));\n        return;\n    }\n    stream.respondWithFile( //4.\n        path.join(process.cwd(), basePath, fileLoc),\n        {\n            ':status' : 200,\n            'content-type' :\n                extension === \".html\" ?\n                'text/html' :\n                extension === \".css\" ?\n                'text/css' :\n                'text/javascript'\n        },\n        {\n            onError : (err) => { //5.\n                if( err.code === 'ENOENT') {\n                    stream.respond({ ':status' : 404 });\n                } else {\n                    stream.respond({ ':status' : 500 });\n                }\n                stream.end();\n            }\n        }\n    )\n});\nserver.listen(80, '127.0.0.1');\n```", "```js\nimport quic from 'node-quic'\n\nconst port = 3000;\nconst address = '127.0.0.1';\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', (data) => {\n    quic.send(port, address, data.trim())\n        .onData((data) => {\n            console.log('we received the following back: ', data);\n        });\n});\n```", "```js\nimport quic from 'node-quic'\n\nconst port = 3000;\nconst address = '127.0.0.1';\nquic.listen(port, address)\n    .then(() => {})\n    .onError((err) => console.error(err))\n    .onData((data, stream, buffer) => {\n        console.log('we received data:', data);\n        if( data === 'quit' ) {\n            console.log('we are going to stop listening for data');\n            quic.stopListening();\n        } else {\n            stream.write(\"Thank you for the data!\");\n        }\n    });\n```"]