- en: Networking and Persistent Storage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络和持久存储
- en: 'We learned a lot about Docker concepts in the previous chapter. We know that
    the container is a runtime of an image. It will contain your Java application
    altogether with all needed dependencies, such as JRE or an application server.
    But, there are rare cases when the Java application is self-sufficient. It always
    needs to communicate with other servers (as a database), or expose itself to others
    (as a web application running on the application server which needs to accept
    requests coming from the user or from the other applications). It''s time to describe
    ways to open the Docker container to the outside world, networking, and persistent
    storage. In this chapter, you are going to learn how to configure networking,
    and expose and map network ports. By doing that, you will enable your Java application
    to communicate with other containers. Imagine the following scenario: you can
    have one container running a Tomcat application server with your Java application,
    communicating with another container running a database, `PostgreSQL` for example.
    While the Kubernetes approach to networking is somewhat different in comparison
    to what Docker provides by default, let''s focus on Docker itself briefly now.
    We are going to cover Kubernetes'' specific networking later on. The container
    communication with the outside world is not only about networking; in this chapter,
    we will also focus on data volumes as a way to persist the data between container
    run and stop cycles.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学到了很多关于Docker概念的知识。我们知道容器是镜像的运行时。它将包含您的Java应用程序以及所有所需的依赖项，如JRE或应用程序服务器。但是，很少有情况下Java应用程序是自给自足的。它总是需要与其他服务器通信（如数据库），或者向其他人公开自己（如在应用程序服务器上运行的Web应用程序，需要接受来自用户或其他应用程序的请求）。现在是描述如何将Docker容器开放给外部世界、网络和持久存储的时候了。在本章中，您将学习如何配置网络，并公开和映射网络端口。通过这样做，您将使您的Java应用程序能够与其他容器通信。想象一下以下情景：您可以有一个容器运行Tomcat应用程序服务器与您的Java应用程序通信，与另一个运行数据库的容器通信，例如`PostgreSQL`。虽然Kubernetes对网络的处理方式与Docker默认提供的有些不同，但让我们先简要地关注Docker本身。稍后我们将介绍Kubernetes的特定网络。容器与外部世界的通信不仅仅是关于网络；在本章中，我们还将关注数据卷作为在容器运行和停止周期之间持久保存数据的一种方式。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Docker network types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网络类型
- en: Networking commands
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络命令
- en: Creating a network
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建网络
- en: Mapping and exposing ports
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射和暴露端口
- en: Volume-related commands
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与卷相关的命令
- en: Creating and removing volumes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和删除卷
- en: Let's begin with Docker networking.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Docker网络开始。
- en: Networking
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络
- en: To make your container able to communicate with the outside world, whether another
    server or another Docker container, Docker provides different ways of configuring
    networking. Let's begin with the network types which are available for our containers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使您的容器能够与外部世界通信，无论是另一个服务器还是另一个Docker容器，Docker提供了不同的配置网络的方式。让我们从可用于我们的容器的网络类型开始。
- en: Docker network types
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker网络类型
- en: 'There are three different network types Docker delivers out of the box. To
    list them, execute the `docker network ls` command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Docker提供了三种不同的网络类型。要列出它们，请执行`docker network ls`命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Docker will output the list of available networks containing the unique network
    identifier, its name, and a driver which powers it behind the scenes:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将输出包含唯一网络标识符、名称和在幕后支持它的驱动程序的可用网络列表：
- en: '![](Image00037.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00037.jpg)'
- en: To have an overview of the differences between various network types, let's
    describe them now one by one.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解各种网络类型之间的区别，让我们现在逐一描述它们。
- en: Bridge
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥接
- en: 'This is the default network type in Docker. When the Docker service daemon
    starts, it configures a virtual bridge, named `docker0` . If you do not specify
    a network with the `docker run -net=<NETWORK>` option, the Docker daemon will
    connect the container to the bridge network by default. Also, if you create a
    new container, it will be connected to the bridge network. For each container
    that Docker creates, it allocates a virtual Ethernet device which will be attached
    to the bridge. The virtual Ethernet device is mapped to appear as `eth0` in the
    container, using Linux namespaces, as you can see in the following diagram:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Docker中的默认网络类型。当Docker服务守护程序启动时，它会配置一个名为`docker0`的虚拟桥。如果您没有使用`docker run -net=<NETWORK>`选项指定网络，Docker守护程序将默认将容器连接到桥接网络。此外，如果您创建一个新的容器，它将连接到桥接网络。对于Docker创建的每个容器，它都会分配一个虚拟以太网设备，该设备将连接到桥上。虚拟以太网设备被映射为在容器中显示为`eth0`，使用Linux命名空间，如您可以在以下图表中看到的那样：
- en: '![](Image00038.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00038.jpg)'
- en: The `in-container eth0` interface is given an IP address from the bridge's address
    range. In other words, Docker will find a free IP address from the range available
    on the bridge and will configure the container's `eth0` interface with that IP
    address. From now on, if the new container wants to, for example, connect to the
    Internet, it will use the bridge; the host's own IP address. The bridge will automatically
    forward packets between any other network interfaces that are attached to it and
    also allow containers to communicate with the host machine, as well as with the
    containers on the same host. The bridge network will probably be the most frequently
    used one.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`in-container eth0`接口从桥的地址范围中获得一个IP地址。换句话说，Docker将从桥可用的范围中找到一个空闲的IP地址，并配置容器的`eth0`接口为该IP地址。从现在开始，如果新容器想要连接到互联网，它将使用桥；主机自己的IP地址。桥将自动转发连接到它的任何其他网络接口之间的数据包，并允许容器与主机机器以及同一主机上的容器进行通信。桥接网络可能是最常用的网络类型。'
- en: Host
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机
- en: 'This type of network just puts the container in the host''s network stack.
    That is, all of the network interfaces defined on the host will be accessible
    to the container, as you can see in the following diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的网络只是将容器放在主机的网络堆栈中。也就是说，主机上定义的所有网络接口都可以被容器访问，如您可以在以下图表中看到的那样：
- en: '![](Image00039.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00039.jpg)'
- en: 'If you start your container using the `-net=host` option, then the container
    will use the host network. It will be as fast as normal networking: there is no
    bridge, no translation, nothing. That''s why it can be useful when you need to
    get the best network performance. Containers running in the host''s network stack
    will achieve faster network performance compared to those running on bridge networking,
    there is no need to traverse the `docker0` `bridge` and `iptables` port mappings.
    In host mode, the container shares the networking namespace of the host (your
    local machine, for example), directly exposing it to the outside world. By using
    the `-net=host` command switch, your container will be accessible through the
    host''s IP address. However, you need to be aware that this can be dangerous.
    If you have an application running as root and it has some vulnerabilities, there
    will be a risk of a security breach, as someone can get remote control of the
    host network via the Docker container. Using the host network type also means
    that you will need to use port mapping to reach services inside the container.
    We are going to cover port mapping later, in this chapter.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`-net=host`选项启动容器，那么容器将使用主机网络。它将与普通网络一样快：没有桥接，没有转换，什么都没有。这就是为什么当您需要获得最佳网络性能时，它可能会有用。在主机网络堆栈中运行的容器将比在桥接网络上运行的容器实现更快的网络性能，无需穿越`docker0`
    `bridge`和`iptables`端口映射。在主机模式下，容器共享主机的网络命名空间（例如您的本地计算机），直接暴露给外部世界。通过使用`-net=host`命令开关，您的容器将通过主机的IP地址访问。但是，您需要意识到这可能是危险的。如果您有一个以root身份运行的应用程序，并且它有一些漏洞，那么存在主机网络被Docker容器远程控制的风险。使用主机网络类型还意味着您需要使用端口映射来访问容器内的服务。我们将在本章后面介绍端口映射。
- en: None
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无
- en: To cut a long story short, the none network does not configure networking at
    all. There is no driver being used by this network type. It's useful when you
    don't need your container to have network access; the `-net=none` switch to `docker
    run` command completely disables networking.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 长话短说，none网络根本不配置网络。这种网络类型不使用任何驱动程序。当您不需要容器访问网络时，`-net=none`开关将完全禁用`docker run`命令的网络。
- en: Docker provides a short list of commands to deal with networking. You can run
    them from the shell (Linux or macOS) or the command prompt and PowerShell in Windows.
    Let's get to know them now.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Docker提供了一组简短的命令来处理网络。您可以从shell（Linux或macOS）或Windows的命令提示符和PowerShell中运行它们。现在让我们来了解它们。
- en: Networking commands
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络命令
- en: 'The parent command for managing networks in Docker is `docker network` . You
    can list the whole command set using the `docker network help` command, as you
    can see in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker中管理网络的父命令是`docker network`。您可以使用`docker network help`命令列出整个命令集，如下面的屏幕截图所示：
- en: '![](Image00040.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00040.jpg)'
- en: To have a detailed syntax and description of each option available for a specific
    command, use the `-help` switch for each of the commands. For example, to get
    the description of parameters available for `docker network create` , execute
    the `docker network create -help` .
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得特定命令的每个选项的详细语法和描述，请对每个命令使用`-help`开关。例如，要获取`docker network create`可用参数的描述，执行`docker
    network create -help`。
- en: 'Let''s briefly describe each command available:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要描述每个可用的命令：
- en: '`**$ docker network ls**` : This is the command we have been using previously,
    it simply lists networks available for your containers. It will output the network
    identifier, its name, the driver being used, and a scope of the network'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**$ docker network ls**`：这是我们之前使用的命令，它简单地列出了容器可用的网络。它将输出网络标识符、名称、使用的驱动程序和网络的范围。'
- en: '`**$ docker network create**` : Creates new network. The full syntax of the
    command is, `docker network create [OPTIONS] NETWORK` . We will use the command
    in a short while'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**$ docker network create**`：创建新网络。命令的完整语法是，`docker network create [OPTIONS]
    NETWORK`。我们将在短时间内使用该命令'
- en: '`**$ docker network rm**` : The `dockercnetworkcrm` command simply removes
    the network'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**$ docker network rm**`：`dockercnetworkcrm`命令简单地删除网络'
- en: '`**$ docker network connect**` : C onnects the container to the specific network'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**$ docker network connect**`：将容器连接到特定网络'
- en: '`**$ docker network disconnect**` : A s the name suggests, it will disconnect
    the container from the network'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**$ docker network disconnect**`：正如其名称所示，它将断开容器与网络的连接'
- en: '`**$ docker network inspect**` : The docker network inspect command displays
    detailed information about the network. It''s very useful, if you have network
    issues. We are going to create and inspect our network now'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**$ docker network inspect**`：docker network inspect命令显示有关网络的详细信息。如果您遇到网络问题，这非常有用。我们现在要创建和检查我们的网络'
- en: The `docker network` inspect command displays detailed information about the
    network. It's very useful if you have network issues. We are going to create and
    inspect our network now.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker network` inspect命令显示有关网络的详细信息。如果您遇到网络问题，这非常有用。我们现在要创建和检查我们的网络。'
- en: Creating and inspecting a network
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和检查网络
- en: 'Let''s create a network. We are going to call our network `myNetwork` . Execute
    the following command from the shell or command line:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个网络。我们将称我们的网络为`myNetwork`。从shell或命令行执行以下命令：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is the simplest form of the command, and yet it will probably be used
    the most often. It takes a default driver (we haven''t used any option to specify
    a driver, we will just use the default one, which is bridge). As the output, Docker
    will print out the identifier of the newly created network:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是命令的最简单形式，但可能会经常使用。它采用默认驱动程序（我们没有使用任何选项来指定驱动程序，我们将只使用默认的桥接驱动程序）。作为输出，Docker将打印出新创建的网络的标识符：
- en: '![](Image00041.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00041.jpg)'
- en: 'You will later use this identifier to refer to this network when connecting
    containers to it or inspecting the network''s properties. The last parameter of
    the command is the network''s name, which is a lot more convenient and easier
    to remember than the ID. The network name in our case is `myNetwork` . The `docker
    network` create command takes more parameters, as shown in the following table:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后您将使用此标识符来连接容器或检查网络属性。命令的最后一个参数是网络的名称，这比ID更方便和更容易记住。在我们的情况下，网络名称是`myNetwork`。`docker
    network` create命令接受更多参数，如下表所示：
- en: '| **Option** | **Description** |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **选项** | **描述** |'
- en: '| `-d, -driver="bridge"` | Driver to manage the network |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `-d, -driver="bridge"` | 管理网络的驱动程序 |'
- en: '| `-aux-address=map[]` | Auxiliary IPv4 or IPv6 addresses used by network driver
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `-aux-address=map[]` | 网络驱动程序使用的辅助IPv4或IPv6地址 |'
- en: '| `-gateway=[]` | IPv4 or IPv6 gateway for the master subnet |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `-gateway=[]` | 主子网的IPv4或IPv6网关 |'
- en: '| `-ip-range=[]` | Allocate container IP from a sub-range |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `-ip-range=[]` | 从子范围分配容器IP |'
- en: '| `-ipam-driver=default` | IP address management driver |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `-ipam-driver=default` | IP地址管理驱动程序 |'
- en: '| `-o` , `-opt=map[]` | Set driver''s specific options |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `-o`，`-opt=map[]` | 设置驱动程序的特定选项 |'
- en: '| `-subnet=[]` | Subnet in CIDR format that represents a network segment |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `-subnet=[]` | 以CIDR格式表示网络段的子网 |'
- en: 'One of the most important parameters is the `-d` (`--driver` ) option, with
    the default value bridge. Drivers let you specify the network type. As you remember,
    Docker has a couple of drivers available by default: `host` , `bridge` , and `none`
    .'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的参数之一是`-d`（`--driver`）选项，默认值为bridge。驱动程序允许您指定网络类型。您记得，Docker默认提供了几个驱动程序：`host`，`bridge`和`none`。
- en: 'After creating a network, we can inspect its properties using the `docker network
    inspect` command. Execute the following from the shell or command line:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建网络后，我们可以使用`docker network inspect`命令检查其属性。从shell或命令行执行以下操作：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In response, you will get a lot of detailed information about your network.
    As you can see in the screenshot, our newly created network uses the bridge driver,
    even if we haven''t explicitly asked for it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回应，你将获得关于你的网络的大量详细信息。正如你在截图中看到的，我们新创建的网络使用桥接驱动程序，即使我们没有明确要求使用它：
- en: '![](Image00042.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00042.jpg)'
- en: As you can see, the container list is empty, and the reason why is that we haven't
    connected any container to this network yet. Let's do it now.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，容器列表是空的，原因是我们还没有将任何容器连接到这个网络。让我们现在来做。
- en: Connecting a container to the network
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将容器连接到网络
- en: 'Now we have our `myNetwork` ready, we can run the Docker container and attach
    it to the network. To launch containers, we are going to user the `docker run
    --net=<NETWORK>` option, where the `<NETWORK>` is the name of one of the default
    networks or the one you have created yourself. Let''s run Apache Tomcat for example,
    which is an open source implementation of the Java Servlet and JavaServer pages
    technologies:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`myNetwork`准备就绪，我们可以运行Docker容器并将其附加到网络。要启动容器，我们将使用`docker run --net=<NETWORK>`选项，其中`<NETWORK>`是默认网络之一的名称，或者是你自己创建的网络的名称。例如，让我们运行Apache
    Tomcat，这是Java Servlet和JavaServer页面技术的开源实现：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It will take a while. The Docker engine will pull all of the Tomcat''s image
    layers from the Docker Hub and then run the Tomcat container. There''s another
    option to attach the network to the container, you can inform Docker that you
    would like the container to connect to the same network as other containers use.
    This way, instead of specifying a network explicitly, you just instruct Docker
    that you want two containers run on the same network. To do this, use the `container:`
    prefix, as in the following example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要一些时间。Docker引擎将从Docker Hub拉取所有Tomcat镜像层，然后运行Tomcat容器。还有另一种选项可以将网络附加到容器上，你可以告诉Docker你希望容器连接到其他容器使用的相同网络。这样，你不需要显式指定网络，只需告诉Docker你希望两个容器在同一网络上运行。要做到这一点，使用`container:`前缀，就像下面的例子一样：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the previous example, we run the `myTomcat` image using the bridge network.
    The next command will run the `myPostgreSQL` image, using the same network as
    `myTomcat` uses. This is a very common scenario; your application will run on
    the same network as the database and this will allow them to communicate. Of course,
    the containers you launch into the same network must be run on the same Docker
    host. Each container in the network can directly communicate with other containers
    in the network. Though, the network itself isolates the containers from external
    networks, as seen in the following diagram:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用桥接网络运行了`myTomcat`镜像。下一个命令将使用与`myTomcat`相同的网络运行`myPostgreSQL`镜像。这是一个非常常见的情况；你的应用程序将在与数据库相同的网络上运行，这将允许它们进行通信。当然，你在同一网络中启动的容器必须在同一Docker主机上运行。网络中的每个容器都可以直接与网络中的其他容器通信。尽管如此，网络本身会将容器与外部网络隔离开来，如下图所示：
- en: '![](Image00043.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00043.jpg)'
- en: If you run your containers in a bridge, isolated network, we need to instruct
    Docker on how to map the ports of our containers to the host's ports. We are going
    to do this now.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在桥接、隔离网络中运行容器，我们需要指示Docker如何将容器的端口映射到主机的端口。我们现在要做的就是这个。
- en: Exposing ports and mapping ports
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露端口和映射端口
- en: A common scenario is usually when you want your containerized application to
    accept incoming connections, either from other containers or from outside of Docker.
    It can be an application server listening on port 80 or a database accepting incoming
    requests.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当您希望容器化应用程序接受传入连接时，无论是来自其他容器还是来自Docker之外，都会出现这种情况。它可以是一个在端口80上监听的应用服务器，也可以是一个接受传入请求的数据库。
- en: 'An image can expose ports. Exposing ports means that your containerized application
    will listen on an exposed port. As an example, the Tomcat application server will
    listen on the port `8080` by default. All containers running on the same host
    and on the same network can communicate with Tomcat on this port. Exposing a port
    can be done in two ways. It can be either in the Dockerfile with the `EXPOSE`
    instruction (we will do this in the chapter about creating images later) or in
    the `docker run` command using the `--expose` option. Take this official Tomcat
    image Dockerfile fragment (note that it has been shortened for clarity of the
    example):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像可以暴露端口。暴露端口意味着您的容器化应用程序将在暴露的端口上监听。例如，Tomcat应用服务器默认将在端口`8080`上监听。在同一主机和同一网络上运行的所有容器都可以与该端口上的Tomcat通信。暴露端口可以通过两种方式完成。它可以在Dockerfile中使用`EXPOSE`指令（我们将在稍后关于创建镜像的章节中进行）或者在`docker
    run`命令中使用`--expose`选项。接下来是这个官方Tomcat镜像的Dockerfile片段（请注意，为了示例的清晰度，它已经被缩短）：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, there''s an `EXPOSE 8080` instruction near the end of the Dockerfile.
    It means that we could expect that the container, when run, will listen on port
    number `8080` . Let''s run the latest Tomcat image again. This time, we will also
    give our container a name, `myTomcat` . Start the application server using the
    following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在Dockerfile的末尾附近有一个`EXPOSE 8080`指令。这意味着我们可以期望该容器在运行时将监听端口号`8080`。让我们再次运行最新的Tomcat镜像。这次，我们还将为我们的容器命名为`myTomcat`。使用以下命令启动应用服务器：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For the purpose of checking if containers on the same network can communicate,
    we will use another image, `busybox` . BusyBox is software that provides several
    stripped-down Unix tools in a single executable file. Let''s run the following
    command in the separate shell or command prompt window:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查同一网络上的容器是否可以通信，我们将使用另一个镜像`busybox`。BusyBox是一种软件，它在一个可执行文件中提供了几个精简的Unix工具。让我们在单独的shell或命令提示符窗口中运行以下命令：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we have instructed Docker that we want our `busybox` container
    to use the same network as Tomcat uses. As an alternative, we could of course
    go with specifying a network name explicitly, using the `--net myNetwork` option.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们已经告诉Docker，我们希望我们的`busybox`容器使用与Tomcat相同的网络。作为另一种选择，当然也可以使用`--net
    myNetwork`选项显式指定网络名称。
- en: 'Let''s check if they indeed can communicate. Execute the following in the shell
    window with `busybox` running:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查它们是否确实可以通信。在运行`busybox`的shell窗口中执行以下操作：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The previous instruction will execute the `HTTP GET` request on port `8080`
    , on which Tomcat is listening in another container. After the successful download
    of Tomcat''s `index.html` , we have proof that both containers can communicate:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个指令将在另一个容器上监听的端口`8080`上执行`HTTP GET`请求。在成功下载Tomcat的`index.html`之后，我们证明了两个容器可以通信：
- en: '![](Image00044.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00044.jpg)'
- en: So far so good, containers running on the same host and the same network can
    communicate with each other. But what about communicating with our container from
    the outside? Mapping ports comes in handy. We can map a port, exposed by the Docker
    container, into the port of the host machine, which will be a localhost in our
    case. The general idea is that we want the port on the host to be mapped to a
    specific port in the running container, the same as port number `8080` of the
    Tomcat container.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，运行在同一主机和同一网络上的容器可以相互通信。但是如何与外部通信呢？端口映射派上了用场。我们可以将Docker容器暴露的端口映射到主机的端口上，这将是我们的本地主机。总体思路是我们希望主机上的端口映射到运行容器中的特定端口，就像Tomcat容器的端口号`8080`一样。
- en: 'To bind a port (or group of ports) from a host to the container, we use the
    `-p` flag of the `docker run` command, as in the following example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定主机到容器的端口（或一组端口），我们使用`docker run`命令的`-p`标志，如下例所示：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The previous command runs another Tomcat instance, also connected to the `myNetwork`
    network. This time, however, we map the container''s port `8080` to the host''s
    port of the same number. The syntax of the `-p` switch is quite straightforward:
    you just enter the host port number, a colon, and then a port number in the container
    you would like to be mapped:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令运行了另一个Tomcat实例，也连接到`myNetwork`网络。然而，这一次，我们将容器的端口`8080`映射到相同编号的主机端口。`-p`开关的语法非常简单：只需输入主机端口号，冒号，然后是您想要映射的容器中的端口号：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The Docker image can expose a whole range of ports to other containers using
    either the `EXPOSE` instruction in a Dockerfile (the same as `EXPOSE 7000-8000`
    , for example) or the `docker run` command, for example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像可以使用Dockerfile中的`EXPOSE`指令（例如`EXPOSE 7000-8000`）或`docker run`命令向其他容器暴露一系列端口，例如：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can then map a whole range of ports from the host to the container by using
    the `docker run` command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用`docker run`命令将一系列端口从主机映射到容器：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s verify if we can access the Tomcat container from outside of Docker.
    To do this, let''s run Tomcat with mapped ports:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证一下是否可以从Docker外部访问Tomcat容器。为此，让我们运行带有映射端口的Tomcat：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we can simply enter the following address in our favorite web browser:
    `http://localhost:8080` .'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在我们喜爱的网络浏览器中输入以下地址：`http://localhost:8080`。
- en: 'As a result, we can see Tomcat''s default welcome page, served straight from
    the Docker container running, as you can see in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们可以看到Tomcat的默认欢迎页面，直接从运行的Docker容器中提供，如下截图所示：
- en: '![](Image00045.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00045.jpg)'
- en: Good, we can communicate with our container from the outside of Docker. By the
    way, we now have two isolated Tomcats running on the host, without any port conflicts,
    resource conflicts, and so on. This is the power of containerization.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们可以从Docker外部与我们的容器通信。顺便说一句，我们现在在主机上有两个隔离的Tomcat运行，没有任何端口冲突、资源冲突等。这就是容器化的力量。
- en: 'You may ask, what is the difference between exposing and mapping ports, that
    is, between `--expose` switch and `-p` switches? Well, the `--expose` will expose
    a port at runtime but will not create any mapping to the host. Exposed ports will
    be available only to another container running on the same network, on the same
    Docker host. The `-p` option, on the other hand, is the same as `publish` : it
    will create a port mapping rule, mapping a port on the container with the port
    on the host system. The mapped port will be available from outside Docker. Note
    that if you do `-p` , but there is no `EXPOSE` in the Dockerfile, Docker will
    do an implicit `EXPOSE` . This is because, if a port is open to the public, it
    is automatically also open to other Docker containers.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问，暴露和映射端口之间有什么区别，也就是`--expose`开关和`-p`开关之间有什么区别？嗯，`--expose`将在运行时暴露一个端口，但不会创建任何映射到主机。暴露的端口只对在同一网络上运行的另一个容器和在同一Docker主机上运行的容器可用。另一方面，`-p`选项与`publish`相同：它将创建一个端口映射规则，将容器上的端口映射到主机系统上的端口。映射的端口将从Docker外部可用。请注意，如果您使用`-p`，但Dockerfile中没有`EXPOSE`，Docker将执行隐式的`EXPOSE`。这是因为，如果一个端口对公众开放，它也会自动对其他Docker容器开放。
- en: There is no way to create a port mapping in the Dockerfile. Mapping a port or
    ports is, just a runtime option. The reason for that is because port mapping configuration
    depends on the host. The Dockerfile needs to be host-independent and portable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无法在Dockerfile中创建端口映射。映射一个或多个端口只是一个运行时选项。原因是端口映射配置取决于主机。Dockerfile需要是与主机无关且可移植的。
- en: You can bind a port using `-p` in the runtime only.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您只能在运行时使用`-p`绑定端口。
- en: There is yet one more option, which allows you to map all ports exposed in an
    image (that is; in the Dockerfile) at once, automatically during the container
    startup. The `-P` switch (capital `P` this time) will map a dynamically allocated
    random host port to all container ports that have been exposed in the Dockerfile
    by the `EXPOSE` instruction.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种选项，允许您一次性自动映射镜像中暴露的所有端口（即Dockerfile中的端口）在容器启动时。`-P`开关（这次是大写`P`）将动态分配一个随机的主机端口映射到Dockerfile中已经暴露的所有容器端口。
- en: The `-p` option gives you more control than `-P` when mapping ports. Docker
    will not automatically pick any random port; it's up to you what ports on the
    host should be mapped to the container ports.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p`选项在映射端口时比`-P`提供更多控制。Docker不会自动选择任何随机端口；由您决定主机上应该映射到容器端口的端口。'
- en: 'If you run the following command, Docker will map a random port on the host
    to Tomcat''s exposed port number `8080` :'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行以下命令，Docker将在主机上将一个随机端口映射到Tomcat的暴露端口号`8080`：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To check exactly which host port has been mapped, you can use the `docker ps`
    command. This is probably the quickest way of determining the current port mapping.
    The `docker ps` command is used to see the list of running containers. Execute
    the following from a separate shell console:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要确切查看已映射的主机端口，可以使用`docker ps`命令。这可能是确定当前端口映射的最快方法。`docker ps`命令用于查看正在运行的容器列表。从单独的shell控制台执行以下操作：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the output, Docker will list all running containers, showing which ports
    have been mapped in the `PORTS` column:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，Docker将列出所有正在运行的容器，显示在`PORTS`列中已经映射了哪些端口：
- en: '![](Image00046.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00046.jpg)'
- en: 'As you can see in the previous screenshot, our `myTomcat3` container will have
    the `8080` port mapped to port number `32772` on the host. Again, executing the
    `HTTP GET` method on the `http://localhost:32772` address will give us `myTomcat3`
    ''s welcome page. An alternative to the `docker ps` command is the docker port
    command, used with the container `ID` or with a `name` as a parameter (this will
    give you information about what ports have been mapped). In our case, this will
    be:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一张截图中所看到的，我们的`myTomcat3`容器将把`8080`端口映射到主机上的`32772`端口。再次在`http://localhost:32772`地址上执行`HTTP
    GET`方法将会显示`myTomcat3`的欢迎页面。`docker ps`命令的替代方法是docker port命令，与容器ID或名称一起使用（这将为您提供已映射的端口信息）。在我们的情况下，这将是：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As a result, Docker will output the mapping, saying that port number 80 from
    the container has been mapped to port number `8080` on the host machine:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Docker将输出映射，表示容器中的端口号80已映射到主机上的端口号`8080`：
- en: '![](Image00047.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00047.jpg)'
- en: 'Information about all the port mappings is also available in the result of
    the docker inspect command. Execute the following command, for example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所有端口映射的信息也可以在docker inspect命令的结果中找到。例如，执行以下命令：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the output of the `docker inspect` command, you will find the `Ports` section
    containing the information about mappings:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`docker inspect`命令的输出中，您将找到包含映射信息的`Ports`部分：
- en: '![](Image00048.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00048.jpg)'
- en: 'Let''s briefly summarize the options related to exposing and mapping ports
    in a table:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要总结一下与暴露和映射端口相关的选项：
- en: '| **Instruction** | **Meaning** |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **含义** |'
- en: '| `EXPOSE` | Signals that there is service available on the specified port.
    Used in the Dockerfile and makes exposed ports open for other containers. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '`EXPOSE` | 表示指定端口上有服务可用。在Dockerfile中使用，使暴露的端口对其他容器开放。'
- en: '| `--expose` | The same as `EXPOSE` but used in the runtime, during the container
    startup. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `--expose` | 与`EXPOSE`相同，但在运行时，在容器启动期间使用。'
- en: '| `-p hostPort:containerPort` | Specify a port mapping rule, mapping the port
    on the container with the port on the host machine. Makes a port open from the
    outside of Docker. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `-p hostPort:containerPort` | 指定端口映射规则，将容器上的端口与主机上的端口进行映射。使得Docker外部的端口开放。'
- en: '| `-P` | Map dynamically allocated random port (or ports) of the host to all
    ports exposed using `EXPOSE` or `--expose` . |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `-P` | 将主机的动态分配的随机端口（或端口）映射到使用`EXPOSE`或`--expose`暴露的所有端口。 |'
- en: Mapping ports is a wonderful feature. It gives you flexible configuration possibilities
    to open your containers to the external world. In fact, it's indispensable if
    you want your containerized web server, database, or messaging server to be able
    to talk to others. If a default set of network drivers is not enough, you can
    always try to find a specific driver on the Internet or develop one yourself.
    Docker Engine network plugins extend Docker to support a wide range of networking
    technologies, such as IPVLAN, MACVLAN, or something completely different and exotic.
    Networking possibilities are almost endless in Docker. Let's focus now on another
    very important aspect of Docker container extensibility volumes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 映射端口是一个很棒的功能。它为您提供了灵活的配置可能性，可以将您的容器开放给外部世界。事实上，如果您希望容器化的Web服务器、数据库或消息服务器能够与其他服务器通信，这是必不可少的。如果默认的网络驱动程序集不够用，您可以尝试在互联网上找到特定的驱动程序，或者自己开发一个。Docker引擎网络插件扩展了Docker以支持各种网络技术，如IPVLAN、MACVLAN，或者完全不同和奇特的技术。在Docker中，网络的可能性几乎是无限的。现在让我们专注于Docker容器可扩展性卷的另一个非常重要的方面。
- en: Persistent storage
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久存储
- en: As you remember from [Chapter 1](text00022.html) , *Introduction to Docker*
    , the Docker container filesystem is kind of temporary by default. If you start
    up a Docker image (that is, run the container), you'll end up with a read-write
    layer on top of the layers stack. You can create, modify, and delete files as
    you wish; if you commit the changes back into the image, they will become persisted.
    This is a great feature if you want to create a complete setup of your application
    in the image, altogether with all its environment. But, this is not very convenient
    when it comes to storing and retrieving data. The best option would be to separate
    the container life cycle and your application from the data. Ideally, you would
    probably want to keep these separate, so that the data generated (or being used)
    by your application is not destroyed or tied to the container life cycle and can
    thus be reused.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[第1章](text00022.html)中所记得的，*Docker简介*，Docker容器文件系统默认是临时的。如果您启动一个Docker镜像（即运行容器），您将得到一个读写层，位于层栈的顶部。您可以随意创建，修改和删除文件；如果您将更改提交回镜像，它们将变得持久。如果您想在镜像中创建应用程序的完整设置，包括所有环境，这是一个很好的功能。但是，当涉及存储和检索数据时，这并不是很方便。最好的选择是将容器的生命周期和您的应用程序与数据分开。理想情况下，您可能希望将这些分开，以便由您的应用程序生成（或使用）的数据不会被销毁或绑定到容器的生命周期，并且可以被重复使用。
- en: 'The perfect example would be a web application server: the Docker image contains
    web server software, the same as Tomcat for example, with your Java application
    deployed, configured, and ready to use. But, the data the server will be using
    should be separated from the image. This is done via volumes, which we will focus
    on in this part of the chapter. Volumes are not part of the union filesystem,
    and so the write operations are instant and as fast as possible, there is no need
    to commit any changes.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完美的例子是一个Web应用程序服务器：Docker镜像包含Web服务器软件，例如Tomcat，部署了您的Java应用程序，配置好并且可以立即使用。但是，服务器将使用的数据应该与镜像分离。这是通过卷来实现的，在本章的这部分我们将重点关注卷。卷不是联合文件系统的一部分，因此写操作是即时的并且尽可能快，不需要提交任何更改。
- en: Volumes live outside of the union filesystem and exist as normal directories
    and files on the host filesystem.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 卷存在于联合文件系统之外，并且作为主机文件系统上的普通目录和文件存在。
- en: 'There are three main use cases for Docker data volumes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Docker数据卷有三个主要用途：
- en: To share data between the host filesystem and the Docker container
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主机文件系统和Docker容器之间共享数据
- en: To keep data when a container is removed
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器被移除时保留数据
- en: To share data with other Docker containers
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他Docker容器共享数据
- en: Let's begin with a list of volume-related commands at our disposal.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们可以使用的卷相关命令列表开始。
- en: Volume-related commands
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与卷相关的命令
- en: 'The basis of volume-related commands is docker volume . The commands are as
    follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与卷相关的命令的基础是docker volume。命令如下：
- en: '`**$docker volume create**` : C reates a volume'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**$docker volume create**`：创建一个卷'
- en: '`**$ docker volume inspect**` : D isplays detailed information on one or more
    volumes'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**$ docker volume inspect**`：显示一个或多个卷的详细信息'
- en: '`**$docker volume ls**` : L ists volumes'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**$docker volume ls**`：列出卷'
- en: '`**$ docker volume rm**` : r emoves one or more volumes'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**$ docker volume rm**`：删除一个或多个卷'
- en: '`**$ docker volume prune**` : r emoves all unused volumes, which is all volumes
    that are no longer mapped into any container'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**$ docker volume prune**`：删除所有未使用的卷，即不再映射到任何容器的所有卷'
- en: 'Similar to network-related commands, you can get the detailed description and
    all the possible options for each command if you execute it with the `-help` switch,
    for example: docker volume create `-help` . Let''s begin with creating a volume.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与与网络相关的命令类似，如果您使用`-help`开关执行每个命令，您可以获得详细的描述和所有可能的选项，例如：docker volume create
    `-help`。让我们开始创建一个卷。
- en: Creating a volume
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建卷
- en: 'As you remember from [Chapter 1](text00022.html) , *Introduction to Docker*
    , there''s a settings screen in Docker for Windows or Docker for Mac, that allows
    us to specify which drives Docker can have access to. For a start, let''s mark
    drive D in our Docker for Windows to make it available for Docker containers:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从[第1章](text00022.html) *Docker简介*中记得的那样，Docker for Windows或Docker for Mac中有一个设置屏幕，允许我们指定Docker可以访问哪些驱动器。首先，让我们在Docker
    for Windows中标记驱动器D，以便让它可用于Docker容器：
- en: '![](Image00049.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00049.jpg)'
- en: 'For the purpose of our volume examples, I''ve created a `docker_volumes/volume1`
    directory on my `D` drive and created an empty `data.txt` file inside:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的卷示例，我在我的D驱动器上创建了一个`docker_volumes/volume1`目录，并在其中创建了一个空的`data.txt`文件：
- en: '![](Image00050.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00050.jpg)'
- en: 'There are two ways to create volumes. The first one is to specify the `-v`
    option when running an image. Let''s run the `busybox` image we already know and,
    at the same time, create a volume for our data:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种创建卷的方法。第一种是在运行镜像时指定`-v`选项。让我们运行我们已经知道的`busybox`镜像，并同时为我们的数据创建一个卷：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the previous command, we have created a volume using the `-v` switch and
    instructed Docker that the `host` directory `d:/docker_volumes/volume1` should
    be mapped into the `/volume` directory in the running container. If we now list
    the contents of the `/volume` directory in the running `busybox` container, we
    can see our empty `data1.txt` file, as you can see in the following screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个命令中，我们使用`-v`开关创建了一个卷，并指示Docker将`host`目录`d:/docker_volumes/volume1`映射到正在运行的容器中的`/volume`目录。如果我们现在列出正在运行的`busybox`容器中`/volume`目录的内容，我们可以看到我们的空`data1.txt`文件，如下面的截图所示：
- en: '![](Image00051.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00051.jpg)'
- en: The parameters in the `-v` options are the directory on the host (your own operating
    system in this case, it is `d:/docker_volumes/volume1` in our example), a colon,
    and a path at which it will be available for the container, `/volume1` in our
    example. The volume created is a kind of mapped directory. It will be available
    for the container and also available from the host operating system. Any files
    already existing in the mapped directory (host's `d:/docker_volumes/volume1` )
    will be available inside the container; they will not be deleted during the mapping.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v`选项中的参数是主机上的目录（在这种情况下是您自己的操作系统，在我们的示例中是`d:/docker_volumes/volume1`），一个冒号，以及容器中可用的路径，在我们的示例中是`/volume1`。创建的卷是一种映射的目录。它将对容器可用，并且也可以从主机操作系统中访问。映射目录（主机的`d:/docker_volumes/volume1`）中已经存在的任何文件将在映射期间在容器内可用；它们不会在映射期间被删除。'
- en: 'The `-v` option can be used not only for directories but for a single file
    as well. This can be very useful if you want to have configuration files available
    in your container. The best example for this is the example from the official
    Docker documentation:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v`选项不仅可以用于目录，还可以用于单个文件。如果您想在容器中使用配置文件，这将非常有用。最好的例子是官方Docker文档中的例子：'
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Executing the previous command will give you the same bash history between your
    local machine and a running Ubuntu container. And best of all, if you exit the
    container, the bash history on your own local machine will contain the bash commands
    you have been executing inside the container. Mapping files can be useful also
    for you, as a developer, when debugging or trying out your application configuration,
    for example.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上一个命令将在本地机器和正在运行的Ubuntu容器之间给您相同的bash历史记录。最重要的是，如果您退出容器，您本地机器上的bash历史记录将包含您在容器内执行的bash命令。映射文件对您作为开发人员在调试或尝试应用程序配置时也很有用。
- en: Mapping a single file from a host allows exposing a configuration of your application.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从主机映射单个文件允许暴露应用程序的配置。
- en: Apart from creating a volume when starting a container, there is a command to
    create a volume prior to starting a container. We will use it now.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在启动容器时创建卷外，还有一个命令可以在启动容器之前创建卷。我们现在将使用它。
- en: 'The simplest form of creating a nameless volume will be just:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 创建无名称卷的最简单形式将是：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As the output, Docker will give you the volume identifier, which you can later
    use to refer to this volume. It''s better to give a volume a meaningful name.
    To create a standalone, named volume, execute the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输出，Docker将为您提供卷标识符，您以后可以使用它来引用此卷。最好给卷一个有意义的名称。要创建一个独立的命名卷，请执行以下命令：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To list the volumes we now have available, execute the `docker volume ls` command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出我们现在可用的卷，执行`docker volume ls`命令：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output will be simply the list of volumes we have created so far:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将简单地列出到目前为止我们创建的卷的列表：
- en: '![](Image00052.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00052.jpg)'
- en: 'Volumes created this way will not be mapped explicitly with a path on the host.
    If the container''s base image contains data at the specified mount point (as
    a result of Dockerfile processing), this data will be copied into the new volume
    upon volume initialization. This is different in comparison to specifying a `host`
    directory explicitly. The idea behind it is that when creating your image, you
    should not care about the location of the volume on the host system, making the
    image portable between different hosts. Let''s run another container and map the
    named volume into it:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式创建的卷不会显式地映射到主机上的路径。如果容器的基本映像包含指定挂载点处的数据（作为Dockerfile处理的结果），则此数据将在卷初始化时复制到新卷中。这与显式指定`host`目录不同。其背后的想法是，在创建图像时，您不应该关心卷在主机系统上的位置，使图像在不同主机之间可移植。让我们运行另一个容器并将命名卷映射到其中：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that this time, we do not specify a path on the host. Instead, we instruct
    Docker to use the named volume we created in the previous step. The named volume
    will be available at the `/volume` path in the container. Let''s create a text
    file on the volume:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这一次，我们没有在主机上指定路径。相反，我们指示Docker使用我们在上一步创建的命名卷。命名卷将在容器中的`/volume`路径处可用。让我们在卷上创建一个文本文件：
- en: '![](Image00053.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00053.jpg)'
- en: 'If we run another container now, specifying the same named volume, we will
    be able to access the same data we have available in our `myBusybox3` container
    which was created previously:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行另一个容器，指定相同的命名卷，我们将能够访问我们在之前创建的`myBusybox3`容器中可用的相同数据：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Our two containers share the single volume now, as you can see in the following
    screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两个容器现在共享单个卷，如下截图所示：
- en: '![](Image00054.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00054.jpg)'
- en: Docker named volumes are an easy way of sharing volumes between containers.
    They are also a great alternative to data-only containers that used to be a common
    practice in the old days of Docker. This is no longer the case—named volumes are
    way better. It's worth noting that you are not limited to just one volume per
    container, as that would be a serious limitation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Docker命名卷是在容器之间共享卷的一种简单方法。它们也是数据专用容器的一个很好的替代方案，这在Docker的旧时代曾经是一种常见做法。现在已经不再是这样了——命名卷要好得多。值得注意的是，您不仅限于每个容器只有一个卷，因为那将是一个严重的限制。
- en: You can use the `-v` multiple times to mount multiple data volumes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以多次使用`-v`来挂载多个数据卷。
- en: 'Another option to share the volume between containers is the `-volumes-from`
    switch. If one of your containers has volumes mounted already, by using this option
    we can instruct Docker to use the volume mapped in some other container, instead
    of providing the name of the volume. Consider this example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器之间共享卷的另一个选项是`-volumes-from`开关。如果您的一个容器已经挂载了卷，通过使用此选项，我们可以指示Docker使用另一个容器中映射的卷，而不是提供卷的名称。考虑以下示例：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After running the `myBusybox5` container this way, again, if you enter the `/volume`
    directory in the `myBusybox5` container running, you will see the same `data.txt`
    file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式运行`myBusybox5`容器后，如果再次进入运行的`myBusybox5`容器中的`/volume`目录，您将看到相同的`data.txt`文件。
- en: 'The `docker volume ls` command can take some filter parameters, which can be
    quite useful. For example, you can list volumes that are not being used by any
    container:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker volume ls`命令可以接受一些过滤参数，这可能非常有用。例如，您可以列出未被任何容器使用的卷：'
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Volumes that are no longer used by any container can be easily removed by using
    the docker volumes prune command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 不再被任何容器使用的卷可以通过使用docker volumes prune命令轻松删除：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To list volumes being created with a specific driver (we are going to cover
    drivers in a short while), you can filter a list using the driver filter, as in
    the following example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出使用特定驱动程序创建的卷（我们将在短时间内介绍驱动程序），您可以使用驱动程序过滤器来过滤列表，如下例所示：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Last but not least, another way of creating a volume is the `VOLUME CREATE`
    instruction in a Dockerfile. We will be using it later in the book when creating
    an image from a Dockerfile. Creating volumes using the `VOLUME CREATE` instruction
    has one but very important difference in comparison to using the `-v` option during
    the container startup: you cannot specify a `host` directory when using `VOLUME
    CREATE` . It''s an analogy to exposing and mapping ports. You cannot map a port
    in a Dockerfile. Dockerfiles are meant to be portable, shareable, and host-independent.
    The `host` directory is 100% host-dependent and will break on any other machine,
    which is a little bit off from the Docker''s idea. Because of this, it is only
    possible to use portable instructions within a Dockerfile.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，创建卷的另一种方法是在Dockerfile中使用`VOLUME CREATE`指令。在本书的后面，当从Dockerfile创建镜像时，我们将使用它。使用`VOLUME
    CREATE`指令创建卷与在容器启动期间使用`-v`选项相比有一个非常重要的区别：当使用`VOLUME CREATE`时，您无法指定`host`目录。这类似于暴露和映射端口。您无法在Dockerfile中映射端口。Dockerfile应该是可移植的、可共享的和与主机无关的。`host`目录是100%依赖于主机的，会在任何其他机器上出现问题，这与Docker的理念有点不符。因此，在Dockerfile中只能使用可移植指令。
- en: If you need to specify a `host` directory when creating a volume, you need to
    specify it at runtime.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在创建卷时指定`host`目录，则需要在运行时指定它。
- en: Removing a volume
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除卷
- en: 'The same as with creating volumes, there are two ways of removing a volume
    in Docker. Firstly, you can remove a volume by referencing a container''s name
    and executing the docker `rm -v` command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建卷一样，Docker中有两种删除卷的方法。首先，您可以通过引用容器的名称并执行docker `rm -v`命令来删除卷：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Docker will not warn you, when removing a container without providing the `-v`
    option, to delete its volumes. As a result, you will have `dangling` volumes—volumes
    that are no longer referenced by a container. As you remember, they are easy to
    get rid of using the docker volume prune command.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当删除容器时，如果没有提供`-v`选项，Docker不会警告您删除其卷。结果，您将拥有`悬空`卷——不再被容器引用的卷。正如您记得的那样，使用`docker
    volume prune`命令很容易摆脱它们。
- en: 'Another option to remove the volume is by using the `docker volume rm` command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种删除卷的选项是使用`docker volume rm`命令：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If the volume happens to be in use by the container, Docker Engine will not
    allow you to delete it and will give you a warning message:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果卷恰好被容器使用，Docker引擎将不允许您删除它，并会给出警告消息：
- en: '![](Image00055.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00055.jpg)'
- en: As you can see, creating, sharing, and removing volumes in Docker is not that
    tricky. It's very flexible and allows the creating a setup you will need for your
    applications. But there's more to this flexibility. When creating a volume, you
    can specify a `--driver` option (or `-d` for short), which may be useful if you
    need to map some external, not so standard storage. The volumes we have created
    so far were using the local filesystem driver (the files were being stored on
    the local drive of the host system); you can see the driver name when inspecting
    a volume using the `volume inspect` command. There are other options though—let's
    look at them now.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在Docker中创建、共享和删除卷并不那么棘手。它非常灵活，允许创建您的应用程序所需的设置。但这种灵活性还有更多。在创建卷时，您可以指定`--driver`选项（或简写为`-d`），如果您需要映射一些外部、不太标准的存储，这可能会很有用。到目前为止，我们创建的卷都是使用本地文件系统驱动程序（文件存储在主机系统的本地驱动器上）；您可以在使用`volume
    inspect`命令检查卷时看到驱动程序名称。不过还有其他选项——现在让我们来看看它们。
- en: Volume drivers
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卷驱动程序
- en: 'The same as with network driver plugins, volume plugins extend the capabilities
    of the Docker engine and enable integration with other types of storage. There
    are a ton of ready to use plugins available for free on the Internet; you can
    find a list on Docker''s GitHub page. Some of them include:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与网络驱动程序插件一样，卷插件扩展了Docker引擎的功能，并实现了与其他类型的存储的集成。在互联网上有大量可用的免费插件；您可以在Docker的GitHub页面上找到一个列表。其中一些包括：
- en: '**Docker volume driver for Azure file storage** : This is a Docker volume driver
    which uses Azure file storage to mount file shares on the cloud to Docker containers
    as volumes. It uses the network file sharing (SMB/CIFS protocols) capabilities
    of Azure file storage. You can create Docker containers that can migrate from
    one host to another seamlessly or share volumes among multiple containers running
    on different hosts.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure文件存储的Docker卷驱动程序**：这是一个Docker卷驱动程序，它使用Azure文件存储将文件共享挂载到Docker容器作为卷。它使用Azure文件存储的网络文件共享（SMB/CIFS协议）功能。您可以创建可以在不同主机之间无缝迁移或在不同主机上运行的多个容器之间共享卷的Docker容器。'
- en: '**IPFS** : Open source volume plugin that allows the use of an IPFS filesystem
    as a volume. IPFS is a very interesting and promising storage system; it makes
    it possible to distribute high volumes of data with high efficiency. It provides
    deduplication, high performance, and clustered persistence, providing secure P2P
    content delivery, fast performance, and decentralized archiving. IPFS provides
    resilient access to data, independent of low latency or connectivity to the backbone.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IPFS**：开源卷插件，允许将IPFS文件系统用作卷。IPFS是一个非常有趣和有前途的存储系统；它可以以高效的方式分发大量数据。它提供了去重、高性能和集群持久性，提供安全的P2P内容传递、快速性能和去中心化的归档。IPFS提供了对数据的弹性访问，独立于低延迟或对骨干网的连接。'
- en: '**Keywhiz** : You can use this driver to make your container talk to a remote
    Keywhiz server. Keywhiz is a system for managing and distributing secret data,
    the same as TLS certificates/keys, GPG keys, API tokens, and database credentials.
    Instead of putting this data in config files or copying files (which is similarly
    to be leaked or difficult to track), Keywhiz makes managing it easier and more
    secure: Keywhiz servers in a cluster centrally store secrets encrypted in a database.
    Clients use **mutually authenticated TLS** (**mTLS** ) to retrieve secrets they
    have access to.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Keywhiz**：您可以使用此驱动程序使您的容器与远程Keywhiz服务器通信。Keywhiz是一个用于管理和分发秘密数据的系统，例如TLS证书/密钥、GPG密钥、API令牌和数据库凭据。Keywhiz使管理变得更容易和更安全：Keywhiz服务器在集群中将加密的秘密数据集中存储在数据库中。客户端使用**相互认证的TLS**（**mTLS**）来检索他们有权限访问的秘密。'
- en: As you can see from the previous examples, they are quite interesting, sometimes
    even exotic. Because of the extendable nature of Docker and its plugin architecture,
    you can create very flexible setups. But, third-party drivers do not always introduce
    completely new storage types; sometimes, they just extend the existing drivers.
    An example of that can be the Local Persist Plugin, a volume plugin that extends
    the default local driver's functionality by allowing you to specify a mount point
    anywhere on the host, which enables the files to always persist, even if the volume
    is removed via the `docker volume rm` command.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中可以看出，它们非常有趣，有时甚至是异国情调的。由于Docker及其插件架构的可扩展性，您可以创建非常灵活的设置。但是，第三方驱动程序并不总是引入全新的存储类型；有时它们只是扩展现有的驱动程序。一个例子就是Local
    Persist Plugin，它通过允许您在主机的任何位置指定挂载点来扩展默认的本地驱动程序功能，从而使文件始终持久存在，即使通过`docker volume
    rm`命令删除了卷。
- en: If you need a volume plugin that is not yet available, you can just write your
    own. The process is very well documented on Docker's GitHub page, together with
    extensible examples.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要一个尚未提供的卷插件，您可以自己编写。该过程在Docker的GitHub页面上有非常详细的文档，还有可扩展的示例。
- en: 'We''ve now covered how to open our containers to the external world. We can
    use networking and mounted volumes to be able to share data between containers
    and other hosts. Let''s summarize what we have learned so far in this chapter:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解了如何将我们的容器开放给外部世界。我们可以使用网络和挂载卷来在容器和其他主机之间共享数据。让我们总结一下我们在本章中学到的内容：
- en: We can use the network plugins to further extend the networking data exchange
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用网络插件来进一步扩展网络数据交换
- en: Volumes persist the data, even through container restarts
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷会持久保存数据，即使容器重新启动
- en: Changes to files on the volume are made directly, but they will not be included
    when you update an image
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对卷上的文件的更改是直接进行的，但在更新镜像时不会包括这些更改
- en: Data volumes persist even if the container itself is deleted
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据卷即使容器本身被删除也会持久存在
- en: Volumes allow of sharing data between the host filesystem and the Docker container,
    or between other Docker containers
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷允许在主机文件系统和Docker容器之间共享数据，或者在其他Docker容器之间共享数据
- en: We can use the volume drivers to further extend the file exchange possibilities
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用卷驱动程序来进一步扩展文件交换的可能性
- en: Containers from the same Docker host see each other automatically on the default
    bridge network.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 同一台Docker主机上的容器在默认的桥接网络上会自动看到彼此。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned about Docker networking and storage volume
    features. We know how to differentiate between various network types, how to create
    a network, and expose and map network ports.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Docker网络和存储卷功能。我们知道如何区分各种网络类型，如何创建网络，以及如何公开和映射网络端口。
- en: We've been through volume-related commands and can now create or remove a volume.
    In [Chapter 3](text00053.html) , *Working with Microservices* , we are going to
    focus on the software that we are going to deploy using Docker and Kubernetes,
    and later, Java microservices.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了与卷相关的命令，现在可以创建或删除卷。在[第3章](text00053.html) *使用微服务*中，我们将专注于使用Docker和Kubernetes部署的软件，以及后来的Java微服务。
