["```java\nint fibonacci(int k) {\n\u00a0\u00a0\u00a0\u00a0// base case\n\u00a0\u00a0\u00a0\u00a0if (k <= 1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return k;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// recursive call\n\u00a0\u00a0\u00a0\u00a0return fibonacci(k - 2) + fibonacci(k - 1);\n}\n```", "```java\nint fibonacci(int k) {\n\u00a0\u00a0\u00a0\u00a0if (k <= 1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return k;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return fibonacci(k - 2) + fibonacci(k - 1);\n}\n```", "```java\nint fibonacci(int k) {\n\u00a0\u00a0\u00a0\u00a0return fibonacci(k, new int[k + 1]);\n}\nint fibonacci(int k, int[] cache) {\n\u00a0\u00a0\u00a0\u00a0if (k <= 1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return k;\n\u00a0\u00a0\u00a0\u00a0} else if (cache[k] > 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return cache[k];\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0cache[k] = fibonacci(k - 2, cache) \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ fibonacci(k - 1, cache);\n\u00a0\u00a0\u00a0\u00a0return cache[k];\n}\n```", "```java\nint fibonacci(int k) {\n\u00a0\u00a0\u00a0\u00a0if (k <= 1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return k;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0int first = 1;\n\u00a0\u00a0\u00a0\u00a0int second = 0;\n\u00a0\u00a0\u00a0\u00a0int result = 0;\n\u00a0\u00a0\u00a0\u00a0for (int i = 1; i < k; i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = first + second;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0second = first;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0first = result;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return result;\n}\n```", "```java\npublic static boolean computePath(int m, int n, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0boolean[][] maze, Set<Point> path) {\n\u00a0\u00a0\u00a0\u00a0// we fell off the grid so we return\n\u00a0\u00a0\u00a0\u00a0if (m < 0 || n < 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// we cannot step at this cell\n\u00a0\u00a0\u00a0\u00a0if (maze[m][n]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// we reached the target \n\u00a0\u00a0\u00a0\u00a0// (this is the bottom-right corner)\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (((m == 0) && (n == 0))\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// or, try to go to the right\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|| computePath(m, n - 1, maze, path)\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// or, try to go to down\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|| computePath(m - 1, n, maze, path)) { \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// we add the cell to the path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path.add(new Point(m, n));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return false;\n}\n```", "```java\npublic static void moveDisks(int n, char origin, \n\u00a0\u00a0\u00a0\u00a0char target, char intermediate) {\n\u00a0\u00a0\u00a0\u00a0if (n <= 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0if (n == 1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.out.println(\"Move disk 1 from rod \" \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ origin + \" to rod \" + target);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// move top n - 1 disks from origin to intermediate, \n\u00a0\u00a0\u00a0\u00a0// using target as a intermediate\n\u00a0\u00a0\u00a0\u00a0moveDisks(n - 1, origin, intermediate, target);\n\u00a0\u00a0\u00a0\u00a0System.out.println(\"Move disk \" + n + \" from rod \" \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ origin + \" to rod \" + target);\n\u00a0\u00a0\u00a0\u00a0// move top n - 1 disks from intermediate to target, \n\u00a0\u00a0\u00a0\u00a0// using origin as an intermediate\n\u00a0\u00a0\u00a0\u00a0moveDisks(n - 1, intermediate, target, origin);\n}\n```", "```java\npublic static int josephus(int n, int k) {\n\u00a0\u00a0\u00a0\u00a0if (n == 1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 1;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return (josephus(n - 1, k) + k - 1) % n + 1;\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```java\npublic static void printJosephus(int n, int k) {\n\u00a0\u00a0\u00a0\u00a0Queue<Integer> circle = new ArrayDeque<>();\n\u00a0\u00a0\u00a0\u00a0for (int i = 1; i <= n; i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0circle.add(i);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0while (circle.size() != 1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int i = 1; i <= k; i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int eliminated = circle.poll();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (i == k) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.out.println(\"Eliminated: \" \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ eliminated);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0circle.add(eliminated);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0System.out.println(\"Using queue! Survivor: \" \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ circle.peek());\n}\n```", "```java\npublic class BiggestColorSpot {\n\u00a0\u00a0\u00a0\u00a0private int currentColorSpot;\n\u00a0\u00a0\u00a0\u00a0void determineBiggestColorSpot(int cols, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int rows, int a[][]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0...\n\u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0private void computeColorSpot(int i, int j, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int cols, int rows, int a[][], int color) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a[i][j] = -a[i][j];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentColorSpot++;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (i > 1 && a[i - 1][j] == color) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0computeColorSpot(i - 1, j, cols, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rows, a, color);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((i + 1) < rows && a[i + 1][j] == color) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0computeColorSpot(i + 1, j, cols, rows, a, color);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (j > 1 && a[i][j - 1] == color) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0computeColorSpot(i, j - 1, cols, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rows, a, color);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((j + 1) < cols && a[i][j + 1] == color) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0computeColorSpot(i, j + 1, cols, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rows, a, color);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```java\nvoid determineBiggestColorSpot(int cols, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int rows, int a[][]) {\n\u00a0\u00a0\u00a0\u00a0int biggestColorSpot = 0;\n\u00a0\u00a0\u00a0\u00a0int color = 0;\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < rows; i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int j = 0; j < cols; j++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (a[i][j] > 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentColorSpot = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0computeColorSpot(i, j, cols, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rows, a, a[i][j]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (currentColorSpot > biggestColorSpot) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0biggestColorSpot = currentColorSpot;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0color = a[i][j] * (-1);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0System.out.println(\"\\nColor: \" + color \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ \" Biggest spot: \" + biggestColorSpot);\n}\n```", "```java\npublic static int calculateChangeMemoization(int n) {\n\u00a0\u00a0\u00a0\u00a0int[] coins = {25, 10, 5, 1};\n\u00a0\u00a0\u00a0\u00a0int[][] cache = new int[n + 1][coins.length];\n\u00a0\u00a0\u00a0\u00a0return calculateChangeMemoization(n, coins, 0, cache);\n}\nprivate static int calculateChangeMemoization(int amount, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int[] coins, int position, int[][] cache) {\n\u00a0\u00a0\u00a0\u00a0if (cache[amount][position] > 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return cache[amount][position];\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0if (position >= coins.length - 1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 1;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0int coin = coins[position];\n\u00a0\u00a0\u00a0\u00a0int count = 0;\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i * coin <= amount; i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int remaining = amount - i * coin;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count += calculateChangeMemoization(remaining, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0coins, position + 1, cache);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0cache[amount][position] = count;\n\u00a0\u00a0\u00a0\u00a0return count;\n}\n```", "```java\nprotected static final int GRID_SIZE = 5; // (5x5)\npublic static void buildTowers(int row, Integer[] columns, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Set<Integer[]> solutions) {\n\u00a0\u00a0\u00a0\u00a0if (row == GRID_SIZE) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0solutions.add(columns.clone());\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int col = 0; col < GRID_SIZE; col++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (canBuild(columns, row, col)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// build this tower\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0columns[row] = col;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// go to the next row\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0buildTowers(row + 1, columns, solutions);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n}\nprivate static boolean canBuild(Integer[] columns, \n\u00a0\u00a0\u00a0\u00a0int nextRow, int nextColumn) {\n\u00a0\u00a0\u00a0\u00a0for (int currentRow=0; currentRow<nextRow; \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentRow++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int currentColumn = columns[currentRow];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// cannot build on the same column\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (currentColumn == nextColumn) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int columnsDistance\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= Math.abs(currentColumn - nextColumn);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int rowsDistance = nextRow - currentRow;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// cannot build on the same diagonal\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (columnsDistance == rowsDistance) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return true;\n}\n```", "```java\npublic static int find(int[] arr) {\n\u00a0\u00a0\u00a0\u00a0return find(arr, 0, arr.length - 1);\n}\nprivate static int find(int[] arr, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int startIndex, int endIndex) {\n\u00a0\u00a0\u00a0\u00a0if (startIndex > endIndex) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1; // return an invalid index\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// halved the indexes\n\u00a0\u00a0\u00a0\u00a0int middleIndex = (startIndex + endIndex) / 2;\n\u00a0\u00a0\u00a0\u00a0// value (element) of middle index\n\u00a0\u00a0\u00a0\u00a0int value = arr[middleIndex];\n\u00a0\u00a0\u00a0\u00a0// check if this is a magic index\n\u00a0\u00a0\u00a0\u00a0if (value == middleIndex) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return middleIndex;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// search from middle of the array to the left\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0int leftIndex = find(arr, startIndex, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Math.min(middleIndex - 1, value));\n\u00a0\u00a0\u00a0\u00a0if (leftIndex >= 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return leftIndex;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// search from middle of the array to the right\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return find(arr,\u00a0\u00a0Math.max(middleIndex + 1, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value), endIndex);\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```java\nfor (int i = 0; i < rows; i++) {\n\u00a0\u00a0\u00a0\u00a0for (int j = 0; j < cols; j++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.out.format(\"%2s\", elevations[i][j]);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0System.out.println();\n}\n```", "```java\npublic static void computePath(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int prevElevation, int i, int j, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int rows, int cols, int[][] elevations) {\n\u00a0\u00a0\u00a0\u00a0// ensure the ball is still on the grid\n\u00a0\u00a0\u00a0\u00a0if (i >= 0 && i <= (rows-1) && j >= 0 && j <= (cols-1)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int currentElevation = elevations[i][j];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// check if the ball can fall\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (prevElevation >= currentElevation\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& currentElevation > 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// store the current elevation\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0prevElevation = currentElevation;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// mark this cell as visited\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0elevations[i][j] = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// try to move the ball \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0computePath(prevElevation,i,j-1,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rows,cols,elevations);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0computePath(prevElevation,i-1,\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j,rows,cols,elevations);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0computePath(prevElevation,i,j+1,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rows,cols,elevations);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0computePath(prevElevation,i+1,j,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rows,cols,elevations);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```java\n// Memoization\npublic static int buildViaMemoization(List<Box> boxes) {\n\u00a0\u00a0\u00a0\u00a0// sorting boxes by width (you can do it by height as well)\n\u00a0\u00a0\u00a0\u00a0Collections.sort(boxes, new Comparator<Box>() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0@Override\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0public int compare(Box b1, Box b2) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return Integer.compare(b2.getWidth(), \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0b1.getWidth());\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0});\n\u00a0\u00a0\u00a0\u00a0// place each box as the base (bottom box) and\n\u00a0\u00a0\u00a0\u00a0// try to arrange the rest of the boxes\n\u00a0\u00a0\u00a0\u00a0int highest = 0;\n\u00a0\u00a0\u00a0\u00a0int[] cache = new int[boxes.size()];\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < boxes.size(); i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int height = buildMemoization(boxes, i, cache);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0highest = Math.max(highest, height);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return highest;\n}\n// Memoization\nprivate static int buildMemoization(List<Box> boxes, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int base, int[] cache) {\n\u00a0\u00a0\u00a0\u00a0if (base < boxes.size() && cache[base] > 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return cache[base];\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0Box current = boxes.get(base);\n\u00a0\u00a0\u00a0\u00a0int highest = 0;\n\u00a0\u00a0\u00a0\u00a0// since the boxes are sorted we don\u2019t \n\u00a0\u00a0\u00a0\u00a0// look in [0, base + 1)\n\u00a0\u00a0\u00a0\u00a0for (int i = base + 1; i < boxes.size(); i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (boxes.get(i).canBeNext(current)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int height = buildMemoization(boxes, i, cache);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0highest = Math.max(height, highest);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0highest = highest + current.getHeight();\n\u00a0\u00a0\u00a0\u00a0cache[base] = highest;\n\u00a0\u00a0\u00a0\u00a0return highest;\n}\n```", "```java\npublic static Set<String> permute(String str) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return permute(\"\", str);\n}\nprivate static Set<String> permute(String prefix, String str) {\n\u00a0\u00a0\u00a0\u00a0Set<String> permutations = new HashSet<>();\n\u00a0\u00a0\u00a0\u00a0int n = str.length();\n\u00a0\u00a0\u00a0\u00a0if (n == 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0permutations.add(prefix);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < n; i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0permutations.addAll(permute(prefix + str.charAt(i),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0str.substring(i + 1, n) + str.substring(0, i)));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return permutations;\n}\n```", "```java\nprivate static Map<Character, Integer> charactersMap(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0String str) {\n\u00a0\u00a0\u00a0\u00a0Map<Character, Integer> characters = new HashMap<>();\n\u00a0\u00a0\u00a0\u00a0BiFunction<Character, Integer, Integer> count = (k, v)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-> ((v == null) ? 1 : ++v);\n\u00a0\u00a0\u00a0\u00a0for (char c : str.toCharArray()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0characters.compute(c, count);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return characters;\n}\n```", "```java\npublic static List<String> permute(String str) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return permute(\"\", str.length(), charactersMap(str));\n}\nprivate static List<String> permute(String prefix, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int strlength, Map<Character, Integer> characters) {\n\u00a0\u00a0\u00a0\u00a0List<String> permutations = new ArrayList<>();\n\u00a0\u00a0\u00a0\u00a0if (strlength == 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0permutations.add(prefix);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// fetch next char and generate remaining permutations\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (Character c : characters.keySet()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int count = characters.get(c);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (count > 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0characters.put(c, count - 1);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0permutations.addAll(permute(prefix + c, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0strlength - 1, characters));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0characters.put(c, count);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return permutations;\n}\n```", "```java\npublic class KnightTour {\n\u00a0\u00a0\u00a0\u00a0private final int n;\n\u00a0\u00a0\u00a0\u00a0// constructor omitted for brevity\n\u00a0\u00a0\u00a0\u00a0// all 8 possible movements for a knight\n\u00a0\u00a0\u00a0\u00a0public static final int COL[] \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= {1,2,2,1,-1,-2,-2,-1,1};\n\u00a0\u00a0\u00a0\u00a0public static final int ROW[] \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= {2,1,-1,-2,-2,-1,1,2,2};\n\u00a0\u00a0\u00a0\u00a0public void knightTour(int r, int c, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int cell, int visited[][]) {\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// mark current cell as visited\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited[r][c] = cell;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// we have a solution\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (cell >= n * n) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(visited);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// backtrack before returning\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited[r][c] = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// check for all possible movements (8) \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// and recur for each valid movement\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < (ROW.length - 1); i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int newR = r + ROW[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int newC = c + COL[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// check if the new position is valid un-visited\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (isValid(newR, newC) \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& visited[newR][newC] == 0) { \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0knightTour(newR, newC, cell + 1, visited);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// backtrack from current cell\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// and remove it from current path\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited[r][c] = 0;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// check if (r, c) is valid chess board coordinates\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0private boolean isValid(int r, int c) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return !(r < 0 || c < 0 || r >= n || c >= n);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// print the solution as a board\n\u00a0\u00a0\u00a0\u00a0private void print(int[][] visited) {\n\u00a0\u00a0\u00a0\u00a0...\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```java\npublic static List<String> embrace(int nr) {\n\u00a0\u00a0\u00a0\u00a0List<String> results = new ArrayList<>();\n\u00a0\u00a0\u00a0\u00a0embrace(nr, nr, new char[nr * 2], 0, results);\n\u00a0\u00a0\u00a0\u00a0return results;\n}\nprivate static void embrace(int leftHand, int rightHand, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0char[] str, int index, List<String> results) {\n\u00a0\u00a0\u00a0\u00a0if (rightHand < leftHand || leftHand < 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0if (leftHand == 0 && rightHand == 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// result found, so store it\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0results.add(String.valueOf(str));\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// add left brace\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0str[index] = '{';\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0embrace(leftHand - 1, rightHand, str, index + 1, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0results);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// add right brace\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0str[index] = '}';\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0embrace(leftHand, rightHand - 1, str, index + 1, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0results);\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```java\npublic static int countViaMemoization(int n) {\n\u00a0\u00a0\u00a0\u00a0int[] cache = new int[n + 1];\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0return count(n, cache);\n}\nprivate static int count(int n, int[] cache) {\n\u00a0\u00a0\u00a0\u00a0if (n == 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 1;\n\u00a0\u00a0\u00a0\u00a0} else if (n < 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0;\n\u00a0\u00a0\u00a0\u00a0} else if (cache[n] > 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return cache[n];\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0cache[n] = count(n - 1, cache) \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ count(n - 2, cache) + count(n - 3, cache);\n\u00a0\u00a0\u00a0\u00a0return cache[n];\n}\n```", "```java\n/* Recursive approach */\npublic static void findSumRecursive(int[] arr, int index,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int currentSum, int givenSum, int[] subset) {\n\u00a0\u00a0\u00a0\u00a0if (currentSum == givenSum) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.out.print(\"\\nSubset found: \");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < subset.length; i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (subset[i] == 1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.out.print(arr[i] + \" \");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0} else if (index != arr.length) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subset[index] = 1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentSum += arr[index];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0findSumRecursive(arr, index + 1, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentSum, givenSum, subset);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentSum -= arr[index];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subset[index] = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0findSumRecursive(arr, index + 1, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentSum, givenSum, subset);\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```java\n/* Dynamic Programming (Bottom-Up) */\npublic static boolean findSumDP(int[] arr, int givenSum) {\n\u00a0\u00a0\u00a0\u00a0boolean[][] matrix \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= new boolean[arr.length + 1][givenSum + 1];\n\u00a0\u00a0\u00a0\u00a0// prepare the first row\n\u00a0\u00a0\u00a0\u00a0for (int i = 1; i <= givenSum; i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0matrix[0][i] = false;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// prepare the first column\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i <= arr.length; i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0matrix[i][0] = true;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0for (int i = 1; i <= arr.length; i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int j = 1; j <= givenSum; j++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// first, copy the data from the above row\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0matrix[i][j] = matrix[i - 1][j];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// if matrix[i][j] = false compute \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// if the value should be F or T\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (matrix[i][j] == false && j >= arr[i \u2013 1]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0matrix[i][j] = matrix[i][j] \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|| matrix[i - 1][j - arr[i - 1]];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0printSubsetMatrix(arr, givenSum, matrix);\n\u00a0\u00a0\u00a0\u00a0printOneSubset(matrix, arr, arr.length, givenSum);\n\u00a0\u00a0\u00a0\u00a0return matrix[arr.length][givenSum];\n}\n```", "```java\nprivate static boolean breakItPlainRecursive(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Set<String> dictionary, String str, int index) {\n\u00a0\u00a0\u00a0\u00a0if (index == str.length()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0boolean canBreak = false;\n\u00a0\u00a0\u00a0\u00a0for (int i = index; i < str.length(); i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0canBreak = canBreak\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|| dictionary.contains(str.substring(index, i + 1))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& breakItPlainRecursive(dictionary, str, i + 1);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return canBreak;\n}\n```", "```java\npublic static boolean breakItBottomUp(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Set<String> dictionary, String str) {\n\u00a0\u00a0boolean[] table = new boolean[str.length() + 1];\n\u00a0\u00a0table[0] = true;\n\u00a0\u00a0for (int i = 0; i < str.length(); i++) {\n\u00a0\u00a0\u00a0\u00a0for (int j = i + 1; table[i] && j <= str.length(); j++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (dictionary.contains(str.substring(i, j))) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0table[j] = true;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return table[str.length()];\n}\n```", "```java\npublic class Trie {\n\u00a0\u00a0\u00a0\u00a0// characters 'a'-'z'\n\u00a0\u00a0\u00a0\u00a0private static final int CHAR_SIZE = 26;\n\u00a0\u00a0\u00a0\u00a0private final Node head;\n\u00a0\u00a0\u00a0\u00a0public Trie() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0this.head = new Node();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// Trie node\n\u00a0\u00a0\u00a0\u00a0private static class Node {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0private boolean leaf;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0private final Node[] next;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0private Node() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0this.leaf = false;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0this.next = new Node[CHAR_SIZE];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0};\n\u00a0\u00a0\u00a0\u00a0// insert a string in Trie\n\u00a0\u00a0\u00a0\u00a0public void insertTrie(String str) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Node node = head;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < str.length(); i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (node.next[str.charAt(i) - 'a'] == null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.next[str.charAt(i) - 'a'] = new Node();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node = node.next[str.charAt(i) - 'a'];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.leaf = true;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// Method to determine if the given string can be \n\u00a0\u00a0\u00a0\u00a0// segmented into a space-separated sequence of one or \n\u00a0\u00a0\u00a0\u00a0// more dictionary words\n\u00a0\u00a0\u00a0\u00a0public boolean breakIt(String str) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// table[i] is true if the first i\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// characters of str can be segmented\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0boolean[] table = new boolean[str.length() + 1];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0table[0] = true;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < str.length(); i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (table[i]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Node node = head;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int j = i; j < str.length(); j++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (node == null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node = node.next[str.charAt(j) - 'a'];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// [0, i]: use our known decomposition\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// [i+1, j]: use this String in the Trie\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (node != null && node.leaf) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0table[j + 1] = true;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// table[n] would be true if \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// all characters of str can be segmented\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return table[str.length()];\n\u00a0\u00a0\u00a0\u00a0}\n}\n```"]