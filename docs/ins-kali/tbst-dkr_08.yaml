- en: Chapter 8. Managing Docker Containers with Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。使用Kubernetes管理Docker容器
- en: In the previous chapter, we learned about Docker networking and how to troubleshoot
    networking issues. In this chapter, we will introduce Kubernetes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了Docker网络和如何解决网络问题。在本章中，我们将介绍Kubernetes。
- en: Kubernetes is a container-cluster management tool. Currently, it supports Docker
    and Rocket. It is an open-sourced project by Google and it was launched in June
    2014 at Google I/O. It supports deployment on various cloud providers, such as GCE,
    Azure, AWS, vSphere, and Bare Metal. The Kubernetes manager is lean, portable,
    extensible, and self-healing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是一个容器集群管理工具。目前，它支持Docker和Rocket。这是谷歌的一个开源项目，于2014年6月在Google I/O上发布。它支持在各种云提供商上部署，如GCE、Azure、AWS、vSphere和裸机。Kubernetes管理器是精简的、可移植的、可扩展的和自愈的。
- en: 'In this chapter, we will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: An introduction to Kubernetes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes简介
- en: Deploying Kubernetes on Bare Metal
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在裸机上部署Kubernetes
- en: Deploying Kubernetes on Minikube
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Minikube上部署Kubernetes
- en: Deploying Kubernetes on AWS and vSphere
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在AWS和vSphere上部署Kubernetes
- en: Deploying a pod
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署一个pod
- en: Deploying Kubernetes in a production environment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生产环境中部署Kubernetes
- en: Debugging Kubernetes issues
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试Kubernetes问题
- en: 'Kubernetes has various important components, as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes有各种重要组件，如下：
- en: '**Node**: This is a physical or virtual machine that is part of a Kubernetes
    cluster, running the Kubernetes and Docker services, onto which pods can be scheduled.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**：这是Kubernetes集群的一部分的物理或虚拟机，运行Kubernetes和Docker服务，可以在其上调度pod。'
- en: '**Master**: This maintains the runtime state of Kubernetes'' server runtime.
    It is the point of entry for all the client calls to configure and manage Kubernetes
    components.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主节点**：这个节点维护Kubernetes服务器运行时的运行状态。这是所有客户端调用配置和管理Kubernetes组件的入口点。'
- en: '**Kubectl**: This is the command-line tool used to interact with the Kubernetes
    cluster to provide master access to Kubernetes APIs. Through it, the user can
    deploy, delete, and list pods.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubectl**：这是用于与Kubernetes集群交互以提供对Kubernetes API的主访问权限的命令行工具。通过它，用户可以部署、删除和列出pod。'
- en: '**Pod**: This is the smallest scheduling unit in Kubernetes. It is a collection
    of Docker containers that share volumes and don''t have port conflicts. It can
    be created by defining a simple JSON file.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod**：这是Kubernetes中最小的调度单元。它是一组共享卷并且没有端口冲突的Docker容器集合。可以通过定义一个简单的JSON文件来创建它。'
- en: '**Replication controller**: This manages the lifecycle of the pod and ensures
    that the specified number of pods are running at any given time by creating or
    killing pods as required.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制控制器**：这个控制pod的生命周期，并确保在任何给定时间运行指定数量的pod，通过根据需要创建或销毁pod。'
- en: '**Label**: Labels are used to identify and organize pods and services based
    on key-value pairs:![Managing Docker Containers with Kubernetes](graphics/image_08_001.jpg)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**：标签用于基于键值对标识和组织pod和服务：![使用Kubernetes管理Docker容器](graphics/image_08_001.jpg)'
- en: Kubernetes master/minion flow
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes主/从流程
- en: Deploying Kubernetes on Bare Metal machine
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在裸机上部署Kubernetes
- en: 'Kubernetes can be deployed on the Bare Metal Fedora or Ubuntu machines. Even
    the Fedora and Ubuntu virtual machine can be deployed in vSphere, workstation,
    or VirtualBox. For the following tutorial, we''ll be looking at Kubernetes deployment
    on a single Fedora 24 machine, which will be acting as master, as well as node
    to deploy `k8s` pods:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes可以部署在裸机Fedora或Ubuntu机器上。甚至Fedora和Ubuntu虚拟机可以部署在vSphere、工作站或VirtualBox上。在以下教程中，我们将介绍在单个Fedora
    24机器上部署Kubernetes，该机器将充当主节点，以及部署`k8s` pod的节点：
- en: 'Enable the Kubernetes testing YUM repository:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用Kubernetes测试YUM仓库：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Install `etcd` and `iptables-services`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`etcd`和`iptables-services`：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In `/etcd/hosts`, set the Fedora master and Fedora node:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/etcd/hosts`中，设置Fedora主节点和Fedora节点：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Disable the firewall and `iptables-services`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用防火墙和`iptables-services`：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Edit the `/etcd/kubernetes/config` file:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`/etcd/kubernetes/config`文件：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Edit the contents of the `/etc/kubernetes/apiserver` file:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`/etc/kubernetes/apiserver`文件的内容：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `/etc/etcd/etcd.conf` file should have the following line uncommented in
    order to listen on port `2379`, as Fedora 24 uses etcd 2.0:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/etc/etcd/etcd.conf`文件应该取消注释以下行，以便在端口`2379`上进行监听，因为Fedora 24使用etcd 2.0：'
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**The Kubernetes node setup can be done on separate hosts, but we will be setting
    them on the current machine in order to have the Kubernetes master and node configured
    on the same machine:**'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Kubernetes节点设置可以在单独的主机上完成，但我们将在当前机器上设置它们，以便在同一台机器上配置Kubernetes主节点和节点：**'
- en: '**Edit the file `/etcd/kubernetes/kubelet` as follows:**'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编辑`/etcd/kubernetes/kubelet`文件如下：**'
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a shell script to start all the Kubernetes master and node services
    on the same machine:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个shell脚本在同一台机器上启动所有Kubernetes主节点和节点服务：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a `node.json` file to configure it on the Kubernetes machine:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kubernetes机器上创建一个`node.json`文件来配置它：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a node object using the following command:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个节点对象：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After some time, node should be ready to deploy pods:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一段时间后，节点应该准备好部署pod：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Troubleshooting the Kubernetes Fedora manual setup
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除Kubernetes Fedora手动设置
- en: If the kube-apiserver fails to start, it might be due to service account admission
    control and require a service account and a token before allowing pods to be scheduled.
    It is generated automatically by the controller. By default, the API server uses
    a TLS serving key, but as we are not sending over HTTPS and don't have a TLS server
    key, we can provide the API server the same key file in order for the API server
    to validate generated service-account tokens.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果kube-apiserver启动失败，可能是由于服务账户准入控制，需要在允许调度pod之前提供服务账户和令牌。它会被控制器自动生成。默认情况下，API服务器使用TLS服务密钥，但由于我们不是通过HTTPS发送数据，也没有TLS服务器密钥，我们可以提供相同的密钥文件给API服务器，以便API服务器验证生成的服务账户令牌。
- en: 'Use the following to generate the key and add it to the `k8s` cluster:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下内容生成密钥并将其添加到`k8s`集群中：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To start the API server, add the following option to the end of the `/etc/kubernetes/apiserver`
    file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动API服务器，在`/etc/kubernetes/apiserver`文件的末尾添加以下选项：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`/etc/kubernetes/kube-controller-manager` add the following option to the end
    of the file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/etc/kubernetes/kube-controller-manager`文件的末尾添加以下选项：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Restart the cluster using the `start_k8s.sh` shell script.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`start_k8s.sh` shell脚本重新启动集群。
- en: Deploying Kubernetes using Minikube
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Minikube部署Kubernetes
- en: Minikube is still in development; it is a tool that makes it easy to run Kubernetes
    locally, optimized for the underlying OS (MAC/Linux). It runs a single-node Kubernetes
    cluster inside a VM. Minikube helps developers to learn Kubernetes and do day-to-day
    development and testing with ease.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube仍在开发中；它是一个工具，可以方便地在本地运行Kubernetes，针对底层操作系统进行了优化（MAC/Linux）。它在虚拟机内运行单节点Kubernetes集群。Minikube帮助开发人员学习Kubernetes，并轻松进行日常开发和测试。
- en: 'The following setup will cover Minikube setup on Mac OS X, as very few guides
    are present to deploy Kubernetes on Mac:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下设置将涵盖Mac OS X上的Minikube设置，因为很少有指南可以部署Kubernetes在Mac上：
- en: 'Download the Minikube binary:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载Minikube二进制文件：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Grant execute permission to the binary:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授予二进制文件执行权限：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Move the Minikube binary to `/usr/local/bin` so that it gets added to the path
    and can be executed directly on the terminal:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Minikube二进制文件移动到`/usr/local/bin`，以便将其添加到路径并可以直接在终端上执行：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After this, we''ll require the `kubectl` client binary to run commands against
    the single-node Kubernetes cluster, for Mac OS X:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将需要`kubectl`客户端二进制文件来针对Mac OS X运行命令单节点Kubernetes集群：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The kubectl is now configured to be used with the cluster.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已配置kubectl以与集群一起使用。
- en: 'Set up Minikube to deploy a VM locally and configure the Kubernetes cluster:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置Minikube以在本地部署VM并配置Kubernetes集群：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can set up kubectl to use a Minikube context, and switch later if required:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以设置kubectl以使用Minikube上下文，并在需要时进行切换：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''ll be able to list the node of the Kubernetes cluster:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将能够列出Kubernetes集群的节点：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a `hello-minikube` pod and expose it as a service:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`hello-minikube` pod并将其公开为服务：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can get the `hello-minikube` pod status using the following command:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令获取`hello-minikube` pod的状态：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can open the Kubernetes dashboard using the following command and view details
    of the deployed pod:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令打开Kubernetes仪表板并查看部署的pod的详细信息：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![Deploying Kubernetes using Minikube](graphics/image_08_002.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![使用Minikube部署Kubernetes](graphics/image_08_002.jpg)'
- en: Kubernetes UI showcasing hello-minikube pod
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 展示hello-minikube pod的Kubernetes UI
- en: Deploying Kubernetes on AWS
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWS上部署Kubernetes
- en: Let's get started with Kubernetes cluster deployment on AWS, which can be done
    by using the configuration file already existing in the Kubernetes codebase.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始在AWS上部署Kubernetes集群，可以使用Kubernetes代码库中已经存在的配置文件来完成。
- en: Log in to AWS console ([http://aws.amazon.com/console/](http://aws.amazon.com/console/))
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到AWS控制台（[http://aws.amazon.com/console/](http://aws.amazon.com/console/)）
- en: Open the IAM console ([https://console.aws.amazon.com/iam/home?#home](https://console.aws.amazon.com/iam/home?))
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开IAM控制台（[https://console.aws.amazon.com/iam/home?#home](https://console.aws.amazon.com/iam/home?))
- en: Choose the IAM username, select the **Security Credentials** tab, and click
    the **Create Access Key** option.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择IAM用户名，选择**安全凭据**选项卡，然后单击**创建访问密钥**选项。
- en: After the keys are created, download them and keep them in a secure place. The
    downloaded CSV file will contain the access key ID and the secret access key,
    which will be used to configure the AWS CLI.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建密钥后，下载并保存在安全的位置。下载的CSV文件将包含访问密钥ID和秘密访问密钥，这将用于配置AWS CLI。
- en: 'Install and configure the AWS command-line interface. In this example, we have
    installed AWS CLI on Linux using the following command:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装和配置AWS命令行界面。在本例中，我们使用以下命令在Linux上安装了AWS CLI：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In order to configure the AWS-CLI, use the following command:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了配置AWS-CLI，请使用以下命令：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After the configuration of the AWS CLI, we will create a profile and attach
    a role to it with full access to S3 and EC2.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置AWS CLI后，我们将创建一个配置文件，并附加一个具有对S3和EC2的完全访问权限的角色。
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The role can be attached above the profile, which will have complete EC2 and
    S3 access, as shown in the following screenshot. The role can be created separately
    using the console or AWS CLI with the JSON file, which will define the permissions
    the role can have:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 角色可以附加到上述配置文件，该配置文件将具有完全的EC2和S3访问权限，如下面的屏幕截图所示。可以使用控制台或AWS CLI单独创建角色，并使用JSON文件定义角色可以具有的权限：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![Deploying Kubernetes on AWS](graphics/image_08_003.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![在AWS上部署Kubernetes](graphics/image_08_003.jpg)'
- en: Attach policy in AWS during Kubernetes deployment
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes部署期间在AWS中附加策略
- en: 'After the role is created, it can be attached to the policy using the following
    command:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建角色后，可以使用以下命令将其附加到策略：
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The script uses the default profile; we can change it as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本使用默认配置文件；我们可以按以下方式更改它：
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The Kubernetes cluster can be easily deployed using one command, as follows;
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes集群可以使用一个命令轻松部署，如下所示；
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding command will call `kube-up.sh` and, in turn, the `utils.sh` using
    the `config-default.sh` script, which contains the basic configuration of the
    `k8s` cluster with four nodes, as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述命令将调用`kube-up.sh`，然后使用`config-default.sh`脚本调用`utils.sh`，该脚本包含具有四个节点的`k8s`集群的基本配置，如下所示：
- en: '[PRE32]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The instances are `**t2.micro**` running on Ubuntu. The process takes five to
    ten minutes, after which the IP address of the master and minions gets listed
    and can be used to access the Kubernetes cluster.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些实例是在Ubuntu上运行的“t2.micro”。该过程需要五到十分钟，之后主节点和从节点的IP地址将被列出，并可用于访问Kubernetes集群。
- en: Deploying Kubernetes on vSphere
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在vSphere上部署Kubernetes
- en: 'Kubernetes can be installed on vSphere with the help of `govc` (a vSphere CLI
    built on top of govmomi):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`govc`（基于govmomi构建的vSphere CLI）在vSphere上安装Kubernetes：
- en: 'Before starting the setup, we''ll have to install golang, which can be done
    in the following way on a Linux machine:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始设置之前，我们需要在Linux机器上安装golang，可以按以下方式进行：
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Set the go path:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置go路径：
- en: '[PRE34]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Download the pre-built Debian VMDK, which will be used to create the Kubernetes
    cluster on vSphere:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载预构建的Debian VMDK，该VMDK将用于在vSphere上创建Kubernetes集群：
- en: '[PRE35]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Kubernetes setup troubleshooting
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes设置故障排除
- en: 'We need to set up the proper environment variables to connect remotely to the
    ESX server to deploy the Kubernetes cluster. The following environment variables
    should be set in order to progress with Kubernetes setup on vSphere:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置适当的环境变量以远程连接到ESX服务器以部署Kubernetes集群。为了在vSphere上进行Kubernetes设置，应设置以下环境变量：
- en: '[PRE36]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use ESX and vSphere version v5.5 for this tutorial.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程使用ESX和vSphere版本v5.5。
- en: 'Upload the `kube.vmdk` to the ESX datastore. The VMDK will be stored in the
    `kube` directory, which will get created by the following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将“kube.vmdk”上传到ESX数据存储。VMDK将存储在由以下命令创建的“kube”目录中：
- en: '[PRE37]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Set up the Kubernetes provider as vSphere, as well the Kubernetes cluster,
    which will get deployed on the ESX. This will contain one Kubernetes master and
    four Kubernetes minion derived from the expanded `kube.vmdk` uploaded in the datastore:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将Kubernetes提供程序设置为vSphere，同时在ESX上部署Kubernetes集群。这将包含一个Kubernetes主节点和四个Kubernetes从节点，这些从节点是从上传到数据存储中的扩展的“kube.vmdk”派生出来的：
- en: '[PRE38]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This will display a list of IP addresses for the four VMs. If you are currently
    developing Kubernetes, you can use this cluster-deployment mechanism to test out
    the new code in the following way:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示四个VM的IP地址列表。如果您目前正在开发Kubernetes，可以使用此集群部署机制以以下方式测试新代码：
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The cluster can be brought down using the following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令关闭集群：
- en: '[PRE40]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![Kubernetes setup troubleshooting](graphics/image_08_004.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Kubernetes设置故障排除](graphics/image_08_004.jpg)'
- en: Kubernetes master/node deployed on vSphere
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在vSphere上部署的Kubernetes主节点/从节点
- en: Kubernetes pod deployment
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes pod部署
- en: 'Now, in the following example, we will be deploying two NGINX replication pods
    (rc-pod) and exposing them via a service. To understand Kubernetes networking,
    please refer to the following diagram for more details. Here, an application can
    be exposed via a virtual IP address, and the request to be proxied, to which replica
    of pod (load balancer), is taken care of by the service:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在以下示例中，我们将部署两个NGINX复制pod（rc-pod）并通过服务公开它们。要了解Kubernetes网络，请参考以下图表以获取更多详细信息。在这里，应用程序可以通过虚拟IP地址公开，并且服务会代理请求，负载均衡到pod的副本：
- en: '![Kubernetes pod deployment](graphics/image_08_005.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![Kubernetes pod deployment](graphics/image_08_005.jpg)'
- en: Kubernetes networking with OVS bridge
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OVS桥的Kubernetes网络
- en: 'In the Kubernetes master, create a new folder:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kubernetes主节点上，创建一个新文件夹：
- en: '[PRE41]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create the YAML file in the editor of your choice, which will be used to deploy
    the NGINX pod:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您选择的编辑器中创建YAML文件，该文件将用于部署NGINX pod：
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Create the NGINX pod using `kubectl:`
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl`创建NGINX pod：
- en: '[PRE43]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the preceding pod creation process, we have created two replicas of the
    NGINX pod, and its details can be listed as shown here:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的pod创建过程中，我们创建了两个NGINX pod的副本，其详细信息如下所示：
- en: '[PRE44]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The container on the deployed minion can be listed as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以列出部署的minion上的容器如下：
- en: '[PRE45]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Deploy the NGINX service using a YAML file in order to expose the NGINX pod
    on host port `82`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用YAML文件部署NGINX服务，以便在主机端口`82`上暴露NGINX pod：
- en: '[PRE46]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Create the NGINX service using `kubectl:`
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl`创建NGINX服务：
- en: '[PRE47]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The NGINX service can be listed as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以列出NGINX服务如下：
- en: '[PRE48]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now the NGINX server test page via service can be accessed on the following
    URL: `http://192.168.3.43:82`'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以通过以下URL访问通过服务访问的NGINX服务器测试页面：`http://192.168.3.43:82`
- en: Deploying Kubernetes in a production environment
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在生产环境中部署Kubernetes
- en: In this section, we'll be covering some of the important points and concepts
    that can be used to deploy Kubernetes in production.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些可以用于在生产环境中部署Kubernetes的重要要点和概念。
- en: '**Exposing Kubernetes services**: Once we deploy the Kubernetes pods, we expose
    them using services. The Kubernetes service is an abstraction, which defines a
    set of pods and a policy to expose them as a microservice. The service gets its
    own IP address, but the catch is that this address only exists within the Kubernetes
    cluster, which means the service is not exposed to the Internet. It''s possible
    to expose the service directly on the host machine port, but once we expose the
    service on the host machine, we get into port conflicts. It also voids Kubernetes
    benefits and makes it harder to scale the deployed service:![Deploying Kubernetes
    in a production environment](graphics/image_08_006.jpg)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暴露Kubernetes服务**：一旦我们部署了Kubernetes pod，我们就使用服务来暴露它们。Kubernetes服务是一个抽象，它定义了一组pod和一种将它们作为微服务暴露的策略。服务有自己的IP地址，但问题是这个地址只存在于Kubernetes集群内，这意味着服务不会暴露到互联网上。可以直接在主机机器端口上暴露服务，但一旦在主机机器上暴露服务，就会出现端口冲突。这也会使Kubernetes的优势失效，并且使部署的服务难以扩展：![在生产环境中部署Kubernetes](graphics/image_08_006.jpg)'
- en: Kubernetes service exposed through external load balancer
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes服务通过外部负载均衡器暴露
- en: 'One solution is to add an external load balancer such as HAProxy or NGINX.
    This is configured with a backend for each Kubernetes service and proxies traffic
    to individual pods. Similar to AWS deployment, a Kubernetes cluster can be deployed
    inside a VPN and an AWS external load balancer can be used to expose each Kubernetes
    service:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案是添加外部负载均衡器，如HAProxy或NGINX。这是为每个Kubernetes服务配置一个后端，并将流量代理到各个pod。类似于AWS部署，可以在VPN内部部署Kubernetes集群，并使用AWS外部负载均衡器来暴露每个Kubernetes服务：
- en: '**Support upgrade scenarios in Kubernetes**: In the case of an upgrade scenario,
    we need to have zero downtime. Kubernetes'' external load balancer helps to achieve
    this functionality in cases of service deployment through Kubernetes. We can start
    a replica cluster running the new version of the service, and the older cluster
    version will serve the live requests. As and when the new service is ready, the
    load balancer can be configured to switch load to the new version. By using this
    approach, we can support a zero-runtime upgrade scenario for enterprise products:![Deploying
    Kubernetes in a production environment](graphics/image_08_007.jpg)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持Kubernetes中的升级场景**：在升级场景中，我们需要实现零停机。Kubernetes的外部负载均衡器有助于在通过Kubernetes部署服务的情况下实现这种功能。我们可以启动一个运行新版本服务的副本集群，旧的集群版本将为实时请求提供服务。一旦新服务准备就绪，负载均衡器可以配置为将负载切换到新版本。通过使用这种方法，我们可以支持企业产品的零运行时升级场景：![在生产环境中部署Kubernetes](graphics/image_08_007.jpg)'
- en: Upgrade scenarios supported in Kubernetes deployment
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes部署中支持的升级场景
- en: '**Make the Kubernetes-based application deployment automatic**: With the help
    of a deployer, we can automate the process of testing, as well as deploying the
    Docker containers in production. In order to do so, we need to have a build pipeline
    and deployer, which pushes the Docker image to a registry such as Docker Hub after
    successful build. Then, the deployer will take care of deploying the test environment
    and invoke the test scripts. After successful testing, the deployer can also take
    care of deploying the service in the Kubernetes production environment:![Deploying
    Kubernetes in a production environment](graphics/image_08_008.jpg)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使基于 Kubernetes 的应用部署自动化**：借助部署工具，我们可以自动化测试和在生产环境中部署 Docker 容器的过程。为此，我们需要构建流水线和部署工具，在成功构建后将
    Docker 镜像推送到 Docker Hub 这样的注册表。然后，部署工具将负责部署测试环境并调用测试脚本。在成功测试后，部署工具还可以负责在 Kubernetes
    生产环境中部署服务。'
- en: Kubernetes application deployment pipeline
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 应用部署流水线
- en: '**Know the resource constraints**: Know the resource constraints while starting
    Kubernetes cluster, configure the resource requests and CPU/memory limits on each
    pod. Most containers crash in the production environment due to lack of resources
    or insufficient memory. The containers should be well tested, and the appropriate
    resource should be allotted to the pod in the production environment for successful
    deployment of the microservice.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**了解资源约束**：在启动 Kubernetes 集群时了解资源约束，配置每个 pod 的资源请求和 CPU/内存限制。大多数容器在生产环境中崩溃是由于资源不足或内存不足。容器应经过充分测试，并在生产环境中为
    pod 分配适当的资源，以成功部署微服务。'
- en: '**Monitor the Kubernetes cluster**: The Kubernetes cluster should be continuously
    monitored with the help of logging. Logging tools such as Graylog, Logcheck, or
    Logwatch should be used with Apache Kafka, a messaging system to collect logs
    from the containers and direct them to the logging tools. With the help of Kafka,
    it is easy to index the logs, as well as handle huge streams. Kubernetes replica
    works flawlessly. If any pod crashes, the Kubernetes service restarts them and
    keeps the number of replicas always up and running as per the configuration. One
    aspect that users like to know about is the real reason behind the failure. Kubernetes
    metrics and application metrics can be published to a time-series store such as
    InfluxDB, which can be used to track application errors and measure load, throughput,
    and other stats to perform post-analysis of the failure.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控 Kubernetes 集群**：应该通过日志持续监控 Kubernetes 集群。应使用诸如 Graylog、Logcheck 或 Logwatch
    等日志工具与 Apache Kafka 这样的消息系统一起收集容器的日志并将其传送到日志工具中。借助 Kafka，可以轻松索引日志，并处理大量流。Kubernetes
    副本运行无误。如果任何 pod 崩溃，Kubernetes 服务会重新启动它们，并根据配置始终保持副本数量正常运行。用户想要了解的一个方面是失败背后的真正原因。Kubernetes
    指标和应用指标可以发布到诸如 InfluxDB 这样的时间序列存储中，用于跟踪应用程序错误，并测量负载、吞吐量和其他统计数据，以进行失败后分析。'
- en: '**Persistent storage in Kubernetes**: Kubernetes has the concept of volumes
    to work with persistent data. We want persistence storage in a production deployment
    of Kubernetes because containers lose their data as they restart. A volume is
    backed by a variety of implementations, such as host machines, NFS, or using the
    cloud-provider volume service. Kubernetes also provides two APIs to handle persistent
    storage:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes 中的持久存储**：Kubernetes 具有卷的概念来处理持久数据。在 Kubernetes 的生产部署中，我们希望有持久存储，因为容器在重新启动时会丢失数据。卷由各种实现支持，例如主机机器、NFS
    或使用云提供商的卷服务。Kubernetes 还提供了两个 API 来处理持久存储。'
- en: '**Persistent volume (PV)**: This is a resource, provisioned in a cluster, which
    behaves as though a node is a cluster resource. Pods request the resource (CPU
    and memory) as required from the persistent volumes. It is usually provisioned
    by an administrator.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久卷（PV）**：这是在集群中预配的资源，其行为就像节点是集群资源一样。pod根据需要从持久卷请求资源（CPU和内存）。通常由管理员进行预配。'
- en: '**Persistent volume claim (PVC)**: A PVC consumes PV resources. It is a request
    for storage by the user, similar to a pod. A pod can request levels of resources
    (CPU and memory) as required.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久卷索赔（PVC）**：PVC消耗PV资源。这是用户对存储的请求，类似于pod。pod可以根据需要请求资源（CPU和内存）的级别。'
- en: Debugging Kubernetes issues
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试Kubernetes问题
- en: 'In this section, we''ll be discussing some of the Kubernetes troubleshooting
    concerns:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些Kubernetes故障排除方面的问题：
- en: 'The first step to debug the Kubernetes cluster is to list the number of nodes,
    using the following command:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试Kubernetes集群的第一步是列出节点的数量，使用以下命令：
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Also, verify that all nodes are in the ready state.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 还要验证所有节点是否处于就绪状态。
- en: Look at the logs in order to figure out issues in the deployed Kubernetes cluster
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看日志以找出部署的Kubernetes集群中的问题
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If the pod stays in the pending state, use the following command:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果pod保持在挂起状态，请使用以下命令：
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This will list events and might describe the last thing that happened to the
    pod.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出事件，并可能描述发生在pod上的最后一件事情。
- en: 'To see all the cluster events, use the following command:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看所有集群事件，请使用以下命令：
- en: '[PRE52]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If the `kubectl` command line is unable to reach the `apiserver` process, ensure
    `Kubernetes_master` or `Kube_Master_IP` is set. Ensure the `apiserver` process
    is running in the master and check its logs:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`kubectl`命令行无法到达`apiserver`进程，请确保`Kubernetes_master`或`Kube_Master_IP`已设置。确保`apiserver`进程在主节点上运行，并检查其日志：
- en: 'If you are able to create the replication controller but not see the pods:
    If the replication controller didn''t create the pods, check if the controller
    is running and look at the logs.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您能够创建复制控制器但看不到pod：如果复制控制器没有创建pod，请检查控制器是否正在运行，并查看日志。
- en: 'If `kubectl` hangs forever or a pod is in the waiting state:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`kubectl`永远挂起或pod处于等待状态：
- en: Check if the hosts are being assigned to the pod, if not then currently they
    are being scheduled for some task.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查主机是否被分配给了pod，如果没有，那么它们目前正在为某些任务进行调度。
- en: Check if the kubelet is pointing at the right place in `etcd` for pods and the
    `apiserver` is using the same name or IP of the minion.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查kubelet是否指向`etcd`中pod的正确位置，`apiserver`是否使用相同的名称或minion的IP。
- en: Check if the Docker daemon is running if some issue occurs. Also, check the
    Docker logs and make sure the firewall is not blocking the image from being fetched
    from Docker Hub.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果出现问题，请检查Docker守护程序是否正在运行。还要检查Docker日志，并确保防火墙没有阻止从Docker Hub获取镜像。
- en: 'The `apiserver` process reports:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiserver`进程报告：'
- en: 'Error synchronizing container: `Get http://:10250/podInfo?podID=foo: dial tcp
    :10250:`**connection refused**:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '错误同步容器：`Get http://:10250/podInfo?podID=foo: dial tcp :10250:`**连接被拒绝**：'
- en: This means the pod has not yet been scheduled
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着pod尚未被调度
- en: Check the scheduler logs to see if it is running properly
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查调度器日志，看看它是否正常运行
- en: Cannot connect to the container
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法连接到容器
- en: Try to Telnet to the minion at the service port or the pod's IP address
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试Telnet到服务端口或pod的IP地址的minion
- en: 'Check if the container is created in Docker using the following command:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令检查Docker中是否创建了容器：
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If you don't see the container, the issue will be with the pod configuration,
    image, Docker, or the kubelet. If you see the container getting created every
    10 seconds, then the issues are with the container creation, or the container's
    process is failing.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您看不到容器，则问题可能出在pod配置、镜像、Docker或kubelet上。如果您看到容器每10秒创建一次，则问题可能出在容器的创建或容器的进程失败。
- en: X.509 certificate has expired or is not yet valid.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X.509证书已过期或尚未生效。
- en: Check if the current time matches on the client and server. Use `ntpdate` for
    one-time clock synchronization.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 检查当前时间是否与客户端和服务器上的时间匹配。使用`ntpdate`进行一次性时钟同步。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about managing Docker containers with help of Kubernetes.
    Kubernetes have a different perspective among Docker orchestration tools,where
    each pod will get a unique IP address and communication between pods can occur
    with the help of services. We have covered many deployment scenarios, as well
    as troubleshooting issues when deploying Kubernetes on a Bare Metal machine, AWS,
    vSphere, or using Minikube. We also looked at deploying Kubernetes pods effectively
    and debugging Kubernetes issues. The final section helps with deploying Kubernetes
    in a production environment with load balancers, Kubernetes services, monitoring
    tools, and persistent storage. In the next chapter, we will cover Docker volumes
    and how to use them efficiently in a production environment.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何借助Kubernetes管理Docker容器。Kubernetes在Docker编排工具中有不同的视角，其中每个pod将获得一个唯一的IP地址，并且可以借助服务进行pod之间的通信。我们涵盖了许多部署场景，以及在裸机、AWS、vSphere或使用Minikube部署Kubernetes时的故障排除问题。我们还研究了有效部署Kubernetes
    pods和调试Kubernetes问题。最后一部分介绍了在生产环境中部署Kubernetes所需的负载均衡器、Kubernetes服务、监控工具和持久存储。在下一章中，我们将介绍Docker卷以及如何在生产环境中有效使用它们。
