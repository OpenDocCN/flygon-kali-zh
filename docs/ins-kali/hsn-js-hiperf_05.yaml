- en: Switching Contexts - No DOM, Different Vanilla
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换上下文-没有DOM，不同的Vanilla
- en: As we turn our attention away from the browser, we'll move on to a context that
    most backend programmers will be familiar with. Node.js provides us with a familiar
    language, known as JavaScript, that can be used in a system context. While Node.js
    is known for being a language that servers can be written in, it can be used for
    most capabilities that other languages are known for. If we wanted to create a
    **command-line interface** (**CLI**) tool, for example, we have the ability to
    do that.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们把注意力从浏览器转向其他地方时，我们将进入大多数后端程序员熟悉的环境。Node.js为我们提供了一个熟悉的语言，即JavaScript，可以在系统环境中使用。虽然Node.js以用于编写服务器的语言而闻名，但它可以用于大多数其他语言所用的大多数功能。例如，如果我们想创建一个**命令行界面**（**CLI**）工具，我们就有能力做到。
- en: Node.js also gives us a similar programming context that we have seen in the
    browser. We get an event loop that allows us to have asynchronous **input and
    output** (**I/O**). How this is achieved is through the libuv library. Later in
    this chapter, we will explain this library and how it helps to give us the common
    event loop that we are used to. First, we will look at getting Node.js up and
    running, along with writing some simple programs that we can run.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js还为我们提供了类似于浏览器中看到的编程环境。我们得到了一个允许我们进行异步**输入和输出**（**I/O**）的事件循环。这是通过libuv库实现的。在本章的后面，我们将解释这个库以及它如何帮助我们提供我们习惯的常见事件循环。首先，我们将看看如何启动和运行Node.js，以及编写一些简单的程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting Node.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取Node.js
- en: Understanding the DOM-less world
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解无DOM的世界
- en: Debugging and inspecting code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试和检查代码
- en: Let's get started.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires the following technical requirements:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下技术要求：
- en: An editor or IDE such as VS Code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像VS Code这样的编辑器或IDE
- en: This chapter's code, which can be found at [https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter05).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter05)找到。
- en: Getting Node.js
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取Node.js
- en: Previous chapters have asked for a Node.js runtime. In this chapter, we will
    take a look at how we can get this installed on our system. If we head over to
    [https://Node.js.org/en/](https://nodejs.org/en/), we will be able to download
    either the **Long-Term Support** (**LTS**) version or the current version. For
    this book, it is recommended to get the current version as the module support
    is better.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的章节要求有一个Node.js运行时。在本章中，我们将看看如何在我们的系统上安装它。如果我们前往[https://Node.js.org/en/](https://nodejs.org/en/)，我们将能够下载**长期支持**（**LTS**）版本或当前版本。对于本书来说，建议获取当前版本，因为模块支持更好。
- en: 'For Windows, all we need to do is download and run the executable. For OS X
    and Linux, this should also be simple. For Linux users especially, there may be
    a version in the repository manager for a specific distribution, but this version
    may be old or line up with the LTS version. Remember: we want to be running the
    latest version of Node.js.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows，我们只需要下载并运行可执行文件。对于OS X和Linux，这也应该很简单。特别是对于Linux用户，可能在特定发行版的存储库中有一个版本，但这个版本可能很旧，或者与LTS版本一致。记住：我们希望运行最新版本的Node.js。
- en: 'Once we have it installed, we should be able to invoke the `node` command from
    any command line (Linux users may have to invoke the `Node.js` command since some
    repositories already had a node package inside of their repository). Once invoked,
    we should be greeted with a **Read Evaluate Print Loop** (**REPL**) tool. This
    gives us the ability to test out some code before we actually write it into a
    file. Run the following fragments of code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装好了，我们应该能够从任何命令行调用`node`命令（Linux用户可能需要调用`Node.js`命令，因为一些存储库已经在其存储库中包含了一个node包）。一旦调用，我们应该会看到一个**读取评估打印循环**（**REPL**）工具。这使我们能够在实际将代码写入文件之前测试一些代码。运行以下代码片段：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From these examples, it should be obvious that we are working in a similar environment
    to the one we are used to in the browser. We have access to most of the data manipulation
    and functional concepts that we had in the browser.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些例子中，很明显我们正在一个类似于我们在浏览器中使用的环境中工作。我们可以访问大多数我们在浏览器中拥有的数据操作和功能概念。
- en: Many of the libraries/APIs that we do not have access to are ones that are specific
    to the browser, such as the DOM APIs. We also don't have access to any of the
    browser external resource access libraries, such as `Fetch` or `XMLHttpRequest`.
    We have lower-level versions of them that we will talk about later, but it should
    be noted that, in some ways, it isn't as simple as calling the fetch API.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法访问许多特定于浏览器的库/ API，比如DOM API。我们也无法访问任何浏览器外部资源访问库，比如`Fetch`或`XMLHttpRequest`。我们将稍后讨论它们的较低级版本，但应该注意的是，在某些方面，它并不像调用fetch
    API那样简单。
- en: 'Go ahead and play with the REPL system. If we want to come out of it, we just
    need to use *Ctrl* + *C* twice on Windows (Linux should be the same; for OS X,
    we need to use *command* + *C*). Now, to run a script, all we need to do is put
    some code in a JavaScript file and call **`node <filename>`**. This should run
    our script in immediate mode. This can be seen in the following `example.js` file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 继续玩一下REPL系统。如果我们想退出，只需要在Windows上按两次*Ctrl* + *C*（Linux应该是一样的；对于OS X，我们需要使用*command*
    + *C*）。现在，要运行一个脚本，我们只需要把一些代码放在一个JavaScript文件中，然后调用**`node <filename>`**。这应该在立即模式下运行我们的脚本。这可以在以下的`example.js`文件中看到：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To get access to the various built-in libraries that Node.js gives us, we can
    utilize two different methods. First, we can use the old `require` system. The
    following script shows this capability:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问Node.js给我们的各种内置库，我们可以利用两种不同的方法。首先，我们可以使用旧的`require`系统。以下脚本展示了这种能力：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is the current way of bringing in built-in/user-built modules. It was the
    style that the Node team decided on since there was no common way of bringing
    in modules. We had systems such as RequireJS or CommonJS, and Node.js decided
    on the CommonJS style of bringing in modules. However, as we have learned, there
    is also a standardized way of bringing modules into the browser. The same is true
    for the Node.js platform.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当前引入内置/用户构建模块的方式。这是Node团队决定的风格，因为没有常见的引入模块的方式。我们有RequireJS或CommonJS等系统，Node.js决定采用CommonJS风格引入模块。然而，正如我们所了解的，也有一种标准化的方式将模块引入浏览器。对于Node.js平台也是如此。
- en: The module system is currently in its experimental phase, but if need be, use
    a system such as RollupJS to change the code into a system version that is universally
    recognized, such as the **Universal Module Dependency** (**UDM**) system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统目前处于实验阶段，但如果需要，可以使用诸如RollupJS之类的系统将代码更改为通用识别的系统版本，例如**通用模块依赖**（**UDM**）系统。
- en: 'This system should look very familiar. The following script shows the previous
    example but in the module import system:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统看起来应该很熟悉。以下脚本显示了先前的示例，但是在模块导入系统中：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will also need to have a `package.json` file that has `"type" : "module"`
    in its manifest.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还需要一个`package.json`文件，在其清单中有`"type" : "module"`。'
- en: Overview of the package.json file
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: package.json文件概述
- en: The `package.json` file holds all of the information about the package we are
    trying to build. It even gives us the ability to tie it into our version control
    system, and we can even tie it into our build system. Let's go over this now.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`文件包含了我们正在构建的包的所有信息。它甚至让我们能够将其与我们的版本控制系统联系起来，甚至可以将其与我们的构建系统联系起来。让我们现在来看一下。'
- en: 'First, a `package.json` file should have the following fields filled out:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`package.json`文件应该填写以下字段：
- en: '`name`: This is the name of the package.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是包的名称。'
- en: '`version`: This is the current version of our software package.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`：这是我们软件包的当前版本。'
- en: '`type`: This should either be `module` or `commonjs`. This will allow us to
    distinguish between legacy systems and the new ECMAScript module system.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：这应该是`module`或`commonjs`。这将允许我们区分传统系统和新的ECMAScript模块系统。'
- en: '`license`: This is how we want to license our module. Most of the time, just
    go ahead and put the MIT license. However, if we do want to lock it down more,
    we could always use the GPL or LGPL license.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`license`：这是我们想要许可我们的模块的方式。大多数情况下，只需放置MIT许可证。然而，如果我们想要更严格地限制它，我们可以随时使用GPL或LGPL许可证。'
- en: '`author`: This is an object with the `name`, `email`, and `url` fields. This
    gives attribution to the software and helps people to know who built it.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`author`：这是一个带有`name`、`email`和`url`字段的对象。这为软件提供了归属，并帮助人们知道是谁构建了它。'
- en: '`main`: This is the main entry point of the module. This will allow others
    to use our module and require/import it. It will also let the system know where
    to look for our starting point of the module.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`：这是模块的主入口点。这将允许其他人使用我们的模块并要求/导入它。它还将让系统知道在哪里寻找我们模块的起始点。'
- en: 'There are many additional fields that can be used, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他可以使用的字段，如下：
- en: '`man`: This allows the `man` command to find the file that we wish to serve
    for our documentation.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man`：这允许`man`命令找到我们希望为我们的文档提供的文件。'
- en: '`description`: This allows us to provide more information about our module
    and what it does. If the description is longer than two to three sentences, it
    is recommended to have an accompanying `README` file.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：这允许我们提供关于我们的模块及其功能的更多信息。如果描述超过两到三句，建议附带一个`README`文件。'
- en: '`repository`: This allows others to find the repository and contribute to it
    or submit bug reports/feature requests.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repository`：这允许其他人找到存储库并为其做出贡献或提交错误报告/功能请求。'
- en: '`config`: This is an object that can be used by the scripts that we define
    in the scripts section of our `package.json` file. Scripts will be discussed in
    more detail soon.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`：这是一个对象，可以被我们在`package.json`文件的脚本部分定义的脚本使用。脚本将很快会详细讨论。'
- en: '`dependencies`: This is a list of modules that our module depends on. This
    can range from modules that live in the public `npm` registry, private repositories,
    Git repositories, tarballs, and even local file paths for local development.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dependencies`：这是我们的模块依赖的模块列表。这可以是来自公共`npm`注册表、私有存储库、Git存储库、tarballs，甚至是本地文件路径用于本地开发。'
- en: '`devDependencies`: This is a list of dependencies that are needed for the development
    of this package.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devDependencies`：这是需要用于此软件包开发的依赖列表。'
- en: '`peerDependencies`: This is a list of dependencies that our package may need
    if someone utilizes a piece of the system. This allows our users to download the
    core system, and if they want to utilize other pieces, they can download the peer
    dependencies that these other subsystems need.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peerDependencies`：这是我们的包可能需要的依赖列表，如果有人使用系统的一部分。这允许我们的用户下载核心系统，如果他们想要使用其他部分，他们可以下载这些其他子系统需要的对等依赖。'
- en: '`OS`: This is a list of OSes that we run on. This can also be the negative
    version of this, such as `!darwin`, meaning that this system will run on all OSes
    other than OS X.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OS`：这是我们运行的操作系统列表。这也可以是其否定版本，比如`!darwin`，意味着这个系统将在除OS X之外的所有操作系统上运行。'
- en: '`engines`: The versions of Node.js that we run on. We will want to use this
    when we utilize a feature (such as ECMAScript modules) that has been introduced
    in a recent version. We may also want to utilize this feature if we''re using
    modules that have been deprecated and want to lock the Node.js version to an older
    one.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`engines`：我们运行的Node.js版本。当我们使用最近版本引入的功能（例如ECMAScript模块）时，我们将要使用这个。如果我们使用已被弃用的模块并希望将Node.js版本锁定到旧版本，我们也可能想要使用这个功能。'
- en: There are a few more fields that are located in the `package.json` file, but
    these are the most common ones.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`文件中还有一些其他字段，但这些是最常见的。'
- en: 'One specific section of the `package.json` file that we want to look at is
    the scripts section. If we go to the website of `npm`,about the scripts section,
    it states the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要查看的“package.json”文件的一个特定部分是脚本部分。如果我们去查看“npm”的网站关于脚本部分的信息，它陈述了以下内容：
- en: The `scripts` property is a dictionary containing script commands that are run
    at various times in the life cycle of your package. The key is the life cycle
    event, and the value is the command to run at that point.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: “scripts”属性是一个包含在包的生命周期中的各个时间点运行的脚本命令的字典。键是生命周期事件，值是在该点运行的命令。
- en: If we go to the more details section, we will see that there are life cycle
    hooks that we can use so that we have various scripts running through the bundling
    and distribution process.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进入更多细节部分，我们将看到我们可以使用生命周期钩子，以便我们可以通过捆绑和分发过程运行各种脚本。
- en: It should be noted that this information is specific to **Node Package Manager**
    (**npm**). While learning about Node.js, we will come across `npm` quite a bit,
    so learning about Node.js has also meant learning about `npm`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这些信息特定于**Node Package Manager**（**npm**）。在学习Node.js的过程中，我们会经常遇到“npm”，因此学习Node.js也意味着学习“npm”。
- en: 'Some of the specific points that we are interested in are the **prepare** and
    **install** sections of the packaging life cycle. Let''s see what these sections
    cover:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的一些具体点是打包生命周期的**prepare**和**install**部分。让我们看看这些部分涵盖了什么：
- en: '**Prepare** will run the script before the package is packed into a tarball
    and published to the remote repository. It''s a great way to run compilers and
    bundlers to get our package ready for deployment.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Prepare**将在将包打包成tarball并发布到远程存储库之前运行脚本。这是运行编译器和捆绑器以准备部署我们的包的好方法。'
- en: '**Install** will run the script after the package has been installed. This
    is great when we pull a package and want to run something such as `node-gyp` or
    something that our package may need that''s specific to the OS.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Install**将在安装完包后运行脚本。当我们拉取一个包并想要运行诸如“node-gyp”之类的东西，或者我们的包可能需要的特定于操作系统的东西时，这非常有用。'
- en: 'Another great thing about the `scripts` section is that we can put any arbitrary
    strings here and run `npm run <script>`. Whatever we decide to use as the value
    will be evaluated when we run the command. Let''s add the following to our `package.json`
    file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: “scripts”部分的另一个好处是，我们可以在这里放任意字符串并运行“npm run <script>”。无论我们决定使用什么值，都将在运行命令时进行评估。让我们将以下内容添加到我们的“package.json”文件中：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will give us the ability to grab configuration data. On top of this, we
    have added a script that can be run with the `npm run example-script` command.
    If we create a `main.js` file and add the following fields to it, we should get
    the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够获取配置数据。除此之外，我们还添加了一个可以通过“npm run example-script”命令运行的脚本。如果我们创建一个“main.js”文件并向其中添加以下字段，我们应该会得到以下输出：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This shows that we can put primitive values inside the configuration, but we
    can''t try to access something that is a complex object. We can do the following
    to get to the properties of the `testdata` object:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们可以在配置中放入原始值，但我们不能尝试访问复杂对象。我们可以这样做来获取“testdata”对象的属性：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we've gained some insight into the Node.js and `npm` ecosystems, let's
    take a look at how Node.js is put together and some of the key modules that we
    will be utilizing in the following chapters.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Node.js和“npm”生态系统有了一些了解，让我们来看看Node.js是如何组合在一起的，以及我们将在接下来的章节中使用的一些关键模块。
- en: Understanding the DOM-less world
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解无DOM世界
- en: As we stated in the introduction, Node.js came out of the idea that if we are
    writing code in the browser, then we should be able to run it on the server. Here,
    we have a single language for both contexts and we don't have to context switch
    when we work on either section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在介绍中所述，Node.js的出现是基于这样一个想法：如果我们在浏览器中编写代码，那么我们应该能够在服务器上运行它。在这里，我们有一个语言适用于两种情境，无论我们在哪个部分工作，都不必切换上下文。
- en: Node.js can function in this way with a mixture of two libraries. These libraries
    are V8, which we should already be familiar with, and libuv, which we aren't currently
    familiar with. The libuv library gives us asynchronous I/O. Every OS has a different
    way of handling this I/O, so libuv gives us a nice C wrapper around all of these
    instances.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js可以通过两个库的混合方式运行。这些库是V8，我们应该已经熟悉了，以及libuv，我们目前还不熟悉。libuv库为我们提供了异步I/O。每个操作系统都有不同的处理方式，所以libuv为我们提供了一个很好的C包装器来处理所有这些实例。
- en: The libuv library queues up requests for I/O onto a stack of requests. Then,
    it farms them out to a certain amount of threads (Node.js utilizes four by default).
    Once the responses come back from these threads, libuv will put them on the response
    stack and alert V8 that the responses are ready to be consumed. Once V8 gets around
    to this alert, it will pull the value off and utilize it for its response to the
    request that we made. This is how the Node.js runtime is able to have asynchronous
    I/O and still maintain a single thread of execution (at least, that's how it looks
    to the user).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: libuv库将I/O请求排队到请求堆栈上。然后，它将它们分配给一定数量的线程（Node.js默认使用四个）。一旦这些线程的响应返回，libuv将它们放在响应堆栈上，并通知V8响应已准备好被消耗。一旦V8注意到这个通知，它将从中取出值并将其用于对我们发出的请求的响应。这就是Node.js运行时如何能够具有异步I/O并仍然保持单线程执行的方式（至少对用户来说是这样看的）。
- en: 'With this basic understanding, we should be able to start writing some basic
    scripts that handle various I/O operations and utilize one of the ideas that made
    Node.js special: the streaming system.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些基本理解，我们应该能够开始编写一些处理各种I/O操作并利用使Node.js特殊的想法之一的基本脚本：流系统。
- en: A first look at streams
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流的第一印象
- en: 'As we saw in the DOM, streams give us the ability to control the flow of data
    and be able to process data in a way that creates a nonblocking system. We can
    see this by creating a simple stream. Let''s go ahead and utilize one of the built-in
    streams that comes with Node.js, `readFileStream`. Let''s write the following
    script:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在DOM中看到的那样，流给了我们控制数据流的能力，并且能够以创建非阻塞系统的方式处理数据。通过创建一个简单的流，我们可以看到这一点。让我们继续利用Node.js提供的内置流之一，`readFileStream`。让我们编写以下脚本：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we have imported the `fs` library and the `PassThrough` stream from the
    `stream` library. Then, we created a read stream for the `example.txt` file, as
    well as a `PassThrough` stream.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入了`fs`库和`stream`库中的`PassThrough`流。然后，我们为`example.txt`文件创建了一个读取流，以及一个`PassThrough`流。
- en: A `PassThrough` stream allows us to process the data without having to explicitly
    create a stream ourselves. We read in the data and piped it to our `PassThrough`
    stream.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`PassThrough`流允许我们处理数据，而无需显式创建流。我们读取数据并将其传输到我们的`PassThrough`流。'
- en: From here, we are able to get a handle to the data event, which gives us a chunk
    of data. On top of this, we have made sure to put our data event listener after
    the `pipe` method. By doing this, we have made sure that no `data` events run
    before we have attached our listener.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们能够获得数据事件的处理，这给了我们一块数据。除此之外，我们还确保在`pipe`方法之后放置了我们的数据事件监听器。通过这样做，我们确保在附加监听器之前没有`data`事件运行。
- en: 'Let''s create the following `example.txt` file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建以下`example.txt`文件：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, if we run the `node --experimental-modules read_file_stream.js` command,
    we will see that it prints out a `Buffer`. All of the data processing is in binary
    chunks that are wrapped in `Buffer` objects unless we explicitly set it to something
    such as object mode. If we change the console log command to print out the following,
    we should get output in plain text:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行`node --experimental-modules read_file_stream.js`命令，我们将看到它打印出一个`Buffer`。除非我们明确将其设置为对象模式，否则所有数据处理都是以二进制块包装在`Buffer`对象中的。如果我们将控制台日志命令更改为打印以下内容，我们应该得到纯文本输出：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s create a program that counts the number of times the word `the` is used
    in the text. We can do this with our `PassThrough` stream, like so:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个程序，统计文本中单词`the`的使用次数。我们可以使用我们的`PassThrough`流来做到这一点，如下所示：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We need to keep a count of the number of times we see the word `the`. We also
    are going to create a byte buffer of the `the` string. We will also need to keep
    track of our current position. By doing this, whenever we get data, we can run
    through it and test each byte. If the byte matches the current position that we
    are holding, then we need to do another check. If it equals our character byte
    count for the word `the`, then we update the number of `the` and reset our current
    position. Otherwise, we set our current position to the next index. If we don't
    get a match, we need to reset our current position; otherwise, we will get any
    combination of the characters *t*, *h*, and *e*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记录单词`the`出现的次数。我们还将创建一个`the`字符串的字节缓冲区。我们还需要跟踪我们当前的位置。通过这样做，每当我们获得数据时，我们可以运行并测试每个字节。如果字节与我们持有的当前位置匹配，那么我们需要进行另一个检查。如果它等于单词`the`的字符字节计数，那么我们更新`the`的数量并重置我们的当前位置。否则，我们将当前位置设置为下一个索引。如果我们没有找到匹配，我们需要重置当前位置；否则，我们将得到字符*t*、*h*和*e*的任意组合。
- en: This is an interesting example of how to utilize a `PassThrough` stream, but
    let's go ahead and create our own write `Transform` stream. We are going to apply
    the same operation that we did before, but we are going to build a custom stream.
    As stated in the documentation, we must write the `_transform` function and, optionally,
    implement the `_flush` function. We are going to implement both the `_transform`
    and `_flush` functions. We are also going to utilize the new class syntax instead
    of utilizing the old prototype-based system. One thing to keep in mind when building
    our own custom streams is to run the `super(options)` method before we do anything
    else in our stream. This will allow the user to pass various stream options that
    they have access to without us needing to do anything.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的例子，展示了如何利用`PassThrough`流，但让我们继续创建我们自己的写`Transform`流。我们将应用与之前相同的操作，但我们将构建一个自定义流。正如文档中所述，我们必须编写`_transform`函数，并且可以选择实现`_flush`函数。我们将实现`_transform`和`_flush`函数。我们还将利用新的类语法，而不是利用旧的基于原型的系统。在构建我们自己的自定义流时要记住的一件事是，在流中做任何其他事情之前运行`super(options)`方法。这将允许用户传递各种流选项，而无需我们做任何事情。
- en: 'With all of this in mind, we should get something that looks like the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，我们应该得到类似以下的东西：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, we import the `Transform` stream from the `stream` base library. We extend
    it and create a couple of private variables, that is, the current position in
    the `the` buffer and the current count of `the` in our stream. We also create
    a static variable for the buffer that we are comparing it to. Then, we have our
    constructor. This is where we pass the options to the `Transform` stream's constructor.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`stream`基础库中导入`Transform`流。我们扩展它并创建一些私有变量，即`the`缓冲区中的当前位置和流中`the`的当前计数。我们还为我们要进行比较的缓冲区创建了一个静态变量。然后，我们有我们的构造函数。这是我们将选项传递给`Transform`流构造函数的地方。
- en: Next, we implement the `_transform` method in the same way that we implemented
    the `data` event on the `PassThrough` stream. The only new piece should be the
    call to the callback at the end. This lets our stream know that we are ready to
    process more data. If we need to error out, we can pass that as the first argument.
    We can also pass a second parameter, as shown in the `_flush` function. This allows
    us to pass the processed data to whoever may be listening. In our case, we only
    want to pass the number of `the` that we found in the text. We can also only pass
    a `Buffer`, `String`, or `Uint8Array`, so we decide to pass the string version
    of our number (we could have used a `Buffer` and this would have probably been
    the better choice). Finally, we export this from our module.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们以与我们在`PassThrough`流的`data`事件上实现的方式实现`_transform`方法。唯一的新部分应该是在最后调用回调函数。这让我们的流知道我们已经准备好处理更多数据。如果我们需要出错，我们可以将其作为第一个参数传递。我们还可以传递第二个参数，就像在`_flush`函数中所示的那样。这允许我们将处理过的数据传递给可能正在监听的人。在我们的情况下，我们只想传递我们在文本中找到的`the`的数量。我们还可以只传递`Buffer`、`String`或`Uint8Array`，所以我们决定传递我们数字的字符串版本（我们本可以使用`Buffer`，这可能是更好的选择）。最后，我们从我们的模块中导出这个。
- en: 'Inside of our `read_file_stream` file, we will import this module with the
    following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`read_file_stream`文件中，我们将使用以下命令导入此模块：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we can utilize it with the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下代码：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By doing this, we have wrapped all of that logic into a separate module and
    a reusable stream instead of just doing this in the `data` event of `PassThrough`.
    We also have the ability to chain our stream implementation to another stream
    (in this case, there would probably be no point unless we were going to pass it
    to a socket).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们将所有这些逻辑封装到一个单独的模块和可重用的流中，而不仅仅是在`PassThrough`的`data`事件中这样做。我们还可以将我们的流实现链接到另一个流（在这种情况下，除非我们要将其传递给套接字，否则可能没有意义）。
- en: This was a short introduction to the stream interface and provided an overview
    of what we will be discussing at length in later chapters. Next, we will take
    a look at some modules that come with Node.js and how they can help us to write
    server applications.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是流接口的简短介绍，并概述了我们将在后面章节中详细讨论的内容。接下来，我们将看一下Node.js附带的一些模块以及它们如何帮助我们编写服务器应用程序。
- en: A high-level look at modules
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块的高级视图
- en: 'There are three I/O modules that allow our applications to work with the filesystem
    and access the outside world. These are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个I/O模块允许我们的应用程序与文件系统和外部世界进行交互。它们分别是：
- en: '`fs`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs`'
- en: '`net`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net`'
- en: '`http`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http`'
- en: These three modules will likely be the main modules that a user will utilize
    when developing Node.js applications. Let's take a look at each of them individually.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个模块很可能是用户在开发Node.js应用程序时将使用的主要模块。让我们分别来看看它们。
- en: fs module
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs模块
- en: 'First, let''s create a basic example of accessing the filesystem and opening
    a file, adding some text to it, closing the file, and then appending some more
    text to it. This would look similar to the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个访问文件系统、打开文件、添加一些文本、关闭文件，然后再追加一些文本的基本示例。这看起来类似于以下内容：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we are grabbing the promise-based version of the library. Most of the
    built-in modules have a promise-based version, which can lead to nice-looking
    code, especially compared to the callback system. Next, we write to a file and
    give it some text. The `writeFile` method allows us to write to a file and create
    the file if it doesn't exist. After this, we open up `FileHandle` for our file.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们正在获取基于Promise的库版本。大多数内置模块都有基于Promise的版本，这可以导致看起来很好的代码，特别是与回调系统相比。接下来，我们写入一个文件并给它一些文本。`writeFile`方法允许我们写入文件并在文件不存在时创建文件。之后，我们打开我们文件的`FileHandle`。
- en: Node.js took the POSIX style of I/O. This means that everything is treated like
    a file. In this case, everything is assigned a **file descriptor** (**fd**). This
    looks like a number to us in languages such as C++. After, we can pass this number
    to a variety of file functions that are available to us. Node.js, in the promises
    API, decided to switch to a `FileHandle` object, which is what we get instead
    of this file descriptor. It leads to cleaner code and a layer of abstraction over
    the system that is sometimes needed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js采用了POSIX风格的I/O。这意味着一切都像文件一样对待。在这种情况下，一切都被分配了一个**文件描述符**（**fd**）。这对我们来说看起来像是C++等语言中的一个数字。之后，我们可以将这个数字传递给我们可用的各种文件函数。在Promises
    API中，Node.js决定切换到`FileHandle`对象，这是我们得到的而不是这个文件描述符。这导致了更清晰的代码，并且有时需要在系统上提供一层抽象。
- en: The `a` that we can see as the second argument states how we are going to use
    the file. In this case, we are going to append to the file. If we opened it with
    `r`, this means that we want to read from it, while if we opened it with `w`,
    this means that we want to overwrite whatever is already there.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到作为第二个参数的`a`表示我们将如何使用文件。在这种情况下，我们将追加到文件中。如果我们用`r`打开它，这意味着我们要从中读取，而如果我们用`w`打开它，这意味着我们要覆盖已经存在的内容。
- en: Having an understanding of a Unix system can go a long way to understanding
    how Node.js works and how all of this corresponds to the programs that we are
    trying to write.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Unix系统可以帮助我们更好地理解Node.js的工作原理，以及所有这些与我们试图编写的程序之间的对应关系。
- en: Then, we append some text to the file and close it. Finally, we console log
    whatever is in the file and state that we want to read it in as UTF-8 text instead
    of in binary.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们向文件追加一些文本并关闭它。最后，我们在控制台记录文件中的内容，并声明我们要以UTF-8文本而不是二进制形式读取它。
- en: There are many more APIs associated with the filesystem, and it is recommended
    to go through the promise documentation to see what capabilities we have, but
    they all boil down to us having access to the filesystem and being able to read/write/append
    to various files and directories. Now, let's move on to the `net` module.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与文件系统相关的API还有很多，建议查看Promise文档以了解我们有哪些能力，但它们都归结为我们可以访问文件系统，并能够读取/写入/追加到各种文件和目录。现在，让我们继续讨论`net`模块。
- en: net module
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络模块
- en: 'The `net` module gives us access to lower-level socket systems and even to
    local **InterProcess Communication** (**IPC**) schemes that we can use. IPC schemes
    are communication strategies that allow us to talk between processes. Processes
    don''t share memory, which means that we have to communicate through other means.
    In Node.js, this usually means three different strategies, and they all depend
    on how quickly and how tightly coupled we want the systems to be. These three
    strategies are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`net`模块为我们提供了对底层套接字系统甚至本地**进程间通信**（**IPC**）方案的访问权限。IPC方案是允许我们在进程之间进行通信的通信策略。进程不共享内存，这意味着我们必须通过其他方式进行通信。在Node.js中，这通常意味着三种不同的策略，它们都取决于我们希望系统有多快速和紧密耦合。这三种策略如下：'
- en: Unnamed pipes
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无名管道
- en: Named pipes/local domain sockets
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名管道/本地域套接字
- en: TCP/UDP sockets
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP/UDP套接字
- en: 'First, we have unnamed pipes. These are one-way communication systems that
    are not seen on the filesystem and are shared between a `parent` and a `child`
    process. This means that a `parent` process would spawn a `child` process and
    `parent` would pass the *location* of one end of the pipe to `child`. By doing
    this, they would be able to communicate over this channel. An example of this
    is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有无名管道。这些是单向通信系统，不会出现在文件系统中，并且在`parent`和`child`进程之间共享。这意味着`parent`进程会生成一个`child`进程，并且`parent`会将管道一端的*位置*传递给`child`。通过这样做，它们可以通过这个通道进行通信。一个例子如下：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our `child` file will look as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`child`文件将如下所示：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We grab the fork method from the `child_process` module (this allows us to spawn
    new processes). Then, we fork a new `child` off of the `child` JavaScript file
    and are given a handler to that `child` process. As part of the fork process,
    Node.js automatically creates an unnamed pipe for us so that we can talk between
    the two processes. Then, we listen for events on the `child` process and do various
    things based on the message that we receive.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`child_process`模块中获取fork方法（这允许我们生成新的进程）。然后，我们从`child` JavaScript文件中fork一个新的`child`，并获得对该`child`进程的处理程序。作为fork过程的一部分，Node.js会自动为我们创建一个无名管道，以便我们可以在两个进程之间进行通信。然后，我们监听`child`进程上的事件，并根据接收到的消息执行各种操作。
- en: 'On the `child` side, we can automatically listen for events from whoever spawned
    us and we can send messages through our process interface (this is global in each
    Node.js file that is started). As shown in the following code, we are able to
    talk between two separate processes. If we wanted to actually see this, we would
    have to add a timeout to our `parent` process so that it doesn''t send the `DISCONNECT`
    message for `15` seconds, like so:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`child`端，我们可以自动监听来自生成我们的进程的事件，并且可以通过我们的进程接口发送消息（这在每个启动的Node.js文件中都是全局的）。如下面的代码所示，我们能够在两个独立的进程之间进行通信。如果我们想要真正看到这一点，我们需要在`parent`进程中添加一个超时，以便在`15`秒内不发送`DISCONNECT`消息，就像这样：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, if we bring up a task manager, we will see that two Node.js processes have
    been started. One of these is `parent` while the other one is `child`. We are
    talking over an unnamed pipe, so they are considered tightly coupled because they
    are the only ones that share it. This is great for systems that we want to have
    a `parent`/`child` relationship and do not expect to have either of them spawned
    in a different way.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们打开任务管理器，我们会看到启动了两个Node.js进程。其中一个是`parent`，另一个是`child`。我们正在通过一个无名管道进行通信，因此它们被认为是紧密耦合的，因为它们是唯一共享它的进程。这对于我们希望有`parent`/`child`关系的系统非常有用，并且不希望以不同的方式生成它们。
- en: Instead of creating this tight link between the two processes, we can use something
    called a named pipe (these are known as Unix domain sockets on OS X and Linux).
    It works similarly to an unnamed pipe, but we are able to connect two unrelated
    processes. To achieve this type of connection, we can utilize the `net` module.
    It provides a low-level API that can be used to create, connect, and listen to
    these connections. We also get a low-level socket connection, so it behaves similarly
    to the `http(s)` modules.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与在两个进程之间创建紧密链接不同，我们可以使用称为命名管道的东西（在OS X和Linux上称为Unix域套接字）。它的工作方式类似于无名管道，但我们能够连接两个不相关的进程。为了实现这种类型的连接，我们可以利用`net`模块。它提供了一个低级API，可以用来创建、连接和监听这些连接。我们还会得到一个低级套接字连接，因此它的行为类似于`http(s)`模块。
- en: 'To start up a connection, we can do the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要建立连接，我们可以这样做：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we import the `net`, `path`, and `os` modules. The `path` module helps
    to create and resolve filesystem paths without us having to write path expressions
    specifically for an OS. The `os` module, as we saw previously, can give us information
    about the OS that we are currently on. When we create the pipe name, Windows needs
    to be at `\\?\pipe\<something>`. On another OS, it can just be a regular path.
    Something else to note is that any other OS besides Windows will not clean the
    pipe after we have finished using it. This means that we will need to make sure
    we delete the file before we exit the program.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入了`net`、`path`和`os`模块。`path`模块帮助我们创建和解析文件系统路径，而无需为特定的操作系统编写路径表达式。正如我们之前看到的，`os`模块可以为我们提供有关当前所在的操作系统的信息。在创建管道名称时，Windows需要在`\\?\pipe\<something>`。在其他操作系统上，它可以只是一个常规路径。还有一点需要注意的是，除了Windows之外的任何其他操作系统在我们使用完管道后都不会清理它。这意味着我们需要确保在退出程序之前删除文件。
- en: In our case, we create a pipe name based off of the platform. In any case, we
    make sure that it is in our current working directory (`process.cwd()`) and that
    it is called `temp`. From here, we can create a server and listen for connections
    on this file. When someone connects, we receive a `Socket` object. This is a full
    Duplex stream, which means that we can read and write from it. We are also able
    to pipe information to and from it. In our case, we want to log to the console
    that `socket` joined and then send a `DISCONNECT` message. Once we get the close
    event, we just log that `socket` closed down.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们根据平台创建一个管道名称。无论如何，我们确保它在我们当前的工作目录（`process.cwd()`）中，并且它被称为`temp`。从这里，我们可以创建一个服务器，并在这个文件上监听连接。当有人连接时，我们收到一个`Socket`对象。这是一个完整的双工流，这意味着我们可以从中读取和写入。我们还能够将信息传送到其中。在我们的情况下，我们想要记录到控制台`socket`加入，然后发送一个`DISCONNECT`消息。一旦我们收到关闭事件，我们就会记录`socket`关闭。
- en: 'For our client code, we should have something similar to the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的客户端代码，我们应该有类似以下的东西：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code is fairly similar, except we create a `Socket` object directly and
    try to connect to the same pipe name. Once we're connected, we log this. When
    we get data, we check whether it is equal to our `DISCONNECT` message, and if
    it is, we get rid of the socket.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前的代码非常相似，只是我们直接创建了一个`Socket`对象并尝试连接到相同的管道名称。一旦连接成功，我们就会记录下来。当我们收到数据时，我们会检查它是否等于我们的`DISCONNECT`消息，如果是，我们就会摆脱这个套接字。
- en: What's nice about the IPC mechanism is that we can pass messages between different
    programs written in different languages. The only thing that they need to have
    in common is some form of common *language*. There are many systems out there
    that can do this. Although this isn't the focus of this book, note that if we
    needed to hook into another program, we could do this fairly easily with the `net`
    module.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: IPC机制的好处在于我们可以在不同语言编写的不同程序之间传递消息。它们唯一需要共同拥有的是某种形式的共同*语言*。有许多系统可以做到这一点。尽管这不是本书的重点，但请注意，如果我们需要连接到另一个程序，我们可以使用`net`模块相当容易地实现这一点。
- en: http module
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: http模块
- en: 'The final module we are going to take a high-level look at is the `http` module.
    This module allows us to create `http` servers with ease. The following is a simple
    example of an `http` server:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要高层次地看一下的最后一个模块是`http`模块。这个模块允许我们轻松创建`http`服务器。以下是一个简单的`http`服务器示例：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we head to `localhost:8000` in our browser, we should see the JSON object
    in our browser. If we wanted to get even fancier, we could send back some basic
    HTML, such as the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中输入`localhost:8000`，我们应该能在浏览器中看到JSON对象。如果我们想变得更加花哨，我们可以发送一些基本的HTML，比如下面这样：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Instead of setting our content type to `application/json`, we set it to `text/html`
    so that the browser knows how to interpret this request. Then, we end the response
    with our basic HTML. How would we be able to respond to the server if our HTML
    requests a CSS file?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将内容类型设置为`text/html`，而不是`application/json`，以便浏览器知道如何解释这个请求。然后，我们用我们的基本HTML结束响应。如果我们的HTML请求CSS文件，我们将如何响应服务器？
- en: 'We would need to interpret the request and be able to send some CSS. We could
    do this with something like the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解释请求并能够发送一些CSS。我们可以使用以下方式来做到这一点：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We are able to pull various pieces of information from the request that we receive.
    In this case, all we care about is whether this was a `GET` request and that it
    is asking for the `main.css` resource. If it is, we return the CSS; otherwise,
    we just return our HTML. It should be noted that this code should look somewhat
    familiar to web server frameworks such as Express. Express adds a bunch of helper
    methods and ways to protect our server, but it should be noted that we can write
    simple servers with fewer dependencies and only by utilizing the modules that
    are internal to Node.js.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够从接收到的请求中提取各种信息。在这种情况下，我们只关心这是否是一个`GET`请求，并且它是否在请求`main.css`资源。如果是，我们返回CSS；否则，我们只返回我们的HTML。值得注意的是，这段代码应该看起来与诸如Express之类的Web服务器框架相似。Express添加了许多辅助方法和保护服务器的方法，但值得注意的是，我们可以通过利用Node.js内部的模块编写简单的服务器，减少依赖。
- en: 'We can also use the `http` module to fetch data from various resources. If
    we use the `get` method built into the `http` module or even the more generic
    request method, we can get resources from various other servers. The following
    code illustrates this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`http`模块从各种资源中获取数据。如果我们使用内置在`http`模块中的`get`方法，甚至更通用的请求方法，我们可以从各种其他服务器获取资源。以下代码说明了这一点：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, we can see that we have to utilize the `https` module. Since this web
    page is located on a server that is utilizing **Secure Socket Layer** (**SSL**)
    certificates, we have to use the secure connection method. Then, we simply call
    the `get` method, passing in the URL that we want, and read the data from the
    response. If, for some reason, we do not get a 200 response (an okay message),
    we error out.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以看到我们必须利用`https`模块。由于这个网页位于一个使用**安全套接字层**（**SSL**）证书的服务器上，我们必须使用安全连接方法。然后，我们只需调用`get`方法，传入我们想要的URL，并从响应中读取数据。如果出现某种原因，我们没有得到一个200响应（一个正常的消息），我们就会出错。
- en: These three modules should showcase that we have quite a bit of power inside
    of the Node.js ecosystem and should spark some curiosity in how we can use Node.js,
    without any dependencies, to make useful systems. In the next section, we will
    take a look at how we can debug our Node.js code in a command-line debugger, along
    with the code inspection system that we are used to using with Chrome.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个模块应该展示了我们在Node.js生态系统中有相当大的能力，并且应该引发一些好奇心，让我们想知道如何在没有任何依赖的情况下使用Node.js来制作有用的系统。在下一节中，我们将看看如何在命令行调试器中调试我们的Node.js代码，以及我们习惯于在Chrome中使用的代码检查系统。
- en: Debugging and inspecting code
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和检查代码
- en: 'One area that new Node.js developers struggle with is debugging code. Instead
    of having the inspector, we have a system where the first crash will dump some
    information to our screen and instantly kick us to the command-line. This can
    be seen with the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 新的Node.js开发人员常常在调试代码方面遇到困难。与检查员不同，我们有一个系统，第一次崩溃会将一些信息转储到屏幕上，然后立即将我们踢到命令行。以下代码可以看到这一点：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, we can see that we are trying to reassign a constant, so Node.js is going
    to throw an error similar to the following one:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们正在尝试重新分配一个常量，所以Node.js将抛出类似以下的错误：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: While this can be scary, it also shows us where the error is. The first line
    in this stack trace tells us it is at *line 3*, *character 7*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能让人感到害怕，但它也向我们展示了错误的位置。这个堆栈跟踪中的第一行告诉我们它在*第3行*，*第7个字符*。
- en: A stack trace is a way for a system to provide the developer with information
    about which functions were calling what. In our case, `Object.<anonymous>` was
    called by `Module.__compile`, and so on. This can help when a good chunk of the
    stack is ours and the error actually occurs farther up.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈跟踪是系统向开发人员提供有关调用了什么函数的信息的一种方式。在我们的情况下，`Object.<anonymous>`被`Module.__compile`调用，依此类推。当堆栈的大部分是我们自己的时候，错误实际上发生在更远的地方时，这可能有所帮助。
- en: With this information, we know how to correct the issue, but what do we do if
    we want to break on a specific statement or a specific line? This is where the
    inspector system comes into play. Here, we can utilize statements that are similar
    to the ones we saw in the web version of our code. If we insert a debug statement
    in the middle of our code, our command line will stop at that point.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我们知道如何纠正问题，但如果我们想在特定语句或特定行上中断怎么办？这就是检查员系统发挥作用的地方。在这里，我们可以利用类似于我们在代码的Web版本中看到的语句。如果我们在代码的中间插入一个调试语句，我们的命令行将在那一点停止。
- en: 'Let''s create some rudimentary code to showcase this. The following code should
    give us plenty to showcase the use of the inspector:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些基本的代码来展示这一点。以下代码应该足够展示检查员的使用：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code will allow us to play around with various parts of the inspector.
    If we run the `npm inspect bad_code.js` command, we should break on the call to
    `fun`. We are greeted with a Terminal interface that states we are in debug mode.
    Now that we have stopped execution here, we can set up a watcher. This allows
    us to capture various variables and expressions and see what their results are
    on the next break. Here, we set up a watcher on the `x` variable by executing
    `watch('x')` in the debugger. From here, if we type `next`, we will move to the
    next line. If we do this a couple of times, we will notice that once we pass the
    assignment of our variable, the watcher will change the `x` variable from undefined
    to 10.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将允许我们玩弄检查员的各个部分。如果我们运行`npm inspect bad_code.js`命令，我们应该会在对`fun`的调用上中断。我们会看到一个终端界面，指出我们处于调试模式。现在我们在这里停止执行，我们可以设置一个监视器。这允许我们捕获各种变量和表达式，并查看它们在下一个中断时的结果。在这里，我们通过在调试器中执行`watch('x')`来设置一个监视器，监视`x`变量。从这里，如果我们输入`next`，我们将移动到下一行。如果我们这样做几次，我们会注意到一旦我们通过变量的赋值，监视器将把`x`变量从未定义变为10。
- en: 'This can be especially helpful when we need to debug a stateful system that
    is sharing state among quite a few objects. It can also be helpful when we are
    trying to see what we have access to. Let''s set up a few more watchers so that
    we can see what their values are when our next debug statement is hit. Set up
    watchers on the following variables: `item`, `tempObj`, and `alternative`. Now,
    type `cont`. This will move us to our next debugger statement. Let''s see what''s
    printed out by our watchers. When we move to the next point, we will see that
    `tempObj` and `x` are not defined, but that we have access to `item` and `alternative`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要调试一个在相当多的对象之间共享状态的有状态系统时，这可能特别有帮助。当我们试图查看我们可以访问的内容时，这也可能有所帮助。让我们设置几个更多的监视器，以便在下一个调试语句被触发时看到它们的值。在以下变量上设置监视器：`item`、`tempObj`和`alternative`。现在，输入`cont`。这将把我们移动到下一个调试器语句。让我们看看我们的监视器打印出了什么。当我们移动到下一个点时，我们会看到`tempObj`和`x`未定义，但我们可以访问`item`和`alternative`。
- en: This is what we expect, seeing how we are scoped inside the outer `fun` function.
    There's much more we can do with this version of the inspector, but we can also
    hook up to the inspector that we are used to.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们所期望的，因为我们被限定在外部`fun`函数内部。我们可以用这个版本的检查员做更多事情，但我们也可以连接到我们习惯的检查员。
- en: 'Now, if we use the following command to run our code, we will be able to attach
    the debug tools to our script:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们使用以下命令运行我们的代码，我们将能够将调试工具附加到我们的脚本上：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this, we will get an address that we can connect to. Let's do just that.
    We will also need to have some long-running code; otherwise, the script will exit
    and we will have nothing to listen to. Let's move back to the `named_pipe.js`
    example. Run `node --inspect -–experimental-modules named_pipe.js`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们将得到一个我们可以连接的地址。让我们这样做。我们还需要有一些长时间运行的代码；否则，脚本将退出，我们将没有任何东西可以监听。让我们回到`named_pipe.js`示例。运行`node
    --inspect -–experimental-modules named_pipe.js`。
- en: 'We should get something that looks like the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到类似以下的东西：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we head to the following address in our Chrome browser, we should be greeted
    with a familiar sight:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Chrome浏览器中输入以下地址，我们应该会看到一个熟悉的界面：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, we have the full power of the inspector from Chrome for our Node.js code.
    Here, we can see that if we connect to our named pipe server with our `named_pipe_child.js`
    file, we will be greeted with the console logs in the debugger. Now, if we add
    debugger statements, we should get breakpoints inside of the inspector. If we
    add a debug statement right when a socket connects to us, when we connect with
    our child socket, we will be able to run through our code the same way we can
    in the browser! This is a great way to debug and step through our code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在Node.js代码中使用Chrome的检查器的全部功能。在这里，我们可以看到，如果我们用`named_pipe_child.js`文件连接到我们的命名管道服务器，我们将在调试器中看到控制台日志。现在，如果我们添加调试器语句，我们应该能够在检查器中得到断点。如果我们在套接字连接到我们时添加一个调试语句，当我们用子套接字连接时，我们将能够以与在浏览器中一样的方式运行我们的代码！这是调试和逐步执行我们的代码的好方法。
- en: We are also able to memory profile. If we head to the Memory tab and create
    a heap snapshot, we will get a nice dump of our memory. It should look quite familiar
    to what we have seen already.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以进行内存分析。如果我们转到内存选项卡并创建堆快照，我们将得到一个漂亮的内存转储。它应该看起来非常熟悉，就像我们已经看到的那样。
- en: With all of this under our belt, we can move onto more complex topics surrounding
    Node.js.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，我们可以进入围绕Node.js的更复杂的主题。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With the advent of Node.js, we are able to have a programming language that
    we can utilize on both the client and server. While the APIs that are given to
    us in Node.js may not look familiar, we can create powerful server applications
    with them.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Node.js的出现，我们能够使用一种编程语言，可以在客户端和服务器上都使用。虽然Node.js给我们的API可能看起来不太熟悉，但我们可以用它们创建强大的服务器应用程序。
- en: In this chapter, we covered the basics of streaming and some of the APIs that
    allow us to create these powerful server applications. We also took a look at
    the tools that allow us to debug with and without a GUI.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了流的基础知识以及一些允许我们创建强大服务器应用程序的API。我们还看了一些工具，可以让我们在有GUI和没有GUI的情况下进行调试。
- en: With all of this under our belt, in the next chapter, we will take a deeper
    dive into the mechanisms we can use to pass data between threads and processes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，下一章中，我们将更深入地探讨我们可以使用的机制，以在线程和进程之间传递数据。
