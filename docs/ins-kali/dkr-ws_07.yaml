- en: 7\. Docker Storage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. Docker存储
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn how Docker manages data. It is crucial to know
    where to store your data and how your services will access it. This chapter will
    explore running stateless versus stateful Docker containers, and will delve into
    the configuration setup options for storage for different applications. By the
    end of the chapter, you will be able to distinguish between the different storage
    types in Docker and identify the container's life cycle and its various states.
    You will also learn how to create and manage Docker volumes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习Docker如何管理数据。了解在哪里存储数据以及您的服务将如何访问它是至关重要的。本章将探讨无状态与有状态的Docker容器运行，并深入探讨不同应用程序存储的配置设置选项。到本章结束时，您将能够区分Docker中不同的存储类型，并识别容器的生命周期及其各种状态。您还将学习如何创建和管理Docker卷。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In previous chapters, you learned how to run a container from an image and how
    to configure its networking. You also learned that you can pass various Docker
    commands while crafting containers from the images. In this chapter, you will
    learn how to control these containers after you have created them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，您学习了如何从镜像运行容器以及如何配置其网络。您还学习了在从镜像创建容器时可以传递各种Docker命令。在本章中，您将学习如何在创建容器后控制这些容器。
- en: Assume that you have been assigned to build a web application for an e-store.
    You will need a database to store the products catalog, clients' information,
    and purchase transactions. To store these details, you need to configure the application's
    storage settings.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您被指派为电子商店构建一个网络应用程序。您将需要一个数据库来存储产品目录、客户信息和购买交易。为了存储这些细节，您需要配置应用程序的存储设置。
- en: There are two types of data storage in Docker. The first one is storage that
    is tightly coupled to the container life cycle. If the container is removed, the
    files on that storage type are also removed and cannot be retrieved. These files
    are stored in the thin read/write layer inside the container itself. This type
    of storage is also known by other terms, such as the local storage, the `graphdriver`
    storage, and the storage driver. The first section of this chapter focuses on
    this type of storage. These files could be of any type—for example, the files
    Docker created after installing a new layer on top of the base image.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Docker中有两种类型的数据存储。第一种是与容器生命周期紧密耦合的存储。如果容器被移除，该存储类型上的文件也将被移除且无法检索。这些文件存储在容器本身内部的薄读/写层中。这种存储类型也被称为其他术语，例如本地存储、`graphdriver`存储和存储驱动程序。本章的第一部分专注于这种存储类型。这些文件可以是任何类型，例如，在基础镜像之上安装新层后Docker创建的文件。
- en: The second section of the chapter explores stateless and stateful services.
    Stateful applications are the ones that need persistent storage, such as databases
    that persist and outlive the container. In stateful services, the data can still
    be accessed even when the container is removed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第二部分探讨了无状态和有状态服务。有状态应用程序是需要持久存储的应用程序，例如持久且超越容器生存期的数据库。在有状态服务中，即使容器被移除，数据仍然可以被访问。
- en: 'The container stores the data on the host in two ways: through volumes and
    bind mounts. Using a bind mount is not recommended because the bind mount binds
    an existing file or directory on the host to a path inside the container. This
    bind adds a burden in referencing by using the full or relative path on the host
    machine. However, a new directory is created within Docker''s storage directory
    on the host machine when you use a volume, and Docker manages the directory''s
    contents. We will focus on using volumes in the third section of this chapter.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 容器以两种方式在主机上存储数据：通过卷和绑定挂载。不推荐使用绑定挂载，因为绑定挂载会将主机上的现有文件或目录绑定到容器内的路径。这种绑定增加了在主机上使用完整或相对路径的负担。然而，当您使用卷时，在主机上的Docker存储目录中创建一个新目录，并且Docker管理目录的内容。我们将在本章的第三部分专注于使用卷。
- en: Before exploring different types of storage in Docker, let's first explore the
    container life cycle.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索Docker中不同类型的存储之前，让我们先探索容器的生命周期。
- en: The Container Life Cycle
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器生命周期
- en: 'Containers are crafted from their base images. The container inherits the filesystem
    of the image by creating a thin read/write layer on top of the image layers''
    stack. The base images stay intact, and no changes are made to them. All your
    changes happen in that top layer of the container. For example, say you create
    a container of `ubuntu: 14.08`. This image does not have the `wget` package in
    it. When you install the `wget` package, you actually install it on the top layer.
    So, you have a layer for the base image, and on top of it, another layer for `wget`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是从其基本镜像中制作的。容器通过在图像层堆栈的顶部创建一个薄的读/写层来继承图像的文件系统。基本镜像保持完整，不对其进行任何更改。所有更改都发生在容器的顶层。例如，假设您创建了一个`ubuntu:14.08`的容器。这个镜像中没有`wget`软件包。当您安装`wget`软件包时，实际上是在顶层安装它。因此，您有一个用于基本镜像的层，以及另一个用于`wget`的层。
- en: If you install the `Apache` server as well, it will be the third layer on top
    of both of the previous layers. To save all your changes, you need to commit all
    these changes to a new image because you cannot write over the base image. If
    you do not commit the changes to a new image, these changes will be deleted with
    the container's removal.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您也安装了`Apache`服务器，它将成为前两层之上的第三层。要保存所有更改，您需要将所有这些更改提交到新的镜像，因为您不能覆盖基本镜像。如果您不将更改提交到新镜像，这些更改将随容器的移除而被删除。
- en: 'The container undergoes many other states during its life cycle, so it is important
    to look into all the states that a container can have during its life cycle. So,
    let''s dive into understanding the different container states:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在其生命周期中经历许多其他状态，因此重要的是要了解容器在其生命周期中可能具有的所有状态。因此，让我们深入了解不同的容器状态：
- en: '![Figure 7.1: Container life cycle'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1：容器生命周期'
- en: '](image/B15021_07_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_07_01.jpg)'
- en: 'Figure 7.1: Container life cycle'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：容器生命周期
- en: 'The different stages that a container undergoes are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 容器经历的不同阶段如下：
- en: The container enters the `CREATED` status using the `docker container run` subcommand,
    as shown in *Figure 7.1*.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`docker container run`子命令，容器进入`CREATED`状态，如*图7.1*所示。
- en: Inside every container, there is a main process running. When this process begins
    running, the container's status changes to the `UP` status.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个容器内部，都有一个主要的进程在运行。当这个进程开始运行时，容器的状态会变为`UP`状态。
- en: The container's status changes to `UP(PAUSED)` by using the `docker container
    pause` subcommand. The container freezes or suspends but is still in the `UP`
    state and is not stopped or removed.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`docker container pause`子命令，容器的状态变为`UP(PAUSED)`。容器被冻结或暂停，但仍处于`UP`状态，没有停止或移除。
- en: To resume running the container, use the `docker container unpause` subcommand.
    Here, the container's status will change to the `UP` status again.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要恢复运行容器，请使用`docker container unpause`子命令。在这里，容器的状态将再次变为`UP`状态。
- en: Use the `docker container stop` subcommand to stop the container without removing
    it. The container's status changes to the `EXITED` status.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`docker container stop`子命令停止容器而不删除它。容器的状态将变为`EXITED`状态。
- en: The container will exit if you execute the `docker container kill` or `docker
    container stop` subcommands. To kill the container, use the `docker container
    kill` subcommand. The container status changes to `EXITED`. However, to make the
    container exit, you should use `docker container stop` subcommand and not `docker
    container kill` subcommand. Do not kill your containers; always remove them because
    removing the container triggers a grace shutdown to the container, giving time,
    for example, to save the data to a database, which is a slower process. However,
    killing does not do that and might cause data inconsistency.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器将在执行`docker container kill`或`docker container stop`子命令时退出。要杀死容器，请使用`docker
    container kill`子命令。容器状态将变为`EXITED`。但是，要使容器退出，应该使用`docker container stop`子命令而不是`docker
    container kill`子命令。不要杀死你的容器；总是删除它们，因为删除容器会触发对容器的优雅关闭，给予时间，例如将数据保存到数据库，这是一个较慢的过程。然而，杀死不会这样做，可能会导致数据不一致。
- en: After stopping or killing the container, you can also resume running the container.
    To start the container and return it to the `UP` status, use the `docker container
    start` or `docker container start -a` subcommands. `docker container start -a`
    is equal to running `docker container start` and then `docker container attach`.
    You cannot attach local standard input, output, and error streams to an exited
    container; the container must be in the `UP` state first to attach local standard
    input, output, and error streams.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在停止或杀死容器后，您还可以恢复运行容器。要启动容器并将其返回到`UP`状态，请使用`docker container start`或`docker container
    start -a`子命令。`docker container start -a`等同于运行`docker container start`然后`docker
    container attach`。您不能将本地标准输入、输出和错误流附加到已退出的容器；容器必须首先处于`UP`状态才能附加本地标准输入、输出和错误流。
- en: To restart a container, use the `docker container restart` subcommand. The restart
    subcommand acts like executing `docker container stop` followed by `docker container
    start`.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要重新启动容器，请使用`docker container restart`子命令。重新启动子命令的作用类似于执行`docker container stop`，然后执行`docker
    container start`。
- en: Stopping or killing the container does not remove the container from the system.
    To remove the container entirely, use the `docker container rm` subcommand.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止或杀死容器不会从系统中删除容器。要完全删除容器，请使用`docker container rm`子命令。
- en: Note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can concatenate several Docker commands to each other – for example, `docker
    container rm -f $(docker container ls -aq)`. The one that you want to execute
    first should be included in the brackets.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将几个Docker命令连接在一起 - 例如，`docker container rm -f $(docker container ls -aq)`。您想要首先执行的命令应包含在括号中。
- en: In this case, `docker container ls -aq` tells Docker to list all the containers,
    even the exited one, in quiet mode. The `-a` option denotes displaying all the
    containers, whatever their states are. The `-q` option is used for quiet mode,
    which means displaying the numeric IDs only and not all the containers' details.
    The output of this command, `docker container ls -aq`, will be the input of the
    `docker container rm -f` command.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`docker container ls -aq`告诉Docker以安静模式列出所有容器，甚至是已退出的容器。`-a`选项表示显示所有容器，无论它们的状态如何。`-q`选项用于安静模式，这意味着仅显示数字ID，而不是所有容器的详细信息。此命令的输出`docker
    container ls -aq`将成为`docker container rm -f`命令的输入。
- en: Understanding the Docker container life cycle events provides a good background
    as to why some applications may or may not need persistent storage. Before moving
    on to the different storage types present in Docker, let's execute the aforementioned
    commands and explore the different container states in the following exercise.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Docker容器生命周期事件可以为某些应用程序是否需要持久存储提供良好的背景。在继续讨论Docker中存在的不同存储类型之前，让我们执行上述命令并在以下练习中探索不同的容器状态。
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please use `touch` command to create files and `vim` command to work on the
    file using vim editor.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用`touch`命令创建文件，并使用`vim`命令使用vim编辑器处理文件。
- en: 'Exercise 7.01: Transitioning through the Common States for a Docker Container'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.01：通过Docker容器的常见状态进行过渡
- en: Pinging www.google.com is a common practice to verify that the server or your
    cluster's node is connected to the internet. In this exercise, you will transit
    through all the states for a Docker container while checking whether the server
    or your cluster's node is connected to the internet.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ping www.google.com是验证服务器或集群节点是否连接到互联网的常见做法。在这个练习中，您将在检查服务器或集群节点是否连接到互联网的同时，经历Docker容器的所有状态。
- en: You will use two terminals in this exercise. One terminal will be used to run
    a container to ping www.google.com, and the other one will be used to control
    this running container by executing the previously mentioned commands.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用两个终端。一个终端将用于运行一个容器来ping www.google.com，另一个终端将用于通过执行先前提到的命令来控制这个正在运行的容器。
- en: 'To ping www.google.com, you will craft a container called `testevents` from
    the `ubuntu:14.04` image:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要ping www.google.com，您将从`ubuntu:14.04`镜像中创建一个名为`testevents`的容器：
- en: 'Open the first terminal and execute the `docker container run` command to run
    a container. Use the `--name` option to give the container a specific nickname—for
    example, `testevents`. Don''t let the Docker host generate a random name for your
    container. Use the `ubuntu:14.04` image and the `ping google.com` command to verify
    that the server is running on the container:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开第一个终端并执行`docker container run`命令来运行一个容器。使用`--name`选项为容器指定一个特定的昵称，例如`testevents`。不要让Docker主机为您的容器生成一个随机名称。使用`ubuntu:14.04`镜像和`ping
    google.com`命令来验证服务器是否在容器上运行：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output will be as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see in the preceding output, the pinging has started. You will find
    the packets being transmitted to `google.com`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的输出所示，ping已经开始。您将发现数据包正在传输到`google.com`。
- en: 'Dedicate the first terminal to the pinging output. Now, control this container
    by executing the commands in another terminal. In the second terminal, execute
    `docker container ls` to list all the running containers:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个终端用于ping输出。现在，通过在另一个终端中执行命令来控制此容器。在第二个终端中，执行`docker container ls`以列出所有正在运行的容器：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Look for the container with the name `testevents`. The status should be `Up`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 查找名称为`testevents`的容器。状态应为`Up`：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, run the `docker container pause` command in the second terminal to pause
    the running container in the first terminal:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在第二个终端中运行`docker container pause`命令来暂停第一个终端中正在运行的容器：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You will see that the pinging has stopped, and no packets are being transmitted
    anymore.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到ping已经停止，不再传输数据包。
- en: 'List the running containers again by using `docker container ls` in the second
    terminal:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用第二个终端中的`docker container ls`列出正在运行的容器：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see in the following output, the status of `testevents` is `Up(Paused)`.
    This is because you ran the `docker container pause` command previously:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如下面的输出所示，`testevents`的状态为`Up(Paused)`。这是因为您之前运行了`docker container pause`命令：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Use `docker container unpause` in the second terminal to start the paused container
    and make it resume sending packets:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个终端中使用 `docker container unpause` 来启动暂停的容器，并使其恢复发送数据包：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You will find that the pinging resumes and new packets are transmitted in the
    first terminal.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现 ping 恢复，并且在第一个终端中传输新的数据包。
- en: 'In the second terminal, run the `docker container ls` command again to see
    the container''s current status:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个终端中，再次运行 `docker container ls` 命令以查看容器的当前状态：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You will see that the status of the `testevents` container is `Up`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到 `testevents` 容器的状态是 `Up`：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, run the `docker container stop` command to stop the container:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行 `docker container stop` 命令来停止容器：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You will observe that the container exits and the shell prompt returns in the
    first terminal:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您将观察到容器退出，并且在第一个终端中返回了 shell 提示符：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, run the `docker container ls` command in any terminal:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在任何终端中运行 `docker container ls` 命令：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You will see that the `testevents` container is not in the list anymore because
    the `docker container ls` subcommand displays the up-and-running containers only:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现 `testevents` 容器不再在列表中，因为 `docker container ls` 子命令只显示正在运行的容器：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the `docker container ls -a` command to display all the containers:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `docker container ls -a` 命令来显示所有容器：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can see that the status of the `testevents` container is now `Exited`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到 `testevents` 容器的状态现在是 `Exited`：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use the `docker container start` command to start the container. Also, add
    the `-a` option to attach local standard input, output, and error streams to the
    container and see its output:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `docker container start` 命令来启动容器。另外，添加 `-a` 选项来附加本地标准输入、输出和错误流到容器，并查看其输出：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see in the following snippet, the pinging resumes and is executed
    in the first terminal:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在以下片段中所见，ping 恢复并在第一个终端中执行：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the `docker ls` command again in the second terminal:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个终端中再次运行 `docker ls` 命令：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You will observe that `testevents` returns back to the list, its status is
    `Up`, and it is running:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您将观察到 `testevents` 返回到列表中，其状态为 `Up`，并且正在运行：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, remove the `testevents` container using the `rm` command with the `-f`
    option. The `-f` option is used to force-remove the container:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用带有 `-f` 选项的 `rm` 命令来删除 `testevents` 容器。 `-f` 选项用于强制删除容器：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The first terminal stops executing the `ping` command and the second terminal
    will return the name of the container:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个终端停止执行 `ping` 命令，第二个终端将返回容器的名称：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the `ls -a` command to check whether the container is running or not:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ls -a` 命令来检查容器是否正在运行：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You will not find the `testevents` container in the list because we just removed
    it from our system.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在列表中找不到 `testevents` 容器，因为我们刚刚从系统中删除了它。
- en: 'Now, you have seen all the various statuses of the container except `CREATED`.
    This is typical, as you usually will not see the `CREATED` status. Inside every
    container, there is a main process with a **Process ID (PID)** of 0 and **Parent
    Process ID (PPID)** of 1\. This process has a different ID outside the container.
    When this process is killed or removed, the container is killed or removed as
    well. Normally, when the main process runs, the state of the container changes
    from `CREATED` to `UP`, and this indicates that the container has been created
    successfully. If the main process fails, the container state does not change from
    `CREATED`, and this is what you are going to set up:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经看到了容器的各种状态，除了 `CREATED`。这是很正常的，因为通常不会看到 `CREATED` 状态。在每个容器内部，都有一个主进程，其
    **进程 ID (PID)** 为 0，**父进程 ID (PPID)** 为 1。此进程在容器外部具有不同的 ID。当此进程被终止或移除时，容器也会被终止或移除。通常情况下，当主进程运行时，容器的状态会从
    `CREATED` 改变为 `UP`，这表明容器已成功创建。如果主进程失败，容器状态不会从 `CREATED` 改变，这就是您要设置的内容：
- en: 'Run the following command to see the `CREATED` status. Craft a container named
    `testcreate` from the `ubuntu:14.04` image using the `docker container run` command:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以查看`CREATED`状态。使用`docker container run`命令从`ubuntu:14.04`镜像创建一个名为`testcreate`的容器：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `time` command will generate an error because there is no such command inside
    `ubuntu:14.04`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`命令将生成一个错误，因为`ubuntu:14.04`中没有这样的命令。'
- en: 'Now, list the running containers:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，列出正在运行的容器：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You will see that the list is empty:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到列表是空的：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, list all the containers by adding the `-a` option:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过添加`-a`选项列出所有的容器：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Look in the list for the container named `testcreate`; you will observe that
    its status is `Created`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中查找名为`testcreate`的容器；您会观察到它的状态是`Created`：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If a container is stuck in the `CREATED` state, this is an indication that an
    error has been generated, and Docker was unable to get the container up and running.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个容器停留在`CREATED`状态，这表明已经生成了一个错误，并且Docker无法使容器运行起来。
- en: In this exercise, you explored the container life cycle and its different states.
    You also learned how to start with attachment by using the `docker container start
    -a <container name or ID>` command and how to stop the container using `docker
    container rm <container name or ID>`. In the end, we discussed how to force-remove
    running containers by using `docker container rm -f <container name or ID>`. Then,
    we saw the rare case of `CREATED`, which is shown only when the command generates
    an error and the container fails to start.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您探索了容器的生命周期及其不同的状态。您还学会了如何使用`docker container start -a <container name
    or ID>`命令开始附加，并使用`docker container rm <container name or ID>`停止容器。最后，我们讨论了如何使用`docker
    container rm -f <container name or ID>`强制删除正在运行的容器。然后，我们看到了`CREATED`的罕见情况，只有在命令生成错误并且容器无法启动时才会显示。
- en: So far, we have focused on the container's statuses and not its size. In the
    next exercise, we will learn how to determine the size of the memory occupied
    by the container.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经关注容器的状态而不是其大小。在下一个练习中，我们将学习如何确定容器所占用的内存大小。
- en: 'Exercise 7.02: Checking the Container Size on Disk'
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.02：检查磁盘上容器的大小
- en: 'When you first craft a container, it has the same size as the base image with
    a top read/write layer. With every layer that is added to the container, its size
    increases. In this exercise, you will create a container that has `ubuntu:14.04`
    as its base image. Update and install `wget` on top of it to highlight the effect
    of state transition on data retention:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当您首次创建一个容器时，它的大小与基础镜像相同，并带有一个顶部的读/写层。随着每个添加到容器中的层，其大小都会增加。在这个练习中，您将创建一个以`ubuntu:14.04`作为基础镜像的容器。在其上更新并安装`wget`以突出状态转换对数据保留的影响：
- en: 'Run the `docker container run` command with the `-it` option to create a container
    named `testsize`. The `-it` option is used to have an interactive terminal to
    run commands inside the running container:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-it`选项运行`docker container run`命令以创建一个名为`testsize`的容器。`-it`选项用于在运行的容器内部运行命令时具有交互式终端：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The prompt will now look like `root@<container ID>:/#`, where the container
    ID is a number that the Docker Engine generates. Therefore, you will have a different
    number when you run this command on your machine. As mentioned before, being inside
    a container means that the container will be in the `UP` state.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 提示现在会变成`root@<container ID>:/#`，其中容器ID是Docker Engine生成的一个数字。因此，当您在自己的机器上运行此命令时，会得到一个不同的数字。如前所述，处于容器内意味着容器将处于`UP`状态。
- en: Dedicate the first terminal to the running container and execute the commands
    in the second terminal. Having two terminals saves us from detaching the container
    to run a command and then reattaching to the container to run another command
    inside it.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个终端专用于运行的容器，并在第二个终端中执行命令。有两个终端可以避免我们分离容器来运行命令，然后重新附加到容器以在其中运行另一个命令。
- en: 'Now, verify that the container initially has the size of the base image, which
    is `ubuntu:14.04`. List the images using the `docker image ls` command in the
    second terminal. Check the size of the `ubuntu:14.04` image:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，验证容器最初是否具有`ubuntu:14.04`基础镜像的大小。使用`docker image ls`命令在第二个终端中列出镜像。检查`ubuntu:14.04`镜像的大小：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see in the following output, the size of the image is `188MB`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如下输出所示，镜像的大小为`188MB`：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, check the size of the container by running the `docker container ls -s`
    command to get the container''s size:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过运行`docker container ls -s`命令来检查容器的大小：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Look for the `testsize` container. You will observe that the size is `0B (virtual
    188MB)`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找`testsize`容器。您会发现大小为`0B（虚拟188MB）`：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `SIZE` column indicates the size of the thin read/write layer of the container
    only, while the virtual size indicates the size of the thin read/write layer and
    all the previous layers encapsulated in the container. Thus, in this case, the
    thin layer equals `0B`, and the virtual size equals the image size.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIZE`列指示容器的薄读/写层的大小，而虚拟大小指示容器中封装的所有先前层的薄读/写层的大小。因此，在这种情况下，薄层的大小为`0B`，虚拟大小等于镜像大小。'
- en: 'Now, install the `wget` package. Run the `apt-get update` command in the first
    terminal. A general recommendation, in Linux, is to run `apt-get update` before
    installing any packages to update the latest versions of the packages that are
    currently on your system:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，安装`wget`软件包。在第一个终端中运行`apt-get update`命令。在Linux中，一般建议在安装任何软件包之前运行`apt-get
    update`以更新系统上当前软件包的最新版本：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the following command when the container finishes updating to install the
    `wget` package on top of the base image. The `-y` option is used to answer yes
    automatically to all the installation questions:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当容器完成更新后，运行以下命令以在基础镜像上安装`wget`软件包。使用`-y`选项自动回答所有安装问题为是。
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When it finishes installing `wget` on top of `ubuntu:14.04`, recheck the container''s
    size by running the `ls -s` command in the second terminal:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在在`ubuntu:14.04`上安装`wget`完成后，通过在第二个终端中运行`ls -s`命令来重新检查容器的大小：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see from the following snippet, the size of the `testsize` container
    is `27.8 MB (virtual 216 MB)`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如下片段所示，`testsize`容器的大小为`27.8MB（虚拟216MB）`：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, the thin layer equals `27.8MB`, and the virtual size equals the size of
    all the layers. In this exercise, the layers are the base image, with a size of
    188 MB; the update; and the `wget` layer, which has a size of 27.8 MB. Therefore,
    the total size will be 216 MB after approximation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，薄层的大小为`27.8MB`，虚拟大小等于所有层的大小。在这个练习中，层包括基础镜像，大小为188MB；更新；以及`wget`层，大小为27.8MB。因此，近似后总大小将为216MB。
- en: In this exercise, you learned about the function of the `-s` option used with
    the `docker container ls` subcommand. This option is used to display the size
    of the base image and the size of the top writable layer. Knowing the size that
    every container consumes is useful to avoid an out-of-disk-space exception. Moreover,
    it can help us in troubleshooting and setting a maximum size for every container.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您了解了`docker container ls`子命令中使用的`-s`选项的功能。此选项用于显示基础镜像和顶部可写层的大小。了解每个容器消耗的大小对于避免磁盘空间不足异常是有用的。此外，它可以帮助我们进行故障排除并为每个容器设置最大大小。
- en: Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Docker uses storage drivers to write in the writable layer. The storage drivers
    differ depending on the operating system that you are using. To find the updated
    list of storage drivers, check out https://docs.docker.com/storage/storagedriver/select-storage-driver/.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使用存储驱动程序来写入可写层。存储驱动程序取决于您使用的操作系统。要查找更新的存储驱动程序列表，请访问https://docs.docker.com/storage/storagedriver/select-storage-driver/。
- en: To find out what driver your operating system is using, run the `$docker info`
    command.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出您的操作系统正在使用哪个驱动程序，请运行`$docker info`命令。
- en: An understanding of Docker container life cycle events provides a good background
    when studying why some applications may or may not need persistent storage and
    outlines the default host storage area (filesystem location) for Docker before
    a container is explicitly removed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Docker容器生命周期事件可以为研究某些应用程序是否需要持久存储提供良好的背景，并概述了在容器明确移除之前Docker的默认主机存储区域（文件系统位置）。
- en: Now, let's delve into the stateful and stateless modes to decide which container
    needs persistent storage.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入研究有状态和无状态模式，以决定哪个容器需要持久存储。
- en: Stateful versus Stateless Containers/Services
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有状态与无状态容器/服务
- en: 'Containers and services can run in two modes: **stateful** and **stateless**.
    A stateless service is the one that does not retain persistent data. This type
    is much easier to scale and update than the stateful one. A stateful service requires
    persistent storage (as in databases). Therefore, it is harder to dockerize because
    stateful services need synchronization with the other components of the application.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和服务可以以两种模式运行：**有状态**和**无状态**。无状态服务是不保留持久数据的服务。这种类型比有状态服务更容易扩展和更新。有状态服务需要持久存储（如数据库）。因此，它更难dockerize，因为有状态服务需要与应用程序的其他组件同步。
- en: Say you're dealing with an application that needs a certain file in order to
    work correctly. If this file is saved inside a container, as in the stateful mode,
    when this container is removed for whatever reason, the whole application crashes.
    However, if this file is saved in a volume or an external database, any container
    will be able to access it, and the application will work fine. Say business is
    booming and we need to scale up the number of containers running to fulfill the
    clients' needs. All the containers will be able to access the file, and scaling
    will be easy and smooth.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在处理一个需要某个文件才能正常工作的应用程序。如果这个文件保存在容器内，就像有状态模式一样，当这个容器因任何原因被移除时，整个应用程序就会崩溃。然而，如果这个文件保存在卷或外部数据库中，任何容器都可以访问它，应用程序将正常工作。假设业务蒸蒸日上，我们需要增加运行的容器数量来满足客户的需求。所有容器都可以访问该文件，并且扩展将变得简单和顺畅。
- en: Apache and NGINX are examples of stateless services, while databases are examples
    of stateful containers. The *Docker Volumes and Stateful Persistence* section
    will focus on volumes that are needed for database images to operate properly.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Apache和NGINX是无状态服务的示例，而数据库是有状态容器的示例。*Docker卷和有状态持久性*部分将重点关注数据库镜像所需的卷。
- en: In the following exercises, you will first create a stateless service and then
    a stateful one. Both will use the Docker playground, which is a website that offers
    Docker Engine in a matter of seconds. It is a free virtual machine in a browser,
    where you can execute Docker commands and create clusters in swarm mode.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，您将首先创建一个无状态服务，然后创建一个有状态服务。两者都将使用Docker游乐场，这是一个网站，可以在几秒钟内提供Docker Engine。这是一个免费的虚拟机浏览器，您可以在其中执行Docker命令并在集群模式下创建集群。
- en: 'Exercise 7.03: Creating and Scaling a Stateless Service, NGINX'
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.03：创建和扩展无状态服务，NGINX
- en: Usually, in web-based applications, there is a frontend and a backend. For example,
    in the Panoramic Trekking application, you use NGINX in the frontend because it
    can handle a high volume of connections and distribute the loads to the slower
    database in the backend. Therefore, NGINX is used as the reverse proxy server
    and load balancer.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在基于Web的应用程序中，有前端和后端。例如，在全景徒步应用程序中，您在前端使用NGINX，因为它可以处理大量连接并将负载分发到后端较慢的数据库。因此，NGINX被用作反向代理服务器和负载均衡器。
- en: 'In this exercise, you will focus on creating a stateless service, NGINX, solely,
    and see how easy it is to scale it. You will initialize a swarm to create a cluster
    and scale NGINX on it. You will use the Docker playground to work in swarm mode:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将专注于创建一个无状态服务，仅仅是NGINX，并看看它有多容易扩展。您将初始化一个swarm来创建一个集群，并在其上扩展NGINX。您将使用Docker
    playground在swarm模式下工作：
- en: 'Connect to the Docker playground at https://labs.play-with-docker.com/, as
    in *Figure 7.2*:![Figure 7.2: The Docker playground'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到Docker playground，网址为https://labs.play-with-docker.com/，如*图7.2*所示：![图7.2：Docker
    playground
- en: '](image/B15021_07_02.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_07_02.jpg)'
- en: 'Figure 7.2: The Docker playground'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：Docker playground
- en: 'Click on `ADD NEW INSTANCE` in the left menu to create a new node. Get the
    node IP from the top node information section. Now, create a swarm using the `docker
    swarm init` command with the `–advertise-addr` option to specify the node IP.
    As in *Figure 7.2*, the Docker Engine generates a long token to allow other nodes,
    whether managers or workers, to join the cluster:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中点击`ADD NEW INSTANCE`来创建一个新节点。从顶部节点信息部分获取节点IP。现在，使用`docker swarm init`命令创建一个swarm，并使用`–advertise-addr`选项指定节点IP。如*图7.2*所示，Docker引擎生成一个长令牌，允许其他节点（无论是管理节点还是工作节点）加入集群：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Use the `docker service create` command to create a service and specify port
    `80` using the `-p` option. Set the number of replicas as `2` for the `--replicas`
    option of the `nginx:1.14.2` image:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker service create`命令创建一个服务，并使用`-p`选项指定端口`80`。将`--replicas`选项的副本数设置为`2`，使用`nginx:1.14.2`镜像：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `docker service create` command creates two replica services from the `nginx:1.14.2`
    image at port `80` inside the container. The Docker daemon chooses any available
    host port. In this case, it chooses port `30000`, as shown at the top of *Figure
    7.2*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker service create`命令从容器内的`nginx:1.14.2`镜像创建了两个副本服务，端口为`80`。Docker守护程序选择任何可用的主机端口。在这种情况下，它选择了端口`30000`，如*图7.2*顶部所示。'
- en: 'To verify that the service has been created, list all of the available services
    using the `docker service ls` command:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证服务是否已创建，使用`docker service ls`命令列出所有可用的服务：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As shown in the following output, the Docker daemon auto-generated a service
    ID and assigned a name, `amazing_hellman`, to the service because you did not
    specify one using the `--name` option:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如下输出所示，Docker守护程序自动生成了一个服务ID，并为服务分配了一个名为`amazing_hellman`的名称，因为您没有使用`--name`选项指定一个名称：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In a container, the Docker daemon assigns a random **adjective_noun** name to
    the container.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中，Docker守护程序为容器分配一个随机的**形容词_名词**名称。
- en: 'Use the `curl <IP:Port Number>` Linux command to see the output of the service
    and connect to it without using a browser:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl <IP:Port Number>` Linux命令来查看服务的输出并连接到它，而不使用浏览器：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output is an HTML version of the welcome page of `NGINX`. This indicates
    it has been installed correctly:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是`NGINX`欢迎页面的HTML版本。这表明它已经正确安装：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Assume that business is booming even more, and two replicas are not enough.
    You need to scale it to five replicas instead of two. Use the `docker service
    scale <service name>=<number of replicas>` subcommand:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设业务更加繁荣，两个副本已经不够了。您需要将其扩展到五个副本，而不是两个。使用`docker service scale <service name>=<number
    of replicas>`子命令：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You will get an output like the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得以下输出：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To verify that the Docker swarm replicated the service, use the `docker service
    ls` subcommand one more time:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证Docker Swarm是否复制了服务，请再次使用`docker service ls`子命令：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output shows that the number of replicas increased from `2` to `5` replicas:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示副本数量从`2`增加到`5`个副本：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Delete the service using the `docker service rm` subcommand:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker service rm`子命令删除服务：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The command will return the name of the service:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回服务的名称：
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To verify that the service has been deleted, list the service one more time
    using the `docker service ls` subcommand:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证服务是否已删除，请再次使用`docker service ls`子命令列出服务：
- en: '[PRE49]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output will be an empty list:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是一个空列表：
- en: '[PRE50]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this exercise, you deployed a stateless service, NGINX, and scaled it using
    the `docker service scale` command. You then used the Docker playground (a free
    solution that you can use to create a cluster, and Swarm to initialize a swarm).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您部署了一个无状态服务NGINX，并使用`docker service scale`命令进行了扩展。然后，您使用了Docker playground（一个免费的解决方案，您可以使用它来创建一个集群，并使用Swarm来初始化一个Swarm）。
- en: Note
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This exercise uses Docker Swarm. To do the same using Kubernetes, you can follow
    the steps at https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习使用Docker Swarm。要使用Kubernetes做同样的事情，您可以按照https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/上的步骤进行操作。
- en: Now, we are done with the frontend example of NGINX. In the next exercise, you
    will see how to create a stateful service that requires persistent data. We will
    use a database service, MySQL, to complete the following exercise.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们完成了NGINX的前端示例。在下一个练习中，您将看到如何创建一个需要持久数据的有状态服务。我们将使用数据库服务MySQL来完成以下练习。
- en: 'Exercise 7.04: Deploying a Stateful Service, MySQL'
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.04：部署有状态服务，MySQL
- en: As mentioned previously, web-based applications have a frontend and a backend.
    You have already seen an example of the frontend component in the previous exercise.
    In this exercise, you will deploy a single stateful MySQL container to be the
    database as a backend component.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，基于Web的应用程序有前端和后端。您已经在上一个练习中看到了前端组件的示例。在这个练习中，您将部署一个单个有状态的MySQL容器作为后端组件的数据库。
- en: 'To install MySQL, follow the steps at https://hub.docker.com/_/mysql in the
    `via stack deploy` section. Select and copy the `stack.yml` file to memory:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装MySQL，请按照https://hub.docker.com/_/mysql中的`通过stack deploy`部分的步骤进行操作。选择并复制`stack.yml`文件到内存：
- en: 'Use an editor to paste the `stack.yml` file. You can use the `vi` or `nano`
    Linux commands to open a text editor in Linux and paste the YAML file:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器粘贴`stack.yml`文件。您可以使用`vi`或`nano` Linux命令在Linux中打开文本编辑器并粘贴YAML文件：
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Paste the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 粘贴以下代码：
- en: '[PRE52]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In this YAML file, you have two services: `db` and `adminer`. The `db` service
    is based on the `mysql` image, while the `adminer` image is the base image of
    the `adminer` service. The `adminer` image is a database management tool. In the
    `db` service, you enter the command and set the environment variable, which has
    the database password with a policy to always restart if it fails for any reason.
    Also, in the `adminer` service, the policy is set to always restart if it fails
    for any reason.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个YAML文件中，您有两个服务：`db`和`adminer`。`db`服务基于`mysql`镜像，而`adminer`镜像是`adminer`服务的基础镜像。`adminer`镜像是一个数据库管理工具。在`db`服务中，您输入命令并设置环境变量，其中包含具有始终重新启动策略的数据库密码，如果出现任何原因失败。同样，在`adminer`服务中，如果出现任何原因失败，策略也被设置为始终重新启动。
- en: 'Press the *Esc* key on the keyboard. Then, run the following command to quit
    and save the code:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在键盘上按*Esc*键。然后，运行以下命令退出并保存代码：
- en: '[PRE53]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To verify that the file has saved correctly, use the `cat` Linux command to
    display the `stack.yml` contents:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证文件是否已正确保存，请使用`cat` Linux命令显示`stack.yml`的内容：
- en: '[PRE54]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The file will be displayed. If there is an error, repeat the previous steps.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 文件将被显示。如果出现错误，请重复上一步。
- en: 'If the code is correct, deploy the `YML` file by using the `docker stack deploy`
    subcommand:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果代码正确，请使用`docker stack deploy`子命令部署`YML`文件：
- en: '[PRE55]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You should see an output like the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到如下输出：
- en: '[PRE56]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To connect to the service, right-click on port `8080` at the top beside the
    node IP in the Docker playground window and open it in a new window:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到服务，请在Docker playground窗口顶部的节点IP旁边右键单击端口`8080`，并在新窗口中打开它：
- en: '![Figure 7.3: Connecting to the service'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3：连接到服务'
- en: '](image/B15021_07_03.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_07_03.jpg)'
- en: 'Figure 7.3: Connecting to the service'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：连接到服务
- en: 'Use the `docker stack ls` subcommand to list the stacks:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker stack ls`子命令列出堆栈：
- en: '[PRE57]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You should see an output like the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到如下输出：
- en: '[PRE58]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Use the `docker stack rm` subcommand to remove the stack:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker stack rm`子命令来移除堆栈：
- en: '[PRE59]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When removing the stack, Docker will remove the two services: `db` and `adminer`.
    It will also remove the network that it created by default to connect all the
    services:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在移除堆栈时，Docker将移除两个服务：`db`和`adminer`。它还将移除默认创建的用于连接所有服务的网络：
- en: '[PRE60]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this exercise, you deployed a stateful service, MySQL, and were able to access
    the database service from the browser. Again, we used the Docker playground as
    our platform to execute the exercise.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您部署了一个有状态的服务MySQL，并能够从浏览器访问数据库服务。同样，我们使用Docker playground作为执行练习的平台。
- en: Note
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Replicating MySQL is not an easy task. You cannot run multiple replicas on one
    data folder as we did in *Exercise 7.03*, *Creating and Scaling a Stateless Service,
    NGINX*. This way does not work because data consistency and database locking and
    caching must be applied to ensure your data is correct. Hence, MySQL uses a master
    and subordinate replication, where you write to the master, and the data gets
    synchronized to the subordinates. To find out more about MySQL replication, please
    visit https://dev.mysql.com/doc/refman/8.0/en/replication.html.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 复制MySQL并不是一件容易的事情。您不能像在*练习7.03*，*创建和扩展无状态服务，NGINX*中那样在一个数据文件夹上运行多个副本。这种方式不起作用，因为必须应用数据一致性、数据库锁定和缓存以确保您的数据正确。因此，MySQL使用主从复制，您在主服务器上写入数据，然后数据同步到从服务器。要了解更多关于MySQL复制的信息，请访问https://dev.mysql.com/doc/refman/8.0/en/replication.html。
- en: We have learned that containers need persistent storage that outlives the container
    life cycle but have not yet covered how to do that. In the next section, we will
    learn about volumes to save persistent data.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到容器需要持久存储，超出容器生命周期，但还没有涵盖如何做到这一点。在下一节中，我们将学习关于卷来保存持久数据。
- en: Docker Volumes and Stateful Persistence
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker卷和有状态的持久性
- en: 'We can use volumes to save persistent data without relying on the containers.
    You can think of a volume as a shared folder. In any instance, if you mount the
    volume to any number of containers, the containers will be able to access the
    data in the volume. There are two ways to create a volume:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用卷来保存持久数据，而不依赖于容器。您可以将卷视为一个共享文件夹。在任何情况下，如果您将卷挂载到任意数量的容器中，这些容器将能够访问卷中的数据。创建卷有两种方式：
- en: Create a volume as an independent entity outside any container by using the
    `docker volume create` subcommand.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`docker volume create`子命令，创建一个独立于任何容器之外的卷。
- en: Creating a volume as an independent object from the container adds flexibility
    to data management. These types of volumes are also called **named volumes** because
    you specify a name for it, rather than leaving the Docker Engine to generate an
    anonymous numeric one. Named volumes outlive all the containers that are in the
    system and preserve its data.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将卷作为容器之外的独立对象创建，可以增加数据管理的灵活性。这些类型的卷也被称为**命名卷**，因为您为其指定了一个名称，而不是让Docker引擎生成一个匿名的数字名称。命名卷会比系统中的所有容器存在更久，并保留其数据。
- en: Despite these volumes being mounted to containers, the volumes will not be deleted
    even when all the containers in the system are deleted.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些卷被挂载到容器中，但即使系统中的所有容器都被删除，这些卷也不会被删除。
- en: Create a volume by using the `--mount` or `-v` or `--volume` options in the
    `docker container run` subcommand. Docker creates an anonymous volume for you.
    When the container is removed, the volume will not be removed as well unless indicated
    explicitly by using the `-v` option to the `docker container rm` subcommand or
    using a `docker volume rm` subcommand.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在`docker container run`子命令中使用`--mount`或`-v`或`--volume`选项创建一个卷。Docker会为您创建一个匿名卷。当容器被删除时，除非使用`-v`选项显式指示`docker
    container rm`子命令或使用`docker volume rm`子命令，否则卷也不会被删除。
- en: The following exercise will provide an example of each method.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习将提供每种方法的示例。
- en: 'Exercise 7.05: Managing a Volume outside the Container''s Scope and Mounting
    It to the Container'
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.05：管理容器范围之外的卷并将其挂载到容器
- en: 'In this exercise, you will create a volume that is not confined to a container.
    You will start by creating a volume, mounting it to a container, and saving some
    data on it. You will then delete the container and list the volume to check whether
    the volume persists even when you do not have a container on your system:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建一个不受限于容器的卷。您将首先创建一个卷，将其挂载到一个容器上，并在上面保存一些数据。然后您将删除容器并列出卷，以检查即使在系统中没有容器时，卷是否仍然存在：
- en: 'Create a volume named `vol1` using the `docker volume create` command:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker volume create`命令创建名为`vol1`的卷：
- en: '[PRE61]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The command will return the name of the volume, as shown:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回卷的名称，如下所示：
- en: '[PRE62]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'List all the volumes using the `docker volume ls` command:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker volume ls`命令列出所有卷：
- en: '[PRE63]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This will result in the following output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '[PRE64]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Inspect the volume to get its mount point using the following command:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查卷以获取其挂载点：
- en: '[PRE65]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You should get an output like the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到以下输出：
- en: '[PRE66]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The volume inspection shows the date and time of its creation, its mount path,
    its name, and its scope.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 卷检查显示了其创建日期和时间、挂载路径、名称和范围。
- en: 'Mount the volume to a container and modify its contents. Any data that is added
    to `vol1` will be copied to the volume inside the container:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将卷挂载到容器并修改其内容。添加到`vol1`的任何数据都将被复制到容器内的卷中：
- en: '[PRE67]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In the preceding command, you have crafted a container from the `ubuntu:14.04`
    image with the `bash` command. The `bash` command allows you to enter the commands
    inside the container. The `-it` option is used to have an interactive terminal.
    The `-v` option is for synchronizing the data between `vol1` at the host and `container_vol`
    inside the container. Use the `--name` option to name the container `container1`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，您使用`ubuntu:14.04`镜像和`bash`命令创建了一个容器。`bash`命令允许您在容器内部输入命令。`-it`选项用于启用交互式终端。`-v`选项用于在主机和容器内部的`container_vol`之间同步数据。使用`--name`选项为容器命名为`container1`。
- en: 'The prompt changes, indicating that you are now inside the container. Write
    the word `hello` in a file called `new_file.txt` onto the volume. The volume inside
    the container is called `container_vol`. In this case, this volume is shared between
    the host and the container. From the host, the volume is called `vol1`:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示会改变，表示您现在在容器内。在名为`new_file.txt`的文件中写入单词`hello`到卷中。容器内的卷称为`container_vol`。在这种情况下，该卷在主机和容器之间共享。从主机上，该卷称为`vol1`：
- en: '[PRE68]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'List the contents of the volume to verify that the file is saved:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出卷的内容以验证文件是否已保存：
- en: '[PRE69]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Exit the container using the `exit` command:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`exit`命令退出容器：
- en: '[PRE70]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Check the contents of the new file from the host by running the following command:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令检查来自主机的新文件的内容：
- en: '[PRE71]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The command will return the name of the new file:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回新文件的名称：
- en: '[PRE72]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Verify that the word `hello`, as the content of the file, is saved as well
    by running the following command:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令验证单词`hello`作为文件内容是否也已保存：
- en: '[PRE73]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Remove the container with the `-v` option to remove any volumes that are created
    within the container''s scope:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-v`选项删除容器以删除在容器范围内创建的任何卷：
- en: '[PRE74]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The command will return the name of the container:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回容器的名称：
- en: '[PRE75]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Verify that the volume still exists by listing all the volumes:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过列出所有卷来验证卷是否仍然存在：
- en: '[PRE76]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The volume, `vol1`, is listed, indicating that the volume was created outside
    the container, and even by using the `-v` option, it will not be removed when
    the container is removed:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 卷`vol1`被列出，表明该卷是在容器之外创建的，即使使用`-v`选项，当容器被删除时也不会被删除：
- en: '[PRE77]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, remove the volume using the `rm` command:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`rm`命令删除卷：
- en: '[PRE78]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The command should return the name of the volume:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应返回卷的名称：
- en: '[PRE79]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Verify that the volume is removed by listing the current list of volumes:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过列出当前的卷列表来验证卷是否已被删除：
- en: '[PRE80]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'An empty list will be displayed, indicating that the volume has been removed:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示一个空列表，表明卷已被删除：
- en: '[PRE81]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In this exercise, you learned how to create volumes as independent objects in
    Docker without being within the container's scope, and how to mount this volume
    to a container. The volume was not removed when you removed the container because
    the volume was created outside the container's scope. In the end, you learned
    how to remove these types of volumes.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您学会了如何在Docker中创建独立的卷对象，而不在容器的范围内，并且如何将这个卷挂载到容器上。卷在删除容器时没有被删除，因为卷是在容器范围之外创建的。最后，您学会了如何删除这些类型的卷。
- en: In the next exercise, we will create, manage, and remove an unnamed or anonymous
    volume that is within the container's scope.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将创建、管理和删除一个在容器范围内的未命名或匿名卷。
- en: 'Exercise 7.06: Managing a Volume within the Container''s Scope'
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.06：管理容器范围内的卷
- en: 'You do not need to create the volume before running the container as in the
    previous example. Docker will create an unnamed volume for you automatically.
    Again, the volume will not be removed when the container is removed, unless you
    specify the `-v` option in the `docker container rm` subcommand. In this exercise,
    you will create an anonymous volume within the container''s scope and then learn
    how to remove it:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行容器之前，您不需要创建卷。Docker会自动为您创建一个无名卷。同样，除非在`docker container rm`子命令中指定`-v`选项，否则在删除容器时不会删除卷。在这个练习中，您将在容器的范围内创建一个匿名卷，然后学习如何删除它：
- en: 'Create a container with an anonymous volume using the following command:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个带有匿名卷的容器：
- en: '[PRE82]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The command should return a long hex digit number, which is the volume ID.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应返回一个长的十六进制数字，这是卷的ID。
- en: 'List all the volumes:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出所有卷：
- en: '[PRE83]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Observe that this time, `VOLUME NAME` is a long hex digit number and not a
    name. This type of volume is called an anonymous volume and can be removed by
    adding the `-v` option to the `docker container rm` subcommand:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次 `VOLUME NAME` 是一个长的十六进制数字，而不是一个名称。这种类型的卷被称为匿名卷，可以通过在 `docker container
    rm` 子命令中添加 `-v` 选项来删除：
- en: '[PRE84]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Remove the container with the volume, this time. Use the `-f` option to force
    remove the container since it is in detached mode and running in the background.
    Add the `v` option (making this `-fv`) to remove the volume as well. If this volume
    is not anonymous, and you named it, it will not be removed by this option and
    you must use `docker volume rm <volume name>` to remove it:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次删除带有卷的容器。由于它处于分离模式并在后台运行，使用 `-f` 选项强制删除容器。还添加 `v` 选项（使其为 `-fv`）以删除卷。如果这个卷不是匿名的，并且您为其命名了，那么它将不会被此选项删除，您必须使用
    `docker volume rm <volume name>` 来删除它：
- en: '[PRE85]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The command will return the name of the container.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回容器的名称。
- en: 'Verify that the volume has been removed. Use the `docker volume ls` subcommand,
    and you will observe that the list is empty:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证卷已被删除。使用 `docker volume ls` 子命令，您会发现列表为空：
- en: '[PRE86]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Compared to the previous exercise, the volume was removed when the container
    was removed by using the `-v` option in the `rm` subcommand. Docker removed the
    volume this time because the volume was initially created within the container's
    scope.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的练习相比，使用 `-v` 选项在删除容器时删除了卷。Docker这次删除了卷，因为卷最初是在容器的范围内创建的。
- en: Note
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 1\. If you are mounting a volume to a service and not to a container, you cannot
    use the `-v` or `--volume` options. You must use the `--mount` option.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 如果您将卷挂载到服务而不是容器，则不能使用 `-v` 或 `--volume` 选项。您必须使用 `--mount` 选项。
- en: 2\. To delete all the anonymous volumes that were not removed when their containers
    were removed, you can use the `docker volume prune` subcommand.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 要删除所有未在其容器被删除时删除的匿名卷，您可以使用 `docker volume prune` 子命令。
- en: For further details, visit https://docs.docker.com/storage/volumes/.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请访问 https://docs.docker.com/storage/volumes/。
- en: Now, we are going to see some more examples of volumes being used with stateful
    containers. Remember that using volumes with stateful containers as databases
    is the best practice. Containers are ephemeral, while data on databases should
    be saved as a persistent volume, where any new container can pick up and use the
    saved data. Therefore, the volume must be named, and you should not leave Docker
    to automatically generate an anonymous volume with a hex digit number as its name.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到一些更多的例子，展示卷与有状态容器一起使用。请记住，将卷与有状态容器（如数据库）一起使用是最佳实践。容器是临时的，而数据库上的数据应该保存在持久卷中，任何新容器都可以获取并使用保存的数据。因此，卷必须被命名，您不应该让Docker自动生成一个带有十六进制数字作为名称的匿名卷。
- en: In the next exercise, you will run a PostgreSQL database container with a volume.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将运行一个带有卷的PostgreSQL数据库容器。
- en: 'Exercise 7.07: Running a PostgreSQL Container with a Volume'
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.07：运行带有卷的PostgreSQL容器
- en: 'Say you work in an organization where a PostgreSQL container with a database
    volume is used and the container gets deleted due to some mishap. However, the
    data persisted and outlived the container. In this exercise, you will run a PostgreSQL
    container with a database volume:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您在一个使用带有数据库卷的PostgreSQL容器的组织中工作，由于某些意外情况，容器被删除了。但是，数据仍然存在并且超出了容器的生存期。在这个练习中，您将运行一个带有数据库卷的PostgreSQL容器：
- en: 'Run a PostgreSQL container with a volume. Name the container `db1`. If you
    do not have the image locally, Docker will pull the image for you. Create a container
    called `db1` from the `postgress` image. Use the `-v` option to share the `db`
    volume at the host with `/var/lib/postgresql/data` inside the container and the
    `-e` option to echo SQL to the standard output stream as well. Use the `POSTGRES_PASSWORD`
    option to set the database password and the `-d` option to run this container
    in detached mode:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一个带有卷的PostgreSQL容器。将容器命名为`db1`。如果您本地没有该镜像，Docker将为您拉取镜像。从`postgress`镜像创建一个名为`db1`的容器。使用`-v`选项将主机上的`db`卷与容器内的`/var/lib/postgresql/data`共享，并使用`-e`选项将SQL回显到标准输出流。使用`POSTGRES_PASSWORD`选项设置数据库密码，并使用`-d`选项以分离模式运行此容器：
- en: '[PRE87]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Use the `exec` command to interact with the container from `bash`. The `exec`
    command does not create a new process but rather replaces `bash` with the command
    to be executed. Here, the prompt will change to `posgres=#` to indicate that you
    are inside the `db1` container:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`exec`命令与容器进行交互，从`bash`中执行命令。`exec`命令不会创建新进程，而是用要执行的命令替换`bash`。在这里，提示将更改为`posgres=#`，表示您在`db1`容器内：
- en: '[PRE88]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The `psql` command allows you to interactively enter, edit, and execute SQL
    commands. The `-U` option is used to enter the database's username, which is `postgres`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`psql`命令允许您交互式输入、编辑和执行SQL命令。使用`-U`选项输入数据库的用户名，即`postgres`。'
- en: 'Create a table, `PEOPLE`, with two columns – `Name` and `age`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PEOPLE`的表，有两列 - `Name`和`age`：
- en: '[PRE89]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Insert some values into the `PEOPLE` table:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`PEOPLE`表中插入一些值：
- en: '[PRE90]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Verify that the values are inserted correctly in the table:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证表中的值是否正确插入：
- en: '[PRE91]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The command will return two rows, which verifies that the data has been inserted
    correctly:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回两行，验证数据已正确插入：
- en: '![Figure 7.4: Output of the SELECT statement'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4：SELECT语句的输出'
- en: '](image/B15021_07_04.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_07_04.jpg)'
- en: 'Figure 7.4: Output of the SELECT statement'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：SELECT语句的输出
- en: 'Exit the container to quit the database. The shell prompt will return:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出容器以退出数据库。shell提示将返回：
- en: '[PRE92]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Verify that your volume is a named one and not anonymous using the `volume
    ls` command:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`volume ls`命令验证您的卷是否是命名卷而不是匿名卷：
- en: '[PRE93]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'You should get an output like the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到以下输出：
- en: '[PRE94]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Remove the `db1` container with the `-v` option:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-v`选项删除`db1`容器：
- en: '[PRE95]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The command will return the name of the container:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回容器的名称：
- en: '[PRE96]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'List the volumes:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出卷：
- en: '[PRE97]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The list shows that the volume is still there and is not removed with the container:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 列表显示卷仍然存在，并且未随容器一起删除：
- en: '[PRE98]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'As in *step 1*, create a new container called `db2` and mount the volume, `db`:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与*步骤1*一样，创建一个名为`db2`的新容器，并挂载卷`db`：
- en: '[PRE99]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Run the `exec` command to execute the commands from `bash` and verify that
    the data persists even when `db1` is removed:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`exec`命令从`bash`执行命令，并验证即使删除`db1`，数据仍然存在：
- en: '[PRE100]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The preceding commands will result in an output like the following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将导致以下输出：
- en: '![Figure 7.5: Output of the SELECT statement'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5：SELECT语句的输出'
- en: '](image/B15021_07_05.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_07_05.jpg)'
- en: 'Figure 7.5: Output of the SELECT statement'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：SELECT语句的输出
- en: 'Exit the container to quit the database:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出容器以退出数据库：
- en: '[PRE101]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now, remove the `db2` container using the following command:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令删除`db2`容器：
- en: '[PRE102]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The command will return the name of the container:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回容器的名称：
- en: '[PRE103]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Remove the `db` volume using the following command:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令删除`db`卷：
- en: '[PRE104]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The command will return the name of the volume:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回卷的名称：
- en: '[PRE105]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: In this exercise, you used a named volume to save your database to keep the
    data persistent. You saw that the data persisted even after you removed the container.
    The new container was able to catch up and access the data that you saved in your
    database.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您使用了一个命名卷来保存您的数据库以保持数据持久。您看到即使在删除容器后数据仍然持久存在。新容器能够追上并访问您在数据库中保存的数据。
- en: In the next exercise, you will run a PostgreSQL database without a volume to
    compare its effect with that of the previous exercise.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将运行一个没有卷的PostgreSQL数据库，以比较其效果与上一个练习的效果。
- en: 'Exercise 7.08: Running a PostgreSQL Container without a Volume'
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.08：运行没有卷的PostgreSQL容器
- en: 'In this exercise, you will run a default PostgreSQL container without a database
    volume. You will then remove the container and its anonymous volume to check whether
    the data persisted after the removal of the container:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将运行一个默认的PostgreSQL容器，而不使用数据库卷。然后，您将删除容器及其匿名卷，以检查在删除容器后数据是否持久存在：
- en: 'Run a PostgreSQL container without a volume. Name the container `db1`:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一个没有卷的PostgreSQL容器。将容器命名为`db1`：
- en: '[PRE106]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Run the `exec` command to execute the commands from `bash`. The prompt will
    change to `posgres=#` to indicate that you are inside the `db1` container:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`exec`命令以执行来自`bash`的命令。提示将更改为`posgres=#`，表示您在`db1`容器内：
- en: '[PRE107]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Create a table, `PEOPLE`, with two columns – `NAME` and `AGE`:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PEOPLE`的表，其中包含两列 - `NAME`和`AGE`：
- en: '[PRE108]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Insert some values in the `PEOPLE` table:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PEOPLE`表中插入一些值：
- en: '[PRE109]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Verify that the values are inserted correctly in the table:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证表中的值是否已正确插入：
- en: '[PRE110]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The command will return two rows, which verifies that the data is inserted
    correctly:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回两行，从而验证数据已正确插入：
- en: '![Figure 7.6: Output of the SELECT statement'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6：SELECT语句的输出'
- en: '](image/B15021_07_04.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_07_04.jpg)'
- en: 'Figure 7.6: Output of the SELECT statement'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：SELECT语句的输出
- en: 'Exit the container to quit the database. The shell prompt will return:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出容器以退出数据库。shell提示将返回：
- en: '[PRE111]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'List the volumes using the following command:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令列出卷：
- en: '[PRE112]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Docker has created an anonymous volume for the `db1` container, as evident
    from the following output:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Docker已为`db1`容器创建了一个匿名卷，如下输出所示：
- en: '[PRE113]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Remove the container with its anonymous volume using the following command:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令删除带有匿名卷的容器：
- en: '[PRE114]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The command will return the name of the container:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回容器的名称：
- en: '[PRE115]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'List the volumes using the `docker volume ls` command to verify that the volume
    is removed:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker volume ls`命令列出卷，以验证卷是否已删除：
- en: '[PRE116]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'You will observe that the list is empty:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 您将观察到列表是空的：
- en: '[PRE117]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: As opposed to the previous exercise, this exercise used an anonymous volume
    rather than a named one. Thus, the volume was within the container's scope and
    was removed from the container.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的练习相反，这次练习使用了匿名卷而不是命名卷。因此，该卷在容器的范围内，并且已从容器中删除。
- en: We can therefore conclude that the best practice is to share the database on
    a named volume to ensure that the data saved in the database will persist and
    outlive the container's life.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以得出结论，最佳做法是将数据库共享到命名卷上，以确保数据库中保存的数据将持久存在并超出容器的生命周期。
- en: Up to now, you have learned how to list the volumes and inspect them. But there
    are other more powerful commands to get the information about your system and
    Docker objects, including the volumes. These will be the subject of the next section.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经学会了如何列出卷并对其进行检查。但是还有其他更强大的命令可以获取有关您的系统和Docker对象的信息，包括卷。这将是下一节的主题。
- en: Miscellaneous Useful Docker Commands
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 杂项有用的Docker命令
- en: 'A lot of commands can be used to troubleshoot and inspect your system, some
    of which are described as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用许多命令来排除故障和检查您的系统，其中一些命令如下所述：
- en: 'Use the `docker system df` command to find out the size of all the Docker objects
    in your system:'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`docker system df`命令来查找系统中所有Docker对象的大小：
- en: '[PRE118]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'As shown in the following output, the number of images, containers, and volumes
    are listed with their sizes:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如下输出所示，列出了图像、容器和卷的数量及其大小：
- en: '[PRE119]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'You can get more detailed information about the Docker objects by adding the
    `-v` option to the `docker system df` command:'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过在`docker system df`命令中添加`-v`选项来获取有关Docker对象的更详细信息：
- en: '[PRE120]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'It should return an output like the following:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该返回以下类似的输出：
- en: '![Figure 7.7: Output of the docker system df -v command'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7：docker system df -v命令的输出'
- en: '](image/B15021_07_07.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_07_07.jpg)'
- en: 'Figure 7.7: Output of the docker system df -v command'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：docker system df -v命令的输出
- en: 'Run the `docker volume ls` subcommand to list all the volumes that you have
    on your system:'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`docker volume ls`子命令来列出系统上所有的卷：
- en: '[PRE121]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Copy the name of the volume so that it can be used to get the name of the container
    that uses it:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 复制卷的名称，以便用它来获取使用它的容器的名称：
- en: '[PRE122]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Then, run the `docker ps -a --filter volume=<Volume Name>` command to get the
    name of the container that is using the volume:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行`docker ps -a --filter volume=<Volume Name>`命令来获取正在使用该卷的容器的名称：
- en: '[PRE123]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'You will get the details of the container, like the following:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得容器的详细信息，如下所示：
- en: '[PRE124]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: So far, we have been sharing volumes between containers and the Docker host.
    This sharing type is not the only type available in Docker. You can also share
    volumes between containers. Let's see how to do that in the next section.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在容器和Docker主机之间共享卷。这种共享类型并不是Docker中唯一可用的类型。您还可以在容器之间共享卷。让我们在下一节中看看如何做到这一点。
- en: Persistent and Ephemeral Volumes
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久卷和临时卷
- en: 'There are two types of volumes: persistent and ephemeral ones. What we have
    seen so far is persistent volumes, which are between the host and the container.
    To share the volume between containers, we use the `--volumes-from` option. This
    volume exists only as long as it is being used by a container. When the last container
    using the volume exits, the volume disappears. This type of volume can be passed
    from one container to the next but is not saved. These volumes are called ephemeral
    volumes.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的卷：持久卷和临时卷。到目前为止，我们所看到的是持久卷，它们位于主机和容器之间。要在容器之间共享卷，我们使用`--volumes-from`选项。这种卷只存在于被容器使用时。当最后一个使用该卷的容器退出时，该卷就会消失。这种类型的卷可以从一个容器传递到下一个，但不会被保存。这些卷被称为临时卷。
- en: Volumes can be used to share log files between the host and the container or
    between containers. It is much easier to share them on a volume with the host
    so that even if the container was removed for an error, we can still track the
    error by checking the log file on the host after the container's removal.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 卷可用于在主机和容器之间或容器之间共享日志文件。在主机上共享它们会更容易，这样即使容器因错误而被移除，我们仍然可以通过在容器移除后检查主机上的日志文件来跟踪错误。
- en: Another common use of volumes in practical microservices applications is sharing
    the code on a volume. The advantage of this practice is that you can achieve zero
    downtime. The developer team can edit the code on the fly. The team can work on
    adding new features or changing the interface. Docker monitors the update in the
    code so that it executes the new code.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际微服务应用程序中，卷的另一个常见用途是在卷上共享代码。这种做法的优势在于可以实现零停机时间。开发团队可以即时编辑代码。团队可以开始添加新功能或更改接口。Docker会监视代码的更新，以便执行新代码。
- en: In the following exercise, we will explore the data container and learn some
    new options to share volumes between containers.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将探索数据容器，并学习一些在容器之间共享卷的新选项。
- en: 'Exercise 7.09: Sharing Volumes between Containers'
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.09：在容器之间共享卷
- en: 'Sometimes, you need a data container to share data between various containers,
    each running a different operating system. It is useful to test the same data
    across different platforms before sending the data to production. In this exercise,
    you will use the data container, which will share volumes between containers using
    `--volume-from`:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要一个数据容器在不同操作系统上运行的各种容器之间共享数据。在将数据发送到生产环境之前，测试在不同平台上相同的数据是很有用的。在这个练习中，你将使用数据容器，它将使用`--volume-from`在容器之间共享卷：
- en: 'Create a container, `c1`, with a volume, `newvol`, that is not shared with
    the host:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`c1`的容器，使用一个名为`newvol`的卷，这个卷不与主机共享：
- en: '[PRE125]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Move to the `newvol` volume:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到`newvol`卷：
- en: '[PRE126]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Save a file inside this volume:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个卷内保存一个文件：
- en: '[PRE127]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Press the escape sequences, *CTRL* + *P* and then *CTRL* + *Q*, so that the
    container runs in a detached mode in the background.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下转义序列，*CTRL* + *P*，然后*CTRL* + *Q*，这样容器就会在后台以分离模式运行。
- en: 'Create a second container, `c2`, that mounts the `c1` container''s volume using
    the `--volumes-from` option:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个容器`c2`，使用`--volumes-from`选项挂载`c1`容器的卷：
- en: '[PRE128]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Verify that `c2` can access `file1.txt`, which you saved from `c1`, using the
    `ls` command:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`c2`能够通过`ls`命令访问你从`c1`保存的`file1.txt`：
- en: '[PRE129]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Add another file, `file2.txt`, inside `c2`:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`c2`内添加另一个文件`file2.txt`：
- en: '[PRE130]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Verify that `c2` can access `file1.txt` and `file2.txt`, which you saved from
    `c1`, using the `ls` command:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`c2`能够通过`ls`命令访问你从`c1`保存的`file1.txt`和`file2.txt`：
- en: '[PRE131]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'You will see that both the files are listed:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到两个文件都被列出：
- en: '[PRE132]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Attach the local standard input, output, and error streams to `c1`:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将本地标准输入、输出和错误流附加到`c1`：
- en: '[PRE133]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Check that `c1` can access the two files using the `ls` command:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`c1`能够通过`ls`命令访问这两个文件：
- en: '[PRE134]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'You will see that both the files are listed:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到两个文件都被列出：
- en: '[PRE135]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Exit `c1` using the following command:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令退出`c1`：
- en: '[PRE136]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'List the volumes using the following command:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令列出卷：
- en: '[PRE137]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'You will observe that the volume still exists even when you have exited `c1`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现即使你退出了`c1`，卷仍然存在：
- en: '[PRE138]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Remove `c1` with the `-v` option:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-v`选项移除`c1`：
- en: '[PRE139]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'List the volumes again:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次列出卷：
- en: '[PRE140]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'You will find that the volume has not been removed with `c1` because `c2` is
    still using it:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现`c1`退出后卷并没有被移除，因为`c2`仍在使用它：
- en: '[PRE141]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Now, remove `c2` with the `-v` option to remove its volumes as well. You must
    use the `-f` option as well to force-remove the container because it is up and
    running:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`-v`选项移除`c2`以及它的卷。你必须同时使用`-f`选项来强制移除容器，因为它正在运行中：
- en: '[PRE142]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'List the volumes again:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次列出卷：
- en: '[PRE143]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'You will find that the volume list is empty now:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现卷列表现在是空的：
- en: '[PRE144]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: This verifies that the ephemeral volumes are removed when all the containers
    using the volumes are removed.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这证实了当使用卷的所有容器被移除时，临时卷也会被移除。
- en: In this exercise, you used the `--volumes-from` option to share volumes between
    containers. Also, this exercise demonstrated that the best practice is to always
    remove the container with the `-v` option. Docker will not remove the volume as
    long as there is at least one container that is using that volume.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你使用了`--volumes-from`选项在容器之间共享卷。此外，这个练习还证明了最佳实践是始终使用`-v`选项移除容器。只要至少有一个容器在使用该卷，Docker就不会移除这个卷。
- en: If we committed any of these two containers, `c1` or `c2`, to a new image, the
    data saved on the shared volume still will not be uploaded to that new image.
    The data on any volume, even if the volume is shared between a container and host,
    will not be uploaded to the new image.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`c1`或`c2`中的任何一个提交为一个新镜像，那么保存在共享卷上的数据仍然不会被上传到新镜像中。即使卷在容器和主机之间共享，卷上的数据也不会被上传到新镜像中。
- en: In the next section, we will see how to engrave this data into the newly committed
    image using the filesystem, rather than volumes.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何使用文件系统而不是卷将这些数据刻在新提交的镜像中。
- en: Volumes versus Filesystem and Images
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卷与文件系统和图像
- en: Note that volumes are not part of images, so the data saved on volumes won't
    be uploaded or downloaded with images. The volumes will be engraved in the image,
    but not its data. Therefore, if you want to save certain data in an image, save
    it as a file, not as a volume.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，卷不是镜像的一部分，因此保存在卷上的数据不会随镜像一起上传或下载。卷将被刻在镜像中，但不包括其数据。因此，如果您想在镜像中保存某些数据，请将其保存为文件，而不是卷。
- en: The next exercise will demonstrate and clarify the different outputs between
    saving data on volumes and when saving it on files.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个练习将演示并澄清在卷上保存数据和在文件上保存数据时的不同输出。
- en: 'Exercise 7.10: Saving a File on a Volume and Committing It to a New Image'
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.10：在卷上保存文件并将其提交到新镜像
- en: 'In this exercise, you will run a container with a volume, save some data on
    the volume, commit the container to a new image, and craft a new container based
    on this new image. When you check the data from inside the container, you will
    not find it. The data will be lost. This exercise will demonstrate how the data
    will be lost when committing the container to a new image. Remember that the data
    on the volumes will not be engraved in the new image:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将运行一个带有卷的容器，在卷上保存一些数据，将容器提交到一个新的镜像，并根据这个新的镜像创建一个新的容器。当您从容器内部检查数据时，您将找不到它。数据将丢失。这个练习将演示当将容器提交到一个新的镜像时数据将如何丢失。请记住，卷上的数据不会被刻在新镜像中：
- en: 'Create a new container with a volume:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有卷的新容器：
- en: '[PRE145]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Save a file inside this volume:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个卷中保存一个文件：
- en: '[PRE146]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Navigate to the `newvol` volume:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`newvol`卷：
- en: '[PRE147]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Verify that `c1` can access `file.txt` using the `ls` command:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`c1`可以使用`ls`命令访问`file.txt`：
- en: '[PRE148]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'You will see that the file is listed:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到文件已列出：
- en: '[PRE149]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'View the content of the file using the `cat` command:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cat`命令查看文件的内容：
- en: '[PRE150]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'This will result in the following output:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE151]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Exit from the container using the following command:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令退出容器：
- en: '[PRE152]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Commit this container to a new image called `newimage`:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此容器提交到名为`newimage`的新镜像：
- en: '[PRE153]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Inspect the image to verify that the volume is engraved inside it:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查镜像以验证卷是否被刻在其中：
- en: '[PRE154]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'This will result in the following output:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE155]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Craft a container based on the `newimage` image that you just created:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您刚刚创建的`newimage`镜像创建一个容器：
- en: '[PRE156]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Navigate to `newvol` and list the files in the volume and its data. You will
    find that the file and the word `hello` were not saved in the image:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`newvol`并列出卷及其数据中的文件。您会发现文件和单词`hello`没有保存在镜像中：
- en: '[PRE157]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Exit the container using the following command:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令退出容器：
- en: '[PRE158]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: From this exercise, you learned that the data on a volume is not uploaded to
    the image. To solve this issue, use the filesystem instead of a volume.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个练习中，您了解到卷上的数据不会上传到镜像中。为了解决这个问题，请使用文件系统而不是卷。
- en: Assume that the word `hello` is important data we want to be saved in `file.txt`
    inside the image so that we can access it when we craft a container from this
    image. You will see how to do that in the next exercise.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 假设单词`hello`是我们希望保存在镜像中的重要数据，以便我们在从这个镜像创建容器时可以访问它。您将在下一个练习中看到如何做到这一点。
- en: 'Exercise 7.11: Saving a File in the New Image Filesystem'
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.11：在新镜像文件系统中保存文件
- en: 'In this exercise, you will use the filesystem instead of a volume. You will
    create a directory instead of a volume and save the data in this new directory.
    Then, you will commit the container to a new image. When you craft a new container
    using this image as its base image, you will find the directory in the container
    and the data saved in it:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用文件系统而不是卷。您将创建一个目录而不是卷，并将数据保存在这个新目录中。然后，您将提交容器到一个新的镜像中。当您使用这个镜像作为基础镜像创建一个新的容器时，您会发现容器中有这个目录和其中保存的数据：
- en: 'Remove any container that you might have from previous labs. You can concatenate
    several Docker commands to each other:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除之前实验中可能存在的任何容器。您可以将多个Docker命令连接在一起：
- en: '[PRE159]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The command will return the IDs of the containers that will be removed.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回将被移除的容器的ID。
- en: 'Create a new container without a volume:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个没有卷的新容器：
- en: '[PRE160]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Create a folder named `new` using the `mkdir` command and open it using the
    `cd` command:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`mkdir`命令创建一个名为`new`的文件夹，并使用`cd`命令打开它：
- en: '[PRE161]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Navigate to the `new` directory and save the word `hello` in a new file called
    `file.txt`:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`new`目录，并将单词`hello`保存在一个名为`file.txt`的新文件中：
- en: '[PRE162]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'View the content of the file using the following command:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令查看文件的内容：
- en: '[PRE163]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The command should return `hello`:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应返回`hello`：
- en: '[PRE164]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Exit `c1` using the following command:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令退出`c1`：
- en: '[PRE165]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Commit this container to a new image called `newimage`:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此容器提交到名为`newimage`的新镜像中：
- en: '[PRE166]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Craft a container based on the `newimage` image that you just created:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您刚刚创建的`newimage`镜像创建一个容器：
- en: '[PRE167]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'List the files using the `ls` command:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ls`命令列出文件：
- en: '[PRE168]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'You will find `file.txt` is saved this time:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这次你会发现`file.txt`被保存了：
- en: '[PRE169]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Navigate to the `new` directory and verify that the container can access `file.txt`
    using the `ls` command:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`new`目录，并使用`ls`命令验证容器是否可以访问`file.txt`：
- en: '[PRE170]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'You will see that the file is listed:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到文件被列出：
- en: '[PRE171]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Use the `cat` command to display the contents of `file.txt`:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cat`命令显示`file.txt`的内容：
- en: '[PRE172]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'It will show that the word `hello` is saved:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 它将显示单词`hello`已保存：
- en: '[PRE173]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Exit from the container using the following command:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令退出容器：
- en: '[PRE174]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: In this exercise, you saw that data is uploaded to the image when the filesystem
    is used, compared to the situation we saw when data was saved on volumes.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您看到当使用文件系统时数据被上传到镜像中，与我们在数据保存在卷上看到的情况相比。
- en: In the following activity, we will see how to save a container's statuses in
    a PostgreSQL database. So, if the container crashes, we will be able to retrace
    what happened. It will act as a black box. Moreover, you will query these events
    using SQL statements in the following activity.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的活动中，我们将看到如何将容器的状态保存在PostgreSQL数据库中。因此，如果容器崩溃，我们将能够追溯发生了什么。它将充当黑匣子。此外，您将在接下来的活动中使用SQL语句查询这些事件。
- en: 'Activity 7.01: Storing Container Event (State) Data on a PostgreSQL Database'
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动7.01：将容器事件（状态）数据存储在PostgreSQL数据库中
- en: Logging and monitoring can be done in several ways in Docker. One of these methods
    is to use the `docker logs` command, which fetches what happens inside the individual
    container. Another is to use the `docker events` subcommand, which fetches everything
    that happens inside the Docker daemon in real-time. This feature is very powerful
    as it monitors all the objects' events that are sent to the Docker server—not
    just the containers. The objects include containers, images, volumes, networks,
    nodes, and so on. Storing these events in a database is useful because they can
    be queried and analyzed to debug and troubleshoot any errors if generated.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker中可以通过几种方式进行日志记录和监控。其中一种方法是使用`docker logs`命令，它获取单个容器内部发生的情况。另一种方法是使用`docker
    events`子命令，它实时获取Docker守护程序内发生的一切。这个功能非常强大，因为它监视发送到Docker服务器的所有对象事件，而不仅仅是容器。这些对象包括容器、镜像、卷、网络、节点等等。将这些事件存储在数据库中是有用的，因为它们可以被查询和分析以调试和排除任何错误。
- en: In this activity, you will be required to store a sample of a container's events'
    output to a PostgreSQL database in `JSON` format by using the `docker events --format
    '{{json .}}'` command.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您将需要使用`docker events --format '{{json .}}'`命令将容器事件的样本输出存储到PostgreSQL数据库中的`JSON`格式中。
- en: 'Perform the following steps to complete this activity:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此活动：
- en: Clean your host by removing any Docker objects.
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理您的主机，删除任何Docker对象。
- en: 'Open two terminals: one to see `docker events --format ''{{json .}}''` in effect
    and the other to control the running container.'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开两个终端：一个用于查看`docker events --format '{{json .}}'`的效果，另一个用于控制运行的容器。
- en: Click *Ctrl* + *C* in the `docker events` terminal to terminate it.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`docker events`终端中点击*Ctrl* + *C*来终止它。
- en: Understand the JSON output structure.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 了解JSON输出结构。
- en: Run the PostgreSQL container.
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行PostgreSQL容器。
- en: Create a table.
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表。
- en: Copy the `docker events` subcommand output from the first terminal.
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第一个终端复制`docker events`子命令的输出。
- en: Insert this JSON output into the PostgreSQL database.
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个JSON输出插入到PostgreSQL数据库中。
- en: Query the JSON data using the SQL `SELECT` statement with the following SQL
    queries.
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下SQL查询使用SQL`SELECT`语句查询JSON数据。
- en: '**Query 1**:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询1**：'
- en: '[PRE175]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'You should get the following output:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '![Figure 7.8: Output of Query 1'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8：查询1的输出'
- en: '](image/B15021_07_08.jpg)'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_07_08.jpg)'
- en: 'Figure 7.8: Output of Query 1'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：查询1的输出
- en: '**Query 2**:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询2**：'
- en: '[PRE176]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'You will get an output like the following:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得类似以下内容的输出：
- en: '![Figure 7.9: Output of Query 2'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.9：查询2的输出'
- en: '](image/B15021_07_09.jpg)'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_07_09.jpg)'
- en: 'Figure 7.9: Output of Query 2'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：查询2的输出
- en: '**Query 3**:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询3**：'
- en: '[PRE177]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'The final output should be similar to the following:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 最终输出应该类似于以下内容：
- en: '![Figure 7.10: Output of Query 3'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10：查询3的输出'
- en: '](image/B15021_07_10.jpg)'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_07_10.jpg)'
- en: 'Figure 7.10: Output of Query 3'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：查询3的输出
- en: Note
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor336).
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B15021_Solution_Final_SMP.xhtml#_idTextAnchor336)找到。
- en: In the next activity, we will look at another example of sharing the container's
    NGINX log files, not just its events. You will also learn how to share log files
    between the container and the host.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，我们将看另一个示例，分享容器的NGINX日志文件，而不仅仅是它的事件。您还将学习如何在容器和主机之间共享日志文件。
- en: 'Activity 7.02: Sharing NGINX Log Files with the Host'
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动7.02：与主机共享NGINX日志文件
- en: As we mentioned before, it is useful to share the log files of an application
    to the host. That way, if the container crashes, you can easily check its log
    files from outside the container since you will not be able to extract them from
    the container. This practice is useful with stateless and stateful containers.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，将应用程序的日志文件共享到主机是很有用的。这样，如果容器崩溃，您可以轻松地从容器外部检查其日志文件，因为您无法从容器中提取它们。这种做法对有状态和无状态容器都很有用。
- en: In this activity, you will share the log files of a stateless container crafted
    from the NGINX image with the host. Then, verify these files by accessing the
    NGINX log files from the host.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您将共享从NGINX镜像创建的无状态容器的日志文件到主机。然后，通过访问主机上的NGINX日志文件来验证这些文件。
- en: '**Steps**:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤**：'
- en: Verify that you do not have the `/var/mylogs` folder on your host.
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请验证您的主机上是否没有`/var/mylogs`文件夹。
- en: Run a container based on the NGINX image. Specify the path of the shared volumes
    on the host and inside the container in the `run` command. Inside the container,
    NGINX uses the `/var/log/nginx` path for the log files. Specify the path on the
    host as `/var/mylogs`.
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行基于NGINX镜像的容器。在`run`命令中指定主机上和容器内共享卷的路径。在容器内，NGINX使用`/var/log/nginx`路径来存储日志文件。在主机上指定路径为`/var/mylogs`。
- en: 'Go to the path of `/var/mylogs`. List all the files in that directory. You
    should find two files there:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`/var/mylogs`路径。列出该目录中的所有文件。您应该在那里找到两个文件：
- en: '[PRE178]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Note
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor337).
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B15021_Solution_Final_SMP.xhtml#_idTextAnchor337)找到。
- en: Summary
  id: totrans-560
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered the life cycle of Docker containers and various events.
    It compared stateful and stateless applications and how each one saves its data.
    If we need the data to be persistent, we should use volumes. The chapter covered
    the creation and management of a volume. It further discussed the different types
    of volumes, as well as the difference between the usage of volumes and the filesystem,
    and how the data in both is affected when the container is committed to a new
    image.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了Docker容器的生命周期和各种事件。它比较了有状态和无状态应用程序以及每种应用程序如何保存其数据。如果我们需要数据持久化，我们应该使用卷。本章介绍了卷的创建和管理。它进一步讨论了不同类型的卷，以及在容器提交到新镜像时卷的使用和文件系统的区别，以及两者的数据在容器提交到新镜像时受到的影响。
- en: In the next chapter, you will learn about the concepts of continuous integration
    and continuous delivery. You will learn how to integrate GitHub, Jenkins, Docker
    Hub, and SonarQube to publish your images automatically to the registry to be
    ready for production.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习持续集成和持续交付的概念。您将学习如何集成GitHub、Jenkins、Docker Hub和SonarQube，以便自动将您的图像发布到注册表，以便准备投入生产。
