- en: Chapter 1. Getting Started with Network Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 网络编程入门
- en: Access to networks (the Internet in particular) is becoming an important and
    often necessary feature of applications. Applications frequently need to access
    and provide services. As the **Internet of Things** (**IoT**) connects more and
    more devices, understanding how to access networks becomes crucial.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 访问网络（特别是互联网）正在成为应用程序的一个重要且经常必要的特性。应用程序经常需要访问和提供服务。随着物联网连接越来越多的设备，了解如何访问网络变得至关重要。
- en: The important factors that have been the driving forces for more network applications
    include the availability of faster networks with greater bandwidth. This has made
    it possible to transmit wider ranges of data, such as video streams. In recent
    years, we have seen an increase in connectivity, whether it has been for new services,
    more extensive social interactions, or games. Knowing how to develop network applications
    is an important development skill.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 推动更多网络应用程序的重要因素包括更快速的网络和更大带宽的可用性。这使得传输更广泛范围的数据成为可能，比如视频流。近年来，我们看到了连接性的增加，无论是用于新服务、更广泛的社交互动还是游戏。知道如何开发网络应用程序是一项重要的发展技能。
- en: 'In this chapter, we will cover the basics of Network programming:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍网络编程的基础知识：
- en: Why networking is important
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么网络是重要的
- en: The support that Java provides
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java提供的支持
- en: Simple programs to address basic network operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决基本网络操作的简单程序
- en: Basic networking terminology
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本网络术语
- en: A simple server/client application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的服务器/客户端应用程序
- en: Using a thread to support a server
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程支持服务器
- en: Throughout this book, you will be exposed to many network concepts, ideas, patterns,
    and implementation strategies using both older and newer Java technologies. Network
    connections occur at a low level using sockets, and at a much higher level using
    a multitude of protocols. Communications can be synchronous requiring careful
    coordination of requests and responses, or they can be asynchronous where other
    activities are performed until the response has been submitted.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，您将接触到许多网络概念、思想、模式和使用旧版和新版Java技术的实现策略。网络连接在低级别使用套接字，而在更高级别使用多种协议。通信可以是同步的，需要仔细协调请求和响应，也可以是异步的，在提交响应之前执行其他活动。
- en: These and other concepts are addressed through a series of chapters, each focusing
    on a specific topic. The chapters complement each other by elaborating on concepts
    that were previously introduced, whenever possible. Numerous code examples are
    used whenever possible to further your understanding of the topic.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些以及其他概念通过一系列章节进行讨论，每个章节都专注于特定主题。这些章节通过详细阐述先前介绍的概念来互补彼此。尽可能使用大量的代码示例来进一步加深您对主题的理解。
- en: Central to accessing a service is knowing or discovering its address. This address
    may be human readable, such as [www.packtpub.com](http://www.packtpub.com), or
    in the form of an **IP** address such as `83.166.169.231`. **Internet Protocol**
    (**IP**) is a low-level addressing scheme that is used to access information on
    the Internet. Addressing has long used IPv4 to access resources. However, these
    addresses are all but gone. The newer IPv6 is available to provide a larger range
    of addresses. The basics of network addressing and how they can be managed in
    Java is the focus of [Chapter 2](ch02.html "Chapter 2. Network Addressing"), *Network
    Addressing*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 访问服务的核心是知道或发现其地址。这个地址可能是人类可读的，比如[www.packtpub.com](http://www.packtpub.com)，或者是IP地址，比如`83.166.169.231`。Internet
    Protocol（IP）是一种低级寻址方案，用于访问互联网上的信息。寻址长期以来一直使用IPv4来访问资源。然而，这些地址几乎用光了。新的IPv6可提供更大范围的地址。网络寻址的基础知识以及如何在Java中管理它们是[第2章](ch02.html
    "第2章 网络寻址")的重点，*网络寻址*。
- en: The intent of network communication is to transfer information to and from other
    applications. This is facilitated using buffers and channels. Buffers hold information
    temporarily until it can be processed by an application. Channels are an abstraction
    that simplifies communications between applications. The NIO and NIO.2 packages
    provide much of the support for buffers and channels. We will explore these techniques
    along with other techniques, such as blocking and non-blocking IO, in [Chapter
    3](ch03.html "Chapter 3. NIO Support for Networking"), *NIO Support for Networking*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 网络通信的目的是将信息传输到其他应用程序并从其他应用程序中传输信息。这是通过缓冲区和通道来实现的。缓冲区临时保存信息，直到应用程序可以处理它。通道是一种简化应用程序之间通信的抽象。NIO和NIO.2包提供了大部分缓冲区和通道的支持。我们将探讨这些技术以及其他技术，如阻塞和非阻塞IO，在[第3章](ch03.html
    "第3章 NIO支持网络")中，*NIO支持网络*。
- en: Services are provided by servers. An example of this is the simple echo server,
    which retransmits what it was sent. More sophisticated servers, such as HTTP servers,
    can support extensive services to meet a wide range of needs. The client/server
    model and its Java support are covered in [Chapter 3](ch03.html "Chapter 3. NIO
    Support for Networking"), *NIO Support for Networking*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是由服务器提供的。一个例子是简单的回显服务器，它重新传输它收到的内容。更复杂的服务器，如HTTP服务器，可以支持广泛的服务，以满足各种需求。客户端/服务器模型及其Java支持在[第3章](ch03.html
    "第3章 NIO支持网络")中有所涵盖，*NIO支持网络*。
- en: Another service model is the **peer-to-peer** (**P2P**) model. In this architecture,
    there is no central server, but rather a network of applications that communicate
    to provide a service. This model is represented by applications, such as BitTorrent,
    Skype, and BBC's iPlayer. While much of the support that is required for the development
    of these types of applications is beyond the scope of this book, [Chapter 4](ch04.html
    "Chapter 4. Client/Server Development"), *Client/Server Development*, explores
    P2P issues and the support provided by Java and JXTA.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个服务模型是**点对点**（**P2P**）模型。在这种架构中，没有中央服务器，而是一组通信以提供服务的应用程序网络。这种模型由应用程序表示，例如BitTorrent、Skype和BBC的iPlayer。虽然这些类型应用程序开发所需的大部分支持超出了本书的范围，但是[第4章](ch04.html
    "第4章.客户端/服务器开发") *客户端/服务器开发* 探讨了P2P问题以及Java和JXTA提供的支持。
- en: IP is used at a low level to send and receive packets of information across
    a network. We will also demonstrate the use of **User Datagram Protocol** (**UDP**)
    and **Transmission Control Protocol** (**TCP**) communication protocols. These
    protocols are layered on top of IP. UDP is used to broadcast short packets or
    messages with no guarantee of reliable delivery. TCP is used more commonly and
    provides a higher level of service than that of UDP. We will cover the use of
    these related technologies in [Chapter 5](ch05.html "Chapter 5. Peer-to-Peer Networks"),
    *Peer-to-Peer Networks*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: IP在低级别用于在网络上发送和接收信息包。我们还将演示**用户数据报协议**（**UDP**）和**传输控制协议**（**TCP**）通信协议的使用。这些协议是在IP之上分层的。UDP用于广播短数据包或消息，没有可靠交付的保证。TCP更常用，提供比UDP更高级别的服务。我们将在[第5章](ch05.html
    "第5章.点对点网络") *点对点网络* 中介绍这些相关技术的使用。
- en: A service will often be faced with varying levels of demand placed on it due
    to a number of factors. Its load may vary by the time of the day. As it becomes
    more popular, its overall demand will also increase. The server will need to scale
    to meet increases and decreases in its load. Threads and thread pools have been
    used to support this effort. These and other technologies are the focus of [Chapter
    6](ch06.html "Chapter 6. UDP and Multicasting"), *UDP and Multicasting*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多因素的影响，服务通常会面临不同程度的需求。它的负载可能会随着一天中的时间而变化。随着它变得更受欢迎，其整体需求也会增加。服务器需要扩展以满足负载的增加和减少。线程和线程池已被用于支持这一努力。这些以及其他技术是[第6章](ch06.html
    "第6章.UDP和多播") *UDP和多播* 的重点。
- en: Increasingly, applications need to be secure against attacks by hackers. When
    it is connected to a network, this threat increases. In [Chapter 7](ch07.html
    "Chapter 7. Network Scalability"), *Network Scalability*, we will explore many
    of the techniques available to support secure Java applications. Among these is
    the **Secure Socket Level** (**SSL**), and how Java supports it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序越来越需要防范黑客的攻击。当它连接到网络时，这种威胁会增加。在[第7章](ch07.html "第7章.网络可扩展性") *网络可扩展性* 中，我们将探讨许多可用于支持安全Java应用程序的技术。其中包括**安全套接字层**（**SSL**）以及Java对其的支持。
- en: Applications rarely work in isolation. Hence, they need to use networks to access
    other applications. However, not all applications are written in Java. Networking
    with these applications can pose special problems ranging from how the bytes of
    a data type are organized to the interface supported by the application. It is
    common to work with specialized protocols, such as HTTP, and WSDL. The last chapter
    of this book examines these issues from a Java perspective.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序很少是孤立运行的。因此，它们需要使用网络来访问其他应用程序。但并非所有应用程序都是用Java编写的。与这些应用程序进行网络通信可能会带来特殊问题，从数据类型的字节组织方式到应用程序支持的接口。通常需要使用专门的协议，例如HTTP和WSDL。本书的最后一章从Java的角度探讨了这些问题。
- en: We will demonstrate both older and newer Java technologies. Understanding the
    older technologies may be necessary in order to maintain older code, and it can
    provide insight into why the newer technologies were developed. We will also complement
    our examples using many of the Java 8 functional programming techniques. Using
    Java 8 examples along with pre-Java 8 implementations, we can learn how to use
    Java 8 and be better informed as to when it can and should be used.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示较旧和较新的Java技术。了解较旧的技术可能是必要的，以便维护较旧的代码，并且可以洞察为什么开发了较新的技术。我们还将使用许多Java 8函数式编程技术来补充我们的示例。使用Java
    8示例以及Java 8之前的实现，我们可以学习如何使用Java 8，并更好地了解何时可以和应该使用它。
- en: It is not the intent to fully explain the newer Java 8 technologies, such as
    lambda expressions, and streams. However, the use of Java 8 examples will provide
    an insight into how they can be used to support networked applications.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目的不是完全解释较新的Java 8技术，例如lambda表达式和流。然而，使用Java 8示例将提供关于如何使用它们来支持网络应用程序的见解。
- en: The remainder of this chapter touches on many of the network technologies that
    are explored in this book. You will be introduced to the basics of these techniques,
    and you should find them easy to understand. However, there are a few places where
    time does not permit us to fully explore and explain these concepts. These issues
    will be addressed in subsequent chapters. So, let's begin our exploration with
    network addressing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分涉及本书中探讨的许多网络技术。您将介绍这些技术的基础知识，并且应该会发现它们很容易理解。但是，有一些地方我们没有时间充分探讨和解释这些概念。这些问题将在随后的章节中解决。因此，让我们从网络寻址开始探索。
- en: Network addressing using the InetAddress class
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用InetAddress类进行网络寻址
- en: An IP address is represented by the `InetAddress` class. Addresses can be either
    unicast where it identifies a specific address, or it can be multicast, where
    a message is sent to more than one address.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址由`InetAddress`类表示。地址可以是单播，其中它标识特定地址，也可以是多播，其中消息发送到多个地址。
- en: 'The `InetAddress` class has no public constructors. To get an instance, use
    one of the several static get type methods. For example, the `getByName` method
    takes a string representing the address as shown next. The string in this case
    is a **Uniform Resource Locator** (**URL**):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`InetAddress`类没有公共构造函数。要获得一个实例，使用其中几个静态的获取类型方法。例如，`getByName`方法接受一个表示地址的字符串，如下所示。在这种情况下，字符串是一个**统一资源定位符**（**URL**）：'
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下载示例代码
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载您购买的所有Packt图书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，直接将文件发送到您的电子邮件。
- en: 'This will display the following results:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下结果：
- en: '**www.packtpub.com/83.166.169.231**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**www.packtpub.com/83.166.169.231**'
- en: The number attached to the end of the name is the IP address. This address uniquely
    identifies an entity on the Internet.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到名称末尾的数字是IP地址。这个地址唯一标识互联网上的实体。
- en: 'If we need other information about the address, we can use one of several methods,
    as illustrated here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要有关地址的其他信息，可以使用几种方法，如下所示：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This produces the following output when executed:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时会产生以下输出：
- en: '**CanonicalHostName: 83.166.169.231**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**规范主机名：83.166.169.231**'
- en: '**HostAddress: 83.166.169.231**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**主机地址：83.166.169.231**'
- en: '**HostName: www.packtpub.com**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**主机名：www.packtpub.com**'
- en: 'To test to see whether this address is reachable, use the `isReachable` method
    as shown next. Its argument specifies how long to wait before deciding that the
    address cannot be reached. The argument is the number of milliseconds to wait:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个地址是否可达，使用`isReachable`方法，如下所示。它的参数指定在决定地址是否不可达之前等待多长时间。参数是等待的毫秒数：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are also the `Inet4Address` and `Inet6Address` classes that support IPv4
    and IPv6 addresses, respectively. We will explain their use in [Chapter 2](ch02.html
    "Chapter 2. Network Addressing"), *Network Addressing*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`Inet4Address`和`Inet6Address`类分别支持IPv4和IPv6地址。我们将在[第2章](ch02.html "第2章。网络寻址")*网络寻址*中解释它们的用法。
- en: Once we have obtained an address, we can use it to support network access, such
    as with servers. Before we demonstrate its use in this context, let's examine
    how we can obtain and process data from a connection.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了一个地址，我们可以用它来支持网络访问，比如与服务器一起。在我们演示它在这个上下文中的使用之前，让我们看看如何获得和处理来自连接的数据。
- en: NIO support
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NIO支持
- en: The `java.io`, `java.nio`, and `java.nio` subpackages provide most of the Java
    support for IO processing. We will examine the support that these packages provide
    for network access in [Chapter 3](ch03.html "Chapter 3. NIO Support for Networking"),
    *NIO Support for Networking*. Here, we will focus on the basic aspects of the
    `java.nio` package.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.io`、`java.nio`和`java.nio`子包提供了大部分Java对IO处理的支持。我们将在[第3章](ch03.html "第3章。NIO支持网络")*NIO支持网络*中检查这些包为网络访问提供的支持。在这里，我们将专注于`java.nio`包的基本方面。'
- en: 'There are three key concepts used in the NIO package:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: NIO包中使用了三个关键概念：
- en: '**Channel**: This represents a stream of data between applications'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通道**：这代表应用程序之间的数据流'
- en: '**Buffer**: This works with a channel to process data'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓冲区**：这与通道一起处理数据'
- en: '**Selector**: This is a technology that allows a single thread to handle multiple
    channels'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择器**：这是一种允许单个线程处理多个通道的技术'
- en: A channel and a buffer are typically associated with each other. Data may be
    transferred from a channel to a buffer or from a buffer to a channel. The buffer,
    as its name implies, is a temporary repository for information. The selector is
    useful in supporting application scalability, and this will be discussed in [Chapter
    7](ch07.html "Chapter 7. Network Scalability"), *Network Scalability*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通道和缓冲区通常是相互关联的。数据可以从通道传输到缓冲区，也可以从缓冲区传输到通道。缓冲区，顾名思义，是信息的临时存储库。选择器对支持应用程序的可伸缩性很有用，这将在[第7章](ch07.html
    "第7章。网络可伸缩性")*网络可伸缩性*中讨论。
- en: 'There are four primary channels:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个主要通道：
- en: '`FileChannel`: This works with a file'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileChannel`：这与文件一起使用'
- en: '`DatagramChannel`: This supports UDP communications'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DatagramChannel`：这支持UDP通信'
- en: '`SocketChannel`: This is used with a TCP client'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SocketChannel`：这与TCP客户端一起使用'
- en: '`ServerSocketChannel`: This is used with a TCP server'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerSocketChannel`：这与TCP服务器一起使用'
- en: There are several buffer classes that support primitive data types, such as
    character, integer, and float.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个缓冲区类支持原始数据类型，如字符、整数和浮点数。
- en: Using the URLConnection class
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用URLConnection类
- en: A simple way of accessing a server is to use the `URLConnection` class. This
    class represents a connection between an application and a `URL` instance. A `URL`
    instance represents a resource on the Internet.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 访问服务器的一种简单方式是使用`URLConnection`类。这个类表示应用程序和`URL`实例之间的连接。`URL`实例代表互联网上的资源。
- en: 'In the next example, a URL instance is created for the Google website. Using
    the `URL` class'' `openConnection` method, a `URLConnection` instance is created.
    A `BufferedReader` instance is used to read lines from the connection that is
    then displayed:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，为Google网站创建了一个URL实例。使用`URL`类的`openConnection`方法，创建了一个`URLConnection`实例。使用`BufferedReader`实例从连接中读取行，然后显示：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is rather lengthy, so only part of the first line is shown here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 输出相当冗长，因此这里只显示了第一行的一部分：
- en: '**<!doctype html><html itemscope="" itemtype="http://schema.org/WebPage" ...**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**<!doctype html><html itemscope="" itemtype="http://schema.org/WebPage" ...**'
- en: The `URLConnection` class hides some of the complexity of accessing HTTP servers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`URLConnection`类隐藏了访问HTTP服务器的一些复杂性。'
- en: Using the URLConnection class with buffers and channels
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用URLConnection类与缓冲区和通道
- en: We can rework the previous example to illustrate the use of channels and buffers.
    The `URLConnection` instance is created as before. We will create a `ReadableByteChannel`
    instance and then a `ByteBuffer` instance, as illustrated in the next example.
    The `ReadableByteChannel` instance allows us to read from the site using its `read`
    method. A `ByteBuffer` instance receives data from the channel and is used as
    the argument of the `read` method. The buffer created holds 64 bytes at a time.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重新调整前面的例子，以说明通道和缓冲区的使用。`URLConnection`实例与以前一样创建。我们将创建一个`ReadableByteChannel`实例，然后创建一个`ByteBuffer`实例，如下例所示。`ReadableByteChannel`实例允许我们使用其`read`方法从站点读取数据。`ByteBuffer`实例从通道接收数据，并用作`read`方法的参数。创建的缓冲区每次可容纳64个字节。
- en: 'The `read` method returns the number of bytes read. The `ByteBuffer` class''
    `array` method returns an array of bytes, which is used as the argument of the
    `String` class'' constructor. This is used to display the data read. The `clear`
    method is used to reset the buffer so that it can be used again:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`方法返回读取的字节数。`ByteBuffer`类的`array`方法返回一个字节数组，该数组用作`String`类的构造函数的参数。这用于显示读取的数据。`clear`方法用于重置缓冲区，以便可以再次使用：'
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first line of output is shown next. This produces the same output as before,
    but it is restricted to displaying 64 bytes at a time:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下面显示了输出的第一行。这产生了与以前相同的输出，但限制为每次显示64个字节：
- en: '**<!doctype html><html itemscope="" itemtype="http://schema.org/We**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**<!doctype html><html itemscope="" itemtype="http://schema.org/We**'
- en: The `Channel` class and its derived classes provide an improved technique to
    access data found on a network than data provided by older technologies. We will
    be seeing more of this class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Channel`类及其派生类提供了一种改进的技术，用于访问网络上的数据，而不是使用旧技术提供的数据。我们将看到更多关于这个类的内容。'
- en: The client/server architecture
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端/服务器架构
- en: There are several ways of creating servers using Java. We will illustrate a
    couple of simple approaches and postpone a detailed discussion of these techniques
    until [Chapter 4](ch04.html "Chapter 4. Client/Server Development"), *Client/Server
    Development*. Both a client and a server will be created.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种使用Java创建服务器的方法。我们将说明一些简单方法，并推迟对这些技术的详细讨论，直到[第4章](ch04.html "第4章. 客户端/服务器开发")，“客户端/服务器开发”。将创建客户端和服务器。
- en: A server is installed on a machine with an IP address. It is possible for more
    than one server to be running on a machine at any given time. When the operating
    system receives a request for a service on a machine, it will also receive a port
    number. The port number will identify the server to where the request should be
    forwarded. A server is, thus, identified by its combination of IP address and
    port number.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器安装在具有IP地址的机器上。在任何给定时间，一台机器上可能运行多个服务器。当操作系统接收到对机器上某项服务的请求时，它还将接收到一个端口号。端口号将标识应将请求转发到的服务器。因此，服务器由其IP地址和端口号的组合来标识。
- en: Typically, a client will issue a request to a server. The server will receive
    the request and send back a response. The nature of the request/response and the
    protocol used for communication is dependent on the client/server. Sometimes a
    well-documented protocol, such as the **Hypertext Transfer Protocol** (**HTTP**),
    is used. For simpler architectures, a series of text messages are sent back and
    forth.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，客户端会向服务器发出请求。服务器将接收请求并发送回响应。请求/响应的性质和通信所使用的协议取决于客户端/服务器。有时会使用一种良好记录的协议，例如**超文本传输协议**（**HTTP**）。对于更简单的架构，会来回发送一系列文本消息。
- en: For the server to communicate with an application making a request, specialized
    software is used to send and receive messages. This software is called a socket.
    One socket is found on the client side, and the other socket is located on the
    server side. When they connect, communication is possible. There are several different
    types of sockets. These include datagram sockets; stream sockets, which frequently
    use TCP; and raw sockets, which normally work at the IP level. We will focus on
    TCP sockets for our client/server application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使服务器与发出请求的应用程序进行通信，需要使用专门的软件来发送和接收消息。这种软件称为套接字。一个套接字位于客户端，另一个套接字位于服务器端。当它们连接时，通信就成为可能。有几种不同类型的套接字。这些包括数据报套接字；经常使用TCP的流套接字；以及通常在IP级别工作的原始套接字。我们将专注于TCP套接字用于我们的客户端/服务器应用程序。
- en: Specifically, we will create a simple echo server. This server will receive
    a text message from a client and will immediately send it back to that client.
    The simplicity of this server allows us to focus on the client-server basics.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将创建一个简单的回显服务器。该服务器将接收来自客户端的文本消息，并立即将其发送回该客户端。这个服务器的简单性使我们能够专注于客户端-服务器的基础知识。
- en: Creating a simple echo server
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的回显服务器
- en: 'We will start with the definition of the `SimpleEchoServer` class as shown
    next. In the `main` method, an initial server message will be displayed:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从下面显示的`SimpleEchoServer`类的定义开始。在`main`方法中，将显示初始服务器消息：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The remainder of the method's body consists of a series of try blocks to handle
    exceptions. In the first try block, a `ServerSocket` instance is created using
    `6000` as its parameter. The `ServerSocket` class is a specialized socket that
    is used by a server to listen for client requests. Its argument is its port number.
    The IP of the machine on which the server is located is not necessarily of interest
    to the server, but the client will ultimately need to know this IP address.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的其余部分由一系列try块组成，用于处理异常。在第一个try块中，使用`6000`作为参数创建了一个`ServerSocket`实例。`ServerSocket`类是服务器用于监听客户端请求的专用套接字。它的参数是端口号。服务器所在机器的IP地址对服务器来说并不一定重要，但客户端最终需要知道这个IP地址。
- en: 'In the next code sequence, an instance of the `ServerSocket` class is created
    and its `accept` method is called. The `ServerSocket` will block this call until
    it receives a request from a client. Blocking means that the program is suspended
    until the method returns. When a request is received, the `accept` method will
    return a `Socket` class instance, which represents the connection between that
    client and the server. They can now send and receive messages:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码序列中，创建了`ServerSocket`类的一个实例，并调用了它的`accept`方法。`ServerSocket`将阻塞此调用，直到它收到来自客户端的请求。阻塞意味着程序暂停，直到方法返回。收到请求时，`accept`方法将返回一个`Socket`类实例，表示客户端和服务器之间的连接。他们现在可以发送和接收消息：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After this client socket has been created, we can process the message sent
    to the server. As we are dealing with text, we will use a `BufferedReader` instance
    to read the message from the client. This is created using the client socket''s
    `getInputStream` method. We will use a `PrintWriter` instance to reply to the
    client. This is created using the client socket''s `getOutputStream` method, shown
    as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了客户端套接字后，我们可以处理发送到服务器的消息。由于我们处理的是文本，我们将使用`BufferedReader`实例从客户端读取消息。这是使用客户端套接字的`getInputStream`方法创建的。我们将使用`PrintWriter`实例回复客户端。这是使用客户端套接字的`getOutputStream`方法创建的，如下所示：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The second argument to the `PrintWriter` constructor is set to `true`. This
    means that text sent using the `out` object will automatically be flushed after
    each use.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrintWriter`构造函数的第二个参数设置为`true`。这意味着使用`out`对象发送的文本将在每次使用后自动刷新。'
- en: When text is written to a socket, it will sit in a buffer until either the buffer
    is full or a flush method is called. Performing automatic flushing saves us from
    having to remember to flush the buffer, but it can result in excessive flushing,
    whereas a single flush issued after the last write is performed, will also do.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当文本被写入套接字时，它将停留在缓冲区中，直到缓冲区满或调用刷新方法。执行自动刷新可以避免我们记得刷新缓冲区，但可能导致过度刷新，而在最后一次写入后发出单个刷新也可以。
- en: 'The next code segment completes the server. The `readLine` method reads a line
    at a time from the client. This text is displayed and then sent back to the client
    using the `out` object:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码段完成了服务器。`readLine`方法一次从客户端读取一行。这个文本被显示，然后使用`out`对象发送回客户端：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Before we demonstrate the server in action, we need to create a client application
    to use with it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在演示服务器运行之前，我们需要创建一个客户端应用程序来使用它。
- en: Creating a simple echo client
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的回声客户端
- en: 'We start with the declaration of a `SimpleEchoClient` class where in the `main`
    method, a message is displayed indicating the application''s start that is shown
    as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从声明一个`SimpleEchoClient`类开始，在`main`方法中，显示一条消息指示应用程序的启动，如下所示：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A `Socket` instance needs to be created to connect to the server. In the following
    example, it is assumed that the server and the client are running on the same
    machine. The `InetAddress` class'' static `getLocalHost` method returns this address,
    which is then used in the `Socket` class''s constructor along with port `6000`.
    If they are located on different machines, then the server''s address needs to
    be used instead. As with the server, an instance of the `PrintWriter` and `BufferedReader`
    classes are created to allow text to be sent to and from the server:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 需要创建一个`Socket`实例来连接到服务器。在下面的示例中，假设服务器和客户端在同一台机器上运行。`InetAddress`类的静态`getLocalHost`方法返回这个地址，然后在`Socket`类的构造函数中与端口`6000`一起使用。如果它们位于不同的机器上，则需要使用服务器的地址。与服务器一样，创建`PrintWriter`和`BufferedReader`类的实例，以允许文本被发送到服务器和从服务器接收：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Localhost refers to the current machine. This has a specific IP address: `127.0.0.1`.
    While a machine may be associated with an additional IP address, every machine
    can reach itself using this localhost address.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本地主机指的是当前机器。它有一个特定的IP地址：`127.0.0.1`。虽然一台机器可能关联有额外的IP地址，但每台机器都可以使用这个本地主机地址来访问自己。
- en: 'The user is then prompted to enter text. If the text is the quit command, then
    the infinite loop is terminated, and the application shuts down. Otherwise, the
    text is sent to the server using the `out` object. When the reply is returned,
    it is displayed as shown next:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后提示用户输入文本。如果文本是退出命令，则终止无限循环，并关闭应用程序。否则，使用`out`对象将文本发送到服务器。当回复返回时，它将如下所示显示：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'These programs can be implemented as two separate projects or within a single
    project. Either way, start the server first and then start the client. When the
    server starts, you will see the following displayed:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序可以作为两个单独的项目或一个单一的项目来实现。无论哪种方式，都先启动服务器，然后再启动客户端。当服务器启动时，您将看到以下内容显示：
- en: '**Simple Echo Server**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单回声服务器**'
- en: '**Waiting for connection.....**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待连接.....**'
- en: 'When the client starts, you will see the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端启动时，您将看到以下内容：
- en: '**Simple Echo Client**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单回声客户端**'
- en: '**Waiting for connection.....**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待连接.....**'
- en: '**Connected to server**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接到服务器**'
- en: '**Enter text:**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入文本：**'
- en: 'Enter a message, and watch how the client and the server interact. The following
    is one possible series of input from the client''s perspective:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一条消息，观察客户端和服务器的交互。以下是客户端的可能输入序列：
- en: '**Enter text: Hello server**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入文本：你好服务器**'
- en: '**Server response: Hello server**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器响应：你好服务器**'
- en: '**Enter text: Echo this!**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入文本：回显这个！**'
- en: '**Server response: Echo this!**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器响应：回显这个！**'
- en: '**Enter text: quit**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入文本：quit**'
- en: 'The server''s output is shown here after the client has entered the `quit`
    command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端输入`quit`命令后，服务器的输出如下所示：
- en: '**Simple Echo Server**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单回声服务器**'
- en: '**Waiting for connection.....**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待连接.....**'
- en: '**Connected to client**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接到客户端**'
- en: '**Client request: Hello server**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端请求：你好服务器**'
- en: '**Client request: Echo this!**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端请求：回显这个！**'
- en: This is one approach to implement the client and server. We will enhance this
    implementation in later chapters.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种实现客户端和服务器的方法。我们将在后面的章节中增强这个实现。
- en: Using Java 8 to support the echo server and client
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Java 8支持回声服务器和客户端
- en: We will be providing examples of using many of the newer Java 8 features throughout
    this book. Here, we will show you alternative implementations of the previous
    echo server and client applications.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供许多新的Java 8功能的使用示例。在这里，我们将向您展示先前回声服务器和客户端应用程序的替代实现。
- en: 'The server uses a while loop to process a client''s request as duplicated here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器使用while循环来处理客户端的请求，如下所示：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can use the `Supplier` interface in conjunction with a `Stream` object to
    perform the same operation. The next statement uses a lambda expression to return
    a string from the client:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Supplier`接口与`Stream`对象结合使用来执行相同的操作。下一条语句使用lambda表达式从客户端返回一个字符串：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'An infinite stream is generated from the `Supplier` instance. The following
    `map` method gets input from the user and then sends it to the server. When `quit`
    is entered, the stream will terminate. The `allMatch` method is a short-circuit
    method, and when its argument evaluates to `false`, the stream is terminated:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Supplier`实例生成一个无限流。以下`map`方法从用户那里获取输入，然后将其发送到服务器。当输入`quit`时，流将终止。`allMatch`方法是一个短路方法，当其参数求值为`false`时，流将终止：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: While this implementation is lengthier than the traditional implementation,
    it can provide more succinct and simple solutions to more complex problems.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种实现比传统实现更长，但它可以提供更简洁和简单的解决更复杂的问题。
- en: 'On the client side, we can replace the while loop as duplicated here with a
    functional implementation:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端上，我们可以用功能性实现替换while循环，如下所示：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The functional solution also uses a `Supplier` instance to capture console
    input as shown here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性解决方案还使用`Supplier`实例来捕获控制台输入，如下所示：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'An infinite stream is generated, as shown next, with a `map` method providing
    the equivalent functionality:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个无限流，如下所示，`map`方法提供了等效的功能：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A functional approach is often a better solution to many problems.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多问题，功能性方法通常是更好的解决方案。
- en: Note that an additional prompt, **Enter text:**, was displayed on the client
    side after the `quit` command was entered. This is easily corrected by not displaying
    the prompt if the `quit` command was entered. This correction is left as an exercise
    for the reader.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在输入`quit`命令后，客户端会显示一个额外的提示**Enter text:**。如果输入了`quit`命令，则可以通过不显示提示来轻松纠正此问题。这个纠正留给读者作为练习。
- en: UDP and multicasting
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP和多播
- en: Multicasting is a useful technique to use if you need to send messages to a
    group on a periodic basis. It uses a UDP server and one or more UDP clients. To
    illustrate this capability, we will create a simple time server. The server will
    send a date and time string to clients every second.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要定期向一组发送消息，则多播是一种有用的技术。它使用UDP服务器和一个或多个UDP客户端。为了说明这种能力，我们将创建一个简单的时间服务器。服务器将每秒向客户端发送一个日期和时间字符串。
- en: 'Multicasting will send an identical message to every member of a group. A group
    is identified by a multicast address. A multicast address must use the following
    IP address range: `224.0.0.0` through `239.255.255.255`. The server will send
    a message mark with this address. Clients must join the group before they can
    receive any multicast messages.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 多播将向组中的每个成员发送相同的消息。组由多播地址标识。多播地址必须使用以下IP地址范围：`224.0.0.0`到`239.255.255.255`。服务器将发送一个带有此地址的消息。客户端必须在接收任何多播消息之前加入该组。
- en: Creating a multicast server
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建多播服务器
- en: 'A `MulticastServer` class is declared next, where a `DatagramSocket` instance
    is created. The try-catch blocks will handle exceptions as they occur:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来声明一个`MulticastServer`类，其中创建一个`DatagramSocket`实例。try-catch块将处理异常：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The body of the try block uses an infinite loop to create an array of bytes
    to hold the current date and time. Next, an `InetAddress` instance representing
    the multicast group is created. Using the array and the group address, a `DatagramPacket`
    is instantiated and used as an argument to the `DatagramSocket` class'' `send`
    method. The data and time sent is then displayed. The server then pauses for one
    second:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: try块的主体使用无限循环来创建一个字节数组来保存当前的日期和时间。接下来，创建一个表示多播组的`InetAddress`实例。使用数组和组地址，实例化一个`DatagramPacket`，并将其用作`DatagramSocket`类的`send`方法的参数。然后显示发送的日期和时间。然后服务器暂停一秒：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This server only broadcasts messages. It never receives messages from a client.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务器只广播消息。它从不接收来自客户端的消息。
- en: Creating the multicast client
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建多播客户端
- en: 'The client is created using the following `MulticastClient` class. In order
    to receive a message, the client must use the same group address and port number.
    Before it can receive messages, it must join the group using the `joinGroup` method.
    In this implementation, it receives 5 date and time messages, displays them, and
    then terminates. The `trim` method removes leading and trailing white space, from
    a string. Otherwise, all 256 bytes of the message will be displayed:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下`MulticastClient`类创建客户端。为了接收消息，客户端必须使用相同的组地址和端口号。在接收消息之前，它必须使用`joinGroup`方法加入组。在此实现中，它接收5条日期和时间消息，显示它们，然后终止。`trim`方法从字符串中删除前导和尾随的空格。否则，将显示消息的所有256个字节：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When the server is started, the messages sent are displayed as shown here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器启动时，发送的消息将显示如下：
- en: '**Multicast Time Server**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**多播时间服务器**'
- en: '**Time sent: Thu Jul 09 13:19:49 CDT 2015**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**Time sent: Thu Jul 09 13:19:49 CDT 2015**'
- en: '**Time sent: Thu Jul 09 13:19:50 CDT 2015**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**Time sent: Thu Jul 09 13:19:50 CDT 2015**'
- en: '**Time sent: Thu Jul 09 13:19:51 CDT 2015**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**Time sent: Thu Jul 09 13:19:51 CDT 2015**'
- en: '**Time sent: Thu Jul 09 13:19:52 CDT 2015**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**Time sent: Thu Jul 09 13:19:52 CDT 2015**'
- en: '**Time sent: Thu Jul 09 13:19:53 CDT 2015**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**Time sent: Thu Jul 09 13:19:53 CDT 2015**'
- en: '**Time sent: Thu Jul 09 13:19:54 CDT 2015**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**Time sent: Thu Jul 09 13:19:54 CDT 2015**'
- en: '**Time sent: Thu Jul 09 13:19:55 CDT 2015**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**Time sent: Thu Jul 09 13:19:55 CDT 2015**'
- en: '**...**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**...**'
- en: 'The client output will look similar to the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端输出将类似于以下内容：
- en: '**Multicast Time Client**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**多播时间客户端**'
- en: '**Multicast Group Joined**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**加入多播组**'
- en: '**Thu Jul 09 13:19:50 CDT 2015**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**Thu Jul 09 13:19:50 CDT 2015**'
- en: '**Thu Jul 09 13:19:51 CDT 2015**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**Thu Jul 09 13:19:51 CDT 2015**'
- en: '**Thu Jul 09 13:19:52 CDT 2015**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**周四 2015年7月9日 13:19:52 CDT**'
- en: '**Thu Jul 09 13:19:53 CDT 2015**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**周四 2015年7月9日 13:19:53 CDT**'
- en: '**Thu Jul 09 13:19:54 CDT 2015**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**周四 2015年7月9日 13:19:54 CDT**'
- en: '**Multicast Time Client Terminated**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**多播时间客户端已终止**'
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the example is executed on a Mac, you may receive an exception indicating
    that it cannot assign the requested address. This can be fixed by using the JVM
    option `-Djava.net.preferIPv4Stack=true`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在Mac上执行示例，可能会收到一个异常，指示它无法分配所请求的地址。这可以通过使用JVM选项`-Djava.net.preferIPv4Stack=true`来解决。
- en: There are numerous other multicast capabilities, which will be explored in [Chapter
    6](ch06.html "Chapter 6. UDP and Multicasting"), *UDP and Multicasting*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的多播功能，将在[第6章](ch06.html "第6章. UDP和多播")中探讨，*UDP和多播*。
- en: Scalability
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性
- en: When the demand on a server increases and decreases, it is desirable to change
    the resources dedicated to the server. The options available range from the use
    of manual threads to allow concurrent behavior to those embedded in specialized
    classes to handle thread pools and NIO channels.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器的需求增加和减少时，改变专门用于服务器的资源是可取的。可用的选项范围从使用手动线程以允许并发行为到嵌入在专门的类中处理线程池和NIO通道。
- en: Creating a threaded server
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个多线程服务器
- en: 'In this section, we will use threads to augment our simple echo server. The
    definition of the `ThreadedEchoServer` class is as follows. It implements the
    `Runnable` interface to create a new thread for each connection. The private `Socket`
    variable will hold the client socket for a specific thread:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用线程来增强我们的简单回显服务器。`ThreadedEchoServer`类的定义如下。它实现了`Runnable`接口，为每个连接创建一个新线程。私有的`Socket`变量将保存特定线程的客户端套接字：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A thread is a block of code that executes concurrently with other blocks of
    code in an application. The `Thread` class supports threads in Java. While there
    are several ways of creating threads, one way is to pass an object that implements
    the `Runnable` interface to its constructor. When the `Thread` class' `start`
    method is invoked, the thread is created and the `Runnable` interface's `run`
    method executes. When the `run` method terminates, so does the thread.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是应用程序中与其他代码块并发执行的代码块。`Thread`类支持Java中的线程。创建线程的几种方法之一是将实现`Runnable`接口的对象传递给其构造函数。当调用`Thread`类的`start`方法时，线程被创建，并且`Runnable`接口的`run`方法被执行。当`run`方法终止时，线程也终止。
- en: Another way of adding the thread is to use a separate class for the thread.
    This can be declared separate from the `ThreadedEchoServer` class or as an inner
    class of the `ThreadedEchoServer` class. Using a separate class, better splits
    the functionality of the application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 添加线程的另一种方法是使用一个单独的类来处理线程。这可以与`ThreadedEchoServer`类分开声明，也可以作为`ThreadedEchoServer`类的内部类。使用单独的类更好地分割了应用程序的功能。
- en: 'The `main` method creates the server socket as before, but when a client socket
    is created, the client socket is used to create a thread, as shown here:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法创建了服务器套接字，但是当创建客户端套接字时，客户端套接字被用来创建一个线程，如下所示：'
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The actual work is performed in the `run` method as shown next. It is essentially
    the same implementation as the original echo server, except that the current thread
    is displayed to clarify which threads are being used:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的工作是在`run`方法中执行的，如下所示。它本质上与原始的回显服务器的实现相同，只是当前线程被显示以澄清使用了哪些线程：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Using the threaded server
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多线程服务器
- en: 'The following output shows the interaction between the server and two clients.
    The original echo client was started twice. As you can see, each client interaction
    is performed with a different thread:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了服务器与两个客户端之间的互动。原始的回显客户端被启动了两次。正如你所看到的，每个客户端的互动都是使用不同的线程执行的：
- en: '**Threaded Echo Server**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**多线程回显服务器**'
- en: '**Waiting for connection.....**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待连接.....**'
- en: '**Waiting for connection.....**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待连接.....**'
- en: '**Connected to client using [Thread[Thread-0,5,main]]**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用[Thread[Thread-0,5,main]]连接到客户端**'
- en: '**Client request [Thread[Thread-0,5,main]]: Hello from client 1**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端请求[Thread[Thread-0,5,main]]：来自客户端1的问候**'
- en: '**Client request [Thread[Thread-0,5,main]]: Its good on this side**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端请求[Thread[Thread-0,5,main]]：这边很好**'
- en: '**Waiting for connection.....**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待连接.....**'
- en: '**Connected to client using [Thread[Thread-1,5,main]]**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用[Thread[Thread-1,5,main]]连接到客户端**'
- en: '**Client request [Thread[Thread-1,5,main]]: Hello from client 2**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端请求[Thread[Thread-1,5,main]]：来自客户端2的问候**'
- en: '**Client request [Thread[Thread-1,5,main]]: Good day!**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端请求[Thread[Thread-1,5,main]]：美好的一天！**'
- en: '**Client request [Thread[Thread-1,5,main]]: quit**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端请求[Thread[Thread-1,5,main]]：退出**'
- en: '**Client [Thread[Thread-1,5,main] connection terminated**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端[Thread[Thread-1,5,main]连接已终止**'
- en: '**Client request [Thread[Thread-0,5,main]]: So long**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端请求[Thread[Thread-0,5,main]]：再见**'
- en: '**Client request [Thread[Thread-0,5,main]]: quit**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端请求[Thread[Thread-0,5,main]]：退出**'
- en: 'The following interaction is from the first client''s perspective:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下互动来自第一个客户端的角度：
- en: '**Simple Echo Client**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单回显客户端**'
- en: '**Waiting for connection.....**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待连接.....**'
- en: '**Connected to server**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接到服务器**'
- en: '**Enter text: Hello from client 1**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入文本：来自客户端1的问候**'
- en: '**Server response: Hello from client 1**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器响应：来自客户端1的问候**'
- en: '**Enter text: Its good on this side**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入文本：这边很好**'
- en: '**Server response: Its good on this side**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器响应：这边很好**'
- en: '**Enter text: So long**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入文本：再见**'
- en: '**Server response: So long**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器响应：再见**'
- en: '**Enter text: quit**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入文本：退出**'
- en: '**Server response: quit**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器响应：退出**'
- en: 'The following interaction is from the second client''s perspective:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下互动来自第二个客户端的角度：
- en: '**Simple Echo Client**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单回显客户端**'
- en: '**Waiting for connection.....**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待连接.....**'
- en: '**Connected to server**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接到服务器**'
- en: '**Enter text: Hello from client 2**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入文本：来自客户端2的问候**'
- en: '**Server response: Hello from client 2**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器响应：来自客户端2的问候**'
- en: '**Enter text: Good day!**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入文本：美好的一天！**'
- en: '**Server response: Good day!**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器响应：美好的一天！**'
- en: '**Enter text: quit**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入文本：退出**'
- en: '**Server response: quit**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器响应：退出**'
- en: This implementation permits multiple clients to be handled at a time. Clients
    are not blocked because another client is using the server. However, it also allows
    a large number of threads to be created. If there are too many threads in existence,
    then server performance can degrade. We will address these issues in [Chapter
    7](ch07.html "Chapter 7. Network Scalability"), *Network Scalability*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现允许同时处理多个客户端。客户端不会因为另一个客户端正在使用服务器而被阻塞。但是，它也允许创建大量线程。如果存在太多线程，则服务器性能可能会下降。我们将在[第7章](ch07.html
    "第7章。网络可扩展性")*网络可扩展性*中解决这些问题。
- en: Security
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全
- en: Security is a complex topic. In this section, we will demonstrate a few simple
    aspects of this topic, as it relates to networks. Specifically, we will create
    a secure echo server. Creating a secure echo server is not that much different
    from the non-secure echo server that we developed earlier. However, there is a
    lot going on behind the scenes to make it work. We can ignore many of these details
    for now, but we will delve more deeply into it in [Chapter 8](ch08.html "Chapter 8. Network
    Security"), *Network Security*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 安全是一个复杂的话题。在本节中，我们将演示与网络相关的这个话题的一些简单方面。具体来说，我们将创建一个安全的回声服务器。创建安全的回声服务器与我们之前开发的非安全回声服务器并没有太大的不同。但是，背后有很多工作正在进行。现在我们可以忽略其中许多细节，但是我们将在[第8章](ch08.html
    "第8章。网络安全")*网络安全*中更深入地探讨。
- en: We will be using the `SSLServerSocketFactory` class to instantiate secure server
    sockets. In addition, it is necessary to create keys that the underlying SSL mechanism
    can use to encrypt the communications.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`SSLServerSocketFactory`类来实例化安全服务器套接字。此外，还需要创建底层SSL机制可以使用的密钥来加密通信。
- en: Creating a SSL server
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SSL服务器
- en: 'An `SSLServerSocket` class is declared in the following example to serve as
    the echo server. As it is similar to the previous echo server, we will not explain
    its implementation, except for its relation to the use of the `SSLServerSocketFactory`
    class. Its static `getDefault` method returns an instance of `ServerSocketFactory`.
    Its `createServerSocket` method returns an instance of a `ServerSocket` bound
    to port `8000` that is capable of supporting secure communications. Otherwise,
    it is organized and functions similarly to the previous echo server:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中声明了一个`SSLServerSocket`类作为回声服务器。由于它与之前的回声服务器类似，我们不会解释其实现，除非它与`SSLServerSocketFactory`类的使用有关。它的静态`getDefault`方法返回一个`ServerSocketFactory`实例。其`createServerSocket`方法返回一个绑定到端口`8000`的`ServerSocket`实例，能够支持安全通信。否则，它与之前的回声服务器组织和功能类似：
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Creating an SSL client
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SSL客户端
- en: 'The secure echo client is also similar to the previous non-secure echo client.
    The `SSLSocketFactory` class'' `getDefault` returns an `SSLSocketFactory` instance
    whose `createSocket` creates a socket that is connected to the secure echo server.
    The application is as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 安全回声客户端也类似于之前的非安全回声客户端。`SSLSocketFactory`类的`getDefault`返回一个`SSLSocketFactory`实例，其`createSocket`创建一个连接到安全回声服务器的套接字。应用程序如下：
- en: '[PRE25]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If we executed this server followed by the client, they will abort with a connection
    error. This is because we have not provided a set of keys that the applications
    can share and use to protect the data passed between them.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们先执行这个服务器，然后是客户端，它们将因连接错误而中止。这是因为我们没有提供一组应用程序可以共享和用于保护它们之间传递的数据的密钥。
- en: Generating secure keys
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成安全密钥
- en: To provide the necessary keys, we need to create a keystore to hold the keys.
    When the applications execute, the keystore must be available to the applications.
    First, we will demonstrate how to create a keystore, and then we will show you
    which runtime parameters must be supplied.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供必要的密钥，我们需要创建一个密钥库来保存密钥。当应用程序执行时，密钥库必须对应用程序可用。首先，我们将演示如何创建一个密钥库，然后我们将向您展示必须提供哪些运行时参数。
- en: Within the Java SE SDK's `bin` directory is a program titled `keytool`. This
    is a command-level program that will generate the necessary keys and store them
    in a key file. In Windows, you will need to bring up a command window and navigate
    to the root directory of your source files. This directory will contain the directory
    holding your application's package.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java SE SDK的`bin`目录中有一个名为`keytool`的程序。这是一个命令级程序，将生成必要的密钥并将它们存储在密钥文件中。在Windows中，您需要打开一个命令窗口并导航到源文件的根目录。该目录将包含包含应用程序包的目录。
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On a Mac, you may have problems generating a key pair. More information about
    using this tool on a Mac is found at [https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/keytool.1.html](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/keytool.1.html).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上，您可能会遇到生成密钥对的问题。有关在Mac上使用此工具的更多信息，请访问[https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/keytool.1.html](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/keytool.1.html)。
- en: 'You will also need to set the path to the `bin` directory using a command that
    is similar to the following one. This command is needed to find and execute the
    `keytool` application:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要使用类似以下命令的命令设置到`bin`目录的路径。这个命令是为了找到并执行`keytool`应用程序：
- en: '[PRE26]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, enter the `keytool` command. You will be prompted for a password and
    other information that is used to create the keys. This process is shown here,
    where a password of `123456` is used although it is not displayed as it is entered:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，输入`keytool`命令。您将被提示输入密码和其他用于创建密钥的信息。这个过程如下所示，其中使用密码`123456`，尽管它输入时没有显示：
- en: '[PRE27]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With the keystore created, you can run the server and client applications. How
    these applications are started depends on how your projects have been created.
    You may be able to execute it from an IDE, or you may need to start them from
    a command window.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了密钥库后，您可以运行服务器和客户端应用程序。这些应用程序的启动方式取决于您的项目是如何创建的。您可以从IDE中执行它，也可以从命令窗口启动它们。
- en: 'Next are the commands that can be used from a command window. The two arguments
    to the `java` command are the location of the keystore and a password. They need
    to be executed from the root directory of your package''s directory:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是可以从命令窗口使用的命令。`java`命令的两个参数是密钥库的位置和密码。它们需要从包目录的根目录执行：
- en: '[PRE28]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you want to use an IDE, then use the equivalent settings for your runtime
    command arguments. The following one illustrates one possible interchange between
    the client and the server. The output of the server window is shown first, followed
    by that of the client:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用IDE，则请使用相应的运行时命令参数设置。以下是客户端和服务器之间可能的一种交互。首先显示服务器窗口的输出，然后是客户端的输出：
- en: '**SSLServerSocket Started**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**SSLServerSocket已启动**'
- en: '**Client socket created**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端套接字已创建**'
- en: '**Hello echo server**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**你好回声服务器**'
- en: '**Safe and secure**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全可靠**'
- en: '**SSLServerSocket Terminated**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**SSLServerSocket已终止**'
- en: '**SSLClientSocket Started**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**SSLClientSocket已启动**'
- en: '**Enter text: Hello echo server**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入文本：你好回声服务器**'
- en: '**Server response: Hello echo server**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器响应：你好回声服务器**'
- en: '**Enter text: Safe and secure**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入文本：安全可靠**'
- en: '**Server response: Safe and secure**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器响应：安全可靠**'
- en: '**Enter text: quit**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入文本：退出**'
- en: '**SSLServerSocket Terminated**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**SSLServerSocket已终止**'
- en: There is more to learn about SSL than what is shown here. However, this provides
    an overview of the process with more details presented in [Chapter 8](ch08.html
    "Chapter 8. Network Security"), *Network Security*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 关于SSL还有更多内容需要学习。然而，这提供了一个过程概述，更多细节在[第8章](ch08.html "第8章 网络安全") *网络安全*中呈现。
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Network enabled applications fulfill an increasingly important role in our society
    today. With more and more devices being connected to the Internet, it is important
    to understand how to build applications that can communicate with other applications.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序在当今社会中扮演着越来越重要的角色。随着越来越多的设备连接到互联网，了解如何构建可以与其他应用程序通信的应用程序变得至关重要。
- en: We briefly identified and explained several of the technologies that Java uses
    to connect to a network. We illustrated how the `InetAddress` class can represent
    an IP address, and we used this class for several examples. The basic elements
    of the client/server architecture were demonstrated using UDP, TCP, and SSL technologies.
    They provide different types of support. UDP is fast but not as reliable or as
    capable as TCP. TCP is a reliable and convenient way of communicating, but is
    not secure unless used with SSL.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要介绍并解释了Java用于连接到网络的几种技术。我们演示了`InetAddress`类如何表示IP地址，并在几个示例中使用了这个类。使用UDP、TCP和SSL技术演示了客户端/服务器架构的基本要素。它们提供不同类型的支持。UDP速度快，但不像TCP那样可靠或功能强大。TCP是一种可靠和方便的通信方式，但如果不与SSL一起使用，则不安全。
- en: The NIO support for buffers and channels was illustrated. These techniques can
    result in more efficient communications. The scalability of an application is
    critical for many applications, specifically the client/server model. We also
    saw how threads can support scalability.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们演示了缓冲区和通道的NIO支持。这些技术可以实现更高效的通信。对于许多应用程序来说，应用程序的可扩展性至关重要，特别是客户端/服务器模型。我们还看到了线程如何支持可扩展性。
- en: Each of these topics will be addressed in more detail in later chapters. This
    includes the support NIO provides for scalability, how P2P applications work,
    and the myriad of interoperability technologies that are available for use with
    Java.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主题将在后续章节中得到更详细的讨论。这包括NIO对可扩展性的支持，P2P应用程序的工作原理，以及可用于与Java一起使用的各种互操作技术。
- en: We'll start with a detailed examination of networks, and network addressing,
    in particular, in the next chapter.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中开始对网络和网络寻址进行详细的研究。
