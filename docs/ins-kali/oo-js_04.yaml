- en: Chapter 4. Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 对象
- en: Now that you've mastered JavaScript's primitive data types, arrays, and functions,
    it's time to stay true to the promise of the book title and talk about objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经掌握了JavaScript的原始数据类型、数组和函数，现在是时候兑现本书标题的承诺，谈论对象了。
- en: JavaScript has an eccentric take on the classical Object-oriented programming.
    Object-oriented programming is one of the most popular programming paradigms and
    has been a mainstay in most of programming languages like Java and C++. There
    are well defined ideas proposed by classical OOP that most of these languages
    adopt. JavaScript, however, has a different take on it. We will look JavaScript's
    way of supporting OOP.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对经典的面向对象编程有着独特的看法。面向对象编程是最流行的编程范式之一，并且一直是大多数编程语言（如Java和C++）的主要内容。经典OOP提出了一些明确定义的概念，大多数语言都采用了这些概念。然而，JavaScript对此有不同的看法。我们将看看JavaScript支持OOP的方式。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: How to create and use objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建和使用对象
- en: What are the constructor functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数是什么
- en: What types of built-in JavaScript objects exist and what they can do for you
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在哪些内置的JavaScript对象类型以及它们能为你做什么
- en: From arrays to objects
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数组到对象
- en: 'As you already know from [Chapter 2](ch02.html "Chapter 2. Primitive Data Types,
    Arrays, Loops, and Conditions"), *Primitive Data Types, Arrays, Loops, and Conditions*,
    an array is just a list of values. Each value has an index (a numeric key) that
    starts from zero and increments by one for each value. Consider the following
    example:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经从[第2章](ch02.html "第 2 章. 原始数据类型、数组、循环和条件")中所知道的，*原始数据类型、数组、循环和条件*，数组只是一个值的列表。每个值都有一个从零开始递增的索引（一个数字键）。考虑以下例子：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you put the indexes in one column and the values in another, you''ll end
    up with a table of key/value pairs shown as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将索引放在一列，值放在另一列，你将得到一个键/值对的表格，如下所示：
- en: '| **Key** | **Value** |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| **键** | **值** |'
- en: '| 0 | red |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 红色 |'
- en: '| 1 | blue |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 蓝色 |'
- en: '| 2 | yellow |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 黄色 |'
- en: '| 3 | purple |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 紫色 |'
- en: An object is similar to an array, but the difference is that you define the
    keys yourself. You're not limited to using only numeric indexes, and you can use
    friendlier keys such as `first_name`, `age`, and so on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对象类似于数组，但不同之处在于你自己定义键。你不仅限于使用数字索引，还可以使用更友好的键，如`first_name`、`age`等。
- en: 'Let''s take a look at a simple object and examine its parts:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的对象并检查它的部分：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can see that:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到：
- en: The name of the variable that refers to the object is `hero`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向对象的变量的名称是`hero`
- en: Instead of `[` and `]`, which you use to define an array, you use `{` and `}`
    for objects
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与用于定义数组的`[`和`]`不同，你用`{`和`}`来定义对象
- en: You separate the elements (called properties) contained in the object with commas
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用逗号分隔对象中包含的元素（称为属性）
- en: The key/value pairs are divided by colons, as in `key:value`
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键/值对由冒号分隔，如 `key:value`
- en: 'The keys (names of the properties) can optionally be placed in quotation marks.
    For example, these keys are all the same:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 键（属性的名称）可以选择性地放在引号中。例如，这些键都是相同的：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It''s recommended that you don''t quote the names of the properties (it''s
    less typing), but there are cases when you must use quotes. Some of the cases
    are stated here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 建议不要给属性的名称加引号（这样打字更少），但也有一些情况下你必须使用引号。这里列举了一些情况：
- en: If the property name is one of the reserved words in JavaScript (see [Appendix
    A](apa.html "Appendix A. Reserved Words"), *Reserved Words*)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性名称是JavaScript中的保留字之一（参见[附录A](apa.html "附录 A. 保留字"), *保留字*）
- en: If it contains spaces or special characters (anything other than letters, numbers,
    and the `_` and `$` characters)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它包含空格或特殊字符（除了字母、数字和`_`和`$`字符之外的任何字符）
- en: If it starts with a number
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它以数字开头
- en: In other words, if the name you have chosen for a property is not a valid name
    for a variable in JavaScript, then you need to wrap it in quotes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果你为属性选择的名称在JavaScript中不是有效的变量名称，那么你需要用引号括起来。
- en: 'Have a look at this bizarre-looking object:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个看起来奇怪的对象：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a valid object. The quotes are required for the second and the third
    properties; otherwise, you'll get an error.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有效的对象。第二个和第三个属性需要引号；否则，你会得到一个错误。
- en: Later in this chapter, you'll see other ways to define objects and arrays, in
    addition to `[]` and `{}`. However, first, let's introduce this bit of terminology
    - defining an array with `[]` is called **array literal notation**, and defining
    an object using curly braces `{}` is called **object literal notation**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，你将看到定义对象和数组的其他方法，除了`[]`和`{}`。然而，首先，让我们介绍一些术语 - 使用`[]`定义数组称为**数组字面量表示法**，使用大括号`{}`定义对象称为**对象字面量表示法**。
- en: Elements, properties, methods, and members
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元素，属性，方法和成员
- en: When talking about arrays, you say that they contain elements. When talking
    about objects, you say that they contain properties. There isn't any significant
    difference in JavaScript; it's just the terminology that people are used to, probably
    from other programming languages.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论数组时，你说它们包含元素。当谈论对象时，你说它们包含属性。在JavaScript中没有什么显著的区别；这只是人们习惯于的术语，可能来自其他编程语言。
- en: 'A property of an object can point to a function, because functions are just
    data. Properties that point to functions are also called methods. In the following
    example, `talk` is a method:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的属性可以指向一个函数，因为函数只是数据。指向函数的属性也被称为方法。在下面的例子中，`talk` 是一个方法：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you have seen in the previous chapter, it''s also possible to store functions
    as array elements and invoke them, but you''ll not see much code like this in
    practice:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，你已经看到，也可以将函数存储为数组元素并调用它们，但在实践中你不会经常看到这样的代码：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can also see people using the word members to refer to the properties of
    an object, most often when it doesn't matter if the property is a function or
    not.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你也会看到人们使用成员这个词来指代对象的属性，通常是当属性是函数或不是函数都无所谓的时候。
- en: Hashes and associative arrays
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希和关联数组
- en: 'In some programming languages, there is a distinction between:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些编程语言中，有一个区别：
- en: A regular array, also called an **indexed** or **enumerated** array (the keys
    are numbers)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常规数组，也称为**索引**或**枚举**数组（键是数字）
- en: An associative array, also called a **hash** or a **dictionary** (the keys are
    strings)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联数组，也称为**哈希**或**字典**（键是字符串）
- en: JavaScript uses arrays to represent indexed arrays and objects to represent
    associative arrays. If you want a hash in JavaScript, you use an object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript使用数组表示索引数组，使用对象表示关联数组。如果你想在JavaScript中使用哈希，你会使用对象。
- en: Accessing an object's properties
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问对象的属性
- en: 'There are two ways to access the property of an object:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种访问对象属性的方法：
- en: Using the square bracket notation, for example, `hero['occupation']`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方括号表示法，例如，`hero['occupation']`
- en: Using the dot notation, for example, `hero.occupation`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用点表示法，例如，`hero.occupation`
- en: The dot notation is easier to read and write, but it cannot always be used.
    The same rules apply for quoting property names. If the name of the property is
    not a valid variable name, you cannot use the dot notation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 点表示法更易于阅读和编写，但并非总是可用。引用属性名称的规则相同。如果属性名称不是有效的变量名称，则不能使用点表示法。
- en: 'Let''s take the `hero` object again:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一下 `hero` 对象：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Following is an example for accessing a property with the dot notation:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用点表示法访问属性的示例：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s see an example for accessing a property with the bracket notation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用方括号表示法访问属性的例子：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Consider the following example for accessing a non-existing property returns
    `undefined`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，访问一个不存在的属性返回 `undefined`：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Objects can contain any data, including other objects:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以包含任何数据，包括其他对象：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To get to the `firstname` property of the object contained in the `author`
    property of the `book` object, you can use the following lines of code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 `book` 对象的 `author` 属性中包含的对象的 `firstname` 属性，你可以使用以下代码行：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let see an example using the square brackets notation:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用方括号表示法的例子：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It works even if you mix both:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你混合使用：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Another case where you need square brackets is when the name of the property
    you need to access is not known beforehand. During runtime, it''s dynamically
    stored in a variable:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要使用方括号的情况是需要访问的属性名称事先不知道。在运行时，它会动态存储在一个变量中：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Calling an object's methods
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用对象的方法
- en: 'You know a method is just a property that happens to be a function, so you
    access methods in the same way in which you would access properties-using the
    dot notation or using square brackets. Calling (invoking) a method is the same
    as calling any other function - you just add parentheses after the method name,
    which effectively says Execute!:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道方法只是一个恰好是函数的属性，所以你访问方法的方式与访问属性的方式相同-使用点表示法或使用方括号。调用（调用）方法与调用任何其他函数相同-只需在方法名称后添加括号，这实际上是在说执行！：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If there are any parameters that you want to pass to a method, you would proceed
    as you would with normal functions:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何要传递给方法的参数，你会像处理普通函数一样进行：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can use the array-like square brackets to access a property, it means
    you can also use brackets to access and invoke methods:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可以使用类似数组的方括号访问属性，这意味着你也可以使用方括号访问和调用方法：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is not a common practice, unless the method name is not known at the time
    of writing code, but it is instead defined at runtime:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个常见的做法，除非在编写代码时不知道方法名，而是在运行时定义：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: No quotes unless you have to use the dot notation to access methods and properties,
    and don't quote properties in your object literals.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除非必须使用点表示法访问方法和属性，并且不要在对象文字中引用属性。
- en: Altering properties/methods
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改属性/方法
- en: JavaScript allows you to alter the properties and methods of existing objects
    at any time. This includes adding new properties or deleting them. You can start
    with a blank object and add properties later. Let's see how you can go about doing
    this.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript允许你随时更改现有对象的属性和方法。这包括添加新属性或删除它们。你可以从一个空白对象开始，然后稍后添加属性。让我们看看你可以如何做到这一点。
- en: 'An object without properties is shown as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 没有属性的对象如下所示：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**A "blank" object**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**“空白”对象**'
- en: In this section, you started with a "blank" object, `var hero = {}`. Blank is
    in quotes because this object is not really empty and useless. Although at this
    stage it has no properties of its own, it has already inherited some.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你从一个“空白”对象开始，`var hero = {}`。引号中的“空白”是因为这个对象并不真的是空的和无用的。尽管在这个阶段它没有自己的属性，但它已经继承了一些属性。
- en: You'll learn more about own versus inherited properties later. So, an object
    in ES3 is never really blank or empty. In ES5 though, there is a way to create
    a completely blank object that doesn't inherit anything, but let's not get ahead
    too much.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后你会了解更多关于自有属性与继承属性的知识。因此，在ES3中，对象从来不是真正的空白或空的。不过，在ES5中，有一种方法可以创建一个完全空白的对象，它不继承任何东西，但我们不要过多地超前。
- en: 'Following is the code to access an non-existing property:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是访问不存在属性的代码：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Adding two properties and a method:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个属性和一个方法：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Calling the method:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用方法：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Deleting a property:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除属性：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you call the method again, it will no longer find the deleted `name` property:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果再次调用该方法，它将不再找到已删除的 `name` 属性：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Malleable objects**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**可变对象**'
- en: You can always change any object at any time, such as adding and removing properties
    and changing their values. However, there are exceptions to this rule. A few properties
    of some built-in objects are not changeable (for example, `Math.PI`, as you'll
    see later). Also, ES5 allows you to prevent changes to objects. You'll learn more
    about it in [Appendix C](apc.html "Appendix C. Built-in Objects"), *Built-in Objects*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时更改任何对象，例如添加和删除属性以及更改它们的值。但是，这个规则也有例外。一些内置对象的一些属性是不可更改的（例如 `Math.PI`，稍后你会看到）。此外，ES5允许你阻止对对象的更改。你将在[附录C](apc.html
    "附录 C. 内置对象")中了解更多关于它的知识，*内置对象*。
- en: Using the this value
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 this 值
- en: 'In the previous example, the `sayName()` method used `hero.name` to access
    the `name` property of the `hero` object. When you''re inside a method though,
    there is another way to access the object the method belongs to. This method is
    using the special value `this`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，`sayName()`方法使用了`hero.name`来访问`hero`对象的`name`属性。然而，在方法内部，还有另一种访问方法所属对象的方式。这种方法就是使用特殊值`this`：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: So, when you say `this`, you're actually saying-this object or the current object.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你说`this`时，实际上是在说-这个对象或当前对象。
- en: Constructor functions
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'There is another way to create objects-using constructor functions. Let''s
    look at an example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种创建对象的方式-使用构造函数。让我们看一个例子：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In order to create an object using this function, you can use the `new` operator
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这个函数创建一个对象，你可以使用`new`操作符，如下所示：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A benefit of using constructor functions is that they accept parameters, which
    can be used when creating new objects. Let''s modify the constructor to accept
    one parameter and assign it to the `name` property:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数的好处是它们可以接受参数，在创建新对象时可以使用这些参数。让我们修改构造函数以接受一个参数并将其赋值给`name`属性：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, you can create different objects using the same constructor:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用相同的构造函数创建不同的对象：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By convention, you should capitalize the first letter of your constructor functions
    so that you have a visual clue that they are not intended to be called as regular
    functions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，你应该将构造函数的第一个字母大写，以便你有一个视觉线索表明它们不打算作为常规函数调用。
- en: 'If you call a function that is designed to be a constructor but you omit the
    `new` operator, it is not an error. However, it doesn''t give you the expected
    result:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用一个被设计为构造函数的函数但省略了`new`操作符，这不会报错。但是，它不会给你期望的结果：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What happened here? There is no `new` operator, so a new object was not created.
    The function was called like any other function, so the variable `h` contains
    the value that the function returns. The function does not return anything (there's
    no `return` function), so it actually returns `undefined`, which gets assigned
    to the variable `h`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？没有`new`操作符，所以没有创建新对象。函数被像任何其他函数一样调用，所以变量`h`包含函数返回的值。函数没有返回任何东西（没有`return`函数），所以实际上返回了`undefined`，这个值被赋给了变量`h`。
- en: In this case, what does `this` refer to? It refers to the global object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`this`指的是什么？它指的是全局对象。
- en: The global object
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局对象
- en: You have already learned a bit about global variables (and how you should avoid
    them). You also know that JavaScript programs run inside a host environment (the
    browser, for example). Now that you know about objects, it's time for the whole
    truth, the host environment provides a global object, and all global variables
    are accessible as properties of the global object.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学习了一些关于全局变量（以及你应该避免它们）的知识。你也知道JavaScript程序运行在一个宿主环境中（例如浏览器）。现在你了解了对象，是时候说出整个真相了，宿主环境提供了一个全局对象，所有全局变量都可以作为全局对象的属性访问。
- en: If your host environment is the web browser, the global object is called **window**.
    Another way to access the global object (and this is also true in most other environments)
    is to use `this` keyword outside a constructor function, for example in the global
    program code outside any function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的宿主环境是Web浏览器，全局对象被称为**window**。另一种访问全局对象的方式（在大多数其他环境中也是如此）是在构造函数之外的全局程序代码中使用`this`关键字。
- en: 'As an illustration, you can declare a global variable outside any function
    as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，你可以在任何函数外声明一个全局变量，如下所示：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, you can access this global variable in various ways:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以以各种方式访问这个全局变量：
- en: As a variable `a`
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为变量`a`
- en: As a property of the global object, for example, `window['a']` or `window.a`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为全局对象的属性，例如`window['a']`或`window.a`
- en: 'As a property of the global object referred to as `this`:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为全局对象的属性，称为`this`：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let's go back to the case where you define a constructor function and call it
    without the `new` operator. In such cases, `this` refers to the global object
    and all the properties set to `this` become properties of `window`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到你定义一个构造函数并在没有`new`操作符的情况下调用它的情况。在这种情况下，`this`指的是全局对象，并且所有设置为`this`的属性都成为`window`的属性。
- en: 'Declaring a constructor function and calling it without new returns `"undefined"`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个构造函数并在没有使用new的情况下调用它会返回`"undefined"`：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As you had `this` keyword inside the function `Hero`, a global variable (a
    property of the global object) called `name` was created:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在`Hero`函数内部使用了`this`关键字，一个全局变量（全局对象的属性）叫做`name`被创建了：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you call the same constructor function using `new`, then a new object is
    returned, and `this` refers to it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`new`调用相同的构造函数，那么会返回一个新对象，并且`this`指向它：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The built-in global functions you have seen in [Chapter 3](ch03.html "Chapter 3. Functions"),
    *Functions*, can also be invoked as methods of the `window` object. So, the following
    two calls have the same result:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第3章](ch03.html "第3章. 函数")中看到的内置全局函数*函数*也可以作为`window`对象的方法来调用。因此，以下两个调用会得到相同的结果：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The constructor property
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数属性
- en: When an object is created, a special property is assigned to it behind the scenes-the
    `constructor` property. It contains a reference to the constructor function used
    to create `this` object.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个对象时，会在幕后为其分配一个特殊的属性-`constructor`属性。它包含了用于创建`this`对象的构造函数的引用。
- en: 'Continuing from the previous example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上一个例子：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As the `constructor` property contains a reference to a function, you might
    as well call this function to produce a new object. The following code is like
    saying, "I don''t care how object `h2` was created, but I want another one just
    like it":'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`constructor`属性包含对函数的引用，你也可以调用这个函数来生成一个新对象。以下代码就像在说：“我不在乎对象`h2`是如何创建的，但我想要另一个和它一样的对象”：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If an object was created using the object literal notation, its constructor
    is the built-in `Object()` constructor function (there is more about this later
    in this chapter):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用对象文字表示法创建对象，则其构造函数是内置的`Object()`构造函数（本章后面将更多介绍）：
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The instanceof operator
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: instanceof运算符
- en: 'With the `instanceof` operator, you can test whether an object was created
    with a specific `constructor` function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`instanceof`运算符，您可以测试对象是否是使用特定的`constructor`函数创建的：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that you don't put parentheses after the function name (you don't use `h
    instanceof Hero()`). This is because you're not invoking this function, but just
    referring to it by name, as with any other variable.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您在函数名称后面不要放括号（不要使用`h instanceof Hero()`）。这是因为您没有调用此函数，而只是通过名称引用它，就像引用任何其他变量一样。
- en: Functions that return objects
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回对象的函数
- en: In addition to using `constructor` functions and the `new` operator to create
    objects, you can also use a normal function to create objects without the `new`
    operator. You can have a function that does a bit of preparatory work and has
    an object as a return value.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`constructor`函数和`new`运算符创建对象之外，您还可以使用普通函数创建对象，而无需使用`new`运算符。您可以有一个函数进行一些准备工作，并将对象作为返回值。
- en: 'For example, here''s a simple `factory()` function that produces objects:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个简单的`factory()`函数，用于生成对象：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Consider the following example using the `factory()` function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下使用`factory()`函数的示例：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In fact, you can also use `constructor` functions and `return` objects different
    from `this` keyword. This means you can modify the default behavior of the `constructor`
    function. Let's see how.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您还可以使用`constructor`函数和`return`与`this`关键字不同的对象。这意味着您可以修改`constructor`函数的默认行为。让我们看看如何做到这一点。
- en: 'Here''s the normal constructor scenario:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正常的构造函数场景：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'However, now, look at this scenario:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在，看看这种情况：
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: What happened here? Instead of returning the `this` object, which contains the
    property `a`, the constructor returned another object that contains the property
    `b`. This is possible only if the return value is an object. Otherwise, if you
    try to return anything that is not an object, the constructor will proceed with
    its usual behavior and return `this`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？构造函数没有返回包含属性`a`的`this`对象，而是返回了另一个包含属性`b`的对象。只有在返回值是对象的情况下才可能发生这种情况。否则，如果您尝试返回任何不是对象的东西，构造函数将继续其通常的行为并返回`this`。
- en: 'If you think about how objects are created inside constructor functions, you
    can imagine that a variable called `this` is defined at the top of the function
    and then returned at the end. Consider the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您考虑构造函数内部如何创建对象，您可以想象在函数顶部定义了一个名为`this`的变量，然后在末尾返回。考虑以下代码：
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Passing objects
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递对象
- en: When you assign an object to a different variable or pass it to a function,
    you only pass a reference to that object. Consequently, if you make a change to
    the reference, you're actually modifying the original object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将对象分配给不同的变量或将其传递给函数时，您只传递了对该对象的引用。因此，如果您对引用进行更改，实际上是修改了原始对象。
- en: 'Here''s an example of how you can assign an object to another variable and
    then make a change to the copy. As a result, the original object is also changed:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，演示了如何将一个对象分配给另一个变量，然后对副本进行更改。结果，原始对象也被更改了：
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The same thing applies when passing objects to functions:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象传递给函数时也是一样的：
- en: '[PRE47]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Comparing objects
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较对象
- en: When you compare objects, you'll get `true` only if you compare two references
    to the same object. If you compare two distinct objects that happen to have the
    exact same methods and properties, the result would be `false`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当您比较对象时，只有在比较两个指向同一对象的引用时才会得到`true`。如果比较两个不同的对象，这两个对象恰好具有完全相同的方法和属性，结果将是`false`。
- en: 'Let''s create two objects that look the same:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建两个看起来相同的对象：
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Comparing them returns `false`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们进行比较会返回`false`：
- en: '[PRE49]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can create a new variable, `mydog`, and assign one of the objects to it.
    This way, the variable `mydog` actually points to the same object:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建一个新变量`mydog`，并将其中一个对象分配给它。这样，变量`mydog`实际上指向同一个对象：
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In this case, `benji` is `mydog` because they are the same object (changing
    the `mydog` variable''s properties will change the `benji` variable''s properties).
    The comparison returns `true`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`benji`是`mydog`，因为它们是同一个对象（更改`mydog`变量的属性将更改`benji`变量的属性）。比较结果为`true`：
- en: '[PRE51]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As `fido` is a different object, it does not compare to `mydog`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`fido`是一个不同的对象，它与`mydog`不相等：
- en: '[PRE52]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Objects in the WebKit console
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebKit控制台中的对象
- en: Before diving into the built-in objects in JavaScript, let's quickly say a few
    words about working with objects in the WebKit console.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究JavaScript中的内置对象之前，让我们快速谈一下在WebKit控制台中使用对象的工作。
- en: After playing around with the examples in this chapter, you might have already
    noticed how objects are displayed in the console. If you create an object and
    type its name, you'll get an arrow pointing to the word object.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中玩耍后，您可能已经注意到对象在控制台中的显示方式。如果您创建一个对象并键入其名称，您将得到一个指向对象的箭头。
- en: 'The object is clickable and expands to show you a list of all of the properties
    of the object. If a property is also an object, there is an arrow next to it too,
    so you can expand this as well. This is handy as it gives you an insight into
    exactly what this object contains. Consider the following example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是可点击的，并展开以显示对象的所有属性列表。如果属性也是对象，则旁边也有一个箭头，因此您也可以展开它。这很方便，因为它可以让您深入了解这个对象的确切内容。考虑以下示例：
- en: '![Objects in the WebKit console](graphics/image_04_001-e1482749176512.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![WebKit控制台中的对象](graphics/image_04_001-e1482749176512.jpg)'
- en: Note
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can ignore `__proto__` for now; there's more about it in the next chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以忽略`__proto__`；下一章将更多介绍。
- en: Logging using the console.log method
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用console.log方法记录
- en: The console also offers you an object called `console` and a few methods, such
    as `console.log()` and `console.error()`, which you can use to display any value
    you want in the console.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台还为您提供了一个名为`console`的对象和一些方法，例如`console.log()`和`console.error()`，您可以使用它们在控制台中显示任何您想要的值。
- en: '![Logging using the console.log method](graphics/image_04_002-e1482749557416.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![使用console.log方法记录日志](graphics/image_04_002-e1482749557416.jpg)'
- en: 'The `console.log()` method is convenient when you want to quickly test something,
    as well as when you want to dump some intermediate debugging information in your
    real scripts. Here''s how you can experiment with loops, for example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log()`方法在您想要快速测试某些内容时非常方便，以及在您的真实脚本中想要转储一些中间调试信息时非常方便。以下是您可以尝试循环的示例：'
- en: '[PRE53]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ES6 object literals
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ES6对象字面量
- en: 'ES6 introduces a much succinct syntax while using object literals. ES6 offers
    several shorthands for property initialization and function definitions. ES6 shorthands
    closely resemble a familiar JSON syntax. Consider the following code fragment:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ES6在使用对象字面量时引入了更简洁的语法。ES6为属性初始化和函数定义提供了几种简写。ES6的简写与熟悉的JSON语法非常相似。考虑以下代码片段：
- en: '[PRE54]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This is a typical way to assign property values. If the name of the variable
    and the property key is the same, ES6 allows you to use shorthand syntax. The
    preceding code can be written as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是分配属性值的典型方式。如果变量的名称和属性键相同，ES6允许您使用简写语法。上述代码可以写成如下形式：
- en: '[PRE55]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Similar syntax is available for method definitions as well. As we have discussed,
    methods are simply properties of an object whose values are functions. Consider
    the following example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义也有类似的语法。正如我们所讨论的，方法只是对象的属性，其值是函数。考虑以下示例：
- en: '[PRE56]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'There is a compact way to define methods in ES6\. You simply drop the `function`
    keyword and `:`. The equivalent code in ES6 would look like the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6中定义方法的一种简洁方式。您只需删除`function`关键字和`:`。在ES6中等效的代码如下所示：
- en: '[PRE57]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'ES6 allows you to compute the key of a property. Until ES6, you could only
    use fixed property names. Here is an example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ES6允许您计算属性的键。在ES6之前，您只能使用固定的属性名称。以下是一个例子：
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As you can see, we are limited to using fixed key names: `prop` and `modifier`
    in this case. However, ES6 allows you to use computed property keys. It is possible
    to create property keys dynamically using values returned by a function as well:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们在这种情况下受限于使用固定的键名称：`prop`和`modifier`。然而，ES6允许您使用计算属性键。还可以使用由函数返回的值动态创建属性键：
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We are using the value of variable `vehicle` to concatenate with a fixed string
    to derive the property key while creating the `car` object. In the second snippet,
    we are creating a property by concatenating a fixed string with the value returned
    by a function. This way of computing property keys provides great flexibility
    while creating objects, and a lot of boilerplate and repetitive code can be eliminated.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用变量`vehicle`的值与固定字符串连接，以推导出创建`car`对象时的属性键。在第二个片段中，我们通过将固定字符串与函数返回的值连接来创建属性。这种计算属性键的方式在创建对象时提供了很大的灵活性，并且可以消除大量样板和重复的代码。
- en: 'This syntax is applicable to method definition as well:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此语法也适用于方法定义：
- en: '[PRE60]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Object properties and attributes
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象属性和属性
- en: 'Each object has a few properties. Each property, in turn, has a key and attributes.
    A property''s state is stored in these attributes. All properties have the following
    attributes:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都有一些属性。每个属性又有一个键和属性。属性的状态存储在这些属性中。所有属性都具有以下属性：
- en: '**Enumerable (boolean)**: This indicates if you can enumerate the properties
    of the object. System properties are non-enumerable while user properties are
    enumerable. Unless there is a strong reason, this property should remain untouched.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可枚举（布尔值）**：这表示您是否可以枚举对象的属性。系统属性是不可枚举的，而用户属性是可枚举的。除非有充分的理由，否则应该保持不变。'
- en: '**Configurable(boolean)**: If this attribute is `false`, the property cannot
    be deleted or edited (it cannot change any of its attribute).'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可配置（布尔值）**：如果此属性为`false`，则该属性无法被删除或编辑（它不能更改任何属性）。'
- en: 'You can use the `Object.getOwnPropertyDescriptor()` method to retrieve an object''s
    own properties:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`Object.getOwnPropertyDescriptor()`方法来检索对象的自有属性：
- en: '[PRE61]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Meanwhile, the property can be defined using the `Object.defineProperty() method`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，可以使用`Object.defineProperty()方法`来定义属性：
- en: '[PRE62]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Though you would never use these methods, it is important to understand object
    properties and attributes. In the next section, we will discuss how some of the
    `object` methods are used in context of some of these properties.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能永远不会使用这些方法，但了解对象属性和属性是很重要的。在下一节中，我们将讨论一些`object`方法在某些属性的上下文中是如何使用的。
- en: ES6 object methods
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES6对象方法
- en: ES6 introduces a few static helper methods for objects. `Object.assign` is a
    helper method that replaces popular mixins to perform a shallow copy of an object.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了一些对象的静态辅助方法。`Object.assign`是一个辅助方法，用于执行对象的浅复制，取代了流行的混合方法。
- en: Copy properties using Object.assign
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Object.assign复制属性
- en: 'This method is used to copy properties of the target object into the source
    object. In other words, this method merges the source object with the target object
    and modifies the target object:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于将目标对象的属性复制到源对象中。换句话说，此方法将源对象与目标对象合并，并修改目标对象：
- en: '[PRE63]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The first parameter to `Object.assign` is the target on which source properties
    are copied. The same target object is returned to the caller. Existing properties
    are overwritten, while properties that aren''t part of the source object are ignored:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign`的第一个参数是要复制源属性的目标对象。同一个目标对象将返回给调用者。现有属性将被覆盖，而不是源对象的一部分的属性将被忽略：'
- en: '[PRE64]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`Object.assign` can take multiple source objects. You can write `Object.assign(target,
    source1, source2)`. Here is an example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign`可以接受多个源对象。您可以编写`Object.assign(target, source1, source2)`。以下是一个例子：'
- en: '[PRE65]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this snippet, we are assigning properties from multiple source objects. Also,
    notice how `Object.assign()` returns the target object, which we in turn use inside
    `console.log()`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们正在从多个源对象中分配属性。另外，请注意`Object.assign()`如何返回目标对象，然后我们将其用在`console.log()`中。
- en: One point to note is that only enumerable own (non-inherited) properties can
    be copied using `Object.assign()`. Properties from the prototype chain (will be
    discussed later in this chapter when we talk about Inheritance) are not considered.
    Our earlier discussion of enumerable properties will help you understand this
    distinction.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，只有可枚举的自有（非继承的）属性才能使用`Object.assign()`进行复制。原型链中的属性（在本章后面讨论继承时将会讨论）不会被考虑。我们之前讨论的可枚举属性将帮助您理解这种区别。
- en: 'In the following example, we will create a non-enumerable property using `defineProperty()`
    and validate the fact that `Object.assign()` ignores that property:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将使用`defineProperty()`创建一个不可枚举的属性，并验证`Object.assign()`忽略该属性的事实：
- en: '[PRE66]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The property defined as `superpowers` has the enumerable attribute set to `false`.
    While copying properties, this property is ignored.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 定义为`superpowers`的属性的可枚举属性设置为`false`。在复制属性时，此属性将被忽略。
- en: Compare values with Object.is
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Object.is比较值
- en: 'ES6 provides a slightly precise way of comparing values. We have discussed
    the strict equality operator `===`. However, for `NaN` and `-0` and `+0`, the
    strict equality operator behaves inconsistently. Here is an example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ES6提供了一种稍微精确比较值的方式。我们已经讨论了严格相等运算符`===`。然而，对于`NaN`和`-0`和`+0`，严格相等运算符的行为是不一致的。这里有一个例子：
- en: '[PRE67]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Apart from these two cases, `Object.is()` can safely be replaced with the `===`
    operator.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两种情况，`Object.is()`可以安全地替换为`===`运算符。
- en: Destructuring
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构
- en: 'You will be working with objects and arrays all the time when you code. JavaScript
    object and array notations resemble the JSON format. You will define objects and
    arrays, and then retrieve elements from them. ES6 gives a convenient syntax that
    significantly improves the way we access properties/members from objects and arrays.
    Let''s consider a typical code you would often write:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 编码时，您将一直使用对象和数组。JavaScript对象和数组的表示方式类似于JSON格式。您将定义对象和数组，然后从中检索元素。ES6提供了一种方便的语法，显著改进了我们从对象和数组中访问属性/成员的方式。让我们考虑一个您经常会写的典型代码：
- en: '[PRE68]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, we extracted values of server and port from the `config` object and assigned
    them to local variables. Pretty straightforward! However, when this object has
    a bunch of properties, some of them nested, this simple operation can get very
    tedious to write.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从`config`对象中提取了`server`和`port`的值，并将它们分配给本地变量。非常简单明了！然而，当这个对象有一堆属性，其中一些是嵌套的，这个简单的操作可能会变得非常乏味。
- en: 'ES6 destructuring syntax allows an object literal on the left-hand side of
    an assignment statement. In the following example, we will define an object `config`
    with a few properties. Later, we will use destructuring to assign the object `config`
    to assign values to individual properties on the left-hand side of the assignment
    statement:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ES6解构语法允许在赋值语句的左侧使用对象字面量。在下面的例子中，我们将定义一个带有几个属性的对象`config`。稍后，我们将使用解构来将对象`config`的值分配给赋值语句左侧的各个属性：
- en: '[PRE69]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As you can see `server` and `port` are local variables that got assigned properties
    from the `config` object because the name of the properties were the same as that
    of the local variables. You can also pick particular properties while you assign
    them to local variables. Here is an example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`server`和`port`是本地变量，它们从`config`对象中获取了属性，因为属性的名称与本地变量的名称相同。您还可以在将它们分配给本地变量时挑选特定的属性。这里有一个例子：
- en: '[PRE70]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, we are only picking `timeout` from the `config` object and assign it to
    a local variable `t`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只从`config`对象中挑选`timeout`并将其赋值给一个本地变量`t`。
- en: 'You can also use the destructuring syntax to assign values to already declared
    variables. In this case, you have to put parentheses around the assignment:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用解构语法将值分配给已声明的变量。在这种情况下，您必须在赋值周围加上括号：
- en: '[PRE71]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'As the destructuring expression evaluates to the right-hand side of the expression,
    it''s possible to use it anywhere you would expect a value. For example, in a
    function call, as shown here:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于解构表达式评估为表达式的右侧，因此可以在期望值的任何位置使用它。例如，在函数调用中，如下所示：
- en: '[PRE72]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If you specify a local variable with a property name that does not exist in
    the object, the local variable gets an `undefined` value. However, while using
    variables in the destructuring assignment, you can optionally specify default
    values:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您指定一个在对象中不存在的属性名称的本地变量，那么本地变量将获得一个`undefined`值。然而，在解构赋值中使用变量时，您可以选择指定默认值：
- en: '[PRE73]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In this example, for a non-existent property timeout, we provided a default
    value to prevent getting `undefined` values assigned to local variables.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，对于不存在的属性`timeout`，我们提供了一个默认值，以防止将`undefined`值分配给本地变量。
- en: 'Destructuring works on arrays as well, and the syntax is also very similar
    to that of the objects. We just need to replace object literal syntax with `array:literals`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 解构也适用于数组，并且语法与对象的语法非常相似。我们只需要用`array:literals`替换对象字面量语法：
- en: '[PRE74]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'As you can see, this is the exact same syntax we saw earlier. We defined an
    array `arr` and later used the destructuring syntax to assign elements of that
    array to two local variables, `x` and `y`. Here, the assignment happens based
    on the order of elements in the array. As you only care about the position of
    elements, you can skip some of them if you want to. Here is an example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这与我们之前看到的完全相同的语法。我们定义了一个数组`arr`，然后使用解构语法将该数组的元素分配给两个本地变量`x`和`y`。在这里，赋值是基于数组中元素的顺序进行的。由于您只关心元素的位置，如果需要，可以跳过其中一些元素。这里有一个例子：
- en: '[PRE75]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Here, we know that we need elements from positions 2 and 3 (an array''s index
    starts from 0), and hence, we ignore elements at positions 0 and 1\. Array destructuring
    can eliminate the use of a `temp` variable while swapping values of two variables.
    Consider the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们知道我们需要位置2和3的元素（数组的索引从0开始），因此，我们忽略位置0和1的元素。数组解构可以在交换两个变量的值时消除对`temp`变量的使用。考虑以下内容：
- en: '[PRE76]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You can use the rest operator (`...`) to extract remaining elements and assign
    them to an array. The rest operator can only be used as the last operator during
    destructuring:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用剩余运算符（`...`）来提取剩余的元素并将它们分配给数组。剩余运算符只能在解构期间作为最后一个运算符使用：
- en: '[PRE77]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Built-in objects
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置对象
- en: Earlier in this chapter, you came across the `Object()` constructor function.
    It's returned when you create objects with the object literal notation and access
    their `constructor` property. `Object()` is one of the built-in constructors;
    there are a few others, and in the rest of this chapter you'll see all of them.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，您遇到了`Object()`构造函数。当您使用对象文字表示法创建对象并访问它们的`constructor`属性时，它将返回。`Object()`是内置构造函数之一；还有其他一些，在本章的其余部分中您将看到它们全部。
- en: 'The built-in objects can be divided into three groups:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 内置对象可以分为三组：
- en: '**Data wrapper objects**: These are `Object`, `Array`, `Function`, `Boolean`,
    `Number`, and `String`. These objects correspond to the different data types in
    JavaScript. There is a data wrapper object for every different value returned
    by `typeof` (discussed in [Chapter 2](ch02.html "Chapter 2. Primitive Data Types,
    Arrays, Loops, and Conditions"), *Primitive Data Types, Arrays, Loops, and Conditions*),
    with the exception of `undefined` and `null`.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据包装对象**：这些是`Object`，`Array`，`Function`，`Boolean`，`Number`和`String`。这些对象对应于JavaScript中的不同数据类型。对于`typeof`返回的每个不同值（在[第2章](ch02.html
    "第 2 章. 原始数据类型、数组、循环和条件")中讨论），都有一个数据包装对象，除了`undefined`和`null`。'
- en: '**Utility objects**: These are `Math`, `Date`, and `RegExp`, and can come in
    handy.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实用对象**：这些是`Math`，`Date`和`RegExp`，可能会派上用场。'
- en: '**Error objects**: These include the generic `Error` object as well as other
    more specific objects that can help your program recover its working state when
    something unexpected happens.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误对象：这些包括通用的`Error`对象，以及其他更具体的对象，可以帮助您的程序在发生意外情况时恢复其工作状态。
- en: Only a handful of methods of the built-in objects will be discussed in this
    chapter. For a full reference, see [Appendix C](apc.html "Appendix C. Built-in
    Objects"), *Built-in Objects*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论内置对象的少数方法。有关完整的参考信息，请参阅[附录C](apc.html "附录 C. 内置对象")，*内置对象*。
- en: If you're confused about what a built-in object is and what a built-in constructor
    is, well, they are the same thing. In a moment, you'll see how functions and,
    therefore, constructor functions, are also objects.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对内置对象和内置构造函数感到困惑，那么它们是相同的。一会儿，您将看到函数，因此构造函数也是对象。
- en: Object
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: 'Object is the parent of all JavaScript objects, which means that every object
    you create inherits from it. To create a new empty object, you can use the literal
    notation or the `Object()` constructor function. The following two lines are equivalent:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是所有JavaScript对象的父对象，这意味着您创建的每个对象都继承自它。要创建一个新的空对象，可以使用文字表示法或`Object()`构造函数。以下两行是等效的：
- en: '[PRE78]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'As mentioned before, an empty (or blank) object is not completely useless,
    because it already contains several inherited methods and properties. In this
    book, empty means an object like `{}` that has no properties of its own, other
    than the ones it automatically gets. Let''s look at a few of the properties that
    even blank objects already have:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，空（或空白）对象并不是完全无用的，因为它已经包含了几个继承的方法和属性。在本书中，空表示像`{}`这样的没有自己属性的对象，除了它自动获得的属性。让我们看看即使是空白对象已经具有的一些属性：
- en: The `o.constructor` property returns a reference to the constructor function
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`o.constructor`属性返回对构造函数的引用'
- en: The `o.toString()` is a method that returns a string representation of the object
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`o.toString()`是一个返回对象的字符串表示的方法'
- en: The `o.valueOf()` returns a single-value representation of the object; often,
    this is the object itself
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`o.valueOf()`返回对象的单个值表示；通常，这就是对象本身'
- en: 'Let''s see these methods in action. First, create an object:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些方法的实际应用。首先，创建一个对象：
- en: '[PRE79]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Calling `toString()` returns a string representation of the object:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`toString()`返回对象的字符串表示：
- en: '[PRE80]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `toString()` method will be called internally by JavaScript when an object
    is used in a string context. For example, `alert()` works only with strings, so
    if you call the `alert()` function passing an object, the `toString()`method will
    be called behind the scenes. These two lines produce the same result:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当JavaScript在字符串上下文中使用对象时，将在内部调用`toString()`方法。例如，`alert()`仅适用于字符串，因此如果调用`alert()`函数并传递一个对象，则`toString()`方法将在幕后调用。这两行产生相同的结果：
- en: '[PRE81]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Another type of string context is the string concatenation. If you try to concatenate
    an object with a string, the object''s `toString()` method is called first:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种字符串上下文是字符串连接。如果尝试将对象与字符串连接，将首先调用对象的`toString()`方法：
- en: '[PRE82]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `valueOf()` method is another method that all objects provide. For the
    simple objects (whose constructor is `Object()`), the `valueOf()` method returns
    the object itself:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`valueOf()`方法是所有对象提供的另一种方法。对于简单对象（其构造函数为`Object()`），`valueOf()`方法返回对象本身：'
- en: '[PRE83]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'To summarize:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下：
- en: You can create objects either with `var o = {};` (object literal notation, the
    preferred method) or with `var o = new Object();`
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`var o = {};`（对象文字表示法，首选方法）或`var o = new Object();`来创建对象
- en: Any object, no matter how complex, inherits from the `Object` object and therefore,
    offers methods such as `toString()` and properties such as a constructor
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何对象，无论多么复杂，都继承自`Object`对象，因此提供诸如`toString()`之类的方法和构造函数之类的属性
- en: Array
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: '`Array()` is a built-in function that you can use as a constructor to create
    arrays:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array()`是一个内置函数，您可以将其用作构造函数来创建数组：'
- en: '[PRE84]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This is equivalent to the array literal notation:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于数组文字表示法：
- en: '[PRE85]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'No matter how the array is created, you can add elements to it as usual:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 无论数组如何创建，都可以像通常一样向其添加元素：
- en: '[PRE86]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'When using the `Array()` constructor, you can also pass values that will be
    assigned to the new array''s elements:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `Array()` 构造函数时，还可以传递要分配给新数组元素的值：
- en: '[PRE87]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'An exception to this is when you pass a single number to the constructor. In
    this case, the number is considered to be the length of the array:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例外是当将单个数字传递给构造函数时。在这种情况下，该数字被视为数组的长度：
- en: '[PRE88]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'As arrays are created with a constructor, does this mean that arrays are in
    fact objects? Yes, and you can verify this using the `typeof` operator:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组是用构造函数创建的，这是否意味着数组实际上是对象？是的，您可以使用 `typeof` 运算符来验证这一点：
- en: '[PRE89]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'As arrays are objects, this means that they inherit the properties and methods
    of the parent object:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组是对象，这意味着它们继承了父对象的属性和方法：
- en: '[PRE90]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Arrays are objects, but of a special type because:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是对象，但是一种特殊类型的对象，因为：
- en: The names of their properties are automatically assigned using numbers starting
    from 0.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的属性名称会自动使用从 0 开始的数字进行分配。
- en: They have a `length` property that contains the number of elements in the array.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有一个包含数组中元素数量的 `length` 属性。
- en: They have more built-in methods in addition to those inherited from the parent
    object.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了从父对象继承的方法之外，它们还有更多内置方法。
- en: 'Let''s examine the differences between an array and an object, starting by
    creating the empty array `a` and the empty object `o`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看数组和对象之间的区别，首先创建空数组 `a` 和空对象 `o`：
- en: '[PRE91]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Array objects have a `length` property automatically defined for them, while
    normal objects do not:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 数组对象自动为它们定义了一个 `length` 属性，而普通对象没有：
- en: '[PRE92]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'It''s ok to add both numeric and non-numeric properties to both arrays and
    objects:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 向数组和对象都可以添加数字和非数字属性是可以的：
- en: '[PRE93]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The `length` property is always up to date with the number of numeric properties,
    while it ignores the non-numeric ones:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`length` 属性始终与数字属性的数量保持同步，而忽略非数字属性：'
- en: '[PRE94]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `length` property can also be set by you. Setting it to a greater value
    than the current number of items in the array makes room for additional elements.
    If you try to access these non-existing elements, you''ll get the value `undefined`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`length` 属性也可以由您设置。将其设置为大于数组中当前项目数的值会为额外的元素腾出空间。如果尝试访问这些不存在的元素，将得到值 `undefined`：'
- en: '[PRE95]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Setting the `length` property to a lower value removes the trailing elements:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `length` 属性设置为较小的值会移除尾随元素：
- en: '[PRE96]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: A few array methods
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些数组方法
- en: In addition to the methods inherited from the parent object, array objects also
    have specialized methods for working with arrays, such as `sort()`, `join()`,
    and `slice()`, among others (see [Appendix C](apc.html "Appendix C. Built-in Objects"),
    *Built-in Objects*, for the complete list).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从父对象继承的方法之外，数组对象还具有专门用于处理数组的方法，例如 `sort()`、`join()` 和 `slice()` 等（有关完整列表，请参见
    [附录 C](apc.html "附录 C. 内置对象")，“内置对象”）。
- en: 'Let''s take an array and experiment with some of these methods:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿一个数组来尝试一些这些方法：
- en: '[PRE97]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The `push()` method appends a new element to the end of the array. The `pop()`
    method removes the last element. The `a.push('new')` method works like `a[a.length]
    = 'new'`, and `a.pop()` is like `a.length-`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`push()` 方法将一个新元素追加到数组的末尾。`pop()` 方法移除最后一个元素。`a.push(''new'')` 方法的作用类似于 `a[a.length]
    = ''new''`，而 `a.pop()` 类似于 `a.length-`。'
- en: 'The `push()` method returns the length of the changed array, whereas `pop()`
    returns the removed element:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`push()` 方法返回更改后数组的长度，而 `pop()` 返回移除的元素：'
- en: '[PRE98]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The `sort()` method sorts the array and returns it. In the next example, after
    sort, both `a` and `b` point to the same array:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()` 方法对数组进行排序并返回它。在下一个例子中，排序后，`a` 和 `b` 都指向同一个数组：'
- en: '[PRE99]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The `join()` method returns a string containing the values of all the elements
    in the array glued together using the string parameter passed to `join()`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()` 方法返回一个包含数组中所有元素值的字符串，这些值使用传递给 `join()` 的字符串参数粘合在一起：'
- en: '[PRE100]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The `slice()` method returns a piece of the array without modifying the source
    array. The first parameter to `slice()` is the start index (zero-based), and the
    second is the end index (both indices are zero-based). Start index is included,
    while the end index is not. Take a look at the following example:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`slice()` 方法返回一个数组的一部分，而不修改源数组。`slice()` 的第一个参数是起始索引（从零开始），第二个是结束索引（两个索引都是从零开始）。起始索引包括在内，而结束索引不包括在内。看下面的例子：'
- en: '[PRE101]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'After all the slicing, the source array is still the same:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有切片之后，源数组仍然是相同的：
- en: '[PRE102]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The `splice()` method modifies the source array. It removes a slice, returns
    it, and optionally fills the gap with new elements. The first two parameters define
    the start index and length (number of elements) of the slice to be removed; the
    other parameters pass the new values:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`splice()` 方法修改源数组。它移除一个片段，返回它，并可选择用新元素填充空白。前两个参数定义要移除的片段的起始索引和长度（元素数量）；其他参数传递新值：'
- en: '[PRE103]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Filling the gap with new elements is optional, so you can skip it:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 用新元素填充空白是可选的，所以您可以跳过它：
- en: '[PRE104]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: ES6 array methods
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES6 数组方法
- en: Arrays get a bunch of useful methods. Libraries such as **lodash** and **underscore**
    provided features missing in the language so far. With the new helper methods,
    array creation and manipulation is much more functional and easy to code.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 数组获得了一堆有用的方法。像 **lodash** 和 **underscore** 这样的库提供了语言中缺少的功能。有了新的辅助方法，数组的创建和操作变得更加功能化和易于编码。
- en: Array.from
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Array.from
- en: Converting array-like values to arrays has always been a bit of a challenge
    in JavaScript. People have employed several hacks and written libraries to just
    let you handle arrays effectively.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，将类似数组的值转换为数组一直是一个挑战。人们已经使用了几种技巧并编写了库，只是为了让您有效地处理数组。
- en: 'ES6 introduces a very helpful method to convert array-like objects and iterable
    values into arrays. Array-like values are objects that have a length property
    and indexed elements. Every function has an implicit arguments variable that contains
    a list of all arguments passed to the function. This variable is an array-like
    object. Before ES6, the only way we could convert the `arguments` object to an
    array was to iterate through it and copy the values over to a new array:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了一个非常有用的方法，可以将类似数组的对象和可迭代值转换为数组。类似数组的值是具有长度属性和索引元素的对象。每个函数都有一个隐式的`arguments`变量，其中包含传递给函数的所有参数的列表。这个变量是一个类似数组的对象。在ES6之前，我们将`arguments`对象转换为数组的唯一方法是遍历它并将值复制到一个新数组中：
- en: '[PRE105]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Here, we are creating a new array to copy over all elements of the `arguments`
    object. This is wasteful and needs a lot of unnecessary coding. `Array.from()`
    is a concise way to convert array-like objects into arrays. We can convert this
    example to a more succinct one using `Array.from()`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个新数组，以复制`arguments`对象的所有元素。这是浪费的，需要大量不必要的编码。`Array.from()`是将类似数组的对象转换为数组的简洁方式。我们可以使用`Array.from()`将这个例子转换为更简洁的一个：
- en: '[PRE106]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'You can provide your own mapping scheme while calling `Array.from()` by providing
    a mapping function. This function is invoked on all the elements of the object
    and converts it. This is a useful construct for many common usecases, for example:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`Array.from()`时，您可以通过提供映射函数来提供自己的映射方案。这个函数在对象的所有元素上被调用并进行转换。这是许多常见用例的一个有用构造，例如：
- en: '[PRE107]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: In this example, we are deconstructing the `arguments` object using `Array.from`
    and for each element in `arguments` object, we are calling a function.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在使用`Array.from`解构`arguments`对象，并对`arguments`对象中的每个元素调用一个函数。
- en: Creating arrays using Array.of
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Array.of创建数组
- en: 'Creating an array using the `Array()` constructor causes a bit of a problem.
    The constructor behaves differently based on the number and type of arguments.
    When you pass a single numeric value to the `Array()` constructor, an array of
    undefined elements is created, with the value of the length assigned to the value
    of the argument:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Array()`构造函数创建数组会引起一些问题。构造函数的行为基于参数的数量和类型而有所不同。当您将单个数值传递给`Array()`构造函数时，将创建一个包含未定义元素的数组，其长度的值被分配给参数的值：
- en: '[PRE108]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'On the other hand, if you pass only one non-numeric value, it becomes the only
    item in the array:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您只传递一个非数值值，它将成为数组中的唯一项：
- en: '[PRE109]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'This is not all. If you pass multiple values, they become elements of the array:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是全部。如果传递多个值，它们将成为数组的元素：
- en: '[PRE110]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'So, clearly, there needs to be a better way to create arrays to avoid such
    confusion. ES6 introduces the `Array.of` method that works like the `Array()`
    constructor, but guarantees one standard behavior. `Array.of` creates an array
    from its arguments, regardless of their number and type:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，显然，需要有更好的方法来创建数组，以避免混淆。ES6引入了`Array.of`方法，它的工作方式类似于`Array()`构造函数，但保证了一种标准行为。`Array.of`从其参数创建一个数组，而不管它们的数量和类型：
- en: '[PRE111]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Array.prototype methods
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Array.prototype方法
- en: ES6 introduces several interesting methods as part of array instances. These
    methods help with array iteration and searching elements in the array, both of
    which are very frequent and useful operations.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了几种有趣的方法作为数组实例的一部分。这些方法有助于数组迭代和搜索数组中的元素，这两种操作都是非常频繁和有用的。
- en: 'Here are the methods used for iterating over arrays:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于迭代数组的方法：
- en: '`Array.prototype.entries()`'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.entries()`'
- en: '`Array.prototype.values()`'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.values()`'
- en: '`Array.prorotype.keys()`'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prorotype.keys()`'
- en: 'All three methods return an iterator. This iterator can be used to create arrays
    using `Array.from()` and can be used in for loops for iteration:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三种方法都返回一个迭代器。这个迭代器可以用于使用`Array.from()`创建数组，并且可以在for循环中用于迭代：
- en: '[PRE112]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Similarly, there are new methods for searching within arrays. Looking for an
    element in an array usually involved iterating through the entire list and comparing
    them with a value, as there were no built-in methods for this. Though `indexOf()`
    and `lastIndexOf()` helped find a single value, there was no way to find elements
    based on complex conditions. With ES6, the following build-in methods help with
    `this` keyword.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，有新的方法用于在数组中搜索。在数组中查找元素通常涉及迭代整个列表，并将它们与一个值进行比较，因为没有内置的方法来实现这一点。虽然`indexOf()`和`lastIndexOf()`有助于找到单个值，但没有办法根据复杂条件找到元素。使用ES6，以下内置方法帮助使用`this`关键字。
- en: '`Array.prototype.find`'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.find`'
- en: '`Array.prototype.findIndex`'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.prototype.findIndex`'
- en: 'Both these methods accept two arguments-first is the `callback` function(which
    contains the predicate condition) and the second is an optional `this` keyword.
    The `callback` accepts three arguments: the array element, index of that element,
    and the array. The `callback` returns `true` if the element matches the predicate:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都接受两个参数-第一个是`callback`函数（其中包含谓词条件），第二个是可选的`this`关键字。`callback`接受三个参数：数组元素，该元素的索引和数组。如果元素与谓词匹配，则`callback`返回`true`：
- en: '[PRE113]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Function
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'You already know that functions are a special data type. However, it turns
    out that there''s more to it than that: functions are actually objects. There
    is a built-in `constructor` function called `Function()` that allows for an alternative
    (but not necessarily recommended) way to create a function.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道函数是一种特殊的数据类型。然而，事实证明，函数不仅仅是如此：函数实际上是对象。有一个内置的`constructor`函数叫做`Function()`，它允许以一种替代的方式（但不一定推荐）创建函数。
- en: 'The following example shows three ways to define a function:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了定义函数的三种方法：
- en: '[PRE114]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: When using the `Function()` constructor, you pass the parameter names first
    (as strings) and then the source code for the body of the function (again as a
    string). The JavaScript engine needs to evaluate the source code you pass and
    create the new function for you. This source code evaluation suffers from the
    same drawbacks as the `eval()` function, so defining functions using the `Function()`
    constructor should be avoided when possible.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`Function()`构造函数时，首先传递参数名称（作为字符串），然后传递函数主体的源代码（再次作为字符串）。JavaScript引擎需要评估您传递的源代码并为您创建新的函数。这种源代码评估遭受与`eval()`函数相同的缺点，因此在可能的情况下应避免使用`Function()`构造函数定义函数。
- en: 'If you use the `Function()` constructor to create functions that have lots
    of parameters, bear in mind that the parameters can be passed as a single comma-delimited
    list; so, for example, these are the same:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`Function()`构造函数创建具有许多参数的函数，请记住参数可以作为单个逗号分隔的列表传递；因此，例如，这些是相同的：
- en: '[PRE115]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Note
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not use the `Function()` constructor. As with `eval()` and `setTimeout()`
    (discussed later in the book), always try to stay away from passing JavaScript
    code as a string.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用`Function()`构造函数。与`eval()`和`setTimeout()`（本书后面讨论）一样，始终尝试避免将JavaScript代码作为字符串传递。
- en: Properties of function objects
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数对象的属性
- en: 'Like any other object, functions have a `constructor` property that contains
    a reference to the `Function()` constructor function. This is true no matter which
    syntax you used to create the function:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他对象一样，函数都有一个`constructor`属性，其中包含对`Function()`构造函数的引用。无论您使用哪种语法创建函数，这都是正确的：
- en: '[PRE116]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Functions also have a `length` property, which contains the number of formal
    parameters the function expects:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 函数还有一个`length`属性，其中包含函数期望的形式参数的数量：
- en: '[PRE117]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Using the prototype property
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用prototype属性
- en: 'One of the most widely used properties of function objects is the `prototype`
    property. You''ll see this property discussed in detail in the next chapter, but
    for now, let''s just say:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象最广泛使用的属性之一是`prototype`属性。您将在下一章中详细讨论这个属性，但现在，让我们先说一下：
- en: The `prototype` property of a `function` object points to another object
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function`对象的`prototype`属性指向另一个对象'
- en: Its benefits shine only when you use this `function` as a constructor
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当您将此`function`用作构造函数时，其优势才会显现
- en: All objects created with this `function` keep a reference to the `prototype`
    property and can use its properties as their own
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用此`function`创建的所有对象都保留对`prototype`属性的引用，并且可以将其属性用作自己的属性
- en: 'Let''s look at a quick example to demonstrate the `prototype` property. Take
    a simple object that has a property name and a method `say()` method:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个快速的例子来演示`prototype`属性。拿一个简单的对象，它有一个属性名称和一个`say()`方法：
- en: '[PRE118]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'When you create a function (even one without a body), you can verify that it
    automatically has a `prototype` property that points to a new object:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个函数（即使没有主体），您可以验证它自动具有指向新对象的`prototype`属性：
- en: '[PRE119]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'It gets interesting when you modify the `prototype` property. You can add properties
    to it, or you can replace the default object with any other object. Let''s assign
    `ninja` to the `prototype`:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 当您修改`prototype`属性时，情况变得有趣。您可以向其中添加属性，或者您可以用任何其他对象替换默认对象。让我们将`ninja`分配给`prototype`：
- en: '[PRE120]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Now, and here''s where the magic happens, using the `F()`function as a `constructor`
    function, you can create a new object, `baby_ninja`, which will have access to
    the properties of `F.prototype` (which points to `ninja`) as if it were its own:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这就是魔术发生的地方，使用`F()`函数作为`constructor`函数，您可以创建一个新对象`baby_ninja`，它将可以访问`F.prototype`的属性（指向`ninja`）就像它自己的属性一样：
- en: '[PRE121]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: There will be much more on this topic later. In fact, the next chapter is all
    about the `prototype` property.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 以后会有更多关于这个主题的内容。事实上，下一章就是关于`prototype`属性的。
- en: Methods of function objects
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数对象的方法
- en: 'Function objects, being a descendant of the top parent object, get the default
    methods such as `toString()`. When invoked on a function, the `toString()` method
    returns the source code of the function:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象作为顶级父对象的后代，获得默认方法，例如`toString()`。当在函数上调用`toString()`方法时，它将返回函数的源代码：
- en: '[PRE122]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'If you try to peek into the source code of the built-in functions, you''ll
    get the `[native code]` string instead of the body of the function:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试窥探内置函数的源代码，您将得到`[native code]`字符串，而不是函数的主体：
- en: '[PRE123]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: As you can see, you can use `toString()` to differentiate between native methods
    and developer-defined ones.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，您可以使用`toString()`来区分原生方法和开发者定义的方法。
- en: Note
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The behavior of the function's `toString()` is environment dependent, and it
    differs among browsers in terms of spacing and new lines.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的`toString()`的行为取决于环境，并且在浏览器之间在间距和换行方面有所不同。
- en: Call and apply
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用和应用
- en: Function objects have `call()` and `apply()` methods. You can use them to invoke
    a function and pass any arguments to it.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象具有`call()`和`apply()`方法。您可以使用它们来调用函数并传递任何参数给它。
- en: These methods also allow your objects to borrow methods from other objects and
    invoke them as their own. This is an easy and powerful way to reuse code.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法还允许您的对象从其他对象中借用方法并将其作为自己的方法调用。这是一种重用代码的简单而强大的方式。
- en: 'Let''s say you have a `some_obj` object, which contains the `say()` method:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个`some_obj`对象，其中包含`say()`方法：
- en: '[PRE124]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'You can call the `say()` method, which internally uses `this.name` to gain
    access to its own name property:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以调用`say()`方法，它在内部使用`this.name`来访问自己的名称属性：
- en: '[PRE125]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now, let''s create a simple object, `my_obj`, which only has a name property:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个简单的对象`my_obj`，它只有一个名称属性：
- en: '[PRE126]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The `my_obj` likes the `some_obj` object''s `say()` method so much that it
    wants to invoke it as its own. This is possible using the `call()` method of the
    `say()` function object:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`my_obj`非常喜欢`some_obj`对象的`say()`方法，以至于它想将其作为自己的方法调用。这可以使用`say()`函数对象的`call()`方法实现：'
- en: '[PRE127]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: It worked! But what happened here? You invoked the `call()` method of the `say()`
    function object by passing two parameters-the `my_obj` object and the `Dude` string.
    The result is that when `say()` is invoked, the references to the this value that
    it contains point to `my_obj`. This way, `this.name` doesn't return `Ninja`, but
    `Scripting guru` instead.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！但这里发生了什么？您通过传递两个参数-`my_obj`对象和`Dude`字符串来调用`say()`函数对象的`call()`方法。结果是，当调用`say()`时，它包含的this值的引用指向`my_obj`。这样，`this.name`不会返回`Ninja`，而是返回`Scripting
    guru`。
- en: 'If you have more parameters to pass when invoking the `call()` method, you
    just keep adding them:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调用`call()`方法时有更多参数要传递，只需继续添加它们：
- en: '[PRE128]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: If you don't pass an object as a first parameter to `call()` or you pass `null`,
    the global object is assumed.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有将对象作为`call()`的第一个参数传递，或者传递`null`，则假定为全局对象。
- en: 'The method `apply()` works the same way as `call()`, but with the difference
    that all parameters you want to pass to the method of the other object are passed
    as an array. The following two lines are equivalent:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply()`方法的工作方式与`call()`相同，但不同之处在于要传递给其他对象方法的所有参数都作为数组传递。以下两行是等效的：'
- en: '[PRE129]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Continuing the previous example, you can use the following line of code:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上一个示例，您可以使用以下代码行：
- en: '[PRE130]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The arguments object revisited
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新访问arguments对象
- en: 'In the previous chapter, you have seen how, from inside a function, you have
    access to something called `arguments`, which contains the values of all the parameters
    passed to the function:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您已经看到了如何从函数内部访问称为`arguments`的东西，其中包含传递给函数的所有参数的值：
- en: '[PRE131]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The `arguments` looks like an array, but it is actually an array-like object.
    It resembles an array because it contains indexed elements and a `length` property.
    However, the similarity ends there, as arguments doesn't provide any of the array
    methods, such as `sort()` or `slice()`.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments`看起来像一个数组，但实际上它是一个类似数组的对象。它看起来像一个数组，因为它包含索引元素和`length`属性。然而，相似之处就在这里，因为arguments不提供任何数组方法，比如`sort()`或`slice()`。'
- en: 'However, you can convert `arguments` to an array and benefit from all the array
    goodies. Here''s what you can do, practicing your newly-learned `call()` method:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可以将`arguments`转换为数组，并从所有数组好处中受益。练习您新学到的`call()`方法，您可以这样做：
- en: '[PRE132]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: As you can see, you can borrow `slice()` using `[].slice` or the more verbose
    `Array.prototype.slice`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，您可以使用`[].slice`或更冗长的`Array.prototype.slice`来借用`slice()`。
- en: Lexical this in arrow functions
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数中的词法this
- en: We discussed ES6 arrow functions and the syntax in detail in the last chapter.
    However, an important aspect of arrow functions is that they behave differently
    from normal functions. The difference is subtle but important. Arrow functions
    do not have their own value of `this`. The value of `this` in an arrow function
    is inherited from the enclosing (lexical) scope.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中详细讨论了ES6箭头函数和语法。然而，箭头函数的一个重要方面是它们的行为与普通函数不同。差异是微妙但重要的。箭头函数没有自己的`this`值。箭头函数中的`this`值是从封闭（词法）范围继承的。
- en: Functions have a special variable `this` that refers to the object via which
    the method was invoked. As the value of `this` is dynamically given based on the
    function invocation, it is sometimes called dynamic `this`. A function is executed
    in two scopes-lexical and dynamic. A lexical scope is a scope that surrounds the
    function scope, and the dynamic scope is the scope that called the function (usually
    an object)
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 函数有一个特殊的变量`this`，它指的是调用该方法的对象。由于`this`的值是根据函数调用动态给出的，有时被称为动态`this`。函数在两个范围中执行-词法和动态。词法范围是包围函数范围的范围，动态范围是调用函数的范围（通常是一个对象）。
- en: 'In JavaScript, traditional functions play several roles. They are non-method
    functions (aka subroutines or functions), methods (part of an object), and constructors.
    When functions do the duty of a subroutine, there is a small problem due to dynamic
    `this`. As subroutines are not called on an object, the value of `this` is undefined
    in a strict mode and set to the global scope otherwise. This makes writing `callbacks`
    difficult. Consider the following example:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，传统函数扮演着几种角色。它们是非方法函数（也称为子例程或函数）、方法（对象的一部分）和构造函数。当函数执行子例程的职责时，由于动态`this`，存在一个小问题。由于子例程不是在对象上调用的，因此在严格模式下`this`的值为未定义，否则设置为全局范围。这使得编写`回调`变得困难。考虑以下示例：
- en: '[PRE133]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: We are passing a subroutine to the `forEach()` function on the `names` array.
    This subroutine has an undefined value of `this`, and unfortunately, it does not
    have access to `this` of the outer method `greet`. Clearly, this subroutine needs
    a lexical `this`,derive `this` from the surrounding scope of the `greet` method.
    Traditionally, to fix this limitation, we assign the lexical `this` into a variable,
    which is then accessible to the subroutine via closure.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将一个子例程传递给`names`数组上的`forEach()`函数。这个子例程的`this`值是未定义的，不幸的是，它无法访问外部方法`greet`的`this`。显然，这个子例程需要一个词法`this`，从`greet`方法的周围范围派生`this`。传统上，为了解决这个限制，我们将词法`this`分配给一个变量，然后通过闭包使子例程可以访问它。
- en: 'We can fix the earlier example as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式修复之前的示例：
- en: '[PRE134]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: This is a reasonable hack to simulate lexical `this`. However, the problem with
    such hacks is that it creates too much noise for the person writing or reviewing
    `this` code. First, you have to understand the quirk of the behavior of `this`.
    Even if you understand `this` behavior well, you will need to continuously remain
    on the lookout for such hacks in your code.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个合理的黑客来模拟词法`this`。然而，这种黑客的问题是它为编写或审查`this`代码的人创建了太多噪音。首先，您必须了解`this`行为的怪癖。即使您很好地理解了`this`的行为，您也需要不断地留意代码中的这种黑客。
- en: 'Arrow functions have lexical `this` and do not require such a hack. They are
    more suited as subroutines because of `this`. We can covert the preceding example
    to use lexical `this` using the arrow function:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数具有词法`this`，不需要这样的黑客。由于`this`，它们更适合作为子例程。我们可以使用箭头函数将前面的示例转换为使用词法`this`：
- en: '[PRE135]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Inferring object types
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推断对象类型
- en: You can see that you have this array-like arguments object looking so much like
    an array object. How can you reliably tell the difference between the two? Additionally,
    `typeof` returns an object when used with arrays. Therefore, how can you tell
    the difference between an object and an array?
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，您有一个类似数组的参数对象，看起来非常像一个数组对象。您如何可靠地区分这两者？此外，当与数组一起使用时，`typeof`返回一个对象。因此，您如何区分对象和数组之间的区别？
- en: 'The silver bullet is the `Object` object''s `toString()` method. It gives you
    the internal class name used to create a given object:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 银弹是`Object`对象的`toString()`方法。它为您提供了用于创建给定对象的内部类名称：
- en: '[PRE136]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'You have to call the original `toString()` method as defined in the prototype
    of the `Object` constructor. Otherwise, if you call the `Array` function''s `toString()`,
    it will give you a different result, as it''s been overridden for the specific
    purposes of the array objects:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须调用`Object`构造函数原型中定义的原始`toString()`方法。否则，如果调用`Array`函数的`toString()`，它将给出不同的结果，因为它已被重写，用于数组对象的特定目的：
- en: '[PRE137]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The preceding code is same as:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码与以下代码相同：
- en: '[PRE138]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Let''s have some more fun with `toString()`. Make a handy reference to save
    typing:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再来玩一下`toString()`。创建一个方便的参考以节省输入：
- en: '[PRE139]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The following example shows how we can differentiate between an array and the
    array-like object `arguments`:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何区分数组和类似数组对象`arguments`：
- en: '[PRE140]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'You can even inspect DOM elements:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以检查DOM元素：
- en: '[PRE141]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Boolean
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔
- en: Your journey through the built-in objects in JavaScript continues, and the next
    three are fairly straightforward. They are Boolean, number, and string. They merely
    wrap the primitive data types.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 您在JavaScript中内置对象的旅程继续进行，接下来的三个对象都相当简单。它们是布尔值、数字和字符串。它们只是包装了原始数据类型。
- en: 'You already know a lot about Booleans from [Chapter 2](ch02.html "Chapter 2. Primitive
    Data Types, Arrays, Loops, and Conditions"), *Primitive Data Types, Arrays, Loops,
    and Conditions*. Now, let''s meet the `Boolean()` constructor:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经从[第2章](ch02.html "第2章.原始数据类型、数组、循环和条件")*原始数据类型、数组、循环和条件*中了解了很多关于布尔值。现在，让我们来认识`Boolean()`构造函数：
- en: '[PRE142]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'It''s important to note that this creates a new object, `b`, and not a primitive
    Boolean value. To get the primitive value, you can call the `valueOf()` method
    (inherited from `Object` class and customized):'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这将创建一个新对象`b`，而不是原始的布尔值。要获取原始值，可以调用`valueOf()`方法（从`Object`类和自定义继承）：
- en: '[PRE143]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Overall, objects created with the `Boolean()` constructor are not too useful,
    as they don't provide any methods or properties other than the inherited ones.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，使用`Boolean()`构造函数创建的对象并不太有用，因为它们除了继承的方法或属性之外没有提供任何其他方法。
- en: 'The `Boolean()` function, when called as a normal function without `new`, converts
    non-Booleans to Booleans (which is like using a double negation `!!`value):'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boolean()`函数在没有`new`的情况下作为普通函数调用时，将非布尔值转换为布尔值（这类似于使用双重否定`!!`值）：'
- en: '[PRE144]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Apart from the six `false` values, everything else is `true` in JavaScript,
    including all objects. This also means that all Boolean objects created with `new
    Boolean()` are also `true`, as they are objects:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 除了六个`false`值，JavaScript中的其他所有内容都是`true`，包括所有对象。这也意味着使用`new Boolean()`创建的所有布尔对象也都是`true`，因为它们是对象：
- en: '[PRE145]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: This can be confusing, and since Boolean objects don't offer any special methods,
    it's best to just stick with regular primitive Boolean values.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会令人困惑，由于布尔对象没有提供任何特殊方法，最好只使用常规原始布尔值。
- en: Number
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: 'Similar to `Boolean()`, the `Number()` function can be used as:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Boolean()`类似，`Number()`函数可以用作：
- en: A `constructor` function (with `new`) to create objects.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`constructor`函数（使用`new`）来创建对象。
- en: 'A normal function in order to try to convert any value to a number. This is
    similar to the use of `parseInt()` or `parseFloat()`:'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个普通函数，用于尝试将任何值转换为数字。这类似于使用`parseInt()`或`parseFloat()`：
- en: '[PRE146]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'As functions are objects, they can also have properties. The `Number()` function
    has constant built-in properties that you cannot modify:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数也是对象，它们也可以有属性。`Number()`函数具有内置的常量属性，您无法修改：
- en: '[PRE147]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The number objects provide three methods-`toFixed()`, `toPrecision()`, and
    `toExponential()`(see [Appendix C](apc.html "Appendix C. Built-in Objects"), *Built-in
    Objects*, for more details):'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 数字对象提供了三种方法-`toFixed()`，`toPrecision()`和`toExponential()`（有关更多详细信息，请参见[附录C](apc.html
    "附录C.内置对象")，*内置对象*）：
- en: '[PRE148]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Note that you can use these methods without explicitly creating a `Number`
    object first. In such cases, the `Number` object is created (and destroyed) for
    you behind the scenes:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以在不显式创建`Number`对象的情况下使用这些方法。在这种情况下，`Number`对象会在幕后为您创建（并销毁）：
- en: '[PRE149]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Like all objects, the `Number` object also provide the `toString()` method.
    When used with `Number` object, this method accepts an optional radix parameter
    (10 being the default):'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有对象一样，`Number`对象也提供了`toString()`方法。当与`Number`对象一起使用时，此方法接受一个可选的基数参数（默认为10）：
- en: '[PRE150]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: String
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: You can use the `String()` constructor function to create string objects. String
    objects provide convenient methods for text manipulation.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`String()`构造函数来创建字符串对象。字符串对象提供了方便的文本操作方法。
- en: 'Here''s an example that shows the difference between a `String` object and
    a `primitive` string data type:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，显示了`String`对象和`primitive`字符串数据类型之间的区别：
- en: '[PRE151]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: A `String` object is similar to an array of characters. String objects have
    an indexed property for each character (introduced in ES5, but long supported
    in many browsers, except old IEs), and they also have a `length` property.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`对象类似于字符数组。字符串对象为每个字符都有一个索引属性（在ES5中引入，但在许多浏览器中长期受支持，除了旧的IE），它们还有一个`length`属性。'
- en: '[PRE152]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'To extract the `primitive` value from the `String` object, you can use the
    `valueOf()` or `toString()` method inherited from `Object`. You''ll probably never
    need to do this, as `toString()` is called behind the scenes if you use an object
    in a `primitive` string context:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`String`对象中提取`primitive`值，可以使用从`Object`继承的`valueOf()`或`toString()`方法。您可能永远不需要这样做，因为如果在`primitive`字符串上下文中使用对象，则会在幕后调用`toString()`：
- en: '[PRE153]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: The `primitive` strings are not objects, so they don't have any methods or properties.
    However, JavaScript also offers you the syntax to treat `primitive` strings as
    objects (just like you already saw with primitive numbers).
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '`primitive` 字符串不是对象，因此它们没有任何方法或属性。但是，JavaScript 还为您提供了将 `primitive` 字符串视为对象的语法（就像您已经看到的原始数字一样）。'
- en: 'In the following example, `String` objects are being created (and then destroyed)
    behind the scenes every time you treat a `primitive` string as if it were an object:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，每当您将 `primitive` 字符串视为对象时，都会在后台创建（然后销毁）`String` 对象：
- en: '[PRE154]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Here is one final example to illustrate the difference between a `primitive`
    string and a `String` object. In this example, we are converting them to Boolean.
    The empty string is a falsy value, but any string object is truthy (because all
    objects are truthy):'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个最终示例，用于说明 `primitive` 字符串和 `String` 对象之间的区别。在此示例中，我们将它们转换为布尔值。空字符串是一个假值，但任何字符串对象都是真值（因为所有对象都是真值）：
- en: '[PRE155]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Similar to `Number()` and `Boolean()`, if you use the `String()` function without
    `new`, it converts the parameter to a primitive:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Number()` 和 `Boolean()` 类似，如果您在没有 `new` 的情况下使用 `String()` 函数，它会将参数转换为原始值：
- en: '[PRE156]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'If you pass an object to `String()`, this object''s `toString()` method will
    be called first:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将对象传递给 `String()`，则首先将调用该对象的 `toString()` 方法：
- en: '[PRE157]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: A few methods of string objects
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串对象的一些方法
- en: Let's experiment with a few of the methods you can call on string objects (see
    [Appendix C](apc.html "Appendix C. Built-in Objects"), *Built-in Objects*, for
    the complete list).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下您可以在字符串对象上调用的一些方法（请参见[附录 C](apc.html "附录 C. 内置对象")，“内置对象”，获取完整列表）。
- en: 'Start off by creating a string object:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个字符串对象：
- en: '[PRE158]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'The `toUpperCase()` and `toLowerCase()` methods transform the capitalization
    of the string:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`toUpperCase()` 和 `toLowerCase()` 方法可以转换字符串的大小写：'
- en: '[PRE159]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'The `charAt()` method tells you the character found at the position you specify,
    which is the same as using square brackets (treating a string as an array of characters):'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '`charAt()` 方法告诉您在指定位置找到的字符，这与使用方括号（将字符串视为字符数组）相同：'
- en: '[PRE160]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'If you pass a non-existent position to `charAt()`, you get an empty string:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您向 `charAt()` 传递一个不存在的位置，您将得到一个空字符串：
- en: '[PRE161]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'The `indexOf()` method allows you to search within a string. If there is a
    match, the method returns the position at which the first match is found. The
    position count starts at 0, so the second character in `Couch` is `o` at position
    1:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexOf()` 方法允许您在字符串中进行搜索。如果找到匹配项，该方法将返回找到第一个匹配项的位置。位置计数从 0 开始，因此 `Couch`
    中的第二个字符是位置 1 处的 `o`：'
- en: '[PRE162]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'You can optionally specify where (at what position) to start the search. The
    following finds the second `o`, because `indexOf()` is instructed to start the
    search at position 2:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择指定从哪里（在什么位置）开始搜索。以下示例找到第二个 `o`，因为 `indexOf()` 被指示从位置 2 开始搜索：
- en: '[PRE163]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The `lastIndexOf()`starts the search from the end of the string (but the position
    of the match is still counted from the beginning):'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`lastIndexOf()` 从字符串的末尾开始搜索（但是匹配的位置仍然从开头计数）：'
- en: '[PRE164]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'You can search , not only for characters, but also for strings, and the search
    is case sensitive:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以搜索字符，也可以搜索字符串，搜索区分大小写：
- en: '[PRE165]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'If there is no match, the function returns position `-1`:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有匹配项，该函数将返回位置 `-1`：
- en: '[PRE166]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'For a case-insensitive search, you can transform the string to lowercase first
    and then search:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不区分大小写的搜索，您可以先将字符串转换为小写，然后再搜索：
- en: '[PRE167]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'If you get `0`, this means that the matching part of the string starts at position
    `0`. This can cause confusion when you check with `if`, because `if` converts
    the position `0` to a Boolean `false` value. So, while this is syntactically correct,
    it is logically wrong:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 如果得到 `0`，这意味着字符串的匹配部分从位置 `0` 开始。这可能会在使用 `if` 时引起混淆，因为 `if` 将位置 `0` 转换为布尔值 `false`。因此，尽管这在语法上是正确的，但在逻辑上是错误的：
- en: '[PRE168]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'The proper way to check whether a string contains another string is to compare
    the result of `indexOf()` to the number `-1`:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 检查字符串是否包含另一个字符串的正确方法是将 `indexOf()` 的结果与数字 `-1` 进行比较：
- en: '[PRE169]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'The `slice()`and `substring()` return a piece of the string when you specify
    the start and end positions:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`slice()` 和 `substring()` 在指定开始和结束位置时返回字符串的一部分：'
- en: '[PRE170]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Note that the second parameter you pass is the end position, not the length
    of the piece. The difference between these two methods is how they treat negative
    arguments. `substring()` treats them as zeros, while `slice()` adds them to the
    length of the string. So, if you pass parameters `(1, -1)` to both methods, it''s
    the same as `substring(1,0)` and `slice(1,s.length-1)`:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您传递的第二个参数是结束位置，而不是片段的长度。这两种方法之间的区别在于它们如何处理负参数。`substring()` 将它们视为零，而 `slice()`
    将它们添加到字符串的长度。因此，如果您将参数 `(1, -1)` 传递给这两种方法，它等同于 `substring(1,0)` 和 `slice(1,s.length-1)`：
- en: '[PRE171]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: There's also the non-standard method `substr()`, but you should try to avoid
    it in favor of `substring()`.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个非标准的 `substr()` 方法，但您应该尽量避免使用它，而使用 `substring()`。
- en: 'The `split()` method creates an array from the string using another string
    that you pass as a separator:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '`split()` 方法使用您传递的另一个字符串作为分隔符从字符串创建一个数组：'
- en: '[PRE172]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'The `split()` method is the opposite of the `join()` method, which creates
    a string from an array:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`split()` 方法是 `join()` 方法的相反，它从数组创建一个字符串：'
- en: '[PRE173]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'The `concat()` glues strings together, in the same way in which the `+` operator
    does for `primitive` strings:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat()` 将字符串粘合在一起，就像 `+` 运算符对 `primitive` 字符串一样：'
- en: '[PRE174]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Note that while some of the preceding methods discussed return new `primitive`
    strings, none of them modify the source string. After all the method calls listed
    previously, the initial string is still the same:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然前面讨论的一些方法返回新的 `primitive` 字符串，但它们都不会修改源字符串。在之前列出的所有方法调用之后，初始字符串仍然是相同的：
- en: '[PRE175]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: You have seen how to use `indexOf()` and `lastIndexOf()` to search within strings,
    but there are more powerful methods (`search()`, `match()`, and `replace()`) that
    take regular expressions as parameters. You'll see these later in the `RegExp()`
    constructor function.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何使用`indexOf()`和`lastIndexOf()`在字符串中进行搜索，但还有更强大的方法（`search()`，`match()`和`replace()`）可以将正则表达式作为参数。稍后你会看到这些方法在`RegExp()`构造函数中。
- en: At this point, you're done with all of the data wrapper objects, so let's move
    on to the utility objects `Math`, `Date`, and `RegExp`.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你已经完成了所有的数据包装对象，所以让我们继续讨论实用对象`Math`，`Date`和`RegExp`。
- en: Math
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Math
- en: '`Math` is a little different from the other built-in global objects you have
    seen previously. It''s not a function, and, therefore, cannot be used with `new`
    to create objects. `Math` is a built-in global object that provides a number of
    methods and properties for mathematical operations.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math`与你之前看到的其他内置全局对象有些不同。它不是一个函数，因此不能与`new`一起用来创建对象。`Math`是一个内置的全局对象，为数学运算提供了许多方法和属性。'
- en: 'The `Math` object''s properties are constants, so you can''t change their values.
    Their names are all in uppercase to emphasize the difference between them and
    a normal property (similar to the constant properties of the `Number()` constructor).
    Let''s see a few of these constant properties:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math`对象的属性是常数，所以你不能改变它们的值。它们的名称都是大写的，以强调它们与普通属性的区别（类似于`Number()`构造函数的常量属性）。让我们看一些这些常量属性：'
- en: 'The constant PI:'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常数PI：
- en: '[PRE176]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Square root of 2:'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2的平方根：
- en: '[PRE177]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Euler''s constant:'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欧拉常数：
- en: '[PRE178]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Natural logarithm of 2:'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2的自然对数：
- en: '[PRE179]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Natural logarithm of 10:'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10的自然对数：
- en: '[PRE180]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Now, you know how to impress your friends the next time they (for whatever reason)
    start wondering, "What was the value of *e*? I can't remember." Just type `Math.E`
    in the console and you have the answer.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你知道了如何在下一次朋友们（不管出于什么原因）开始想知道“*e*的值是多少？我记不清了。”时给他们留下深刻印象。只需在控制台中输入`Math.E`，你就有了答案。
- en: Let's take a look at some of the methods the `Math` object provides (the full
    list is in [Appendix C](apc.html "Appendix C. Built-in Objects"), *Built-in Objects*).
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`Math`对象提供的一些方法（完整列表在[附录C](apc.html "附录C.内置对象")中，“内置对象”）。
- en: 'Generating random numbers:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 生成随机数：
- en: '[PRE181]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'The `random()` function returns a number between `0` and `1`, so if you want
    a number between, let''s say, `0` and `100`, you can use the following line of
    code:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '`random()`函数返回一个在`0`和`1`之间的数字，所以如果你想要一个在`0`和`100`之间的数字，你可以使用以下代码：'
- en: '[PRE182]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'For numbers between any two values, use the formula `((max-min) * Math.random())+min`.
    For example, a random number between 2 and 10 can be obtained using the formula
    as follows:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任意两个值之间的数字，使用公式`((max-min) * Math.random())+min`。例如，可以使用以下公式获得2到10之间的随机数：
- en: '[PRE183]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'If you only need an integer, you can use one of the following rounding methods:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要一个整数，你可以使用以下其中一种取整方法：
- en: '`floor()` to round down'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`floor()`向下取整'
- en: '`ceil()` to round up'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ceil()`向上取整'
- en: '`round()` to round to the nearest'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`round()`四舍五入'
- en: 'For example, to get either `0` or `1`, you can use the following line of code:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要获得`0`或`1`，你可以使用以下代码：
- en: '[PRE184]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'If you need the lowest or the highest among a set of numbers, you have the
    `min()` and `max()` methods. So, if you have a form on a page that asks for a
    valid month, you can make sure that you always work with sane data (a value between
    `1` and `12`):'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一组数字中的最低或最高值，你可以使用`min()`和`max()`方法。所以，如果你在页面上有一个要求有效月份的表单，你可以确保你总是使用合理的数据（一个值在`1`和`12`之间）：
- en: '[PRE185]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: The `Math` object also provides the ability to perform mathematical operations
    for which you don't have a designated operator. This means that you can raise
    to a power using `pow()`, find the square root using `sqrt()`, and perform all
    the trigonometric operations-`sin()`, `cos()`, `atan()`, and so on.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math`对象还提供了执行数学运算的能力，而这些运算没有专门的运算符。这意味着你可以使用`pow()`进行乘方运算，使用`sqrt()`找到平方根，并执行所有的三角函数运算-`sin()`，`cos()`，`atan()`等等。'
- en: 'For example, to calculate `2` to the power of `8`, you can use the following
    line of code:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要计算`2`的`8`次方，你可以使用以下代码：
- en: '[PRE186]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'To calculate the square root of `9`, you can use the following line of code:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算`9`的平方根，你可以使用以下代码：
- en: '[PRE187]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Date
  id: totrans-578
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期
- en: '`Date()` is a constructor function that creates date objects. You can create
    a new object by passing:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date()`是一个创建日期对象的构造函数。您可以通过传递来创建一个新对象：'
- en: Nothing (defaults to today's date)
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无（默认为今天的日期）
- en: A date-like string
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似日期的字符串
- en: Separate values for day, month, time, and so on
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分别为天、月、时间等提供值
- en: A timestamp
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳
- en: 'Here is an object instantiated with today''s date/time (using the browser''s
    timezone):'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用今天的日期/时间实例化的对象（使用浏览器的时区）：
- en: '[PRE188]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: The console displays the result of the `toString()` method called on the `Date`
    object, so you get this long string `Wed Feb 27 2013 23:49:28 GMT-0800 (PST)`
    as a representation of the date object.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台显示了在`Date`对象上调用`toString()`方法的结果，所以你会得到这个长字符串`Wed Feb 27 2013 23:49:28 GMT-0800
    (PST)`作为日期对象的表示。
- en: 'Here are a few examples of using strings to initialize a `Date` object. Note
    how many different formats you can use to specify the date:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用字符串初始化`Date`对象的一些示例。请注意你可以使用多种不同的格式来指定日期：
- en: '[PRE189]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'The `Date` constructor can figure out a date from different strings, but this
    is not really a reliable way of defining a precise date, for example, when passing
    user input to the constructor. A better way is to pass numeric values to the `Date()`
    constructor representing:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date`构造函数可以从不同的字符串中找出一个日期，但这并不是一个定义精确日期的可靠方法，例如，当将用户输入传递给构造函数时。更好的方法是向`Date()`构造函数传递表示：'
- en: Year
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年
- en: Month - 0 (January) to 11 (December)
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 月 - 0（一月）到11（十二月）
- en: Day - 1 to 31
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日 - 1到31
- en: Hour - 0 to 23
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小时 - 0到23
- en: Minutes - 0 to 59
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分钟 - 0到59
- en: Seconds - 0 to 59
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秒 - 0到59
- en: Milliseconds - 0 to 999
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 毫秒 - 0到999
- en: Let's look at some examples.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些例子。
- en: 'Passing all the parameters by writing the following line of code:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写以下代码来传递所有参数：
- en: '[PRE190]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Passing date and hour by writing the following line of code:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写以下代码来传递日期和小时：
- en: '[PRE191]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Watch out for the fact that the month starts from 0, so 1 is February:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意月份是从0开始的，所以1代表二月：
- en: '[PRE192]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'If you pass a value greater than the one allowed, your date overflows forward.
    As there''s no February 30 in 2016, this means it has to be March 1 (2016 is a
    leap year):'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递的值大于允许的值，您的日期将向前溢出。由于2016年没有2月30日，这意味着它必须是3月1日（2016年是闰年）：
- en: '[PRE193]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Similarly, December 32 becomes January 1 of the next year:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，12月32日变成了下一年的1月1日：
- en: '[PRE194]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Finally, a date object can be initialized with a timestamp (the number of milliseconds
    since the UNIX epoch, where 0 milliseconds is January 1, 1970):'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，日期对象可以使用时间戳（自UNIX纪元以来的毫秒数，其中0毫秒是1970年1月1日）进行初始化：
- en: '[PRE195]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'If you call `Date()` without `new`, you get a string representing the current
    date, whether or not you pass any parameters. The following example gives the
    current time (current when this example was run):'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用`Date()`而不使用`new`，则会得到一个表示当前日期的字符串，无论是否传递任何参数。以下示例给出了当前时间（在运行此示例时的当前时间）：
- en: '[PRE196]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Methods to work with date objects
  id: totrans-612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于处理日期对象的方法
- en: Once you've created a date object, there are lots of methods you can call on
    that object. Most of the methods can be divided into `set*()` and `get*()` methods,
    for example, `getMonth()`, `setMonth()`, `getHours()`, `setHours()`, and so on.
    Let's see some examples.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 创建日期对象后，您可以在该对象上调用许多方法。大多数方法可以分为`set*()`和`get*()`方法，例如`getMonth()`、`setMonth()`、`getHours()`、`setHours()`等。让我们看一些例子。
- en: 'Creating a date object by writing the following code:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写以下代码创建日期对象：
- en: '[PRE197]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'Setting the month to March (months start from 0):'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 将月份设置为三月（月份从0开始）：
- en: '[PRE198]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Getting the month by writing the following code:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写以下代码来获取月份：
- en: '[PRE199]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: In addition to all the methods of date objects, there are also two methods (plus
    one more added in ES5) that are properties of the `Date()` function/object. These
    do not need a `date` object; they work just like the `Math` object methods. In
    class-based languages, such methods would be called static because they don't
    require an instance.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 除了日期对象的所有方法外，`Date()`函数/对象还有两种方法（ES5中添加了一种方法），它们是`Date()`函数/对象的属性。这些不需要`date`对象；它们的工作方式就像`Math`对象的方法一样。在基于类的语言中，这样的方法被称为静态方法，因为它们不需要实例。
- en: 'The `Date.parse()` method takes a string and returns a timestamp:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date.parse()`方法接受一个字符串并返回一个时间戳：'
- en: '[PRE200]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'The `Date.UTC()` method takes all the parameters for year, month, day, and
    so on, and produces a timestamp in **Universal Time** (**UT**):'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date.UTC()`方法接受年、月、日等所有参数，并在**世界标准时间**（**UT**）中生成一个时间戳：'
- en: '[PRE201]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'As the `new Date()` constructor can accept timestamps, you can pass the result
    of `Date.UTC()` to it. Using the following example, you can see how `UTC()` works
    with Universal Time, while `new Date()` works with local time:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`new Date()`构造函数可以接受时间戳，因此可以将`Date.UTC()`的结果传递给它。使用以下示例，您可以看到`UTC()`如何与世界标准时间一起工作，而`new
    Date()`与本地时间一起工作：
- en: '[PRE202]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'The ES5 addition to the `Date` constructor is the `now()`method, which returns
    the current timestamp. It provides a more convenient way to get the timestamp
    instead of using the `getTime()` method on a `Date` object as you would in ES3:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date`构造函数的ES5新增方法是`now()`，它返回当前时间戳。它提供了一个更方便的方法来获取时间戳，而不是像在ES3中那样在`Date`对象上使用`getTime()`方法：'
- en: '[PRE203]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'You can think of the internal representation of the date being an integer timestamp
    and all other methods being sugar on top of it. So, it makes sense that `valueOf()`
    is a timestamp:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将日期的内部表示想象成一个整数时间戳，而所有其他方法都是在其上的糖。因此，`valueOf()`是一个时间戳是有意义的：
- en: '[PRE204]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Also, dates cast to integers with the `+` operator:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，日期可以通过`+`运算符转换为整数：
- en: '[PRE205]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Calculating birthdays
  id: totrans-633
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计算生日
- en: 'Let''s look at one final example of working with `Date` objects. I was curious
    about which day my birthday falls on in 2016:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个最后的`Date`对象的工作示例。我很好奇我的生日在2016年是星期几：
- en: '[PRE206]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Starting the count from 0 (Sunday), 1 means Monday. Is that so?
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 从0开始计数（星期日），1代表星期一。是这样吗？
- en: '[PRE207]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: ok, good to know, but Monday is not necessarily the best day for a party. So,
    how about a loop that shows how many times June 20 is a Friday from year 2016
    to year 3016, or better yet, let's see the distribution of all the days of the
    week. After all, with all the progress in DNA hacking, we're all going to be alive
    and kicking in 3016.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，知道了，但是星期一不一定是举办派对的最佳日子。那么，我们来看看一个循环，展示从2016年到3016年6月20日是星期五的次数，或者更好的是，让我们看看一周中所有日期的分布。毕竟，随着DNA技术的进步，我们都将在3016年活得好好的。
- en: 'First, let''s initialize an array with seven elements, one for each day of
    the week. These will be used as counters. Then, as a loop goes up to 3016, let''s
    increment the counters:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们用七个元素初始化一个数组，每个元素代表一周的一天。这些将被用作计数器。然后，当循环到3016年时，让我们递增计数器：
- en: '[PRE208]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Here is the loop:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是循环：
- en: '[PRE209]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'Here is the result:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '[PRE210]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 142 Fridays and 145 Saturdays. Woo-hoo!
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 142个星期五和145个星期六。哇哦！
- en: RegExp
  id: totrans-646
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RegExp
- en: Regular expressions provide a powerful way to search and manipulate text. Different
    languages have different implementations (think dialects) of the regular expression
    syntax. JavaScript uses the Perl 5 syntax.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式提供了一种强大的搜索和操作文本的方法。不同的语言有不同的正则表达式语法实现（考虑方言）。JavaScript使用Perl 5语法。
- en: Instead of saying regular expression, people often shorten it to regex or regexp.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 人们通常将正则表达式缩写为regex或regexp。
- en: 'A regular expression consists of:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式由以下部分组成：
- en: A pattern you use to match text
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于匹配文本的模式
- en: Zero or more modifiers (also called flags) that provide more instructions on
    how the pattern should be used
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零个或多个修饰符（也称为标志），提供有关应如何使用模式的更多指令
- en: The pattern can be as simple as literal text to be matched verbatim, but that's
    rare, and in such cases you're better off using `indexOf()`. Most of the time,
    the pattern is more complex and could be difficult to understand. Mastering regular
    expressions' patterns is a large topic, which won't be discussed in full detail
    here. Instead, you'll see what JavaScript provides in terms of syntax, objects,
    and methods in order to support the use of regular expressions. You can also refer
    to [Appendix D](apd.html "Appendix D. Regular Expressions"), *Regular Expressions*,
    to help you when you're writing patterns.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 模式可以是简单的文字文本，以便逐字匹配，但这种情况很少见，而且在这种情况下，最好使用`indexOf()`。大多数情况下，模式更复杂，可能难以理解。掌握正则表达式的模式是一个庞大的主题，在这里不会详细讨论。相反，你将看到JavaScript在语法、对象和方法方面提供了什么来支持正则表达式的使用。你也可以参考[附录D](apd.html
    "附录 D. 正则表达式")，*正则表达式*，在你编写模式时帮助你。
- en: 'JavaScript provides the `RegExp()` constructor, which allows you to create
    regular expression objects:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript提供了`RegExp()`构造函数，允许你创建正则表达式对象：
- en: '[PRE211]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'There is also the more convenient **regexp literal notation**:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更方便的**正则表达式字面量表示法**：
- en: '[PRE212]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: In the preceding example, `j.*t` is the regular expression pattern. It means
    `"` matches any string that starts with `j`, ends with `t`, and has zero or more
    characters in between `"`. The asterisk (`*`) means `"` zero or more of the preceding,
    `"` and the dot (`.`) means `"` any character `"`. The pattern needs to be quoted
    when passed to a `RegExp()` constructor.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`j.*t`是正则表达式模式。它表示`"`匹配任何以`j`开头，以`t`结尾，并且中间有零个或多个字符的字符串`"`。星号（`*`）表示`"`前面的零个或多个，`"`点（`.`）表示`"`任何字符`"`。传递给`RegExp()`构造函数时，模式需要用引号括起来。
- en: Properties of RegExp objects
  id: totrans-658
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RegExp对象的属性
- en: 'Regular expression objects have the following properties:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式对象有以下属性：
- en: '`global`: If this property is `false`, which is the default, the search stops
    when the first match is found. Set this to `true` if you want all matches.'
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`global`：如果这个属性是`false`，也就是默认值，那么当找到第一个匹配时搜索就会停止。如果你想要所有的匹配，就把它设置为`true`。'
- en: '`ignoreCase`: When the match is case insensitive, this property defaults to
    `false` (meaning the default is a case-sensitive match).'
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignoreCase`：当匹配不区分大小写时，这个属性默认为`false`（意味着默认是区分大小写的匹配）。'
- en: '`multiline`: Search matches that may span over more than one line default to
    `false`.'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multiline`：搜索可能跨越多行的匹配，默认为`false`。'
- en: '`lastIndex`: The position at which to start the search; this defaults to `0`.'
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastIndex`：开始搜索的位置；默认为`0`。'
- en: '`source`: This contains the `RegExp` pattern.'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source`：这包含了`RegExp`模式。'
- en: None of these properties, except for `lastIndex`, can be changed once the object
    has been created.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`lastIndex`之外，这些属性都不能在对象创建后被改变。
- en: 'The first three items in the preceding list represent the regex modifiers.
    If you create a regex object using the constructor, you can pass any combination
    of the following characters as a second parameter:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的列表中，前三个项目代表了正则表达式修饰符。如果你使用构造函数创建一个正则表达式对象，你可以将以下任意组合的字符作为第二个参数传递：
- en: '`g` for `global`'
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g`代表`global`'
- en: '`i` for `ignoreCase`'
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`代表`ignoreCase`'
- en: '`m` for `multiline`'
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m`代表`multiline`'
- en: 'These letters can be in any order. If a letter is passed, the corresponding
    modifier property is set to `true`. In the following example, all modifiers are
    set to `true`:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字母可以以任何顺序出现。如果传递了一个字母，相应的修饰符属性就会被设置为`true`。在下面的例子中，所有修饰符都被设置为`true`：
- en: '[PRE213]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'Let''s verify:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证一下：
- en: '[PRE214]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'Once set, the modifier cannot be changed:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置，修饰符就不能被改变：
- en: '[PRE215]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'To set any modifiers using the regex literal, you add them after the closing
    slash:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用正则表达式字面量设置任何修饰符，你需要在闭合斜杠后添加它们：
- en: '[PRE216]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Methods of RegExp objects
  id: totrans-678
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RegExp对象的方法
- en: Regex objects provide two methods you can use to find matches-`test()` and `exec()`.
    They both accept a string parameter. The `test()` method returns a Boolean (`true`
    when there's a match, `false` otherwise), while `exec()` returns an array of matched
    strings. Obviously, `exec()` is doing more work, so use `test()` only if you really
    need to do something with the matches. People often use regular expressions to
    validate data. In this case, `test()` should be enough.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式对象提供了两种方法来查找匹配-`test()`和`exec()`。它们都接受一个字符串参数。`test()`方法返回一个布尔值（当有匹配时为`true`，否则为`false`），而`exec()`返回一个匹配字符串的数组。显然，`exec()`做了更多的工作，所以只有在你真的需要对匹配做一些操作时才使用`test()`。人们经常使用正则表达式来验证数据。在这种情况下，`test()`应该足够了。
- en: 'In the following example, there is no match because of the capital `J`:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，由于大写的`J`，没有匹配：
- en: '[PRE217]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'A case-insensitive test gives a positive result:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不区分大小写的测试会得到一个积极的结果：
- en: '[PRE218]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'The same test using `exec()` returns an array, and you can access the first
    element as shown here:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`exec()`进行相同的测试会返回一个数组，你可以像下面这样访问第一个元素：
- en: '[PRE219]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: String methods that accept regular expressions as arguments
  id: totrans-686
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接受正则表达式作为参数的字符串方法
- en: Previously in this chapter, you learned about string objects and how you can
    use the `indexOf()` and `lastIndexOf()` methods to search within text. Using these
    methods, you can only specify literal string patterns to search. A more powerful
    solution would be to use regular expressions to find text. String objects offer
    you this ability.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，你学习了字符串对象以及如何使用`indexOf()`和`lastIndexOf()`方法在文本中进行搜索。使用这些方法，你只能指定文字字符串模式进行搜索。更强大的解决方案是使用正则表达式来查找文本。字符串对象为你提供了这种能力。
- en: 'String objects provide the following methods that accept regular expression
    objects as parameters:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串对象提供了以下接受正则表达式对象作为参数的方法：
- en: '`match()`: Returns an array of matches'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`match()`：返回一个匹配的数组'
- en: '`search()`: Returns the position of the first match'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search()`：返回第一个匹配的位置'
- en: '`replace()`: Allows you to substitute matched text with another string'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace()`：允许你用另一个字符串替换匹配的文本'
- en: '`split()`: Accepts a regexp when splitting a string into array elements'
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`split()`：在将字符串分割成数组元素时接受一个正则表达式'
- en: search() and match()
  id: totrans-693
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: search()和match()
- en: 'Let''s look at some examples of using the `search()`and `match()` methods.
    First, you create a string object:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些使用`search()`和`match()`方法的例子。首先，你创建一个字符串对象：
- en: '[PRE220]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'Using `match()`, you get an array containing only the first match:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`match()`，你得到一个只包含第一个匹配的数组：
- en: '[PRE221]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'Using the `g` modifier, you perform a global search, so the result array contains
    two elements:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`g`修饰符，你执行全局搜索，所以结果数组包含两个元素：
- en: '[PRE222]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'A case-insensitive match is as follows:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 不区分大小写的匹配如下：
- en: '[PRE223]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'The `search()` method gives you the position of the matching string:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '`search()`方法给出了匹配字符串的位置：'
- en: '[PRE224]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: replace()
  id: totrans-704
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: replace()
- en: 'The `replace()` method allows you to replace the matched text with some other
    string. The following example removes all capital letters (it replaces them with
    blank strings):'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace()`方法允许你用其他字符串替换匹配的文本。以下示例删除所有大写字母（用空字符串替换它们）：'
- en: '[PRE225]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'If you omit the `g` modifier, you''re only going to replace the first match:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你省略`g`修饰符，你只会替换第一个匹配：
- en: '[PRE226]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'When a match is found, if you want to include the matched text in the replacement
    string, you can access it using `$&`. Here''s how to add an underscore before
    the match while keeping the match:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 当找到匹配时，如果你想在替换字符串中包含匹配的文本，你可以使用`$&`来访问它。下面是如何在保留匹配的同时在匹配前添加下划线：
- en: '[PRE227]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'When the regular expression contains groups (denoted by parentheses), the matches
    of each group are available as `$1` for the first group, `$2` the second, and
    so on:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 当正则表达式包含组（用括号表示），每个组的匹配都可以作为`$1`表示第一个组，`$2`表示第二个组，依此类推：
- en: '[PRE228]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'Imagine you have a registration form on your web page that asks for an e-mail
    address, username, and password. The user enters their e-mail IDs, and then, your
    JavaScript kicks in and suggests the username, taking it from the e-mail address:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的网页上有一个注册表单，要求输入电子邮件地址、用户名和密码。用户输入他们的电子邮件ID，然后，你的JavaScript开始并建议用户名，从电子邮件地址中获取：
- en: '[PRE229]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: Replace callbacks
  id: totrans-715
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换回调
- en: 'When specifying the replacement, you can also pass a function that returns
    a string. This gives you the ability to implement any special logic you may need
    before specifying the replacements:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定替换时，你也可以传递一个返回字符串的函数。这使你能够在指定替换之前实现任何特殊逻辑：
- en: '[PRE230]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'The callback function receives a number of parameters (the previous example
    ignores all but the first one):'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数接收多个参数（前面的例子忽略了除第一个参数之外的所有参数）：
- en: The first parameter is the `match`
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是`match`
- en: The last is the string being searched
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后是被搜索的字符串
- en: The one before last is the position of the `match`
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 倒数第二个是`match`的位置
- en: The rest of the parameters contain any strings matched by any groups in your
    regex pattern
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余的参数包含你的正则表达式模式中任何组匹配的任何字符串
- en: 'Let''s test this. First, let''s create a variable to store the entire arguments
    array passed to the callback function:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下。首先，让我们创建一个变量来存储传递给回调函数的整个参数数组：
- en: '[PRE231]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'Next, define a regular expression that has three groups and matches e-mail
    addresses in the format `something@something.something`:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个具有三个组并匹配格式为`something@something.something`的电子邮件地址的正则表达式：
- en: '[PRE232]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'Finally, let''s define a callback function that stores the arguments in `glob`
    and then returns the replacement:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们定义一个回调函数，将参数存储在`glob`中，然后返回替换：
- en: '[PRE233]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'Now, perform a test:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行一个测试：
- en: '[PRE234]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'Here''s what the callback function received as arguments:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 这是回调函数接收到的参数：
- en: '[PRE235]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: split()
  id: totrans-733
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: split()
- en: 'You already know about the `split()` method, which creates an array from an
    input string and a delimiter string. Let''s take a string of comma-separated values
    and split it:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道`split()`方法，它可以从输入字符串和分隔符字符串创建一个数组。让我们取一个逗号分隔的值的字符串并将其拆分：
- en: '[PRE236]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'Because the input string happens to have random inconsistent spaces before
    and after the commas, the array result has spaces too. With a regular expression,
    you can fix this using `\s*`, which means zero or more spaces:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 因为输入字符串恰好在逗号之前和之后有随机不一致的空格，所以数组结果也有空格。使用正则表达式，你可以使用`\s*`来修复这个问题，它表示零个或多个空格：
- en: '[PRE237]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: Passing a string when a RegExp is expected
  id: totrans-738
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当期望一个正则表达式时传递一个字符串
- en: One last thing to note is that the four methods that you have just seen (`split()`,
    `match()`, `search()`, and `replace()`) can also take strings as opposed to regular
    expressions. In this case, the string argument is used to produce a new regex
    as if it were passed to `new RegExp()`.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的一点是，你刚刚看到的这四种方法（`split()`、`match()`、`search()`和`replace()`）也可以接受字符串而不是正则表达式。在这种情况下，字符串参数被用来产生一个新的正则表达式，就好像它被传递给`new
    RegExp()`一样。
- en: 'An example of passing a string to `replace` is shown as follows:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串传递给`replace`的示例如下所示：
- en: '[PRE238]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'The preceding lines of code are the same as the following one:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码行与下面的代码行相同：
- en: '[PRE239]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'When you pass a string, you cannot set modifiers the way you do with a normal
    constructor or regex literal. There''s a common source of errors when using a
    string instead of a regular expression object for string replacements, and it''s
    due to the fact that the `g` modifier is `false` by default. The outcome is that
    only the first string is replaced, which is inconsistent with most other languages
    and a little confusing. Here is an example:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 当你传递一个字符串时，你不能像使用普通构造函数或正则表达式字面量那样设置修饰符。当使用字符串而不是正则表达式对象进行字符串替换时，存在一个常见的错误来源，这是因为`g`修饰符默认为`false`。结果是只有第一个字符串被替换，这与大多数其他语言不一致，有点令人困惑。这里有一个例子：
- en: '[PRE240]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'Most likely, you want to replace all occurrences:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，你想要替换所有出现的：
- en: '[PRE241]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: Error objects
  id: totrans-748
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误对象
- en: Errors happen, and it's good to have the mechanisms in place so that your code
    can realize that there has been an error condition and can recover from it in
    a graceful manner. JavaScript provides the `try`, `catch`, and `finally` statements
    to help you deal with errors. If an error occurs, an error object is thrown. Error
    objects are created using one of these built-in constructors-`EvalError`, `RangeError`,
    `ReferenceError`, `SyntaxError`, `TypeError`, and `URIError`. All these constructors
    inherit from `Error`.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 错误会发生，有必要有机制来让你的代码意识到发生了错误，并以一种优雅的方式从中恢复。JavaScript提供了`try`、`catch`和`finally`语句来帮助你处理错误。如果发生错误，将抛出一个错误对象。错误对象是使用这些内置构造函数之一创建的-`EvalError`、`RangeError`、`ReferenceError`、`SyntaxError`、`TypeError`和`URIError`。所有这些构造函数都继承自`Error`。
- en: 'Let''s just cause an error and see what happens. What''s a simple way to cause
    an error? Just call a function that doesn''t exist. Type this into the console:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们只是引发一个错误，看看会发生什么。引发错误的简单方法是什么？只需调用一个不存在的函数。在控制台中键入以下内容：
- en: '[PRE242]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'You''ll get something like the following:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到类似以下的内容：
- en: '![Error objects](graphics/image_04_003-e1482749061350.jpg)'
  id: totrans-753
  prefs: []
  type: TYPE_IMG
  zh: '![错误对象](graphics/image_04_003-e1482749061350.jpg)'
- en: The display of errors can vary greatly between browsers and other host environments.
    In fact, most recent browsers tend to hide the errors from the users. However,
    you cannot assume that all of your users have disabled the display of errors,
    and it is your responsibility to ensure an error-free experience for them. The
    previous error propagated to the user, because the code didn't try to trap (catch)
    this error. The code didn't expect the error and was not prepared to handle it.
    Fortunately, it's trivial to trap the error. All you need is the `try` statement
    followed by a `catch` statement.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的显示在不同的浏览器和其他主机环境中可能会有很大的差异。事实上，大多数最近的浏览器倾向于隐藏错误。但是，您不能假设所有用户都已禁用错误显示，并且您有责任确保他们的体验是无错误的。之前的错误传播给用户，因为代码没有尝试捕获（catch）此错误。代码没有预期错误，也没有准备好处理它。幸运的是，捕获错误是微不足道的。您只需要`try`语句，后跟`catch`语句。
- en: 'This code hides the error from the user:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会隐藏错误：
- en: '[PRE243]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'Here you have:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你有：
- en: The `try` statement followed by a block of code.
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try`语句后跟一块代码。'
- en: The `catch` statement followed by a variable name in parentheses and another
    block of code.
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catch`语句后跟括号中的变量名，然后是另一个代码块。'
- en: There can be an optional `finally` statement (not used in this example) followed
    by a block of code, which is executed regardless of whether there was an error
    or not.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 可以有一个可选的`finally`语句（在此示例中未使用），后跟一块代码，无论是否出现错误都会执行。
- en: In the previous example, the code block that follows the `catch` statement didn't
    do anything. However, this is the place where you put the code that can help recover
    from the error, or at least give feedback to the user that your application is
    aware that there was a special condition.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，紧随`catch`语句之后的代码块什么也没做。然而，这是你放置代码的地方，可以帮助从错误中恢复，或者至少向用户提供反馈，表明你的应用程序知道存在特殊条件。
- en: The variable `e` in the parentheses after the `catch` statement contains an
    error object. Like any other object, it contains properties and methods. Unfortunately,
    different browsers implement these methods and properties differently, but there
    are two properties that are consistently implemented-`e.name` and `e.message`.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`语句括号中的变量`e`包含一个错误对象。与任何其他对象一样，它包含属性和方法。不幸的是，不同的浏览器以不同的方式实现这些方法和属性，但有两个属性是一致实现的-`e.name`和`e.message`。'
- en: 'Let''s try this code now:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试这段代码：
- en: '[PRE244]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: This will present an `alert()` showing `e.name` and `e.message` and then another
    `alert()` saying `Finally!`.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示一个`alert()`，显示`e.name`和`e.message`，然后另一个`alert()`显示`Finally!`。
- en: 'In Firefox and Chrome, the first alert will say **ReferenceError: iDontExist
    is not defined**. In Internet Explorer, it will be **TypeError: Object expected**.
    This tells us two things:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '在Firefox和Chrome中，第一个警报将显示**ReferenceError: iDontExist is not defined**。在Internet
    Explorer中，它将是**TypeError: Object expected**。这告诉我们两件事：'
- en: The `e.name` method contains the name of the constructor that was used to create
    the error object
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e.name`方法包含用于创建错误对象的构造函数的名称'
- en: As the error objects are not consistent across host environments (browsers),
    it would be somewhat tricky to have your code act differently depending on the
    type of error (the value of `e.name`)
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于错误对象在主机环境（浏览器）中不一致，根据错误类型（`e.name`的值）使您的代码以不同方式行事可能有些棘手
- en: You can also create error objects yourself using `new Error()` or any of the
    other error constructors and then let the JavaScript engine know that there's
    an erroneous condition using the `throw` statement.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`new Error()`或任何其他错误构造函数自己创建错误对象，然后使用`throw`语句告诉JavaScript引擎存在错误条件。
- en: 'For example, imagine a scenario where you call the `maybeExists()` function
    and after that make calculations. You want to trap all errors in a consistent
    way, no matter whether the error is that `maybeExists()` doesn''t exist or that
    your calculations found a problem. Consider the following code:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一种情况，您调用`maybeExists()`函数，然后进行计算。您希望以一种一致的方式捕获所有错误，无论是`maybeExists()`不存在还是您的计算发现了问题。考虑以下代码：
- en: '[PRE245]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'This code will alert different messages depending on whether or not `maybeExists()`
    is defined and the values it returns:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将根据`maybeExists()`是否定义以及它返回的值而显示不同的消息：
- en: 'If `maybeExists()` doesn''t exist, you get **ReferenceError: maybeExists()
    is not defined** in Firefox and **TypeError: Object expected** in IE'
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果`maybeExists()`不存在，Firefox中会得到**ReferenceError: maybeExists() is not defined**，IE中会得到**TypeError:
    Object expected**'
- en: 'If `maybeExists()` returns `0`, you get **Error: Division by zero!**'
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果`maybeExists()`返回`0`，您将得到**Error: Division by zero!**'
- en: If `maybeExists()` returns `2`, you get an alert that says **25**
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`maybeExists()`返回`2`，您将得到一个显示**25**的警报
- en: In all cases, there will be a second alert that says **Finally!**.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，都会有第二个警报，显示**Finally!**。
- en: 'Instead of throwing a generic error, `thrownewError(''Divisionbyzero!'')`,
    you can be more specific if you choose to, for example, throw `thrownewRangeError(''Divisionbyzero!'')`.
    Alternatively, you don''t need a constructor; you can simply throw a normal object:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 不要抛出通用错误，`thrownewError('Divisionbyzero!')`，如果选择，可以更具体，例如抛出`thrownewRangeError('Divisionbyzero!')`。或者，您不需要构造函数；您可以简单地抛出一个普通对象：
- en: '[PRE246]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: This gives you cross-browser control over the error name.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 这使您可以跨浏览器控制错误名称。
- en: Exercises
  id: totrans-780
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Lets solve the following exercise:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决以下练习：
- en: 'Look at the following code:'
  id: totrans-782
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看以下代码：
- en: '[PRE247]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: Does the value of `this` refer to the global object or the object `o`?
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`的值是指全局对象还是对象`o`？'
- en: What's the result of executing this piece of code?
  id: totrans-785
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此代码片段的结果是什么？
- en: '[PRE248]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: What's the result of executing the following piece of code?
  id: totrans-787
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下代码片段的结果是什么？
- en: '[PRE249]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'Imagine the `String()` constructor didn''t exist. Create a constructor function,
    `MyString()`, that acts like `String()` as closely as possible. You''re not allowed
    to use any built-in string methods or properties, and remember that the `String()`
    doesn''t exist. You can use this code to test your constructor:'
  id: totrans-789
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想象一下`String()`构造函数不存在。创建一个名为`MyString()`的构造函数，尽可能接近`String()`的行为。你不允许使用任何内置的字符串方法或属性，并且记住`String()`不存在。你可以使用这段代码来测试你的构造函数：
- en: '[PRE250]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: Note
  id: totrans-791
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can use a `for` loop to loop through the input string, treating it as an
    array.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`for`循环来遍历输入字符串，将其视为数组。
- en: Update your `MyString()` constructor to include a `reverse()` method.
  id: totrans-793
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新你的`MyString()`构造函数，包括一个`reverse()`方法。
- en: Note
  id: totrans-794
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Try to leverage the fact that arrays have a `reverse()` method.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试利用数组具有`reverse()`方法的事实。
- en: 'Imagine that `Array()`and the array literal notation don''t exist. Create a
    constructor called `MyArray()` that behaves as close to `Array()` as possible.
    Test it with the following code:'
  id: totrans-796
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想象一下`Array()`和数组文字表示法不存在。创建一个名为`MyArray()`的构造函数，其行为尽可能接近`Array()`。使用以下代码进行测试：
- en: '[PRE251]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: If you found this exercise amusing, don't stop with the `join()` method; go
    on with as many methods as possible.
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你觉得这个练习有趣，不要停留在`join()`方法上；尽可能多地使用其他方法。
- en: 'Imagine `Math` didn''t exist. Create a `MyMath` object that also provides the
    following additional methods:'
  id: totrans-799
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想象一下`Math`不存在。创建一个`MyMath`对象，还提供以下额外的方法：
- en: '`MyMath.rand(min, max, inclusive)`: This generates a random number between
    `min` and `max`, inclusive if `inclusive` is `true` (default)'
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyMath.rand(min, max, inclusive)`: 这将在`min`和`max`之间生成一个随机数，如果`inclusive`为`true`（默认）'
- en: '`MyMath.min(array)`: This returns the smallest number in a given array'
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyMath.min(array)`: 这将返回给定数组中的最小数'
- en: '`MyMath.max(array)`: This returns the largest number in a given array'
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyMath.max(array)`: 这将返回给定数组中的最大数'
- en: Summary
  id: totrans-803
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In [Chapter 2](ch02.html "Chapter 2. Primitive Data Types, Arrays, Loops, and
    Conditions"), *Primitive Data Types, Arrays, Loops, and Conditions*, you saw that
    there are five primitive data types (`number`, `string`, `Boolean`, `null`, and
    `undefined`), and we also said that everything that is not a primitive piece of
    data is an object. Now, you also know that:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。原始数据类型、数组、循环和条件")中，*原始数据类型、数组、循环和条件*，你看到有五种原始数据类型（`number`、`string`、`Boolean`、`null`和`undefined`），我们也说过，不是原始数据的一切都是对象。现在，你也知道：
- en: Objects are like arrays, but you specify the keys
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象就像数组，但你要指定键
- en: Objects contain properties
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象包含属性
- en: Properties can be functions (functions are data; remember `var f = function
    () {};`). Properties that are functions are also called methods
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性可以是函数（函数是数据；记住`var f = function () {};`）。函数是属性的也称为方法
- en: Arrays are actually objects with predefined numeric properties and an auto-incrementing
    `length` property
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组实际上是具有预定义数值属性和自动递增`length`属性的对象
- en: Array objects have a number of convenient methods (such as `sort()` or `slice()`)
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组对象有许多方便的方法（如`sort()`或`slice()`）
- en: Functions are also objects, and they have properties (such as `length` and `prototype`)
    and methods (such as `call()` and `apply()`)
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数也是对象，它们有属性（如`length`和`prototype`）和方法（如`call()`和`apply()`）
- en: Regarding the five primitive data types, apart from `undefined` and `null`,
    the other three have the corresponding constructor functions-`Number()`, `String()`,
    and `Boolean()`. Using these, you can create objects, called wrapper objects,
    which contain methods for working with primitive data elements.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 关于五种原始数据类型，除了`undefined`和`null`之外，其他三种都有相应的构造函数-`Number()`、`String()`和`Boolean()`。使用这些，你可以创建包含用于处理原始数据元素的方法的对象，称为包装对象。
- en: '`Number()`, `String()`, and `Boolean()` can be invoked:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number()`、`String()`和`Boolean()`可以被调用：'
- en: With the `new` operator, to create new objects.
  id: totrans-813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`new`运算符，创建新对象。
- en: Without the `new` operator, to convert any value to the corresponding primitive
    data type.
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有`new`运算符，将任何值转换为相应的原始数据类型。
- en: Other built-in constructor functions you're now familiar with include `Object()`,
    `Array()`, `Function()`, `Date()`, `RegExp()`, and `Error()`. You're also familiar
    with `Math`-a global object that is not a constructor.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在熟悉的其他内置构造函数包括`Object()`、`Array()`、`Function()`、`Date()`、`RegExp()`和`Error()`。你也熟悉`Math`-一个不是构造函数的全局对象。
- en: Now, you can see how objects have a central role in JavaScript programming,
    as pretty much everything is an object or can be wrapped by an object.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到对象在JavaScript编程中起着核心作用，因为几乎一切都是对象，或者可以被对象包装。
- en: 'Finally, let''s wrap up the literal notations you''re now familiar with:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们总结一下你现在熟悉的文字表示法：
- en: '| **Name** | **Literal** | **Constructor** | **Example** |'
  id: totrans-818
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **文字** | **构造函数** | **示例** |'
- en: '| Object | `{}` | `new Object()` | `{prop: 1}` |'
  id: totrans-819
  prefs: []
  type: TYPE_TB
  zh: '| 对象 | `{}` | `new Object()` | `{prop: 1}` |'
- en: '| Array | `[]` | `new Array()` | `[1,2,3,''test'']` |'
  id: totrans-820
  prefs: []
  type: TYPE_TB
  zh: '| 数组 | `[]` | `new Array()` | `[1,2,3,''test'']` |'
- en: '| Regular expression | `/pattern/modifiers` | `new RegExp(''pattern'', ''modifiers'')`
    | `/java.*/img` |'
  id: totrans-821
  prefs: []
  type: TYPE_TB
  zh: '| 正则表达式 | `/pattern/modifiers` | `new RegExp(''pattern'', ''modifiers'')` |
    `/java.*/img` |'
