- en: 6\. Introduction to Docker Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. Docker网络简介
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: The goal of this chapter is to provide you with a concise overview of how container
    networking works, how it differs from networking at the level of the Docker host,
    and how containers can leverage Docker networking to provide direct network connectivity
    to other containerized services. By the end of this chapter, you will know how
    to deploy containers using networking configurations such as `bridge`, `overlay`,
    `macvlan`, and `host`. You will learn the benefits of different networking drivers
    and under which circumstances you should choose certain network drivers. Finally,
    we will look at containerized networking between hosts deployed in a Docker swarm
    cluster.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是为您提供容器网络如何工作的简明概述，以及它与Docker主机级别的网络有何不同，以及容器如何利用Docker网络提供对其他容器化服务的直接网络连接。通过本章的学习，您将了解如何使用`bridge`、`overlay`、`macvlan`和`host`等网络配置部署容器。您将了解不同网络驱动程序的优势，并在何种情况下应选择特定的网络驱动程序。最后，我们将研究在Docker
    swarm集群中部署的主机之间的容器化网络。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Throughout this workshop, we have looked at many aspects of containerization
    and microservices architecture in relation to Docker. We have learned about how
    encapsulating applications into microservices that perform discrete functions
    creates an incredibly flexible architecture that enables rapid deployments and
    powerful horizontal scaling. Perhaps one of the more interesting and complex topics
    as it relates to containerization is networking. After all, in order to develop
    a flexible and agile microservices architecture, proper networking considerations
    need to be made to ensure reliable connectivity between container instances.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个研讨会中，我们已经研究了与Docker相关的容器化和微服务架构的许多方面。我们已经了解了如何将应用程序封装为执行离散功能的微服务，从而创建了一种非常灵活的架构，可以实现快速部署和强大的水平扩展。也许与容器化相关的更有趣和复杂的话题之一是网络。毕竟，为了开发灵活和敏捷的微服务架构，需要考虑适当的网络，以确保容器实例之间可靠的连接。
- en: When referring to **container networking**, always try to keep in mind the difference
    between networking on the container host (underlay networking) and networking
    between containers on the same host or within different clusters (`overlay` networking).
    Docker supports many different types of network configurations out of the box
    that can be customized to suit the needs of your infrastructure and deployment
    strategy.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及**容器网络**时，始终要记住容器主机上的网络（底层网络）与同一主机上或不同集群内的容器之间的网络（`覆盖`网络）之间的区别。Docker支持许多不同类型的网络配置，可以根据基础设施和部署策略的需求进行定制。
- en: For example, a container may have an IP address, unique to that container instance,
    that exists on a virtual subnet between the container hosts. This type of networking
    is typical of a Docker swarm clustered configuration in which network traffic
    gets encrypted and passed over the host machine's network interfaces, only to
    be decrypted on a different host and then passed to the receiving microservice.
    This type of network configuration usually involves Docker maintaining a mapping
    of container and service names to container IP addresses. This provides powerful
    service discovery mechanisms that allow container networking even when containers
    terminate and restart on different cluster hosts.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个容器可能具有一个IP地址，该IP地址是该容器实例独有的，在容器主机之间的虚拟子网上存在。这种类型的网络是Docker swarm集群配置的典型特征，其中网络流量被加密并通过主机机器的网络接口传输，然后在不同的主机上解密，然后传递给接收微服务。这种类型的网络配置通常涉及Docker维护容器和服务名称到容器IP地址的映射。这提供了强大的服务发现机制，即使容器在不同的集群主机上终止和重新启动，也可以进行容器网络。
- en: Alternatively, containers may run in a more simplistic host networking mode.
    In this scenario, containers running in a cluster or a standalone host expose
    ports on the host machine's network interfaces to send and receive network traffic.
    The containers themselves may still have their IP addresses, which get mapped
    to physical network interfaces on the hosts by Docker. This type of network configuration
    is useful when your microservices need to communicate primarily with services
    that exist outside your containerized infrastructure.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，容器也可以以更简单的主机网络模式运行。在这种情况下，运行在集群或独立主机中的容器会在主机机器的网络接口上公开端口，以发送和接收网络流量。容器本身仍然可能有它们的IP地址，这些地址通过Docker映射到主机上的物理网络接口。当您的微服务需要主要与容器化基础设施之外存在的服务进行通信时，这种类型的网络配置非常有用。
- en: By default, Docker operates in a **bridge network mode**. A `bridge` network
    creates a single network interface on the host that acts as a bridge to another
    subnet configured on the host. All incoming (ingress) and outgoing (egress) network
    traffic travel between the container subnet and the host using the `bridge` network
    interface.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker以**桥接网络模式**运行。`bridge`网络在主机上创建一个单一网络接口，充当与主机上配置的另一个子网进行桥接的桥接器。所有传入（入口）和传出（出口）的网络流量都通过`bridge`网络接口在容器子网和主机之间传输。
- en: After installing Docker Engine in a Linux environment, if you run the `ifconfig`
    command, Docker will create a new virtual bridged network interface called `docker0`.
    This interface bridges a Docker private subnet that gets created by default (usually
    `172.16.0.0/16`) to the host machine's networking stack. If a container is running
    in the default Docker network with an IP address of `172.17.8.1` and you attempt
    to contact that IP address, the internal route tables will direct that traffic
    through the `docker0` `bridge` interface and pass the traffic to the IP address
    of the container on the private subnet. Unless ports are published through Docker,
    this container's IP address cannot be accessed by the outside world. Throughout
    this chapter, we will dive deep into various network drivers and configuration
    options provided by Docker.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux环境中安装了Docker引擎后，如果运行`ifconfig`命令，Docker将创建一个名为`docker0`的新虚拟桥接网络接口。该接口将默认创建的Docker私有子网（通常为`172.16.0.0/16`）与主机的网络堆栈进行桥接。如果一个容器在默认的Docker网络中以IP地址`172.17.8.1`运行，并且您尝试联系该IP地址，内部路由表将通过`docker0`桥接接口将流量传递到私有子网上容器的IP地址。除非通过Docker发布端口，否则无法从外部访问该容器的IP地址。在本章中，我们将深入探讨Docker提供的各种网络驱动程序和配置选项。
- en: In the next exercise, we will look at creating Docker containers in the default
    Docker `bridge` network and how to expose container ports to the outside world.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将看看如何在默认的Docker `bridge`网络中创建Docker容器，以及如何将容器端口暴露给外部世界。
- en: 'Exercise 6.01: Hands-On with Docker Networking'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.01：Docker网络实践
- en: By default, when you run a container in Docker, the container instance you create
    will exist in a Docker network. Docker networks are collections of subnets, rules,
    and metadata that Docker uses to allocate network resources to containers running
    in the immediate Docker server or across servers in a Docker swarm cluster. The
    network will provide the container with access to other containers in the same
    subnet, and even outbound (egress) access to other external networks, including
    the internet. Each Docker network is associated with a network driver that determines
    how the network will function within the context of the system the containers
    are running on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在Docker中运行容器时，您创建的容器实例将存在于一个Docker网络中。Docker网络是Docker用来为在即时Docker服务器或Docker集群中的服务器上运行的容器分配网络资源的子网集合、规则和元数据。该网络将为容器提供访问同一子网中的其他容器，甚至提供对其他外部网络（包括互联网）的出站（egress）访问。每个Docker网络都与一个网络驱动程序相关联，该驱动程序确定了网络在容器所在系统的上下文中的功能。
- en: 'In this exercise, you will run Docker containers and use basic networking to
    run two simple web servers (Apache2 and NGINX) that will expose ports in a few
    different basic networking scenarios. You will then access the exposed ports of
    the container to learn more about how Docker networking works at the most basic
    level. Launching containers and exposing the service ports to make them available
    is one of the most common networking scenarios when first starting with containerized
    infrastructure:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将运行Docker容器，并使用基本网络来运行两个简单的Web服务器（Apache2和NGINX），它们将在几种不同的基本网络场景中暴露端口。然后，您将访问容器的暴露端口，以更多地了解Docker网络是如何在最基本的级别上工作的。启动容器并暴露服务端口以使它们可用是最常见的网络场景之一，当您首次开始使用容器化基础设施时：
- en: 'List the networks that are currently configured in your Docker environment
    using the `docker network ls` command:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出当前在您的Docker环境中配置的网络，使用`docker network ls`命令：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output displayed will show all the configured Docker networks available
    on your system. It should resemble the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的输出将显示系统中所有配置的Docker网络。它应该类似于以下内容：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When creating a container using Docker without specifying a network or networking
    driver, Docker will create the container using a `bridge` network. This network
    exists behind a `bridge` network interface configured in your host OS. Use `ifconfig`
    in a Linux or macOS Bash shell, or `ipconfig` in Windows PowerShell, to see which
    interface the Docker bridge is configured as. It is generally called `docker0`:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Docker中创建容器时，如果没有指定网络或网络驱动程序，Docker将使用`bridge`网络创建容器。这个网络存在于您的主机操作系统中配置的`bridge`网络接口后面。在Linux或macOS的Bash
    shell中使用`ifconfig`，或在Windows PowerShell中使用`ipconfig`，来查看Docker桥接口配置为哪个接口。通常被称为`docker0`：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of this command will list all the network interfaces available in
    your environment, as shown in the following figure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出将列出环境中所有可用的网络接口，如下图所示：
- en: '![Figure 6.1: Listing the available network interfaces'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1：列出可用的网络接口'
- en: '](image/B15021_06_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_01.jpg)'
- en: 'Figure 6.1: Listing the available network interfaces'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：列出可用的网络接口
- en: It can be observed in the preceding figure that the Docker `bridge` interface
    is called `docker0` and has an IP address of `172.17.0.1`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可以观察到在前面的图中，Docker的`bridge`接口被称为`docker0`，并且具有IP地址`172.17.0.1`。
- en: 'Use the `docker run` command to create a simple NGINX web server container,
    using the `latest` image tag. Set the container to start in the background using
    the `-d` flag and give it a human-readable name of `webserver1` using the `--name`
    flag:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker run`命令创建一个简单的NGINX Web服务器容器，使用`latest`镜像标签。使用`-d`标志将容器设置为在后台启动，并使用`--name`标志为其指定一个可读的名称`webserver1`：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the command is successful, no output will be returned in the terminal session.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令成功，终端会没有返回任何输出。
- en: 'Execute the `docker ps` command to check whether the container is up and running:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行“docker ps”命令来检查容器是否正在运行：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, the `webserver1` container is up and running as expected:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，“webserver1”容器正在如预期地运行：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Execute the `docker inspect` command to check what networking configuration
    this container has by default:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行“docker inspect”命令来检查这个容器默认的网络配置：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Docker will return the verbose details about the running container in JSON
    format. For this exercise, focus on the `NetworkSettings` block. Pay special attention
    to the `Gateway`, `IPAddress`, `Ports`, and `NetworkID` parameters underneath
    the `networks` sub-block:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将以JSON格式返回有关正在运行的容器的详细信息。在这个练习中，重点关注“NetworkSettings”块。特别注意“networks”子块下面的“Gateway”、“IPAddress”、“Ports”和“NetworkID”参数：
- en: '![Figure 6.2: Output of the docker inspect command'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2：docker inspect命令的输出'
- en: '](image/B15021_06_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_02.jpg)'
- en: 'Figure 6.2: Output of the docker inspect command'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：docker inspect命令的输出
- en: From this output, it can be concluded that this container lives in the default
    Docker `bridge` network. Looking at the first 12 characters of `NetworkID`, you
    will observe that it is the same identifier used in the output of the `docker
    network ls` command, which was executed in *step 1*. It should also be noted that
    the `Gateway` this container is configured to use is the IP address of the `docker0`
    `bridge` interface. Docker will use this interface as an egress point to access
    networks in other subnets outside itself, as well as forwarding traffic from our
    environment to the containers in the subnet. It can also be observed that this
    container has a unique IP address within the Docker bridge network, `172.17.0.2`
    in this example. Our local machine has the ability to route to this subnet since
    we have the `docker0` `bridge` interface available to forward traffic. Finally,
    it can be observed that the NGINX container is by default exposing TCP port `80`
    for incoming traffic.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出可以得出结论，这个容器存在于默认的Docker“bridge”网络中。观察“NetworkID”的前12个字符，您会发现它与“docker network
    ls”命令的输出中使用的标识符相同，该命令是在*步骤1*中执行的。还应该注意，这个容器配置使用的“Gateway”是“docker0”“bridge”接口的IP地址。Docker将使用这个接口作为访问自身以外子网中的网络的出口点，同时将来自我们环境的流量转发到子网中的容器。还可以观察到，这个容器在Docker桥接网络中有一个唯一的IP地址，在本例中为“172.17.0.2”。由于我们有“docker0”“bridge”接口可用来转发流量，我们的本地机器可以路由到这个子网。最后，可以观察到，默认情况下，NGINX容器正在暴露TCP端口“80”用于传入流量。
- en: 'In a web browser, access the `webserver1` container by IP address over port
    `80`. Enter the IP address of the `webserver1` container in your favorite web
    browser:![Figure 6.3: Accessing an NGINX web server container by IP address through'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web浏览器中，通过IP地址和端口“80”访问“webserver1”容器。在您喜欢的Web浏览器中输入“webserver1”容器的IP地址：![图6.3：通过IP地址访问NGINX
    Web服务器容器
- en: the default Docker bridge network
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的Docker桥接网络
- en: '](image/B15021_06_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_03.jpg)'
- en: 'Figure 6.3: Accessing an NGINX web server container by IP address through the
    default Docker bridge network'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：通过默认的Docker桥接网络通过IP地址访问NGINX Web服务器容器
- en: 'Alternatively, use the `curl` command to see similar output, albeit in text
    format:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，使用“curl”命令查看类似的输出，尽管是以文本格式：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following HTML response indicates that you have received a response from
    the running NGINX container:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下HTML响应表示您已从正在运行的NGINX容器收到响应：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Accessing the IP address of a container in the local `bridge` subnet works
    well for testing containers locally. To expose your service on the network to
    other users or servers, use the `-p` flag in the `docker run` command. This will
    allow you to map a port on the host to an exposed port on the container. This
    is similar to port forwarding on a router or other network device. To expose a
    container by the port to the outside world, use the `docker run` command followed
    by the `-d` flag to start the container in the background. The `-p` flag will
    enable you to specify a port on the host, separated by a colon and the port on
    the container that you wish to expose. Also, give this container a unique name,
    `webserver2`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问本地`bridge`子网中容器的IP地址对于测试本地容器非常有效。要将您的服务暴露给其他用户或服务器的网络，请在`docker run`命令中使用`-p`标志。这将允许您将主机上的端口映射到容器上的公开端口。这类似于路由器或其他网络设备上的端口转发。要通过端口向外部世界暴露容器，请使用`docker
    run`命令，后跟`-d`标志以在后台启动容器。`-p`标志将使您能够指定主机上的端口，用冒号分隔，并指定要公开的容器上的端口。还要为此容器指定一个唯一的名称，`webserver2`：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Upon successful container startup, your shell will not return anything. However,
    certain versions of Docker may show the full container ID.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 成功启动容器后，您的shell将不会返回任何内容。但是，某些版本的Docker可能会显示完整的容器ID。
- en: 'Run the `docker ps` command to check whether you have two NGINX containers
    up and running:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker ps`命令，检查是否有两个正在运行的NGINX容器：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The two running containers, `webserver1` and `webserver2`, will be displayed:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示两个正在运行的容器，`webserver1`和`webserver2`：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the `PORTS` column, you will see that Docker is now forwarding port `80`
    on the `webserver` container to port `8080` on the host machine. That is deduced
    from the `0.0.0.0:8080->80/tcp` part of the output.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PORTS`列中，您将看到Docker现在正在将`webserver`容器上的端口`80`转发到主机上的端口`8080`。这是从输出的`0.0.0.0:8080->80/tcp`部分推断出来的。
- en: Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to remember that the host machine port is always to the left
    of the colon, while the container port is to the right when specifying ports with
    the `-p` flag.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，使用`-p`标志指定端口时，主机机器端口始终位于冒号的左侧，而容器端口位于右侧。
- en: 'In your web browser, navigate to `http://localhost:8080` to see the running
    container instance you just spawned:![Figure 6.4: NGINX default page indicating
    that you have successfully forwarded'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中，导航至`http://localhost:8080`，以查看您刚刚生成的运行容器实例：![图6.4：NGINX默认页面，指示您已成功转发
- en: a port to your web server container
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将端口映射到您的Web服务器容器
- en: '](image/B15021_06_04.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_04.jpg)'
- en: 'Figure 6.4: NGINX default page indicating that you have successfully forwarded
    a port to your web server container'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：NGINX默认页面，指示您已成功将端口转发到您的Web服务器容器
- en: 'Now, you have two NGINX instances running in the same Docker environment with
    slightly different networking configurations. The `webserver1` instance is running
    solely on the Docker network without any ports exposed. Inspect the configuration
    of the `webserver2` instance using the `docker inspect` command followed by the
    container name or ID:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在相同的Docker环境中运行两个NGINX实例，具有略有不同的网络配置。`webserver1`实例仅在Docker网络上运行，没有任何端口暴露。使用`docker
    inspect`命令检查`webserver2`实例的配置，后跟容器名称或ID：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `NetworkSettings` section at the bottom of the JSON output will resemble
    the following. Pay close attention to the parameters (`Gateway`, `IPAddress`,
    `Ports`, and `NetworkID`) underneath the `networks` sub-block:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: JSON输出底部的`NetworkSettings`部分将类似于以下内容。请特别注意`networks`子块下面的参数（`Gateway`、`IPAddress`、`Ports`和`NetworkID`）：
- en: '![Figure 6.5: Output from the docker inspect command'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5：docker inspect命令的输出'
- en: '](image/B15021_06_05.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_05.jpg)'
- en: 'Figure 6.5: Output from the docker inspect command'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：docker inspect命令的输出
- en: As the `docker inspect` output displays, the `webserver2` container has an IP
    address of `172.17.0.3`, whereas your `webserver1` container has an IP address
    of `172.17.0.1`. The IP addresses in your local environment may be slightly different
    depending on how Docker assigns the IP addresses to the containers. Both the containers
    live on the same Docker network (`bridge`) and have the same default gateway,
    which is the `docker0` `bridge` interface on the host machine.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如`docker inspect`输出显示的那样，`webserver2`容器的IP地址为`172.17.0.3`，而您的`webserver1`容器的IP地址为`172.17.0.1`。根据Docker分配IP地址给容器的方式，您本地环境中的IP地址可能略有不同。这两个容器都位于同一个Docker网络（`bridge`）上，并且具有相同的默认网关，即主机上的`docker0`
    `bridge`接口。
- en: 'Since both of these containers live on the same subnet, you can test communication
    between the containers within the Docker `bridge` network. Run the `docker exec`
    command to gain access to a shell on the `webserver1` container:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这两个容器都位于同一个子网上，您可以在Docker“bridge”网络内测试容器之间的通信。运行`docker exec`命令以访问`webserver1`容器上的shell：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The prompt should noticeably change to a root prompt, indicating you are now
    in a Bash shell on the `webserver1` container:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 提示符应明显更改为根提示符，表示您现在在`webserver1`容器的Bash shell中：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At the root shell prompt, use the `apt` package manager to install the `ping`
    utility in this container:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根shell提示符下，使用`apt`软件包管理器在此容器中安装`ping`实用程序：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The aptitude package manager will then install the `ping` utility in the `webserver1`
    container. Please note that the `apt` package manager will install `ping` as well
    as other dependencies that are required to run the `ping` command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，aptitude软件包管理器将在`webserver1`容器中安装`ping`实用程序。请注意，`apt`软件包管理器将安装`ping`以及运行`ping`命令所需的其他依赖项：
- en: '![Figure 6.6: Installing the ping command inside a Docker container'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.6：在Docker容器内安装ping命令'
- en: '](image/B15021_06_06.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_06.jpg)'
- en: 'Figure 6.6: Installing the ping command inside a Docker container'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：在Docker容器内安装ping命令
- en: 'Once the `ping` utility has successfully installed, use it to ping the IP address
    of the other container:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`ping`实用程序后，使用它来ping另一个容器的IP地址：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output should display ICMP response packets, indicating that the containers
    can successfully ping each other through the Docker `bridge` network:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应显示ICMP响应数据包，表明容器可以通过Docker“bridge”网络成功ping通彼此：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can also access the NGINX default web interface using the `curl` command.
    Install `curl` using the `apt` package manager:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以使用`curl`命令访问NGINX默认的Web界面。使用`apt`软件包管理器安装`curl`：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following output should display, indicating that the `curl` utility and
    all required dependencies are being installed:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的输出应显示，正在安装`curl`实用程序和所有必需的依赖项：
- en: '![Figure 6.7: Installing the curl utility'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.7：安装curl实用程序'
- en: '](image/B15021_06_07.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_07.jpg)'
- en: 'Figure 6.7: Installing the curl utility'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：安装curl实用程序
- en: 'After installing `curl`, use it to curl the IP address of `webserver2`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`curl`后，使用它来curl`webserver2`的IP地址：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should see the `Welcome to nginx!` page displayed in HTML format, indicating
    that you were able to successfully contact the IP address of the `webserver2`
    container through the Docker `bridge` network:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以HTML格式显示的“欢迎使用nginx！”页面，这表明您能够通过Docker“bridge”网络成功联系到“webserver2”容器的IP地址：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since you are using `curl` to navigate to the NGINX welcome page, it will render
    on your terminal display in raw HTML format.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您正在使用`curl`导航到NGINX欢迎页面，它将以原始HTML格式呈现在您的终端显示器上。
- en: In this section, we have successfully spawned two NGINX web server instances
    in the same Docker environment. We configured one instance to not expose any ports
    outside the default Docker network, while we configured the second NGINX instance
    to run on the same network but to expose port `80` to the host system on port
    `8080`. We saw how these containers could be accessed using a standard internet
    web browser as well as by the `curl` utility in Linux.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们已经成功在同一个Docker环境中生成了两个NGINX Web服务器实例。我们配置了一个实例，不在默认Docker网络之外暴露任何端口，而我们配置了第二个NGINX实例在同一网络上运行，但将端口`80`暴露给主机系统的端口`8080`。我们看到这些容器可以使用标准的互联网浏览器以及Linux中的`curl`实用程序进行访问。
- en: During this exercise, we also saw how containers can use Docker networks to
    talk to other containers directly. We used the `webserver1` container to call
    the IP address of the `webserver2` container and display the output of the web
    page the container was hosting.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们还看到了容器如何使用Docker网络直接与其他容器通信。我们使用`webserver1`容器调用`webserver2`容器的IP地址，并显示容器托管的网页的输出。
- en: In this exercise, we were also able to demonstrate network connectivity between
    container instances using the native Docker `bridge` network. However, when we
    deploy containers at scale, there is no easy way to know which IP address in the
    Docker network belongs to which container.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们还能够演示容器实例之间使用本机Docker`bridge`网络进行网络连接。然而，当我们大规模部署容器时，很难知道Docker网络中的哪个IP地址属于哪个容器。
- en: In the next section, we will look at native Docker DNS and learn how to use
    human-readable DNS names to reliably send network traffic to other container instances.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将看看本机Docker DNS，并学习如何使用可靠的人类可读的DNS名称将网络流量可靠地发送到其他容器实例。
- en: Native Docker DNS
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本机Docker DNS
- en: One of the biggest benefits of running a containerized infrastructure is the
    ability to quickly and effortlessly scale your workloads horizontally. Having
    more than one machine in a cluster with a shared `overlay` network between them
    means that you can have many containers running across fleets of servers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 运行容器化基础架构的最大好处之一是能够快速轻松地横向扩展工作负载。在一个具有共享`overlay`网络的集群中有多台机器意味着你可以在多台服务器上运行许多容器。
- en: As we saw in the previous exercise, Docker gives us the power to allow containers
    to directly talk to other containers in a cluster through the various network
    drivers that Docker provides, such as `bridge`, `macvlan`, and `overlay` drivers.
    In the previous example, we leveraged Docker `bridge` networking to allow containers
    to talk to each other by their respective IP addresses. However, when your containers
    are deployed on real servers, you can't normally rely on containers having consistent
    IP addresses that they can use to talk to each other. Every time a new container
    instance terminates or respawns, Docker will give that container a new IP address.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的练习中看到的，Docker赋予我们的权力允许容器通过Docker提供的各种网络驱动程序（如`bridge`、`macvlan`和`overlay`驱动程序）直接与集群中的其他容器通信。在前面的例子中，我们利用Docker`bridge`网络使容器能够通过各自的IP地址相互通信。然而，当您的容器部署在真实服务器上时，通常不能依赖容器具有一致的IP地址来相互通信。每当一个新的容器实例终止或重新生成时，Docker都会给该容器一个新的IP地址。
- en: Similar to a traditional infrastructure scenario, we can leverage DNS within
    container networks to give containers a reliable way to communicate with each
    other. By assigning human-readable names to containers within Docker networks,
    users no longer have to look up the IP address each time they want to initiate
    communication between containers on a Docker network. Docker itself will keep
    track of the IP addresses of the containers as they spawn and respawn.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于传统基础设施场景，我们可以利用容器网络内的DNS来为容器提供可靠的通信方式。通过为Docker网络中的容器分配可读的名称，用户不再需要每次想要在Docker网络上的容器之间发起通信时查找IP地址。Docker本身将跟踪容器的IP地址，因为它们生成和重新生成。
- en: In older legacy versions of Docker, simple DNS resolution was possible by establishing
    links between containers using the `--link` flag in the `docker run` command.
    Using linking, Docker would create an entry in the linked container's `hosts`
    file, which would enable simple name resolution. However, as you will see in the
    upcoming exercise, using links between containers can be slow, not scalable, and
    prone to errors. Recent versions of Docker support a native DNS service between
    containers running on the same Docker network. This allows containers to look
    up the names of other containers running in the same Docker network. The only
    caveat with this approach is that native Docker DNS doesn't work on the default
    Docker `bridge` network; thus, other networks must first be created to build your
    containers in.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧版本的Docker中，可以通过在`docker run`命令中使用`--link`标志在容器之间建立链接来实现简单的DNS解析。使用链接，Docker会在链接的容器的`hosts`文件中创建一个条目，从而实现简单的名称解析。然而，正如你将在即将进行的练习中看到的，使用容器之间的链接可能会很慢，不可扩展，并且容易出错。最近的Docker版本支持在同一Docker网络上运行的容器之间的原生DNS服务。这允许容器查找在同一Docker网络中运行的其他容器的名称。这种方法的唯一注意事项是，原生Docker
    DNS在默认的Docker `bridge`网络上不起作用；因此，必须首先创建其他网络来构建您的容器。
- en: For native Docker DNS to work, we must first create a new network using the
    `docker network create` command. We can then create new containers in that network
    using `docker run` with the `--network-alias` flag. In the following exercise,
    we are going to use these commands to learn how native Docker DNS works to enable
    scalable communication between container instances.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使原生Docker DNS工作，我们必须首先使用`docker network create`命令创建一个新的网络。然后，我们可以使用`docker
    run`命令和`--network-alias`标志在该网络中创建新的容器。在接下来的练习中，我们将使用这些命令来学习原生Docker DNS是如何工作的，以实现容器实例之间的可扩展通信。
- en: 'Exercise 6.02: Working with Docker DNS'
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.02：使用Docker DNS
- en: 'In the following exercise, you will learn about name resolution between Docker
    containers running on the same network. You will first enable simple name resolution
    using the legacy link method. You will contrast this approach by using the newer
    and more reliable native Docker DNS service:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，您将学习在运行在同一网络上的Docker容器之间的名称解析。您将首先使用传统的链接方法启用简单的名称解析。然后，您将通过使用更新的、更可靠的原生Docker
    DNS服务来对比这种方法：
- en: 'First, create two Alpine Linux containers on the default Docker `bridge` network
    that will communicate with each other using the `--link` flag. Alpine is a very
    good base image for this exercise because it contains the `ping` utility by default.
    This will enable you to quickly test the connectivity between containers in the
    various scenarios. To get started, create a container called `containerlink1`
    to indicate that you have created this container using the legacy link method:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在默认的Docker `bridge`网络上创建两个Alpine Linux容器，它们将使用`--link`标志相互通信。Alpine是这个练习的一个很好的基础镜像，因为它默认包含`ping`实用程序。这将使您能够快速测试各种情况下容器之间的连接。要开始，请创建一个名为`containerlink1`的容器，以指示您是使用传统的链接方法创建了这个容器。
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will start a container in the default Docker network called `containerlink1`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在名为`containerlink1`的默认Docker网络中启动一个容器。
- en: 'Start another container in the default Docker bridge network, called `containerlink2`,
    which will create a link to `containerlink1` to enable rudimentary DNS:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在默认的Docker桥接网络中启动另一个名为`containerlink2`的容器，它将创建一个到`containerlink1`的链接以启用基本的DNS：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will start a container in the default Docker network called `containerlink2`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在名为`containerlink2`的默认Docker网络中启动一个容器。
- en: 'Run the `docker exec` command to access a shell inside the `containerlink2`
    container. This will allow you to investigate how the link functionality is working.
    Since this container is running Alpine Linux, you do not have access to the Bash
    shell by default. Instead, access it using an `sh` shell:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker exec`命令以访问`containerlink2`容器内部的shell。这将允许您调查链接功能的工作方式。由于此容器正在运行Alpine
    Linux，默认情况下您无法访问Bash shell。而是使用`sh` shell进行访问：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This should drop you into a root `sh` shell in the `containerlink2` container.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该将您放入`containerlink2`容器中的root `sh` shell中。
- en: 'From the shell of the `containerlink2` container, ping `containerlink1`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`containerlink2`容器的shell中，ping `containerlink1`：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You will get a reply to the `ping` request:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您将收到`ping`请求的回复：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use the `cat` utility to have a look at the `/etc/hosts` file of the `containerlink2`
    container. The `hosts` file is a list of routable names to IP addresses that Docker
    can maintain and override:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cat`实用程序查看`containerlink2`容器的`/etc/hosts`文件。`hosts`文件是Docker可以维护和覆盖的可路由名称到IP地址的列表：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output of the `hosts` file should display and resemble the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`hosts`文件的输出应该显示并类似于以下内容：'
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: From the output of the `hosts` file of the `containerlink2` container, observe
    that Docker is adding an entry for the `containerlink1` container name as well
    as its container ID. This enables the `containerlink2` container to know the name,
    and the container ID is mapped to the IP address `172.17.0.2`. Typing the `exit`
    command will terminate the `sh` shell session and bring you back to your environment's
    main terminal.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从`containerlink2`容器的`hosts`文件输出中，观察到Docker正在为`containerlink1`容器名称以及其容器ID添加条目。这使得`containerlink2`容器可以知道名称，并且容器ID映射到IP地址`172.17.0.2`。输入`exit`命令将终止`sh`
    shell会话，并将您带回到您环境的主终端。
- en: 'Run `docker exec` to access an `sh` shell inside the `containerlink1` container:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker exec`命令以访问`containerlink1`容器内部的`sh` shell：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This should drop you into the shell of the `containerlink1` container.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该将您放入`containerlink1`容器的shell中。
- en: 'Ping the `containerlink2` container using the `ping` utility:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ping`实用程序对`containerlink2`容器进行ping测试：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should see the following output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It is not possible to ping the `containerlink2` container since linking containers
    only works unidirectionally. The `containerlink1` container has no idea that the
    `containerlink2` container exists since no `hosts` file entry has been created
    in the `containerlink1` container instance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器之间的链接只能单向工作，所以无法对`containerlink2`容器进行ping测试。`containerlink1`容器不知道`containerlink2`容器的存在，因为在`containerlink1`容器实例中没有创建`hosts`文件条目。
- en: Note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can only link to running containers using the legacy link method between
    containers. This means that the first container cannot link to containers that
    get started later. This is one of the many reasons why using links between containers
    is no longer a recommended approach. We are covering the concept in this chapter
    to show you how the functionality works.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您只能使用容器之间的传统链接方法链接到运行中的容器。这意味着第一个容器不能链接到稍后启动的容器。这是使用容器之间的链接不再是推荐方法的许多原因之一。我们在本章中介绍这个概念，以向您展示功能是如何工作的。
- en: 'Due to the limitations using the legacy link method, Docker also supports native
    DNS using user-created Docker networks. To leverage this functionality, create
    a Docker network called `dnsnet` and deploy two Alpine containers within that
    network. First, use the `docker network create` command to create a new Docker
    network using a `192.168.56.0/24` subnet and using the IP address `192.168.54.1`
    as the default gateway:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于使用传统链接方法存在限制，Docker还支持使用用户创建的Docker网络来支持本机DNS。为了利用这个功能，创建一个名为`dnsnet`的Docker网络，并在该网络中部署两个Alpine容器。首先，使用`docker
    network create`命令创建一个新的Docker网络，使用`192.168.56.0/24`子网和IP地址`192.168.54.1`作为默认网关：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Depending on the version of Docker you are using, the successful execution of
    this command may return the ID of the network you have created.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您使用的Docker版本，成功执行此命令可能会返回您创建的网络的ID。
- en: Note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Simply using the `docker network create dnsnet` command will create a network
    with a Docker-allocated subnet and gateway. This exercise demonstrates how to
    specify the subnet and gateway for your Docker network. It should also be noted
    that if your computer is attached to a subnet in the `192.168.54.0/24` subnet
    or a subnet that overlaps that space, it may cause network connectivity issues.
    Please use a different subnet for this exercise.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用`docker network create dnsnet`命令将创建一个具有Docker分配的子网和网关的网络。此练习演示了如何为Docker网络指定子网和网关。还应注意，如果您的计算机连接到`192.168.54.0/24`子网或与该空间重叠的子网，可能会导致网络连接问题。请为此练习使用不同的子网。
- en: 'Use the `docker network ls` command to list the Docker networks available in
    this environment:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker network ls`命令列出此环境中可用的Docker网络：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The list of Docker networks should be returned, including the `dnsnet` network
    you just created:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 应返回Docker网络列表，包括您刚刚创建的`dnsnet`网络：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the `docker network inspect` command to view the configuration for this
    network:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker network inspect`命令查看此网络的配置：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The details of the `dnsnet` network should be displayed. Pay close attention
    to the `Subnet` and `Gateway` parameters. These are the same parameters that you
    used to create a Docker network in *Step 8*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 应显示`dnsnet`网络的详细信息。特别注意`子网`和`网关`参数。这些是您在*步骤8*中用来创建Docker网络的相同参数：
- en: '![Figure 6.8: Output from the docker network inspect command'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8：来自docker network inspect命令的输出'
- en: '](image/B15021_06_08.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_08.jpg)'
- en: 'Figure 6.8: Output from the docker network inspect command'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：来自docker network inspect命令的输出
- en: 'Since this is a Docker `bridge` network, Docker will also create a corresponding
    bridge network interface for this network. The IP address of the `bridge` network
    interface will be the same IP address as the default gateway address you specified
    when creating this network. Use the `ifconfig` command to view the configured
    network interfaces on Linux or macOS. If you are using Windows, use the `ipconfig`
    command:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个Docker“桥接”网络，Docker还将为此网络创建一个相应的桥接网络接口。桥接网络接口的IP地址将与您在创建此网络时指定的默认网关地址相同。使用`ifconfig`命令在Linux或macOS上查看配置的网络接口。如果您使用Windows，请使用`ipconfig`命令：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This should display the output of all available network interfaces, including
    the newly created `bridge` interface:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该显示所有可用网络接口的输出，包括新创建的`bridge`接口：
- en: '![Figure 6.9: Analyzing the bridge network interface for the newly created
    Docker network'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9：分析新创建的Docker网络的桥接网络接口'
- en: '](image/B15021_06_09.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_09.jpg)'
- en: 'Figure 6.9: Analyzing the bridge network interface for the newly created Docker
    network'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：分析新创建的Docker网络的桥接网络接口
- en: 'Now that a new Docker network has been created, use the `docker run` command
    to start a new container (`alpinedns1`) within this network. Use the `docker run`
    command with the `--network` flag to specify the `dnsnet` network that was just
    created, and the `--network-alias` flag to give your container a custom DNS name:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在已经创建了一个新的Docker网络，使用`docker run`命令在此网络中启动一个新的容器（`alpinedns1`）。使用`docker run`命令，使用`--network`标志指定刚刚创建的`dnsnet`网络，并使用`--network-alias`标志为容器指定自定义DNS名称：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Upon successful execution of the command, the full container ID should be displayed
    before returning to a normal terminal prompt.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 成功执行命令后，应显示完整的容器ID，然后返回到正常的终端提示符。
- en: 'Start a second container (`alpinedns2`) using the same `--network` and `--network-alias`
    settings:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的`--network`和`--network-alias`设置启动第二个容器（`alpinedns2`）：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to understand the difference between the `–network-alias` flag
    and the `--name` flag. The `--name` flag is used to give the container a human-readable
    name within the Docker API. This makes it easy to start, stop, restart, and manage
    containers by name. The `--network-alias` flag, however, is used to create a custom
    DNS entry for the container.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解`--network-alias`标志和`--name`标志之间的区别。`--name`标志用于在Docker API中为容器指定一个易于阅读的名称。这使得通过名称轻松启动、停止、重新启动和管理容器。然而，`--network-alias`标志用于为容器创建自定义DNS条目。
- en: 'Use the `docker ps` command to verify that the containers are running as expected:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker ps`命令验证容器是否按预期运行：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output will display the running container instances:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示正在运行的容器实例：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use the `docker inspect` command to verify that the IP addresses of the container
    instances are from within the subnet (`192.168.54.0/24`) that was specified:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker inspect`命令验证容器实例的IP地址是否来自指定的子网（`192.168.54.0/24`）：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following output is truncated to show the relevant details:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出被截断以显示相关细节：
- en: '![Figure: 6.10: Output from the Networks section of the alpinedns1 container
    instance'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图：6.10：alpinedns1容器实例的网络部分输出'
- en: '](image/B15021_06_10.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_10.jpg)'
- en: 'Figure: 6.10: Output from the Networks section of the alpinedns1 container
    instance'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图：6.10：alpinedns1容器实例的网络部分输出
- en: It can be observed from the output that the `alpinedns1` container was deployed
    with an IP address of `192.168.54.2`, which is a part of the subnet that was defined
    during the creation of the Docker network.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从输出中观察到，`alpinedns1`容器部署时具有IP地址`192.168.54.2`，这是在创建Docker网络时定义的子网的一部分。
- en: 'Execute the `docker network inspect` command in a similar fashion for the `alpinedns2`
    container:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以类似的方式执行`docker network inspect`命令，针对`alpinedns2`容器：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output is again truncated to display the relevant networking details:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 输出再次被截断以显示相关的网络细节：
- en: '![Figure 6.11: Output of the Networks section of the alpinedns2 container instance'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.11：alpinedns2容器实例的网络部分输出'
- en: '](image/B15021_06_11.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_11.jpg)'
- en: 'Figure 6.11: Output of the Networks section of the alpinedns2 container instance'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：alpinedns2容器实例的网络部分输出
- en: It can be observed in the preceding output that the `alpinedns2` container has
    an IP address of `192.168.54.3`, which is a different IP address within the `dnsnet`
    subnet.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 可以观察到在前面的输出中，`alpinedns2`容器具有IP地址`192.168.54.3`，这是`dnsnet`子网内的不同IP地址。
- en: 'Run the `docker exec` command to access a shell in the `alpinedns1` container:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker exec`命令以访问`alpinedns1`容器中的shell：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This should drop you into a root shell inside of the containers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该将您放入容器内的root shell中。
- en: 'Once inside the `alpinedns1` container, use the `ping` utility to ping the
    `alpinedns2` container:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`alpinedns1`容器后，使用`ping`实用程序对`alpinedns2`容器进行ping测试：
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `ping` output should display successful network connectivity to the `alpinedns2`
    container instance:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`ping`输出应显示与`alpinedns2`容器实例的成功网络连接：'
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Use the `exit` command to return to your primary terminal. Use the `docker
    exec` command to gain access to a shell inside the `alpinedns2` container:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`exit`命令返回到主要终端。使用`docker exec`命令访问`alpinedns2`容器内的shell：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This should drop you to a shell within the `alpinedns2` container.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使您进入`alpinedns2`容器内的shell。
- en: 'Use the `ping` utility to ping the `alpinedns1` container by name:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ping`实用程序通过名称ping`alpinedns1`容器：
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output should display successful responses from the `alpinedns1` container:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应显示来自`alpinedns1`容器的成功响应：
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Docker DNS, as opposed to the legacy link method, allows bidirectional communication
    between containers in the same Docker network.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统链接方法相比，Docker DNS允许在同一Docker网络中的容器之间进行双向通信。
- en: 'Use the `cat` utility inside any of the `alpinedns` containers to reveal that
    Docker is using true DNS as opposed to `/etc/hosts` file entries inside the container:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何`alpinedns`容器内使用`cat`实用程序来揭示Docker正在使用真正的DNS，而不是容器内的`/etc/hosts`文件条目：
- en: '[PRE48]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This will reveal the contents of the `/etc/hosts` file inside the respective
    container:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示各自容器内`/etc/hosts`文件的内容：
- en: '[PRE49]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Use the `exit` command to terminate the shell session inside of the `alpinedns2`
    container.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`exit`命令终止`alpinedns2`容器内的shell会话。
- en: 'Clean up your environment by stopping all running containers using the `docker
    stop` command:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker stop`命令停止所有正在运行的容器来清理您的环境：
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Use the `docker system prune -fa` command to clean the remaining stopped containers
    and networks:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker system prune -fa`命令清理剩余的已停止容器和网络：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Successfully executing this command should clean up the `dnsnet` network as
    well as the container instances and images:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 成功执行此命令应清理`dnsnet`网络以及容器实例和镜像：
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Each section of the system prune output will identify and remove Docker resources
    that are no longer in use. In this case, it will remove the `dnsnet` network since
    no container instances are currently deployed in this network.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 系统清理输出的每个部分都将识别并删除不再使用的Docker资源。在这种情况下，它将删除`dnsnet`网络，因为当前在该网络中没有部署容器实例。
- en: In this exercise, you looked at the benefits of using name resolution to enable
    communication between the containers over Docker networks. Using name resolution
    is efficient since applications don't have to worry about the IP addresses of
    the other running containers. Instead, communication can be initiated by simply
    calling the other containers by name.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您看到了使用名称解析在Docker网络上启用容器之间通信的好处。使用名称解析是高效的，因为应用程序不必担心其他正在运行的容器的IP地址。相反，通信可以通过简单地按名称调用其他容器来启动。
- en: We first explored the legacy link method of name resolution, by which running
    containers can establish a relationship, leveraging a unidirectional relationship
    using entries in the container's `hosts` file. The second and more modern way
    to use DNS between containers is by creating user-defined Docker networks that
    allow DNS resolution bidirectionally. This will enable all containers on the network
    to resolve all other containers by name or container ID without any additional
    configuration.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先探讨了名称解析的传统链接方法，通过该方法，运行的容器可以建立关系，利用容器的`hosts`文件中的条目进行单向关系。使用DNS在容器之间进行通信的第二种更现代的方法是创建用户定义的Docker网络，允许双向DNS解析。这将使网络上的所有容器都能够通过名称或容器ID解析所有其他容器，而无需任何额外的配置。
- en: As we have seen in this section, Docker provides many unique ways to provide
    reliable networking resources to container instances, such as enabling routing
    between containers on the same Docker network and native DNS services between
    containers. This is only scratching the surface of the network options that are
    provided by Docker.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节中所见，Docker提供了许多独特的方法来为容器实例提供可靠的网络资源，例如在相同的Docker网络上启用容器之间的路由和容器之间的本机DNS服务。这只是Docker提供的网络选项的冰山一角。
- en: In the next section, we will learn about deploying containers using other types
    of networking drivers to truly provide maximum flexibility when deploying containerized
    infrastructure.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用其他类型的网络驱动程序部署容器，以便在部署容器化基础架构时提供最大的灵活性。
- en: Native Docker Network Drivers
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本机Docker网络驱动程序
- en: Since Docker is one of the most broadly supported container platforms in recent
    times, the Docker platform has been vetted across numerous production-level networking
    scenarios. To support various types of applications, Docker provides various network
    drivers that enable flexibility in how containers are created and deployed. These
    network drivers allow containerized applications to run in almost any networking
    configuration that is supported directly on bare metal or virtualized servers.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker是近年来最广泛支持的容器平台之一，Docker平台已在许多生产级网络场景中得到验证。为了支持各种类型的应用程序，Docker提供了各种网络驱动程序，可以灵活地创建和部署容器。这些网络驱动程序允许容器化应用程序在几乎任何直接在裸机或虚拟化服务器上支持的网络配置中运行。
- en: 'For example, containers can be deployed that share the host server''s networking
    stack, or in a configuration that allows them to be assigned unique IP addresses
    from the underlay network infrastructure. In this section, we are going to learn
    about the basic Docker network drivers and how to leverage them to provide the
    maximum compatibility for various types of network infrastructures:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以部署共享主机服务器网络堆栈的容器，或者以允许它们从底层网络基础设施分配唯一IP地址的配置。在本节中，我们将学习基本的Docker网络驱动程序以及如何利用它们为各种类型的网络基础设施提供最大的兼容性：
- en: '`bridge`: A `bridge` is the default network that Docker will run containers
    in. If nothing is defined when launching a container instance, Docker will use
    the subnet behind the `docker0` interface, in which containers will be assigned
    an IP address in the `172.17.0.0/16` subnet. In a `bridge` network, containers
    have network connectivity to other containers in the `bridge` subnet as well as
    outbound connectivity to the internet. So far, all containers we have created
    in this chapter have been in `bridge` networks. Docker `bridge` networks are generally
    used for simple TCP services that only expose simple ports or require communication
    with other containers that exist on the same host.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bridge`：`bridge`是Docker将容器运行在其中的默认网络。如果在启动容器实例时没有定义任何内容，Docker将使用`docker0`接口后面的子网，其中容器将被分配在`172.17.0.0/16`子网中的IP地址。在`bridge`网络中，容器可以与`bridge`子网中的其他容器进行网络连接，也可以与互联网进行出站连接。到目前为止，在本章中创建的所有容器都在`bridge`网络中。Docker的`bridge`网络通常用于仅公开简单端口或需要与同一主机上存在的其他容器进行通信的简单TCP服务。'
- en: '`host`: Containers running in the `host` networking mode have direct access
    to the host machine''s network stack. This means that any ports that are exposed
    to the container are also exposed to the same ports on the host machine running
    the containers. The container also has visibility of all physical and virtual
    network interfaces running on the host. `host` networking is generally preferred
    when running container instances that consume lots of bandwidth or leverage multiple
    protocols.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host`：以`host`网络模式运行的容器直接访问主机机器的网络堆栈。这意味着容器暴露的任何端口也会暴露给运行容器的主机机器上的相同端口。容器还可以看到主机上运行的所有物理和虚拟网络接口。通常在运行消耗大量带宽或利用多个协议的容器实例时，会首选`host`网络。'
- en: '`none`: The `none` network provides no network connectivity to containers deployed
    in this network. Container instances that are deployed in the `none` network only
    have a loopback interface and no access to other network resources at all. No
    driver operates this network. Containers deployed using the `none` networking
    mode are usually applications that operate on storage or disk workloads and don''t
    require network connectivity. Containers that are segregated from network connectivity
    for security purposes may also be deployed using this network driver.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none`：`none`网络不提供网络连接给部署在该网络中的容器。在`none`网络中部署的容器实例只有一个环回接口，根本无法访问其他网络资源。没有驱动程序操作这个网络。使用`none`网络模式部署的容器通常是在存储或磁盘工作负载上运行的应用程序，不需要网络连接。出于安全目的而被隔离在网络连接之外的容器也可以使用这个网络驱动程序进行部署。'
- en: '`macvlan`: `macvlan` networks created in Docker are used in scenarios in which
    your containerized application requires a MAC address and direct network connectivity
    to the underlay network. Using a `macvlan` network, Docker will allocate a MAC
    address to your container instance via a physical interface on the host machine.
    This makes your container appear as a physical host on the deployed network segment.
    It should be noted that many cloud environments, such as AWS, Azure, and many
    virtualization hypervisors, do not allow `macvlan` networking to be configured
    on container instances. `macvlan` networks allow Docker to assign containers IP
    addresses and MAC addresses from the underlay networks based on a physical network
    interface attached to the host machine. Using `macvlan` networking can easily
    lead to IP address exhaustion or IP address conflicts if not configured correctly.
    `macvlan` container networks are generally used in very specific network use cases,
    such as applications that monitor network traffic modes or other network-intensive
    workloads.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`macvlan`：在Docker中创建的`macvlan`网络用于容器化应用程序需要MAC地址和直接网络连接到底层网络的情况。使用`macvlan`网络，Docker将通过主机机器上的物理接口为容器实例分配一个MAC地址。这使得您的容器在部署的网络段上看起来像是一个物理主机。需要注意的是，许多云环境，如AWS、Azure和许多虚拟化hypervisor，不允许在容器实例上配置`macvlan`网络。`macvlan`网络允许Docker根据连接到主机机器的物理网络接口，为容器分配IP地址和MAC地址。如果未正确配置，使用`macvlan`网络可能会很容易导致IP地址耗尽或IP地址冲突。`macvlan`容器网络通常用于非常特定的网络用例，例如监视网络流量模式或其他网络密集型工作负载的应用程序。'
- en: No conversation on Docker networking would be complete without a brief overview
    of **Docker overlay networking**. `Overlay` networking is how Docker handles networking
    with a swarm cluster. When a Docker cluster is defined between nodes, Docker will
    use the physical network linking the nodes together to define a logical network
    between containers running on the nodes. This allows containers to talk directly
    to each other between cluster nodes. In *Exercise 6.03, Exploring Docker Networks*,
    we will look at the various types of Docker network drivers that are supported
    in Docker by default, such as `host`, `none`, and `macvlan`. In *Exercise 6.04*,
    *Defining Overlay Networks*, we will then define a simple Docker swarm cluster
    to discover how `overlay` networking works between Docker hosts configured in
    a cluster mode.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Docker网络的讨论如果没有对**Docker叠加网络**进行简要概述，就不完整。`叠加`网络是Docker处理与集群的网络的方式。当在节点之间定义Docker集群时，Docker将使用将节点连接在一起的物理网络来定义在节点上运行的容器之间的逻辑网络。这允许容器在集群节点之间直接通信。在*练习6.03，探索Docker网络*中，我们将看看Docker默认支持的各种类型的Docker网络驱动程序，如`host`、`none`和`macvlan`。在*练习6.04*中，*定义叠加网络*，我们将定义一个简单的Docker集群，以发现在集群模式下配置的Docker主机之间的`叠加`网络是如何工作的。
- en: 'Exercise 6.03: Exploring Docker Networks'
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.03：探索Docker网络
- en: 'In this exercise, we will look into the various types of Docker network drivers
    that are supported in Docker by default, such as `host`, `none`, and `macvlan`.
    We will start with the `bridge` network and then look into the `none`, `host`,
    and `macvlan` networks:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将研究Docker默认支持的各种类型的网络驱动程序，如“host”、“none”和“macvlan”。我们将从“bridge”网络开始，然后再看看“none”、“host”和“macvlan”网络：
- en: 'First, you need to get an idea of how networking is set up in your Docker environment.
    From a Bash or PowerShell terminal, use the `ifconfig` or `ipconfig` command on
    Windows. This will display all the network interfaces in your Docker environment:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要了解在您的Docker环境中如何设置网络。从Bash或PowerShell终端，在Windows上使用`ifconfig`或`ipconfig`命令。这将显示您的Docker环境中的所有网络接口：
- en: '[PRE53]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This will display all the network interfaces you have available. You should
    see a `bridge` interface called `docker0`. This is the Docker `bridge` interface
    that serves as the entrance (or ingress point) into the default Docker network:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示您可用的所有网络接口。您应该看到一个名为`docker0`的`bridge`接口。这是Docker的`bridge`接口，用作默认Docker网络的入口（或入口点）：
- en: '![Figure 6.12: Example ifconfig output from your Docker development environment'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.12：来自您的Docker开发环境的示例ifconfig输出'
- en: '](image/B15021_06_12.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_12.jpg)'
- en: 'Figure 6.12: Example ifconfig output from your Docker development environment'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：来自您的Docker开发环境的示例ifconfig输出
- en: 'Use the `docker network ls` command to view the networks available in your
    Docker environment:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker network ls`命令查看您的Docker环境中可用的网络：
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This should list the three basic network types defined previously, displaying
    the network ID, the name of the Docker network, and the driver associated with
    the network type:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该列出之前定义的三种基本网络类型，显示网络ID、Docker网络的名称和与网络类型相关联的驱动程序：
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'View the verbose details of these networks using the `docker network inspect`
    command, followed by the ID or the name of the network you want to inspect. In
    this step, you will view the verbose details of the `bridge` network:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker network inspect`命令查看这些网络的详细信息，然后跟上要检查的网络的ID或名称。在这一步中，您将查看“bridge”网络的详细信息：
- en: '[PRE56]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Docker will display the verbose output of the `bridge` network in JSON format:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将以JSON格式显示“bridge”网络的详细输出：
- en: '![Figure 6.13: Inspecting the default bridge network'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.13：检查默认的桥接网络'
- en: '](image/B15021_06_13.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_13.jpg)'
- en: 'Figure 6.13: Inspecting the default bridge network'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13：检查默认的桥接网络
- en: 'Some key parameters to note in this output are the `Scope`, `Subnet`, and `Gateway`
    keywords. Based on this output, it can be observed that the scope of this network
    is only the local host machine (`Scope: Local`). This indicates the network is
    not shared between hosts in a Docker swarm cluster. The `Subnet` value of this
    network under the `Config` section is `172.17.0.0/16`, and the `Gateway` address
    for the subnet is an IP address within the defined subnet (`172.17.0.1`). It is
    critical that the `Gateway` value of a subnet is an IP address within that subnet
    to enable containers deployed in that subnet to access other networks outside
    the scope of that network. Finally, this network is tied to the host interface,
    `docker0`, which will serve as the `bridge` interface for the network. The output
    of the `docker network inspect` command can be very helpful in getting a full
    understanding of how containers deployed in that network are expected to behave.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个输出中需要注意的一些关键参数是`Scope`、`Subnet`和`Gateway`关键字。根据这个输出，可以观察到这个网络的范围只是本地主机（`Scope:
    Local`）。这表明该网络不在Docker集群中的主机之间共享。在`Config`部分下，这个网络的`Subnet`值是`172.17.0.0/16`，子网的`Gateway`地址是定义的子网内的IP地址（`172.17.0.1`）。子网的`Gateway`值是子网内的IP地址，以便在该子网中部署的容器可以访问该网络范围之外的其他网络。最后，这个网络与主机接口`docker0`绑定，它将作为网络的`bridge`接口。`docker
    network inspect`命令的输出对于全面了解在该网络中部署的容器预期行为非常有帮助。'
- en: 'View the verbose details of the `host` network using the `docker network inspect`
    command:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker network inspect`命令查看`host`网络的详细信息：
- en: '[PRE57]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This will display the details of the `host` network in JSON format:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以JSON格式显示`host`网络的详细信息：
- en: '![Figure 6.14: docker network inspect output for the host network'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.14：主机网络的docker网络检查输出'
- en: '](image/B15021_06_14.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_14.jpg)'
- en: 'Figure 6.14: docker network inspect output for the host network'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14：主机网络的docker网络检查输出
- en: As you can see, there is not very much configuration present in the `host` network.
    Since it uses the `host` networking driver, all the container's networking will
    be shared with the host. Hence, this network configuration does not need to define
    specific subnets, interfaces, or other metadata, as we have seen in the default
    `bridge` network from before.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`host`网络中没有太多的配置。由于它使用`host`网络驱动程序，所有容器的网络将与主机共享。因此，这个网络配置不需要定义特定的子网、接口或其他元数据，就像我们之前在默认的`bridge`网络中看到的那样。
- en: 'Investigate the `none` network next. Use the `docker network inspect` command
    to view the details of the `none` network:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来调查`none`网络。使用`docker network inspect`命令查看`none`网络的详细信息：
- en: '[PRE58]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The details will be displayed in JSON format:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 详细信息将以JSON格式显示：
- en: '![Figure 6.15: docker network inspect output for the none network'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.15：none网络的docker网络检查输出'
- en: '](image/B15021_06_15.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_15.jpg)'
- en: 'Figure 6.15: docker network inspect output for the none network'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15：none网络的docker网络检查输出
- en: Similar to the `host` network, the `none` network is mostly empty. Since containers
    deployed in this network will have no network connectivity by leveraging the `null`
    driver, there isn't much need for configuration.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 与`host`网络类似，`none`网络大部分是空的。由于在这个网络中部署的容器将通过`null`驱动程序没有网络连接，因此不需要太多的配置。
- en: Note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Be aware that the difference between the `none` and `host` networks lies in
    the driver they use, despite the fact that the configurations are almost identical.
    Containers launched in the `none` network have no network connectivity at all,
    and no network interfaces are assigned to the container instance. However, containers
    launched in the `host` network will share the networking stack with the host system.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`none` 和 `host` 网络之间的区别在于它们使用的驱动程序，尽管配置几乎相同。在 `none` 网络中启动的容器根本没有网络连接，并且没有网络接口分配给容器实例。然而，在
    `host` 网络中启动的容器将与主机系统共享网络堆栈。
- en: 'Now create a container in the `none` network to observe its operation. In your
    terminal or PowerShell session, use the `docker run` command to start an Alpine
    Linux container in the `none` network using the `--network` flag. Name this container
    `nonenet` so we know that it is deployed in the `none` network:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在 `none` 网络中创建一个容器以观察其操作。在您的终端或 PowerShell 会话中，使用 `docker run` 命令使用 `--network`
    标志在 `none` 网络中启动一个 Alpine Linux 容器。将此容器命名为 `nonenet`，以便我们知道它部署在 `none` 网络中：
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This will pull and start an Alpine Linux Docker container in the `none` network.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 `none` 网络中拉取并启动一个 Alpine Linux Docker 容器。
- en: 'Use the `docker ps` command to verify whether the container is up and running
    as expected:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `docker ps` 命令验证容器是否按预期运行：
- en: '[PRE60]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output should display the `nonenet` container as up and running:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应显示 `nonenet` 容器已启动并运行：
- en: '[PRE61]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Execute the `docker inspect` command, along with the container name, `nonenet`,
    to get a deeper understanding of how this container is configured:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `docker inspect` 命令，以及容器名称 `nonenet`，以更深入地了解此容器的配置：
- en: '[PRE62]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output of `docker inspect` will display the full container configuration
    in JSON format. A truncated version highlighting the `NetworkSettings` section
    is provided here. Pay close attention to the `IPAddress` and `Gateway` settings:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker inspect` 的输出将以 JSON 格式显示完整的容器配置。这里提供了一个突出显示 `NetworkSettings` 部分的缩略版本。请特别注意
    `IPAddress` 和 `Gateway` 设置：'
- en: '![Figure 6.16: docker inspect output for the nonenet container'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.16：nonenet 容器的 docker inspect 输出'
- en: '](image/B15021_06_16.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_16.jpg)'
- en: 'Figure 6.16: docker inspect output for the nonenet container'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16：nonenet 容器的 docker inspect 输出
- en: The `docker inspect` output will reveal that this container does not have an
    IP address, nor does it have a gateway or any other networking settings.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker inspect` 输出将显示该容器没有 IP 地址，也没有网关或任何其他网络设置。'
- en: 'Use the `docker exec` command to access an `sh` shell inside this container:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `docker exec` 命令访问此容器内部的 `sh` shell：
- en: '[PRE63]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Upon successful execution of this command, you will be dropped into a root
    shell in the container instance:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 成功执行此命令后，您将进入容器实例中的 root shell：
- en: '[PRE64]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Execute the `ip a` command to view the network interfaces available in the
    container:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `ip a` 命令查看容器中可用的网络接口：
- en: '[PRE65]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This will display all network interfaces configured in this container:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示在此容器中配置的所有网络接口：
- en: '[PRE66]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The only network interface available to this container is its `LOOPBACK` interface.
    As this container is not configured with an IP address or default gateway, common
    networking commands will not work.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此容器可用的唯一网络接口是其 `LOOPBACK` 接口。由于此容器未配置 IP 地址或默认网关，常见的网络命令将无法使用。
- en: 'Test the lack of network connectivity using the `ping` utility provided by
    default in the Alpine Linux Docker image. Try to ping the Google DNS servers located
    at IP address `8.8.8.8`:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Alpine Linux Docker 镜像中默认提供的 `ping` 实用程序测试网络连接的缺失。尝试 ping IP 地址为 `8.8.8.8`
    的谷歌 DNS 服务器：
- en: '[PRE67]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The output of the `ping` command should reveal that it has no network connectivity:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`ping` 命令的输出应显示它没有网络连接：'
- en: '[PRE68]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Use the `exit` command to return to your main terminal session.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`exit`命令返回到主终端会话。
- en: Now that you have taken a closer look at the `none` network, consider the `host`
    networking driver. The `host` networking driver in Docker is unique since it doesn't
    have any intermediate interfaces or create any extra subnets. Instead, the `host`
    networking driver shares the networking stack with the host operating system such
    that any network interfaces that are available to the host are also available
    to containers running in `host` mode.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经仔细查看了`none`网络，请考虑`host`网络驱动程序。Docker中的`host`网络驱动程序是独特的，因为它没有任何中间接口或创建任何额外的子网。相反，`host`网络驱动程序与主机操作系统共享网络堆栈，因此主机可用的任何网络接口也适用于以`host`模式运行的容器。
- en: 'To get started with running a container in `host` mode, execute `ifconfig`
    if you are running macOS or Linux, or use `ipconfig` if you are running on Windows,
    to take inventory of the network interfaces that are available on the host machine:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始以`host`模式运行容器，请执行`ifconfig`（如果在macOS或Linux上运行）或使用`ipconfig`（如果在Windows上运行）来列出主机机器上可用的网络接口清单：
- en: '[PRE69]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This should output a list of network interfaces available on your host machine:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出主机机器上可用的网络接口列表：
- en: '![Figure 6.17: List of network interfaces configured on the host machine'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.17：主机机器上配置的网络接口列表'
- en: '](image/B15021_06_12.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_12.jpg)'
- en: 'Figure 6.17: List of network interfaces configured on the host machine'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17：主机机器上配置的网络接口列表
- en: In this example, the primary network interface of your host machine is `enp1s0`
    with an IP address of `192.168.122.185`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您的主机的主要网络接口是`enp1s0`，IP地址为`192.168.122.185`。
- en: Note
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Some versions of Docker Desktop on macOS or Windows may not properly be able
    to start and run containers in `host` network mode or using `macvlan` network
    drivers, due to the dependencies on the Linux kernel to provide many of these
    functionalities. When running these examples on macOS or Windows, you may see
    the network details of the underlying Linux virtual machine running Docker, as
    opposed to the network interfaces available on your macOS or Windows host machine.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS或Windows上的某些版本的Docker Desktop可能无法正确启动和运行`host`网络模式或使用`macvlan`网络驱动程序的容器，因为这些功能依赖于Linux内核。在macOS或Windows上运行这些示例时，您可能会看到运行Docker的基础Linux虚拟机的网络详细信息，而不是macOS或Windows主机机器上可用的网络接口。
- en: 'Use the `docker run` command to start an Alpine Linux container in the `host`
    network. Name it `hostnet1` to tell it apart from the other containers:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker run`命令在`host`网络中启动一个Alpine Linux容器。将其命名为`hostnet1`以区分其他容器：
- en: '[PRE70]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Docker will start this container in the background using the `host` network.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将使用`host`网络在后台启动此容器。
- en: 'Use the `docker inspect` command to look at the network configuration of the
    `hostnet1` container you just created:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker inspect`命令查看刚创建的`hostnet1`容器的网络配置：
- en: '[PRE71]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This will reveal the verbose configuration of the running container, including
    the networking details, in JSON format:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以JSON格式显示运行容器的详细配置，包括网络详细信息：
- en: '![Figure 6.18: docker inspect output for the hostnet1 container'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.18：hostnet1容器的docker inspect输出'
- en: '](image/B15021_06_18.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_18.jpg)'
- en: 'Figure 6.18: docker inspect output for the hostnet1 container'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18：hostnet1容器的docker inspect输出
- en: It should be noted that the output of the `NetworkSettings` block will look
    a lot like the containers you deployed in the `none` network. In the `host` networking
    mode, Docker will not assign an IP address or gateway to the container instance
    since it shares all network interfaces with the host machine directly.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，“NetworkSettings”块的输出看起来很像您在“none”网络中部署的容器。在“主机”网络模式下，Docker不会为容器实例分配IP地址或网关，因为它直接与主机机器共享所有网络接口。
- en: 'Use `docker exec` to access an `sh` shell inside this container, providing
    the name `hostnet1`:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“docker exec”访问此容器内的“sh” shell，提供名称“hostnet1”：
- en: '[PRE72]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This should drop you into a root shell inside the `hostnet1` container.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会将您放入“hostnet1”容器内的root shell中。
- en: 'Inside the `hostnet1` container, execute the `ifconfig` command to list which
    network interfaces are available to it:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“hostnet1”容器内，执行“ifconfig”命令列出可用的网络接口：
- en: '[PRE73]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The full list of network interfaces available inside of this container should
    be displayed:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 应该显示此容器内可用的完整网络接口列表：
- en: '![Figure 6.19: Displaying the available network interfaces inside the hostnet1
    container'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.19：显示hostnet1容器内可用的网络接口'
- en: '](image/B15021_06_19.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_19.jpg)'
- en: 'Figure 6.19: Displaying the available network interfaces inside the hostnet1
    container'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19：显示hostnet1容器内可用的网络接口
- en: Note that this list of network interfaces is identical to that which you encountered
    when querying the host machine directly. This is because this container and the
    host machine are sharing the network directly. Anything available to the host
    machine will also be available to containers running in `host` network mode.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个网络接口列表与直接查询主机机器时遇到的是相同的。这是因为这个容器和主机机器直接共享网络。对主机机器可用的任何东西也将对在“主机”网络模式下运行的容器可用。
- en: Use the `exit` command to end the shell session and return to the terminal of
    the host machine.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“exit”命令结束shell会话并返回到主机机器的终端。
- en: 'To understand more fully how the shared networking model works in Docker, start
    an NGINX container in `host` network mode. The NGINX container automatically exposes
    port `80`, which we previously had to forward to a port on the host machine. Use
    the `docker run` command to start an NGINX container on the host machine:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更充分地了解Docker中共享网络模型的工作原理，以“主机”网络模式启动一个NGINX容器。NGINX容器会自动暴露端口“80”，以前我们必须将其转发到主机机器上的一个端口。使用“docker
    run”命令在主机机器上启动一个NGINX容器：
- en: '[PRE74]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This command will start an NGINX container in the `host` networking mode.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将在“主机”网络模式下启动一个NGINX容器。
- en: 'Navigate to `http://localhost:80` using a web browser on the host machine:![Figure
    6.20: Accessing the NGINX default web page of a container'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主机机器上使用Web浏览器导航至`http://localhost:80`：![图6.20：访问运行在主机网络模式下的容器的NGINX默认网页
- en: running in host networking mode
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机网络模式下运行
- en: '](image/B15021_06_20.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_20.jpg)'
- en: 'Figure 6.20: Accessing the NGINX default web page of a container running in
    host networking mode'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20：访问在主机网络模式下运行的容器的NGINX默认网页
- en: You should be able to see the NGINX default web page displayed in your web browser.
    It should be noted that the `docker run` command did not explicitly forward or
    expose any ports to the host machine. Since the container is running in `host`
    networking mode, any ports that containers expose by default will be available
    directly on the host machine.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够在Web浏览器中看到NGINX默认网页。需要注意的是，“docker run”命令没有明确地将任何端口转发或暴露给主机机器。由于容器在“主机”网络模式下运行，容器默认暴露的任何端口将直接在主机机器上可用。
- en: 'Use the `docker run` command to create another NGINX instance in the `host`
    network mode. Call this container `hostnet3` to differentiate it from the other
    two container instances:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker run`命令在`host`网络模式下创建另一个NGINX实例。将此容器命名为`hostnet3`，以便与其他两个容器实例区分开来：
- en: '[PRE75]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now use the `docker ps -a` command to list all the containers, both in running
    and stopped status:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用`docker ps -a`命令列出所有容器，包括运行和停止状态的容器：
- en: '[PRE76]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The list of running containers will be displayed:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示运行中的容器列表：
- en: '[PRE77]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Based on the preceding output, you can see that the `hostnet3` container exited
    and is currently in a stopped state. To understand more fully why this is the
    case, use the `docker logs` command to view the container logs:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据上述输出，您可以看到`hostnet3`容器已退出并当前处于停止状态。要更充分地了解原因，使用`docker logs`命令查看容器日志：
- en: '[PRE78]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The log output should be displayed as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 日志输出应显示如下：
- en: '![Figure 6.21: NGINX errors in the hostnet3 container'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.21：hostnet3容器中的NGINX错误'
- en: '](image/B15021_06_21.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_21.jpg)'
- en: 'Figure 6.21: NGINX errors in the hostnet3 container'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21：hostnet3容器中的NGINX错误
- en: Essentially, this second instance of an NGINX container was unable to start
    properly because it was unable to bind to port `80` on the host machine. The reason
    for this is that the `hostnet2` container is already listening on that port.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这第二个NGINX容器实例无法正常启动，因为它无法绑定到主机上的端口`80`。原因是`hostnet2`容器已经在监听该端口。
- en: Note
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that containers running in `host` networking mode need to be deployed with
    care and consideration. Without proper planning and architecture, container sprawl
    can lead to a variety of port conflicts across container instances that are running
    on the same machine.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以`host`网络模式运行的容器需要谨慎部署和考虑。如果没有适当的规划和架构，容器的泛滥可能会导致在同一台机器上运行的容器实例之间发生各种端口冲突。
- en: The next type of native Docker network you will investigate is `macvlan`. In
    a `macvlan` network, Docker will allocate a MAC address to a container instance
    to make it appear as a physical host on a particular network segment. It can run
    either in `bridge` mode, which uses a parent `host` network interface to gain
    physical access to the underlay network, or in `802.1Q trunk` mode, which leverages
    a sub-interface that Docker creates on the fly.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将要调查的下一个类型的本机Docker网络是`macvlan`。在`macvlan`网络中，Docker将为容器实例分配一个MAC地址，使其在特定网络段上看起来像是物理主机。它可以在`bridge`模式下运行，该模式使用父`host`网络接口来获得对底层网络的物理访问，或者在`802.1Q
    trunk`模式下运行，该模式利用Docker动态创建的子接口。
- en: To begin, create a new network utilizing the `macvlan` Docker network driver
    by specifying a physical interface on your host machine as the parent interface
    using the `docker network create` command.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用`docker network create`命令指定主机上的物理接口作为父接口，通过`macvlan` Docker网络驱动程序创建一个新网络。
- en: 'Earlier in the `ifconfig` or `ipconfig` output, you saw that the `enp1s0` interface
    is the primary network interface on the machine. Substitute the name of the primary
    network interface of your machine. Since you are using the primary network interface
    of the host machine as the parent, specify the same subnet (or a smaller subnet
    within that space) for the network connectivity of our containers. Use a `192.168.122.0/24`
    subnet here, since it is the same subnet of the primary network interface. Likewise,
    you want to specify the same default gateway as the parent interface. Use the
    same subnet and gateway of your host machine:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前的`ifconfig`或`ipconfig`输出中，你看到`enp1s0`接口是机器上的主要网络接口。替换你的机器的主要网络接口的名称。由于你正在使用主机机器的主要网络接口作为父接口，为我们的容器的网络连接指定相同的子网（或者在该空间内更小的子网）。在这里使用`192.168.122.0/24`子网，因为它是主要网络接口的相同子网。同样，你想要指定与父接口相同的默认网关。使用主机机器的相同子网和网关：
- en: '[PRE79]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This command should create a network called `macvlan-net1`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令应该创建一个名为`macvlan-net1`的网络。
- en: 'Use the `docker network ls` command to confirm that the network has been created
    and is using the `macvlan` network driver:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker network ls`命令来确认网络已经被创建，并且正在使用`macvlan`网络驱动程序：
- en: '[PRE80]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This command will output all the currently configured networks that are defined
    in your environment. You should see the `macvlan-net1` network:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将输出当前在你的环境中定义的所有网络。你应该会看到`macvlan-net1`网络：
- en: '[PRE81]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now that the `macvlan` network has been defined in Docker, create a container
    in this network and investigate the network connectivity from the host''s perspective.
    Use the `docker run` command to create another Alpine Linux container named `macvlan1`
    using the `macvlan` network `macvlan-net1`:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`macvlan`网络已经在Docker中定义，创建一个在这个网络中的容器，并从主机的角度调查网络连接。使用`docker run`命令在`macvlan`网络`macvlan-net1`中创建另一个名为`macvlan1`的Alpine
    Linux容器：
- en: '[PRE82]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This should start an Alpine Linux container instance called `macvlan1` in the
    background.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在后台启动一个名为`macvlan1`的Alpine Linux容器实例。
- en: 'Use the `docker ps -a` command to check and make sure this container instance
    is running:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker ps -a`命令来检查并确保这个容器实例正在运行：
- en: '[PRE83]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This should reveal that the container named `macvlan1` is up and running as
    expected:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该显示名为`macvlan1`的容器正在按预期运行：
- en: '[PRE84]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Use the `docker inspect` command to investigate the networking configuration
    of this container instance:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker inspect`命令来调查这个容器实例的网络配置：
- en: '[PRE85]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The verbose output of the container configuration should be displayed. The
    following output has been truncated to show only the network settings section
    in JSON format:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 容器配置的详细输出应该被显示出来。以下输出已经被截断，只显示了JSON格式的网络设置部分：
- en: '![Figure 6.22: The docker network inspect output of the macvlan1 network'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.22：macvlan1网络的docker网络检查输出'
- en: '](image/B15021_06_22.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_22.jpg)'
- en: 'Figure 6.22: The docker network inspect output of the macvlan1 network'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.22：macvlan1网络的docker网络检查输出
- en: From this output, you can see that this container instance (similar to containers
    in other networking modes) has both an IP address and a default gateway. It can
    also be concluded that this container also has an OSI Model Layer 2 MAC address
    within the `192.168.122.0/24` network, based on the `MacAddress` parameter under
    the `Networks` subsection. Other hosts within this network segment would believe
    this machine is another physical node living in this subnet, not a container hosted
    inside a node on the subnet.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中，你可以看到这个容器实例（类似于其他网络模式的容器）既有IP地址又有默认网关。还可以得出结论，这个容器也在`192.168.122.0/24`网络中拥有一个OSI模型第2层的MAC地址，根据`Networks`子部分下的`MacAddress`参数。这个网络段内的其他主机会认为这台机器是另一个物理节点，而不是托管在子网中的节点上的容器。
- en: 'Use `docker run` to create a second container instance named `macvlan2` inside
    the `macvlan-net1` network:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker run`创建`macvlan-net1`网络内的第二个容器实例命名为`macvlan2`：
- en: '[PRE86]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This should start another container instance within the `macvlan-net1` network.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在`macvlan-net1`网络中启动另一个容器实例。
- en: 'Run the `docker inspect` command to see the MAC address of the `macvlan-net2`
    container instance:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker inspect`命令以查看`macvlan-net2`容器实例的MAC地址：
- en: '[PRE87]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This will output the verbose configuration of the `macvlan2` container instance
    in JSON format, truncated here to only show the relevant networking settings:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以JSON格式输出`macvlan2`容器实例的详细配置，此处仅显示相关的网络设置。
- en: '![Figure 6.23: docker inspect output for the macvlan2 container'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.23：macvlan2容器的docker inspect输出'
- en: '](image/B15021_06_23.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_23.jpg)'
- en: 'Figure 6.23: docker inspect output for the macvlan2 container'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.23：macvlan2容器的docker inspect输出
- en: It can be seen in this output that the `macvlan2` container has both a different
    IP address and MAC address from the `macvlan1` container instance. Docker assigns
    different MAC addresses to ensure that Layer 2 conflicts do not arise when many
    containers are using `macvlan` networks.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在此输出中看到`macvlan2`容器具有与`macvlan1`容器实例不同的IP地址和MAC地址。Docker分配不同的MAC地址以确保在许多容器使用`macvlan`网络时不会出现第2层冲突。
- en: 'Run the `docker exec` command to access an `sh` shell inside this container:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker exec`命令以访问此容器内的`sh` shell：
- en: '[PRE88]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This should drop you into a root session inside the container.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该将您放入容器内的root会话。
- en: 'Use the `ifconfig` command inside the container to observe that the MAC address
    you saw in the `docker inspect` output on the `macvlan1` container is present
    as the MAC address of the container''s primary network interface:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内使用`ifconfig`命令观察在`macvlan1`容器的`docker inspect`输出中看到的MAC地址是否存在于容器的主要网络接口的MAC地址中：
- en: '[PRE89]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'In the details for the `eth0` interface, look at the `HWaddr` parameter. You
    may also note the IP address listed under the `inet addr` parameter, as well as
    the number of bytes transmitted and received by this network interface – `RX bytes`
    (bytes received) and `TX bytes` (bytes transmitted):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在`eth0`接口的详细信息中，查看`HWaddr`参数。您还可以注意`inet addr`参数下列出的IP地址，以及通过此网络接口传输和接收的字节数-`RX字节`（接收的字节数）和`TX字节`（传输的字节数）：
- en: '[PRE90]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Install the `arping` utility using the `apk` package manager available in the
    Alpine Linux container. This is a tool used to send `arp` messages to a MAC address
    to check Layer 2 connectivity:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Alpine Linux容器中可用的`apk`软件包管理器安装`arping`实用程序。这是一个用于向MAC地址发送`arp`消息以检查第2层连接的工具：
- en: '[PRE91]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `arping` utility should install inside the `macvlan1` container:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`arping`实用程序应该安装在`macvlan1`容器内：'
- en: '[PRE92]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Specify the Layer 3 IP address of the `macvlan2` container instance as the
    primary argument to `arping`. Now, `arping` will automatically look up the MAC
    address and check the Layer 2 connectivity to it:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`macvlan2`容器实例的第3层IP地址指定为`arping`的主要参数。现在，`arping`将自动查找MAC地址并检查与其的第2层连接：
- en: '[PRE93]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The `arping` utility should report back the correct MAC address for the `macvlan2`
    container instance, indicating successful Layer 2 network connectivity:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`arping`实用程序应该报告`macvlan2`容器实例的正确MAC地址，表明成功的第2层网络连接：'
- en: '[PRE94]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Check the status of the containers using the `docker ps -a` command:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker ps -a`命令检查容器的状态：
- en: '[PRE95]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The output of this command should show all the running and stopped container
    instances in your environment.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出应显示环境中所有正在运行和停止的容器实例。
- en: 'Next, stop all running containers using `docker stop`, followed by the container
    name or ID:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`docker stop`停止所有正在运行的容器，然后是容器名称或ID：
- en: '[PRE96]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Repeat this step for all running containers in your environment.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 对您环境中的所有运行容器重复此步骤。
- en: 'Clean up the container images and unused networks using the `docker system
    prune` command:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `docker system prune` 命令清理容器镜像和未使用的网络：
- en: '[PRE97]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This command will clean up all unused container images, networks, and volumes
    remaining on your machine.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将清理您的机器上剩余的所有未使用的容器镜像、网络和卷。
- en: 'In this exercise, we looked at the four default networking drivers available
    by default in Docker: `bridge`, `host`, `macvlan`, and `none`. For each example,
    we explored how the network functions, how containers deployed using these network
    drivers function with the host machine, and how they function with other containers
    on the network.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看了一下 Docker 默认提供的四种默认网络驱动程序：`bridge`、`host`、`macvlan` 和 `none`。对于每个示例，我们探讨了网络的功能，使用这些网络驱动程序部署的容器如何与主机机器一起工作，以及它们如何在网络上与其他容器一起工作。
- en: The networking capability that Docker exposes by default can be leveraged to
    deploy containers in very advanced networking configurations, as we have seen
    so far. Docker also offers the ability to manage and coordinate container networking
    between hosts in a clustered swarm configuration.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 默认公开的网络功能可以用来部署非常高级的网络配置，正如我们迄今所见。Docker 还提供了管理和协调集群化的容器网络之间的能力。
- en: In the next section, we will look at creating networks that will create overlay
    networks between Docker hosts to ensure direct connectivity between container
    instances.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看创建网络，这些网络将在 Docker 主机之间创建覆盖网络，以确保容器实例之间的直接连接。
- en: Docker Overlay Networking
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Overlay 网络
- en: '`Overlay` networks are logical networks that are created on top of a physical
    (underlay) network for specific purposes. A **Virtual Private Network** (**VPN**),
    for example, is a common type of `overlay` network that uses the internet to create
    a link to another private network. Docker can create and manage `overlay` networks
    between containers, which can be used for containerized applications to directly
    talk to one another. When containers are deployed into an `overlay` network, it
    does not matter which host in the cluster they are deployed on; they will have
    direct connectivity to other containerized services that exist in the same `overlay`
    network in the same way that they would if they existed on the same physical host.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`Overlay` 网络是在特定目的下在物理（底层）网络之上创建的逻辑网络。例如，**虚拟专用网络**（**VPN**）是一种常见的 `overlay`
    网络类型，它使用互联网来创建与另一个私有网络的连接。Docker 可以创建和管理容器之间的 `overlay` 网络，这些网络可以用于容器化应用程序直接相互通信。当容器部署到
    `overlay` 网络中时，它们部署在集群中的哪个主机上并不重要；它们将直接连接到同一 `overlay` 网络中存在的其他容器化服务，就像它们存在于同一物理主机上一样。'
- en: 'Exercise 6.04: Defining Overlay Networks'
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.04：定义 Overlay 网络
- en: Docker `overlay` networking is used to create mesh networks between machines
    in a Docker swarm cluster. In this exercise, you will use two machines to create
    a basic Docker swarm cluster. Ideally, these machines will exist on the same networking
    segment to ensure direct network connectivity and fast network connectivity between
    them. Furthermore, they should be running the same version of Docker in a supported
    distribution of Linux, such as RedHat, CentOS, or Ubuntu.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Docker `overlay` 网络用于在 Docker 集群中的机器之间创建网格网络。在这个练习中，您将使用两台机器创建一个基本的 Docker 集群。理想情况下，这些机器将存在于同一个网络段，以确保它们之间的直接网络连接和快速网络连接。此外，它们应该在支持的
    Linux 发行版（如 RedHat、CentOS 或 Ubuntu）上运行相同版本的 Docker。
- en: 'You will define `overlay` networks that will span hosts in a Docker swarm cluster.
    You will then ensure that containers deployed on separate hosts can talk to one
    another via the `overlay` network:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 您将定义将跨越 Docker 集群中的主机的 `overlay` 网络。然后，您将确保部署在不同主机上的容器可以通过 `overlay` 网络相互通信：
- en: Note
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This exercise requires access to a secondary machine with Docker installed on
    it. Usually, cloud-based virtual machines or machines deployed in another hypervisor
    work best. Deploying a Docker swarm cluster on your system using Docker Desktop
    could lead to networking issues or serious performance degradation.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习需要访问一个安装了 Docker 的辅助机器。通常，基于云的虚拟机或部署在另一个虚拟化程序中的机器效果最好。在使用 Docker Desktop
    在系统上部署 Docker 集群可能会导致网络问题或严重的性能下降。
- en: On the first machine, `Machine1`, run `docker --version` to find out which version
    of Docker is currently running on it.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一台机器 `Machine1` 上运行 `docker --version` 来查找当前正在运行的 Docker 版本。
- en: '[PRE98]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '`The version details of the Docker installation of Machine1 will be displayed:`'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示 `Machine1` 的 Docker 安装的版本细节：
- en: '[PRE99]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Then, you can do the same for `Machine2:`
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以对 `Machine2` 执行相同的操作：
- en: '[PRE100]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '`The version details of the Docker installation of Machine2 will be displayed`:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示 `Machine2` 的 Docker 安装的版本细节：
- en: '[PRE101]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Verify that the installed version of Docker is the same before moving forward.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，验证已安装的 Docker 版本是否相同。
- en: Note
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The Docker version may vary depending on your system.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 版本可能会因系统而异。
- en: 'On `Machine1`, run the `docker swarm init` command to initialize a Docker swarm
    cluster:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Machine1` 上，运行 `docker swarm init` 命令来初始化 Docker 集群：
- en: '[PRE102]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This should print the command you can use on other nodes to join the Docker
    swarm cluster, including the IP address and `join` token:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该打印出您可以在其他节点上使用的命令，以加入 Docker 集群，包括 IP 地址和 `join` 令牌：
- en: '[PRE103]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'On `Machine2`, run the `docker swarm join` command, which was provided by `Machine1`,
    to join the Docker swarm cluster:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Machine2` 上，运行由 `Machine1` 提供的 `docker swarm join` 命令，以加入 Docker 集群：
- en: '[PRE104]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '`Machine2` should successfully join the Docker swarm cluster:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`Machine2` 应成功加入 Docker 集群：'
- en: '[PRE105]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Execute the `docker info` command on both nodes to ensure they have successfully
    joined the swarm cluster:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个节点上执行 `docker info` 命令，以确保它们已成功加入集群：
- en: '`Machine1`:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`Machine1`：'
- en: '[PRE106]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '`Machine2`:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`Machine2`：'
- en: '[PRE107]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The following output is a truncation of the `swarm` portion of the `docker
    info` output. From these details, you will see that these Docker nodes are configured
    in a swarm cluster and there are two nodes in the cluster with a single manager
    node (`Machine1`). These parameters should be identical on both nodes, except
    for the `Is Manager` parameter, for which `Machine1` will be the manager. By default,
    Docker will allocate a default subnet of `10.0.0.0/8` for the default Docker swarm
    `overlay` network:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出是 `docker info` 输出的 `swarm` 部分的截断。从这些细节中，您将看到这些 Docker 节点配置在一个集群中，并且集群中有两个节点，一个是单个管理节点（`Machine1`）。这些参数在两个节点上应该是相同的，除了
    `Is Manager` 参数，其中 `Machine1` 将是管理节点。默认情况下，Docker 将为默认的 Docker 集群 `overlay` 网络分配一个默认子网
    `10.0.0.0/8`：
- en: '[PRE108]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'From the `Machine1` box, create an `overlay` network using the `docker network
    create` command. Since this is a network that will span more than one node in
    a simple swarm cluster, specify the `overlay` driver as the network driver. Call
    this network `overlaynet1`. Use a subnet and gateway that are not yet in use by
    any networks on your Docker hosts to avoid subnet collisions. Use `172.45.0.0/16`
    and `172.45.0.1` as the gateway:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Machine1` 中，使用 `docker network create` 命令创建一个 `overlay` 网络。由于这是一个将跨越简单集群中的多个节点的网络，因此需要将
    `overlay` 驱动程序指定为网络驱动程序。将此网络命名为 `overlaynet1`。使用尚未被 Docker 主机上的任何网络使用的子网和网关，以避免子网冲突。使用
    `172.45.0.0/16` 和 `172.45.0.1` 作为网关：
- en: '[PRE109]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The `overlay` network will be created.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建 `overlay` 网络。
- en: 'Use the `docker network ls` command to verify whether the network was created
    successfully and is using the correct `overlay` driver:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `docker network ls` 命令来验证网络是否成功创建并且是否使用了正确的 `overlay` 驱动程序：
- en: '[PRE110]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'A list of networks available on your Docker host will be displayed:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示 Docker 主机上可用的网络列表：
- en: '[PRE111]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Use the `docker service create` command to create a service that will span
    multiple nodes in the swarm cluster. Deploying containers as services allow you
    to specify more than one replica of a container instance for horizontal scaling
    or scaling container instances across nodes in a cluster for high availability.
    To keep this example simple, create a single container service of Alpine Linux.
    Name this service `alpine-overlay1`:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“docker service create”命令创建一个将跨多个节点的swarm集群的服务。将容器部署为服务允许您指定一个容器实例的多个副本，以进行水平扩展或在集群中的节点之间扩展容器实例以实现高可用性。为了保持这个例子简单，创建一个Alpine
    Linux的单个容器服务。将此服务命名为“alpine-overlay1”：
- en: '[PRE112]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'A text-based progress bar will display the progress of the `alpine-overlay1`
    service deployment:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基于文本的进度条将显示“alpine-overlay1”服务部署的进度：
- en: '[PRE113]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Repeat the same `docker service create` command, but now specify `alpine-overlay2`
    as the service name:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复相同的“docker service create”命令，但现在将“alpine-overlay2”指定为服务名称：
- en: '[PRE114]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'A text-based progress bar will again display the progress of the service deployment:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基于文本的进度条将再次显示服务部署的进度：
- en: '[PRE115]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Note
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: More details on creating services in Docker swarm can be found in *Chapter 9,
    Docker Swarm*. As the scope of this exercise is networking, we will focus for
    now on the networking component.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在Docker swarm中创建服务的更多详细信息，请参阅《第9章，Docker Swarm》。由于本练习的范围是网络，我们现在将专注于网络组件。
- en: 'From the `Machine1` node, execute the `docker ps` command to see which service
    is running on this node:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“Machine1”节点，执行“docker ps”命令以查看此节点上正在运行的服务：
- en: '[PRE116]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The running containers will be displayed. Docker will intelligently scale containers
    between nodes in a Docker swarm cluster. In this example, the container from the
    `alpine-overlay1` service landed on `Machine1`. Your environment may vary depending
    on how Docker deploys the services:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行的容器将被显示。Docker将在Docker swarm集群中的节点之间智能地扩展容器。在本例中，“alpine-overlay1”服务的容器落在了“Machine1”上。根据Docker部署服务的方式，您的环境可能会有所不同：
- en: '[PRE117]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Run the `docker inspect` command to view the verbose details of the running
    container:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行“docker inspect”命令以查看正在运行的容器的详细信息：
- en: '[PRE118]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The verbose details of the running container instance will be displayed. The
    following output has been truncated to display the `NetworkSettings` portion of
    the `docker inspect` output:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示正在运行的容器实例的详细信息。以下输出已被截断以显示“docker inspect”输出的“NetworkSettings”部分：
- en: '![Figure 6.24: Inspecting the alpine-overlay1 container instance'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.24：检查alpine-overlay1容器实例'
- en: '](image/B15021_06_24.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_24.jpg)'
- en: 'Figure 6.24: Inspecting the alpine-overlay1 container instance'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.24：检查alpine-overlay1容器实例
- en: Notice that the IP address of this container is as expected within the subnet
    you have specified on `Machine1`.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此容器的IP地址与您在“Machine1”上指定的子网中的预期值相同。
- en: 'On the `Machine2` instance, execute the `docker network ls` command to view
    the Docker networks available on the host:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Machine2”实例上，执行“docker network ls”命令以查看主机上可用的Docker网络：
- en: '[PRE119]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'A list of all available Docker networks will be displayed on the Docker host:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示Docker主机上所有可用的Docker网络的列表：
- en: '[PRE120]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Notice the `overlaynet1` network defined on `Machine1` is also available on
    `Machine2`. This is because networks created using the `overlay` driver are available
    to all hosts in the Docker swarm cluster. This enables containers to be deployed
    using this network to run across all hosts in the cluster.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，“Machine1”上定义的“overlaynet1”网络也可在“Machine2”上使用。这是因为使用“overlay”驱动程序创建的网络可用于Docker
    swarm集群中的所有主机。这使得可以使用此网络部署容器以在集群中的所有主机上运行。
- en: 'Use the `docker ps` command to list the running containers on this Docker instance:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“docker ps”命令列出此Docker实例上正在运行的容器：
- en: '[PRE121]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'A list of all running containers will be displayed. In this example, the container
    in the `alpine-overlay2` service landed on the `Machine2` cluster node:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有正在运行的容器列出。在这个例子中，`alpine-overlay2` 服务中的容器落在了 `Machine2` 集群节点上：
- en: '[PRE122]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Note
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Which node the services land on in your example may differ from what is displayed
    here. Docker makes decisions on how to deploy containers based on various criteria,
    such as available CPU bandwidth, memory, and scheduling restrictions placed on
    the deployed containers.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的示例中，服务落在哪个节点可能与此处显示的不同。Docker 根据各种标准（如可用的 CPU 带宽、内存和对部署容器的调度限制）来决定如何部署容器。
- en: 'Use `docker inspect` to investigate the network configuration of this container
    as well:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `docker inspect` 来调查该容器的网络配置：
- en: '[PRE123]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The verbose container configuration will be displayed. This output has been
    truncated to display the `NetworkSettings` portion of the output in JSON format:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示详细的容器配置。此输出已被截断，以 JSON 格式显示输出的 `NetworkSettings` 部分：
- en: '![Figure 6.25: docker inspect output of the alpine-overlay2 container instance'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.25：alpine-overlay2 容器实例的 docker inspect 输出'
- en: '](image/B15021_06_25.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_25.jpg)'
- en: 'Figure 6.25: docker inspect output of the alpine-overlay2 container instance'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.25：alpine-overlay2 容器实例的 docker inspect 输出
- en: Note that this container also has an IP address within the `overlaynet1` `overlay`
    network.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该容器还在 `overlaynet1` `overlay` 网络中拥有一个 IP 地址。
- en: 'Since both services are deployed within the same `overlay` network but exist
    in two separate hosts, you can see that Docker is using the `underlay` network
    to proxy the traffic for the `overlay` network. Check the network connectivity
    between the services by attempting a ping from one service to the other. It should
    be noted here that, similar to static containers deployed in the same network,
    services deployed on the same network can resolve each other by name using Docker
    DNS. Use the `docker exec` command on the `Machine2` host to access an `sh` shell
    inside the `alpine-overlay2` container:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于两个服务都部署在同一个 `overlay` 网络中，但存在于两个独立的主机中，您可以看到 Docker 正在使用 `underlay` 网络来代理
    `overlay` 网络的流量。通过尝试从一个服务到另一个服务的 ping 来检查服务之间的网络连接。需要注意的是，类似于部署在同一网络中的静态容器，部署在同一网络上的服务可以使用
    Docker DNS 通过名称解析彼此。在 `Machine2` 主机上使用 `docker exec` 命令访问 `alpine-overlay2` 容器内的
    `sh` shell：
- en: '[PRE124]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'This should drop you into a root shell on the `alpine-overlay2` container instance.
    Use the `ping` command to initiate network communication to the `alpine-overlay1`
    container:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该将您放入 `alpine-overlay2` 容器实例的 root shell。使用 `ping` 命令发起与 `alpine-overlay1`
    容器的网络通信：
- en: '[PRE125]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Notice that even though these containers are deployed across two separate hosts,
    the containers can communicate with each other by name, using the shared `overlay`
    network.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使这些容器部署在两个独立的主机上，它们也可以通过名称使用共享的 `overlay` 网络进行通信。
- en: 'From the `Machine1` box, you can attempt the same communication to the `alpine-overlay2`
    service container. Use the `docker exec` command to access an `sh` shell on the
    `Machine1` box:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Machine1` 主机，您可以尝试与 `alpine-overlay2` 服务容器进行相同的通信。使用 `docker exec` 命令在 `Machine1`
    主机上访问 `alpine-overlay2` 容器内的 `sh` shell：
- en: '[PRE126]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'This should drop you into a root shell inside the container. Use the `ping`
    command to initiate communication to the `alpine-overlay2` container instance:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该将您放入容器内的 root shell。使用 `ping` 命令发起与 `alpine-overlay2` 容器实例的网络通信：
- en: '[PRE127]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Notice again that, by using Docker DNS, the IP address of the `alpine-overlay2`
    container can be resolved between hosts using the `overlay` networking driver.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，通过使用 Docker DNS，可以使用 `overlay` 网络驱动程序在主机之间解析 `alpine-overlay2` 容器的 IP 地址。
- en: 'Use the `docker service rm` command to delete both services from the `Machine1`
    node:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `docker service rm` 命令从 `Machine1` 节点中删除这两个服务：
- en: '[PRE128]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: For each of these commands, the service name will appear briefly indicating
    the command execution was successful. On both nodes, `docker ps` will display
    that no containers are currently running.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些命令中的每一个，服务名称将会短暂地显示，表明命令执行成功。在两个节点上，`docker ps` 将显示当前没有正在运行的容器。
- en: 'Delete the `overlaynet1` Docker network by using the `docker rm` command and
    specifying the name `overlaynet1`:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `docker rm` 命令并指定名称 `overlaynet1` 删除 `overlaynet1` Docker 网络。
- en: '[PRE129]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The `overlaynet1` network will be deleted.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`overlaynet1` 网络将被删除。'
- en: In this exercise, we looked at Docker `overlay` networking between two hosts
    in a Docker swarm cluster. `Overlay` networking is enormously beneficial in a
    Docker container cluster because it allows the horizontal scaling of containers
    between nodes in a cluster. From a network perspective, these containers can directly
    talk to one another by using a service mesh proxied over the physical network
    interfaces of the host machines. This not only reduces latency but simplifies
    deployments by taking advantage of many of Docker's features, such as DNS.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们研究了 Docker 集群中两个主机之间的 `overlay` 网络。`Overlay` 网络在 Docker 容器集群中非常有益，因为它允许在集群中的节点之间水平扩展容器。从网络的角度来看，这些容器可以通过使用服务网格在主机机器的物理网络接口上直接进行通信。这不仅减少了延迟，还通过利用
    Docker 的许多功能（如 DNS）简化了部署。
- en: Now that we have looked at all the native Docker network types and examples
    of how they function, we can look at another aspect of Docker networking that
    has recently been gaining popularity. Since Docker networking is very modular,
    as we have seen, Docker supports a plugin system that allows users to deploy and
    manage custom network drivers.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了所有本地 Docker 网络类型以及它们的功能示例，我们可以看看 Docker 网络的另一个方面，这个方面最近变得越来越受欢迎。由于
    Docker 网络非常模块化，正如我们所见，Docker 支持插件系统，允许用户部署和管理自定义网络驱动程序。
- en: In the next section, we will learn about how non-native Docker networks work
    by installing a third-party network driver from Docker Hub.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过从 Docker Hub 安装第三方网络驱动程序来了解非本地 Docker 网络是如何工作的。
- en: Non-Native Docker Networks
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非本地 Docker 网络
- en: In the final section of this chapter, we will discuss non-native Docker networks.
    Aside from the native Docker network drivers that are available, Docker also supports
    custom networking drivers that can be written by users or downloaded from third
    parties via Docker Hub. Custom third-party network drivers are useful in circumstances
    that require very particular network configurations, or where container networking
    is expected to behave in a certain way. For example, some network drivers provide
    the ability for users to set custom policies regarding access to internet resources,
    or other defining whitelists for communication between containerized applications.
    This can be helpful from a security, policy, and auditing perspective.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一节中，我们将讨论非本地 Docker 网络。除了可用的本地 Docker 网络驱动程序之外，Docker 还支持用户编写或通过 Docker
    Hub 从第三方下载的自定义网络驱动程序。自定义的第三方网络驱动程序在需要非常特定的网络配置或容器网络需要以特定方式运行的情况下非常有用。例如，一些网络驱动程序提供了用户设置自定义策略以控制对互联网资源的访问，或者定义容器化应用之间通信的白名单的能力。从安全、策略和审计的角度来看，这是有帮助的。
- en: In the following exercise, we will download and install the Weave Net driver
    and create a network on a Docker host. Weave Net is a highly supported third-party
    network driver that provides excellent visibility into container mesh networks,
    allowing users to create complex service mesh infrastructures that can span multi-cloud
    scenarios. We will install the Weave Net driver from Docker Hub and configure
    a basic network in the simple swarm cluster we defined in the previous exercise.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将下载并安装Weave Net驱动程序，并在Docker主机上创建一个网络。Weave Net是一个得到高度支持的第三方网络驱动程序，可以很好地查看容器网格网络，允许用户创建可以跨多云场景的复杂服务网格基础设施。我们将从Docker
    Hub安装Weave Net驱动程序，并在前面练习中定义的简单集群中配置一个基本网络。
- en: 'Exercise 6.05: Installing and Configuring the Weave Net Docker Network Driver'
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.05：安装和配置Weave Net Docker网络驱动程序
- en: 'In this exercise, you will download and install the Weave Net Docker network
    driver and deploy it within the Docker swarm cluster you created in the previous
    exercise. Weave Net is one of the most common and flexible third-party Docker
    network drivers available. Using Weave Net, very complex networking configurations
    can be defined to enable maximum flexibility in your infrastructure:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将下载并安装Weave Net Docker网络驱动程序，并在之前创建的Docker集群中部署它。Weave Net是最常见和灵活的第三方Docker网络驱动程序之一。使用Weave
    Net，可以定义非常复杂的网络配置，以实现基础设施的最大灵活性：
- en: 'Install the Weave Net driver from Docker Hub using the `docker plugin install`
    command on the `Machine1` node:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Machine1`节点上使用`docker plugin install`命令从Docker Hub安装Weave Net驱动程序：
- en: '[PRE130]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'This will prompt you to grant Weave Net permissions on the machine you are
    installing it on. It is safe to grant the requested permissions as Weave Net requires
    them to set up the network driver on the host operating system properly:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提示您在安装它的机器上授予Weave Net权限。授予请求的权限是安全的，因为Weave Net需要这些权限才能在主机操作系统上正确设置网络驱动程序：
- en: '[PRE131]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Answer the prompt by pressing the *y* key. The Weave Net plugin should be installed
    successfully.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按下*y*键来回答提示。Weave Net插件应该安装成功。
- en: 'On the `Machine2` node, run the same `docker plugin install` command. All nodes
    in the Docker swarm cluster should have the plugin installed since all nodes will
    be participating in the swarm mesh networking:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Machine2`节点上运行相同的`docker plugin install`命令。Docker集群中的所有节点都应该安装了插件，因为所有节点都将参与到集群网格网络中：
- en: '[PRE132]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The permissions prompt will be displayed. Respond with *y* when prompted to
    continue the installation:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 权限提示将被显示。在提示继续安装时回答*y*：
- en: '[PRE133]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Create a network using the `docker network create` command on the `Machine1`
    node. Specify the Weave Net driver as the primary driver and the network name
    as `weavenet1`. For the subnet and gateway parameters, use a unique subnet that
    has not yet been used in the previous exercises:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Machine1`节点上使用`docker network create`命令创建一个网络。将Weave Net驱动程序指定为主驱动程序，网络名称为`weavenet1`。对于子网和网关参数，请使用之前练习中尚未使用的唯一子网：
- en: '[PRE134]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: This should create a network called `weavenet1` in the Docker swarm cluster.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在Docker集群中创建一个名为`weavenet1`的网络。
- en: 'List the available networks in the Docker swarm cluster using the `docker network
    ls` command:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker network ls`命令列出Docker集群中可用的网络：
- en: '[PRE135]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The `weavenet1` network should be displayed in the list:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`weavenet1`网络应该显示在列表中：'
- en: '[PRE136]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Execute the `docker network ls` command on the `Machine2` node to ensure that
    the `weavenet1` network is present on that machine as well:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Machine2`节点上执行`docker network ls`命令，以确保`weavenet1`网络也存在于该机器上：
- en: '[PRE137]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The `weavenet1` network should be listed:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`weavenet1`网络应该被列出：'
- en: '[PRE138]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'On the `Machine1` node, create a service called `alpine-weavenet1` that uses
    the `weavenet1` network using the `docker service create` command:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Machine1`节点上，使用`docker service create`命令创建一个名为`alpine-weavenet1`的服务，该服务使用`weavenet1`网络：
- en: '[PRE139]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'A text-based progress bar will display the deployment status of the service.
    It should complete without any issues:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 文本进度条将显示服务的部署状态。它应该在没有任何问题的情况下完成：
- en: '[PRE140]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Use the `docker service create` command again to create another service in
    the `weavenet1` network called `alpine-weavenet2`:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`docker service create`命令在`weavenet1`网络中创建另一个名为`alpine-weavenet2`的服务：
- en: '[PRE141]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'A text-based progress bar will again display indicating the status of the service
    creation:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 文本进度条将再次显示，指示服务创建的状态：
- en: '[PRE142]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Run the `docker ps` command to validate that an Alpine container is successfully
    running on each node in the cluster:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker ps`命令验证集群中每个节点上是否成功运行了Alpine容器：
- en: '`Machine1`:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`Machine1`：'
- en: '[PRE143]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '`Machine2`:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`Machine2`：'
- en: '[PRE144]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'One of the service containers should be up and running on both machines:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个服务容器应该在两台机器上都正常运行：
- en: '`Machine1`:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`Machine1`：'
- en: '[PRE145]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '`Machine2`:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '`Machine2`：'
- en: '[PRE146]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Use the `docker exec` command to access an `sh` shell inside the `weavenet1.1`
    container instance. Make sure to run this command on the node in the swarm cluster
    that is running this container:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker exec`命令访问`weavenet1.1`容器实例内部的`sh` shell。确保在运行此容器的swarm集群中的节点上运行此命令：
- en: '[PRE147]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'This should drop you into a root shell inside the container:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该将您带入容器内部的root shell：
- en: '[PRE148]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Use the `ifconfig` command to view the network interfaces present inside this
    container:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ifconfig`命令查看此容器内部存在的网络接口：
- en: '[PRE149]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'This will display a newly named network interface called `ethwe0`. A core part
    of Weave Net''s core networking policy is to create custom-named interfaces within
    the container for easy identification and troubleshooting. It should be noted
    this interface is assigned an IP address from the subnet that we provided as a
    configuration parameter:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示一个名为`ethwe0`的新命名网络接口。Weave Net核心网络策略的核心部分是在容器内创建自定义命名的接口，以便进行简单识别和故障排除。需要注意的是，此接口被分配了一个IP地址，该地址来自我们提供的子网作为配置参数：
- en: '[PRE150]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'From inside this container, ping the `alpine-weavenet2` service by name, using
    the `ping` utility:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从容器内部，使用`ping`实用程序通过名称ping`alpine-weavenet2`服务：
- en: '[PRE151]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'You should see responses coming from the resolved IP address of the `alpine-weavenet2`
    service:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到来自`alpine-weavenet2`服务的解析IP地址的响应：
- en: '[PRE152]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Note
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Due to recent updates in the Docker libnetwork stack in recent versions of
    Docker and Docker Swarm, pinging the service by name: `alpine-weavenet2` may not
    work. To demonstrate the network is working as intended, try pinging the name
    of the container directly instead: `alpine-weavenet2.1.z8jpiup8yetjrqca62ub0yz9k`
    – Keep in mind, the name of this container will be different in your lab environment.'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker和Docker Swarm最近版本中Docker libnetwork堆栈的更新，通过名称ping服务：`alpine-weavenet2`可能无法正常工作。为了证明网络按预期工作，请尝试直接ping容器的名称而不是服务的名称：`alpine-weavenet2.1.z8jpiup8yetjrqca62ub0yz9k`
    - 请记住，在您的实验环境中，此容器的名称将不同。
- en: 'Try pinging Google DNS servers (`8.8.8.8`) on the open internet from these
    containers as well to ensure that these containers have internet access:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还可以尝试从这些容器中通过开放的互联网ping Google DNS服务器（`8.8.8.8`）以确保这些容器具有互联网访问权限：
- en: '[PRE153]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'You should see responses returning, indicating these containers have internet
    access:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到返回的响应，表明这些容器具有互联网访问权限：
- en: '[PRE154]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Use the `docker service rm` command to remove both services from the `Machine1`
    node:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker service rm`命令从`Machine1`节点中删除两个服务：
- en: '[PRE155]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: This will delete both the services, stopping and removing the container instances.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除两个服务，停止并删除容器实例。
- en: 'Delete the Weave Net network that was created by running the following command:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令删除Weave Net网络：
- en: '[PRE156]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The Weave Net network should be deleted and removed.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 应删除和移除Weave Net网络。
- en: In the robust system of containerized networking concepts, Docker has a vast
    array of networking drivers to cover almost any circumstance that your workloads
    demand. However, for all the use cases that lie outside the default Docker networking
    drivers, Docker supports third-party custom drivers for almost any networking
    conditions that may arise. Third-party network drivers allow Docker to have flexible
    integrations with various platforms and even across multiple cloud providers.
    In this exercise, we looked at installing and configuring the Weave Net networking
    plugin and creating simple services in a Docker swarm cluster to leverage this
    network.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器化网络概念的强大系统中，Docker拥有广泛的网络驱动程序，几乎可以满足工作负载需求的任何情况。然而，对于所有超出默认Docker网络驱动程序范围的用例，Docker支持第三方自定义驱动程序，几乎可以满足可能出现的任何网络条件。第三方网络驱动程序使Docker能够灵活地与各种平台甚至跨多个云提供商进行集成。在这个练习中，我们看了安装和配置Weave
    Net网络插件，并在Docker集群中创建简单服务以利用这个网络。
- en: In the following activity, you will apply what you have learned in this chapter,
    using the various Docker network drivers, to deploy a multi-container infrastructure
    solution. These containers will communicate using different Docker networking
    drivers on the same hosts and even across multiple hosts in a Docker swarm configuration.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的活动中，您将应用本章学到的知识，使用各种Docker网络驱动程序部署多容器基础架构解决方案。这些容器将使用不同的Docker网络驱动程序在同一台主机甚至跨多台主机在Docker集群配置中进行通信。
- en: 'Activity 6.01: Leveraging Docker Network Drivers'
  id: totrans-563
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动6.01：利用Docker网络驱动程序
- en: Earlier in the chapter, we looked at the various types of Docker network drivers
    and how they all function in different ways to bring various degrees of networking
    capability to deliver functionality in your container environment. In this activity,
    you are going to deploy an example container from the Panoramic Trekking application
    in a Docker `bridge` network. You will then deploy a secondary container in `host`
    networking mode that will serve as a monitoring server and will be able to use
    `curl` to verify that the application is running as expected.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们看了各种类型的Docker网络驱动程序以及它们以不同的方式运行，为您的容器环境提供各种程度的网络功能。在这个活动中，您将在Docker“桥接”网络中部署Panoramic
    Trekking应用程序的示例容器。然后，您将以“主机”网络模式部署一个辅助容器，该容器将作为监控服务器，并能够使用“curl”来验证应用程序是否按预期运行。
- en: 'Perform the following steps to complete this activity:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此活动：
- en: Create a custom Docker `bridge` network with a custom subnet and gateway IP.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个自定义的Docker“桥接”网络，具有自定义子网和网关IP。
- en: Deploy an NGINX web server called `webserver1` in that `bridge` network, exposing
    forwarding port `80` on the container to port `8080` on the host.
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“桥接”网络中部署一个名为“webserver1”的NGINX web服务器，将容器上的转发端口“80”暴露到主机上的端口“8080”。
- en: Deploy an Alpine Linux container in `host` networking mode, which will serve
    as a monitoring container.
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“主机”网络模式下部署一个Alpine Linux容器，该容器将作为监控容器。
- en: Use the Alpine Linux container to `curl` the NGINX web server and get a response.
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Alpine Linux容器对NGINX web服务器进行“curl”操作并获得响应。
- en: '**Expected output:**'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '**预期输出：**'
- en: 'When you connect to both the forwarded port `8080` and the IP address of the
    `webserver1` container directly on port `80` upon completion of the activity,
    you should get the following output:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在活动完成后连接到转发端口“8080”和“webserver1”容器的IP地址上的端口“80”，您应该会得到以下输出：
- en: '![Figure 6.26: Accessing the NGINX web server from the IP address of the container
    instance'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.26：从容器实例的IP地址访问NGINX web服务器'
- en: '](image/B15021_06_26.jpg)'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_06_26.jpg)'
- en: 'Figure 6.26: Accessing the NGINX web server from the IP address of the container
    instance'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.26：从容器实例的IP地址访问NGINX Web服务器
- en: Note
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor331).
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以通过[此链接](B15021_Solution_Final_SMP.xhtml#_idTextAnchor331)找到。
- en: In the next activity, we will look at how Docker `overlay` networking can be
    leveraged to provide horizontal scalability for our Panoramic Trekking application.
    By deploying Panoramic Trekking across multiple hosts, we can ensure reliability
    and durability, and make use of system resources from more than one node in our
    environment.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，我们将看看如何利用Docker `overlay`网络为我们的全景徒步应用程序提供水平可扩展性。通过在多个主机上部署全景徒步，我们可以确保可靠性和耐久性，并利用环境中多个节点的系统资源。
- en: 'Activity 6.02: Overlay Networking in Action'
  id: totrans-578
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动6.02：`overlay`网络实战
- en: In this chapter, you have seen how powerful `overlay` networking is when deploying
    multiple containers between cluster hosts with direct network connectivity between
    them. In this activity, you will revisit the two-node Docker swarm cluster and
    create services from the Panoramic Trekking application that will connect using
    Docker DNS between two hosts. In this scenario, different microservices will be
    running on different Docker swarm hosts but will still be able to leverage the
    Docker `overlay` network to directly communicate with each other.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经看到了在集群主机之间部署多个容器时，`overlay`网络是多么强大，它们之间可以直接进行网络连接。在本活动中，您将重新访问双节点Docker
    swarm集群，并从全景徒步应用程序创建服务，这些服务将使用Docker DNS在两个主机之间进行连接。在这种情况下，不同的微服务将在不同的Docker swarm主机上运行，但仍然能够利用Docker
    `overlay`网络直接相互通信。
- en: 'To complete this activity successfully, perform the following steps:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功完成此活动，请执行以下步骤：
- en: A Docker `overlay` network using a custom subnet and gateway
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自定义子网和网关的Docker `overlay`网络
- en: One application Docker swarm service called `trekking-app` using an Alpine Linux
    container
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个名为`trekking-app`的应用程序Docker swarm服务，使用Alpine Linux容器
- en: One database Docker swarm service called `database-app` using a PostgreSQL 12
    container (extra credit to supply default credentials)
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个名为`database-app`的数据库Docker swarm服务，使用PostgreSQL 12容器（额外学分提供默认凭据）
- en: Prove that the `trekking-app` service can communicate with the `database-app`
    service using `overlay` networking
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明`trekking-app`服务可以使用`overlay`网络与`database-app`服务通信
- en: '**Expected Output:**'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '**预期输出:**'
- en: 'The `trekking-app` service should be able to communicate with the `database-app`
    service, which can be verified by ICMP replies such as the following:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '`trekking-app`服务应能够与`database-app`服务通信，可以通过ICMP回复进行验证，例如：'
- en: '[PRE157]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Note
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor333).
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以通过[此链接](B15021_Solution_Final_SMP.xhtml#_idTextAnchor333)找到。
- en: Summary
  id: totrans-590
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the many facets of networking in relation to microservices
    and Docker containers. Docker comes equipped with numerous drivers and configuration
    options that users can use to tune the way their container networking works in
    almost any environment. By deploying the correct networks and the correct drivers,
    powerful service mesh networks can quickly be spun up to enable container-to-container
    access without egressing any physical Docker hosts. Containers can even be created
    that will bind to the host networking fabric to take advantage of the underlying
    network infrastructure.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了与微服务和Docker容器相关的许多网络方面。Docker配备了许多驱动程序和配置选项，用户可以使用这些选项来调整他们的容器网络在几乎任何环境中的工作方式。通过部署正确的网络和正确的驱动程序，可以快速地建立强大的服务网格网络，实现容器之间的访问，而无需从任何物理Docker主机出口。甚至可以创建绑定到主机网络结构以利用底层网络基础设施的容器。
- en: Quite arguably the most powerful network feature that can be enabled in Docker
    is the ability to create networks across clusters of Docker hosts. This can allow
    us to quickly create and deploy horizontal scaling applications between hosts
    for high availability and redundancy. By leveraging the underlay network, `overlay`
    networks within swarm clusters allow containers to directly contact containers
    running on other cluster hosts by taking advantage of the powerful Docker DNS
    system.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker中可以启用的最强大的网络功能可能是能够在Docker主机集群之间创建网络的能力。这可以让我们快速地在主机之间创建和部署水平扩展的应用程序，以实现高可用性和冗余。通过利用底层网络，在集群中的“覆盖”网络允许容器利用强大的Docker
    DNS系统直接联系其他集群主机上运行的容器。
- en: 'In the next chapter, we will look at the next pillar of a powerful containerized
    infrastructure: storage. By understanding how container storage can be utilized
    for stateful applications, extremely powerful solutions can be architected that
    involve not only containerized stateless applications, but containerized database
    services that can be deployed, scaled, and optimized as easily as other containers
    across your infrastructure.'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看强大的容器化基础设施的下一个支柱：存储。通过了解容器存储如何用于有状态的应用程序，可以设计出非常强大的解决方案，不仅涉及容器化的无状态应用程序，还涉及可以像其他容器一样轻松部署、扩展和优化的容器化数据库服务。
