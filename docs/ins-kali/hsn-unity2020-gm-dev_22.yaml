- en: '*Chapter 22*: Augmented Reality in Unity'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第22章*：Unity中的增强现实'
- en: Nowadays, new technologies expand the fields of application of Unity, from gaming
    to all kinds of software, such as simulations, training, apps, and so on. In the
    latest versions of Unity, we saw lots of improvements in the field of **augmented
    reality (AR)**, which allows us to add a layer of virtuality on top of our reality,
    thereby augmenting what our device can perceive to create games that rely on real-world
    data, such as the camera's image, our real-world position, and the current weather.
    This can also be applied to work environments, such as when viewing the building
    map or checking the electrical ducts inside a wall. Welcome to the extra section
    of this book, where we are going to discuss how to create AR applications using
    Unity's AR Foundation package.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，新技术扩展了Unity的应用领域，从游戏到各种软件，比如模拟、培训、应用等等。在Unity的最新版本中，我们看到了在**增强现实（AR）**领域的许多改进，这使我们能够在现实之上添加一层虚拟，从而增强我们的设备可以感知的内容，从而创建依赖于真实世界数据的游戏，比如摄像头的图像、我们的真实位置和当前的天气。这也可以应用于工作环境，比如查看建筑地图或检查墙内的电气管道。欢迎来到本书的额外部分，在这里我们将讨论如何使用Unity的AR
    Foundation包创建AR应用程序。
- en: 'In this chapter, we will examine the following AR Foundation concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下AR Foundation概念：
- en: Using AR Foundation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AR Foundation
- en: Building for mobile devices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为移动设备构建
- en: Creating a simple AR game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的AR游戏
- en: By the end of this chapter, you will be able to create AR apps using AR Foundation,
    and will have a fully functional game that uses its framework so that you can
    test the framework's capabilities.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够使用AR Foundation创建AR应用程序，并且将拥有一个完全功能的游戏，使用其框架，以便你可以测试框架的能力。
- en: Let's start by exploring the AR Foundation framework.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探索AR Foundation框架。
- en: Using AR Foundation
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AR Foundation
- en: 'When it comes to AR, Unity has two main tools to create applications: Vuforia
    and AR Foundation. Vuforia is an AR framework that can work on almost any phone
    and contains all the needed features for basic AR apps, but with a paid subscription
    for more advanced features. On the other hand, the completely free AR Foundation
    framework supports the latest AR native features of our devices but is supported
    only by newer devices. Picking between one or the other depends a lot on the type
    of project you''re going to build and the target audience. However, since this
    book aims to discuss the latest Unity features, we are going to explore how to
    use AR Foundation to create our first AR app for detecting the positions of images
    and surfaces in the real world. So, we''ll start by exploring its API.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在AR方面，Unity有两个主要工具来创建应用程序：Vuforia和AR Foundation。Vuforia是一个几乎可以在任何手机上工作的AR框架，并且包含了基本AR应用程序所需的所有功能，但高级功能需要付费订阅。另一方面，完全免费的AR
    Foundation框架支持我们设备的最新AR本地功能，但只受新设备支持。选择其中一个取决于你要构建的项目类型和目标受众。然而，由于本书旨在讨论最新的Unity功能，我们将探讨如何使用AR
    Foundation来创建我们的第一个AR应用程序，以便检测现实世界中图像和表面的位置。因此，我们将开始探索其API。
- en: 'In this section, we will examine the following AR Foundation concepts:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究以下AR Foundation概念：
- en: Creating an AR Foundation project
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个AR Foundation项目
- en: Using tracking features
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用跟踪功能
- en: Let's start by discussing how to prepare our project so that it can run AR Foundation
    apps.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从讨论如何准备我们的项目，以便它可以运行AR Foundation应用程序开始。
- en: Creating an AR Foundation project
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个AR Foundation项目
- en: Something to consider when creating AR projects is that we will not only change
    the way we code our game, but also the game design aspect. AR apps have differences,
    especially in the way the user interacts, and also limitations, such as the user
    being in control of the camera all the time. We cannot simply port an existing
    game to AR without changing the very core experience of the game. That's why,
    in this chapter, we are going to work on a brand new project; it would be too
    difficult to change the game we've created so far so that it works well in AR.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建AR项目时需要考虑的一些事情是，我们不仅会改变我们编写游戏的方式，还会改变游戏设计方面。AR应用程序有差异，特别是用户交互的方式，还有一些限制，比如用户始终控制摄像头。我们不能简单地将现有游戏移植到AR中而不改变游戏的核心体验。这就是为什么在本章中，我们将致力于一个全新的项目；到目前为止，我们创建的游戏要想在AR中运行良好，改变它将会太困难了。
- en: 'In our case, we are going to create a game where the user controls a player
    moving a "marker", a physical image you can print that will allow our app to recognize
    where the player is in the real world. We will be able to move the player while
    moving that image, and this virtual player will automatically shoot at the nearest
    Enemy. Those enemies will spawn from certain spawn points that the user will need
    to place in different parts of the home. As an example, we can put two spawn points
    on the walls and place our player marker in a table in the middle of the room
    so that the enemies will go toward them. In the following image, you can see a
    preview of what the game will look like:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将创建一个游戏，用户控制一个移动“标记”的玩家，这是一个可以打印的物理图像，可以让我们的应用程序识别玩家在现实世界中的位置。我们将能够在移动图像的同时移动玩家，并且这个虚拟玩家将自动向最近的敌人射击。这些敌人将从用户需要放置在家中不同部分的特定生成点生成。例如，我们可以在墙上放置两个生成点，并将我们的玩家标记放在房间中间的桌子上，这样敌人就会朝着它们走去。在下面的图片中，你可以看到游戏将会是什么样子的预览：
- en: '![Figure 22.1 – Finished game. The Cylinder is an Enemy Spawner, the Capsule
    is the Enemy, and the Cube is the Player. These are positioned in a marker image
    displayed by the cellphone'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.1 - 完成的游戏。圆柱体是敌人生成器，胶囊体是敌人，立方体是玩家。这些都被手机显示的标记图像定位'
- en: '](img/Figure_22.01_B14199.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.01_B14199.jpg)'
- en: Figure 22.1 – Finished game. The Cylinder is an Enemy Spawner, the Capsule is
    the Enemy, and the Cube is the Player. These are positioned in a marker image
    displayed by the cellphone
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.1 - 完成的游戏。圆柱体是敌人生成器，胶囊体是敌人，立方体是玩家。这些都被手机显示的标记图像定位
- en: 'We''ll start creating a new URP-based project in the same manner we created
    our first game. Something to consider is that AR Foundation works with other pipelines,
    including built-in ones, in case you want to use it in already existing projects.
    If you don''t remember how to create a project, please refer to [*Chapter 2*](B14199_02_Final_SK_ePub.xhtml#_idTextAnchor040),
    *Setting Up Unity*. Once you''re in your new blank project, install the AR Foundation
    package from the Package Manager, just like we''ve installed other packages previously;
    that is, from **Window | Package Manager**. Remember to set the Package Manager
    so that it shows all packages, not only the ones in the project (the **Packages**
    button at the top-left part of the window needs to be set to **Unity Registry**).
    At the time of writing this book, the latest version is 4.0.2\. Remember you can
    use the **See other Versions** button that appears clicking the triangle at the
    left of the package under **Package Item** in the list to display other version
    options. If you find a newer version than mine, you can try using that one, but
    as usual, if something works differently to what we want, please install this
    specific version:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以与创建第一个游戏相同的方式开始创建基于URP的新项目。需要考虑的是，AR Foundation可以与其他管道一起使用，包括内置管道，以防您想在已有项目中使用它。如果您不记得如何创建项目，请参考[*第2章*]（B14199_02_Final_SK_ePub.xhtml#_idTextAnchor040），*设置Unity*。一旦进入新的空白项目中，就像我们之前安装其他软件包一样，从软件包管理器中安装AR
    Foundation软件包；也就是说，从**窗口|软件包管理器**。记得设置软件包管理器，以便显示所有软件包，而不仅仅是项目中的软件包（窗口左上角的**软件包**按钮需要设置为**Unity
    Registry**）。在撰写本书时，最新版本是4.0.2。请记住，您可以使用**查看其他版本**按钮，该按钮出现在列表中**软件包项**下的软件包左侧的三角形上，以显示其他版本选项。如果您找到比我的更新版本，可以尝试使用该版本，但通常情况下，如果某些功能与我们想要的不同，请安装此特定版本：
- en: '![Figure 22.2 – Installing AR Foundation'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.2 - 安装AR Foundation'
- en: '](img/Figure_22.2_B14199.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.2_B14199.jpg)'
- en: Figure 22.2 – Installing AR Foundation
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.2 - 安装AR Foundation
- en: Before we install any other needed packages, now is a good moment to discuss
    some core ideas of the AR Foundation framework. This package, by itself, does
    nothing; it defines a series of AR features that mobile devices offer, such as
    image tracking, cloud points, and object tracking, but the actual implementation
    of how to do that is contained in the **Provider** packages, such as AR Kit and
    AR Core XR plugins. This is designed like this because, depending on the target
    device you want to work with, the way those features are implemented changes.
    As an example, in iOS, Unity implements those features using AR Kit, while in
    Android, it uses AR Core; they are platform-specific frameworks.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装其他所需软件包之前，现在是讨论AR Foundation框架的一些核心思想的好时机。这个软件包本身什么也不做；它定义了移动设备提供的一系列AR功能，比如图像跟踪、云点和对象跟踪，但如何实现这些功能的实际实现包含在**提供程序**软件包中，比如AR
    Kit和AR Core XR插件。这样设计是因为，根据您想要使用的目标设备，这些功能的实现方式会发生变化。例如，在iOS中，Unity使用AR Kit来实现这些功能，而在Android中，它使用AR
    Core；它们是特定于平台的框架。
- en: 'Something to consider here is that not all iOS or Android devices support AR
    Foundation apps. You might find an updated list of supported devices when searching
    for AR Core and AR Kit supported devices on the internet. At the time of writing,
    the following links provide the supported devices lists:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的是，并非所有iOS或Android设备都支持AR Foundation应用程序。在互联网上搜索AR Core和AR Kit支持的设备时，您可能会找到受支持设备的更新列表。撰写本文时，以下链接提供了受支持设备列表：
- en: 'iOS: [https://www.apple.com/lae/ios/augmented-reality/](https://www.apple.com/lae/ios/augmented-reality/)
    (at the bottom of the page)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS：[https://www.apple.com/lae/ios/augmented-reality/](https://www.apple.com/lae/ios/augmented-reality/)（页面底部）
- en: 'Android: [https://developers.google.com/ar/discover/supported-devices](https://developers.google.com/ar/discover/supported-devices)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android：[https://developers.google.com/ar/discover/supported-devices](https://developers.google.com/ar/discover/supported-devices)
- en: 'Also, there isn''t a PC Provider package, so the only way to test AR Foundation
    apps so far is directly on the device, but testing tools are going to be released
    soon. In my case, I will be creating an app for iOS, so aside from the **AR Foundation**
    package, I need to install the **ARKit XR** plugin. However, if you want to develop
    for Android, install the **ARCore XR** plugin instead (or both if you''re targeting
    both platforms). I will be using the 4.0.2 version of the ARKit package, but at
    the moment of writing this book, the ARCore recommended version is 4.0.4 Usually,
    the versions of the **AR Foundation** and **Provider** packages match, but apply
    the same logic as when you picked the **AR Foundation** version. In the following
    screenshot, you can see the **ARKit** package in the Package Manager:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，没有PC提供程序包，因此迄今为止测试AR Foundation应用程序的唯一方法是直接在设备上进行测试，但测试工具即将发布。在我的情况下，我将为iOS创建一个应用程序，因此除了**AR
    Foundation**软件包外，我还需要安装**ARKit XR**插件。但是，如果您想为Android开发，请安装**ARCore XR**插件（如果您针对两个平台，请安装两者）。我将使用ARKit软件包的4.0.2版本，但在撰写本书时，ARCore推荐的版本是4.0.4通常，**AR
    Foundation**和**提供程序**软件包的版本匹配，但应用与选择**AR Foundation**版本时相同的逻辑。在下面的屏幕截图中，您可以看到软件包管理器中的**ARKit**软件包：
- en: '![Figure 22.3 – Installing the platform-specific AR provider package'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.3 - 安装特定于平台的AR提供程序包
- en: '](img/Figure_22.3_B14199.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.3_B14199.jpg)'
- en: Figure 22.3 – Installing the platform-specific AR provider package
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.3 - 安装特定于平台的AR提供程序包
- en: 'Now that we have the needed plugins, we need to prepare a scene for AR, as
    follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们有了所需的插件，我们需要为AR准备一个场景，如下所示： '
- en: Create a new Scene in **File | New Scene**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**文件|新场景**中创建一个新场景。
- en: Delete **Main Camera**; we are going to use a different one.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除**主相机**；我们将使用另一个。
- en: In the **GameObject | XR** menu, create an **AR Session** Object.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**游戏对象|XR**菜单中，创建一个**AR会话**对象。
- en: In the same menu, create an **AR Session Origin** Object that has a **Camera**
    inside it:![Figure 22.4 – Creating the Session objects
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个菜单中，创建一个**AR会话起源**对象，其中包含一个**相机**：![图22.4 - 创建会话对象
- en: '](img/Figure_22.04_B14199.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.04_B14199.jpg)'
- en: Figure 22.4 – Creating the Session objects
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.4 - 创建会话对象
- en: 'Your hierarchy should look as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的层次结构应如下所示：
- en: '![Figure 22.5 – Starter ARSCcene'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.5 - 起始ARSCcene'
- en: '](img/Figure_22.05_B14199.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.05_B14199.jpg)'
- en: Figure 22.5 – Starter ARSCcene
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.5 - 起始ARSCcene
- en: The **AR Session** object will be responsible for initializing AR Framework
    and will handle all the update logic for the AR systems. The **AR Session Origin**
    object will allow the framework to locate tracked objects such as images and point
    clouds in a relative position to the scene. The devices inform the positions of
    tracked objects relative to what the device considers "the origin". This is usually
    the first area of your house you were pointing at when the app started detecting
    objects, so the AR Session Origin object will represent that area. Finally, you
    can check the camera inside the origin, which contains some extra components,
    with the most important being **AR Pose** **Driver**, which will make your **Camera**
    object move along with your device. Since the device's position is relative to
    the Session Origin object's point, the camera needs to be inside the origin object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR会话**对象将负责初始化AR框架，并处理AR系统的所有更新逻辑。**AR会话原点**对象将允许框架相对于场景定位跟踪对象，如图像和点云。设备会通知跟踪对象相对于设备认为的“原点”的位置。这通常是您在应用程序开始检测对象时指向的房屋的第一个区域，因此AR会话原点对象将代表该区域。最后，您可以检查原点内的相机，其中包含一些额外的组件，其中最重要的是**AR姿势驱动器**，它将使您的**相机**对象随着您的设备移动。由于设备的位置是相对于会话原点对象的点，因此相机需要在原点对象内部。'
- en: 'One extra step in case you are working in a URP project (our case) is that
    you need to set up the render pipeline so that it supports rendering the camera
    image in the app. To do that, go to the `Settings` folder that was generated when
    we created the project, look for the `Forward Renderer` file, and select it. In
    the **Renderer Features** list, click the **Add renderer feature** button and
    select **AR Background Renderer Feature**. Consider that this option might be
    unavailable if you are working on versions older than 4.0.0 of the AR Foundation
    and Provider plugins. In the following screenshot, you can see what the Forward
    Renderer asset should look like:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在URP项目（我们的情况）中的一个额外步骤是，您需要设置渲染管道，以便支持在应用程序中渲染相机图像。为此，请转到创建项目时生成的`Settings`文件夹，查找`Forward
    Renderer`文件，并选择它。在**Renderer Features**列表中，单击**添加渲染器功能**按钮，然后选择**AR背景渲染器功能**。请注意，如果您使用的是早于AR
    Foundation和Provider插件4.0.0版本的版本，则此选项可能不可用。在以下截图中，您可以看到前向渲染器资产应该是什么样子的：
- en: '![Figure 22.6 – Adding support for URP'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.6 - 添加对URP的支持'
- en: '](img/Figure_22.06_B14199.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.06_B14199.jpg)'
- en: Figure 22.6 – Adding support for URP
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.6 - 添加对URP的支持
- en: And that's all! We are ready to start exploring the AR Foundation components
    so that we can implement tracking features.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们已经准备好开始探索AR Foundation组件，以便我们可以实现跟踪功能。
- en: Using tracking features
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用跟踪功能
- en: 'For our project, we are going to need two of the most common tracking features
    in AR (but not the only ones): image recognition and plane detection. The first
    one consists of detecting the position in the real world of a specific image so
    that we can place digital objects on top of it, such as the player. The second
    one, plane detection, consists of recognizing real-life surfaces, such as floors,
    tables, and walls, so that we have a reference of where we can put objects such
    as the enemies'' spawn points. Only horizontal and vertical surfaces are recognized
    (just vertical surfaces on some devices).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们将需要AR中最常见的两种跟踪功能（但不是唯一的）：图像识别和平面检测。第一种是检测特定图像在现实世界中的位置，以便我们可以将数字对象放在其上，例如玩家。第二种，平面检测，是识别现实生活中的表面，如地板、桌子和墙壁，以便我们知道可以放置对象的位置，例如敌人的生成点。只有水平和垂直表面被识别（某些设备上只有垂直表面）。
- en: 'The first thing we need to do is tell our app which images it needs to detect,
    as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是告诉我们的应用程序它需要检测哪些图像，如下所示：
- en: Add an image to the project that you can print or display in a cellphone. Having
    a way to display the image in the real world is necessary to test this. In this
    case, I will use the following image:![Figure 22.7 – Image to track
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目添加一个图像，您可以打印或在手机上显示。有一种在现实世界中显示图像的方式是必要的来测试这一点。在这种情况下，我将使用以下图像：![图22.7 -
    要跟踪的图像
- en: '](img/Figure_22.07_B14199.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.07_B14199.jpg)'
- en: Figure 22.7 – Image to track
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.7 - 要跟踪的图像
- en: Important Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Try to get an image that contains as many features as you can. This means an
    image with lots of little details, such as contrasts, sharp corners, and so on.
    Those are what our AR systems use to detect it; the more detail, the better the
    recognition. In our case, the Unity logo we are using doesn't actually have too
    many details, but there's enough contrast (just black and white) and sharp corners
    for the system to recognize it. If your device has trouble detecting it, try other
    images (the classic QR code might help).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量获取包含尽可能多特征的图像。这意味着图像具有许多细节，如对比度、锐利的角落等。这些是我们的AR系统用来检测的；细节越多，识别就越好。在我们的情况下，我们使用的Unity标志实际上并没有太多细节，但有足够的对比度（只是黑白）和锐利的角落，以便系统识别它。如果您的设备在检测时出现问题，请尝试其他图像（经典的QR码可能会有所帮助）。
- en: Consider that some devices might have trouble with certain images, such as the
    image suggested in this book. If this generates issues when testing, please try
    using another one. You will be testing this on your device in the upcoming sections
    of this chapter, so just keep this in mind.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，某些设备可能会对某些图像（例如本书中建议的图像）产生问题。如果在测试时出现问题，请尝试使用其他图像。您将在本章的后续部分在您的设备上测试这一点，所以请记住这一点。
- en: Create a Reference Image Library, an asset containing all the images we wish
    our app to recognize, by clicking the **+** button in **Project Panel** and selecting
    **XR** | **Reference Image Library**:![Figure 22.8 – Creating a Reference Image
    Library
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击**Project Panel**中的**+**按钮并选择**XR** | **Reference Image Library**来创建一个包含我们希望应用程序识别的所有图像的资产，创建一个参考图像库：![图22.8
    – 创建参考图像库
- en: '](img/Figure_22.08_B14199.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.08_B14199.jpg)'
- en: Figure 22.8 – Creating a Reference Image Library
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.8 – 创建参考图像库
- en: Select the library asset and click the **Add Image** button to add a new image
    to the library.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择库资产并单击**添加图像**按钮以向库中添加新图像。
- en: Drag the texture to the texture slot (the one that says **None**).
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将纹理拖到纹理槽（标有**None**的槽）。
- en: 'Turn **Specify Size** on and set **Physical Size** to the size that your image
    will be in real life, in meters. Try to be accurate here; on some devices, not
    having this value right might result in the image not being tracked:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**Specify Size**并将**Physical Size**设置为图像在现实生活中的大小，以米为单位。在这里尽量准确；在某些设备上，如果这个值不正确，可能会导致图像无法被跟踪：
- en: '![Figure 22.9 – Adding an image to be recognized'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.9 – 添加要识别的图像'
- en: '](img/Figure_22.09_B14199.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.09_B14199.jpg)'
- en: Figure 22.9 – Adding an image to be recognized
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.9 – 添加要识别的图像
- en: 'Now that we''ve specified the images to be detected, let''s test this by placing
    a cube on top of the real-life image:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经指定了要检测的图像，让我们通过在真实世界的图像顶部放置一个立方体来测试这一点：
- en: Create a prefab of a cube and add the **AR Tracked Image** component to it.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个立方体的预制体并向其添加**AR Tracked Image**组件。
- en: Add the **AR Tracked Image Manager** component to the **AR Session Origin**
    object. This will be responsible for detecting images and creating objects in
    its position.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**AR Tracked Image Manager**组件添加到**AR Session Origin**对象中。这将负责检测图像并在其位置创建对象。
- en: Drag the **Image Library** asset to the **Serialized Library** property of the
    component to specify the images to recognize.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Image Library**资产拖到组件的**Serialized Library**属性中，以指定要识别的图像。
- en: 'Drag the **Cube** prefab to the **Tracked Image** Prefab property of the component:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Cube**预制体拖到组件的**Tracked Image** Prefab属性中：
- en: '![Figure 22.10 – Setting up the Tracked Image Manager'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.10 – 设置Tracked Image Manager'
- en: '](img/Figure_22.10_B14199.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.10_B14199.jpg)'
- en: Figure 22.10 – Setting up the Tracked Image Manager
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.10 – 设置Tracked Image Manager
- en: 'And that''s all! We will see a cube spawning in the same position the image
    is located at in the real world. Remember that you need to test this in the device,
    which we will do in the next section, so for now, let''s keep coding our test
    app:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们将看到一个立方体在现实世界中与图像相同的位置生成。请记住，您需要在设备上测试这一点，我们将在下一节中进行测试，所以现在让我们继续编写我们的测试应用程序：
- en: '![Figure 22.11 – Cube located on top of the image being displayed by the cellphone'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.11 – 放置在手机显示的图像顶部的立方体'
- en: '](img/Figure_22.11_B14199.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.11_B14199.jpg)'
- en: Figure 22.11 – Cube located on top of the image being displayed by the cellphone
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.11 – 放置在手机显示的图像顶部的立方体
- en: 'Let''s also prepare our app so that it can detect and display the plane surfaces
    the camera has recognized. This is simply done by adding the **AR Plane Manager**
    component to the **AR Session Origin** object:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还要准备我们的应用程序，以便它可以检测和显示相机识别的平面表面。只需将**AR Plane Manager**组件添加到**AR Session Origin**对象即可：
- en: '![Figure 22.12 – Adding the AR Plane Manager component'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.12 – 添加AR Plane Manager组件'
- en: '](img/Figure_22.12_B14199.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.12_B14199.jpg)'
- en: Figure 22.12 – Adding the AR Plane Manager component
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.12 – 添加AR Plane Manager组件
- en: 'This component will detect surface planes over our house as we move the camera
    over it. It can take a while to detect them, so it''s important to visualize the
    detected areas to get feedback about this to ensure it''s working properly. We
    can manually get information about the plane from a component reference to the
    AR Plane Manager, but luckily, Unity allows us to visualize planes easily. Let''s
    take a look:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在房子上移动相机时，这个组件将检测表面平面。检测它们可能需要一段时间，所以重要的是要可视化检测到的区域，以确保它正常工作。我们可以通过组件引用手动获取有关平面的信息，但幸运的是，Unity允许我们轻松可视化平面。让我们来看一下：
- en: Create a prefab of a plane, first by creating the plane in **GameObject | 3D
    Object | Plane**.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个平面的预制体，首先在**GameObject | 3D Object | Plane**中创建平面。
- en: Add a **Line Renderer** to it. This will allow us to draw a line over the edges
    of the detected areas.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Line Renderer**。这将允许我们在检测到的区域边缘上画一条线。
- en: Set the `0.01`, the **Color** property to black, and uncheck **Use World Space**:![Figure
    22.13 – Setting the Line Renderer
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`0.01`，**Color**属性设置为黑色，并取消选中**Use World Space**：![图22.13 – 设置Line Renderer
- en: '](img/Figure_22.13_B14199.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.13_B14199.jpg)'
- en: Figure 22.13 – Setting the Line Renderer
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.13 – 设置Line Renderer
- en: Remember to create a material for **Line Renderer** with the proper shader and
    set it as the material of the renderer:![Figure 22.14 – Creating the Line Renderer
    Material
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得为**Line Renderer**创建一个合适的着色器材质，并将其设置为渲染器的材质：![图22.14 – 创建Line Renderer材质
- en: '](img/Figure_22.14_B14199.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.14_B14199.jpg)'
- en: Figure 22.14 – Creating the Line Renderer Material
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.14 – 创建Line Renderer材质
- en: Also, create a transparent material and use it in the **MeshRenderer** plane.
    We want to see through it so that we can easily see the real surface beneath:![Figure
    22.15 – Material for the detected plane
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，创建一个透明材质并在**MeshRenderer**平面中使用。我们希望能透过它看到真实表面，以便轻松地看到下面的真实表面：![图22.15 –
    用于检测平面的材质
- en: '](img/Figure_22.15_B14199.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.15_B14199.jpg)'
- en: Figure 22.15 – Material for the detected plane
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.15 – 用于检测平面的材质
- en: Add the **AR Plane** and **AR Plane Mesh Visualizer** components to the **Plane**
    prefab.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向**Plane**预制体添加**AR Plane**和**AR Plane Mesh Visualizer**组件。
- en: 'Drag the prefab to the **Plane Prefab** property of the **AR Plane Manager**
    component of the **AR Session Origin** object:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将预制体拖动到**AR Plane Manager**组件的**Plane Prefab**属性中的**AR Session Origin**对象：
- en: '![Figure 22.16 – Setting the plane visualization prefab'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.16 – 设置平面可视化预制体'
- en: '](img/Figure_22.16_B14199.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.16_B14199.jpg)'
- en: Figure 22.16 – Setting the plane visualization prefab
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.16 – 设置平面可视化预制件
- en: Now, we have a way to see the planes, but seeing them is not the only thing
    we can do (sometimes, we don't even want them to be visible). The real power of
    planes resides on placing virtual objects on top of real-life surfaces, tapping
    in a specific plane area, and getting its real-life position. We can access the
    plane data using the AR Plane Manager or by accessing the AR Plane component of
    our visualization planes, but something easier is to use the **AR Raycast Manager**
    component.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一种方法来看到平面，但看到它们并不是我们唯一能做的事情（有时，我们甚至不希望它们可见）。平面的真正力量在于将虚拟对象放置在现实表面上，点击特定平面区域，并获取其现实位置。我们可以使用AR
    Plane Manager或访问可视化平面的AR Plane组件来访问平面数据，但更简单的方法是使用**AR Raycast Manager**组件。
- en: 'The `Physics.Raycast` function of the Unity Physics system, which, as you may
    recall, is used to create imaginary rays that start from one position and go toward
    a specified direction in order to make them hit surfaces and detect the exact
    hit point. The version provided by **AR Raycast Manager**, instead of colliding
    with Physics Colliders, collides with tracked objects, mostly Point Clouds (we
    are not using them) and the "Planes" we are tracking. We can test this feature
    by following these steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Unity物理系统的`Physics.Raycast`函数，您可能还记得，用于创建从一个位置开始并朝着指定方向的虚拟射线，以使它们击中表面并检测确切的击中点。由**AR
    Raycast Manager**提供的版本，与物理碰撞体不同，它与跟踪对象发生碰撞，主要是点云（我们不使用它们）和我们正在跟踪的“平面”。我们可以通过以下步骤测试这个功能：
- en: Add the **AR Raycast Manager** component to the **AR Session Origin** object.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**AR Raycast Manager**组件添加到**AR Session Origin**对象中。
- en: Create a custom script called `InstanceOnPlane` in the **AR Session Origin**
    object.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**AR Session Origin**对象中创建一个名为`InstanceOnPlane`的自定义脚本。
- en: In the `ARRaycastManager`. You will need to add the `using UnityEngine.XR.ARFoundation;`
    line to the top of the script for this class to be usable in our script.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ARRaycastManager`中。您需要在脚本顶部添加`using UnityEngine.XR.ARFoundation;`行，以便在我们的脚本中可用。
- en: Create a private field of the `List<ARRaycastHit>` type and instantiate it;
    the Raycast is going to detect every plane our ray hit, not just the first one:![Figure
    22.17 – List to store hits
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`List<ARRaycastHit>`类型的私有字段并实例化它；Raycast将检测我们的射线击中的每个平面，而不仅仅是第一个：![图22.17
    – 存储射线击中的列表
- en: '](img/Figure_22.17_B14199.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.17_B14199.jpg)'
- en: Figure 22.17 – List to store hits
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.17 – 存储射线击中的列表
- en: Under `KeyCode.Mouse0`) is being pressed. In AR apps, the mouse is emulated
    with the device's touch screen (you can also use the `Input.touches` array for
    multi-touch support).
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`KeyCode.Mouse0`下按下。在AR应用中，鼠标是用设备的触摸屏模拟的（您还可以使用`Input.touches`数组来支持多点触控）。
- en: Inside the `if` statement, add another condition for calling the `Raycast` function
    of **AR Raycast Manager**, passing the position of the mouse as the first parameter
    and the list of hits as the second.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`if`语句中，添加另一个条件来调用**AR Raycast Manager**的`Raycast`函数，将鼠标的位置作为第一个参数，将击中列表作为第二个参数。
- en: This will throw a raycast toward the direction the player touches the screen
    and store the hits inside the list we provided. This will return `true` if something
    has been hit, and `false` if not:![Figure 22.18 – Throwing AR raycasts
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将向玩家触摸屏幕的方向投射射线，并将击中的结果存储在我们提供的列表中。如果有东西被击中，它将返回`true`，否则返回`false`：![图22.18
    – 发射AR射线
- en: '](img/Figure_22.18_B14199.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.18_B14199.jpg)'
- en: Figure 22.18 – Throwing AR raycasts
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.18 – 发射AR射线
- en: Add a public field to specify the prefab to instantiate in the place we touched.
    You can just create a Sphere prefab to test this; there's no need to add any special
    component to the prefab here.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个公共字段来指定要在我们触摸的位置实例化的预制件。您可以只创建一个球体预制件来测试这个；这里不需要为预制件添加任何特殊组件。
- en: 'Instantiate the prefab in the **Position** and **Rotation** fields of the **Pose**
    property of the first hit stored in the list. The hits are sorted by distance,
    so the first hit is the closest one. Your final script should look as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表中存储的第一个击中的**Pose**属性的**Position**和**Rotation**字段中实例化预制件。击中是按距离排序的，所以第一个击中是最近的。您的最终脚本应如下所示：
- en: '![Figure 22.19 – Raycaster component'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.19 – 射线投射器组件'
- en: '](img/Figure_22.19_B14199.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.19_B14199.jpg)'
- en: Figure 22.19 – Raycaster component
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.19 – 射线投射器组件
- en: In this section, we learned how to create a new AR project using AR Foundation.
    We discussed how to install and set up the framework, as well as how to detect
    real-life image positions and surfaces, and then how to place objects on top of
    them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用AR Foundation创建新的AR项目。我们讨论了如何安装和设置框架，以及如何检测现实图像的位置和表面，然后如何将对象放置在其上。
- en: As you may have noticed, we never hit play to test this, and sadly at the time
    of writing this book, we cannot test this in the Editor. Instead, we need to test
    this directly on the device. Due to this, in the next section, we are going to
    learn how to do builds for mobile devices such as Android and iOS.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，我们从未点击播放按钮来测试这个，遗憾的是，在撰写本书时，我们无法在编辑器中测试这个。相反，我们需要直接在设备上测试这个。因此，在下一节中，我们将学习如何为Android和iOS等移动设备构建。
- en: Building for mobile devices
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为移动设备构建
- en: Unity is a very powerful tool that solves the most common problems in game development
    very easily, and one of them is building the game for several target platforms.
    Now, the Unity part of building our project for such devices is easy to do, but
    each device has its non-Unity-related nuances for installing development builds.
    In order to test our AR app, we need to test it directly in the device. So, let's
    explore how we can make our app run on Android and iOS, the most common mobile
    platforms.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Unity是一个非常强大的工具，可以非常轻松地解决游戏开发中最常见的问题之一，其中之一是为多个目标平台构建游戏。现在，为这些设备构建我们的项目的Unity部分很容易，但是每个设备都有其与Unity无关的细微差别，用于安装开发构建。为了测试我们的AR应用程序，我们需要直接在设备上测试它。因此，让我们探索如何使我们的应用程序在Android和iOS上运行，这是最常见的移动平台。
- en: Before diving into this topic, it is worth mentioning that the following procedures
    change a lot over time, so you will need to find the latest instructions on the
    internet. The Unity Learn portal site ([https://learn.unity.com/tutorial/building-for-mobile](https://learn.unity.com/tutorial/building-for-mobile))
    may be a good alternative in case the instructions in this book fail, but try
    the steps here first.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论这个话题之前，值得一提的是，以下程序随时间变化很大，因此您需要在互联网上找到最新的说明。Unity Learn门户网站（[https://learn.unity.com/tutorial/building-for-mobile](https://learn.unity.com/tutorial/building-for-mobile)）可能是一个很好的选择，如果本书中的说明失败，请先尝试这里的步骤。
- en: 'In this section, we will examine the following mobile building concepts:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究以下移动构建概念：
- en: Building for Android
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Android构建
- en: Building for iOS
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为iOS构建
- en: Let's start by discussing how to build our app so that it runs on Android phones.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论如何构建我们的应用程序，以便在Android手机上运行。
- en: Building for Android
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Android构建
- en: 'Creating Android builds is relatively easy compared to other platforms, so
    we''ll start with Android. Remember that you will need an Android device capable
    of running AR Foundation apps, so please refer to the link regarding Android supported
    devices we mentioned in the first section of this chapter. The first thing we
    need to do is check if we have installed Unity''s Android support and configured
    our project to use that platform. To do that, follow these steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他平台相比，创建Android构建相对容易，因此我们将从Android开始。请记住，您需要一台能够运行AR Foundation应用程序的Android设备，请参考本章第一节中提到的关于Android支持设备的链接。我们需要做的第一件事是检查我们是否已安装了Unity的Android支持并配置了我们的项目以使用该平台。要做到这一点，请按照以下步骤操作：
- en: Close Unity and open **Unity Hub**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭Unity并打开**Unity Hub**。
- en: Go to the **Installs** section and locate the Unity version you are working
    on.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**Installs**部分，找到您正在使用的Unity版本。
- en: Click the three dots button at the top-right corner of the Unity version and
    click **Add Modules**:![Figure 22.20 – Adding modules to the Unity version
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击Unity版本右上角的三个点按钮，然后单击**Add Modules**：![图22.20 – 向Unity版本添加模块
- en: '](img/Figure_22.20_B14199.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.20_B14199.jpg)'
- en: Figure 22.20 – Adding modules to the Unity version
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.20 – 向Unity版本添加模块
- en: Make sure **Android Build Support** and the sub-options that are displayed when
    you click the arrow on its left are checked. If not, check them and click the
    **Done** button at the bottom-right to install them:![Figure 22.21 – Adding Android
    support to Unity
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保勾选**Android Build Support**以及单击左侧箭头时显示的子选项。如果没有，请勾选它们，然后单击右下角的**Done**按钮进行安装：![图22.21
    – 向Unity添加Android支持
- en: '](img/Figure_22.21_B14199.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.21_B14199.jpg)'
- en: Figure 22.21 – Adding Android support to Unity
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.21 – 向Unity添加Android支持
- en: Open the AR project we created in this chapter.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们在本章中创建的AR项目。
- en: Go to **Build Settings** (**File | Build Settings**).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**Build Settings**（**File | Build Settings**）。
- en: 'Select the **Android** platform from the list and click the **Switch Platform**
    button at the bottom-right part of the window:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中选择**Android**平台，然后单击窗口右下角的**Switch Platform**按钮：
- en: '![Figure 22.22 – Switching to Android builds'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.22 – 切换到Android构建'
- en: '](img/Figure_22.22_B14199.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.22_B14199.jpg)'
- en: Figure 22.22 – Switching to Android builds
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.22 – 切换到Android构建
- en: 'To build an app on Android, there are some requirements we need to meet, such
    as having the Java SDK (not the regular Java runtime) and Android SDK installed,
    but luckily, the new versions of Unity take care of that. Just to double-check
    that we have installed the needed dependencies, follow these steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Android上构建应用程序，我们需要满足一些要求，例如安装Java SDK（而不是常规的Java运行时）和Android SDK，但幸运的是，Unity的新版本会处理这些。只是为了再次确认我们已安装所需的依赖项，请按照以下步骤操作：
- en: Go to **Unity Preferences** (**Edit | Preferences** on Windows, **Unity | Preferences**
    on Mac).
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**Unity Preferences**（Windows上为**Edit | Preferences**，Mac上为**Unity | Preferences**）。
- en: Click **External Tools**.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**External Tools**。
- en: 'Check that all the options that say …**Installed with Unity** on the Android
    section are checked. This means we will be using all the dependencies installed
    by Unity:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查Android部分上所有标有**Installed with Unity**的选项是否都已被选中。这意味着我们将使用Unity安装的所有依赖项：
- en: '![Figure 22.23 – Using installed dependencies'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.23 – 使用已安装的依赖项'
- en: '](img/Figure_22.23_B14199.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.23_B14199.jpg)'
- en: Figure 22.23 – Using installed dependencies
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.23 – 使用已安装的依赖项
- en: 'There are some additional Android AR Core-specific related settings to check
    that you can find at [https://developers.google.com/ar/develop/unity-arf/quickstart-android](https://developers.google.com/ar/develop/unity-arf/quickstart-android).
    These can change if you are using newer versions of AR Core. You can apply them
    by following these steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些额外的与Android AR Core相关的设置需要检查，您可以在[https://developers.google.com/ar/develop/unity-arf/quickstart-android](https://developers.google.com/ar/develop/unity-arf/quickstart-android)找到。如果您使用的是更新版本的AR
    Core，这些设置可能会发生变化。您可以按照以下步骤应用它们：
- en: Go to **Player Settings** (**Edit | Project Settings | Player**).
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**Player Settings**（**Edit | Project Settings | Player**）。
- en: Uncheck **Multithreaded Rendering** and **Auto Graphics API**.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中**Multithreaded Rendering**和**Auto Graphics API**。
- en: Remove **Vulkan** from the **Graphics APIs** list.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Graphics APIs**列表中删除**Vulkan**。
- en: 'Set **Minimum API Level** to **Android 7.0**:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Minimum API Level**设置为**Android 7.0**：
- en: '![Figure 22.24 – AR Core settings'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.24 – AR Core设置'
- en: '](img/Figure_22.24_B14199.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.24_B14199.jpg)'
- en: Figure 22.24 – AR Core settings
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.24 – AR Core设置
- en: Now, you can finally build the app from **File | Build Settings** like usual,
    by using the **Build** button. This time, the output will be a single APK file
    that you can install by copying the file to your device and opening it. Remember
    that in order to install APKs that weren't downloaded from the Play Store, you
    need to set your device to allow **Install Unknown Apps**. The location for that
    option varies a lot, depending on the Android version and the device you are using,
    but this option is usually located in the **Security** settings. Some Android
    versions prompt you to view these settings when installing the APK.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以像往常一样从**文件 | 构建设置**构建应用，使用**构建**按钮。这一次，输出将是一个单独的APK文件，您可以通过将文件复制到您的设备并打开它来安装。请记住，为了安装未从Play商店下载的APK文件，您需要设置您的设备允许**安装未知应用**。这个选项的位置可能会有很大不同，取决于您使用的Android版本和设备，但这个选项通常位于**安全**设置中。一些Android版本在安装APK时会提示您查看这些设置。
- en: 'Now, we can copy and install the generated APK build file every time we want
    to create a build. However, we can let Unity do that for us using the **Build
    and Run** button. This option, after building the app, will look for the first
    Android device connected to your computer via USB and will automatically install
    the app. For this to work, we need to prepare our device and PC, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以每次想要创建构建时复制和安装生成的APK构建文件。但是，我们可以让Unity使用**构建和运行**按钮为我们完成这些工作。这个选项在构建应用程序后，会查找通过USB连接到您的计算机的第一个Android设备，并自动安装应用程序。为了使这个工作，我们需要准备好我们的设备和PC，具体操作如下：
- en: 'On your device, find the build number in the **Settings** section of the device,
    whose location, again, can change depending on the device. On my device, it is
    located in the **About Phone | Software Information** section:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的设备上，在**设置**部分找到构建号，其位置可能会根据设备而变化。在我的设备上，它位于**关于手机 | 软件信息**部分：
- en: '![Figure 22.25 – Locating the build number'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.25 – 查找构建号'
- en: '](img/Figure_22.25_B14199.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.25_B14199.jpg)'
- en: Figure 22.25 – Locating the build number
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.25 – 查找构建号
- en: Tap it a few times until the device says you are now a programmer. This procedure
    enables the hidden developer option in the device, which you can now find in the
    settings.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 轻点几次，直到设备显示您现在是一个程序员。这个过程会在设备中启用隐藏的开发者选项，您现在可以在设置中找到它。
- en: Open the developer options and turn on **USB Debugging**, which allows your
    PC to have special permissions on your device. In this case, it allows you to
    install apps.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开开发者选项并打开**USB调试**，这允许您的PC在您的设备上拥有特殊权限。在这种情况下，它允许您安装应用程序。
- en: Install the USB drivers from your phone manufacturer's site onto your computer.
    For example, if you have a Samsung device, search for `Samsung USB Driver`. Also,
    if you can't find that, you can look for `Android USB Driver` to get the generic
    drivers, but that might not work if your device manufacturer has their own. On
    Mac, this step is usually not necessary.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您手机制造商的网站上安装USB驱动程序到您的计算机上。例如，如果您有一部三星设备，请搜索`三星USB驱动程序`。另外，如果您找不到，您可以搜索`Android
    USB驱动程序`来获取通用驱动程序，但如果您的设备制造商有自己的驱动程序，这可能不起作用。在Mac上，这一步通常是不必要的。
- en: Connect your device (or reconnect it if it's already connected). The option
    to **Allow USB Debugging** for your computer will appear on the device. Check
    **Always Allow** and click **OK**:![Figure 22.26 – Allowing USB debugging
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接您的设备（如果已连接，请重新连接）。设备上将出现**允许USB调试**的选项。选择**始终允许**并点击**确定**：![图22.26 – 允许USB调试
- en: '](img/Figure_22.26_B14199.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.26_B14199.jpg)'
- en: Figure 22.26 – Allowing USB debugging
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.26 – 允许USB调试
- en: Accept the **Allow Data** prompt that appears.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受出现的**允许数据**提示。
- en: If these options don't appear, check that the **USB Mode** of your device is
    set to **Debugging** and not any other.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这些选项不出现，请检查您的设备的**USB模式**是否设置为**调试**而不是其他任何模式。
- en: In Unity, build with the **Build and Run** button.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity中，使用**构建和运行**按钮进行构建。
- en: Please remember to try another image if you have trouble detecting the image
    where we instantiate the player (the Unity logo, in my case). This might vary
    a lot, according to your device's capabilities.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在检测我们实例化播放器的图像时遇到问题，请记得尝试另一张图片（在我这里是Unity标志）。这可能会根据您的设备能力而有很大不同。
- en: And that's all! Now that you have your app running on your device, let's learn
    how to do the same for the iOS platform.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在您的应用程序已经在您的设备上运行了，让我们学习如何在iOS平台上做同样的事情。
- en: Building for iOS
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为iOS构建
- en: When developing on iOS, you will need to spend some money. You will need to
    run Xcode, a piece of software you can only run on OS X. Due to this, you'll need
    a device that can run it, such as a MacBook, a Mac mini, and so on. There may
    be ways to run OS X on PCs, but you will need to find this out and try it for
    yourself. Besides spending on a Mac and on an iOS device (iPhone, iPad, iPod,
    and so on), you'll need to pay for an Apple Developer account, which costs 99
    USD per year, even if you are not planning to release the application on the App
    Store (there may be alternatives, but, again, you will need to find them).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS开发时，您需要花一些钱。您需要运行Xcode，这是一款只能在OS X上运行的软件。因此，您需要一台可以运行它的设备，比如MacBook，Mac
    mini等。可能有办法在PC上运行OS X，但您需要自己找出来并尝试。除了在Mac和iOS设备（iPhone，iPad，iPod等）上花钱外，您还需要支付99美元/年的Apple开发者账户费用，即使您不打算在App
    Store上发布应用程序（可能有替代方案，但同样，您需要自己找到）。
- en: 'So, to create an iOS build, you should do the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要创建iOS构建，您应该执行以下操作：
- en: Get a Mac computer.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一台Mac电脑。
- en: Get an iOS device.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个iOS设备。
- en: Create an Apple Developer account (at the time of writing this book, you can
    create one at [https://developer.apple.com/](https://developer.apple.com/)).
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Apple开发者账户（在撰写本书时，您可以在[https://developer.apple.com/](https://developer.apple.com/)上创建一个）。
- en: Install Xcode from the App Store onto your Mac.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从App Store上安装Xcode到您的Mac上。
- en: Check if you have iOS build support in Unity Install on the Unity Hub. Please
    refer to the *Building on Android* section for more information about this step:![Figure
    22.27 – Enabling iOS build support
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查Unity Hub中是否安装了iOS构建支持。有关此步骤的更多信息，请参考*在Android上构建*部分：![图22.27 - 启用iOS构建支持
- en: '](img/Figure_22.27_B14199.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.27_B14199.jpg)'
- en: Figure 22.27 – Enabling iOS build support
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.27 - 启用iOS构建支持
- en: Switch to the iOS platform under **Build Settings**, selecting iOS and clicking
    the **Switch Platform** button:![Figure 22.28 – Switching to iOS build
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**构建设置**下切换到iOS平台，选择iOS并点击**切换平台**按钮：![图22.28 - 切换到iOS构建
- en: '](img/Figure_22.28_B14199.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.28_B14199.jpg)'
- en: Figure 22.28 – Switching to iOS build
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.28 - 切换到iOS构建
- en: Click the **Build** button in the **Build Settings** window and wait.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**构建设置**窗口中的**构建**按钮，然后等待。
- en: 'You will notice that the result of the build process will be a folder containing
    an Xcode project. Unity cannot create the build directly, so it generates a project
    you can open with the Xcode software we mentioned previously. The step you need
    to follow to create a build with the Xcode version being used in this book (11.4.1)
    are as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到构建过程的结果是一个包含Xcode项目的文件夹。Unity无法直接创建构建，因此它生成了一个项目，您可以使用我们之前提到的Xcode软件打开。在本书中使用的Xcode版本（11.4.1）创建构建的步骤如下：
- en: Double-click the `.xcproject` file inside the generated folder:![Figure 22.29
    – Xcode project file
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击生成的文件夹中的`.xcproject`文件：![图22.29 - Xcode项目文件
- en: '](img/Figure_22.29_B14199.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.29_B14199.jpg)'
- en: Figure 22.29 – Xcode project file
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.29 - Xcode项目文件
- en: Go to **Xcode | Preferences**.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**Xcode | 首选项**。
- en: In the **Accounts** tab, hit the **+** button at the bottom-left part of the
    window and log in with the Apple account you registered as an Apple developer:![Figure
    22.30 – Account Settings
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**帐户**选项卡中，点击窗口左下角的**+**按钮，并使用您注册为苹果开发者的苹果帐户登录：![图22.30 - 帐户设置
- en: '](img/Figure_22.30_B14199.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.30_B14199.jpg)'
- en: Figure 22.30 – Account Settings
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.30 - 帐户设置
- en: Connect your device and select it from the top-left part of the window, which
    should now say **Generic iOS device**:![Figure 22.31 – Selecting the device
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接您的设备，并从窗口左上角选择它，现在应该显示**通用iOS设备**：![图22.31 - 选择设备
- en: '](img/Figure_22.31_B14199.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.31_B14199.jpg)'
- en: Figure 22.31 – Selecting the device
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.31 - 选择设备
- en: In the left panel, click the folder icon and then the **Unity-iPhone** settings
    to display the project settings.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧面板中，点击文件夹图标，然后点击**Unity-iPhone**设置以显示项目设置。
- en: From the **TARGETS** list, select **Unity-iPhone** and click on the **Signing
    & Capabilities** tab.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**目标**列表中，选择**Unity-iPhone**，然后点击**签名和功能**选项卡。
- en: In the `Personal Team`:![Figure 22.32 – Selecting a team
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`个人团队`中：![图22.32 - 选择团队
- en: '](img/Figure_22.32_B14199.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.32_B14199.jpg)'
- en: Figure 22.32 – Selecting a team
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.32 - 选择团队
- en: If you see a `com.XXXX.XXXX`), and then click on **Try Again** until it is solved.
    Once you find one that works, set it in Unity (**Bundle Identifier** under **Player
    Settings**) to avoid needing to change it in every build.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果看到一个`com.XXXX.XXXX`），然后点击**重试**，直到问题解决。一旦找到一个有效的，设置在Unity中（**播放器设置**下的**包标识符**）以避免在每次构建中都需要更改它。
- en: Hit the **Play** button at the top-left part of the window and wait for the
    build to complete. You might be prompted to enter your password a couple of times
    in the process, so please do so.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗口左上角的**播放**按钮，等待构建完成。在这个过程中，您可能会被提示输入密码几次，请务必这样做。
- en: When the build completes, remember to unlock the device. A prompt will ask you
    to do that. Note that the process won't continue unless you unlock the phone.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建完成后，请记得解锁设备。会有提示要求您这样做。请注意，除非您解锁手机，否则流程将无法继续。
- en: After completion, you may see an error saying that the app couldn't be launched
    but that it was installed anyway. If you try to open it, it will say you need
    to trust the developer of the app, which you can do by going to the settings of
    your device.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，您可能会看到一个错误，说应用无法启动，但已经安装了。如果尝试打开它，会提示您需要信任应用的开发者，您可以通过转到设备的设置来执行。
- en: From there, go to **General | Device Management** and select the first developer
    in the list.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，转到**通用 | 设备管理**，并选择列表中的第一个开发者。
- en: Click the blue **Trust …** button and then **Trust**.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击蓝色的**信任...**按钮，然后**信任**。
- en: Try to open the app again.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试再次打开应用程序。
- en: Please remember to try another image if you're having trouble detecting the
    image where we instantiate the player (the Unity logo, in my case). This might
    vary a lot, depending on your device's capabilities.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在实例化播放器的图像上遇到问题，请记得尝试另一张图像（在我的情况下是Unity标志）。这可能会有很大的变化，取决于您设备的能力。
- en: In this section, we discussed how to build a Unity project that can run on iOS
    and Android, thus allowing us to create mobile apps–AR mobile apps, specifically.
    Like any build, there are methods we can follow to profile and debug, as we saw
    when we looked at PC builds, but we are not going to discuss that here. Now that
    we have created our first test project, we will convert it into a real game by
    adding some mechanics to it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何构建一个可以在iOS和Android上运行的Unity项目，从而使我们能够创建移动应用程序 - 特别是AR移动应用程序。与任何构建一样，我们可以遵循方法进行分析和调试，就像我们在查看PC构建时所看到的那样，但我们不打算在这里讨论。现在我们已经创建了我们的第一个测试项目，我们将通过向其添加一些机制将其转换为一个真正的游戏。
- en: Creating a simple AR game
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的AR游戏
- en: As we discussed previously, the idea is to create a simple game where we can
    move our player while moving a real-life image, and also put in some Enemy Spawners
    by just tapping where we want them to be, such as a wall, the floor, a table,
    and so on. Our player will automatically shoot at the nearest Enemy, and the enemies
    will shoot directly at the player, so our only task will be to move the Player
    so that they avoid bullets. We are going to implement these game mechanics using
    scripts very similar to the ones we used in this book's main project.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，我们的想法是创建一个简单的游戏，我们可以在移动真实图像的同时移动我们的玩家，并通过点击放置一些敌人生成器，比如墙壁、地板、桌子等。我们的玩家将自动射击最近的敌人，敌人将直接射击玩家，所以我们唯一的任务就是移动玩家以避开子弹。我们将使用与本书的主要项目中使用的非常相似的脚本来实现这些游戏机制。
- en: 'In this section, we will develop the following AR game features:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发以下AR游戏功能：
- en: Spawning the Player and Enemies
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成玩家和敌人
- en: Coding the Player and Enemy behavior
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写玩家和敌人的行为
- en: First, we are going to discuss how to make our Player and Enemies appear on
    the app, specifically in real-world positions, and then we will make them move
    and shoot each other to create the specified gameplay mechanics. Let's start with
    spawning.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论如何使我们的玩家和敌人出现在应用程序中，特别是在现实世界的位置，然后我们将使它们移动并相互射击，以创建指定的游戏机制。让我们从生成开始。
- en: Spawning the Player and Enemies
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成玩家和敌人
- en: 'Let''s start with the Player, since that''s the easiest one to deal with: we
    will create a prefab with the graphics we want the player to have (in my case,
    just a cube), a `Rigidbody` with `0.05`, `0.05`, `0.05`). Since the original cube
    is 1 meter in size, this means that my player will be *5x5x5* centimeters. Your
    Player prefab should look as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从玩家开始，因为这是最容易处理的：我们将创建一个带有我们希望玩家拥有的图形的预制体（在我的情况下，只是一个立方体），一个带有`0.05`，`0.05`，`0.05`的`Rigidbody`。由于原始立方体的大小为1米，这意味着我的玩家将是*5x5x5*厘米。您的玩家预制体应如下所示：
- en: '![Figure 22.33 – The starting "Player" prefab'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.33 – 起始“玩家”预制体'
- en: '](img/Figure_22.33_B14199.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.33_B14199.jpg)'
- en: Figure 22.33 – The starting "Player" prefab
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.33 – 起始“玩家”预制体
- en: 'The enemies will require a little bit more work, as shown here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人将需要更多的工作，如下所示：
- en: Create a prefab called `Spawner` with the graphic you want your Spawner to have
    (in my case, a cylinder) and its real-life size.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Spawner`的预制体，其中包含您希望生成器具有的图形（在我的情况下是一个圆柱体）和其真实大小。
- en: Add a custom script that spawns a prefab every few seconds, such as the one
    shown in the following screenshot.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个自定义脚本，每隔几秒生成一个预制体，如下截图所示。
- en: You will notice the usage of `Physics.IgnoreCollision` to prevent the Spawner
    from colliding with the `Spawner` object, getting the colliders of both objects
    and passing them to the function. You can also use the **Layer Collision Matrix**
    to prevent collisions, just like we did with this book's main project, if you
    prefer to:![Figure 22.34 – Spawner script
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将注意到使用`Physics.IgnoreCollision`来防止生成器与`Spawner`对象发生碰撞，获取两个对象的碰撞体并将它们传递给函数。您也可以使用**层碰撞矩阵**来防止碰撞，就像我们在本书的主要项目中所做的那样，如果您愿意的话：![图22.34
    – 生成器脚本
- en: '](img/Figure_22.34_B14199.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.34_B14199.jpg)'
- en: Figure 22.34 – Spawner script
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.34 – 生成器脚本
- en: Create an `Enemy` prefab with the desired graphic (a Capsule, in my case) and
    a `Rigidbody` component with the **Is Kinematic** checkbox checked. This way,
    the Enemy will move but not with physics. Remember to consider the real-life size
    of the Enemy.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有所需图形（在我的情况下是一个胶囊体）和一个勾选了**Is Kinematic**复选框的`Rigidbody`组件的`Enemy`预制体。这样，敌人将移动但不受物理影响。记得考虑敌人的真实大小。
- en: Set the **Prefab** property of the Spawner so that it spawns our Enemy at your
    desired time frequency:![Figure 22.35 – Configuring the Spawner
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成器的**Prefab**属性设置为在所需的时间频率生成我们的敌人：![图22.35 – 配置生成器
- en: '](img/Figure_22.35_B14199.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.35_B14199.jpg)'
- en: Figure 22.35 – Configuring the Spawner
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.35 – 配置生成器
- en: Add a new `SpawnerPlacer` custom script to the **AR Session Origin** object
    that instantiates a prefab in the place the player tapped using the AR Raycast
    system, as shown in the following screenshot:![Figure 22.36 – Placing the Spawners
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**AR Session Origin**对象中添加一个新的`SpawnerPlacer`自定义脚本，使用AR射线系统在玩家点击的地方实例化一个预制体，如下截图所示：![图22.36
    – 放置生成器
- en: '](img/Figure_22.36_B14199.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.36_B14199.jpg)'
- en: Figure 22.36 – Placing the Spawners
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.36 – 放置生成器
- en: Set the prefab of `SpawnerPlacer` so that it spawns the **Spawner** prefab we
    created earlier.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`SpawnerPlacer`的预制体，以便生成我们之前创建的**生成器**预制体。
- en: And that's all for the first part. If you test the game now, you will be able
    to tap on the detected planes in the app and see how the Spawner starts creating
    enemies. You can also look at the target image and see our Cube Player appear.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是第一部分的全部内容。如果您现在测试游戏，您将能够点击应用程序中检测到的平面，并看到生成器开始创建敌人。您还可以查看目标图像，看到我们的立方体玩家出现。
- en: Now that we have the objects in the scene, let's make them do something more
    interesting, starting with the Enemies.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在场景中有了这些对象，让我们让它们做一些更有趣的事情，从敌人开始。
- en: Coding the Player and Enemy behavior
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写玩家和敌人的行为
- en: 'The Enemy must move toward the player in order to shoot at them, so it will
    need to have access to the player position. Since the Enemy is instantiated, we
    cannot drag the Player reference to the prefab. However, the Player has also been
    instantiated, so we can add a `PlayerManager` script to the player that uses the
    Singleton pattern (as we did with managers). To do that, follow these steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人必须朝着玩家移动以射击他们，因此它需要访问玩家的位置。由于敌人是实例化的，我们无法将玩家引用拖到预制体上。然而，玩家也已经被实例化，所以我们可以向玩家添加一个使用单例模式的`PlayerManager`脚本（就像我们在管理器中所做的那样）。要做到这一点，请按照以下步骤进行：
- en: Create a `PlayerManager` script similar to the one shown in the following screenshot
    and add it to the Player:![Figure 22.37 – Creating the PlayerManager script
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类似于下图所示的`PlayerManager`脚本，并将其添加到玩家：![图22.37 – 创建PlayerManager脚本
- en: '](img/Figure_22.37_B14199.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.37_B14199.jpg)'
- en: Figure 22.37 – Creating the PlayerManager script
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.37 – 创建PlayerManager脚本
- en: Now that the Enemy has a reference to the player, let's make them look at the
    player by adding a `LookAtPlayer` script, as shown here:![Figure 22.38 – Creating
    the LookAtPlayer script
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在敌人已经有了对玩家的引用，让我们通过添加一个`LookAtPlayer`脚本使它们朝向玩家，如下所示：![图22.38 – 创建LookAtPlayer脚本
- en: '](img/Figure_22.38_B14199.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.38_B14199.jpg)'
- en: Figure 22.38 – Creating the LookAtPlayer script
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.38 – 创建LookAtPlayer脚本
- en: 'Also, add a simple `MoveForward` script like the one shown in the following
    screenshot to make the `LookAtPlayer` script is making the Enemy face the Player,
    this script moving along the z axis is just enough:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，添加一个简单的`MoveForward`脚本，如下面截图中所示的脚本，使`LookAtPlayer`脚本使敌人面向玩家，这个沿z轴移动的脚本就足够了：
- en: '![Figure 22.39 – Creating the MoveForward script'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.39 – 创建MoveForward脚本'
- en: '](img/Figure_22.39_B14199.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.39_B14199.jpg)'
- en: Figure 22.39 – Creating the MoveForward script
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.39 – 创建MoveForward脚本
- en: 'Now, we will take care of the Player movement. Remember that our player is
    controlled through moving the image, so here, we are actually referring to the
    rotation, since the player will need to automatically look and shoot at the nearest
    Enemy. To do this, follow these steps:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将处理玩家的移动。记住，我们的玩家是通过移动图像来控制的，所以这里实际上是指旋转，因为玩家需要自动瞄准并射击最近的敌人。要做到这一点，请按照以下步骤进行：
- en: Create an `Enemy` script and add it to the **Enemy** prefab.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Enemy`脚本并将其添加到**Enemy**预制件中。
- en: Create an `EnemyManager` script like the one shown in the following screenshot
    and add it to an empty `EnemyManager` object in the scene:![Figure 22.40 – Creating
    the EnemyManager script
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个像下面截图中所示的`EnemyManager`脚本，并将其添加到场景中的一个空的`EnemyManager`对象中：![图22.40 – 创建EnemyManager脚本
- en: '](img/Figure_22.40_B14199.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.40_B14199.jpg)'
- en: Figure 22.40 – Creating the EnemyManager script
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.40 – 创建EnemyManager脚本
- en: In the `Enemy` script, make sure to register the object in the `EnemyManager`,
    as we did previously with `WavesManager` in this book's main project:![Figure
    22.41 – Creating the Enemy script
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Enemy`脚本中，确保在`EnemyManager`中注册对象，就像我们之前在本书的主项目中使用`WavesManager`一样：![图22.41
    – 创建Enemy脚本
- en: '](img/Figure_22.41_B14199.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.41_B14199.jpg)'
- en: Figure 22.41 – Creating the Enemy script
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.41 – 创建Enemy脚本
- en: Create a `LookAtNearestEnemy` script like the one shown in the following screenshot
    and add it to the **Player** prefab to make it look at the nearest Enemy:![Figure
    22.42 – Looking at the nearest Enemy
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个像下面截图中所示的`LookAtNearestEnemy`脚本，并将其添加到**Player**预制件中，使其朝向最近的敌人：![图22.42
    – 瞄准最近的敌人
- en: '](img/Figure_22.42_B14199.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.42_B14199.jpg)'
- en: Figure 22.42 – Looking at the nearest Enemy
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.42 – 瞄准最近的敌人
- en: 'Now that our objects are rotating and moving as expected, the only thing missing
    is shooting and damaging:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的对象旋转和移动如预期般进行，唯一缺少的是射击和造成伤害：
- en: Create a `Life` script like the one shown in the following screenshot and add
    it to both the `Life` instead of needing to check if the life has reached zero
    every frame. We have created a `Damage` function to check that damage is dealt
    (the `Damage` function is executed), but the other version of this book's project
    also works:![Figure 22.43 – Creating a Life component
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个像下面截图中所示的`Life`脚本，并将其添加到`Life`中，而不需要每帧检查生命是否已经降至零。我们创建了一个`Damage`函数来检查是否造成了伤害（执行了`Damage`函数），但本书项目的另一个版本也可以工作：![图22.43
    – 创建Life组件
- en: '](img/Figure_22.43_B14199.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.43_B14199.jpg)'
- en: Figure 22.43 – Creating a Life component
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.43 – 创建Life组件
- en: Create a `Bullet` prefab with the desired graphics, the collider with the `Rigidbody`
    component with **Is Kinematic** checked (a Kinematic Trigger Collider), and the
    proper real-life size.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有所需图形的`Bullet`预制件，带有**Is Kinematic**选中的`Rigidbody`组件的碰撞体（一个运动学触发碰撞体），以及适当的真实尺寸。
- en: Add the `MoveForward` script to the **Bullet** prefab to make it move. Remember
    to set the speed.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MoveForward`脚本添加到**Bullet**预制件中使其移动。记得设置速度。
- en: Add a `Spawner` script to both the **Player** and the **Enemy** components and
    set the **Bullet** prefab as the prefab to spawn, as well as the desired spawn
    frequency.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Spawner`脚本添加到**Player**和**Enemy**组件中，并将**Bullet**预制件设置为要生成的预制件，以及所需的生成频率。
- en: Add a `Damager` script like the one shown in the following screenshot to the
    **Bullet** prefab to make bullets inflict damage on the objects it touches. Remember
    to set the damage:![Figure 22.44 – Creating a Damager script – part 1
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向**Bullet**预制件添加一个像下面截图中所示的`Damager`脚本，使子弹对其触及的物体造成伤害。记得设置伤害：![图22.44 – 创建Damager脚本
    – 第1部分
- en: '](img/Figure_22.44_B14199.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.44_B14199.jpg)'
- en: Figure 22.44 – Creating a Damager script – part 1
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.44 – 创建Damager脚本 – 第1部分
- en: 'Add an `AutoDestroy` script like the one shown in the following screenshot
    to the `Destroy` time:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Destroy`时间添加一个像下面截图中所示的`AutoDestroy`脚本：
- en: '![Figure 22.45 – Creating a Damager script – part 2'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.45 – 创建Damager脚本 – 第2部分'
- en: '](img/Figure_22.45_B14199.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.45_B14199.jpg)'
- en: Figure 22.45 – Creating a Damager script – part 2
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.45 – 创建Damager脚本 – 第2部分
- en: And that's all! As you can see, we basically created a new game using almost
    the same scripts we used in the main game, mostly because we designed them to
    be generic (and the game genres are almost the same). Of course, this project
    can be improved a lot, but we have a nice base project upon which to create amazing
    AR apps.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！正如你所看到的，我们基本上使用了几乎与主游戏中使用的相同的脚本来创建了一个新的游戏，主要是因为我们设计它们是通用的（而且游戏类型几乎相同）。当然，这个项目还有很大的改进空间，但我们已经有了一个很好的基础项目，可以在此基础上创建令人惊叹的AR应用程序。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced the AR Foundation Unity framework, explored how
    to set it up, and how to implement several tracking features so that we can position
    virtual objects on top of real-life objects. We also discussed how to build our
    project so that it can run on both iOS and Android platforms, which is the only
    way we can test our AR apps at the time of writing. Finally, we created a simple
    AR game based on the game we created in the main project but modified it so that
    it's suitable for use in AR scenarios.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了AR Foundation Unity框架，探讨了如何设置它，以及如何实现几个跟踪功能，以便我们可以将虚拟对象放置在现实对象之上。我们还讨论了如何构建我们的项目，使其可以在iOS和Android平台上运行，这是我们在撰写时测试我们的AR应用程序的唯一方法。最后，我们创建了一个简单的AR游戏，基于我们在主项目中创建的游戏，但修改了它，使其适用于AR场景的使用。
- en: With this new knowledge, you will be able to start your path as an AR app developer,
    creating apps that augment real objects with virtual objects by detecting the
    positions of the real objects. This can be applied to games, training apps, and
    simulations. You may even be able to find new fields of usage, so take advantage
    of this new technology and its new possibilities!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些新知识，您将能够开始作为AR应用程序开发人员的道路，通过检测真实对象的位置，创建可以用虚拟对象增强真实对象的应用程序。这可以应用于游戏、培训应用程序和模拟。您甚至可能能够找到新的使用领域，因此利用这项新技术及其新的可能性！
