- en: 1\. Introduction to Docker and Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. Docker和Kubernetes简介
- en: Kubernetes has become the leading standard in container orchestration. Since
    its inception in 2014, it has gained tremendous popularity. It has been adopted
    by start-ups as well as major enterprises, and the major public cloud vendors
    all offer a managed Kubernetes service.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes已成为容器编排的领先标准。自2014年成立以来，它已经获得了巨大的流行。它已被初创公司和主要企业采用，而且主要的公共云供应商都提供了托管的Kubernetes服务。
- en: Kubernetes builds upon the success of the Docker container revolution. Docker
    is both a company and the name of a technology. Docker as a technology is the
    standard way of creating and running software containers, often called Docker
    containers. A container itself is a way of packaging software that makes it easy
    to run that software on any platform, ranging from your laptop to a server in
    a data center, to a cluster running in the public cloud.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes建立在Docker容器革命的成功基础上。Docker既是一家公司，也是一种技术的名称。作为一种技术，Docker是创建和运行软件容器的标准方式，通常称为Docker容器。容器本身是一种打包软件的方式，使得在任何平台上运行该软件变得容易，从您的笔记本电脑到数据中心的服务器，再到公共云中运行的集群。
- en: Docker is also the name of the company behind the Docker technology. Although
    the core technology is open source, the Docker company focuses on reducing complexity
    for developers through a number of commercial offerings.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Docker也是Docker技术背后公司的名称。尽管核心技术是开源的，但Docker公司专注于通过多种商业产品减少开发人员的复杂性。
- en: Kubernetes takes Docker containers to the next level. Kubernetes is a container
    orchestrator. A container orchestrator is a software platform that makes it easy
    to run many thousands of containers on top of thousands of machines. It automates
    a lot of the manual tasks required to deploy, run, and scale applications. The
    orchestrator will take care of scheduling the right container to run on the right
    machine, and it will take care of health monitoring and failover, as well as scaling
    your deployed application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes将Docker容器提升到了一个新的水平。Kubernetes是一个容器编排器。容器编排器是一种软件平台，可以轻松地在成千上万台机器上运行成千上万个容器。它自动化了部署、运行和扩展应用程序所需的许多手动任务。编排器将负责安排正确的容器在正确的机器上运行，并负责健康监控和故障转移，以及扩展您部署的应用程序。
- en: Docker and Kubernetes are both open-source software projects. Open-source software
    allows developers from many companies to collaborate on a single piece of software.
    Kubernetes itself has contributors from companies such as Microsoft, Google, Red
    Hat, VMware, and many others.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Docker和Kubernetes都是开源软件项目。开源软件允许来自许多公司的开发人员共同合作开发单一软件。Kubernetes本身有来自微软、谷歌、红帽、VMware等公司的贡献者。
- en: The three major public cloud platforms – **Azure,** **Amazon Web Services**
    (**AWS**), and **Google Cloud Platform** (**GCP**) – all offer a managed Kubernetes
    service. This is attracting a lot of interest in the market since the virtually
    unlimited compute power and the ease of use of these managed services make it
    easy to build and deploy large-scale applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 三大主要的公共云平台 - Azure，Amazon Web Services（AWS）和Google Cloud Platform（GCP） - 都提供了托管的Kubernetes服务。这在市场上引起了很大的兴趣，因为这些托管服务的计算能力几乎是无限的，而且易于使用，可以轻松构建和部署大规模应用程序。
- en: '**Azure Kubernetes Service** (**AKS**) is Azure''s managed service for Kubernetes.
    It manages the complexity of putting together all the preceding services for you.
    In this book, you will learn how to use AKS to run your applications. Each chapter
    will introduce new concepts, which you will apply through the many examples in
    this book.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Kubernetes Service（AKS）是Azure的Kubernetes托管服务。它管理了为您组合所有前述服务的复杂性。在本书中，您将学习如何使用AKS来运行您的应用程序。每一章都会介绍新的概念，您将通过本书中的许多示例来应用这些概念。
- en: As an engineer, however, it is still very useful to understand the technologies
    that underpin AKS. We will explore these foundations in this chapter. You will
    learn about Linux processes, and how they are related to Docker. You will see
    how various processes fit nicely into Docker, and how Docker fits nicely into
    Kubernetes. Even though Kubernetes is technically a container runtime-agnostic
    platform, Docker is the most commonly used container technology and is used everywhere.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，作为一名工程师，了解支撑AKS的技术仍然非常有用。我们将在本章探讨这些基础知识。您将了解Linux进程及其与Docker的关系。您将看到各种进程如何很好地适配到Docker中，以及Docker如何很好地适配到Kubernetes中。尽管Kubernetes在技术上是一个容器运行时无关的平台，但Docker是最常用的容器技术，被广泛应用。
- en: This chapter introduces fundamental Docker concepts so that you can begin your
    Kubernetes journey. This chapter also briefly introduces the basics that will
    help you build containers, implement clusters, perform container orchestration,
    and troubleshoot applications on AKS. Having cursory knowledge of what's in this
    chapter will demystify much of the work needed to build your authenticated, encrypted,
    highly scalable applications on AKS. Over the next chapters, you will gradually
    build scalable and secure applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了基本的Docker概念，以便您可以开始您的Kubernetes之旅。本章还简要介绍了将帮助您构建容器、实现集群、执行容器编排和在AKS上排除故障的基础知识。对本章内容的粗略了解将使构建在AKS上的经过认证、加密、高度可扩展的应用程序所需的大部分工作变得不再神秘。在接下来的章节中，您将逐渐构建可扩展和安全的应用程序。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The software evolution that brought us here
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们带到这里的软件演变
- en: The fundamentals of Docker
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker的基础知识
- en: The fundamentals of Kubernetes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes的基础知识
- en: The fundamentals of AKS
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AKS的基础知识
- en: The aim of this chapter is to introduce the essentials rather than to provide
    a thorough information source describing Docker and Kubernetes. To begin with,
    we'll first take a look at how software has evolved to get us to where we are
    now.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是介绍基本知识，而不是提供描述Docker和Kubernetes的详尽信息源。首先，我们将首先看一下软件是如何演变到现在的。
- en: The software evolution that brought us here
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们带到这里的软件演变
- en: There are two major software development evolutions that enabled the popularity
    of Docker and Kubernetes. One is the adoption of a microservices architectural
    style. Microservices allow an application to be built from a collection of small
    services that each serve a specific function. The other evolution that enabled
    Docker and Kubernetes is DevOps. DevOps is a set of cultural practices that allows
    people, processes, and tools to build and release software faster, more frequently,
    and more reliably.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个主要的软件开发演变使得Docker和Kubernetes变得流行。一个是采用了微服务架构风格。微服务允许应用程序由一系列小服务构建，每个服务都提供特定的功能。使Docker和Kubernetes变得流行的另一个演变是DevOps。DevOps是一组文化实践，允许人员、流程和工具更快、更频繁、更可靠地构建和发布软件。
- en: Although you can use both Docker and Kubernetes without using either microservices
    or DevOps, the technologies are most widely adopted for deploying microservices
    using DevOps methodologies.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可以在不使用微服务或DevOps的情况下使用Docker和Kubernetes，但这些技术最广泛地被采用用于使用DevOps方法部署微服务。
- en: In this section, we'll discuss both evolutions, starting with microservices.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论两种演变，首先是微服务。
- en: Microservices
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务
- en: Software development has drastically evolved over time. Initially, software
    was developed and run on a single system, typically a mainframe. A client could
    connect to the mainframe through a terminal, and only through that terminal. This
    changed when computer networks became common when the client-server programming
    model emerged. A client could connect remotely to a server, and even run part
    of the application on their own system while connecting to the server to retrieve
    part of the data the application required.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发随着时间的推移发生了巨大变化。最初，软件是在单一系统上开发和运行的，通常是在大型机上。客户端可以通过终端连接到大型机，而且只能通过那个终端。当计算机网络变得普遍时，这种情况发生了变化，客户端-服务器编程模型出现了。客户端可以远程连接到服务器，甚至在连接到服务器检索应用程序所需的部分数据时，在自己的系统上运行应用程序的一部分。
- en: The client-server programming model has evolved toward truly distributed systems.
    Distributed systems are different from the traditional client-server model as
    they have multiple different applications running on multiple different systems,
    all interconnected.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器编程模型已经发展成真正的分布式系统。分布式系统不同于传统的客户端-服务器模型，因为它们在多个不同的系统上运行多个不同的应用程序，并且彼此相互连接。
- en: Nowadays, a microservices architecture is common when developing distributed
    systems. A microservices-based application consists of a group of services that
    work together to form the application, while the individual services themselves
    can be built, tested, deployed, and scaled independently from each other. The
    style has many benefits but also has several disadvantages.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，在开发分布式系统时，微服务架构很常见。基于微服务的应用程序由一组服务组成，这些服务共同形成应用程序，而这些个别服务本身可以独立构建、测试、部署和独立扩展。这种风格有许多好处，但也有一些缺点。
- en: A key part of a microservices architecture is the fact that each individual
    service serves one and only one core function. Each service serves a single bounded
    business function. Different services work together to form the complete application.
    Those services work together over network communication, commonly using HTTP REST
    APIs or gRPC.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的一个关键部分是每个个别服务只提供一个核心功能。每个服务提供一个单一的业务功能。不同的服务共同形成完整的应用程序。这些服务通过网络通信共同工作，通常使用HTTP
    REST API或gRPC。
- en: This architectural approach is commonly adopted by applications run using Docker
    and Kubernetes. Docker is used as the packaging format for the individual services,
    while Kubernetes is the orchestrator that deploys and manages the different services
    running together.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构方法通常被应用程序使用Docker和Kubernetes运行。Docker被用作单个服务的打包格式，而Kubernetes是部署和管理一起运行的不同服务的编排器。
- en: Before we dive into the Docker and Kubernetes specifics, let's first explore
    the benefits and downsides of adopting microservices.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究Docker和Kubernetes的具体内容之前，让我们先探讨一下采用微服务的利与弊。
- en: '**Advantages of running microservices**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行微服务的优势**'
- en: There are several advantages to running a microservices-based application. The
    first is the fact that each service is independent of the other services. The
    services are designed to be small enough (hence micro) to handle the needs of
    a business domain. As they are small, they can be made self-contained and independently
    testable, and so are independently releasable.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 运行基于微服务的应用程序有几个优势。第一个是每个服务都独立于其他服务。这些服务被设计得足够小（因此是微型），以满足业务领域的需求。由于它们很小，它们可以被制作成自包含的、可以独立测试的，因此可以独立发布。
- en: This leads to the fact that each microservice is independently scalable as well.
    If a certain part of the application is getting more demand, that part of the
    application can be scaled independently from the rest of the application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了每个微服务都可以独立扩展。如果应用程序的某个部分需求增加，该部分可以独立于应用程序的其他部分进行扩展。
- en: The fact that services are independently scalable also means they are independently
    deployable. There are multiple deployment strategies when it comes to microservices.
    The most popular are rolling upgrades and blue/green deployments.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可以独立扩展也意味着它们可以独立部署。在微服务方面有多种部署策略。最流行的是滚动升级和蓝/绿部署。
- en: With a rolling upgrade, a new version of the service is deployed only to part
    of the end user community. This new version is carefully monitored and gradually
    gets more traffic if the service is healthy. If something goes wrong, the previous
    version is still running, and traffic can easily be cut over.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过滚动升级，服务的新版本只部署到部分最终用户社区。如果服务正常，新版本会受到仔细监控，并逐渐获得更多的流量。如果出现问题，之前的版本仍在运行，流量可以轻松切换。
- en: With a blue/green deployment, you would deploy the new version of the service
    in isolation. Once the new version of the service is deployed and tested, you
    would cut over 100% of the production traffic to the new version. This allows
    for a clean transition between service versions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过蓝/绿部署，您可以将服务的新版本独立部署。一旦部署并测试了服务的新版本，您就可以将100%的生产流量切换到新版本。这可以实现服务版本之间的平稳过渡。
- en: Another benefit of the microservices architecture is that each service can be
    written in a different programming language. This is described as being **polyglot**
    – able to understand and use multiple languages. For example, the front end service
    can be developed in a popular JavaScript framework, the back end can be developed
    in C#, while the machine learning algorithm can be developed in Python. This allows
    you to select the right language for the right service, and to have the developers
    use the languages they are most familiar with.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的另一个好处是每个服务可以用不同的编程语言编写。这被描述为**多语言** - 能够理解和使用多种语言。例如，前端服务可以使用流行的JavaScript框架开发，后端可以使用C#开发，而机器学习算法可以使用Python开发。这使您可以为每个服务选择合适的语言，并让开发人员使用他们最熟悉的语言。
- en: '**Disadvantages of running microservices**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行微服务的缺点**'
- en: There's a flip side to every coin, and the same is true for microservices. While
    there are multiple advantages to a microservices-based architecture, this architecture
    has its downsides as well.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个硬币都有两面，微服务也是如此。虽然基于微服务的架构有多个优点，但这种架构也有其缺点。
- en: Microservices designs and architectures require a high degree of software development
    maturity in order to be implemented correctly. Architects who understand the domain
    very well must ensure that each service is bounded and that different services
    are cohesive. Since services are independent of each other and versioned independently,
    the software contract between these different services is important to get right.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的设计和架构需要高度的软件开发成熟度才能正确实施。深刻理解领域的架构师必须确保每个服务都是有界的，并且不同的服务是内聚的。由于服务彼此独立且独立版本化，因此这些不同服务之间的软件合同非常重要。
- en: Another common issue with a microservices design is the added complexity when
    it comes to monitoring and troubleshooting such an application. Since different
    services make up a single application, and those different services run on multiple
    servers, both logging and tracing such an application is a complicated endeavor.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务设计的另一个常见问题是在监视和故障排除这样的应用程序时增加了复杂性。由于不同的服务构成单个应用程序，并且这些不同的服务在多个服务器上运行，因此记录和跟踪这样的应用程序是一项复杂的工作。
- en: Linked to the aforementioned disadvantages is that, typically, in microservices,
    you need to build more fault tolerance into your application. Due to the dynamic
    nature of the different services in an application, faults are more likely to
    happen. In order to guarantee application availability, it is important to build
    fault tolerance into the different microservices that make up an application.
    Implementing patterns such as retry logic or circuit breakers is critical to avoid
    a single fault causing application downtime.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与前述的缺点相关的是，通常在微服务中，您需要为应用程序构建更多的容错能力。由于应用程序中不同服务的动态性质，故障更有可能发生。为了保证应用程序的可用性，重要的是在构成应用程序的不同微服务中构建容错能力。实施重试逻辑或断路器等模式对于避免单一故障导致应用程序停机至关重要。
- en: Often linked to microservices, but a separate transformation, is the DevOps
    movement. We will explore what DevOps means in the next section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通常与微服务相关联，但是一个独立的转型是DevOps运动。我们将在下一节探讨DevOps的含义。
- en: DevOps
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DevOps
- en: 'DevOps literally means the combination of development and operations. More
    specifically, DevOps is the union of people, processes, and tools to deliver software
    faster, more frequently, and more reliably. DevOps is more about a set of cultural
    practices than about any specific tools or implementations. Typically, DevOps
    spans four areas of software development: planning, developing, releasing, and
    operating software.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps字面上意味着开发和运营的结合。更具体地说，DevOps是人员、流程和工具的结合，以更快、更频繁、更可靠地交付软件。DevOps更多地涉及一套文化实践，而不是任何特定的工具或实施。通常，DevOps涵盖软件开发的四个领域：规划、开发、发布和操作软件。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Many definitions of DevOps exist. The authors have adopted this definition,
    but you as a reader are encouraged to explore different definitions in the literature
    around DevOps.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多关于DevOps的定义。作者采用了这个定义，但鼓励读者在DevOps的文献中探索不同的定义。
- en: The DevOps culture starts with planning. In the planning phase of a DevOps project,
    the goals of a project are outlined. These goals are outlined both at a high level
    (called an *Epic*) and at a lower level (in *Features* and *Tasks*). The different
    work items in a DevOps project are captured in the feature backlog. Typically,
    DevOps teams use an agile planning methodology working in programming sprints.
    Kanban boards are often used to represent project status and to track work. As
    a task changes status from *to do* to *doing* to *done*, it moves from left to
    right on a Kanban board.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps文化始于规划。在DevOps项目的规划阶段，项目的目标被概述。这些目标在高层次（称为*史诗*）和较低层次（在*特性*和*任务*中）都有概述。DevOps项目中的不同工作项被记录在特性积压中。通常，DevOps团队使用敏捷规划方法，在编程冲刺中工作。看板经常被用来表示项目状态和跟踪工作。当任务从*待办*状态变为*进行中*再到*完成*时，它在看板上从左向右移动。
- en: When work is planned, actual development can be done. Development in a DevOps
    culture isn't only about writing code, but also about testing, reviewing, and
    integrating with team members. A version control system such as Git is used for
    different team members to share code with each other. An automated **continuous
    integration** (**CI**) tool is used to automate most manual tasks such as testing
    and building code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当工作计划好后，实际的开发工作就可以开始了。在DevOps文化中，开发不仅仅是编写代码，还包括测试、审查和与团队成员集成。诸如Git之类的版本控制系统用于不同团队成员之间共享代码。自动化的持续集成（CI）工具用于自动化大部分手动任务，如测试和构建代码。
- en: 'When a feature is code-complete, tested, and built, it is ready to be delivered.
    The next phase in a DevOps project can start: delivery. A **continuous delivery**
    (**CD**) tool is used to automate the deployment of software. Typically, software
    is deployed to different environments, such as testing, quality assurance, or
    production. A combination of automated and manual gates is used to ensure quality
    before moving to the next environment.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个功能完成编码、测试和构建后，就可以交付了。DevOps项目的下一个阶段可以开始：交付。使用持续交付（CD）工具来自动化软件的部署。通常，软件会部署到不同的环境，如测试、质量保证或生产。使用自动化和手动门来确保在进入下一个环境之前的质量。
- en: Finally, when a piece of software is running in production, the operations phase
    can start. This phase involves the maintaining, monitoring, and supporting of
    an application in production. The end goal is to operate an application reliably
    with as little downtime as possible. Any issues are to be identified as proactively
    as possible. Bugs in the software need to be tracked in the backlog.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当一款软件在生产中运行时，运维阶段就可以开始了。这个阶段涉及在生产中维护、监控和支持应用程序。最终目标是以尽可能少的停机时间可靠地运行应用程序。任何问题都应该尽可能被主动识别。软件中的错误需要在积压中被跟踪。
- en: The DevOps process is an iterative process. A single team is never in a single
    phase of the process. The whole team is continuously planning, developing, delivering,
    and operating software.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps流程是一个迭代的过程。一个团队永远不只处于一个阶段。整个团队不断地规划、开发、交付和操作软件。
- en: 'Multiple tools exist to implement DevOps practices. There are point solutions
    for a single phase, such as Jira for planning or Jenkins for CI and CD, as well
    as complete DevOps platforms, such as GitLab. Microsoft operates two solutions
    that enable customers to adopt DevOps practices: Azure DevOps and GitHub. Azure
    DevOps is a suite of services to support all phases of the DevOps process. GitHub
    is a separate platform that enables DevOps software development. GitHub is known
    as the leading open-source software development platform, hosting over 40 million
    open-source projects.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种工具来实施DevOps实践。有针对单个阶段的点解决方案，比如用于规划的Jira或用于CI和CD的Jenkins，以及完整的DevOps平台，比如GitLab。微软提供了两种解决方案，使客户能够采用DevOps实践：Azure
    DevOps和GitHub。Azure DevOps是一套服务，支持DevOps流程的所有阶段。GitHub是一个单独的平台，支持DevOps软件开发。GitHub被认为是领先的开源软件开发平台，托管了超过4000万个开源项目。
- en: Both microservices and DevOps are commonly used in combination with Docker and
    Kubernetes. After this introduction to microservices and DevOps, we'll continue
    this first chapter with the fundamentals of Docker and containers and then the
    fundamentals of Kubernetes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务和DevOps通常与Docker和Kubernetes结合使用。在介绍了微服务和DevOps之后，我们将继续本章的第一部分，介绍Docker和容器的基础知识，然后是Kubernetes的基础知识。
- en: Fundamentals of Docker containers
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker容器的基础知识
- en: A form of container technology has existed in the Linux kernel since the 1970s.
    The technology powering today's containers, called cgroups, was introduced into
    the Linux kernel in 2006 by Google. The Docker company popularized the technology
    in 2013 by introducing an easy developer workflow. The company gave its name to
    the technology, so the name Docker can refer to both the company as well as the
    technology. Most commonly though, we use Docker to refer to the technology.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 自20世纪70年代以来，Linux内核中一种容器技术已经存在。今天容器的技术，称为cgroups，是由Google在2006年引入Linux内核的。Docker公司在2013年通过引入一种简单的开发者工作流程使这项技术变得流行。该公司以自己的名字命名了这项技术，因此Docker这个名字既可以指公司，也可以指技术。不过，通常我们使用Docker来指代这项技术。
- en: Docker as a technology is both a packaging format and a container runtime. We
    refer to packaging as an architecture that allows an application to be packaged
    together with its dependencies, such as binaries and runtime. The runtime points
    at the actual process of running the container images.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Docker作为一种技术既是一种打包格式，也是一个容器运行时。我们将打包称为一种架构，允许应用程序与其依赖项（如二进制文件和运行时）一起打包。运行时指的是运行容器映像的实际过程。
- en: You can experiment with Docker by creating a free Docker account at Docker Hub
    ([https://hub.docker.com/](https://hub.docker.com/)) and using that login to open
    Docker Labs ([https://labs.play-with-docker.com/](https://labs.play-with-docker.com/)).
    This will give you access to an environment with Docker pre-installed that is
    valid for 4 hours. We will be using Docker Labs in this section as we build our
    own container and image.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在Docker Hub（[https://hub.docker.com/](https://hub.docker.com/)）创建一个免费的Docker账户，并使用该登录信息打开Docker实验室（[https://labs.play-with-docker.com/](https://labs.play-with-docker.com/)）来尝试Docker。这将为你提供一个预先安装了Docker的环境，有效期为4小时。在本节中，我们将使用Docker实验室来构建我们自己的容器和镜像。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：
- en: Although we are using the browser-based Docker Labs in this chapter to introduce
    Docker, you can also install Docker on your local desktop or server. For workstations,
    Docker has a product called Docker Desktop ([https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop))
    that is available for Windows and Mac to create Docker containers locally. On
    servers – both Windows and Linux – Docker is also available as a runtime for containers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在本章中我们使用基于浏览器的Docker实验室来介绍Docker，但你也可以在本地桌面或服务器上安装Docker。对于工作站，Docker有一个名为Docker
    Desktop的产品（[https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)），适用于Windows和Mac，可以在本地创建Docker容器。在服务器上，无论是Windows还是Linux，Docker也可以作为容器的运行时使用。
- en: Docker images
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker镜像
- en: Docker uses an image to start a new container. An image contains all the software
    you need to run within your container. Container images can be stored locally
    on your machine, as well as in a container registry. There are public registries,
    such as the public Docker Hub ([https://hub.docker.com/](https://hub.docker.com/)),
    or private registries, such as **Azure Container Registry** (**ACR**). When you,
    as a user, don't have an image locally on your PC, you will pull an image from
    a registry using the `docker pull` command.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使用镜像来启动一个新的容器。镜像包含了在容器内运行所需的所有软件。容器镜像可以存储在本地计算机上，也可以存储在容器注册表中。有公共注册表，如公共Docker
    Hub（[https://hub.docker.com/](https://hub.docker.com/)），也有私有注册表，如Azure容器注册表（ACR）。当你作为用户在PC上没有镜像时，你将使用`docker
    pull`命令从注册表中拉取镜像。
- en: 'In the following example, we will pull an image from the public Docker Hub
    repository and run the actual container. You can run this example in Docker Labs
    by following these instructions:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将从公共Docker Hub存储库中拉取一个镜像并运行实际的容器。你可以按照以下说明在Docker实验室中运行这个示例：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of these commands will look similar to *Figure 1.1*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令的输出将类似于*图1.1*：
- en: '![The Docker image pulled from the public Docker Hub repositoryand the output
    displaying the image ID and size. Also, running the Docker image results in a
    picture of a whale saying "boo".](image/Figure_1.1.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![从公共Docker Hub仓库中拉取的Docker镜像以及显示镜像ID和大小的输出。此外，运行Docker镜像会显示一张鲸鱼说“boo”的图片。](image/Figure_1.1.jpg)'
- en: 'Figure 1.1: Example of running Docker in Docker Labs'
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.1：在Docker实验室中运行Docker的示例
- en: What happened here is that Docker first pulled your image in multiple parts
    and stored it locally on the machine it was running on. When we ran the actual
    application, it used that local image to start a container. If we look at the
    commands in detail, you will see that `docker pull` took in a single parameter,
    `docker/whalesay`. If you don't provide a private container registry, Docker will
    look in the public Docker Hub for images, which is where Docker pulled our image
    from. The `docker run` command took in a couple of arguments. The first argument
    was `docker/whalesay`, which is the reference to the image. The next two arguments,
    `cowsay boo`, are commands that were passed to the running container to execute.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的是，Docker首先将您的镜像分成多个部分，并将其存储在运行的机器上。当我们运行实际的应用程序时，它使用本地镜像来启动一个容器。如果我们详细查看命令，您会发现`docker
    pull`只接受一个参数，即`docker/whalesay`。如果您没有提供私有容器注册表，Docker将在公共Docker Hub中查找镜像，这就是Docker从中拉取我们的镜像的地方。`docker
    run`命令接受了几个参数。第一个参数是`docker/whalesay`，这是对镜像的引用。接下来的两个参数，`cowsay boo`，是传递给正在运行的容器以执行的命令。
- en: 'In the previous example, we learned that it is possible to run a container
    without building an image first. It is, however, very common that you will want
    to build your own images. To do this, you use a **Dockerfile**. A Dockerfile contains
    steps that Docker will follow to start from a base image and build your image.
    These instructions can range from adding files to installing software or setting
    up networking. An example of a Dockerfile is provided in the following code snippet,
    which we''ll create in our Docker playground:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们了解到可以在不先构建镜像的情况下运行容器是可能的。然而，通常情况下，您会想要构建自己的镜像。为此，您可以使用**Dockerfile**。Dockerfile包含Docker将遵循的步骤，从基础镜像开始构建您的镜像。这些指令可以包括添加文件、安装软件或设置网络等。下面提供了一个Dockerfile的示例，我们将在我们的Docker
    playground中创建：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are three lines in this Dockerfile. The first one will instruct Docker
    which image to use as a source image for this new image. The next step is a command
    that is run to add new functionality to our image. In this case, updating our
    `apt` repository and installing an application called `fortunes`. Finally, the
    `CMD` command tells Docker which command to execute when a container based on
    this image is run.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Dockerfile有三行。第一行将指示Docker使用哪个镜像作为新镜像的源镜像。下一步是运行一个命令，向我们的镜像添加新功能。在这种情况下，更新我们的`apt`仓库并安装一个叫做`fortunes`的应用程序。最后，`CMD`命令告诉Docker在基于这个镜像运行的容器中执行哪个命令。
- en: You typically save a Dockerfile in a file called `Dockerfile`, without an extension.
    To build our image, you need to execute the `docker build` command and point it
    to the Dockerfile you created. In building the Docker image, the process will
    read the Dockerfile and execute the different steps in the Dockerfile. This command
    will also output the steps it took to run a container and build your image. Let's
    walk through a demo of building our own image.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通常将Dockerfile保存在名为`Dockerfile`的文件中，不带扩展名。要构建我们的镜像，您需要执行`docker build`命令，并指向您创建的Dockerfile。在构建Docker镜像时，该过程将读取Dockerfile并执行其中的不同步骤。该命令还将输出运行容器和构建镜像所采取的步骤。让我们演示构建我们自己的镜像。
- en: 'In order to create this Dockerfile, open up a text editor via the `vi Dockerfile`
    command. vi is an advanced text editor in the Linux command line. If you are not
    familiar with it, let''s walk through how you would enter the text in there:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个Dockerfile，通过`vi Dockerfile`命令打开一个文本编辑器。vi是Linux命令行中的高级文本编辑器。如果你不熟悉它，让我们一起看看你该如何在其中输入文本：
- en: After you've opened vi, hit the `i` key to enter insert mode.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开vi后，按下`i`键进入插入模式。
- en: Then, either copy-paste or type the three code lines.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，要么复制粘贴，要么输入这三行代码。
- en: Afterward, hit the *Esc* key, and type `:wq!` to write (w) your file and quit
    (q) the text editor.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，按下*Esc*键，然后输入`:wq!`来写入（w）你的文件并退出（q）文本编辑器。
- en: The next step is to execute `docker build` to build our image. We will add a
    final bit to that command, namely adding a tag to our image so we can call it
    by a useful name. To build your image, you will use the `docker build -t smartwhale
    .` command (don't forget to add the final dot here).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是执行`docker build`来构建我们的镜像。我们将在该命令中添加最后一部分，即给我们的镜像添加一个标签，这样我们就可以用一个有用的名称来调用它。要构建你的镜像，你将使用`docker
    build -t smartwhale .`命令（不要忘记在这里加上最后的点）。
- en: 'You will now see Docker execute a number of steps – three in our case – in
    order to build our image. After your image is built, you can run your application.
    To run your container, you would run `docker run smartwhale`, and you should see
    an output similar to *Figure 1.2*. However, you will probably see a different
    smart quote. This is due to the `fortunes` application generating different quotes.
    If you run the container multiple times, you will see different quotes appear,
    as shown in *Figure 1.2*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你会看到Docker执行一系列步骤 - 在我们的例子中是三个步骤 - 以构建我们的镜像。镜像构建完成后，你可以运行你的应用程序。要运行容器，你需要运行`docker
    run smartwhale`，然后你应该会看到类似于*图1.2*的输出。然而，你可能会看到不同的智能引号。这是因为`fortunes`应用程序生成不同的引言。如果你多次运行容器，你会看到不同的引言出现，就像*图1.2*中显示的那样。
- en: '![Output of the docker run smartwhale command displaying a smart quote; generated
    by the fortunes application.](image/Figure_1.2.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![运行docker run smartwhale命令的输出，显示由fortunes应用程序生成的智能引号。](image/Figure_1.2.jpg)'
- en: 'Figure 1.2: Example of running a custom container'
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.2：运行自定义容器的示例
- en: That concludes our overview and demo of Docker. In this section, you started
    with an existing container image and launched that on Docker Labs. Afterward,
    you took that a step further and built your own container image and started containers
    using your own image. You have now learned what it takes to build and run a container.
    In the next section, we will cover Kubernetes. Kubernetes allows you to run multiple
    containers at scale.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对Docker的概述和演示。在本节中，你从一个现有的容器镜像开始，并在Docker实验室上启动了它。之后，你进一步构建了自己的容器镜像，并使用自己的镜像启动了容器。现在你已经学会了构建和运行容器的方法。在下一节中，我们将介绍Kubernetes。Kubernetes允许你以规模运行多个容器。
- en: Kubernetes as a container orchestration platform
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes作为容器编排平台
- en: Building and running a single container seems easy enough. However, things can
    get complicated when you need to run multiple containers across multiple servers.
    This is where a container orchestrator can help. A container orchestrator takes
    care of scheduling containers to be run on servers, restarting containers when
    they fail, moving containers to a new host when that host becomes unhealthy, and
    much more.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行单个容器似乎足够简单。然而，当你需要在多个服务器上运行多个容器时，情况可能会变得复杂。这就是容器编排器可以帮助的地方。容器编排器负责安排容器在服务器上运行，当容器失败时重新启动容器，当主机不健康时将容器移动到新主机，以及更多其他任务。
- en: The current leading orchestration platform is Kubernetes ([https://kubernetes.io/](https://kubernetes.io/)).
    Kubernetes was inspired by the Borg project in Google, which, by itself, was running
    millions of containers in production.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当前领先的编排平台是Kubernetes（[https://kubernetes.io/](https://kubernetes.io/)）。Kubernetes受到了Google的Borg项目的启发，该项目本身在生产环境中运行了数百万个容器。
- en: Kubernetes takes a declarative approach to orchestration; that is, you specify
    what you need and Kubernetes takes care of deploying the workload you specified.
    You don't need to start these containers manually yourself anymore, as Kubernetes
    will launch the Docker containers you specified.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes采用声明性的编排方式；也就是说，你指定你需要什么，Kubernetes负责部署你指定的工作负载。你不再需要手动启动这些容器，因为Kubernetes将启动你指定的Docker容器。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Although Kubernetes supports multiple container runtimes, Docker is the most
    popular runtime.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Kubernetes支持多个容器运行时，但Docker是最流行的运行时。
- en: 'Throughout the book, we will build multiple examples that run containers in
    Kubernetes, and you will learn more about the different objects in Kubernetes.
    In this introductory chapter, we''ll introduce three elementary objects in Kubernetes
    that you will likely see in every application: a Pod, a Deployment, and a Service.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将构建多个在Kubernetes中运行容器的示例，并且你将了解更多关于Kubernetes中不同对象的知识。在这个介绍性的章节中，我们将介绍Kubernetes中的三个基本对象，这些对象在每个应用中都可能会看到：Pod、Deployment和Service。
- en: Pods in Kubernetes
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes中的Pod
- en: A Pod in Kubernetes is the essential scheduling block. A Pod is a group of one
    or more containers. This means a Pod contains either a single container or multiple
    containers. When creating a Pod with a single container, you can use the terms
    container and Pod interchangeably. However, the term Pod is still preferred.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的Pod是基本的调度块。一个Pod是一个或多个容器的组合。这意味着一个Pod可以包含单个容器或多个容器。当创建一个只有一个容器的Pod时，你可以互换使用容器和Pod这两个术语。然而，Pod这个术语仍然更受青睐。
- en: When a Pod contains multiple containers, these containers share the same filesystem
    and the same network namespace. This means that when a container that is part
    of a Pod writes a file, other containers in that same Pod can read that file.
    This also means that all containers in a Pod can communicate with each other using
    `localhost` networking.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个Pod包含多个容器时，这些容器共享相同的文件系统和网络命名空间。这意味着当一个Pod中的容器写入一个文件时，该Pod中的其他容器可以读取该文件。这也意味着Pod中的所有容器可以使用“localhost”网络相互通信。
- en: 'In terms of design, you should only put containers that need to be tightly
    integrated in the same pod. Imagine the following situation: you have an old web
    application that does not support HTTPS. You want to upgrade that application
    to support HTTPS. You could create a Pod that contains your old web application
    and includes another container that would do SSL offloading for that application
    as described in *Figure 1.3*. Your users would connect to your application using
    HTTPS, while the container in the middle converts HTTPS traffic to HTTP:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计方面，你应该只将需要紧密集成的容器放在同一个Pod中。想象一下以下情况：你有一个不支持HTTPS的旧Web应用。你想要升级该应用以支持HTTPS。你可以创建一个包含旧Web应用的Pod，并包含另一个容器，该容器将为该应用执行SSL卸载，如*图1.3*所述。用户将使用HTTPS连接到你的应用，而中间的容器将HTTPS流量转换为HTTP：
- en: '![Example of a multi-container Pod that does HTTPS offloading, illustrating
    how the user makes an HTTPS request to the HTTPS offload container, which in turn
    makes an HTTP request to the old web app within the Pod.](image/Figure_1.3.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![一个执行HTTPS卸载的多容器Pod的示例，说明用户如何向HTTPS卸载容器发出HTTPS请求，然后该容器再向Pod内的旧Web应用发出HTTP请求。](image/Figure_1.3.jpg)'
- en: 'Figure 1.3: Example of a multi-container Pod that does HTTPS offloading'
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.3：执行HTTPS卸载的多容器Pod的示例
- en: Note
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: This design principle is known as a sidecar. Microsoft has a free e-book available
    that describes multiple multi-container Pod designs and designing distributed
    systems ([https://azure.microsoft.com/resources/designing-distributed-systems/](https://azure.microsoft.com/resources/designing-distributed-systems/)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计原则被称为边车。微软提供了一本免费的电子书，描述了多个多容器Pod设计和设计分布式系统（[https://azure.microsoft.com/resources/designing-distributed-systems/](https://azure.microsoft.com/resources/designing-distributed-systems/)）。
- en: A Pod, whether it be a single or a multi-container Pod, is an ephemeral resource.
    This means that a Pod can be terminated at any point and restarted on another
    node. When this happens, the state that was stored in that Pod will be lost. If
    you need to store state in your application, you either need to store that in
    a `StatefulSet`, which we'll touch on in *Chapter 3*, *Application deployment
    on AKS*, or store the state outside of Kubernetes in an external database.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Pod，无论是单个还是多个容器的Pod，都是一个短暂的资源。这意味着Pod可以在任何时候被终止，并在另一个节点上重新启动。当这种情况发生时，存储在该Pod中的状态将丢失。如果您需要在应用程序中存储状态，您需要将其存储在`StatefulSet`中，我们将在*第3章*，*在AKS上部署应用程序*中讨论，或者将状态存储在Kubernetes之外的外部数据库中。
- en: Deployments in Kubernetes
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes中的部署
- en: A Deployment in Kubernetes provides a layer of functionality around Pods. It
    allows you to create multiple Pods from the same definition and to easily perform
    updates to your deployed Pods. A Deployment also helps with scaling your application,
    and potentially even autoscaling your application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的部署提供了围绕Pod的功能层。它允许您从相同的定义中创建多个Pod，并轻松地对部署的Pod进行更新。部署还有助于扩展您的应用程序，甚至可能自动扩展您的应用程序。
- en: Under the covers, a Deployment creates a `ReplicaSet`, which in turn will create
    the Pod you requested. A `ReplicaSet` is another object in Kubernetes. The purpose
    of a `ReplicaSet` is to maintain a stable set of Pods running at any given time.
    If you perform updates to your Deployment, Kubernetes will create a new `ReplicaSet`
    that will contain the updated Pods. By default, Kubernetes will do a rolling upgrade
    to the new version. This means that it will start a few new Pods. If those are
    running correctly, then it will terminate a few old Pods and continue this loop
    until only new Pods are running.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，部署创建一个`ReplicaSet`，然后将创建您请求的Pod。`ReplicaSet`是Kubernetes中的另一个对象。`ReplicaSet`的目的是在任何给定时间维护一组稳定运行的Pod。如果您对部署进行更新，Kubernetes将创建一个包含更新的Pod的新`ReplicaSet`。默认情况下，Kubernetes将对新版本进行滚动升级。这意味着它将启动一些新的Pod。如果这些Pod正常运行，那么它将终止一些旧的Pod并继续这个循环，直到只有新的Pod在运行。
- en: '![A graphical representation of the relationship between Deployments, ReplicaSets,
    and Pods.](image/Figure_1.4.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![部署、ReplicaSet和Pod之间关系的图形表示。](image/Figure_1.4.jpg)'
- en: 'Figure1.4: Relationship between Deployment, ReplicaSet, and Pods'
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.4：部署、ReplicaSet和Pod之间的关系
- en: Services in Kubernetes
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes中的服务
- en: A Service in Kubernetes is a network-level abstraction. This allows you to expose
    the multiple Pods you have in your Deployment under a single IP address and a
    single DNS name.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的服务是一个网络级的抽象。这允许您在单个IP地址和单个DNS名称下公开部署中的多个Pod。
- en: Each Pod in Kubernetes has its own private IP address. You could theoretically
    connect your applications using this private IP address. However, as mentioned
    before, Kubernetes Pods are ephemeral, meaning they can be terminated and moved,
    which would impact their IP address. By using a Service, you can connect your
    applications together using a single IP address. When a Pod moves from one node
    to another, the Service will ensure traffic is routed to the correct endpoint.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的每个Pod都有自己的私有IP地址。理论上，您可以使用这个私有IP地址连接您的应用程序。然而，正如前面提到的，Kubernetes
    Pods是短暂的，这意味着它们可以被终止和移动，这会影响它们的IP地址。通过使用Service，您可以使用单个IP地址将您的应用程序连接在一起。当一个Pod从一个节点移动到另一个节点时，Service将确保流量被路由到正确的端点。
- en: In this section, we have introduced Kubernetes and three essential objects with
    Kubernetes. In the next section, we'll introduce AKS.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了Kubernetes和三个基本对象。在下一节中，我们将介绍AKS。
- en: Azure Kubernetes Service
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure Kubernetes服务
- en: '**Azure Kubernetes Service** (**AKS**) makes creating and managing Kubernetes
    clusters easier.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**Azure Kubernetes服务**（**AKS**）使创建和管理Kubernetes集群变得更容易。'
- en: A typical Kubernetes cluster consists of a number of master nodes and a number
    of worker nodes. A node within Kubernetes is equivalent to a **virtual machine**
    (**VM**). The master nodes contain the Kubernetes API and a database that contains
    the cluster state. The worker nodes are the VMs that run your actual workload.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的Kubernetes集群由多个主节点和多个工作节点组成。Kubernetes中的节点相当于**虚拟机**（**VM**）。主节点包含Kubernetes
    API和包含集群状态的数据库。工作节点是运行实际工作负载的虚拟机。
- en: AKS makes it a lot easier to create a cluster. When you create an AKS cluster,
    AKS sets up the Kubernetes master for you, free of charge. AKS will then create
    VMs in your subscription, and turn those VMs into worker nodes of your Kubernetes
    cluster in your network. You only pay for those VMs; you don't pay for the master.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: AKS使创建集群变得更加容易。当您创建一个AKS集群时，AKS会免费为您设置Kubernetes主节点。然后，AKS将在您的订阅中创建虚拟机，并将这些虚拟机转换为您网络中Kubernetes集群的工作节点。您只需为这些虚拟机付费；您不需要为主节点付费。
- en: Within AKS, Kubernetes Services are integrated with Azure Load Balancer and
    Kubernetes Ingresses are integrated with the application gateway. Azure Load Balancer
    is a layer-4 network load balancer Service; the application gateway is a layer-7
    HTTP-based load balancer. The integration between Kubernetes and both Services
    means that when you create a Service or Ingress in Kubernetes, Kubernetes will
    create a rule in an Azure load balancer or application gateway respectively. Azure
    Load Balancer or Application Gateway will then route the traffic to the right
    node in your cluster that hosts your Pod.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在AKS中，Kubernetes服务与Azure负载均衡器集成，Kubernetes Ingress与应用程序网关集成。Azure负载均衡器是一个第4层网络负载均衡器服务；应用程序网关是一个基于HTTP的第7层负载均衡器。Kubernetes和这两个服务之间的集成意味着当您在Kubernetes中创建一个服务或Ingress时，Kubernetes将在Azure负载均衡器或应用程序网关中分别创建一个规则。Azure负载均衡器或应用程序网关将然后将流量路由到托管您的Pod的集群中的正确节点。
- en: Additionally, AKS adds a number of functionalities that make it easier to manage
    a cluster. AKS contains logic to upgrade clusters to newer Kubernetes versions.
    It also has the ability to easily scale your clusters, either making them bigger
    or smaller.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，AKS添加了许多功能，使得更容易管理集群。AKS包含升级集群到更新的Kubernetes版本的逻辑。它还可以轻松地扩展您的集群，使其变得更大或更小。
- en: The service also comes with integrations that make operations easier. AKS clusters
    come pre-configured with integration with **Azure Active Directory** (**Azure
    AD**) to make managing identities and **role-based access control** (**RBAC**)
    straightforward. RBAC is the configuration process that defines which users get
    access to resources and which actions they can take against those resources. AKS
    is also integrated into Azure Monitor for containers, which makes monitoring and
    troubleshooting your Deployments simpler.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 服务还带有使操作更容易的集成。AKS集群预先配置了与Azure Active Directory（Azure AD）的集成，以便简化身份管理和基于角色的访问控制（RBAC）。RBAC是定义哪些用户可以访问资源以及他们可以对这些资源执行哪些操作的配置过程。AKS还集成到Azure
    Monitor for containers中，这使得监视和排除故障变得更简单。
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we introduced the concepts of Docker and Kubernetes. We ran
    a number of containers, starting with an existing image and then using an image
    we built ourselves. After that demo, we explored three essential Kubernetes objects:
    the Pod, the Deployment, and the Service.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Docker和Kubernetes的概念。我们运行了许多容器，从现有的镜像开始，然后使用我们自己构建的镜像。在演示之后，我们探索了三个基本的Kubernetes对象：Pod、Deployment和Service。
- en: This provides the common context for the remaining chapters, where you will
    deploy Dockerized applications in Microsoft AKS. You will see how the AKS **Platform
    as a Service** (**PaaS**) offering from Microsoft streamlines Deployment by handling
    many of the management and operational tasks that you would have to do yourself
    if you managed and operated your own Kubernetes infrastructure.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这为剩余的章节提供了共同的背景，您将在Microsoft AKS中部署Docker化的应用程序。您将看到，Microsoft的AKS平台即服务（PaaS）提供简化部署，通过处理许多管理和运营任务，您将不得不自行处理这些任务，如果您管理和运营自己的Kubernetes基础设施。
- en: In the next chapter, we will introduce the Azure portal and its components in
    the context of creating your first AKS cluster.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Azure门户及其组件，以便在创建您的第一个AKS集群的情况下使用。
