- en: Memory Management and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理和调试
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Understanding the G1 garbage collector
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解G1垃圾收集器
- en: Unified logging for JVM
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM的统一日志记录
- en: Using the `jcmd` command for JVM
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`jcmd`命令进行JVM
- en: Try-with-resources for better resource handling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用try-with-resources来更好地处理资源
- en: Stack walking for improved debugging
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了改进调试，堆栈遍历
- en: Using the memory-aware coding style
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内存感知的编码风格
- en: Best practices for better memory usage
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好地使用内存的最佳实践
- en: Understand Epsilon, a low-overhead garbage collector
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Epsilon，一种低开销的垃圾收集器
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Memory management is the process of memory allocation for program execution
    and memory reuse after some of the allocated memory is not used anymore. In Java,
    this process is called **garbage collection** (**GC**). The effectiveness of GC
    affects two major application characteristics—responsiveness and throughput.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理是程序执行的内存分配过程，以及一些分配的内存不再使用后的内存重用。在Java中，这个过程被称为**垃圾收集**（**GC**）。GC的有效性影响两个主要应用特性——响应性和吞吐量。
- en: Responsiveness is measured by how quickly an application responds to the request.
    For example, how quickly a website returns a page or how quickly a desktop application
    responds to an event. Naturally, the lower the response time, the better the user
    experience, which is the goal for many applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 响应性是指应用程序对请求的快速响应程度。例如，一个网站返回页面的速度，或者桌面应用程序对事件的快速响应。自然地，响应时间越短，用户体验就越好，这是许多应用程序的目标。
- en: Throughput indicates the amount of work an application can do in a unit of time.
    For example, how many requests a web application can serve or how many transactions
    a database can support. The bigger the number, the more value the application
    can potentially generate and the greater number of users it can accommodate.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 吞吐量表示应用程序在单位时间内可以完成的工作量。例如，一个Web应用程序可以提供多少请求，或者一个数据库可以支持多少交易。数字越大，应用程序可能产生的价值就越大，可以容纳的用户数量也越多。
- en: Not every application needs to have the minimal possible responsiveness and
    the maximum achievable throughput. An application may be an asynchronous submit-and-go-do-something-else,
    which does not require much user interaction. There may be a few potential application
    users too, so a lower-than-average throughput could be more than enough. Yet,
    there are applications that have high requirements to one or both of these characteristics
    and cannot tolerate long pauses imposed by the GC process.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个应用程序都需要具有最小的响应性和最大的可实现吞吐量。一个应用程序可能是异步提交并执行其他操作，不需要太多用户交互。可能也只有少数潜在的应用程序用户，因此低于平均水平的吞吐量可能已经足够了。然而，有些应用程序对这些特性中的一个或两个有很高的要求，并且无法容忍GC过程带来的长时间暂停。
- en: GC, on the other hand, needs to stop any application execution once in a while
    to reassess the memory usage and to release it from data no longer used. Such
    periods of GC activity are called stop-the-world. The longer they are, the quicker
    the GC does its job and the longer an application freeze lasts, which can eventually
    grow big enough to affect both the application responsiveness and throughput.
    If that is the case, the GC tuning and JVM optimization become important and require
    an understanding of the GC principles and their modern implementations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，GC需要偶尔停止任何应用程序执行，重新评估内存使用情况，并释放不再使用的数据。这些GC活动期间被称为停止-世界。它们持续的时间越长，GC完成工作的速度越快，应用程序冻结的时间就越长，最终可能会足够大到影响应用程序的响应性和吞吐量。如果情况如此，GC调优和JVM优化变得重要，并需要理解GC原则及其现代实现。
- en: Unfortunately, this step is often missed by programmers. Trying to improve responsiveness
    and/or throughput, they just add memory and other computing capacities, thereby
    providing the originally-small existing problem with the space to grow. The enlarged
    infrastructure, in addition to hardware and software costs, requires more people
    to maintain it and eventually justifies the building of a whole new organization
    dedicated to keeping up the system. By then, the problem reaches the scale of
    becoming virtually unsolvable and feeds on those who have created it by forcing
    them to do the routine—almost menial—work for the rest of their professional lives.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，程序员经常忽略了这一步。试图改进响应性和/或吞吐量，他们只是增加了内存和其他计算能力，从而为最初较小的现有问题提供了增长的空间。扩大的基础设施，除了硬件和软件成本外，还需要更多的人来维护，最终证明需要建立一个专门的组织来维护系统。到那时，问题已经达到了几乎无法解决的规模，并且通过迫使他们为其余的职业生涯做例行的——几乎是琐碎的——工作，滋养了那些创造它的人。
- en: In this chapter, we will focus on the **Garbage-First** (**G1**) garbage collector,
    which is the default one since Java 9\. However, we'll also refer to a few other
    available GC implementations to contrast and explain some design decisions that
    have brought G1 to life. Besides, they might be more appropriate than G1 for some
    of the applications.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注**Garbage-First**（**G1**）垃圾收集器，这是自Java 9以来的默认收集器。然而，我们也会提到其他几种可用的GC实现，以对比和解释一些设计决策，这些决策使G1得以诞生。此外，它们可能比G1更适合某些应用程序。
- en: Memory organization and management are very specialized and complex areas of
    expertise in JVM development. This book is not intended to address the implementation
    details on such a level. Our focus is on those aspects of GC that can help an
    application developer to tune it for the application needs by setting the corresponding
    parameters of JVM runtime.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 内存组织和管理是JVM开发中非常专业和复杂的领域。本书不打算在这个层面上解决实现细节。我们的重点是GC的那些方面，可以通过设置JVM运行时的相应参数，帮助应用程序开发人员调整应用程序的需求。
- en: There are two memory areas that are used by GC—heap and stack. The first one
    is used by JVM to allocate memory and store objects created by the program. When
    an object is created with the `new` keyword, it is located in the heap, and the
    reference to it is stored in the stack. The stack also stores primitive variables
    and references to heap objects that are used by the current method or thread.
    The stack operates in **Last-In-First-Out** (**LIFO**). The stack is much smaller
    than the heap.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: GC使用的两个内存区域是堆和栈。第一个由JVM用于分配内存和存储程序创建的对象。当使用`new`关键字创建对象时，它位于堆中，并且对它的引用存储在栈中。栈还存储原始变量和当前方法或线程使用的堆对象的引用。栈以**后进先出**（**LIFO**）的方式操作。栈比堆小得多。
- en: The slightly simplistic, but good enough for our purpose, high-level view of
    the main activity of any GC is the following—walking through objects in the heap
    and removing those that don’t have any references in the stack.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何GC的略微简化但足够好的高层次视图是—遍历堆中的对象并删除那些在堆栈中没有引用的对象。
- en: Understanding the G1 garbage collector
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解G1垃圾收集器
- en: The previous GC implementations include the **Serial GC**, **Parallel GC**,
    and **Concurrent Mark-Sweep** (**CMS**) collector. They divide the heap into three
    sections—young generation, old or tenured generation, and humongous regions for
    holding the objects that are 50% of the size of a standard region or larger. The
    young generation contains most of the newly created objects; this is the most
    dynamic area because a majority of the objects are short-lived and soon (as they
    age) become eligible for collection. The term age refers to the number of collection
    cycles the object has survived. The young generation has three collection cycles—
    an *Eden space* and two survivor spaces, such as survivor 0 (*S0*) and survivor
    1 (*S1*). The objects are moved through them (according to their age and some
    other characteristics) until they are eventually discarded or placed in the old
    generation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的GC实现包括**串行GC**、**并行GC**和**并发标记-清除**（**CMS**）收集器。它们将堆分成三个部分—年轻代、老年代或终身代和用于容纳大小为标准区域的50%或更大的对象的巨大区域。年轻代包含大部分新创建的对象；这是最动态的区域，因为大多数对象的寿命很短，很快（随着它们的年龄）就有资格进行收集。术语年龄指的是对象存活的收集周期数。年轻代有三个收集周期—伊甸空间和两个幸存者空间，如幸存者0（*S0*）和幸存者1（*S1*）。对象会根据它们的年龄和其他一些特征移动到这些空间中，直到它们最终被丢弃或放入老年代。
- en: The old generation contains objects that are older than a certain age. This
    area is bigger than the young generation, and because of this, the garbage collection
    here is more expensive and happens not as often as in the young generation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 老年代包含比一定年龄更老的对象。这个区域比年轻代大，因此这里的垃圾收集更昂贵，发生的频率也不如年轻代频繁。
- en: The permanent generation contains metadata that describes the classes and methods
    used in applications. It also stores strings, library classes, and methods.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 永久代包含描述应用程序中使用的类和方法的元数据。它还存储字符串、库类和方法。
- en: When JVM starts, the heap is empty and then the objects are pushed into Eden.
    When it is filling up, a minor GC process starts. It removes the unreferenced
    and circular referred objects and moves the others to the *S0* area.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: JVM启动时，堆是空的，然后对象被推送到伊甸园。当它填满时，一个小的GC过程开始。它移除了未引用和循环引用的对象，并将其他对象移动到*S0*区域。
- en: The next minor GC process migrates the referenced objects to *S1* and increments
    the age of those that survived the previous minor collection. After all the surviving
    objects (of different ages) are moved to *S1*, both *S0* and Eden become empty.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的小GC过程将引用的对象迁移到*S1*，并增加了在上一次小集合中幸存的对象的年龄。在所有幸存的对象（不同年龄的对象）都移动到*S1*后，*S0*和伊甸园都变为空。
- en: In the next minor collection, *S0* and *S1* switch their roles. The referenced
    objects are moved from Eden to *S1* and from *S1* to *S0*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一次小集合中，*S0*和*S1*交换它们的角色。引用的对象从伊甸园移动到*S1*，从*S1*移动到*S0*。
- en: In each of the minor collections, the objects that have reached a certain age
    are moved to the old generation. As we mentioned earlier, the old generation is
    checked eventually (after several minor collections), the unreferenced objects
    are removed from there, and the memory is defragmented. This cleaning of the old
    generation is considered a major collection.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次小集合中，已经达到一定年龄的对象被移动到老年代。正如我们之前提到的，老年代最终会被检查（经过几次小集合后），未引用的对象将从中移除，并且内存将被碎片整理。这种对老年代的清理被认为是一次大集合。
- en: The permanent generation is cleaned at different times by different GC algorithms.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 永久代由不同的GC算法在不同的时间进行清理。
- en: The G1 GC does it somewhat differently. It divides the heap into equal-sized
    regions and assigns each of them one of the same roles—Eden, survivor, or old—but
    changes the number of regions with the same role dynamically, depending on the
    need. It makes the memory-cleaning process and the memory defragmentation more
    predictable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: G1 GC做法略有不同。它将堆分成相等大小的区域，并为每个区域分配相同的角色—伊甸园、幸存者或老年代—但根据需要动态地改变具有相同角色的区域数量。这使得内存清理过程和内存碎片整理更加可预测。
- en: Getting ready
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The serial GC cleans the young and the old generations in the same cycle (serially,
    thus the name). During the task, it stops the world. That is why it is used for
    non-server applications with one CPU and a heap size of a few hundred MB.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 串行GC在同一个周期内清理年轻代和老年代（串行地，因此得名）。在执行任务期间，它会停止世界。这就是为什么它适用于只有一个CPU和堆大小为几百MB的非服务器应用程序。
- en: The parallel GC works in parallel on all available cores, although the number
    of threads can be configured. It also stops the world and is appropriate only
    for applications that can tolerate long freezing times.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 并行GC在所有可用核心上并行工作，尽管线程数量可以进行配置。它也会停止世界，只适用于可以容忍长时间冻结的应用程序。
- en: The CMS collector was designed to address this issue of long pauses. It does
    it at the expense of not defragmenting the old generation and doing some analysis
    in parallel to the application execution (typically using 25% of CPU). The collection
    of the old generation starts when it is 68% full (by default, but this value can
    be configured).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: CMS收集器旨在解决长时间暂停的问题。它以不对旧一代进行碎片整理和在应用程序执行期间进行一些分析（通常使用25%的CPU）为代价。旧一代的收集在其占用空间达到68%时开始（默认情况下，但此值可以配置）。
- en: The G1 GC algorithm is similar to the CMS collector. First, it concurrently
    identifies all the referenced objects in the heap and marks them correspondingly.
    Then it collects the emptiest regions first, thereby releasing a lot of free space.
    That's why it is called *Garbage-First*. Because it uses many small dedicated
    regions, it has a better chance of predicting the amount of time it needs to clean
    one of them and in fitting a user-defined pause time (G1 may exceed it occasionally,
    but it is pretty close most of the times).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: G1 GC算法类似于CMS收集器。首先，它并发地识别堆中的所有引用对象并相应地标记它们。然后，它首先收集最空的区域，从而释放大量的空间。这就是为什么它被称为*垃圾优先*。因为它使用许多小的专用区域，它有更好的机会来预测清理一个区域所需的时间，并适应用户定义的暂停时间（G1偶尔可能超出，但大多数情况下非常接近）。
- en: The main beneficiaries of G1 are applications that require large heaps (6 GB
    or more) and do not tolerate long pauses (0.5 seconds or less). If an application
    encounters an issue of too many and/or too-long pauses, it can benefit from switching
    from the CMS or parallel GC (especially the parallel GC of the old generation)
    to the G1 GC. If that is not the case, switching to the G1 collector is not a
    requirement when using JDK 9 or higher.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: G1的主要受益者是需要大堆（6GB或更多）且不能容忍长时间暂停（0.5秒或更短）的应用程序。如果应用程序遇到太多或太长时间的暂停问题，可以从CMS或并行GC（特别是旧一代的并行GC）切换到G1
    GC获益。如果不是这种情况，在使用JDK 9或更高版本时，切换到G1收集器不是必需的。
- en: 'The G1 GC starts with the young generation collection using stop-the-world
    pauses for evacuation (moving objects inside the young generation and out to the
    old generation). After the occupancy of the old generation reaches a certain threshold,
    it is collected too. The collection of some of the objects in the old generation
    is done concurrently and some objects are collected using stop-the-world pauses. The
    steps include the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: G1 GC从年轻代开始收集，使用停顿世界暂停进行疏散（将年轻代内部和旧一代之间的对象移动）。当旧一代的占用达到一定阈值后，也会进行收集。旧一代中的一些对象是并发收集的，而一些对象是使用停顿世界暂停进行收集的。步骤包括以下内容：
- en: The initial marking of the survivor regions (root regions), which may have references
    to objects in the old generation, done using stop-the-world pauses
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幸存者区域（根区域）的初始标记，可能引用旧一代的对象，使用停顿世界暂停来完成
- en: The scanning of survivor regions for references to the old generation, done
    concurrently while the application continues to run
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描幸存者区域以查找对旧一代的引用，与此同时应用程序继续运行
- en: The concurrent marking of live objects over the entire heap, done concurrently
    while the application continues to run
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在整个堆上并发标记活动对象，同时应用程序继续运行
- en: The remark step completes the marking of live objects, done using stop-the-world
    pauses
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备注步骤完成了活动对象的标记，使用停顿世界暂停来完成
- en: The cleanup process calculates the age of live objects, frees the regions (using
    stop-the-world pauses), and returns them to the free list (concurrently)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理过程计算活动对象的年龄，释放区域（使用停顿世界暂停），并将它们返回到空闲列表（并发进行）
- en: The preceding sequence might be interspersed with young generation evacuations
    because most of the objects are short-lived and it is easier to free a lot of
    memory by scanning the young generation more often.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的序列可能会与年轻代疏散交错，因为大多数对象的生命周期很短，通过更频繁地扫描年轻代来释放大量内存更容易。
- en: There is also a mixed phase when G1 collects the regions already marked as mostly
    garbage in both the young and old generations, and humongous allocation when large
    objects are moved to or evacuated from humongous regions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个混合阶段，当G1收集已标记为大部分垃圾的年轻代和旧一代的区域时，以及巨大分配，当大对象被移动到或从巨大区域疏散时。
- en: 'There are a few occasions when full GC is performed, using stop-the-world pauses:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下会执行完全GC，使用停顿世界暂停：
- en: '**Concurrent failure**: This happens if the old generation gets full during
    the marking phase'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发失败**：如果在标记阶段旧一代占满空间'
- en: '**Promotion failure**: This happens if the old generation runs out of space
    during the mixed phase'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提升失败**：如果在混合阶段旧一代空间不足时发生'
- en: '**Evacuation failure**: This happens when the collector cannot promote objects
    to the survivor space and the old generation'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**疏散失败**：当收集器无法将对象提升到幸存者空间和旧一代时发生'
- en: '**Humongous allocation**: This happens when an application tries to allocate
    a very big object'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**巨大分配**：当应用程序尝试分配一个非常大的对象时发生'
- en: If tuned properly, your applications should avoid full GC.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正确调整，您的应用程序应该避免完全GC。
- en: 'To help with GC tuning, JVM documentation ([https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html))
    describes ergonomics as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助GC调优，JVM文档（[https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html)）描述了人体工程学如下：
- en: '"*Ergonomics is t*he process by which* JVM and garbage collection tuning, such
    as behavior-based tuning, improve application performance. The JVM provides platform-dependent
    default selections for the garbage collector, heap size, and runtime compiler.
    These selections match the needs of different types of applications while requiring
    less command-line tuning. In addition, behavior-based tuning dynamically tunes
    the sizes of the heap to meet a specified behavior of the application.*"'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: “*自适应性是JVM和垃圾收集调整的过程，例如基于行为的调整，它提高了应用程序的性能。JVM为垃圾收集器、堆大小和运行时编译器提供了平台相关的默认选择。这些选择符合不同类型应用程序的需求，同时需要较少的命令行调整。此外，基于行为的调整动态调整堆的大小，以满足应用程序的指定行为。”
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To see how GC works, write the following program:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要了解GC的工作原理，请编写以下程序：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, it creates 99,888,999 objects and adds them to the `List<AnObject>
    list` collection. You might tune it by decreasing the maximum number of objects
    (`max`) to match the configuration of your computer.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它创建了99,888,999个对象，并将它们添加到`List<AnObject> list`集合中。您可以通过减少对象的最大数量（`max`）来调整它，以匹配您计算机的配置。
- en: 'The G1 GC is the default collector since Java 9, so you don''t have to set
    anything if it is good enough for your application. Nevertheless, you can explicitly
    enable G1 by providing `-XX:+UseG1GC` on the command line:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自Java 9以来，G1 GC是默认收集器，因此如果对您的应用程序足够好，您无需设置任何内容。尽管如此，您可以通过在命令行上提供`-XX:+UseG1GC`来显式启用G1：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that we assume you can build an executable `.jar` file and understand the
    basic Java execution command. If not, please refer to the JVM documentation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们假设您可以构建一个可执行的`.jar`文件并理解基本的Java执行命令。如果不行，请参考JVM文档。
- en: 'Other available GCs can be used by setting one of the following options:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可用的GC可以通过设置以下选项之一来使用：
- en: '`-XX:+UseSerialGC` for using a serial collector.'
  id: totrans-61
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:+UseSerialGC`用于使用串行收集器。'
- en: '`-XX:+UseParallelGC` for using a parallel collector with parallel compaction
    (which enables the parallel collector to perform major collections in parallel).
    Without parallel compaction, major collections are performed using a single thread,
    which can significantly limit the scalability. Parallel compaction is disabled
    by the `-XX:+UseParallelOldGC` option.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:+UseParallelGC`用于使用带有并行压缩的并行收集器（这使得并行收集器可以并行执行主要收集）。没有并行压缩，主要收集将使用单个线程执行，这可能会严重限制可伸缩性。通过`-XX:+UseParallelOldGC`选项禁用并行压缩。'
- en: '`-XX:+UseConcMarkSweepGC` for using the CMS collector.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -XX:+UseConcMarkSweepGC 用于使用CMS收集器。
- en: 'To see the log messages of GC, set `-Xlog:gc`. You can also use the Unix utility, `time`,
    to measure the time it took to do the job (the utility publishes the last three
    lines of the output, so you do not need to use it if you cannot or do not want
    to do it):'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看GC的日志消息，请设置`-Xlog:gc`。您还可以使用Unix实用程序`time`来测量完成作业所需的时间（该实用程序会发布输出的最后三行，因此如果您无法或不想使用它，则无需使用它）：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the preceding command. The output may look as follows (the actual values
    may be different on your computer):'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行上述命令。输出可能如下所示（实际值可能在您的计算机上有所不同）：
- en: '![](img/559f97f3-d6c4-40f6-8656-ba6b3a7f2834.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/559f97f3-d6c4-40f6-8656-ba6b3a7f2834.png)'
- en: As you can see, the GC went through most of the steps we have described. It
    has started with collecting the young generation. Then, when the `List<AnObject>
    list` object (see the preceding code) becomes too big (more than 50% of a young
    generation region), the memory for it is allocated in the *humongous* region.
    You can also see the initial mark step, the following remark, and other steps
    described earlier.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，GC经历了我们描述的大部分步骤。它从收集年轻代开始。然后，当`List<AnObject> list`对象（请参阅前面的代码）变得太大（超过年轻代区域的50%以上）时，为其分配内存到*巨大*区域。您还可以看到初始标记步骤、随后的重新标记和其他先前描述的步骤。
- en: 'Each line starts with the time (in seconds) the JVM was running for and ends
    with the time (in milliseconds) that every step took. At the bottom of the screenshot,
    we see three lines printed by the `time` utility:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每行以JVM运行的时间（以秒为单位）开头，并以每个步骤花费的时间（以毫秒为单位）结尾。在屏幕截图的底部，我们看到了`time`实用程序打印的三行：
- en: '`real` is the amount of wall clock time spent—all the time elapsed (should
    align with the first column of the JVM uptime value) since the command was run'
  id: totrans-70
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`real`是花费的挂钟时间量——自命令运行以来经过的所有时间（应与JVM正常运行时间值的第一列对齐）'
- en: '`user` is the amount of time all the CPUs spent in the user-mode code (outside
    the kernel) within the process; it is bigger because GC worked concurrently with
    the application'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`是进程中所有CPU在用户模式代码（内核外）中花费的时间量；它更大是因为GC与应用程序并发工作。'
- en: '`sys` is the amount of time the CPU spent in the kernel within the process'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sys` 是CPU在进程内核中花费的时间量'
- en: '`user`+`sys` is the amount of CPU time the process used'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`+`sys`是进程使用的CPU时间量'
- en: 'Set the `-XX:+PrintGCDetails` option (or just add `*` to the log option, `-Xlog:gc*`)
    to see more details about GC activity. In the following screenshot, we provide
    only the beginning of the log related to GC step 0:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`-XX:+PrintGCDetails`选项（或只需在日志选项`-Xlog:gc*`中添加`*`）以查看有关GC活动的更多详细信息。在以下屏幕截图中，我们仅提供了与GC步骤0相关的日志的开头：
- en: '![](img/99a97b8a-3f4b-44ef-bff8-1001d7346e0c.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99a97b8a-3f4b-44ef-bff8-1001d7346e0c.png)'
- en: Now the log has more than a dozen entries for each of the GC steps and ends
    up with logging the `User`, `Sys`, and `Real` amount of time (the amounts accumulated
    by the `time` utility) each step took. You can modify the program by adding more
    short-lived objects, for example, and see how the GC activity changes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在日志中有超过十几个条目，每个GC步骤都以记录`User`、`Sys`和`Real`时间量（由`time`实用程序累积的时间量）结束。您可以通过添加更多的短寿命对象来修改程序，例如，看看GC活动如何改变。
- en: 'Get even more information with the `-Xlog:gc*=debug` option. The following
    is only a fragment of an output:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-Xlog:gc*=debug`选项获取更多信息。以下仅为输出的一部分：
- en: '![](img/2b425d3d-0e6e-4cb2-9900-2a001530b65e.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b425d3d-0e6e-4cb2-9900-2a001530b65e.png)'
- en: So, it is up to you to choose how much info you need for the analysis.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以选择需要多少信息进行分析。
- en: We will discuss more details of the logging format and other log options in
    the *Unified logging for the JVM* recipe.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在《JVM统一日志记录》中讨论日志格式和其他日志选项的更多细节。
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'As we have mentioned earlier, the G1 GC uses default ergonomic values that
    probably would be good enough for most applications. Here is the list of the most
    important ones (`<ergo>` means that the actual value is determined ergonomically
    depending on the environment):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，G1 GC使用默认的人体工程学值，这些值对于大多数应用程序来说可能已经足够好了。以下是最重要的一些值的列表（`<ergo>`表示实际值是根据环境人体工程学确定的）：
- en: '`-XX:MaxGCPauseMillis=200`: Holds the value for the maximum pause time'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -XX:MaxGCPauseMillis=200：保持最大暂停时间的值
- en: '`-XX:GCPauseTimeInterval=<ergo>`: Holds the maximum pause time between GC steps
    (not set by default, allowing G1 to perform garbage collections back to back if
    needs be)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -XX:GCPauseTimeInterval=<ergo>：保持GC步骤之间的最大暂停时间（默认情况下未设置，允许G1在需要时连续执行垃圾收集）
- en: '`-XX:ParallelGCThreads=<ergo>`: Holds the maximum number of threads used for
    parallel work during garbage collection pauses (by default, derived from the number
    of available threads; if the number of CPU threads available to the process is
    less than or equal to eight, it uses this number; otherwise, it adds five-eighths
    of the threads greater than eight to the final number of threads)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -XX:ParallelGCThreads=<ergo>：保持在垃圾收集暂停期间用于并行工作的最大线程数（默认情况下，从可用线程数派生；如果可用于进程的CPU线程数小于或等于八，它使用这个数字；否则，它将大于八的五分之八的线程添加到最终线程数中）
- en: '`-XX:ConcGCThreads=<ergo>`: Holds the maximum number of threads used for concurrent
    work (set by default as `-XX:ParallelGCThreads` divided by four).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -XX:ConcGCThreads=<ergo>：保持用于并发工作的最大线程数（默认设置为`-XX:ParallelGCThreads`除以四）。
- en: '`-XX:+G1UseAdaptiveIHOP`: Indicates that the initiating heap occupancy should
    be adaptive'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -XX:+G1UseAdaptiveIHOP：表示启动堆占用应该是自适应的
- en: '`-XX:InitiatingHeapOccupancyPercent=45`: Sets the first few collection cycles;
    G1 will use an occupancy of 45% of the old generation as the mark start threshold'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -XX:InitiatingHeapOccupancyPercent=45：设置了最初的几个收集周期；G1将使用老年代45%的占用作为标记开始阈值
- en: '`-XX:G1HeapRegionSize=<ergo>`: Holds the heap region size based on the initial
    and maximum heap sizes (by default, because the heap contains roughly 2,048 heap
    regions, the size of a heap region can vary from 1 to 32 MB and must be a power
    of 2)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -XX:G1HeapRegionSize=<ergo>：根据初始和最大堆大小保持堆区域大小（默认情况下，因为堆包含大约2048个堆区域，堆区域的大小可以从1到32
    MB不等，并且必须是2的幂）
- en: '`-XX:G1NewSizePercent=5` and`-XX:XX:G1MaxNewSizePercent=60`: Define the size
    of the young generation in total, which varies between these two values as percentages
    of the current JVM heap in use'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -XX:G1NewSizePercent=5和-XX:XX:G1MaxNewSizePercent=60：定义了年轻代的总大小，它们作为当前JVM堆使用百分比在这两个值之间变化
- en: '`-XX:G1HeapWastePercent=5`: Holds the allowed unreclaimed space in the collection-set
    candidates as a percentage (G1 stops the space reclamation if the free space in
    the collection-set candidates is lower than that)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -XX:G1HeapWastePercent=5：保持收集集候选对象中允许的未回收空间的百分比（如果收集集候选对象中的空闲空间低于此值，G1将停止空间回收）
- en: '`-XX:G1MixedGCCountTarget=8`: Holds the expected length of the space-reclamation
    phase in a number of collections)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -XX:G1MixedGCCountTarget=8：保持空间回收阶段的预期长度（以收集次数计算）
- en: '`-XX:G1MixedGCLiveThresholdPercent=85`: Holds the percentage of the live object
    occupancy of the old generation regions, after which a region won''t be collected
    in this space-reclamation phase'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -XX:G1MixedGCLiveThresholdPercent=85：保持老年代区域中存活对象占用的百分比，超过这个百分比的区域将不会在空间回收阶段被收集
- en: In general, the G1 goals in the default configuration are "to provide relatively
    small, uniform pauses at high throughput"(from the G1 documentation). If these
    default settings do not fit your application, you can change the pause time (using
    `-XX:MaxGCPauseMillis`) and the maximum Java heap size (using the `-Xmx` option).
    Note, though, that the actual pause time will not be an exact match at runtime,
    but G1 will try its best to meet the goal.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，默认配置下G1的目标是“在高吞吐量下提供相对较小、均匀的暂停”（来自G1文档）。如果这些默认设置不适合您的应用程序，您可以改变暂停时间（使用`-XX:MaxGCPauseMillis`）和最大Java堆大小（使用`-Xmx`选项）。但请注意，实际的暂停时间在运行时不会完全匹配，但G1会尽力满足目标。
- en: If you would like to increase the throughput, decrease the pause time goal or
    request a larger heap. To increase responsiveness, change the pause time value.
    Note, though, that the limiting of the young generation size (using `-Xmn`, `-XX:NewRatio`, or other
    options) can impede the pause-time control because "the young generation size
    is the main means for G1 to allow it to meet the pause time"(from the G1 documentation).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想增加吞吐量，可以减少暂停时间目标或请求更大的堆。要增加响应性，改变暂停时间值。但请注意，限制年轻代大小（使用`-Xmn`，`-XX:NewRatio`或其他选项）可能会妨碍暂停时间控制，因为“年轻代大小是G1允许其满足暂停时间的主要手段”（来自G1文档）。
- en: 'One of the first possible causes of poor performance can be full GC triggered
    by a too-high heap occupancy in the old generation. This situation can be detected
    by the presence of *Pause Full (Allocation failure)* in the log. It usually happens
    when too many objects are created in a quick succession (and cannot be collected
    quickly enough) or many large (humongous) objects cannot be allocated in a timely
    manner. There are several recommended ways to handle this condition:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 性能不佳的一个可能原因是由于老年代堆占用过高而触发了Full GC。这种情况可以通过日志中出现*Pause Full (Allocation failure)*来检测到。通常发生在对象快速创建过多（无法及时回收）或者许多大型（巨大）对象无法及时分配的情况下。有几种推荐的处理这种情况的方法：
- en: In the case of an excessive number of humongous objects, try to reduce their
    count by increasing the region size, using the `-XX:G1HeapRegionSize` option (the
    currently selected heap region size is printed at the beginning of the log).
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在出现过多的巨大对象的情况下，尝试通过增加区域大小，使用`-XX:G1HeapRegionSize`选项来减少它们的数量（当前选择的堆区域大小在日志开头打印出来）。
- en: Increase the size of the heap.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加堆的大小。
- en: Increase the number of concurrent marking threads by setting `-XX:ConcGCThreads`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设置`-XX:ConcGCThreads`增加并发标记线程的数量。
- en: Facilitate the beginning of marking earlier (using the fact that G1 makes the
    decisions based on earlier application behavior). Increase the buffer used in
    an adaptive IHOP calculation by modifying `-XX:G1ReservePercent`, or disable the
    adaptive calculation of the IHOP by setting it manually using `-XX:-G1UseAdaptiveIHOP`
    and `-XX:InitiatingHeapOccupancyPercent`.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '通过修改`-XX:G1ReservePercent`增加自适应IHOP计算中使用的缓冲区，或者通过`-XX:-G1UseAdaptiveIHOP`和`-XX:InitiatingHeapOccupancyPercent`手动设置禁用IHOP的自适应计算，促进更早的标记开始（利用G1基于更早应用行为做出决策的事实）。 '
- en: 'Only after addressing full GC can one start tuning the JVM for better responsiveness
    and/or throughput. The JVM documentation identifies the following cases for responsiveness
    tuning:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在解决了完整的GC后，才能开始调整JVM以获得更好的响应和/或吞吐量。JVM文档确定了以下情况需要调整响应性：
- en: Unusual system or real-time usage
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常系统或实时使用
- en: Reference processing takes too long
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用处理需要太长时间
- en: Young-only collections take too long
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅年轻代收集需要太长时间
- en: Mixed collections take too long
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合集合需要太长时间
- en: High update RS and scan RS times
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高更新RS和扫描RS时间
- en: Better throughput can be achieved by decreasing the overall pause times and
    the frequency of the pauses. Refer to the JVM documentation for the identification
    and recommendations of mitigating the issues.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过减少总暂停时间和暂停频率来实现更好的吞吐量。请参考JVM文档以识别和建议减轻问题。
- en: Unified logging for JVM
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM的统一日志记录
- en: 'The main components of JVM include the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: JVM的主要组件包括以下内容：
- en: Classloader
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类加载器
- en: 'JVM memory where the runtime data is stored; it is broken down into the following
    areas:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM内存，运行时数据存储在其中；它分为以下几个区域：
- en: Stack area
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈区域
- en: Method area
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法区域
- en: Heap area
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆区域
- en: PC registers
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PC寄存器
- en: Native method stack
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地方法栈
- en: 'Execution engine, which consists of the following parts:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行引擎，包括以下部分：
- en: Interpreter
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器
- en: The JIT compiler
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JIT编译器
- en: Garbage collection
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾收集
- en: Native method interface JNI
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地方法接口JNI
- en: Native method library
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地方法库
- en: The log message of all these components can now be captured and analyzed using
    unified logging, turned on by the `-Xlog` option.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用统一日志记录所有这些组件的日志消息，并通过`-Xlog`选项打开。
- en: 'The main features of the new logging system are as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 新日志系统的主要特点如下：
- en: Usage of the log levels—`trace`, `debug`, `info`, `warning`, `error`
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志级别的使用——`trace`、`debug`、`info`、`warning`、`error`
- en: Message tags that identify the JVM component, action, or message of a specific
    interest
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识JVM组件、操作或特定感兴趣消息的消息标签
- en: Three output types—`stdout`, `stderr`, and `file`
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三种输出类型——`stdout`、`stderr`和`file`
- en: The enforcement of the one-message-per-line limit
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制每行限制一个消息
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To see all the logging possibilities at a glance, you can run the following
    command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要一目了然地查看所有日志可能性，可以运行以下命令：
- en: '[PRE3]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is the output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![](img/788ed104-16ed-496b-90d0-b8d535eca63d.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/788ed104-16ed-496b-90d0-b8d535eca63d.png)'
- en: 'As you can see, the format of the `-Xlog` option is defined as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`-Xlog`选项的格式定义如下：
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s explain the option in detail:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细解释一下这个选项：
- en: '`what` is a combination of tags and levels of the `tag1[+tag2...][*][=level][,...]` form.
    We have already demonstrated how this construct works when we used the `gc` tag
    in the `-Xlog:gc*=debug` option. The wildcard (`*`) indicates that you''d like to
    see all the messages that have the `gc` tag (maybe among other tags). An absence
    of the `-Xlog:gc=debug` wildcard indicates that you would like to see messages
    marked by one tag (`gc`, in this case) only. If only `-Xlog` is used, the log
    will show all the messages at the `info` level.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`what`是`tag1[+tag2...][*][=level][,...]`形式的标签和级别的组合。我们已经演示了当我们在`-Xlog:gc*=debug`选项中使用`gc`标签时，这个结构是如何工作的。通配符（`*`）表示您想要查看所有具有`gc`标签的消息（可能是其他标签中的一部分）。`-Xlog:gc=debug`中缺少通配符表示您只想看到由一个标签（在本例中为`gc`）标记的消息。如果只使用`-Xlog`，日志将以`info`级别显示所有消息。'
- en: The `output` sets the type of output (the default is `stdout`).
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output`设置输出类型（默认为`stdout`）。'
- en: The `decorators` indicate what will be placed at the beginning of each line
    of the log (before the actual log message comes from a component). Default decorators
    are `uptime`, `level`, and `tags`, each included in square brackets.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decorators`指示日志每行的开头将放置什么（在实际日志消息来自组件之前）。默认的`decorators`是`uptime`、`level`和`tags`，每个都包含在方括号中。'
- en: '`output_options` may include `filecount=file count` and/or `filesize=file size`
    with optional K, M or G suffix.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output_options`可能包括`filecount=file count`和/或`filesize=file size`，可选的K、M或G后缀。'
- en: 'To summarize, the default log configuration is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，默认的日志配置如下：
- en: '[PRE5]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s run some of the log settings:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一些日志设置：
- en: 'Run the following command:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE6]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are no messages because the JVM does not log messages with the `cpu` tag
    only. The tag is used in combination with other tags.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 没有消息是因为JVM不仅使用`cpu`标签记录消息。该标签与其他标签结合使用。
- en: 'Add a `*` sign and run the command again:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`*`号并再次运行命令：
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The result will look as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/4566a7ef-010f-4d35-ab73-cdba7dd3f4a9.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4566a7ef-010f-4d35-ab73-cdba7dd3f4a9.png)'
- en: As you can see, the `cpu` tag brings only messages about how long it took a
    garbage collection to execute. Even if we set the log level to `trace` or `debug`
    (`-Xlog:cpu*=debug`, for example), no other messages will be shown.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`cpu`标签只会显示垃圾收集执行所需的时间。即使我们将日志级别设置为`trace`或`debug`（例如`-Xlog:cpu*=debug`），也不会显示其他消息。
- en: 'Run the command with the `heap` tag:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`heap`标签运行命令：
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You will only get heap-related messages:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您将只收到与堆相关的消息：
- en: '![](img/c81bd5b6-448f-48d3-b5d4-af99a70f1f13.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c81bd5b6-448f-48d3-b5d4-af99a70f1f13.png)'
- en: But let's look closer at the first line. It starts with three decorators—`uptime`,
    `log level`, and `tags`—and then with the message itself, which starts with the
    collection cycle number (0 in this case) and the information that the number of
    Eden regions dropped from 24 to 0 (and their count now is 9). It happened because
    (as we see in the next line) the count of survivor regions grew from 0 to 3 and
    the count of the old generation (the third line) grew to 18, while the count of
    humongous regions (23) did not change. These are all the heap-related messages
    in the first collection cycle. Then, the second collection cycle starts.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们仔细看看第一行。它以三个装饰符开头——`uptime`、`log level`和`tags`——然后是消息本身，它以收集周期编号（在本例中为0）开头，以及Eden区域的数量从24下降到0（现在的数量为9）的信息。这是因为（正如我们在下一行中看到的那样）幸存者区域的数量从0增加到3，老年代的数量（第三行）增加到18，而巨大区域的数量（23）没有改变。这些都是第一个收集周期中与堆相关的消息。然后，第二个收集周期开始。
- en: 'Add the `cpu` tag again and run:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次添加`cpu`标签并运行：
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, the `cpu` message shows how long each cycle took:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`cpu`消息显示了每个周期的持续时间：
- en: '![](img/f3cfeb83-7d29-427b-a784-3905350fbd00.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3cfeb83-7d29-427b-a784-3905350fbd00.png)'
- en: Try to use two tags combined via the `+` sign (`-Xlog:gc+heap`, for example).
    It brings up only the messages that have both tags (similar to the binary `AND`
    operation). Note that a wildcard will not work together with the `+` sign (`-Xlog:gc*+heap`,
    for example, does not work).
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用通过`+`符号组合的两个标签（例如`-Xlog:gc+heap`）。它只会显示具有这两个标签的消息（类似于二进制的`AND`操作）。请注意，通配符将无法与`+`符号一起使用（例如，`-Xlog:gc*+heap`不起作用）。
- en: 'You can also select the output type and decorators. In practice, the decorator
    level does not seem very informative and can be easily omitted by explicitly listing
    only the decorators that are needed. Consider the following example:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以选择输出类型和装饰符。实际上，装饰符级别似乎并不是非常信息丰富，可以通过明确列出仅需要的装饰符来轻松省略。考虑以下示例：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note how the two colons (`::`) were inserted to preserve the default setting
    of the output type. We could also show it explicitly:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何插入两个冒号（`::`）以保留输出类型的默认设置。我们也可以明确显示它：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To remove any decoration, one can set them to `none`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除任何装饰，可以将它们设置为`none`：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The most useful aspect of a new logging system is tag selection. It allows a
    better analysis of the memory evolution of each JVM component and its subsystems
    or to find the performance bottleneck, analyzing the time spent in each collection
    phase—both are critical for the JVM and application tuning.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 新日志系统最有用的方面是标签选择。它允许更好地分析每个JVM组件及其子系统的内存演变，或者找到性能瓶颈，分析在每个收集阶段花费的时间——这两者对于JVM和应用程序调优都至关重要。
- en: Using the jcmd command for the JVM
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JVM的jcmd命令
- en: If you open the `bin` folder of the Java installation, you can find quite a
    few command-line utilities there that can be used to diagnose issues and monitor
    an application deployed with the **Java Runtime Environment** (**JRE**). They use
    different mechanisms to get the data they report. The mechanisms are specific
    to the **Virtual Machine** (**VM**) implementation, operating systems, and release.
    Typically, only a subset of the tools is applicable to a given issue.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果打开Java安装的`bin`文件夹，您可以在那里找到相当多的命令行实用程序，可用于诊断问题并监视使用**Java Runtime Environment**（**JRE**）部署的应用程序。它们使用不同的机制来获取它们报告的数据。这些机制特定于**虚拟机**（**VM**）实现、操作系统和版本。通常，这些工具的子集仅适用于特定问题。
- en: In this recipe, we will focus on the diagnostic command introduced with Java
    9 as a command-line utility, `jcmd`. If the `bin` folder is on the path, you can
    invoke it by typing `jcmd` on the command line. Otherwise, you have to go to the
    `bin` directory or prepend the `jcmd` in our examples with the full or relative
    (to the location of your command line window) path to the `bin` folder.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将重点放在Java 9中引入的诊断命令，即命令行实用程序`jcmd`。如果`bin`文件夹在路径上，您可以通过在命令行上键入`jcmd`来调用它。否则，您必须转到`bin`目录，或者在我们的示例中在`jcmd`之前加上`bin`文件夹的完整路径或相对路径（相对于您的命令行窗口的位置）。
- en: 'If you do type it and there is no Java process currently running on the machine,
    you will get back only one line, which looks as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您输入它，而机器上当前没有运行Java进程，您将只收到一行，如下所示：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It shows that only one Java process is currently running (the `jcmd` utility
    itself) and it has the **process identifier** (**PID**) of 87863 (which will be
    different with each run).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示当前只有一个Java进程正在运行（`jcmd`实用程序本身），并且它具有**进程标识符**（**PID**）为87863（每次运行时都会有所不同）。
- en: 'Let''s run a Java program, for example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个Java程序，例如：
- en: '[PRE14]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of `jcmd` will show (with different PIDs) the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`jcmd`的输出将显示（具有不同PID）以下内容：'
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, if entered without any options, the `jcmd` utility reports
    the PIDs of all the currently running Java processes. After getting the PID, you
    can then use `jcmd` to request data from the JVM that runs the process:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果没有任何选项输入，`jcmd`实用程序将报告所有当前运行的Java进程的PID。获取PID后，您可以使用`jcmd`从运行该进程的JVM请求数据：
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Alternatively, you can avoid using PID (and calling `jcmd` without parameters)
    by referring to the process by the main class of the application:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以避免使用PID（并且不带参数调用`jcmd`）通过引用应用程序的主类来引用该进程：
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can read the JVM documentation for more details about the `jcmd` utility
    and how to use it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以阅读JVM文档，以获取有关`jcmd`实用程序及其用法的更多详细信息。
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: '`jcmd` is a utility that allows us to issue commands to the specified Java
    process:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`jcmd`是一个允许我们向指定的Java进程发出命令的实用程序：'
- en: 'Get the full list of the `jcmd` commands available for a particular Java process
    by executing the following line:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下行，可以获取特定Java进程可用的`jcmd`命令的完整列表：
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Instead of `PID/main-class`, put the process identifier or the main class name. The
    list is specific to JVM, so each listed command requests the data from the specific
    process.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PID/main-class`的位置，放置进程标识符或主类名称。该列表特定于JVM，因此每个列出的命令都会从特定进程请求数据。
- en: 'In JDK 8, the following `jcmd` commands were available:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JDK 8中，以下`jcmd`命令是可用的：
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The JDK 9 introduced the following `jcmd` commands (JDK 18.3 and JDK 18.9 did
    not add new commands):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 9引入了以下`jcmd`命令（JDK 18.3和JDK 18.9没有添加新命令）：
- en: '`Compiler.queue`: Prints the methods queued for compilation with either C1
    or C2 (separate queues)'
  id: totrans-193
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Compiler.queue`: 打印排队等待使用C1或C2编译的方法（分别排队）'
- en: '`Compiler.codelist`: Prints n-methods (compiled) with full signature, address
    range, and state (alive, non-entrant, and zombie), and allows the selection of
    printing to `stdout`, a file, XML, or text printout'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Compiler.codelist`: 打印n个（已编译的）方法的完整签名、地址范围和状态（活动、非进入和僵尸），并允许选择打印到`stdout`、文件、XML或文本输出'
- en: '`Compiler.codecache`: Prints the content of the code cache, where the JIT compiler
    stores the generated native code to improve performance'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Compiler.codecache`: 打印代码缓存的内容，即JIT编译器存储生成的本机代码以提高性能的地方'
- en: '`Compiler.directives_add file`: Adds compiler directives from a file to the
    top of the directives stack'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Compiler.directives_add file`: 从文件向指令栈顶部添加编译器指令'
- en: '`Compiler.directives_clear`: Clears the compiler directives stack (leaves the
    default directives only)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Compiler.directives_clear`: 清除编译器指令栈（仅保留默认指令）'
- en: '`Compiler.directives_print`: Prints all the directives on the compiler directives
    stack from top to bottom'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Compiler.directives_print`: 从顶部到底部打印编译器指令栈上的所有指令'
- en: '`Compiler.directives_remove`: Removes the top directive from the compiler directives
    stack'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Compiler.directives_remove`: 从编译器指令栈中移除顶部指令'
- en: '`GC.heap_info`: Prints the current heap parameters and status'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GC.heap_info`: 打印当前堆参数和状态'
- en: '`GC.finalizer_info`: Shows the status of the finalizer thread, which collects
    objects with a finalizer (that is, a `finalize()` method)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GC.finalizer_info`: 显示终结器线程的状态，该线程收集具有终结器（即`finalize()`方法）的对象'
- en: '`JFR.configure`: Allows us to configure the Java Flight Recorder'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JFR.configure`: 允许我们配置Java Flight Recorder'
- en: '`JVMTI.data_dump`: Prints the Java Virtual Machine Tool Interface data dump'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JVMTI.data_dump`: 打印Java虚拟机工具接口数据转储'
- en: '`JVMTI.agent_load`: Loads (attaches) the Java Virtual Machine Tool Interface agent'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JVMTI.agent_load`: 加载（附加）Java虚拟机工具接口代理'
- en: '`ManagementAgent.status`: Prints the status of the remote JMX agent'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ManagementAgent.status`: 打印远程JMX代理的状态'
- en: '`Thread.print`: Prints all the threads with stack traces'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread.print`: 打印所有带有堆栈跟踪的线程'
- en: '`VM.log [option]`: Allows us to set the JVM log configuration (which we described
    in the previous recipe) at runtime, after the JVM has started (the availability
    can be seen by using `VM.log list`)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VM.log [option]`: 允许我们在JVM启动后（可以通过使用`VM.log list`查看可用性）在运行时设置JVM日志配置（我们在前面的配方中描述了）'
- en: '`VM.info`: Prints the unified JVM info (version and configuration), a list
    of all threads and their state (without thread dump and heap dump), heap summary,
    JVM internal events (GC, JIT, safepoint, and so on), memory map with loaded native
    libraries, VM arguments and environment variables, and details of the operation
    system and hardware'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VM.info`: 打印统一的JVM信息（版本和配置）、所有线程及其状态的列表（不包括线程转储和堆转储）、堆摘要、JVM内部事件（GC、JIT、安全点等）、加载的本机库的内存映射、VM参数和环境变量，以及操作系统和硬件的详细信息'
- en: '`VM.dynlibs`: Prints information about dynamic libraries'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VM.dynlibs`: 打印动态库的信息'
- en: '`VM.set_flag`: Allows us to set the JVM *writable* (also called *manageable*)
    flags (see the JVM documentation for a list of the flags)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VM.set_flag`: 允许我们设置JVM的*可写*（也称为*可管理*）标志（请参阅JVM文档以获取标志列表）'
- en: '`VM.stringtable` and `VM.symboltable`: Prints all UTF-8 string constants'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VM.stringtable`和`VM.symboltable`: 打印所有UTF-8字符串常量'
- en: '`VM.class_hierarchy [full-class-name]`: Prints all the loaded classes or just
    a specified class hierarchy'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VM.class_hierarchy [full-class-name]`: 打印所有已加载的类或指定类层次结构'
- en: '`VM.classloader_stats`: Prints information about the classloader'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VM.classloader_stats`: 打印有关类加载器的信息'
- en: '`VM.print_touched_methods`: Prints all the methods that have been touched (have
    been read at least) at runtime'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VM.print_touched_methods`: 打印在运行时已被访问（至少已被读取）的所有方法'
- en: As you can see, these new commands belong to several groups, denoted by the
    prefix compiler, **garbage collector** (**GC**), **Java Flight Recorder** (**JFR**), **Java
    Virtual Machine Tool Interface** (**JVMTI**),  **Management Agent** (related to
    remote JMX agent), **thread**, and **VM**. In this book, we do not have enough
    space to go through each command in detail. We will only demonstrate the usage
    of a few practical ones.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这些新命令属于几个组，由前缀编译器、**垃圾收集器**（**GC**）、**Java Flight Recorder**（**JFR**）、**Java虚拟机工具接口**（**JVMTI**）、**管理代理**（与远程JMX代理相关）、**线程**和**VM**表示。在本书中，我们没有足够的空间来详细介绍每个命令。我们只会演示一些实用命令的用法。
- en: How it works...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'To get help for the `jcmd` utility, run the following command:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取`jcmd`实用程序的帮助，请运行以下命令：
- en: '[PRE20]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is the result of the command:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是命令的结果：
- en: '![](img/9c0c5f23-7cdb-4af3-b2ce-942c651d9803.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c0c5f23-7cdb-4af3-b2ce-942c651d9803.png)'
- en: It tells us that the commands can also be read from the file specified after
    `-f` and that there is a `PerfCounter.print` command, which prints all the performance
    counters (statistics) of the process.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉我们，命令也可以从`-f`之后指定的文件中读取，并且有一个`PerfCounter.print`命令，它打印进程的所有性能计数器（统计信息）。
- en: 'Run the following command:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE21]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output may look like this screenshot:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能看起来像这个屏幕截图：
- en: '![](img/abfd96d8-ab1b-4ff2-8991-f21ef5f8d76a.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/abfd96d8-ab1b-4ff2-8991-f21ef5f8d76a.png)'
- en: It shows the total heap size and how much of it was used, the size of a region
    in the young generation and how many regions are allocated, and the parameters
    of `Metaspace` and `class space`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了总堆大小及其使用量，年轻代中区域的大小和分配的区域数量，以及`Metaspace`和`class space`的参数。
- en: 'The following command is very helpful in case you are looking for runaway threads
    or would like to know what else is going on behind the scenes:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令在您寻找失控线程或想了解幕后发生了什么时非常有帮助：
- en: '[PRE22]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is a fragment of the possible output:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可能输出的片段：
- en: '![](img/a43091e9-2642-4bde-9792-76cedc1a469e.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a43091e9-2642-4bde-9792-76cedc1a469e.png)'
- en: 'This command is probably used most often, as it produces a wealth of information
    about the hardware, the JVM process as a whole, and the current state of its components:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个命令可能是最常用的，因为它提供了关于硬件、整个JVM进程以及其组件当前状态的丰富信息：
- en: '[PRE23]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It starts with a summary, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 它以摘要开始，如下所示：
- en: '![](img/74c3872d-716d-4a5e-8479-35a470b2c17f.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74c3872d-716d-4a5e-8479-35a470b2c17f.png)'
- en: 'The general process description follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一般的过程描述：
- en: '![](img/d749730b-0f1f-415e-99cb-20c47419c2fe.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d749730b-0f1f-415e-99cb-20c47419c2fe.png)'
- en: 'Then come the details of the heap (this is only a tiny fragment of it):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是堆的详细信息（这只是其中的一小部分）：
- en: '![](img/6f0074ff-b4b5-465c-b168-bcd5089fa685.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f0074ff-b4b5-465c-b168-bcd5089fa685.png)'
- en: It then prints the compilation events, GC heap history, deoptimization events,
    internal exceptions, events, dynamic libraries, logging options, environment variables, VM
    arguments, and many parameters of the system running the process.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后打印编译事件、GC堆历史、去优化事件、内部异常、事件、动态库、日志选项、环境变量、VM参数以及运行进程的系统的许多参数。
- en: The `jcmd` commands give a deep insight into the JVM process, which helps to debug
    and tune the process for best performance and optimal resource usage.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`jcmd`命令深入了解JVM进程，有助于调试和调整进程以获得最佳性能和最佳资源使用。'
- en: Try-with-resources for better resource handling
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用*try-with-resources*更好地处理资源
- en: 'Managing resources is important. Any mishandling (not releasing) of the resources—database
    connections and file descriptors left opened, for example—can exhaust the system''s
    capability to operate. That''s why, in JDK 7,  the *try-with-resources* statement
    was introduced. We have used it in the examples of [Chapter 6](4d5627d7-8aa3-4ad8-912f-7525f77143b9.xhtml),
    *Database Programming*:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 管理资源是很重要的。任何资源的错误处理（未释放）——例如保持打开的数据库连接和文件描述符——都可能耗尽系统的操作能力。这就是为什么在JDK 7中引入了*try-with-resources*语句。我们在[第6章](4d5627d7-8aa3-4ad8-912f-7525f77143b9.xhtml)的示例中使用了它，*数据库编程*：
- en: '[PRE24]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As a reminder, here is the `getDbConnection()` method:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，这是`getDbConnection()`方法：
- en: '[PRE25]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And here is the `createStatement()` method:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`createStatement()`方法：
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This was very helpful, but in some cases, we were still required to write extra
    code in the old style, for example, if there is an `execute()` method that accepts
    a `Statement` object as a parameter, and we would like to release (close) it as
    soon as it was used. In such a case, the code will look as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有帮助，但在某些情况下，我们仍然需要以旧的方式编写额外的代码，例如，如果有一个接受`Statement`对象作为参数的`execute()`方法，并且我们希望在使用后立即释放（关闭）它。在这种情况下，代码将如下所示：
- en: '[PRE27]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, most of it is just boilerplate copy-and-paste code.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，其中大部分只是样板复制粘贴代码。
- en: The new *try-with-resources* statement, introduced with Java 9, addresses this
    case by allowing effectively final variables to be used as the resources.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9引入的新*try-with-resources*语句通过允许有效地最终变量作为资源来解决了这种情况。
- en: How to do it...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Rewrite the previous example using the new *try-with-resources* statement:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的*try-with-resources*语句重写前面的示例：
- en: '[PRE28]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, it is much more concise and focused, without the need to repeatedly
    write trivial code that closes the resource. No more `finally` and additional `try...catch`
    in it.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，它更加简洁和专注，无需反复编写关闭资源的琐碎代码。不再需要`finally`和额外的`try...catch`。
- en: 'If the connection is passed in too, it also can be put in the same try-block
    and closed as soon as it is no longer needed:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果连接也被传递进来，它也可以放在同一个try块中，并在不再需要时立即关闭：
- en: '[PRE29]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It may or may not fit your application's connection-handling, but often, this
    capability is handy.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能适合或不适合您应用程序的连接处理，但通常，这种能力是很方便的。
- en: 'Try a different combination, such as the following:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试不同的组合，例如以下：
- en: '[PRE30]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And this combination is allowed too:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组合也是允许的：
- en: '[PRE31]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The new statement provides more flexibility to write code that fits the needs
    without writing the lines that close the resource.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 新语句提供了更灵活的编写代码的方式，以满足需求，而无需编写关闭资源的代码行。
- en: 'The only requirements are as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的要求如下：
- en: The variable included in the `try` statement has to be final or effectively
    final
  id: totrans-265
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try`语句中包含的变量必须是final或有效最终'
- en: 'The resource has to implement the `AutoCloseable` interface, which includes
    only one method:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源必须实现`AutoCloseable`接口，其中只包括一个方法：
- en: '[PRE32]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To demonstrate how the new statement works, let's create our own resources that
    implement `AutoCloseable` and use them in a fashion similar to the resources of
    the previous examples.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示新语句的工作原理，让我们创建自己的资源，实现`AutoCloseable`并以与之前示例中的资源类似的方式使用它们。
- en: 'Here is one resource:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个资源：
- en: '[PRE33]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here is the second resource:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个资源：
- en: '[PRE34]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s use them in the code example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码示例中使用它们：
- en: '[PRE35]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we run it, the result will be as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行它，结果将如下：
- en: '![](img/27c7e219-b1e6-488a-b968-ce460476c73a.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27c7e219-b1e6-488a-b968-ce460476c73a.png)'
- en: 'Note that the resource listed first in the `try` statement is closed last.
    Let us make only one change and switch the order  of the references in the `try`
    statement:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`try`语句中列出的第一个资源最后关闭。让我们只做一个改变，并在`try`语句中切换引用的顺序：
- en: '[PRE36]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output confirms that the sequence of the references closing changes too:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 输出确认了引用关闭的顺序也发生了变化：
- en: '![](img/b9d13e94-10a6-414f-89ae-61cb50692e48.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9d13e94-10a6-414f-89ae-61cb50692e48.png)'
- en: This rule of closing the resources in the reverse order addresses the most important
    possible issue of dependency between resources, but it is up to the programmer
    to define the sequence of closing the resources (by listing them in the `try` statement
    in the correct order). Fortunately, the closing of most standard resources is
    handled by the JVM gracefully, and the code does not break if the resources are
    listed in incorrect order. Still, it is a good idea to list them in the same sequence
    as they were created.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相反顺序关闭资源的规则解决了资源之间可能存在的最重要的依赖问题，但是由程序员定义关闭资源的顺序（通过在`try`语句中按正确顺序列出它们）是程序员的责任。幸运的是，大多数标准资源的关闭都由JVM优雅地处理，如果资源按照不正确的顺序列出，代码不会中断。但是，按照创建顺序列出它们是一个好主意。
- en: Stack walking for improved debugging
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于改进调试的堆栈遍历
- en: Stack trace can be very helpful in figuring out the source of a problem. When
    an automatic correction is possible, the need arises to read it programmatically.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈跟踪在找出问题的根源时非常有帮助。当可能进行自动更正时，需要以编程方式读取它。
- en: 'Since Java 1.4, the current stack trace can be accessed via the `java.lang.Thread`
    and `java.lang.Throwable` classes. You can add the following line to any method
    of your code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java 1.4以来，可以通过`java.lang.Thread`和`java.lang.Throwable`类访问当前堆栈跟踪。您可以在代码的任何方法中添加以下行：
- en: '[PRE37]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can also add the following line:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以添加以下行：
- en: '[PRE38]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It will print the stack trace to the standard output. Alternatively, since
    Java 8, you can use any of the following lines for the same effect:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 它将堆栈跟踪打印到标准输出。或者，自Java 8以来，您可以使用以下任一行达到相同的效果：
- en: '[PRE39]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Or you can extract the fully qualified name of the caller class, using one
    of these lines:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以使用以下任一行提取调用者类的完全限定名称：
- en: '[PRE40]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'All the aforementioned solutions are possible because of the `java.lang.StackTraceElement` class,
    which represents a stack frame in a stack trace. This class provides other methods
    that describe the execution point represented by this stack-trace element, which
    allows programmatic access to the stack-trace information. For example, you can
    run this code snippet from anywhere in your program:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述解决方案都是可能的，因为`java.lang.StackTraceElement`类代表堆栈跟踪中的堆栈帧。该类提供其他描述由此堆栈跟踪元素表示的执行点的方法，这允许以编程方式访问堆栈跟踪信息。例如，您可以在程序的任何位置运行此代码片段：
- en: '[PRE41]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Or you can run the following from anywhere in the program:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以在程序的任何位置运行以下内容：
- en: '[PRE42]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Unfortunately, this wealth of data comes with a price. The JVM captures the
    entire stack (except for hidden stack frames), and—in those cases when the programmatic
    analysis of the stack trace is embedded in the main application flow—it may affect
    the application performance. Meanwhile, you only need a fraction of this data
    to make a decision.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这些丰富的数据是有代价的。JVM捕获整个堆栈（除了隐藏的堆栈帧），并且在程序堆栈跟踪的程序化分析嵌入主应用程序流程的情况下，可能会影响应用程序性能。与此同时，您只需要这些数据的一小部分来做出决策。
- en: This is where the new Java 9 class, `java.lang.StackWalker`, with its nested
    `Option` class and `StackFrame` interface, comes in handy.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是新的Java 9类`java.lang.StackWalker`以及其嵌套的`Option`类和`StackFrame`接口派上用场的地方。
- en: Getting ready
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The `StackWalker` class has four overloaded  `getInstance()` static factory
    methods:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackWalker`类有四个重载的`getInstance()`静态工厂方法：'
- en: '`StackWalker getInstance()`: This is configured to skip all the hidden frames
    and no caller class reference is retained. The hidden frames contain JVM internal
    implementation-specific information. Not retaining the caller class reference
    means that calling the `getCallerClass()` method on the `StackWalker` object throws `UnsupportedOperationException`.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackWalker getInstance()`: 这是配置为跳过所有隐藏帧的实例，并且不保留调用者类引用。隐藏帧包含JVM内部实现特定的信息。不保留调用者类引用意味着在`StackWalker`对象上调用`getCallerClass()`方法会抛出`UnsupportedOperationException`。'
- en: '`StackWalker getInstance(StackWalker.Option option)`: This creates an instance
    with the given option, specifying the stack frame information it can access.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackWalker getInstance(StackWalker.Option option)`: 这将创建一个具有给定选项的实例，指定它可以访问的堆栈帧信息。'
- en: '`StackWalker getInstance(Set<StackWalker.Option> options)`: This creates an
    instance with the given set of options, specifying the stack frame information
    it can access. If the given set is empty, the instance is configured exactly like
    the instance created by `StackWalker getInstance()`.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackWalker getInstance(Set<StackWalker.Option> options)`: 这将创建一个具有给定选项集的实例，指定它可以访问的堆栈帧信息。如果给定的集合为空，则该实例的配置与`StackWalker
    getInstance()`创建的实例完全相同。'
- en: '`StackWalker getInstance(Set<StackWalker.Option> options, int estimatedDepth)`:
    This creates a similar instance as the preceding one and accepts the `estimatedDepth`
    parameter, which allows us to estimate the buffer size it might need.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackWalker getInstance(Set<StackWalker.Option> options, int estimatedDepth)`:
    这将创建一个与前一个实例类似的实例，并接受`estimatedDepth`参数，允许我们估计它可能需要的缓冲区大小。'
- en: 'The following are the values of `enum StackWalker.Option`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`enum StackWalker.Option`的值：
- en: '`StackWalker.Option.RETAIN_CLASS_REFERENCE`: Configures the `StackWalker` instance
    to support the `getCallerClass()` method, and the `StackFrame` to support the `getDeclaringClass()` method'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackWalker.Option.RETAIN_CLASS_REFERENCE`: 配置`StackWalker`实例以支持`getCallerClass()`方法，并且`StackFrame`支持`getDeclaringClass()`方法'
- en: '`StackWalker.Option.SHOW_HIDDEN_FRAMES`: Configures the `StackWalker` instance
    to show all reflection frames and implementation-specific frames'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackWalker.Option.SHOW_HIDDEN_FRAMES`: 配置`StackWalker`实例以显示所有反射帧和特定实现帧'
- en: '`StackWalker.Option.SHOW_REFLECT_FRAMES`: Configures the `StackWalker` instance
    to show all reflection frames'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackWalker.Option.SHOW_REFLECT_FRAMES`: 配置`StackWalker`实例以显示所有反射帧'
- en: 'The `StackWalker` class also has three methods:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackWalker`类还有三个方法：'
- en: '`T walk(Function<Stream<StackWalker.StackFrame>, T> function)`: This applies
    the given function to the stream of `StackFrames` for the current thread, traversing
    the frames from the top of the stack. The top frame contains the method that has
    called this `walk()` method.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T walk(Function<Stream<StackWalker.StackFrame>, T> function)`: 这将给定的函数应用于当前线程的`StackFrames`流，从堆栈顶部遍历帧。顶部帧包含调用此`walk()`方法的方法。'
- en: '`void forEach(Consumer<StackWalker.StackFrame> action)`: This performs the
    given action on each element of the `StackFrame` stream of the current thread,
    traversing from the top frame of the stack, which is the method calling the `forEach`
    method. This method is equivalent to calling `walk(s -> { s.forEach(action); return
    null; })`.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void forEach(Consumer<StackWalker.StackFrame> action)`: 这对当前线程的`StackFrame`流的每个元素执行给定的操作，从堆栈的顶部帧开始，这是调用`forEach`方法的方法。此方法相当于调用`walk(s
    -> { s.forEach(action); return null; })`。'
- en: '`Class<?> getCallerClass()`: This gets the `Class` object of the caller that
    invoked the method that called `getCallerClass()`. This method throws `UnsupportedOperationException`
    if this `StackWalker` instance is not configured with the `RETAIN_CLASS_REFERENCE`
    option.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Class<?> getCallerClass()`: 这获取调用了调用`getCallerClass()`方法的方法的`Class`对象。如果此`StackWalker`实例未配置`RETAIN_CLASS_REFERENCE`选项，则此方法会抛出`UnsupportedOperationException`。'
- en: How to do it...
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create several classes and methods that will call each other, so you can perform
    stack-trace processing:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 创建几个类和方法，它们将相互调用，这样您就可以执行堆栈跟踪处理：
- en: 'Create a `Clazz01` class:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Clazz01`类：
- en: '[PRE43]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a `Clazz02` class:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Clazz02`类：
- en: '[PRE44]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create a `Clazz03` class:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Clazz03`类：
- en: '[PRE45]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Write a `demo4_StackWalk()` method:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`demo4_StackWalk()`方法：
- en: '[PRE46]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Call this method from the main method of the `Chapter11Memory` class:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Chapter11Memory`类的主方法中调用此方法：
- en: '[PRE47]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we now run the `Chapter11Memory` class, the result will be as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行`Chapter11Memory`类，结果将如下所示：
- en: '![](img/60ec130e-737d-49db-831f-f14f3fd5e717.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60ec130e-737d-49db-831f-f14f3fd5e717.png)'
- en: The `Do something` message is passed from `Clazz01` and printed out in `Clazz03`.
    Then `Clazz02` passes null to `Clazz03`, and the `Throw the exception` message
    is printed out before the stack trace caused by `NullPointerException` from the `action.toString()` line.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`Do something`消息从`Clazz01`传递并在`Clazz03`中打印出来。然后`Clazz02`将null传递给`Clazz03`，并在`action.toString()`行引起的`NullPointerException`的堆栈跟踪之前打印出`Throw
    the exception`消息。'
- en: How it works...
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'For a deeper understanding of the concepts here, let''s modify `Clazz03`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地理解这里的概念，让我们修改`Clazz03`：
- en: '[PRE48]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The result will be the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/fb839893-eba0-42a0-9ef6-7f8eccc8e86b.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb839893-eba0-42a0-9ef6-7f8eccc8e86b.png)'
- en: 'Alternatively, we can get a similar output by using `Throwable` instead of
    `Thread`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`Throwable`而不是`Thread`来获得类似的输出：
- en: '[PRE49]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The preceding line produces this output:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行产生了这个输出：
- en: '![](img/cbefaa13-cce7-4a17-b224-fc6f2df44f43.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbefaa13-cce7-4a17-b224-fc6f2df44f43.png)'
- en: 'A similar result will produce each of the following two lines:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 每个以下两行将产生类似的结果：
- en: '[PRE50]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Since Java 9, the same output can be achieved using the `StackWalker` class.
    Let''s look at what happens if we modify `Clazz03` as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java 9以来，可以使用`StackWalker`类实现相同的输出。让我们看看如果我们修改`Clazz03`会发生什么：
- en: '[PRE51]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The result is this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/0a56bc8a-4f69-4dc3-81a0-8cee5859d2bf.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a56bc8a-4f69-4dc3-81a0-8cee5859d2bf.png)'
- en: 'It contains all the information the traditional methods produced. However,
    contrary to the full stack trace generated and stored as an array in the memory,
    the `StackWalker` class only brings the requested elements. This is already a
    big plus. Yet the biggest advantage of `StackWalker` is that, when we need the
    caller class name only, instead of getting all the array and using only one element,
    we can now get the info we need by using the following two lines:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含了传统方法产生的所有信息。然而，与在内存中生成和存储完整堆栈跟踪不同，`StackWalker`类只带来了请求的元素。这已经是一个很大的优点。然而，`StackWalker`的最大优势是，当我们只需要调用者类名时，而不是获取整个数组并仅使用一个元素，我们现在可以通过以下两行获取所需的信息：
- en: '[PRE52]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The result of the preceding code snippet is the following:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的结果如下：
- en: '![](img/370ad025-999a-46d6-afaf-3f2d7557c969.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](img/370ad025-999a-46d6-afaf-3f2d7557c969.png)'
- en: Using the memory-aware coding style
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内存感知编码风格
- en: 'When writing code, a programmer has two main objectives in mind:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，程序员有两个主要目标：
- en: To implement the required functionality
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现所需的功能
- en: To write code that is easy to read and understand
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写易于阅读和理解的代码
- en: 'Yet, while doing that, they also have to make many other decisions, one of
    them being which of the standard library classes and methods with similar functionality
    to use. In this recipe, we will walk you through a few considerations that help
    to avoid the wasting of memory and make your code style memory-aware:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这样做的同时，他们还必须做出许多其他决定，其中之一是使用与标准库类和方法具有类似功能的类。在这个示例中，我们将带您了解一些考虑因素，以帮助避免浪费内存，并使您的代码风格具有内存感知能力：
- en: Pay attention to the object created inside the loop
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意在循环内创建的对象
- en: Use lazy initialization and create an object just before the usage, especially
    if there is a good chance that, this need may never materialize at all
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用延迟初始化，在使用之前创建对象，特别是如果有很大的可能性，这种需求根本不会出现
- en: Don't forget to clean the cache and remove unnecessary entries
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要忘记清理缓存并删除不必要的条目
- en: Use `StringBuilder` instead of the `+` operator
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`StringBuilder`而不是`+`运算符
- en: Use `ArrayList` if it fits your needs, before using `HashSet` (the memory usage
    increases from `ArrayList` to `LinkedList`, `HashTable`, `HashMap`, and `HashSet`,
    in this sequence)
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果符合您的需求，请使用`ArrayList`，然后再使用`HashSet`（从`ArrayList`到`LinkedList`，`HashTable`，`HashMap`和`HashSet`，内存使用量逐渐增加）
- en: How to do it...
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Pay attention to the object created inside the loop.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意在循环内创建的对象。
- en: 'This recommendation is pretty obvious. Creating and discarding many objects
    in quick succession may consume too much memory before the garbage collector catches
    up with reusing the space. Consider reusing objects instead of creating a new
    one every time. Here is an example:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这个建议非常明显。在快速连续创建和丢弃许多对象可能在垃圾收集器重新利用空间之前消耗太多内存。考虑重用对象而不是每次都创建一个新对象。这里有一个例子：
- en: '[PRE53]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The preceding code can be improved by making the `calculate()` method static. Another
    solution would be to create a static property, `Calculator calculator = new Calculator()`,
    of the `SomeOtherClass` class. But the static property is initialized as soon
    as the class is loaded the first time. If the `calculator` property is not used,
    its initialization would be unnecessary overhead. In such cases, lazy initialization
    has to be added.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以通过使`calculate()`方法静态来改进。另一个解决方案是创建`SomeOtherClass`类的静态属性`Calculator calculator
    = new Calculator()`。但是静态属性在类第一次加载时就会初始化。如果`calculator`属性没有被使用，那么它的初始化将是不必要的开销。在这种情况下，需要添加延迟初始化。
- en: Use lazy initialization and create an object just before the usage, especially
    if there is a good chance this need may never materialize for some requests.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用延迟初始化，在使用之前创建对象，特别是如果有很大的可能性某些请求可能永远不会实现这个需求。
- en: 'In the previous step, we talked about lazy initialization of the `calculator`
    property:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，我们谈到了`calculator`属性的延迟初始化：
- en: '[PRE54]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the preceding example, the `Calculator` object is a singleton—once created,
    only one instance of it exists in the application. If we know that calculator
    property is always going to be used, then there is no need for the lazy initialization.
    In Java, we can take advantage of the static-property initialization the first
    time the class is loaded by any of the application threads:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`Calculator`对象是一个单例 - 一旦创建，应用程序中就只存在一个实例。如果我们知道`calculator`属性总是会被使用，那么就不需要延迟初始化。在Java中，我们可以利用静态属性在任何应用程序线程加载类时的第一次初始化。
- en: '[PRE55]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: But if there is a good chance the initialized object will never be used, we
    are back to the lazy initialization that can be implemented as was discussed earlier
    (using the `getCalculator()` method) in a single thread or when the shared object
    is stateless and its initialization does not consume many resources.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果初始化的对象很可能永远不会被使用，我们又回到了可以在单线程中实现的延迟初始化（使用`getCalculator()`方法）或者当共享对象是无状态的且其初始化不消耗太多资源时。
- en: 'In the case of a multi-threaded application and complex object initialization
    with substantial resource consumption, some additional measures have to be taken
    to avoid the conflict of a concurrent access and make sure only one instance is
    created. For example, consider the following class:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程应用程序和复杂对象初始化的情况下，需要采取一些额外措施来避免并发访问冲突，并确保只创建一个实例。例如，考虑以下类：
- en: '[PRE56]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If the preceding constructor requires an extensive time to complete object
    creation, there is a chance that the second thread enters the constructor before
    the first thread has completed the object creation. To avoid this concurrent creation
    of the second object, we need to synchronize the initialization process:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的构造函数需要大量时间来完成对象的创建，那么第二个线程有可能在第一个线程完成对象创建之前进入构造函数。为了避免第二个对象的并发创建，我们需要同步初始化过程：
- en: '[PRE57]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see, we could synchronize access to the `getData()` method, but this
    synchronization is not needed after the object is created and can cause a bottleneck
    in a highly concurrent multithreaded environment. Similarly, we could have only
    one check for null—inside the synchronized block—but this synchronization is not
    needed after the object is initialized, so we surround it with another check for
    null to decrease the chance for the bottleneck.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以同步访问`getData()`方法，但在对象创建后不需要此同步，并且可能在高并发多线程环境中造成瓶颈。同样，我们可以只在同步块内部进行一次空值检查，但在对象初始化后不需要此同步，因此我们用另一个空值检查来减少瓶颈的机会。
- en: Don't forget to clean the cache and remove unnecessary entries.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记清理缓存并删除不必要的条目。
- en: 'Caching helps to decrease the time for accessing the data. But the cache consumes
    memory, so it makes sense to keep it as small as possible, while still being useful.
    How to do it very much depends on the pattern of the cached data usage. For example,
    if you know that, once used, the object stored in the cache is not going to be
    used again, you can put it in the cache at the application startup time (or periodically,
    according to the pattern of the usage) and remove it from the cache after it was
    used:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存有助于减少访问数据的时间。但缓存会消耗内存，因此有意义的是尽可能保持它小，同时仍然有用。如何做取决于缓存数据使用的模式。例如，如果你知道一旦使用，存储在缓存中的对象不会再次被使用，你可以在应用程序启动时（或根据使用模式定期）将其放入缓存中，并在使用后从缓存中删除：
- en: '[PRE58]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Alternatively, if you expect a high level of reusability for each object, you
    can put it in the cache after it was requested the first time:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您期望每个对象具有很高的可重用性，可以在第一次请求后将其放入缓存中：
- en: '[PRE59]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The preceding case may lead to an uncontrollable growth of the cache that consumes
    too much memory and eventually causes the `OutOfMemoryError` condition. To prevent
    it, you can implement an algorithm that keeps the cache''s size limited—after
    a certain size, every time a new object is added, some other object (used the
    most, for example, or used the least) is removed. The following is an example
    of limiting the cache size to 10 by removing the most-used cached object:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的情况可能导致缓存无法控制地增长，消耗太多内存，并最终导致`OutOfMemoryError`条件。为了防止这种情况，您可以实现一个算法，限制缓存的大小
    - 达到一定大小后，每次添加新对象时，都会删除一些其他对象（例如，最常用的对象或最少使用的对象）。以下是将缓存大小限制为10的示例，通过删除最常使用的缓存对象：
- en: '[PRE60]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Alternatively, one can use the `java.util.WeakHashMap` class to implement the
    cache:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用`java.util.WeakHashMap`类来实现缓存：
- en: '[PRE61]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If you run the preceding example, you will see that the memory usage and the
    cache size first increase, then drop down, then increase, and drop down again.
    Here is an excerpt from an output:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上面的示例，您会看到内存使用和缓存大小首先增加，然后下降，然后再次增加，然后再次下降。以下是输出的摘录：
- en: '[PRE62]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The memory usage calculation we used was as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的内存使用量计算如下：
- en: '[PRE63]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `java.util.WeakHashMap` class is a Map implementation with keys of the `java.lang.ref.WeakReference` type. The
    objects that are referenced only by weak references are garbage-collected any
    time the garbage collector decides there is more memory needed. This means that
    an entry in a `WeakHashMap` object will be removed when there is no reference
    to that key. When the garbage collection removes the key from the memory, the
    corresponding value is removed from the map too.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.WeakHashMap`类是一个具有`java.lang.ref.WeakReference`类型键的Map实现。只有通过弱引用引用的对象在垃圾收集器决定需要更多内存时才会被回收。这意味着`WeakHashMap`对象中的条目将在没有对该键的引用时被移除。当垃圾收集器从内存中移除键时，相应的值也会从地图中移除。'
- en: 'In our preceding example, none of the cache keys was used outside the map,
    so the garbage collector removed them at its discretion. The code behaves the
    same way even when we add an explicit reference to a key outside the map:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，缓存键都没有在地图之外使用，因此垃圾收集器会自行删除它们。即使我们在地图之外添加对键的显式引用，代码的行为也是相同的：
- en: '[PRE64]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'That is because the `iObj` reference shown in the earlier code block gets abandoned
    after each iteration and collected, so the corresponding key in the cache is left
    without external reference, and the garbage collector removes it too. To prove
    this point, let''s modify the preceding code again:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在之前的代码块中显示的`iObj`引用在每次迭代后都被丢弃并被收集，因此缓存中的相应键也没有外部引用，垃圾收集器也会将其删除。为了证明这一点，让我们再次修改上面的代码：
- en: '[PRE65]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We have created a list and added each of the map keys to it. If we run the
    preceding code, we will eventually get `OutOfMemoryError` because the cache''s
    keys had strong references outside the map.  We can weaken the external references
    too:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个列表，并将地图的每个键添加到其中。如果我们运行上述代码，最终会得到`OutOfMemoryError`，因为缓存的键在地图之外有强引用。我们也可以减弱外部引用：
- en: '[PRE66]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The preceding code now runs as if the cache keys do not have external references.
    The used memory and cache size grow and drop down again. But the list size does
    not drop down, because the garbage collector does not remove values from the list.
    So, eventually, the application may run out of memory.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码现在运行得好像缓存键没有外部引用一样。使用的内存和缓存大小会增长，然后再次下降。但是列表大小不会下降，因为垃圾收集器不会从列表中删除值。因此，最终应用程序可能会耗尽内存。
- en: Yet, whether you limit the size of the cache or let it grow uncontrollably,
    there may be a situation when the application needs as much memory as possible.
    So, if there are big objects that are not critical to the application's main functionality,
    sometimes it makes sense to remove them from memory in order for the application
    to survive and not get into the `OutOfMemoryError` condition.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无论您限制缓存的大小还是让其无法控制地增长，都可能出现应用程序需要尽可能多的内存的情况。因此，如果有一些对应用程序主要功能不是关键的大对象，有时将它们从内存中移除以使应用程序能够生存并避免出现`OutOfMemoryError`的情况是有意义的。
- en: 'If there is a cache, it is typically a good candidate for removing and freeing
    the memory, so we can wrap the cache itself with the `WeakReference` class:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在缓存，通常是一个很好的候选对象来释放内存，因此我们可以使用`WeakReference`类来包装缓存本身：
- en: '[PRE67]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the preceding code, we have wrapped up the map (cache) inside the `WeakReference`
    class, which means we tell the JVM that it can collect this object as soon as
    there is no reference to it. Then, in each iteration of the for-loop, we create
    `new Double[1024]` object and save it in the list. We do it in order to use up
    all the available memory quicker. Then we put the same object in the cache. When
    we run this code, it quickly ends up with the following output:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们将地图（缓存）包装在`WeakReference`类中，这意味着我们告诉JVM只要没有对它的引用，就可以收集此对象。然后，在每次for循环迭代中，我们创建一个`new
    Double[1024]`对象并将其保存在列表中。我们这样做是为了更快地使用完所有可用内存。然后我们将相同的对象放入缓存中。当我们运行此代码时，它会迅速得到以下输出：
- en: '[PRE68]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This means that the garbage collector decided to collect cache object after
    25 MB of memory was used. If such an approach, you think, is too aggressive and
    you do not need to renew the cache often, you can wrap it in the `java.lang.ref.SoftReference`
    class instead. If you do, the cache will be collected only when all the memory
    is used up—just on the brink of throwing `OutOfMemoryError`. Here is the code
    snippet that demonstrates it:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着垃圾收集器在使用了25MB内存后决定收集缓存对象。如果您认为这种方法太过激进，而且您不需要经常更新缓存，您可以将其包装在`java.lang.ref.SoftReference`类中。如果这样做，缓存只有在所有内存用完时才会被收集——就在即将抛出`OutOfMemoryError`的边缘。以下是演示它的代码片段：
- en: '[PRE69]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If we run it, the output will be the following:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行它，输出将如下所示：
- en: '[PRE70]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: That's right, on our test computer, there is 4 GB of RAM, so the cache was removed
    only when almost all of it was used.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，在我们的测试计算机上，有4GB的RAM，因此只有在几乎用完所有内存时才会删除缓存。
- en: Use `StringBuilder` instead of the `+` operator.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`StringBuilder`代替`+`运算符。
- en: 'You can find many such recommendations on the internet. There are also quite
    a few statements saying that this recommendation is obsolete because modern Java
    uses `StringBuilder` to implement the `+` operator for strings. Here is the result
    of our experimentation. First, we have run the following code:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在互联网上找到许多这样的建议。也有相当多的声明说这个建议已经过时，因为现代Java使用`StringBuilder`来实现字符串的`+`运算符。以下是我们实验的结果。首先，我们运行了以下代码：
- en: '[PRE71]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The implementation of `usedMemoryMB()` :'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`usedMemoryMB()`的实现：'
- en: '[PRE72]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Then we used `StringBuilder` for the same purpose:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们用`StringBuilder`来达到同样的目的：
- en: '[PRE73]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As you can see, using the `+` operator consumed 71 MB of memory, while `StringBuilder`
    used only 1 MB for the same task. We have tested `StringBuffer`, too. It consumed
    1 MB as well but performed slightly slower than `StringBuilder`, because it is
    thread-safe, while `StringBuilder` can be used in a single-thread environment
    only.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用`+`运算符消耗了71MB的内存，而`StringBuilder`仅在相同任务中使用了1MB。我们也测试了`StringBuffer`。它也消耗了1MB，但比`StringBuilder`执行稍慢，因为它是线程安全的，而`StringBuilder`只能在单线程环境中使用。
- en: 'All this does not apply to the long `String` value that was broken into several
    substrings with the plus sign for better readability. The compiler collects the
    substring back into one long value. For example, the `s1` and `s2` strings occupy
    the same amount of memory:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都不适用于长字符串值，该值已被拆分为几个子字符串，以提高可读性。编译器将子字符串收集回一个长值。例如，`s1`和`s2`字符串占用相同的内存量：
- en: '[PRE74]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If you need to use a collection, select `ArrayList` if it fits your needs. The
    memory usage increases from `ArrayList` to `LinkedList`, `HashTable`, `HashMap`,
    and `HashSet`, in this sequence.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要使用集合，如果符合你的需求，选择`ArrayList`。从`ArrayList`到`LinkedList`、`HashTable`、`HashMap`和`HashSet`，内存使用量逐渐增加。
- en: The `ArrayList` object stores its elements in an `Object[]` array and uses an
    `int` field for tracking the list size (in addition to `array.length`). Because
    of such a design, it is not recommended to allocate an `ArrayList` of a large
    capacity while declaring it, if there is a chance that this capacity will not
    be fully used. As new elements are added to the list, the backend array's capacity
    is incremented in blocks of 10 elements, which is a possible source of wasted
    memory. If it is significant for the application, it is possible to shrink the
    `ArrayList` capacity to the one currently utilized by calling on it the `trimToSize()` method.
    Please, note that the `clear()` and `remove()` methods do not affect the `ArrayList`
    capacity, they change only its size.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`对象将其元素存储在`Object[]`数组中，并使用一个`int`字段来跟踪列表的大小（除了`array.length`）。由于这样的设计，如果有可能这个容量不会被充分使用，那么在声明时不建议分配一个大容量的`ArrayList`。当新元素添加到列表中时，后端数组的容量会以10个元素的块递增，这可能是浪费内存的一个可能来源。如果这对应用程序很重要，可以通过调用`trimToSize()`方法来缩小`ArrayList`的容量到当前使用的容量。请注意，`clear()`和`remove()`方法不会影响`ArrayList`的容量，它们只会改变其大小。'
- en: Other collections have more overhead because they provide more service. The
    `LinkedList` elements carry references to the previous and next elements as well
    as a reference to the data value. Most implementations of hash-based collections
    are focused on better performance, which often comes at the expense of memory
    footprint.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 其他集合的开销更大，因为它们提供了更多的服务。`LinkedList`元素不仅携带对前一个和后一个元素的引用，还携带对数据值的引用。大多数基于哈希的集合实现都专注于更好的性能，这往往是以内存占用为代价的。
- en: The choice of Java collection class may be irrelevant if its size is going to
    be small. However, programmers usually use the same coding pattern, and one can
    identify the code's author by its style. That's why it pays, in the long run,
    to figure out the most efficient constructs and use them routinely. However, try
    to avoid making your code difficult to understand; readability is an important
    aspect of code quality.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集合的大小很小，那么选择Java集合类可能是无关紧要的。然而，程序员通常使用相同的编码模式，通过其风格可以识别代码的作者。因此，长远来看，找出最有效的构造并经常使用它们是值得的。但是，尽量避免使你的代码难以理解；可读性是代码质量的一个重要方面。
- en: Best practices for better memory usage
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好地使用内存的最佳实践
- en: Memory management may never become an issue for you, it might your every waking
    moment, or you might find yourself in between these two polarities. Most of the
    time, it is a non-issue for the majority of programmers, especially with the constantly
    improving garbage-collection algorithms. The G1 garbage collector (default in
    JVM 9) is definitely a step in the right direction. But there is also a chance
    you will be called (or will notice yourself) about the application's degrading
    performance, and that is when you'll learn how well you are equipped to meet the
    challenge.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理可能永远不会成为你的问题，它可能会成为你每一个清醒的时刻，或者你可能会发现自己处于这两个极端之间。大多数情况下，对于大多数程序员来说，这都不是问题，尤其是随着不断改进的垃圾回收算法。G1垃圾收集器（JVM
    9中的默认值）绝对是朝着正确方向迈出的一步。但也有可能你会被要求（或者自己注意到）应用程序性能下降的情况，这时你就会了解你有多少能力来应对挑战。
- en: This recipe is an attempt to help you avoid such a situation or to get out of
    it successfully.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是为了帮助你避免这种情况或成功摆脱它而做出的尝试。
- en: How to do it...
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The first line of defense is the code itself. In the previous recipes, we discussed
    the need to release resources as soon as they are no longer needed and the usage
    of `StackWalker` to consume less memory. There are plenty of recommendations on
    the internet, but they might not apply to your application. You'll have to monitor
    the memory consumption and test your design decisions, especially if your code
    handles a lot of data, before deciding where to concentrate your attention.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 第一道防线是代码本身。在之前的示例中，我们讨论了释放资源的必要性，以及使用`StackWalker`来消耗更少的内存。互联网上有很多建议，但它们可能不适用于你的应用程序。你需要监控内存消耗并测试你的设计决策，特别是如果你的代码处理大量数据，然后才决定在哪里集中你的注意力。
- en: Test and profile your code as soon as it starts doing what it was supposed to
    do. You might need to change your design or some details of implementation. It
    will also inform your future decisions. There are many profilers and diagnostic
    tools available for any environment. We described one of them, `jcmd`, in the *Using
    the jcmd command for the JVM *recipe.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的代码开始做它应该做的事情，就测试和分析你的代码。你可能需要改变你的设计或一些实现的细节。这也会影响你未来的决策。任何环境都有许多分析器和诊断工具可用。我们在*使用jcmd命令进行JVM*示例中描述了其中的一个，`jcmd`。
- en: Learn how your garbage collector works (see the *Understanding the G1 garbage
    collector* recipe) and do not forget to use JVM logging (described in the *Unified
    logging for JVM* recipe).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 了解您的垃圾收集器是如何工作的（参见*了解G1垃圾收集器*配方），并且不要忘记使用JVM日志记录（在*JVM的统一日志记录*配方中描述）。
- en: 'After that, you might need to tune the JVM and garbage collector. Here are
    a few frequently used `java` command-line parameters (the size is specified in
    bytes by default, but you can append the letter k or K to indicate kilobytes,
    m or M to indicate megabytes, g or G to indicate gigabytes):'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后，您可能需要调整JVM和垃圾收集器。以下是一些经常使用的`java`命令行参数（默认情况下，大小以字节指定，但您可以附加字母k或K表示千字节，m或M表示兆字节，g或G表示千兆字节）：
- en: '`-Xms size`: This option allows us to set the initial heap size (has to be
    greater than 1 MB and a multiple of 1,024).'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Xms size`：此选项允许我们设置初始堆大小（必须大于1 MB且是1024的倍数）。'
- en: '`-Xmx size`: This option allows us to set the maximum heap size (has to be
    greater than 2 MB and a multiple of 1,024).'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Xmx size`：此选项允许我们设置最大堆大小（必须大于2 MB且是1024的倍数）。'
- en: '`-Xmn size` or a combination of `-XX:NewSize=size` and `-XX:MaxNewSize=size`: This
    option allows us to set the initial and maximum size of the young generation.
    For efficient GC, it has to be lower than `-Xmx size`. Oracle recommends you set
    it at more than 25% and less than 50% of the heap size.'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Xmn size`或`-XX:NewSize=size`和`-XX:MaxNewSize=size`的组合：此选项允许我们设置年轻代的初始和最大大小。为了有效的GC，它必须低于`-Xmx
    size`。Oracle建议将其设置为堆大小的25%以上但低于50%。'
- en: '`-XX:NewRatio=ratio`: This option allows us to set the ratio between the young
    and old generations (two, by default).'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:NewRatio=ratio`：此选项允许我们设置年轻代和老年代之间的比率（默认为两个）。'
- en: '`-Xss size`: This option allows us to set the thread stack size. The following
    are the default values for different platforms:'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Xss size`：此选项允许我们设置线程堆栈大小。不同平台的默认值如下：'
- en: 'Linux/ARM (32-bit): 320 KB'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux/ARM（32位）：320 KB
- en: 'Linux/ARM (64-bit): 1,024 KB'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux/ARM（64位）：1,024 KB
- en: 'Linux/x64 (64-bit): 1,024 KB'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux/x64（64位）：1,024 KB
- en: 'macOS (64-bit): 1,024 KB'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS（64位）：1,024 KB
- en: 'Oracle Solaris/i386 (32-bit): 320 KB'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle Solaris/i386（32位）：320 KB
- en: 'Oracle Solaris/x64 (64-bit): 1,024 KB'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle Solaris/x64（64位）：1,024 KB
- en: 'Windows: Depends on virtual memory'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows：取决于虚拟内存
- en: '`-XX:MaxMetaspaceSize=size`: This option allows us to set the upper limit of
    the class metadata area (no limit, by default).'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:MaxMetaspaceSize=size`：此选项允许我们设置类元数据区的上限（默认情况下没有限制）。'
- en: 'The tell-tale sign of a memory leak is the growing of the old generation causing
    the full GC to run more often. To investigate, you can use the JVM parameters
    that dump heap memory into a file:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏的明显迹象是老年代的增长导致完整GC更频繁地运行。要进行调查，您可以使用将堆内存转储到文件的JVM参数：
- en: '`-XX:+HeapDumpOnOutOfMemoryError`: Allows us to save the JVM heap content into
    a file, but only when a `java.lang.OutOfMemoryError` exception is thrown. By default,
    the heap dump is saved in the current directory with the `java_pid<pid>.hprof` name
    where `<pid>` is the process ID. Use the `-XX:HeapDumpPath=<path>` option to customize
    the dump file location. The `<path>` value must include filename.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:+HeapDumpOnOutOfMemoryError`：允许我们将JVM堆内容保存到文件中，但仅当抛出`java.lang.OutOfMemoryError`异常时。默认情况下，堆转储保存在当前目录中，名称为`java_pid<pid>.hprof`，其中`<pid>`是进程ID。使用`-XX:HeapDumpPath=<path>`选项来自定义转储文件位置。`<path>`值必须包括文件名。'
- en: '`-XX:OnOutOfMemoryError="<cmd args>;<cmd args>"`: Allows us to provide a set
    of commands (separated by a semicolon) that will be executed when an `OutOfMemoryError`
    exception is thrown.'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:OnOutOfMemoryError="<cmd args>;<cmd args>"`：允许我们提供一组命令（用分号分隔），当抛出`OutOfMemoryError`异常时将执行这些命令。'
- en: '`-XX:+UseGCOverheadLimit`: Regulates the size of the proportion of time GC
    takes before an `OutOfMemoryError` exception is thrown. For example, the parallel
    GC will throw an `OutOfMemoryError` exception when GC takes more than 98% of the time
    and recovers less than 2% of the heap. This option is particularly useful when
    the heap is small because it prevents JVM from running with little or no progress.
    It is turned on by default. To disable it, use `-XX:-UseGCOverheadLimit`.'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:+UseGCOverheadLimit`：调节GC占用时间比例的大小，超过这个比例会抛出`OutOfMemoryError`异常。例如，并行GC将在GC占用时间超过98%且恢复的堆不到2%时抛出`OutOfMemoryError`异常。此选项在堆较小时特别有用，因为它可以防止JVM在几乎没有进展的情况下运行。默认情况下已启用。要禁用它，请使用`-XX:-UseGCOverheadLimit`。'
- en: Understanding Epsilon, a low-overhead garbage collector
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Epsilon，一种低开销的垃圾收集器
- en: One of the popular Java interview questions is, c*an you enforce garbage collection?* Java
    runtime memory management remains outside a programmer's control and sometimes
    acts as an unpredictable Joker it interrupts the otherwise well-performing application
    and initiates a stop-the-world full-memory scan. It typically happens at the *worst
    possible time*. It is especially annoying when you try to measure your application
    performance under the load using a short run and realize afterward that a lot
    of time and resources were spent on the garbage collection process and that the
    pattern of the garbage collection, after you changed the code, became different
    than before the code change.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的Java面试问题是，*您能强制进行垃圾收集吗？* Java运行时内存管理仍然不受程序员控制，有时会像一个不可预测的小丑一样打断本来表现良好的应用程序，并启动全内存扫描。它通常发生在*最糟糕的时候*。当您尝试在负载下使用短时间运行来测量应用程序性能时，后来意识到大量时间和资源都花在了垃圾收集过程上，并且在更改代码后，垃圾收集的模式变得与更改代码之前不同，这尤其令人恼火。
- en: In this chapter, we described quite a few programming tricks and solutions that
    help to ease pressure on the garbage collector. Yet, it remains an independent
    and unpredictable contributor (or detractor) of the application performance. Wouldn't
    it be nice if the garbage collector was better controlled, at least for test purposes,
    or could be turned off? In Java 11, a garbage collector, Epsilon, called a no-op
    garbage collector, was introduced.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了许多编程技巧和解决方案，可以帮助减轻垃圾收集器的压力。然而，它仍然是应用程序性能的独立和不可预测的贡献者（或减少者）。如果垃圾收集器能够更好地受控制，至少在测试目的中，或者可以关闭，那不是很好吗？在Java
    11中，引入了一个名为Epsilon的垃圾收集器，称为无操作垃圾收集器。
- en: At first glance, it looks strange—a garbage collector that doesn't collect anything.
    But it is predictable (that's for sure) because it does nothing, and that feature
    allows us to test algorithms in short runs without worrying about unpredictable
    pauses. Besides, there is a whole category of small short-lived applications that
    need all the resources they can muster for a brief period of time and it is preferable
    to restart the JVM and let the load balancer perform failover than to try factoring
    in an unpredictable Joker of the garbage-collection process.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这看起来很奇怪——一个不收集任何东西的垃圾收集器。但它是可预测的（这是肯定的），因为它什么也不做，这个特性使我们能够在短时间内测试算法，而不用担心不可预测的暂停。此外，还有一整类需要在短时间内尽可能利用所有资源的小型短期应用程序，最好重新启动JVM并让负载均衡器执行故障转移，而不是尝试考虑垃圾收集过程中不可预测的Joker。
- en: It was also envisioned as a benchmark process that allows us to estimate a regular
    garbage collector overhead.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 它也被设想为一个基准过程，可以让我们估计常规垃圾收集器的开销。
- en: How to do it...
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: To invoke the no-op garbage collector, use the `-XX:+UseEpsilonGC` option. At
    the time of writing, it requires an `-XX:+UnlockExperimentalVMOptions` option
    to access the new capability.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用无操作垃圾收集器，请使用`-XX:+UseEpsilonGC`选项。在撰写本文时，它需要一个`-XX:+UnlockExperimentalVMOptions`选项来访问新功能。
- en: 'We will use the following program for the demonstration:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下程序进行演示：
- en: '[PRE75]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As you can see, in this program, we are trying to allocate 4 GB of memory by
    adding a 1 KB array to the list at each iteration. At the same time, we also create
    a 1 K array, `arr`, at each iteration but do not use the reference to it, so the
    traditional garbage collector can collect it.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在这个程序中，我们试图通过在每次迭代中向列表添加1KB数组来分配4GB的内存。与此同时，我们还在每次迭代中创建一个1K数组`arr`，但不使用对它的引用，因此传统的垃圾收集器可以收集它。
- en: 'First, we will run the preceding program with the default garbage collector:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用默认的垃圾收集器运行前面的程序：
- en: '[PRE76]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Please note that we have limited the JVM heap memory to 4 GB because, for demonstrative
    purposes, we would like the program to exit with `OutOfMemoryError`. And we have
    wrapped the call with the `time` command to capture three values:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已将JVM堆内存限制为4GB，因为出于演示目的，我们希望程序以`OutOfMemoryError`退出。我们已经使用`time`命令包装了调用以捕获三个值：
- en: '**Real time**: How long the program was running'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实际时间**：程序运行的时间'
- en: '**User time**: How long CPU was used by the program'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户时间**：程序使用CPU的时间'
- en: '**Sys time**: How long the operating system worked for the program'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统时间**：操作系统为程序工作的时间'
- en: 'We used JDK 11:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了JDK 11：
- en: '[PRE77]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The output of the preceding commands may be different on your computer. During
    our test run, when we executed the preceding program with the specified `java`
    command parameters, the output started with the following four lines:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的计算机上，前面的命令的输出可能会有所不同。在我们的测试运行期间，当我们使用指定的`java`命令参数执行前面的程序时，输出以以下四行开头：
- en: '[PRE78]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'As you can see, the G1 garbage collector is the default in JDK 11, and it started
    collecting unreferenced `arr` objects right away. As we have expected, the program
    exited after `OutOfMemoryError`:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，G1垃圾收集器是JDK 11中的默认值，并且它立即开始收集未引用的`arr`对象。正如我们所预期的那样，程序在`OutOfMemoryError`后退出：
- en: '[PRE79]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The time utility produced the following results:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 时间实用程序产生了以下结果：
- en: '[PRE80]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Our computer is multicore, so the JVM was able to utilize several cores in parallel,
    most likely for the garbage collection. That is why user time is bigger than real
    time, and the system time is bigger than real time for the same reason.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计算机是多核的，因此JVM能够并行利用多个核心，很可能是用于垃圾收集。这就是为什么用户时间比实际时间长，系统时间也因同样的原因比实际时间长。
- en: 'Now let''s run the same program with the following command:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用以下命令运行相同的程序：
- en: '[PRE81]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Note that we have added the `-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC` options,
    which requires Epsilon garbage collector. The result looks as follows:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已添加了`-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC`选项，这需要Epsilon垃圾收集器。结果如下：
- en: '[PRE82]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'As you can see, the garbage collector did not even try to collect the abandoned
    objects. The usage of the heap space grew steadily until it was consumed completely,
    and the JVM exited with `OutOfMemoryError`.  Using the `time` utility allowed
    us to measure three following time parameters:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，垃圾收集器甚至没有尝试收集被丢弃的对象。堆空间的使用量稳步增长，直到完全耗尽，并且JVM以`OutOfMemoryError`退出。使用`time`实用程序允许我们测量三个时间参数：
- en: '[PRE83]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Naturally, it took much less time to exhaust all the heap memory, and the user
    time is much less than real time. That is why, as we have mentioned already, the
    no-op Epsilon garbage collector can be useful to the programs that have to be
    as fast as possible but do not consume all the heap memory or can be stopped at
    any time. There are probably other use cases where the garbage collector that does
    not do anything can be helpful.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，耗尽所有堆内存所需的时间要少得多，用户时间要比实际时间少得多。这就是为什么，正如我们已经提到的那样，无操作的Epsilon垃圾收集器对于那些必须尽可能快速但不会消耗所有堆内存或可以随时停止的程序可能是有用的。可能还有其他垃圾收集器不做任何事情可能有帮助的用例。
