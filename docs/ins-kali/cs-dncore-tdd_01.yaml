- en: Exploring Test-Driven Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索测试驱动开发
- en: In order to craft robust, maintainable, and scalable software applications,
    software development teams and stakeholders must make certain important decisions
    early in the software development process. These decision makers must adopt the
    software industry's tested and proven best practices and standards throughout
    the different stages of software development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打造健壮、可维护和可扩展的软件应用程序，软件开发团队和利益相关者必须在软件开发过程的不同阶段早期做出一些重要决策。这些决策者必须在整个软件开发过程中采用软件行业经过测试和证明的最佳实践和标准。
- en: The quality of software projects can quickly degrade when developers build the
    code base using development approaches, coding styles, and practices that automatically
    make source code rigid and difficult to maintain. This chapter points out the
    habits and practices that result in writing bad code and should therefore be avoided.
    The programming habits, development styles, and approaches that should be learned
    to facilitate writing clean and maintainable code are explained.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发人员使用开发方法、编码风格和实践来构建代码库时，这些方法会自动使源代码变得僵化且难以维护，软件项目的质量会迅速下降。本章指出了导致编写糟糕代码的习惯和实践，因此应该避免。解释了应该学习的编程习惯、开发风格和方法，以便编写清洁和可维护的代码。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Difficulty in maintaining code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护代码的困难
- en: How bad code gets that way
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 糟糕的代码是如何变成糟糕的
- en: What we can do to prevent bad code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以做些什么来防止糟糕的代码
- en: The principles of test-driven development
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发的原则
- en: The test-driven development cycle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发周期
- en: Difficulty in maintaining code
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护代码的困难
- en: There are two types of code—good code and bad code. The syntax of both types
    of code may be correct when compiled and running the code can give the expected
    results. However, bad code leads to serious issues when it comes to extending
    or even making little changes to the code, due to the way it was written.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的代码——好的代码和糟糕的代码。这两种类型的代码在编译时语法可能是正确的，运行代码可以得到预期的结果。然而，由于编写方式的原因，糟糕的代码在扩展或甚至对代码进行小改动时会导致严重问题。
- en: When programmers write code using unprofessional approaches and styles, this
    often results in bad code. Also, the use of unreadable coding styles or formats
    as well as not properly and effectively testing code are all precursors to bad
    code. Code can be written poorly when programmers sacrifice professionalism in
    order to meet approaching deadlines and project milestones.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员使用不专业的方法和风格编写代码时，通常会导致糟糕的代码。此外，使用难以阅读的编码风格或格式，以及未能正确有效地测试代码都是糟糕代码的先兆。当程序员为了满足即将到来的截止日期和项目里程碑而牺牲专业精神时，代码可能会写得很糟糕。
- en: I have come across a few software projects that rapidly become legacy software
    projects that are abandoned because of incessant production bugs and the inability
    to incorporate change requests from users easily. This is because these software
    applications were deployed into production with a severe accumulation of technical
    debts through bad code written by software developers as a result of making poor
    design and development decisions and using programming styles known to cause future
    maintenance problems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾遇到一些软件项目，它们迅速成为被遗弃的遗留软件项目，因为不断出现的生产错误和无法轻松地满足用户的变更请求。这是因为这些软件应用程序在投入生产时积累了严重的技术债务，这是由于软件开发人员编写了糟糕的代码，导致了糟糕的设计和开发决策，并使用了已知会导致未来维护问题的编程风格。
- en: Source code elements—methods, classes, comments, and other artifacts—should
    be easy to read, understand, debug, refactor, and extend if required by another
    developer other than the original developer; otherwise, bad code has already been
    written.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码元素——方法、类、注释和其他工件——应该易于阅读、理解、调试、重构和扩展，如果需要由原始开发人员以外的其他开发人员进行；否则，糟糕的代码已经被编写。
- en: You know you have bad code when, extending or adding new features, you break
    the existing working features. This can also happen when there are portions of
    code that cannot be decoded or any changes to them will bring the system to a
    halt. Another reason for bad code is usually because of nonadherence to object-oriented
    and **Don't Repeat Yourself** (**DRY**) principles or wrong use of the principles.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在扩展或添加新功能时，你会知道你的代码有问题，因为你会破坏现有的工作功能。当代码部分无法解码或对其进行任何更改会使系统停止时，也会发生这种情况。糟糕的代码通常是因为不遵守面向对象和“不要重复自己”（DRY）原则或错误使用这些原则。
- en: DRY is an important principle in programming, which aims at breaking down a
    system into small components. These components can easily be managed, maintained,
    and reused in order to avoid writing duplicate code and having different parts
    of code performing the same function.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: DRY是编程中的一个重要原则，旨在将系统分解为小组件。这些组件可以轻松管理、维护和重复使用，以避免编写重复的代码并使代码的不同部分执行相同的功能。
- en: How does bad code appear?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 糟糕的代码是如何出现的？
- en: 'Bad code doesn''t just appear in a code base; programmers write bad code. Most
    of the time, bad code can be written because of any of the following reasons:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕的代码不仅仅出现在代码库中；程序员写了糟糕的代码。大多数情况下，糟糕的代码可能是由于以下任何原因之一而写成的：
- en: Use of wrong approaches by developers when writing code that is often attributed
    to tight coupling of components
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员在编写代码时使用错误的方法经常被归因于组件之间的紧密耦合
- en: Faulty program designs
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误的程序设计
- en: Bad naming conventions for program elements and objects
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序元素和对象的糟糕命名约定
- en: Writing code that is not readable as well as having a code base without proper
    test cases, thus causing difficulty when there is a need to maintain the code
    base
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写不可读的代码以及没有适当的测试用例的代码库，因此在需要维护代码库时会导致困难
- en: Tight coupling
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 紧密耦合
- en: Most legacy software applications are known to be tightly coupled, with little
    or no flexibility and modularity. Tightly coupled software components lead to
    a rigid code base which can be difficult to modify, extend, and maintain. As most
    software applications evolve over time, big maintenance issues are created when
    components of applications are tightly coupled. This is due to the changes in
    requirements, user's business processes, and operations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数传统软件应用程序都被认为是紧密耦合的，灵活性和模块化性很少或根本没有。紧密耦合的软件组件会导致刚性的代码库，难以修改、扩展和维护。随着大多数软件应用程序随着时间的推移而发展，当应用程序的组件紧密耦合时，会产生大量的维护问题。这是由于需求变化、用户业务流程和操作的变化所导致的。
- en: Third-party libraries and frameworks reduce development time and allow developers
    to concentrate on implementing users' business logic and requirements without
    having to waste valuable productive time reinventing the wheel through implementing
    common or mundane tasks. However, at times, developers tightly couple the applications
    with third-party libraries and frameworks, creating maintenance bottlenecks that
    require great efforts to fix when the need arises to replace a referenced library
    or framework.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方库和框架可以减少开发时间，并允许开发人员集中精力实施用户的业务逻辑和需求，而无需浪费宝贵的生产时间通过实现常见或乏味的任务来重新发明轮子。然而，有时开发人员会将应用程序与第三方库和框架紧密耦合，从而创建维护瓶颈，需要大力修复当需要替换引用的库或框架时。
- en: 'The following code snippet shows an example of tight coupling with a third-party
    `smpp` library:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了与第三方`smpp`库紧密耦合的示例：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Code smell
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码异味
- en: '**Code smell** is a term that was first used by *Kent Beck*, which indicates
    deeper issues in the source code. Code smell in a code base can come from having
    replications in the source code, use of inconsistent or vague naming conventions
    and coding styles, creating methods with a long list of parameters, and having
    monster methods and classes, that is methods or classes that know and do too much
    thereby violating the single responsibility principle. The list goes on and on.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码异味**是由*Kent Beck*首次使用的一个术语，它指出了源代码中的更深层次的问题。代码库中的代码异味可能来自于源代码中的复制、使用不一致或模糊的命名约定和编码风格、创建具有长参数列表的方法以及具有庞大方法和类，即知道并做太多事情，从而违反了单一责任原则。列表还在继续。'
- en: A common code smell in the source code is when a developer creates two or more
    methods that perform the same action with little or no variation or with program
    details or facts that ought to be implemented in a single point replicated in
    several methods or classes, leading to a code base that is not easy to maintain.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码中常见的代码异味是当开发人员创建两个或更多执行相同操作的方法，几乎没有变化或在应该在单个点中实现的程序细节或事实在多个方法或类中复制，导致代码库难以维护。
- en: 'The following two ASP.NET MVC action methods have lines of code that create
    a strongly-typed list of strings of years and months. These lines of code, that
    could easily have been refactored into a third method and called by both methods,
    have been replicated in these two methods:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个ASP.NET MVC动作方法有代码行，创建了一个强类型的字符串年份和月份列表。这些代码行本来可以被重构为第三个方法，并被这两个方法调用，但却在这两个方法中被复制：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Another common code smell occurs when developers create methods with a long
    list of parameters, as in the following method:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的代码异味出现在开发人员创建具有长参数列表的方法时，就像以下方法中所示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Bad or broken designs
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坏或破损的设计
- en: Quite often, the structure or design and patterns used in implementing an application
    can result in bad code, most especially when object-oriented programming principles
    or design patterns are wrongly used. A common anti-pattern is **spaghetti coding**.
    It is common among developers with little grasp of object-orientation and this
    involves creating a code base with unclear structures, little or no reusability,
    and no relationships between objects and components. This leads to applications
    that are difficult to maintain and extend.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施应用程序时，经常会出现结构或设计和模式导致糟糕的代码，尤其是在错误使用面向对象编程原则或设计模式时。一个常见的反模式是**意大利面条式编码**。这在对面向对象理解不深的开发人员中很常见，这涉及创建具有不清晰结构、几乎没有可重用性以及对象和组件之间没有关系的代码库。这导致应用程序难以维护和扩展。
- en: There is a common practice among inexperienced developers, which is the unnecessary
    or inappropriate use of design patterns in solving application complexity. The
    design patterns when used incorrectly can give a code base bad structure and design.
    The use of design patterns should simplify complexity and create readable and
    maintainable solutions to software problems. When a pattern is causing a readability
    issue and overtly adding complexity to a program, it is worth reconsidering whether
    to use the pattern at all, as the pattern is being misused.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在经验不足的开发人员中有一种常见的做法，即在解决应用程序复杂性时不必要或不适当地使用设计模式。当错误使用设计模式时，会给代码库带来糟糕的结构和设计。使用设计模式应该简化复杂性，并为软件问题创建可读和可维护的解决方案。当某个模式导致可读性问题并明显增加了程序的复杂性时，值得重新考虑是否使用该模式，因为该模式被误用了。
- en: 'For example, a singleton pattern is used to create a single instance to a resource.
    The design of a singleton class should have a private constructor with no arguments,
    a static variable with reference to the single instance of the resource, and a
    managed public means of referencing the static variable. A singleton pattern can
    simplify the access to a single-shared resource but can also cause a lot of problems
    when not implemented with thread safety in mind. Two or more threads can access
    the `if (smtpGateway==null)` line at the same time, which can create multiple
    instances of the resource if the line is evaluated to `true`, as with the implementation
    shown in the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，单例模式用于创建对资源的单个实例。单例类的设计应该有一个私有构造函数，没有参数，一个静态变量引用资源的单个实例，以及一个管理的公共手段来引用静态变量。单例模式可以简化对单一共享资源的访问，但如果没有考虑线程安全性，也可能会导致很多问题。两个或更多线程可以同时访问`if
    (smtpGateway==null)`这一行，如果这行被评估为`true`，就会创建资源的多个实例，就像下面代码中所示的实现一样：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Naming the program elements
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名程序元素
- en: Meaningful and descriptive element naming can greatly improve the source code's
    readability. It allows easy comprehension of the logical flow of the program.
    It is amazing how software developers still give names to program elements that
    are too short or not descriptive enough, such as giving a variable a letter name
    or using acronyms for variable naming.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有意义和描述性的元素命名可以极大地提高源代码的可读性。它可以让程序的逻辑流程更容易理解。令人惊讶的是，软件开发人员仍然会给程序元素起太短或者不够描述性的名字，比如给变量起一个字母的名字，或者使用缩写来命名变量。
- en: 'Generic or elusive names for elements lead to ambiguity. For example, having
    a method name as `Extract()` or `Calculate()` at first glance results in subjective
    interpretations. The same is applicable to using vague names for variables. For
    example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对元素使用通用或模糊的名称会导致歧义。例如，将一个方法命名为`Extract()`或`Calculate()`，乍一看会导致主观解释。对变量使用模糊的名称也是如此。例如：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: While program element naming in itself is an art, names are to be selected to
    define the purposes as well as succinctly describe the elements and ensure that
    the chosen names comply with the standards and rules of the programming language
    being used.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然程序元素的命名本身就是一门艺术，但是名称应该被选择来定义目的，并简要描述元素，并确保所选名称符合所使用的编程语言的标准和规则。
- en: More information on acceptable naming guidelines and conventions is available
    at: [https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/naming-guidelines](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/naming-guidelines).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可接受的命名准则和约定的更多信息，请访问：[https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/naming-guidelines](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/naming-guidelines)。
- en: Source code readability
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码的可读性
- en: A good code base can be easily distinguished from a bad one by how quickly a
    new team member or even the programmer can easily understand it after leaving
    it for a few years. Quite often, because of tight schedules and approaching deadlines,
    software development teams tend to compromise and sacrifice professionalism to
    meet deadlines, by not following the recommended best practices and standards.
    This often leads them to produce code that is not readable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的代码库可以通过一个新团队成员或者甚至是程序员在离开几年后能够轻松理解来轻松区分出一个糟糕的代码库。由于时间紧迫和截止日期临近，软件开发团队往往会妥协和牺牲专业精神来满足截止日期，不遵循推荐的最佳实践和标准。这经常导致他们产生不可读的代码。
- en: 'The following code snippet will perform what it is intended to do, although
    it contains elements written using terrible naming conventions and this affects
    the code''s readability:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段将执行其预期的功能，尽管其中包含使用糟糕的命名约定编写的元素，这影响了代码的可读性：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Poor source code documentation
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 糟糕的源代码文档
- en: Code can be easily understood when written using the programming language's
    coding style and convention while avoiding the bad code pitfalls discussed earlier.
    However, source code documentation is very valuable and its importance in software
    projects cannot be overemphasized. Brief and meaningful documentation of classes
    and methods can give developers a quick insight into their internal structures
    and operations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用编程语言的编码风格和约定编写代码时，可以很容易地理解代码，同时避免之前讨论过的糟糕的代码陷阱。然而，源代码文档非常有价值，在软件项目中的重要性不可低估。对类和方法进行简要而有意义的文档编写可以让开发人员快速了解它们的内部结构和操作。
- en: Understanding a complex or poorly written class becomes a nightmare when there
    is no proper documentation in place. When the original programmer that wrote the
    code is no longer around to provide clarifications, valuable productive time can
    be lost trying to understand how the class or method is implemented.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有适当的文档时，理解复杂或写得不好的类会变成一场噩梦。当原始编写代码的程序员不再提供澄清时，宝贵的生产时间可能会因为试图理解类或方法的实现而丢失。
- en: Non-tested code
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未经测试的代码
- en: Though many articles have been written and discussions have been initiated at
    various developers' conferences on different types of testing—test-driven development,
    behavior-driven development, and acceptance test-driven development—it is very
    concerning that there are developers that continuously develop and ship software
    applications that are not thoroughly tested or tested at all.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管已经有很多文章和讨论在各种开发者会议上启动了不同类型的测试——测试驱动开发、行为驱动开发和验收测试驱动开发，但令人担忧的是，仍然有开发人员不断开发和发布未经彻底测试或根本没有经过测试的软件应用程序。
- en: Shipping applications that are poorly tested can have catastrophic consequences
    and maintenance problems. Notable is **NASA's Mars Climate Orbiter** launched
    on **December 11, 1998** that failed just as the orbiter approached Mars, due
    to a software error caused by an error in conversion where the orbiter's program
    code was calculating a metric in pounds instead of newtons. A simple unit testing
    of the particular module responsible for calculating the metrics could have detected
    the error and maybe prevented the failure.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 发布未经充分测试的应用程序可能会产生灾难性后果和维护问题。值得注意的是**美国国家航空航天局**于**1998年12月11日**发射的**火星气候轨道飞行器**在接近火星时失败，原因是由于转换错误导致的软件错误，其中轨道飞行器的程序代码在计算时使用的是磅而不是牛顿。对负责计算度量标准的特定模块进行简单的单元测试可能会检测到错误并可能防止失败。
- en: Also, according to the *State of Test-First Methodologies 2016 Report*, a survey
    of the adoption of test-first methodologies of more than 200 software organizations
    from 15 different countries, conducted by a testing services company named **QASymphony**,
    revealed that nearly half of the survey respondents had not implemented a test-first
    methodology in the applications they had developed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，根据2016年*测试优先方法的现状报告*，由名为**QASymphony**的测试服务公司对来自15个不同国家的200多家软件组织的测试优先方法的采用进行了调查，结果显示近一半的受访者在他们开发的应用程序中没有实施测试优先方法。
- en: What we can do to prevent bad code
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们可以做些什么来防止糟糕的代码
- en: Writing clean code requires a conscious effort of maintaining professionalism
    and following best industry standards throughout the stages of the software development
    process. Bad code should be avoided right from the onset of software project development,
    because the accumulation of bad debt through bad code can slow down software project
    completion and create future issues after the software has been deployed to production.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 编写干净的代码需要有意识地保持专业精神，并在软件开发过程的各个阶段遵循最佳行业标准。从软件项目开发的一开始就应该避免糟糕的代码，因为通过糟糕的代码积累的坏账可能会减慢软件项目的完成速度，并在软件部署到生产环境后造成未来问题。
- en: To avoid bad code, you have to be lazy, as the general saying goes that lazy
    programmers are the best and smartest programmers because they hate repetitive
    tasks, such as having to go back to fix issues that could have been prevented.
    Try to use programming styles and approaches that avoid writing bad code, to avoid
    having to rewrite your code in order to fix avoidable issues, bugs, or to pay
    technical debts.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要避免糟糕的代码，你必须懒惰，因为一般说来懒惰的程序员是最好的和最聪明的程序员，因为他们讨厌重复的任务，比如不得不回去修复本可以避免的问题。尽量使用避免编写糟糕代码的编程风格和方法，以避免不得不重写代码以修复可避免的问题、错误或支付技术债务。
- en: Loose coupling
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松散耦合
- en: '**Loose coupling** is the direct opposite of tight coupling. This is a good
    object-oriented programming practice of separation of concerns by allowing components
    to have little or no information of the internal workings and implementation of
    other components. Communication is done through interfaces. This approach allows
    for an easy substitution of components without many changes to the entire code
    base. The sample code in the *Tight coupling* section can be refactored to allow
    loose coupling:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**松散耦合**是紧密耦合的直接相反。这是一种良好的面向对象编程实践，通过允许组件几乎不知道其他组件的内部工作和实现来实现关注点的分离。通信是通过接口进行的。这种方法允许轻松替换组件，而不需要对整个代码库进行太多更改。在*紧耦合*部分的示例代码可以重构以实现松散耦合：'
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Sound architecture and design
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声音架构和设计
- en: Bad code can be avoided through the use of a good development architecture and
    design strategy. This will ensure that development teams and organizations have
    a high-level architecture, strategy, practices, guidelines, and governance plans
    that team members must follow to prevent cutting corners and avoiding bad code
    throughout the development process.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用良好的开发架构和设计策略可以避免糟糕的代码。这将确保开发团队和组织具有高级架构、策略、实践、准则和治理计划，团队成员必须遵循以防止走捷径和避免在整个开发过程中出现糟糕的代码。
- en: 'Through continuous learning and improvement, software development team members
    can develop thick skins towards writing bad code. The sample code snippet in the
    *Bad or broken designs* section can be refactored to be thread-safe and avoid
    thread-related issues, as shown in the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过持续学习和改进，软件开发团队成员可以对编写糟糕的代码产生厚厚的皮肤。*糟糕或破损的设计*部分中的示例代码片段可以重构为线程安全，并避免与线程相关的问题，如下所示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Preventing and detecting code smell
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预防和检测代码异味
- en: 'Programming styles and coding formats that result in code smell should be avoided.
    By adequately paying attention to the details, bad code pointers discussed in
    the *Code smell* section should be avoided. The replicated lines of code in the
    two methods of the source code mentioned in the *Code smell* section can be refactored
    to a third method. This avoids replication of code and allows for easy modifications:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 应该避免导致代码异味的编程风格和编码格式。通过充分关注*代码异味*部分中讨论的糟糕代码指针，可以避免代码的重复。在*代码异味*部分提到的源代码的两种方法中的重复代码可以重构为第三种方法。这样可以避免代码的重复，并且可以轻松进行修改：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, the method with a long list of parameters in the *Code smell* section
    can be refactored to use **C# Plain Old CLR Object** (**POCO**) for clarity and
    reusability:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在*代码异味*部分中具有长参数列表的方法可以重构为使用**C# Plain Old CLR Object**（**POCO**）以实现清晰和可重用性：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Development teams should have guidelines, principles, and coding conventions
    and standards developed jointly by the team members and should be constantly updated
    and refined. These, when used effectively, will prevent code smell in the software
    code base and allow for the easy identification of potential bad code by team
    members.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队应该有由团队成员共同制定的准则、原则和编码约定和标准，并应不断更新和完善。有效使用这些将防止软件代码库中的代码异味，并允许团队成员轻松识别潜在的糟糕代码。
- en: C# coding conventions
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#编码约定
- en: 'Using the guidelines in C# coding conventions facilitates the mastery of writing
    clean, readable, easy to modify, and maintainable code. Use variable names that
    are descriptive and represent what they are used for, as shown in the following
    code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循C#编码约定指南有助于掌握编写清晰、可读、易于修改和易于维护的代码。使用描述性的变量名称，代表它们的用途，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Also, having more than one statement or declaration on a line clogs readability.
    Comments should be on a new line and not at the end of the code. You can read
    more about C# coding conventions at: [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一行上有多个语句或声明会降低可读性。注释应该在新的一行上，而不是在代码的末尾。您可以在以下链接了解更多关于C#编码约定的信息：[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions)。
- en: Succinct and proper documentation
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简洁而恰当的文档
- en: You should always try to write self-documenting code. This can be achieved through
    good programming style. Write code in such a manner that your classes, methods,
    and other objects are self-documenting. A new developer should be able to pick
    your code and not have to be stressed out before understanding what the code does
    and its internal structure.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终尝试编写自解释的代码。这可以通过良好的编程风格实现。以这样一种方式编写代码，使得您的类、方法和其他对象都是自解释的。新的开发人员应该能够使用您的代码，而不必在理解代码及其内部结构之前感到紧张。
- en: 'Coding elements should be descriptive and meaningful to provide an insight
    to the reader. In situations where you have to document a method or class to provide
    further clarity, adopt the **Keep It Simple Short** (**KISS**) approach, briefly
    stating the reasons for a certain decision. Check the following code snippet;
    nobody wants to have to read two pages of documentation for a class containing
    200 lines of code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 编码元素应该具有描述性和意义，以向读者提供洞察力。在必须记录方法或类以提供进一步澄清的情况下，采用“保持简单”的方法，简要说明某个决定的原因。检查以下代码片段；没有人希望为包含200行代码的类阅读两页文档：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: KISS also known as **Keep it Simple, Stupid**, is a design principle that states
    that most systems work at their best when they are kept simple rather than making
    them unnecessarily complex. The principle aims at aiding programmers to keep the
    code simple as much as possible, to ensure that code can be easily maintained
    in the future.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: KISS，也称为“保持简单，愚蠢”，是一种设计原则，它指出大多数系统在保持简单而不是使其不必要地复杂时运行得最好。该原则旨在帮助程序员尽可能简化代码，以确保未来可以轻松维护代码。
- en: Why test-driven development?
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要进行测试驱动开发？
- en: Each time I enter a discussion with folks not practicing test-driven development,
    they mostly have one thing in common, which is that it consumes time and resources
    and it does not really give a return on investment. I usually reply to them by
    asking which is better, detecting bugs and potential bottlenecks and fixing them
    while the application is being developed or hotfixing bugs when the application
    is in production? Test-driven development will save you a lot of problems and
    ensure you produce robust and issue-free applications.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我与不实践测试驱动开发的人进行讨论时，他们通常有一个共同点，那就是它消耗时间和资源，而且并不能真正带来投资回报。我通常会回答他们，问哪个更好，即在应用程序开发过程中检测错误和潜在瓶颈并修复它们，还是在应用程序处于生产状态时进行热修复？测试驱动开发将为您节省大量问题，并确保您生成健壮且无故障的应用程序。
- en: Building for longevity
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向长期发展
- en: To avoid future problems resulting from issues when making modifications to
    a system in production as a result of changes in user requirements, as well as
    bugs which get exposed because of inherent bad code in a code base and accumulated
    technical debt, you need to have the mindset of developing with the future in
    mind and embracing changes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免由于用户需求变化而对系统进行修改时可能导致的未来问题，以及由于代码库中固有的糟糕代码和累积的技术债务而暴露的错误，您需要具有以未来为考量并接受变化的思维方式。
- en: Use flexible patterns and always employ good object-oriented development and
    design principles when writing code. The requirements of most software projects
    change over their life cycles. It is wrong to assume that a component or part
    might not change, so try and put a mechanism in place to allow the application
    to be graceful and accept future changes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用灵活的模式，并且在编写代码时始终遵循良好的面向对象开发和设计原则。大多数软件项目的需求在其生命周期内都会发生变化。假设某个组件或部分不会发生变化是错误的，因此请尝试建立一个机制，使应用程序能够优雅地接受未来的变化。
- en: The principles of test-driven development
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发的原则
- en: '**Test-driven development** (**TDD**) is an iterative agile development technique
    that emphasizes test-first development, which implies that you write a test before
    you write production-ready code to make the test pass. The TDD technique focuses
    on writing clean and quality code by ensuring that the code passes the earlier
    written tests by continuously refactoring the code.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发（TDD）是一种迭代的敏捷开发技术，强调先测试开发，这意味着在编写生产就绪的代码之前编写测试。TDD技术侧重于通过不断重构代码来确保代码通过先前编写的测试，从而编写干净和高质量的代码。
- en: TDD, being a test-first development approach, places greater emphasis on building
    well-tested software applications. This allows developers to write code in relation
    to solving the tasks defined in the tests after a thorough thought process. It
    is a common practice in TDD that the development process begins with writing the
    tests code before the actual application code is written.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: TDD作为一种先测试的开发方法，更加强调构建经过充分测试的软件应用程序。这使开发人员能够根据在经过深思熟虑后定义的测试任务来编写代码。在TDD中，常见的做法是在编写实际应用程序代码之前编写测试代码。
- en: TDD introduces an entirely new development paradigm and shifts your mindset
    to begin thinking about testing your code right before you even start writing
    the code. This contrasts with the traditional development technique of deferring
    code testing to the later stage of the development cycle, an approach known as
    **test last development** (**TLD**).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: TDD引入了一个全新的开发范式，并改变了你的思维方式，开始在甚至开始编写代码之前考虑测试你的代码。这与传统的开发技术相反，传统技术将代码测试推迟到开发周期的后期阶段，这种方法被称为**最后测试开发**（**TLD**）。
- en: TDD has been discussed at several conferences and hackathons. Many technology
    advocates and bloggers have blogged about TDD, its principles, and its benefits.
    At the same time, there have been many talks and articles written against TDD.
    The honest truth is TDD rocks, it works, and it offers great benefits when practiced
    correctly and consistently.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: TDD已经在多个会议和黑客马拉松上进行了讨论。许多技术倡导者和博客作者都在博客中讨论了TDD、它的原则和好处。与此同时，也有许多关于TDD的演讲和文章。诚实的事实是TDD很棒，它有效，当正确和一贯地实践时，它提供了巨大的好处。
- en: You might probably be wondering, like every developer new to TDD, why write
    a test first, since you trust your coding instinct to write clean code that always
    works and usually will test the entire code when you've done coding. Your coding
    instinct may be right or it may not. There is no way to validate this assumption
    until the code is validated against a set of written test cases and passes; trust
    is good, but control is better.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，就像每个新接触TDD的开发人员一样，为什么要先写测试，因为你相信自己的编码直觉可以编写始终有效的干净代码，并且通常在编码完成后会测试整个代码。你的编码直觉可能是正确的，也可能不是。在代码通过一组书面测试用例并通过验证之前，没有办法验证这个假设；信任是好的，但控制更好。
- en: Test cases in TDD are prepared with the aid of user stories or use cases of
    the software application being developed. The code is then written and refactored
    iteratively until the tests pass. For example, a method written to validate the
    length of a credit card might contain test cases to validate the correct length,
    incorrect length, and even when the null or empty credit card is passed as a parameter
    to the method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: TDD中的测试用例是通过用户故事或正在开发的软件应用程序的用例来准备的。然后编写代码并进行迭代重构，直到测试通过。例如，编写用于验证信用卡长度的方法可能包含用例来验证正确长度、不正确长度，甚至当空或空信用卡作为参数传递给方法时。
- en: Many variants of TDD have been proposed ever since it was originally popularized.
    A variant is **behavior-driven development** (**BDD**) or **acceptance test–driven
    development** (**ATDD**), which follows all the principles of TDD while the tests
    are based on expected user-specified behavior.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 自TDD最初被推广以来，已经提出了许多变体。其中一种是**行为驱动开发**（**BDD**）或**验收测试驱动开发**（**ATDD**），它遵循TDD的所有原则，而测试是基于预期的用户指定行为。
- en: Origin of TDD
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD的起源
- en: There is literally no written evidence as to when the practice of TDD was introduced
    into computer programming or by which company it was first used. Nevertheless,
    there is an excerpt from *Digital Computer Programming*, by D.D. McCracken, in
    1957, which indicated that the concept of TDD was not new and had been used by
    earlier folks, though the nomenclature apparently was different.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 关于TDD实践是何时引入计算机编程或者是哪家公司首先使用的，实际上没有任何书面证据。然而，1957年D.D. McCracken的《数字计算机编程》中有一段摘录，表明TDD的概念并不新鲜，早期的人们已经使用过，尽管名称显然不同。
- en: The first attack on the checkout problem may be made before coding has begun.
    In order to fully ascertain the accuracy of the answers, it is necessary to have
    a hand-calculated check case with which to compare the answers which will later
    be calculated by the machine. This means that stored program machines are never
    used for a true one-shot problem. There must always be an element of iteration
    to make it pay.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码开始之前，可能会对结账问题进行第一次攻击。为了充分确定答案的准确性，有必要准备一个手工计算的检查案例，以便将来与机器计算的答案进行比较。这意味着存储程序机永远不会用于真正的一次性问题。总是必须有迭代的元素来使其付出。
- en: Also, in the early 1960s, folks at IBM ran a project (**Project Mecury**) for
    NASA where they utilized a technique like TDD where half-day iterations were done
    and the development team performed a review of the changes made. This was a manual
    process and cannot be compared to the automated tests we have today.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在1960年代初，IBM的人们为NASA运行了一个项目（**Project Mecury**），他们利用了类似TDD的技术，进行了半天的迭代，并且开发团队对所做的更改进行了审查。这是一个手动过程，无法与我们今天拥有的自动化测试相比。
- en: TDD was originally popularized by Kent Beck. He attributed it to an excerpt
    he read in an ancient book where TDD was described with the simple statements,
    *you take the input tape, manually type in the output tape you expect, then program
    until the actual output tape matches the expected output*. The concept of TDD was
    redefined by Kent Beck when he developed the first xUnit test framework at Smalltalk.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: TDD最初是由Kent Beck推广的。他将其归因于他在一本古老书中读到的一段摘录，其中TDD被描述为简单的陈述，*你拿输入磁带，手动输入你期望的输出磁带，然后编程直到实际输出磁带与期望输出相匹配*。当他在Smalltalk开发了第一个xUnit测试框架时，Kent
    Beck重新定义了TDD的概念。
- en: It is safe to say that the Smalltalk community used TDD long before it became
    widespread because **SUnit** was used in the community. Not until SUnit was ported
    to **JUnit** by *Kent Beck* and other enthusiasts was it that TDD became widely
    known. Since then different testing frameworks have been developed. A popular
    tool is the **xUnit**, with ports available for a large number of programming
    languages.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 可以肯定地说，Smalltalk社区在TDD变得普遍之前就已经使用了TDD，因为社区中使用了**SUnit**。直到*Kent Beck*和其他爱好者将SUnit移植到**JUnit**之后，TDD才变得广为人知。从那时起，不同的测试框架已经被开发出来。一个流行的工具是**xUnit**，可以为大量编程语言提供端口。
- en: TDD misconceptions
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD的误解
- en: Developers have different opinions when it comes to TDD. Most developers do
    complain about the time and resources required to practice TDD fully and how practicing
    TDD might not be feasible, based on tight deadlines and schedules. This perception
    is common among developers just adopting the technique, on the premise that TDD
    requires writing double code and that time spent doing this could have been used
    to work on developing other features, and that TDD is best suited for projects
    with small features or tasks and will be time-wasting with little return on investment
    for large projects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及TDD时，开发人员有不同的观点。大多数开发人员抱怨完全实践TDD所需的时间和资源，以及实践TDD可能不可行，基于紧迫的截止日期和时间表。这种看法在刚刚采用该技术的开发人员中很常见，因为TDD需要编写双倍的代码，而这些时间本可以用来开发其他功能，而且TDD最适合具有小功能或任务的项目，对于大型项目来说，可能会浪费时间，回报很少。
- en: Also, some developers complain that mocking can make TDD very difficult and
    frustrating, as the required dependencies are not to be implemented at the same
    time the dependent code is being implemented but should be mocked. Using the traditional
    approach of testing last, the dependencies can be implemented and all the different
    parts of the code can be tested afterwards.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些开发人员抱怨模拟可能会使TDD变得非常困难和令人沮丧，因为所需的依赖关系不应该在实现依赖代码的同时实现，而应该进行模拟。使用传统的测试最后的方法，可以实现依赖关系，然后可以测试代码的所有不同部分。
- en: Another popular misconception is that in the real sense tests cannot be written
    until the design is determined which relies on code implementation. This is not
    true, as adopting TDD will ensure there is a clear-cut plan on how the code implementation
    is to be done, which in turn gives a proper design which can aid the creation
    of efficient and reliable tests for the intended code to be written.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的误解是，在真正意义上，直到确定设计依赖于代码实现之前，测试才不能被编写。这是不正确的，因为采用TDD将确保对代码实现的计划清晰明了，从而产生一个适当的设计，可以帮助编写高效可靠的测试。
- en: Some folks at times use TDD and unit testing interchangeably, taking them to
    be the same. TDD and unit testing are not the same. Unit testing involves practicing
    TDD at the smallest unit or level of coding, which is a method or function, while
    TDD is a technique and design approach that encompasses unit testing and integration
    testing, as well as acceptance testing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，一些人会将TDD和单元测试混为一谈，认为它们是一样的。TDD和单元测试并不相同。单元测试涉及在最小的编码单元或级别上实践TDD，这是一种方法或函数，而TDD是一种技术和设计方法，包括单元测试、集成测试以及验收测试。
- en: Developers new to TDD often think you must completely write the tests before
    writing the actual code. The reverse is the case as TDD is an iterative technique.
    TDD favors exploratory processes where you write the tests and you write enough
    code. If it fails, you refactor the code until it passes and you can move on to
    implementing the next feature of your application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 刚接触TDD的开发人员经常认为在编写实际代码之前必须完全编写测试。事实恰恰相反，因为TDD是一种迭代技术。TDD倾向于探索性过程，你编写测试并编写足够的代码。如果失败，就重构代码直到通过，然后可以继续实现应用程序的下一个功能。
- en: TDD is not a silver bullet that automatically fixes all your bad coding behaviors.
    You can practice TDD and still write bad code or even bad tests. This is possible
    if the TDD principles and practices are not correctly used, or even when trying
    to use TDD where it's not practical to use it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: TDD并不是一个可以自动修复所有糟糕编码行为的灵丹妙药。你可以实践TDD，但仍然编写糟糕的代码甚至糟糕的测试。如果没有正确使用TDD原则和实践，或者试图在不适合使用TDD的地方使用TDD，这是可能的。
- en: Benefits of TDD
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD的好处
- en: TDD, when done correctly and appropriately, can give a good return on investment
    as it facilitates the development of self-testing code, which yields robust software
    applications with fewer or no bugs. This is because most of the bugs and issues
    that might appear in production would have been caught and fixed during the development
    stage.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: TDD，如果正确和适当地完成，可以带来良好的投资回报，因为它有助于开发自测代码，从而产生具有更少或没有错误的健壮软件应用程序。这是因为大部分可能出现在生产中的错误和问题在开发阶段已经被捕捉和修复了。
- en: Documenting the source code is a good coding practice, but in addition to source
    code documentation, tests are miniature documentations of the source code as they
    serve as a quick way to understand how a piece of code works. The test will show
    the expected input together with the expected output or outcomes. The structure
    of an application can be easily understood from the tests, as there will be tests
    for all the objects as well as tests for the methods of the objects, showing their
    usage.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了源代码文档，编写测试也是一种良好的编码实践，因为它们作为源代码的微型文档，可以快速理解代码的工作原理。测试将显示预期的输入以及预期的输出或结果。从测试中可以轻松理解应用程序的结构，因为所有对象都将有测试，以及对象方法的测试，显示它们的使用方式。
- en: Practicing TDD correctly and continuously helps you to write elegant code with
    good abstraction, flexible design, and architecture. This is true because, to
    effectively test all parts of an application, the various dependencies need to
    be broken down into components that can be tested in isolation and later tested
    when integrated.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正确和持续地实践TDD有助于编写具有良好抽象、灵活设计和架构的优雅代码。这是因为，为了有效地测试应用程序的所有部分，各种依赖关系需要被分解成可以独立测试的组件，并在集成后进行测试。
- en: What makes a code clean is when the code has been written using best industry
    standards, can be easily maintained, is readable, and has tests written to validate
    its consistent behavior appropriately . This indicates that a code without testing
    is a bad code as there is no specific way of directly verifying its integrity.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的清晰性在于使用最佳行业标准编写代码，易于维护，可读性强，并且编写了用于验证其一致行为的测试。这表明没有测试的代码是糟糕的代码，因为没有直接验证其完整性的特定方式。
- en: Types of tests
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试的类型
- en: Testing software projects can take different forms and is often carried out
    by the developers and test analysts or specialists. Testing is carried out to
    ascertain that the software meets its specified expectation, to identify errors
    if possible, and to validate that the software is usable. Most programmers often
    take testing and debugging to be the same. Debugging is carried out to diagnose
    errors and issues in software and take the possible corrective measures.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 测试软件项目可以采用不同的形式，通常由开发人员和测试分析员或专家进行。测试是为了确定软件是否符合其指定的期望，如果可能的话，识别错误，并验证软件是否可用。大多数程序员通常认为测试和调试是一样的。调试是为了诊断软件中的错误和问题，并采取可能的纠正措施。
- en: Unit tests
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: This is a level of testing that involves testing each unit that constitutes
    the components of a software application. This is the lowest level of test and
    it is done at the method or function level. It is primarily done by programmers,
    specifically to show code correctness and that the requirement has been correctly
    implemented. A unit test usually has one or more inputs and outputs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是测试的一个级别，涉及测试构成软件应用程序组件的每个单元。这是测试的最低级别，它在方法或函数级别进行。它主要由程序员完成，特别是为了显示代码的正确性和要求是否已经正确实现。单元测试通常具有一个或多个输入和输出。
- en: It is the first level of test usually done in software development and it is
    designed to isolate units of software systems and test them independently or in
    isolation. Through unit testing, inherent issues and bugs in systems can be easily
    detected earlier in the development process.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通常在软件开发中进行的第一级测试，旨在隔离软件系统的单元并独立或隔离地测试它们。通过单元测试，系统中固有的问题和错误可以在开发过程的早期轻松检测到。
- en: Integration tests
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: An integration test is done by combining and testing different units or components
    that must have been tested in isolation. This test is to ensure that the different
    units of an application can work together to satisfy the user requirements. Through
    integration tests, you can uncover bugs in the system when different components
    interact and exchange data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试是通过组合和测试不同的单元或组件来完成的，这些单元或组件必须在隔离状态下进行测试。这个测试是为了确保应用程序的不同单元可以共同工作以满足用户的需求。通过集成测试，您可以在不同组件交互和交换数据时发现系统中的错误。
- en: 'This test can be carried out by programmers, software testers, or quality assurance
    analysts. There are different approaches that can be used for integration testing:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这项测试可以由程序员、软件测试人员或质量保证分析员进行。可以使用不同的方法进行集成测试：
- en: '**Top down**: Top-level components are integrated and tested first before the
    lower level components'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自上而下**：在较低级别组件之前，先集成和测试顶层组件'
- en: '**Bottom up**: Lower-level components are integrated and tested before top
    level components'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自下而上**：在顶层组件之前，先集成和测试较低级别的组件'
- en: '**Big bang**: All components are integrated together and tested at once'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大爆炸**：所有组件一起集成并一次性测试'
- en: System testing
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统测试
- en: This level of test is where you validate the entire integrated system to ensure
    it complies with the specified user requirements. This test is usually performed
    immediately after the integration test and is carried out by dedicated testers
    or quality assurance analysts.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试级别是您验证整个集成系统以确保其符合指定的用户需求。这个测试通常在集成测试之后立即进行，由专门的测试人员或质量保证分析员进行。
- en: The whole software system suite is tested from the user's perspective to identify
    hidden issues or bugs and usability problems. A rigorous testing of the implemented
    system is done with the real inputs that the system is meant to process and output
    is validated against the expected data.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 整个软件系统套件是从用户的角度进行测试，以识别隐藏的问题或错误和可用性问题。对实施的系统进行了严格的测试，使用系统应处理的真实输入，并验证输出是否符合预期数据。
- en: User acceptance testing
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户验收测试
- en: User acceptance tests are usually written to specify how software applications
    work. These tests are intended for business users and programmers and are used
    to determine if the system meets the expectations and user-specific requirements,
    and whether the system has been developed completely and correctly based on the
    specifications. This test is conducted by end users in collaboration with the
    system developers to determine whether to accept the system formally or make adjustments
    or modifications.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 用户验收测试通常用于指定软件应用程序的工作方式。这些测试是为业务用户和程序员编写的，用于确定系统是否符合期望和用户特定要求，以及系统是否根据规格完全和正确地开发。这项测试由最终用户与系统开发人员合作进行，以确定是否正式接受系统或进行调整或修改。
- en: Principles of TDD
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD的原则
- en: 'The practice of TDD helps with the design of clean code and serves as a buffer
    against regression in a large code base. It allows developers to determine easily
    whether newly implemented features have broken other features that were previously
    working through the instant feedback obtainable when the tests are run. The working
    principles of TDD are explained in the following diagram:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的实践有助于设计清晰的代码，并作为大型代码库中回归的缓冲。它允许开发人员轻松确定新实施的功能是否通过运行测试时获得的即时反馈破坏了先前正常工作的其他功能。TDD的工作原理如下图所示：
- en: '![](img/8df88590-65cc-4355-8b98-a6d3a80abea2.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8df88590-65cc-4355-8b98-a6d3a80abea2.png)'
- en: Writing the tests
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试
- en: This is the initial step of the technique, where you have to write the tests
    that describe a component or feature to be developed. The component can be the
    user interface, business rule or logic, data persistence routine, or a method
    implementing a specific user requirement. The tests need to be brief and should
    contain the required data input and desired outcome expected by the component
    being tested.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是技术的初始步骤，您必须编写描述要开发的组件或功能的测试。组件可以是用户界面、业务规则或逻辑、数据持久性例程，或实现特定用户需求的方法。测试需要简洁，并应包含组件测试所需的数据输入和期望的预期结果。
- en: While writing the tests, technically you have solved half of the development
    task, because the design of the code is usually conceived through the thought
    pattern and process put into writing the tests. It becomes easier to tackle the
    difficult code after the easier code, which is the test that has been written.
    At this point, as a TDD newcomer, the tests are not expected to be 100% perfect
    or have full code coverage, but with continuous practice and adequate refactoring,
    this can be achieved.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时，从技术上讲，你已经解决了一半的开发任务，因为通过编写测试来构思代码的设计。在编写的测试之后，更容易处理困难的代码，这就是已经编写的测试。在这一点上，作为TDD新手，不要期望测试是100%完美或具有完整的代码覆盖率，但通过持续的练习和充分的重构，这是可以实现的。
- en: Writing the code
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写代码
- en: After the tests have been written, you should write enough code to implement
    the feature for the tests you wrote earlier. Bear in mind that the goal here is
    to try to employ good practices and standards in writing the code to make the
    test pass. All the approaches that lead to writing bad or stinking code should
    be avoided.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写完测试之后，你应该编写足够的代码来实现之前编写的测试所需的功能。请记住，这里的目标是尽量采用良好的实践和标准来编写代码，以使测试通过。应避免所有导致编写糟糕或糟糕代码的方法。
- en: Try to avoid test overfitting, a situation where you write code just to make
    the tests pass. Instead you should write the code to implement the feature or
    user requirements fully, so as to ensure that every possible use case of the feature
    is covered to avoid situations where the code has different behaviors when executed
    by the test cases and when in production.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量避免测试过度拟合，即为了使测试通过而编写代码的情况。相反，你应该编写代码来实现功能或用户需求，以确保覆盖功能的每种可能用例，避免代码在测试用例执行和生产环境中执行时具有不同的行为。
- en: Running the tests
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: When you are sure you have enough code to make the test pass, you should run
    the test, using the test suite of your choice. At this point, the test might pass
    or fail. This depends on how you have written the code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你确信已经有足够的代码使测试通过时，你应该运行测试，使用你选择的测试套件。此时，测试可能会通过或失败。这取决于你如何编写代码。
- en: A thumb rule of TDD is to run the tests several times until the tests pass.
    Initially, when you run the test before the code is fully implemented, the test
    will fail, which is the expected behavior.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的一个基本规则是多次运行测试，直到测试通过。最初，在代码完全实现之前运行测试时，测试将失败，这是预期的行为。
- en: Refactoring
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: To achieve full code coverage, both the tests and the source code have to be
    refactored and tested several times to ensure that a robust and clean code is
    written. Refactoring should be iterative until full coverage is achieved. The
    refactoring step should remove duplicates from code and attempt to fix any signs
    of code smell.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现完整的代码覆盖率，测试和源代码都必须进行重构和多次测试，以确保编写出健壮且干净的代码。重构应该是迭代的，直到实现完整的覆盖率。重构步骤应该删除代码中的重复部分，并尝试修复任何代码异味的迹象。
- en: The essence of TDD is to write clean code and in turn solid applications, depending
    on the type of tests being written (unit, acceptance, or integration tests). Refactoring
    can be localized to just a method or it can affect multiple classes. When refactoring,
    for example, an interface or multiple methods in a class, it is recommended you
    make the changes gradually, taking it one test at a time until all the tests and
    their implementation code are refactored.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的本质是编写干净的代码，从而构建可靠的应用程序，这取决于所编写的测试类型（单元测试、验收测试或集成测试）。重构可以局部地影响一个方法，也可以影响多个类。例如，在重构一个接口或一个类中的多个方法时，建议您逐渐进行更改，一次一个测试，直到所有测试及其实现代码都被重构。
- en: Doing TDD the wrong way
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以错误的方式进行TDD
- en: As interesting as practicing TDD can be, it can also be wrongly done. Programmers
    new to TDD can sometimes write monster tests that are way too large and defeat
    the purpose of test brevity and being able to perform the TDD cycle quickly, leading
    to a waste of productive development time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管练习TDD可能很有趣，但也可能被错误地执行。对于TDD新手来说，有时可能会编写过大的怪物测试，这远远超出了测试简洁性和能够快速执行TDD循环的目的，导致了生产开发时间的浪费。
- en: Partial adoption of the technique can also reduce the full benefit of TDD. In
    situations where only a few developers in a team use the technique and others
    don't, this will lead to fragmented code where a portion of code is tested and
    another portion is not, resulting in an unreliable application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 部分采用该技术也可能减少TDD的全部好处。在团队中只有少数开发人员使用该技术而其他人不使用的情况下，这将导致代码片段化，其中一部分代码经过测试，另一部分没有经过测试，从而导致应用程序不可靠。
- en: You should avoid writing tests for code that are naturally trivial or not required;
    for example, writing tests for object accessors. Tests should be run frequently,
    especially through the use of test runners, build tools, or continuous integration
    tools. Failing to run the tests often can lead to a situation where the true reflection
    of the state of the code base is not known even when changes have been made and
    components are probably failing.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 应避免为自然微不足道或不需要的代码编写测试；例如，为对象访问器编写测试。测试应该经常运行，特别是通过测试运行器、构建工具或持续集成工具。不经常运行测试可能导致情况，即即使已经进行了更改并且组件可能失败，代码基地的真实状态也不为人所知。
- en: The TDD cycle
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD循环
- en: The TDD technique follows a tenet known as the red-green-refactor cycle, with
    the red state being the initial state, indicating the commencement of a **TDD
    cycle**. At the red state, the test has just been written and will fail when it
    is run.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: TDD技术遵循一个被称为红-绿-重构循环的原则，红色状态是初始状态，表示TDD循环的开始。在红色状态下，测试刚刚被编写，并且在运行时将失败。
- en: 'The next state is the green state and it shows that the test has passed after
    the actual application code has been written. Code refactoring is essential to
    ensure code completeness and robustness. Refactoring will be repeatedly done until
    the code meets performance and requirement expectations:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个状态是绿色状态，它显示在实际应用代码编写后测试已通过。重构代码是确保代码完整性和健壮性的重要步骤。重构将反复进行，直到代码满足性能和需求期望为止。
- en: '![](img/ddddbd5c-0bb6-4cba-b577-c1f53eefe39b.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ddddbd5c-0bb6-4cba-b577-c1f53eefe39b.png)'
- en: 'At the beginning of the cycle, the production code to run the test against
    has not been written, so it is expected that the test will fail. For example,
    in the following code snippet, the `IsServerOnline` method has not been implemented
    yet, and when the `Test_IsServerOnline_ShouldReturnTrue` unit test method is run,
    it should fail:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在周期开始时，尚未编写用于运行测试的生产代码，因此预计测试将失败。例如，在以下代码片段中，`IsServerOnline`方法尚未实现，当运行`Test_IsServerOnline_ShouldReturnTrue`单元测试方法时，它应该失败。
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For the test to pass, you have to implement the production code iteratively.
    When the following `IsServerOnline` method is implemented, the `Test_IsServerOnline_ShouldReturnTrue`
    test method is expected to pass:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试通过，您必须迭代实现生产代码。当实现以下`IsServerOnline`方法时，预期`Test_IsServerOnline_ShouldReturnTrue`测试方法将通过。
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When the test is run and it passes, showing a green color depending on the test
    runner you are using, this provides an immediate feedback to you on the status
    of the code. This gives you confidence and inner joy that the code works correctly
    and behaves as it is intended to.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试运行并通过时，根据您使用的测试运行器显示绿色，这会立即向您提供有关代码状态的反馈。这让您对代码的正确运行和预期行为感到自信和内心的喜悦。
- en: Refactoring is an iterative endeavor, where you continuously modify the code
    you have earlier written to pass the test until it has attained the state of production-ready
    code and that it fully implements the requirements and will work for all possible
    use cases and scenarios.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 重构是一个迭代的努力，您将不断修改先前编写的代码以通过测试，直到它达到了生产就绪状态，并且完全实现了需求，并且适用于所有可能的用例和场景。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Most potential software project maintenance bottlenecks can be avoided through
    the use of the principles and coding patterns discussed in this chapter. Attaining
    professionalism requires consistency to be disciplined and holds true to good
    coding habits, practices, and having a professional attitude towards TDD.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章讨论的原则和编码模式，可以避免大多数潜在的软件项目维护瓶颈。成为专业人士需要保持一致性，要有纪律性，并坚持良好的编码习惯、实践，并对TDD持有专业态度。
- en: Writing clean code that is easy to maintain pays off in the long term as less
    effort will be required to make user-requested changes and users will be kept
    happy when the application is always available for use with few or no bugs.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 编写易于维护的清晰代码将在长期内得到回报，因为将需要更少的工作量来进行用户请求的更改，并且当应用程序始终可供使用且几乎没有错误时，用户将感到满意。
- en: In the next chapter, we will explore the .NET Core framework, and its capabilities
    and limitations. Also, we will take a tour of Microsoft Visual Studio Code before
    reviewing the new features available in Version 7 of the C# programming language.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索.NET Core框架及其能力和局限性。此外，我们将在审查C#编程语言的第7版中介绍的新功能之前，先了解Microsoft Visual
    Studio Code。
