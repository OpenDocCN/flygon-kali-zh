- en: Additional Configuration and Discovery Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的配置和发现功能
- en: 'We talked a great deal about service discovery and distributed configuration
    in [Chapter 4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml), *Service Discovery*,
    and [Chapter 5](37142825-02d0-48a0-99df-1a1a88a1bbd4.xhtml), *Distributed Configuration
    with Spring Cloud Config*. We discussed two solutions in detail. The first of
    them, Eureka, is provided by Netflix OSS and has been adopted by Spring Cloud
    for service discovery. The second was the Spring Cloud Config project dedicated
    only to a distributed configuration. However, there are some interesting solutions
    on the market effectively combining both of these features. Currently, Spring
    Cloud supports two of them:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在《服务发现》第4章和《Spring Cloud Config分布式配置》第5章中详细讨论了服务发现和分布式配置。我们详细讨论了两种解决方案。其中第一种是由Netflix
    OSS提供的Eureka，已被Spring Cloud用于服务发现。第二种是专门用于分布式配置的Spring Cloud Config项目。然而，市场上有一些有趣的解决方案有效地结合了这两个功能。目前，Spring
    Cloud支持其中的两种：
- en: '**Consul**: This product is built by HashiCorp. It is a highly available, distributed
    solution designed to connect and configure applications across dynamic, distributed
    infrastructure. Consul is a rather complex product, and has multiple components,
    but its main functionality is discovering and configuring services across any
    infrastructure.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Consul**：这个产品是由HashiCorp构建的。它是一个高可用性的、分布式的解决方案，旨在连接和配置动态的、分布式的基础设施上的应用程序。Consul是一个相当复杂的产品，有多个组件，但其主要功能是在任何基础设施上发现和配置服务。'
- en: '**Zookeeper**: This product is built by Apache Software Foundation. It is a
    distributed, hierarchical key/value storage written in Java. It is designed to
    maintain configuration information, naming, and distributed synchronization. In
    contrast to Consul, it is more of a primitive key/value storage than a modern
    service discovery tool. However, Zookeeper is still very popular, especially for
    solutions based on the Apache Software stack.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zookeeper**：这个产品是由Apache Software Foundation构建的。它是一个分布式的、分层的、用Java编写的键/值存储。它旨在维护配置信息、命名和分布式同步。与Consul相比，它更像是一个原始的键/值存储，而不是一个现代的服务发现工具。然而，Zookeeper仍然非常受欢迎，特别是对于基于Apache
    Software堆栈的解决方案。'
- en: 'Support for two other popular products from that area is still in the development
    stage. The following projects have still not been added to the official Spring
    Cloud Release Train:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于该领域的另外两种热门产品的支持仍处于开发阶段。以下项目尚未添加到官方Spring Cloud Release Train中：
- en: '**Kubernetes**: This is an open-source solution designed for automating deployment,
    scaling, and management of containerized applications, originally created by Google.
    This tool is enjoying great popularity right now. Recently, the Docker platform
    has started supporting Kubernetes.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes**：这是一个用于自动化部署、扩展和管理容器化应用程序的开源解决方案，最初由Google创建。这个工具目前非常受欢迎。最近，Docker平台已开始支持Kubernetes。'
- en: '**Etcd**: This is a distributed reliable key/value storage for the most critical
    data of a distributed system written in Go. It is used in production by many companies
    and other software products, for example, Kubernetes.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Etcd**：这是一个用Go语言编写的分布式可靠的关键/值存储，用于分布式系统的最关键数据。它被许多公司和其他软件产品用于生产，例如Kubernetes。'
- en: In this chapter, I'm going to introduce only officially supported solutions,
    namely Consul and Zookeeper. Kubernetes, which is much more than only a key/value
    storage or a service registry, will be discussed in [Chapter 14](0756243e-39c9-4696-8d79-4175e7cf4c48.xhtml),
    *Docker Support*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将只介绍官方支持的解决方案，即Consul和Zookeeper。Kubernetes不仅仅是一个键/值存储或服务注册表，我们将在《Docker支持》第14章中讨论它。
- en: Using Spring Cloud Consul
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Consul
- en: The Spring Cloud Consul project provides integration for Consul and Spring Boot
    applications through auto-configuration. By using the well-known Spring Framework
    annotation style, we may enable and configure common patterns within microservice-based
    environments. These patterns include service discovery using Consul agent, distributed
    configuration using Consul key/value store, distributed events with Spring Cloud
    Bus, and Consul Events. The project also supports a client-side load balancer
    based on Netflix's Ribbon and an API gateway based on Netflix's Zuul. Before we
    start to discuss these features, we first have to run and configure Consul agent.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Consul项目通过自动配置为Consul和Spring Boot应用程序提供集成。通过使用众所周知的Spring Framework注解风格，我们可以在基于微服务的环境中启用和配置常见模式。这些模式包括使用Consul代理进行服务发现、使用Consul键/值存储进行分布式配置、使用Spring
    Cloud Bus和Consul事件进行分布式事件。该项目还支持基于Netflix的Ribbon的客户端负载均衡器和基于Netflix的Zuul的API网关。在我们开始讨论这些功能之前，我们首先必须运行和配置Consul代理。
- en: Running Consul agent
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Consul代理
- en: 'We will begin with the simplest way of starting Consul agent on our local machines.
    The standalone development mode may be easily set up with the Docker container.
    Here''s the command, which will start the Consul container from the official Hashicorp''s
    image available on Docker Hub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在本地机器上启动Consul代理的最简单方法开始。独立开发模式可以很容易地通过Docker容器进行设置。以下是启动Consul容器的命令，该容器来自Docker
    Hub上的Hashicorp官方镜像：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After launching, Consul is available under the address `http://192.168.99.100:8500`.
    It exposes RESTful HTTP API, that is, the main interface. All the API routes are
    prefixed with `/v1/`. Of course, it is not required to use the API directly. There
    are some programming libraries that can be used to consume the API more conveniently.
    One of them is `consul-api`, the client written in Java and also used by Spring
    Cloud Consul internally. There is also the web UI dashboard provided by Consul
    available under the same address as the HTTP API, but on a different context path,
    `/ui/`. It allows for viewing all registered services and nodes, viewing all health
    checks and their current status, and reading and setting key/value data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 启动后，Consul在地址`http://192.168.99.100:8500`下可用。它公开RESTful HTTP API，即主要接口。所有API路由都以`/v1/`为前缀。当然，不需要直接使用API。有一些编程库可以更方便地用于消费API。其中之一是`consul-api`，这是一个用Java编写的客户端，也被Spring
    Cloud Consul内部使用。还有Consul提供的Web UI仪表板，可在与HTTP API相同的地址下使用，但在不同的上下文路径`/ui/`下。它允许查看所有已注册的服务和节点，查看所有健康检查及其当前状态，以及读取和设置键/值数据。
- en: 'As I mentioned in the preface to this section, we are going to use three different
    features of Consul—agent, events, and KV store. Each of them is represented by
    the group of endpoints, respectively `/agent`, `/event`, and `/kv`. The most interesting
    agent endpoints are those related with service registration. Here''s a list of
    these endpoints:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本节的前言中提到的，我们将使用Consul的三个不同特性——代理、事件和KV存储。它们分别由端点组表示，即`/agent`、`/event`和`/kv`。最有趣的代理端点是与服务注册相关的端点。以下是这些端点的列表：
- en: '| **Method** | **Path** | **Description** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **路径** | **描述** |'
- en: '| `GET` | `/agent/services` | It returns a list of the services registered
    with the local agent. If Consul is run in a clustered mode, that list may be different
    than the list reported by the `/catalog` endpoint before synchronization performed
    between cluster members. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/agent/services` | 返回与本地代理注册的服务列表。如果Consul在集群模式下运行，则该列表可能与同步之前在集群成员之间执行的`/catalog`端点报告的列表不同。|'
- en: '| `PUT` | `/agent/service/register` | It adds a new service to the local agent.
    The agent is responsible for managing local services, and for sending updates
    to the servers to perform synchronization for the global catalog. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `/agent/service/register` | 向本地代理添加新服务。代理负责管理本地服务，并向服务器发送更新以执行全局目录的同步。|'
- en: '| `PUT` | `/agent/service/deregister/:service_id` | It removes a service with
    `service_id` from the local agent. The agent takes care of de-registering the
    service with the global catalog. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `/agent/service/deregister/:service_id` | 从本地代理中删除具有`service_id`的服务。代理负责取消向全局目录注册服务。|'
- en: 'The `/kv` endpoints are dedicated to managing simple key/value store, which
    is especially useful for storing service configuration or other metadata. It is
    worth noting that each data center has its own KV store, so in order to share
    it across multiple nodes, we should have configured the Consul replicate daemon.
    Anyway, here''s a list of the three endpoints for managing the key/value store:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`/kv`端点专用于管理简单的键/值存储，特别适用于存储服务配置或其他元数据。值得注意的是，每个数据中心都有自己的KV存储，因此为了在多个节点之间共享它，我们应该配置Consul复制守护程序。无论如何，以下是用于管理键/值存储的三个端点的列表：'
- en: '| **Method** | **Path** | **Description** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **路径** | **描述** |'
- en: '| `GET` | `/kv/:key` | It returns the value for the given key name. If the
    requested key does not exist, HTTP status 404 is returned as a response. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/kv/:key` | 返回给定键名的值。如果请求的键不存在，则返回HTTP状态404作为响应。|'
- en: '| `PUT` | `/kv/:key` | It is used for adding a new key to the store, or just
    to update the existing one with a key name. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `/kv/:key` | 用于向存储添加新键，或者只是使用键名更新现有键。|'
- en: '| `DELETE` | `/kv/:key` | It is the last CRUD method that is used for deleting
    a single key, or all keys, with the same prefix. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `/kv/:key` | 这是用于删除单个键或具有相同前缀的所有键的最后一个CRUD方法。|'
- en: Spring Cloud uses Consul Events for providing a dynamic configuration reload.
    There are two simple API methods. The first of them, `PUT /event/fire/:name`,
    triggers a new event. The second, `GET /event/list`, returns a list of events,
    which might be filtered by name, tag, node, or service name.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud使用Consul事件来提供动态配置重新加载。有两种简单的API方法。其中之一，`PUT /event/fire/:name`，触发一个新事件。另一个，`GET
    /event/list`，返回一个事件列表，可以按名称、标签、节点或服务名称进行过滤。
- en: Integration on the client side
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端集成
- en: 'To activate Consul service discovery in your project, you should include the
    starter `spring-cloud-starter-consul-discovery` to the dependencies. If you would
    like to enable distributed configuration with Consul, just include `spring-cloud-starter-consul-config`.
    In some cases, you would probably use both these features in your client-side
    application. Then, you should declare a dependency to the `spring-cloud-starter-consul-all`
    artifact:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中激活Consul服务发现，您应该将starter `spring-cloud-starter-consul-discovery`包含在依赖项中。如果您想要使用Consul进行分布式配置，只需包含`spring-cloud-starter-consul-config`。在某些情况下，您可能会在客户端应用程序中同时使用这两个特性。然后，您应该声明对`spring-cloud-starter-consul-all`构件的依赖：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By default, the Consul agent is expected to be available under the address
    `localhost:8500`. If it is different for your application, you should provide
    the appropriate address in the `application.yml` or `bootstrap.yml` file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Consul代理应该在地址`localhost:8500`下可用。如果对于您的应用程序有所不同，您应该在`application.yml`或`bootstrap.yml`文件中提供适当的地址：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Service discovery
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现
- en: 'Discovery with Consul is enabled for the application by annotating the main
    class with the generic Spring Cloud `@EnableDiscoveryClient`. You should remember
    that from [Chapter 4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml), *Service Discovery*,
    because there is no difference in comparison with Eureka. The default service
    name is also taken from the `${spring.application.name}` property. Sample microservices
    that use Consul as a discovery server are available on GitHub in the [https://github.com/piomin/sample-spring-cloud-consul.git](https://github.com/piomin/sample-spring-cloud-consul.git)
    repository. The architecture of the system is the same as for examples in some
    previous chapters. There are four microservices, `order-service`, `product-service`,
    `customer-service`, and `account-service`, and the API gateway is implemented
    in the module `gateway-service`. For inter-service communication, we use the Feign
    client together with the Ribbon load balancer:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Consul进行发现的应用程序通过在主类上注释通用的Spring Cloud `@EnableDiscoveryClient`来启用。你应该记得从[第4章](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml)，*服务发现*，因为与Eureka相比没有区别。默认服务名称也是从`${spring.application.name}`属性中获取的。使用Consul作为发现服务器的示例微服务可在GitHub的[https://github.com/piomin/sample-spring-cloud-consul.git](https://github.com/piomin/sample-spring-cloud-consul.git)存储库中找到。系统的架构与之前章节中的示例相同。有四个微服务，`order-service`，`product-service`，`customer-service`和`account-service`，API网关实现在`gateway-service`模块中。对于服务间通信，我们使用Feign客户端和Ribbon负载均衡器：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'By default, the Spring Boot application is registered in Consul with the instance
    ID generated as a concatenation of values taken from the properties `spring.application.name`,
    `spring.profiles.active`, `server.port`. In most cases, it is enough to be sure
    that the ID is unique, but if the custom pattern is required, it may be easily
    set with the `spring.cloud.consul.discovery.instanceId` property:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Boot应用程序在Consul中注册的实例ID是从`spring.application.name`，`spring.profiles.active`，`server.port`属性中获取的值进行连接而成。在大多数情况下，确保ID是唯一的就足够了，但如果需要自定义模式，可以使用`spring.cloud.consul.discovery.instanceId`属性轻松设置。
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After launching all the sample microservices, take a look at the Consul UI
    dashboard. You should see there are four different services registered, like in
    the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 启动所有示例微服务后，查看Consul UI仪表板。您应该看到有四个不同的服务注册，就像下面的截图一样：
- en: '![](img/8fa25939-b447-4d22-af84-19dab28e9745.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fa25939-b447-4d22-af84-19dab28e9745.png)'
- en: 'Alternatively, you may check out a list of registered services using the RESTful
    HTTP API endpoint `GET /v1/agent/services`. Here''s the fragment of the JSON response:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用RESTful HTTP API端点`GET /v1/agent/services`来查看已注册服务的列表。以下是JSON响应的片段：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, you may easily test the whole system by sending some test requests to `order-service`
    using the `pl.piomin.services.order.OrderControllerTest` JUnit test class. Everything
    should work fine, and the same as for discovery with Eureka.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过使用`pl.piomin.services.order.OrderControllerTest` JUnit测试类向`order-service`发送一些测试请求来轻松测试整个系统。一切应该正常工作，就像使用Eureka进行发现一样。
- en: Health check
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康检查
- en: 'Consul checks out the health status of every registered instance by calling
    the `/health` endpoint. If you do not wish to provide the Spring Boot Actuator
    library in the classpath, or there are some problems with your service, it will
    be visible on the web dashboard:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Consul通过调用`/health`端点来检查每个注册实例的健康状态。如果您不希望在类路径中提供Spring Boot Actuator库，或者服务出现问题，它将在Web仪表板上可见：
- en: '![](img/208a2cee-71ec-4469-b222-39572887b4ea.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/208a2cee-71ec-4469-b222-39572887b4ea.png)'
- en: If the health check endpoint is available under a different context path for
    any reason, you may override that path with the `spring.cloud.consul.discovery.healthCheckPath`
    property. There is also the possibility to change the status refresh interval
    by defining `healthCheckInterval` with a pattern, such as, for example, `10s`
    for seconds or `2m` for minutes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因健康检查端点在不同的上下文路径下可用，您可以使用`spring.cloud.consul.discovery.healthCheckPath`属性来覆盖该路径。还有可能通过定义`healthCheckInterval`来更改状态刷新间隔，例如，`10s`表示秒或`2m`表示分钟。
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Zones
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区域
- en: I assume you remember our discussion about zoning mechanisms available for discovery
    with Eureka in [Chapter 4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml), *Service
    Discovery*. It is useful when the hosts are placed in a different location, and
    you would prefer communication between instances registered in the same zone.
    The official documentation of the Spring Cloud Consul ([http://cloud.spring.io/spring-cloud-static/spring-cloud-consul/1.2.3.RELEASE/single/spring-cloud-consul.html](http://cloud.spring.io/spring-cloud-static/spring-cloud-consul/1.2.3.RELEASE/single/spring-cloud-consul.html))
    says nothing about such a solution, which fortunately doesn't mean it is not implemented.
    Spring Cloud provides a zoning mechanism based on Consul tags. The default zone
    for the application may be configured with the `spring.cloud.consul.discovery.instanceZone`
    property. It sets the tag configured in the `spring.cloud.consul.discovery.defaultZoneMetadataName`
    property with the passed value. The default metadata tag name is `zone`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设您还记得我们在[第4章](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml)中讨论过关于Eureka发现可用的分区机制。当主机位于不同位置时，以及您希望在同一区域注册的实例之间进行通信时，这是很有用的。Spring
    Cloud Consul的官方文档([http://cloud.spring.io/spring-cloud-static/spring-cloud-consul/1.2.3.RELEASE/single/spring-cloud-consul.html](http://cloud.spring.io/spring-cloud-static/spring-cloud-consul/1.2.3.RELEASE/single/spring-cloud-consul.html))没有提到这样的解决方案，但这并不意味着它没有实现。Spring
    Cloud提供了基于Consul标签的分区机制。应用程序的默认区域可以通过`spring.cloud.consul.discovery.instanceZone`属性进行配置。它使用`spring.cloud.consul.discovery.defaultZoneMetadataName`属性中配置的标签与传递的值进行设置。默认的元数据标签名称是`zone`。
- en: 'Let''s go back to the sample applications. I have extended all the configuration
    files with two profiles, `zone1` and `zone2`. Here''s the `bootstrap.yml` file
    for `order-service`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到示例应用程序。我已经为所有配置文件添加了两个配置文件，`zone1`和`zone2`。以下是`order-service`的`bootstrap.yml`文件：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are two running instances of every microservice registered in two different
    zones. After building the whole project with the `mvn clean install` command,
    you should launch the Spring Boot application with the active profile `zone1`
    or `zone2`, for example, `java -jar --spring.profiles.active=zone1 target/order-service-1.0-SNAPSHOT.jar`.
    You can see the full list of registered instances tagged with the zone in the
    Nodes section. The view from the Consul dashboard is visible in the following
    screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务在两个不同区域中注册了两个运行实例。使用`mvn clean install`命令构建整个项目后，您应该使用活动配置文件`zone1`或`zone2`启动Spring
    Boot应用程序，例如`java -jar --spring.profiles.active=zone1 target/order-service-1.0-SNAPSHOT.jar`。您可以在节点部分看到带有区域标签的注册实例的完整列表。Consul仪表板的视图在以下截图中可见：
- en: '![](img/a1a34b42-27d3-46d1-814b-fc20ffd77a3e.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1a34b42-27d3-46d1-814b-fc20ffd77a3e.png)'
- en: The last element of our architecture is an API gateway based on Zuul. We also
    run two instances of `gateway-service` in different zones. We would like to omit
    registration in Consul and allow only a configuration to be fetched, which is
    used by the Ribbon client while performing load balancing. Here's the fragment
    of the `bootstrap.yml` file of `gateway-service`. Registration has been disabled
    by setting the properties `spring.cloud.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们架构的最后一个元素是基于Zuul的API网关。我们还在不同区域运行两个`gateway-service`实例。我们希望在Consul中省略注册，只允许获取配置，该配置由Ribbon客户端在执行负载平衡时使用。这是`gateway-service`的`bootstrap.yml`文件的片段。通过设置属性`spring.cloud`来禁用注册。
- en: consul.discovery.register` and `spring.cloud.consul.discovery.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: consul.discovery.register`和`spring.cloud.consul.discovery.
- en: 'registerHealthCheck` to `false`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: registerHealthCheck`为`false`：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Client settings customization
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端设置自定义
- en: 'The Spring Cloud Consul client may be customized through the properties in
    the configuration file. Some of those settings have already been introduced in
    the previous sections in this chapter. Other useful settings have been listed
    in the following table. All of them are prefixed with `spring.cloud.consul.discovery`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Consul客户端可以通过配置文件中的属性进行自定义。本章的前几节已经介绍了其中一些设置。其他有用的设置已列在以下表中。它们都以`spring.cloud.consul.discovery`为前缀：
- en: '| **Property** | **Default value** | **Description** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **默认值** | **描述** |'
- en: '| `enabled` | `true` | It sets whether Consul discovery is enabled or disabled
    for an application |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `enabled` | `true` | 设置应用程序是否启用或禁用Consul发现 |'
- en: '| `failFast` | `true` | It throws exceptions during service registration if
    `true`; otherwise, it logs warnings |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `failFast` | `true` | 如果为`true`，则在服务注册期间抛出异常；否则，记录警告 |'
- en: '| `hostname` | - | It sets the hostname of the instance when registering in
    Consul |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `hostname` | - | 在注册Consul时设置实例的主机名 |'
- en: '| `preferIpAddress` | `false` | It forces an application to send its IP address
    instead of the hostname during registration |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `preferIpAddress` | `false` | 强制应用程序在注册期间发送其IP地址而不是主机名 |'
- en: '| `scheme` | `http` | It sets whether the service is available under HTTP or
    HTTPS protocol |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `scheme` | `http` | 设置服务是在HTTP还是HTTPS协议下可用 |'
- en: '| `serverListQueryTags` | - | It allows filtering services by a single tag
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `serverListQueryTags` | - | 允许通过单个标签过滤服务 |'
- en: '| `serviceName` | - | It overrides the service name, which by default takes
    from the property `spring.application.name` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `serviceName` | - | 覆盖默认从属性`spring.application.name`中获取的服务名称 |'
- en: '| `tags` | - | It sets the list tags with values to use when registering the
    service |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `tags` | - | 设置在注册服务时使用的标签列表 |'
- en: Running in clustered mode
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在集群模式下运行
- en: Until now, we were always launching a single, standalone instance of Consul.
    As far as this is a suitable solution in development mode, it is not enough for
    a production. There, we would like to have a scalable, production-grade service
    discovery infrastructure, consisting of some nodes working together inside the
    cluster. Consul provides support for clustering based on a gossip protocol used
    for communication between members and a Raft consensus protocol for a leadership
    election. I wouldn't like to go into the details of that process, but some basics
    about Consul architecture should be clarified.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在启动单个独立的Consul实例。在开发模式下，这是一个合适的解决方案，但对于生产来说还不够。在那里，我们希望拥有一个可扩展的、生产级别的服务发现基础设施，由集群内的一些节点共同工作组成。Consul提供了基于用于成员之间通信的gossip协议和用于领导选举的Raft一致性协议的集群支持。我不想深入讨论该过程的细节，但应该澄清一些关于Consul架构的基础知识。
- en: We have already talked about Consul agent, but what it is exactly and what is
    its role weren't explained. An agent is the long-running daemon on every member
    of the Consul cluster. It may be run in either client or server mode. All agents
    are responsible for running checks and keeping services registered, in different
    nodes and in sync, globally.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经谈到了Consul代理，但它究竟是什么以及它的作用并未解释。代理是Consul集群中每个成员上长时间运行的守护程序。它可以在客户端模式或服务器模式下运行。所有代理都负责运行检查并保持服务在不同节点和全局中同步注册。
- en: 'Our main goal in this section is to set up and configure the Consul cluster
    using its Docker image. First, we will start the container, which acts as a leader
    of the cluster. There is only one difference in the currently used Docker command
    than for the standalone Consul server. We have set the environment variable `CONSUL_BIND_INTERFACE=eth0`
    in order to change the network address of the cluster agent from `127.0.0.1` to
    the one available for other member containers. My Consul server is now running
    at the internal address `172.17.0.2`. To check out what your address is (it should
    be the same) you may run the command `docker logs consul`. The appropriate information
    is logged just after container startup:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的主要目标是使用其Docker镜像设置和配置Consul集群。首先，我们将启动容器，该容器充当集群的领导者。当前使用的Docker命令与独立的Consul服务器的命令只有一个区别。我们设置了环境变量`CONSUL_BIND_INTERFACE=eth0`，以便将集群代理的网络地址从`127.0.0.1`更改为其他成员容器可用的地址。我的Consul服务器现在正在内部地址`172.17.0.2`上运行。要检查您的地址是什么（应该是相同的），您可以运行命令`docker
    logs consul`。适当的信息将在容器启动后记录：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Knowledge of that address is very important, since now we have to pass it to
    every member container startup command as a cluster join parameter. We also bind
    it to all interfaces by setting `0.0.0.0` as a client address. Now, we may easily
    expose the client agent API outside the container using the `-p` parameter:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 了解该地址非常重要，因为现在我们必须将其作为集群加入参数传递给每个成员容器启动命令。我们还通过将`0.0.0.0`设置为客户端地址将其绑定到所有接口。现在，我们可以使用`-p`参数轻松地在容器外部公开客户端代理API：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After running two containers with Consul agent, you may check out the full
    list of cluster members by executing the following command on the leader''s container:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 运行两个带有Consul代理的容器后，您可以通过在领导者容器上执行以下命令来检查集群成员的完整列表：
- en: '![](img/62ad9459-eb41-4770-8035-f2a23dee1e42.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62ad9459-eb41-4770-8035-f2a23dee1e42.png)'
- en: 'The Consul server agent is exposed on the `8500` port, while member agents
    on ports `8501` and `8502`. Even if the microservice instance registers itself
    to a member agent, it is visible to all members of a cluster:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Consul服务器代理在`8500`端口上公开，而成员代理在`8501`和`8502`端口上。即使微服务实例向成员代理注册自己，它也对集群的所有成员可见：
- en: '![](img/0003cbac-7ff3-4286-ac65-3c13cf98a2ad.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0003cbac-7ff3-4286-ac65-3c13cf98a2ad.png)'
- en: 'We may easily change the default Consul agent address for the Spring Boot application
    by changing the configuration properties:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更改配置属性轻松更改Spring Boot应用程序的默认Consul代理地址：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Distributed configuration
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式配置
- en: 'An application with Spring Cloud Consul Config library in the classpath fetches
    configuration from the Consul key/value store during the bootstrap phase. That
    is, by default, stored in the `/config` folder. When we are creating a new key
    first, we have to set a folder path. That path is then used for identifying the
    key and assigning it to the application. Spring Cloud Config tries to resolve
    properties stored in the folder based on the application name and active profiles.
    Assuming we have the `spring.application.name` property set to `order-service`
    in the `bootstrap.yml` file and the `spring.profiles.active` running argument
    set to `zone1`, it tries to locate the property sources in the following order:
    `config/order-service,zone1/`, `config/order-service/`, `config/application,zone1/`,
    `config/application/`. All folders with the prefix `config/application` are the
    default configuration dedicated to all the applications that do not have service-specific
    property sources.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 具有Spring Cloud Consul Config库的应用程序在类路径中在引导阶段从Consul键/值存储中获取配置。默认情况下，这些配置存储在`/config`文件夹中。当我们首次创建一个新键时，我们必须设置一个文件夹路径。然后该路径用于标识键并将其分配给应用程序。Spring
    Cloud Config尝试根据应用程序名称和活动配置文件解析存储在文件夹中的属性。假设我们在`bootstrap.yml`文件中将`spring.application.name`属性设置为`order-service`，并且将`spring.profiles.active`运行参数设置为`zone1`，它将尝试按以下顺序定位属性源：`config/order-service,zone1/`，`config/order-service/`，`config/application,zone1/`，`config/application/`。所有以`config/application`为前缀的文件夹都是专门为没有特定服务属性源的所有应用程序而设的默认配置。
- en: Managing properties in Consul
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Consul中管理属性
- en: 'The most comfortable way to add a single key to Consul is through its web dashboard.
    The other way is by using the `/kv` HTTP endpoint, which has been already described
    at the beginning of this chapter. When using a web console, you have to go to
    the section KEY/VALUE. Then, you may view all the currently existing keys and
    also create a new one by providing its full path and value, in any format. That
    feature is visualized in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将单个键添加到Consul的最舒适的方式是通过其Web仪表板。另一种方式是使用`/kv` HTTP端点，这在本章的开头已经描述过。在使用Web控制台时，您必须转到KEY/VALUE部分。然后，您可以查看所有当前存在的键，并通过提供其完整路径和值（以任何格式）来创建一个新键。该功能在以下截图中可视化：
- en: '![](img/f0b420c2-a7db-4403-9a36-107311c5d2ac.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0b420c2-a7db-4403-9a36-107311c5d2ac.png)'
- en: 'Every single key may be updated or deleted:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单独的键都可以更新或删除：
- en: '![](img/85ffa69a-6da9-49aa-b8fc-ef419d3a28ce.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85ffa69a-6da9-49aa-b8fc-ef419d3a28ce.png)'
- en: To access a sample application that uses a property source stored in Consul,
    you should switch to the branch configuration in the same repository as the previous
    sample. I have created keys, `server.port` and `spring.cloud.consul.discovery.instanceZone`,
    for every microservice instead of defining it in the `application.yml` or `bootstrap.yml`
    files.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问一个使用存储在Consul中的属性源的示例应用程序，您应该切换到与之前示例相同的存储库中的配置分支。我已经为每个微服务创建了`server.port`和`spring.cloud.consul.discovery.instanceZone`键，而不是在`application.yml`或`bootstrap.yml`文件中定义它。
- en: Client customization
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端自定义
- en: 'The Consul Config client may be customized with the following properties, which
    are prefixed with `spring.cloud.consul.config`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Consul Config客户端可以使用以下属性进行自定义，这些属性以`spring.cloud.consul.config`为前缀：
- en: '`enabled`: By setting this property to `false`, you may disable Consul Config.
    It is useful if you include `spring-cloud-starter-consul-all`, which enables both
    discovery and distributed configuration.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enabled`：通过将此属性设置为`false`，可以禁用Consul Config。如果您包括`spring-cloud-starter-consul-all`，它将非常有用，因为它同时启用了发现和分布式配置。'
- en: '`fail-fast`: This sets whether to throw exceptions during configuration lookup
    or log warnings in case of connection failure. Setting it to `true` allows the
    application to continue startup normally.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fail-fast`：设置是否在配置查找期间抛出异常或在连接失败时记录警告。将其设置为`true`允许应用程序正常启动。'
- en: '`prefix`: This sets the base folder for all the configuration values. By default,
    it is `/config`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prefix`：设置所有配置值的基本文件夹。默认情况下为`/config`。'
- en: '`defaultContext`: This sets the folder name used by all applications that do
    not have a specific configuration. By default, it is `/application`. For example,
    if you override it to `app`, the properties should be searched in the folder `/config/apps`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultContext`：设置所有没有特定配置的应用程序使用的文件夹名称。默认情况下为`/application`。例如，如果您将其覆盖为`app`，则应在文件夹`/config/apps`中搜索属性。'
- en: '`profileSeparator`: By default, a profile is separated with an application
    name using a comma. That property allows you to override the value of that separator.
    For example, if you set it to `::`, you should create the folder `/config/order-service::zone1/`.
    Here''s an example:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`profileSeparator`：默认情况下，使用逗号将配置文件与应用程序名称分隔开。该属性允许您覆盖该分隔符的值。例如，如果将其设置为`::`，您应该创建文件夹`/config/order-service::zone1/`。以下是一个示例：'
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Sometimes, you would like to store a blob of properties created in a YAML or
    Properties format, in contrast to individual key/value pairs. In that case, you
    should set the `spring.cloud.consul.config.format` property to `YAML` or `PROPERTIES`.
    Then, the application would look for configuration properties located inside a
    folder with the data key, for example, `config/order-service,zone1/data`, `config/order-service/data`,
    `config/application,zone1/data`, or `config/application/data`. The default data
    key may be changed using the `spring.cloud.consul.config.data-key` property.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望以YAML或Properties格式存储一组属性的blob，而不是单个键/值对。在这种情况下，您应该将`spring.cloud.consul.config.format`属性设置为`YAML`或`PROPERTIES`。然后，应用程序将查找位于带有数据键的文件夹内的配置属性，例如`config/order-service,zone1/data`，`config/order-service/data`，`config/application,zone1/data`或`config/application/data`。默认数据键可以使用`spring.cloud.consul.config.data-key`属性进行更改。
- en: Watching configuration changes
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察配置更改
- en: 'The sample that has been discussed in the previous section loads the configuration on
    startup of the application. If you would like that configuration to be reloaded,
    you should send an HTTP `POST` to the `/refresh` endpoint. In order to examine
    how such a refresh would work for our application, we modify the fragment of application
    code responsible for creating some test data. Until now, it has been provided
    as a repository, `@Bean`, with some hardcoded in-memory objects. Take a look at
    the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中讨论的示例中，配置在应用程序启动时加载。如果您希望重新加载该配置，您应该向`/refresh`端点发送HTTP `POST`。为了检查这样的刷新对我们的应用程序将如何工作，我们修改了负责创建一些测试数据的应用程序代码片段。到目前为止，它已经作为一个存储库，`@Bean`，带有一些硬编码的内存对象提供。看一下以下代码：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our goal is to move the code visible here to the configuration store using
    the Consul key/value feature. To achieve this, we have to create three keys per
    object, with names `id`, `name`, and `type`. The configuration is loaded from
    the properties with the `repository` prefix:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是将此处可见的代码移动到使用Consul键/值功能的配置存储中。为了实现这一点，我们必须为每个对象创建三个键，名称分别为`id`、`name`和`type`。配置是从具有`repository`前缀的属性中加载的：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next step is to define the appropriate keys for each service using the
    Consul web dashboard. Here''s the sample configuration for the list consisting
    of `Customer` objects. The list is initialized on application startup:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用Consul Web仪表板为每个服务定义适当的键。以下是由`Customer`对象组成的列表的示例配置。该列表在应用程序启动时初始化：
- en: '![](img/bffd5327-fdb1-4ea1-9e4f-8dd99169c30a.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bffd5327-fdb1-4ea1-9e4f-8dd99169c30a.png)'
- en: 'You may change the value of each property. The update event would be automatically
    sent to application thanks to Consul''s ability to watch a key prefix. If there
    is a new configuration data, the refresh event is published to the queue. All
    queues and exchanges are created on application startup by Spring Cloud Bus, which
    is included in the project as a dependency of `spring-cloud-starter-consul-all`.
    If your application receives such an event, it prints the following information
    in logs:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以更改每个属性的值。更新事件将自动发送到应用程序，这要归功于Consul监视键前缀的能力。如果有新的配置数据，刷新事件将发布到队列中。所有队列和交换都是在应用程序启动时由Spring
    Cloud Bus创建的，它作为`spring-cloud-starter-consul-all`的依赖项包含在项目中。如果您的应用程序接收到这样的事件，它将在日志中打印以下信息：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using Spring Cloud Zookeeper
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Zookeeper
- en: 'Spring Cloud supports various products used as a part of the microservices
    architecture. You can find this out when reading this chapter where Consul has
    been compared with Eureka as a discovery tool, and with Spring Cloud Config as
    a distributed configuration tool. Zookeeper is another solution that might serve
    as an alternative choice to those listed previously. As with Consul, it can be
    used for both service discovery and distributed configuration. To enable Spring
    Cloud Zookeeper in the project, you should include the `spring-cloud-starter-zookeeper-discovery`
    starter for the service discovery feature, or `spring-cloud-starter-zookeeper-config`
    for the configuration server feature. Alternatively, you may declare a `spring-cloud-starter-zookeeper-all`
    dependency that activates all functionalities for the application. Don''t forget
    to include `spring-boot-starter-web`, which is still required to provide web functionality:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud支持作为微服务架构一部分使用的各种产品。当阅读本章时，您会发现Consul已与Eureka作为发现工具以及Spring Cloud
    Config作为分布式配置工具进行了比较。 Zookeeper是另一个可能作为前述选择的替代方案。与Consul一样，它既可以用于服务发现，也可以用于分布式配置。要在项目中启用Spring
    Cloud Zookeeper，您应该为服务发现功能包含`spring-cloud-starter-zookeeper-discovery`启动器，或者为配置服务器功能包含`spring-cloud-starter-zookeeper-config`。或者，您可以声明一个`spring-cloud-starter-zookeeper-all`依赖项，以激活应用程序的所有功能。不要忘记包含`spring-boot-starter-web`，这仍然是提供Web功能所必需的：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Zookeeper connection settings are auto-configured. By default, the client tries
    to connect to `localhost:2181`. In order to override it, you should define the
    `spring.cloud.zookeeper.connect-string` property with the current server network
    address:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Zookeeper连接设置是自动配置的。默认情况下，客户端尝试连接到`localhost:2181`。为了覆盖它，您应该使用当前服务器网络地址定义`spring.cloud.zookeeper.connect-string`属性：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As with Spring Cloud Consul, Zookeeper supports all the most popular communication
    libraries provided by Spring Cloud Netflix, such as Feign, Ribbon, Zuul, or Hystrix.
    Before we start working on the sample implementation, first we have to start the
    Zookeeper instance.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与Spring Cloud Consul一样，Zookeeper支持Spring Cloud Netflix提供的所有最受欢迎的通信库，如Feign、Ribbon、Zuul或Hystrix。在开始对示例实现进行操作之前，我们首先必须启动Zookeeper实例。
- en: Running Zookeeper
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Zookeeper
- en: 'As you probably guessed, I''m going to launch Zookeeper on the local machine
    using its Docker image. The following command starts the Zookeeper server instance.
    Since it <q>fails fast</q>, the best approach is to always restart it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的那样，我打算使用其Docker镜像在本地机器上启动Zookeeper。以下命令启动Zookeeper服务器实例。由于它“快速失败”，最好的方法是始终重新启动它：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In contrast to previously discussed solutions in this area, such as Consul
    or Eureka, Zookeeper doesn''t provide a simple RESTful API or a web management
    console that allows us to easily manage it. It has an official API binding for
    Java and C. We may also use its command line interface, which can be easily started
    within the Docker container. The command visible here starts the container with
    the command line client, and links it to the Zookeeper server container:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与此领域中先前讨论的解决方案（如Consul或Eureka）相比，Zookeeper并不提供一个简单的RESTful API或Web管理控制台，使我们可以轻松管理它。它有一个官方的Java和C的API绑定。我们也可以使用它的命令行界面，它可以很容易地在Docker容器中启动。这里可见的命令启动了带有命令行客户端的容器，并将其链接到Zookeeper服务器容器：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Zookeeper CLI allows for performing some useful operations, such as the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Zookeeper CLI允许执行一些有用的操作，例如以下操作：
- en: '**Creating znodes**: To create a znode with the given path, use the command
    `create /path /data`.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建znodes**：要使用给定路径创建znode，使用命令`create /path /data`。'
- en: '**Getting data**: The command `get /path` returns the data and metadata associated
    with the znode.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取数据**：命令`get /path`返回与znode关联的数据和元数据。'
- en: '**Watching znode for changes**: This shows a notification if znode or znode''s
    children data changes. Watching can only be set with the `get` command.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监视znode的更改**：如果znode或znode的子数据发生更改，这将显示通知。监视只能使用`get`命令设置。'
- en: '**Setting data**: To set znode data, use the command `set /path /data`.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置数据**：要设置znode数据，使用命令`set /path /data`。'
- en: '**Creating children of a znode**: This command is similar to that used for
    creating a single znode. The only difference is that the path of the child znode
    includes the parent path `create /parent/path/subnode/path /data`.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建znode的子节点**：此命令类似于用于创建单个znode的命令。唯一的区别是子znode的路径包括父路径`create /parent/path/subnode/path
    /data`。'
- en: '**Listing children of a znode**: This may be displayed using the `ls /path`
    command.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列出znode的子节点**：可以使用`ls /path`命令显示。'
- en: '**Checking status**: This may be checked out with the command `stat /path`.
    Status describes the metadata of a specified znode, like timestamp or version
    number.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查状态**：可以使用`stat /path`命令进行检查。状态描述了指定znode的元数据，如时间戳或版本号。'
- en: '**Removing/deleting a znode**: The command `rmr /path` removes the znode with
    all its children.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除znode**：命令`rmr /path`删除带有所有子节点的znode。'
- en: In that fragment, the term *znode* has appeared for the first time. When storing
    data, Zookeeper uses a tree structure, where each node is called a **znode**.
    The names of those znodes are based on the path taken from the root node. Each
    node has a name. It can be accessed using the absolute path that begins from the
    root node. This concept is similar to Consul folders, and has been used for creating
    keys in the key/value store.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在该片段中，术语*znode*首次出现。在存储数据时，Zookeeper使用树结构，其中每个节点称为**znode**。这些znode的名称基于从根节点获取的路径。每个节点都有一个名称。可以使用从根节点开始的绝对路径访问它。这个概念类似于Consul文件夹，并且已用于在键/值存储中创建键。
- en: Service discovery
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现
- en: The most popular Java client library for Apache Zookeeper is Apache Curator.
    It provides an API framework and utilities to make using Apache Zookeeper much
    easier. It also includes recipes for common-use cases and extensions, such as
    service discovery or Java 8 asynchronous DSL. Spring Cloud Zookeeper leverages
    one such extension for service discovery implementation. The usage of the Curator
    library by Spring Cloud Zookeeper is completely transparent for the developer,
    so I wouldn't like to describe it in more detail here.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Zookeeper最受欢迎的Java客户端库是Apache Curator。它提供了一个API框架和实用程序，使使用Apache Zookeeper变得更加容易。它还包括常见用例和扩展的配方，例如服务发现或Java
    8异步DSL。Spring Cloud Zookeeper利用了这样的扩展来实现服务发现。Spring Cloud Zookeeper对Curator库的使用对开发人员来说是完全透明的，因此我不想在这里更详细地描述它。
- en: Client implementation
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端实现
- en: The usage on the client side is the same as for other Spring Cloud projects
    related to service discovery. The application main class, or `@Configuration`
    class, should be annotated with `@EnableDiscoveryClient`. The default service
    name, instance ID, and port are taken from `spring.application.name`, the Spring
    Context ID, and `server.port`, respectively.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端端的使用与与服务发现相关的其他Spring Cloud项目相同。应用程序的主类或`@Configuration`类应该用`@EnableDiscoveryClient`进行注释。默认的服务名称、实例ID和端口分别来自`spring.application.name`、Spring上下文ID和`server.port`。
- en: Sample application source code is available in the GitHub repository at [https://github.com/piomin/sample-spring-cloud-zookeeper.git](https://github.com/piomin/sample-spring-cloud-zookeeper.git).
    Fundamentally, it is no different than the sample system introduced for Consul,
    other than the dependency on Spring Cloud Zookeeper Discovery. It still consists
    of four microservices, which communicate with each other. Now, after cloning the
    repository, build it with the `mvn clean install` command. Then, run every service
    with an active profile name using `java -jar` command, for example, `java -jar
    --spring.profiles.active=zone1 order-service/target/order-service-1.0-SNAPSHOT.jar`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序源代码可在GitHub存储库[https://github.com/piomin/sample-spring-cloud-zookeeper.git](https://github.com/piomin/sample-spring-cloud-zookeeper.git)中找到。基本上，它与为Consul引入的示例系统没有什么不同，只是依赖于Spring
    Cloud Zookeeper Discovery。它仍然由四个微服务组成，它们相互通信。现在，克隆存储库后，使用`mvn clean install`命令构建它。然后，使用`java
    -jar`命令运行每个带有活动配置文件名称的服务，例如`java -jar --spring.profiles.active=zone1 order-service/target/order-service-1.0-SNAPSHOT.jar`。
- en: 'You may see the list of registered services and instances by using the CLI
    commands `ls` and `get`. Spring Cloud Zookeeper, by default, registers all instances
    in the `/services` root folder. It may be overridden with the `spring.cloud.zookeeper.discovery.root`
    property. You may check out a list of currently registered services by using the
    Docker container with the command-line client:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用CLI命令`ls`和`get`查看已注册服务和实例的列表。默认情况下，Spring Cloud Zookeeper将所有实例注册在`/services`根文件夹中。可以使用`spring.cloud.zookeeper.discovery.root`属性进行覆盖。您可以使用带有命令行客户端的Docker容器来查看当前注册的服务列表。
- en: '![](img/fdbd83d4-a14c-43f6-8302-5a761da38a9d.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fdbd83d4-a14c-43f6-8302-5a761da38a9d.png)'
- en: Zookeeper dependencies
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zookeeper依赖
- en: Spring Cloud Zookeeper has one additional feature, called **Zookeeper dependencies**.
    Dependencies are to be understood as the other applications registered in Zookeeper,
    which are called via the Feign client or the Spring `RestTemplate`. These dependencies
    may be provided as properties of the application. The functionality is enabled
    through auto-configuration after you include the `spring-cloud-starter-zookeeper-discovery`
    starter to the project. It may be disabled by setting the `spring.cloud.zookeeper.dependency.enabled`
    property to `false`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Zookeeper有一个额外的功能，称为**Zookeeper依赖**。依赖项是指在Zookeeper中注册的其他应用程序，通过Feign客户端或Spring
    `RestTemplate`调用。这些依赖项可以作为应用程序的属性提供。在将`spring-cloud-starter-zookeeper-discovery`启动器包含到项目中后，该功能将通过自动配置启用。可以通过将`spring.cloud.zookeeper.dependency.enabled`属性设置为`false`来禁用该功能。
- en: 'The configuration of the Zookeeper Dependency mechanism is provided with `spring.cloud.zookeeper.dependencies.*`
    properties. Here''s the fragment of the `bootstrap.yml` file from `order-service`.
    This service integrates with all other available services:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Zookeeper依赖机制的配置使用`spring.cloud.zookeeper.dependencies.*`属性。以下是`order-service`中`bootstrap.yml`文件的片段。该服务集成了所有其他可用服务：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s take a closer look at the preceding configuration. The root property
    of every called service is the alias, which may then be used as the service name
    by the Feign client or `@LoadBalanced RestTemplate`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下前面的配置。每个被调用服务的根属性是别名，然后可以被Feign客户端或`@LoadBalanced RestTemplate`用作服务名称：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The next very important field in the configuration is the path. It sets the
    path under which the dependency is registered in Zookeeper. So, if that property
    has the value `customer-service`, it means Spring Cloud Zookeeper tries to look
    up the appropriate service znode under the path `/services/customer-service`.
    There are some other properties that may customize the behavior of the client.
    One of them is `loadBalancerType`, used for applying the load balancing strategy.
    We can choose between three available strategies—`ROUND_ROBIN`, `RANDOM`, and
    `STICKY`. I also set the `required` property to `true` for every service mapping. Now,
    if your application can’t detect the required dependency during boot time, it
    fails to start. Spring Cloud Zookeeper dependencies also allow managing API versions
    (the properties `contentTypeTemplate` and `versions`), and request headers (the
    `headers` property).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 配置中的下一个非常重要的字段是路径。它设置了依赖项在Zookeeper中注册的路径。因此，如果该属性的值为`customer-service`，这意味着Spring
    Cloud Zookeeper尝试在路径`/services/customer-service`下查找适当的服务znode。还有一些其他属性可以自定义客户端的行为。其中之一是`loadBalancerType`，用于应用负载均衡策略。我们可以在三种可用策略之间进行选择——`ROUND_ROBIN`、`RANDOM`和`STICKY`。我还为每个服务映射将`required`属性设置为`true`。现在，如果您的应用程序在启动时无法检测到所需的依赖项，它将无法启动。Spring
    Cloud Zookeeper依赖还允许管理API版本（属性`contentTypeTemplate`和`versions`）和请求头（`headers`属性）。
- en: By default, Spring Cloud Zookeeper enables `RestTemplate` for communication
    with dependencies. In the sample application available in branch dependencies
    ([https://github.com/piomin/sample-spring-cloud-zookeeper/tree/dependencies](https://github.com/piomin/sample-spring-cloud-zookeeper/tree/dependencies)),
    we use the Feign client instead of `@LoadBalanced RestTemplate`. In order to disable
    that feature, we should set the property `spring.cloud.zookeeper.dependency.resttemplate.enabled`
    to `false`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Cloud Zookeeper启用`RestTemplate`与依赖项进行通信。在分支dependencies中提供的示例应用程序中，我们使用Feign客户端而不是`@LoadBalanced
    RestTemplate`。为了禁用该功能，我们应该将`spring.cloud.zookeeper.dependency.resttemplate.enabled`属性设置为`false`。
- en: Distributed configuration
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式配置
- en: 'Configuration management with Zookeeper is pretty similar to that described
    for Spring Cloud Consul Config. By default, all the property sources are stored
    in the `/config` folder (or znode in Zookeeper nomenclature). Let me point it
    out one more time. Assuming we have the `spring.application.name` property set
    to `order-service` in the `bootstrap.yml` file, and the `spring.profiles.active`
    running argument set to `zone1`, it tries to locate the property sources in the
    following order: `config/order-service,zone1/`, `config/order-service/`, `config/application,zone1/`,
    `config/application/`. Properties stored in the folder with the prefix `config/application`
    in the namespace are available for all applications that use Zookeeper for distributed
    configuration.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Zookeeper进行配置管理与Spring Cloud Consul Config中描述的非常相似。默认情况下，所有属性源都存储在`/config`文件夹（或Zookeeper术语中的znode）中。让我再次指出。假设我们在`bootstrap.yml`文件中将`spring.application.name`属性设置为`order-service`，并且将`spring.profiles.active`运行参数设置为`zone1`，它将按以下顺序查找属性源：`config/order-service,zone1/`、`config/order-service/`、`config/application,zone1/`、`config/application/`。在具有前缀`config/application`的文件夹中存储的属性在命名空间中可供使用Zookeeper进行分布式配置的所有应用程序。
- en: 'To access the sample application, you need to switch to the branch configuration
    in the [https://github.com/piomin/sample-spring-cloud-zookeeper.git](https://github.com/piomin/sample-spring-cloud-zookeeper.git)
    repository. The configuration defined in the local `application.yml` or `bootstrap.yml`
    file, visible here, has now been moved to Zookeeper:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问示例应用程序，您需要切换到 [https://github.com/piomin/sample-spring-cloud-zookeeper.git](https://github.com/piomin/sample-spring-cloud-zookeeper.git)
    仓库中的分支配置。在本地的 `application.yml` 或 `bootstrap.yml` 文件中定义的配置已经移动到了Zookeeper中：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The required znodes have to be created using CLI. Here''s the list of Zookeeper
    commands that create znodes with the given path. I have used the `create /path
    /data` command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 必须使用CLI创建所需的znodes。以下是创建具有给定路径的znodes的Zookeeper命令列表。我使用了 `create /path /data`
    命令：
- en: '![](img/7494c667-24b5-4a33-aef6-fbb27e519e61.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7494c667-24b5-4a33-aef6-fbb27e519e61.png)'
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, I have guided you through the main features of two Spring Cloud
    projects—Consul and Zookeeper. I haven't focused only on Spring Cloud functionalities,
    but have also given you the instructions on how to start, configure, and maintain
    instances of its tools. We have discussed even more advanced scenarios, such as
    setting up a cluster consisting of numerous members using Docker. There, you had
    a chance to see the true power of Docker as a development tool. It allowed us
    to initialize a cluster that consists of three members just by using three simple
    commands, without any additional configuration.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我已经向您介绍了两个Spring Cloud项目——Consul和Zookeeper的主要特性。我不仅关注Spring Cloud的功能，还向您提供了有关如何启动、配置和维护其工具实例的说明。我们甚至讨论了更高级的场景，比如使用Docker设置由多个成员组成的集群。在那里，您有机会看到Docker作为开发工具的真正力量。它使我们能够仅通过三个简单的命令，而无需任何额外配置，初始化由三个成员组成的集群。
- en: Consul seems to be an important alternative to Eureka as a discovery server
    when using Spring Cloud. I cannot say the same about Zookeeper. As you have probably
    noticed, I have written much more about Consul than Zookeeper. Also, Spring Cloud
    treats Zookeeper as a second choice. It still does not have a zoning mechanism
    or watching capability for configuration changes that are implemented, in contrast
    to Spring Cloud Consul. You shouldn't be surprised by this. Consul is a modern
    solution designed in order to meet needs of the newest architectures, such as
    microservices-based systems, while Zookeeper is a key/value store adopted as a
    service discovery tool for applications running in a distributed environment.
    However, it is worth considering this tool if you use an Apache Foundation stack
    in your system. Thanks to that, you may take advantage of integration between
    Zookeeper and other Apache components, such as Camel or Karaf, and easily discover
    services created using the Spring Cloud framework.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Consul似乎是Spring Cloud在使用时作为发现服务器的重要替代品。我不能说Zookeeper也是如此。您可能已经注意到，我对Consul的描述要比Zookeeper多得多。此外，Spring
    Cloud将Zookeeper视为第二选择。与Spring Cloud Consul相比，它仍然没有用于配置更改的分区机制或监视能力。对此您不应感到惊讶。Consul是一种现代解决方案，旨在满足最新架构的需求，例如基于微服务的系统，而Zookeeper是一种键/值存储，被采用为分布式环境中运行的应用程序的服务发现工具。但是，如果您的系统中使用了Apache
    Foundation堆栈，那么考虑使用这个工具是值得的。借助它，您可以利用Zookeeper与其他Apache组件（如Camel或Karaf）的集成，并轻松发现使用Spring
    Cloud框架创建的服务。
- en: To conclude, after reading this chapter, you should be able to use the main
    features of Spring Cloud Consul and Spring Cloud Zookeeper in your microservice-based
    architecture. You should also know the major advantages and disadvantages of all
    available discovery and configuration tools within Spring Cloud, in order to choose
    the most appropriate solution for your system.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在阅读本章后，您应该能够在基于微服务的架构中使用Spring Cloud Consul和Spring Cloud Zookeeper的主要功能。您还应该了解Spring
    Cloud中所有可用发现和配置工具的主要优缺点，以便为您的系统选择最合适的解决方案。
