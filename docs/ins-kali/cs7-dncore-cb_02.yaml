- en: Classes and Generics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和泛型
- en: 'Classes form the building blocks of software development and are essential
    for building good code. In this chapter, we will be looking at classes and generics
    and why we need to use them. The recipes we will be covering are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类是软件开发的构建模块，对于构建良好的代码至关重要。在本章中，我们将看看类和泛型，以及为什么我们需要使用它们。我们将涵盖的内容如下：
- en: Creating and implementing an abstract class
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和实现抽象类
- en: Creating and implementing an interface
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和实现接口
- en: Creating and using a generic class or method
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用泛型类或方法
- en: Creating and using a generic interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用泛型接口
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: As you probably know, classes are simply containers for related methods and
    properties to describe an object in your software. An object is an instance of
    a specific class and, sometimes, mimics real-world things. When thinking of a
    car, you might create a vehicle class that contains certain attributes (properties)
    that all vehicles contain, such as automatic or manual transmission, wheel count
    (not all vehicles have only four wheels), or fuel type.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，类只是相关方法和属性的容器，用于描述软件中的对象。对象是特定类的实例，并且有时模拟现实世界的事物。当想到汽车时，你可能会创建一个包含所有车辆共有属性（属性）的车辆类，比如自动或手动变速器，轮子数量（并非所有车辆都只有四个轮子），或燃料类型。
- en: When we create an instance of the vehicle class, we can create a car object,
    an SUV object, and so on. Here lies the power of classes, which is to describe
    the world around us and translate it into a programming language that a compiler
    can understand.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个车辆类的实例时，我们可以创建一个汽车对象、一个SUV对象等等。这就是类的力量所在，它可以描述我们周围的世界，并将其转化为编译器可以理解的编程语言。
- en: Creating and implementing an abstract class
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和实现抽象类
- en: Many developers have heard about abstract classes, but their implementation
    is a mystery. How can you as a developer identify an abstract class and decide
    when to use one? The definition is quite a simple one actually. Once you understand
    this fundamental definition of an abstract class, when and why to use one becomes
    obvious.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员听说过抽象类，但它们的实现是一个谜。作为开发人员，你如何识别抽象类并决定何时使用它？实际上，定义是非常简单的。一旦你理解了抽象类的基本定义，何时以及为什么使用它就变得显而易见。
- en: Imagine for a moment that you are developing an application that manages the
    animals in a cat sanctuary. The cat sanctuary rehabilitates lions, tigers, jaguars,
    leopards, cheetahs, pumas, and even domestic cats. The common noun that describes
    all these animals is the word *cat*. You can, therefore, safely assume that the
    abstraction of all these animals is a cat, and thus, this word identifies our
    abstract class. You would then create an abstract class called `Cat`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在开发一个管理猫收容所动物的应用程序。猫收容所康复狮子、老虎、美洲豹、豹子、猎豹、美洲狮，甚至家猫。描述所有这些动物的共同名词是“猫”。因此，你可以安全地假设所有这些动物的抽象是一只猫，因此，这个词标识了我们的抽象类。然后你会创建一个名为`Cat`的抽象类。
- en: However, you need to keep in mind that you will never ever create an instance
    of the abstract class `Cat`. All the classes that inherit from the abstract class
    also share some functionality. This means that you will create a `Lion` class
    and a `Tiger` class that inherit from the abstract class `Cat`. In other words,
    the inherited classes are a kind of cat. Both classes share functionality in the
    form of `Sleep()`, `Eat()`, `Hunt()`, and various other methods. In this way,
    we can ensure that inherited classes all contain this common functionality.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你需要记住，你永远不会创建抽象类`Cat`的实例。所有继承自抽象类的类也共享一些功能。这意味着你将创建一个继承自抽象类`Cat`的`Lion`类和`Tiger`类。换句话说，继承的类是一种猫。这两个类共享`Sleep()`、`Eat()`、`Hunt()`和其他各种方法的功能。通过这种方式，我们可以确保继承的类都包含这些共同的功能。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's go ahead and create our abstract class for cat. We will then use it to
    inherit from and create other objects to define different types of cats.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建我们的猫的抽象类。然后我们将使用它来继承并创建其他对象来定义不同类型的猫。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: Create a new console application in Visual Studio and call it `ClassesAndGenerics`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中创建一个新的控制台应用程序，并将其命名为`ClassesAndGenerics`。
- en: 'Add an abstract class called `Cat`. To do this, add the `abstract` keyword
    to the class. We are now ready to describe the `Cat` abstract class:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Cat`的抽象类。为此，在类中添加`abstract`关键字。我们现在准备描述`Cat`抽象类：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `abstract` keyword indicates to us that the object it is applied to has
    no implementation. When used in a class declaration, it basically tells the compiler
    that the class is to be used as a base class. This means that no instance of the
    class can be created. The only way in which implementation of the abstract class
    happens is when it is implemented by derived classes that inherit from the base
    class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`abstract`关键字告诉我们，它所应用的对象没有实现。当用于类声明时，它基本上告诉编译器该类将被用作基类。这意味着不能创建该类的实例。抽象类的实现方式是由继承自基类的派生类实现的。'
- en: 'Your console application code should now look as follows:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的控制台应用程序代码现在应该如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add three methods to the abstract class called `Eat()`, `Hunt()`, and `Sleep()`.
    You will note that these methods don''t contain a body (curly braces). This is
    because they have been defined as abstract. As with abstract classes, the abstract
    methods contained within the abstract class contain no implementation. These three
    methods basically describe functionality that is common to all cats. All cats
    must eat, hunt, and sleep. Therefore, to ensure that all classes that inherit
    from the `Cat` abstract class contain this functionality, it is added to the abstract
    class. These methods are then implemented in the derived classes, which we will
    see in the upcoming steps:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在抽象类中添加三个方法，分别为`Eat()`、`Hunt()`和`Sleep()`。您会注意到这些方法没有包含具体的实现（花括号）。这是因为它们被定义为抽象方法。与抽象类一样，抽象类中包含的抽象方法没有具体的实现。这三个方法基本上描述了所有猫共有的功能。所有的猫都必须吃饭、狩猎和睡觉。因此，为了确保所有继承自`Cat`抽象类的类都包含这些功能，它被添加到了抽象类中。这些方法然后在派生类中实现，我们将在接下来的步骤中看到：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We want to define two types of cats. The first type of cat we want to define
    is a lion. For this, we create a `Lion` class:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要定义两种类型的猫。我们想要定义的第一种猫是狮子。为此，我们创建一个`Lion`类：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At this point in time, the `Lion` class is simply an ordinary class and does
    not contain any common functionality defined in the `Cat` abstract class. To inherit
    from the `Cat` abstract class, we need to add `: Cat` after the `Lion` class name.
    The colon indicates that the `Lion` class inherits from the `Cat` abstract class.
    The `Lion` class is therefore a derived class of the `Cat` abstract class:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '此时，`Lion`类只是一个普通类，不包含在`Cat`抽象类中定义的任何共有功能。要继承自`Cat`抽象类，我们需要在`Lion`类名后面添加`: Cat`。冒号表示`Lion`类继承自`Cat`抽象类。因此，`Lion`类是`Cat`抽象类的派生类：'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As soon as you specify that the `Lion` class inherits from the `Cat` class,
    Visual Studio will show you an error. This is expected, because we have told the
    compiler that the `Lion` class needs to inherit all the features of the `Cat`
    abstract class, but we have not actually added these features to the `Lion` class.
    The derived class is said to override the methods in the abstract class, and needs
    to specifically be written with the `override` keyword.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦指定`Lion`类继承自`Cat`类，Visual Studio将显示错误。这是预期的，因为我们已经告诉编译器，`Lion`类需要继承`Cat`抽象类的所有特性，但我们实际上并没有将这些特性添加到`Lion`类中。派生类被认为是重写了抽象类中的方法，并且需要使用`override`关键字来明确地编写。
- en: 'If you hover over the red squiggly line underlining the `Lion` class, Visual
    Studio will offer an explanation for the error via the lightbulb feature. As you
    can see, Visual Studio is telling you that while you have defined the class to
    be inheriting from the abstract class, you have not implemented any of the abstract
    members of the `Cat` class:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您将鼠标悬停在`Lion`类下面的红色波浪线上，Visual Studio将通过灯泡功能提供错误的解释。正如您所看到的，Visual Studio告诉您，虽然您已经定义了该类继承自抽象类，但您并没有实现`Cat`类的任何抽象成员：
- en: '![](img/B06434_02_03.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_02_03.png)'
- en: You can, therefore, see that using abstract classes is a fantastic way to enforce
    specific functionality within your system. If you define abstract members in an
    abstract class, the derived classes that inherit from that abstract class must
    implement those members; otherwise, your code will not compile. This can be used
    to enforce standards and practices adopted by your company or to simply allow
    other developers to implement certain best practices as they use your base class
    for their derived classes. With the advent of code analyzers in Visual Studio
    2015, the practice of enforcing certain code best practices is easily enforced.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以看到使用抽象类是在系统中强制执行特定功能的一种绝妙方式。如果您在抽象类中定义了抽象成员，那么继承自该抽象类的派生类必须实现这些成员；否则，您的代码将无法编译。这可以用来强制执行公司采用的标准和实践，或者简单地允许其他开发人员在使用您的基类为其派生类实现某些最佳实践。随着Visual
    Studio 2015中代码分析器的出现，强制执行某些最佳代码实践的做法变得更加容易。
- en: To implement these members that Visual Studio is warning us about, place your
    mouse cursor on the `Lion` class name and hit *Ctrl* + *.* (period). You can also
    click on the Show potential fixes link in the lightbulb popup. Visual Studio will
    give you a small heads up, displaying the changes it will make to your code. You
    can preview these changes by clicking on the Preview changes link as well as fix
    all occurrences in the document, project, or solution by clicking on the appropriate
    link:![](img/B06434_02_04.png)
  id: totrans-32
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现Visual Studio警告我们的这些成员，将鼠标光标放在`Lion`类名上，然后按下*Ctrl* + *.*（句号）。您也可以点击灯泡弹出窗口中的显示潜在修复链接。Visual
    Studio会给出一个小提示，显示它将对您的代码进行的更改。您可以通过点击预览更改链接来预览这些更改，也可以通过点击文档、项目或解决方案中的适当链接来修复所有出现的情况：![](img/B06434_02_04.png)
- en: After Visual Studio has added the changes displayed in the suggestions window,
    your `Lion` class will be correct and will look like the code listing in the following
    step.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio添加了建议窗口中显示的更改之后，您的`Lion`类将是正确的，并且看起来像以下步骤中的代码清单。
- en: 'You will notice that Visual Studio automatically adds a `NotImplementedException`
    exception with the following line of code in each overridden method `throw new
    NotImplementedException();`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到Visual Studio自动在每个重写的方法中添加了`NotImplementedException`异常的代码行 `throw new NotImplementedException();`：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is the default behavior of Visual Studio when overriding methods in the
    base class. Basically, if you had to instantiate the `Lion` class without writing
    any implementation in the overridden methods, a runtime exception would be generated.
    The idea of inheriting from our abstract class was to extend it and implement
    common functionality. This is where we need to implement that functionality, and
    this is the reason there is no implementation in the abstract class. The abstract
    class just tells us that the following methods need to be implemented. The derived
    class does the actual implementation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在覆盖基类中的方法时Visual Studio的默认行为。基本上，如果您必须在覆盖的方法中实例化`Lion`类而不写任何实现，将生成运行时异常。从我们的抽象类继承的想法是扩展它并实现共同功能。这就是我们需要实现该功能的地方，也是抽象类中没有实现的原因。抽象类只告诉我们需要实现以下方法。派生类执行实际的实现。
- en: 'Go ahead and add some implementation to the overridden methods of the `Lion`
    class. First, add the `using static` statement for the `Console.WriteLine` method
    to the top of your class file:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续为`Lion`类的覆盖方法添加一些实现。首先，在您的类文件顶部添加`using static`语句以使用`Console.WriteLine`方法：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, add the implemented code for the methods as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按照以下方式添加方法的实现：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we will create another class called `Tiger` that also derives from the
    abstract class `Cat`. Follow step 7 to step 10 to create the `Tiger` class and
    inherit the `Cat` abstract class:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建另一个名为`Tiger`的类，它也派生自抽象类`Cat`。按照步骤7到步骤10创建`Tiger`类并继承`Cat`抽象类：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the same implementation for the `Tiger` class as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的`Tiger`类添加相同的实现如下：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For our `Lion` class, add an enumerator for `ColorSpectrum` and a property
    called `LionColor`. It is here that the implementations of the `Lion` and `Tiger`
    classes will differ. While they both must implement the common functionality specified
    in the abstract class, namely, `Eat()`, `Hunt()`, and `Sleep()`, only the lion
    can have a color of either brown or white in its available range of colors:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的`Lion`类，添加一个名为`ColorSpectrum`的枚举器和一个名为`LionColor`的属性。在这里，`Lion`和`Tiger`类的实现将有所不同。虽然它们都必须实现抽象类中指定的共同功能，即`Eat()`、`Hunt()`和`Sleep()`，但只有狮子可以在其可用颜色范围内拥有棕色或白色的颜色：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, add the `Lion()` constructor in our `Lion` class. This will allow us
    to specify a color for the lions in the cat sanctuary. The constructor also takes
    as a parameter a variable of the `ColorSpectrum` enumerator type:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的`Lion`类中添加`Lion()`构造函数。这将允许我们为猫保护区的狮子指定颜色。构造函数还以`ColorSpectrum`枚举器类型的变量作为参数：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Slightly similar to this, but quite different in color, the `Tiger` class can
    only have a `ColorSpectrum` enumeration that defines tigers as being orange, white,
    gold, blue (yes, you actually get a blue tiger), or black. Add the `ColorSpectrum`
    enumerator to the `Tiger` class as well as a property called `TigerColor`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与此类似，但颜色相当不同，`Tiger`类只能有一个`ColorSpectrum`枚举，定义老虎为橙色、白色、金色、蓝色（是的，您实际上可以得到一只蓝色老虎）或黑色。在`Tiger`类中添加`ColorSpectrum`枚举器以及一个名为`TigerColor`的属性：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we will create a `Tiger()` constructor for our `Tiger` class to set
    the colors of tigers in the cat sanctuary to the valid colors that tigers are
    found in. By doing this, we are separating certain functionality specific only
    to tigers and lions in their respective classes, while all the common functionality
    is contained in the abstract class `Cat`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将为我们的`Tiger`类创建一个`Tiger()`构造函数，以将猫保护区中老虎的颜色设置为老虎所在的有效颜色。通过这样做，我们将特定于老虎和狮子的某些功能分离到各自的类中，而所有共同功能都包含在抽象类`Cat`中：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We now need to instantiate the `Lion` and `Tiger` classes from the console
    application. You will see that we set the respective cat''s color from the constructor:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要从控制台应用程序实例化`Lion`和`Tiger`类。您将看到我们从构造函数中设置了相应猫的颜色：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When you run your console application, you see that the methods are called in
    sequence:![](img/B06434_02_07.png)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您运行控制台应用程序时，您会看到方法按顺序调用：![](img/B06434_02_07.png)
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: While the example illustrated earlier is a rather simplistic one, the theory
    is sound. The abstract class takes collective functionality across all cats and
    groups so that it can be shared inside each derived class. No implementation exists
    in the abstract class; it only defines what needs to happen. Think of abstract
    classes as a type of blueprint for classes that inherit from the abstract class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面举的例子相当简单，但理论是正确的。抽象类跨所有猫和组的集体功能，以便它可以在每个派生类内共享。抽象类中不存在实现；它只定义了需要发生的事情。将抽象类视为从抽象类继承的类的一种蓝图。
- en: 'While the content of the implementation is up to you, the abstract class requires
    that you add the abstract methods it defines. From here on, you can create a solid
    foundation for similar classes in your applications that are supposed to share
    functionality. This is the goal of inheritance. Let''s recap the features of an
    abstract class:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实现的内容由您决定，但抽象类要求您添加它定义的抽象方法。从现在开始，您可以为应用程序中类似的类创建一个坚实的基础，这些类应该共享功能。这就是继承的目的。让我们回顾一下抽象类的特点：
- en: You can't instantiate an abstract class with the `new` keyword.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不能使用`new`关键字实例化抽象类。
- en: You can only add abstract methods and accessors to an abstract class.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您只能向抽象类添加抽象方法和访问器。
- en: You can never modify an abstract class as `sealed`. The `sealed` modifiers prevents
    inheritance, while abstract requires inheritance.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您永远不能将抽象类修改为`sealed`。`sealed`修饰符阻止继承，而抽象类要求继承。
- en: Any class derived from your abstract class must include the implementations
    of the abstract methods that were inherited from the abstract class.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从您的抽象类派生的任何类都必须包括从抽象类继承的抽象方法的实现。
- en: Because abstract methods inside the abstract class have no implementation, they
    don't contain a body either.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为抽象类中的抽象方法没有实现，它们也没有主体。
- en: Creating and implementing an interface
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和实现接口
- en: For many developers, interfaces are equally confusing and their purpose not
    clearly understood. Interfaces are actually quite easy to get to grips with once
    you understand the concept that defines an interface.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多开发人员来说，接口同样令人困惑，它们的目的并不清楚。一旦你理解了定义接口的概念，接口实际上是非常容易掌握的。
- en: Interfaces act like verbs. So, for example, if we had to create two classes
    called `Lion` and `Tiger` that derive from the `Cat` abstract class, the interface
    would describe some sort of action. Lions and tigers can roar (but not purr).
    We can then create an interface called `IRoarable`. If we had to derive a class
    called `Cheetah` from our abstract class `Cat`, we would not be able to use the
    `IRoarable` interface, because cheetahs purr. We would need to create an `IPurrable`
    interface.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接口就像动词一样。例如，如果我们必须创建两个分别从抽象类`Cat`派生的类`Lion`和`Tiger`，接口将描述某种动作。狮子和老虎可以咆哮（但不能发出喉音）。然后我们可以创建一个名为`IRoarable`的接口。如果我们必须从抽象类`Cat`派生一个名为`Cheetah`的类，我们将无法使用`IRoarable`接口，因为猎豹会发出喉音。我们需要创建一个`IPurrable`接口。
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Creating an interface is very similar to creating an abstract class. The difference
    is that the interface is describing what the class can do, in the case of the
    `Cheetah` class, by implementing `IPurrable`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个接口与创建一个抽象类非常相似。不同之处在于接口描述了类可以做什么，在`Cheetah`类的情况下，通过实现`IPurrable`。
- en: How to do it...
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'If you haven''t already done so in the previous recipe, create an abstract
    class called `Cat`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你之前还没有这样做，在上一个步骤中创建一个名为`Cat`的抽象类：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, add a class called `Cheetah` that inherits from the `Cat` abstract class:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个名为`Cheetah`的类，它继承自抽象类`Cat`：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As soon as you inherit from the `Cat` abstract class, Visual Studio will show
    you a warning via the lightbulb feature. As you inherited from the abstract class
    `Cat`, you have to implement the abstract members within the abstract class in
    your derived class `Cheetah`:![](img/B06434_02_08.png)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你从抽象类`Cat`继承，Visual Studio将通过灯泡功能显示警告。由于你从抽象类`Cat`继承，你必须在派生类`Cheetah`中实现抽象类中的抽象成员：![](img/B06434_02_08.png)
- en: This is easily fixable by typing *Ctrl* +*.* (period) and fixing all occurrences
    in the document. You can also do this for the project or solution. For our purpose,
    we only select the Document link at the bottom of the lightbulb suggestions. Visual
    Studio will automatically add the abstract methods defined in the abstract class
    to implement inside your `Cheetah` class:![](img/B06434_02_09.png)
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这很容易通过在文档中键入*Ctrl* +*.*（句号）并修复所有出现的情况来解决。你也可以为项目或解决方案这样做。对于我们的目的，我们只选择灯泡建议底部的文档链接。Visual
    Studio将自动在`Cheetah`类中添加在抽象类中定义的抽象方法的实现：![](img/B06434_02_09.png)
- en: 'You will notice that Visual Studio adds just the methods you need to override
    but will throw `NotImplementedException` if you try to use the class as is. The
    reason for using an abstract class is to implement the functionality defined in
    the abstract class `Cat` in the derived class `Cheetah`. Not doing so contravenes
    the rules for using abstract classes:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到Visual Studio只会添加你需要重写的方法，但如果你尝试使用这个类，它会抛出`NotImplementedException`。使用抽象类的原因是在派生类`Cheetah`中实现抽象类`Cat`中定义的功能。不这样做违反了使用抽象类的规则：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To add some implementation, modify your `Cheetah` class as follows. The implementation
    in the overridden methods is simple, but this validates the rule of writing some
    sort of implementation in the overridden methods:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了添加一些实现，修改你的`Cheetah`类如下。重写方法中的实现很简单，但这样验证了在重写方法中写一些实现的规则：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You will notice that the `WriteLine` method is used without the `Console` class.
    This is because we are using a new feature introduced in C# 6.0 that allows developers
    to bring static classes into scope by adding the `using static System.Console;`
    statement to the top of your class file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到`WriteLine`方法是在不使用`Console`类的情况下使用的。这是因为我们使用了C# 6.0中引入的一个新特性，允许开发人员通过在类文件顶部添加`using
    static System.Console;`语句将静态类引入作用域。
- en: 'Create an interface called `IPurrable` that will be implemented in the `Cheetah`
    class. A common naming convention for interfaces dictates that the interface name
    should be prefixed with a capital `I`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`IPurrable`的接口，它将在`Cheetah`类中实现。接口的一个常见命名约定规定接口名应以大写`I`为前缀：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we will add a method to the interface that any class implementing the
    interface must implement. You will notice that the interface''s `SoftPurr` method
    contains no implementation at all. It, however, specifies that we will need to
    pass this method an integer value for the decibel that the `Cheetah` class will
    purr at:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在接口中添加一个任何实现接口的类都必须实现的方法。你会注意到接口的`SoftPurr`方法根本没有实现。但它指定了我们需要为`Cheetah`类发出的喉音传递一个整数值：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next step is to implement the `IPurrable` interface in the `Cheetah` class.
    To do this, we need to add the `IPurrable` interface name after the `Cat` abstract
    class name. If the `Cheetah` class did not inherit from the abstract class, then
    the interface name would simply follow after the colon:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在`Cheetah`类中实现`IPurrable`接口。为此，我们需要在`Cat`抽象类名后添加`IPurrable`接口名。如果`Cheetah`类没有继承自抽象类，那么接口名将直接跟在冒号后面：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After specifying that the `Cheetah` class implements the `IPurrable` interface,
    Visual Studio once again displays a warning via the lightbulb feature. It is warning
    us that the `Cheetah` class does not implement the `SoftPurr` method defined in
    the interface `IPurrable`:![](img/B06434_02_10.png)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在指定`Cheetah`类实现`IPurrable`接口之后，Visual Studio再次通过灯泡功能显示警告。它警告我们`Cheetah`类没有实现接口`IPurrable`中定义的`SoftPurr`方法：![](img/B06434_02_10.png)
- en: As we did earlier, we can let Visual Studio suggest possible fixes for the problems
    encountered by typing *Ctrl* + *.* (period). Visual Studio suggests that the interface
    can be implemented implicitly or explicitly:![](img/B06434_02_11.png)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前一样，我们可以让Visual Studio建议可能的修复方法，通过输入*Ctrl* + *.* (句号)。Visual Studio建议接口可以被隐式或显式地实现:![](img/B06434_02_11.png)
- en: 'Knowing when to use an implicit or explicit implementation is also quite easy.
    We first need to know when using one over the other would be preferred. Let''s
    start off by implementing the `SoftPurr` method implicitly by selecting the first
    option in the lightbulb suggestion. You will see that this uses the `SoftPurr`
    method defined in the `IPurrable` interface as if it were part of the `Cheetah`
    class:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '知道何时使用隐式或显式实现也很容易。我们首先需要知道在何种情况下使用其中一种会更好。让我们首先通过选择灯泡建议中的第一个选项来隐式实现`SoftPurr`方法。您会看到这使用了在`IPurrable`接口中定义的`SoftPurr`方法，就好像它是`Cheetah`类的一部分一样:'
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we look at the `SoftPurr` method, it looks like a normal method inside the
    `Cheetah` class. This would be fine unless our `Cheetah` class already contains
    a property called `SoftPurr`. Go ahead and add a property called `SoftPurr` to
    your `Cheetah` class:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如果我们看`SoftPurr`方法，它看起来像是`Cheetah`类中的一个普通方法。这没问题，除非我们的`Cheetah`类已经包含了一个名为`SoftPurr`的属性。继续为您的`Cheetah`类添加一个名为`SoftPurr`的属性:'
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Visual Studio immediately displays a warning by telling us that the `Cheetah`
    class already contains a definition for `SoftPurr`:![](img/B06434_02_12-1.png)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio立即通过告诉我们`Cheetah`类已经包含了`SoftPurr`的定义来显示警告:![](img/B06434_02_12-1.png)
- en: It is here that the use of an explicit implementation becomes evident. This
    specifies that the `SoftPurr` method is a member of the implementation defined
    in the `IPurrable` interface:![](img/B06434_02_13.png)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，显式实现的使用变得明显。这指定了`SoftPurr`方法是在`IPurrable`接口中定义的实现的成员:![](img/B06434_02_13.png)
- en: 'Therefore, selecting the second option to implement the interface explicitly
    will add the `SoftPurr` method to your `Cheetah` class as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '因此，选择第二个选项来显式实现接口将会将`SoftPurr`方法添加到您的`Cheetah`类中，如下所示:'
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The compiler now knows that this is an interface that is being implemented and
    is therefore a valid line of code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器现在知道这是正在实现的接口，因此这是有效的代码。
- en: 'For the purposes of this book, let''s just use the implicit implementation.
    Let''s write some implementation for the `SoftPurr` method and use the new `nameof`
    keyword (introduced in C# 6.0) as well as the interpolated string for the output.
    Also, remove the `SoftPurr` property added earlier:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '为了本书的目的，让我们只使用隐式实现。让我们为`SoftPurr`方法编写一些实现，并使用新的`nameof`关键字(在C# 6.0中引入)以及插值字符串进行输出。同时，移除之前添加的`SoftPurr`属性:'
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Heading over to our console application, we can call our `Cheetah` class as
    follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '前往我们的控制台应用程序，我们可以调用我们的`Cheetah`类如下:'
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Running the application will produce the following output:![](img/B06434_02_14.png)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序将产生以下输出:![](img/B06434_02_14.png)
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: So, you might be wondering what the difference between an abstract class and
    an interface is. It basically comes down to where you want your implementation.
    If you need to share functionality between derived classes, then an abstract class
    is the best fit for your needs. In other words, we had specific things that were
    common to all cats (lions, tigers, and cheetahs) such as hunting, eating, and
    sleeping. This is then best used within an abstract class.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可能想知道抽象类和接口之间的区别是什么。基本上取决于您想要放置实现的位置。如果您需要在派生类之间共享功能，则抽象类是最适合您需求的选择。换句话说，我们有一些特定于所有猫(狮子、老虎和猎豹)的共同事物，例如狩猎、进食和睡觉。这时最好使用抽象类。
- en: If your implementation is specific to a class or several classes (but not all
    classes), then your best course of action would be to use an interface. In this
    case, the `IPurrable` interface can be applied to several classes (for example,
    cheetahs and domestic cats) but can't be applied to all cats (such as lions and
    tigers), because not all cats can purr.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的实现特定于一个类或多个类(但不是所有类)，那么您最好的选择是使用接口。在这种情况下，`IPurrable`接口可以应用于多个类(例如，猎豹和家猫)，但不能应用于所有猫(例如，狮子和老虎)，因为并非所有猫都能发出咕噜声。
- en: Knowing this difference and where you need to place your implementation will
    aid you in deciding whether you need to use an abstract class or an interface.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这种差异以及您需要放置实现的位置将有助于您决定是否需要使用抽象类还是接口。
- en: Creating and using a generic class or method
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和使用泛型类或方法
- en: Generics is a very interesting way of writing code. Instead of specifying the
    data type of the elements in the code at design time, you can actually delay the
    specification of those elements until they are used in code. This basically means
    that your class or method can work with any data type.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是编写代码的一种非常有趣的方式。在设计时，您可以延迟指定代码中元素的数据类型，直到它们在代码中使用。这基本上意味着您的类或方法可以与任何数据类型一起使用。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start off by writing a generic class that can take any data type as
    a parameter in its constructor and do something with it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写一个泛型类，该类可以在其构造函数中接受任何数据类型作为参数并对其进行操作。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Declaring a generic class is actually very easy. All that we need to do is
    create the class with the generic type parameter `<T>`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '声明一个泛型类实际上非常简单。我们所需要做的就是创建带有泛型类型参数`<T>`的类:'
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The generic type parameter is basically a placeholder for a specific type that
    will need to be defined when the class of variable is instantiated. This means
    that the generic class `PerformAction<T>` can never just be used without specifying
    the type argument inside angle brackets when instantiating the class.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型参数基本上是特定类型的占位符，当实例化变量的类时需要定义该类型。这意味着泛型类`PerformAction<T>`永远不能在实例化类时不在尖括号内指定类型参数而直接使用。
- en: 'Next, create a `private` variable of the generic type parameter `T`. This will
    hold the value we pass to the generic class:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个泛型类型参数`T`的`private`变量。这将保存我们传递给泛型类的值：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We now need to add a constructor to the generic class. The constructor will
    take as parameter a value of type `T`. The private variable `_value` will be set
    to the parameter passed to the constructor:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要为泛型类添加一个构造函数。构造函数将以`T`类型的值作为参数。私有变量`_value`将设置为传递给构造函数的参数：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, to complete our generic class, create a void return method called
    `IdentifyDataType()`. All that this is going to do is tell us what data type we
    passed to the generic class. We can find the type of the variable using `GetType()`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了完成我们的泛型类，创建一个名为`IdentifyDataType()`的void返回方法。这将告诉我们我们传递给泛型类的数据类型。我们可以使用`GetType()`找到变量的类型：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To see the true beauty of our generic class in action, instantiate the generic
    class in the console application and specify different data type arguments inside
    the angle brackets of each new instantiation:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了看到我们的泛型类真正的优势，实例化控制台应用程序中的泛型类，并在每个新实例化的尖括号内指定不同的数据类型参数：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Running your console application will output the given data types that you instantiated
    the generic class with each time:![](img/B06434_02_15.png)
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序将输出您每次实例化泛型类时使用的给定数据类型：![](img/B06434_02_15.png)
- en: We used the exact same class but let it perform with three very different data
    types. This kind of flexibility is a very powerful feature in your code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用完全相同的类，但让它使用三种非常不同的数据类型。这种灵活性是您代码中非常强大的一个特性。
- en: 'Another feature of C# is that you can constrain the generic types implemented:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: C#的另一个特性是您可以约束实现的泛型类型：
- en: 'We can do this by telling the compiler that only types that implement the `IDisposable`
    interface can be used with the generic class. Change your generic class by adding
    `where T : IDisposable` to it. Your generic class should now look like this:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们可以通过告诉编译器只有实现了`IDisposable`接口的类型才能与泛型类一起使用来实现这一点。通过向其添加`where T : IDisposable`，更改您的泛型类。您的泛型类现在应该是这样的：'
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Go back to the console application and take a look at the previous instantiations
    of the generic class:![](img/B06434_02_16.png)
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到控制台应用程序，看一下泛型类的先前实例化：![](img/B06434_02_16.png)
- en: Visual Studio will tell you that the types underlined by the red squiggly lines
    do not implement `IDisposable` and therefore can't be supplied to the `PerformAction`
    generic class.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio会告诉您，红色波浪线下划线的类型没有实现`IDisposable`，因此无法提供给`PerformAction`泛型类。
- en: 'Comment out those lines of code and add the following instantiation to your
    console application:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉这些代码行，并将以下实例化添加到您的控制台应用程序中：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that for this to work, you might need to add `using System.Data;` to your
    code file. This is needed so that you can declare a `DataSet`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了使其工作，您可能需要在代码文件中添加`using System.Data;`。这是必需的，这样您就可以声明一个`DataSet`。
- en: As you might know, a `DataSet` type implements `IDisposable` and therefore it
    is a valid type to pass to our generic class. Go ahead and run the console application:![](img/B06434_02_17.png)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能知道，`DataSet`类型实现了`IDisposable`，因此它是可以传递给我们的泛型类的有效类型。继续运行控制台应用程序：![](img/B06434_02_17.png)
- en: The `DataSet` type is valid, and the generic class performs as expected, identifying
    the type of the parameter passed to the constructor.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataSet`类型是有效的，泛型类按预期运行，识别传递给构造函数的参数的类型。'
- en: 'But what about generic methods? Well, just like generic classes, generic methods
    also do not specify their type at design time. It is only known when the method
    is called. Let''s take a look at the following implementation of the generic methods:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 但是泛型方法呢？就像泛型类一样，泛型方法在设计时也不指定其类型。只有在调用方法时才知道。让我们来看看泛型方法的以下实现：
- en: 'Let''s go ahead and create a new helper class called `MyHelperClass`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续创建一个名为`MyHelperClass`的新辅助类：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Inside this helper class, we will create a generic method called `InspectType`.
    What is interesting about this generic method is that it can return multiple types
    because the return type is also marked with the generic type parameter. Your generic
    method does not have to return anything. It can also be declared as `void`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个辅助类中，我们将创建一个名为`InspectType`的泛型方法。这个泛型方法有趣的地方在于它可以返回多种类型，因为返回类型也标记了泛型类型参数。您的泛型方法不一定要返回任何东西。它也可以声明为`void`：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To illustrate that this generic method can return multiple types, we will output
    the type passed to the generic method to the console window and then return that
    type and display it in the console application. You will notice that you need
    to cast the return type as `(T)` when returning it:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了说明这个泛型方法可以返回多种类型，我们将把传递给泛型方法的类型输出到控制台窗口，然后返回该类型并在控制台应用程序中显示它。您会注意到在返回时需要将返回类型强制转换为`(T)`：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the console application, go ahead and create an enumerator called `MyEnum`.
    The generic method can also accept enumerators:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，继续创建一个名为`MyEnum`的枚举器。泛型方法也可以接受枚举器：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After creating the enumerator, add the following code to the console application.
    We are instantiating and calling the `oHelper` class and passing different values
    to it:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建枚举器后，将以下代码添加到控制台应用程序。我们正在实例化和调用`oHelper`类，并向其传递不同的值：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you run the console application, you will see that the generic method correctly
    identifies the type of the parameter passed to it and then returns that type to
    the calling code in the console application:![](img/B06434_02_18.png)
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果运行控制台应用程序，您将看到泛型方法正确地识别了传递给它的参数的类型，然后将该类型返回给控制台应用程序中的调用代码：![](img/B06434_02_18.png)
- en: Generic methods can be used in a multitude of situations. This is, however,
    only an introduction to generic classes and methods. It is recommended that you
    do further research to learn how to implement generics in your code appropriately.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型方法可以在多种情况下使用。然而，这只是对泛型类和方法的介绍。建议您进行进一步的研究，以了解如何适当地在代码中实现泛型。
- en: How it works...
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: At the heart of generics lies the ability to reuse a single class or method.
    It allows developers to essentially not repeat similar code throughout your code
    base. This conforms well to the **Don't Repeat Yourself** (**DRY**) principle.
    This design principle states that a specific bit of logic should be represented
    in code only once.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型的核心是能够重用单个类或方法。它允许开发人员在整个代码库中基本上不重复相似的代码。这与**不要重复自己**（**DRY**）原则非常符合。这个设计原则规定特定的逻辑应该在代码中只表示一次。
- en: Using generic classes, for example, also allows developers to create a class
    that is type safe when compiling. Type safe basically means that the developer
    can be assured of the type of the object and can use the class in a specific way
    without experiencing any unexpected behavior. Therefore, the compiler takes over
    the burden of type safety.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用泛型类还允许开发人员在编译时创建类型安全的类。类型安全基本上意味着开发人员可以确保对象的类型，并且可以以特定的方式使用类，而不会遇到任何意外的行为。因此，编译器承担了类型安全的负担。
- en: Generics also allow developers to write less code, because code can be reused
    and less code also performs better.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型还允许开发人员编写更少的代码，因为代码可以被重用，而且更少的代码也能更好地执行。
- en: Creating and using a generic interface
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和使用通用接口
- en: Generic interfaces work in much the same way as the previous examples in generics.
    Let's assume that we want to find the properties of certain classes in our code,
    but we can't be sure how many classes we will need to inspect. A generic interface
    could come in very handy here.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型接口的工作方式与泛型中的先前示例非常相似。假设我们想要在我们的代码中找到某些类的属性，但我们不能确定我们需要检查多少个类。泛型接口在这里会非常方便。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to inspect several classes for their properties. To do this, we will
    create a generic interface that will return a list of all the properties found
    for a class as a list of strings.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要检查几个类的属性。为了做到这一点，我们将创建一个通用接口，它将返回一个类的所有属性作为字符串列表。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s take a look at the following implementation of the generic interface
    as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下通用接口的实现：
- en: 'Go ahead and create a generic interface called `IListClassProperties<T>`. The
    interface will define a method that needs to be used called `GetPropertyList()`
    that simply uses a LINQ query to return a `List<string>` object:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续创建一个名为`IListClassProperties<T>`的通用接口。该接口将定义一个需要使用的方法`GetPropertyList()`，它简单地使用LINQ查询返回一个`List<string>`对象：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, create a generic class called `InspectClass<T>`. Let the generic class
    implement the `IListClassProperties<T>` interface created in the previous step:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`InspectClass<T>`的通用类。让这个通用类实现上一步创建的`IListClassProperties<T>`接口：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As usual, Visual Studio will highlight that the interface member `GetPropertyList()`
    has not been implemented in the `InspectClass<T>` generic class:![](img/B06434_02_19.png)
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常情况下，Visual Studio会突出显示`InspectClass<T>`通用类中未实现`GetPropertyList()`接口成员的情况：![](img/B06434_02_19.png)
- en: To show any potential fixes, type *Ctrl* + *.* (period) and implement the interface
    implicitly:![](img/B06434_02_20.png)
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了显示任何潜在的修复，键入*Ctrl* + *.*（句号）并隐式实现接口：![](img/B06434_02_20.png)
- en: 'This will create the `GetPropertyList()` method in your `InspectClass<T>` class
    without any implementation. You will add the implementation in a moment. If you
    try to run your code without adding any implementation to the `GetpropertyList()`
    method, the compiler will throw `NotImplementedException`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在你的`InspectClass<T>`类中创建一个没有任何实现的`GetPropertyList()`方法。你将在稍后添加实现。如果你尝试在`GetpropertyList()`方法中没有添加任何实现的情况下运行你的代码，编译器将抛出`NotImplementedException`：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, add a constructor to your `InspectClass<T>` class that takes a generic
    type parameter and sets it equal to a private variable `_classToInspect` that
    you also need to create. This is setting up the code that we will use to instantiate
    out class. We will pass to the object we need a list of properties from the constructor,
    and the constructor will set the private variable `_classToInspect` so that we
    can use it in our `GetPropertyList()` method implementation:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在你的`InspectClass<T>`类中添加一个构造函数，它接受一个泛型类型参数，并将其设置为一个私有变量`_classToInspect`，你也需要创建这个变量。这是为了设置我们将用来实例化类的代码。我们将通过构造函数传递我们需要从中获取属性列表的对象，并且构造函数将设置私有变量`_classToInspect`，以便我们可以在我们的`GetPropertyList()`方法实现中使用它：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To finish off our class, we need to add some implementation to the `GetPropertyList()`
    method. It is here that the LINQ query will be used to return a `List<string>`
    object of all the properties contained in the class supplied to the constructor:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的类，我们需要向`GetPropertyList()`方法添加一些实现。在这里，LINQ查询将被用来返回一个包含在构造函数中提供的类中的所有属性的`List<string>`对象：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Moving to our console application, go ahead and create a simple class called
    `Invoice`. This is one of several classes that can be used in the system, and
    the `Invoice` class is one of the smaller classes. It usually just holds invoice
    data specific to a record in the invoices records of the data store you connect
    to. We need to find a list of the properties in this class:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到我们的控制台应用程序，继续创建一个名为`Invoice`的简单类。这是系统中可以使用的几个类之一，而`Invoice`类是较小的类之一。它通常只保存与你连接的数据存储的发票记录中特定记录相关的发票数据。我们需要找到这个类中的属性列表：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can now make use of our `InspectClass<T>` generic class that implements
    the `IListClassProperties<T>` generic interface. To do this, we will create a
    new instance of the `Invoice` class. We will then instantiate the `InspectClass<T>`
    class, passing the type in the angle brackets and the `oInvoice` object to the
    constructor. We are now ready to call the `GetPropertyList()` method. The result
    is returned to a `List<string>` object called `lstProps`. We can then run `foreach`
    on the list, writing the value of each `property` variable to the console window:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用实现`IListClassProperties<T>`泛型接口的`InspectClass<T>`泛型类。为此，我们将创建`Invoice`类的新实例。然后实例化`InspectClass<T>`类，将类型传递到尖括号中，并将`oInvoice`对象传递给构造函数。现在我们准备调用`GetPropertyList()`方法。结果返回到名为`lstProps`的`List<string>`对象。然后我们可以在列表上运行`foreach`，将每个`property`变量的值写入控制台窗口：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Go ahead and run the code to see the output generated by inspecting the properties
    of the `Invoice` class:![](img/B06434_02_21.png)
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续运行代码，查看检查`Invoice`类属性生成的输出！[](img/B06434_02_21.png)
- en: As you can see, the properties are listed as they exist in the `Invoice` class.
    The `IListClassProperties<T>` generic interface and the `InspectClass<T>` class
    don't care what type of class they need to inspect. They will take any class and
    run the code on it and produce a result.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，属性按照它们在`Invoice`类中的存在顺序列出。`IListClassProperties<T>`泛型接口和`InspectClass<T>`类不关心它们需要检查的类的类型。它们将接受任何类并运行代码，并产生结果。
- en: 'However, the preceding implementation still poses a slight problem. Let''s
    take a look at one of the variations of this problem:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，上述实现仍然存在轻微问题。让我们看看这个问题的一个变化：
- en: 'Consider the following code in the console application:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑在控制台应用程序中的以下代码：
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can see that we have easily passed an integer value and type to the `InspectClass<T>`
    class, and the code does not show any warnings at all. In fact, if you ran this
    code, nothing would be returned and nothing outputs to the console window. What
    we need to do is implement the constraints on our generic class and interface.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们很容易地将整数值和类型传递给`InspectClass<T>`类，代码根本没有显示任何警告。实际上，如果您运行此代码，将不会返回任何内容，也不会输出到控制台窗口。我们需要在我们的泛型类和接口上实现约束。
- en: 'At the end of the interface implementation after the class, add the `where
    T : class` clause. The code now needs to look like this:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在类的接口实现结束后，添加`where T : class`子句。现在代码需要看起来像这样：'
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If we returned to our console application code, you will see that Visual Studio
    has underlined the `int` type passed to the `InspectClass<T>` class:![](img/B06434_02_22.png)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们返回到我们的控制台应用程序代码，您会看到Visual Studio已经在传递给`InspectClass<T>`类的`int`类型下划线标记了：![](img/B06434_02_22.png)
- en: The reason for this is because we defined a constraint against our generic class
    and interface. We told the compiler that we only accept reference types. Therefore,
    this applies to any class, interface array, type, or delegate. Our `Invoice` class
    will therefore be a valid type, and the constraint will not apply to it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们对我们的泛型类和接口定义了一个约束。我们告诉编译器我们只接受引用类型。因此，这适用于任何类、接口数组、类型或委托。因此，我们的`Invoice`类将是一个有效的类型，约束不会适用于它。
- en: 'We can also be more specific in our type parameter constraints. The reason
    for this is that we perhaps do not want to constrain the parameters to reference
    types. If we, for example, wanted to button down the generic class and interface
    to only accept classes created inside our current system, we can implement a constraint
    that the argument for `T` needs to be derived from a specific object. Here, we
    can use abstract classes again:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在类型参数约束中更加具体。这是因为我们可能不希望将参数限制为引用类型。例如，如果我们只想将泛型类和接口限制为只接受在我们当前系统中创建的类，我们可以实现`T`的参数需要从特定对象派生的约束。在这里，我们可以再次使用抽象类：
- en: 'Create an abstract class called `AcmeObject` and specify that all classes that
    inherit from `AcmeObject` implement a property called `ID`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AcmeObject`的抽象类，并指定从`AcmeObject`继承的所有类都实现一个名为`ID`的属性：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can now ensure that objects we create in our code which we need to read
    the properties from are derived from `AcmeObject`. To apply the constraint, modify
    the generic class and place the `where T : AcmeObject` constraint after the interface
    implementation. Your code should now look like this:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在我们可以确保我们在代码中创建的需要从中读取属性的对象是从`AcmeObject`派生的。要应用约束，修改泛型类，并在接口实现后放置`where T
    : AcmeObject`约束。您的代码现在应该看起来像这样：'
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the console application, modify the `Invoice` class to inherit from the
    `AcmeObject` abstract class. Implement the `ID` property as defined in the abstract
    class:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，修改`Invoice`类，使其继承自`AcmeObject`抽象类。根据抽象类中定义的实现`ID`属性：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create two more classes called `SalesOrder` and `CreditNote`. This time, however,
    only make the `SalesOrder` class inherit from `AcmeObject`. Leave the `CreditNote`
    object as is. This is so that we can clearly see how the constraint can be applied:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个名为`SalesOrder`和`CreditNote`的类。但这次，只让`SalesOrder`类继承自`AcmeObject`。保持`CreditNote`对象不变。这样我们可以清楚地看到约束如何应用：
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create the code needed to get the property list for the `Invoice` and `SalesOrder`
    classes. The code is straightforward, and we can see that Visual Studio does not
    complain about either of these two classes:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建获取`Invoice`和`SalesOrder`类的属性列表所需的代码。代码很简单，我们可以看到Visual Studio对这两个类都没有抱怨：
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If, however, we had to try do the same for our `CreditNote` class, we will see
    that Visual Studio will warn us that we can't pass the `CreditNote` class to the
    `InspectClass<T>` class because the constraint we implemented only accepts objects
    that derive from our `AcmeObject` abstract class. By doing this, we have effectively
    taken control over exactly what we allow to be passed to our generic class and
    interface by means of constraints:![](img/B06434_02_23.png)
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，如果我们试图对我们的`CreditNote`类做同样的事情，我们会发现Visual Studio会警告我们不能将`CreditNote`类传递给`InspectClass<T>`类，因为我们实现的约束只接受从我们的`AcmeObject`抽象类派生的对象。通过这样做，我们有效地控制了允许传递给我们的泛型类和接口的内容，通过约束的方式！
- en: How it works...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Speaking of generic interfaces, we have seen that we can implement behavior
    on a generic class by implementing a generic interface. The power of using the
    generic class and generic interface is well illustrated earlier.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 说到泛型接口，我们已经看到我们可以通过实现泛型接口在泛型类上实现行为。使用泛型类和泛型接口的强大之处在前面已经很好地说明了。
- en: Having said that, we do believe that knowing when to use constraints is also
    important so that you can close down your generic classes to only accept specific
    types that you want. This ensures that you don't get any surprises when someone
    accidentally passes an integer to your generic class.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们确实认为知道何时使用约束也很重要，这样您就可以关闭泛型类，只接受您想要的特定类型。这确保了当有人意外地将整数传递给您的泛型类时，您不会受到任何意外。
- en: 'Finally, the constraints that you can use are as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用的约束如下：
- en: '`where T: struct`: The type argument must be any value types'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`where T: struct`: 类型参数必须是任何值类型'
- en: '`where T: class`: The type argument must be any reference types'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`where T: class`: 类型参数必须是任何引用类型'
- en: '`where T: new()`: The type argument needs to have a parameterless constructor'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`where T: new()`: 类型参数需要有一个无参数的构造函数'
- en: '`where T: <base class name>`: The type argument must derive from the given
    base class'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`where T: <base class name>`: 类型参数必须从给定的基类派生'
- en: '`where T: <T must derive from object>`: `T` The type arg was must derive must
    derive from the object after the colon'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`where T: <T must derive from object>`: `T`类型参数必须从冒号后的对象派生'
- en: '`where T: <interface>`: The type argument must implement the interface specified'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`where T: <interface>`: 类型参数必须实现指定的接口'
