- en: Day 07 - Understanding Object-Oriented Programming with C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7天 - 用C#理解面向对象编程
- en: Today we are on day seven of our seven-day learning series. Yesterday (day six),
    we went through a few advanced topics and we discussed attributes, generics, and
    LINQ. Today, we will start learning **object-oriented programming** (**OOP**)
    using C#.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 今天是我们七天学习系列的第七天。昨天（第六天），我们学习了一些高级主题，讨论了属性、泛型和LINQ。今天，我们将开始学习使用C#的面向对象编程（OOP）。
- en: This will be a practical approach to OOP, while covering all the aspects. You
    will benefit even without having any basic knowledge of OOP and move on to confidently
    practicing this easily in the workplace.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个实际的面向对象编程方法，同时涵盖所有方面。即使没有任何面向对象编程的基础知识，您也将受益，并且可以自信地在工作场所轻松地进行实践。
- en: 'We will be covering these topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Introduction to OOP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程介绍
- en: Discussing object relationships
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论对象关系
- en: Encapsulation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Abstraction
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象
- en: Inheritance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Polymorphism
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态
- en: Introduction to OOP
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程介绍
- en: OOP is one of the programming paradigms that is purely based on objects. These
    objects contain data (please refer to day seven for more details).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: OOP是纯粹基于对象的编程范式之一。这些对象包含数据（请参考第七天了解更多细节）。
- en: When we do the classification of programming languages it is called programming
    paradigm. For more information refer to [https://en.wikipedia.org/wiki/Programming_paradigm](https://en.wikipedia.org/wiki/Programming_paradigm).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对编程语言进行分类时，称之为编程范式。有关更多信息，请参阅[https://en.wikipedia.org/wiki/Programming_paradigm](https://en.wikipedia.org/wiki/Programming_paradigm)。
- en: OOP has come into consideration to overcome the limitations of earlier programming
    approaches (consider the procedural language approach).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: OOP已经被考虑来克服早期编程方法的局限性（考虑过程语言方法）。
- en: 'Generally, I define OOP as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我将OOP定义如下：
- en: '*A modern programming language in which we use objects as building blocks to
    develop applications.*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*一种现代编程语言，我们使用对象作为构建应用程序的基本组件。*'
- en: 'There are a lot of examples of objects in our surroundings and in the real
    world, we have various aspects that are the representation of objects. Let us
    go back to our programming world and think about a program that is defined as
    follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们周围有很多对象的例子，在现实世界中，我们有各种方面是对象的代表。让我们回到我们的编程世界，思考一个定义如下的程序：
- en: '*A program is a list of instructions that instructs the language compiler on
    what to do.*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*程序是一系列指令，指示语言编译器要做什么。*'
- en: To understand OOP more closely, we should know about earlier programming approaches,
    mainly procedural programming, structured programming, and so on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地理解OOP，我们应该了解早期的编程方法，主要是过程式编程、结构化编程等。
- en: '**Structured programming**: This is a term coined by Edsger W. Dijkstra in
    1966\. Structured programming is a programming paradigm that solves a problem
    to handle 1000 lines of code and divides these into small parts. These small parts
    are mostly called subroutine, block structures, `for` and `while` loops, and so
    on. Known languages that use structured programming techniques are ALGOL, Pascal,
    PL/I, and so on.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化编程：这是由艾兹格·W·迪科斯特拉在1966年创造的一个术语。结构化编程是一种编程范式，用于解决处理1000行代码并将其分成小部分的问题。这些小部分通常被称为子例程、块结构、`for`和`while`循环等。使用结构化编程技术的已知语言包括ALGOL、Pascal、PL/I等。
- en: '**Procedural programming**: A paradigm derived from structured programming
    and simply based on how we make a call (known as a procedural call). Known languages
    that use procedural programming techniques are COBOL, Pascal, C. A recent example
    of the Go programming language was published in 2009.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过程式编程：这是从结构化编程派生出来的一种范式，简单地基于我们如何进行调用（称为过程调用）。使用过程式编程技术的已知语言包括COBOL、Pascal、C。Go编程语言的一个最新例子于2009年发布。
- en: 'The main problem with these two approaches is that programs are not well manageable
    once they grow. Programs with more complex and large code bases make these two
    approaches strained. In short, the maintainability of the code is tedious with
    the use of these two approaches. To overcome such problems now, we have OOP, which
    has the following features:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法的主要问题是，一旦程序增长，程序就变得难以管理。具有更复杂和庞大代码库的程序使这两种方法变得紧张。简而言之，使用这两种方法会使代码的可维护性变得繁琐。为了克服这些问题，现在我们有了OOP，它具有以下特点：
- en: Inheritance
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Encapsulation
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Polymorphism
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态
- en: Abstraction
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象
- en: Discussing Object relations
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论对象关系
- en: 'Before we start our discussion on OOP, first we should understand relationships.
    In the real world, objects have relationships between them and hierarchies as
    well. There are the following types of relationships in object-oriented programming:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论OOP之前，首先我们应该了解关系。在现实世界中，对象之间有关系，也有层次结构。面向对象编程中有以下类型的关系：
- en: '**Association**: Association represents a relationship between objects in a
    manner that all objects have their own life cycle. In association, there is no
    owner of these objects. For example, a person in a meeting. Here, the person and
    the meeting are independent; there is no parent of them. A person can have multiple
    meetings and a meeting can combine multiple persons. The meeting and persons are
    both independently initialized and destroyed.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联：关联表示对象之间的关系，所有对象都有自己的生命周期。在关联中，这些对象没有所有者。例如，会议中的人。在这里，人和会议是独立的；它们没有父级。一个人可以参加多个会议，一个会议可以组合多个人。会议和人都是独立初始化和销毁的。
- en: Aggregation and composition are both types of association.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合和组合都是关联的类型。
- en: '**Aggregation**: Aggregation is a specialized form of association. Similar
    to association, objects have their own life cycle in aggregations, but it involves
    ownership that means a child object cannot belong to another parent object. Aggregation
    is a one-way relationship where the lives of objects are independent from each
    other. For example, the child and parent relationship is an aggregation, because
    every child has parent but it''s not necessary that every parent has child.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合**：聚合是一种特殊形式的关联。与关联类似，对象在聚合中有自己的生命周期，但它涉及所有权，这意味着子对象不能属于另一个父对象。聚合是一种单向关系，对象的生命周期彼此独立。例如，子对象和父对象的关系是一种聚合，因为每个子对象都有父对象，但并不是每个父对象都有子对象。'
- en: '**Composition**: Composition is a relationship of *death* that represents the
    relationship between two objects and one object (child) depends on another object
    (parent). If the parent object is deleted, all its children automatically get
    deleted. For example, a house and a room. One house has multiple rooms. But a
    single room cannot belong to multiple houses. If we demolished the house, the
    room would automatically delete.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**：组合是一种*死亡*关系，表示两个对象之间的关系，一个对象（子对象）依赖于另一个对象（父对象）。如果父对象被删除，所有的子对象都会自动被删除。例如，一个房子和一个房间。一个房子有多个房间。但一个房间不能属于多个房子。如果我们拆毁了房子，房间会自动删除。'
- en: In the coming sections, we will discuss all features of OOP in detail. Also,
    we will understand implementing these features using C#.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将详细讨论面向对象编程的所有特性。此外，我们将了解如何使用C#实现这些特性。
- en: Inheritance
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: Inheritance is one of the most important features/concepts of OOP. It is self-explanatory
    in name; inheritance inherits features from a class. In simple words, inheritance
    is an activity performed at compile-time as instructed with the help of the syntax.
    The class that inherits another class is known as the child or derived class,
    and the class which is being inherited is known as the base or parent class. Here,
    derived classes inherit all the features of base classes either to implement or
    to override.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是面向对象编程中最重要的特性/概念之一。它在名称上是不言自明的；继承从一个类继承特性。简而言之，继承是一个在编译时执行的活动，通过语法的帮助进行指示。继承另一个类的类称为子类或派生类，被继承的类称为基类或父类。在这里，派生类继承基类的所有特性，无论是实现还是重写。
- en: In the coming sections, we will discuss inheritance in detail with code examples
    using C#.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将使用C#的代码示例详细讨论继承。
- en: Understanding inheritance
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解继承
- en: Inheritance as a feature of OOP helps you to define a child class. This child
    class inherits the behavior of the parent or base class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 继承作为面向对象编程的一个特性，帮助您定义一个子类。这个子类继承了父类或基类的行为。
- en: Inheriting a class means reusing the class. In C#, inheritance is symbolically
    defined using the colon (*:*) sign.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 继承一个类意味着重用这个类。在C#中，继承是用冒号（*:*）符号来象征性地定义的。
- en: 'The modifier (refer to [Chapter 2](part0032.html#UGI00-cd07d0bec7404d1cb3fdb41e48e5618f),
    *Day 02 - Getting Started with C#*) tells us what the scope of the reuse of the
    base class for derived classes is. For instance, consider that class *B* inherits
    class *A.* Here, class *B* contains all the features of class *A* including its
    own features. Refer the following diagram:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符（参考[第2章](part0032.html#UGI00-cd07d0bec7404d1cb3fdb41e48e5618f)，*第02天-开始使用C#*）告诉我们基类对派生类的重用范围。例如，考虑类*B*继承类*A*。在这里，类*B*包含类*A的所有特性，包括它自己的特性。请参考以下图表：
- en: '![](img/00102.gif)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00102.gif)'
- en: In the preceding figure, the derived class (that is, *B*) inherits all the features
    by ignoring modifiers. Features are inherited whether these are public or private.
    These modifiers come in to consideration when these features are going to be implemented.
    At the time of implementation only public features are considered. So, here, public
    features, that is, *A*, *B*, and *C* will be implemented but private features,
    that is, *B,* will not be implemented.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，派生类（即*B*）通过忽略修饰符继承了所有特性。特性的继承无论是公共的还是私有的。这些修饰符在这些特性要被实现时才会考虑。在实现时只有公共特性才会被考虑。所以，在这里，公共特性，即*A*、*B*和*C*将被实现，但私有特性，即*B*将不会被实现。
- en: Types of inheritance
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承的类型
- en: 'Up until this point, we have got the idea about inheritance. Now, it''s time
    to discuss inheritance types; inheritance is of the following types:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 直到这一点，我们已经了解了继承的概念。现在，是时候讨论继承的类型了；继承有以下几种类型：
- en: '**Single inheritance:**'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一继承：**'
- en: This is a widely used type of inheritance. Single inheritance is when a class
    inherits another class. A class that inherits another class is called a child
    class and the class which is being inherited is called a parent or base class.
    In the child class, the class inherits features from one parent class only.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种广泛使用的继承类型。单一继承是指一个类继承另一个类。继承另一个类的类称为子类，被继承的类称为父类或基类。在子类中，类只从一个父类继承特性。
- en: C# only supports single inheritance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: C#只支持单一继承。
- en: 'You can inherit classes hierarchically (as we will see in the following section),
    but that is a single inheritance in nature for a derived class. Refer the following
    diagram:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您可以按层次继承类（正如我们将在下一节中看到的），但这是派生类的自然单一继承。请参考以下图表：
- en: '![](img/00103.gif)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00103.gif)'
- en: The preceding diagram is a representation of a single inheritance that shows
    *Class B* (inherited class) inheriting *Class A* (base class). *Class B* can reuse
    all features that is, *A*, *B*, and *C,* including its own feature, that is, D.
    Visibility or reusability of members in inheritance depends on the protection
    levels (this will be discussed in the coming section, *Member visibility in inheritance*).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表是单一继承的表示，显示*Class B*（继承类）继承*Class A*（基类）。*Class B*可以重用所有特性，即*A*、*B*和*C*，包括它自己的特性，即D。继承中成员的可见性或可重用性取决于保护级别（这将在接下来的部分“继承中的成员可见性”中讨论）。
- en: '**Multiple inheritance:**'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多重继承：**'
- en: 'Multiple inheritance happens when a derived class inherits multiple base classes.
    Languages such as C++ support multiple inheritance. C# does not support multiple
    inheritance, but we can achieve multiple inheritance with the help of interfaces.
    If you are curious to know that why C# does not support multiple inheritance,
    refer to this official link at [https://blogs.msdn.microsoft.com/csharpfaq/2004/03/07/why-doesnt-c-support-multiple-inheritance/](https://blogs.msdn.microsoft.com/csharpfaq/2004/03/07/why-doesnt-c-support-multiple-inheritance/).
    Refer to the following diagram:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承发生在派生类继承多个基类时。诸如C++之类的语言支持多重继承。C#不支持多重继承，但我们可以借助接口实现多重继承。如果您想知道为什么C#不支持多重继承，请参考官方链接[https://blogs.msdn.microsoft.com/csharpfaq/2004/03/07/why-doesnt-c-support-multiple-inheritance/](https://blogs.msdn.microsoft.com/csharpfaq/2004/03/07/why-doesnt-c-support-multiple-inheritance/)。参考以下图表：
- en: '![](img/00104.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00104.jpeg)'
- en: The preceding diagram is a representation of multiple inheritance (not possible
    in C# without the help of interfaces), which shows that *Class C* (derived class)
    inherits from two base classes (*A* and *B*). In multiple inheritance, the derived
    *Class C* will have all the features of both *Class A* and *Class B*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表是多重继承的表示（在没有接口帮助的情况下在C#中不可能），显示了*Class C*（派生类）从两个基类（*A*和*B*）继承。在多重继承中，派生的*Class
    C*将拥有*Class A*和*Class B*的所有特性。
- en: '**Hierarchical inheritance:**'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层次继承：**'
- en: 'Hierarchical inheritance happens when more than one class inherits from one
    class. Refer to the following diagram:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当超过一个类从一个类继承时，层次继承发生。参考以下图表：
- en: '![](img/00105.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00105.jpeg)'
- en: In the preceding diagram, *Class B* (derived class) and *Class C* (derived class)
    inherit from *Class A* (base class). With the help of hierarchical inheritance,
    *Class B* can use all the features of *Class A*. Similarly, *Class C* can also
    use all the features of *Class A*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，*Class B*（派生类）和*Class C*（派生类）从*Class A*（基类）继承。借助层次继承，*Class B*可以使用*Class
    A*的所有特性。同样，*Class C*也可以使用*Class A*的所有特性。
- en: '**Multilevel inheritance:**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多级继承：**'
- en: When a class is derived from a class that is already a derived class, it is
    called multilevel inheritance.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类从已经是派生类的类派生时，称为多级继承。
- en: In multi-level inheritance, the recently derived class owns the features of
    all the earlier derived classes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在多级继承中，最近派生的类拥有所有先前派生类的特性。
- en: 'In this, a derived class can have its parent and a parent of the parent class.
    Refer to the following diagram:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，派生类可以有其父类和父类的父类。参考以下图表：
- en: '![](img/00106.gif)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00106.gif)'
- en: The preceding diagram represents multilevel inheritance and shows that *Class
    C* (recently derived class) can reuse all the features of *Class B* and *Class
    A*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表表示多级继承，并显示*Class C*（最近派生的类）可以重用*Class B*和*Class A*的所有特性。
- en: '**Hybrid inheritance:**'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合继承：**'
- en: Hybrid inheritance is a combination of more than one inheritance.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 混合继承是多重继承的组合。
- en: C# does not support hybrid inheritance.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: C#不支持混合继承。
- en: 'Combination of multiple and multilevel inheritance is a hierarchical inheritance,
    where a parent class is a derived class and a recently derived class inherits
    multiple parent classes. There can be more combinations. Refer to the following
    diagram:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 多重和多级继承的组合是层次继承，其中一个父类是一个派生类，最近派生的类继承多个父类。还可以有更多的组合。参考以下图表：
- en: '![](img/00107.gif)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00107.gif)'
- en: The preceding image, representing hybrid inheritance, shows the combination
    hierarchical and multiple inheritance. You can see that *Class A* is a parent
    class and all the other classes are derived from *Class A,* directly or indirectly.
    Our derived *Class E* can reuse all the features of Class *A*, *B*, *C,* and *D*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像代表混合继承，显示了层次和多重继承的组合。您可以看到*Class A*是一个父类，所有其他类都直接或间接地从*Class A*派生而来。我们的派生*Class
    E*可以重用*Class A*、*B*、*C*和*D*类的所有特性。
- en: '**Implicit inheritance:**'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式继承：**'
- en: All the types in .NET implicitly inherit from `system.object` or its derived
    classes. For more information on implicit inheritance, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/inheritance#implicit-inheritance](https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/inheritance#implicit-inheritance).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中的所有类型都隐式继承自`system.object`或其派生类。有关隐式继承的更多信息，请参考[https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/inheritance#implicit-inheritance](https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/inheritance#implicit-inheritance)。
- en: Member visibility in inheritance
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承中的成员可见性
- en: As we discussed earlier, in inheritance, derived classes can reuse the functionality
    of the parent class and use or modify the members of its parent class. But these
    members can be reused or modified as per their access modifier or visibility (for
    more details refer to [Chapter 4](part0119.html#3HFIU0-cd07d0bec7404d1cb3fdb41e48e5618f),
    *Day 04 - Discussing C# Class Members*).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，在继承中，派生类可以重用父类的功能并使用或修改其父类的成员。但是这些成员可以根据其访问修饰符或可见性进行重用或修改（有关更多详细信息，请参阅[第4章](part0119.html#3HFIU0-cd07d0bec7404d1cb3fdb41e48e5618f)，*第04天
    - 讨论C#类成员*）。
- en: 'In this section, we will briefly discuss member visibility in inheritance.
    In any type of inheritance (that is possible in C# language) the following members
    cannot be inherited by base classes:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要讨论继承中的成员可见性。在C#语言中可能的任何类型的继承中，以下成员不能被基类继承：
- en: '**Static constructors**: A static constructor is one that initializes the static
    data (refer to the *Modifier* section of [Chapter 4](part0119.html#3HFIU0-cd07d0bec7404d1cb3fdb41e48e5618f),
    *Day 04: Discussing C# Class Members*). The importance of static constructors
    is that these are called before the creation of the first instance of a class
    or any other static members called or referred to in some operations. Being a
    static data initializer, a static constructor cannot be inherited by a derived
    class.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态构造函数：静态构造函数是初始化静态数据的构造函数（参考[第4章](part0119.html#3HFIU0-cd07d0bec7404d1cb3fdb41e48e5618f)，*第4天：讨论C#类成员*中的*修饰符*部分）。静态构造函数的重要性在于，在创建类的第一个实例或在某些操作中调用或引用其他静态成员之前调用这些构造函数。作为静态数据初始化程序，静态构造函数不能被派生类继承。
- en: '**Instance constructor**: It is not a static constructor; whenever you create
    a new instance of a class, a constructor is called, which is the instance class.
    A class can have multiple constructors. As the instance constructor is used to
    create an instance of a class, it is not inherited by the derived class. For more
    information on constructors, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例构造函数**：这不是静态构造函数；每当创建类的新实例时，都会调用构造函数，即实例类。一个类可以有多个构造函数。由于实例构造函数用于创建类的实例，因此不能被派生类继承。有关构造函数的更多信息，请参阅[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors)。'
- en: '**Finalizers**: These are just destructors of classes. These are used or called
    by garbage collectors at runtime to destroy the instances of a class. As finalizers
    are called only once and are per class, these cannot be inherited by a derived
    class. For more information on destructors or finalizers, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/destructors](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/destructors).'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Finalizers**：这些只是类的析构函数。这些在运行时由垃圾收集器调用或使用来销毁类的实例。由于析构函数只调用一次且每个类只有一个，因此不能被派生类继承。有关析构函数的更多信息，请参阅[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/destructors](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/destructors)。'
- en: 'Derived classes can reuse or inherit all the members of the base class, but
    their usage or visibility depends upon their access modifiers (refer to [Chapter
    4](part0119.html#3HFIU0-cd07d0bec7404d1cb3fdb41e48e5618f), *Day 04 - Discussing
    C# Class Members*). Different visibility of these members depends upon the following
    accessibility modifiers:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类可以重用或继承基类的所有成员，但其使用或可见性取决于其访问修饰符（参考[第4章](part0119.html#3HFIU0-cd07d0bec7404d1cb3fdb41e48e5618f)，*第4天
    - 讨论C#类成员*）。这些成员的不同可见性取决于以下可访问性修饰符：
- en: '**Private**: If a member is `private`, the visibility of a `private` member
    is restricted to its derived class; `private` members are available in derived
    classes if the derived class nests to its base class.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**：如果成员是`private`，则`private`成员的可见性仅限于其派生类；如果派生类嵌套在其基类中，则派生类中将可用`private`成员。'
- en: 'Consider the following code snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE0]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](img/00108.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00108.jpeg)'
- en: The preceding image shows the visibility of a private method for a derived class.
    The private method is visible in the derived class if the class is nested within
    its base class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像显示了派生类中私有方法的可见性。如果类嵌套在其基类中，则派生类中的私有方法是可见的。
- en: 'If the class is not nested within its parent/base class, then you can see the
    following compile-time exception:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类没有嵌套在其父类/基类中，则可以看到以下编译时异常：
- en: '![](img/00109.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00109.jpeg)'
- en: In the preceding screenshot, we have `ChildClass`, which inherits from `BaseClass`.
    Here, we cannot use private members of `BaseClass` as `ChildClass` is not nested
    within `BaseClass`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们有`ChildClass`，它继承自`BaseClass`。在这里，我们不能使用`BaseClass`的私有成员，因为`ChildClass`没有嵌套在`BaseClass`中。
- en: '**Protected**: If a member is a protected modifier, it is only visible to the
    derived class. These members will not be available or visible while you''re using
    the using the instance of a base class, because these are defined as protected.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护**：如果成员是受保护修饰符，则仅对派生类可见。在使用基类的实例时，这些成员将不可用或不可见，因为它们被定义为受保护。'
- en: 'The following screenshot depicts how a protected member can be accessible/visible
    using the base class:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了如何使用基类访问/可见受保护的成员：
- en: '![](img/00110.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00110.jpeg)'
- en: In the preceding screenshot, the protected member, `EditorName` is visible in
    `ChildClass` because it inherits `BaseClass`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，受保护的成员`EditorName`在`ChildClass`中可见，因为它继承了`BaseClass`。
- en: 'The following screenshot shows that the protected members are not accessible
    using the instance of `BaseClass` in `ChildClass`. If you try to do so, you will
    get a compile-time error:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了使用`BaseClass`实例中不可访问受保护成员的情况。如果尝试这样做，将会收到编译时错误：
- en: '![](img/00111.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00111.jpeg)'
- en: '**Internal**: Members with internal modifiers are only available in the derived
    classes of the same assembly as of the base class. These members can''t be available
    for derived classes that belong to other assemblies.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部**：具有内部修饰符的成员仅在与基类相同程序集的派生类中可用。这些成员对于属于其他程序集的派生类将不可用或不可见。'
- en: 'Consider the following code-snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE1]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code shows the visibility of an internal member. Here, `ChildClass`
    belongs to the `Lib` assembly, which is where `BaseClass` exists.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示了内部成员的可见性。在这里，`ChildClass`属于`Lib`程序集，而`BaseClass`就在其中。
- en: 'On the other hand, if `BaseClass` exists in an assembly other than `Lib`, then
    internal members will not accessible; see the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果`BaseClass`存在于`Lib`之外的程序集中，则内部成员将无法访问；请参阅以下屏幕截图：
- en: '![](img/00112.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00112.jpeg)'
- en: The preceding screenshot shows a compile-time error that tells that the internal
    members are inaccessible, as they are not available in the same assembly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图显示了一个编译时错误，告诉我们内部成员是不可访问的，因为它们在同一个程序集中不可用。
- en: '**Public**: Public members are available or visible in derived classes and
    can be used further.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Public**：公共成员在派生类中可用或可见，并且可以进一步使用。'
- en: 'Consider the following code-snippet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE2]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](img/00113.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00113.jpeg)'
- en: 'In the previous code, you should notice that we added a `new` keyword with
    the `Display()` method of the `ChildClassYounger` class. This is because we have
    a method with the same name in the parent class (that is, `ChildClass`). If we
    don''t add the `new` keyword, we''ll see a compile-time warning, as shown in the
    following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您应该注意到我们在`ChildClassYounger`类的`Display()`方法中添加了一个`new`关键字。这是因为我们在父类（即`ChildClass`）中有一个同名的方法。如果我们不添加`new`关键字，我们将看到一个编译时警告，如下面的截图所示：
- en: '![](img/00114.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00114.jpeg)'
- en: By applying the `new` keyword, you hide the `ChildClass.Display()` member that
    is inherited from `ChildClass`. In C#, this concept is called method hiding.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用`new`关键字，您隐藏了从`ChildClass`继承的`ChildClass.Display()`成员。在C#中，这个概念被称为方法隐藏。
- en: Implementing inheritance
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现继承
- en: In the previous section, you learned about inheritance in detail and went through
    its various types. You also learned inherited member's visibility. In this section,
    we will implement inheritance.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，您详细了解了继承，并了解了继承成员的可见性。在本节中，我们将实现继承。
- en: 'Inheritance is representation of an **IS-A** relation, which suggests that
    `Author` **IS-A** `Person` and `Person` **IS-A** `Human`, so `Author` **IS-A**
    `Human`. Let''s understand this in a code example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是**IS-A**关系的表示，这表明`Author`**IS-A**`Person`，`Person`**IS-A**`Human`，所以`Author`**IS-A**`Human`。让我们在一个代码示例中理解这一点：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we have a base class, `Person` and three derived classes,
    namely `Author`, `Editor`, and `Reviewer`. This shows single inheritance. The
    following is the implementation of the previous code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们有一个基类`Person`和三个派生类，分别是`Author`、`Editor`和`Reviewer`。这显示了单一继承。以下是先前代码的实现：
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, we instantiated a single class and called details; each
    class inherits the `Person` class and, hence, all its members. This produces the
    following output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们实例化了一个单一类并调用了details；每个类都继承了`Person`类，因此，它的所有成员。这产生了以下输出：
- en: '![](img/00115.gif)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00115.gif)'
- en: Implementing multiple inheritance in C#
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#中实现多重继承
- en: We have already discussed in the previous section that C# does not support multiple
    inheritance. But we can achieve multiple inheritance with the help of interfaces
    (refer to [Chapter 2](part0032.html#UGI00-cd07d0bec7404d1cb3fdb41e48e5618f), *Day
    02 – Getting Started with C#*). In this section, we will implement multiple inheritance
    using C#.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前一节中讨论过C#不支持多重继承。但是我们可以借助接口实现多重继承（请参阅[第2章](part0032.html#UGI00-cd07d0bec7404d1cb3fdb41e48e5618f)，*第02天-开始使用C#*）。在本节中，我们将使用C#实现多重继承。
- en: Let's consider the code snippet of the previous section, which implements single
    inheritance. Let's rewrite the code by implementing interfaces.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑前一节的代码片段，该片段实现了单一继承。让我们通过实现接口来重写代码。
- en: Interfaces represent **Has-A**/**Can-Do** relationship, which indicates that
    `Publisher` **Has-A** `Author` and `Author` **Has-A** `Book`. In C#, you can assign
    an instance of a class to any variable that is of the type of the interface or
    the base class. In view of OOP, this concept is referred to as polymorphism (refer
    to the *Polymorphism* section for more details).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接口代表**具有**/**能够做**的关系，这表明`Publisher`**具有**`Author`和`Author`**具有**`Book`。在C#中，您可以将类的实例分配给任何类型为接口或基类的变量。从面向对象的角度来看，这个概念被称为多态性（有关更多细节，请参阅*多态性*部分）。
- en: 'First of all, let''s create an interface:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个接口：
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s implement the `IBook` interface to derive the `Author` class, which
    inherits the `Person` class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现`IBook`接口来派生`Author`类，该类继承了`Person`类：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](img/00116.gif)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00116.gif)'
- en: The preceding image shows the output of the implemented code using interfaces.
    All the members of the interface are accessible to the child class; there is no
    need for special implementation when you are instantiating a child class. The
    instance of a child class is able to access all the visible members. The important
    point in the preceding implementation is in the `((IBook)author).Detail();` statement,
    where we explicitly cast the instance of child class to the interface to get the
    implementation of the interface member. By default, it provides the implementation
    of a class member, so we need explicitly tell the compiler that we need an interface
    method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图像显示了使用接口实现的代码的输出。接口的所有成员对子类都是可访问的；在实例化子类时，不需要特殊实现。子类的实例能够访问所有可见成员。在上述实现中的重要一点是在`((IBook)author).Detail();`语句中，我们显式地将子类的实例转换为接口，以获得接口成员的实现。默认情况下，它提供类成员的实现，因此我们需要明确告诉编译器我们需要一个接口方法。
- en: Abstraction
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象
- en: Abstraction is the process where relevant data is shown by hiding irrelevant
    or unnecessary information. For example, if you purchase a mobile phone, you'd
    not be interested in the process of how your message is delivered or how your
    call connects another number, but you'd be interested to know that whenever you
    press the call button on your phone, it should connect your call. In this example,
    we hide those features that do not interest the user and provide those features
    that interest the user. This process is called abstraction.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象是通过隐藏不相关或不必要的信息来显示相关数据的过程。例如，如果您购买了一部手机，您可能对您的消息是如何传递的或者您的呼叫是如何连接到另一个号码不感兴趣，但您可能会对知道每当您在手机上按下呼叫按钮时，它应该连接您的呼叫感兴趣。在这个例子中，我们隐藏了那些用户不感兴趣的功能，并提供了用户感兴趣的功能。这个过程叫做抽象。
- en: Implementing abstraction
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现抽象
- en: 'In C#, abstraction can be implemented with the use of:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，抽象类可以通过以下方式实现：
- en: Abstract class
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类
- en: Abstract class is half-defined that means it provides a way to override members
    to its child classes. We should use base classes in the project where we need
    have a need same member to all its child classes with own implementations or want
    to override. For an example if we have an abstract class Car with an abstract
    method color and have child classes HondCar, FordCar, MarutiCar etc. in this case
    all child classes would have color member but with different implementation because
    color method would be overridden in the child classes with their own implementations.
    The point to be noted here - abstract classes represent IS-A relation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类是半定义的，这意味着它提供了一种方法来覆盖其子类的成员。我们应该在需要将相同成员提供给所有子类并具有自己实现或想要覆盖的项目中使用基类。例如，如果我们有一个抽象类Car，其中有一个抽象方法color，并且有子类HondCar、FordCar、MarutiCar等。在这种情况下，所有子类都将具有color成员，但具有不同的实现，因为color方法将在子类中被覆盖并具有自己的实现。这里需要注意的一点是
    - 抽象类代表IS-A关系。
- en: You can also revisit our discussion of abstract class during Day04 section 'abstract'
    and code-examples to understand the implementation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在Day04部分“抽象”中重新讨论我们对抽象类的讨论，并查看代码示例以了解实现。
- en: Features of abstract class
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类的特点
- en: 'In previous section we learned about abstract classes, here are the few features
    of abstract class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们了解了抽象类的一些特点：
- en: Abstract class can't be initialized that means, you cannot create an object
    of abstract class.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类不能被初始化，这意味着您不能创建抽象类的对象。
- en: Abstract class is meant to act as a base class so, other classes can inherit
    it.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类旨在充当基类，因此其他类可以继承它。
- en: If you declared an abstract class then by design it must be inherited by other
    classes.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果声明了抽象类，则按设计必须由其他类继承。
- en: An abstract class can have both concrete or abstract methods. Abstrcat methods
    should be implemented in the child class that inherited abstract class.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类可以同时拥有具体方法和抽象方法。抽象方法应该在继承抽象类的子类中实现。
- en: Interface
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: An interface does not contain functionality or concrete members. You can call
    this is a contract for the class or structure that will implement to define the
    signatures of the functionality. With the use of interface, you make sure that
    whenever a class or struct implement it that class or struct is going to use the
    contract of the interface. For an instance if ICalculator interface has method
    Add() that means whenever a class or structure implement this interface it provides
    a specific contractual functionality that is addition.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接口不包含功能或具体成员。您可以称之为类或结构将实现以定义功能签名的合同。通过使用接口，您可以确保每当类或结构实现它时，该类或结构将使用接口的合同。例如，如果ICalculator接口具有Add()方法，这意味着每当类或结构实现此接口时，它都提供了一个特定的合同功能，即加法。
- en: 'For more information on interface, refer: [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/index](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/index)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有关接口的更多信息，请参阅：[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/index](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/index)
- en: 'Interface can only have these members:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接口只能拥有以下成员：
- en: Methods
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法
- en: Properties
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: Indexers
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引器
- en: Events
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Features of interface
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口的特点
- en: Followings are the main features of interfaces
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是接口的主要特点
- en: Interface is internal by default
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口默认为internal
- en: All member of interface is public by default and there is no need to explicitly
    apply public modifier to the members
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口的所有成员默认为public，并且不需要显式应用public修饰符到成员上。
- en: Similarly, to abstract class, interface also cannot be instantiated. They can
    only implement and the class or structure that implement it should implement all
    the members.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，接口也不能被实例化。它们只能实现，并且实现它的类或结构应该实现所有成员。
- en: Interface cannot contain any concrete method
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口不能包含任何具体方法
- en: An interface can be implemented by another interface, a class or struct.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口可以被另一个接口、类或结构实现。
- en: A class or struct can implement multiple interfaces.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类或结构可以实现多个接口。
- en: A class can inherit abstract class or a normal class and implement an interface.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以继承抽象类或普通类并实现接口。
- en: 'In this section, we will implement abstraction using abstract class. Let''s
    consider following code-snippet:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用抽象类来实现抽象。让我们考虑以下代码片段：
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Above code-snippet contains only one public method that is responsible to display
    the operations. Display() method is one that gets the details of author , editor
    and reviewer of a book. At first glance, we can say that above code is with different
    classes of different implementation. But, actually we are abstracting our code
    with the help of abstract class, the child or derived classes then providing the
    details whatever the demand.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段只包含一个负责显示操作的公共方法。Display()方法是获取书籍作者、编辑和评论员详细信息的方法。乍一看，我们可以说上面的代码是不同实现的不同类。但实际上，我们正在使用抽象类来抽象我们的代码，然后派生类提供所需的详细信息。
- en: 'Consider following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE9]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have an abstract class Team with an abstract method GetDetail() this is
    the method that is responsible to get the details of team. Now, think what this
    team include, this team build with Author, Editor and a Reviewer. So, we have
    following code-snippet:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个抽象类Team，其中有一个抽象方法GetDetail()，这个方法负责获取团队的详细信息。现在，想一下这个团队包括什么，这个团队由作者、编辑和评论员组成。因此，我们有以下代码片段：
- en: '[PRE10]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: BookAuthor class inherits Team and override the GetDetail() method. This method
    further call a private method Display() that is something user would not be aware.
    As user will call only GetDetail() method.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: BookAuthor类继承Team并重写GetDetail()方法。该方法进一步调用一个私有方法Display()，这是用户不会意识到的。用户只会调用GetDetail()方法。
- en: 'In similar way, we have BookEditor and BookReviewer classes:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们还有BookEditor和BookReviewer类：
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, classes will only reveal one method, that is, `GetDetail()`
    to provide the required details.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，类将只公开一个方法，即`GetDetail()`，以提供所需的详细信息。
- en: 'Following will be the output when this code will be called from the client:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端调用此代码时，将会得到以下输出：
- en: '![](img/00117.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00117.jpeg)'
- en: Encapsulation
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: Encapsulation is a process where data is not directly accessible to user. When
    you want to restrict or hide the direct access to data from client or user, that
    activity or a process is known as encapsulation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是一种数据不直接对用户可访问的过程。当你想要限制或隐藏客户端或用户对数据的直接访问时，这种活动或过程就被称为封装。
- en: When we say information hiding that means hiding an information that doesn't
    require for user or user is not interested in the information for example - when
    you buy a bike you'd not be interested to know how it's engine works, how fuel
    supply exists internally, but you're interested about the mileage of bike and
    so on.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说信息隐藏时，意味着隐藏用户不需要或对信息不感兴趣的信息，例如-当你买一辆自行车时，你可能不会对引擎如何工作，内部如何供应燃料等感兴趣，但你可能对自行车的里程等感兴趣。
- en: 'Information hiding is not a data hiding but it is an implementation hiding
    in C# for more information refer: [http://blog.ploeh.dk/2012/11/27/Encapsulationofproperties/](http://blog.ploeh.dk/2012/11/27/Encapsulationofproperties/).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 信息隐藏不是数据隐藏，而是在C#中的实现隐藏，欲了解更多信息，请参考：[http://blog.ploeh.dk/2012/11/27/Encapsulationofproperties/](http://blog.ploeh.dk/2012/11/27/Encapsulationofproperties/)。
- en: In C# when functions and data combined in a single unit (called class) and you
    cannot access the data directly is called encapsulation. In C# class, access modifiers
    are applied to members, properties to avoid the direct access of data to other
    cases or users.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，当函数和数据组合在一个单元中（称为类），并且你不能直接访问数据时，称为封装。在C#类中，应用访问修饰符到成员、属性，以避免其他情况或用户直接访问数据。
- en: In this section, we will discuss about encapsulation in detail.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细讨论封装。
- en: What are access modifier in C#?
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#中的访问修饰符是什么？
- en: As discussed in previous section, encapsulation is a concept of hiding information
    from the outer world. In C#, we have access modifier or access specifiers that
    helps us to hide the information. These access modifiers help you to define the
    scope and visibility of a class member.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所讨论的，封装是隐藏信息不让外部世界知道的概念。在C#中，我们有访问修饰符或访问限定符，可以帮助我们隐藏信息。这些访问修饰符帮助你定义类成员的范围和可见性。
- en: 'Following are the access modifiers:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是访问修饰符：
- en: Public
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共的
- en: Private
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有的
- en: Protected
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受保护的
- en: Internal
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部的
- en: Protected internal
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受保护的内部
- en: We have already gone through all the preceding access modifiers during day four.
    Please refer to section *Access modifier* and their accessibility to revise how
    these modifier works and help us to define the visibility.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第四天已经讨论了所有上述的访问修饰符。请参考*访问修饰符*部分以及它们的可访问性，以了解这些修饰符如何工作并帮助我们定义可见性。
- en: Implementing encapsulation
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现封装
- en: 'In this section, we will implement encapsulation in C# 7.0\. Think a scenario
    where we need to provide the information of an `Author` including recent published
    book. Consider following code-snippet:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在C# 7.0中实现封装。想象一个场景，我们需要提供一个`Author`的信息，包括最近出版的书。考虑以下代码片段：
- en: '[PRE12]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code-snippet that is showing the implementation of encapsulation,
    we are hiding our fields that user would not want to know. As the main motto is
    to show the recent publication.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述显示封装实现的代码片段中，我们隐藏了用户不想知道的字段。因为主要目的是展示最近的出版物。
- en: 'Following is the code for client, that need the information:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是客户端需要的信息的代码：
- en: '[PRE13]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code-snippet is to get the required information only. User would
    not be aware of how the information is fetching/retrieving from class.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段只是为了获取所需的信息。用户不会知道信息是如何从类中获取/检索的。
- en: '![](img/00118.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00118.jpeg)'
- en: The preceding image is showing the exact output, you will see after execution
    of previous code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图像显示了在执行前面的代码后，您将看到的确切输出。
- en: Polymorphism
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性
- en: In simple words, polymorphism means having many forms. In C#, we can express
    one interface with multiple functions as polymorphism. Polymorphism is taken from
    Greek-word that has meaning of *many-shapes*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，多态意味着有多种形式。在C#中，我们可以将一个接口表达为多个函数，这就是多态。多态来自希腊词，意思是“多种形式”。
- en: All types in C# (including user-defined types) inherit from object hence every
    type in C# is polymorphic.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，所有类型（包括用户定义的类型）都继承自对象，因此C#中的每种类型都是多态的。
- en: As we discussed polymorphism means many forms. These forms can be of functions
    where we implement function of same name having same parameters in different forms
    in derived classes. Also, polymorphism is having the capability to provide different
    implementation of methods that are implemented with same name.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论的，多态意味着多种形式。这些形式可以是函数的形式，在派生类中以不同形式实现相同名称和相同参数的函数。此外，多态性具有提供相同名称的方法的不同实现的能力。
- en: In coming sections, we will discuss the various types of polymorphism including
    their implementation using C# 7.0.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将讨论各种类型的多态性，包括它们在C# 7.0中的实现。
- en: Types of polymorphism
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性的类型
- en: 'In C#, we have two types of polymorphism and these types are:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，我们有两种多态性，这些类型是：
- en: '**Compile-time polymorphism**'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译时多态**'
- en: 'Compile-time polymorphism is also famous as early binding or overloading or
    static binding. It determines at compile-time and meant for same function name
    with different parameters. Compile-time or early binding is further divided into
    two more types and these types are:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时多态也被称为早期绑定或重载或静态绑定。它在编译时确定，并用于具有不同参数的相同函数名称。编译时或早期绑定进一步分为两种类型，这些类型是：
- en: '**Function Overloading**'
  id: totrans-202
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数重载**'
- en: Function overloading as name is self-explanatory function is overloaded. When
    you declare function with same name but different parameters, it is called as
    function overloading. You can declare as many overloaded functions as you want.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 函数重载，如其名所示，函数被重载。当您声明具有相同名称但不同参数的函数时，它被称为函数重载。您可以声明尽可能多的重载函数。
- en: 'Consider following code-snippet:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE14]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code is a representation of overloading, `Math` class is having
    a method `Add()` with an overload the parameters of type double. These methods
    in meant to separate behaviour. Consider following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是重载的一种表示，`Math`类有一个带有双重载参数的`Add()`方法。这些方法用于分离行为。考虑以下代码：
- en: '[PRE15]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code snippet is using both the methods. Following is the output
    of the preceding implementation:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段同时使用了这两种方法。以下是上述实现的输出：
- en: '![](img/00119.jpeg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00119.jpeg)'
- en: If you analyse previous result you will find the overloaded method that accepts
    double parameters provides accurate results that is, 99 because we supplied decimal
    values and it adds decimals. On the other had `Add` method with integer type parameter,
    apply round of to double and convert them into integer so, it displays the wrong
    result. However previous example is not related to correct calculations but this
    tells about the compile-time polymorphism using function overloading.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您分析之前的结果，您会发现接受双参数的重载方法提供了准确的结果，即99，因为我们提供了小数值并且它添加了小数。另一方面，带有整数类型参数的`Add`方法，将双精度数四舍五入并将其转换为整数，因此显示了错误的结果。然而，之前的例子与正确的计算无关，但它告诉了关于使用函数重载进行编译时多态性的情况。
- en: '**Operator Overloading**'
  id: totrans-211
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运算符重载**'
- en: Operator loading is a way to redefine the actual functionality of a particular
    operator.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符重载是重新定义特定运算符的实际功能的一种方式。
- en: This is important while you're working with user-defined complex types where
    direct use of in-built operators is impossible.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理用户定义的复杂类型时，这一点非常重要，直接使用内置运算符是不可能的。
- en: We have already discussed operator overloading in details during [Chapter 2](part0032.html#UGI00-cd07d0bec7404d1cb3fdb41e48e5618f),
    *Day 02 – Getting Started with C#* section - *Operator Overloading* - refer to
    this section if you want to revise operator overloading.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第2章](part0032.html#UGI00-cd07d0bec7404d1cb3fdb41e48e5618f)中详细讨论了运算符重载，*第02天
    - 开始使用C#*部分 - *运算符重载* - 如果您想复习运算符重载，请参考本节。
- en: Run-time polimorphism
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时多态性
- en: Run-time polymorphism is also famous as late binding or overriding or dynamic
    binding. We can achieve run-time polymorphism by overriding methods in C#. The
    virtual or abstract methods can be overridden in derived classes.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时多态性也被称为晚期绑定、覆盖或动态绑定。我们可以通过在C#中覆盖方法来实现运行时多态性。虚拟或抽象方法可以在派生类中被覆盖。
- en: In C# abstract classes provide a way to implement run-time polymorphism where
    we override abstract methods in derived classes. The `virtual` keyword is also
    a way to override method in derive class. We discussed `virtual` keyword during
    [Chapter 2](part0032.html#UGI00-cd07d0bec7404d1cb3fdb41e48e5618f), *Day 02 – Getting
    Started with C#* (refer if you want to revise it).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，抽象类提供了一种在派生类中覆盖抽象方法的方法。`virtual`关键字也是在派生类中覆盖方法的一种方式。我们在[第2章](part0032.html#UGI00-cd07d0bec7404d1cb3fdb41e48e5618f)中讨论了`virtual`关键字（如果您想复习，请参考）。
- en: 'Consider the following example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE16]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](img/00120.jpeg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00120.jpeg)'
- en: The preceding image is showing output of a program example implementing of abstract
    class.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了一个实现抽象类的程序示例的输出。
- en: 'We can also implement run-time polymorphism using abstract class and virtual
    methods, consider following code-snippet:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用抽象类和虚拟方法实现运行时多态性，考虑以下代码片段：
- en: '[PRE18]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](img/00121.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00121.jpeg)'
- en: Our method `ShowDetail()` displays the member name of a particular type.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ShowDetail()`方法显示了特定类型的成员名称。
- en: Implementing polymorphism
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现多态性
- en: 'Let''s implement polymorphism in a complete, consider the following code-snippet:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个完整的程序中实现多态性，考虑以下代码片段：
- en: '[PRE19]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code-snippet is a representation of polymorphism, that is building
    different teams. It produces the following output:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段是多态性的一种表示，即构建不同的团队。它产生以下输出：
- en: '![](img/00122.jpeg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00122.jpeg)'
- en: The preceding image is showing results from a program that represents the implementation
    of polymorphism.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了一个程序的结果，该程序表示了多态性的实现。
- en: Hands on Exercise
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手练习
- en: 'Here are the unsolved questions from today''s study:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是今天学习中未解决的问题：
- en: What is OOP?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是面向对象编程？
- en: Why we should use OOP language over procedural language?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们应该使用面向对象的语言而不是过程式语言？
- en: Define inheritance?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义继承？
- en: How many type of inheritance is available in general?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常有多少种继承类型？
- en: Why we can't implement multiple inheritance in C#?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们不能在C#中实现多重继承？
- en: How we can achieve multiple inheritance in C#.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在C#中实现多重继承。
- en: Define inherited member visibility with the help of a short program.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用一个简短的程序定义继承成员的可见性。
- en: Define hiding and elaborate with the help of a short program.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义隐藏并用一个简短的程序详细说明。
- en: What is overriding?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是覆盖？
- en: 'When to use hiding and when to use overriding, elaborate with the help of a
    short program (hint: refer to - [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords))'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时使用隐藏，何时使用覆盖，用一个简短的程序详细说明（提示：参考 - [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords)）
- en: What is implicit inheritance?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是隐式继承？
- en: What is the difference between abstract class and interface?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象类和接口之间有什么区别？
- en: What is encapsulation, elaborate it with the help of a short program.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是封装，用一个简短的程序来详细说明。
- en: Define access modifiers or access specifiers that are helpful in encapsulation.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义有助于封装的访问修饰符或访问说明符。
- en: What is abstraction? Elaborate it with a real-world example.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是抽象？用一个现实世界的例子详细说明。
- en: 'What is the difference between encapsulation and abstraction with the help
    of a real-world example. (hint: [https://stackoverflow.com/questions/16014290/simple-way-to-understand-encapsulation-and-abstraction](https://stackoverflow.com/questions/16014290/simple-way-to-understand-encapsulation-and-abstraction))'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用一个现实世界的例子说明封装和抽象的区别。(提示：[https://stackoverflow.com/questions/16014290/simple-way-to-understand-encapsulation-and-abstraction](https://stackoverflow.com/questions/16014290/simple-way-to-understand-encapsulation-and-abstraction))
- en: 'When to use abstract class and interface elaborate with the help of short program.
    (hint: [https://dzone.com/articles/when-to-use-abstract-class-and-intreface](https://dzone.com/articles/when-to-use-abstract-class-and-intreface))'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时使用抽象类和接口，用简短的程序详细说明。(提示：[https://dzone.com/articles/when-to-use-abstract-class-and-intreface](https://dzone.com/articles/when-to-use-abstract-class-and-intreface))
- en: 'What is the difference between abstract and virtual functions? (hint: [https://stackoverflow.com/questions/391483/what-is-the-difference-between-an-abstract-function-and-a-virtual-function](https://stackoverflow.com/questions/391483/what-is-the-difference-between-an-abstract-function-and-a-virtual-function))'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象函数和虚函数有什么区别？(提示：[https://stackoverflow.com/questions/391483/what-is-the-difference-between-an-abstract-function-and-a-virtual-function](https://stackoverflow.com/questions/391483/what-is-the-difference-between-an-abstract-function-and-a-virtual-function))
- en: Define polymorphism in C#?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C#中定义多态？
- en: How many types of polymorphism, implement using a short program using C# 7.0?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有多少种多态性，使用C# 7.0编写一个简短的程序来实现？
- en: Define late binding and early binding with the use of real world example.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用实际例子定义晚期绑定和早期绑定。
- en: Prove this with the help of a program - In C# every type is a polymorphic.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用程序证明 - 在C#中，每种类型都是多态的。
- en: What is the difference between overloading and overriding?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重载和重写有什么区别？
- en: Revisiting Day 7
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重温第7天
- en: Finally, we are at the stage where we conclude the final day that is, day seven
    of our 7-days learning series. Today, we have gone through concepts of OOP paradigm
    where we started with object relationship and get an overview of association,
    aggregation and composition and then we discussed structural and procedural language.
    We discussed all four features that is, encapsulation, abstraction, inheritance,
    and polymorphism of OOP. We also implemented OOP concepts using C# 7.0.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们到达了我们7天学习系列的最后一天，也就是第七天。今天，我们已经学习了面向对象编程范式的概念，从对象关系开始，概述了关联、聚合和组合，然后讨论了结构化和过程化语言。我们讨论了面向对象编程的封装、抽象、继承和多态这四个特性。我们还使用C#
    7.0实现了面向对象编程的概念。
- en: Tomorrow, on day eight we will be starting a real-world application that will
    help us to revise all our concepts till today. If you want to revise now, please
    go ahead and take a look in previous day's learning.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 明天，第八天，我们将开始一个真实世界的应用程序，这将帮助我们复习到目前为止学到的所有概念。如果你现在想复习，请继续查看之前几天的学习。
- en: What next?
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来做什么？
- en: 'Today we concluded our 7^(th) days of 7-days learning series. During this journey,
    we have started with very basic and then gradually adapted the advanced terms
    but this is just a beginning there are more to grab. I tried to combine almost
    all things here for next step, I suggest you should learn these:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 今天我们结束了我们的7天学习系列。在这段旅程中，我们从非常基础的开始，然后逐渐适应了高级术语，但这只是一个开始，还有更多要学习。我尽量将几乎所有的东西都结合在这里，为下一步，我建议你应该学习这些：
- en: Multi- threading
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多线程
- en: Constructor chaining
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数链
- en: Indexers
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 索引器
- en: Extension methods
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展方法
- en: Advanced regular expression
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高级正则表达式
- en: Advanced unsafe code implementation
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高级不安全代码实现
- en: Advanced concepts of garbage collection
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垃圾回收的高级概念
- en: 'For more advance topics, please refer to following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更高级的主题，请参考以下内容：
- en: C# 7.0 and .NET Core Cookbook ([https://www.packtpub.com/application-development/c-7-and-net-core-cookbook](https://www.packtpub.com/application-development/c-7-and-net-core-cookbook))
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C# 7.0 和 .NET Core Cookbook ([https://www.packtpub.com/application-development/c-7-and-net-core-cookbook](https://www.packtpub.com/application-development/c-7-and-net-core-cookbook))
- en: '[http://questpond.over-blog.com/](http://questpond.over-blog.com/)'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[http://questpond.over-blog.com/](http://questpond.over-blog.com/)'
- en: Functional C# ([https://www.packtpub.com/application-development/functional-c](https://www.packtpub.com/application-development/functional-c))
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Functional C# ([https://www.packtpub.com/application-development/functional-c](https://www.packtpub.com/application-development/functional-c))
- en: Multithreading with C# Cookbook - Second Edition ([https://www.packtpub.com/application-development/multithreading-c-cookbook-second-edition](https://www.packtpub.com/application-development/multithreading-c-cookbook-second-edition))
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用C# 7.0进行多线程的Cookbook - 第二版 ([https://www.packtpub.com/application-development/multithreading-c-cookbook-second-edition](https://www.packtpub.com/application-development/multithreading-c-cookbook-second-edition))
