["```kt\n    (types of parameters)->return type \n```", "```kt\n    lateinit var a: (Int) -> Int   \n    lateinit var b: ()->Int \n    lateinit var c: (String)->Unit \n```", "```kt\n    fun addCache(function: (Int) -> Int): (Int) -> Int { \n        // code \n    } \n\n    val fibonacciNumber: (Int)->Int = // function implementation \n    val fibonacciNumberWithCache = addCache(fibonacciNumber) \n```", "```kt\n    val i = a(10) \n    val j = b() \n    c(\"Some String\") \n```", "```kt\n    var todoList: List<() -> Unit> = // ... \n    for (task in todoList) task() \n```", "```kt\n    val a: (Int) -> Unit = //... \n    a(10)        // 1 \n    a.invoke(10) // 1 \n```", "```kt\n    val a: (Int) -> Int = fun(i: Int) = i * 2 // 1 \n    val b: ()->Int = fun(): Int { return 4 } \n    val c: (String)->Unit = fun(s: String){ println(s) } \n```", "```kt\n    // Usage \n    println(a(10))      // Prints: 20 \n    println(b())        // Prints: 4 \n    c(\"Kotlin rules\")   // Prints: Kotlin rules \n```", "```kt\n    var a = fun(i: Int) = i * 2 \n    var b = fun(): Int { return 4 } \n    var c = fun(s: String){ println(s) } \n```", "```kt\n    var a: (Int)->Int = fun(i) = i * 2 \n    var c: (String)->Unit = fun(s){ println(s) }\n```", "```kt\n    println(a.invoke(4))        // Prints: 8 \n    println(b.invoke())         // Prints: 4 \n    c.invoke(\"Hello, World!\")   // Prints: Hello, World! \n```", "```kt\n    var a: ((Int) -> Int)? = null // 1 \n    if (false) a = fun(i: Int) = i * 2 \n    print(a?.invoke(4)) // Prints: null \n```", "```kt\n    val TAG = \"MainActivity\" \n    val errorHandler = fun (error: Throwable) { \n        if(BuildConfig.DEBUG) { \n            Log.e(TAG, error.message, error) \n        } \n        toast(error.message) \n        // Other methods, like: Crashlytics.logException(error) \n    } \n\n    // Usage in project \n    val adController = AdController(errorHandler) \n    val presenter = MainPresenter(errorHandler) \n\n    // Usage \n    val error = Error(\"ExampleError\") \n    errorHandler(error) // Logs: MainActivity: ExampleError \n```", "```kt\n    { arguments -> function body } \n```", "```kt\n    var a: (Int) -> Int = { i: Int -> i * 2 } \n    var b: ()->Int = { 4 } \n    var c: (String)->Unit = { s: String -> println(s) } \n```", "```kt\n    var a: (Int) -> Int = { i: Int -> return i * 2 } \n\n    // Error: Return is not allowed there \n    var l: (Int) -> Int = l@ { i: Int -> return@l i * 2 } \n```", "```kt\n    val printAndReturn = { i: Int, j: Int -> \n        println(\"I calculate $i + $j\") \n        i + j // 1 \n    } \n```", "```kt\nval printAndReturn = {i: Int, j: Int -> println(\"I calculate $i + $j\"); \n\n                      i + j } \n```", "```kt\n    val text = \"Text\" \n    var a: () -> Unit = { println(text) } \n    a() // Prints: Text \n    a() // Prints: Text \n```", "```kt\n    var i = 1 \n    val a: () -> Int = { ++i } \n    println (i)     // Prints: 1 \n    println (a())   // Prints: 2 \n    println (i)     // Prints: 2 \n    println (a())   // Prints: 3 \n    println (i)     // Prints: 3\n```", "```kt\n    fun setUpCounter() { \n        var value: Int = 0 \n        val showValue = { counterView.text = \"$value\" } \n        counterIncView.setOnClickListener { value++; showValue() } \n\n        // 1 \n        counterDecView.setOnClickListener { value--; showValue() } \n\n        // 1 \n    } \n```", "```kt\n    val a: (Int) -> Int = { i -> i * 2 }  // 1 \n    val c: (String)->Unit = { s -> println(s) } // 2 \n```", "```kt\n    val b = { 4 }                        // 1 \n    val c = { s: String -> println(s) }  // 2 \n    val a = { i: Int -> i * 2 }          // 3 \n```", "```kt\n    val a: (Int) -> Int = { it * 2 }         // 1\n    val c: (String)->Unit = { println(it) }  // 2 \n```", "```kt\n    strings.filter { it.length = 5 }.map { it.toUpperCase() } \n```", "```kt\n    fun sum(numbers: List<BigDecimal>): BigDecimal { \n        var sum = BigDecimal.ZERO \n        for (num in numbers) { \n            sum += num \n        } \n        return sum \n    } \n\n    fun prod(numbers: List<BigDecimal>): BigDecimal { \n        var prod = BigDecimal.ONE \n        for (num in numbers) { \n            prod *= num \n        } \n        return prod \n    } \n\n    // Usage \n    val numbers = listOf( \n        BigDecimal.TEN,  \n        BigDecimal.ONE,  \n        BigDecimal.valueOf(2) \n    ) \n    print(numbers)          //[10, 1, 2] \n    println(prod(numbers))  // 20 \n    println(sum(numbers))   // 13 \n```", "```kt\n    fun sum(numbers: List<BigDecimal>) = \n        fold(numbers, BigDecimal.ZERO) { acc, num -> acc + num } \n\n    fun prod(numbers: List<BigDecimal>) = \n       fold(numbers, BigDecimal.ONE) { acc, num -> acc * num } \n\n    private fun fold( \n        numbers: List<BigDecimal>, \n        start: BigDecimal, \n        accumulator: (BigDecimal, BigDecimal) -> BigDecimal \n    ): BigDecimal { \n        var acc = start \n        for (num in numbers) { \n            acc = accumulator(acc, num) \n        } \n        return acc \n    } \n\n    // Usage \n\n    fun BD(i: Long) = BigDecimal.valueOf(i) \n    val numbers = listOf(BD(1), BD(2), BD(3), BD(4)) \n    println(sum(numbers))   // Prints: 10 \n    println(prod(numbers))  // Prints: 24 \n```", "```kt\n    fun longOperation(vararg observers: ()->Unit) {\n        //... \n        for(o in observers) o()\n    } \n```", "```kt\n    longOperation({ notifyMainView() }, { notifyFooterView() })\n```", "```kt\n    fun makeErrorHandler(tag: String) = fun (error: Throwable) { \n        if(BuildConfig.DEBUG) Log.e(tag, error.message, error) \n        toast(error.message) \n        // Other methods, like: Crashlytics.logException(error) \n    } \n\n    // Usage in project \n    val adController = AdController(makeErrorHandler(\"Ad in MainActivity\")) \n    val presenter = MainPresenter(makeErrorHandler(\"MainPresenter\")) \n\n    // Usage \n    val exampleHandler = makeErrorHandler(\"Example Handler\") \n    exampleHandler(Error(\"Some Error\")) // Logs: Example Handler: Some Error \n```", "```kt\n    var visibleTasks = emptyList<Task>() \n    for (task in tasks) { \n        if (task.active) \n        visibleTasks += task \n    } \n```", "```kt\n    fun <T> filter(list: List<T>, predicate: (T)->Boolean) { \n        var visibleTasks = emptyList<T>() \n        for (elem in list) { \n            if (predicate(elem)) \n                visibleTasks += elem \n        } \n    } \n\n    var visibleTasks = filter(tasks, { it.active }) \n```", "```kt\n    button.setOnClickListener({ someOperation() }) \n```", "```kt\n    var listeners: List<()->Unit> = emptyList() // 1 \n    fun addListener(listener: ()->Unit) { \n        listeners += listener // 2 \n    } \n\n    fun invokeListeners() { \n        for( listener in listeners) listener() // 3 \n    } \n```", "```kt\nfun longOperationAsync(longOperation: ()->Unit, callback: ()->Unit) { \n        Thread({ // 1 \n            longOperation() // 2 \n            callback() // 3 \n        }).start() // 4 \n    } \n\n    // Usage\n\n    longOperationAsync\n\n(\n\n            longOperation = \n\n{ \n\nThread.sleep(1000L\n\n) }\n\n,\n\n            callback = \n\n{ \n\nprint\n\n(\"After second\"\n\n) } \n\n            // 5, Prints: \n\nAfter second\n\n    )\n\n    println\n\n(\"Now\"\n\n) // 6, Prints: Now\n```", "```kt\nfun getAndFillList(onStart: () -> Unit = {}, \n\n    onFinish: () -> Unit = {}){ \n        // code \n    } \n```", "```kt\n    getAndFillList( \n        onStart = { view.loadingProgress = true } , \n        onFinish = { view.loadingProgress = false } \n    ) \n```", "```kt\ngetAndFillList(onFinish = { view.swipeRefresh.isRefreshing = \n\n   false }) \n```", "```kt\n    getAndFillList() \n```", "```kt\n    fun longOperationAsync(a: Int, callback: ()->Unit) { \n        // ... \n    } \n```", "```kt\n    longOperationAsync(10) {\n        hideProgress() \n    } \n```", "```kt\n    public fun thread( \n        start: Boolean = true, \n        isDaemon: Boolean = false, \n        contextClassLoader: ClassLoader? = null, \n        name: String? = null, \n        priority: Int = -1, \n        block: () -> Unit): Thread { \n            // implementation \n        } \n```", "```kt\n    thread { /* code */ } \n```", "```kt\n    thread (name = \"SomeThread\") { /*...*/ } \n    thread (false, false) { /*...*/ } \n```", "```kt\n    thread {  \n        operation1() \n        operation2() \n    } \n```", "```kt\n    fun addLogs(tag: String, f: () -> Unit) { \n        println(\"$tag started\") \n        val startTime = System.currentTimeMillis() \n        f() \n        val endTime = System.currentTimeMillis() \n        println(\"$tag finished. It took \" + (endTime - startTime)) \n    } \n```", "```kt\n    addLogs(\"Some operations\") { \n        // Operations we are measuring \n    } \n```", "```kt\n    addLogs(\"Sleeper\") { \n        Thread.sleep(1000) \n    } \n```", "```kt\n    Sleeper started \n    Sleeper finished. It took 1001 \n```", "```kt\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {  \n        // Operations \n    } \n```", "```kt\n    fun ifSupportsLolipop(f:()->Unit) { \n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) \n\n        {  \n            f() \n        } \n    } \n    //Usage    \n\n    ifSupportsLollipop { \n        // Operation \n    } \n```", "```kt\n    fun repeatUntilError(code: ()->Unit): Throwable { \n        while (true) { \n            try { \n                code() \n            } catch (t: Throwable) { \n                return t \n            } \n        } \n    } \n\n    // Usage \n    val tooMuchAttemptsError = repeatUntilError { \n        attemptLogin() \n    } \n```", "```kt\n    strings.filter { it.length == 5 }.map { it.toUpperCase() } \n```", "```kt\n    strings.({ s -> s.length == 5 }).map({ s -> s.toUpperCase() }) \n```", "```kt\n    //Java \n    button.setOnClickListener(new OnClickListener() { \n        @Override public void onClick(View v) { \n            // Operation \n        } \n    }); \n```", "```kt\n    button.setOnClickListener(OnClickListener { \n        /* ... */ \n    }) \n```", "```kt\n    button.setOnClickListener { \n        // Operations \n    } \n```", "```kt\n    interface OnClick { \n        fun call() \n    } \n\n    fun setOnClick(onClick: OnClick) { \n        //... \n    } \n\n    setOnClick {  } // 1\\. Error \n```", "```kt\n    fun setOnClick(onClick: ()->Unit) { \n        //...   \n    } \n\n    setOnClick {  } // Works \n```", "```kt\n    // Java, inside View class \n    public interface OnClickListener { \n        void onClick(View v); \n    } \n```", "```kt\n    val onClick = View.OnClickListener { toast(\"Clicked\") } \n```", "```kt\n    fun addOnClickListener(d: View.OnClickListener) {} \n    addOnClickListener( View.OnClickListener { v -> println(v) }) \n```", "```kt\n    view.setOnLongClickListener { /* ... */; true } \n    view.onFocusChange { view, b -> /* ... */ } \n\n    val callback = Runnable { /* ... */ } \n    view.postDelayed(callback, 1000) \n    view.removeCallbacks(callback) \n```", "```kt\n    observable.doOnNext { /* ... */ } \n    observable.doOnEach { /* ... */ } \n```", "```kt\n    fun setOnItemClickListener(listener: (Int, View, View)->Unit) { \n        // code \n    } \n    setOnItemClickListener { position, view, parent -> /* ... */ } \n```", "```kt\n    (position: Int, view: View, parent: View)->Unit \n```", "```kt\n    data class User(val name: String, val surname: String) \n    typealias Users = List<User> \n```", "```kt\n    typealias Weight = Double \n    typealias Length = Int \n```", "```kt\n    val users: Users = listOf( \n        User(\"Marcin\", \"Moskala\"),  \n        User(\"Igor\", \"Wojda\") \n    ) \n\n    fun calculatePrice(length: Length) { \n        // ... \n    } \n    calculatePrice(10) \n\n    val weight: Weight = 52.0 \n    val length: Length = 34 \n```", "```kt\n    typealias Length = Int \n    var intLength: Int = 17 \n    val length: Length = intLength \n    intLength = length \n```", "```kt\n    typealias Dictionary<V> = Map<String, V> \n    typealias Array2D<T> = Array<Array<T>> \n```", "```kt\n    typealias Action<T> = (T) -> Unit \n    typealias CustomHandler = (Int, String, Any) -> Unit \n```", "```kt\n    typealias OnElementClicked = (position: Int, view: View, parent: View)->Unit \n```", "```kt\n    typealias OnElementClicked = (position: Int, view: View, parent: View)->Unit \n\n    class MainActivity: Activity(), OnElementClicked { \n\n        override fun invoke(position: Int, view: View, parent: View) { \n            // code \n        } \n    } \n```", "```kt\n    list.filterIndexed { index, value -> index % 2 == 0 } \n```", "```kt\n    list.filterIndexed { index, ignored -> index % 2 == 0 } \n```", "```kt\n    list.filterIndexed { index, _ -> index % 2 == 0 } \n```", "```kt\ndata class User(val name: String, val surname: String, val phone: String) \n\nval (name, surname, phone) = user \n```", "```kt\n    val showUser: (User) -> Unit = { (name, surname, phone) -> \n        println(\"$name $surname have phone number: $phone\")  \n    } \n\n    val user = User(\"Marcin\", \"Moskala\", \"+48 123 456 789\") \n    showUser(user) \n\n    // Marcin Moskala have phone number: +48 123 456 789 \n```", "```kt\n    val f1: (Pair<Int, String>)->Unit = { (first, second) -> \n\n        /* code */ } // 1 \n    val f2: (Int, Pair<Int, String>)->Unit = { index, (f, s)-> \n\n        /* code */ } // 2 \n    val f3: (Pair<Int, String>, User) ->Unit = { (f, s), (name, \n\n        surname, tel) ->/* code */ } // 3 \n```", "```kt\n    val f: (User)->Unit = { (name, surname) -> /* code */ } \n```", "```kt\n    val f: (User)->Unit = { (name, _, phone) -> /* code */ } \n    val third: (List<Int>)->Int = { (_, _, third) -> third } \n```", "```kt\n    val f = { (name, surname): User -> /* code */ } //1\n```", "```kt\n    val f = { (name: String, surname: String): User -> \n\n       /* code */}// 1 \n    val f: (User)->Unit = { (name, surname) -> \n\n      /* code */ } // 2 \n```", "```kt\n    val map = mapOf(1 to 2, 2 to \"A\") \n    val text = map.map { (key, value) -> \"$key: $value\" } \n    println(text) // Prints: [1: 2, 2: A] \n```", "```kt\n    val listOfPairs = listOf(1 to 2, 2 to \"A\") \n    val text = listOfPairs.map { (first, second) -> \n\n        \"$first and $second\" } \n    println(text) // Prints: [1 and 2, 2 and A] \n```", "```kt\n    fun setOnUserClickedListener(listener: (User)->Unit) { \n        listView.setOnItemClickListener { _, _, position, _ -> \n            listener(users[position]) \n        } \n    } \n\n    setOnUserClickedListener { (name, surname) -> \n        toast(\"Clicked to $name $surname\") \n    } \n```", "```kt\ngetQuestionAndAnswer() \n    .flatMap { (question, answer) -> \n\n      view.showCorrectAnswerAnimationObservable(question, answer)  \n    }   \n    .subscribe( { (question, answer) -> /* code */ } ) \n```", "```kt\n    inline fun printExecutionTime(f: () -> Unit) { \n        val startTime = System.currentTimeMillis() \n        f() \n        val endTime = System.currentTimeMillis() \n        println(\"It took \" + (endTime - startTime))  \n    } \n\n    fun measureOperation() { \n        printExecutionTime { \n            longOperation() \n        } \n    } \n```", "```kt\n    fun measureOperation() { \n        val startTime = System.currentTimeMillis() // 1 \n        longOperation() // 2 \n        val endTime = System.currentTimeMillis() \n        println(\"It took \" + (endTime - startTime)) \n    } \n```", "```kt\n    internal fun someFun() {}  \n    inline fun inlineFun() { \n        someFun() // ERROR \n    } \n```", "```kt\n    fun boo(f: ()->Int) { \n        //...  \n    } \n\n    inline fun foo(f: () -> Int) { \n        boo (f) // ERROR, 1 \n    } \n```", "```kt\n    fun boo(f: ()->Unit) { \n        //... \n    } \n\n    inline fun foo(before: ()->Unit, noinline f: () -> Unit) { // 1 \n        before() // 2 \n        boo (f) // 3 \n    } \n```", "```kt\n    fun forEach(list: List<Int>, body: (Int) -> Unit) { \n        for (i in list) body(i) \n    } \n\n    // Usage \n    val list = listOf(1, 2, 3, 4, 5) \n    forEach(list) { print(it) } // Prints: 12345 \n```", "```kt\n    fun maxBounded(list: List<Int>, upperBound: Int, lowerBound: Int): \n\n    Int { \n        var currentMax = lowerBound \n        for(i in list) { \n            when { \n                i > upperBound -> return upperBound \n                i > currentMax -> currentMax = i \n            } \n        } \n        return currentMax \n    } \n```", "```kt\n    inline fun forEach(list: List<Int>, body: (Int)->Unit) { \n        for(i in list) body(i) \n    } \n\n    fun maxBounded(list: List<Int>, upperBound: Int, \n\n        lowerBound: Int): Int { \n        var currentMax = lowerBound \n        forEach(list) { i -> \n            when { \n                i > upperBound -> return upperBound \n                i > currentMax -> currentMax = i \n            } \n        } \n        return currentMax \n    } \n```", "```kt\n    public static final int maxBounded(@NotNull List list, \n\n    int upperBound, int lowerBound) { \n        int currentMax = lowerBound; \n        Iterator iter = list.iterator(); \n\n        while(iter.hasNext()) { \n            int i = ((Number)iter.next()).intValue(); \n            if(i > upperBound) { \n                return upperBound; // 1 \n            } \n\n            if(i > currentMax) { \n                currentMax = i; \n            } \n        } \n\n        return currentMax; \n    } \n```", "```kt\n    inline fun <T> forEach(list: List<T>, body: (T) -> Unit) { // 1 \n        for (i in list) body(i) \n    } \n\n    fun printMessageButNotError(messages: List<String>) { \n        forEach(messages) messageProcessor@ { // 2 \n            if (it == \"ERROR\") return@messageProcessor // 3 \n            print(it) \n        } \n    } \n\n    // Usage \n    val list = listOf(\"A\", \"ERROR\", \"B\", \"ERROR\", \"C\") \n    processMessageButNotError(list) // Prints: ABC \n```", "```kt\n    inline fun <T> forEach(list: List<T>, body: (T) -> Unit) { // 1 \n        for (i in list) body(i) \n    } \n\n    fun processMessageButNotError(messages: List<String>) { \n        forEach(messages) { \n            if (it == \"ERROR\") return@forEach // 1 \n            process(it) \n        } \n    } \n\n    // Usage \n    val list = listOf(\"A\", \"ERROR\", \"B\", \"ERROR\", \"C\") \n    processMessageButNotError(list) // Prints: ABC \n```", "```kt\n    inline fun <T> forEach(list: List<T>, body: (T) -> Unit) { \n        for (i in list) body(i) \n    }  \n\n    fun processMessageButNotError(messages: List<String>) { \n        forEach(messages) { \n            if (it == \"ERROR\") return \n            process(it) \n        } \n    } \n\n    // Usage \n    val list = listOf(\"A\", \"ERROR\", \"B\", \"ERROR\", \"C\") \n    processMessageButNotError(list) // Prints: A \n```", "```kt\n    inline fun <T> forEach(list: List<T>, body: (T) -> Unit) { // 1 \n        for (i in list) body(i)  \n    } \n\n    fun processMessageButNotError(conversations: List<List<String>>) { \n        forEach(conversations) { messages -> \n            forEach(messages) { \n                if (it == \"ERROR\") return@forEach // 1\\. \n                process(it) \n            } \n        } \n    } \n\n    // Usage \n    val conversations = listOf( \n        listOf(\"A\", \"ERROR\", \"B\"),  \n        listOf(\"ERROR\", \"C\"),  \n        listOf(\"D\") \n    ) \n    processMessageButNotError(conversations) // ABCD \n```", "```kt\n    inline fun <T> forEach(list: List<T>, body: (T) -> Unit) { // 1 \n        for (i in list) body(i) \n    } \n\n    fun processMessageButNotError(conversations: List<List<String>>) { \n        forEach(conversations) conv@ { messages -> \n            forEach(messages) { \n                if (it == \"ERROR\") return@conv // 1\\. \n                print(it) \n            } \n        } \n    } \n\n    // Usage \n    val conversations = listOf( \n        listOf(\"A\", \"ERROR\", \"B\"), \n        listOf(\"ERROR\", \"C\"), \n        listOf(\"D\") \n    ) \n    processMessageButNotError(conversations) // AD \n```", "```kt\n    inline fun <T> forEach(list: List<T>, body: (T) -> Unit) { // 1 \n        for (i in list) body(i) \n    } \n\n    fun processMessageButNotError(conversations: List<List<String>>) { \n        forEach(conversations) { messages -> \n            forEach(messages) { \n                if (it == \"ERROR\") return // 1\\. \n                process(it) \n           } \n        } \n    } \n```", "```kt\n    fun boo(f: () -> Unit) { \n        //... \n    } \n\n    inline fun foo(crossinline f: () -> Unit) { \n        boo { println(\"A\"); f() } \n    } \n\n    fun main(args: Array<String>) { \n        foo { println(\"B\") } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n        boo { println(\"A\"); println(\"B\") } \n    } \n```", "```kt\n    inline fun runOnUiThread(crossinline action: () -> Unit) { \n        val mainLooper = Looper.getMainLooper() \n        if (Looper.myLooper() == mainLooper) { \n            action() \n        } else { \n            Handler(mainLooper).post { action() } // 1 \n        } \n    } \n```", "```kt\nvar viewIsVisible: Boolean \ninline get() = findViewById(R.id.view).visibility == View.VISIBLE \ninline set(value) { \n  findViewById(R.id.view).visibility = if (value) View.VISIBLE \n\n  else View.GONE \n} \n```", "```kt\ninline var viewIsVisible: Boolean \nget() = findViewById(R.id.view).visibility == View.VISIBLE \n  set(value) { \n    indViewById(R.id.view).visibility = if (value) View.VISIBLE \n\n      else View.GONE \n    } \n\n// Usage \nif (!viewIsVisible) \nviewIsVisible = true \n```", "```kt\nif (!(findViewById(R.id.view).getVisibility() == View.VISIBLE)) \n\n{ \n  findViewById(R.id.view).setVisibility(true?View.VISIBLE:View.GONE); \n} \n```", "```kt\n    fun isOdd(i: Int) = i % 2 == 1 \n\n    list.filter { isOdd(it) } \n```", "```kt\n    list.filter(::isOdd) \n```", "```kt\n    fun greet(){ \n        print(\"Hello! \") \n    } \n\n    fun salute(){ \n        print(\"Have a nice day \") \n    } \n\n    val todoList: List<() -> Unit> = listOf(::greet, ::salute) \n\n    for (task in todoList) { \n        task()  \n    } \n\n    // Prints: Hello! Have a nice day \n```", "```kt\n    fun isOdd(i: Int) = i % 2 == 1 \n\n    val annotations = ::isOdd.annotations \n    val parameters = ::isOdd.parameters   \n    println(annotations.size) // Prints: 0 \n    println(parameters.size) // Prints: 1 \n```", "```kt\n    val predicate: (Int)->Boolean = ::isOdd \n```", "```kt\n    val isStringEmpty: (String)->Boolean = String::isEmpty \n\n    // Usage \n    val nonEmpty = listOf(\"A\", \"\", \"B\", \"\") \n    .filter(String::isNotEmpty) \n    print(nonEmpty) // Prints: [\"A\", \"B\"] \n```", "```kt\n    class User { \n\n        fun wantToEat(food: Food): Boolean { \n            // ... \n        } \n    } \n\n    val func: (User, Food) -> Boolean = User::wantToEat \n```", "```kt\n    object MathHelpers { \n        fun isEven(i: Int) = i % 2 == 0 \n    } \n\n    class Math { \n        companion object { \n            fun isOdd(i: Int) = i % 2 == 1 \n        } \n    } \n\n    // Usage \n    val evenPredicate: (Int)->Boolean = MathHelpers::isEven \n    val oddPredicate: (Int)->Boolean = Math.Companion::isOdd \n\n    val numbers = 1..10 \n    val even = numbers.filter(evenPredicate) \n    val odd = numbers.filter(oddPredicate) \n    println(even) // Prints: [2, 4, 6, 8, 10] \n    println(odd) // Prints: [1, 3, 5, 7, 9] \n```", "```kt\n    getUsers().smartSubscribe ( \n        onStart = { view.showProgress() }, // 1 \n        onNext = { user -> onUsersLoaded(user) }, // 2 \n        onError = { view.displayError(it) }, // 1 \n        onFinish = { view.hideProgress() } // 1 \n    ) \n```", "```kt\n    getUsers().smartSubscribe ( \n        onStart = view::showProgress, \n        onNext = this::onUsersLoaded, \n        onError = view::displayError, \n        onFinish = view::hideProgress \n    ) \n```", "```kt\n    fun toUsers(usersDto: List<UserDto>) = usersDto.map { User(it) } \n```", "```kt\n    val mapper: (UserDto)->User = ::User \n```", "```kt\n    fun toUsers(usersDto: List<UserDto>) = usersDto.map(::User) \n```"]