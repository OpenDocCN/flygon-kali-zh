- en: Functional Programming Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程实践
- en: The previous chapter ([Chapter 8](ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml), *Concurrent
    Programming in .NET Core*) introduced concurrent programming in .NET Core, and
    the aim of the chapter was to take advantage of `async`/`await` and parallelism,
    to make our program more performant.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章（[第8章](ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml)，* .NET Core中的并发编程*）介绍了.NET
    Core中的并发编程，本章的目的是利用`async`/`await`和并行性，使我们的程序更加高效。
- en: In this chapter, we will get a taste of functional programming, using the C#
    language. We will also dive deeper into the concepts that show you how to leverage
    C# in .NET Core to perform functional programming. The aim of this chapter is
    to help you understand what functional programming is and how we can use it using
    the C# language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将品尝使用C#语言的函数式编程。我们还将深入探讨这些概念，向您展示如何利用.NET Core中的C#来执行函数式编程。本章的目的是帮助您了解函数式编程是什么，以及我们如何使用C#语言来实现它。
- en: Functional programming was inspired by mathematics, and it solves problems in
    a functional way. In mathematics, we have formulas and, in functional programming,
    we use math in the form of various functions. The best part of functional programming
    is that it helps to implement concurrency seamlessly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程受数学启发，以函数式方式解决问题。在数学中，我们有公式，在函数式编程中，我们使用各种函数的数学形式。函数式编程的最大优点是它有助于无缝实现并发。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding functional programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解函数式编程
- en: The inventory application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库存应用程序
- en: Strategy patterns and functional programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式和函数式编程
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter contains various code examples to explain the concepts of functional
    programming. The code is kept simple and is just for demonstration purposes. Most
    of the examples involve a .NET Core console application written in C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例，以解释函数式编程的概念。代码保持简单，仅用于演示目的。大多数示例涉及使用C#编写的.NET Core控制台应用程序。
- en: The complete source code is available at the following link: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter9](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter9).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可在以下链接找到：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter9](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter9)。
- en: 'To run and execute the code, the prerequisites are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行和执行代码，先决条件如下：
- en: Visual Studio 2019 (a Visual Studio 2017 update 3 or later can also be used
    to run the application).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019（也可以使用Visual Studio 2017更新3或更高版本来运行应用程序）。
- en: Setting up .NET Core
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置.NET Core
- en: SQL server (the Express Edition is used in this chapter)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server（本章中使用Express Edition）
- en: Installing Visual Studio
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Visual Studio
- en: 'To run these code examples, you need to install Visual Studio 2017 (or a later
    version such as 2019). To do so, follow these instructions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些代码示例，您需要安装Visual Studio 2017（或更新版本，如2019）。要执行此操作，请按照以下说明操作：
- en: Download Visual Studio from the following download link, which includes installation
    instructions: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下下载链接下载Visual Studio，其中包括安装说明：[https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio)。
- en: Follow the installation instructions.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照安装说明操作。
- en: Multiple versions are available for the Visual Studio installation. Here, we
    are using Visual Studio for Windows.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio安装有多个版本可供选择。在这里，我们使用Windows的Visual Studio。
- en: Setting up .NET Core
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置.NET Core
- en: 'If you do not have .NET Core installed, you need to follow these instructions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装.NET Core，需要按照以下说明操作：
- en: Download .NET Core for Windows at [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows)下载Windows的.NET
    Core。
- en: For multiple versions and a related library, visit [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2)获取多个版本和相关库。
- en: Installing SQL Server
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装SQL Server
- en: 'If you do not have SQL Server installed, you need to follow these instructions:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装SQL Server，需要按照以下说明操作：
- en: Download SQL Server from the following link: [https://www.microsoft.com/en-in/download/details.aspx?id=1695](https://www.microsoft.com/en-in/download/details.aspx?id=1695).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载SQL Server：[https://www.microsoft.com/en-in/download/details.aspx?id=1695](https://www.microsoft.com/en-in/download/details.aspx?id=1695)。
- en: Find the installation instructions here: [https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017).
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此处找到安装说明：[https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017)。
- en: For troubleshooting and more information, refer to the following link: [https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm](https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有关故障排除和更多信息，请参阅以下链接：[https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm](https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm)。
- en: Understanding functional programming
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解函数式编程
- en: 'In simple terms, **functional programming** is an approach to symbolic computation
    that is done in the same way as solving mathematical problems. Any functional
    programming is based on mathematical functions and its coding style. Any language
    that supports functional programming works for solutions for the following two
    questions:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，**函数式编程**是一种符号计算的方法，它与解决数学问题的方式相同。任何函数式编程都是基于数学函数及其编码风格的。任何支持函数式编程的语言都可以解决以下两个问题：
- en: What does it need to solve?
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要解决什么问题？
- en: How does it solve it?
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是如何解决的？
- en: 'Functional programming is not a new invention. This language has existed in
    the industry for a long time. The following are some well-known programming languages
    that support functional programming:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程并不是一个新的发明。这种语言在行业中已经存在很长时间了。以下是一些支持函数式编程的知名编程语言：
- en: Haskell
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Haskell
- en: Scala
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala
- en: Erlang
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Erlang
- en: Clojure
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure
- en: Lisp
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lisp
- en: OCaml
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OCaml
- en: In 2005, Microsoft released the first version of F# (pronounced *EffSharp—*[https://fsharp.org/](https://fsharp.org/)).
    This is a functional programming language that has a lot of good features that
    any functional programming should have. In this chapter, we are not going to discuss
    much F#, but we will be discussing functional programming and its implementation
    using the C# language.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 2005年，微软发布了F#的第一个版本（发音为*EffSharp—*[https://fsharp.org/](https://fsharp.org/)）。这是一种具有许多良好特性的函数式编程语言。在本章中，我们不会讨论太多关于F#，但我们将讨论函数式编程及其在C#语言中的实现。
- en: 'Pure functions are the ones that strengthen functional programming by saying
    that they''re pure. These functions work on two levels:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是通过说它们是纯的来加强函数式编程的函数。这些函数在两个层面上工作：
- en: The end result/output will always remain the same for the provided parameters.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终结果/输出对于提供的参数始终保持不变。
- en: They will not impact the behavior of the program or the execution path of the
    application, even when they are being called a hundred times.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不会影响程序的行为或应用程序的执行路径，即使它们被调用了一百次。
- en: 'Consider the following example from our FlixOne inventory application:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下我们FlixOne库存应用程序中的例子：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, we have a `PriceCalc` class with two extension methods: `Discount`
    and `PriceAfterDiscount`. These functions could be called pure functions; both
    the `PriceCalc` function and the `PriceAfterDiscount` function are meeting the
    criteria to be `Pure` function; the `Discount` method will calculate the discount
    based on the current price and discount. In this case, the output of the method
    will never change for the supplied parameter values. In this way, the product
    with a price of `190.00` and a discount of `10.00` will be calculated in this
    way: `190.00 * 10.00 /100`, and this will return `19.00`. Our next method—`PriceAfterDiscount`—with
    the same parameter values will calculate `190.00 - 19.00` and return the value
    of `171.00`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们有一个`PriceCalc`类，其中有两个扩展方法：`Discount`和`PriceAfterDiscount`。这些函数可以被称为纯函数；`PriceCalc`函数和`PriceAfterDiscount`函数都符合`纯`函数的标准；`Discount`方法将根据当前价格和折扣计算折扣。在这种情况下，该方法的输出对于提供的参数值永远不会改变。这样，价格为`190.00`且折扣为`10.00`的产品将以这种方式计算：`190.00
    * 10.00 /100`，并返回`19.00`。我们的下一个方法—`PriceAfterDiscount`—使用相同的参数值将计算`190.00 - 19.00`并返回`171.00`的值。
- en: 'One more important point in functional programming is that functions are pure
    and convey complete information (also called **functional honesty**). Consider
    the `Discount` method from the previous code; this is a pure function that is
    also honest. So, if someone accidentally supplies a negative discount or a discount
    that is more than its actual price (more than 100%), will this function remain
    pure and honest? To handle this scenario, our mathematics function should be written
    in such a way that if someone enters `discount <= 0 or discount > 100`, then the
    system will not entertain it. Consider the following code with this approach:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程中另一个重要的点是函数是纯的，并传达完整的信息（也称为**函数诚实**）。考虑前面代码中的`Discount`方法；这是一个纯函数，也是诚实的。那么，如果有人意外地提供了负折扣或超过实际价格的折扣（超过100%），这个函数还会保持纯和诚实吗？为了处理这种情况，我们的数学函数应该这样编写，如果有人输入`discount
    <= 0 or discount > 100`，那么系统将不予考虑。考虑以下代码以此方法编写：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, our `Discount` function has a parameter type named `ValidDiscount`,
    which validates the input we have discussed. In this way, our function is now
    an honest function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的`Discount`函数有一个名为`ValidDiscount`的参数类型，用于验证我们讨论的输入。这样，我们的函数现在是一个诚实的函数。
- en: These functions are as simple as functional programming, but working with functional
    programming still requires a lot of practice. In the upcoming sections, we will
    discuss advanced concepts of functional programming, including functional programming
    principles.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数就像函数式编程一样简单，但是要想使用函数式编程仍然需要大量的实践。在接下来的章节中，我们将讨论函数式编程的高级概念，包括函数式编程原则。
- en: 'Consider the following code, where we are checking whether the discount value
    is valid:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，我们正在检查折扣值是否有效：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code snippet, we have a field named `_validDiscount`. Let's
    look at what this is doing: `Func` accepts `decimal` as an input and returns `bool`
    as an output. From its name, you can see that `field` stores only valid discounts.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们有一个名为`_validDiscount`的字段。让我们看看它的作用：`Func`接受`decimal`作为输入，并返回`bool`作为输出。从它的名称可以看出，`field`只存储有效的折扣。
- en: '`Func` is a type of delegate that points to a method of one or more arguments
    and returns a value. The general declaration of `Func` is `Func<TParameter, TOutput>`,
    where `TParameter` is the input parameter of any valid datatype and `TOutput`
    is the return value of any valid datatype.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Func`是一种委托类型，指向一个或多个参数的方法，并返回一个值。`Func`的一般声明是`Func<TParameter, TOutput>`，其中`TParameter`是任何有效数据类型的输入参数，`TOutput`是任何有效数据类型的返回值。'
- en: 'Consider the following code snippet, where we are using the `_validDiscount`
    field in a method:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段，我们在一个方法中使用了`_validDiscount`字段：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we have the `FilterOutInvalidDiscountRates` method. This
    method is self-explanatory and indicates that we are filtering out invalid discount
    rates. Let's analyze the code now.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们有`FilterOutInvalidDiscountRates`方法。这个方法不言自明，表明我们正在过滤掉无效的折扣率。现在让我们分析一下代码。
- en: 'The `FilterOutInvalidDiscountRates` method returns a collection of `DiscountViewModel` class
    for the products that have a valid discount. The following code is of our `DiscountViewModel`
    class:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`FilterOutInvalidDiscountRates`方法返回一个具有有效折扣的产品的`DiscountViewModel`类的集合。以下代码是我们的`DiscountViewModel`类的代码：'
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our `DiscountViewModel` class contains the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`DiscountViewModel`类包含以下内容：
- en: '`ProductId`: This represents the ID of a product.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductId`：这代表一个产品的ID。'
- en: '`ProductName`: This represents the name of a product.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductName`：这代表一个产品的名称。'
- en: '`Price`: This contains the actual price of the product. The actual price is
    before any discount, taxes, and so on.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Price`：这包含产品的实际价格。实际价格是在任何折扣、税收等之前。'
- en: '`Discount`: This contains the percentage of a discount such as 10 or 3\. A
    valid discount rate should not be negative, equal to zero, or more than 100% (in
    other words, it should not be more than the actual cost of the product).'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Discount`：这包含折扣的百分比，如10或3。有效的折扣率不应为负数，等于零或超过100%（换句话说，不应超过产品的实际成本）。'
- en: '`Amount`: This contains the product value after any discount, taxes, and so
    on.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Amount`：这包含任何折扣、税收等之后的产品价值。'
- en: Now, let's jump back to our `FilterOutInavlidDiscountRates` method and take
    a look at `viewModels.Select(x => x.Discount).Where(_vallidDiscount)`. Here, you
    might notice that we are selecting discount rates from our `viewModels` list.
    This list contains discount rates that are valid as per the `_validDiscount` field.
    In the next line, our method is returning records with valid discount rates.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的`FilterOutInavlidDiscountRates`方法，看一下`viewModels.Select(x => x.Discount).Where(_vallidDiscount)`。在这里，您可能会注意到我们正在从我们的`viewModels`列表中选择折扣率。这个列表包含根据`_validDiscount`字段有效的折扣率。在下一行，我们的方法返回具有有效折扣率的记录。
- en: In functional programming, these functions are also known as **first-class functions**.
    These are the functions whose values can be used as an input or output for any
    other function. They can also be assigned to variables or stored in collections.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，这些函数也被称为**一等函数**。这些函数的值可以作为任何其他函数的输入或输出使用。它们也可以被分配给变量或存储在集合中。
- en: 'Go to Visual Studio and open the `FlixOne` inventory application. From here,
    run the application and you will see the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 转到Visual Studio并打开`FlixOne`库存应用程序。从这里运行应用程序，您将看到以下屏幕截图：
- en: '![](img/a92e6211-c9db-44ae-8dde-6c0cff7213f5.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a92e6211-c9db-44ae-8dde-6c0cff7213f5.png)'
- en: The previous screenshot is the Product Listing page that is showing all the
    available products. This is a simple page; you can also call it the Product Listing
    dashboard, where you'll find all the products. From Create New Product, you can
    add a new product, and Edit will give you the facility to update an existing product.
    In addition, the Details page will show the complete details of a specific product.
    By clicking Delete, you can remove the existing product from the listing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张屏幕截图是产品列表页面，显示了所有可用的产品。这是一个简单的页面；您也可以称之为产品列表仪表板，在这里您将找到所有产品。从创建新产品，您可以添加一个新产品，编辑将为您提供更新现有产品的功能。此外，详细页面将显示特定产品的完整详细信息。通过单击删除，您可以从列表中删除现有产品。
- en: 'Please refer to our `DiscountViewModel` class. We have the option to have multiple
    discount rates for a product with a business rule, which establishes that only
    one discount rate is active at a time. To view all the discount rates for a product,
    click on a discount rate from the preceding screen (Product Listing). This will
    show the following screen:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考我们的`DiscountViewModel`类。我们有多个产品的折扣率选项，业务规则规定一次只能激活一个折扣率。要查看产品的所有折扣率，请从前一屏幕（产品列表）中单击折扣率。这将显示以下屏幕：
- en: '![](img/70619b88-ea6e-4cbd-814b-22c43ab44ae0.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70619b88-ea6e-4cbd-814b-22c43ab44ae0.png)'
- en: The preceding screen is Product Discount Listing that shows the discount listing
    for the product name Mango. This has two discount rates, but only the Seasonal
    Discount rate is active. You might have noticed the remarks column; this is marked
    as an invalid discount rate because, as per `_validDiscount`—which is discussed
    in the previous section—this discount rate does not match the criteria for a valid
    discount rate.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述屏幕是产品折扣列表，显示了产品名称Mango的折扣列表。这有两个折扣率，但只有季节性折扣率是活动的。您可能已经注意到备注栏；这被标记为无效的折扣率，因为根据前一节讨论的`_validDiscount`，这个折扣率不符合有效折扣率的标准。
- en: '`Predicate` is also a delegate type, similar to `Func` delegates. This represents
    a method that validates the set of criteria. In other words, `Predicate` returns
    the type of `Predicate <T>`, where `T` is a valid datatype. It works if the criteria
    matches and returns a value of type `T`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Predicate`也是一种委托类型，类似于`Func`委托。这代表一个验证一组标准的方法。换句话说，`Predicate`返回`Predicate
    <T>`类型，其中`T`是有效的数据类型。如果标准匹配并返回`T`类型的值，则它起作用。'
- en: 'Consider the following code, where we are validating the Product Name to be
    valid as sentence case:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，我们在其中验证产品名称是否有效为句子大小写：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code, we are using the `Predicate` keyword, and this analyzes
    the condition to validate `ProductName` using `TitleCase` keyword. If the criteria
    matches, the result will be `true`. If not, the result will be `false`. Consider
    the following code snippet, where we are using `_isProductNameTitleCase`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用了`Predicate`关键字，这分析了使用`TitleCase`关键字验证`ProductName`的条件。如果标准匹配，结果将是`true`。如果不匹配，结果将是`false`。考虑以下代码片段，我们在其中使用了`_isProductNameTitleCase`：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we have the `FilterOutInvalidProductNames` method. The
    aim of this method is to pick the products with a valid product name (a `TitleCase`
    product name only).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有`FilterOutInvalidProductNames`方法。该方法的目的是选择具有有效产品名称（仅`TitleCase`产品名称）的产品。
- en: Enhancing our inventory application
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强我们的库存应用程序
- en: The project is for a hypothetical situation where a company, FlixOne, wants
    to enhance an inventory management application to manage its growing collection
    of products. This is not a new application, as we have already started the development
    of this application and discussed the initial stage in [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing
    Design Patterns - Basics Part 1*, where we have started developing a console-based
    inventory system. From time to time, stakeholders will review the application
    and try to meet end users' requirements. The enhancement is important, as this
    application will be used by both staff (to manage the inventory) and by customers
    (to browse and create new orders). The application will need to be scalable, and
    is an essential system for the business.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目是针对一个假设情况，即一家名为FlixOne的公司希望增强一个库存管理应用程序，以管理其不断增长的产品收藏。这不是一个新的应用程序，因为我们已经开始开发这个应用程序，并在[第3章](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml)中讨论了初始阶段，即*实施设计模式
    - 基础部分1*，在那里我们已经开始开发基于控制台的库存系统。利益相关者将不时审查应用程序，并尝试满足最终用户的需求。增强非常重要，因为这个应用程序将被员工（用于管理库存）和客户（用于浏览和创建新订单）使用。该应用程序需要具有可扩展性，并且是业务的重要系统。
- en: As this is a technical book, we will mostly discuss the various technical observations
    from the development team's perspective and discuss the patterns and practices
    used to implement the inventory management application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一本技术书，我们将主要从开发团队的角度讨论各种技术观察，并讨论用于实现库存管理应用的模式和实践。
- en: Requirements
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求
- en: There is a need to enhance the application, and this cannot be achieved in one
    day. This will require a lot of meetings and discussions. Over the course of several
    meetings, the business and the development teams discussed the requirements of
    the new enhancements to the inventory management system. Progress toward defining
    a clear set of requirements was slow, and the vision of the final product was
    not clear. The development team decided to pare down the enormous list of requirements
    to just enough functionality so that a key individual could start to record some
    inventory information. This would allow for simple inventory management and provide
    a basis that the business could extend upon. We will work on the requirement and
    take a **Minimal Viable Product** (**MVP**) approach.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有必要增强应用程序，这不可能在一天内完成。这将需要大量的会议和讨论。在几次会议的过程中，业务和开发团队讨论了对库存管理系统的新增强的要求。定义一组清晰的要求的进展缓慢，最终产品的愿景也不清晰。开发团队决定将庞大的需求列表精简到足够的功能，以便一个关键人物可以开始记录一些库存信息。这将允许简单的库存管理，并为业务提供一个可以扩展的基础。我们将按照需求进行工作，并采取**最小可行产品**（**MVP**）的方法。
- en: MVP is the smallest set of features of an application that can still be released
    and have enough value for a user base.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: MVP是一个应用程序的最小功能集，仍然可以发布并为用户群体提供足够的价值。
- en: 'After several meetings and discussions between management and business analysts,
    a list of requirements was produced to enhance our `FlixOne` web application.
    The high-level requirements are as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理层和业务分析师之间进行了几次会议和讨论后，产生了一系列要求的清单，以增强我们的`FlixOne` web应用程序。高级要求如下：
- en: '**Implementation of pagination**: Currently, all page listings are not paginated.
    It is really challenging to view items with large page counts by scrolling down
    or scrolling up the screen.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分页实现**：目前，所有页面列表都没有分页。通过向下滚动或向上滚动屏幕来查看具有大页数的项目是非常具有挑战性的。'
- en: '**Discount Rates**: Currently, there is no provision to add or see the various
    discount rates for a product. The business rules for discount rates are as follows:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**折扣率**：目前，没有提供添加或查看产品的各种折扣率。折扣率的业务规则如下：'
- en: A product can have more than one discount rate.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个产品可以有多个折扣率。
- en: A product can only have one active discount rate.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个产品只能有一个活动的折扣率。
- en: A valid discount rate should not be a negative value and should not be more
    than 100%.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效的折扣率不应为负值，也不应超过100%。
- en: Back to FlixOne
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到FlixOne
- en: 'In the previous section, we discussed what is required in order to enhance
    an application. In this section, we will implement these requirements. Let''s
    first revisit the file structure of our project. Take a look at the following
    snapshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们讨论了增强应用程序所需的内容。在本节中，我们将实现这些要求。让我们首先重新审视一下我们项目的文件结构。看一下下面的快照：
- en: '![](img/fb23aa69-1daf-4775-b51f-5afe3c7d9bc9.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb23aa69-1daf-4775-b51f-5afe3c7d9bc9.png)'
- en: 'The previous snapshot is depicting our FlixOne web application, having a folder
    structure as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的快照描述了我们的FlixOne web应用程序，其文件夹结构如下：
- en: '**wwwroot**: This is the folder that comes with static contents, such as CSS
    and jQuery files, which are required for the UI project. This folder comes with
    the default template provided by Visual Studio.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wwwroot**：这是一个带有静态内容的文件夹，例如CSS和jQuery文件，这些文件是UI项目所需的。该文件夹带有Visual Studio提供的默认模板。'
- en: '**Common**: This contains all the common files and operations related to business
    rules and more.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共**：这包含所有与业务规则和更多相关的公共文件和操作。'
- en: '**Contexts**: This contains `InventoryContext`, which is a `DBContext` class
    that provides `Entity Framework Core` capabilities.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**：这包含`InventoryContext`，这是一个提供`Entity Framework Core`功能的`DBContext`类。'
- en: '**Controllers**: This contains all the controller classes of our `FlixOne`
    application.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：这包含我们`FlixOne`应用程序的所有控制器类。'
- en: '**Migration**: This contains the `InventoryModel` snapshot and initially created
    entities.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迁移**：这包含了`InventoryModel`的快照和最初创建的实体。'
- en: '**Models:** This contains data models, `ViewModels`, that are required for
    our application.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这包含了我们应用程序所需的数据模型、`ViewModels`。'
- en: '**Persistence:** This contains the  `InventoryRepository` and its operations.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：这包含了`InventoryRepository`及其操作。'
- en: '**Views**: This contains all the views/screens of the application.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这包含了应用程序的所有视图/屏幕。'
- en: 'Consider the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code contains an `IHelper` interface that is holding two methods.
    We will implement this interface in the following code snippet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码包含一个`IHelper`接口，其中包含两个方法。我们将在下面的代码片段中实现这个接口：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `Helper` class implements the `IHelper` interface. In this class, we have
    two main, and important, methods: one is to check for a valid discount and the
    other is to check for a valid  `ProductName` attribute.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Helper`类实现了`IHelper`接口。在这个类中，我们有两个主要且重要的方法：一个是检查有效折扣，另一个是检查有效的`ProductName`属性。'
- en: 'Before we use this functionality in our application, we should add this to
    our `Startup.cs` file, as shown in the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用这个功能之前，我们应该将它添加到我们的`Startup.cs`文件中，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code snippet, we have a written statement, `services.AddTransient<IHelper,
    Helper>();`. With this, we are adding a transient service to our application.
    We have already discussed the *Inversion of control* section in [Chapter 5](fd71001a-4673-4391-a10b-2490e07f135e.xhtml), *Implementing
    Design Patterns - .Net Core*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们有一个写入语句，`services.AddTransient<IHelper, Helper>();`。通过这样做，我们向我们的应用程序添加了一个瞬态服务。我们已经在[第5章](fd71001a-4673-4391-a10b-2490e07f135e.xhtml)中讨论了*控制反转*部分，*实现设计模式-.Net
    Core*。
- en: 'Consider the following code, where we are using the `IHelper` class by taking
    leverage of Inversion of control:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，我们在这里使用`IHelper`类，利用了控制反转：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code contains the `InventoryRepository` class, where we can see
    the use of a proper **Dependency Injection** (**DI**):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码包含了`InventoryRepository`类，我们可以看到适当使用了**依赖注入**（**DI**）：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code is the `GetDiscountBy` method of the `InventoryRepository`
    class that is a returning collection of the discount model for the `active` or
    `de-active` records. Consider the following code snippet that is used for the `DiscountViewModel`
    collection:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码是`InventoryRepository`类的`GetDiscountBy`方法，它返回了`active`或`de-active`记录的折扣模型集合。考虑以下用于`DiscountViewModel`集合的代码片段：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code that uses a collection of `DiscountViewModel` is filtering
    out the products that do not have a valid discount as per the business rule we
    discussed previously. The `GetValidDiscountProducts` method returns the collection
    of `DiscountViewModel`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码使用了一个`DiscountViewModel`集合，过滤掉了根据我们之前讨论的业务规则没有有效折扣的产品。`GetValidDiscountProducts`方法返回`DiscountViewModel`的集合。
- en: 'If we forget to define `IHelper` in our project `startup.cs` file, we will
    meet an exception, as shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忘记在项目的`startup.cs`文件中定义`IHelper`，我们将会遇到一个异常，如下面的截图所示：
- en: '![](img/18dae3fc-bf2b-4296-be43-c0447ffc8d47.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18dae3fc-bf2b-4296-be43-c0447ffc8d47.png)'
- en: The preceding screenshot is clearly saying that the `IHelper` service is not
    resolved. In our case, we will not face this exception, as we have already added
    `IHelper` to the `Startup` class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图清楚地表明`IHelper`服务没有被解析。在我们的情况下，我们不会遇到这个异常，因为我们已经将`IHelper`添加到了`Startup`类中。
- en: 'Until now, we have added helper methods to fulfill our new requirement for
    discount rates and to validate them. Now, let''s add a controller and subsequent
    action methods. To do so, add a new `DiscountController` controller from Solution
    Explorer. After this, our `FlixOne` web solution will look similar to the following
    snapshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经添加了辅助方法来满足我们对折扣率的新要求，并对其进行验证。现在，让我们添加一个控制器和随后的操作方法。为此，从解决方案资源管理器中添加一个新的`DiscountController`控制器。之后，我们的`FlixOne`
    web解决方案将看起来类似于以下快照：
- en: '![](img/8c9cb2fd-c823-4cd2-bcac-143a3fd6ff2c.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c9cb2fd-c823-4cd2-bcac-143a3fd6ff2c.png)'
- en: 'In the preceding snapshot, we can see that our `Controller` folder now has
    one additional controller, which is `DiscountController`.  The following code
    is from `DiscountController`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的快照中，我们可以看到我们的`Controller`文件夹现在有一个额外的控制器，即`DiscountController`。以下代码来自`DiscountController`：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Execute the application and, from the main screen, click on Products and then
    click on Product Discount Listing. From here, you will get the following screen:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 执行应用程序，并从主屏幕上点击产品，然后点击产品折扣清单。从这里，你将得到以下屏幕：
- en: '![](img/b228c14a-47b4-427b-9f13-b4bff9507521.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b228c14a-47b4-427b-9f13-b4bff9507521.png)'
- en: The preceding snapshot is depicting Product Discount Listing for all the available
    products. The Product Discount Listing has a lot of records; therefore, it requires
    scrolling up or scrolling down to view items on the screen. To handle this difficult
    situation, we should implement paging.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的快照描述了所有可用产品的产品折扣清单。产品折扣清单有很多记录，因此需要向上或向下滚动以查看屏幕上的项目。为了处理这种困难的情况，我们应该实现分页。
- en: Strategy pattern and functional programming
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式和函数式编程
- en: During the first four chapters of this book, we discussed patterns and practices
    a lot. The strategy pattern is one of the important patterns of **Gang of Four** (**GoF**) patterns.
    This falls under the behavioral patterns category and is also known as a policy
    pattern. This is a pattern that is usually implemented with the help of classes.
    This is also an easier one to implement using functional programming.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前四章中，我们讨论了很多模式和实践。策略模式是**四人帮**模式中的重要模式之一。这属于行为模式类别，也被称为策略模式。这通常是使用类来实现的模式。这也是一个更容易使用函数式编程实现的模式。
- en: Jump back to the *Understanding functional programming* section of this chapter
    and reconsider the paradigm of functional programming. Higher-order functions
    are one of the important paradigms of functional programming; using this, we can
    easily implement a strategy pattern in a functional way.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 回到本章的*理解函数式编程*部分，重新考虑函数式编程的范式。高阶函数是函数式编程的重要范式之一；使用它，我们可以轻松地以函数式的方式实现策略模式。
- en: '**Higher-order functions** (**HOFs**) are the functions that take parameters
    as functions. They can also return functions.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**高阶函数**（**HOFs**）是接受函数作为参数的函数。它们也可以返回函数。'
- en: 'Consider the following code that shows the implementation of HOFs in functional
    programming:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，展示了函数式编程中HOFs的实现：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code is a simple implementation of the `Where` clause, in which
    we used `LINQ Query`. In this, we are iterating a collection and returning an
    item if it meets the criteria. The preceding code can be further simplified. Consider
    the following code for a more simplified version of the preceding code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是`Where`子句的简单实现，我们在其中使用了`LINQ查询`。在这里，我们正在迭代一个集合，并在满足条件时返回一个项。上述代码可以进一步简化。考虑以下更简化版本的代码：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, the `SimplifiedWhere` method produces the same result as the
    previously discussed `Where` method. This method is criteria-based and has a strategy
    to return results, and this criterion executes at runtime. We can easily call
    the preceding function in a subsequent method to take advantage of functional
    programming. Consider the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`SimplifiedWhere`方法产生了与之前讨论的`Where`方法相同的结果。这个方法是基于条件的，并且有一个返回结果的策略，这个条件在运行时执行。我们可以轻松地在后续方法中调用上述函数，以利用函数式编程。考虑以下代码：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have a method called `GetProductsAbovePrice`. In this method, we are providing
    the price. This method is self-explanatory, and it works on a collection of `ProductViewModel`
    with a criteria to list the products that have a product price that is more than
    the parameter price. In our `FlixOne` inventory application, you can find further
    scope to implement functional programming.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`GetProductsAbovePrice`的方法。在这个方法中，我们提供了价格。这个方法很容易理解，它在一个`ProductViewModel`的集合上工作，并根据条件列出产品价格高于参数价格的产品。在我们的`FlixOne`库存应用中，你可以找到更多实现函数式编程的范围。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Functional programming is all about functions and, predominantly, mathematical
    functions. Any language that supports functional programming always works on the
    solution with two main questions: what needs to be solved and how can this be
    solved? We saw functional programming and its easy implementation using the C#
    programming language.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程关注的是函数，主要是数学函数。任何支持函数式编程的语言都会通过两个主要问题来解决问题：需要解决什么，以及如何解决？我们看到了函数式编程及其在C#编程语言中的简单实现。
- en: We also learned about `Func`, `Predicate`, LINQ, `Lambda`, anonymous functions,
    closures, expression trees, currying, closures, and recursion. Finally, we looked into
    the implementation of the strategy pattern using functional programming.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了`Func`、`Predicate`、LINQ、`Lambda`、匿名函数、闭包、表达式树、柯里化、闭包和递归。最后，我们研究了使用函数式编程实现策略模式。
- en: In the next chapter ([Chapter 10](84b551c9-fcee-4017-bea5-31c803184e9f.xhtml),
    *Reactive Programming Patterns and Techniques*), we will discuss reactive programming
    as well as its model and principles. We will also discuss **reactive extensions**.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章（[第10章](84b551c9-fcee-4017-bea5-31c803184e9f.xhtml)，*响应式编程模式和技术*）中，我们将讨论响应式编程以及其模型和原则。我们还将讨论**响应式扩展**。
- en: Questions
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将帮助你巩固本章中包含的信息：
- en: What is functional programming?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是函数式编程？
- en: What is referential transparency in functional programming?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数式编程中的引用透明是什么？
- en: What is a pure function?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是纯函数？
