- en: Understanding the Security Risks and Benefits of Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Docker的安全风险和好处
- en: Docker is a new type of application platform, and it has been built with a strong
    focus on security. You can package an existing application as a Docker image,
    run it in a Docker container, and get significant security benefits without changing
    any code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一种新型的应用平台，它在建设过程中始终专注于安全性。您可以将现有应用程序打包为Docker镜像，在Docker容器中运行，并在不更改任何代码的情况下获得显著的安全性好处。
- en: 'A .NET 2.0 WebForms app currently running on Windows Server 2003 will happily
    run under .NET 4.7 in a Windows container based on Windows Server Core 2019 with
    no code changes: an immediate upgrade that applies 16 years of security patches!
    There are still huge numbers of Windows applications running on Server 2003 which
    is out of support, or Server 2008 which will shortly be out of support. Moving
    to Docker is a great way to bring those apps onto a modern technology stack.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Windows Server Core 2019的Windows容器上运行的.NET 2.0 WebForms应用程序将在不进行任何代码更改的情况下愉快地在.NET
    4.7下运行：这是一个立即应用了16年安全补丁的升级！仍然有大量运行在不受支持的Server 2003上或即将不受支持的Server 2008上的Windows应用程序。转移到Docker是将这些应用程序引入现代技术栈的绝佳方式。
- en: Security in Docker encompasses a wide range of topics, which I will cover in
    this chapter. I'll explain the security aspects of containers and images, the
    extended features in **Docker Trusted Registry** (**DTR**), and the secure configuration
    of Docker in swarm mode.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的安全涵盖了广泛的主题，我将在本章中进行介绍。我将解释容器和镜像的安全方面，**Docker Trusted Registry**（**DTR**）中的扩展功能，以及在swarm模式下的Docker的安全配置。
- en: 'In this chapter I''ll look at some of the internals of Docker to show how security
    is implemented. I''ll cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将深入研究Docker的内部，以展示安全性是如何实现的。我将涵盖：
- en: Understanding container security
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解容器安全性
- en: Securing applications with secure Docker images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用安全的Docker镜像保护应用程序
- en: Securing the software supply chain with DTR
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DTR保护软件供应链
- en: Understanding security in swarm mode
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解swarm模式下的安全性
- en: Understanding container security
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解容器安全性
- en: Application processes running in Windows Server containers are actually running
    on the host. If you run multiple ASP.NET applications in containers, you'll see
    multiple `w3wp.exe` processes in the task list on the host machine. Sharing the
    operating system kernel between containers is how Docker containers are so efficient—the
    container doesn't load its own kernel, so the startup and shutdown times are very
    fast and the overhead on runtime resources is minimal.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Server容器中运行的应用程序进程实际上是在主机上运行的。如果在容器中运行多个ASP.NET应用程序，您将在主机机器的任务列表中看到多个`w3wp.exe`进程。在容器之间共享操作系统内核是Docker容器如此高效的原因——容器不加载自己的内核，因此启动和关闭时间非常快，对运行时资源的开销也很小。
- en: 'Software running inside a container may have security vulnerabilities, and
    the big question security folks ask about Docker is: How secure is the isolation
    between containers? If an app in a Docker container is compromised, that means
    a host process is compromised. Could the attacker use that process to compromise
    other processes, potentially hijacking the host machine or other containers running
    on the host?'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内运行的软件可能存在安全漏洞，安全人员关心的一个重要问题是：Docker容器之间的隔离有多安全？如果Docker容器中的应用程序受到攻击，这意味着主机进程受到了攻击。攻击者能否利用该进程来攻击其他进程，潜在地劫持主机或在主机上运行的其他容器？
- en: Breaking out of a container and compromising other containers and the host could
    be possible if there was a vulnerability in the operating system kernel that the
    attacker could exploit. The Docker platform is built with the principle of security-in-depth,
    so even if that were possible, the platform provides multiple ways to mitigate
    it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作系统内核存在攻击者可以利用的漏洞，那么可能会打破容器并危害其他容器和主机。Docker平台建立在深度安全原则之上，因此即使可能存在这种情况，平台也提供了多种方法来减轻风险。
- en: The Docker platform has near feature parity between Linux and Windows, with
    a few gaps on the Windows side being actively worked on. But Docker has a longer
    history of production deployment on Linux and much of the guidance and tooling
    such as Docker Bench and the CIS Docker Benchmark is specific to Linux. It's useful
    to know the Linux side, but many of the practical points do not apply to Windows
    containers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Docker平台在Linux和Windows之间几乎具有功能上的平等，但Windows方面还存在一些差距，正在积极解决中。但Docker在Linux上有更长的生产部署历史，许多指导和工具，如Docker
    Bench和CIS Docker Benchmark，都是针对Linux的。了解Linux方面是有用的，但许多实际要点不适用于Windows容器。
- en: Container processes
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器进程
- en: 'All Windows processes are started and owned by a user account. The permissions
    of the user account determine whether the process can access files and other resources
    and whether they are available to modify or just to view. In the Docker base image
    for Windows Server Core, there is a default user account called **container administrator**.
    Any process you start in a container from that image will use that user account—you
    can run the `whoami` tool, which just writes out the current username:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Windows进程都由用户帐户启动和拥有。用户帐户的权限决定了进程是否可以访问文件和其他资源，以及它们是否可用于修改或仅用于查看。在Windows
    Server Core的Docker基础映像中，有一个名为**容器管理员**的默认用户帐户。您在容器中从该映像启动的任何进程都将使用该用户帐户-您可以运行`whoami`工具，它只会输出当前用户名：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can run an interactive container by starting a PowerShell and find the
    user ID (SID) of the container administrator account:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过启动PowerShell来运行交互式容器，并找到容器管理员帐户的用户ID（SID）：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You''ll find that the container user always has the same SID, `S-1-5-93-2-1`,
    as the account is part of the Windows image. Due to this, it has the same attributes
    in every container. The container process is really running on the host, but there
    is no **container administrator** user on the host. In fact, if you look at the
    container process on the host, you''ll see a blank entry for the username. I''ll
    start a long-running `ping` process in a background container and check the **process
    ID** (**PID**) inside the container:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现容器用户的SID始终相同，即`S-1-5-93-2-1`，因为该帐户是Windows映像的一部分。由于这个原因，它在每个容器中都具有相同的属性。容器进程实际上是在主机上运行的，但主机上没有**容器管理员**用户。实际上，如果您查看主机上的容器进程，您会看到用户名的空白条目。我将在后台容器中启动一个长时间运行的`ping`进程，并检查容器内的**进程ID**（PID）：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is a Windows Server container running in Docker on Windows Server 2019,
    so the `ping` process is running directly on the host, and the PID inside the
    container will match the PID on the host. On the server, I can check the details
    of that same PID, which is `7704` in this case:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Windows Server 2019上运行的Docker中的Windows Server容器，因此`ping`进程直接在主机上运行，容器内的PID将与主机上的PID匹配。在服务器上，我可以检查相同PID的详细信息，本例中为`7704`：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There is no username because the container user does not map any users on the
    host. Effectively, the host process is running under an anonymous user, and it
    has no permissions on the host, it only has the permissions configured within
    the sandboxed environment of one container. If a Windows Server vulnerability
    was found that allowed attackers to break out of a container, they would be running
    a host process with no access to host resources.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器用户在主机上没有映射任何用户，所以没有用户名。实际上，主机进程是在匿名用户下运行的，并且它在主机上没有权限，它只有在一个容器的沙盒环境中配置的权限。如果发现了允许攻击者打破容器的Windows
    Server漏洞，他们将以无法访问主机资源的主机进程运行。
- en: It's possible that a more extreme vulnerability could allow the anonymous user
    on the host to assume wider privileges, but that would be a major security hole
    in the core Windows permissions stack, one of the scale that typically gets a
    very fast response from Microsoft. The anonymous host user approach is a good
    mitigation to limit the impact of any unknown vulnerabilities.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有更严重的漏洞允许主机上的匿名用户假定更广泛的权限，但这将是核心Windows权限堆栈中的一个重大安全漏洞，这通常会得到微软的非常快速的响应。匿名主机用户方法是限制任何未知漏洞影响的良好缓解措施。
- en: Container user accounts and ACLs
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器用户帐户和ACLs
- en: In a Windows Server Core container, the default user account is the container
    administrator. This account is in the administrator group on the container, so
    it has complete access to the whole filesystem and all the resources on the container.
    The process specified in the `CMD` or `ENTRYPOINT` instruction in a Dockerfile
    will run under the container administrator account.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows Server Core容器中，默认用户帐户是容器管理员。该帐户在容器中是管理员组，因此可以完全访问整个文件系统和容器中的所有资源。在Dockerfile中指定的`CMD`或`ENTRYPOINT`指令中指定的进程将在容器管理员帐户下运行。
- en: This can be problematic if there is a vulnerability in the application. The
    app could be compromised, and, while the chances of an attacker breaking out of
    the container are small, the attacker could still do a lot of damage inside the
    application container. Administrative access means that the attacker could download
    malicious software from the internet and run it in the container or copy state
    from the container to an external location.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序存在漏洞，这可能会有问题。应用程序可能会受到损害，虽然攻击者打破容器的机会很小，但攻击者仍然可以在应用程序容器内造成很大的破坏。管理访问权限意味着攻击者可以从互联网下载恶意软件并在容器中运行，或者将容器中的状态复制到外部位置。
- en: 'You can mitigate this by running container processes under a least-privilege
    user account. The Nano Server images use this approach—they are set up with a
    container administrator user, but the default account for container processes
    is a user without admin permissions. You can see that, by echoing the username
    in a Nano Server container:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以最低特权用户帐户运行容器进程来减轻这种情况。Nano Server映像使用了这种方法 - 它们设置了一个容器管理员用户，但容器进程的默认帐户是一个没有管理员权限的用户。您可以通过在Nano
    Server容器中回显用户名来查看这一点：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The Nano Server image doesn't have the `whoami` command, and it doesn't even
    have PowerShell installed. It is set up with the bare minimum that's necessary
    to run new applications. This is another part of security-in-depth with containers.
    If there was an exploit in the `whoami` command, then your container applications
    could be vulnerable, so Microsoft don't package the command at all. This makes
    sense because you wouldn't use it in a production application. It's still there
    in Windows Server Core to preserve backwards compatibility.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Nano Server镜像没有`whoami`命令，甚至没有安装PowerShell。它只设置了运行新应用程序所需的最低限度。这是容器安全性的另一个方面。如果`whoami`命令中存在漏洞，那么您的容器应用程序可能会受到威胁，因此Microsoft根本不打包该命令。这是有道理的，因为您不会在生产应用程序中使用它。在Windows
    Server Core中仍然存在它，以保持向后兼容性。
- en: The `ContainerUser` account does not have admin access inside the container.
    If you need admin rights to set up your application, you can switch to the admin
    account in your Dockerfile with the `USER ContainerAdministrator` command. But
    if your application doesn't need admin access, you should switch back at the end
    of your Dockerfile with `USER ContainerUser` so that the container startup command
    runs as the least-privilege account.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContainerUser`帐户在容器内没有管理员访问权限。如果需要管理员权限来设置应用程序，可以在Dockerfile中使用`USER ContainerAdministrator`命令切换到管理员帐户。但是，如果您的应用程序不需要管理员访问权限，应该在Dockerfile的末尾切换回`USER
    ContainerUser`，以便容器启动命令以最低特权帐户运行。'
- en: The **Internet Information Services** (**IIS**) and ASP.NET images from Microsoft
    are other examples of running as least-privilege users. The external-facing process
    is the IIS Windows service, which runs under a local account in the `IIS_IUSRS`
    group. This group has read access to the IIS root path `C:\inetpub\wwwroot`, but
    no write access. An attacker could compromise the web application, but they would
    not be able to write files, so the ability to download malicious software is gone.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Microsoft的**Internet Information Services**（**IIS**）和ASP.NET镜像是运行最低特权用户的其他示例。外部进程是运行在`IIS_IUSRS`组中的本地帐户下的IIS
    Windows服务。该组对IIS根路径`C:\inetpub\wwwroot`具有读取访问权限，但没有写入访问权限。攻击者可能会破坏Web应用程序，但他们将无法写入文件，因此下载恶意软件的能力已经消失。
- en: 'In some cases, the web application needs write access to save the state, but
    it can be granted at a very fine level in the Dockerfile. As an example, the open
    source **content management system** (**CMS**) Umbraco can be packaged as a Docker
    image, but the IIS user group needs write permissions to the content folder. Rather
    than changing the Dockerfile to run the service as an administrative account,
    you can set ACL permissions with a `RUN` instruction:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，Web应用程序需要写入访问权限以保存状态，但可以在Dockerfile中以非常细的级别授予。例如，开源**内容管理系统**（**CMS**）Umbraco可以打包为Docker镜像，但IIS用户组需要对内容文件夹进行写入权限。您可以使用`RUN`指令设置ACL权限，而不是更改Dockerfile以将服务作为管理帐户运行。
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I won't go into detail on Umbraco here, but it runs very nicely in a container.
    You can find sample Dockerfiles for Umbraco and lots of other open source software
    in my GitHub repository at [https://github.com/sixeyed/dockerfiles-windows](https://github.com/sixeyed/dockerfiles-windows).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里详细介绍Umbraco，但它在容器中运行得非常好。您可以在我的GitHub存储库[https://github.com/sixeyed/dockerfiles-windows](https://github.com/sixeyed/dockerfiles-windows)中找到Umbraco和许多其他开源软件的示例Dockerfile。
- en: You should use a least-privilege user account to run processes and set ACLs
    as narrowly as possible. This limits the scope for any attackers who gain access
    to the process inside the container, but there are still attack vectors from outside
    the container that you need to consider.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用最低特权用户帐户来运行进程，并尽可能狭隘地设置ACL。这限制了任何攻击者在容器内部获得进程访问权限的范围，但仍然存在来自容器外部的攻击向量需要考虑。
- en: Running containers with resource constraints
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用资源约束运行容器
- en: You can run Docker containers with no constraints, and the container process
    will use as much of the host's resources as it needs. That's the default, but
    it can be an easy attack vector. A malicious user could generate an excess load
    on the application in the container, which could try and grab 100% CPU and memory,
    starving other containers on the host. This is especially significant if you're
    running hundreds of containers that are serving multiple application workloads.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行没有约束的Docker容器，容器进程将使用主机资源的尽可能多。这是默认设置，但可能是一个简单的攻击向量。恶意用户可能会在容器中对应用程序产生过多的负载，尝试占用100%的CPU和内存，使主机上的其他容器陷入饥饿状态。如果您运行着为多个应用程序工作负载提供服务的数百个容器，这一点尤为重要。
- en: Docker has mechanisms to prevent individual containers using excessive resources.
    You can start containers with explicit constraints to limit the resources they
    can use, ensuring no single container consumes the majority of the host's compute
    power. You can limit a container to an explicit number of CPU cores and memory.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Docker有机制来防止单个容器使用过多的资源。您可以启动带有显式约束的容器，以限制它们可以使用的资源，确保没有单个容器占用大部分主机的计算能力。您可以将容器限制为显式数量的CPU核心和内存。
- en: 'I have a simple .NET console app and a Dockerfile to package this in the `ch09-resource-check`
    folder. The application is built to hog compute resources, and I can run it in
    a container to show how Docker limits the impact of a rogue application. I can
    use the app to successfully allocate 600 MB of memory, like so:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个简单的.NET控制台应用程序和一个Dockerfile，可以将其打包到`ch09-resource-check`文件夹中。该应用程序被设计为占用计算资源，我可以在容器中运行它，以展示Docker如何限制恶意应用程序的影响。我可以使用该应用程序成功分配600MB的内存，如下所示：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The console application allocates 600 MB of memory in the container, which
    is actually 600 MB of memory from the server in a Windows Server container. I
    ran the container without any constraints, so the app is able to use as much memory
    as the server has. If I limit the container to 500 MB of memory using a `--memory`
    limit in the `docker container run` command, then the application cannot allocate
    600 MB:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序在容器中分配了600MB的内存，实际上是在Windows Server容器中从服务器中分配了600MB的内存。我在没有任何约束的情况下运行了容器，因此该应用程序可以使用服务器拥有的所有内存。如果我使用`docker
    container run`命令中的`--memory`限制将容器限制为500MB的内存，那么该应用程序将无法分配600MB：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The sample application can also hog the CPU. It computes Pi to a given number
    of decimal places, which is a computationally expensive operation. In an unrestricted
    container, computing Pi to 20,000 decimal places takes just under a second on
    my quad-core development laptop:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序也可以占用CPU。它计算Pi的小数点位数，这是一个计算成本高昂的操作。在不受限制的容器中，计算Pi到20000位小数只需要在我的四核开发笔记本上不到一秒钟：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'I can use a CPU restriction by specifying a `--cpu` limit in the `run` command,
    and Docker will limit the compute resources available to this container, retaining
    more CPU for other tasks. The same computation takes more than twice as long:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以通过在`run`命令中指定`--cpu`限制来使用CPU限制，并且Docker将限制可用于此容器的计算资源，为其他任务保留更多的CPU。相同的计算时间超过了两倍：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The same memory and CPU constraints can be applied to a production Docker Swarm
    deployment by using resource limits in the deploy section. This example limits
    the new NerdDinner REST API to 25% of available CPU and 250 MB of memory:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 生产Docker Swarm部署可以使用部署部分的资源限制来应用相同的内存和CPU约束。这个例子将新的NerdDinner REST API限制为可用CPU的25%和250MB的内存：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It can be challenging to verify that the resource constraints are in place.
    The underlying Windows APIs to get the CPU count and memory capacity use the OS
    kernel, and in a container that will be the host''s kernel. The kernel reports
    the full hardware spec, so the limits don''t appear to be in place inside the
    container, but they are enforced. You can use WMI to check the constraints, but
    the output will not be as expected:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 验证资源限制是否生效可能是具有挑战性的。获取 CPU 计数和内存容量的底层 Windows API 使用操作系统内核，在容器中将是主机的内核。内核报告完整的硬件规格，因此限制似乎不会在容器内生效，但它们是强制执行的。您可以使用
    WMI 来检查限制，但输出将不如预期：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the container reports four CPUs and 16 GB of RAM, even though it has been
    constrained to one CPU and 1 GB of RAM. The constraints are actually in place,
    but they operate at a level above the WMI call. If a process running inside the
    container tried to allocate more than 1 GB of RAM, then it would fail.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，容器报告有四个 CPU 和 16 GB 的 RAM，尽管它被限制为一个 CPU 和 1 GB 的 RAM。实际上已经施加了限制，但它们在 WMI
    调用的上层操作。如果容器内运行的进程尝试分配超过 1 GB 的 RAM，那么它将失败。
- en: Remember that only Windows Server containers have access to all the host's compute
    power, where the container process is actually running on the host. Hyper-V containers
    each have a lightweight VM where the process is running, and that VM has its own
    allocation of CPU and memory. You can apply container limits using the same Docker
    commands, and they're applied to the container's VM.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，只有 Windows Server 容器才能访问主机的所有计算能力，容器进程实际上是在主机上运行的。Hyper-V 容器每个都有一个轻量级的虚拟机，进程在其中运行，该虚拟机有自己的
    CPU 和内存分配。您可以使用相同的 Docker 命令应用容器限制，并且这些限制适用于容器的虚拟机。
- en: Running containers with restricted capabilities
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用受限制的功能运行容器
- en: There are two useful features of the Docker platform to restrict what applications
    can do inside containers. Currently, they only work with Linux containers, but
    they are worth understanding if you need to deal with mixed workloads, and support
    for Windows may be coming in future versions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 平台有两个有用的功能，可以限制容器内应用程序的操作。目前，它们只适用于 Linux 容器，但如果您需要处理混合工作负载，并且对 Windows
    的支持可能会在未来版本中推出，那么了解它们是值得的。
- en: Linux containers can be run with the `read-only` flag, which creates the container
    with a read-only filesystem. This option can be used with any image, and it will
    start a container with the same entry process as usual. The difference is that
    the container does not have a writeable filesystem layer, so no files can be added
    or changed—the container cannot modify the contents of the image.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 容器可以使用 `read-only` 标志运行，这将创建一个具有只读文件系统的容器。此选项可与任何镜像一起使用，并将启动一个具有与通常相同入口进程的容器。不同之处在于容器没有可写文件系统层，因此无法添加或更改文件
    - 容器无法修改镜像的内容。
- en: This is a useful security feature. A web application could have a vulnerability
    that allows attackers to execute code on the server, but a read-only container
    severely limits what the attacker can do. They cannot change application configuration
    files, alter access permissions, download new malware, or replace application
    binaries.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的安全功能。Web 应用程序可能存在漏洞，允许攻击者在服务器上执行代码，但只读容器严重限制了攻击者的操作。他们无法更改应用程序配置文件，更改访问权限，下载新的恶意软件或替换应用程序二进制文件。
- en: Read-only containers can be combined with Docker volumes, so applications can
    write to known locations for logging or caching data. If you have an application
    that writes to the filesystem, that's how you can run it in a read-only container
    without changing functionality. You need to be aware that if you write logs to
    a file in a volume and an attacker has gained access to the filesystem, they could
    read historical logs, which they can't do if logs are written to standard output
    and consumed by the Docker platform.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 只读容器可以与Docker卷结合使用，以便应用程序可以写入已知位置以记录日志或缓存数据。如果您有一个写入文件系统的应用程序，那么您可以在只读容器中运行它而不改变功能。您需要意识到，如果您将日志写入卷中的文件，并且攻击者已经访问了文件系统，他们可以读取历史日志，而如果日志写入标准输出并被Docker平台消耗，则无法这样做。
- en: When you run Linux containers, you can also explicitly add or drop the system
    capabilities that are available to the container. As an example, you can start
    a container without the `chown` capability, so no process inside the container
    can change file access permissions. Similarly, you can restrict binding to network
    ports or write access to kernel logs.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行Linux容器时，您还可以明确添加或删除容器可用的系统功能。例如，您可以启动一个没有`chown`功能的容器，因此容器内部的任何进程都无法更改文件访问权限。同样，您可以限制绑定到网络端口或写入内核日志的访问。
- en: The `read-only`, `cap-add`, and `cap-drop` options have no effect on Windows
    containers, but support may come in future versions of Docker on Windows.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`只读`，`cap-add`和`cap-drop`选项对Windows容器没有影响，但是在未来的Docker on Windows版本中可能会提供支持。'
- en: One great thing about Docker is that the open source components are built into
    the supported Docker Enterprise version. You can make feature requests and track
    bugs on GitHub in the `moby/moby` repository, which is the source code for Docker
    Community Edition. When features are implemented in Docker CE, they become available
    in the subsequent Docker Enterprise release.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的一个很棒的地方是，开源组件内置在受支持的Docker Enterprise版本中。您可以在GitHub的`moby/moby`存储库中提出功能请求和跟踪错误，这是Docker社区版的源代码。当功能在Docker
    CE中实现后，它们将在随后的Docker Enterprise版本中可用。
- en: Windows containers and Active Directory
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows容器和Active Directory
- en: Large organizations use **Active Directory** (**AD**) to manage all the users,
    groups, and machines in their Windows network. Application servers can be domain-joined,
    giving them access to AD for authentication and authorization. This is how internal
    web applications in .NET are usually deployed. The app uses Windows authentication
    to give users single sign-on, and the IIS application pool runs as a service account
    that has access to SQL Server.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 大型组织使用**Active Directory**（**AD**）来管理他们Windows网络中的所有用户，组和机器。应用服务器可以加入域，从而可以访问AD进行身份验证和授权。这通常是.NET内部Web应用程序部署的方式。该应用程序使用Windows身份验证为用户提供单一登录，而IIS应用程序池则以访问SQL
    Server的服务帐户运行。
- en: Servers running Docker can be domain-joined, but the containers on the machine
    are not. You can run a legacy ASP.NET app in a container, but with a default deployment
    you'll find that Windows authentication does not work for the users, and the application
    itself can't connect to the database.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Docker的服务器可以加入域，但是机器上的容器不能。您可以在容器中运行传统的ASP.NET应用程序，但是在默认部署中，您会发现Windows身份验证对用户不起作用，应用程序本身也无法连接到数据库。
- en: 'This is a deployment concern, and you can give Windows containers access to
    AD using a **group-Managed Service Account** (**gMSA**), which is a type of AD
    account that you can use without a password. Active Directory quickly becomes
    a complex topic, so I will just give an overview here so that you''re aware that
    you can make use of AD services inside your containers:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个部署问题，您可以使用**组管理服务帐户**（**gMSA**）为Windows容器提供对AD的访问权限，这是一种无需密码即可使用的AD帐户类型。Active
    Directory很快就会变成一个复杂的话题，所以我在这里只是给出一个概述，让您知道您可以在容器内部使用AD服务：
- en: A domain administrator creates the gMSA in Active Directory. This requires one
    domain controller to be running on Windows Server 2012 or later.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域管理员在Active Directory中创建gMSA。这需要一个域控制器在运行Windows Server 2012或更高版本。
- en: Grant access permission for the gMSA to your Docker servers.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为gMSA授予对Docker服务器的访问权限。
- en: Use the `CredentialSpec` PowerShell module to generate a JSON-formatted credential
    specification for the gMSA.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`CredentialSpec` PowerShell模块为gMSA生成JSON格式的凭据规范。
- en: Run containers with the `security-opt` flag, specifying the path to the JSON
    credential spec.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`security-opt`标志运行容器，指定JSON凭据规范的路径。
- en: The application in the container is effectively domain-joined, and can use AD
    with the permissions that have been assigned to the gMSA.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器中的应用程序实际上是加入域的，并且可以使用已分配给gMSA的权限来使用AD。
- en: Accessing AD services from inside a container is much easier in Windows Server
    2019\. Previously, there were restrictions on the names you had to use for the
    gMSA, which made it difficult to apply credential specifications when you were
    running in Docker Swarm. Now, you can use any name for your gMSA, and use one
    gMSA for many containers. Docker Swarm supports credential specifications in the
    compose file via the use of the `credential_spec` value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从容器内部访问AD服务在Windows Server 2019中要容易得多。以前，您在Docker Swarm中运行时必须使用特定名称的gMSA，这使得在运行时应用凭据规范变得困难。现在，您可以为gMSA使用任何名称，并且一个gMSA可以用于多个容器。Docker
    Swarm通过使用`credential_spec`值在compose文件中支持凭据规范。
- en: 'There''s a full walkthrough of creating and using a gMSA and a credential spec
    in Microsoft''s container documentation on GitHub: [https://github.com/MicrosoftDocs/Virtualization-Documentation/tree/live/windows-server-container-tools/ServiceAccounts](https://github.com/MicrosoftDocs/Virtualization-Documentation/tree/live/windows-server-container-tools/ServiceAccounts).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Microsoft的GitHub容器文档中有一个完整的创建和使用gMSA和凭据规范的演练：[https://github.com/MicrosoftDocs/Virtualization-Documentation/tree/live/windows-server-container-tools/ServiceAccounts](https://github.com/MicrosoftDocs/Virtualization-Documentation/tree/live/windows-server-container-tools/ServiceAccounts)。
- en: Isolation in Hyper-V containers
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hyper-V容器中的隔离
- en: 'Docker on Windows has one big security feature that Docker on Linux does not
    have: extended isolation with Hyper-V containers. Containers running on Windows
    Server 2019 use the host''s operating system kernel. You can see this when you
    run a container, and the process inside the container is listed on Task Manager
    on the host.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Windows上的Docker具有一个大的安全功能，Linux上的Docker没有：使用Hyper-V容器进行扩展隔离。运行在Windows Server
    2019上的容器使用主机的操作系统内核。当您运行容器时，可以在主机的任务管理器上看到容器内部的进程。
- en: On Windows 10, the default behavior is different. With the Windows 1809 update,
    you can run Windows Server containers with process isolation on Windows 10 by
    adding the `--isolation=process` flag to your docker container run commands. You
    need to specify the isolation level in the command or in the Docker configuration
    file, because the default on Windows 10 is `hyperv`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows 10上，默认行为是不同的。通过Windows 1809更新，您可以通过在docker容器运行命令中添加`--isolation=process`标志在Windows
    10上以进程隔离的方式运行Windows Server容器。您需要在命令中或Docker配置文件中指定隔离级别，因为在Windows 10上默认值是`hyperv`。
- en: Containers with their own kernel are called **Hyper-V** containers. They are
    implemented with a lightweight virtual machine that provides the server kernel,
    but this is not a full VM and doesn't have the typical overhead of a VM. Hyper-V
    containers use normal Docker images and they run in the normal Docker engine in
    the same way as all containers. They don't show in the Hyper-V management tool
    because they are not full virtual machines.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 具有自己内核的容器称为**Hyper-V**容器。它们是使用轻量级虚拟机实现的，提供服务器内核，但这不是完整的虚拟机，也没有典型的虚拟机开销。Hyper-V容器使用普通的Docker镜像，并且它们以与所有容器相同的方式在普通的Docker引擎中运行。它们不会显示在Hyper-V管理工具中，因为它们不是完整的虚拟机。
- en: 'Hyper-V containers can also be run on Windows Server using the `isolation`
    option. This command runs the IIS image as a Hyper-V container, publishing port
    `80` to a random port on the host:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Hyper-V容器也可以在Windows Server上使用`isolation`选项运行。此命令将IIS镜像作为Hyper-V容器运行，将端口`80`发布到主机上的随机端口：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The container behaves in the same way. External users can browse to port `80`
    on the host and the traffic is handled by the container. On the host, you can
    run `docker container inspect` to see the IP address and go to the container directly.
    Features such as Docker networking, volumes, and swarm mode work in the same way
    for Hyper-V containers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的行为方式相同。外部用户可以浏览主机上的`80`端口，流量由容器处理。在主机上，您可以运行`docker container inspect`来查看IP地址并直接进入容器。Docker网络、卷和集群模式等功能对Hyper-V容器也适用。
- en: The extended isolation of Hyper-V containers offers additional security. There
    is no shared kernel, so even if a kernel vulnerability allowed the container application
    to access the host, the host is just a thin VM layer running in its own kernel.
    There are no other processes or containers running on that kernel, so there is
    no ability for attackers to compromise other workloads.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Hyper-V容器的扩展隔离提供了额外的安全性。没有共享内核，因此即使内核漏洞允许容器应用程序访问主机，主机也只是在自己的内核中运行的薄型VM层。在该内核上没有其他进程或容器运行，因此攻击者无法危害其他工作负载。
- en: Hyper-V containers have additional overheads because of the separate kernels.
    They typically have a slower startup time, and by default they impose memory and
    CPU limits, restricting resources at the kernel level that the container can't
    exceed. In some scenarios, the trade-off is worthwhile. In multi-tenant situations,
    where you assume zero trust for every workload, extended isolation can be a useful
    defense.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有单独的内核，Hyper-V容器有额外的开销。它们通常启动时间较慢，并且默认情况下会施加内存和CPU限制，限制容器在内核级别无法超过的资源。在某些情况下，这种权衡是值得的。在多租户情况下，您对每个工作负载都假定零信任，扩展隔离可以是一种有用的防御。
- en: Licensing is different for Hyper-V containers. Normal Windows Server containers
    are licensed at the host level, so you need a license for each server, and then
    you can run as many containers as you like. Hyper-V containers each have their
    own kernel, and there are licensing levels that restrict the number of containers
    you can run on each host.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Hyper-V容器的许可证不同。普通的Windows Server容器在主机级别获得许可，因此您需要为每台服务器获得许可，然后可以运行任意数量的容器。每个Hyper-V容器都有自己的内核，并且有限制您可以在每个主机上运行的容器数量的许可级别。
- en: Securing applications with secure Docker images
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用安全的Docker镜像保护应用程序
- en: I've covered many aspects of securing containers at runtime, but the Docker
    platform provides security in depth that starts before any containers are run.
    You can start securing your application by securing the image that packages your
    application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经涵盖了许多关于运行时保护容器的方面，但Docker平台在任何容器运行之前就提供了深度安全性。您可以通过保护打包应用程序的镜像来开始保护您的应用程序。
- en: Building minimal images
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建最小化镜像
- en: It's unlikely that an attacker can compromise your application and gain access
    to the container, but you should build your image to mitigate the damage if that
    happens. Building a minimal image is key. The ideal Docker image should contain
    nothing more than the application and the dependencies it needs to run.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者不太可能破坏您的应用程序并访问容器，但如果发生这种情况，您应该构建您的映像以减轻损害。构建最小映像至关重要。理想的Docker映像应该只包含应用程序和运行所需的依赖项。
- en: This is more difficult to achieve for Windows applications than Linux apps.
    A Docker image for a Linux app can use a minimal distribution as the base, packaging
    just the application binaries on top. The attack surface for that image is very
    small. Even if an attacker gained access to the container, they would find themselves
    in an operating system with very few features.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于Windows应用程序比Linux应用程序更难实现。 Linux应用程序的Docker映像可以使用最小的发行版作为基础，在其上只打包应用程序二进制文件。该映像的攻击面非常小。即使攻击者访问了容器，他们会发现自己处于一个功能非常有限的操作系统中。
- en: In contrast, Docker images using Windows Server Core have a fully featured operating
    system at the base. The minimal alternative is Nano Server, which has a significantly
    reduced Windows API and does not even have PowerShell installed, which removes
    a large feature set that could be exploited. In theory, you can remove features,
    disable Windows Services, and even delete Windows binaries in your Dockerfile
    to limit the capabilities of the final image. However, you would need to do a
    lot of testing to be sure that your app would run correctly in your customized
    version of Windows.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，使用Windows Server Core的Docker映像具有完整功能的操作系统作为基础。最小的替代方案是Nano Server，它具有大大减少的Windows
    API，甚至没有安装PowerShell，这消除了可以被利用的大量功能集。理论上，您可以在Dockerfile中删除功能，禁用Windows服务，甚至删除Windows二进制文件，以限制最终映像的功能。但是，您需要进行大量测试，以确保您的应用程序在定制的Windows版本中能够正确运行。
- en: Docker's recognition for experts and community leaders is the Captain's program.
    Docker Captains are like Microsoft MVPs, and Stefan Scherer is both a Captain
    and an MVP. Stefan has done some promising work by looking at reducing Windows
    image size by creating images with an empty filesystem and adding a minimal set
    of Windows binaries.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Docker对专家和社区领袖的认可是Captain计划。 Docker Captains就像Microsoft MVPs，Stefan Scherer既是Captain又是MVP。
    Stefan通过创建带有空文件系统并添加最小一组Windows二进制文件的镜像来减小Windows镜像大小，做了一些有前途的工作。
- en: 'You can''t easily limit the features of the base Windows image, but you can
    limit what you add on top. Wherever possible, you should add just your application
    content and the minimal application runtime so that an attacker can''t modify
    the app. Some programming languages have better support for this than others,
    for example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法轻松限制基本Windows映像的功能，但可以限制您在其上添加的内容。在可能的情况下，您应该只添加您的应用程序内容和最小的应用程序运行时，以便攻击者无法修改应用程序。一些编程语言对此的支持要比其他语言好，例如：
- en: Go applications can be compiled to native binaries, so you only need to package
    the executable in your Docker image, not the full Go runtime.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go应用程序可以编译为本机二进制文件，因此您只需要在Docker映像中打包可执行文件，而不是完整的Go运行时。
- en: .NET Core apps can be published as assemblies, so you only need to package the
    .NET Core runtime to execute them, not the full .NET Core SDK.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core应用程序可以发布为程序集，因此您只需要打包.NET Core运行时来执行它们，而不是完整的.NET Core SDK。
- en: .NET Framework apps need the matching .NET Framework installed in the container
    image, but you can still minimize the app content that you package. You should
    compile the app in release mode and ensure that you don't package debug files.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Framework应用程序需要在容器映像中安装匹配的.NET Framework，但您仍然可以最小化打包的应用程序内容。您应该以发布模式编译应用程序，并确保不打包调试文件。
- en: Node.js uses V8 as an interpreter and compiler, so, to run apps in Docker, the
    image needs to have the full Node.js runtime installed, and the full source code
    for the app needs to be packaged.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js使用V8作为解释器和编译器，因此，要在Docker中运行应用程序，镜像需要安装完整的Node.js运行时，并且需要打包应用程序的完整源代码。
- en: You will be limited by what your application stack supports, but a minimal image
    is the goal. If your application will run on Nano Server, it's definitely preferable
    to Windows Server Core. Full .NET apps don't run on Nano Server but .NET Standard
    is advancing rapidly, so it could be a viable option to port your app to .NET
    Core, which can then run on Nano Server.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您将受到应用程序堆栈支持的限制，但最小镜像是目标。如果您的应用程序将在Nano Server上运行，那么与Windows Server Core相比，Nano
    Server肯定更可取。完整的.NET应用程序无法在Nano Server上运行，但.NET Standard正在迅速发展，因此将应用程序移植到.NET Core可能是一个可行的选择，然后可以在Nano
    Server上运行。
- en: When you run your application in Docker, the unit you work with is the container,
    and you administer and monitor it using Docker. The underlying operating system
    doesn't affect how you interact with the container, so having a minimal OS doesn't
    limit what you can do with your application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在Docker中运行应用程序时，您使用的单元是容器，并且使用Docker进行管理和监控。底层操作系统不会影响您与容器的交互方式，因此拥有最小的操作系统不会限制您对应用程序的操作。
- en: Docker Security Scanning
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker安全扫描
- en: A minimal Docker image could still contain software with known vulnerabilities.
    Docker images use a standard, open format, which means that tools can be reliably
    built to navigate and inspect image layers. One tool is Docker Security Scanning,
    which examines the software inside Docker images for vulnerabilities.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最小的Docker镜像仍然可能包含已知漏洞的软件。Docker镜像使用标准的开放格式，这意味着可以可靠地构建工具来导航和检查镜像层。一个工具是Docker安全扫描，它检查Docker镜像中的软件是否存在漏洞。
- en: Docker Security Scanning looks at all the binary files in the image, in your
    application dependencies, the application framework, and even the operating system.
    Every binary is checked against multiple **Common Vulnerability and Exploit**
    (**CVE**) databases, looking for known vulnerabilities. If any issues are found,
    Docker reports the details.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Docker安全扫描检查镜像中的所有二进制文件，包括应用程序依赖项、应用程序框架甚至操作系统。每个二进制文件都会根据多个**通用漏洞和利用**（**CVE**）数据库进行检查，寻找已知的漏洞。如果发现任何问题，Docker会报告详细信息。
- en: 'Docker Security Scanning is available on Docker Hub for official repositories
    and on the Docker Trusted Registry for your own private registry. The web interface
    of those systems shows the output of each scan. Minimal images such as Alpine
    Linux can be completely free of vulnerabilities:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Docker安全扫描可用于Docker Hub的官方存储库以及Docker Trusted Registry的私有存储库。这些系统的Web界面显示了每次扫描的输出。像Alpine
    Linux这样的最小镜像可能完全没有漏洞：
- en: '![](Images/9f1d7121-06c6-4dcf-baa3-ab74a483095f.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9f1d7121-06c6-4dcf-baa3-ab74a483095f.png)'
- en: 'The official NATS image has a Nano Server 2016 variant, and you can see that
    there is a vulnerability in that image:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 官方NATS镜像有一个Nano Server 2016变体，您可以看到该镜像中存在漏洞：
- en: '![](Images/ecb59cef-aa94-407c-85a5-92798a94e8c8.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ecb59cef-aa94-407c-85a5-92798a94e8c8.png)'
- en: Where there are vulnerabilities, you can drill down to see exactly which binaries
    are flagged, and that links off to the CVE database, describing the vulnerability.
    In the case of the `nats:nanoserver` image, there are vulnerabilities in the versions
    of zlib and SQLite, which packaged in the Nano Server base image.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在存在漏洞的地方，您可以深入了解到底有哪些二进制文件被标记，并且链接到CVE数据库，描述了漏洞。在`nats:nanoserver`镜像的情况下，Nano
    Server基础镜像中打包的zlib和SQLite版本存在漏洞。
- en: 'These scan results are from official images on Docker Hub. Docker Enterprise
    provides security scanning in DTR too, and you can run manual scans on demand
    or configure any push to the repository to trigger a scan. I''ve created a repository
    for the NerdDinner web application, which is configured to scan on every image
    push:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些扫描结果来自Docker Hub上的官方镜像。Docker Enterprise还在DTR中提供安全扫描，您可以按需运行手动扫描，或配置任何推送到存储库的操作来触发扫描。我已经为NerdDinner
    web应用程序创建了一个存储库，该存储库配置为在每次推送图像时进行扫描：
- en: '![](Images/41764876-a665-4d54-b05c-9c8d25b49bf1.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/41764876-a665-4d54-b05c-9c8d25b49bf1.png)'
- en: Access to this repository is based on the same security setup from [Chapter
    8](98e12163-b4ad-4b5d-aecc-827f5e204caa.xhtml), *Administering and Monitoring
    Dockerized Solutions*, with the **nerd-dinner** organization and the **Nerd Dinner
    Ops** team. DTR uses the same authorization as UCP, so you build organizations
    and teams once in Docker Enterprise and you can use them to secure images and
    runtime resources. The user **elton** is in the **Nerd Dinner Ops** team, with
    read-write access to the **nerd-dinner-web** repository, which means access to
    push and pull images.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对该存储库的访问基于[第8章](98e12163-b4ad-4b5d-aecc-827f5e204caa.xhtml)中相同的安全设置，即*管理和监控Docker化解决方案*，使用**nerd-dinner**组织和**Nerd
    Dinner Ops**团队。DTR使用与UCP相同的授权，因此您可以在Docker Enterprise中构建组织和团队一次，并将它们用于保护图像和运行时资源。用户**elton**属于**Nerd
    Dinner Ops**团队，对**nerd-dinner-web**存储库具有读写访问权限，这意味着可以推送和拉取图像。
- en: 'When I push an image to this repository, Docker Trusted Registry will begin
    a security scan, thus identifying all the binaries in every layer of the image
    and checking them all for known vulnerabilities in the CVE databases. The NerdDinner
    web application is based on Microsoft''s ASP.NET image, and, at the time of writing,
    there are known vulnerabilities with components in that image:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我向这个存储库推送图像时，Docker Trusted Registry将开始进行安全扫描，从而识别图像每个层中的所有二进制文件，并检查它们是否存在CVE数据库中已知的漏洞。NerdDinner
    web应用程序基于Microsoft的ASP.NET镜像，在撰写本文时，该镜像中的组件存在已知漏洞：
- en: '![](Images/8e898f88-e3e4-420f-b52a-84e193d4f88a.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8e898f88-e3e4-420f-b52a-84e193d4f88a.png)'
- en: The issues in `System.Net.Http` are only exploitable in ASP.NET Core applications,
    so I could confidently say they're not an issue in my .NET Framework app. The
    `Microsoft.AspNet.Mvc` **cross-site scripting** (**XSS**) issue definitely applies
    though, and I would want to read more about the exploit and add tests to my CI
    process to confirm that attackers can't exploit that through my app.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Net.Http`中的问题只能在ASP.NET Core应用程序中被利用，所以我可以自信地说它们在我的.NET Framework应用程序中不是问题。然而，`Microsoft.AspNet.Mvc`的跨站脚本（XSS）问题确实适用，我想要更多地了解有关利用的信息，并在我的CI流程中添加测试来确认攻击者无法通过我的应用程序利用它。'
- en: These vulnerabilities are not in libraries that I've added in my Dockerfile—they
    are in the base image, and they're actually part of ASP.NET and ASP.NET Core.
    This is nothing to do with running in containers. If you're running any version
    of ASP.NET MVC from 2.0 through to 5.1 on any version of Windows, then you have
    this XSS exploit in your production system, but you probably didn't know about
    it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些漏洞不是我在Dockerfile中添加的库中的漏洞——它们在基础镜像中，并且实际上是ASP.NET和ASP.NET Core的一部分。这与在容器中运行无关。如果您在任何版本的Windows上运行任何版本的ASP.NET
    MVC从2.0到5.1，那么您的生产系统中就存在这个XSS漏洞，但您可能不知道。
- en: When you find vulnerabilities in your images, you can see exactly where they
    are and decide how to mitigate them. You could try removing the binaries altogether
    if you have an automated test suite that you can confidently use to verify that
    your app still works without them. Alternatively, you may decide that there's
    no path to the vulnerable code from your application and leave the image as it
    is, adding tests to make sure that there is no way to exploit the vulnerability.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在图像中发现漏洞时，您可以准确地看到它们的位置，并决定如何加以减轻。如果您有一个可以自信地用来验证您的应用程序是否仍然可以正常工作的自动化测试套件，您可以尝试完全删除二进制文件。或者，您可能会决定从您的应用程序中没有漏洞代码的路径，并保持图像不变，并添加测试以确保没有办法利用漏洞。
- en: However you manage it, knowing that there are vulnerabilities in your application
    stack is extremely useful. Docker Security Scanning can work on each push, so
    you get immediate feedback if a new version introduces a vulnerability. It also
    links into UCP, so you can see from the management interface if there are vulnerabilities
    in the images for your running containers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您如何管理它，知道应用程序堆栈中存在漏洞非常有用。Docker安全扫描可以在每次推送时工作，因此如果新版本引入漏洞，您将立即得到反馈。它还链接到UCP，因此您可以从管理界面上看到正在运行的容器的图像中是否存在漏洞。
- en: Managing Windows updates
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理Windows更新
- en: The process of managing updates to the application stack for your Docker image
    applies to Windows updates too. You wouldn't connect to a running container to
    update the version of Node.js it uses, and you wouldn't run Windows Update either.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 管理应用程序堆栈更新的过程也适用于Docker镜像的Windows更新。您不会连接到正在运行的容器来更新其使用的Node.js版本，也不会运行Windows更新。
- en: Microsoft release a combined set of security patches and other hotfixes for
    Windows, typically on a monthly basis as a Windows update. At the same time, they
    publish new versions of the Windows Server Core and Nano Server base images and
    any dependent images on Docker Hub and Microsoft Container Registry. The version
    number in the image tag matches the hotfix number of the Windows release.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 微软通常会发布一组综合的安全补丁和其他热修复程序，通常每月一次作为Windows更新。同时，他们还会在Docker Hub和Microsoft容器注册表上发布新版本的Windows
    Server Core和Nano Server基础镜像以及任何依赖镜像。镜像标签中的版本号与Windows发布的热修复号匹配。
- en: It's a good practice to explicitly state the Windows version to use in the `FROM`
    instruction in your Dockerfile and use specific versions of any dependencies you
    install. This makes your Dockerfile deterministic—any time you build it in the
    future, you will get the same image with all the same binaries as a result.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Dockerfile的`FROM`指令中明确声明要使用的Windows版本，并使用安装的任何依赖项的特定版本是一个很好的做法。这使得您的Dockerfile是确定性的-在将来任何时候构建它，您将得到相同的镜像，其中包含所有相同的二进制文件。
- en: 'Specifying the Windows version also makes it clear how you manage Windows updates
    for your Dockerized applications. The Dockerfile for a .NET Framework application
    may start like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 指定Windows版本还清楚地表明了如何管理Docker化应用程序的Windows更新。.NET Framework应用程序的Dockerfile可能是这样开始的：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This pins the image to Windows Server 2019 with update `KB4471332`. That''s
    a searchable Knowledge Base ID that tells you it''s the December 2018 update of
    Windows. With the release of the new Windows base image, you update your application
    by changing the tag in the `FROM` instruction and rebuilding your image, in this
    case by using release `KB4480116`, which is the January 2019 update:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将镜像固定为带有更新`KB4471332`的Windows Server 2019。这是一个可搜索的知识库ID，告诉您这是Windows 2018年12月的更新。随着新的Windows基础镜像的发布，您可以通过更改`FROM`指令中的标签并重新构建镜像来更新应用程序，例如使用发布`KB4480116`，这是2019年1月的更新：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I'll cover automated build and deployment in [Chapter 10](e0946741-5df7-4a13-b220-ffc963f1e3d3.xhtml),
    *Powering a Continuous Deployment Pipeline with Docker*. With a good CI/CD pipeline,
    you can rebuild your images with a new Windows version and run all your tests
    to confirm that the update doesn't impact any features. Then, you can roll out
    the update to all your running applications with no downtime by using `docker
    stack deploy` or `docker service update`, specifying the new versions of your
    application images. The whole process can be automated, so the IT Admin's pain
    on *Patch Tuesday* disappears with Docker.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在[第10章](e0946741-5df7-4a13-b220-ffc963f1e3d3.xhtml)中介绍自动构建和部署，*使用Docker打造持续部署流水线*。通过一个良好的CI/CD流水线，您可以使用新的Windows版本重新构建您的镜像，并运行所有测试以确认更新不会影响任何功能。然后，您可以通过使用`docker
    stack deploy`或`docker service update`在没有停机时间的情况下将更新推出到所有正在运行的应用程序，指定应用程序镜像的新版本。整个过程可以自动化，因此IT管理员在*补丁星期二*时的痛苦会随着Docker的出现而消失。
- en: Securing the software supply chain with DTR
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DTR保护软件供应链
- en: 'DTR is the second part of Docker''s extended EE offering. (I covered **Universal
    Control Plane** (**UCP**) in [Chapter 8](98e12163-b4ad-4b5d-aecc-827f5e204caa.xhtml),
    *Administering and Monitoring Dockerized Solutions.*) DTR is a private Docker
    registry that adds an important piece to the overall security story of the Docker
    platform: a secure software supply chain.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: DTR是Docker扩展EE提供的第二部分。（我在[第8章](98e12163-b4ad-4b5d-aecc-827f5e204caa.xhtml)中介绍了**Universal
    Control Plane**（**UCP**），*管理和监控Docker化解决方案*。）DTR是一个私有的Docker注册表，为Docker平台的整体安全性故事增添了一个重要组成部分：一个安全的软件供应链。
- en: You can digitally sign Docker images with DTR, and DTR lets you configure who
    can push and pull images, securely storing all the digital signatures that users
    have applied to an image. It also works in conjunction with UCP to enforce **content
    trust**. With Docker Content Trust, you can set up your cluster so that it only
    runs containers from images that have been signed by specific users or teams.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用DTR对Docker镜像进行数字签名，并且DTR允许您配置谁可以推送和拉取镜像，安全地存储用户对镜像应用的所有数字签名。它还与UCP一起工作，以强制执行**内容信任**。通过Docker内容信任，您可以设置集群，使其仅运行由特定用户或团队签名的镜像中的容器。
- en: This is a powerful feature that meets the audit requirements for a lot of regulated
    industries. There may be requirements for a company to prove that the software
    running in production is actually built from the code in the SCM. This is very
    difficult to do without a software supply chain; you have to rely on manual processes
    and a document trail. With Docker, you can enforce it at the platform and meet
    the audit requirements with automated processes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个强大的功能，符合许多受监管行业的审计要求。公司可能需要证明生产中运行的软件实际上是从SCM中的代码构建的。没有软件供应链，这是非常难以做到的；您必须依赖手动流程和文件记录。使用Docker，您可以在平台上强制执行它，并通过自动化流程满足审计要求。
- en: Repositories and users
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库和用户
- en: DTR uses the same authentication model as UCP, so you can use either your **Active
    Directory** (**AD**) account to log in, or you can use an account that's been
    created in UCP. DTR uses the same authorization model with organizations, teams,
    and users from UCP, but the permissions are separate. Users can have completely
    different access rights to image repositories in DTR and the services that are
    running from those images in UCP.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: DTR使用与UCP相同的身份验证模型，因此您可以使用您的**Active Directory**（**AD**）帐户登录，或者您可以使用在UCP中创建的帐户。DTR使用与UCP相同的组织、团队和用户的授权模型，但权限是分开的。用户可以对DTR中的镜像仓库和从这些镜像中运行的服务具有完全不同的访问权限。
- en: Some parts of the DTR authorization model are similar to Docker Hub. Users can
    own public or private repositories, which are prefixed with their username. Administrators
    can create organizations, and organization repositories can set access to users
    and teams with a fine level of control.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: DTR授权模型的某些部分与Docker Hub相似。用户可以拥有公共或私人存储库，这些存储库以他们的用户名为前缀。管理员可以创建组织，组织存储库可以对用户和团队进行细粒度的访问控制。
- en: 'I covered image registries and repositories in [Chapter 4](cba48cea-1666-4d9a-a268-ee2a104f5565.xhtml),
    *Sharing Images with Docker Registries*. The full name for a repository contains
    the registry host, the owner, and the repository name. I''ve set up a Docker Enterprise
    cluster in Azure using Docker Certified Infrastructure. I''ve created a user called
    `elton` who has one private repository that they own:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第4章](cba48cea-1666-4d9a-a268-ee2a104f5565.xhtml)中介绍了镜像注册表和存储库，*使用Docker注册表共享镜像*。存储库的完整名称包含注册表主机、所有者和存储库名称。我在Azure中使用Docker
    Certified Infrastructure搭建了一个Docker Enterprise集群。我创建了一个名为`elton`的用户，他拥有一个私人存储库：
- en: '![](Images/016f0d1b-a23f-4268-b118-5a272601c40e.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/016f0d1b-a23f-4268-b118-5a272601c40e.png)'
- en: 'To push an image to the repository called `private-app` for the user `elton`,
    I need to tag it with the full DTR domain in the repository name. My DTR instance
    is running at `dtrapp-dow2e-hvfz.centralus.cloudapp.azure.com`, so the full image
    name I need to use is `dtrapp-dow2e-hvfz.centralus.cloudapp.azure.com/elton/private-app`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要将镜像推送到名为`private-app`的存储库，需要使用完整的DTR域标记它的存储库名称为用户`elton`。我的DTR实例正在运行在`dtrapp-dow2e-hvfz.centralus.cloudapp.azure.com`，所以我需要使用的完整镜像名称是`dtrapp-dow2e-hvfz.centralus.cloudapp.azure.com/elton/private-app`：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is a private repository, so it can only be accessed by the user `elton`.
    DTR presents the same API as any other Docker registry, so I need to log in with
    the `docker login` command, specifying the DTR domain as the registry address:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个私人存储库，所以只能被用户`elton`访问。DTR呈现与任何其他Docker注册表相同的API，因此我需要使用`docker login`命令登录，指定DTR域作为注册表地址：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If I make the repository public, anyone with access to DTR can pull the image,
    but this is a user-owned repository, so only the `elton` account has permission
    to push.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将存储库设为公开，任何有权访问DTR的人都可以拉取镜像，但这是一个用户拥有的存储库，所以只有`elton`账户有推送权限。
- en: This is the same as Docker Hub, where anyone can pull an image from my `sixeyed`
    user repositories, but only I can push them. For shared projects where multiple
    users need access to push images, you use organizations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这与Docker Hub相同，任何人都可以从我的`sixeyed`用户存储库中拉取镜像，但只有我可以推送它们。对于需要多个用户访问推送镜像的共享项目，您可以使用组织。
- en: Organizations and teams
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织和团队
- en: Organizations are for shared ownership of repositories. Organizations and the
    repositories they own are separate from the users who have permissions to the
    repositories. Specific users may have admin access, while others may have read-only
    access, and specific teams may have read-write access.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 组织用于共享存储库的所有权。组织及其拥有的存储库与拥有存储库权限的用户是分开的。特定用户可能具有管理员访问权限，而其他用户可能具有只读访问权限，特定团队可能具有读写访问权限。
- en: The user and organization model of DTR is the same in the paid subscription
    tiers of Docker Hub. If you don't need the full production suite of Docker Enterprise
    but you need private repositories with shared access, you can use Docker Hub.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: DTR的用户和组织模型与Docker Hub的付费订阅层中的模型相同。如果您不需要完整的Docker Enterprise生产套件，但需要具有共享访问权限的私人存储库，您可以使用Docker
    Hub。
- en: 'I''ve created repositories for more of the components of the NerdDinner stack
    under the nerd-dinner organization:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我在nerd-dinner组织下为NerdDinner堆栈的更多组件创建了存储库：
- en: '![](Images/8a5e090e-42bb-443a-aa48-b0592e29a4b2.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8a5e090e-42bb-443a-aa48-b0592e29a4b2.png)'
- en: 'I can grant access to the repositories to individual users or to teams. The
    **Nerd Dinner Ops** team is the group for the admin users that I created in UCP.
    Those users may push images directly, so they have read-write access to all the
    repositories:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以向个别用户或团队授予对存储库的访问权限。**Nerd Dinner Ops**团队是我在UCP中创建的管理员用户组。这些用户可以直接推送图像，因此他们对所有存储库具有读写权限：
- en: '![](Images/efec642a-563b-4090-80e9-737e9293866a.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/efec642a-563b-4090-80e9-737e9293866a.png)'
- en: 'The Nerd Dinner Testers team only needs read access to the repositories, so
    they can pull images locally for testing but can''t push images to the registry:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Nerd Dinner测试团队只需要对存储库具有读取权限，因此他们可以在本地拉取图像进行测试，但无法将图像推送到注册表：
- en: '![](Images/d3812ad2-757f-48e7-9a60-ea678de03287.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d3812ad2-757f-48e7-9a60-ea678de03287.png)'
- en: How you organize repositories in DTR is up to you. You may put all application
    repositories under one organization, and have a separate organization for shared
    components that might be used in many projects—such as NATS and Elasticsearch.
    This means that shared components can be managed by a dedicated team, who can
    approve updates and make sure that the same versions are being used by all projects.
    Project team members have read access, so they can always pull the latest shared
    images and run their full application stack, but they can only push updates to
    their project repositories.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在DTR中组织存储库取决于您。您可以将所有应用程序存储库放在一个组织下，并为可能在许多项目中使用的共享组件（如NATS和Elasticsearch）创建一个单独的组织。这意味着共享组件可以由专门的团队管理，他们可以批准更新并确保所有项目都使用相同的版本。项目团队成员具有读取权限，因此他们可以随时拉取最新的共享图像并运行其完整的应用程序堆栈，但他们只能将更新推送到其项目存储库。
- en: DTR has permission levels of none, read, read-write, and admin. They can be
    applied at the repository level to teams or individual users. The consistent authentication
    but separate authorization models of DTR and UCP mean that a developer can have
    full access to pull and push images in DTR but may have only read access to view
    running containers in UCP.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: DTR具有无、读取、读写和管理员的权限级别。它们可以应用于团队或个别用户的存储库级别。DTR和UCP的一致身份验证但分离授权模型意味着开发人员可以在DTR中具有完全访问权限以拉取和推送图像，但在UCP中可能只有读取权限以查看运行中的容器。
- en: In a mature workflow, you would not have individual users pushing images—it
    would all be automated. Your initial push would be from the CI system that built
    the image, and then you would add layers of provenance to your images, starting
    with promotion policies.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在成熟的工作流程中，您不会让个人用户推送图像 - 一切都将自动化。您的初始推送将来自构建图像的CI系统，然后您将为图像添加来源层，从推广政策开始。
- en: Image promotion policies in DTR
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DTR中的图像推广政策
- en: Many companies use multiple repositories in their registry to store images at
    different stages of the application life cycle. The simplest example would be
    a `nerd-dinner-test/web` repository for images that are going through various
    phases of testing, and a nerd-dinner-prod/web repository for images that have
    been approved for production.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 许多公司在其注册表中使用多个存储库来存储应用程序生命周期不同阶段的图像。最简单的例子是`nerd-dinner-test/web`存储库，用于正在经历各种测试阶段的图像，以及`nerd-dinner-prod/web`存储库，用于已获得生产批准的图像。
- en: DTR provides image promotion policies for automatically copying images from
    one repository to another if they meet the criteria you specify. This adds an
    important link to the secure software supply chain. The CI process can push images
    to the test repository from every build, and then DTR can check the image and
    promote it to the production repository.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: DTR提供了图像推广政策，可以根据您指定的标准自动将图像从一个存储库复制到另一个存储库。这为安全软件供应链增加了重要的链接。CI流程可以从每次构建中将图像推送到测试存储库，然后DTR可以检查图像并将其推广到生产存储库。
- en: 'You can configure promotion rules based on the number of vulnerabilities found
    in the scan, the contents of the image tag, and the software licenses used in
    open source components in the image. I''ve configured some sensible policies for
    promoting images from `nerd-dinner-test/web` to `nerd-dinner-prod/web`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据扫描中发现的漏洞数量、镜像标签的内容以及镜像中使用的开源组件的软件许可证来配置推广规则。我已经为从`nerd-dinner-test/web`到`nerd-dinner-prod/web`的镜像配置了一些合理的推广策略：
- en: '![](Images/cf81e705-c28b-4049-9b36-131360593401.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/cf81e705-c28b-4049-9b36-131360593401.png)'
- en: 'When I push an image to the test repository that meets all the criteria, it
    gets automatically promoted by DTR to the production repository:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我将符合所有标准的镜像推送到测试仓库时，它会被DTR自动推广到生产仓库：
- en: '![](Images/2218ea06-00d5-4f85-ab96-a2ce137c079f.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2218ea06-00d5-4f85-ab96-a2ce137c079f.png)'
- en: Configuring your production repositories so that no end users can push to them
    directly means that images can only get there through an automated process, such
    as through promotion by DTR.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 配置生产仓库，使得没有最终用户可以直接推送到其中，意味着镜像只能通过DTR的推广等自动化流程到达那里。
- en: Docker Trusted Registry gives you all the pieces you need to build a secure
    delivery pipeline, but it doesn't mandate any particular process or technology.
    Events from DTR can trigger webhooks, which means that you can integrate your
    registry with pretty much any CI system. One event that triggers a webhook is
    image promotion, which you could use to trigger the automated signing of the new
    image.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Trusted Registry为您提供了构建安全交付流水线所需的所有组件，但它并不强制执行任何特定的流程或技术。来自DTR的事件可以触发webhooks，这意味着您可以将您的注册表与几乎任何CI系统集成。触发webhook的一个事件是镜像推广，您可以使用它来触发新镜像的自动签名。
- en: Image signing and content trust
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜像签名和内容信任
- en: DTR makes use of the client certificates managed by UCP to sign images with
    a digital signature that can be tracked to a known user account. Users download
    a client bundle from UCP, which contains a public and private key for their client
    certificate, which is used by the Docker CLI.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: DTR利用UCP管理的客户端证书对镜像进行数字签名，可以追踪到已知用户帐户。用户从UCP下载客户端捆绑包，其中包含其客户端证书的公钥和私钥，该证书由Docker
    CLI使用。
- en: You can use the same approach with user accounts for other systems—so you can
    create an account for your CI service and set up repositories so that only the
    CI account has access to push. That lets you integrate image signing into your
    secure delivery pipeline, applying the signature from the CI process and using
    that to enforce content trust.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用相同的方法处理其他系统的用户帐户，因此您可以为您的CI服务创建一个帐户，并设置仓库，以便只有CI帐户可以访问推送。这样，您可以将镜像签名集成到您的安全交付流水线中，从CI流程应用签名，并使用它来强制执行内容信任。
- en: You can switch Docker Content Trust on with an environment variable, and, when
    you push images to a registry, Docker will sign them using the key from your client
    bundle. Content trust will work only for specific image tags and not the default
    `latest` tag, as the signatures are stored against the tag.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过环境变量打开Docker内容信任，并且当您将镜像推送到注册表时，Docker将使用来自您客户端捆绑包的密钥对其进行签名。内容信任仅适用于特定的镜像标签，而不适用于默认的`latest`标签，因为签名存储在标签上。
- en: 'I can add the `v2` tag to my private image, enable content trust in the PowerShell
    session, and push the tagged image to DTR:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以给我的私有镜像添加`v2`标签，在PowerShell会话中启用内容信任，并将标记的镜像推送到DTR：
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The act of pushing the image adds the digital signature, in this case using
    the certificate for the `elton` account and creating new key pairs for the repository.
    DTR records the signatures for each image tag, and in the UI I can see that the
    `v2` image tag is signed:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 推送图像的行为会添加数字签名，在这种情况下使用`elton`帐户的证书并为存储库创建新的密钥对。DTR记录每个图像标签的签名，在UI中我可以看到`v2`图像标签已签名：
- en: '![](Images/2dfc1580-d358-4b20-ada7-acac29c0dd88.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2dfc1580-d358-4b20-ada7-acac29c0dd88.png)'
- en: Users can push images to add their own signature. This enables an approval pipeline,
    where authorized users pull an image, run whatever tests they need to, and then
    push it again to confirm their approval.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以推送图像以添加自己的签名。这使得批准流水线成为可能，授权用户拉取图像，运行他们需要的任何测试，然后再次推送以确认他们的批准。
- en: DTR uses Notary to manage access keys and signatures. Like SwarmKit and LinuxKit,
    Notary is an open source project that Docker integrates into a commercial product,
    adding features and providing support. To see image signing and content trust
    in action, check out my Pluralsight course, *Getting Started with Docker Datacenter*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: DTR使用Notary来管理访问密钥和签名。与SwarmKit和LinuxKit一样，Notary是Docker集成到商业产品中的开源项目，添加功能并提供支持。要查看图像签名和内容信任的实际操作，请查看我的Pluralsight课程*Getting
    Started with Docker Datacenter*。
- en: 'UCP integrates with DTR to verify image signatures. In the Admin Settings,
    you can configure UCP so that it will run containers from images that have been
    signed by a known team in an organization:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: UCP与DTR集成以验证图像签名。在管理设置中，您可以配置UCP，使其可以运行已由组织中已知团队签名的图像的容器：
- en: '![](Images/1e574805-ce05-490b-b97e-c170869b6550.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1e574805-ce05-490b-b97e-c170869b6550.png)'
- en: 'I''ve configured Docker Content Trust so that UCP will only run containers
    that have been signed by members of the Nerd Dinners Ops team. This explicitly
    captures the release approval workflow, and the platform enforces it. Not even
    administrators can run containers from images that have not been signed by users
    from the required teams—UCP will throw an error stating that the image did not
    meet the signing policy:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经配置了Docker内容信任，以便UCP只运行已由Nerd Dinners Ops团队成员签名的容器。这明确捕获了发布批准工作流程，并且平台强制执行它。甚至管理员也不能运行未经所需团队用户签名的图像的容器——UCP将抛出错误，指出图像未满足签名策略：
- en: '![](Images/94659751-ead8-47c1-b879-881b3dbb21c3.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/94659751-ead8-47c1-b879-881b3dbb21c3.png)'
- en: Building a secure software supply chain is about making an automated pipeline
    where you can guarantee that images have been pushed by a known user account,
    that they meet specific quality criteria, and they have been signed by a known
    user account. DTR provides all the features for integrating that into a CI pipeline
    using tools like Jenkins or Azure DevOps. You can use any automation server or
    service, provided it can run shell commands and respond to webhooks—which is pretty
    much every system.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 构建安全的软件供应链是关于建立一个自动化流水线，您可以保证图像已由已知用户帐户推送，它们满足特定的质量标准，并且已由已知用户帐户签名。DTR提供了所有集成这一点到CI流水线中的功能，使用诸如Jenkins或Azure
    DevOps之类的工具。您可以使用任何自动化服务器或服务，只要它可以运行shell命令并响应webhook——这几乎是每个系统。
- en: There's a Docker Reference Architecture that covers the secure supply chain
    in detail, using GitLab as the example CI server and showing you how to integrate
    a secure delivery pipeline with Docker Hub or DTR. You can find it at [https://success.docker.com/article/secure-supply-chain](https://success.docker.com/article/secure-supply-chain).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个Docker参考架构详细介绍了安全供应链，以GitLab作为示例CI服务器，并向您展示如何将安全交付流水线与Docker Hub或DTR集成。您可以在[https://success.docker.com/article/secure-supply-chain](https://success.docker.com/article/secure-supply-chain)找到它。
- en: Golden images
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黄金图像
- en: One final security consideration for images and registries is the source of
    the base images that are used for application images. Companies running Docker
    in production typically restrict the base images that developers can use for a
    set, which has been approved by infrastructure or security stakeholders. This
    set of golden images that are available to use may just be captured in documentation,
    but it is easier to enforce with a private registry.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像和注册表的最后一个安全考虑是用于应用程序镜像的基础镜像的来源。在生产中运行Docker的公司通常限制开发人员可以使用的基础镜像集，该集已获得基础设施或安全利益相关者的批准。可供使用的这组黄金镜像可能仅在文档中记录，但使用私有注册表更容易强制执行。
- en: 'Golden images in a Windows environment may be limited to two options: a version
    of Windows Server Core and a version of Nano Server. Instead of allowing users
    to use the public Microsoft images, the Ops team may build custom images from
    Microsoft''s base images. The custom images may add security or performance tweaks
    or set some defaults that apply to all applications, such as packaging the company''s
    Certificate Authority certs.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows环境中，黄金镜像可能仅限于两个选项：Windows Server Core的一个版本和Nano Server的一个版本。运维团队可以从Microsoft的基础镜像构建自定义镜像，而不是允许用户使用公共Microsoft镜像。自定义镜像可能会添加安全或性能调整，或设置一些适用于所有应用程序的默认值，例如打包公司的证书颁发机构证书。
- en: Using DTR, you can create an organization for all your base images, where the
    Ops team has read-write access to the repositories, while all other users have
    read access. Checking that images are using a valid base just means checking that
    the Dockerfile is using an image from the base-images organization, which is an
    easy test to automate in your CI/CD process.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DTR，您可以为所有基础镜像创建一个组织，运维团队对存储库具有读写访问权限，而所有其他用户只有读取权限。检查镜像是否使用有效的基础镜像只意味着检查Dockerfile是否使用了来自base-images组织的镜像，这是在CI/CD过程中轻松自动化的测试。
- en: Golden images add a management overhead to your organization, but it's one that
    becomes worthwhile as you move more and more applications to Docker. Owning your
    own image with ASP.NET that's been deployed and configured with your company's
    defaults makes it easy for the security team to audit that base image. You also
    own your release cadence and the domain for your registry, so you don't need to
    use arcane image names in your Dockerfiles.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 黄金镜像为您的组织增加了管理开销，但随着您将越来越多的应用程序迁移到Docker，这种开销变得更加值得。拥有自己的ASP.NET镜像，并使用公司的默认配置部署，使安全团队可以轻松审计基础镜像。您还拥有自己的发布节奏和注册表域，因此您不需要在Dockerfile中使用古怪的镜像名称。
- en: Understanding security in swarm mode
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解集群模式中的安全性
- en: Docker's security-in-depth approach covers the whole software life cycle, from
    image signing and scanning at build time through to container isolation and management
    at runtime. I'll end this chapter with an overview of the security features that
    are implemented in swarm mode.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的深度安全性方法涵盖了整个软件生命周期，从构建时的镜像签名和扫描到运行时的容器隔离和管理。我将以概述在集群模式中实施的安全功能结束本章。
- en: Distributed software offers a lot of attractive attack vectors. Communication
    between components can be intercepted and modified. Rogue agents can join the
    network and gain access to data or run workloads. Distributed data stores can
    be compromised. Docker swarm mode, which is built on top of the open source SwarmKit
    project, addresses these vectors at a platform level so that your application
    is running on a secure base by default.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式软件提供了许多有吸引力的攻击向量。组件之间的通信可能会被拦截和修改。恶意代理可以加入网络并访问数据或运行工作负载。分布式数据存储可能会受到损害。建立在开源SwarmKit项目之上的Docker集群模式在平台级别解决了这些向量，因此您的应用程序默认在安全基础上运行。
- en: Nodes and join tokens
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点和加入令牌
- en: You can switch to swarm mode by running `docker swarm init`. The output of this
    command gives you a token that you can use so that other nodes can join the swarm.
    There are separate tokens for workers and managers. Nodes cannot join a swarm
    without the token, so you need to keep the token protected, like any other secret.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行`docker swarm init`切换到集群模式。此命令的输出会给您一个令牌，您可以使用它让其他节点加入集群。工作节点和管理节点有单独的令牌。节点没有令牌无法加入集群，因此您需要像保护其他秘密一样保护令牌。
- en: The join tokens are comprised of the prefix, the format version, the hash of
    the root key, and a cryptographically strong random string.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 加入令牌由前缀、格式版本、根密钥的哈希和密码学强随机字符串组成。
- en: Docker uses a fixed `SWMTKN` prefix for tokens, so you can run automated checks
    to see whether a token has been accidentally shared in source code or on another
    public location. If the token is compromised, rogue nodes could join the swarm
    if they had access to your network. Swarm mode can use a specific network for
    node traffic, so you should use a network that is not publicly accessible.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使用固定的`SWMTKN`前缀用于令牌，因此您可以运行自动检查，以查看令牌是否在源代码或其他公共位置上被意外共享。如果令牌受到损害，恶意节点可能会加入集群，如果它们可以访问您的网络。集群模式可以使用特定网络进行节点流量，因此您应该使用一个不公开可访问的网络。
- en: 'Join tokens can be rotated with the `join-token rotate` command, which can
    target either the worker token or the manager token:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 加入令牌可以通过`join-token rotate`命令进行旋转，可以针对工作节点令牌或管理节点令牌进行操作：
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Token rotation is a fully managed operation by the swarm. Existing nodes are
    all updated and any error conditions, such as nodes going offline or joining mid-rotation,
    are gracefully handled.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌旋转是集群的完全托管操作。所有现有节点都会更新，并且任何错误情况，如节点离线或在旋转过程中加入，都会得到优雅处理。
- en: Encryption and secrets
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密和秘密
- en: Communication between swarm nodes is encrypted using **Transport Layer Security**
    (**TLS**). The swarm manager configures itself as a certification authority when
    you create the swarm, and the manager generates certificates for each node when
    they join. Communication between nodes in the swarm is encrypted using mutual
    TLS.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 集群节点之间的通信使用**传输层安全性**（**TLS**）进行加密。当您创建集群时，集群管理器会将自身配置为认证机构，并在节点加入时为每个节点生成证书。集群中的节点之间的通信使用相互TLS进行加密。
- en: Mutual TLS means that the nodes can securely communicate and trust each other,
    as every node has a trusted certificate to identify itself. Nodes are assigned
    a random ID that is used in the certificate, so the swarm doesn't rely on attributes
    such as the hostname, which could potentially be faked.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 相互TLS意味着节点可以安全地通信并相互信任，因为每个节点都有一个受信任的证书来标识自己。节点被分配一个在证书中使用的随机ID，因此集群不依赖于主机名等属性，这些属性可能会被伪造。
- en: Trusted communication between nodes is the foundation for Docker Secrets in
    swarm mode. Secrets are stored and encrypted in the Raft log on the managers,
    and a secret is sent to the worker only if that worker is going to run a container
    that uses the secret. The secret is always encrypted in transit using mutual TLS.
    On the worker node, the secret is made available in plain text on a temporary
    RAM drive that is surfaced to the container as a volume mount. The data is never
    persisted in plain text.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 节点之间的可信通信是集群模式中Docker Secrets的基础。秘密存储在管理节点的Raft日志中并进行加密，只有当工作节点要运行使用该秘密的容器时，才会将秘密发送给工作节点。秘密在传输过程中始终使用相互TLS进行加密。在工作节点上，秘密以明文形式在临时RAM驱动器上可用，并作为卷挂载到容器中。数据永远不会以明文形式持久保存。
- en: Windows doesn't have a native RAM drive, so the secrets implementation currently
    stores the secret data on the disk on the worker nodes, with the recommendation
    that BitLocker is used for the system drive. Secret files are secured with ACLs
    on the host.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Windows没有本地的RAM驱动器，因此目前的秘密实现将秘密数据存储在工作节点的磁盘上，并建议使用BitLocker来保护系统驱动器。秘密文件在主机上受ACLs保护。
- en: Inside the container, access to secret files is restricted to certain user accounts.
    The accounts with access can be specified in Linux, but in Windows, there's currently
    a fixed list. I used secrets in the ASP.NET web application in [Chapter 7](bf6a5e90-bbba-435b-b0a0-734611e0e834.xhtml),
    *Orchestrating Distributed Solutions with Docker Swarm*, and you can see there
    that I configured the IIS application pool to use an account with access.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内部，对秘密文件的访问受到限制，只能由特定用户帐户访问。在Linux中可以指定具有访问权限的帐户，但在Windows中，目前有一个固定的列表。我在[第7章](bf6a5e90-bbba-435b-b0a0-734611e0e834.xhtml)的ASP.NET
    Web应用程序中使用了秘密，*使用Docker Swarm编排分布式解决方案*，您可以在那里看到我配置了IIS应用程序池以使用具有访问权限的帐户。
- en: When containers are stopped, paused, or removed, the secrets that were available
    to the container are removed from the host. On Windows, where secrets are currently
    persisted to disk, if the host is forcefully shut down, then secrets are removed
    when the host restarts.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器停止、暂停或删除时，容器可用的秘密将从主机中删除。在Windows上，秘密目前被持久化到磁盘，如果主机被强制关闭，那么在主机重新启动时秘密将被删除。
- en: Node labels and external access
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点标签和外部访问
- en: Once a node has been added to a swarm, it is a candidate for container workloads
    to be scheduled. Many production deployments use constraints to ensure that applications
    are run on the correct type of node, and Docker will try to match the requested
    constraints to labels on the nodes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦节点被添加到集群中，它就成为容器工作负载的候选对象。许多生产部署使用约束条件来确保应用程序在正确类型的节点上运行，并且Docker将尝试将请求的约束与节点上的标签进行匹配。
- en: In a regulated environment, you may have requirements to ensure that applications
    run only on those servers that have met required audit levels, like PCI compliance
    for credit card processing. You can identify compliant nodes with labels and use
    constraints to ensure that the applications only run on those nodes. Swarm mode
    helps ensure that these constraints are properly enforced.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在受监管的环境中，您可能需要确保应用程序仅在已满足所需审核级别的服务器上运行，例如用于信用卡处理的PCI合规性。您可以使用标签识别符合条件的节点，并使用约束条件确保应用程序仅在这些节点上运行。集群模式有助于确保这些约束得到适当执行。
- en: 'There are two types of labels in swarm mode: engine labels and node labels.
    Engine labels are set by the machine in the Docker service configuration, so,
    if a worker was compromised, an attacker could add labels and make a machine they
    own appear to be compliant. Node labels are set by the swarm, so they can only
    be created by a user with access to a swarm manager. Node labels mean you don''t
    have to rely on claims made by individual nodes, so, if they are compromised,
    the impact can be limited.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 集群模式中有两种类型的标签：引擎标签和节点标签。引擎标签由Docker服务配置中的机器设置，因此，如果工作节点受到攻击者的攻击，攻击者可以添加标签，使他们拥有的机器看起来合规。节点标签由集群设置，因此只能由具有对集群管理器访问权限的用户创建。节点标签意味着您不必依赖于各个节点提出的声明，因此，如果它们受到攻击，影响可以得到限制。
- en: Node labels are also useful in segregating access to applications. You may have
    Docker hosts that are accessible only on your internal network and others that
    have access to the public internet. With labels, you can explicitly record it
    as a distinction and run containers with constraints based on the labels. You
    could have a content management system in a container that is only available internally
    but a web proxy that is available publicly.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 节点标签在隔离对应用程序的访问方面也很有用。您可能有仅在内部网络上可访问的Docker主机，也可能有访问公共互联网的主机。使用标签，您可以明确记录它作为一个区别，并根据标签运行具有约束的容器。您可以在容器中拥有一个仅在内部可用的内容管理系统，但一个公开可用的Web代理。
- en: Integration with container security technologies
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与容器安全技术的集成
- en: Docker Swarm is a secure container platform, and, because it uses open source
    components and open standards, it integrates nicely with third-party tools. Applications
    all expose the same API when they're running in containers—you can use Docker
    to check the processes running in the container, view log entries, navigate the
    filesystem, and even run new commands. The container security ecosystem is evolving
    powerful tools that take advantage of that to add more security at runtime.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm是一个安全的容器平台，因为它使用开源组件和开放标准，所以与第三方工具集成得很好。当应用程序在容器中运行时，它们都暴露相同的API——您可以使用Docker来检查容器中运行的进程，查看日志条目，浏览文件系统，甚至运行新命令。容器安全生态系统正在发展强大的工具，利用这一点在运行时增加更多的安全性。
- en: 'There are two main vendors to evaluate if you''re looking for extended security
    for Windows containers: Twistlock and Aqua Security. Both have comprehensive product
    suites that include image scanning and secret management, and runtime protection,
    which is the most innovative way of adding security to your applications.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在寻找Windows容器的扩展安全性，有两个主要供应商可供评估：Twistlock和Aqua Security。两者都有包括镜像扫描和秘密管理、运行时保护在内的全面产品套件，这是为您的应用程序增加安全性的最创新方式。
- en: When you deploy a runtime security product to your cluster, it monitors the
    container and builds a profile of that application's typical behavior—including
    CPU and memory usage, and network traffic in and out. Then, it looks for anomalies
    in instances of that application, where a container starts to behave differently
    from the expected model. This is a powerful way of identifying that an application
    has been compromised, as attackers will typically start running new processes
    or moving unusual amounts of data.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将运行时安全产品部署到集群时，它会监视容器并构建该应用程序的典型行为文件，包括CPU和内存使用情况，以及进出的网络流量。然后，它会寻找该应用程序实例中的异常情况，即容器开始表现出与预期模型不同的方式。这是识别应用程序是否被入侵的强大方式，因为攻击者通常会开始运行新进程或移动异常数量的数据。
- en: Taking Aqua Security as an example, it has a full suite of protection for Docker
    on Windows, scanning images and providing runtime security controls for containers.
    That includes preventing containers running from images that don't meet security
    criteria—flagged as CVE severity or average score, blacklisted and whitelisted
    packages, malware, sensitive data, and custom compliance checks.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以Aqua Security为例，它为Windows上的Docker提供了全套保护，扫描镜像并为容器提供运行时安全控制。这包括阻止从不符合安全标准的镜像中运行的容器——标记为CVE严重程度或平均分数、黑名单和白名单软件包、恶意软件、敏感数据和自定义合规性检查。
- en: Aqua also enforces container immutability, comparing running containers to their
    originating images and preventing changes, like new executables being installed.
    This is a powerful way to prevent malicious code injection or attempts to bypass
    the image pipeline controls. If you're building images from a large base image
    with a lot of components you don't actually need, Aqua can profile the attack
    surface and whitelist the functionality and capabilities that are actually required.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Aqua还强制执行容器的不可变性，将运行的容器与其原始图像进行比较，并防止更改，比如安装新的可执行文件。这是防止恶意代码注入或尝试绕过图像管道控制的强大方式。如果您从一个包含许多实际上不需要的组件的大型基础图像构建图像，Aqua可以对攻击面进行分析，并列出实际需要的功能和能力。
- en: These features apply to legacy apps in containers just as much as new cloud-native
    applications. The ability to add security in-depth to every layer of an application
    deployment, and to have automated monitoring for suspected compromises in real-time,
    makes the security aspect one of the strongest reasons for moving to containers.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能适用于遗留应用程序中的容器，就像新的云原生应用程序一样。能够为应用程序部署的每一层添加深度安全，并实时监视可疑妥协，使安全方面成为迁移到容器的最有力的原因之一。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter looked at the security considerations of Docker and Windows containers.
    You learned that the Docker platform is built for security in depth, and that
    the runtime security of containers is only one part of the story. Security scanning,
    image signing, content trust, and secure distributed communication can be combined
    to give you a secure software supply chain.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了Docker和Windows容器的安全考虑。您了解到Docker平台是为深度安全而构建的，并且容器的运行时安全只是故事的一部分。安全扫描、图像签名、内容信任和安全的分布式通信可以结合起来，为您提供一个安全的软件供应链。
- en: You looked at the practical security aspects of running apps in Docker and learned
    how processes in Windows containers run in a context that makes it difficult for
    attackers to escape from containers and invade other processes. Container processes
    will use all the compute resources they need, but I also demonstrated how to limit
    CPU and memory usage, which can prevent rogue containers from starving the host's
    compute resources.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你研究了在Docker中运行应用程序的实际安全方面，并了解了Windows容器中的进程是如何在一个上下文中运行的，这使得攻击者很难逃离容器并侵入其他进程。容器进程将使用它们所需的所有计算资源，但我还演示了如何限制CPU和内存使用，这可以防止恶意容器耗尽主机的计算资源。
- en: In a dockerized application, you have much more scope to enforce security in
    depth. I explained why minimal images help keep applications safe and how you
    can use Docker Security Scanning to be alerted if there are vulnerabilities in
    any of the dependencies your application uses. You can enforce good practices
    by digitally signing images and configure Docker so that it will only run containers
    from images that have been signed by approved users.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在docker化的应用程序中，您有更多的空间来实施深度安全。我解释了为什么最小化的镜像有助于保持应用程序的安全，以及您如何使用Docker安全扫描来在您的应用程序使用的任何依赖关系中发现漏洞时收到警报。您可以通过数字签名图像并配置Docker，以便它只运行已获得批准用户签名的图像中的容器，来强制执行良好的实践。
- en: Lastly, I looked at the security implementation in Docker Swarm. Swarm mode
    has the most in-depth security of all the orchestration layers, and it provides
    a solid foundation for you to run your apps securely. Using secrets to store sensitive
    application data and node labels to identify host compliance makes it very easy
    for you to run a secure solution, and the open API makes it easy to integrate
    third-party security enhancements such as Aqua.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我看了一下Docker Swarm中的安全实现。Swarm模式拥有所有编排层中最深入的安全性，并为您提供了一个稳固的基础，让您可以安全地运行应用程序。使用secrets来存储敏感的应用程序数据，使用节点标签来识别主机的合规性，使您可以轻松地运行一个安全的解决方案，而开放的API使得集成第三方安全增强，如Aqua变得很容易。
- en: In the next chapter we'll work with a distributed application and look at building
    a pipeline for CI/CD. The Docker Engine can be configured to provide remote access
    to the API, so it's easy to integrate Docker deployments with any build system.
    The CI server can even run inside a Docker container and you can use Docker for
    the build agents, so you don't need any complex configuration for CI/CD.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用分布式应用程序，并着眼于构建CI/CD的流水线。Docker引擎可以配置为提供对API的远程访问，因此很容易将Docker部署与任何构建系统集成。CI服务器甚至可以在Docker容器内运行，您可以使用Docker作为构建代理，因此对于CI/CD，您不需要任何复杂的配置。
