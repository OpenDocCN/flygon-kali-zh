- en: 6\. Securing your application with HTTPS and Azure AD
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 使用HTTPS和Azure AD保护您的应用程序
- en: HTTPS has become a necessity for any public-facing website. Not only does it
    improve the security of your website, but it is also becoming a requirement for
    new browser functionalities. HTTPS is a secure version of the HTTP protocol. HTTPS
    makes use of **Transport Layer Security** (**TLS**) certificates to encrypt traffic
    between an end user and a server, or between two servers. TLS is the successor
    to the **Secure Sockets Layer** (**SSL**). The terms *TLS* and *SSL* are often
    used interchangeably.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS已经成为任何面向公众的网站的必需品。它不仅提高了网站的安全性，而且还成为新的浏览器功能的要求。HTTPS是HTTP协议的安全版本。HTTPS利用**传输层安全**（**TLS**）证书来加密终端用户和服务器之间的流量，或者两个服务器之间的流量。TLS是**安全套接字层**（**SSL**）的后继者。术语*TLS*和*SSL*经常可以互换使用。
- en: In the past, you needed to buy certificates from a **certificate authority**
    (**CA**), then set them up on your web server, and then renew them periodically.
    While that is still possible today, the **Let's Encrypt** service and helpers
    in Kubernetes make it very easy to set verified TLS certificates in your cluster.
    Let's Encrypt is a non-profit organization run by the Internet Security Research
    Group and backed by multiple companies. It is a free service that offers verified
    TLS certificates in an automated manner. Automation is a key benefit of the Let's
    Encrypt service.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，您需要从**证书颁发机构**（**CA**）购买证书，然后在您的Web服务器上设置它们，并定期更新它们。虽然今天仍然可能，但Let's Encrypt服务和Kubernetes中的助手使在集群中设置经过验证的TLS证书变得非常容易。Let's
    Encrypt是由互联网安全研究组织运营并得到多家公司支持的非营利组织。它是一个提供自动验证TLS证书的免费服务。自动化是Let's Encrypt服务的一个关键优势。
- en: In terms of Kubernetes helpers, we will introduce a new object called an **Ingress**,
    and we will use a Kubernetes add-on called **cert-manager**. An Ingress is an
    object within Kubernetes that manages external access to services. Ingresses are
    commonly used for HTTP services. An Ingress adds additional functionality on top
    of the service object we explained in *Chapter 3, Application deployment on AKS.*
    An Ingress can be configured to handle HTTPS traffic. It can also be configured
    to route traffic to different back-end services based on the host name, which
    is assigned by the **Domain Name System** (**DNS**) that is used to connect.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes助手方面，我们将介绍一个名为**Ingress**的新对象，并且我们将使用一个名为**cert-manager**的Kubernetes附加组件。Ingress是Kubernetes中管理对服务的外部访问的对象。Ingress通常用于HTTP服务。Ingress在我们在*第3章，AKS上的应用部署*中解释的服务对象之上添加了额外的功能。Ingress可以配置为处理HTTPS流量。它还可以根据由用于连接的**域名系统**（**DNS**）分配的主机名配置为将流量路由到不同的后端服务。
- en: '`cert-manager` is a Kubernetes add-on that helps in automating the creation
    of TLS certificates. It also helps in the rotation of certificates when they are
    close to expiring. `cert-manager` can interface with Let''s Encrypt to request
    certificates automatically.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`cert-manager`是一个Kubernetes附加组件，可帮助自动创建TLS证书。它还可以在证书临近到期时帮助进行轮换。`cert-manager`可以与Let''s
    Encrypt接口自动请求证书。'
- en: In this chapter, we will see how to set up the Ingress and `cert-manager` to
    interface with Let's Encrypt.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何设置Ingress和`cert-manager`与Let's Encrypt接口。
- en: Also in this chapter, we will explore different approaches to authentication
    for the guestbook app. We will look at the `oauth2_proxy` reverse proxy to add
    authentication to the sample guest app using Azure **Active Directory** (**AD**).
    The `oauth2_proxy` is a reverse proxy that will forward authentication requests
    to a configuration authentication platform. You will learn how to easily secure
    apps that have no built-in authentication. The authentication scheme can be extended
    to use GitHub, Google, GitLab, LinkedIn, or Facebook.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在本章中，我们将探讨为guestbook应用程序进行身份验证的不同方法。我们将使用`oauth2_proxy`反向代理来向示例guest应用程序添加Azure
    Active Directory（AD）的身份验证。`oauth2_proxy`是一个反向代理，将身份验证请求转发到配置身份验证平台。您将学习如何轻松地保护没有内置身份验证的应用程序。身份验证方案可以扩展为使用GitHub、Google、GitLab、LinkedIn或Facebook。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Setting up an Ingress in front of a service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务前设置Ingress
- en: Adding TLS support to an Ingress
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Ingress添加TLS支持
- en: Authentication and common authentication providers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证和常见身份验证提供程序
- en: Authentication versus authorization
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证与授权
- en: Deploying the `oauth2_proxy` sidecar
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署`oauth2_proxy` sidecar
- en: Let's start with setting up the Ingress.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置Ingress开始。
- en: HTTPS support
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTPS支持
- en: Obtaining TLS certificates traditionally has been an expensive and manual business.
    If you wanted to do it cheaply, you could self-sign your certificates, but browsers
    would complain when opening up your site and identify it as not trusted. The Let's
    Encrypt service changes all that. Let's Encrypt is a free, automated, and open
    CA, run for the public's benefit. It gives people the digital certificates they
    need in order to enable HTTPS (SSL/TLS) for websites, for free, in the most user-friendly
    way.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，获取TLS证书一直是一项昂贵且繁琐的业务。如果您想以低成本完成，可以自行签署证书，但浏览器在打开您的网站时会抱怨并将其标识为不受信任。Let's
    Encrypt改变了这一切。Let's Encrypt是一个免费、自动化和开放的CA，为公众利益而运行。它为人们提供数字证书，以便免费以最用户友好的方式为网站启用HTTPS（SSL/TLS）。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Although this section focuses on using an automated service such as Let's Encrypt,
    you can still pursue the traditional path of buying a certificate from an existing
    CA and importing it into Kubernetes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本节侧重于使用诸如Let's Encrypt之类的自动化服务，您仍然可以选择传统的方式从现有CA购买证书并将其导入Kubernetes。
- en: Installing an Ingress controller
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Ingress控制器
- en: With the Ingress object, Kubernetes provides a clean way of securely exposing
    your services. It provides an SSL endpoint and name-based routing, meaning different
    DNS names can be routed to different back-end services.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Ingress对象，Kubernetes提供了一种安全地公开您的服务的清晰方式。它提供了SSL终端点和基于名称的路由，这意味着不同的DNS名称可以路由到不同的后端服务。
- en: If you want to create an Ingress object in your cluster, you first need to set
    up an **Ingress controller**. The Ingress controller will manage the state of
    the Ingresses you have deployed in your cluster. There are multiple options when
    selecting an Ingress controller. For a full list of options, please refer to [https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/](https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/).
    When running AKS, the two most common options are either using an NGINX-based
    Ingress controller, or an Ingress controller based on the Azure application gateway.
    For our example, we'll use the NGINX version.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在集群中创建Ingress对象，首先需要设置Ingress控制器。Ingress控制器将管理您在集群中部署的Ingresses的状态。在选择Ingress控制器时有多个选项。有关所有选项的完整列表，请参阅[https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/](https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/)。在运行AKS时，最常见的两个选项要么使用基于NGINX的Ingress控制器，要么使用基于Azure应用程序网关的Ingress控制器。在我们的示例中，我们将使用NGINX版本。
- en: 'Let''s go ahead and install the NGINX version of the Ingress controller by
    performing the following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续安装Ingress控制器的NGINX版本，执行以下步骤：
- en: To follow along, run this sample in the Bash version of Cloud Shell.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要跟着操作，请在Cloud Shell的Bash版本中运行此示例。
- en: 'Type in the following command to begin installation:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令开始安装：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will set up the Ingress controller for our cluster. This will additionally
    create a public IP that we will use to access the Ingress controller.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们的集群设置Ingress控制器。这还将创建一个我们将用于访问Ingress控制器的公共IP。
- en: 'Let''s connect to the Ingress controller. To get the exposed IP of the `ingress-controller`
    service, enter this command:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们连接到Ingress控制器。要获取`ingress-controller`服务的公开IP，请输入此命令：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You should see an entry for the Ingress controller as shown in *Figure 6.1*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到Ingress控制器的条目，如*图6.1*所示：
- en: '![Your output screen will show you three entries. Out of these three entries,
    the ingress controller will show an external  IP.](image/Figure_6.1.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![您的输出屏幕将显示三个条目。在这三个条目中，Ingress 控制器将显示一个外部 IP。](image/Figure_6.1.jpg)'
- en: 'Figure 6.1: Getting the IP of the Ingress controller'
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.1：获取Ingress控制器的IP
- en: 'You can browse to the web page by entering `http://<EXTERNAL-IP>` in the browser:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在浏览器中输入`http://<EXTERNAL-IP>`来浏览网页：
- en: '![Your output screen will show you three entries. Out of these three entries,
    the ingress controller will show an external  IP.](image/Figure_6.2.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![您的输出屏幕将显示三个条目。在这三个条目中，Ingress 控制器将显示一个外部 IP。](image/Figure_6.2.jpg)'
- en: 'Figure 6.2: An Ingress showing its default back end'
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.2：显示其默认后端的Ingress
- en: 'This shows you two things:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这向您展示了两件事：
- en: There is no back-end application, just a default application.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有后端应用程序，只有一个默认应用程序。
- en: The website is served over HTTP, not HTTPS (hence the **Not secure** warning).
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网站通过HTTP提供服务，而不是HTTPS（因此会出现**不安全**警告）。
- en: In the next two sections, we'll solve both of these issues. We'll first create
    an Ingress rule for our guestbook application, and then we'll add HTTPS support
    via Let's Encrypt.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，我们将解决这两个问题。我们将首先为我们的留言板应用程序创建一个Ingress规则，然后我们将通过Let's Encrypt添加HTTPS支持。
- en: Adding an Ingress rule for the guestbook application
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为留言板应用程序添加Ingress规则
- en: 'Let''s start by relaunching our guestbook application. To launch the guestbook
    application, type in the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从重新启动我们的留言板应用程序开始。要启动留言板应用程序，请输入以下命令：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will create our trusted guestbook application. You should see the objects
    being created as shown in *Figure 6.3*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建我们信任的留言板应用程序。您应该看到对象被创建，如*图6.3*所示：
- en: '![Upon executing the kubectl create -f guestbook-all-in-one.yaml command, your
    output screen will show that all the objects will be created.](image/Figure_6.3.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![执行kubectl create -f guestbook-all-in-one.yaml命令后，您的输出屏幕将显示所有对象都已创建。](image/Figure_6.3.jpg)'
- en: 'Figure 6.3: Creating the guestbook application'
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.3：创建留言板应用程序
- en: 'We can then use the following YAML file to expose the front-end service via
    the Ingress. This is provided as `simple-frontend-ingress.yaml` in the source
    code for this chapter:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下YAML文件通过Ingress公开前端服务。这在本章的源代码中提供为`simple-frontend-ingress.yaml`：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s have a look at what we define in this YAML file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在这个YAML文件中定义了什么：
- en: '**Line 2**: Here, we define the fact that we are creating an Ingress object.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第2行**：在这里，我们定义了我们正在创建一个Ingress对象的事实。'
- en: '**Lines 5-12**: These lines define the configuration of the Ingress. Pay specific
    attention to:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第5-12行**：这些行定义了Ingress的配置。特别注意：'
- en: '**Line 9**: Here, we define the path this Ingress is listening on. In our case,
    this is the top-level path. In more advanced cases, you can have different paths
    pointing to different services.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第9行**：在这里，我们定义了此Ingress正在侦听的路径。在我们的情况下，这是顶级路径。在更高级的情况下，您可以有不同的路径指向不同的服务。'
- en: '**Lines 10-12**: These lines define the actual service this traffic should
    be pointed to.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第10-12行**：这些行定义了应将此流量指向的实际服务。'
- en: 'We can use the following command to create this Ingress:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令创建此Ingress：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you now go to `https://<EXTERNAL-IP>/`, you should get an output as shown
    in *Figure 6.4*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在转到`https://<EXTERNAL-IP>/`，您应该会得到如*图6.4*所示的输出：
- en: '![When you enter the public IP address to your browser, it will display a white
    screen with Guestbook written on it. This indicates that the guestbook application
    is available via the Ingress.](image/Figure_6.4.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![当您在浏览器中输入公共IP地址时，它将显示一个带有Guestbook字样的白屏。这表明通过Ingress可以访问guestbook应用程序。](image/Figure_6.4.jpg)'
- en: 'Figure 6.4: Accessing the guestbook application via the Ingress'
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.4：通过Ingress访问guestbook应用程序
- en: 'Please pay attention to the following: we didn''t have to publicly expose the
    front-end service as we have done in the preceding chapters. We have added the
    Ingress as the exposed service, and the front-end service remains private to the
    cluster:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下内容：我们不必像在前面的章节中那样公开暴露前端服务。我们已将Ingress添加为公开服务，前端服务仍然对集群保密：
- en: '![The user can have access to the Ingress, whereas the service and the frontend
    pods remain private.](image/Figure_6.5.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![用户可以访问Ingress，而服务和前端pod保持私密。](image/Figure_6.5.jpg)'
- en: 'Figure 6.5: Flowchart displaying publicly accessible Ingress'
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.5：显示可公开访问的Ingress的流程图
- en: 'You can verify this by running the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令来验证这一点：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This should only show you one public service:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该只显示一个公共服务：
- en: '![Upon running the kubectl get svc command, you will see a total of six services
    and that only the ingress controller provides an External-IP.](image/Figure_6.6.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![运行kubectl get svc命令后，您将看到共有六个服务，只有Ingress控制器提供了外部IP。](image/Figure_6.6.jpg)'
- en: 'Figure 6.6: Output displaying only the Ingress having a public IP'
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.6：仅显示具有公共IP的Ingress的输出
- en: In this section, you have launched an instance of the guestbook application.
    You exposed it publicly by creating an Ingress. Only the Ingress was publicly
    accessible. In the next section, we'll see how to get a certification from Let's
    Encrypt.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经启动了一个guestbook应用程序的实例。您通过创建Ingress将其公开。只有Ingress是公开访问的。在下一节中，我们将看到如何从Let's
    Encrypt获取证书。
- en: Getting a certificate from Let's Encrypt
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从Let's Encrypt获取证书
- en: 'In this section, we will add HTTPS support to our application. To do this,
    we need a TLS certificate. We will be using the `cert-manager` Kubernetes add-on
    to request a certificate from Let''s Encrypt. There are a couple of steps involved.
    The process of adding HTTPS to our application involves the following steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为我们的应用程序添加HTTPS支持。为此，我们需要一个TLS证书。我们将使用`cert-manager` Kubernetes附加组件从Let's
    Encrypt请求证书。涉及几个步骤。将HTTPS添加到我们的应用程序的过程涉及以下步骤：
- en: Install `cert-manager`, which interfaces with the Let's Encrypt API to request
    a certificate for the domain name you specify.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`cert-manager`，它与Let's Encrypt API接口，以请求您指定的域名的证书。
- en: Map the **Azure Fully Qualified Domain Name** (**FQDN**) to the NGINX Ingress
    public IP. An FQDN is the complete DNS name of a service, sometimes referred to
    as the DNS record, such as `www.google.com`. A TLS certificate is issued for an
    FQDN, which is why we need to map an FQDN for our Ingress.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Azure完全合格的域名**（**FQDN**）映射到NGINX Ingress公共IP。 FQDN是服务的完整DNS名称，有时称为DNS记录，例如`www.google.com`。
    为FQDN颁发TLS证书，这就是为什么我们需要为我们的Ingress映射一个FQDN。
- en: Install the certificate issuer, which will get the certificate from Let's Encrypt.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装证书颁发者，该颁发者将从Let's Encrypt获取证书。
- en: Create an SSL certificate for a given FQDN.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为给定的FQDN创建SSL证书。
- en: Secure the front-end service section by creating an Ingress to the service with
    the certificate created in *step 4*. In our example, we will not be executing
    this step. We will, however, reconfigure our Ingress to automatically pick up
    the certificate created in *step 4*.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建Ingress到在*步骤4*中创建的证书的服务来保护前端服务部分。在我们的示例中，我们不会执行此步骤。但是，我们将重新配置我们的Ingress以自动获取在*步骤4*中创建的证书。
- en: Let's start with the first step; installing `cert-manager` in our cluster.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一步开始；在我们的集群中安装`cert-manager`。
- en: '**Installing cert-manager**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装cert-manager**'
- en: The first step in getting a TLS certificate is to install `cert-manager` in
    your cluster. `cert-manager` ([https://github.com/jetstack/cert-manager](https://github.com/jetstack/cert-manager))
    automates the management and issuance of TLS certificates from various issuing
    sources. It is an open-source solution managed by the company **Jetstack**. Renewing
    certificates and ensuring that they are updated periodically is all managed by
    `cert-manager`, which is a Kubernetes add-on.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 获取TLS证书的第一步是在您的集群中安装`cert-manager`。`cert-manager` ([https://github.com/jetstack/cert-manager](https://github.com/jetstack/cert-manager))自动管理和发放来自各种发放源的TLS证书。这是由公司**Jetstack**管理的开源解决方案。续订证书和确保它们定期更新都由`cert-manager`管理，这是一个Kubernetes附加组件。
- en: 'The following commands install `cert-manager` in your cluster:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令在您的集群中安装`cert-manager`：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These commands do a couple of things in your cluster:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令在您的集群中执行了一些操作：
- en: Create a new **namespace**. Namespaces are used within Kubernetes to isolate
    workloads from each other.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**命名空间**。命名空间在Kubernetes中用于隔离彼此的工作负载。
- en: Add a new repository to Helm to grab charts from.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向Helm添加一个新的存储库以获取图表。
- en: Install the `cert-manager` Helm chart.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`cert-manager` Helm图表。
- en: 'Now that you have installed `cert-manager`, we can move on to the next step:
    mapping an FQDN to the Ingress.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了`cert-manager`，我们可以继续下一步：将FQDN映射到Ingress。
- en: '**Mapping the Azure FQDN to the NGINX Ingress public IP**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**将Azure FQDN映射到NGINX Ingress公共IP**'
- en: The next step in the process of getting a TLS certificate is adding an FQDN
    to your IP address. Let's Encrypt requires a publicly available DNS entry to verify
    ownership of the DNS entry *before* it issues a certificate. This ensures that
    you cannot hijack someone else's site. We have to map the public domain name given
    to us by Azure to the external IP we get from Azure Load Balancer in order to
    prove ownership.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 获取TLS证书过程的下一步是将FQDN添加到您的IP地址。Let's Encrypt需要一个公开可用的DNS条目来验证DNS条目的所有权*之前*发放证书。这确保您不能劫持别人的站点。我们必须将Azure给我们的公共域名映射到我们从Azure负载均衡器获取的外部IP，以证明所有权。
- en: 'The following steps will help us link a DNS entry to our public IP:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助我们将DNS条目链接到我们的公共IP：
- en: 'Let''s go ahead and link a DNS name to our public IP address. First, make sure
    you get your IP address from your Ingress service:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续将DNS名称链接到我们的公共IP地址。首先，请确保从您的Ingress服务获取IP地址：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note down the IP of the Ingress service. In the Azure Search bar, now look
    for `public ip`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 记下Ingress服务的IP。在Azure搜索栏中，现在搜索`public ip`：
- en: '![Type public ip in your search bar on the Azure search bar and select "Public
    IP addresses"](image/Figure_6.7.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![在Azure搜索栏中键入公共IP并选择“公共IP地址”](image/Figure_6.7.jpg)'
- en: 'Figure 6.7: Searching for public ip in the Azure search bar'
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.7：在Azure搜索栏中搜索公共IP
- en: Once there, you should see a number of public IP addresses. To find our public
    IP address, you can show an extra column here that would show you the actual IP
    address. Hit the **Edit columns** button to add the extra column:![When you find
    your public IP from the default directory page on the Azure portal, click on the
    Edit columns button located on top of the page. This will open the column selector.](image/Figure_6.8.jpg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦到达那里，您应该会看到许多公共IP地址。要找到我们的公共IP地址，您可以在这里显示一个额外的列，该列将显示实际的IP地址。点击“编辑列”按钮添加额外的列：![当您从Azure门户上的默认目录页面找到您的公共IP时，点击页面顶部的“编辑列”按钮。这将打开列选择器。](image/Figure_6.8.jpg)
- en: 'Figure 6.8: Clicking on Edit columns to add an extra column'
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.8：点击“编辑列”以添加额外的列
- en: In the column selector, pick **IP address** and hit the arrow pointing right,
    as shown in *Figure 6.9*:![To add the IP address to the selected columns, click
    on the IP address tab in the Available columns navigation pane. Next, click on
    the arrow facing right located at the center of the page.](image/Figure_6.9.jpg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列选择器中，选择“IP地址”，然后点击向右的箭头，如*图6.9*所示：![要将IP地址添加到所选列中，请点击“可用列”导航窗格中的IP地址选项卡。接下来，点击位于页面中央的向右的箭头。](image/Figure_6.9.jpg)
- en: 'Figure 6.9: Adding the IP address to the selected columns'
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.9：将IP地址添加到所选列
- en: Hit **Apply** to show the actual IP addresses. When you see yours, click on
    it. In the blade for your IP address, enter the **Configuration** view. Then,
    enter a *unique* DNS name and hit **Save**:![Open your IP address. Click on the
    Configurations tab in the Navigation pane. Enter the unique name of the DNS, and
    then click on the Save button alongside the search bar.](image/Figure_6.10.jpg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“应用”以显示实际的IP地址。当您看到您的IP地址时，请点击它。在您的IP地址的窗格中，进入“配置”视图。然后，输入一个*唯一*的DNS名称，然后点击“保存”：![打开您的IP地址。点击导航窗格中的“配置”选项卡。输入DNS的唯一名称，然后点击搜索栏旁边的保存按钮。](image/Figure_6.10.jpg)
- en: 'Figure 6.10: Adding a unique DNS name label and saving the configuration'
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.10：添加一个唯一的DNS名称标签并保存配置
- en: You now have a DNS record linked to your public IP address. Next, you will install
    the certificate issuer in your cluster.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了与您的公共IP地址相关联的DNS记录。接下来，您将在集群中安装证书颁发机构。
- en: '**Installing the certificate issuer**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装证书颁发机构**'
- en: 'In this section, we will install the Let''s Encrypt staging certificate issuer.
    A certificate can be issued by multiple issuers. `letsencrypt-staging`, for example,
    is for testing purposes. As we are building tests, we''ll use the staging server.
    The code for the certificate issuer has been provided in the source code for this
    chapter in the `certificate-issuer.yaml` file. As usual, use `kubectl create -f
    certificate-issuer.yaml`, which has the following contents:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将安装Let's Encrypt的staging证书颁发机构。一个证书可以由多个颁发机构颁发。例如，`letsencrypt-staging`是用于测试目的。由于我们正在构建测试，我们将使用staging服务器。证书颁发机构的代码已经在本章的源代码中提供在`certificate-issuer.yaml`文件中。像往常一样，使用`kubectl
    create -f certificate-issuer.yaml`，其中包含以下内容：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s look at what we have defined here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们在这里定义了什么：
- en: '**Lines 1-2**: Here, we have used the **CustomResourceDefinition** (**CRD**)
    that we installed earlier. A CRD is a way to extend the Kubernetes API server
    to create custom resources, like a certificate issuer. In this case specifically,
    we point to the `cert-manager` API CRD we injected into the Kubernetes API and
    create an `Issuer` object.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第1-2行**：在这里，我们使用了我们之前安装的**CustomResourceDefinition**（**CRD**）。CRD是扩展Kubernetes
    API服务器以创建自定义资源的一种方式，比如证书颁发机构。在这种情况下，我们特别指向了我们注入到Kubernetes API中的`cert-manager`
    API CRD，并创建了一个`Issuer`对象。'
- en: '**Lines 6-10**: We have provided the configuration for Let''s Encrypt in these
    lines and pointed to the staging server.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第6-10行**：我们在这些行中提供了Let''s Encrypt的配置，并指向了staging服务器。'
- en: '**Lines 11-14**: This is additional configuration for the ACME client to certify
    domain ownership.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第11-14行**：这是用于ACME客户端认证域名所有权的附加配置。'
- en: 'With the certificate issuer installed, we can now move to the next step: creating
    the TLS certificate.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了证书颁发者后，我们现在可以进行下一步：创建TLS证书。
- en: '**Creating the TLS certificate and securing our service**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建TLS证书并保护我们的服务**'
- en: 'In this section, we will create a TLS certificate. There are two ways you can
    configure `cert-manager` to create certificates. You can either manually create
    a certificate and link it to the Ingress controller, or you can configure your
    Ingress controller so `cert-manager` automatically creates the certificate. In
    this example, we''ll show you the second way, by editing our Ingress to look like
    the following YAML code. This file is present in the source code on GitHub as
    `ingress-with-tls.yaml`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个TLS证书。您可以通过两种方式配置`cert-manager`来创建证书。您可以手动创建证书并将其链接到Ingress控制器，或者您可以配置Ingress控制器，以便`cert-manager`自动创建证书。在本例中，我们将向您展示第二种方法，即通过编辑我们的Ingress来使其看起来像以下的YAML代码。此文件在GitHub上的源代码中存在，名称为`ingress-with-tls.yaml`：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have made the following changes to the original Ingress:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对原始Ingress进行了以下更改：
- en: '**Line 6**: We have added an annotation to our Ingress that points to a certificate
    issuer.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第6行**：我们已经在Ingress上添加了一个指向证书颁发者的注释。'
- en: '**Lines 10 and 13**: The domain name for our Ingress has been added here. This
    is required because Let''s Encrypt only issues certificates for domains.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第10行和第13行**：我们在这里添加了Ingress的域名。这是必需的，因为Let''s Encrypt只为域名颁发证书。'
- en: '**Line 11**: This is the name of the secret that will be created to store our
    certificate.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第11行**：这是将用于存储我们的证书的密钥的名称。'
- en: 'You can update the Ingress we created earlier with the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令更新我们之前创建的Ingress：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It takes `cert-manager` about a minute to request a certificate and configure
    our Ingress to use that certificate. While we are waiting for that, let's have
    a look at the intermediate resources that `cert-manager` created on our behalf.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`cert-manager`大约需要一分钟来请求证书并配置我们的Ingress以使用该证书。在等待期间，让我们来看看`cert-manager`代表我们创建的中间资源。'
- en: 'First off, `cert-manager` created a `certificate` object for us. We can look
    at the status of that object using:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`cert-manager`为我们创建了一个`certificate`对象。我们可以使用以下命令查看该对象的状态：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This command will generate an output as shown in *Figure 6.11*:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令将生成一个输出，如*图6.11*所示：
- en: '![When the kubectl get certificate command is executed, you should see the
    status of the object is False. This indicates that the certificate is not ready
    yet.](image/Figure_6.11.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![当执行kubectl get certificate命令时，您应该看到对象的状态为False。这表示证书尚未准备就绪。](image/Figure_6.11.jpg)'
- en: 'Figure 6.11: Output displaying the status of the certificate'
  id: totrans-119
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.11：显示证书状态的输出
- en: 'As you can see, our certificate isn''t ready yet. There is another object that
    `cert-manager` created to actually get the certificate. This object is `certificaterequest`.
    We can get its status by using the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的证书尚未准备就绪。`cert-manager`创建了另一个对象来实际获取证书。这个对象是`certificaterequest`。我们可以使用以下命令获取其状态：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will generate the output shown in *Figure 6.12*:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成如*图6.12*所示的输出：
- en: '![Next, when the kubectl get certificaterequest command is executed, this too
    shows the status of the object is False. This indicates that the certificaterequest
    object isn''t ready yet.](image/Figure_6.12.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![接下来，当执行kubectl get certificaterequest命令时，这也显示对象的状态为False。这表示证书请求对象尚未准备就绪。](image/Figure_6.12.jpg)'
- en: 'Figure 6.12: Output displaying the status of the certificaterequest object
    as False'
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.12：输出显示证书请求对象的状态为False
- en: 'We can also get more details about the request by issuing a `describe` command
    against the `certificaterequest` object:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过针对`certificaterequest`对象发出`describe`命令来获取有关请求的更多详细信息：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'While we''re waiting for our certificate to be issued, the status will look
    similar to *Figure 6.13*:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在等待证书签发时，状态将类似于*图6.13*：
- en: '![Using the kubectl describe certificaterequestcommand, you can obtain more
    details on the certificaterequest object that will indicate that the status is
    False. It shows a message saying"Created Order resource default/frontend-tls-<random
    ID>".](image/Figure_6.13.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![使用kubectl describe certificaterequest命令，您可以获取有关certificaterequest对象的更多详细信息，指示状态为False。它显示一条消息说“创建了订单资源default/frontend-tls-<随机ID>”。](image/Figure_6.13.jpg)'
- en: 'Figure 6.13: Output providing more details on the certificaterequest object'
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.13：提供有关certificaterequest对象的更多详细信息的输出
- en: 'If we give this a couple of additional seconds, the `describe` command should
    return a successful certificate creation message, as shown in *Figure 6.14*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再给它几秒钟，`describe`命令应该会返回一个成功创建证书的消息，如*图6.14*所示：
- en: '![After a couple of seconds, you will see that the details have been updated
    and the status changes to True. There is a message saying "Certificate fetched
    from issuer successfully," which means that the certificate is now issued.](image/Figure_6.14.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![几秒钟后，您将看到详细信息已更新，状态更改为True。有一条消息说“成功从签发者获取证书”，这意味着证书现在已签发。](image/Figure_6.14.jpg)'
- en: 'Figure 6.14: Output displaying the issued certificate'
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.14：显示已签发证书的输出
- en: 'This should now enable our front-end Ingress to be served over HTTPS. Let''s
    try this out in a browser by browsing to the DNS name you created in the section
    mapping an FQDN. This will indicate an error in the browser, showing you that
    the certificate isn''t valid as shown in *Figure 6.15*. This is to be expected
    since we are using the Let''s Encrypt staging service:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这应该可以使我们的前端Ingress通过HTTPS提供服务。让我们在浏览器中尝试一下，浏览到您在映射FQDN部分创建的DNS名称。这将在浏览器中显示错误，显示证书无效，如*图6.15*所示。这是可以预期的，因为我们正在使用Let's
    Encrypt临时服务：
- en: '![The screen will displaya message saying that your connection isn''t private.](image/Figure_6.15.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![屏幕将显示一条消息，说明您的连接不是私密的。](image/Figure_6.15.jpg)'
- en: 'Figure 6.15: Using the Let''s Encrypt staging server, our certificate isn''t
    trusted by default'
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.15：使用Let's Encrypt临时服务器，我们的证书默认不受信任
- en: You can browse to your application by clicking **Advanced** and selecting **Continue**.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过单击**高级**并选择**继续**来浏览到您的应用程序。
- en: Since we were able to complete our test with the staging certificate, we can
    now move on to production.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们能够完成临时证书的测试，现在我们可以转向生产环境。
- en: '**Switching from staging to production**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**从临时切换到生产**'
- en: 'In this section, we will switch from a staging certificate to a production-level
    certificate. To do this, you can redo the previous exercise by creating a new
    issuer in your cluster, like the following (provided in `certificate-issuer-prod.yaml`).
    Don''t forget to change your email address in the file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从临时证书切换到生产级证书。要做到这一点，您可以通过在集群中创建一个新的签发者来重新执行上一个练习，就像以下所示（在`certificate-issuer-prod.yaml`中提供）。不要忘记在文件中更改您的电子邮件地址：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And then replace the reference to the issuer in the `ingress-with-tls.yaml`
    file to `letsencrypt-prod`, like this (provided in the `ingress-with-tls-prod.yaml`
    file):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`ingress-with-tls.yaml`文件中对签发者的引用替换为`letsencrypt-prod`，就像这样（在`ingress-with-tls-prod.yaml`文件中提供）：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To apply these changes, execute the following commands:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用这些更改，请执行以下命令：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It will again take about a minute for the certificate to become active. Once
    the new certificate is issued, you can browse to your DNS name again, and shouldn''t
    see any more warnings regarding invalid certificates. If you click the padlock
    item in the browser, you should see that your connection is secure and uses a
    valid certificate:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 证书再次生效大约需要一分钟。一旦新证书发放，您可以再次浏览到您的DNS名称，并且不应该再看到关于无效证书的警告。如果您单击浏览器中的挂锁项目，您应该会看到您的连接是安全的，并使用有效的证书。
- en: '![Clicking the padlock icon on the browser''s address bar will tell you that
    your connection is secure. This pop-up window will also let you know that the
    certificate is valid.](image/Figure_6.16.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![单击浏览器地址栏上的挂锁图标将告诉您连接是安全的。这个弹出窗口还会让您知道证书是有效的。](image/Figure_6.16.jpg)'
- en: 'Figure 6.16: The web page displaying a valid certificate'
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.16：显示有效证书的网页
- en: 'In this section, we have introduced two new concepts: first, we added an Ingress
    to our guestbook application. We did this by first setting up an Ingress controller
    on our cluster and then setting up the Ingress for our guestbook application.
    An Ingress allows advanced routing and HTTPS offloading for applications on top
    of Kubernetes. After that, we added HTTPS to our guestbook application. We didn''t
    have to change the source code of the application itself; we were able to add
    HTTPS support by configuring our Ingress.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了两个新概念：首先，我们为我们的留言板应用程序添加了一个Ingress。我们首先在集群上设置了一个Ingress控制器，然后为我们的留言板应用程序设置了Ingress。Ingress允许在Kubernetes之上为应用程序进行高级路由和HTTPS卸载。之后，我们为我们的留言板应用程序添加了HTTPS。我们不需要更改应用程序本身的源代码；通过配置我们的Ingress，我们能够添加HTTPS支持。
- en: In the next section, we'll add yet another security layer. We will add authentication
    to our application. Before diving into this, let's first discuss a common misunderstanding
    about authentication and authorization.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将为我们的应用程序添加另一个安全层。我们将为我们的应用程序添加认证。在深入讨论之前，让我们首先讨论一下关于认证和授权的常见误解。
- en: Authentication versus authorization
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证与授权
- en: '**Authentication** (**AuthN**) is very often mixed up with **authorization**
    (**AuthZ**). Authentication deals with identity (who are you?) and, in general,
    requires a trusted identity provider. Multiple providers exist, such as Azure
    AD, Okta, or GitHub, and even social media platforms such as Facebook, Google,
    or Twitter can be used as a provider. Authorization deals with permissions (what
    are you trying to do?) and is very implementation-specific in terms of what application
    resources need to be protected.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证**（**AuthN**）经常与**授权**（**AuthZ**）混淆。认证涉及身份（你是谁？），通常需要一个受信任的身份提供者。存在多个提供者，如Azure
    AD、Okta或GitHub，甚至社交媒体平台如Facebook、Google或Twitter也可以用作提供者。授权涉及权限（你想做什么？），在应用程序资源需要受保护方面非常具体。'
- en: It generally takes multiple attempts to understand the difference, and even
    then you can still get confused between the two. The source of confusion is that
    in some cases, the authentication provider and the authorization provider are
    the same. For instance, in our WordPress example, WordPress provides the authentication
    (it has the username and password) and authorization (it stores the users under
    admin or user roles, for example).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通常需要多次尝试才能理解两者之间的区别，即使这样，你仍然可能会在两者之间感到困惑。混淆的根源在于，在某些情况下，认证提供者和授权提供者是相同的。例如，在我们的WordPress示例中，WordPress提供认证（它有用户名和密码）和授权（它将用户存储在管理员或用户角色下，例如）。
- en: However, in most cases, the authentication system and the authorization system
    are different. We'll use a practical example of this in *Chapter 10*, *Securing
    your AKS cluster*. In that chapter, we will use Azure AD as an authentication
    source, while using Kubernetes RBAC as the authorization source.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大多数情况下，身份验证系统和授权系统是不同的。我们将在*第10章*，*保护您的AKS集群*中使用一个实际的例子。在该章节中，我们将使用Azure
    AD作为身份验证源，同时使用Kubernetes RBAC作为授权源。
- en: Authentication and common authN providers
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 身份验证和常见的身份验证提供商
- en: Our guestbook application is open to all and lets anyone with a public IP access
    the service. The image by itself has no authentication. A common problem is wanting
    to apply additional functionality separately from the application implementation.
    This can be done by introducing a proxy that will serve the authentication traffic,
    rather than introducing the authentication logic in the main application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的留言板应用对所有人开放，并允许任何拥有公共IP的人访问该服务。图像本身没有身份验证。一个常见的问题是希望将附加功能与应用程序实现分开。这可以通过引入一个代理来实现，该代理将提供身份验证流量，而不是在主应用程序中引入身份验证逻辑。
- en: 'With recent hacks, it has proven to be difficult to set up and maintain a secure
    authentication system by yourself. To help their customers build secure applications,
    many companies allow you to use their authentication service to verify a user''s
    identity. Authentication is provided as a service by those providers with support
    for OAuth. Here are some of the well-known providers:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的黑客攻击表明，自己建立和维护安全的身份验证系统是困难的。为了帮助客户构建安全的应用程序，许多公司允许您使用他们的身份验证服务来验证用户的身份。这些提供商提供了OAuth支持的身份验证服务。以下是一些知名的提供商：
- en: '**Azure** ([https://github.com/pusher/oauth2_proxy#azure-auth-provider](https://github.com/pusher/oauth2_proxy#azure-auth-provider))'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure** ([https://github.com/pusher/oauth2_proxy#azure-auth-provider](https://github.com/pusher/oauth2_proxy#azure-auth-provider))'
- en: '**Facebook** ([https://github.com/pusher/oauth2_proxy#facebook-auth-provider](https://github.com/pusher/oauth2_proxy#facebook-auth-provider))'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Facebook** ([https://github.com/pusher/oauth2_proxy#facebook-auth-provider](https://github.com/pusher/oauth2_proxy#facebook-auth-provider))'
- en: '**GitHub** (https://github.com/pusher/oauth2_proxy#github-auth-provider)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub** (https://github.com/pusher/oauth2_proxy#github-auth-provider)'
- en: '**GitLab** (https://github.com/pusher/oauth2_proxy#gitlab-auth-provider)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitLab** (https://github.com/pusher/oauth2_proxy#gitlab-auth-provider)'
- en: '**Google** (https://github.com/pusher/oauth2_proxy#google-auth-provider)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google** (https://github.com/pusher/oauth2_proxy#google-auth-provider)'
- en: '**LinkedIn** ([https://github.com/pusher/oauth2_proxy#linkedin-auth-provider](https://github.com/pusher/oauth2_proxy#linkedin-auth-provider))'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LinkedIn** ([https://github.com/pusher/oauth2_proxy#linkedin-auth-provider](https://github.com/pusher/oauth2_proxy#linkedin-auth-provider))'
- en: In the following sections, we will use a proxy implementation, `oauth2_proxy`,
    to implement authentication for our guestbook example.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将使用代理实现`oauth2_proxy`来为我们的留言板示例实现身份验证。
- en: Deploying the oauth2_proxy proxy
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署oauth2_proxy代理
- en: 'Let''s start with cleaning up the previously deployed Ingress. We''ll keep
    the certificate issuer deployed in the cluster. We can clean up the Ingress using:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从清理之前部署的Ingress开始。我们将保留集群中部署的证书颁发机构。我们可以使用以下方式清理Ingress：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are going to implement `oauth2_proxy` from Pusher ([https://github.com/pusher/oauth2_proxy](https://github.com/pusher/oauth2_proxy)).
    Implement the following steps to configure `oauth2_proxy` to use Azure AD as an
    authentication system.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现来自Pusher的`oauth2_proxy` ([https://github.com/pusher/oauth2_proxy](https://github.com/pusher/oauth2_proxy))。按照以下步骤配置`oauth2_proxy`以使用Azure
    AD作为身份验证系统。
- en: 'First, register an app with Azure AD. Open the Azure AD blade in the portal
    by searching for `azure active directory` in the search bar:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在Azure AD中注册一个应用程序。通过在搜索栏中搜索`azure active directory`来打开门户中的Azure AD选项卡：
- en: '![Type azure active directory in the search bar.](image/Figure_6.17.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![在搜索栏中输入Azure活动目录。](image/Figure_6.17.jpg)'
- en: 'Figure 6.17: Searching for Azure Active Directory in the Azure search bar'
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.17：在Azure搜索栏中搜索Azure活动目录
- en: 'Then, go to **App registrations** and click **New registration**:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，转到**应用注册**并点击**新注册**：
- en: '![Click on App registrations in the Navigation pane in Azure Active Directory.
    Next, click on the New registration tab alongside the search bar. A new application
    registration will be created.](image/Figure_6.18.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![在Azure活动目录的导航窗格中点击应用注册。接下来，点击搜索栏旁边的新注册选项卡。将创建一个新的应用程序注册。](image/Figure_6.18.jpg)'
- en: 'Figure 6.18: Creating a new application registration'
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.18：创建新的应用程序注册
- en: 'Then, provide a name for the application and hit **Create**:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为应用程序提供名称并点击**创建**：
- en: '![Type a name for the newly created application and save it.](image/Figure_6.19.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![为新创建的应用程序输入名称并保存。](image/Figure_6.19.jpg)'
- en: 'Figure 6.19: Providing a name for the application'
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.19：为应用程序提供名称
- en: 'Next, create a client ID secret by performing the following steps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过以下步骤创建客户端ID密钥：
- en: Select **Certificates & secrets** and go to **New client secret**. Give the
    secret a description and hit **Add**:![Once you open your application, click on
    the Certificates & secrets tab in the navigation pane on the leftside of the screen.
    Click on New client secret button. Set oauth2_proxy as the description for this
    application. Set the expiry duration to 1 year and click on the Add button.](image/Figure_6.20.jpg)
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**证书和密钥**，然后转到**新的客户端密钥**。为密钥提供描述并点击**添加**：![打开应用程序后，点击左侧屏幕导航窗格中的证书和密钥选项卡。点击新的客户端密钥按钮。将oauth2_proxy设置为此应用程序的描述。将到期时间设置为1年，然后点击添加按钮。](image/Figure_6.20.jpg)
- en: 'Figure 6.20: Creating a new client secret'
  id: totrans-179
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.20：创建新的客户端密钥
- en: Click on the copy icon and save the secret in a safe place:![To copy and save
    the secret in a safe place, click on the copy icon alongside the value of the
    client secret.](image/Figure_6.21.jpg)
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击复制图标并将密钥保存在安全的地方：![要复制并将密钥保存在安全的地方，请点击客户端密钥值旁边的复制图标。](image/Figure_6.21.jpg)
- en: 'Figure 6.21: Copying the client secret'
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.21：复制客户端密钥
- en: Next, we will need to configure a redirect URL. This is the URL that Azure AD
    will call back once the user has been authenticated. To configure this, head over
    to **Authentication** in the Azure AD blade, click on **Add a platform**, and
    select **Web**, as shown in *Figure 6.22*:![Click on the Authentication tab in
    the navigation pane on the leftside of the screen. Next, click on the Add Platform
    button in the Platform Configurations section in the center of the screen. This
    will open a new page to help you configure platforms. Select the Web option in
    the Web applications section.](image/Figure_6.22.jpg)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置重定向URL。这是Azure AD在用户经过身份验证后将回调的URL。要进行配置，请转到Azure AD的**身份验证**，点击**添加平台**，然后选择**Web**，如*图6.22*所示：![点击左侧屏幕导航窗格中的身份验证选项卡。接下来，点击平台配置部分中的添加平台按钮。这将打开一个新页面，帮助您配置平台。在Web应用程序部分中选择Web选项。](image/Figure_6.22.jpg)
- en: 'Figure 6.22: Providing a redirect URL'
  id: totrans-183
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.22：提供重定向URL
- en: 'Once there, you can enter the following URL:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，您可以输入以下URL：
- en: '`https://<your dns prefix>.<your azure region>.cloudapp.azure.com/oauth2/callback`
    and hit **Configure**.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://<your dns prefix>.<your azure region>.cloudapp.azure.com/oauth2/callback`，然后点击**配置**。'
- en: Then, go back to the **Overview** blade and save the **Application** and the
    **Directory ID**:![Copy the Application ID and the Directory ID and save it in
    the Overview blade on the leftside of the screen.](image/Figure_6.23.jpg)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，返回**概述**窗格并保存**应用程序**和**目录ID**：![在左侧屏幕的概述窗格中复制应用程序ID和目录ID并保存。](image/Figure_6.23.jpg)
- en: 'Figure 6.23: Copying the Application ID and the Directory ID'
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.23：复制应用程序ID和目录ID
- en: 'After creating the client ID secret, setting the redirect URL, and copying
    the application and directory IDs, we need to create the following three objects
    in Kubernetes to get `oauth2_proxy` working on our cluster and perform a final
    step to link OAuth to our existing Ingress:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建客户端ID密钥、设置重定向URL和复制应用程序和目录ID之后，我们需要在Kubernetes中创建以下三个对象，以使`oauth2_proxy`在我们的集群上运行，并执行最后一步将OAuth链接到我们现有的Ingress：
- en: First, we need to create a deployment for `oauth2_proxy`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要为`oauth2_proxy`创建一个部署。
- en: Then, we need to expose this as a service.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要将其公开为一个服务。
- en: After that, we will create a new Ingress for `oauth2`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将为`oauth2`创建一个新的Ingress。
- en: And finally, we will reconfigure our current Ingress to send unauthenticated
    requests to `oauth2_proxy`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将重新配置当前的Ingress，以便将未经身份验证的请求发送到`oauth2_proxy`。
- en: 'We will execute all three steps while showing the YAML files as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行所有三个步骤，并显示YAML文件如下：
- en: 'Let''s start with the first item – creating the deployment. The deployment
    can be found in the source as the `oauth2_deployment.yaml` file:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从第一项开始 - 创建部署。 部署可以在源代码中找到`oauth2_deployment.yaml`文件：
- en: '[PRE18]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This deployment has a couple of interesting lines to discuss. We discussed
    the other lines in previous examples in *Chapter 3*, *Application deployment on
    AKS*. We''ll focus on the following lines here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部署有几行有趣的内容需要讨论。 我们在*第3章*的先前示例中讨论了其他行。 我们将在这里重点讨论以下行：
- en: '**Lines 17-18**: These lines tell the `oauth2` proxy to redirect to Azure AD.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**第17-18行**：这些行告诉`oauth2`代理重定向到Azure AD。'
- en: '**Lines 19-32**: This is the `oauth2` configuration.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**第19-32行**：这是`oauth2`的配置。'
- en: '**Line 33**: This line points to the correct container image. This is the first
    time we have used an image that is not hosted on Docker Hub. **Quay** is an alternative
    container repository, hosted by RedHat.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**第33行**：这行指向正确的容器镜像。 这是我们第一次使用不是托管在Docker Hub上的镜像。 **Quay**是由RedHat托管的另一个容器存储库。'
- en: 'Create the deployment using the following command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建部署：
- en: '[PRE19]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, `oauth2` needs to be exposed as a service so that the Ingress can talk
    to it by creating the following service (`oauth2_service.yaml`):'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`oauth2`需要被公开为一个服务，以便Ingress可以与其通信，通过创建以下服务（`oauth2_service.yaml`）：
- en: '[PRE20]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create this service using:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建此服务：
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will create an Ingress so that any URL that goes to `handsonaks-ingress-<yourname>.<your
    azure region>.cloudapp.azure.com/oauth` will be redirected to the `oauth2-proxy`
    service. The same Let''s Encrypt certiﬁcate issuer is used here (the `oauth2_ingress.yaml`
    file in the source code for this chapter):'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个Ingress，以便任何访问`handsonaks-ingress-<yourname>.<your azure region>.cloudapp.azure.com/oauth`的URL将被重定向到`oauth2-proxy`服务。
    这里使用相同的Let's Encrypt证书颁发者（本章的源代码中的`oauth2_ingress.yaml`文件）：
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There is one interesting line to point out in this Ingress. **Line 17** introduced
    a new path to our Ingress. As mentioned earlier in this chapter, the same Ingress
    can have multiple paths being directed to different back-end services. This is
    what we are configuring here.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Ingress中有一行很有趣。 **第17行**引入了一个新的路径到我们的Ingress。 正如本章前面提到的，同一个Ingress可以将多个路径指向不同的后端服务。
    这就是我们在这里配置的内容。
- en: 'Create this Ingress by using the following command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建此Ingress：
- en: '[PRE23]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, we will link the `oauth2` proxy to the front-end service by creating
    an Ingress that configures `nginx` so that authentication is checked using the
    paths in `auth-url` and `auth-signin`. If the request is not authenticated, traffic
    is sent to the `oauth2_proxy`. If it is successfully authenticated, the traffic
    is redirected to the back-end service (in our case, it is the front-end service).
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将通过创建Ingress将`oauth2`代理链接到前端服务，以配置`nginx`，以便使用`auth-url`和`auth-signin`中的路径进行身份验证检查。如果请求未经身份验证，则流量将发送到`oauth2_proxy`。如果成功经过身份验证，则流量将重定向到后端服务（在我们的案例中是前端服务）。
- en: 'The following code performs the redirection once authentication is successful
    (`frontend-oauth2-ingress.yaml` in the GitHub repository):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub存储库中的以下代码执行身份验证成功后的重定向（`frontend-oauth2-ingress.yaml`）：
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are a couple of interesting things to point in this Ingress configuration.
    The other lines are common with the other Ingresses we have created throughout
    this chapter:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Ingress配置中有一些有趣的地方要指出。其他行与我们在本章中创建的其他Ingress一样普通：
- en: '**Line 5:** As mentioned previously, the Ingress object can be backed by multiple
    technologies (such as NGINX or Application Gateway). The Ingress object has a
    syntax to configure basic tasks, such as `hosts` and `paths`, but it doesn''t
    have a configuration for authentication redirects, for example. Annotations are
    used by multiple Ingress providers to pass detailed configuration data to the
    Ingress provider in the back end.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 第5行：如前所述，Ingress对象可以由多种技术（如NGINX或应用程序网关）支持。 Ingress对象具有配置基本任务的语法，例如“hosts”和“paths”，但例如没有配置身份验证重定向。注释由多个Ingress提供程序使用，以将详细配置数据传递给后端的Ingress提供程序。
- en: '**Lines 7-8:** This configures our Ingress to send non-authenticated requests
    to these URLs.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第7-8行：这将配置我们的Ingress将非经过身份验证的请求发送到这些URL。
- en: 'Create this Ingress using the following command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建此Ingress：
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We are now done with configuration. You can now log in with your existing Microsoft
    account to the service at `https://handsonaks-ingress-<yourname>.<your azure region>.cloudapp.azure.net/`.
    To make sure you get the authentication redirect, please make sure to use a new
    browser window or a private window. You should get automatically redirected to
    Azure AD's sign in page.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了配置。您现在可以使用现有的Microsoft帐户登录到`https://handsonaks-ingress-<yourname>.<your
    azure region>.cloudapp.azure.net/`的服务。为了确保您获得身份验证重定向，请确保使用新的浏览器窗口或私人窗口。您应该会自动重定向到Azure
    AD的登录页面。
- en: Note
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`oauth2-proxy` supports multiple authentication providers, such as GitHub and
    Google. Only the `oauth2-proxy` deployment''s YAML has to be changed with the
    right service to change the authentication provider. Please see the relevant details
    at https://github.com/pusher/oauth2_proxy#oauth- provider-configuration.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`oauth2-proxy`支持多个身份验证提供程序，例如GitHub和Google。只需更改`oauth2-proxy`部署的YAML以使用正确的服务更改身份验证提供程序。请参阅https://github.com/pusher/oauth2_proxy#oauth-provider-configuration中的相关详细信息。'
- en: 'Now that everything has been deployed, let''s clean up the resources we created
    in our cluster:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已部署完成，让我们清理一下我们在集群中创建的资源：
- en: '[PRE26]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this section, we have added Azure AD authentication to your application.
    We did this by adding the `oauth2_proxy` to our cluster, and we then reconfigured
    the existing Ingress to redirect unauthenticated requests to `oauth2_proxy`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已将Azure AD身份验证添加到您的应用程序。我们通过将`oauth2_proxy`添加到我们的集群，然后重新配置现有的Ingress以将未经身份验证的请求重定向到`oauth2_proxy`来实现这一点。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added HTTPS security and identity control to our guestbook
    application without actually changing the source code. We started by getting the
    Kubernetes Ingress objects set up in our cluster. Then, we installed a certificate
    manager that interfaces with the Let's Encrypt API to request a certificate for
    the domain name we subsequently specified. We leveraged a certificate issuer to
    get the certificate from Let's Encrypt. We then reconfigured our Ingress to request
    a certificate from this issuer in the cluster.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在不实际更改源代码的情况下，为我们的留言板应用程序添加了HTTPS安全性和身份控制。我们首先在集群中设置了Kubernetes Ingress对象。然后，我们安装了一个证书管理器，该管理器与Let's
    Encrypt API接口，以请求指定的域名的证书。我们利用证书签发者从Let's Encrypt获取了证书。然后，我们重新配置了我们的Ingress，以从集群中的签发者请求证书。
- en: Then, we jumped into authentication and authorization and showed you how to
    leverage Azure AD as an authentication provider for the guestbook application.
    You learned how to secure your applications on an enterprise scale. By integrating
    with Azure AD, you can enable any application to link to an organization's AD.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们深入探讨了身份验证和授权，并向您展示了如何利用Azure AD作为留言板应用程序的身份验证提供者。您将学习如何在企业规模上保护您的应用程序。通过与Azure
    AD集成，您可以使任何应用程序连接到组织的AD。
- en: In the next chapter, you will learn how to monitor your deployments and set
    up alerts. You will also learn how to quickly identify root causes when errors
    do occur, and you will learn how to debug applications running on AKS. At the
    same time, you'll learn how to perform the correct fixes once you have identified
    the root causes.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何监视您的部署并设置警报。您还将学习如何在发生错误时快速识别根本原因，并学习如何调试在AKS上运行的应用程序。与此同时，您还将学习如何在确定了根本原因后执行正确的修复操作。
