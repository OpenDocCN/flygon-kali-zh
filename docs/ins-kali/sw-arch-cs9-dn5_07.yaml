- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Azure Kubernetes Service
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure Kubernetes Service
- en: This chapter is dedicated to describing the Kubernetes microservices orchestrator
    and, in particular, its implementation in Azure named Azure Kubernetes Service.
    The chapter explains the fundamental Kubernetes concepts, and then focuses on
    how to interact with a Kubernetes cluster, and how to deploy an Azure Kubernetes
    application. All concepts are put into practice with simple examples. We recommend
    reading *Chapter 5*, *Applying a Microservice Architecture to Your Enterprise
    Application*, and *Chapter 6*, *Azure Service Fabric*, before dealing with this
    chapter, since it relies on the concepts explained in these previous chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于描述Kubernetes微服务编排器，特别是在Azure中的实现，名为Azure Kubernetes Service。该章节解释了基本的Kubernetes概念，然后重点介绍了如何与Kubernetes集群进行交互，以及如何部署Azure
    Kubernetes应用程序。所有概念都通过简单的示例进行了实践。我们建议在阅读本章之前先阅读*第5章*的*将微服务架构应用于企业应用程序*和*第6章*的*Azure
    Service Fabric*，因为它依赖于这些先前章节中解释的概念。
- en: 'More specifically, in this chapter you will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，在本章中，您将学习以下主题：
- en: Kubernetes basics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes基础
- en: Interacting with Azure Kubernetes clusters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Azure Kubernetes集群交互
- en: Advanced Kubernetes concepts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级Kubernetes概念
- en: By the end of this chapter, you will have learned how to implement and deploy
    a complete solution based on Azure Kubernetes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将学会如何实现和部署基于Azure Kubernetes的完整解决方案。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Visual Studio 2019 free Community Edition or better, with all the database tools
    installed or any other `.yaml` file editor such as Visual Studio Code.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019免费的Community Edition或更高版本，安装了所有数据库工具，或者任何其他`.yaml`文件编辑器，如Visual
    Studio Code。
- en: A free Azure account. The *Creating an Azure account* section in *Chapter 1*,
    *Understanding the Importance of Software Architecture*, explains how to create one.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 免费的Azure账户。*第1章*的*创建Azure账户*部分解释了如何创建一个。
- en: The code for this chapter is available at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在[https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5)找到。
- en: Kubernetes basics
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes基础
- en: Kubernetes is an advanced, open source orchestrator that you can install locally
    on your private machine's cluster. At the time of writing, it is the most widespread
    orchestrator, so Microsoft also offers it as a better alternative to Azure Service
    Fabric, since it is currently the *de facto* standard, and can rely on a wide
    ecosystem of tools and applications. This section introduces basic Kubernetes
    concepts and entities.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是一个先进的开源编排器，您可以在私人机器集群上本地安装。在撰写本文时，它是最广泛使用的编排器，因此微软也将其作为Azure Service
    Fabric的更好替代品，因为它目前是*事实上*的标准，并且可以依赖于广泛的工具和应用程序生态系统。本节介绍了基本的Kubernetes概念和实体。
- en: A Kubernetes cluster is a cluster of virtual machines running the Kubernetes
    orchestrator. As for Azure Service Fabric, the virtual machines composing the
    cluster are called nodes. The smallest software unit we can deploy on Kubernetes
    is not a single application, as in the case of Azure Service Fabric, but an aggregate
    of containerized applications called pods. While Kubernetes supports various types
    of containers, the most commonly used container type is Docker, which we analyzed
    in *Chapter 5*, *Applying a Microservice Architecture to Your Enterprise Application*,
    so we will confine our discussion to Docker.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes集群是运行Kubernetes编排器的虚拟机集群。与Azure Service Fabric一样，组成集群的虚拟机被称为节点。我们可以在Kubernetes上部署的最小软件单元不是单个应用程序，而是一组容器化的应用程序，称为pod。虽然Kubernetes支持各种类型的容器，但最常用的容器类型是Docker，我们在*第5章*的*将微服务架构应用于企业应用程序*中进行了分析，因此我们将把讨论限制在Docker上。
- en: '`pods` are important since applications belonging to the same pod are ensured
    to run on the same node. This means that they can easily communicate through localhost
    ports. Communication between different pods, however, is more complex since the
    IP addresses of pods are ephemeral resources because pods have no fixed node where
    they run, but are moved from one node to another by the orchestrator. Moreover,
    pods may be replicated to increase performance, so, in general, it makes no sense
    addressing a message to a specific pod, but just to any of the identical replicas
    of the same pod.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`pod`很重要，因为属于同一pod的应用程序确保在同一节点上运行。这意味着它们可以通过本地主机端口轻松通信。然而，不同pod之间的通信更复杂，因为pod的IP地址是临时资源，因为pod没有固定的节点在其上运行，而是由编排器从一个节点移动到另一个节点。此外，为了提高性能，pod可能会被复制，因此，通常情况下，将消息发送到特定pod是没有意义的，而只需发送到同一pod的任何相同副本之一即可。'
- en: While, in Azure Service Fabric, the infrastructure gives automatically virtual
    net addresses to groups of identical replicas, in Kubernetes we need to define
    explicit resources called Services that are assigned virtual addresses by the
    Kubernetes infrastructure and forward their communications to sets of identical
    pods. In short, Services are Kubernetes way to assign constant virtual addresses
    to sets of pod replicas.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure Service Fabric中，基础设施会自动为相同副本组分配虚拟网络地址，而在Kubernetes中，我们需要定义显式资源，称为服务，这些服务由Kubernetes基础设施分配虚拟地址，并将其通信转发到相同pod的集合。简而言之，服务是Kubernetes分配常量虚拟地址给pod副本集的方式。
- en: All Kubernetes entities may be assigned name value pairs called labels that
    are used to reference them through a pattern matching mechanism. More specifically,
    Selectors select Kubernetes entities by listing labels they must have.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Kubernetes实体都可以分配名称值对，称为标签，用于通过模式匹配机制引用它们。更具体地说，选择器通过列出它们必须具有的标签来选择Kubernetes实体。
- en: Thus, for instance, all pods that receive traffic from the same Service are
    selected by specifying labels they must have in the Service definition.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，所有从同一服务接收流量的pod都是通过在服务定义中指定的标签来选择的。
- en: The way a Service routes its traffic to all connected pods depends on the way
    pods are organized. Stateless pods are organized in so called `ReplicaSets`, which
    are similar to stateless replicas of Azure Service Fabric services. As Azure Service
    Fabric stateless services, `ReplicaSets` have a unique virtual address assigned
    to the whole group and traffic is split equally among all pods of the group.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 服务将其流量路由到所有连接的Pod的方式取决于Pod的组织方式。无状态的Pod被组织在所谓的`ReplicaSets`中，它们类似于Azure Service
    Fabric服务的无状态副本。与Azure Service Fabric无状态服务一样，`ReplicaSets`分配给整个组的唯一虚拟地址，并且流量在组中的所有Pod之间均匀分配。
- en: 'Stateful Kubernetes pod replicas are organized into so called `StatefulSets`.
    Similar to Azure Service Fabric stateful services, `StatefulSets` use sharding
    to split the traffic among all their pods. For this reason, Kubernetes Services
    assign a different name to each pod of the `StatefulSet` they are connected to.
    These names look like the following: `basename-0.<base URL>`, `basename-1.<base
    URL>`, ..., `basename-n.<base URL>`. This way, message sharding is easily accomplished
    as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态的Kubernetes Pod副本被组织成所谓的`StatefulSets`。与Azure Service Fabric有状态服务类似，`StatefulSets`使用分片将流量分配给它们的所有Pod。因此，Kubernetes服务为它们连接的`StatefulSet`的每个Pod分配一个不同的名称。这些名称看起来像这样：`basename-0.<base
    URL>`，`basename-1.<base URL>`，...，`basename-n.<base URL>`。这样，消息分片可以轻松地完成如下：
- en: Each time a message must be sent to a `StatefulSet` composed of *N* replicas,
    you compute a hash between 0 and *N*-1, say `x`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次需要将消息发送到由*N*个副本组成的`StatefulSet`时，计算0到*N*-1之间的哈希值，例如`x`。
- en: Add the postfix `x` to a base name to get a cluster address, such as `basename-x.<base
    URL>`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将后缀`x`添加到基本名称以获取集群地址，例如`basename-x.<base URL>`。
- en: Send the message to the `basename-x.<base URL>` cluster address.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将消息发送到`basename-x.<base URL>`集群地址。
- en: Kubernetes has no predefined storing facilities, and you can't use node disk
    storage since pods are moved among available nodes, so long-term storage must
    be provided with sharded cloud databases or with other kinds of cloud storage.
    While each pod of a `StatefulSet` can access a sharded cloud database with the
    usual connection string technique, Kubernetes offers a technique to abstract disk-like
    cloud storage offered by the external Kubernetes cluster environment. We will
    describe these in the *Advanced Kubernetes concepts* section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes没有预定义的存储设施，也不能使用节点磁盘存储，因为Pod会在可用节点之间移动，因此必须使用分片的云数据库或其他类型的云存储来提供长期存储。虽然`StatefulSet`的每个Pod可以使用常规的连接字符串技术访问分片的云数据库，但Kubernetes提供了一种技术来抽象外部Kubernetes集群环境提供的类似磁盘的云存储。我们将在*高级Kubernetes概念*部分中描述这些内容。
- en: All Kubernetes entities mentioned in this short introduction can be defined
    in a `.yaml` file, which, once deployed to a Kubernetes cluster, causes the actual
    creation of all entities defined in the file. The subsection that follows describes
    `.yaml` files, while the other subsections thereafter describe in detail all the
    basic Kubernetes objects mentioned so far, and explain how to define them in a
    `.yaml` file. Further Kubernetes objects will be described throughout the whole
    chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的介绍中提到的所有Kubernetes实体都可以在`.yaml`文件中定义，一旦部署到Kubernetes集群中，就会创建文件中定义的所有实体。接下来的子节描述了`.yaml`文件，而随后的其他子节详细描述了到目前为止提到的所有基本Kubernetes对象，并解释了如何在`.yaml`文件中定义它们。在整个章节中将描述更多的Kubernetes对象。
- en: .yaml files
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .yaml文件
- en: '`.yaml` files, like JSON files, are a way to describe nested objects and collections
    in a human-readable way, but they do it with a different syntax. You have objects
    and lists, but object properties are not surrounded by `{}`, and lists are not
    surrounded by `[]`. Instead, nested objects are declared by simply indenting their
    content with spaces. The number of spaces can be freely chosen, but once they''ve
    been chosen, they must be used consistently.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`.yaml`文件与JSON文件一样，是一种以人类可读的方式描述嵌套对象和集合的方法，但它们使用不同的语法。你有对象和列表，但对象属性不用`{}`括起来，列表也不用`[]`括起来。相反，嵌套对象通过简单地缩进其内容来声明。可以自由选择缩进的空格数，但一旦选择了，就必须一致使用。'
- en: List items can be distinguished from object properties by preceding them with
    a hyphen (`-`).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表项可以通过在前面加上连字符（`-`）来与对象属性区分开。
- en: 'Here is an example involving nested objects and collections:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是涉及嵌套对象和集合的示例：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding `Person` object has a `Spouse` nested object, and a nested collection
    of addresses.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`Person`对象有一个嵌套的`Spouse`对象和一个嵌套的地址集合。
- en: '`.yaml` files can contain several sections, each defining a different entity,
    that are separated by a line containing the `---` string. Comments are preceded
    by a `#` symbol, which must be repeated on each comment line.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`.yaml`文件可以包含多个部分，每个部分定义一个不同的实体，它们由包含`---`字符串的行分隔。注释以`#`符号开头，在每行注释前必须重复该符号。'
- en: 'Each section starts with the declaration of the Kubernetes API group and version.
    In fact, not all objects belong to the same API group. For objects that belong
    to the `core` API group, we can specify just the API version, as in the following
    example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分都以声明Kubernetes API组和版本开始。实际上，并不是所有对象都属于同一个API组。对于属于`core` API组的对象，我们可以只指定API版本，如下面的示例所示：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'While objects belonging to different API groups must also specify the API name,
    as in the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然属于不同API组的对象也必须指定API名称，如下面的示例所示：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the next subsection, we analyze in detail `ReplicaSets` and `Deployments`
    that are built on top of them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，我们将详细分析构建在其上的`ReplicaSets`和`Deployments`。
- en: ReplicaSets and Deployments
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReplicaSets和Deployments
- en: The most important building block of Kubernetes applications is the `ReplicaSet`,
    that is, a pod replicated *n* times. Usually, however, you adopt a more complex
    object that is built on top of the `ReplicaSet` – the `Deployment`. `Deployments`
    not only create a `ReplicaSet`, but also monitor them to ensure that the number
    of replicas is kept constant, independent of hardware faults and other events
    that might involve the `ReplicaSets`. In other words, they are a declarative way
    of defining `ReplicaSets` and pods.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes应用程序的最重要的构建块是`ReplicaSet`，即一个被复制*n*次的Pod。然而，通常情况下，您会采用一个更复杂的对象，该对象建立在`ReplicaSet`之上
    - `Deployment`。`Deployments`不仅创建`ReplicaSet`，还监视它们以确保副本的数量保持恒定，独立于硬件故障和可能涉及`ReplicaSets`的其他事件。换句话说，它们是一种声明性的定义`ReplicaSets`和Pod的方式。
- en: 'Each `Deployment` has a name (`metadata->name`), an attribute that specifies
    the desired number of replicas (`spec->replicas`), a key-value pair (`spec ->`
    `selector-> matchLabels`) that selects the pods to monitor, and a template (`spec->template`)
    that specifies how to build the pod replicas:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Deployment`都有一个名称（`metadata->name`），一个指定所需副本数量的属性（`spec->replicas`），一个键值对（`spec->selector->matchLabels`）用于选择要监视的Pod，以及一个模板（`spec->template`），用于指定如何构建Pod副本：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`namespace` is optional and, if not provided, a namespace called `default`
    is assumed. Namespaces are a way of keeping separate the objects of a Kubernetes
    cluster. For instance, a cluster can host the objects of two completely independent
    applications each placed in a separate `namespace`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`namespace`是可选的，如果未提供，则假定为名为`default`的命名空间。命名空间是保持Kubernetes集群中对象分开的一种方式。例如，一个集群可以托管两个完全独立的应用程序的对象，每个应用程序都放在一个单独的`namespace`中。'
- en: Indented inside the template is the definition of the pod to replicate. Complex
    objects such as `Deployments` can also contain other kinds of templates, for instance,
    a template of disk-like memory required by the external environment. We will discuss
    this further, in the *Advanced Kubernetes concepts* section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进在模板内部是要复制的Pod的定义。复杂的对象（如`Deployments`）还可以包含其他类型的模板，例如外部环境所需的类似磁盘的内存的模板。我们将在“高级Kubernetes概念”部分进一步讨论这个问题。
- en: 'In turn, the pod template contains a `metadata` section with labels used to
    select the pods, and a `spec` section with a list of all of the containers:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，Pod模板包含一个`metadata`部分，其中包含用于选择Pod的标签，以及一个`spec`部分，其中包含所有容器的列表：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each container has a name and must specify the name of the Docker image to use
    for creating the containers. In case the Docker image is not contained in the
    public Docker registry, the name must be a URI that also includes the repository
    location.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器都有一个名称，并且必须指定用于创建容器的Docker镜像的名称。如果Docker镜像不包含在公共Docker注册表中，则名称必须是包含存储库位置的URI。
- en: Then, containers must specify the memory and CPU resources that they need to
    be created in the `resources->requests` object. A pod replica is created only
    if these resources are currently available. The `resources->limits` object, instead,
    specifies the maximum resources a container replica can actually use. If, during
    the container execution, these limits are exceeded, actions are taken to limit
    them. More specifically, if the CPU limit is exceeded, the container is throttled
    (its execution is stopped to restore its CPU consumption), while, if the memory
    limits are exceeded, the container is restarted. `containerPort` must be the port
    exposed by the container. Here, we can also specify further information, such
    as the protocol used.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，容器必须指定它们需要创建在`resources->requests`对象中的内存和CPU资源。只有在当前可用这些资源的情况下才会创建Pod副本。相反，`resources->limits`对象指定容器副本实际可以使用的最大资源。如果在容器执行过程中超过了这些限制，将采取措施限制它们。具体来说，如果超过了CPU限制，容器将被限制（其执行将停止以恢复其CPU消耗），而如果超过了内存限制，容器将被重新启动。`containerPort`必须是容器暴露的端口。在这里，我们还可以指定其他信息，例如使用的协议。
- en: CPU time is expressed in millicores, where 1,000 millicores means 100% of the
    CPU time, while memory is expressed in Mebibytes (*1Mi = 1024*1024 bytes*), or
    other units. `env` lists all the environment variables to pass to the containers
    with their values.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: CPU时间以毫核表示，其中1,000毫核表示100％的CPU时间，而内存以Mebibytes（*1Mi = 1024*1024字节*）或其他单位表示。`env`列出了要传递给容器的所有环境变量及其值。
- en: Both containers and pod templates can contain further fields, such as properties
    that define virtual files, and properties that define commands that returns the
    readiness and the health state of the container. We will analyze these in the
    *Advanced Kubernetes concepts* section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和Pod模板都可以包含进一步的字段，例如定义虚拟文件的属性和定义返回容器就绪状态和健康状态的命令的属性。我们将在“高级Kubernetes概念”部分中分析这些内容。
- en: The following subsection describes pod sets conceived to store state information.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的子部分描述了用于存储状态信息的Pod集。
- en: StatefulSets
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有状态集
- en: '`StatefulSets` are very similar to a `ReplicaSet`, but while pods of a `ReplicaSet`
    are indistinguishable processors that contribute in parallel to the same workload
    through load balancing strategies, pods in a `StatefulSet` have a unique identity,
    and can contribute to the same workload only through sharding. This is because
    `StatefulSets` were conceived to store information, and information cannot be
    stored in parallel, merely split among several stores by means of sharding.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`StatefulSets`与`ReplicaSet`非常相似，但是`ReplicaSet`的Pod是不可区分的处理器，通过负载均衡策略并行地为相同的工作贡献，而`StatefulSet`中的Pod具有唯一的标识，并且只能通过分片方式共享相同的工作负载。这是因为`StatefulSets`被设计用于存储信息，而信息无法并行存储，只能通过分片的方式在多个存储之间分割。'
- en: For the same reason, each pod instance is always kept tied to any virtual disk
    space it requires (see the *Advanced Kubernetes concepts* section), so that each
    pod instance is responsible for writing to a specific store.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 出于同样的原因，每个Pod实例始终与其所需的任何虚拟磁盘空间绑定在一起（参见“高级Kubernetes概念”部分），因此每个Pod实例负责向特定存储写入。
- en: Moreover, `StatefulSets` pods instances have ordinal numbers attached to them.
    They are started in sequence according to these numbers, and they are stopped
    in reverse order. If the `StatefulSet` contains *N* replicas, these numbers go
    from zero to *N*-1\. Moreover, a unique name for each instance is obtained by
    chaining the pod name specified in the template, with the instance ordinal, in
    the following way – `<pod name>-<instance ordinal>`. Thus, instance names will
    be something like `mypodname-0`, `mypodname-1`, and so on. As we will see in the
    *Services* subsection, instance names are used to build unique cluster network
    URIs for all instances, so that other pods can communicate with a specific instance
    of a `StatefulSets` pods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`StatefulSets`的pod实例附带有序号。它们按照这些序号顺序启动，并按相反的顺序停止。如果`StatefulSet`包含*N*个副本，这些序号从零到*N*-1。此外，通过将模板中指定的pod名称与实例序号链接起来，可以获得每个实例的唯一名称，方式如下
    - `<pod名称>-<实例序号>`。因此，实例名称将类似于`mypodname-0`，`mypodname-1`等。正如我们将在*服务*子部分中看到的那样，实例名称用于为所有实例构建唯一的集群网络URI，以便其他pod可以与`StatefulSets`的特定实例通信。
- en: 'Here is a typical `StatefulSet` definition:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是典型的`StatefulSet`定义：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The template part is the same as that of `Deployments`. The main conceptual
    difference with `Deployments` is the `serviceName` field. It specifies the name
    of a service that must be connected with `StatefulSets` to provide unique network
    addresses for all pod instances. We will discuss this subject in more detail in
    the *Services* subsection. Moreover, usually, `StatefulSets` use some form of
    storage. We will discuss this in detail in the *Advanced Kubernetes concepts*
    section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 模板部分与`Deployments`相同。与`Deployments`的主要概念上的区别是`serviceName`字段。它指定必须与`StatefulSets`连接以为所有pod实例提供唯一网络地址的服务的名称。我们将在*服务*子部分中详细讨论这个主题。此外，通常，`StatefulSets`使用某种形式的存储。我们将在*高级Kubernetes概念*部分详细讨论这个问题。
- en: It is worth pointing out also that the default ordered creation and stop strategy
    of `StatefulSets` can be changed by specifying an explicit `Parallel` value for
    the `spec->podManagementPolicy` property (the default value is `OrderedReady`).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，`StatefulSets`的默认有序创建和停止策略可以通过为`spec->podManagementPolicy`属性指定显式的`Parallel`值来更改（默认值为`OrderedReady`）。
- en: The following subsection describes how to provide stable network addresses to
    both `ReplicaSets` and `StatefulSets`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的子部分描述了如何为`ReplicaSets`和`StatefulSets`提供稳定的网络地址。
- en: Services
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: Since pod instances can be moved between nodes, they have no stable IP address
    attached to them. Services take care of assigning a unique and stable virtual
    address to a whole `ReplicaSet` and of load balancing the traffic to all its instances.
    Services are not software objects created in the cluster, just an abstraction
    for the various settings and activities needed to put in place their functionalities.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于pod实例可以在节点之间移动，因此它们没有与之关联的稳定IP地址。服务负责为整个`ReplicaSet`分配一个唯一且稳定的虚拟地址，并将流量负载均衡到所有与之连接的实例。服务不是在集群中创建的软件对象，只是为实施其功能所需的各种设置和活动的抽象。
- en: Services work at level 4 of the protocol stack, so they understand protocols
    such as TCP, but they aren't able to perform, for instance, HTTP-specific actions/transformations,
    such as for instance, ensuring a secure HTTPS connection. Therefore, if you need
    to install HTTPS certificates on the Kubernetes cluster, you need a more complex
    object that is capable of interacting at level 7 of the protocol stack. The `Ingress`
    object was conceived for this. We will discuss this in the next subsection.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 服务在协议栈的第4级工作，因此它们理解诸如TCP之类的协议，但它们无法执行例如HTTP特定的操作/转换，例如确保安全的HTTPS连接。因此，如果您需要在Kubernetes集群上安装HTTPS证书，您需要一个能够在协议栈的第7级进行交互的更复杂的对象。`Ingress`对象就是为此而设计的。我们将在下一个子部分中讨论这个问题。
- en: Services also handle assigning a unique virtual address to each instance of
    a `StatefulSet`. In fact, there are various kinds of Services; some were conceived
    for `ReplicaSet` and others for `StatefulSet`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 服务还负责为`StatefulSet`的每个实例分配一个唯一的虚拟地址。实际上，有各种类型的服务；一些是为`ReplicaSet`设计的，另一些是为`StatefulSet`设计的。
- en: A `ClusterIP` service type is assigned a unique cluster internal IP address.
    It specifies the `ReplicaSets` or `Deployments` it is connected to through label
    pattern matching. It uses tables maintained by the Kubernetes infrastructure to
    load balance the traffic it receives among all pod instances to which it is connected.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClusterIP`服务类型被分配一个唯一的集群内部IP地址。它通过标签模式匹配指定与之连接的`ReplicaSets`或`Deployments`。它使用由Kubernetes基础设施维护的表来将接收到的流量在所有与之连接的pod实例之间进行负载均衡。'
- en: 'Therefore, other pods can communicate with the pods connected to a Service
    by interacting with this Service that is assigned the stable network name `<service
    name>.<service namespace>.svc.cluster.local`. Since they are just assigned local
    IP addresses, a `ClusterIP` service can''t be accessed from outside the Kubernetes
    cluster. Here is the definition of a typical `ClusterIP` service:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，其他pod可以通过与分配了稳定网络名称`<service名称>.<service命名空间>.svc.cluster.local`的服务进行交互，与连接到该服务的pod进行通信。由于它们只分配了本地IP地址，因此无法从Kubernetes集群外部访问`ClusterIP`服务。以下是典型`ClusterIP`服务的定义：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each Service can work on several ports, and can route any port (`port`) to the
    ports exposed by the containers (`targetPort`). However, it is very often the
    case that `port = targetPort`. Ports can be given names, but these names are optional.
    Also, the specification of the protocol is optional, in which case all supported
    level 4 protocols are allowed. The `spec->selector` property specifies all the
    name/value pairs that select the pods for the Service to route the communications
    it receives to.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务可以在多个端口上工作，并且可以将任何端口（`port`）路由到容器公开的端口（`targetPort`）。但是，很常见的情况是`port = targetPort`。端口可以有名称，但这些名称是可选的。此外，协议的规范是可选的，如果不指定，则允许所有支持的第4级协议。`spec->selector`属性指定选择服务要将其接收到的通信路由到的所有名称/值对。
- en: Since a `ClusterIP` service can't be accessed from outside the Kubernetes cluster,
    we need other Service types to expose a Kubernetes application on a public IP
    address.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无法从Kubernetes集群外部访问`ClusterIP`服务，我们需要其他类型的服务来将Kubernetes应用程序暴露在公共IP地址上。
- en: '`NodePort`-type Services are the simplest way to expose pods to the outside
    word. In order to implement a `NodePort` service, the same port `x` is opened
    on all nodes of the Kubernetes cluster and each node routes the traffic it receives
    on this port to a newly created `ClusterIP` service.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`NodePort`类型的服务是将pod暴露给外部世界的最简单方式。为了实现`NodePort`服务，在Kubernetes集群的所有节点上都打开相同的端口`x`，并且每个节点将其接收到的流量路由到一个新创建的`ClusterIP`服务。'
- en: 'In turn, the `ClusterIP` service routes its traffic to all pods selected by
    the service:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，`ClusterIP`服务将其流量路由到服务选择的所有pod：
- en: '![](img/B16756_07_01.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_07_01.png)'
- en: 'Figure 7.1: NodePort service'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：NodePort服务
- en: Therefore, it is enough to communicate with port `x` through a public IP of
    any cluster node in order to access the pods connected to the `NodePort` service.
    Of course, the whole process is completely automatic and hidden to the developer,
    whose only preoccupation is getting the port number `x` in terms of where to forward
    the external traffic.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只需通过任何集群节点的公共IP与端口`x`通信，就可以访问与`NodePort`服务连接的pod。当然，整个过程对开发人员来说是完全自动和隐藏的，他们唯一需要关注的是获取端口号`x`以确定外部流量的转发位置。
- en: 'The definition of a `NodePort` service is identical to the definition of a
    `ClusterIP` service, the only difference being that they specify a value of `NodePort`
    for the `spec->type` property:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`NodePort`服务的定义与`ClusterIP`服务的定义相同，唯一的区别是它们将`spec->type`属性的值设置为`NodePort`。'
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As a default, a node port `x` in the range 30000-327673 is automatically chosen
    for each `targetPort` specified by the `Service`. The port property associated
    with each `targetPort` is meaningless for `NodePortServices` since all traffic
    passes through the selected node port `x`, and, for convention, is set to the
    same value of the `targetPort`. The developer can also set the node port `x` directly
    through a `nodePort` property:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个`Service`指定的`targetPort`都会自动选择30000-327673范围内的节点端口`x`。对于`NodePortServices`来说，与每个`targetPort`关联的端口属性是无意义的，因为所有流量都通过所选的节点端口`x`传递，并且按照惯例，设置为与`targetPort`相同的值。开发人员还可以通过`nodePort`属性直接设置节点端口`x`：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When the Kubernetes cluster is hosted in a cloud, the more convenient way to
    expose some pods to the outside world is through a `LoadBalancer` service, in
    which case the Kubernetes cluster is exposed to the outside world through a level
    4 load balancer of the selected cloud provider.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当Kubernetes集群托管在云中时，将一些pod暴露给外部世界的更方便的方式是通过`LoadBalancer`服务，此时Kubernetes集群通过所选云提供商的第四层负载均衡器暴露给外部世界。
- en: 'The definition of a `LoadBalancer` service is identical to that of a `ClusterIp`
    service, the only difference being that the `spec->type` property must be set
    to `LoadBalancer`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadBalancer`服务的定义与`ClusterIp`服务相同，唯一的区别是`spec->type`属性必须设置为`LoadBalancer`：'
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If no further specification is added, a dynamic public IP is randomly assigned.
    However, if a specific public IP address to the cloud provider is required, it
    can be used as a public IP address for the cluster load balancer by specifying
    it in the `spec->loadBalancerIP` property:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有添加进一步的规范，动态公共IP将被随机分配。然而，如果需要特定的公共IP地址给云提供商，可以通过在`spec->loadBalancerIP`属性中指定它来用作集群负载均衡器的公共IP地址：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In Azure Kubernetes, you must also specify the resource group where the IP
    address was allocated, in an annotation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure Kubernetes中，您还必须在注释中指定分配IP地址的资源组：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In Azure Kubernetes, you can remain with a dynamic IP address, but you can
    get a public static domain name of the type `<my-service-label>.<location>.cloudapp.azure.com`,
    where `<location>` is the geographic label you have chosen for your resources.
    `<my-service-label>` is a label that you verified makes the previous domain name
    unique. The chosen label must be declared in an annotation of your service, as
    shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure Kubernetes中，您可以保留动态IP地址，但可以获得类型为`<my-service-label>.<location>.cloudapp.azure.com`的公共静态域名，其中`<location>`是您为资源选择的地理标签。`<my-service-label>`是一个您验证过使前面的域名唯一的标签。所选标签必须在您的服务的注释中声明，如下所示：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`StatefulSets` don''t need any load balancing since each pod instance has its
    own identity, but just require a unique URL address for each pod instance. This
    unique URL is provided by the so called headless Services. Headless Services are
    defined like `ClusterIP` services, the only difference being that they have a
    `spec->clusterIP` property set to `none`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`StatefulSets`不需要任何负载均衡，因为每个pod实例都有自己的标识，只需要为每个pod实例提供一个唯一的URL地址。这个唯一的URL由所谓的无头服务提供。无头服务的定义与`ClusterIP`服务相同，唯一的区别是它们的`spec->clusterIP`属性设置为`none`：'
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: All `StatefulSets` handled by a headless Service must place the Service name
    in their `spec-> serviceName` property, as already stated in the *StatefulSets*
    subsection.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所有由无头服务处理的`StatefulSets`必须将服务名称放置在其`spec->serviceName`属性中，如*StatefulSets*子部分中所述。
- en: The unique name provided by a headless Service to all `StatefulSets` pod instances
    it handles is `<unique pod name>.<service name>.<namespace>.svc.cluster.local`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 无头服务为其处理的所有`StatefulSets` pod实例提供的唯一名称是`<unique pod name>.<service name>.<namespace>.svc.cluster.local`。
- en: Services only understand low-level protocols, such as TCP/IP, but most web applications
    are situated on the more sophisticated HTTP protocol. That's why Kubernetes offers
    higher-level entities called `Ingresses` that are built on top of services. The
    following subsection describes these and explains how to expose a set of `pods`
    through a level 7 protocol load balancer, which could offer you typical HTTP services,
    instead of through a `LoadBalancer` service.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 服务只能理解低级协议，如TCP/IP，但大多数Web应用程序位于更复杂的HTTP协议上。这就是为什么Kubernetes提供了基于服务的更高级实体`Ingresses`。下一小节描述了这些内容，并解释了如何通过级别7协议负载均衡器将一组`pods`公开，该负载均衡器可以为您提供典型的HTTP服务，而不是通过`LoadBalancer`服务。
- en: Ingresses
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ingresses
- en: '`Ingresses` are mainly conceived to work with HTTP(S). They provide the following
    services:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ingresses`主要用于使用HTTP(S)。它们提供以下服务：'
- en: HTTPS termination. They accept HTTPS connections and route them in HTTP format
    to any service in the cloud.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTPS终止。它们接受HTTPS连接并将其路由到云中的任何服务的HTTP格式。
- en: Name-based virtual hosting. They associate several domain names with the same
    IP address and route each domain, or `<domain>/<path prefix>`, to a different
    cluster Service.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于名称的虚拟主机。它们将多个域名与同一个IP地址关联，并将每个域或`<domain>/<path prefix>`路由到不同的集群服务。
- en: Load balancing.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡。
- en: '`Ingresses` rely on web servers to offer the above services. In fact, `Ingresses`
    can be used only after having installed an `Ingress Controller`. `Ingress Controllers`
    are custom Kubernetes objects that must be installed in the cluster. They handle
    the interface between Kubernetes and a web server, which can be either an external
    web server or a web server that is part of the `Ingress Controller` installation.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ingresses`依赖于Web服务器来提供上述服务。实际上，只有在安装了`Ingress Controller`之后才能使用`Ingresses`。`Ingress
    Controllers`是必须安装在集群中的自定义Kubernetes对象。它们处理Kubernetes与Web服务器之间的接口，可以是外部Web服务器或作为`Ingress
    Controller`安装的Web服务器的一部分。'
- en: We will describe the installation of an `Ingress Controller` based on the NGINX
    web server in the *Advanced Kubernetes concepts* section, as an example of the
    use of Helm. The *Further reading* section contains information on how to install
    also an `Ingress Controller` that interfaces an external Azure application gateway.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*高级Kubernetes概念*部分中描述基于NGINX Web服务器的`Ingress Controller`的安装，作为使用Helm的示例。
    *进一步阅读*部分包含有关如何安装与外部Azure应用程序网关进行接口的`Ingress Controller`的信息。
- en: HTTPS termination and name-based virtual hosting can be configured in the `Ingress`
    definition in a way that is independent of the chosen `Ingress Controller`, while
    the way load balancing is achieved depends on the specific `Ingress Controller`
    chosen and on its configuration. Some `Ingress Controller` configuration data
    can be passed in the `metadata-> annotations` field of the `Ingress` definition.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS终止和基于名称的虚拟主机可以在`Ingress`定义中进行配置，与所选择的`Ingress Controller`无关，而负载均衡的实现方式取决于所选择的特定`Ingress
    Controller`及其配置。一些`Ingress Controller`配置数据可以通过`Ingress`定义的`metadata->annotations`字段传递。
- en: 'Name-based virtual hosting is defined in a `spec>rules` section of the Ingress
    definition:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 基于名称的虚拟主机在Ingress定义的`spec>rules`部分中定义：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Each rule specifies an optional hostname that can contain the `*` wildcard.
    If no hostname is provided, the rule matches all hostnames. For each rule, we
    can specify several paths, each redirected to a different service/port pair, where
    the service is referenced through its name. The way the match with each `path`
    is carried out depends on the value of `pathType`; if this value is `Prefix`,
    the specified `path` must be a prefix of any matching path. Otherwise, if this
    value is `Exact`, the match must be exact. Matches are case-sensitive.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每个规则都指定了一个可选的主机名，可以包含`*`通配符。如果没有提供主机名，则规则匹配所有主机名。对于每个规则，我们可以指定多个路径，每个路径重定向到不同的服务/端口对，其中服务通过其名称引用。与每个`path`的匹配方式取决于`pathType`的值；如果该值为`Prefix`，则指定的`path`必须是任何匹配路径的前缀。否则，如果该值为`Exact`，则匹配必须完全相同。匹配区分大小写。
- en: 'HTTPS termination on a specific hostname is specified by associating it a certificate
    encoded in a Kubernetes secret:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将特定主机名与在Kubernetes密钥中编码的证书关联，可以指定特定主机名上的HTTPS终止：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: HTTPS certificates can be obtained free of charge at [https://letsencrypt.org/](https://letsencrypt.org/).
    The procedure is explained on the website, but basically, as with all certificate
    authorities, you provide a key and they return the certificate based on that key.
    It is also possible to install a **certificate manger** that takes care of automatically
    installing and renewing the certificate. The way a key/certificate pair is encoded
    in a Kubernetes secret string is detailed in the *Advanced Kubernetes concepts*
    section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可以免费获取HTTPS证书，网址为[https://letsencrypt.org/](https://letsencrypt.org/)。该过程在网站上有详细说明，但基本上，与所有证书颁发机构一样，您提供一个密钥，他们根据该密钥返回证书。还可以安装一个**证书管理器**，它负责自动安装和更新证书。在Kubernetes密钥/证书对如何编码为Kubernetes密钥的字符串中，详细说明在*高级Kubernetes概念*部分中。
- en: 'The whole `Ingress` definition looks like the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 整个`Ingress`定义如下所示：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the `namespace` is optional, and if not specified, is assumed to be `default`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`namespace`是可选的，如果未指定，则假定为`default`。
- en: In the next section, we will put in practice some of the concepts explained
    here by defining an Azure Kubernetes cluster and deploying a simple application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过定义Azure Kubernetes集群并部署一个简单应用程序来实践这里解释的一些概念。
- en: Interacting with Azure Kubernetes clusters
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Azure Kubernetes集群交互
- en: 'To create an **Azure Kubernetes Service** (**AKS**) cluster, type `AKS` into
    the Azure search box, select **Kubernetes services**, and then click the **Add**
    button. The following form will appear:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个**Azure Kubernetes服务**（**AKS**）集群，请在Azure搜索框中键入`AKS`，选择**Kubernetes服务**，然后单击**添加**按钮。将显示以下表单：
- en: '![](img/B16756_07_02.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_07_02.png)'
- en: 'Figure 7.2: Creating a Kubernetes cluster'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：创建Kubernetes集群
- en: It is worth mentioning that you can get help by just hovering any circled **i**
    with the mouse, as shown in the preceding screenshot.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，您可以通过将鼠标悬停在任何带有圆圈的“i”上来获取帮助，如上述屏幕截图所示。
- en: As usual, you are required to specify a subscription, resource group, and region.
    Then, you can choose a unique name (**Kubernetes cluster name**), and the version
    of Kubernetes you would like to use. For computational power, you are asked to
    select a machine template for each node (node size) and the number of nodes. The
    initial screen shows a default of three nodes. We decreased it to two, because
    three nodes are too much for the Azure free credit. Moreover, the default virtual
    machine should also be replaced by a cheaper one, so click **Change size** and
    select **DS1 v2**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，您需要指定订阅、资源组和区域。然后，您可以选择一个唯一的名称（Kubernetes集群名称），以及您想要使用的Kubernetes版本。对于计算能力，您需要为每个节点选择一个机器模板（节点大小）和节点数量。初始屏幕显示默认的三个节点。由于三个节点对于Azure免费信用来说太多了，我们将其减少为两个。此外，默认虚拟机也应该被更便宜的虚拟机替换，因此单击“更改大小”并选择“DS1
    v2”。
- en: The **Availability zones** setting allows you to spread your nodes across several
    geographic zones for a better fault tolerance. The default is three zones. Please
    change it to two zones since we have just two nodes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: “可用区”设置允许您将节点分布在多个地理区域以实现更好的容错性。默认值为三个区域。由于我们只有两个节点，请将其更改为两个区域。
- en: 'Following the preceding changes, you should see the following settings:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行了上述更改后，您应该会看到以下设置：
- en: '![](img/B16756_07_03.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_07_03.png)'
- en: 'Figure 7.3: Chosen settings'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：选择的设置
- en: Now you can create your cluster by clicking the **Review + create** button.
    A review page should appear, confirm, and create the cluster.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过单击“查看+创建”按钮来创建您的集群。应该会出现一个审查页面，请确认并创建集群。
- en: If you click **Next**, instead of **Review + create**, you can also define other
    node types, and then you can provide security information, namely, a *service
    principal*, and specify whether you wish to enable role-based access control.
    In Azure, service principals are accounts that are associated with services you
    may use to define resource access policies. You may also change the default network
    settings and other settings.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您单击“下一步”而不是“查看+创建”，您还可以定义其他节点类型，然后可以提供安全信息，即“服务主体”，并指定是否希望启用基于角色的访问控制。在Azure中，服务主体是与您可能用于定义资源访问策略的服务相关联的帐户。您还可以更改默认网络设置和其他设置。
- en: Deployment may take a little while (10-20 minutes). After that time, you will
    have your first Kubernetes cluster! At the end of the chapter, when the cluster
    is no longer required, please don't forget to delete it in order to avoid wasting
    your Azure free credit.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 部署可能需要一些时间（10-20分钟）。之后，您将拥有您的第一个Kubernetes集群！在本章结束时，当不再需要该集群时，请不要忘记删除它，以避免浪费您的Azure免费信用。
- en: In the next subsection, you will learn how to interact with your cluster through
    Kubernetes' official client, Kubectl.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，您将学习如何通过Kubernetes的官方客户端Kubectl与集群进行交互。
- en: Using Kubectl
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Kubectl
- en: 'Once you have created your cluster, you can interact with it with Azure Cloud
    Shell. Click on the console icon on the top right of your Azure portal page. The
    following screenshot shows the Azure Shell icon:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完集群后，您可以使用Azure Cloud Shell与其进行交互。单击Azure门户页面右上角的控制台图标。以下屏幕截图显示了Azure Shell图标：
- en: '![](img/B16756_07_04.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_07_04.png)'
- en: 'Figure 7.4: Azure Shell icon'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：Azure Shell图标
- en: When prompted, select the **Bash Shell**. Then you will be prompted to create
    a storage account, so confirm and create it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示时，选择“Bash Shell”。然后，您将被提示创建一个存储帐户，确认并创建它。
- en: 'We will use this shell to interact with our cluster. On the top of the shell
    there is a file icon that we will use to upload our `.yaml` files:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用此Shell与我们的集群进行交互。在Shell的顶部有一个文件图标，我们将使用它来上传我们的`.yaml`文件：
- en: '![](img/B16756_07_05.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_07_05.png)'
- en: 'Figure 7.5: How to upload files in Azure Cloud Shell'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：如何在Azure Cloud Shell中上传文件
- en: It is also possible to download a client called Azure CLI and to install it
    on your local machine (see [https://docs.microsoft.com/en-US/cli/azure/install-azure-cli](https://docs.microsoft.com/en-US/cli/azure/install-azure-cli)),
    but, in this case, you also need to install all tools needed to interact with
    the Kubernetes cluster (Kubectl and Helm) that are pre-installed in the Azure Cloud Shell.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以下载一个名为Azure CLI的客户端，并在本地机器上安装它（参见[https://docs.microsoft.com/en-US/cli/azure/install-azure-cli](https://docs.microsoft.com/en-US/cli/azure/install-azure-cli)），但在这种情况下，您还需要安装与Kubernetes集群交互所需的所有工具（Kubectl和Helm），这些工具已预先安装在Azure
    Cloud Shell中。
- en: 'Once you''ve created a Kubernetes cluster, you can interact with it through
    the `kubectl` command-line tool. `kubectl` is integrated in the Azure Shell, so
    you just need to activate your cluster credentials to use it. You can do this
    with the following Cloud Shell command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Kubernetes集群后，您可以通过`kubectl`命令行工具与其进行交互。`kubectl`已集成在Azure Shell中，因此您只需激活集群凭据即可使用它。您可以使用以下Cloud
    Shell命令来完成此操作：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding command stores the credentials that were automatically created
    to enable your interaction with the cluster in a `/.kube/config` configuration
    file. From now on, you can issue your `kubectl` commands with no further authentication.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将凭据存储在`/.kube/config`配置文件中，该凭据是自动创建的，以便您与集群进行交互。从现在开始，您可以无需进一步身份验证即可发出`kubectl`命令。
- en: 'If you issue the `kubectl get nodes` command, you get a list of all your Kubernetes
    nodes. In general, `kubectl get <object type>` lists all objects of a given type.
    You can use it with `nodes`, `pods`, `statefulset`, and so on. `kubectl get all`
    shows a list of all the objects created in your cluster. If you also add the name
    of a specific object, you will get information on just that specific object, as
    shown here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发出`kubectl get nodes`命令，您将获得所有Kubernetes节点的列表。通常，`kubectl get <对象类型>`列出给定类型的所有对象。您可以将其与`nodes`、`pods`、`statefulset`等一起使用。`kubectl
    get all`显示在您的集群中创建的所有对象的列表。如果您还添加了特定对象的名称，您将只获取该特定对象的信息，如下所示：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you add the `--watch` option, the object list will be continuously updated,
    so you can see the state of all the selected objects changing over time. You can
    leave this watch state by hitting Ctrl + c.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果添加`--watch`选项，对象列表将持续更新，因此您可以看到所有选定对象的状态随时间变化。您可以通过按下Ctrl + c来退出此观察状态。
- en: 'The following command shows a detailed report on a specific object:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示了有关特定对象的详细报告：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'All objects described in a `.yaml` file, say `myClusterConfiguration.yaml`,
    can be created with the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令创建在`.yaml`文件中描述的所有对象，例如`myClusterConfiguration.yaml`：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, if you modify the `.yaml` file, you can reflect all modifications on
    your cluster with the `apply` command, as shown here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果您修改了`.yaml`文件，可以使用`apply`命令在集群上反映所有修改，如下所示：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`apply` does the same job of `create` but, if the resource already exists,
    `apply` overrides it, while `create` exits with an error message.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`执行与`create`相同的工作，但如果资源已经存在，`apply`会覆盖它，而`create`则会显示错误消息。'
- en: 'You can destroy all objects that were created with a `.yaml` file by passing
    the same file to the `delete` command, as shown here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将相同的文件传递给`delete`命令来销毁使用`.yaml`文件创建的所有对象，如下所示：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `delete` command can also be passed an object type and a list of names
    of objects of that type to destroy, as shown in the following example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`命令还可以传递对象类型和要销毁的该类型对象的名称列表，如下例所示：'
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding `kubectl` command shown should suffice for most of your practical
    needs. For more details, the *Further reading* section contains a link to the
    official documentation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`kubectl`命令应足以满足大部分实际需求。有关更多详细信息，请参阅*Further reading*部分中的官方文档链接。
- en: In the next subsection, we will use `kubectl create` to install a simple demo
    application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将使用`kubectl create`安装一个简单的演示应用程序。
- en: Deploying the demo Guestbook application
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署演示Guestbook应用程序
- en: The Guestbook application is a demo application used in the examples of the
    official Kubernetes documentation. We will use it as an example of a Kubernetes
    application since its Docker images are already available in the public Docker
    repository, so we don't need to write software.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Guestbook应用程序是官方Kubernetes文档示例中使用的演示应用程序。我们将使用它作为Kubernetes应用程序的示例，因为它的Docker镜像已经在公共Docker存储库中可用，所以我们不需要编写软件。
- en: The Guestbook application stores the opinions of customers who visit a hotel
    or a restaurant. It is composed of an UI tier implemented with a `Deployment`,
    and of a database layer implemented with an in-memory store based on Redis. In
    turn, the Redis store is implemented with a unique master storage used for write/update
    and several read-only replicas, always based on Redis, that achieve a read parallelism.
    Write/update parallelism could be implemented with several sharded Redis masters,
    but for the very nature of the applications, write operations should not be predominant,
    so a single master database should suffice in the practical case of a single restaurant/hotel.
    The whole application is composed of three `.yaml` files that you can find in
    the GitHub repository associated with this book.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Guestbook应用程序存储了访问酒店或餐厅的客户的意见。它由一个使用`Deployment`实现的UI层和一个使用基于Redis的内存存储实现的数据库层组成。而Redis存储则是由一个用于写入/更新的唯一主存储和几个只读副本组成，这些副本始终基于Redis，并实现了读取并行性。写入/更新并行性可以通过多个分片的Redis主节点来实现，但由于应用程序的特性，写入操作不应占主导地位，因此在实际情况下，单个主数据库应该足够满足单个餐厅/酒店的需求。整个应用程序由三个`.yaml`文件组成，您可以在与本书相关的GitHub存储库中找到。
- en: 'Here is the code for the master storage based on Redis that is contained in
    the `redis-master.yaml` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是包含在`redis-master.yaml`文件中的基于Redis的主存储的代码：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The file is composed of two object definitions separated by a line containing
    just `---`, that is, the object definition separator of `.yaml` files. The first
    object is a `Deployment` with a single replica, and the second object is a `ClusterIPService`
    that exposes the `Deployment` on the `6379` port at the internal `redis-master.default.svc.cluster.local`
    network address. The `Deployment pod template` defines the three `app`, `role`,
    and `tier` labels with their values that are used in the `selector` definition
    of the Service to connect the Service with the unique pod defined in the `Deployment`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件由两个对象定义组成，由一个只包含`---`的行分隔，即`.yaml`文件的对象定义分隔符。第一个对象是一个具有单个副本的`Deployment`，第二个对象是一个`ClusterIPService`，它在内部`redis-master.default.svc.cluster.local`网络地址上的`6379`端口上公开`Deployment`。`Deployment
    pod template`定义了三个`app`、`role`和`tier`标签及其值，这些值在Service的`selector`定义中用于将Service与在`Deployment`中定义的唯一pod连接起来。
- en: 'Let''s upload the `redis-master.yaml` file on Cloud Shell, and then deploy
    it in the cluster with the following command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`redis-master.yaml`文件上传到Cloud Shell，然后使用以下命令在集群中部署它：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once the operation is complete, you can inspect the content of the cluster with
    `kubectl get all`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 操作完成后，您可以使用`kubectl get all`命令检查集群的内容。
- en: The slave storage is defined in the `redis-slave.yaml` file and is completely
    analogous, the only difference being that this time we have two replicas, and
    a different Docker image.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从`redis-slave.yaml`文件中定义了从存储，它与主存储完全类似，唯一的区别是这次有两个副本和不同的Docker镜像。
- en: 'Let''s upload this file as well and deploy it with the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也上传此文件，并使用以下命令部署它：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The code for the UI tier is contained in the `frontend.yaml` file. `Deployment`
    has three replicas and a different Service type. Let''s upload and deploy this
    file with the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: UI层的代码包含在`frontend.yaml`文件中。`Deployment`有三个副本和不同的服务类型。让我们使用以下命令上传并部署此文件：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It is worthwhile analyzing the Service code in the `frontend.yaml` file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 值得分析的是`frontend.yaml`文件中的服务代码：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This type of Service is of the `LoadBalancer` type, since it must expose the
    application on a public IP address. In order to get the public IP address assigned
    to the service, and then to the application, use the following command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的服务属于`LoadBalancer`类型，因为它必须在公共IP地址上公开应用程序。为了获取分配给服务和应用程序的公共IP地址，请使用以下命令：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding command should display information on all the installed services.
    You should find the public IP under the `EXTERNAL-IP` column of the list. If you
    see only `<none>` values, please repeat the command until the public IP address
    is assigned to the load balancer.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令应该显示所有已安装服务的信息。您应该在列表的`EXTERNAL-IP`列下找到公共IP。如果您只看到`<none>`的值，请重复该命令，直到公共IP地址分配给负载均衡器。
- en: Once you get the IP address, navigate with the browser to this address. The
    application home page should now appear!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获得IP地址，使用浏览器导航到该地址。应用程序的主页现在应该显示出来了！
- en: 'Once you have finished experimenting with the application, remove the application
    from the cluster to avoid wasting your Azure free credit (public IP addresses
    cost money) with the following commands:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成对应用程序的实验后，使用以下命令从集群中删除应用程序，以避免浪费您的Azure免费信用额度（公共IP地址需要付费）：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the next section, we will analyze other important Kubernetes features.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将分析其他重要的Kubernetes功能。
- en: Advanced Kubernetes concepts
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级Kubernetes概念
- en: In this section, we will discuss other important Kubernetes features, including
    how to assign permanent storage to `StatefulSets`, how to store secrets such as
    passwords, connection strings, or certificates, how a container can inform Kubernetes
    about its health state, and how to handle complex Kubernetes packages with Helm.
    All subjects are organized in dedicated subsections. We will start with the problem
    of permanent storage.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论其他重要的Kubernetes功能，包括如何为`StatefulSets`分配永久存储，如何存储密码、连接字符串或证书等秘密信息，容器如何通知Kubernetes其健康状态，以及如何使用Helm处理复杂的Kubernetes包。所有主题都按照专门的子部分进行组织。我们将从永久存储的问题开始。
- en: Requiring permanent storage
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要永久存储
- en: 'Since pods are moved among nodes, they can''t rely on the permanent storage
    offered by the current node where they are running. This leaves us with two options:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Pod会在节点之间移动，它们不能依赖于当前运行它们的节点提供的永久存储。这给我们留下了两个选择：
- en: '**Using external databases**: With the help of databases, `ReplicaSets` can
    also store information. However, if we need a better performance in terms of write/update
    operations, we should use distributed sharded databases based on non-SQL engines
    such as Cosmos DB or MongoDB (see *Chapter 9*, *How to Choose Your Data Storage
    in the Cloud*). In this case, in order to take maximum advantage of table sharding,
    we need `StatefulSets`, where each `pod` instance takes care of a different table
    shard.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用外部数据库**：借助数据库，`ReplicaSets`也可以存储信息。然而，如果我们需要更好的写入/更新操作性能，我们应该使用基于非SQL引擎（如Cosmos
    DB或MongoDB）的分布式分片数据库（参见*第9章*，*如何在云中选择数据存储*）。在这种情况下，为了充分利用表分片，我们需要使用`StatefulSets`，其中每个`pod`实例负责不同的表分片。'
- en: '**Using cloud storage**: Not being tied to a physical cluster node, cloud storage
    can be associated permanently with specific pod instances of `StatefulSets`.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用云存储**：由于不与物理集群节点绑定，云存储可以永久关联到`StatefulSets`的特定Pod实例。'
- en: Since access to external databases doesn't require any Kubernetes-specific technique,
    but can be done with the usual connection strings, we will concentrate on cloud
    storage.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于访问外部数据库不需要任何特定于Kubernetes的技术，而是可以使用通常的连接字符串来完成，我们将集中讨论云存储。
- en: Kubernetes offers an abstraction of storage called **PersistentVolumeClaim**
    (**PVC**) that is independent of the underlying storage provider. More specifically,
    PVCs are allocation requests that are either matched to predefined resources or
    allocated dynamically. When the Kubernetes cluster is in the cloud, typically,
    you use dynamic allocation carried out by dynamic providers installed by the cloud
    provider.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了一个名为**PersistentVolumeClaim**（PVC）的存储抽象，它独立于底层存储提供商。更具体地说，PVC是分配请求，可以与预定义资源匹配或动态分配。当Kubernetes集群在云中时，通常使用由云提供商安装的动态提供商进行动态分配。
- en: 'Cloud providers such as Azure offer different storage classes with different
    performance and different costs. Moreover, the PVC can also specify the `accessMode`,
    which can be:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Azure等云提供商提供具有不同性能和不同成本的不同存储类。此外，PVC还可以指定`accessMode`，可以是：
- en: '`ReadWriteOnce` – The volume can be mounted as read-write by a single `pod`.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadWriteOnce` - 卷可以被单个Pod挂载为读写。'
- en: '`ReadOnlyMany` – The volume can be mounted as read-only by many pods.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadOnlyMany` - 卷可以被多个Pod挂载为只读。'
- en: '`ReadWriteMany` – The volume can be mounted as read-write by many pods.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadWriteMany` - 卷可以被多个Pod挂载为读写。'
- en: 'Volume claims can be added to `StatefulSets` in a specific `spec->volumeClaimTemplates`
    object:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 卷声明可以添加到`StatefulSets`的特定`spec->volumeClaimTemplates`对象中：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `storage` property contains the storage requirements. `volumeMode` set to
    `Filesystem` is a standard setting that means the storage will be available as
    a file path. The other possible value is `Block`, which allocates the memory as
    `unformatted`. `storageClassName` must be set to an existing storage class offered
    by the cloud provider. If omitted, the default storage class will be assumed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`storage`属性包含存储需求。将`volumeMode`设置为`Filesystem`是一种标准设置，表示存储将作为文件路径可用。另一个可能的值是`Block`，它将内存分配为`未格式化`。`storageClassName`必须设置为云提供商提供的现有存储类。如果省略，则将假定默认存储类。'
- en: 'All available storage classes can be listed with the following command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令列出所有可用的存储类：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once `volumeClaimTemplates` has defined how to create permanent storage, then
    each container must specify which file path to attach that permanent storage to
    in the `spec->containers->volumeMounts` property:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`volumeClaimTemplates`定义了如何创建永久存储，那么每个容器必须指定将永久存储附加到的文件路径，位于`spec->containers->volumeMounts`属性中。
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, `name` must correspond to the name given to the PVC.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`name`必须与PVC的名称相对应。
- en: The following subsection shows how to use Kubernetes secrets.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下子节显示了如何使用Kubernetes secrets。
- en: Kubernetes secrets
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes secrets
- en: 'Secrets are sets of key-value pairs that are encrypted to protect them. They
    can be created by putting each value in a file, and then invoking the following
    `kubectl` command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密是一组键值对，它们被加密以保护它们。可以通过将每个值放入文件中，然后调用以下`kubectl`命令来创建它们：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this case, the filenames become the keys and the file contents are the values.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，文件名成为键，文件内容成为值。
- en: 'When the values are strings, they can be specified directly in the `kubectl`
    command, as shown here:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当值为字符串时，可以直接在`kubectl`命令中指定，如下所示：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this case, keys and values are listed one after the other, separated by the
    `=` character.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，键和值按顺序列出，由`=`字符分隔。
- en: 'Once defined, secrets can be referred to in the `spec->volume` property of
    a pod (`Deployment` or `StatefulSettemplate`), as shown here:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 定义后，可以在pod（`Deployment`或`StatefulSettemplate`）的`spec->volume`属性中引用secrets，如下所示：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After that, each container can specify in which path to mount them in the `spec->containers->volumeMounts`
    property:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，每个容器可以在`spec->containers->volumeMounts`属性中指定要将它们挂载到的路径：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding example, each key is seen as a file with the same name of the
    key. The content of the file is the secret value, base64-encoded. Therefore, the
    code that reads each file must decode its content (in .NET, `Convert.FromBase64`
    will do the job).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，每个键被视为具有与键相同名称的文件。文件的内容是秘密值，经过base64编码。因此，读取每个文件的代码必须解码其内容（在.NET中，`Convert.FromBase64`可以完成这项工作）。
- en: 'When secrets contain strings, they can also be passed as environment variables
    in the `spec->containers->env object`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当secrets包含字符串时，它们也可以作为环境变量传递给`spec->containers->env object`：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, the `name` property must match the secret `name`. Passing secrets as environment
    variables is very convenient when containers host ASP.NET Core applications, since,
    in this case, environment variables are all immediately available in the configuration
    object (see the *Loading configuration data and using it with the options framework*
    section of *Chapter 15*, *Presenting ASP.NET Core MVC*).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`name`属性必须与secret的`name`匹配。当容器托管ASP.NET Core应用程序时，将secrets作为环境变量传递非常方便，因为在这种情况下，环境变量立即在配置对象中可用（请参阅*第15章*的*加载配置数据并与选项框架一起使用*部分，*介绍ASP.NET
    Core MVC*）。
- en: 'Secrets can also encode the key/certificate pair of an HTTPS certificate, with
    the following `kubectl` command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Secrets还可以使用以下`kubectl`命令对HTTPS证书的密钥/证书对进行编码：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Secrets defined in this way can be used to enable HTTPS termination in `Ingresses`.
    It is enough to place the secret names in the `spec->tls->hosts->secretName` properties
    of an `Ingress`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式定义的secrets可用于在`Ingresses`中启用HTTPS终止。只需将secret名称放置在`spec->tls->hosts->secretName`属性中即可。
- en: Liveness and readiness checks
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活跃性和就绪性检查
- en: Kubernetes automatically monitors all containers to ensure they are still alive
    and that they keep their resource consumption within the limits declared in the
    `spec->containers->resources->limits` object. When some conditions are violated,
    the container is either throttled, or restarted, or the whole pod instance is
    restarted on a different node. How does Kubernetes know that a container is in
    a healthy state? While it can use the operating system to check the healthy state
    of nodes, it has no universal check that works with all containers.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes会自动监视所有容器，以确保它们仍然存活，并且将资源消耗保持在`spec->containers->resources->limits`对象中声明的限制范围内。当某些条件被违反时，容器要么被限制，要么被重新启动，要么整个pod实例在不同的节点上重新启动。Kubernetes如何知道容器处于健康状态？虽然它可以使用操作系统来检查节点的健康状态，但它没有适用于所有容器的通用检查。
- en: Therefore, the containers themselves must inform Kubernetes of their healthy
    state, otherwise Kubernetes must renounce verifying them. Containers can inform
    Kubernetes of their healthy state in two ways, either by declaring a console command
    that returns the healthy state, or by declaring an endpoint that provides the
    same information.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，容器本身必须通知Kubernetes它们的健康状态，否则Kubernetes必须放弃验证它们。容器可以通过两种方式通知Kubernetes它们的健康状态，一种是声明返回健康状态的控制台命令，另一种是声明提供相同信息的端点。
- en: 'Both declarations are provided in the `spec->containers->livenessProb` object.
    The console command check is declared as shown here:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个声明都在`spec->containers->livenessProb`对象中提供。控制台命令检查声明如下所示：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If `command` returns `0`, the container is considered healthy. In the preceding
    example, we suppose that the software running in the container records its state
    of health in the `/tmp/healthy` file, so that the `cat/tmp/healthy` command returns
    it. `PeriodSeconds` is the time between checks, while `initialDelaySeconds` is
    the initial delay before performing the first check. An initial delay is always
    necessary so as to give the container time to start.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`command`返回`0`，则容器被视为健康。在上面的示例中，我们假设在容器中运行的软件将其健康状态记录在`/tmp/healthy`文件中，因此`cat/tmp/healthy`命令返回它。`PeriodSeconds`是检查之间的时间，而`initialDelaySeconds`是执行第一次检查之前的初始延迟。始终需要初始延迟，以便给容器启动的时间。
- en: 'The endpoint check is quite similar:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 端点检查非常类似：
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The test is successful if the HTTP response contains the declared header with
    the declared value. You may also use a pure TCP check, as shown here:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HTTP响应包含声明的标头和声明的值，则测试成功。您还可以使用纯TCP检查，如下所示：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this case, the check succeeds if Kubernetes is able to open a TCP socket
    to the container on the declared port.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果Kubernetes能够在声明的端口上打开与容器的TCP套接字，则检查成功。
- en: In a similar way, the readiness of containers once they are installed is monitored
    with a readiness check. The readiness check is defined in exactly the same way
    as the liveness check, the only difference being that `livenessProbe` is replaced
    with `readinessProbe`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，一旦安装了容器，就会使用就绪性检查来监视容器的就绪性。就绪性检查的定义方式与活跃性检查完全相同，唯一的区别是将`livenessProbe`替换为`readinessProbe`。
- en: The following subsection explains how to autoscale `Deployments`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节解释了如何自动缩放`Deployments`。
- en: Autoscaling
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动缩放
- en: Instead of modifying manually the number of replicas in a `Deployment`, in order
    to adapt it to a decrease or increase in load, we can let Kubernetes decide for
    itself the number of replicas trying to keep constant a declared resource consumption.
    Thus, for instance, if we declare a target 10% CPU consumption, when the average
    resource consumption of each replica exceeds this limit, a new replica is created,
    while if the average CPU falls below this limit, a replica is destroyed. The typical
    resource used to monitor replicas is CPU consumption, but we can also use memory
    consumption.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与手动修改`Deployment`中的副本数以适应负载的减少或增加不同，我们可以让Kubernetes自行决定副本的数量，试图保持声明的资源消耗恒定。因此，例如，如果我们声明目标为10%的CPU消耗，当每个副本的平均资源消耗超过此限制时，将创建一个新副本，而如果平均CPU低于此限制，则销毁一个副本。用于监视副本的典型资源是CPU消耗，但我们也可以使用内存消耗。
- en: 'Autoscaling is achieved by defining a `HorizontalPodAutoscaler` object. Here
    is an example of the `HorizontalPodAutoscaler` definition:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义`HorizontalPodAutoscaler`对象来实现自动缩放。以下是`HorizontalPodAutoscaler`定义的示例：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`spec-> scaleTargetRef->name` specifies the name of the `Deployment` to autoscale,
    while `targetAverageUtilization` specifies the target resource (in our case, CPU)
    percentage usage (in our case, 25%).'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec-> scaleTargetRef->name`指定要自动缩放的`Deployment`的名称，而`targetAverageUtilization`指定目标资源（在我们的情况下是CPU）的使用百分比（在我们的情况下是25%）。'
- en: The following subsection gives a short introduction to the Helm package manager
    and Helm charts, and explains how to install Helm charts on a Kubernetes cluster.
    An example of how to install an `Ingress Controller` is given.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节简要介绍了Helm软件包管理器和Helm图表，并解释了如何在Kubernetes集群上安装Helm图表。给出了安装“Ingress Controller”的示例。
- en: Helm – Installing an Ingress Controller
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helm - 安装Ingress Controller
- en: 'Helm charts are a way to organize the installation of complex Kubernetes applications
    that contain several `.yaml` files. A Helm chart is a set of `.yaml` files, organized
    into folders and subfolders. Here is a typical folder structure of a Helm chart
    taken from the official documentation:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Helm图表是组织安装包含多个`.yaml`文件的复杂Kubernetes应用程序的一种方式。Helm图表是一组`.yaml`文件，组织成文件夹和子文件夹。以下是从官方文档中获取的Helm图表的典型文件夹结构：
- en: '![](img/B16756_07_06.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_07_06.png)'
- en: 'Figure 7.6: Folder structure of a Helm chart'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：Helm图表的文件夹结构
- en: 'The `.yaml` files specific to the application are placed in the top `templates`
    directory, while the `charts` directory may contain other Helm charts used as
    helper libraries. The top-level `Chart.yaml` file contains general information
    on the package (name and description), together with both the application version
    and the Helm chart version. The following is a typical example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 特定于应用程序的`.yaml`文件放置在顶级`templates`目录中，而`charts`目录可能包含其他用作辅助库的Helm图表。顶级`Chart.yaml`文件包含有关软件包（名称和描述）的一般信息，以及应用程序版本和Helm图表版本。以下是典型示例：
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, `type` can be either `application` or `library`. Only `application` charts
    can be deployed, while `library` charts are utilities for developing other charts.
    `library` charts are placed in the `charts` folder of other Helm charts.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`type`可以是`application`或`library`。只能部署`application`图表，而`library`图表是用于开发其他图表的实用程序。`library`图表放置在其他Helm图表的`charts`文件夹中。
- en: In order to configure each specific application installation, Helm chart `.yaml`
    files contain variables that are specified when Helm charts are installed. Moreover,
    Helm charts also provide a simple templating language that allows some declarations
    to be included only if some conditions depending on the input variables are satisfied.
    The top-level `values.yaml` file declares default values for the input variables,
    meaning that the developer needs to specify just the few variables for which they
    require values different from the defaults. We will not describe the Helm chart
    templates language, but you can find it in the official Helm documentation referred
    to in the *Further reading* section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置每个特定应用程序的安装，Helm图表`.yaml`文件包含在安装Helm图表时指定的变量。此外，Helm图表还提供了一个简单的模板语言，允许仅在满足取决于输入变量的条件时包含一些声明。顶级`values.yaml`文件声明了输入变量的默认值，这意味着开发人员只需要指定几个需要与默认值不同的变量。我们不会描述Helm图表模板语言，但您可以在*进一步阅读*部分中找到官方Helm文档。
- en: Helm charts are usually organized in public or private repositories in a way
    that is similar to Docker images. There is a Helm client that you can use for
    downloading packages from a remote repository and for installing charts in Kubernetes
    clusters. The Helm client is immediately available in the Azure Cloud Shell, so
    you can start using Helm for your Azure Kubernetes cluster with no need to install
    it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Helm图表通常以与Docker镜像类似的方式组织在公共或私有存储库中。有一个Helm客户端，您可以使用它从远程存储库下载软件包，并在Kubernetes集群中安装图表。Helm客户端立即在Azure
    Cloud Shell中可用，因此您可以开始在Azure Kubernetes集群中使用Helm，而无需安装它。
- en: 'A remote repository must be added before using its packages, as shown in the
    following example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用其软件包之前，必须添加远程存储库，如下例所示：
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding command makes available the packages of a remote repository and
    gives a local name to it. After that, any package of the remote repository can
    be installed with a command such as the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令使远程存储库的软件包可用，并为其指定本地名称。之后，可以使用以下命令安装远程存储库的任何软件包：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here, `<namespace>` is the namespace where to install the application. As usual,
    if not provided, the `default` namespace is assumed. `<instance name>` is the
    name that you give to the installed application. You need this name to get information
    about the installed application with the following command:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<namespace>`是要安装应用程序的命名空间。通常情况下，如果未提供，则假定为`default`命名空间。`<instance name>`是您为安装的应用程序指定的名称。您需要此名称才能使用以下命令获取有关已安装应用程序的信息：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can get also information about all applications installed with Helm with
    the help of the following command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下命令获取使用Helm安装的所有应用程序的信息：
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The application name is also needed to delete the application from the cluster,
    by means of the following command:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要应用程序名称来通过以下命令从集群中删除应用程序：
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When we install an application, we may also provide a `.yaml` file with all
    the variable values we want to override. We can also specify a specific version
    of the Helm chart, otherwise the more recent version is assumed. Here is an example
    with both the version and values overridden:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们安装应用程序时，我们还可以提供一个包含要覆盖的所有变量值的`.yaml`文件。我们还可以指定Helm图表的特定版本，否则将假定为最新版本。以下是一个同时覆盖版本和值的示例：
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, value overrides can also be provided in-line with the `--set` option,
    as shown here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值覆盖也可以通过`--set`选项提供，如下所示：
- en: '[PRE51]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can also upgrade an existing installation with the `upgrade` command, as
    shown here:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`upgrade`命令升级现有的安装，如下所示：
- en: '[PRE52]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `upgrade` command may specify new value overrides with the `–f` option or
    with the `--set` option, and it can specify a new version with `--version`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`upgrade`命令可以使用`-f`选项或`--set`选项指定新的值覆盖，并且可以使用`--version`指定新版本。'
- en: 'Let''s use Helm to provide an `Ingress` for the guestbook demo application.
    More specifically, we will use Helm to install an `Ingress-Controller` based on
    Nginx. The detailed procedure to be observed is as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Helm为guestbook演示应用程序提供一个`Ingress`。更具体地说，我们将使用Helm安装一个基于Nginx的`Ingress-Controller`。要遵循的详细过程如下：
- en: 'Add the remote repository:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加远程存储库：
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Install the `Ingress-Controller`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`Ingress-Controller`：
- en: '[PRE54]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When the installation is complete, you should see an entry for the installed
    `Ingress-Controller` among the installed services if you type `kubectl get service`.
    The entry should contain a public IP. Please make a note of this IP since it will
    be the public IP of the application.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，如果键入`kubectl get service`，您应该在已安装的服务中看到已安装的`Ingress-Controller`的条目。该条目应包含一个公共IP。请记下此IP，因为它将是应用程序的公共IP。
- en: 'Open the `frontend.yaml` file and remove the `type: LoadBalancer` line. Save
    and upload this to Azure Cloud Shell. We changed the service type of the frontend
    application from `LoadBalancer` to `ClusterIP` (the default). This service will
    be connected to the new Ingress you are going to define.'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开`frontend.yaml`文件并删除`type: LoadBalancer`行。保存并上传到Azure Cloud Shell。我们将前端应用程序的服务类型从`LoadBalancer`更改为`ClusterIP`（默认）。此服务将连接到您将要定义的新Ingress。'
- en: 'Deploy `redis-master.yaml`, `redis-slave.yaml`, and `frontend.yaml` with `kubectl`,
    as detailed in the *Deploying the demo Guestbook application* subsection. Create
    a `frontend-ingress.yaml` file and place the following code in it:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl`部署`redis-master.yaml`，`redis-slave.yaml`和`frontend.yaml`，如*部署演示Guestbook应用程序*子部分所述。创建一个`frontend-ingress.yaml`文件，并将以下代码放入其中：
- en: '[PRE55]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Upload `frontend-ingress.yaml` to Cloud Shell and deploy it with the following
    command:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`frontend-ingress.yaml`上传到Cloud Shell，并使用以下命令部署它：
- en: '[PRE56]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Open the browser and navigate to the public IP you annotated in *step 3*. There,
    you should see the application running.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器并导航到您在*步骤3*中注释的公共IP。在那里，您应该看到应用程序正在运行。
- en: Since the public IP allocated to `Ingress-Controller` is available in the Azure
    *Public IP Addresses* section of Azure (use the Azure search box to find it),
    you can retrieve it there and assign it a hostname of the type `<chosen name>.<your
    Azure region>.cloudeapp.com`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分配给`Ingress-Controller`的公共IP在Azure的*公共IP地址*部分中可用（使用Azure搜索框找到它），您可以在那里检索它，并为其分配一个类型为`<chosen
    name>.<your Azure region>.cloudeapp.com`的主机名。
- en: 'You are encouraged to assign a hostname to the application public IP, and then
    to use this hostname to get a free HTTPS certificate from [https://letsencrypt.org/](https://letsencrypt.org/).
    Once you get a certificate, you can generate a secret from it with the following
    command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励您为应用程序公共IP分配一个主机名，然后使用此主机名从[https://letsencrypt.org/](https://letsencrypt.org/)获取免费的HTTPS证书。获得证书后，可以使用以下命令从中生成一个密钥：
- en: '[PRE57]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then you can add the preceding secret to your `frontend-ingress.yamlIngress`
    by adding the following `spec->tls` section to it:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过将前面的密钥添加到`frontend-ingress.yamlIngress`中，将以下`spec->tls`部分添加到其中：
- en: '[PRE58]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Following the correction, upload the file to your Azure Cloud Shell, and update
    the previous `Ingress` definition with the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 进行更正后，将文件上传到Azure Cloud Shell，并使用以下内容更新先前的`Ingress`定义：
- en: '[PRE59]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: At this point, you should be able to access the Guestbook application with HTTPS.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该能够通过HTTPS访问Guestbook应用程序。
- en: 'When you are done experimenting, please don''t forget to delete everything
    from your cluster to avoid wasting your free Azure credit. You can do this by
    means of the following commands:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成实验时，请不要忘记从集群中删除所有内容，以避免浪费您的免费Azure信用额度。您可以通过以下命令来完成：
- en: '[PRE60]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we described Kubernetes basic concepts and objects, and then
    we explained how to create an Azure Kubernetes cluster. We also showed how to
    deploy applications, and how to monitor and inspect the state of your cluster
    with a simple demo application.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Kubernetes的基本概念和对象，然后解释了如何创建Azure Kubernetes集群。我们还展示了如何部署应用程序，以及如何使用简单的演示应用程序监视和检查集群的状态。
- en: The chapter also described more advanced Kubernetes features that cover a fundamental
    role in practical applications, including how to provide persistent storage to
    the containers running on Kubernetes, how to inform Kubernetes of the health state
    of your containers, and how to offer advanced HTTP services, such as HTTPS and
    name-based virtual hosting.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还介绍了更高级的Kubernetes功能，这些功能在实际应用程序中起着基本作用，包括如何为在Kubernetes上运行的容器提供持久存储，如何通知Kubernetes容器的健康状态，以及如何提供高级HTTP服务，如HTTPS和基于名称的虚拟主机。
- en: Finally, we reviewed how to install complex applications with Helm, and gave
    a short description of Helm and Helm commands.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们回顾了如何使用Helm安装复杂的应用程序，并对Helm和Helm命令进行了简短的描述。
- en: In the next chapter, you will learn how to connect your .NET application with
    databases with Entity Framework.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何使用Entity Framework将.NET应用程序与数据库连接。
- en: Questions
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why are Services needed?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么需要服务（Services）？
- en: Why is an `Ingress` needed?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么需要`Ingress`？
- en: Why is Helm needed?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么需要Helm？
- en: Is it possible to define several Kubernetes objects in the same `.yaml` file?
    If yes, how?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可以在同一个`.yaml`文件中定义多个Kubernetes对象？如果可以，如何操作？
- en: How does Kubernetes detect container faults?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes如何检测容器故障？
- en: Why are persistent volume claims needed?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么需要持久卷索赔（Persistent Volume Claims）？
- en: What is the difference between a `ReplicaSet` and a `StatefulSet`?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ReplicaSet`和`StatefulSet`之间有什么区别？'
- en: Further reading
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'A good book for extending the knowledge acquired in this chapter is the following:
    [https://www.packtpub.com/product/hands-on-kubernetes-on-azure-second-edition/9781800209671](https://www.packtpub.com/product/hands-on-kubernetes-on-azure-second-edition/9781800209671).'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个很好的书籍，可以扩展在本章中获得的知识，是以下这本：[https://www.packtpub.com/product/hands-on-kubernetes-on-azure-second-edition/9781800209671](https://www.packtpub.com/product/hands-on-kubernetes-on-azure-second-edition/9781800209671)。
- en: 'The official documentation for Kubernetes and `.yaml` files can be found here:
    [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/).'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes和`.yaml`文件的官方文档可以在这里找到：[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)。
- en: 'More information on Helm and Helm charts can be found in the official documentation.
    This is extremely well written and contains some good tutorials: [https://helm.sh/](https://helm.sh/).'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Helm和Helm charts的更多信息可以在官方文档中找到。这些文档写得非常好，包含一些很好的教程：[https://helm.sh/](https://helm.sh/)。
- en: 'The official documentation for Azure Kubernetes can be found here: [https://docs.microsoft.com/en-US/azure/aks/](https://docs.microsoft.com/en-US/azure/aks/).'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Kubernetes的官方文档可以在这里找到：[https://docs.microsoft.com/en-US/azure/aks/](https://docs.microsoft.com/en-US/azure/aks/)。
- en: 'The official documentation on the Azure Application Gateway-based `Ingress
    Controller` is available here: [https://github.com/Azure/application-gateway-kubernetes-ingress](https://github.com/Azure/application-gateway-kubernetes-ingress).'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Azure应用程序网关的`Ingress Controller`的官方文档可以在这里找到：[https://github.com/Azure/application-gateway-kubernetes-ingress](https://github.com/Azure/application-gateway-kubernetes-ingress)。
- en: '`Ingress` certificate release and renewal can be automated as explained here:
    [https://docs.microsoft.com/en-us/azure/application-gateway/ingress-controller-letsencrypt-certificate-application-gateway](https://docs.microsoft.com/en-us/azure/application-gateway/ingress-controller-letsencrypt-certificat).
    While the procedure specifies an Azure Application Gateway-based ingress controller,
    it is adequate for any `Ingress Controller`.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ingress`证书的发布和更新可以按照这里的说明进行自动化：[https://docs.microsoft.com/en-us/azure/application-gateway/ingress-controller-letsencrypt-certificate-application-gateway](https://docs.microsoft.com/en-us/azure/application-gateway/ingress-controller-letsencrypt-certificat)。虽然该过程指定了基于Azure应用程序网关的入口控制器，但适用于任何`Ingress
    Controller`。'
