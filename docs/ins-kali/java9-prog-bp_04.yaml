- en: Date Calculator
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期计算器
- en: If you've been developing in Java for any serious length of time, you know one
    thing to be true--working with dates is awful. The `java.util.Date` class, with
    its related classes, shipped with 1.0, and `Calendar` and its related classes
    coming along in 1.1\. Even early on, problems were apparent. For example, the
    Javadoc on `Date` says this--*Unfortunately, the API for these functions was not
    amenable to internationalization*. As a result, `Calendar` was introduced in 1.1\.
    Sure, there have been other enhancements down through the years, but given Java's
    strict adherence to backwards compatibility, there's only so much the language
    architects can do. As much as they may want to fix those APIs, their hands are
    tied.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Java中有任何严肃的开发经验，你会知道一件事是真实的——处理日期是糟糕的。`java.util.Date`类及其相关类是在1.0版中发布的，`Calendar`及其相关类是在1.1版中发布的。甚至在早期，问题就已经显现出来。例如，`Date`的Javadoc上说——*不幸的是，这些函数的API不适合国际化*。因此，`Calendar`在1.1版中被引入。当然，多年来还有其他的增强，但考虑到Java对向后兼容性的严格遵守，语言架构师们能做的只有那么多。尽管他们可能想要修复这些API，但他们的手是被捆绑的。
- en: Fortunately, **Java Specification Request** (**JSR 310**) was filed. Led by
    Stephen Colebourne, an effort was begun to create a new API, based on the very
    popular open source library, Joda-Time. In this chapter, we'll take an in-depth
    look at this new API, then build a simple command-line utility to perform date
    and time math, which will give us an opportunity to see some of this API in action.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，**Java规范请求**（**JSR 310**）已经提交。由Stephen Colebourne领导，开始了一个努力创建一个新的API，基于非常流行的开源库Joda-Time。在本章中，我们将深入研究这个新的API，然后构建一个简单的命令行实用程序来执行日期和时间计算，这将让我们有机会看到这个API的一些实际应用。
- en: 'This chapter, then, will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章将涵盖以下主题：
- en: The Java 8 Date/Time API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8日期/时间API
- en: Revisiting command-line utilities
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视命令行实用程序
- en: Text parsing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本解析
- en: Getting started
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Like the project in [Chapter 2](../Text/139d1d2c-9088-4545-a627-47b619ef035a.xhtml),
    *Managing Processes in Java*, this project is fairly simple, conceptually. The
    end goal is a command-line utility to perform various date and time calculations.
    However, while we're at it, it would be very nice if the actual date/time work
    were to be put in a reusable library, so that's what we'll do. This leaves us
    with two projects, which we'll set up, like last time, as a multi-module Maven
    project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 就像[第2章](../Text/139d1d2c-9088-4545-a627-47b619ef035a.xhtml)中的项目，*在Java中管理进程*，这个项目在概念上是相当简单的。最终目标是创建一个命令行实用程序来执行各种日期和时间计算。然而，在此过程中，如果实际的日期/时间工作能够被放入一个可重用的库中，那将是非常好的，所以我们将这样做。这给我们留下了两个项目，我们将像上次一样设置为多模块Maven项目。
- en: 'The parent POM will look something like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 父POM将看起来像这样：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you read [Chapter 2](../Text/139d1d2c-9088-4545-a627-47b619ef035a.xhtml),
    *Managing Processes in Java*, or have worked with multi-module Maven builds before,
    there's nothing new here. It's included simply for completeness. If this is foreign
    to you, take a moment to review the first few pages of Chapter 2 before continuing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你读过[第2章](../Text/139d1d2c-9088-4545-a627-47b619ef035a.xhtml)，*在Java中管理进程*，或者之前有过多模块Maven构建的经验，这里没有什么新的。这只是为了完整性而包含在内。如果这对你来说是陌生的，请花点时间在继续之前回顾第2章的前几页。
- en: Building the library
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建库
- en: 'Since we''d like to be able to reuse this tool in other projects, we''ll start
    by building a library that exposes its functionality. All of the functionality
    we''ll need is built into the platform, so our POM file is very simple:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望能够在其他项目中重用这个工具，我们将首先构建一个公开其功能的库。我们需要的所有功能都内置在平台中，因此我们的POM文件非常简单：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are **almost** no external dependencies. The only dependency listed is
    on the testing library, TestNG. We didn't talk much about testing in the last
    chapter (rest assured, there are tests in the project). In this chapter, we'll
    introduce the topic of testing and show some examples.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有外部依赖。唯一列出的依赖是测试库TestNG。在上一章中我们没有谈论太多关于测试（请放心，项目中有测试）。在本章中，我们将介绍测试的主题并展示一些例子。
- en: 'Now we need to define our module. Remember that these are Java 9 projects,
    so we want to make use of the module functionality to help protect our internal
    classes from accidental public exposure. Our module is very simple. We need to
    give it a name, then export our public API package, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要定义我们的模块。请记住，这些是Java 9项目，所以我们希望利用模块功能来帮助保护我们的内部类不被意外公开。我们的模块非常简单。我们需要给它一个名称，然后导出我们的公共API包，如下所示：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since everything we need is already in the JDK, we have nothing to declare beyond
    what we export.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要的一切都已经在JDK中，我们没有什么需要声明的，除了我们导出的内容。
- en: With our project set up, let's take a quick look at the functional requirements.
    Our intent with this project is to build a system that allows the user to provide
    an arbitrary string representing a date or time calculation expression and get
    a response. The string may look something like `"today + 2 weeks"` to find out
    the date 2 weeks from today, `"now + 3 hours 15 minutes"` to find out what time
    it is in 3 hours and 15 minutes, or `"2016/07/04 - 1776/07/04"` to find out how
    many years, months, and days are between the two dates. The processing of these
    expressions will be one line at a time, so the ability to pass in, for example,
    a text document with multiple expressions and get multiple results is explicitly
    excluded from the scope. This can be implemented easily enough, of course, by
    any consuming application or library.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的项目设置，让我们快速看一下功能需求。我们这个项目的目的是构建一个系统，允许用户提供一个表示日期或时间计算表达式的任意字符串，并得到一个响应。这个字符串可能看起来像`"today
    + 2 weeks"`，以找出从今天开始的2周后的日期，`"now + 3 hours 15 minutes"`，以找出3小时15分钟后的时间，或者`"2016/07/04
    - 1776/07/04"`，以找出两个日期之间的年、月和天数。这些表达式的处理将一次处理一行，因此明确排除了传入多个表达式的文本文档并得到多个结果的能力。当然，任何消费应用程序或库都可以很容易地实现这一点。
- en: So, now we have a project set up and ready to go, and we have a rough sketch
    of its fairly simple functional requirements. We're ready to start coding. Before
    we do that, let's take a quick tour of the new `java.time` package to get a better
    sense of what we'll be seeing in this project, as well as some of the functionality
    we **won't** be using in this simple project.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置好了一个项目，并且准备好了，我们对其相当简单的功能需求有一个大致的草图。我们准备开始编码。在这之前，让我们快速浏览一下新的`java.time`包，以更好地了解我们将在这个项目中看到的内容，以及我们在这个简单项目中**不会**使用的一些功能。
- en: A timely interlude
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 及时的插曲
- en: Prior to Java 8, two primary date-related classes were `Date` and `Calendar`
    (and, of course, `GregorianCalendar`). The new `java.time` package offers several
    new classes, such as `Duration`, `Period`, `Clock`, `Instant`, `LocalDate`, `LocalTime`,
    `LocalDateTime`, and `ZonedDateTime`. There is a plethora of supporting classes,
    but these are the primary starting points. Let's take a quick look at each.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8之前，两个主要的日期相关类是`Date`和`Calendar`（当然还有`GregorianCalendar`）。新的`java.time`包提供了几个新类，如`Duration`、`Period`、`Clock`、`Instant`、`LocalDate`、`LocalTime`、`LocalDateTime`和`ZonedDateTime`。还有大量的支持类，但这些是主要的起点。让我们快速看一下每一个。
- en: Duration
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续时间
- en: '`Duration` is a **time-based unit of time**. While it may sound odd to phrase
    it that way, the wording was chosen to distinguish it from a date-based unit of
    time, which we''ll look at next. In plain English, it''s a measurement of time,
    such as **10 seconds**, **1 hour**, or **100 nanoseconds**. `Duration` is measured
    in seconds, but there are a number of methods to get a representation of the duration
    in other units of measure, which are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Duration`是一个**基于时间的时间单位**。虽然用这种方式来表达可能听起来有点奇怪，但选择这种措辞是为了区分它与基于日期的时间单位，我们将在下面看到。简单来说，它是时间的度量，比如**10秒**、**1小时**或**100纳秒**。`Duration`以秒为单位，但有许多方法可以以其他度量单位表示持续时间，如下所示：'
- en: '`getNano()`: This is `Duration` in nanosecods'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getNano()`: 这是以纳秒为单位的`Duration`'
- en: '`getSeconds()`: This is `Duration` in seconds'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSeconds()`: 这是以秒为单位的`Duration`'
- en: '`get(TemporalUnit)`: This is `Duration` in a unit of measure specified'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(TemporalUnit)`: 这是以指定的度量单位为单位的`Duration`'
- en: 'There are also a variety of arithmetic methods, which are mentioned as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 还有各种算术方法，如下所述：
- en: '`add`/`minus (int amount, TemporalUnit unit)`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add`/`minus (int amount, TemporalUnit unit)`'
- en: '`add`/`minus (Duration)`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add`/`minus (Duration)`'
- en: '`addDays`/`minusDays(long)`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addDays`/`minusDays(long)`'
- en: '`addHours`/`minusHours(long)`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addHours`/`minusHours(long)`'
- en: '`addMillis`/`minusMillis(long)`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addMillis`/`minusMillis(long)`'
- en: '`addMinutes`/`minusMinutes(long)`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addMinutes`/`minusMinutes(long)`'
- en: '`addNanos`/`minusNanos(long)`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addNanos`/`minusNanos(long)`'
- en: '`addSeconds`/`minusSeconds(long)`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addSeconds`/`minusSeconds(long)`'
- en: '`dividedBy`/`multipliedBy`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dividedBy`/`multipliedBy`'
- en: 'We also have a number of convenient factory and extraction methods, such as
    the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有许多方便的工厂和提取方法，如下所示：
- en: '`ofDays(long)`/`toDays()`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ofDays(long)`/`toDays()`'
- en: '`ofHours(long)`/``toHours()``'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ofHours(long)`/`toHours()`'
- en: '`ofMinutes(long)`/`toMinutes()`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ofMinutes(long)`/`toMinutes()`'
- en: '`ofSeconds(long)`/`toSeconds()`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ofSeconds(long)`/`toSeconds()`'
- en: 'A `parse()` method is also supplied. Unfortunately, perhaps, for some, the
    input for this method may not be what you might expect. Since we''re dealing with
    a duration that is often, say, in hours and minutes, you might expect the method
    to accept something like "1:37" for 1 hour and 37 minutes. However, that will
    cause the system to throw `DateTimeParseException`. What the method expects to
    receive is a string in an ISO-8601 format, which looks like this--`PnDTnHnMn.nS`.
    That''s pretty fantastic, isn''t it? While it may be confusing at first, it''s
    not too bad once you understand it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 还提供了一个`parse()`方法。不幸的是，对于一些人来说，这个方法的输入可能不是你所期望的。因为我们通常处理的是以小时和分钟为单位的持续时间，你可能期望这个方法接受类似于"1:37"的输入，表示1小时37分钟。然而，这将导致系统抛出`DateTimeParseException`。这个方法期望接收的是一个ISO-8601格式的字符串，看起来像这样--`PnDTnHnMn.nS`。这很棒，不是吗？虽然一开始可能会有点困惑，但一旦你理解了它，就不会太糟糕：
- en: The first character is an optional `+` (plus) or `-` (minus) sign.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个字符是可选的`+`（加号）或`-`（减号）符号。
- en: The next character is `P` and can be either uppercase or lowercase.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个字符是`P`，可以是大写或小写。
- en: What follows is at least one of four sections indicating days (`D`), hours (`H`),
    minutes (`M`), and seconds (`S`). Again, case doesn't matter.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是至少四个部分中的一个，表示天（`D`）、小时（`H`）、分钟（`M`）和秒（`S`）。再次强调，大小写不重要。
- en: They must be declared in this order.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们必须按照这个顺序声明。
- en: Each section has a numeric part that includes an optional `+` or `-` sign, one
    or more ASCII digits, and the unit of measure indicator. The seconds amount may
    be fractional (expressed as a floating point number) and may use a period or a
    comma.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个部分都有一个数字部分，包括一个可选的`+`或`-`符号，一个或多个ASCII数字，以及度量单位指示符。秒数可能是分数（表示为浮点数），可以使用句点或逗号。
- en: The letter `T` must come before the first instance of hours, minutes, or seconds.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字母`T`必须出现在小时、分钟或秒的第一个实例之前。
- en: Simple, right? It may not be very friendly to a non-technical audience, but
    that it supports encoding a duration in a string that allows unambiguous parsing
    is a huge step forward.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 简单吧？对于非技术人员来说可能不太友好，但它支持以字符串编码持续时间，允许无歧义地解析，这是一个巨大的进步。
- en: Period
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 期间
- en: '`Period` is a date-based unit of time. Whereas `Duration` was about time (hours,
    minutes, seconds, and so on), `Period` is about years, weeks, months, and so forth.
    Like `Duration`, it exposes several arithmetic methods to add and subtract, though
    these deal with years, months, and days. It also offers `plus(long amount, TemporalUnit
    unit)` (and the equivalent `minus`) as well.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Period`是一个基于日期的时间单位。而`Duration`是关于时间（小时、分钟、秒等）的，`Period`是关于年、周、月等的。与`Duration`一样，它公开了几种算术方法来添加和减去，尽管这些方法处理的是年、月和日。它还提供了`plus(long
    amount, TemporalUnit unit)`（以及相应的`minus`）。'
- en: 'Also, like `Duration`, `Period` has a `parse()` method, which also takes an
    ISO-8601 format that looks like this--`PnYnMnD` and `PnW`. Based on the discussion
    earlier, the structure is probably pretty obvious:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，就像`Duration`一样，`Period`有一个`parse()`方法，它也采用ISO-8601格式，看起来像这样--`PnYnMnD`和`PnW`。根据前面的讨论，结构可能是相当明显的：
- en: The string starts with an optional sign, followed by the letter `P`.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串以一个可选的符号开头，后面跟着字母`P`。
- en: After that, for the first form, come three sections, at least one of which must
    be present--years (`Y`), months(`M`), and days (`D`).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一种形式之后，有三个部分，至少一个必须存在--年（`Y`）、月（`M`）和日（`D`）。
- en: For the second form, there is only one section--weeks (`W`).
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第二种形式，只有一个部分--周（`W`）。
- en: The amount in each section can have a positive or negative sign.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个部分的金额可以有正数或负数的符号。
- en: The `W` unit can't be combined with the others. Internally, the amount is multiplied
    by `7` and treated as days.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`W`单位不能与其他单位组合在一起。在内部，金额乘以`7`并视为天数。'
- en: Clock
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时钟
- en: '`Clock` is an abstract class that provides access to the current instant (which
    we will see next), date, and time using a timezone. Prior to Java 8, we would
    have to call `System.currentTimeInMillis()` and `TimeZone.getDefault()` to calculate
    these values. `Clock` provides a nice interface to get that from one object.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clock`是一个抽象类，它提供了使用时区的当前时刻（我们将在下面看到），日期和时间的访问。在Java 8之前，我们需要调用`System.currentTimeInMillis()`和`TimeZone.getDefault()`来计算这些值。`Clock`提供了一个很好的接口，可以从一个对象中获取这些值。'
- en: The Javadoc states that the use of `Clock` is purely optional. In fact, the
    major date/time classes have a `now()` method that uses the system clock to get
    their value. If, however, you need to provide an alternate implementation (say,
    in testing, you need the `LocalTime` in another timezone), this abstract class
    can be extended to provide the functionality needed, and can then be passed to
    the appropriate `now()` method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Javadoc声明使用`Clock`纯粹是可选的。事实上，主要的日期/时间类有一个`now()`方法，它使用系统时钟来获取它们的值。然而，如果您需要提供一个替代实现（比如在测试中，您需要另一个时区的`LocalTime`），这个抽象类可以被扩展以提供所需的功能，然后可以传递给适当的`now()`方法。
- en: Instant
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Instant
- en: An `Instant` is a single, exact point in time (or **on the timeline**, you'll
    see the Javadoc say). This class offers arithmetic methods, much like `Period`
    and `Duration`. Parsing is also an option, with the string being an ISO-8601 instant
    format such as `1977-02-16T08:15:30Z`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Instant`是一个单一的、确切的时间点（或**在时间线上**，您会看到Javadoc说）。这个类提供了算术方法，就像`Period`和`Duration`一样。解析也是一个选项，字符串是一个ISO-8601的时间点格式，比如`1977-02-16T08:15:30Z`。'
- en: LocalDate
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LocalDate
- en: '`LocalDate` is a date without a timezone. While the value of this class is
    a date (year, month, and day), there are accessor methods for other values, which
    are as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalDate`是一个没有时区的日期。虽然这个类的值是一个日期（年、月和日），但是还有其他值的访问器方法，如下所示：'
- en: '`getDayOfWeek()`: This returns the `DayOfWeek` enum for the day of the week
    represented by the date.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDayOfWeek()`: 这返回日期表示的星期几的`DayOfWeek`枚举。'
- en: '`getDayOfYear()`: This returns the day of the year (1 to 365, or 366 for leap
    years) represented by the date. This is a 1-based counter from January 1 of the
    specified year.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDayOfYear()`: 这返回日期表示的一年中的日子（1到365，或闰年的366）。这是从指定年份的1月1日开始的基于1的计数器。'
- en: '`getEra()`: This returns the ISO era for the given date.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getEra()`: 这返回给定日期的ISO纪元。'
- en: Local dates can be parsed from a string, of course, but, this time, the format
    seems much more reasonable--`yyyy-mm-dd`. If you need a different format, the
    `parse()` method has been overridden to allow you to specify the `DateTimeFormatter`
    that can handle the format of the string.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，本地日期可以从字符串中解析，但是，这一次，格式似乎更加合理--`yyyy-mm-dd`。如果您需要不同的格式，`parse()`方法已经被重写，允许您指定可以处理字符串格式的`DateTimeFormatter`。
- en: LocalTime
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LocalTime
- en: '`LocalTime` is the time-based equivalent of `LocalDate`. It stores `HH:MM:SS`,
    but does **not** store the timezone. Parsing times requires the format above,
    but, just like `LocalDate`, does allow you to specify a `DateTimeFormatter` for
    alternate string representations.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalTime`是`LocalDate`的基于时间的等价物。它存储`HH:MM:SS`，但**不**存储时区。解析时间需要上面的格式，但是，就像`LocalDate`一样，允许您指定一个`DateTimeFormatter`来表示替代字符串。'
- en: LocalDateTime
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LocalDateTime
- en: '`LocalDateTime` is basically a combination of the last two classes. All of
    the arithmetic, factory, and extraction methods apply as expected. Parsing the
    text is also a combination of the two, except that `T` must separate the date
    and time portions of the string--`''2016-01-01T00:00:00''`. This class **does
    not** store or represent a timezone.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalDateTime`基本上是最后两个类的组合。所有的算术、工厂和提取方法都按预期应用。解析文本也是两者的组合，只是`T`必须分隔字符串的日期和时间部分--`''2016-01-01T00:00:00''`。这个类**不**存储或表示时区。'
- en: ZonedDateTime
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ZonedDateTime
- en: If you need to represent a date/time **and** a timezone, then `ZonedDateTime`
    is the class you need. As you might expect, this class' interface is a combination
    of `LocalDate` and `LocalTime`, with extra methods added for handling the timezone.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要表示日期/时间**和**时区，那么`ZonedDateTime`就是您需要的类。正如您可能期望的那样，这个类的接口是`LocalDate`和`LocalTime`的组合，还增加了处理时区的额外方法。
- en: As shown at length in the overview of duration's API (and hinted at, though
    not as clearly shown in the other classes), one of the strong points of this new
    API is the ability to manipulate and process various date and time artifacts mathematically.
    It is precisely this functionality that we will spend most of our time with in
    this project as we explore this new library.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在持续时间API的概述中所展示的（并且在其他类中也有所暗示，尽管没有那么清楚地显示），这个新API的一个强大之处是能够在数学上操作和处理各种日期和时间工件。正是这个功能，我们将在这个项目中花费大部分时间来探索这个新的库。
- en: Back to our code
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到我们的代码
- en: 'The first part of the process we need to tackle is parsing the user-provided
    string into something we can use programmatically. If you were to search for a
    parser generator, you would find a myriad of options, with tools such as Antlr
    and JavaCC showing up near the top. It''s tempting to turn to one of these tools,
    but our purposes here are pretty simple, and the grammar is not all that complex.
    Our functional requirements include:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决的过程的第一部分是将用户提供的字符串解析为我们可以在程序中使用的东西。如果您要搜索解析器生成器，您会发现有很多选择，Antlr和JavaCC等工具通常排在前面。诱人的是转向其中一个工具，但我们这里的目的相当简单，语法并不复杂。我们的功能要求包括：
- en: We want to be able to add/subtract time to/from a date or a time
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望能够向日期或时间添加/减去时间
- en: We want to be able to subtract one date or time from another to get the difference
    between the two
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望能够从另一个日期或时间中减去一个日期或时间，以获得两者之间的差异
- en: We want to be able to convert a time from one timezone to another
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望能够将一个时区的时间转换为另一个时区
- en: For something as simple as this, a parser is far too expensive, both in terms
    of complexity and binary size. We can easily write a parser using tools built
    into the JDK, which is what we'll do.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样简单的东西，解析器太昂贵了，无论是在复杂性还是二进制大小方面。我们可以很容易地使用JDK内置的工具编写解析器，这就是我们将要做的。
- en: To set the stage before we get into the code, the plan is this--we will define
    a number of **tokens** to represent logical parts of a date calculation expression.
    Using regular expressions, we will break down the given string, returning a list
    of these tokens, which will then be processed **left to right** to return the
    result.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入代码之前，我们的计划是这样的——我们将定义许多**令牌**来表示日期计算表达式的逻辑部分。使用正则表达式，我们将分解给定的字符串，返回这些令牌的列表，然后按**从左到右**的顺序处理以返回结果。
- en: That said, let's make a list of the types of token we'll need. We'll need one
    for a date, a time, the operator, any numeric amount, the unit of measure, and
    the timezone. Obviously, we won't need each of these for every expression, but
    that should cover all of our given use cases.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们列出我们需要的令牌类型。我们需要一个日期，一个时间，操作符，任何数字金额，度量单位和时区。显然，我们不需要每个表达式中的每一个，但这应该涵盖我们所有给定的用例。
- en: 'Let''s start with a base class for our tokens. When defining a type hierarchy,
    it''s always good to ask whether you want a base class or an interface. Using
    an interface gives the developer extra flexibility with regard to the class hierarchy
    should the need arise to extend a different class. A base class, however, allows
    us to provide default behavior at the cost of some rigidity in the hierarchy of
    the type. To make our `Token` implementations as simple as possible, we''d like
    to put as much in the base class as possible, so we''ll use a base class as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的令牌的基类开始。在定义类型层次结构时，询问是否需要基类或接口总是一个好主意。使用接口可以使开发人员在需要扩展不同类时对类层次结构具有额外的灵活性。然而，基类允许我们以一定的类型层次结构提供默认行为。为了使我们的“Token”实现尽可能简单，我们希望尽可能多地将其放在基类中，因此我们将使用如下的基类：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Java 8 did introduce a means to provide default behavior from an interface,
    that being a **default methods**. A default method is a method on an interface
    that provides a concrete implementation, which is a significant departure from
    interfaces. Prior to this change, all interfaces could do was define the method
    signature and force the implementing class to define the body. This allows us
    to add methods to an interface and provide a default implementation so that existing
    implementations of the interface need not change. In our case, the behavior we're
    providing is the storing of a value (the instance variable `value`) and the accessor
    for it (`getValue()`), so an interface with a default method is not appropriate.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8确实引入了一种从接口提供默认行为的方法，即**默认方法**。默认方法是接口上提供具体实现的方法，这是与接口的重大变化。在这一变化之前，所有接口能做的就是定义方法签名并强制实现类定义方法体。这使我们能够向接口添加方法并提供默认实现，以便接口的现有实现无需更改。在我们的情况下，我们提供的行为是存储一个值（实例变量`value`）和它的访问器（`getValue()`），因此具有默认方法的接口不合适。
- en: Note that we've also defined a nested interface, `Info`, which we will cover
    in more detail when we get to the parser.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还定义了一个嵌套接口`Info`，我们将在解析器部分详细介绍。
- en: 'With our base class defined, we can now create the tokens we will need as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们定义的基类，我们现在可以创建我们需要的令牌，如下所示：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To start the class, we define two constants. `TODAY` is a special string that
    we will allow the user to specify today''s date. The second is the regular expression
    we''ll use to identify a date string:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始这个类，我们定义了两个常量。`TODAY`是一个特殊的字符串，我们将允许用户指定今天的日期。第二个是我们将用来识别日期字符串的正则表达式：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It''s no secret that regular expressions are ugly, and as these things go,
    this one''s not too terribly complicated. We''re matching 4 digits (`\\d{4}`),
    either a - or / (`[-/]`), a 0 or 1 followed by any digit (`[01]\\d`), another
    - or /, then a 0, 1, 2, or 3 followed by any digit. Finally, the last segment,
    `|today`, tells the system to match on the pattern that comes before, **or** the
    text `today`. All this regular expression can do is identify a string that **looks**
    like a date. In its current form, it can''t actually ensure that it is valid.
    We can probably make a regex that can do exactly that, but the complexity that
    would introduce is just not worth it. What we can do though is let the JDK validate
    the string for us, which we''ll do in the `of` method, as shown here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，正则表达式很丑陋，就像这些东西一样，这个并不太复杂。我们匹配4位数字（`\\d{4}`），或者是-或/（`[-/]`），0或1后面跟任意数字（`[01]\\d`），另一个-或/，然后是0、1、2或3后面跟任意数字。最后一部分`|today`告诉系统匹配前面的模式，**或**文本`today`。所有这些正则表达式能做的就是识别一个**看起来**像日期的字符串。在当前形式下，它实际上不能确保它是有效的。我们可能可以制作一个可以确保这一点的正则表达式，但是引入的复杂性是不值得的。不过，我们可以让JDK为我们验证字符串，这就是我们将在`of`方法中做的。
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we've defined a static method to handle the creation of the `DateToken`
    instance. If the user provides the string `today`, we provide the value `LocalDate.now()`,
    which does what you think it might. Otherwise, we pass the string to `LocalDate.parse()`,
    changing any forward slashes to dashes, as that's what the method expects. If
    the user provided an invalid date, but the regular expression still matched it,
    we'll get an error here. Since we have built-in support to validate the string,
    we can content ourselves with letting the system do the heavy lifting for us.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个静态方法来处理`DateToken`实例的创建。如果用户提供字符串`today`，我们提供值`LocalDate.now()`，这做了你认为它可能会做的事情。否则，我们将字符串传递给`LocalDate.parse()`，将任何斜杠更改为破折号，因为这是该方法所期望的。如果用户提供了无效的日期，但正则表达式仍然匹配了它，我们将在这里得到一个错误。由于我们内置了支持来验证字符串，我们可以满足于让系统为我们做繁重的工作。
- en: 'The other tokens look very similar. Rather than showing each class, much of
    which would be very familiar, we''ll skip most of those classes and just look
    at the regular expressions, as some are quite complex. Take a look at the following
    code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 其他标记看起来非常相似。与其展示每个类，其中大部分都会非常熟悉，我们将跳过大部分这些类，只看看正则表达式，因为有些非常复杂。看看以下代码：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Well, that one''s not too bad, is it? One or more digits will match here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这个不算太糟糕，是吧？这里将匹配一个或多个数字：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Another relatively simple one, which will match a +, a -, or the `to` text:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相对简单的，它将匹配+、-或`to`文本：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The regular expression breaks down like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式分解如下：
- en: '`(?:`: This is a non-capturing group. We need to group some rules together,
    but we don''t want them to show up as separate groups when we process this in
    our Java code.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(?:`：这是一个非捕获组。我们需要将一些规则组合在一起，但我们不希望它们在我们的Java代码中处理时显示为单独的组。'
- en: '`[01]?`: This is a zero or a one. The `?` indicates that this should occur
    once or not at all.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[01]?：这是0或1。`?`表示这应该发生一次或根本不发生。'
- en: '`|2[0-3]`: We either want to match the first half, **or** this section, which
    will be a 2 followed by a 0, 1, 2, or 3.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '|2[0-3]：我们要么想匹配前半部分，**或**这一部分，它将是2后面跟着0、1、2或3。'
- en: '`)`: This ends the non-capturing group. This group will allow us to match 12
    or 24-hour times.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`)`: 这结束了非捕获组。这个组将允许我们匹配12或24小时制的时间。'
- en: '`:`: This position requires a colon. Its presence is not optional.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:`：这个位置需要一个冒号。它的存在是不可选的。'
- en: '`[0-5]\\d`: Next, the pattern must match a digit of `0-5` followed by another
    digit. This is the minutes portion of the time.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[0-5]\\d`：接下来，模式必须匹配一个0-5后面跟着另一个数字。这是时间的分钟部分。'
- en: '`'' *''`: It''s hard to see, so I''ve added quotes to help indicate it, but
    we want to match 0 or more (as indicated by the asterisk) spaces.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`'' *''`: 很难看到，所以我添加了引号来帮助指示，但我们想匹配0个或更多个（由星号表示）空格。'
- en: '`(?:`: This is another non-capturing group.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(?:`: 这是另一个非捕获组。'
- en: '`[AaPp][Mm]`: These are the `A` or `P` letters (of either case) followed by
    an `M` (also of either case).'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[AaPp][Mm]`：这些是`A`或`P`字母（任何大小写）后面跟着一个`M`（也是任何大小写）。'
- en: '`)?`: We end the non-capturing group, but mark it with a `?` to indicate that
    it should occur once or not all. This group lets us capture any `AM`/`PM` designation.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ）：我们结束了非捕获组，但用`?`标记它，以指示它应该发生一次或根本不发生。这个组让我们捕获任何`AM`/`PM`指定。
- en: '`|now`: Much like today above, we allow the user to specify this string to
    indicate the current time.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '|现在：与上面的today一样，我们允许用户指定此字符串以指示当前时间。'
- en: 'Again, this pattern may match an invalid time string, but we''ll let `LocalTime.parse()`
    handle that for us in `TimeToken.of()`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这个模式可能匹配一个无效的时间字符串，但我们将让`LocalTime.parse()`在`TimeToken.of()`中为我们处理。
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a bit more complex than others, primarily because of the default format
    expected by `LocalTime.parse()`, which is an ISO-8601 time format. Typically,
    time is specified in a 12-hour format with an am/pm designation. Unfortunately,
    that's not how the API works, so we have to make adjustments.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这比其他的要复杂一些，主要是因为`LocalTime.parse()`期望的默认格式是ISO-8601时间格式。通常，时间是以12小时制和上午/下午指定的。不幸的是，这不是API的工作方式，所以我们必须进行调整。
- en: First, we pad the hour, if needed. Second, we look to see if the user specified
    `"am"` or `"pm"`. If so, we need to create a special formatter, which is done
    via `DateTimeFormatterBuilder`. We start by telling the builder to build a case-insensitve
    formatter. If we don't do that, `"AM"` will work, but `"am"` will not. Next, we
    append the pattern we want, which is hours, minutes, and am/pm, then build the
    formatter. Finally, we can parse our text, which we do by passing the string and
    the formatter to `LocalTime.parse()`. If all goes well, we'll get a `LocalTime`
    instance back. If not, we get an `Exception` instance, which we will handle. Note
    that we call `replaceAll()` on our string. We do that to strip any spaces out
    between the time and am/pm. Otherwise, the parse will fail.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果需要，我们填充小时。其次，我们查看用户是否指定了“am”或“pm”。如果是这样，我们需要创建一个特殊的格式化程序，这是通过`DateTimeFormatterBuilder`完成的。我们首先告诉构建器构建一个不区分大小写的格式化程序。如果我们不这样做，"AM"将起作用，但"am"将不起作用。接下来，我们附加我们想要的模式，即小时、分钟和上午/下午，然后构建格式化程序。最后，我们可以解析我们的文本，方法是将字符串和格式化程序传递给`LocalTime.parse()`。如果一切顺利，我们将得到一个`LocalTime`实例。如果不行，我们将得到一个`Exception`实例，我们将处理它。请注意，我们在字符串上调用`replaceAll()`。我们这样做是为了去除时间和上午/下午之间的任何空格。否则，解析将失败。
- en: 'Finally, we come to our `UnitOfMeasureToken`. This token isn''t necessarily
    complex, but it''s certainly not simple. For our units of measure, we want to
    support the words `year`, `month`, `day`, `week`, `hour`, `minute`, and `second`,
    all of which can be plural, and most of which can be abbreviated to their initial
    character. This makes the regular expression interesting:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到我们的`UnitOfMeasureToken`。这个标记并不一定复杂，但它肯定不简单。对于我们的度量单位，我们希望支持单词`year`、`month`、`day`、`week`、`hour`、`minute`和`second`，所有这些都可以是复数，大多数都可以缩写为它们的首字母。这使得正则表达式很有趣：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That's not so much complex as ugly. We have a list of possible strings, separated
    by the logical `OR` operator, the vertical pipe. It is probably possible to write
    a regular expression that searches for each word, or parts of it, but such an
    expression will likely be very difficult to write correctly, and almost certainly
    hard to debug or change. Simple and clear is almost always better than clever
    and complex.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是很复杂，而是很丑陋。我们有一个可能的字符串列表，由逻辑`OR`运算符竖线分隔。可能可以编写一个正则表达式来搜索每个单词，或者它的部分，但这样的表达式很可能很难编写正确，几乎肯定很难调试或更改。简单和清晰几乎总是比聪明和复杂更好。
- en: 'There''s one last element here that needs discussion: `VALID_UNITS`. In a static
    initializer, we build a `Map` to allow looking up the correct `ChronoUnit`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个需要讨论的最后一个元素：`VALID_UNITS`。在静态初始化程序中，我们构建了一个`Map`，以允许查找正确的`ChronoUnit`：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: And so on.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。
- en: 'We''re now ready to take a look at the parser, which is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备来看一下解析器，它如下所示：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When we build our parser, we register each of our `Token` classes in a `List`,
    but we see two new types: `Token.Info` and `InfoWrapper`. `Token.Info` is an interface
    nested inside the `Token` class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建我们的解析器时，我们在`List`中注册了每个`Token`类，但我们看到了两种新类型：`Token.Info`和`InfoWrapper`。`Token.Info`是嵌套在`Token`类中的一个接口：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have added this interface to give us a convenient way to get the regular
    expression for a `Token` class, as well as the `Token`, without having to resort
    to reflection. `DateToken.Info`, for example, looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了这个接口，以便以方便的方式获取`Token`类的正则表达式，以及`Token`，而不必求助于反射。例如，`DateToken.Info`看起来像这样：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since this is a nested class, we get easy access to members, including statics,
    of the enclosing class.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个嵌套类，我们可以轻松访问包含类的成员，包括静态成员。
- en: 'The next new type, `InfoWrapper`, looks like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个新类型，`InfoWrapper`，看起来像这样：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is a simple, private class, so some of the normal encapsulation rules
    can be set aside (although, should this class ever be made public, this would
    certainly need to be cleaned up). What we''re doing, though, is storing a compiled
    version of the token''s regular expression. Note that we''re wrapping the regular
    expression with a couple of extra characters. The first, the caret (`^`), says
    that the match must be at the beginning of the text. We''re also wrapping the
    regular expression in parentheses. However, this time this is a capturing group.
    We''ll see why in the following parse method:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的私有类，所以一些正常的封装规则可以被搁置（尽管，如果这个类曾经被公开，肯定需要清理一下）。不过，我们正在做的是存储令牌的正则表达式的编译版本。请注意，我们用一些额外的字符包装了正则表达式。第一个是插入符（`^`），表示匹配必须在文本的开头。我们还用括号包装了正则表达式。不过，这次这是一个捕获组。我们将在下面的解析方法中看到为什么要这样做：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We start by making sure that `text` is not null, then `trim()` it, then make
    sure it's not empty. With the sanity checks done, we loop through the `List` of
    info wrappers to find a match. Remember that the pattern compiled is a capturing
    group looking at the start of the text, so we loop through each `Pattern` until
    one matches. If we don't find a match, we throw an `Exception`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先确保`text`不为空，然后`trim()`它，然后确保它不为空。完成了这些检查后，我们循环遍历信息包装器的`List`以找到匹配项。请记住，编译的模式是一个捕获组，查看文本的开头，所以我们循环遍历每个`Pattern`直到找到匹配项。如果我们找不到匹配项，我们会抛出一个`Exception`。
- en: Once we find a match, we extract the matching text from `Matcher`, then, using
    `Token.Info`, we call `getToken()` to get a `Token` instance for the matching
    `Pattern`. We store that in our list, then recursively call the `parse()` method,
    passing a substring of text starting after our match. That removes the matched
    text from the original, then repeats the process until the string is empty. Once
    the recursion ends and things unwind, we return a `Queue` of tokens that represent
    the string the user provided. We use a `Queue` instead of, say, a `List`, as that
    will make processing a bit easier. We now have a parser, but our work is only
    half done. Now we need to process those tokens.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到匹配，我们从`Matcher`中提取匹配的文本，然后使用`Token.Info`调用`getToken()`来获取匹配`Pattern`的`Token`实例。我们将其存储在我们的列表中，然后递归调用`parse()`方法，传递文本的子字符串，从我们的匹配后开始。这将从原始文本中删除匹配的文本，然后重复这个过程，直到字符串为空。一旦递归结束并且事情解开，我们将返回一个代表用户提供的字符串的`Queue`。我们使用`Queue`而不是，比如，`List`，因为这样处理会更容易一些。现在我们有了一个解析器，但我们的工作只完成了一半。现在我们需要处理这些令牌。
- en: 'In the spirit of Separation of Concerns, we''ve encapsulated the processing
    of these tokens--the actual calculation of the expression--in a separate class,
    `DateCalculator`, which uses our parser. Consider the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在关注关注关注的精神下，我们将这些令牌的处理——实际表达式的计算——封装在一个单独的类`DateCalculator`中，该类使用我们的解析器。考虑以下代码：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Each time `calculate()` is called, we create a new instance of the parser. Also,
    note that, as we look at the rest of the code, we pass the `Queue` around. While
    that does make the method signatures a bit bigger, it also makes the class thread-safe,
    as there's no state held in the class itself.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`calculate()`时，我们都会创建解析器的新实例。另外，请注意，当我们查看代码的其余部分时，我们会传递`Queue`。虽然这确实使方法签名变得有点大，但它也使类线程安全，因为类本身没有保存状态。
- en: After our `isEmpty()` check, we can see where the `Queue` API comes in handy.
    By calling `poll()`, we get a reference to the next element in the collection,
    but--and this is important--**we leave the element in the collection**. This lets
    us look at it without altering the state of the collection. Based on the type
    of the first element in the collection, we delegate to the appropriate method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`isEmpty()`检查之后，我们可以看到`Queue` API的方便之处。通过调用`poll()`，我们可以得到集合中下一个元素的引用，但是——这很重要——**我们保留了集合中的元素**。这让我们可以查看它而不改变集合的状态。根据集合中第一个元素的类型，我们委托给适当的方法。
- en: 'For handling dates, the expression syntax is `<date> <operator> <date | number
    unit_of_measure>`. We can start our processing, then, by extracting a `DateToken`
    and an `OperatorToken`, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理日期，表达式语法是`<date> <operator> <date | number unit_of_measure>`。因此，我们可以通过提取`DateToken`和`OperatorToken`来开始我们的处理，如下所示：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To retrieve an element from a `Queue`, we use the `poll()` method, and we can
    safely cast that to `DateToken` since we checked that in the calling method. Next,
    we `peek()` at the next element and, via the `validateToken()` method, we verify
    that the element is not null and is of the type desired. If the token is valid,
    we can `poll()` and cast safely. Next, we `peek()` at the third token. Based on
    its type, we delegate to the correct method to finish the processing. If we find
    an unexpected `Token` type, we throw an `Exception`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Queue`中检索元素，我们使用`poll()`方法，我们可以安全地将其转换为`DateToken`，因为我们在调用方法中检查了这一点。接下来，我们`peek()`下一个元素，并通过`validateToken()`方法验证元素不为空且为所需类型。如果令牌有效，我们可以安全地`poll()`和转换。接下来，我们`peek()`第三个令牌。根据其类型，我们委托给正确的方法来完成处理。如果我们发现意外的`Token`类型，我们抛出一个`Exception`。
- en: 'Before looking at those calculation methods, let''s look at `validateToken()`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看这些计算方法之前，让我们看一下`validateToken()`：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There's nothing too terribly exciting here, but eagle-eyed readers might notice
    that we're returning the class name of our token, and, by doing so, we're leaking
    the name of a non-exported class to the end user. That's probably not ideal, but
    we'll leave fixing that as an exercise for the reader.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多令人兴奋的东西，但敏锐的读者可能会注意到我们正在返回我们令牌的类名，并且通过这样做，我们向最终用户泄露了一个未导出类的名称。这可能不是理想的，但我们将把修复这个问题留给读者作为一个练习。
- en: 'The method to perform date math looks like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 执行日期数学的方法如下：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Since we already have our starting and operator tokens, we pass those in, as
    well as the `Queue` so that we can process the remaining tokens. Our first step
    is to determine if the operator is a plus or a minus, assigning a positive `1`
    or a `-1` to `negate` as appropriate. We do this so we can use a single method,
    `LocalDate.plus()`. If the operator is a minus, we add a negative number and get
    the same result as subtracting the original number.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了我们的起始和操作符令牌，我们将它们传递进去，以及`Queue`，以便我们可以处理剩余的令牌。我们的第一步是确定操作符是加号还是减号，根据需要给`negate`分配正数`1`或负数`-1`。我们这样做是为了能够使用一个方法`LocalDate.plus()`。如果操作符是减号，我们添加一个负数，得到与减去原始数相同的结果。
- en: Finally, we loop through the remaining tokens, verifying each one before we
    process it. We get the `IntegerToken`; grab its value; multiply it by our negative
    modifier, `negate`; then add that value to the `LocalDate` using the `UnitOfMeasureToken`
    to tell what **kind** of value we're adding.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们循环遍历剩余的令牌，在处理之前验证每一个。我们获取`IntegerToken`；获取其值；将其乘以我们的负数修饰符`negate`，然后使用`UnitOfMeasureToken`将该值添加到`LocalDate`中，以告诉我们正在添加的值的**类型**。
- en: 'Calculating the difference between dates is pretty straightforward, as we see
    here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 计算日期之间的差异非常简单，如下所示：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We extract the `LocalDate` from our two `DateToken` variables, then call `Period.between()`,
    which returns a `Period` that indicates the elapsed amount of time between the
    two dates. We do check to see which date comes first so that we return a positive
    `Period` to the user as a convenience, since most people don't typically think
    in terms of negative periods.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从两个`DateToken`变量中提取`LocalDate`，然后调用`Period.between()`，它返回一个指示两个日期之间经过的时间量的`Period`。我们确实检查了哪个日期先出现，以便向用户返回一个正的`Period`，作为一种便利，因为大多数人通常不会考虑负周期。
- en: 'The time-based methods are largely identical. The big difference is the time
    difference method:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 基于时间的方法基本相同。最大的区别是时间差异方法：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The notable difference here is the use of `Duration.between()`. It looks identical
    to `Period.between()`, but the `Duration` class offers a method that `Period`
    does not: `abs()`. This method lets us return the absolute value of `Period`,
    so we can pass our `LocalTime` variable to `between()` in any order we want.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的区别是使用了`Duration.between()`。它看起来与`Period.between()`相同，但`Duration`类提供了一个`Period`没有的方法：`abs()`。这个方法让我们返回`Period`的绝对值，所以我们可以按任何顺序将我们的`LocalTime`变量传递给`between()`。
- en: One final note before we leave this--we are wrapping our results in a `DateCalculatorResult`
    instance. Since the various operations return several different, unrelated types,
    this allows us to return a single type from our `calculate()` method. It will
    be up to the calling code to extract the appropriate value. We'll do that in our
    command-line interface, which we'll look at in the next section.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开之前的最后一点注意事项是--我们将结果封装在`DateCalculatorResult`实例中。由于各种操作返回几种不同的、不相关的类型，这使我们能够从我们的`calculate()`方法中返回一个单一类型。由调用代码来提取适当的值。我们将在下一节中查看我们的命令行界面。
- en: A brief interlude on testing
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于测试的简短插曲
- en: Before we move on, we need to visit a topic we've not discussed yet, that being
    testing. Anyone who has been in the industry for a while has likely heard the
    term **Test-Driven Development** (or **TDD** for short). It's an approach to software
    development that posits that the first thing that should be written is a test,
    which will fail (since there's no code to run), then the code should be written
    that makes the test **green**, a reference to the green indicator given in IDEs
    and other tools to indicate that the test has passed. This process repeats as
    many times as necessary to build the final system, always making changes in small
    increments, and always starting with a test. A myriad of books have been written
    on the topic, which is both hotly debated and oftentimes heavily nuanced. The
    exact way the approach is implemented, if at all, almost always comes in flavors.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要讨论一个我们尚未讨论过的话题，那就是测试。在这个行业工作了一段时间的人很可能听说过**测试驱动开发**（或简称**TDD**）这个术语。这是一种软件开发方法，认为应该首先编写一个测试，这个测试将失败（因为没有代码可以运行），然后编写使测试**通过**的代码，这是指IDE和其他工具中给出的绿色指示器，表示测试已经通过。这个过程根据需要重复多次来构建最终的系统，总是以小的增量进行更改，并始终从测试开始。关于这个主题已经有大量的书籍写成，这个主题既备受争议，又常常被严格细分。这种方法的确切实现方式，如果有的话，几乎总是有不同的版本。
- en: Clearly, in our work here, we haven't followed the TDD principle strictly, but
    that doesn't mean we haven't tested. While TDD purists are likely to quibble,
    my general approach tends to be a bit looser on the testing side until my API
    starts to solidify some. How long this takes depends on how familiar I am with
    the technologies being used. If I'm very familiar with them, I might sketch out
    a quick interface, then scaffold a test based on that as a means of testing the
    API itself, then iterate over that. For new libraries, I might write a very broad
    test to help drive the investigation of the new library, using the test framework
    as a means for bootstrapping a runtime environment in which I can experiment.
    Regardless, at the end of the development effort, the new system should be **fully**
    tested (with the exact definition of **fully** being another hotly debated concept),
    which is what I have striven for here. A full treatise on testing and test-driven
    development is beyond our scope here, though.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在我们的工作中，我们并没有严格遵循TDD原则，但这并不意味着我们没有进行测试。虽然TDD纯粹主义者可能会挑剔，但我的一般方法在测试方面可能会有些宽松，直到我的API开始变得稳定为止。这需要多长时间取决于我对正在使用的技术的熟悉程度。如果我对它们非常熟悉，我可能会草拟一个快速的接口，然后基于它构建一个测试，作为测试API本身的手段，然后对其进行迭代。对于新的库，我可能会编写一个非常广泛的测试，以帮助驱动对新库的调查，使用测试框架作为引导运行环境的手段，以便我可以进行实验。无论如何，在开发工作结束时，新系统应该经过**完全**测试（**完全**的确切定义是另一个备受争议的概念），这正是我在这里努力追求的。关于测试和测试驱动开发的全面论述超出了我们的范围。
- en: When it comes to testing in Java, you have a **lot** of options. However, the
    two most common ones are TestNG and JUnit, with JUnit probably being the most
    popular. Which one should you pick? That depends. If you are working with an existing
    code-base, you should probably use whatever is already in use, unless you have
    a good reason to do otherwise. For example, the library could be old and no longer
    supported, it could be demonstrably insufficient for your needs, or you've been
    given an express directive to update/replace the existing system. If any of those
    conditions, or others similar to these, are true, we circle back to the question--*Which
    should I choose?* Again, that depends. JUnit is extremely popular and common,
    so using it might make sense in order to lower the barrier of entry into a project.
    However, TestNG has what some feel to be a much better, cleaner API. For example,
    TestNG does not require the use of static methods for certain test setup methods.
    It also aims to be much more than just a unit testing framework, providing tools
    for unit, functional, end-to-end, and integration testing. For our tests here,
    we will be using TestNG.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中进行测试时，你有很多选择。然而，最常见的两种是TestNG和JUnit，其中JUnit可能是最受欢迎的。你应该选择哪一个？这取决于情况。如果你正在处理一个现有的代码库，你可能应该使用已经在使用的东西，除非你有充分的理由做出其他选择。例如，该库可能已经过时并且不再受支持，它可能明显不符合你的需求，或者你已经得到了明确的指令来更新/替换现有系统。如果这些条件中的任何一个，或者类似这些的其他条件是真实的，我们就回到了这个问题--*我应该选择哪一个？*同样，这取决于情况。JUnit非常受欢迎和常见，因此在项目中使用它可能是有道理的，以降低进入项目的门槛。然而，一些人认为TestNG具有更好、更清晰的API。例如，TestNG不需要对某些测试设置方法使用静态方法。它还旨在不仅仅是一个单元测试框架，还提供了用于单元、功能、端到端和集成测试的工具。在这里，我们将使用TestNG进行测试。
- en: 'To get started with TestNG, we need to add it to our project. To do that, we
    will add a test dependency to the Maven POM file as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用TestNG，我们需要将其添加到我们的项目中。为此，我们将在Maven POM文件中添加一个测试依赖项，如下所示：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Writing the tests is very simple. With the defaults of the TestNG Maven plugin,
    the class simply needs to be in `src/test/java` and end with the `Test` string.
    Each test method needs to be annotated with `@Test`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试非常简单。使用TestNG Maven插件的默认设置，类只需要在`src/test/java`中，并以`Test`字符串结尾。每个测试方法都需要用`@Test`进行注释。
- en: 'There are a number of tests in the library module, so let''s start with some
    of the very basic ones that test the regular expressions used by the tokens to
    identify and extract the relevant parts of the expression. For example, consider
    the following piece of code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 库模块中有许多测试，所以让我们从一些非常基本的测试开始，这些测试测试了标记使用的正则表达式，以识别和提取表达式的相关部分。例如，考虑以下代码片段：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is a very basic test of the `DateToken` regular expression. The test delegates
    to the `testPattern()` method, passing the regular expression to test, and a string
    to test it with. Our functionality is tested by following these steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对`DateToken`正则表达式的一个非常基本的测试。测试委托给`testPattern()`方法，传递要测试的正则表达式和要测试的字符串。我们的功能通过以下步骤进行测试：
- en: Compiling the `Pattern`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译`Pattern`。
- en: Creating a `Matcher`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Matcher`。
- en: Calling the `matcher.find()` method.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`matcher.find()`方法。
- en: With that, the logic of the system under test is exercised. What remains is
    to verify that it worked as expected. We do that with our call to `Assert.assertTrue()`.
    We assert that `matcher.find()` returns `true`. If the regex is correct, we should
    get a `true` response. If the regex is not correct, we'll get a `false` response.
    In the latter case, `assertTrue()` will throw an `Exception` and the test will
    fail.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，被测试系统的逻辑就得到了执行。剩下的就是验证它是否按预期工作。我们通过调用`Assert.assertTrue()`来做到这一点。我们断言`matcher.find()`返回`true`。如果正则表达式正确，我们应该得到一个`true`的响应。如果正则表达式不正确，我们将得到一个`false`的响应。在后一种情况下，`assertTrue()`将抛出一个`Exception`，测试将失败。
- en: This test is certainly very basic. It could--should--be more robust. It should
    test a greater variety of strings. It should include some strings known to be
    bad to make sure we're not getting incorrect results in our tests. There are probably
    a myriad of other enhancements that could be made. The point here, though, is
    to show a simple test to demonstrate how to set up a TestNG-based environment.
    Before moving on, let's look at a couple more examples.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试确实非常基础。它可能——应该——更加健壮。它应该测试更多种类的字符串。它应该包括一些已知的坏字符串，以确保我们在测试中没有得到错误的结果。可能还有许多其他的增强功能可以实现。然而，这里的重点是展示一个简单的测试，以演示如何设置基于TestNG的环境。在继续之前，让我们看几个更多的例子。
- en: 'Here''s a test to check for failure (a **negative test**):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于检查失败的测试（**负面测试**）：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this test, we expect the call to `parse()` to fail, with a `DateCalcException`.
    Should the call **not** fail, we have a call to `Assert.fail()` that will force
    the test to fail with the message provided. If the `Exception` is thrown, it's
    swallowed silently and the test finishes successfully.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们期望调用`parse()`失败，并抛出一个`DateCalcException`。如果调用**没有**失败，我们会调用`Assert.fail()`，强制测试失败并提供消息。如果抛出了`Exception`，它会被悄悄地吞没，测试将成功结束。
- en: 'Swallowing the `Exception` is one approach, but you can also tell TestNG to
    expect an `Exception` to be thrown, as we''ve done here via the `expectedExceptions`
    attribute:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 吞没`Exception`是一种方法，但你也可以告诉TestNG期望抛出一个`Exception`，就像我们在这里通过`expectedExceptions`属性所做的那样：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Again, we're passing a bad string to the parser. However, this time, we're telling
    TestNG to expect the exception via the annotation--`@Test(expectedExceptions =
    {DateCalcException.class})`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将一个坏的字符串传递给解析器。然而，这一次，我们通过注解告诉TestNG期望抛出异常——`@Test(expectedExceptions =
    {DateCalcException.class})`。
- en: Much more could be written on testing in general and TestNG in particular. A
    thorough treatment of both topics is beyond our scope, but if you are not familiar
    with either topic, you would be well served to find one of the many great resources
    available and study them thoroughly.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 关于测试一般和特别是TestNG，还可以写更多。对这两个主题的全面讨论超出了我们的范围，但如果你对任何一个主题不熟悉，最好找到其中的一些优秀资源并进行深入学习。
- en: For now, let's turn our attention to the command-line interface.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把注意力转向命令行界面。
- en: Building the command-line interface
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建命令行界面
- en: In the last chapter, we built a command-line tool using the Crest library from
    Tomitribe, and it worked out pretty well, so we will return to the library in
    building this command line as well.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了Tomitribe的Crest库构建了一个命令行工具，并且效果非常好，所以我们将在构建这个命令行时再次使用这个库。
- en: 'To enable Crest in our project, we must do two things. First, we have to configure
    our POM file as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的项目中启用Crest，我们必须做两件事。首先，我们必须按照以下方式配置我们的POM文件：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We must also update our module definition in `src/main/java/module-info.java`
    as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须按照以下方式更新`src/main/java/module-info.java`中的模块定义：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can now define our CLI class like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以像这样定义我们的CLI类：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Unlike in the last chapter, this command line will be extremely simple, as the
    only input we need is the expression to evaluate. With the preceding method signature,
    we tell Crest to pass all of the command-line arguments as the `args` value, which
    we then join back together via `String.join()` into `expression`. Next, we create
    our calculator and calculate the result.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章不同，这个命令行将非常简单，因为我们唯一需要的输入是要评估的表达式。通过前面的方法签名，我们告诉Crest将所有命令行参数作为`args`值传递，然后我们通过`String.join()`将它们重新连接成`expression`。接下来，我们创建我们的计算器并计算结果。
- en: 'We now need to interrogate our `DateCalcResult` to determine the nature of
    the expression. Consider the following piece of code as an example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要询问我们的`DateCalcResult`来确定表达式的性质。考虑以下代码片段作为示例：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `LocalDate` and `LocalTime` responses are pretty straightforward--we can
    simply call the `toString()` method on them, as the defaults are, for our purposes
    here, perfectly acceptable. Duration and periods are a bit more complicated. Both
    provide a number of methods to extract the details. We will hide those details
    in separate methods:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalDate`和`LocalTime`的响应非常直接——我们可以简单地调用它们的`toString()`方法，因为默认值对于我们的目的来说是完全可以接受的。`Duration`和`periods`则更加复杂。两者都提供了许多提取细节的方法。我们将把这些细节隐藏在单独的方法中：'
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The method itself is pretty simple--we extract the various parts from `Duration`,
    then build the string based on whether or not the part returns values.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法本身非常简单——我们从`Duration`中提取各个部分，然后根据部分是否返回值来构建字符串。
- en: 'The date-related method, `processPeriod()`, is similar:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与日期相关的`processPeriod()`方法类似：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Each of these methods returns the result as a string, which we then write to
    standard out. And that's it. It's not a terribly complicated command-line utility,
    but the purpose of the exercise here is found mostly in the library.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的每一个都将结果作为字符串返回，然后我们将其写入标准输出。就是这样。这不是一个非常复杂的命令行实用程序，但这里的练习目的主要在于库中。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Our date calculator is now complete. The utility itself is not too terribly
    complex, although, it did serve as expected, which has to be a vehicle for experimenting
    with Java 8's Date/Time API. In addition to the new date/time API, we scratched
    the surface of regular expressions, a very powerful and complex tool to parse
    strings. We also revisited the command-line utility library from the last chapter,
    and dipped our toes in the waters of unit testing and test-driven development.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的日期计算器现在已经完成。这个实用程序本身并不是太复杂，尽管它确实如预期般发挥作用，这必须成为尝试使用Java 8的日期/时间API的工具。除了新的日期/时间API，我们还初步了解了正则表达式，这是一种非常强大和复杂的工具，用于解析字符串。我们还重新访问了上一章的命令行实用程序库，并在单元测试和测试驱动开发的领域涉足了一点。
- en: In the next chapter, we'll get a bit more ambitious and step into the world
    of social media, building an app to help us aggregate some of our favorite services
    into a single application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更加雄心勃勃地进入社交媒体的世界，构建一个应用程序，帮助我们将一些喜爱的服务聚合到一个单一的应用程序中。
