- en: Chapter 10. Maximization of Code Reuse with Generics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。通过泛型最大化代码重用
- en: 'In this chapter, we will learn about parametric polymorphism and how Java 9
    implements this object-oriented concept by allowing us to write generic code.
    We will start creating classes that use one constrained generic type. We will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习参数多态以及Java 9如何通过允许我们编写通用代码来实现这一面向对象的概念。我们将开始创建使用受限泛型类型的类。我们将：
- en: Understand parametric polymorphism
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解参数多态
- en: Learn the differences between parametric polymorphism and duck typing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解参数多态和鸭子类型之间的区别
- en: Understand Java 9 generics and generic code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Java 9泛型和通用代码
- en: Declare an interface to be used as a type constraint
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个用作类型约束的接口
- en: Declare a class that conforms to multiple interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明符合多个接口的类
- en: Declare subclasses that inherit the implementation of interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明继承接口实现的子类
- en: Create exception classes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建异常类
- en: Declare a class that works with a constrained generic type
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个使用受限泛型类型的类
- en: Use a generic class for multiple compatible types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个通用类来处理多个兼容类型
- en: Understanding parametric polymorphism, Java 9 generics, and generic code
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解参数多态、Java 9泛型和通用代码
- en: Imagine that we have develop a Web Service that has to work with the representation
    of the organization of a party of specific wild animals. We definitely don't want
    to mix lions with hyenas because the party would end up with the hyenas intimidating
    a lonely lion. We want a well-organized party, and we don't want intruders such
    as dragons or cats in a party where only lions should attend.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们开发了一个Web服务，必须使用特定野生动物聚会的组织表示。我们绝对不希望把狮子和鬣狗混在一起，因为聚会最终会以鬣狗吓唬一只孤狮而结束。我们希望一个组织有序的聚会，不希望有入侵者，比如龙或猫，出现在只有狮子应该参加的聚会中。
- en: We want to describe the procedures to start, welcome members, organize the party
    and say goodbye to the different members of the party. Then, we want to replicate
    these procedures with swans in a party of swans. Thus, we want to reuse our procedures
    for a party of lions and a party of swans. In the future, we will need to use
    the same procedures for parties of other wild and domestic animals, such as foxes,
    alligators, cats, tigers, and dogs. Obviously, we wouldn't like to become intruders
    in a party of alligators. Neither would we like to participate in the party of
    tigers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想描述启动程序、欢迎成员、组织聚会以及向聚会的不同成员道别的程序。然后，我们想在天鹅聚会中复制这些程序。因此，我们希望重用我们的程序来举办狮子聚会和天鹅聚会。将来，我们将需要使用相同的程序来举办其他野生动物和家养动物的聚会，比如狐狸、鳄鱼、猫、老虎和狗。显然，我们不希望成为鳄鱼聚会的入侵者。我们也不想参加老虎聚会。
- en: In the previous chapters, [Chapter 8](part0076_split_000.html#28FAO2-bc1530b4c4784270ae8a31a7038f8341
    "Chapter 8. Contract Programming with Interfaces"), *Contract Programming with
    Interfaces*, and [Chapter 9](part0083_split_000.html#2F4UM2-bc1530b4c4784270ae8a31a7038f8341
    "Chapter 9. Advanced Contract Programming with Interfaces"), *Advanced Contract
    Programming with Interfaces*, we learned to work with interfaces in Java 9\. We
    can declare an interface to specify the requirements for an animal that can participate
    in a party and then take advantage of Java 9 features to write generic code that
    works with any class that implements the interface.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，[第8章](part0076_split_000.html#28FAO2-bc1530b4c4784270ae8a31a7038f8341
    "第8章。接口的合同编程")，“使用接口进行合同编程”，和[第9章](part0083_split_000.html#2F4UM2-bc1530b4c4784270ae8a31a7038f8341
    "第9章。接口的高级合同编程")，“使用接口进行高级合同编程”，我们学习了如何在Java 9中使用接口。我们可以声明一个接口来指定可以参加聚会的动物的要求，然后利用Java
    9的特性编写通用代码，可以与实现接口的任何类一起使用。
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Parametric polymorphism** allows us to write generic and reusable code that
    can work with values without depending on the type while keeping the full static-type
    safety.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数多态**允许我们编写通用和可重用的代码，可以处理值而不依赖于类型，同时保持完全的静态类型安全。'
- en: We can take advantage of parametric polymorphism in Java 9 through generics,
    also known as generic programming. After we declare an interface that indicates
    the requirements for an animal that can participate in a party, we can create
    a class that works with any instance that implements this interface. This way,
    we can reuse the code that generates a party of lions and create a party of swans,
    hyenas, or any other animal. Specifically, we can reuse code that generates a
    party of any instance of a class that implements the interface that specifies
    the requirements for an animal that can participate in a party.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过泛型在Java 9中利用参数多态，也称为通用编程。在我们声明一个指示可以参加聚会的动物要求的接口之后，我们可以创建一个可以与实现此接口的任何实例一起使用的类。这样，我们可以重用生成狮子聚会的代码，并创建天鹅、鬣狗或任何其他动物的聚会。具体来说，我们可以重用生成任何实现指定可以参加聚会的动物要求的接口的类的聚会的代码。
- en: We require animals to be sociable in order to participate in a party, and therefore,
    we can create an interface named `Sociable` to specify the requirements for an
    animal that can participate in a party. However, take into account that many wild
    animals we will use as an example are not very sociable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求动物在聚会中要有社交能力，因此，我们可以创建一个名为`Sociable`的接口，来指定可以参加聚会的动物的要求。但要注意，我们将用作示例的许多野生动物并不太善于社交。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Many modern strongly typed programming languages allow us to work with parametric
    polymorphism through generics. If you have worked with C# or Swift, you will find
    that the syntax in Java 9 is very similar to the syntax used in these programming
    languages. C# also works with interfaces, but Swift uses protocols instead of
    interfaces.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代强类型编程语言允许我们通过泛型进行参数多态。如果你有使用过C#或Swift，你会发现Java 9的语法与这些编程语言中使用的语法非常相似。C#也使用接口，但Swift使用协议而不是接口。
- en: Other programming languages, such as Python, JavaScript, and Ruby, work with
    a different philosophy known as **duck typing**, where the presence of certain
    fields and methods make an object suitable to its usage as a specific sociable
    animal. With duck typing, if we require sociable animals to have the `getName`
    and `danceAlone` methods, we can consider any object as a sociable animal as long
    as it provides the required methods. Thus, with duck typing, any instance of any
    type that provides the required methods can be used as a sociable animal.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 其他编程语言，如Python、JavaScript和Ruby，采用一种称为**鸭子类型**的不同哲学，其中某些字段和方法的存在使对象适合于其用途作为特定的社交动物。使用鸭子类型，如果我们要求社交动物具有`getName`和`danceAlone`方法，只要对象提供了所需的方法，我们就可以将任何对象视为社交动物。因此，使用鸭子类型，任何提供所需方法的任何类型的实例都可以用作社交动物。
- en: Let's move to a real-life situation to understand the duck typing philosophy.
    Imagine that we see a bird and this bird quacks, swims, and walks like a duck.
    We can definitely call this bird a duck because it satisfies all the conditions
    required for this bird to be a duck. Similar examples related to a bird and a
    duck generate the duck typing name. We don't need additional information to work
    with the bird as a duck. Python, JavaScript, and Ruby are examples of languages
    where duck typing is extremely popular.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个真实的情况，以理解鸭子类型的哲学。想象一下，我们看到一只鸟，这只鸟嘎嘎叫、游泳和走路都像一只鸭子。我们肯定可以称这只鸟为鸭子，因为它满足了这只鸟被称为鸭子所需的所有条件。与鸟和鸭子相关的类似例子产生了鸭子类型的名称。我们不需要额外的信息来将这只鸟视为鸭子。Python、JavaScript和Ruby是鸭子类型极为流行的语言的例子。
- en: It is possible to work with duck typing in Java 9, but it is not the natural
    way of doing things in this programming language. It would require many complex
    workarounds to implement duck typing in Java 9\. Thus, we will focus on learning
    to write generic code with parametric polymorphism through generics.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中可以使用鸭子类型，但这不是这种编程语言的自然方式。在Java 9中实现鸭子类型需要许多复杂的解决方法。因此，我们将专注于学习通过泛型实现参数多态性的通用代码编写。
- en: Declaring an interface to be used as a type constraint
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明一个接口用作类型约束
- en: 'First, we will create a `Sociable` interface to specify the requirements that
    a type must meet in order to be considered a potential member of a party, that
    is, a sociable animal in our application domain. Then, we will create a `SociableAnimal`
    abstract base class that implements this interface, and then, we will specialize
    this class in three concrete subclasses: `SocialLion`, `SocialParrot`, and `SocialSwan`.
    Then, we will create a `Party` class that will be able to work with instances
    of any class that implements the `Sociable` interface through generics. We will
    create two new classes that will represent specific exceptions. We will work with
    a party of sociable lions, one of sociable parrots, and another of sociable swans.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个`Sociable`接口，以指定类型必须满足的要求，才能被视为潜在的聚会成员，也就是我们应用领域中的社交动物。然后，我们将创建一个实现了这个接口的`SociableAnimal`抽象基类，然后，我们将在三个具体的子类中专门化这个类：`SocialLion`、`SocialParrot`和`SocialSwan`。然后，我们将创建一个`Party`类，它将能够通过泛型与实现`Sociable`接口的任何类的实例一起工作。我们将创建两个新的类，它们将代表特定的异常。我们将处理一群社交狮子、一群社交鹦鹉和一群社交天鹅。
- en: 'The following UML diagram shows the interface, the abstract class that implements
    it, and the concrete subclasses that we will create, including all the fields
    and meth:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的UML图显示了接口，实现它的抽象类，以及我们将创建的具体子类，包括所有的字段和方法：
- en: '![Declaring an interface to be used as a type constraint](img/00089.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![声明一个接口用作类型约束](img/00089.jpeg)'
- en: The following lines show the code for the `Sociable` interface. The code file
    for the sample is included in the `java_9_oop_chapter_10_01` folder, in the `example10_01.java`
    file.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行显示了`Sociable`接口的代码。示例的代码文件包含在`java_9_oop_chapter_10_01`文件夹中的`example10_01.java`文件中。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The interface declares the following nine method requirements:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接口声明了以下九个方法要求：
- en: '`getName`: This method must return a `String` with the name for `Sociable`.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getName`：这个方法必须返回一个`String`，表示`Sociable`的名字。'
- en: '`getAge`: This method must return an `int` with the age for `Sociable`.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAge`：这个方法必须返回一个`int`，表示`Sociable`的年龄。'
- en: '`actAlone`: This method must make `Sociable` act alone.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actAlone`：这个方法必须让`Sociable`独自行动。'
- en: '`danceAlone`: This method must make `Sociable` dance alone.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`danceAlone`：这个方法必须让`Sociable`独自跳舞。'
- en: '`danceWith`: This method must make `Sociable` dance with another `Sociable`
    received in the partner argument.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`danceWith`：这个方法必须让`Sociable`与另一个在partner参数中接收到的`Sociable`一起跳舞。'
- en: '`singALyric`: This method must make `Sociable` sing the lyric received as an
    argument.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`singALyric`：这个方法必须让`Sociable`唱接收到的歌词。'
- en: '`speak`: This method makes `Sociable` say a message.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`speak`：这个方法让`Sociable`说一条消息。'
- en: '`welcome`: This method makes `Sociable` say a welcome message to another `Sociable`
    received in the other argument.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`welcome`：这个方法让`Sociable`向另一个在其他参数中接收到的`Sociable`说欢迎的消息。'
- en: '`sayGoodbyeTo`: This method makes `Sociable` say goodbye to another `Sociable`
    received in the other argument.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sayGoodbyeTo`：这个方法让`Sociable`向另一个在其他参数中接收到的`Sociable`说再见。'
- en: We didn't include any default method in the interface declaration, and therefore,
    the classes that implement the `Sociable` interface are responsible for implementing
    the previously enumerated nine methods.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在接口声明中包含任何默认方法，因此实现`Sociable`接口的类负责实现之前列举的九个方法。
- en: Declaring a class that conforms to multiple interfaces
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明符合多个接口的类
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`actAlone`: This method prints the name followed by `"to be or not to be"`.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actAlone`：这个方法打印名字，后面跟着"to be or not to be"。'
- en: '`danceAlone`: This method uses the `String` retrieved with a call to the `getDanceRepresentation`
    method to print the name followed by a message indicating that the social animal
    is dancing.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`danceAlone`：这个方法使用调用`getDanceRepresentation`方法检索到的`String`来打印名字，后面跟着指示社交动物正在跳舞的消息。'
- en: '`danceWith`: This method uses the `String` retrieved with a call to the `getDanceRepresentation`
    method to print the name followed by a message indicating that the social animal
    is dancing with the partner specified in the partner argument of the `Sociable`
    type. The message prints the name for the partner.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`danceWith`：此方法使用调用`getDanceRepresentation`方法获取的`String`来打印名称，然后是一条消息，指示社交动物正在与`Sociable`类型的partner参数指定的伙伴一起跳舞。消息中包括伙伴的名称。'
- en: '`singALyric`: This method uses the strings retrieved with calls to `getFirstSoundInWords`,
    `getSecondSoundInWords`, and `getThirdSoundInWords` and the lyric received as
    an argument to print the name followed by a message indicating that the social
    animal sings the lyric.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`singALyric`：此方法使用调用`getFirstSoundInWords`、`getSecondSoundInWords`和`getThirdSoundInWords`获取的字符串以及作为参数接收到的歌词来打印名称，然后是一条消息，指示社交动物唱出歌词。'
- en: '`speak`: This method uses the `String` retrieved with a call to `getDanceRepresentation`
    and the message received as an argument to print the name followed by the words
    that the animal says followed by its dance representation characters.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`speak`：此方法使用调用`getDanceRepresentation`获取的`String`和作为参数接收到的消息来打印名称，然后是动物说的话，再接着是它的舞蹈表示字符。'
- en: '`welcome`: This method prints a message to say welcome to another `Sociable`
    received in the other argument. The message includes the name for the destination.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`welcome`：此方法打印一条消息，欢迎另一个在其他参数中接收到的`Sociable`。消息包括目的地的名称。'
- en: '`sayGoodbyeTo`: This method uses the strings retrieved with calls to `getFirstSoundInWords`,
    `getSecondSoundInWords`, and `getThirdSoundInWords` and to build and print a message
    to say goodbye to another `Sociable` received in the other argument. The message
    includes the name for the destination.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sayGoodbyeTo`：此方法使用调用`getFirstSoundInWords`、`getSecondSoundInWords`和`getThirdSoundInWords`获取的字符串来构建并打印一条消息，向其他参数中接收到的另一个`Sociable`说再见。消息包括目的地的名称。'
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, the code checks whether the received `Object` is a reference to the actual
    instance. In this case, the code returns `true` and nothing else has to be checked.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码检查接收到的`Object`是否是对实际实例的引用。在这种情况下，代码返回`true`，不需要再进行其他检查。
- en: Then, the code checks whether the value for `other` is equal to `null`. In case
    the method received `null`, the code returns `false` because the actual instance
    is not `null`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码检查`other`的值是否等于`null`。如果方法接收到`null`，则代码返回`false`，因为实际实例不是`null`。
- en: Then, the code checks whether the `String` returned by the `getClass` method
    for the actual instance matches the `String` returned by the same method for the
    received instance. If these values do not match, it means that the received `Object`
    is an instance of a different type, and therefore, it is different and the code
    returns `false`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码检查实际实例的`getClass`方法返回的`String`是否与接收到的实例的相同方法返回的`String`匹配。如果这些值不匹配，则表示接收到的`Object`是不同类型的实例，因此不同，代码返回`false`。
- en: At this point, we know that the actual instance has the same type as the received
    instance. Thus, it is safe to typecast the other argument to `SocialAnimal` and
    save the casted reference in the `otherSocialAnimal` local variable of the `SocialAnimal`
    type.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们知道实际实例与接收到的实例具有相同的类型。因此，可以安全地将其他参数强制转换为`SocialAnimal`，并将转换后的引用保存在`SocialAnimal`类型的`otherSocialAnimal`局部变量中。
- en: Finally, the code returns the results of evaluating whether the calls to `Object.equals`
    for `getName` and `getAge` for the current instance and `otherSocialAnimal` are
    both `true`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码返回评估当前实例和`otherSocialAnimal`的`getName`和`getAge`的`Object.equals`调用的结果是否都为`true`。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is a good practice to follow the previously explained steps when we override
    the `equals` method inherited from `java.lang.Object`. In case you have experience
    with C#, it is important to understand that Java 9 doesn't provide an equivalent
    to the `IEquatable<T>` interface. In addition, take into account that Java doesn't
    support user-defined operator overloading, a feature that is included in other
    object-oriented programming languages such as C++, C#, and Swift.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重写从`java.lang.Object`继承的`equals`方法时，遵循先前解释的步骤是一个好习惯。如果您有C#的经验，重要的是要了解Java
    9没有提供与`IEquatable<T>`接口等效的内容。此外，请注意，Java不支持用户定义的运算符重载，这是其他面向对象编程语言（如C++、C#和Swift）中包含的功能。
- en: 'The `SocialAnimal` abstract class also implements the `compareTo` method required
    by the `Comparable<Sociable>` interface. In this case, the code is very simple
    because the method receives a `Sociable` instance in the `otherSociable` argument
    and returns the results of calling the `Integer.compare` method, that is, the
    `compare` class method for the `java.lang.Integer` class. The code calls this
    method with the `int` values returned by `getAge` for the current instance and
    `otherSociable` as the two arguments. The `Integer.compare` method returns the
    following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`SocialAnimal`抽象类还实现了`Comparable<Sociable>`接口所需的`compareTo`方法。在这种情况下，代码非常简单，因为该方法在`otherSociable`参数中接收到一个`Sociable`实例，并返回调用`Integer.compare`方法的结果，即`java.lang.Integer`类的`compare`类方法。代码使用当前实例的`getAge`返回的`int`值和`otherSociable`作为两个参数调用此方法。`Integer.compare`方法返回以下结果：'
- en: '`0` if the first argument is equal to the second one.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个参数等于第二个参数，则为`0`。
- en: Less than `0` if the first argument is lower than the second one.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个参数小于第二个参数，则小于`0`。
- en: Greater than `0` if the first argument is greater than the second one.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个参数大于第二个参数，则大于`0`。
- en: All the concrete subclasses that inherit from `SocialAnimal` will be able to
    use the `equals` and `compareTo` methods implemented in the `SocialAnimal` abstract
    class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有继承自`SocialAnimal`的具体子类都将能够使用`SocialAnimal`抽象类中实现的`equals`和`compareTo`方法。
- en: Declaring subclasses that inherit the implementation of interfaces
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明继承接口实现的子类
- en: We have the `SocialAnimal` abstract class that implements both the `Sociable`
    and `Comparable<Sociable>` interfaces. We cannot create instances of this abstract
    class. Now, we will create a concrete subclass of `SocialAnimal` named `SocialLion`.
    The class declares a constructor that ends up calling the constructor defined
    in the superclass. The class implements the four abstract methods declared in
    its superclass to return the appropriate values for a lion that will participate
    in a party. The code file for the sample is included in the `java_9_oop_chapter_10_01`
    folder, in the `example10_01.java` file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个抽象类`SocialAnimal`，它实现了`Sociable`和`Comparable<Sociable>`接口。我们不能创建这个抽象类的实例。现在，我们将创建`SocialAnimal`的一个具体子类，名为`SocialLion`。这个类声明了一个构造函数，最终调用了超类中定义的构造函数。该类实现了其超类中声明的四个抽象方法，以返回适合参加派对的狮子的适当值。示例的代码文件包含在`java_9_oop_chapter_10_01`文件夹中的`example10_01.java`文件中。
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We will create another concrete subclass of `SocialAnimal` named `SocialParrot`.
    This new subclass also implements the abstract methods defined in the `SocialAnimal`
    superclass but, in this case, returns the appropriate values for a parrot. The
    code file for the sample is included in the `java_9_oop_chapter_10_01` folder,
    in the `example10_01.java` file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建另一个名为`SocialParrot`的`SocialAnimal`的具体子类。这个新的子类也实现了`SocialAnimal`超类中定义的抽象方法，但在这种情况下，返回了鹦鹉的适当值。示例的代码文件包含在`java_9_oop_chapter_10_01`文件夹中的`example10_01.java`文件中。
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally, we will create another concrete subclass of `SocialAnimal` named `SocialSwan`.
    This new subclass also implements the abstract methods defined in the `SocialAnimal`
    superclass but, in this case, returns the appropriate values for a swan. The code
    file for the sample is included in the `java_9_oop_chapter_10_01` folder, in the
    `example10_01.java` file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建另一个名为`SocialSwan`的`SocialAnimal`的具体子类。这个新的子类也实现了`SocialAnimal`超类中定义的抽象方法，但在这种情况下，返回了天鹅的适当值。示例的代码文件包含在`java_9_oop_chapter_10_01`文件夹中的`example10_01.java`文件中。
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have three concrete classes that inherit the implementation of two interfaces
    from its abstract superclass: `SociableAnimal`. The following three concrete classes
    implement both the `Sociable` and `Comparable<Sociable>` interfaces, and they
    can use the inherited overridden `equals` method to compare their instances:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个具体类，它们继承了两个接口的实现，这两个接口来自它们的抽象超类`SociableAnimal`。以下三个具体类都实现了`Sociable`和`Comparable<Sociable>`接口，并且它们可以使用继承的重写的`equals`方法来比较它们的实例：
- en: '`SocialLion`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SocialLion`'
- en: '`SocialParrot`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SocialParrot`'
- en: '`SocialSwan`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SocialSwan`'
- en: Creating exception classes
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建异常类
- en: We will create two exception classes because we need to throw exception types
    that aren't represented by any of the types included in the Java 9 platform. Specifically,
    we will create two subclasses of the `java.lang.Exception` class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个异常类，因为我们需要抛出Java 9平台中没有表示的异常类型。具体来说，我们将创建`java.lang.Exception`类的两个子类。
- en: The following lines declare the `InsufficientMembersException` class that inherits
    from `Exception`. We will throw this exception when a party has an insufficient
    number of members to perform an operation that requires more members to be executed.
    The class defines an immutable `numberOfMembers` private field of the `int` type
    that is initialized with the value received in the constructor. In addition, the
    class declares a `getNumberOfMembers` method that returns the value for this field.
    The code file for the sample is included in the `java_9_oop_chapter_10_01` folder,
    in the `example10_01.java` file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`InsufficientMembersException`类，它继承自`Exception`。当一个派对的成员数量不足以执行需要更多成员的操作时，我们将抛出这个异常。该类定义了一个不可变的`numberOfMembers`私有字段，类型为`int`，它在构造函数中初始化为接收到的值。此外，该类声明了一个`getNumberOfMembers`方法，返回这个字段的值。示例的代码文件包含在`java_9_oop_chapter_10_01`文件夹中的`example10_01.java`文件中。
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The following lines declare the `CannotRemovePartyLeaderException` class that
    inherits from `Exception`. We will throw this exception when a method tries to
    remove the current party leader from the party's member list. In this case, we
    just declare an empty class that inherits from `Exception` because we don't need
    additional features, we just want the new type. The code file for the sample is
    included in the `java_9_oop_chapter_10_01` folder, in the `example10_01.java`
    file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`CannotRemovePartyLeaderException`类，它继承自`Exception`。当一个方法试图从派对成员列表中移除当前的派对领袖时，我们将抛出这个异常。在这种情况下，我们只声明了一个继承自`Exception`的空类，因为我们不需要额外的功能，我们只需要新的类型。示例的代码文件包含在`java_9_oop_chapter_10_01`文件夹中的`example10_01.java`文件中。
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Declaring a class that works with a constrained generic type
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明一个与受限泛型类型一起工作的类
- en: The following lines declare a `Party` class that takes advantage of generics
    to work with many types. We import `java.util.concurrent.ThreadLocalRandom` because
    it is an extremely useful class to easily generate a pseudo-random number within
    a range. The class name, `Party`, is followed by a less than sign (`<`), a `T`
    that identifies the generic type parameter, the `extends` keyword, and an interface
    name that the `T` generic type parameter must implement, `Sociable`, an ampersand
    (`&`), and another interface name that the `T` generic type must also implement,
    `Comparable<Sociable>`. The greater than sign (`>`) ends the type constraint declaration
    that is included within angle brackets (`<>`). Thus, the `T` generic type parameter
    has to be a type that must implement both the `Sociable` and `Comparable<Sociable>`
    interfaces. The following code highlights the lines that use the `T` generic type
    parameter. The code file for the sample is included in the `java_9_oop_chapter_10_01`
    folder, in the `example10_01.java` file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了一个`Party`类，利用泛型来处理多种类型。 我们导入`java.util.concurrent.ThreadLocalRandom`，因为它是一个非常有用的类，可以轻松地在范围内生成伪随机数。
    类名`Party`后面跟着一个小于号(`<`)，一个标识泛型类型参数的`T`，`extends`关键字，以及`T`泛型类型参数必须实现的接口名称`Sociable`，一个和号(`&`)，以及`T`泛型类型必须实现的另一个接口名称`Comparable<Sociable>`。
    大于号(`>`)结束了包含在尖括号(`<>`)中的类型约束声明。 因此，`T`泛型类型参数必须是一个既实现`Sociable`接口又实现`Comparable<Sociable>`接口的类型。
    以下代码突出显示了使用`T`泛型类型参数的行。 示例的代码文件包含在`java_9_oop_chapter_10_01`文件夹中的`example10_01.java`文件中。
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now we will analyze many code snippets to understand how the code included in
    the `Party<T>` class works. The following line starts the class body, declares
    a protected `List<T>`, that is, a `List` of elements whose type is `T` or implements
    the `T` interface. `List` uses generics to specify the type of the elements that
    will be accepted and added to the list.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将分析许多代码片段，以了解包含在`Party<T>`类中的代码是如何工作的。 以下行开始了类体，声明了一个受保护的`List<T>`，即元素类型为`T`或实现`T`接口的元素列表。
    `List`使用泛型来指定将被接受和添加到列表中的元素的类型。
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following line declares a protected `partyLeader` field whose type is `T`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了一个受保护的`partyLeader`字段，其类型为`T`：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The following lines declare a constructor that receives a `partyLeader` argument
    whose type is `T`. The argument specifies the first party leader and also the
    first member of the party, that is, the first element added to the `membersList<T>`.
    The code that creates a new `ArrayList<T>` takes advantage of type inference that
    was introduced with Java 7, improved in Java 8, and persists in Java 9\. We specify
    `new ArrayList<>()` instead of `new` `ArrayList<T>()` because Java 9 can use the
    empty set of type parameters (`<>`) to infer the type arguments from the context.
    The `members` protected field has a `List<T>` type, and therefore, Java's type
    inference can determine that `T` is the type and that `ArrayList<>()` means `ArrayList<T>()`.
    The last line adds the `partyLeader` to the `members` list.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了一个接收`partyLeader`参数的构造函数，其类型为`T`。 该参数指定了第一位党领导者，也是党的第一位成员，即添加到`membersList<T>`的第一个元素。
    创建新的`ArrayList<T>`的代码利用了Java 7中引入的类型推断，Java 8中改进，并在Java 9中保留。 我们指定`new ArrayList<>()`而不是`new`
    `ArrayList<T>()`，因为Java 9可以使用空类型参数集(`<>`)从上下文中推断出类型参数。 `members`受保护字段具有`List<T>`类型，因此，Java的类型推断可以确定`T`是类型，并且`ArrayList<>()`意味着`ArrayList<T>()`。
    最后一行将`partyLeader`添加到`members`列表中。
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When we invoke the constructor of a generic class with an empty set of type
    parameters, the pair of angle brackets (`<>`) is known as the **diamond**, and
    the notation is named **diamond notation**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用空类型参数集调用泛型类的构造函数时，尖括号(`<>`)被称为**diamond**，并且该表示法称为**diamond notation**。
- en: The following lines declare the `getPartyLeader` method that specifies `T` as
    the return type. The method returns `partyLeader`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`getPartyLeader`方法，指定`T`作为返回类型。 该方法返回`partyLeader`。
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following lines declare the `addMember` method that receives a `newMember`
    argument whose type is `T`. The code adds the new member received as an argument
    to the `members` list and calls the `partyLeader.sayWelcomeTo` method with `newMember`
    as an argument to make the party leader welcome the new member:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`addMember`方法，该方法接收一个类型为`T`的`newMember`参数。 该代码将接收到的新成员添加到`members`列表中，并调用`partyLeader.sayWelcomeTo`方法，将`newMember`作为参数，使得党领导者欢迎新成员：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The following lines declare the `removeMember` method that receives a `memberToRemove`
    argument whose type is `T`, returns `T`, and can throw a `CannotRemovePartyLeaderException`
    exception. The `throws` keyword after the method arguments followed by the exception
    name indicates that the method can throw the specified exception. The code checks
    whether the member to be removed matches the party leader with the help of the
    `equals` method. The method throws a `CannotRemovePartyLeaderException` exception
    in case the member is the party leader. The code retrieves the index for `memberToRemove`
    in the list and calls the `members.remove` method with `memberToRemove` as an
    argument in case it was a member of the list. Then, the code calls the `sayGoodbyeTo`
    method for the successfully removed member with `partyLeader` as an argument.
    This way, the member that leaves the party says goodbye to the party leader. In
    case the member is removed, the method returns the removed member. Otherwise,
    the method returns `null`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`removeMember`方法，该方法接收一个类型为`T`的`memberToRemove`参数，返回`T`，并且可能抛出`CannotRemovePartyLeaderException`异常。
    方法参数后面的`throws`关键字，后跟异常名称，表示该方法可以抛出指定的异常。 代码检查要移除的成员是否与党领导者匹配，使用`equals`方法进行检查。
    如果成员是党领导者，则该方法抛出`CannotRemovePartyLeaderException`异常。 代码检索列表中`memberToRemove`的索引，并在该成员是列表成员的情况下调用`members.remove`方法，参数为`memberToRemove`。
    然后，代码调用成功移除成员的`sayGoodbyeTo`方法，参数为`partyLeader`。 这样，离开党的成员向党领导者道别。 如果成员被移除，则该方法返回被移除的成员。
    否则，该方法返回`null`。
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following lines declare the `makeMembersAct` method that calls the `actAlone`
    method for each member of the `members` list:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`makeMembersAct`方法，该方法调用`members`列表中每个成员的`actAlone`方法：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the forthcoming chapters, we will learn other ways of coding the same method
    that performs an action for each member of a list because we will mix object-oriented
    programming with functional programming in Java 9.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习在Java 9中将面向对象编程与函数式编程相结合的其他编码方法，以执行列表中每个成员的操作。
- en: 'The following lines declare the `makeMembersDance` method that calls the `danceAlone`
    method for each member of the `members` list:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`makeMembersDance`方法，该方法调用`members`列表中每个成员的`danceAlone`方法：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following lines declare the `makeMembersSingALyric` method that receives
    a `lyricString` and calls the `singALyric` method with the received `lyric` as
    an argument for each member of the `members` list:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`makeMembersSingALyric`方法，该方法接收一个`lyricString`并调用`members`列表中每个成员的`singALyric`方法，参数为接收到的`lyric`：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Notice that methods are not marked as final, and therefore, we will be able
    to override these methods in a future subclass.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，方法没有标记为final，因此，我们将能够在将来的子类中重写这些方法。
- en: Finally, the following lines declare the `declareNewPartyLeader` method that
    can throw an `InsufficientMembersException`. As it happened with the `removeMember`
    method, the `throws` keyword after the method arguments followed by `InsufficientMembersException`
    indicates that the method can throw an `InsufficientMembersException` exception.
    In case we have just one member in the members list, the code throws an `InsufficientMembersException`
    exception and uses the value returned from `members.size()` to create the instance
    of the class that inherits from `Exception`. Remember that this exception class
    uses this value to initialize a field and the code that calls this method will
    be able to retrieve the number of members that is insufficient. If we have at
    least two members, the code generates a new pseudo-random party leader that is
    different from the existing one. The code uses `ThreadLocalRandom.current().nextInt`
    to generate a pseudo-random `int` number within a range. The code calls the `speak`
    method for the actual leader to make it explain to the other party members that
    they have a new party leader. The code calls the `danceWith` method for the new
    leader with the previous party leader as an argument. If the result of calling
    the `newPartyLeader.compareTo` method with the previous party leader as an argument
    returns less than `0`, it means that the new party leader is younger than the
    previous one and the code calls the `newPartyLeader.danceAlone` method. Finally,
    the code sets the new value to the `partyLeader` field.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下行声明了`declareNewPartyLeader`方法，该方法可能会抛出`InsufficientMembersException`。与`removeMember`方法一样，方法参数后的`throws`关键字后跟着`InsufficientMembersException`表示该方法可能会抛出`InsufficientMembersException`异常。如果`members`列表中只有一个成员，代码将抛出`InsufficientMembersException`异常，并使用从`members.size()`返回的值创建继承自`Exception`的类的实例。请记住，此异常类使用此值初始化一个字段，调用此方法的代码将能够检索到不足的成员数量。如果至少有两个成员，代码将生成一个新的伪随机党领袖，与现有的不同。代码使用`ThreadLocalRandom.current().nextInt`生成一个伪随机的`int`范围内的数字。代码调用`speak`方法让现任领袖向其他党员解释他们有了新的党领袖。代码调用`danceWith`方法，让新领袖与前任党领袖一起跳舞。如果调用`newPartyLeader.compareTo`方法与前任党领袖作为参数返回小于`0`，则意味着新的党领袖比前任年轻，代码将调用`newPartyLeader.danceAlone`方法。最后，代码将新值设置为`partyLeader`字段。
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using a generic class for multiple compatible types
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通用类处理多个兼容类型
- en: 'We can create instances of the `Party<T>` class by replacing the `T` generic
    type parameter with any type name that adapts to the type constraints specified
    in the declaration of the `Party<T>` class. So far, we have three concrete classes
    that implement both the `Sociable` and `Comparable<Sociable>` interfaces: `SocialLion`,
    `SocialParrot`, and `SocialSwan`. Hence, we can use `SocialLion` to create an
    instance of `Party<SocialLion>`, that is, a `Party` of `SocialLion`. We take advantage
    of type inference and we use the previously explained diamond notation. This way,
    we will create a party of lions, and `Simba` is the party leader. The code file
    for the sample is included in the `java_9_oop_chapter_10_01` folder, in the `example10_01.java`
    file.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`T`通用类型参数替换为符合`Party<T>`类声明中指定的类型约束的任何类型名称来创建`Party<T>`类的实例。到目前为止，我们有三个实现了`Sociable`和`Comparable<Sociable>`接口的具体类：`SocialLion`、`SocialParrot`和`SocialSwan`。因此，我们可以使用`SocialLion`来创建`Party<SocialLion>`的实例，即`SocialLion`的派对。我们利用类型推断，并使用先前解释的菱形符号。这样，我们将创建一个狮子派对，而`Simba`是党领袖。示例的代码文件包含在`java_9_oop_chapter_10_01`文件夹中的`example10_01.java`文件中。
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `lionsParty` instance will only accept a `SocialLion` instance for all the
    arguments in which the class definition uses the generic type parameter named
    `T`. The following lines add the previously created three instances of `SocialLion`
    to the lions' party by calling the `addMember` method for each instance. The code
    file for the sample is included in the `java_9_oop_chapter_10_01` folder, in the
    `example10_01.java` file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`lionsParty`实例将仅接受`SocialLion`实例，其中类定义使用名为`T`的通用类型参数。以下行通过调用`addMember`方法为狮子派对添加了先前创建的三个`SocialLion`实例。示例的代码文件包含在`java_9_oop_chapter_10_01`文件夹中的`example10_01.java`文件中。'
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The following lines call the `makeMembersAct` method to make all the lions act,
    call the `makeMembersDance` method to make all the lions dance, use the `removeMember`
    method to remove a member that isn't the party leader, use the `declareNewPartyLeader`
    method to declare a new leader, and finally call the `makeMembersSingALyric` method
    to make all the lions sing. We will add the `try` keyword before the calls to
    `removeMember` and `declareNewPartyLeader` because these methods can throw exceptions.
    In this case, we don't check the result returned by `removeMember`. The code file
    for the sample is included in the `java_9_oop_chapter_10_01` folder, in the `example10_01.java`
    file.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行调用`makeMembersAct`方法使所有狮子行动，调用`makeMembersDance`方法使所有狮子跳舞，使用`removeMember`方法删除不是派对领袖的成员，使用`declareNewPartyLeader`方法声明一个新领袖，最后调用`makeMembersSingALyric`方法使所有狮子唱歌。我们将在调用`removeMember`和`declareNewPartyLeader`之前添加`try`关键字，因为这些方法可能会抛出异常。在这种情况下，我们不检查`removeMember`返回的结果。示例的代码文件包含在`java_9_oop_chapter_10_01`文件夹中的`example10_01.java`文件中。
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following lines show the output after we run the preceding code snippets
    in JShell. However, we must take into account that there is a pseudo-random selection
    of the new party leader, and therefore, the results will vary in each execution:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了在JShell中运行前面的代码片段后的输出。但是，我们必须考虑到新派对领袖的伪随机选择，因此结果在每次执行时会有所不同：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can use `SocialParrot` to create an instance of `Party<SocialParrot>`, that
    is, a `Party` of `SocialParrot`. We use the previously explained diamond notation.
    This way, we will create a party of parrots, and `Rio` is the party leader. The
    code file for the sample is included in the `java_9_oop_chapter_10_01` folder,
    in the `example10_01.java` file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`SocialParrot`创建`Party<SocialParrot>`的实例，即`SocialParrot`的`Party`。我们使用先前解释的菱形符号。这样，我们将创建一个鹦鹉派对，`Rio`是派对领袖。示例的代码文件包含在`java_9_oop_chapter_10_01`文件夹中的`example10_01.java`文件中。
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `parrotsParty` instance will only accept a `SocialParrot` instance for all
    the arguments in which the class definition uses the generic type parameter named
    `T`. The following lines add the previously created three instances of `SocialParrot`
    to the parrots' party by calling the `addMember` method for each instance. The
    code file for the sample is included in the `java_9_oop_chapter_10_01` folder,
    in the `example10_01.java` file.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`parrotsParty`实例将仅接受`SocialParrot`实例，用于类定义使用名为`T`的泛型类型参数的所有参数。以下行通过为每个实例调用`addMember`方法，将先前创建的三个`SocialParrot`实例添加到鹦鹉派对中。示例的代码文件包含在`java_9_oop_chapter_10_01`文件夹中的`example10_01.java`文件中。'
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The following lines call the `makeMembersDance` method to make all the parrots
    dance, use the `removeMember` method to remove a member that isn't the party leader,
    use the `declareNewPartyLeader` method to declare a new leader, and finally call
    the `makeMembersSingALyric` method to make all the parrots sing. The code file
    for the sample is included in the `java_9_oop_chapter_10_01` folder, in the `example10_01.java`
    file.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行调用`makeMembersDance`方法使所有鹦鹉跳舞，使用`removeMember`方法删除不是派对领袖的成员，使用`declareNewPartyLeader`方法声明一个新领袖，最后调用`makeMembersSingALyric`方法使所有鹦鹉唱歌。示例的代码文件包含在`java_9_oop_chapter_10_01`文件夹中的`example10_01.java`文件中。
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following lines show the output after we run the preceding code snippets
    in JShell. Again, we must take into account that there is a pseudo-random selection
    of the new party leader, and therefore, the results will vary in each execution:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了在JShell中运行前面的代码片段后的输出。再次，我们必须考虑到新派对领袖的伪随机选择，因此结果在每次执行时会有所不同：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The following lines will fail to compile because we use incompatible types.
    First, we try to add a `SocialParrot` instance, `rio`, to the `Party<SocialLion>`,
    `lionsParty`. Then, we try to add a `SocialLion` instance, `simba`, to the `Party<SocialParrot>`,
    `parrotsParty`. Both lines will fail to compile and JShell will display a message
    indicating that the types are incompatible and they cannot be converted to the
    necessary type required by each party. The code file for the sample is included
    in the `java_9_oop_chapter_10_01` folder, in the `example10_02.java` file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将无法编译，因为我们使用了不兼容的类型。首先，我们尝试将`SocialParrot`实例`rio`添加到`Party<SocialLion>`的`lionsParty`。然后，我们尝试将`SocialLion`实例`simba`添加到`Party<SocialParrot>`的`parrotsParty`。这两行都将无法编译，并且JShell将显示一条消息，指示类型不兼容，它们无法转换为每个派对所需的必要类型。示例的代码文件包含在`java_9_oop_chapter_10_01`文件夹中的`example10_02.java`文件中。
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following screenshot shows the errors displayed in JShell when we try to
    execute the previous lines:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在我们尝试执行前面的行时JShell中显示的错误：
- en: '![Using a generic class for multiple compatible types](img/00090.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![使用泛型类处理多个兼容类型](img/00090.jpeg)'
- en: We can use `SocialSwan` to create an instance of `Party<SocialSwan>`, that is,
    a `Party` of `SocialSwan`. This way, we will create a party of swans, and `Kevin`
    is the party leader. The code file for the sample is included in the `java_9_oop_chapter_10_01`
    folder, in the `example10_03.java` file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`SocialSwan`创建`Party<SocialSwan>`的实例，即`SocialSwan`的`Party`。这样，我们将创建一个天鹅派对，`Kevin`是派对领袖。示例的代码文件包含在`java_9_oop_chapter_10_01`文件夹中的`example10_03.java`文件中。
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `swansParty` instance will only accept a `SocialSwan` instance for all the
    arguments in which the class definition uses the generic type parameter named
    `T`. The following lines add the previously created two instances of `SocialSwan`
    to the swans' party by calling the `addMember` method for each instance. The code
    file for the sample is included in the `java_9_oop_chapter_10_01` folder, in the
    `example10_03.java` file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`swansParty`实例将仅接受`SocialSwan`实例，用于类定义使用名为`T`的泛型类型参数的所有参数。以下行通过为每个实例调用`addMember`方法，将先前创建的两个`SocialSwan`实例添加到天鹅派对中。示例的代码文件包含在`java_9_oop_chapter_10_01`文件夹中的`example10_03.java`文件中。'
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The following lines call the `makeMembersDance` method to make all the parrots
    dance, use the `removeMember` method to try to remove the party leader, use the
    `declareNewPartyLeader` method to declare a new leader, and finally call the `makeMembersSingALyric`
    method to make all the swans sing. The code file for the sample is included in
    the `java_9_oop_chapter_10_01` folder, in the `example10_03.java` file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行调用`makeMembersDance`方法使所有鹦鹉跳舞，使用`removeMember`方法尝试移除党领袖，使用`declareNewPartyLeader`方法宣布新领袖，最后调用`makeMembersSingALyric`方法使所有天鹅唱歌。示例的代码文件包含在`java_9_oop_chapter_10_01`文件夹中的`example10_03.java`文件中。
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following lines show the output after we run the preceding code snippets
    in JShell. Again, we must take into account that there is a pseudo-random selection
    of the new party leader, and therefore, the results will vary in each execution:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了在JShell中运行前面的代码片段后的输出。再次，我们必须考虑到新的党领袖是伪随机选择的，因此，结果在每次执行时都会有所不同：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Test your knowledge
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'The `public class Party<T extends Sociable & Comparable<Sociable>>` line means:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public class Party<T extends Sociable & Comparable<Sociable>>`行的意思是：'
- en: The generic type constraint specifies that `T` must implement either the `Sociable`
    or `Comparable<Sociable>` interfaces.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型类型约束指定`T`必须实现`Sociable`或`Comparable<Sociable>`接口之一。
- en: The generic type constraint specifies that `T` must implement both the `Sociable`
    and `Comparable<Sociable>` interfaces.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型类型约束指定`T`必须实现`Sociable`和`Comparable<Sociable>`接口。
- en: The class is a subclass of both the `Sociable` and `Comparable<Sociable>` classes.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类是`Sociable`和`Comparable<Sociable>`类的子类。
- en: 'Which of the following lines is equivalent to `List<SocialLion> lionsList =
    new ArrayList<SocialLion>();` in Java 9:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪行与Java 9中的`List<SocialLion> lionsList = new ArrayList<SocialLion>();`等效：
- en: '`List<SocialLion> lionsList = new ArrayList();`'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`List<SocialLion> lionsList = new ArrayList();`'
- en: '`List<SocialLion> lionsList = new ArrayList<>();`'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`List<SocialLion> lionsList = new ArrayList<>();`'
- en: '`var lionsList = new ArrayList<SocialLion>();`'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var lionsList = new ArrayList<SocialLion>();`'
- en: 'Which of the following lines uses the diamond notation to take advantage of
    Java 9 type inference:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪行使用了钻石符号来利用Java 9的类型推断：
- en: '`List<SocialLion> lionsList = new ArrayList<>();`'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`List<SocialLion> lionsList = new ArrayList<>();`'
- en: '`List<SocialLion> lionsList = new ArrayList();`'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`List<SocialLion> lionsList = new ArrayList();`'
- en: '`var lionsList = new ArrayList<SocialLion>();`'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var lionsList = new ArrayList<SocialLion>();`'
- en: 'Java 9 allows us to work with parametric polymorphism through:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 9允许我们通过以下方式使用参数多态性：
- en: Duck typing.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鸭子打字。
- en: Rabbit typing.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 兔子打字。
- en: Generics.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型。
- en: 'Which of the following code snippets declares a class whose generic type constraint
    specifies that `T` must implement both the `Sociable` and `Convertible` interfaces:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个代码片段声明了一个类，其泛型类型约束指定`T`必须实现`Sociable`和`Convertible`接口：
- en: '`public class Game<T extends Sociable & Convertible>`'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public class Game<T extends Sociable & Convertible>`'
- en: '`public class Game<T: where T is Sociable & Convertible>`'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public class Game<T: where T is Sociable & Convertible>`'
- en: '`public class Game<T extends Sociable> where T: Convertible`'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public class Game<T extends Sociable> where T: Convertible`'
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned to maximize code reuse by writing code capable
    of working with objects of different types, that is, instances of classes that
    implement specific interfaces or whose class hierarchies include specific superclasses.
    We worked with interfaces, generics, and constrained generic types.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了通过编写能够与不同类型的对象一起工作的代码来最大化代码重用，也就是说，能够实现特定接口的类的实例或其类层次结构包括特定超类的类的实例。我们使用了接口、泛型和受限泛型类型。
- en: We created classes capable of working with one constrained generic type. We
    combined class inheritance and interfaces to maximize the reusability of code.
    We could make classes work with many different types and we were able to code
    the behavior of a party that could then be reused to create parties of lions,
    parrots, and swans.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了能够使用受限泛型类型的类。我们结合了类继承和接口，以最大化代码的可重用性。我们可以使类与许多不同类型一起工作，我们能够编写一个能够被重用来创建狮子、鹦鹉和天鹅的派对行为的类。
- en: Now that you have learned the basics about parametric polymorphism and generics,
    we are ready to work with more advanced scenarios that maximize code reuse with
    generics in Java 9, which is the topic we are going to discuss in the next chapter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了关于参数多态性和泛型的基础知识，我们准备在Java 9中与泛型最大化代码重用的更高级场景一起工作，这是我们将在下一章讨论的主题。
