- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Applying Service-Oriented Architectures with .NET Core
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用.NET Core应用面向服务的架构
- en: The term **Service-Oriented Architecture** (**SOA**) refers to a modular architecture
    where interaction between system components is achieved through communication.
    SOA allows applications from different organizations to exchange data and transactions
    automatically and allows organizations to offer services on the internet.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: “面向服务的架构”（SOA）一词指的是通过通信实现系统组件之间交互的模块化架构。SOA允许来自不同组织的应用程序自动交换数据和交易，并允许组织在互联网上提供服务。
- en: Moreover, as we discussed in the *Microservices and the evolution of the concept
    of modules* section of *Chapter 5*, *Applying a Microservice Architecture to Your
    Enterprise Application*, communication-based interaction solves binary compatibility
    and version mismatch problems that inevitably appear in complex systems made up
    of modules that share the same address space. Moreover, with SOA, you do not need
    to deploy different copies of the same component in the various systems/subsystems
    that use it – each component only needs to be deployed in just one place. This
    can be a single server, a cluster located in a single data center, or a geographically
    distributed cluster. Here, each version of your component is deployed just once,
    and the server/cluster logic automatically creates all the necessary replicas,
    thus simplifying the overall **Continuous Integration / Continuous Delivery**
    (**CI/CD**) cycle.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如我们在《微服务和模块概念的演变》章节中讨论的那样，《将微服务架构应用于企业应用程序》第5章，基于通信的交互解决了复杂系统中不可避免出现的模块共享相同地址空间的二进制兼容性和版本不匹配问题。此外，使用SOA，您无需在使用它的各个系统/子系统中部署相同组件的不同副本-每个组件只需在一个地方部署。这可以是单个服务器，位于单个数据中心的集群，或地理分布的集群。在这里，您的组件的每个版本只部署一次，服务器/集群逻辑会自动创建所有必要的副本，从而简化整个持续集成/持续交付（CI/CD）周期。
- en: If a newer version conforms to the communication interface that is declared
    to the clients, no incompatibilities can occur. On the other hand, with DLLs/packages,
    when the same interface is maintained, incompatibilities may arise because of
    possible version mismatches in terms of the dependencies of other DLLs/packages
    that the library module might have in common with its clients.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新版本符合向客户端声明的通信接口，则不会发生不兼容性。另一方面，对于DLLs/软件包，当保持相同接口时，可能会出现不兼容性，因为库模块可能与其客户端共享的其他DLLs/软件包的依赖关系可能存在版本不匹配的情况。
- en: 'Organizing clusters/networks of cooperating services was discussed in *Chapter
    5*, *Applying a Microservice Architecture to Your Enterprise Application*. In
    this chapter, we will mainly focus on the communication interface offered by each
    service. More specifically, we will discuss the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在《将微服务架构应用于企业应用程序》第5章中讨论了组织协作服务的集群/网络。在本章中，我们将主要关注每个服务提供的通信接口。更具体地，我们将讨论以下主题：
- en: Understanding the principles of the SOA approach
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解SOA方法的原则
- en: SOAP and REST web services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOAP和REST Web服务
- en: How does .NET 5 deal with SOA?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 5如何处理SOA？
- en: Use case – exposing WWTravelClub packages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例-公开WWTravelClub套餐
- en: By the end of this chapter, you will know how to publicly expose data from the WWTravelClub
    book use case through an ASP.NET Core service.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将了解如何通过ASP.NET Core服务公开WWTravelClub书籍用例中的数据。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the Visual Studio 2019 free Community edition or better
    with all the database tools installed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要安装了所有数据库工具的Visual Studio 2019免费社区版或更高版本。
- en: All the concepts in this chapter will be clarified with practical examples based
    on this book's WWTravelClub book use case. You will find the code for this chapter
    at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有概念都将通过本书的WWTravelClub书籍用例的实际示例加以阐明。您可以在以下网址找到本章的代码：[https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5)。
- en: Understanding the principles of the SOA approach
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解SOA方法的原则
- en: Like classes in an object-oriented architecture, services are implementations
    of interfaces that, in turn, come from a system's functional specifications. Therefore,
    the first step in a *service* design is the definition of its *abstract interface*.
    During this stage, you define all the service operations as interface methods
    that operate on the types of your favorite language (C#, Java, C++, JavaScript,
    and so on) and decide which operations to implement with synchronous communication
    and which ones to implement with asynchronous communication.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与面向对象架构中的类一样，服务是接口的实现，而接口又来自系统的功能规范。因此，“服务”设计的第一步是定义其“抽象接口”。在此阶段，您将定义所有服务操作，作为操作您喜欢的语言类型（C＃，Java，C
    ++，JavaScript等）的接口方法，并决定使用同步通信实现哪些操作，使用异步通信实现哪些操作。
- en: The interfaces that are defined in this initial stage will not necessarily be
    used in the actual service implementation and are just useful design tools. Once
    we have decided on the architecture of the services, these interfaces are usually
    redefined so that we can adapt them to the peculiarity of the architecture.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个初始阶段定义的接口不一定会在实际服务实现中使用，它们只是有用的设计工具。一旦我们决定了服务的架构，通常会重新定义这些接口，以便我们可以将它们适应架构的特殊性。
- en: It is worth pointing out that SOA messages must keep the same kind of semantics
    as method calls/answers; that is, the reaction to a message must not depend on
    any previously received messages. Here, the messages must be independent of each
    other, and the service *must not remember* any previously received messages. This
    is what we call stateless development.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，SOA消息必须保持与方法调用/回答相同类型的语义；也就是说，对消息的反应不能依赖于先前接收到的任何消息。在这里，消息必须彼此独立，服务*不能记住*任何先前接收到的消息。这就是我们所说的无状态开发。
- en: For instance, if the purpose of messages is to create a new database entry,
    this semantic must not change with the context of other messages, and the way
    the database entry is created must depend on the content of the current message
    and not on other previously received messages. Consequently, a client cannot create
    sessions and cannot log in to a service, perform some operations, and then log
    out. An authentication token must be repeated in each message.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果消息的目的是创建新的数据库条目，这种语义不能随着其他消息的上下文而改变，创建数据库条目的方式必须取决于当前消息的内容，而不是先前接收到的其他消息。因此，客户端不能创建会话，也不能登录到服务，执行一些操作，然后注销。认证令牌必须在每条消息中重复。
- en: The reasons for this constraint are modularity, testability, and maintainability.
    In fact, a session-based service would be very hard to test and modify due to
    the interactions that are *hidden* in the session data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种约束的原因是模块化、可测试性和可维护性。事实上，基于会话的服务将非常难以测试和修改，因为这些交互是*隐藏*在会话数据中的。
- en: 'Once you have decided on the interface that is going to be implemented by a
    service, you must decide which communication stack/SOA architecture to adopt.
    The communication stack must be part of some official or *de facto* standard to
    ensure the interoperability of the service. Interoperability is the main constraint
    prescribed by SOA: services must offer a communication interface that does not
    depend on the specific communication library used, on the implementation language,
    or on the deployment platform.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您决定要由服务实现的接口，您必须决定采用哪种通信堆栈/SOA架构。通信堆栈必须是某些官方或*事实*标准的一部分，以确保服务的互操作性。互操作性是SOA规定的主要约束：服务必须提供一个通信接口，不依赖于特定的通信库、实现语言或部署平台。
- en: Considering you have decided on the communication stack/architecture, you need
    to adapt your previous interfaces to the peculiarities of the architecture (see
    the *REST web services* subsection of this chapter for more details). Then, you
    must translate these interfaces into the chosen communication language. This means
    that you must map all the programming language types into types that are available
    in the chosen communication language.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到您已经决定了通信堆栈/架构，您需要根据架构的特点调整先前的接口（有关更多详细信息，请参阅本章的*REST Web服务*子部分）。然后，您必须将这些接口翻译成所选择的通信语言。这意味着您必须将所有编程语言类型映射到所选择的通信语言中可用的类型。
- en: The actual translation of data is usually performed automatically by the SOA
    libraries that are used by your development environment. However, some configuration
    might be needed, and, in any case, we must be aware of how our programming language
    types are transformed before each communication. For instance, some numeric types
    might be transformed into types with less precision or with different ranges of
    values.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的实际翻译通常由您的开发环境使用的SOA库自动执行。然而，可能需要一些配置，无论如何，我们必须意识到在每次通信之前我们的编程语言类型是如何转换的。例如，一些数字类型可能会被转换为精度较低或具有不同值范围的类型。
- en: The interoperability constraint can be interpreted in a lighter form in the
    case of microservices that are not accessible outside of their clusters, since
    they need to communicate with other microservices that belong to the same cluster.
    In this case, this means that the communication stack might be platform-specific
    so that it can increase performance, but it must be standard to avoid compatibility
    problems with other microservices that might be added to the cluster as the application
    evolves.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 互操作性约束在微服务的情况下可以以较轻的形式解释，因为这些微服务无法在其集群之外访问，因此它们需要与属于同一集群的其他微服务进行通信。在这种情况下，这意味着通信堆栈可能是特定于平台的，以提高性能，但必须是标准的，以避免与随着应用程序发展可能添加到集群中的其他微服务的兼容性问题。
- en: We have spoken of the *communication stack* and not of the *communication protocol*
    because SOA communication standards usually define the format of the message's
    content and provide different possibilities for the specific protocol that is
    used to embed those messages. For instance, the SOAP protocol just defines an
    XML-based format for the various kinds of messages, but SOAP messages can be conveyed
    by various protocols. Usually, the most common protocol that is used for SOAP
    is HTTP, but you may decide to jump to the HTTP level and send SOAP messages directly
    over TCP/IP for better performance.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈论的是*通信堆栈*而不是*通信协议*，因为SOA通信标准通常定义了消息内容的格式，并为用于嵌入这些消息的特定协议提供了不同的可能性。例如，SOAP协议只是定义了各种消息的基于XML的格式，但SOAP消息可以通过各种协议传递。通常，用于SOAP的最常见协议是HTTP，但您可以决定跳转到HTTP级别，并直接通过TCP/IP发送SOAP消息以获得更好的性能。
- en: 'The choice of communication stack you should adopt depends on several factors:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该采用的通信堆栈的选择取决于几个因素：
- en: '**Compatibility constraints**: If your service must be publicly available on
    the internet to business clients, then you must conform to the most common choices,
    which means using either SOAP over HTTP or JSON REST services. The most common
    choices are different if your clients are not business clients but **Internet
    of Things** (**IoT**) clients. Also, within IoT, the protocols that are used in
    different application areas can be different. For instance, marine vehicle status
    data is not typically exchanged with *Signal K*.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兼容性约束**：如果您的服务必须对业务客户在互联网上公开可用，那么您必须遵守最常见的选择，这意味着使用SOAP over HTTP或JSON REST服务。如果您的客户不是业务客户而是**物联网**（**IoT**）客户，则最常见的选择是不同的。此外，在物联网中，不同应用领域使用的协议可能不同。例如，海洋车辆状态数据通常不与*Signal
    K*交换。'
- en: '**Development/deployment platform**: Not all communication stacks are available
    on all development frameworks and on all deployment platforms, but luckily, all
    the most common communication stacks that are used in public business services,
    such as SOAP and JSON-based REST communication, are available on all the main
    development/deployment platforms.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发/部署平台**：并非所有通信堆栈都适用于所有开发框架和所有部署平台，但幸运的是，所有主要的开发/部署平台上都可以使用在公共业务服务中使用的所有最常见的通信堆栈，例如SOAP和基于JSON的REST通信。'
- en: '**Performance**: If your system is not exposed to the outside world and is
    a private part of your microservice cluster, performance considerations have a
    higher priority. In this scenario, gRPC, which we will discuss soon in this chapter,
    can be mentioned as a good option.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：如果您的系统不向外部公开，而是微服务集群的私有部分，性能考虑将具有更高的优先级。在这种情况下，我们将在本章后面讨论的gRPC可以被提及为一个不错的选择。'
- en: '**Availability of tools and knowledge in your team**: Having knowledge and
    knowing about the availability of tools in your team/organization has an important
    weight when it comes to choosing between acceptable communication stacks. However,
    this kind of constraint always has less priority than compatibility constraints
    since it makes no sense to conceive a system that is easy to implement for your
    team but that almost nobody can use.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队中工具和知识的可用性**：在选择可接受的通信堆栈时，团队/组织中的知识和工具的可用性具有重要的影响。然而，这种约束始终比兼容性约束的优先级低，因为构想一个对团队易于实现但几乎没有人能使用的系统是毫无意义的。'
- en: '**Flexibility versus available features**: Some communication solutions, while
    less complete, offer a higher degree of flexibility, while other solutions, while
    being more complete, offer less flexibility. The need for flexibility started
    a movement from SOAP-based services to the more flexible REST services in the
    last few years. This point will be discussed in more detail when we describe SOAP
    and REST services in the remainder of this section.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性与可用功能**：一些通信解决方案虽然不够完整，但提供了更高程度的灵活性，而另一些解决方案虽然更完整，但提供的灵活性较少。在过去几年中，对灵活性的需求促使从基于SOAP的服务转向更灵活的REST服务。在本节的其余部分中，我们将更详细地讨论SOAP和REST服务。'
- en: '**Service description**: When services must be exposed on the internet, client
    applications need a publicly available description of the service specifications
    to design their communication clients. Some communication stacks include languages
    and conventions to describe service specifications. Formal service specifications
    that are exposed this way can be processed so that they automatically create communication
    clients. SOAP goes further and allows service discoverability by means of a public
    XML-based directory containing information about the tasks each web service can
    carry out.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务描述**：当服务必须在互联网上公开时，客户端应用程序需要一个公开可用的服务规范描述，以设计其通信客户端。一些通信堆栈包括用于描述服务规范的语言和约定。以这种方式公开的正式服务规范可以被处理，以便它们自动创建通信客户端。SOAP进一步允许通过包含每个Web服务可以执行的任务信息的公共基于XML的目录来发现服务。'
- en: 'Once you have chosen the communication stack you wish to use, you must use
    the tools that are available in your development environment to implement the
    service in a way that conforms to the chosen communication stack. Sometimes, communication
    stack compliance is automatically ensured by the development tools, but sometimes,
    it may require some development effort. For instance, in the .NET world, the compliance
    of SOAP services is automatically ensured by development tools if you use WCF,
    while the compliance of REST services falls under the developer''s responsibility.
    Some of the fundamental features of SOA solutions are as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 选择要使用的通信堆栈后，必须使用开发环境中可用的工具来实现符合所选通信堆栈的服务。有时，开发工具会自动确保通信堆栈的符合性，但有时可能需要一些开发工作。例如，在.NET世界中，如果使用WCF，则开发工具会自动确保SOAP服务的符合性，而REST服务的符合性则由开发人员负责。SOA解决方案的一些基本特性如下：
- en: '**Authentication**: Allows the client to authenticate to access service operations.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：允许客户端进行身份验证以访问服务操作。'
- en: '**Authorization**: Handles the client''s permissions.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：处理客户端的权限。'
- en: '**Security**: This is how communication is kept safe, that is, how to prevent
    unauthorized systems from reading and/or modifying the content of the communication.
    Typically, encryption prevents both unauthorized modifications and reading, while
    electronic signature algorithms prevent just modifications.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：这是通信如何保持安全的方式，即如何防止未经授权的系统读取和/或修改通信内容。通常，加密可以防止未经授权的修改和阅读，而电子签名算法只能防止修改。'
- en: '**Exceptions**: Returns exceptions to the client.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常**：向客户返回异常。'
- en: '**Message reliability**: Ensures that messages reliably reach their destination
    in case of possible infrastructure faults.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息可靠性**：确保在可能的基础设施故障的情况下，消息能够可靠地到达目的地。'
- en: 'Though sometimes desirable, the following features are not always necessary:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有时是可取的，但以下特性并不总是必要的：
- en: '**Distributed transactions**: The capability to handle distributed transactions,
    thus undoing all the changes you have made whenever the distributed transactions
    fail or are aborted.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式事务**：处理分布式事务的能力，因此当分布式事务失败或中止时，撤消您所做的所有更改。'
- en: '**Support for the Publisher/Subscriber pattern**: If and how events and notifications
    are supported.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持发布者/订阅者模式**：事件和通知的支持方式。'
- en: '**Addressing**: If and how references to other services and or service/methods
    are supported.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**寻址**：引用其他服务和/或服务/方法的支持方式。'
- en: '**Routing**: If and how messages can be routed through a network of services.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：消息如何通过服务网络进行路由。'
- en: The remainder of this section is dedicated to describing SOAP and REST services
    since they are the *de facto* standard for business services that are exposed
    outside of their clusters/servers. For performance reasons, microservices use
    other protocols, discussed in *Chapter 5*, *Applying a Microservice Architecture
    to Your Enterprise Application*; *Chapter 6*, *Azure Service Fabric*; and *Chapter
    7*, *Azure Kubernetes Service*. For inter-cluster communication, **Advanced Message
    Queuing Protocol** (**AMQP**) is used, and links are given in the *Further reading*
    section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分致力于描述SOAP和REST服务，因为它们是在集群/服务器之外公开的业务服务的*事实*标准。出于性能原因，微服务使用其他协议，在*第5章*，*将微服务架构应用于企业应用程序*；*第6章*，*Azure服务布局*；和*第7章*，*Azure
    Kubernetes服务*中进行了讨论。对于集群间通信，使用**高级消息队列协议**（**AMQP**），在*进一步阅读*部分给出了链接。
- en: SOAP web services
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOAP Web服务
- en: The **Simple Object Access Protocol** (**SOAP**) allows both one-way messages
    and answer/response messages. Communication can be both synchronous and asynchronous,
    but, if the underlying protocol is synchronous, such as in the case of HTTP, the
    sender receives an acknowledgment saying that the message was received (but not
    necessarily processed). When asynchronous communication is used, the sender must
    listen for incoming communications. Often, asynchronous communication is implemented
    with the Publisher/Subscriber pattern that we described in *Chapter 11*, *Design
    Patterns and .NET 5 Implementation*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单对象访问协议**（**SOAP**）允许单向消息和答复/响应消息。通信可以是同步的也可以是异步的，但是，如果底层协议是同步的，比如在HTTP的情况下，发送者会收到一个确认消息，说明消息已经被接收（但不一定被处理）。当使用异步通信时，发送者必须监听传入的通信。通常，异步通信是使用我们在*第11章*，*设计模式和.NET
    5实现*中描述的发布者/订阅者模式来实现的。'
- en: Messages are represented as XML documents called **envelopes**. Each envelope
    contains a `header`, a `body`, and a `fault` element. The `body` is where the
    actual content of the message is placed. The `fault` element contains possible
    errors, so it is the way exceptions are exchanged when communication occurs. Finally,
    the `header` contains any auxiliary information that enriches the protocol but
    does not contain domain data. For example, the `header` may contain an authentication
    token, and/or a signature if the message is signed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 消息被表示为称为**信封**的XML文档。每个信封包含一个`头部`，一个`主体`和一个`故障`元素。`主体`是消息的实际内容所在。`故障`元素包含可能的错误，因此在通信发生时，这是交换异常的方式。最后，`头部`包含丰富协议的任何辅助信息，但不包含域数据。例如，`头部`可能包含身份验证令牌，和/或如果消息被签名的话。
- en: The underlying protocol that is used to send the XML envelopes is usually HTTP,
    but the SOAP specification allows any protocol, so we can use TCP/IP or SMTP directly.
    As a matter of fact, the more diffused underlying protocol is HTTP, so, if you
    do not have a good reason to choose another protocol, you should use HTTP in order
    to maximize the interoperability of the service.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 用于发送XML信封的底层协议通常是HTTP，但SOAP规范允许任何协议，因此我们可以直接使用TCP/IP或SMTP。事实上，更为普遍的底层协议是HTTP，因此，如果您没有选择其他协议的充分理由，应该使用HTTP以最大化服务的互操作性。
- en: SOAP specifications contain the basics of message exchange, while other auxiliary
    features are described in separate specification documents called `WS- *` and
    are usually handled by adding extra information in the SOAP header. `WS-*` specifications
    handle all the fundamental and desirable features of SOA we listed previously.
    For instance, `WS-Security` takes care of security, including authentication,
    authorization, and encryption/signatures; `WS-Eventing` and `WS-Notification`
    are two alternative ways of implementing the Publisher/Subscriber pattern; `WS-ReliableMessaging`
    is concerned with the reliable delivery of messages in case of possible faults;
    and `WS-Transaction` is concerned with distributed transactions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP规范包含消息交换的基础知识，而其他辅助功能则在称为`WS- *`的单独规范文档中描述，并通常通过在SOAP头部添加额外信息来处理。`WS-*`规范处理我们之前列出的SOA的所有基本和理想特性。例如，`WS-Security`负责安全性，包括身份验证、授权和加密/签名；`WS-Eventing`和`WS-Notification`是实现发布者/订阅者模式的两种替代方式；`WS-ReliableMessaging`关注在可能出现故障时消息的可靠传递；`WS-Transaction`关注分布式事务。
- en: The preceding `WS-*` specifications are in no way exhaustive but are the more
    relevant and supported features. In fact, actual implementations in various environments
    (such as Java and .NET) furnish the more relevant `WS-*` services, but no implementation
    supports all the `WS-*` specifications.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前述的`WS-*`规范并不是详尽无遗的，但是它们是更相关和受支持的特性。实际上，各种环境中的实际实现（如Java和.NET）提供了更相关的`WS-*`服务，但没有一种实现支持所有的`WS-*`规范。
- en: All the XML documents/document parts involved in the SOAP protocol are formally
    defined in XSD documents, which are special XML documents whose content provides
    a description of XML structures. Also, all your custom data structures (classes
    and interfaces in an object-oriented language) must be translated into XSD if they
    are going to be part of a SOAP envelope.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP协议涉及的所有XML文档/文档部分在XSD文档中得到正式定义，这些文档是特殊的XML文档，其内容提供了XML结构的描述。此外，所有自定义数据结构（面向对象语言中的类和接口）必须被转换为XSD，如果它们将成为SOAP信封的一部分。
- en: Each XSD specification has an associated `namespace` that identifies the specification
    and a physical location where it can be found. Both the namespace and the physical
    location are URIs. The location URI does not need to be publicly accessible if
    the web service is accessible just from within an intranet.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每个XSD规范都有一个关联的`命名空间`，用于标识规范和可以找到规范的物理位置。命名空间和物理位置都是URI。如果Web服务只能从内部网络访问，位置URI不需要公开访问。
- en: The whole definition of a service is an XSD specification that may contain references
    to other namespaces, that is, to other XSD documents. Simply put, all the messages
    of a SOAP communication must be defined in an XSD specification. Then, a server
    and a client can communicate if they refer to the same XSD specifications. This
    means, for instance, that you need to create a new XSD specification each time
    you add another field to a message. After that, you need to update all the XSD
    files that reference the old message definition to the new message definition
    by creating a new version of them. In turn, these modifications require the creation
    of other versions for other XSD files, and so on. Therefore, simple modifications
    that maintain compatibility with the previous behavior (clients could simply ignore
    the field that was added) may cause an exponential chain of version changes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的整个定义是一个可能包含对其他命名空间的引用的XSD规范，也就是说，对其他XSD文档的引用。简而言之，SOAP通信的所有消息必须在XSD规范中定义。然后，如果服务器和客户端引用相同的XSD规范，它们可以进行通信。这意味着，例如，每次向消息添加另一个字段时，您需要创建一个新的XSD规范。之后，您需要更新所有引用旧消息定义的XSD文件到新消息定义，通过创建它们的新版本。反过来，这些修改需要为其他XSD文件创建其他版本，依此类推。因此，保持与先前行为兼容的简单修改（客户端可以简单地忽略添加的字段）可能会导致指数级的版本更改链。
- en: In the last few years, the difficulty in handling modifications, along with
    the complexity of handling the configuration of all the `WS-*` specifications
    and performance problems, caused a gradual move toward the simpler REST services
    that we will describe in the upcoming sections. This move started with services
    that were called from JavaScript due to the difficulty of implementing complete
    SOAP clients that were able to run efficiently in a web browser. Moreover, the
    complex SOAP machinery was oversized for the simple needs of the typical clients
    running in a browser and may have caused a complete waste of development time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，处理修改的困难以及处理所有`WS-*`规范的配置和性能问题，导致了逐渐向我们将在接下来的部分中描述的更简单的REST服务的转变。这一转变始于从JavaScript调用的服务，因为在Web浏览器中实现完整的SOAP客户端的困难。此外，复杂的SOAP机制对于运行在浏览器中的典型客户端的简单需求来说过于庞大，可能导致开发时间的完全浪费。
- en: For this reason, services aimed at non-JavaScript clients started a massive
    move toward REST services, and nowadays the preferred choice is REST services,
    with SOAP being used either for compatibility with legacy systems or when features
    that are not supported by REST services are needed. A typical application area
    that continues to prefer the SOAP system is that of payment/banking systems because
    these systems need the transactional support that is offered by the `WS-Transaction`
    SOAP specification. There is no equivalent in the REST services world.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，面向非JavaScript客户端的服务开始大规模转向REST服务，如今首选的选择是REST服务，而SOAP则用于与遗留系统兼容或者在需要REST服务不支持的功能时使用。继续偏好SOAP系统的典型应用领域是支付/银行系统，因为这些系统需要`WS-Transaction`
    SOAP规范提供的事务支持。在REST服务领域没有相应的功能。
- en: REST web services
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST网络服务
- en: REST services were initially conceived to avoid the complex machinery of SOAP
    in simple cases such as calls to a service from the JavaScript code of a web page.
    Then, they gradually became the preferred choice for complex systems. REST services
    use HTTP to exchange data in JSON or, less commonly, in XML format. Simply put,
    they replace the SOAP body with the HTTP body, the SOAP header with the HTTP header,
    and the HTTP response code replaces the fault element and furnishes further auxiliary
    information on the operation that was performed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务最初被构想为避免在简单情况下使用SOAP的复杂机制，比如从网页的JavaScript代码调用服务。然后，它们逐渐成为复杂系统的首选。REST服务使用HTTP以JSON或者更少见的XML格式交换数据。简而言之，它们用HTTP主体替换SOAP主体，用HTTP头部替换SOAP头部，HTTP响应代码替换故障元素，并提供有关执行的操作的进一步辅助信息。
- en: 'The main reason for the success of REST services is that HTTP already offers
    most of the SOAP features natively, which means we can avoid building a SOAP level
    on top of HTTP. Moreover, the whole HTTP machinery is simpler than SOAP: simpler
    to program, simpler to configure, and simpler to implement efficiently.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务成功的主要原因是，HTTP本身已经提供了大部分SOAP功能，这意味着我们可以避免在HTTP之上构建SOAP级别。此外，整个HTTP机制比SOAP更简单：编程更简单，配置更简单，而且更容易高效地实现。
- en: Moreover, REST services impose fewer constraints on the clients. Type compatibility
    between servers and clients conforms to the more flexible JavaScript type compatibility
    model because JSON is a subset of JavaScript. Moreover, when XML is used in place
    of JSON, it maintains the same JavaScript type compatibility rules. No XML namespaces
    need to be specified.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，REST服务对客户端的约束更少。服务器和客户端之间的类型兼容性符合更灵活的JavaScript类型兼容性模型，因为JSON是JavaScript的子集。此外，当使用XML代替JSON时，它保持相同的JavaScript类型兼容性规则。不需要指定XML命名空间。
- en: When using JSON and XML, if the server adds some more fields to the response
    while keeping the same semantic of all the other fields compatible with the previous
    client, they can simply ignore the new fields. Accordingly, changes that are made
    to a REST service definition only need to be propagated to previous clients in
    case of breaking changes that cause actual incompatible behavior in the server.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用JSON和XML时，如果服务器在响应中添加了一些新字段，同时保持与先前客户端的所有其他字段兼容的语义，他们可以简单地忽略新字段。因此，在服务器中引起实际不兼容行为的破坏性更改的情况下，对REST服务定义所做的更改只需要传播到先前的客户端。
- en: Moreover, it is likely that changes will be self-limited and won't result in
    an exponential chain of changes because type compatibility does not require the
    reference to a specific type to be defined in a unique shared place and simply
    requires that the shape of types is compatible.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于类型兼容性不要求引用特定类型在唯一共享的位置定义，并且只需要类型的形状是兼容的，因此更改可能是自限制的，不会导致指数级的更改链。
- en: Service type compatibility rules
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务类型兼容性规则
- en: 'Let''s clarify the REST service type compatibility rules with an example. Imagine
    that several services use a `Person` object that contains `Name`, `Surname`, and
    `Address` string fields. This object is served by **S1**:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来澄清REST服务类型兼容性规则。假设有几个服务使用包含“姓名”、“姓氏”和“地址”字符串字段的“Person”对象。这个对象由**S1**提供：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Type compatibility is ensured if the service and client refer to different
    copies of the preceding definition. It is also acceptable for the client to use
    a definition with fewer fields, since it can simply ignore all the other fields:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 确保类型兼容性，如果服务和客户端引用前面定义的不同副本。客户端使用字段较少的定义也是可以接受的，因为它可以简单地忽略所有其他字段：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can only use a definition with fewer fields within your "own" code. Attempting
    to send information back to the server without the expected fields may cause problems.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您只能在“自己”的代码中使用字段较少的定义。尝试在没有预期字段的情况下将信息发送回服务器可能会导致问题。
- en: 'Now, imagine the scenario where you have an **S2** service that takes `Person`
    objects from **S1** and adds them to the responses it returns on some of its methods.
    Suppose the **S1** service that handles the `Person` object replaces the `Address`
    string with a complex object:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下这样的情景：您有一个**S2**服务，它从**S1**获取“Person”对象，并将它们添加到其某些方法返回的响应中。假设处理“Person”对象的**S1**服务用复杂对象替换了“地址”字符串：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After the breaking change, the **S2** service will have to adapt its communication
    client that calls the **S1** service to the new format. Then, it can convert the
    new `Person` format into the older one before using `Person` objects in its responses.
    This way, the **S2** service avoids propagating the breaking change of **S1**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在破坏性更改之后，**S2**服务将不得不调整其调用**S1**服务的通信客户端以适应新格式。然后，它可以在使用“Person”对象在其响应中之前将新的“Person”格式转换为旧的格式。这样，**S2**服务避免了传播**S1**的破坏性更改。
- en: In general, basing type compatibility on the object shape (tree of nested properties),
    instead of a reference to the same formal type definition, increases flexibility
    and modifiability. The price we pay for this increased flexibility is that type
    compatibility cannot be computed automatically by comparing the formal definition
    of server and client interfaces. In fact, in absence of a univocal specification,
    each time a new version of the service is released, the developer must verify
    that the semantics of all the fields that the client and server have in common
    remain unchanged from the previous version.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，基于对象形状（嵌套属性树）而不是对相同正式类型定义的引用来确定类型兼容性，增加了灵活性和可修改性。我们为这种增加的灵活性付出的代价是，类型兼容性不能通过比较服务器和客户端接口的正式定义来自动计算。事实上，在没有明确规范的情况下，每次发布服务的新版本时，开发人员必须验证客户端和服务器共有的所有字段的语义是否与上一个版本保持不变。
- en: The basic idea behind REST services is to give up the severity checks and complex
    protocols for greater flexibility and simplicity, while SOAP does exactly the
    opposite.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务背后的基本思想是放弃严格的检查和复杂的协议，以换取更大的灵活性和简单性，而SOAP恰恰相反。
- en: Rest and native HTTP features
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rest和本机HTTP功能
- en: The REST services manifesto states that REST uses native HTTP features to implement
    all the required service features. So, for instance, authentication will be performed
    directly with the HTTP `Authorization` field, encryption will be achieved with
    HTTPS, exceptions will be handled with an HTTP error status code, and routing
    and reliable messaging will be handled by the machinery the HTTP protocol relies
    on. Addressing is achieved by using URLs to refer to services, their methods,
    and other resources.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务宣言指出，REST使用本机HTTP功能来实现所有所需的服务功能。因此，例如，身份验证将直接使用HTTP的“Authorization”字段进行，加密将通过HTTPS实现，异常将使用HTTP错误状态代码处理，路由和可靠的消息传递将由HTTP协议依赖的机制处理。通过使用URL来引用服务、它们的方法和其他资源来实现寻址。
- en: There is no native support for asynchronous communication since HTTP is a synchronous
    protocol. There is also no native support for the Publisher/Subscriber pattern,
    but two services can interact with the Publisher/Subscriber pattern by each exposing
    an endpoint to the other. More specifically, the first service exposes a subscription
    endpoint, while the second one exposes an endpoint where it receives its notifications,
    which are authorized through a common secret that is exchanged during the subscription.
    This pattern is quite common. GitHub also allows us to send our REST services
    to repository events.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HTTP是同步协议，因此没有原生支持异步通信。也没有原生支持发布者/订阅者模式，但两个服务可以通过各自公开一个端点来与发布者/订阅者模式进行交互。更具体地，第一个服务公开一个订阅端点，而第二个服务公开一个端点，用于接收其通知，这些通知通过在订阅期间交换的共同秘密进行授权。这种模式非常常见。GitHub还允许我们将我们的REST服务发送到存储库事件。
- en: REST services offer no easy options when it comes to implementing distributed
    transactions, which is why payment/banking systems still prefer SOAP. Luckily,
    most application areas do not need the strong form of consistency that is ensured
    by distributed transactions. For them, lighter forms of consistency, such as *eventual
    consistency*, are enough and are preferred for performance reasons. Please refer
    to *Chapter 9*, *How to Choose Your Data Storage in the Cloud*, for a discussion
    on the various types of consistencies.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务在实现分布式事务时没有简单的选项，这就是为什么支付/银行系统仍然更喜欢SOAP。幸运的是，大多数应用领域不需要分布式事务所确保的强一致性。对于它们来说，轻量级的一致性形式，如*最终一致性*，已经足够，并且出于性能原因更受欢迎。请参阅*第9章*，*如何在云中选择您的数据存储*，讨论各种一致性类型。
- en: 'The REST manifesto not only prescribes the usage of the predefined solutions
    that are already available in HTTP but also the usage of a web-like semantic.
    More specifically, all the service operations must be conceived as CRUD operations
    on resources that are identified by URLs (the same resource may be identified
    by several URLs). In fact, REST is the acronym for **Representational State Transfer**,
    meaning that each URL is the representation of some sort of object. Each kind
    of service request needs to adopt the appropriate HTTP verb, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: REST宣言不仅规定了在HTTP中使用预定义的解决方案，还规定了使用类似Web的语义。更具体地说，所有服务操作必须被构想为对由URL标识的资源进行CRUD操作（同一资源可以由多个URL标识）。事实上，REST是**表现状态转移**的缩写，意味着每个URL都是某种对象的表示。每种服务请求都需要采用适当的HTTP动词，如下所示：
- en: '`GET` (Read operation): The URL represents the resource that is returned by
    the read operation. Thus, `GET` operations mimic pointer dereferencing. In the
    case of a successful operation, a 200 (OK) status code is returned.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`（读取操作）：URL代表读取操作返回的资源。因此，`GET`操作模拟指针解引用。在操作成功的情况下，将返回200（OK）状态码。'
- en: '`POST` (Creation operation): The JSON/XML object that is contained in the request
    body is added as a new resource to the object represented by the operation URL.
    If the new resource is successfully created immediately, a 201 (created) status
    code is returned, along with a response object that depends on the operation and
    the indicative about where the created resource can be retrieved from. The response
    object should contain the most specific URL that identifies the created resource.
    If creation is deferred to a later time, a 202 (accepted) status code is returned.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`（创建操作）：包含在请求体中的JSON/XML对象被添加为操作URL所代表的对象的新资源。如果新资源立即成功创建，将返回201（已创建）状态码，以及取决于操作的响应对象和关于可以从哪里检索到创建的资源的指示。响应对象应包含标识创建的资源的最具体URL。如果创建推迟到以后的时间，将返回202（已接受）状态码。'
- en: '`PUT` (Edit operation): The JSON/XML object contained in the request body replaces
    the object referenced by the request URL. In the case of successful operation,
    a 200 (OK) status code is returned. This operation is idempotent, meaning that
    repeating the same request twice causes the same modification.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`（编辑操作）：请求体中包含的JSON/XML对象替换了请求URL引用的对象。在操作成功的情况下，将返回200（OK）状态码。这个操作是幂等的，也就是说重复相同的请求两次会导致相同的修改。'
- en: '`PATCH`: The JSON/XML object contained in the request body contains instructions
    on how to modify the object referenced by the request URL. This operation is not
    idempotent since the modification may be an increment of a numeric field. In the
    case of successful operation, a 200 (OK) status code is returned.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`：请求体中包含的JSON/XML对象包含如何修改请求URL引用的对象的指令。这个操作不是幂等的，因为修改可能是对数值字段的增量。在操作成功的情况下，将返回200（OK）状态码。'
- en: '`DELETE`: The resource referenced by the request URL is removed. In the case
    of successful operation, a 200 (OK) status code is returned.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：删除请求URL引用的资源。在操作成功的情况下，将返回200（OK）状态码。'
- en: 'If the resource has been moved from the request URL to another URL, a redirect
    code is returned:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资源已从请求URL移动到另一个URL，将返回重定向代码：
- en: '`301` (moved permanently), plus the new URL where we can find the resource'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`301`（永久移动），以及我们可以找到资源的新URL'
- en: '`307` (moved temporarily), plus the new URL where we can find the resource'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`307`（临时移动），以及我们可以找到资源的新URL'
- en: 'If the operation fails, a status code that depends on the kind of failure is
    returned. Some examples of failures codes are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作失败，将返回取决于失败类型的状态码。一些失败代码的示例如下：
- en: '`400` (bad request): The request that was sent to the server is ill-formed.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`400`（错误的请求）：发送到服务器的请求格式不正确。'
- en: '`404` (not found): When the request URL does not refer to any known object.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`404`（未找到）：当请求URL不引用任何已知对象时。'
- en: '`405` (method not allowed): When the request verb is not supported by the resource
    referenced by the URL.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`405`（方法不允许）：当URL引用的资源不支持请求动词时。'
- en: '`401` (unauthorized): The operation requires authentication, but the client
    has not furnished any valid authorization header.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`401`（未经授权）：操作需要身份验证，但客户端未提供任何有效的授权头。'
- en: '`403` (forbidden): The client is correctly authenticated but has no right to
    perform the operation.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`403`（禁止）：客户端已正确进行身份验证，但没有执行操作的权限。'
- en: The preceding list of status codes is not exhaustive. References to an exhaustive
    list will be provided in the *Further reading* section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上述状态码列表并非详尽无遗。详尽列表的参考将在*进一步阅读*部分提供。
- en: It is fundamental to point out that `POST`/`PUT`/`PATCH`/`DELETE` operations
    may have – and usually have – side effects on other resources. Otherwise, it would
    be impossible to code operations that act simultaneously on several resources.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的是，`POST`/`PUT`/`PATCH`/`DELETE`操作可能具有对其他资源的副作用，通常也会有副作用。否则，将无法编写同时对多个资源进行操作的操作。
- en: In other words, the HTTP verb must conform with the operation that is performed
    on the resource and referenced by the request URL, but the operation might affect
    other resources. The same operation might be performed with a different HTTP verb
    on one of the other involved resources. It is the developer's responsibility to
    choose which way to perform the same operation to implement it in the service
    interface.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，HTTP动词必须符合在请求URL引用的资源上执行的操作，但该操作可能会影响其他资源。同一操作可能会使用不同的HTTP动词在其他涉及的资源中执行。开发人员有责任选择以哪种方式执行相同的操作来实现服务接口。
- en: Thanks to the side effects of HTTP verbs, REST services can encode all these
    operations as CRUD operations on resources represented by URLs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HTTP动词的副作用，REST服务可以将所有这些操作编码为URL表示的资源上的CRUD操作。
- en: Often, moving an existing service to REST requires us to split the various inputs
    between the request URL and the request body. More specifically, we extract the
    input fields that univocally define one of the objects involved in the method's
    execution and use them to create a URL that univocally identifies that object.
    Then, we decide on which HTTP verb to use based on the operation that is performed
    on the selected object. Finally, we place the remainder of the input in the request
    body.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将现有服务转换为REST需要我们在请求URL和请求主体之间分割各种输入。更具体地说，我们提取唯一定义方法执行中涉及的对象之一的输入字段，并使用它们创建一个唯一标识该对象的URL。然后，我们根据在所选对象上执行的操作选择要使用的HTTP动词。最后，我们将其余的输入放在请求主体中。
- en: If our services were designed with an object-oriented architecture focused on
    the business domain objects (such as DDD, as described in *Chapter 12*, *Understanding
    the Different Domains in Software Solutions*), the REST translation of all the
    service methods should be quite immediate, since services should already be organized
    around domain resources. Otherwise, moving to REST might require some service
    interface redefinitions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的服务是以面向业务域对象的面向对象架构设计的（例如DDD，如*第12章*中所述，*理解软件解决方案中的不同领域*），那么所有服务方法的REST翻译应该是相当直接的，因为服务应该已经围绕领域资源组织起来。否则，转移到REST可能需要重新定义一些服务接口。
- en: The adoption of full REST semantics has the advantage that services can be extended
    with or without small modifications being made to the preexisting operation definitions.
    In fact, extensions should mainly manifest as additional properties of some objects
    and as additional resource URLs with some associated operations. Therefore, preexisting
    clients can simply ignore them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 采用完整的REST语义的优势在于服务可以在不对现有操作定义进行小修改的情况下进行扩展。事实上，扩展主要表现为某些对象的附加属性和一些相关操作的附加资源URL。因此，现有客户端可以简单地忽略它们。
- en: Example of methods in the REST language
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST语言中方法的示例
- en: 'Now, let''s learn how methods can be expressed in the REST language with a
    simple example of an intra-bank money transfer. A bank account can be represented
    by a URL, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个简单的银行内部转账的示例来学习如何在REST语言中表达方法。银行账户可以通过以下URL表示：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A transfer might be represented as a `PATCH` request whose body contains an
    object with properties representing the amount of money, time of transfer, description,
    and the account receiving the money.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 转账可以表示为一个`PATCH`请求，其主体包含一个表示金额、转账时间、描述和接收资金的账户的属性对象。
- en: The operation modifies the account mentioned in the URL, but also the receiving
    account as a *side effect*. If the account doesn't have enough money, a `403`
    (Forbidden) status code is returned, along with an object with all the error details
    (an error description, the available funds, and so on).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作修改了URL中提到的账户，同时也会影响到接收账户。如果账户没有足够的资金，将返回403（禁止）状态码，以及一个包含所有错误细节的对象（错误描述、可用资金等）。
- en: 'However, since all the bank operations are recorded in the account statement,
    the creation and addition of a new transfer object for a *bank account operations*
    collection associated with the bank account is a better way to represent the transfer.
    In this case, the URL might be something like the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于所有的银行操作都记录在账单中，为与银行账户相关的*bank account operations*集合创建和添加一个新的转账对象是更好的表示转账的方式。在这种情况下，URL可能是以下内容：
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the HTTP verb is `POST` since we are creating a new object. The body content
    is the same and a `422` status code is returned if there is a lack of funds.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，HTTP动词是`POST`，因为我们正在创建一个新对象。主体内容是相同的，如果资金不足，则返回`422`状态码。
- en: Both representations of the transfer cause the same changes in the database.
    Moreover, once the inputs are extracted from the different URLs and from the possibly
    different request bodies, the subsequent processing is the same. In both cases,
    we have the same inputs and the same processing – it is just the exterior appearance
    of the two requests that is different.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 转账的两种表示都会导致数据库中的相同更改。此外，一旦输入从不同的URL和可能不同的请求主体中提取出来，后续处理是相同的。在这两种情况下，我们有相同的输入和相同的处理
    - 只是这两个请求的外观不同。
- en: 'However, the introduction of the virtual *operations* collection allows us
    to extend the service with several more *operations* collection-specific methods.
    It is worth pointing out that the *operations* collection does not need to be
    connected with a database table or with any physical object: it lives in the world
    of URLs and creates a convenient way for us to model the transfer.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，引入虚拟的*operations*集合使我们能够通过几种特定于*operations*集合的方法来扩展服务。值得指出的是*operations*集合不需要与数据库表或任何物理对象连接：它存在于URL的世界中，并为我们建模转账提供了便利的方式。
- en: The increased usage of REST services leads to a description of REST service
    interfaces to be created, like the ones developed for SOAP. This standard is called **OpenAPI**.
    We will talk about this in the following subsection.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务的增加使用导致了REST服务接口的描述被创建，就像为SOAP开发的那样。这个标准称为OpenAPI。我们将在下一小节中讨论这个问题。
- en: The OpenAPI standard
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenAPI标准
- en: OpenAPI is a standard that is used for describing the REST API. It is currently
    version 3\. The whole service is described by a JSON endpoint, that is, an endpoint
    that describes the service with a JSON object. This JSON object has a general
    section that applies to the whole service and contains the general features of
    the service, such as its version and description, as well as shared definitions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI是用于描述REST API的标准。目前是版本3。整个服务由JSON端点描述，即用JSON对象描述服务的端点。这个JSON对象有一个适用于整个服务的一般部分，包含服务的一般特性，如其版本和描述，以及共享定义。
- en: Then, each service endpoint has a specific section that describes the endpoint
    URL or URL format (in case some inputs are included in the URL), all its inputs,
    all the possible output types and status codes, and all the authorization protocols.
    Each endpoint-specific section can reference the definitions contained in the
    general section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个服务端点都有一个特定部分，描述端点的URL或URL格式（如果URL中包含一些输入），所有的输入，所有可能的输出类型和状态码，以及所有的授权协议。每个特定端点部分可以引用一般部分中包含的定义。
- en: A description of the OpenAPI syntax is out of the scope of this book, but references
    are provided in the *Further reading* section. Various development frameworks
    automatically generate OpenAPI documentation by processing the REST API code and
    further information is provided by the developer, so your team does not need to
    have in-depth knowledge of OpenAPI syntax. An example of it is the `Swashbuckle.AspNetCore`
    NuGet package that we will present in this chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不涵盖OpenAPI语法的描述，但在“进一步阅读”部分提供了参考资料。各种开发框架通过处理REST API代码自动生成OpenAPI文档，并由开发人员提供更多信息，因此您的团队不需要深入了解OpenAPI语法。其中一个例子是我们将在本章中介绍的`Swashbuckle.AspNetCore`
    NuGet包。
- en: The *How does .NET 5 deal with SOA?* section explains how we can automatically
    generate OpenAPI documentation in ASP.NET Core REST API projects, while the use
    case at the end of this chapter provides a practical example of its usage.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: “.NET 5如何处理SOA？”部分解释了我们如何在ASP.NET Core REST API项目中自动生成OpenAPI文档，而本章末尾的用例提供了其使用的实际示例。
- en: We will end this subsection by talking about how to handle authentication and
    authorization in REST services.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过讨论如何处理REST服务中的身份验证和授权来结束本小节。
- en: REST service authorization and authentication
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST服务授权和身份验证
- en: 'Since REST services are sessionless, when authentication is required, the client
    must send an authentication token in every single request. That token is usually
    placed in the HTTP authorization header, but this depends on the type of authentication
    protocol you are using. The simplest way to authenticate is through the explicit
    transmission of a shared secret. This can be done with the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于REST服务是无状态的，当需要身份验证时，客户端必须在每个请求中发送身份验证令牌。该令牌通常放在HTTP授权标头中，但这取决于您使用的身份验证协议的类型。通过显式传输共享密钥是进行身份验证的最简单方式。可以使用以下代码来实现：
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The shared secret is called an API key. Since, at the time of writing, there
    is no standard on how to send it, API keys can also be sent in other headers,
    as shown in the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 共享密钥称为API密钥。由于在撰写本文时，尚无关于如何发送API密钥的标准，因此API密钥也可以在其他标头中发送，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is worth mentioning that API key-based authentication needs HTTPS to stop
    shared secrets from being stolen. API keys are very simple to use, but they do
    not convey information about user authorizations, so they can be adopted when
    the operations allowed by the client are quite standard and there are no complex
    authorization patterns. Moreover, when exchanged in requests, API keys are susceptible
    to being attacked on the server or client side. A common pattern to mitigate this
    is to create a "service account" user and restrict their authorizations to just
    those needed and use the API keys from that specific account when interacting
    with the API.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，基于API密钥的身份验证需要使用HTTPS来阻止共享密钥被窃取。API密钥非常简单易用，但它们不传达有关用户授权的信息，因此当客户端允许的操作非常标准且没有复杂的授权模式时，可以采用它们。此外，在请求中交换API密钥时，API密钥容易受到服务器或客户端的攻击。缓解这种情况的常见模式是创建一个“服务账户”用户，并将其授权限制在所需的范围内，并在与API交互时使用该特定账户的API密钥。
- en: Safer techniques use shared secrets that are valid for a long period of time,
    just by the user logging in. Then, the login returns a short-life token that is
    used as a shared secret in all the subsequent requests. When the short-life secret
    is going to expire, it can be renewed with a call to a renew endpoint.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 更安全的技术使用长期有效的共享密钥，用户登录后即可使用。然后，登录返回一个短期令牌，该令牌在所有后续请求中用作共享密钥。当短期密钥即将过期时，可以通过调用续订端点来进行续订。
- en: The whole logic is completely decoupled from the short-life token-based authorization
    logic. The login is usually based on login endpoints that receive long-term credentials
    and return short-life tokens. Login credentials are either usual username-password
    pairs that are passed as input to the login method or other kinds of authorization
    tokens that are converted into short-life tokens that are served by the login
    endpoint. Login can also be achieved with various authentication protocols based
    on X.509 certificates.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 整个逻辑与短期令牌身份验证逻辑完全解耦。登录通常基于接收长期凭据并返回短期令牌的登录端点。登录凭据可以是传递给登录方法的常规用户名密码对，也可以是其他类型的授权令牌，这些令牌被转换为由登录端点提供的短期令牌。登录还可以通过基于X.509证书的各种身份验证协议实现。
- en: The most widespread short-life token type is the so-called bearer token. Each
    bearer token encodes information about how long it lasts and a list of assertions,
    called claims, that can be used for authorization purposes. Bearer tokens are
    returned by either login operations or renewal operations. Their characteristic
    feature is that they are not tied to the client that receives them or to any other
    specific client.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的短寿命令牌类型是所谓的持有者令牌。每个持有者令牌都编码了它的持续时间以及一系列断言，称为声明，可用于授权目的。持有者令牌由登录操作或续订操作返回。它们的特征是它们不与接收它们的客户端或任何其他特定客户端绑定。
- en: No matter how a client gets a bearer token, this is all a client needs to be
    granted all the rights implied by its claims. It is enough to transfer a bearer
    token to another client to empower that client with all the rights implied by
    all the bearer token claims, since no proof of identity is required by bearer
    token-based authorization.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 无论客户端如何获得持有者令牌，这都是客户端需要被其声明隐含的所有权利授予的。只需将持有者令牌转让给另一个客户端，即可授予该客户端所有持有者令牌声明隐含的所有权利，因为基于持有者令牌的授权不需要身份的证明。
- en: Therefore, once a client gets a bearer token, it can delegate some operations
    to third parties by transferring its bearer token to them. Typically, when a bearer
    token must be used for delegation, during the login phase, the client specifies
    the claims to include to restrict what operations can be authorized by the token.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦客户端获得了一个持有者令牌，它可以通过将其持有者令牌转让给第三方来委托一些操作。通常，在必须使用持有者令牌进行委托时，在登录阶段，客户端指定要包含的声明以限制令牌可以授权的操作。
- en: 'Compared to API key authentication, bearer token-based authentication is disciplined
    by standards. They must use the following `Authorization` header:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与API密钥身份验证相比，基于持有者令牌的身份验证受到标准的约束。它们必须使用以下`Authorization`标头：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Bearer tokens can be implemented in several ways. REST services typically use
    JWT tokens that are strung with a Base64URL encoding of JSON objects. More specifically,
    JWT creation starts with a JSON header, as well as a JSON payload. The JSON header
    specifies the kind of token and how it is signed, while the payload consists of
    a JSON object that contains all the claims as property/value pairs. The following
    is an example header:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 持有者令牌可以以多种方式实现。REST服务通常使用JWT令牌，该令牌是由JSON对象的Base64URL编码串联而成。更具体地说，JWT的创建始于JSON标头，以及JSON负载。JSON标头指定了令牌的类型以及如何签名，而负载由一个包含所有声明的JSON对象作为属性/值对组成。以下是一个示例标头：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is an example payload:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例负载：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, the header and payload are Base64URL-encoded and the corresponding string
    is concatenated as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，标头和负载被Base64URL编码，并且相应的字符串连接如下：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding string is then signed with the algorithm specified in the header,
    which, in our example, is RSA +SHA256, and the signature string is concatenated
    with the original string as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用标头中指定的算法对前面的字符串进行签名，例如，在我们的示例中，是RSA + SHA256，并将签名字符串与原始字符串连接如下：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code is the final bearer token string. A symmetric signature can
    be used instead of RSA, but, in this case, both the JWT issuer and all the services
    using it for authorization must share a common secret, while, with RSA, the private
    key of the JWT issuer does not need to be shared with anyone, since the signature
    can be verified with just the issuer public key.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是最终的持有者令牌字符串。可以使用对称签名代替RSA，但在这种情况下，JWT颁发者和所有使用它进行授权的服务必须共享一个公共密钥，而在RSA中，JWT颁发者的私钥不需要与任何人共享，因为签名可以仅通过颁发者公钥进行验证。
- en: 'Some payload properties are standard, such as the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一些负载属性是标准的，比如以下内容：
- en: '`iss`: Issuer of the JWT.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iss`：JWT的颁发者。'
- en: '`aud`: The audience, that is, the services and/or operations that can use the
    token for authorization. If a service does not see its identifier within this
    list, it should reject the token.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aud`：受众，即可以使用令牌进行授权的服务和/或操作。如果服务在此列表中看不到其标识符，则应拒绝令牌。'
- en: '`sub`: A string that identifies the *principal* (that is, the user) to which
    the JWT was issued.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sub`：标识JWT颁发给的*主体*（即用户）的字符串。'
- en: '`iat`, `exp`, and `nbf`: These are for the time the JWT was issued, its expiration
    time, and, if set, the time after which the token is valid, respectively. All
    the times are expressed as seconds from midnight UTC on January 1, 1970\. Here,
    all the days are considered as having exactly 86,400 seconds in them.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iat`，`exp`和`nbf`：这些是JWT颁发的时间，其过期时间，以及如果设置了，令牌有效的时间之后。所有时间都表示为从1970年1月1日UTC午夜开始的秒数。在这里，所有天都被认为是确切地有86400秒。'
- en: Other claims may be defined as public if we represent them with a unique URI;
    otherwise, they are considered private to the issuer and to the services known
    to the issuer.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用唯一的URI表示，其他声明可以被定义为公共的；否则，它们被认为是颁发者和已知服务的私有声明。
- en: How does .NET 5 deal with SOA?
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET 5 如何处理SOA？
- en: WCF technology has not been ported to .NET 5 and there are no plans to perform
    a complete port of it. Instead, Microsoft is investing in gRPC, Google's open
    source technology. Besides, .NET 5 has excellent support for REST services through
    ASP.NET Core.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: WCF技术尚未移植到.NET 5，并且没有计划对其进行完全移植。相反，微软正在投资于gRPC，谷歌的开源技术。此外，.NET 5通过ASP.NET Core对REST服务有出色的支持。
- en: 'The main reasons behind the decision to abandon WCF in .NET 5 are as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 5放弃WCF的主要原因如下：
- en: As we have already discussed, SOAP technology has been overtaken by REST technology
    in most application areas.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，SOAP技术在大多数应用领域已被REST技术取代。
- en: WCF technology is strictly tied to Windows, so it would be very expensive to
    reimplement all its features from scratch in .NET 5\. Since support for full .NET
    will continue, users that need WCF can still rely on it.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WCF技术严格绑定在Windows上，因此在.NET 5中从头开始重新实现其所有功能将非常昂贵。由于对完整.NET的支持将继续，需要WCF的用户仍然可以依赖它。
- en: As a general strategy, with .NET 5, Microsoft prefers investing in open source
    technologies that can be shared with other competitors. That is why, instead of
    investing in WCF, Microsoft provided a gRPC implementation starting from .NET
    Core 3.0.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一般策略，微软更倾向于投资于可以与其他竞争对手共享的开源技术。这就是为什么微软在.NET Core 3.0开始提供了gRPC实现，而不是投资于WCF。
- en: The next subsections will cover the support provided inside Visual Studio for
    each technology we have mentioned.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的小节将介绍Visual Studio为我们提到的每种技术提供的支持。
- en: SOAP client support
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SOAP客户端支持
- en: In WCF, service specifications are defined through .NET interfaces and the actual
    service code is supplied in classes that implement those interfaces. Endpoints,
    underlying protocols (HTTP and TCP/IP), and any other features are defined in
    a configuration file. In turn, the configuration file can be edited with an easy
    to use configuration tool. Therefore, the developer is responsible for providing
    just the service behavior as a standard .NET class and for configuring all the
    service features in a declarative way. This way, the service configuration is
    completely decoupled from the actual service behavior and each service can be
    reconfigured so that it can be adapted to a different environment without the
    need to modify its code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在WCF中，服务规范是通过.NET接口定义的，实际的服务代码是在实现这些接口的类中提供的。端点、底层协议（HTTP和TCP/IP）以及任何其他特性都在配置文件中定义。配置文件可以通过易于使用的配置工具进行编辑。因此，开发人员只需提供标准的.NET类作为服务行为，并以声明方式配置所有服务特性。这样，服务配置完全与实际的服务行为解耦，每个服务都可以重新配置，以适应不同的环境，而无需修改其代码。
- en: While .NET 5 does not support SOAP technology, it does support SOAP clients.
    More specifically, it is quite easy to create a SOAP service proxy for an existing
    SOAP service in Visual Studio (please refer to *Chapter 11*, *Design Patterns
    and .NET 5 Implementation*, for a discussion of what a proxy is and of the proxy
    pattern).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然.NET 5不支持SOAP技术，但它支持SOAP客户端。更具体地说，在Visual Studio中为现有的SOAP服务创建SOAP服务代理非常容易（请参阅*第11章*，*设计模式和.NET
    5实现*，讨论代理是什么以及代理模式）。
- en: In the case of services, a proxy is a class that implements the service interface
    and whose methods perform their jobs by calling the analogous methods of the remote
    service.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务的情况下，代理是实现服务接口的类，其方法通过调用远程服务的类似方法来执行它们的工作。
- en: To create a service proxy, right-click **Dependencies** in your project in **Solution
    Explorer**, and then select **Add connected service**. Then, in the form that
    appears, select **Microsoft WCF Service Reference Provider**. There, you can specify
    the URL of the service (where the WSDL service description is contained), the
    namespace where you wish to add the proxy class, and much more. At the end of
    the wizard, Visual Studio automatically adds all the necessary NuGet packages
    and scaffolds the proxy class. This is enough to create an instance of this class
    and to call its methods so that we can interact with the remote SOAP service.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建服务代理，在**解决方案资源管理器**中的项目中右键单击**依赖项**，然后选择**添加连接的服务**。然后，在出现的表单中，选择**Microsoft
    WCF服务引用提供程序**。在那里，您可以指定服务的URL（包含WSDL服务描述的位置）、要添加代理类的命名空间等。在向导结束时，Visual Studio会自动添加所有必要的NuGet包并生成代理类。这就足以创建此类的实例并调用其方法，以便与远程SOAP服务进行交互。
- en: There are also third parties, such as NuGet packages that provide limited support
    for SOAP services, but at the moment, they aren't very useful, since such limited
    support does not include features that aren't available in REST services.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第三方，如NuGet包，提供了对SOAP服务的有限支持，但目前它们并不是很有用，因为这种有限支持不包括在REST服务中不可用的功能。
- en: gRPC support
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gRPC支持
- en: Visual Studio 2019 supports the gRPC project template, which scaffolds both
    a gRPC server and a gRPC client. gRPC implements a remote procedure call pattern
    that offers both synchronous and asynchronous calls, reducing the traffic of messages
    between client and server.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2019支持gRPC项目模板，可以为gRPC服务器和gRPC客户端生成脚手架。gRPC实现了远程过程调用模式，提供了同步和异步调用，减少了客户端和服务器之间的消息流量。
- en: Although at the time of writing this book, gRPC is not available for IIS and
    App Service in Azure, there are great initiatives related to it. One of them is
    gRPC-Web ([https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/)).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在撰写本书时，gRPC在Azure的IIS和应用服务中不可用，但与此相关的伟大倡议。其中之一是gRPC-Web（[https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/)）。
- en: It is configured in a way that is similar to WCF and to .NET remoting, as we
    described at the end of *Chapter 6*, *Azure Service Fabric*. That is, services
    are defined through interfaces and their code is provided in classes that implement
    those interfaces, while clients interact with those services through proxies that
    implement the same service interfaces.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 它的配置方式类似于WCF和.NET远程调用，正如我们在*第6章*，*Azure Service Fabric*末尾所描述的那样。也就是说，服务是通过接口定义的，它们的代码是在实现这些接口的类中提供的，而客户端通过实现相同的服务接口的代理与这些服务进行交互。
- en: gRPC is a good option for internal communications within a microservices cluster,
    especially if the cluster is not fully based on Service Fabric technology and
    cannot rely on .NET remoting. Since there are gRPC libraries for all the main
    languages and development frameworks, it can be used in Kubernetes-based clusters,
    as well as in Service Fabric clusters that host Docker images that have been implemented
    in other frameworks.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC是微服务集群内部通信的一个很好的选择，特别是如果集群不完全基于Service Fabric技术，并且不能依赖.NET远程调用。由于所有主要语言和开发框架都有gRPC库，因此它可以在基于Kubernetes的集群中使用，以及在托管了在其他框架中实现的Docker镜像的Service
    Fabric集群中使用。
- en: gRPC is more efficient than the REST services protocol due to its more compact
    representation of data and it being easier to use, since everything to do with
    the protocol is taken care of by the development framework. However, at the time
    of writing, none of its features rely on well-established standards, so it cannot
    be used for publicly exposed endpoints – it can only be used for intra-cluster
    communication. For this reason, we will not describe gRPC in detail, but the *Further
    reading* section of this chapter contains references to both gRPC in general and
    to its .NET Core implementation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于gRPC对数据的更紧凑表示以及更易于使用，因为协议的所有内容都由开发框架处理，所以gRPC比REST服务协议更有效。然而，在撰写本文时，它的特性都不依赖于成熟的标准，因此不能用于公开的端点
    - 它只能用于集群内部通信。因此，我们不会详细描述gRPC，但本章的*进一步阅读*部分包含了对gRPC的一般参考以及其.NET Core实现的引用。
- en: Using gRPC is super easy since Visual Studio's gRPC project template scaffolds
    everything so that the gRPC service and its clients are working. The developer
    just needs to define the application-specific C# service interface and a class
    that implements it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用gRPC非常简单，因为Visual Studio的gRPC项目模板会自动生成gRPC服务和其客户端的所有内容。开发人员只需定义特定于应用程序的C#服务接口和实现它的类。
- en: You can check details about this implementation at [https://docs.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-5.0](https://docs.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-5.0).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-5.0](https://docs.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-5.0)上查看有关此实现的详细信息。
- en: The remainder of the section is dedicated to .NET Core support for REST services
    from both the server and client side.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分专门介绍了.NET Core对REST服务的支持，包括服务器端和客户端。
- en: A short introduction to ASP.NET Core
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASP.NET Core简介
- en: 'ASP.NET Core applications are .NET Core applications based on the *Host* concept
    we described in the *Using generic hosts* subsection of *Chapter 5*, *Applying
    a Microservice Architecture to Your Enterprise Application*. The `program.cs`
    file of each ASP.NET application creates a Host, builds it, and runs it with the
    following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core应用程序是基于我们在“使用通用主机”子章节中描述的*主机*概念的.NET Core应用程序，该子章节位于*第5章*的*将微服务架构应用于企业应用程序*中。每个ASP.NET应用程序的`program.cs`文件都会创建一个主机，构建它，并使用以下代码运行它：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`CreateDefaultBuilder` sets up a standard Host, while `ConfigureWebHostDefaults`
    configures it so that it can handle an HTTP pipeline. More specifically, it sets
    the `ContentRootPath` property of the `IWebHostEnvironment` interface for the
    current directory.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateDefaultBuilder`设置了一个标准主机，而`ConfigureWebHostDefaults`配置了它，以便它可以处理HTTP管道。更具体地说，它为当前目录设置了`IWebHostEnvironment`接口的`ContentRootPath`属性。'
- en: Then, it loads the configuration information from `appsettings.json` and `appsettings.[EnvironmentName].json`.
    Once loaded, the configuration information contained in the JSON object properties
    can be mapped to .NET object properties with the ASP.NET Core options framework.
    More specifically, `appsettings.json` and `appsettings.[EnvironmentName].json`
    are merged and the file's environment-specific information overrides the corresponding
    `appsettings.json` settings.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它从`appsettings.json`和`appsettings.[EnvironmentName].json`中加载配置信息。一旦加载，JSON对象属性中包含的配置信息可以使用ASP.NET
    Core选项框架映射到.NET对象属性。更具体地说，`appsettings.json`和`appsettings.[EnvironmentName].json`被合并，文件的特定于环境的信息会覆盖相应的`appsettings.json`设置。
- en: '`EnvironmentName` is taken from the `ASPNETCORE_ENVIRONMENT` environment variable.
    In turn, it is defined in the `Properties\launchSettings.json` file when the application
    runs in Visual Studio, over **Solution Explorer**. In this file, you can define
    several environments that can be selected with the dropdown next to Visual Studio''s
    run button **IIS Express**. By default, the **IIS Express** setting sets `ASPNETCORE_ENVIRONMENT`
    to `Development`. The following is a typical `launchSettings.json` file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`EnvironmentName`取自`ASPNETCORE_ENVIRONMENT`环境变量。反过来，当应用程序在Visual Studio中运行时，它在`Properties\launchSettings.json`文件中定义，位于**解决方案资源管理器**上方。在此文件中，您可以定义几个可以使用下拉菜单选择的环境，该下拉菜单位于Visual
    Studio运行按钮**IIS Express**旁边。默认情况下，**IIS Express**设置将`ASPNETCORE_ENVIRONMENT`设置为`Development`。以下是一个典型的`launchSettings.json`文件：'
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The value to use for `ASPNETCORE_ENVIRONMENT` when the application is published
    can be added to the published XML file after it has been created by Visual Studio.
    This value is `<EnvironmentName>Staging</EnvironmentName>`. It can also be specified
    in your Visual Studio ASP.NET Core project file (`.csproj`):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序发布时，可以在Visual Studio创建的发布XML文件中添加要使用的`ASPNETCORE_ENVIRONMENT`值。该值为`<EnvironmentName>Staging</EnvironmentName>`。它也可以在您的Visual
    Studio ASP.NET Core项目文件（`.csproj`）中指定：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Later, the application configures Host logging so that it can write to the console
    and debug output. This setting can be changed with further configuration. Then,
    it sets up/connects a web server to the ASP.NET Core pipeline.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，应用程序配置主机日志记录，以便可以将日志写入控制台和调试输出。此设置可以通过进一步的配置进行更改。然后，它设置/连接Web服务器到ASP.NET
    Core管道。
- en: 'When the application runs in Linux, the ASP.NET Core pipeline connects to the
    .NET Core Kestrel web server. Since Kestrel is a minimal web server, you are responsible
    for reverse proxying requests to it from a complete web server, such as Apache
    or NGINX, that adds features that Kestrel does not have. When the application
    runs in Windows, by default, `ConfigureWebHostDefaults` connects the ASP.NET Core
    pipeline directly to **Internet Information Services** (**IIS**). However, you
    can also use Kestrel in Windows and you can reverse proxy IIS requests to Kestrel
    by changing the `AspNetCoreHostingModel` setting of your Visual Studio project
    file like so:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序在Linux上运行时，ASP.NET Core管道连接到.NET Core Kestrel Web服务器。由于Kestrel是一个最小的Web服务器，您需要负责从完整的Web服务器（如Apache或NGINX）进行反向代理请求，以添加Kestrel没有的功能。当应用程序在Windows上运行时，默认情况下，`ConfigureWebHostDefaults`将ASP.NET
    Core管道直接连接到**Internet Information Services**（**IIS**）。但是，您也可以在Windows中使用Kestrel，并且可以通过更改Visual
    Studio项目文件的`AspNetCoreHostingModel`设置将IIS请求反向代理到Kestrel。
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`UseStartup<Startup>()` lets Host services (see the *Using generic hosts* subsection
    in *Chapter 5*, *Applying a Microservice Architecture to Your Enterprise Application*)
    and the definition of the ASP.NET Core pipeline be taken from the methods of the
    project''s `Startup.cs` class. More specifically, services are defined in its
    `ConfigureServices(IServiceCollection services)` method, while the ASP.NET Core
    pipeline is defined in the `Configure` method. The following code shows the standard
    `Configure` method scaffolded with an API REST project:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseStartup<Startup>()`允许主机服务（参见*第5章*的*使用通用主机*子章节，将ASP.NET Core管道的定义从项目的`Startup.cs`类的方法中获取。更具体地说，服务在其`ConfigureServices(IServiceCollection
    services)`方法中定义，而ASP.NET Core管道在`Configure`方法中定义。以下代码显示了使用API REST项目生成的标准`Configure`方法：'
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Each middleware in the pipeline is defined by an `app.Use<something>` method,
    which often accepts some options. Each of them processes the requests and then
    either forwards the modified request to the next one in the pipeline or returns
    an HTTP response. When an HTTP response is returned, it is processed by all the
    previous ones in reverse order.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 管道中的每个中间件都由一个`app.Use<something>`方法定义，通常接受一些选项。它们中的每一个都处理请求，然后要么将修改后的请求转发到管道中的下一个中间件，要么返回HTTP响应。当返回HTTP响应时，它将按相反的顺序由所有先前的中间件处理。
- en: Modules are inserted in the pipeline in the order they are defined by the `app.Use<something>`
    method calls. The preceding code adds an error page if `ASPNETCORE_ENVIRONMENT`
    is `Development`; otherwise, `UseHsts` negotiates a security protocol with the
    client. Finally, `UseEndpoints` adds the MVC controllers that create the actual
    HTTP response. A complete description of the ASP.NET Core pipeline will be given
    in the *Understanding the presentation layers of web applications* section of
    *Chapter 15*, *Presenting ASP.NET Core MVC*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 模块按照它们被`app.Use<something>`方法调用定义的顺序插入到管道中。前面的代码在`ASPNETCORE_ENVIRONMENT`为`Development`时添加了一个错误页面；否则，`UseHsts`与客户端协商安全协议。最后，`UseEndpoints`添加了创建实际HTTP响应的MVC控制器。ASP.NET
    Core管道的完整描述将在*第15章*的*理解Web应用程序的表示层*部分中给出。
- en: In the next subsection, we will explain how the MVC framework lets you implement
    REST services.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将解释MVC框架如何让您实现REST服务。
- en: Implementing REST services with ASP.NET Core
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ASP.NET Core实现REST服务
- en: Today, we can guarantee that the use of MVC and a Web API is consolidated. In the
    MVC framework, HTTP requests are processed by classes called controllers. Each
    request is mapped to the call of a controller public method. The selected controller
    and controller methods depend on the shape of the request path, and they are defined
    by routing rules, that, for the REST API, are usually provided through attributes
    associated with both the `Controller` class and its methods.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们可以保证MVC和Web API的使用已经得到巩固。在MVC框架中，HTTP请求由称为控制器的类处理。每个请求都映射到调用控制器公共方法。所选的控制器和控制器方法取决于请求路径的形状，并且由路由规则定义，对于REST
    API，通常通过与`Controller`类及其方法相关联的属性提供。
- en: '`Controller` methods that process HTTP requests are called action methods.
    When the controller and action methods are selected, the MVC framework creates
    a controller instance to serve the request. All the parameters of the controller
    constructors are resolved with dependency injection with types defined in the
    `ConfigureServices` method of the `Startup.cs` class.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 处理HTTP请求的`Controller`方法称为操作方法。当选择控制器和操作方法时，MVC框架会创建一个控制器实例来处理请求。控制器构造函数的所有参数都通过`Startup.cs`类的`ConfigureServices`方法中定义的类型进行依赖注入解析。
- en: Please refer to the *Using generic hosts* subsection of *Chapter 5*, *Applying
    a Microservice Architecture to Your Enterprise Application*, for a description
    of how to use dependency injection with .NET Core Hosts, and to the *Dependency
    Injection pattern* subsection of *Chapter 11*, *Design Patterns and .NET 5 Implementation*,
    for a general discussion of dependency injection.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何在.NET Core主机中使用依赖注入的描述，请参阅*第5章*的*应用微服务架构到企业应用程序*的*使用通用主机*子章节，并参阅*第11章*的*设计模式和.NET
    5实现*的*依赖注入模式*子章节，以获取有关依赖注入的一般讨论。
- en: 'The following is a typical REST API controller and its controller method definitions:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个典型的REST API控制器及其控制器方法定义：
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `[ApiController]` attribute declares that the controller is a REST API controller.
    `[Route("api/[controller]")]` declares that the controller must be selected on
    paths that start with `api/<controller name>`. The controller name is the name
    of the controller class without the `Controller` postfix. Thus, in this case,
    we have `api/values`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`[ApiController]`属性声明控制器是一个REST API控制器。`[Route("api/[controller]")]`声明控制器必须在以`api/<controller
    name>`开头的路径上进行选择。控制器名称是控制器类的名称，不包括`Controller`后缀。因此，在这种情况下，我们有`api/values`。'
- en: '`[HttpGet("{id}")]` declares that the method must be invoked on GET requests
    of the `api/values/<id>` type, where `id` must be a number that''s passed as an
    argument to the method invocation. This can be done with `Get(int id)`. There
    is also an `Http<verb>` attribute for each HTTP verb: `HttpPost` and `HttpPatch`.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`[HttpGet("{id}")]`声明该方法必须在`api/values/<id>`类型的GET请求上调用，其中`id`必须是作为方法调用参数传递的数字。可以使用`Get(int
    id)`来实现。每个HTTP动词也有一个`Http<verb>`属性：`HttpPost`和`HttpPatch`。'
- en: 'We may also have another method defined like so:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义另一个方法如下：
- en: '[PRE18]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method is invoked on `GET` requests of the `api/values` type, that is,
    on `GET` requests without `id` after the controller name.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是在`api/values`类型的`GET`请求上调用的，也就是在控制器名称后没有`id`的`GET`请求上调用的。
- en: Several action methods can have the same name, but only one should be compatible
    with each request path; otherwise, an exception is thrown. In other words, routing
    rules and `Http<verb>` attributes must univocally define which controller and
    which of its action methods to select for each request.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 多个操作方法可以具有相同的名称，但只有一个应与每个请求路径兼容；否则，将抛出异常。换句话说，路由规则和`Http<verb>`属性必须明确定义每个请求的哪个控制器及其哪个操作方法。
- en: 'By default, parameters are passed to the action methods of API controllers
    according to the following rules:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数根据以下规则传递给API控制器的操作方法：
- en: Simple types (`integers`, `floats`, and `DateTimes`) are taken from the request
    path if routing rules specify them as parameters, as in the case of the previous
    example's `[HttpGet("{id}")]` attribute. If they are not found in the routing
    rules, the MVC framework looks for query string parameters with the same name.
    Thus, for instance, if we replace `[HttpGet("{id}")]` with `[HttpGet]`, the MVC
    framework will look for something like `api/values?id=<an integer>`.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果路由规则将简单类型（`整数`、`浮点数`和`日期时间`）指定为参数，它们将从请求路径中获取，就像前面示例的`[HttpGet("{id}")]`属性一样。如果它们在路由规则中找不到，MVC框架将查找具有相同名称的查询字符串参数。因此，例如，如果我们用`[HttpGet]`替换`[HttpGet("{id}")]`，MVC框架将查找类似`api/values?id=<整数>`的内容。
- en: Complex types are extracted from the request body by formatters. The right formatter
    is chosen according to the value of the request's `Content-Type` header. If no
    `Content-Type` header is specified, the JSON formatter is taken. The JSON formatter
    tries to parse the request body as a JSON object and then tries to transform this
    JSON object into an instance of the .NET Core complex type. If either the JSON
    extraction or the subsequent conversion fails, an exception is thrown. By default,
    just the JSON input formatter is supported, but you can also add an XML formatter
    that can be used when `Content-Type` specifies XML content. It is enough to add
    the `Microsoft.AspNetCore.Mvc.Formatters.Xml` NuGet package and replace `services.AddControllers()`
    with `services.AddControllers().AddXmlSerializerFormatters()` in the `ConfigureServices`
    method of `Startup.cs`.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂类型是由格式化程序从请求正文中提取的。根据请求的`Content-Type`标头的值选择正确的格式化程序。如果未指定`Content-Type`标头，则采用JSON格式化程序。JSON格式化程序尝试解析请求正文作为JSON对象，然后尝试将此JSON对象转换为.NET
    Core复杂类型的实例。如果JSON提取或随后的转换失败，将抛出异常。默认情况下，只支持JSON输入格式化程序，但您还可以添加一个XML格式化程序，当`Content-Type`指定XML内容时可以使用。只需添加`Microsoft.AspNetCore.Mvc.Formatters.Xml`
    NuGet软件包，并在`Startup.cs`的`ConfigureServices`方法中用`services.AddControllers().AddXmlSerializerFormatters()`替换`services.AddControllers()`即可。
- en: 'You can customize the source that is used to fill an action method parameter
    by prefixing the parameter with an adequate attribute. The following code shows
    some examples of this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用适当的属性为操作方法参数添加前缀来自定义用于填充操作方法参数的源。以下代码显示了一些示例：
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The return type of an `Action` method must be an `IActionResult` interface
    or a type that implements that interface. In turn, `IActionResult` has just the
    following method:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Action`方法的返回类型必须是`IActionResult`接口或实现该接口的类型。反过来，`IActionResult`只有以下方法：'
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This method is called by the MVC framework at the right time to create the actual
    response and response headers. The `ActionContext` object, when passed to the
    method, contains the whole context of the HTTP request, which includes a request
    object with all the necessary information about the original HTTP requests (headers,
    body, and cookies), as well as a response object that collects all the pieces
    of the response that is being built.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在正确的时间由MVC框架调用，以创建实际的响应和响应头。当传递给方法时，`ActionContext`对象包含HTTP请求的整个上下文，其中包括一个包含有关原始HTTP请求的所有必要信息的请求对象（标头、正文和cookie），以及一个收集正在构建的响应的所有部分的响应对象。
- en: You do not have to create an implementation of `IActionResult` manually, since
    `ControllerBase` already has methods to create `IActionResult` implementations
    so that all the necessary HTTP responses are generated. Some of these methods
    are as follows.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必手动创建`IActionResult`的实现，因为`ControllerBase`已经有了创建`IActionResult`实现的方法，以便生成所有必要的HTTP响应。其中一些方法如下。
- en: '`OK`: This returns a 200 status code, as well as an optional result object.
    It is used either as `return OK()` or as `return OK(myResult)`.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OK`：这返回一个200状态代码，以及一个可选的结果对象。它可以作为`return OK()`或`return OK(myResult)`使用。'
- en: '`BadRequest`: This returns a 400 status code, as well as an optional response
    object.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BadRequest`：这返回一个400状态代码，以及一个可选的响应对象。'
- en: '`Created(string uri, object o)`: This returns a 201 status code, as well as
    a result object and the URI of the created resource.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Created(string uri, object o)`：这返回一个201状态代码，以及一个结果对象和创建的资源的URI。'
- en: '`Accepted`: This returns a 202 status result, as well as an optional result
    object and resource URI.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Accepted`：这返回一个202状态结果，以及一个可选的结果对象和资源URI。'
- en: '`Unauthorized`: This returns a 401 status result, as well as an optional result
    object.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unauthorized`：这返回一个401状态结果，以及一个可选的结果对象。'
- en: '`Forbid`: This returns a 403 status result, as well as an optional list of
    failed permissions.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Forbid`：这返回一个403状态结果，以及一个可选的失败权限列表。'
- en: '`StatusCode(int statusCode, object o = null)`: This returns a custom status
    code, as well as an optional result object.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StatusCode(int statusCode, object o = null)`：这返回一个自定义状态码，以及一个可选的结果对象。'
- en: An action method can return a result object directly with `return myObject`.
    This is equivalent to returning `OK(myObject)`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 操作方法可以直接返回一个结果对象，如 `return myObject`。这相当于返回 `OK(myObject)`。
- en: When all the result paths return a result object of the same type, say, `MyType`,
    the action method can be declared as returning `ActionResult<MyType>`. You may
    also return responses like `NotFound`, but for sure you will get a better type
    check with this approach.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有结果路径返回相同类型的结果对象，比如 `MyType`，操作方法可以声明为返回 `ActionResult<MyType>`。您也可以返回诸如 `NotFound`
    的响应，但是通过这种方法肯定会得到更好的类型检查。
- en: By default, result objects are serialized in JSON in the response body. However,
    if an XML formatter has been added to the MVC framework processing pipeline, as shown
    previously, the way the result is serialized depends on the `Accept` header of
    the HTTP request. More specifically, if the client explicitly requires XML format
    with the `Accept` header, the object will be serialized in XML; otherwise, it
    will be serialized in JSON.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，结果对象以 JSON 格式序列化在响应主体中。然而，如果在 MVC 框架处理管道中添加了 XML 格式化程序，如前所示，结果的序列化方式取决于
    HTTP 请求的 `Accept` 标头。更具体地说，如果客户端明确要求 XML 格式的 `Accept` 标头，对象将以 XML 格式序列化；否则，它将以
    JSON 格式序列化。
- en: 'Complex objects that are passed as input to action methods can be validated
    with validation attributes, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输入传递给操作方法的复杂对象可以使用验证属性进行验证，如下所示：
- en: '[PRE21]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If the controller has been decorated with the `[ApiController]` attribute and
    if validation fails, the MVC framework automatically creates a `BadRequest` response
    containing a dictionary with all the validation errors detected, without executing
    the action method. Therefore, you do not need to add further code to handle validation
    errors.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果控制器已经使用了 `[ApiController]` 属性进行装饰，并且验证失败，MVC 框架会自动创建一个包含所有检测到的验证错误的字典的 `BadRequest`
    响应，而不执行操作方法。因此，您无需添加进一步的代码来处理验证错误。
- en: 'Action methods can also be declared as async methods, as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 操作方法也可以声明为异步方法，如下所示：
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Practical examples of controllers/action methods will be shown in the *Use case*
    section of this chapter. In the next subsection, we will explain how to handle
    authorization and authentication with JWT tokens.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的*用例*部分将展示控制器/操作方法的实际示例。在下一小节中，我们将解释如何处理 JWT 令牌的授权和身份验证。
- en: ASP.NET Core service authorization
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ASP.NET Core 服务授权
- en: 'When using a JWT token, authorizations are based on the claims contained in
    the JWT token. All the token claims in any action method can be accessed through
    the `User.Claims` controller property. Since `User.Claims` is an `IEnumerable<Claim>`,
    it can be processed with `LINQ` to verify complex conditions on claims. If authorization
    is based on *role* claims, you can simply use the `User.IsInRole` function, as
    shown in the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 JWT 令牌时，授权是基于 JWT 令牌中包含的声明。任何操作方法中的所有令牌声明都可以通过 `User.Claims` 控制器属性访问。由于
    `User.Claims` 是一个 `IEnumerable<Claim>`，它可以使用 `LINQ` 处理以验证声明的复杂条件。如果授权基于 *角色* 声明，您可以简单地使用
    `User.IsInRole` 函数，如下所示：
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, permissions are not usually checked from within action methods and
    are automatically checked by the MVC framework, according to authorization attributes
    that decorate either the whole controller or a single action method. If an action
    method or the whole controller is decorated with `[Authorize]`, then access to
    the action method is possible only if the request has a valid authentication token,
    which means we don''t have to perform a check on the token claims. It is also
    possible to check whether the token contains a set of roles using the following
    code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，权限通常不是从操作方法内部检查的，而是由 MVC 框架自动检查，根据装饰整个控制器或单个操作方法的授权属性。如果操作方法或整个控制器使用 `[Authorize]`
    装饰，那么只有在请求具有有效的身份验证令牌时才能访问操作方法，这意味着我们不必对令牌声明进行检查。还可以使用以下代码检查令牌是否包含一组角色：
- en: '[PRE24]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'More complex conditions on claims require that authorization policies be defined
    in the `ConfigureServices` method of `Startup.cs`, as shown in the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对声明的复杂条件需要在 `Startup.cs` 的 `ConfigureServices` 方法中定义授权策略，如下所示：
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After that, you can decorate the action methods or controllers with `[Authorize(Policy
    = "Father")]`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可以使用 `[Authorize(Policy = "Father")]` 装饰操作方法或控制器。
- en: 'Before using JWT-based authorization, you must configure it in `Startup.cs`.
    First, you must add the middleware that processes authentication tokens in the
    ASP.NET Core processing pipeline defined in the `Configure` method, as shown here:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用基于 JWT 的授权之前，您必须在 `Startup.cs` 中进行配置。首先，您必须在 `Configure` 方法中定义的 ASP.NET Core
    处理管道中添加处理身份验证令牌的中间件，如下所示：
- en: '[PRE26]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, you must configure the authentication services in the `ConfigureServices`
    section. Here, you define the authentication options that will be injected through
    dependency injection into the authentication middleware:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您必须在 `ConfigureServices` 部分配置身份验证服务。在这里，您定义将通过依赖注入注入到身份验证中间件中的身份验证选项：
- en: '[PRE27]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code provides a name to the authentication scheme, that is, a
    default name. Then, it specifies JWT authentication options. Usually, we require
    that the authentication middleware verifies that the JWT token is not expired
    (`ValidateLifetime = true`), that it has the right issuer and audience (see the
    *REST services authorization and authentication* section of this chapter), and
    that its signature is valid.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码为身份验证方案提供了一个名称，即默认名称。然后，它指定了 JWT 身份验证选项。通常，我们要求身份验证中间件验证 JWT 令牌是否未过期（`ValidateLifetime
    = true`），它具有正确的发行者和受众（请参阅本章的*REST 服务授权和身份验证*部分），以及其签名是否有效。
- en: The preceding example uses a symmetric signing key generated from a string.
    This means that the same key is used to sign and to verify the signature. This
    is an acceptable choice if JWT tokens are created by the same website that uses
    them, but it is not an acceptable choice if there is a unique JWT issuer that
    controls access to several Web API sites.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例使用了从字符串生成的对称签名密钥。这意味着相同的密钥用于签名和验证签名。如果JWT令牌是由使用它们的同一个网站创建的，这是一个可以接受的选择，但如果有一个唯一的JWT发行者控制对多个Web
    API站点的访问，这是一个不可接受的选择。
- en: Here, we should use an asymmetric key (typically, an `RsaSecurityKey`), so JWT
    verification requires just the knowledge of the public key associated with the
    actual private signing key. Identity Server 4 can be used to quickly create a
    website that works as an authentication server. It emits a JWT token with the
    usual username/password credentials or converts other authentication tokens. If
    you use an authentication server such as Identity Server 4, you do not need to
    specify the `IssuerSigningKey` option, since the authorization middleware is able
    to retrieve the required public key from the authorization server automatically.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们应该使用非对称密钥（通常是`RsaSecurityKey`），因此JWT验证只需要知道与实际私钥相关联的公钥。Identity Server
    4可以用于快速创建一个作为身份验证服务器的网站。它发出带有通常的用户名/密码凭据或转换其他身份验证令牌的JWT令牌。如果您使用诸如Identity Server
    4之类的身份验证服务器，您不需要指定`IssuerSigningKey`选项，因为授权中间件能够自动从授权服务器检索所需的公钥。
- en: 'It is enough to provide the authentication server URL, as shown here:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 只需提供身份验证服务器的URL，如下所示：
- en: '[PRE28]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'On the other hand, if you decide to emit JWT in your Web API''s site, you can
    define a `Login` action method that accepts an object with a username and password,
    and that, while relying on database information, builds the JWT token with code
    similar to the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果决定在Web API站点中发出JWT，可以定义一个接受包含用户名和密码的对象的`Login`操作方法，并且在依赖于数据库信息的同时，使用类似以下代码构建JWT令牌：
- en: '[PRE29]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, `JwtSecurityTokenHandler().WriteToken(token)` generates the actual token
    string from the token properties contained in the `JwtSecurityToken` instance.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`JwtSecurityTokenHandler().WriteToken(token)`从`JwtSecurityToken`实例中包含的令牌属性生成实际的令牌字符串。
- en: In the next subsection, we will learn how to empower our Web API with an OpenAPI
    documentation point so that proxy classes for communicating with our services
    can be generated automatically.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将学习如何通过OpenAPI文档端点增强我们的Web API，以便可以自动生成用于与我们的服务通信的代理类。
- en: ASP.NET Core support for OpenAPI
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ASP.NET Core对OpenAPI的支持
- en: Most of the information that is needed to fill in an OpenAPI JSON document can
    be extracted from Web API controllers through reflection, that is, input types
    and sources (path, request body, and header) and endpoint paths (these can be
    extracted from routing rules). Returned output types and status codes, in general,
    cannot be easily computed since they can be generated dynamically.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过反射，大部分填写OpenAPI JSON文档所需的信息可以从Web API控制器中提取，即输入类型和来源（路径、请求体和标头）以及端点路径（这些可以从路由规则中提取）。一般来说，返回的输出类型和状态码不能轻松计算，因为它们可以动态生成。
- en: 'Therefore, the MVC framework provides the `ProducesResponseType` attribute
    so that we can declare a possible return type – a status code pair. It is enough
    to decorate each action method with as many `ProducesResponseType` attributes
    as there are possible types, that is, possible status code pairs, as shown in
    the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，MVC框架提供了`ProducesResponseType`属性，以便我们可以声明可能的返回类型 - 状态码对。只需为每个操作方法装饰上与可能的类型相同数量的`ProducesResponseType`属性，即可能的状态码对，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If no object is returned along a path, we can just declare the status code,
    as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果沿着某个路径没有返回对象，我们可以只声明状态码，如下所示：
- en: '[PRE31]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can also specify just the status code when all the paths return the same
    type and when that type is specified in the action method return type as `ActionResult<CommonReturnType>`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有路径返回相同类型且该类型在操作方法返回类型中指定为`ActionResult<CommonReturnType>`时，我们也可以只指定状态码。
- en: 'Once all the action methods have been documented, to generate any actual documentation
    for the JSON endpoints, we must install the `Swashbuckle.AspNetCore` NuGet package
    and place some code in the `Startup.cs` file. More specifically, we must add some
    middleware in the `Configure` method, as shown here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有操作方法都已记录，要为JSON端点生成任何实际的文档，我们必须安装`Swashbuckle.AspNetCore` NuGet软件包，并在`Startup.cs`文件中放置一些代码。更具体地说，我们必须在`Configure`方法中添加一些中间件，如下所示：
- en: '[PRE32]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we must add some configuration options in the `ConfigureServices` method,
    as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须在`ConfigureServices`方法中添加一些配置选项，如下所示：
- en: '[PRE33]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first argument of the `SwaggerDoc` method is the documentation endpoint
    name. By default, the documentation endpoint is accessible through the `<webroot>//swagger/<endpoint
    name>/swagger.json` path, but this can be changed in several ways. The rest of
    the information contained in the `Info` class is self-explanatory.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`SwaggerDoc`方法的第一个参数是文档端点名称。默认情况下，文档端点可以通过`<webroot>//swagger/<endpoint name>/swagger.json`路径访问，但可以通过多种方式进行更改。`Info`类中包含的其余信息是不言自明的。'
- en: We can add several `SwaggerDoc` calls to define several documentation endpoints.
    However, by default, all the documentation endpoints will contain the same documentation,
    which includes a description of all the REST services included in the project.
    This default can be changed by calling the `c.DocInclusionPredicate(Func<string,
    ApiDescription> predicate)` method from within `services.AddSwaggerGen(c => {...})`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加多个`SwaggerDoc`调用来定义多个文档端点。然而，默认情况下，所有文档端点将包含相同的文档，其中包括项目中包含的所有REST服务的描述。可以通过在`services.AddSwaggerGen(c
    => {...})`中调用`c.DocInclusionPredicate(Func<string, ApiDescription> predicate)`方法来更改此默认设置。
- en: '`DocInclusionPredicate` must be passed a function that receives a JSON document
    name and an action method description and must return `true` if the documentation
    of the action must be included in that JSON document.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`DocInclusionPredicate`必须传递一个函数，该函数接收一个JSON文档名称和一个操作方法描述，并且必须在该JSON文档中包含操作的文档时返回`true`。'
- en: 'To declare that your REST APIs need a JWT token, you must add the following
    code within `services.AddSwaggerGen(c => {...})`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明您的REST API需要JWT令牌，您必须在`services.AddSwaggerGen(c => {...})`中添加以下代码：
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can enrich the JSON documentation endpoint with information that has been
    extracted from triple-slash comments, which are usually added to generate automatic
    code documentation. The following code shows some examples of this. The following
    snippet shows how we can add a method description and parameter information:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用从三斜杠注释中提取的信息来丰富JSON文档端点，这些注释通常用于生成自动代码文档。以下代码显示了一些示例。以下代码片段显示了如何添加方法描述和参数信息：
- en: '[PRE35]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following snippet shows how we can add an example of usage:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何添加使用示例：
- en: '[PRE36]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following snippet shows how we can add parameter descriptions and return
    type descriptions for each HTTP status code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何为每个HTTP状态代码添加参数描述和返回类型描述：
- en: '[PRE37]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To enable extraction from triple-slash comments, we must enable code documentation
    creation by adding the following code in our project file (`.csproj`):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要从三斜杠注释中提取信息，我们必须通过在项目文件（`.csproj`）中添加以下代码来启用代码文档创建：
- en: '[PRE38]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we must enable code documentation processing from within `services.AddSwaggerGen(c
    => {...})` by adding the following code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须通过添加以下代码来从`services.AddSwaggerGen(c => {...})`中启用代码文档处理：
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once our documentation endpoints are ready, we can add some more middleware
    that is contained in the same `Swashbuckle.AspNetCore` NuGet package to generate
    a friendly user interface that we can test our REST API on:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的文档端点准备就绪，我们可以添加一些中间件，该中间件包含在相同的`Swashbuckle.AspNetCore` NuGet包中，以生成一个友好的用户界面，我们可以在其上测试我们的REST
    API：
- en: '[PRE40]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you have several documentation endpoints, you need to add a `SwaggerEndpoint`
    call for each of them. We will use this interface to test the REST API defined
    in this chapter's use case.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个文档端点，您需要为每个端点添加一个`SwaggerEndpoint`调用。我们将使用此接口来测试本章中定义的REST API。
- en: 'Once you have a working JSON documentation endpoint, you can automatically
    generate the C# or TypeScript code of a proxy class with one of the following
    methods:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有一个可用的JSON文档端点，您可以使用以下方法之一自动生成代理类的C#或TypeScript代码：
- en: The NSwagStudio Windows program, which is available at [https://github.com/RicoSuter/NSwag/wiki/NSwagStudio](https://github.com/RicoSuter/NSwag/wiki/NSwagStudio).
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NSwagStudio Windows程序，可在[https://github.com/RicoSuter/NSwag/wiki/NSwagStudio](https://github.com/RicoSuter/NSwag/wiki/NSwagStudio)上获得。
- en: The `NSwag.CodeGeneration.CSharp` or `NSwag.CodeGeneration.TypeScript` NuGet
    packages if you want to customize code generation.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想自定义代码生成，可以使用`NSwag.CodeGeneration.CSharp`或`NSwag.CodeGeneration.TypeScript`
    NuGet包。
- en: The `NSwag.MSBuild` NuGet package if you want to tie code generation to Visual
    Studio build operations. The documentation for this can be found at [https://github.com/RicoSuter/NSwag/wiki/MSBuild](https://github.com/RicoSuter/NSwag/wiki/MSBuild).
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想将代码生成与Visual Studio构建操作绑定在一起，可以使用`NSwag.MSBuild` NuGet包。有关此的文档可以在[https://github.com/RicoSuter/NSwag/wiki/MSBuild](https://github.com/RicoSuter/NSwag/wiki/MSBuild)找到。
- en: In the next subsection, you will learn how to invoke a REST API from another
    REST API or from a .NET Core client.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，您将学习如何从另一个REST API或.NET Core客户端调用REST API。
- en: .Net Core HTTP clients
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .Net Core HTTP客户端
- en: 'The `HttpClient` class in the `System.Net.Http` namespace is a .NET standard
    2.0 built-in HTTP client class. While it could be used directly whenever we need
    to interact with a REST service, there are some problems in creating and releasing
    `HttpClient` instances repeatedly, as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Net.Http`命名空间中的`HttpClient`类是一个.NET标准2.0内置的HTTP客户端类。虽然它可以直接使用，但在重复创建和释放`HttpClient`实例时会出现一些问题，如下所示：'
- en: Their creation is expensive.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的创建是昂贵的。
- en: When an `HttpClient` is released, for instance, in a `using` statement, the
    underlying connection is not closed immediately but at the first garbage collection
    session, which is a repeated creation. Release operations quickly exhaust the
    maximum number of connections the operating system can handle.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，当`HttpClient`在`using`语句中被释放时，底层连接不会立即关闭，而是在第一次垃圾回收会话时关闭，这是一个重复的创建。释放操作会迅速耗尽操作系统可以处理的最大连接数。
- en: Therefore, either a single `HttpClient` instance is reused, such as a singleton,
    or `HttpClient` instances are somehow pooled. Starting from the 2.1 version of
    .NET Core, the `HttpClientFactory` class was introduced to pool HTTP clients.
    More specifically, whenever a new `HttpClient` instance is required for an `HttpClientFactory`
    object, a new `HttpClient` is created. However, the underlying `HttpClientMessageHandler`
    instances, which are expensive to create, are pooled until their maximum lifetime
    expires.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要么重用单个`HttpClient`实例，比如单例，要么以某种方式对`HttpClient`实例进行池化。从.NET Core 2.1版本开始，引入了`HttpClientFactory`类来对HTTP客户端进行池化。更具体地说，每当需要为`HttpClientFactory`对象创建新的`HttpClient`实例时，都会创建一个新的`HttpClient`。但是，昂贵创建的底层`HttpClientMessageHandler`实例会在其最大生命周期到期之前被池化。
- en: '`HttpClientMessageHandler` instances must have a finite duration since they
    cache DNS resolution information that may change over time. The default lifetime
    of `HttpClientMessageHandler` is 2 minutes, but it can be redefined by the developer.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClientMessageHandler`实例必须具有有限的持续时间，因为它们缓存可能随时间变化的DNS解析信息。`HttpClientMessageHandler`的默认生命周期为2分钟，但可以由开发人员重新定义。'
- en: Using `HttpClientFactory` allows us to automatically pipeline all the HTTP operations
    with other operations. For instance, we can add a Polly retry strategy to handle
    all the failures of all our HTTP operations automatically. For an introduction
    to Polly, please refer to the *Resilient task execution* subsection of *Chapter
    5*, *Applying a Microservice Architecture to Your Enterprise Application*.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`HttpClientFactory`允许我们自动将所有HTTP操作与其他操作进行管道化。例如，我们可以添加Polly重试策略来处理所有HTTP操作的失败。有关Polly的介绍，请参阅*第5章*的*将微服务架构应用于企业应用程序*的*弹性任务执行*子部分。
- en: 'The simplest way to exploit the advantages offered by the `HttpClientFactory`
    class is to add the `Microsoft.Extensions.Http` NuGet package and then to follow
    these steps:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 利用`HttpClientFactory`类提供的优势的最简单方法是添加`Microsoft.Extensions.Http` NuGet包，然后按照以下步骤操作：
- en: Define a proxy class, say, `MyProxy`, to interact with the desired REST service.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个代理类，比如`MyProxy`，以与所需的REST服务进行交互。
- en: Let `MyProxy` accept an `HttpClient` instance in its constructor.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让`MyProxy`在其构造函数中接受一个`HttpClient`实例。
- en: Use the `HttpClient` that was injected into the constructor to implement all
    the necessary operations.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用注入到构造函数中的`HttpClient`来实现所有必要的操作。
- en: Declare your proxy in the services configuration method of your Host which,
    in the case of an ASP.NET Core application, is the `ConfigureServices` method
    of the `Startup.cs` class, while, in the case of a client application, this is
    the `ConfigureServices` method of the `HostBuilder` instance. In the simplest
    case, the declaration is something similar to `services.AddHttpClient<MyProxy>()`.
    This will automatically add `MyProxy` to the services that are available for dependency
    injection, so you can easily inject it, for instance, in your controller's constructors.
    Moreover, each time an instance of `MyProxy` is created, an `HttpClient` is returned
    by an `HttpClientFactory` and is automatically injected into its constructor.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主机的服务配置方法中声明您的代理，在ASP.NET Core应用程序的情况下，这是`Startup.cs`类的`ConfigureServices`方法，而在客户端应用程序的情况下，这是`HostBuilder`实例的`ConfigureServices`方法。在最简单的情况下，声明类似于`services.AddHttpClient<MyProxy>()`。这将自动将`MyProxy`添加到可用于依赖注入的服务中，因此您可以轻松地将其注入到控制器的构造函数中。此外，每次创建`MyProxy`的实例时，`HttpClientFactory`都会返回一个`HttpClient`并自动注入到其构造函数中。
- en: 'In the constructors of the classes that need to interact with a REST service,
    we may also need an interface instead of a specific proxy implementation with
    a declaration of the type:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要与REST服务进行交互的类的构造函数中，我们可能还需要一个接口，而不是具体的代理实现类型的声明：
- en: '[PRE41]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'A Polly resilient strategy (see the *Resilient task execution* subsection of
    *Chapter 5*, *Applying a Microservice Architecture to Your Enterprise Application*)
    can be applied to all the HTTP calls issued by our proxy class, as shown here:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 可以应用Polly弹性策略（请参阅*第5章*的*将微服务架构应用于企业应用程序*的*弹性任务执行*子部分）到我们代理类发出的所有HTTP调用，如下所示：
- en: '[PRE42]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we can preconfigure some of the properties of all the `HttpClient`
    instances that are passed to our proxy, as shown here:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以预先配置传递给我们代理的所有`HttpClient`实例的一些属性，如下所示：
- en: '[PRE43]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This way, each client that is passed to the proxy is preconfigured so that they
    require a JSON response and must work with a specific service. Once the base address
    has been defined, each HTTP request needs to specify the relative path of the
    service method to call.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，传递给代理的每个客户端都预先配置，以便它们需要JSON响应并且必须与特定服务一起工作。一旦定义了基本地址，每个HTTP请求都需要指定要调用的服务方法的相对路径。
- en: 'The following code shows how to perform a `POST` to a service. This requires
    an extra package, `System.Net.Http.Json`. Here, we are stating that the `HttpClient`
    that was injected into the proxy constructor has been stored in the `webClient`
    private field:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何执行对服务的`POST`。这需要一个额外的包`System.Net.Http.Json`。在这里，我们声明注入到代理构造函数中的`HttpClient`已存储在`webClient`私有字段中：
- en: '[PRE44]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you use Polly, you do not need to intercept and handle communication errors
    since this job is performed by Polly. First, you need to verify the status code
    to decide what to do next. Then, you can parse the JSON string contained in the
    response body to get a .NET instance of a type that, in general, depends on the
    status code. The code to perform the parsing is based on the `System.Text.Json`
    NuGet package''s `JsonSerializer` class and is as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Polly，则无需拦截和处理通信错误，因为Polly会执行此任务。首先，您需要验证状态代码以决定下一步该做什么。然后，您可以解析响应主体中包含的JSON字符串，以获得一个.NET类型的实例，通常取决于状态代码。执行解析的代码基于`System.Text.Json`
    NuGet包的`JsonSerializer`类，如下所示：
- en: '[PRE45]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Performing a GET request is similar but, instead of calling `PostAsJsonAsync`,
    you need to call `GetAsync`, as shown here. The use of other HTTP verbs is completely
    analogous:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 执行GET请求类似，但是，而不是调用`PostAsJsonAsync`，您需要调用`GetAsync`，如下所示。使用其他HTTP动词完全类似：
- en: '[PRE46]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can check in this topic, accessing HTTP APIs is quite simple and requires
    the implementation of some .NET 5 libraries. Since the beginning of .NET Core,
    Microsoft has been working a lot on the improvement of the performance and the
    simplicity of this part of the framework. It is up to you to keep in touch with
    the documentation and facilities they keep implementing.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可以在本主题中检查的那样，访问HTTP API非常简单，并且需要实现一些.NET 5库。自.NET Core开始，微软一直在努力改进框架的性能和简单性。您需要与他们不断实施的文档和设施保持联系。
- en: Use case – exposing WWTravelClub packages
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用情况 - 暴露WWTravelClub套餐
- en: In this section, we will implement an ASP.NET REST service that lists all the
    packages that are available for a given vacation's start and end dates. For didactic
    purposes, we will not structure the application according to the best practices
    described in *Chapter 12*, *Understanding the Different Domains in Software Solutions*;
    instead, we will simply generate the results with a LINQ query that will be directly
    placed in the controller action method. A well-structured ASP.NET Core application
    will be presented in *Chapter 15*, *Presenting ASP.NET Core MVC*, which is dedicated
    to the MVC framework.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个ASP.NET REST服务，列出给定假期开始和结束日期可用的所有套餐。出于教学目的，我们不会按照*第12章*中描述的最佳实践结构化应用程序；相反，我们将简单地使用LINQ查询生成结果，并直接放置在控制器操作方法中。一个良好结构化的ASP.NET
    Core应用程序将在*第15章*中介绍，*介绍ASP.NET Core MVC*，该章节专门介绍MVC框架。
- en: Let's make a copy of the `WWTravelClubDB` solution folder and rename the new
    folder `WWTravelClubREST`. The WWTravelClubDB project was built step by step in
    the various sections of *Chapter 8*, *Interacting with Data in C# – Entity Framework
    Core*. Let's open the new solution and add a new ASP.NET Core API project to it
    named `WWTravelClubREST` (the same name as the new solution folder). For simplicity,
    select no authentication. Right-click on the newly created project and select
    **Set as StartUp project** to make it the default project that is launched when
    the solution is run.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们复制`WWTravelClubDB`解决方案文件夹，并将新文件夹重命名为`WWTravelClubREST`。WWTravelClubDB项目是在*第8章*的各个部分逐步构建的，*在C#中与实体框架核心交互*。让我们打开新解决方案，并向其中添加一个名为`WWTravelClubREST`的新ASP.NET
    Core API项目（与新解决方案文件夹同名）。为简单起见，选择不进行身份验证。右键单击新创建的项目，选择**设置为启动项目**，使其成为运行解决方案时启动的默认项目。
- en: Finally, we need to add a reference to the WWTravelClubDB project.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要向WWTravelClubDB项目添加引用。
- en: 'ASP.NET Core projects store configuration constants in the `appsettings.json`
    file. Let''s open this file and add the database connection string for the database
    we created in the WWTravelClubDB project to it, as shown here:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core项目将配置常量存储在`appsettings.json`文件中。让我们打开这个文件，并向其中添加我们在WWTravelClubDB项目中创建的数据库连接字符串，如下所示：
- en: '[PRE47]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we must add the WWTravelClubDB entity framework database context to the
    `ConfigureServices` method in `Startup.cs`, as shown here:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须在`Startup.cs`的`ConfigureServices`方法中添加WWTravelClubDB实体框架数据库上下文，如下所示：
- en: '[PRE48]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The option object settings that are passed to `AddDbContext` specify the usage
    of SQL server with a connection string that is extracted from the `ConnectionStrings`
    section of the `appsettings.json` configuration file with the `Configuration.GetConnectionString("DefaultConnection")`
    method. The `b =>b.MigrationsAssembly("WWTravelClubDB")` lambda function declares
    the name of the assembly that contains the database migrations (see *Chapter 8*,
    *Interacting with Data in C# – Entity Framework Core*) which, in our case, is
    the DLL that was generated by the WWTravelClubDB project. For the preceding code
    to compile, you should add `Microsoft.EntityFrameworkCore`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`AddDbContext`的选项对象设置指定了使用从`appsettings.json`配置文件的`ConnectionStrings`部分提取的连接字符串的SQL服务器，使用`Configuration.GetConnectionString("DefaultConnection")`方法。`b
    =>b.MigrationsAssembly("WWTravelClubDB")` lambda函数声明了包含数据库迁移的程序集的名称（参见*第8章*，*在C#中与实体框架核心交互*），在我们的情况下，这是由WWTravelClubDB项目生成的DLL。为了使前面的代码编译，您应该添加`Microsoft.EntityFrameworkCore`。
- en: 'Since we want to enrich our REST service with OpenAPI documentation, let''s
    add a reference to the `Swashbuckle.AspNetCore` NuGet package. Now, we can add
    the following very basic configuration to the `ConfigureServices` method:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望使用OpenAPI文档丰富我们的REST服务，让我们添加对`Swashbuckle.AspNetCore` NuGet包的引用。现在，我们可以向`ConfigureServices`方法添加以下非常基本的配置：
- en: '[PRE49]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we can add the middleware for the OpenAPI endpoint and for adding a user
    interface for our API documentation, as shown here:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加OpenAPI端点的中间件，并为API文档添加用户界面，如下所示：
- en: '[PRE50]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we are ready to encode our service. Let''s delete `ValuesController`,
    which is automatically scaffolded by Visual Studio. Then, right-click on the `Controller`
    folder and select **Add** | **Controller**. Now, choose an empty API controller
    called `PackagesController`. First, let''s modify the code, as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备编码我们的服务。让我们删除Visual Studio自动生成的`ValuesController`。然后，右键单击`Controller`文件夹，选择**添加**
    | **控制器**。现在，选择一个名为`PackagesController`的空API控制器。首先，让我们修改代码，如下所示：
- en: '[PRE51]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `Route` attribute declares that the basic path for our service will be
    `api/packages`. The unique action method that we implement is `GetPackagesByDate`,
    which is invoked on `HttpGet` requests on paths of the `bydate/{start}/{stop}`
    type, where `start` and `stop` are the `DateTime` parameters that are passed as
    input to `GetPackagesByDate`. The `ProduceResponseType` attributes declare the
    following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`Route`属性声明了我们服务的基本路径将是`api/packages`。我们实现的唯一操作方法是`GetPackagesByDate`，它在`HttpGet`请求的路径上调用`bydate/{start}/{stop}`类型的路径，其中`start`和`stop`是作为输入传递给`GetPackagesByDate`的`DateTime`参数。`ProduceResponseType`属性声明如下：'
- en: When a request is successful, a 200 code is returned, and the body contains
    an `IEnumerable` of the `PackagesListDTO` (which we will soon define) type containing
    the required package information.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当请求成功时，将返回200代码，并且响应体包含`PackagesListDTO`（我们将很快定义）类型的`IEnumerable`，其中包含所需的包信息。
- en: When the request is ill-formed, a 400 code is returned. We don't specify the type
    returned since bad requests are automatically handled by the MVC framework through
    the `ApiController` attribute.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当请求格式不正确时，将返回400代码。我们不指定返回的类型，因为坏请求会通过`ApiController`属性自动由MVC框架处理。
- en: In the case of unexpected errors, a 500 code is returned with an empty body.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在出现意外错误的情况下，将返回500代码并带有空的响应体。
- en: 'Now, let''s define the `PackagesListDTO` class in a new `DTOs` folder:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在一个新的`DTOs`文件夹中定义`PackagesListDTO`类：
- en: '[PRE52]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, let''s add the following `using` clauses to our controller code so
    that we can easily refer to our DTO and to Entity Framework LINQ methods:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将以下`using`子句添加到我们的控制器代码中，以便我们可以轻松地引用我们的DTO和Entity Framework LINQ方法：
- en: '[PRE53]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we are ready to fill the body of the `GetPackagesByDate` method with the
    following code:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备使用以下代码填充`GetPackagesByDate`方法的主体：
- en: '[PRE54]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The LINQ query is similar to the one contained in the `WWTravelClubDBTest` project
    we tested in *Chapter 8*, *Interacting with Data in C# – Entity Framework Core*.
    Once the result has been computed, it is returned with an `OK` call. The method's
    code handles internal server errors by catching exceptions and returning a 500
    status code since bad requests are automatically handled before the `Controller`
    method is called by the `ApiController` attribute.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ查询类似于我们在*第8章*中测试的`WWTravelClubDBTest`项目中包含的查询，即*在C#中与数据交互 - Entity Framework
    Core*。一旦结果计算完成，就会通过`OK`调用返回。该方法的代码通过捕获异常并返回500状态代码来处理内部服务器错误，因为坏请求会在`Controller`方法被`ApiController`属性调用之前自动处理。
- en: 'Let''s run the solution. When the browser opens, it is unable to receive any
    result from our ASP.NET Core website. Let''s modify the browser URL so that it
    is `https://localhost:<previous port>/swagger`. The user interface of the OpenAPI
    documentation will look as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行解决方案。当浏览器打开时，无法从我们的ASP.NET Core网站接收任何结果。让我们修改浏览器URL，使其为`https://localhost:<previous
    port>/swagger`。OpenAPI文档的用户界面将如下所示：
- en: '![](img/B16756_14_01.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_14_01.png)'
- en: 'Figure 14.1: Swagger output'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1：Swagger输出
- en: '`PackagesListDTO` is the model we defined to list the packages, while `ProblemDetails`
    is the model that is used to report errors in the event of bad requests. By clicking
    the **GET** button, we can get more details about our `GET` method and we can
    also test it, as shown in the following screenshot:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`PackagesListDTO`是我们定义的用于列出包的模型，而`ProblemDetails`是在发生坏请求时用于报告错误的模型。通过单击**GET**按钮，我们可以获取有关我们的`GET`方法的更多详细信息，并且还可以测试它，如下面的屏幕截图所示：'
- en: '![](img/B16756_14_02.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_14_02.png)'
- en: 'Figure 14.2: GET method details'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：GET方法详细信息
- en: Pay attention when it comes to inserting dates that are covered by packages
    in the database; otherwise, an empty list will be returned. The ones shown in
    the preceding screenshot should work.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入数据库中由包覆盖的日期时要注意；否则，将返回一个空列表。在前面的屏幕截图中显示的应该可以工作。
- en: 'Dates must be entered in a correct JSON format; otherwise, a 400 Bad Request
    error is returned, like the one shown in the following code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 日期必须以正确的JSON格式输入；否则，将返回400 Bad Request错误，就像下面的代码中所示的那样：
- en: '[PRE55]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If you insert the correct input parameters, the Swagger UI returns the packages
    that satisfy the query in JSON format.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果插入正确的输入参数，Swagger UI将以JSON格式返回满足查询的包。
- en: That is all! You have implemented your first API with OpenAPI documentation!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！您已经实现了您的第一个带有OpenAPI文档的API！
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced SOA, its design principles, and its constraints.
    Among them, it is worth remembering interoperability.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了SOA及其设计原则和约束。其中，值得记住的是互操作性。
- en: Then, we focused on well-established standards for business applications that
    achieve the interoperability that is needed for publicly exposed services. Therefore,
    SOAP and REST services were discussed in detail, along with the transition from
    SOAP services to REST services, which has taken place in most application areas
    in the last few years. Then, REST service principles, authentication/authorization,
    and its documentation were described in greater detail.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们专注于业务应用程序的成熟标准，以实现公开服务所需的互操作性。因此，SOAP和REST服务以及从SOAP服务过渡到REST服务的细节被详细讨论，这在过去几年中在大多数应用领域都已经发生。然后，更详细地描述了REST服务原则、验证/授权和其文档。
- en: Finally, we looked at the tools that are available in .NET 5 that we can use
    to implement and interact with services. We looked at a variety of frameworks
    for intra-cluster communication, such as .NET remoting and gRPC, and tools for
    SOAP and REST-based public services.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看了一下在.NET 5中可用的工具，我们可以使用这些工具来实现和交互服务。我们看了一系列用于集群内通信的框架，如.NET remoting和gRPC，以及用于SOAP和基于REST的公共服务的工具。
- en: Here, we mainly focused on REST services. Their ASP.NET Core implementations
    were described in detail, along with the techniques we can use to authenticate/authorize
    them and their documentation. We also focused on how to implement efficient .NET
    Core proxies so that we can interact with REST services.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们主要关注REST服务。它们的ASP.NET Core实现被详细描述，以及我们可以用来验证/授权它们和它们的文档的技术。我们还专注于如何实现高效的.NET
    Core代理，以便我们可以与REST服务交互。
- en: In the next chapter, we will learn how to use .NET 5 while building an application
    on ASP .NET Core MVC.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在ASP .NET Core MVC上构建应用程序时使用.NET 5。
- en: Questions
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can services use cookie-based sessions?
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务可以使用基于cookie的会话吗？
- en: Is it good practice to implement a service with a custom communication protocol?
    Why or why not?
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自定义通信协议实现服务是一个好的做法吗？为什么是或者为什么不是？
- en: Can a `POST` request to a REST service cause a deletion?
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST`请求到REST服务会导致删除吗？'
- en: How many dot-separated parts are contained in a JWT bearer token?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JWT承载令牌中包含多少个点分隔的部分？
- en: By default, where are the complex type parameters of a REST service's action
    methods taken from?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，REST服务的操作方法的复杂类型参数来自哪里？
- en: How is a controller declared as a REST service?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何声明控制器作为REST服务？
- en: What are the main documentation attributes of ASP.NET Core services?
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core服务的主要文档属性是什么？
- en: How are ASP.NET Core REST service routing rules declared?
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core REST服务路由规则如何声明？
- en: How should a proxy be declared so that we can take advantage of .NET Core's
    `HttpClientFactory` class features?
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何声明代理以便我们可以利用.NET Core的`HttpClientFactory`类的特性？
- en: Further reading
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'This chapter mainly focused on the more commonly used REST service. If you
    are interested in SOAP services, a good place to start is the Wikipedia page regarding
    SOAP specifications: [https://en.wikipedia.org/wiki/List_of_web_service_specifications](https://en.wikipedia.org/wiki/List_of_web_service_specifications).
    On the other hand, if you are interested in the Microsoft .NET WCF technology
    for implementing SOAP services, you can refer to WCF''s official documentation
    here: [https://docs.microsoft.com/en-us/dotnet/framework/wcf/](https://docs.microsoft.com/en-us/dotnet/framework/wcf/).'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要关注更常用的REST服务。如果您对SOAP服务感兴趣，可以从维基百科关于SOAP规范的页面开始：[https://en.wikipedia.org/wiki/List_of_web_service_specifications](https://en.wikipedia.org/wiki/List_of_web_service_specifications)。另外，如果您对用于实现SOAP服务的Microsoft
    .NET WCF技术感兴趣，可以参考WCF的官方文档：[https://docs.microsoft.com/en-us/dotnet/framework/wcf/](https://docs.microsoft.com/en-us/dotnet/framework/wcf/)。
- en: 'This chapter mentioned the AMQP protocol as an option for intra-cluster communication
    without describing it. Detailed information on this protocol is available on AMQP''s
    official site: [https://www.amqp.org/](https://www.amqp.org/).'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提到了AMQP协议作为集群内通信的一种选择，但没有进行描述。有关该协议的详细信息可在AMQP的官方网站上找到：[https://www.amqp.org/](https://www.amqp.org/)。
- en: 'More information on gRPC is available on Google gRPC''s official site: [https://grpc.io/](https://grpc.io/).
    More information on the Visual Studio gRPC project template can be found here:
    [https://docs.microsoft.com/en-US/aspnet/core/grpc/](https://docs.microsoft.com/en-US/aspnet/core/grpc/).
    You may also want to check out gRPC-Web at [https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/).'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC的更多信息可在Google gRPC的官方网站上找到：[https://grpc.io/](https://grpc.io/)。有关Visual
    Studio gRPC项目模板的更多信息可以在这里找到：[https://docs.microsoft.com/en-US/aspnet/core/grpc/](https://docs.microsoft.com/en-US/aspnet/core/grpc/)。您还可以查看[https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/)上的gRPC-Web。
- en: 'More details on ASP.NET Core services are available in the official documentation:
    [https://docs.microsoft.com/en-US/aspnet/core/web-api/](https://docs.microsoft.com/en-US/aspnet/core/web-api/).
    More information on .NET Core''s HTTP client is available here: [https://docs.microsoft.com/en-US/aspnet/core/fundamentals/http-requests](https://docs.microsoft.com/en-US/aspnet/core/fundamentals/http-requests).'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core服务的更多详细信息可在官方文档中找到：[https://docs.microsoft.com/en-US/aspnet/core/web-api/](https://docs.microsoft.com/en-US/aspnet/core/web-api/)。有关.NET
    Core的HTTP客户端的更多信息，请访问这里：[https://docs.microsoft.com/en-US/aspnet/core/fundamentals/http-requests](https://docs.microsoft.com/en-US/aspnet/core/fundamentals/http-requests)。
- en: 'More information on JWT token authentication is available here: [https://jwt.io/](https://jwt.io/).
    If you would like to generate JWT tokens with Identity Server 4, you may refer
    to its official documentation page: [http://docs.identityserver.io/en/latest/](http://docs.identityserver.io/en/latest/).'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 有关JWT令牌认证的更多信息，请访问这里：[https://jwt.io/](https://jwt.io/)。如果您想要使用Identity Server
    4生成JWT令牌，可以参考其官方文档页面：[http://docs.identityserver.io/en/latest/](http://docs.identityserver.io/en/latest/)。
- en: 'More information on OpenAPI is available at [https://swagger.io/docs/specification/about/](https://swagger.io/docs/specification/about/),
    while more information on Swashbuckle can be found on its GitHub repository page:
    [https://github.com/domaindrivendev/Swashbuckle](https://github.com/domaindrivendev/Swashbuckle).'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 有关OpenAPI的更多信息，请访问[https://swagger.io/docs/specification/about/](https://swagger.io/docs/specification/about/)，而有关Swashbuckle的更多信息可以在其GitHub存储库页面上找到：[https://github.com/domaindrivendev/Swashbuckle](https://github.com/domaindrivendev/Swashbuckle)。
