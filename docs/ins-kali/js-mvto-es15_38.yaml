- en: Chapter 10. Building User Interfaces Using React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。使用React构建用户界面
- en: Writing code for reactive UI is a difficult task, as writing code to manipulate
    the DOM using JavaScript whenever the application state changes is difficult and
    it makes understanding the application difficult. Therefore, the MVC architecture
    was introduced, where we define the UI and application state separately, and the
    UI is updated automatically as the application state changes. MVC framework views
    have been concentrating on making the writing of code for reactive UIs easier
    but not increasing rendering performance, reusability, and ease of debugging.
    This is what React aims to solve. It not only makes writing code for reactive
    UI easier but also takes care of rendering performance, reusability, and ease
    of debugging.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写响应式UI的代码是一项困难的任务，因为使用JavaScript操纵DOM以及应用程序状态发生变化时，这使得理解应用程序变得困难。因此，引入了MVC架构，其中我们将UI和应用程序状态分开定义，并且UI会随着应用程序状态的变化而自动更新。MVC框架的视图一直致力于使编写响应式UI的代码更加容易，但并没有增加渲染性能、可重用性和调试的便利性。这正是React的目标所在。它不仅使编写响应式UI的代码更容易，还关注渲染性能、可重用性和调试的便利性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What React is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React是什么
- en: Virtual DOM technology
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟DOM技术
- en: Component-based UI development using React
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React进行基于组件的UI开发
- en: One-way dataflow programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单向数据流编程
- en: Using JSX to write React code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSX编写React代码
- en: Using React on the server side to build isomorphic apps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端使用React构建同构应用程序
- en: Many other topics to help us get a good hold on React
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多其他主题可以帮助我们更好地掌握React
- en: Introducing React
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入React
- en: React is a JavaScript library for building reactive UIs. We usually use jQuery
    or pure JavaScript to manipulate a reactive UI whenever the application state
    changes, which makes it difficult to reuse and understand the code. Instead, we
    can use React, which lets us declare how the UI behaves based on the application
    state, and it automatically updates the UI whenever the application state changes.
    There are lots of libraries and technologies, such as web components and templating
    engines, that aim to make the building of UIs easier, but React stands out from
    the crowd as it makes it easy to build reusable and high-performance reactive
    UIs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: React是一个用于构建响应式UI的JavaScript库。通常我们使用jQuery或纯JavaScript来操纵响应式UI，每当应用程序状态发生变化时，这使得代码难以重用和理解。相反，我们可以使用React，它让我们声明UI如何根据应用程序状态而行为，并且在应用程序状态发生变化时自动更新UI。有许多库和技术，如Web组件和模板引擎，旨在使构建UI更容易，但React脱颖而出，因为它使构建可重用和高性能的响应式UI变得容易。
- en: React is also used as a view library because it is exactly what a view library
    is supposed to be. A view holds the UI of the application and defines how the
    UI changes based on the application state, that is, how the application state
    is displayed. As it's just a view library, it doesn't tell us how to manage, access,
    and mutate the application state. It can be used as the view layer in any kind
    of architecture and framework.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: React也被用作视图库，因为它正是视图库应该具备的特性。视图保存应用程序的UI，并定义了UI如何根据应用程序状态发生变化，也就是应用程序状态如何显示。作为视图库，它不告诉我们如何管理、访问和改变应用程序状态。它可以用作任何类型架构和框架中的视图层。
- en: Remember that React is a library and not a framework such as Angular or Ember.
    Thus, React can be used with Angular to make Angular views better in terms of
    performance and reusability.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，React是一个库，而不是像Angular或Ember这样的框架。因此，React可以与Angular一起使用，以提高Angular视图的性能和可重用性。
- en: For example, there is an AngularJS module named ngReact that lets React be used
    as a view in AngularJS.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有一个名为ngReact的AngularJS模块，它允许在AngularJS中使用React作为视图。
- en: Even the Flux architecture uses React as its view. We will learn more about
    Flux in the next chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至Flux架构也使用React作为其视图。我们将在下一章中更多地了解Flux。
- en: React is always used with a framework as it only defines the UI but doesn't
    tell us how to manage the application logic and state, just like a template library
    or web component is always used with a framework.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: React总是与框架一起使用，因为它只定义了UI，但不告诉我们如何管理应用程序逻辑和状态，就像模板库或Web组件总是与框架一起使用一样。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Is React a templating engine?**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**React是一个模板引擎吗？**'
- en: React is not a templating engine. The views of most of the popular MVC frameworks
    are of a template system. In a templating system, we write HTML with a template
    language for the UI, and it is processed in order to generate the final HTML.
    For example, an AngularJS view is a template system that's composed of directives,
    expressions, and so on. React is not a templating engine because we don't write
    HTML. Instead, we define the structure of the DOM using JavaScript. React can
    also do much more than what a templating engine can do. It can also capture user
    events in the UI. This is how it differs from traditional views. It's just that
    React works in a different way than a template system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: React不是一个模板引擎。大多数流行的MVC框架的视图都是模板系统。在模板系统中，我们使用模板语言为UI编写HTML，并且对其进行处理以生成最终的HTML。例如，AngularJS视图是一个由指令、表达式等组成的模板系统。React不是一个模板引擎，因为我们不编写HTML。相反，我们使用JavaScript定义DOM的结构。React可以做的事情远远超出了模板引擎的能力。它还可以捕获UI中的用户事件。这就是它与传统视图的区别。只是React的工作方式与模板系统不同。
- en: When building user interfaces using React, we don't write any HTML to build
    the UI like when using other frameworks and libraries; instead, we declare the
    DOM structure using JavaScript only. This programming style is what makes React
    able to implement various algorithms and technologies to achieve high rendering
    performance and reusability.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用React构建用户界面时，我们不像使用其他框架和库时那样编写任何HTML来构建UI；相反，我们只使用JavaScript声明DOM结构。这种编程风格使得React能够实现各种算法和技术，以实现高性能渲染和可重用性。
- en: Before we get further into learning React, let's first set up a project to use
    it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步学习React之前，让我们先设置一个项目来使用它。
- en: Setting up a basic React project
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置基本的React项目
- en: At the time of writing, the latest version of React was 0.14.7\. This is the
    version this module uses. First, visit [https://facebook.github.io/react/downloads.html](https://facebook.github.io/react/downloads.html)
    to download React. Here, you will find two types of React builds, namely, production
    and development builds. The difference between these two build is that the development
    build is uncompressed and includes extra warnings, whereas the production build
    is compressed, includes extra performance optimizations, and strips all errors.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，React的最新版本是0.14.7。这是本模块使用的版本。首先，访问[https://facebook.github.io/react/downloads.html](https://facebook.github.io/react/downloads.html)下载React。在这里，您将找到两种类型的React构建，即生产和开发构建。这两种构建之间的区别在于，开发构建是未压缩的，并包含额外的警告，而生产构建是压缩的，包含额外的性能优化，并剥离所有错误。
- en: You should use the development build when your application is in the development
    phase. Once your application is ready for deployment, you should change to the
    production build.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发阶段使用开发版本构建。一旦应用程序准备部署，应切换到生产版本构建。
- en: 'Again, you will find two types of production and development build: one with
    add-ons and the other without. We will use the development version without add-ons.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您将找到两种类型的生产和开发版本构建：一种带有附加组件，另一种没有。我们将使用没有附加组件的开发版本。
- en: 'You will find CDN links as well as links to download and enqueue React manually.
    React is composed of two files: `react.js` and `react-dom.js`. Download both of
    them manually.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您将找到CDN链接以及手动下载和排队React。React由两个文件组成：`react.js`和`react-dom.js`。手动下载这两个文件。
- en: 'Create a folder named `react-demo` and place both the files in it. Then, create
    a file called `index.html` and put this code in it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`react-demo`的文件夹，并将这两个文件放入其中。然后，创建一个名为`index.html`的文件，并将以下代码放入其中：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Later on in this chapter, we will learn more about why React is composed of
    two files and not one. For now, just ignore this.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，我们将了解为什么React由两个文件组成而不是一个。现在，暂时忽略这一点。
- en: Virtual DOM
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟DOM
- en: A browser interprets HTML and creates a DOM. A DOM is a tree-like structure
    that defines the structure of the page. The browser then renders the DOM on the
    page. The DOM API is what we use to manipulate the DOM. When we manipulate it,
    the browser re-renders the manipulated parts.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器解释HTML并创建DOM。DOM是一种类似树状结构的东西，定义了页面的结构。然后浏览器在页面上渲染DOM。DOM API是我们用来操作DOM的。当我们操纵它时，浏览器会重新渲染被操纵的部分。
- en: The problem is not with how the DOM works, but how we programmatically alter
    it. Manipulating nodes of a DOM requires expertise; otherwise, we could often
    end up re-rendering lots of nodes unnecessarily, which would result in poor rendering
    performance.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 问题不在于DOM的工作方式，而在于我们如何以编程方式改变它。操纵DOM的节点需要专业知识；否则，我们往往会不必要地重新渲染大量节点，这将导致渲染性能不佳。
- en: For example, imagine we have a large list of products in an e-commerce website.
    We also have a filter widget to filter the items. When we change the values in
    the filter widget, the list items are reloaded and the complete list is re-rendered,
    which requires a lot of manipulation to the DOM and can result in bad rendering
    performance. To get better performance, we can actually manipulate only specific
    parts of the list, such as product titles, image, and cost. But writing code for
    this is going to be hard.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下我们在电子商务网站上有一个大型产品列表。我们还有一个过滤器小部件来过滤物品。当我们改变过滤器小部件中的数值时，列表项将重新加载并完整重新渲染，这需要对DOM进行大量操作，可能导致渲染性能不佳。为了获得更好的性能，我们实际上可以只操作列表的特定部分，比如产品标题、图片和成本。但是编写这样的代码会很困难。
- en: Let's take another example. If you are using `ng-repeat` to display a list,
    then adding a new item to the list will cause the complete re-rending of the list.
    So, if Facebook or Instagram had used `ng-repeat`, then whenever we scrolled down,
    the whole set of posts would have been re-rendered. The solution to this problem
    is instead of using `ng-repeat`, which re-renders the whole list, we can append
    a new post to the end of the list using jQuery or pure JavaScript. But if you
    want to maintain the posts that are being displayed, then you will end up writing
    some more complex code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举另一个例子。如果您正在使用`ng-repeat`来显示列表，那么向列表添加新项将导致完全重新渲染列表。因此，如果Facebook或Instagram使用了`ng-repeat`，那么每当我们向下滚动时，整套帖子都将被重新渲染。解决这个问题的方法是，不使用`ng-repeat`，它会重新渲染整个列表，而是可以使用jQuery或纯JavaScript将新帖子附加到列表的末尾。但是，如果您想保留正在显示的帖子，那么您将不得不编写一些更复杂的代码。
- en: Due to these kinds of problem, virtual DOM was introduced. Virtual DOM makes
    sure that anyone can write complex reactive UI code without worrying about performance.
    Virtual DOM is the secret that React implements to achieve rendering performance.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种问题，虚拟DOM被引入。虚拟DOM确保任何人都可以编写复杂的响应式UI代码，而不必担心性能。虚拟DOM是React实现渲染性能的秘密。
- en: A virtual DOM is an abstract version of the real DOM, that is, a description
    of the real DOM. Virtual DOM elements are just JavaScript objects whereas real
    DOM elements are real UI elements. Virtual DOM is much faster as it's just a JavaScript
    data structure and manipulating it doesn't automatically re-render the UI. Earlier,
    I said that in React, you don't write any HTML but instead declare the structure
    of the DOM. Actually, you declare the structure of the virtual DOM, not the real
    DOM. React keeps the real DOM in sync with virtual DOM. Whenever the application
    state changes to update the UI, React uses complex algorithms to compare the real
    DOM with the virtual DOM and finds as few mutations as possible for the real DOM
    to sync with the virtual DOM. We will later see how these algorithms actually
    find the difference and mutate the real DOM. For example, if we have a list in
    the virtual DOM and we remove the list and add a new list with just an extra item,
    then, only the new item is rendered when synced with the real DOM, not the whole
    list.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟DOM是真实DOM的抽象版本，也就是真实DOM的描述。虚拟DOM元素只是JavaScript对象，而真实DOM元素是真实的UI元素。虚拟DOM要快得多，因为它只是一个JavaScript数据结构，对其进行操作不会自动重新渲染UI。在前面，我说在React中，你不写任何HTML，而是声明DOM的结构。实际上，你声明的是虚拟DOM的结构，而不是真实DOM。React保持真实DOM与虚拟DOM同步。每当应用程序状态发生变化以更新UI时，React使用复杂的算法来比较真实DOM和虚拟DOM，并找到尽可能少的变化，以使真实DOM与虚拟DOM同步。我们稍后将看到这些算法实际上是如何找到差异并改变真实DOM的。例如，如果我们在虚拟DOM中有一个列表，我们删除该列表并添加一个只有一个额外项的新列表，那么在与真实DOM同步时，只有新项被渲染，而不是整个列表。
- en: 'Let''s look at some example code to print **Hello World** using React. Inside
    the `index.html` body tag, place this code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些使用React打印**Hello World**的示例代码。在`index.html`的body标签内，放置以下代码：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We are going to display **Hello World** inside this `div` element. Place this
    code in the script tag of the `index.html` file to display **Hello World**:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个`div`元素内显示**Hello World**。将此代码放置在`index.html`文件的脚本标记中，以显示**Hello World**：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is how the code''s output looks:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的输出外观：
- en: '![Virtual DOM](img/00134.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![虚拟DOM](img/00134.jpeg)'
- en: Let's understand how the code works.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解代码是如何工作的。
- en: '`React.createElement` is used to create an object of a `ReactElement` interface.
    A `ReactElement` object is a light, stateless, and virtual representation of a
    real DOM element, but it''s not a real DOM element. It''s a virtual DOM, basically.
    `ReactElement` and real DOM elements are of different interfaces. The first parameter
    of `React.createElement` can be an HTML tag name or an object of a `ReactClass`
    interface. We will learn more about `ReactClass` later on. The second argument
    is an object containing attributes of the HTML tag or properties of the `ReactClass`
    object. And then, we can pass an infinite number of arguments, which can be strings,
    `ReactElement` objects, or `ReactClass` objects. All the arguments after the second
    argument are treated as children of the `ReactElement` object that''s going to
    be created. If the children are dynamically decided, then you can provide an array
    as the third argument.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`React.createElement`用于创建`ReactElement`接口的对象。`ReactElement`对象是真实DOM元素的轻量、无状态和虚拟表示，但它不是真实DOM元素。它基本上是虚拟DOM。`ReactElement`和真实DOM元素是不同的接口。`React.createElement`的第一个参数可以是HTML标签名称，也可以是`ReactClass`接口的对象。我们稍后将学习更多关于`ReactClass`的知识。第二个参数是包含HTML标签属性或`ReactClass`对象属性的对象。然后，我们可以传递无限数量的参数，可以是字符串、`ReactElement`对象或`ReactClass`对象。第二个参数之后的所有参数都被视为将要创建的`ReactElement`对象的子元素。如果子元素是动态决定的，那么可以将数组作为第三个参数。'
- en: Here, we created three `ReactElement` objects. `helloWorld` is an anchor tag
    with `helloBold` and `worldItalic` as its children. We assigned the `href` attribute
    of the anchor tag to `#`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了三个`ReactElement`对象。`helloWorld`是一个带有`helloBold`和`worldItalic`作为其子元素的锚标记。我们将锚标记的`href`属性分配为`#`。
- en: '`ReactDOM.render` is used to render `ReactElement` objects in the real DOM.
    `ReactDOM.render` takes a `ReactElement` object as first argument, and the second
    argument is the reference to the container element in the real DOM inside which
    we want to add to the `ReactElement`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReactDOM.render`用于在真实DOM中呈现`ReactElement`对象。`ReactDOM.render`以`ReactElement`对象作为第一个参数，第二个参数是真实DOM中容器元素的引用，我们希望将其添加到`ReactElement`中。'
- en: Here, we've rendered the anchor tag inside the container element.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在容器元素内呈现了锚标记。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As a `ReactElement` object is stateless, we cannot assign any UI event handlers
    to the `properties` object. Also, directly mutating the properties passed to the
    `ReactElement` object will not have any effect, as React doesn't watch the properties
    directly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ReactElement`对象是无状态的，我们无法将任何UI事件处理程序分配给`properties`对象。直接突变传递给`ReactElement`对象的属性也不会产生任何效果，因为React不会直接监视属性。
- en: 'In the beginning, it may feel as if `ReactElement` and real DOM elements are
    just created in different ways and their interface is the same, but this is not
    true. Here are a few differences:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，可能会感觉`ReactElement`和真实DOM元素只是以不同的方式创建，并且它们的接口是相同的，但这是不正确的。以下是一些区别：
- en: Instead of the `class` attribute, you need to use `className`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要使用`className`而不是`class`属性
- en: Instead of the `for` attribute, you need to use the `htmlFor` attribute
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要使用`htmlFor`属性而不是`for`属性
- en: The `style` attribute cannot be a string; it has to be a object
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`style`属性不能是字符串，必须是对象'
- en: There are many more. We will explore them as we go deeper.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多。随着我们深入探讨，我们将探索它们。
- en: Components
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件
- en: You can use React using only `ReactElement` objects, but to take advantage of
    React, you have to use React components. `ReactElement` objects are stateless
    and immutable and therefore useless for building reactive UIs. Also, they don't
    provide a structured mechanism for UI reusability.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以只使用`ReactElement`对象来使用React，但要充分利用React，你必须使用React组件。`ReactElement`对象是无状态且不可变的，因此无法用于构建响应式UI。此外，它们不提供用于UI可重用性的结构化机制。
- en: A React component is a reusable custom tag that is mutable and encapsulated
    with an embedded state, that is, changes to the state or properties will mutate
    the UI. For example, we can have a component named `clock` that takes the current
    time as an attribute and displays a clock with the passed time. Another exchange
    could be a Bitcoin price component that displays Bitcoin prices in real time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: React组件是可重用的自定义标签，可变且封装了嵌入状态，也就是说，对状态或属性的更改将改变UI。例如，我们可以有一个名为`clock`的组件，它以当前时间作为属性，并显示一个显示传递时间的时钟。另一个例子是比特币价格组件，它实时显示比特币价格。
- en: A component state is internal to the component. It's created and mutated inside
    the component. However, the properties of a component cannot be mutated inside
    the component; rather, they can be mutated by the code that created the component
    instance.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 组件状态是组件内部的。它是在组件内部创建和改变的。然而，组件的属性不能在组件内部改变；而是可以由创建组件实例的代码来改变。
- en: You can break your complete UI into components—this is the style of coding that's
    recommended when building a UI using react. You can use components inside components
    as well. Before we get further into components, let's rewrite the previous **Hello
    World** code using components.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将整个UI分解为组件——这是在使用react构建UI时推荐的编码风格。您也可以在组件内部使用组件。在我们进一步了解组件之前，让我们使用组件重写上一个**Hello
    World**代码。
- en: 'Inside the `index.html` body tag, place this code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`的body标签内，放置这段代码：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We are going to display **Hello World** inside this `div` element. Place this
    code in the `script` tag of the `index.html` file to display **Hello World**:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个`div`元素内显示**Hello World**。将这段代码放在`index.html`文件的`script`标签中，以显示**Hello
    World**：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the output of the previous code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上一个代码的输出：
- en: '![Components](img/00135.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![组件](img/00135.jpeg)'
- en: 'Here is how the code works:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的工作原理如下：
- en: A component is created using the `React.createClass` function. This function
    takes an object, and the object must have a `render` property assigned to a function
    that returns a `ReactElement` object. The `ReactElement` object returned by the
    `render` method is said to be the content of the component, that is, it states
    how the tag is rendered. Whenever we try to display the tag, the contents of the
    tag are displayed in place.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`React.createClass`函数创建组件。这个函数接受一个对象，对象必须有一个分配给返回`ReactElement`对象的函数的`render`属性。`render`方法返回的`ReactElement`对象被称为组件的内容，即它说明了标签的渲染方式。每当我们尝试显示标签时，标签的内容会显示在原地。
- en: '`React.createClass` returns a component. To use the component, we need to create
    instances of it. Like `React.createElement` is used to create a `ReactElement`
    object for an HTML tag, it can also create a `ReactElement` object for a component.
    So, `React.createElement` is used to create instances of a component. `this.props`
    is used inside the component to access its properties.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`React.createClass`返回一个组件。要使用组件，我们需要创建它的实例。就像`React.createElement`用于为HTML标签创建`ReactElement`对象一样，它也可以为组件创建`ReactElement`对象。因此，`React.createElement`用于创建组件的实例。`this.props`用于在组件内部访问其属性。'
- en: Here, we created a component called `anchorWithBoldItalic`, which is an anchor
    element with some text displayed as bold and some displayed as italic.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`anchorWithBoldItalic`的组件，它是一个带有一些文本的锚元素，其中一些文本显示为粗体，一些显示为斜体。
- en: Then, we created a `ReactElement` object for our component and finally rendered
    it using `ReactDOM.render`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为我们的组件创建了一个`ReactElement`对象，并最终使用`ReactDOM.render`进行了渲染。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that mutating properties after a component instance has been created
    will re-render the component.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在创建组件实例后改变属性将重新渲染组件。
- en: One-way data binding
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单向数据绑定
- en: In the previous subsection, I stated that a component has an enclosing nature.
    Whenever we make changes to the state, the component is rendered. Components also
    let you register UI event handlers, and you can mutate the state inside the event
    handlers too.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一小节中，我提到组件具有封闭的特性。每当我们对状态进行更改时，组件就会被渲染。组件还允许您注册UI事件处理程序，并且您也可以在事件处理程序中改变状态。
- en: React lets you manage, access, and mutate UI state but not application state.
    The difference between UI state and application state is that the UI state represents
    the data that's used to manipulate the UI whereas the application state represents
    the data that's displayed in the UI. For example, let's assume that you have a
    comment box. The comments in the comment box are the application state, and the
    **View more comments** button is the UI state, which may or may not be displayed,
    depending on whether there are any more posts.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: React允许您管理、访问和改变UI状态，但不允许改变应用程序状态。UI状态和应用程序状态之间的区别在于，UI状态表示用于操作UI的数据，而应用程序状态表示显示在UI中的数据。例如，假设您有一个评论框。评论框中的评论是应用程序状态，而**查看更多评论**按钮是UI状态，可能会显示，也可能不会，这取决于是否有更多的帖子。
- en: Data binding between a UI and its state is only one-way. This means that user
    actions on the UI cannot alter the UI state directly, but the UI state can alter
    the UI.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: UI和其状态之间的数据绑定只是单向的。这意味着用户在UI上的操作不能直接改变UI状态，但UI状态可以改变UI。
- en: It may seem as if this were a limitation as AngularJS and other popular frameworks
    provide two-way data binding, but this is actually a feature. This feature makes
    it easier to understand and debug applications.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一个限制，因为AngularJS和其他流行的框架提供了双向数据绑定，但实际上这是一个特性。这个特性使得理解和调试应用程序变得更容易。
- en: Many developers tend to use UI state as application state, but for complex and
    large apps, this will cause issues and make it difficult to build the application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员倾向于将UI状态作为应用程序状态，但对于复杂和大型应用程序，这将导致问题，并使构建应用程序变得困难。
- en: Let's look at an example of how to use component state by building a button
    that hides/shows a box when clicked on.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过构建一个在点击时隐藏/显示框的按钮来看一下如何使用组件状态的示例。
- en: 'Place this code in the `<body>` tag of the `index.html` file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段代码放在`index.html`文件的`<body>`标签中：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will display the component inside this container element.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个容器元素中显示组件。
- en: 'Place this code inside the `script` tag:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码放入`script`标签中：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the output of the previous code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前代码的输出：
- en: '![One-way data binding](img/00136.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![单向数据绑定](img/00136.jpeg)'
- en: 'This is how the code works:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码的工作原理：
- en: At first, we create a new component.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的组件。
- en: The `getInitialState` method returns the initial state of the component.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getInitialState`方法返回组件的初始状态。'
- en: Then, we create a click handler that toggles the display state. When mutating
    the state, you must use `this.setState` and not directly mutate the state using
    `this.state`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个点击处理程序，切换显示状态。在变异状态时，必须使用`this.setState`，而不是直接使用`this.state`变异状态。
- en: Then, we create the `render` method, which displays a button and a small red
    box. The `render` method sets the display style of the box to the display state.
    So, whenever the state changes, React renders the component. Instead of rendering
    the complete component, React re-renders it by comparing the virtual DOM with
    the real DOM and mutating only the required DOM elements. This is how it achieves
    rendering performance.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建`render`方法，它显示一个按钮和一个小红色框。`render`方法将框的显示样式设置为显示状态。因此，每当状态改变时，React都会渲染组件。React不是通过渲染完整的组件来重新渲染它，而是通过比较虚拟DOM和真实DOM，并且只变异所需的DOM元素来重新渲染它。这就是它实现渲染性能的方式。
- en: Finally, we create a component instance and add it to the container element.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个组件实例并将其添加到容器元素中。
- en: Also note that we've only specified a number for height and width without any
    unit. In such a case, the unit is pixels.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要注意，我们只指定了高度和宽度的数字，没有任何单位。在这种情况下，单位是像素。
- en: Isomorphic UI development
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同构UI开发
- en: '**Isomorphic development** is where we can use the same code in both the frontend
    and backend.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**同构开发**是指我们可以在前端和后端同时使用相同的代码。'
- en: Till now, we've seen how to use React in the frontend to build reactive UI,
    but the same React code can also be used in the backend. When used in the backend,
    React outputs HTML and doesn't provide any kind of UI performance advantage or
    reactivity.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何在前端使用React来构建响应式UI，但是相同的React代码也可以在后端使用。当在后端使用时，React会输出HTML，并且不提供任何UI性能优势或响应性。
- en: 'The isomorphic nature of React is one of the things that make it so popular
    and powerful. It has made many things easier. For example, it makes it easier
    to prevent FOUC by letting us pre-render the page in the backend, and then in
    the frontend: the same components will just add event bindings.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: React的同构性质是使其如此受欢迎和强大的原因之一。它使许多事情变得更容易。例如，它可以通过让我们在后端预渲染页面，然后在前端：相同的组件将只是添加事件绑定，从而更容易地防止FOUC。
- en: React code not only executes in Node.js but can also be executed in PHP, Ruby,
    .NET, and some other major backend languages.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: React代码不仅在Node.js中执行，还可以在PHP、Ruby、.NET和其他一些主要后端语言中执行。
- en: 'Due to the fact that React can be used in both the frontend and backend, the
    React developer team decided to split React into two files: React core and another
    part that is specific to the executing environment. That''s why when we included
    React in our HTML file earlier, we included two files. The React core contains
    `React.createElement`, `React.createClass`, and so on whereas the React DOM contains
    `ReactDOM.render` and so on.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于React可以在前端和后端都使用，React开发团队决定将React拆分为两个文件：React核心和特定于执行环境的另一部分。这就是为什么当我们之前在HTML文件中包含React时，我们包含了两个文件。React核心包含`React.createElement`、`React.createClass`等，而React
    DOM包含`ReactDOM.render`等。
- en: Let's look at an example of how to use React in Node.js by creating and displaying
    the previous hello world component in Node.js. Create a directory named `React-Server-Demo`.
    Inside it, create files named `app.js` and `package.json`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在Node.js中如何使用React的例子，通过在Node.js中创建和显示之前的hello world组件。创建一个名为`React-Server-Demo`的目录。在其中，创建名为`app.js`和`package.json`的文件。
- en: 'Inside the `package.json` file, place this code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`文件中，放入此代码：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, run `npm install` to download the Express and React modules. Now, in
    the `app.js` file, place the following code and run the `node app.js` command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行`npm install`来下载Express和React模块。现在，在`app.js`文件中，放入以下代码并运行`node app.js`命令：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, open `http://localhost:8080/` in your browser; you''ll see this output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中打开`http://localhost:8080/`，你会看到这个输出：
- en: '![Isomorphic UI development](img/00137.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![同构UI开发](img/00137.jpeg)'
- en: 'This is how the code works:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码的工作原理：
- en: First, we import the React core module, then the React server-side module, and
    then Express.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入React核心模块，然后是React服务器端模块，然后是Express。
- en: We're using the same code we used earlier to create the component.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在使用之前用来创建组件的相同代码。
- en: Then, we create a route for the root path.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为根路径创建一个路由。
- en: The root path uses the `renderToString` method of the React server-side module
    to generate the HTML code of the component.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根路径使用React服务器端模块的`renderToString`方法来生成组件的HTML代码。
- en: Finally, we send the HTML to the client.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将HTML发送到客户端。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that by default, React will be in development mode. To use React in production
    mode, set the environment variable `NODE_ENV` to `production`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，默认情况下，React将处于开发模式。要在生产模式下使用React，请将环境变量`NODE_ENV`设置为`production`。
- en: Getting started with JSX
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用JSX
- en: Writing JavaScript to define a tree-like structure and attributes while building
    UI using React is difficult and also makes it difficult to understand the UI.
    So, the React team came up with an alternative syntax to write React code, which
    is easier to write and understand. This alternate syntax is called JSX. JSX stands
    for JavaScript syntax extension. It looks similar to XML. Files that contain JSX
    code have the`.jsx` extension.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript来定义树状结构和属性来构建UI，使用React是困难的，也使得理解UI变得困难。因此，React团队提出了一种替代语法来编写React代码，这种语法更容易编写和理解。这种替代语法称为JSX。JSX代表JavaScript语法扩展。它看起来类似于XML。包含JSX代码的文件具有`.jsx`扩展名。
- en: Compiling JSX
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译JSX
- en: Of course, browsers and server-side engines cannot understand and interpret
    JSX; therefore, we need to compile JSX into pure JavaScript before using it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，浏览器和服务器端引擎无法理解和解释JSX；因此，在使用之前，我们需要将JSX编译为纯JavaScript。
- en: There are various open source JSX compilers. You can find the list at [https://github.com/facebook/react/wiki/Complementary-Tools#build-tools](https://github.com/facebook/react/wiki/Complementary-Tools#build-tools).
    The most popular and recommended compiler for JSX is Babel. Babel can be installed
    ([https://babeljs.io/docs/setup/](https://babeljs.io/docs/setup/)), we can use
    the Babel compiler online ([https://babeljs.io/repl/](https://babeljs.io/repl/)),
    and we can also embed the Babel compiler in our HTML page so that it compiles
    in the browser.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种开源的JSX编译器。您可以在[https://github.com/facebook/react/wiki/Complementary-Tools#build-tools](https://github.com/facebook/react/wiki/Complementary-Tools#build-tools)找到列表。JSX最受欢迎和推荐的编译器是Babel。Babel可以安装([https://babeljs.io/docs/setup/](https://babeljs.io/docs/setup/))，我们可以使用在线的Babel编译器([https://babeljs.io/repl/](https://babeljs.io/repl/))，也可以将Babel编译器嵌入到我们的HTML页面中，以便在浏览器中进行编译。
- en: For the purpose of demonstration, we will embed the Babel compiler in our HTML
    page. Compiling takes time, so in production sites, you should never embed the
    compiler in web pages; instead, you should precompile and serve JSX code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将在我们的HTML页面中嵌入Babel编译器。编译需要时间，因此在生产站点中，您不应该在网页中嵌入编译器；相反，您应该预编译并提供JSX代码。
- en: 'To embed the Babel compiler in a webpage, visit [https://cdnjs.com/libraries/babel-core](https://cdnjs.com/libraries/babel-core)
    and download the Babel core. These are CDN links, so they can be embedded directly,
    but let''s download and embed them in our webpage. Download the `browser.min.js`
    file and place it in the `react-demo` directory. And then, embed it in the `index.html`
    page by placing the following code in the `<head>` tag:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要在网页中嵌入Babel编译器，请访问[https://cdnjs.com/libraries/babel-core](https://cdnjs.com/libraries/babel-core)并下载Babel核心。这些是CDN链接，因此它们可以直接嵌入，但让我们下载并将它们嵌入到我们的网页中。下载`browser.min.js`文件并将其放置在`react-demo`目录中。然后，在`<head>`标签中嵌入它：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, create a new `<script>` tag at the end of the `body` tag and set the `type`
    attribute to `text/babel` so that the Babel compiler knows which code to compile.
    Here is how the code should look:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`body`标签的末尾创建一个新的`<script>`标签，并将`type`属性设置为`text/babel`，以便Babel编译器知道要编译的代码。代码应如下所示：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From now on, all the JSX code will be placed in this script tag.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，所有的JSX代码都将放在这个脚本标签中。
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**JSX editors**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSX编辑器**'
- en: There are extensions available for almost all the popular code editors to properly
    highlight JSX syntax.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有流行的代码编辑器都有可用于正确突出显示JSX语法的扩展。
- en: JSX syntax
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSX语法
- en: 'Let''s rewrite the data-binding example code using JSX syntax. Place this code
    in the `body` tag to create a new container element:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用JSX语法重写数据绑定示例代码。将此代码放在`body`标签中以创建一个新的容器元素：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is the JSX code. Place it in the `script` tag that will be compiled by
    Babel:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是JSX代码。将其放在将由Babel编译的`script`标签中：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of the code is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下：
- en: '![JSX syntax](img/00138.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![JSX语法](img/00138.jpeg)'
- en: 'Before we see how this code works, let''s look at its compiled version:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看到这段代码是如何工作之前，让我们看一下它的编译版本：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This compiled version will give you a basic idea of how JSX syntax works. Let's
    understand how the previous JSX code works.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个编译后的版本将让您对JSX语法的工作原理有一个基本的了解。让我们了解之前的JSX代码是如何工作的。
- en: In a nutshell, JSX is used to write the `React.createElement` method in XML-like
    syntax. The XML tag name is the first argument, the attributes are the second
    argument, and finally, the child elements are the other arguments of `React.createElement`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，JSX用于以类似XML的语法编写`React.createElement`方法。XML标签名称是第一个参数，属性是第二个参数，最后，子元素是`React.createElement`的其他参数。
- en: If a JSX tag name starts with a lowercase letter, it's an HTML tag, whereas
    if it starts with a capital letter, it's a component. So here, we made the component
    name start with a capital H. Had we used a small H, it would have been treated
    as an HTML tag, and `<hideShowBoxButton></hideShowBoxButton>` would have been
    inserted into the page, which would have rendered nothing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果JSX标签名称以小写字母开头，则为HTML标签，而如果以大写字母开头，则为组件。因此，在这里，我们使组件名称以大写H开头。如果我们使用小写h，它将被视为HTML标签，并且`<hideShowBoxButton></hideShowBoxButton>`将被插入到页面中，这将不会渲染任何内容。
- en: In the `HideShowBoxButton` component, except the `render` method code, everything
    else is the same. We rewrote the `render` method using JSX syntax.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HideShowBoxButton`组件中，除了`render`方法代码之外，其他都是相同的。我们使用JSX语法重写了`render`方法。
- en: JSX provides `{}` braces to wrap JavaScript expressions while assigning them
    to attributes or using them as child elements. Here, we've assigned JavaScript
    expressions to `onClick` and `style` attributes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: JSX提供`{}`大括号来包装JavaScript表达式，以便将它们分配给属性或将它们用作子元素。在这里，我们将JavaScript表达式分配给`onClick`和`style`属性。
- en: Finally, we created an instance of the component using JSX syntax.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用JSX语法创建了一个组件的实例。
- en: In the compiled code, you will find a `displayName` property in the object passed
    to `React.createClass`. The `displayName` property is used for debugging. If not
    set, it's set to the component name while compiling.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译后的代码中，您将在传递给`React.createClass`的对象中找到一个`displayName`属性。`displayName`属性用于调试。如果未设置，则在编译时设置为组件名称。
- en: Digging into components
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解组件
- en: Let's dig further into components and master them. We'll look at component composition
    and ownership. Learning this will help us build complex reactive UIs that are
    easier to manage.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步深入组件并掌握它们。我们将研究组件组合和所有权。学习这些将帮助我们构建更容易管理的复杂响应式UI。
- en: Component composition
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件组合
- en: '**Composability** is a feature that lets you use a component inside another
    component''s `render` method.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**可组合性**是一个功能，它允许您在另一个组件的`render`方法中使用组件。'
- en: 'Let''s look at a basic example of component composition. First, create a new
    container element. To do so, place the following code in the `body` tag:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个组件组合的基本示例。首先，创建一个新的容器元素。为此，请将以下代码放在`body`标签中：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the component composition example code. Place this code in the `script`
    tag that''s compiled by Babel:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是组件组合示例代码。将此代码放在由Babel编译的`script`标签中：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is the output of the code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的输出：
- en: '![Component composition](img/00139.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![组件组合](img/00139.jpeg)'
- en: Here, we've created two different components. Inside the Card component, we
    are using the `ResponsiveImage` component to display a responsive image in it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了两个不同的组件。在Card组件内部，我们使用`ResponsiveImage`组件来显示一个响应式图像。
- en: Component ownership
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件所有权
- en: When components are used inside other components' `render` methods, they are
    said to have an owner-ownee relationship and not a parent-child relationship.
    Component X is said to be the owner of component Y if component X created an instance
    of component Y in its `render` method.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件在其他组件的`render`方法中使用时，它们被认为是所有者-被拥有关系，而不是父-子关系。如果组件X在其`render`方法中创建了组件Y的实例，则组件X被认为是组件Y的所有者。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that component X is not called the parent; rather, it's called the owner
    of component Y.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，组件X并不被称为父组件；相反，它被称为组件Y的所有者。
- en: For example, in the previous code, the `Card` component is the owner of the
    `ResponsiveImage` component and `<div>` is the parent of `ResponsiveImage`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面的代码中，`Card`组件是`ResponsiveImage`组件的所有者，`<div>`是`ResponsiveImage`的父组件。
- en: If we place a component instance inside the opening and closing tags of a component
    instance, then they are said to be in a parent-child relationship. The parent
    can access its children by using the `this.props.children` object. React also
    provides utility functions to make working with children easier. You can find
    the utilities at [https://facebook.github.io/react/docs/top-level-api.html#react.children](https://facebook.github.io/react/docs/top-level-api.html#react.children).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个组件实例放在另一个组件实例的开放和关闭标签内，那么它们被认为是父子关系。父组件可以通过使用`this.props.children`对象访问其子组件。React还提供了实用函数来使处理子组件更容易。您可以在[https://facebook.github.io/react/docs/top-level-api.html#react.children](https://facebook.github.io/react/docs/top-level-api.html#react.children)找到这些实用程序。
- en: Reconciliation
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协调
- en: '**Reconciliation** is the process by which React updates the DOM whenever the
    state changes. React doesn''t re-render everything from scratch when the state
    changes; instead, it first finds whether a mutation is required by comparing the
    new virtual DOM with the old one, and if there is a difference, it compares the
    new virtual DOM with the real DOM and makes the necessary mutations.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**协调**是React在状态改变时更新DOM的过程。当状态改变时，React不会从头开始重新渲染所有内容；相反，它首先通过比较新的虚拟DOM和旧的虚拟DOM来确定是否需要变异，如果有差异，它会将新的虚拟DOM与真实DOM进行比较并进行必要的变异。'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that reconciliation doesn't happen only when you change the component state;
    it also happens when you call `ReactDOM.render` on the same container element
    again.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，协调不仅在更改组件状态时发生；当您在同一个容器元素上调用`ReactDOM.render`时，它也会发生。
- en: 'Let''s see how exactly reconciliation happens by looking at an example. Suppose
    this is the initial render:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看协调是如何发生的。假设这是初始渲染：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we remove `Item 1` from the state, then the render will change to this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从状态中移除`Item 1`，那么渲染将变成这样：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: React algorithms compare DOM items one by one, and whenever they find a difference
    between two nodes, they make mutations. So here, React will remove the `Item 1`
    list item by changing the text of the first list item and removing the last one.
    This process is much faster than removing both the list items and adding a new
    list item, which is what `ng-repeat` does and what we used to do using JavaScript.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: React算法逐个比较DOM项，每当它们发现两个节点之间有差异时，就会进行变异。因此，在这里，React将通过更改第一个列表项的文本并删除最后一个列表项来移除`Item
    1`列表项。这个过程比同时移除两个列表项并添加一个新的列表项要快得多，这是`ng-repeat`做的事情，也是我们以前使用JavaScript做的事情。
- en: If the node type is different, React will treat them as two different subtrees,
    throw away the first one, and build/insert the second one. For example, if we
    change `<ul>` to `<ol>`, the complete `<ul>` tree will be deleted.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点类型不同，React将把它们视为两个不同的子树，丢弃第一个子树，并构建/插入第二个子树。例如，如果我们将`<ul>`更改为`<ol>`，则完整的`<ul>`树将被删除。
- en: 'This behavior is fine until you add new items to the end of the list or modify
    them. In case you add new items to the beginning or in between the list, you will
    start facing rendering performance issues. To understand the issue, let''s take
    an example. Let''s add `Item 0` to the beginning. Now, the render will look like
    this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为在向列表末尾添加新项或修改它们时是可以接受的。但是，如果您在列表开头或中间添加新项，您将开始面临渲染性能问题。为了理解这个问题，让我们举个例子。让我们在开头添加`Item
    0`。现在，渲染将如下所示：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, while reconciling, React will first change the text of the first list
    item to `Item 0`, then change the text of the second list item to `Item 1`, and
    finally will add a new list item and assign its text to `Item 2` instead of simply
    adding a new list item to the beginning of the list. This behavior makes the rendering
    actually slower.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在协调时，React首先将第一个列表项的文本更改为`Item 0`，然后将第二个列表项的文本更改为`Item 1`，最后将添加一个新的列表项，并将其文本分配为`Item
    2`，而不是简单地在列表开头添加一个新的列表项。这种行为实际上使渲染变慢。
- en: React does provide a way to get around this kind of issue as well. It lets us
    uniquely identify each child by assigning it a unique key. When React reconciles
    the keyed children, it will ensure that any child with a key will be reordered
    (instead of being mutated) or destroyed (instead of being reused). A key is assigned
    using the `key` attribute.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: React确实提供了一种解决这种问题的方法。它允许我们通过为每个子组件分配一个唯一的键来唯一标识每个子组件。当React协调带有键的子组件时，它将确保任何带有键的子组件将被重新排序（而不是被变异）或销毁（而不是被重用）。使用`key`属性分配一个键。
- en: 'Let''s look at an example of how to create keyed children. Here is the code
    to create a new container element. Place this code in the `body` tag:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个创建带键子元素的例子。以下是创建新容器元素的代码。将此代码放在`body`标签中：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is the React code for creating keyed children:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建带键子元素的React代码：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is the output of the code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的输出：
- en: '![Reconciliation](img/00140.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![Reconciliation](img/00140.jpeg)'
- en: Here, when the `anchor` element is clicked on, a new object is added to the
    beginning of the result array. As the state changes, the list is re-rendered.
    While rendering, React will reorder the list items and add new list items to the
    beginning instead of mutating them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当点击`anchor`元素时，一个新对象被添加到结果数组的开头。随着状态的改变，列表被重新渲染。在渲染时，React会重新排序列表项，并在开头添加新的列表项，而不是对它们进行变异。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that when dynamically creating component instances, the key should
    always be supplied to the components in the array, not to the container element
    of each component in the array.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当动态创建组件实例时，应该始终为数组中的组件提供键，而不是为数组中每个组件的容器元素提供键。
- en: Default component property values
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认组件属性值
- en: React lets you define default values for properties in a very declarative way.
    The default value is used if the parent does not pass a property.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: React允许你以一种非常声明式的方式为属性定义默认值。如果父级没有传递属性，则使用默认值。
- en: 'Default values are returned by a method `getDefaultProps`, which is a member
    of the object passed to `React.createClass`. Here is some sample code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值由`getDefaultProps`方法返回，它是传递给`React.createClass`的对象的成员。以下是一些示例代码：
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Component life cycle methods
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件生命周期方法
- en: Various methods are executed at specific points in a component's lifecycle.
    Let's look at them.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件的生命周期中的特定点执行各种方法。让我们来看看它们。
- en: componentWillMount()
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: componentWillMount()
- en: The `componentWillMount()` method is invoked once immediately before the initial
    rendering occurs. If you call `setState` within this method, `render()` will see
    the updated state and will be executed only once despite the state change.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentWillMount()`方法在初始渲染之前立即被调用一次。如果在这个方法内部调用`setState`，`render()`将看到更新后的状态，并且尽管状态改变，只会执行一次。'
- en: componentDidMount()
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: componentDidMount()
- en: The `componentDidMount()` method is invoked only on the client side. It is invoked
    only once after initial rendering has occurred.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentDidMount()`方法只在客户端上被调用。它在初始渲染之后只会被调用一次。'
- en: componentWillReceiveProps(nextProps)
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: componentWillReceiveProps(nextProps)
- en: Directly mutating the properties passed to a component will have no effect because
    there is no way for React to find value changes as it doesn't watch the properties
    directly. But sometimes, it is possible for React to predict property value changes,
    and in that case, it calls the `componentWillReceiveProps` method, if it exists,
    with the new property values as its parameters, and it also re-renders the component.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 直接变异传递给组件的属性将不会产生任何效果，因为React无法直接监视属性的值变化。但有时，React可以预测属性值的变化，在这种情况下，它会调用`componentWillReceiveProps`方法（如果存在），并使用新的属性值作为参数进行重新渲染。
- en: For example, if we change the state of the owner of a component, then that sends
    a signal that the properties of the components it owns might have changed, so
    it calls the `componentWillReceiveProps` method and re-renders the components
    it owns.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们改变组件的所有者的状态，那么这会发送一个信号，表明它拥有的组件的属性可能已经改变，因此它调用`componentWillReceiveProps`方法并重新渲染它拥有的组件。
- en: 'Let''s look at an example to demonstrate the `componentWillReceiveProps` method.
    We will create a button whose value increments every second. Here is the code
    to create a new container element. Place it in the `body` tag:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子来演示`componentWillReceiveProps`方法。我们将创建一个按钮，其值每秒递增一次。以下是创建一个新容器元素的代码。将其放在`body`标签中：
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is the code for our example. Place this code in the `script` tag that
    will be compiled by Babel:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们示例的代码。将这段代码放在由Babel编译的`script`标签中：
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is the output of the code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的输出：
- en: '![componentWillReceiveProps(nextProps)](img/00141.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![componentWillReceiveProps(nextProps)](img/00141.jpeg)'
- en: In the code, we are changing the state of the owner every second after the initial
    rendering has occurred. Whenever the state changes, the `componentWillReceieveProps`
    object of `ButtonComponent` is called. Inside the `componentWillReceieveProps`
    object, we can use `this.props` to access the previous values of the properties.
    The button is rendered whenever its owner's state changes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们在初始渲染后每秒改变所有者的状态。每当状态改变时，都会调用`ButtonComponent`的`componentWillReceieveProps`对象。在`componentWillReceieveProps`对象中，我们可以使用`this.props`来访问属性的先前值。按钮在其所有者的状态改变时被渲染。
- en: Remember that `componentWillReceieveProps` is called before the component is
    re-rendered, so we can make any state changes we want inside it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`componentWillReceieveProps`在组件重新渲染之前被调用，因此我们可以在其中进行任何我们想要的状态改变。
- en: shouldComponentUpdate(nextProps, nextState)
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: shouldComponentUpdate(nextProps, nextState)
- en: The `shouldComponentUpdate(nextProps, nextState)` method is called before the
    `render` method is called, that is, before rendering happens. If this method returns
    `false`, then rendering is skipped.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`render`方法之前，即在渲染之前，会调用`shouldComponentUpdate(nextProps, nextState)`方法。如果该方法返回`false`，则跳过渲染。
- en: Remember that this method is not called before forced updates or initial rendering.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个方法在强制更新或初始渲染之前不会被调用。
- en: Tip
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**What is a forced update?**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是强制更新？**'
- en: React provides a `forceUpdate` method inside a component, which renders the
    component when called. This can be used when the `render()` method depends on
    some other data instead of just `this.props` and `this.state`, as changes to other
    data don't trigger the `render` method.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: React在组件内部提供了一个`forceUpdate`方法，当调用时会渲染组件。当`render()`方法依赖于一些其他数据而不仅仅是`this.props`和`this.state`时，可以使用这个方法，因为对其他数据的更改不会触发`render`方法。
- en: componentWillUpdate(nextProps, nextState)
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: componentWillUpdate(nextProps, nextState)
- en: The `componentWillUpdate(nextProps, nextState)` method is invoked immediately
    before rendering when new props or state are being received. This method is not
    called for the initial render.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收到新的props或state时，会立即在渲染之前调用`componentWillUpdate(nextProps, nextState)`方法。这个方法不会在初始渲染时被调用。
- en: Note that you cannot use `this.setState` inside this method.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你不能在这个方法中使用`this.setState`。
- en: componentDidUpdate(prevProps, prevState)
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: componentDidUpdate(prevProps, prevState)
- en: The `componentDidUpdate(prevProps, prevState)` method is invoked immediately
    after the component's updates are flushed to the real DOM. This method is not
    called for the initial render.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentDidUpdate(prevProps, prevState)`方法在组件的更新被刷新到真实DOM后立即调用。此方法不适用于初始渲染。'
- en: componentWillUnmount()
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: componentWillUnmount()
- en: The `componentWillUnmount()` method is invoked immediately before a component
    is unmounted from the real DOM.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentWillUnmount()`方法在组件从真实DOM中卸载之前立即调用。'
- en: Mixins
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合物
- en: There are times when multiple components share the same code; in such cases,
    we can use mixins instead of writing the same code again and again.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有时多个组件共享相同的代码；在这种情况下，我们可以使用混合物而不是一遍又一遍地编写相同的代码。
- en: A **mixin** is an object that holds component methods that can be easily plugged
    in to any component.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**混合物**是一个包含组件方法的对象，可以轻松地插入到任何组件中。'
- en: 'Let''s look at an example to demonstrate mixins. Here is the code to create
    a new container element. Place it in the `body` tag:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例来演示混合物。以下是创建一个新容器元素的代码。将其放在`body`标记中：
- en: '[PRE24]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here is the code for our example. Place it in the `script` tag that will be
    compiled by Babel.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们示例的代码。将其放在将由Babel编译的`script`标记中。
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is the output of the code on the page:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是页面上代码的输出：
- en: '![Mixins](img/00142.jpeg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![混合物](img/00142.jpeg)'
- en: 'And this is the output on the console:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是控制台上的输出：
- en: '![Mixins](img/00143.jpeg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![混合物](img/00143.jpeg)'
- en: Here, we've created two mixins and added them to `HeadingComponent`. These mixins
    can be used in any number of methods. Mixins simply increase code reusability.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了两个混合物并将它们添加到`HeadingComponent`中。这些混合物可以在任意数量的方法中使用。混合物简单地增加了代码的可重用性。
- en: Using Refs
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Refs
- en: '**Refs** are used inside components to return references to real DOM elements
    rendered by React. So, instead of assigning an `id` or `class` value to elements,
    we can assign refs. It''s easier to get references to real DOM elements using
    refs than `id` or `class` attributes.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**Refs**在组件内部用于返回由React渲染的真实DOM元素的引用。因此，我们可以使用refs而不是为元素分配`id`或`class`值。使用refs比使用`id`或`class`属性更容易获取对真实DOM元素的引用。'
- en: 'Let''s look at a basic example of how to use refs by creating a form. First,
    create a container element and place it inside the `body` tag. Here is the code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个表单来看一下如何使用refs的基本示例。首先，创建一个容器元素并将其放在`body`标记内。以下是代码：
- en: '[PRE26]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here is the code for the form, which uses refs:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用refs的表单的代码：
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of this code on the webpage is as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在网页上的输出如下：
- en: '![Using Refs](img/00144.jpeg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![使用Refs](img/00144.jpeg)'
- en: 'If we enter `Hello World` in the text field and click on the button, then the
    output of the console is this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在文本字段中输入`Hello World`并单击按钮，那么控制台的输出是这样的：
- en: '[PRE28]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the previous code, we're assigning a `ref` attribute to the button element.
    To refer to the button in the methods of the component, we use `this.refs`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们给按钮元素分配了一个`ref`属性。要在组件的方法中引用按钮，我们使用`this.refs`。
- en: ReactDOMServer.renderToStaticMarkup
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReactDOMServer.renderToStaticMarkup
- en: Earlier in this chapter, we used React on the server side to generate HTML.
    The HTML generated by React on the server and client side contains `data-reactid`
    attributes, which are used by React internally. On the client side, it makes sense
    to have `data-reactid`, as it is used during reconciliation and other processes
    and features.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们在服务器端使用React生成HTML。React在服务器端和客户端生成的HTML包含`data-reactid`属性，这些属性由React在内部使用。在客户端，具有`data-reactid`是有意义的，因为它在协调和其他过程和功能中使用。
- en: You must be wondering what the point of adding this attribute on the server
    side is. Actually, it is added so that if you call `ReactDOM.render()` on the
    client side on a node that already has React server-rendered markup, React will
    preserve it and only reconcile it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您一定想知道在服务器端添加此属性的意义是什么。实际上，它是为了在客户端对已经具有React服务器渲染标记的节点调用`ReactDOM.render()`时，React将保留它并仅对其进行协调。
- en: If you don't want `data-reactid` attributes to be generated on the server side,
    you can use `renderToStaticMarkup` instead of `renderToString`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不希望在服务器端生成`data-reactid`属性，可以使用`renderToStaticMarkup`而不是`renderToString`。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned React up to an intermediate level by covering in
    depth its features and components, JSX, using it for server-side rendering, reconciliation,
    and so on. We also learned miscellaneous features such as mixins and refs. Now,
    you should have a basic understanding of how and when to integrate React into
    your websites.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过深入研究其特性和组件、JSX、在服务器端渲染中使用它、协调等，学习了React直到中级水平。我们还学习了杂项功能，如混合物和refs。现在，您应该对何时以及如何将React集成到您的网站中有一个基本的理解。
- en: In the next chapter, we will learn React in more depth by building an application
    that uses the Flux and SPA architectures.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过构建一个使用Flux和SPA架构的应用程序来更深入地了解React。
