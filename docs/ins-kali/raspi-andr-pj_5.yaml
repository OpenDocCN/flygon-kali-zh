- en: Chapter 5. Missed Calls with Pi
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。使用树莓派的未接来电
- en: 'In this chapter, we will implement a much more programming-oriented project
    and dive into Bluetooth Smart or **Bluetooth Low Energy** (**BLE**) programming.
    We will make the Pi and Android phones communicate through Bluetooth, and control
    the Pi using this channel. We will cover the following topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实施一个更加面向编程的项目，并深入研究蓝牙智能或蓝牙低功耗（BLE）编程。我们将通过蓝牙使树莓派和Android手机进行通信，并使用这个通道控制树莓派。本章将涵盖以下主题：
- en: Installing the necessary components
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装必要的组件
- en: Adding a sensor service to Bluetooth Low Energy
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向蓝牙低功耗添加传感器服务
- en: Connecting from an Android app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Android应用程序连接
- en: Sending the reboot command from your Android phone to the Pi
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从您的Android手机发送重启命令到树莓派
- en: Sending more commands from your Android phone to the Pi
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从您的Android手机发送更多命令到树莓派
- en: Installing the necessary components
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装必要的组件
- en: The hardware component needed for this project is a BLE-enabled Bluetooth USB
    dongle. It is important that this hardware supports BLE as we will specifically
    make use of this part of the Bluetooth stack. We will use one by **Plugable**,
    which is available on Amazon.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目所需的硬件组件是一个支持BLE的蓝牙USB适配器。重要的是这个硬件支持BLE，因为我们将专门利用蓝牙堆栈的这一部分。我们将使用由**Plugable**提供的一个，它在亚马逊上有售。
- en: '![Installing the necessary components](img/image00131.jpeg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![安装必要的组件](img/image00131.jpeg)'
- en: The Bluetooth dongle by Plugable
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由Plugable提供的蓝牙适配器
- en: 'The Raspbian distribution that we have downloaded already contains support
    for Bluetooth, but we need to update Bluetooth packages for better LE support.
    You can build and install a more modern of the Bluetooth package version using
    the following commands:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经下载的Raspbian发行版已经包含了对蓝牙的支持，但我们需要更新蓝牙软件包以获得更好的低功耗支持。您可以使用以下命令构建和安装更现代的蓝牙软件包版本：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `make` step will compile the necessary packages needed for the Pi and will
    take about 15 minutes to complete. However, you'll need to be patient as it will
    lead to something cool and useful at the end. Note that the latest version of
    BlueZ is 5.33 at the time of writing this book, and you can instead replace it
    with the latest version by checking the list of all available versions at [https://www.kernel.org/pub/linux/bluetooth/](https://www.kernel.org/pub/linux/bluetooth/).
    Note here that we have disabled the `systemd` support using the `--disable-systemd`
    option, which causes build errors, otherwise.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: “make”步骤将编译树莓派所需的必要软件包，并需要大约15分钟才能完成。但是，您需要耐心等待，因为最终会得到一些很酷和有用的东西。请注意，撰写本书时BlueZ的最新版本是5.33，您可以通过检查[https://www.kernel.org/pub/linux/bluetooth/](https://www.kernel.org/pub/linux/bluetooth/)上所有可用版本的列表来替换为最新版本。请注意，我们已使用“--disable-systemd”选项禁用了“systemd”支持，否则会导致构建错误。
- en: 'The preceding commands have also installed some command-line tools to let us
    configure and scan for Bluetooth devices. The following command lists all the
    attached components on the USB ports of the Pi:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令还安装了一些命令行工具，让我们能够配置和扫描蓝牙设备。以下命令列出了树莓派的USB端口上连接的所有组件：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出如下：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The Bluetooth adapter is named `Broadcom` in my case. To get more details on
    a specific device, use the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，蓝牙适配器的名称是“Broadcom”。要获取有关特定设备的更多详细信息，请使用以下命令：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, note that `0a5c` is the first part of the address of the Bluetooth dongle
    that I am reusing to get more information on only this device.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，请注意“0a5c”是我正在重用的蓝牙适配器地址的第一部分，仅获取有关此设备的更多信息。
- en: 'The `hciconfig` tool will show you which devices support Bluetooth. This command
    outputs the following information on my system:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: “hciconfig”工具将向您显示哪些设备支持蓝牙。这个命令在我的系统上输出了以下信息：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As seen here, the device is marked as `DOWN`. We will keep it this way as the
    next tool we install requires it to be down initially.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里看到，设备标记为“DOWN”。我们将保持这种状态，因为我们安装的下一个工具需要它最初处于关闭状态。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are useful Bluetooth LE commands that you can use to check for other BLE
    devices. We will not use these commands yet, but it is a good practice to play
    with them to check if your BLE devices are working or accessible.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些有用的蓝牙低功耗命令，您可以使用它们来检查其他BLE设备。我们暂时不会使用这些命令，但是熟悉它们并检查您的BLE设备是否工作或可访问是一个好习惯。
- en: 'The same `hciconfig` tool that we''ve used previously helps us bring the Bluetooth
    device up. However, do not do this if you want to proceed with the rest of the
    chapter as the next tool requires it to be down:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用过的“hciconfig”工具可以帮助我们启动蓝牙设备。但是，如果您想继续本章的其余部分，不要这样做，因为下一个工具需要它处于关闭状态：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is a good idea to put this command in crontab, as discussed previously, using
    crontab with the `–e` option in order to let you use nano as the editor and install
    new crontab automatically. Add `@reboot sudo hciconfig hci0 up` inside the file
    at the end, and save and exit.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将此命令放入crontab中是个好主意，如前所述，使用crontab和“-e”选项，以便您可以使用nano作为编辑器，并自动安装新的crontab。在文件末尾添加“@reboot
    sudo hciconfig hci0 up”，然后保存并退出。
- en: 'There are two other commands we can use:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个其他命令可以使用：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This command lists the BLE devices. Now let''s take a look at the following
    command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令列出了BLE设备。现在让我们看看以下命令：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And this command tests the Bluetooth connection to the device. Note that the
    address provided to the latter command was returned by the former.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令测试与设备的蓝牙连接。请注意，后一个命令提供的地址是由前一个命令返回的。
- en: 'We will even need a programming support for Bluetooth. We will use **Go** as
    the language and the **Gatt** package for Go that gives support for Bluetooth
    LE in the Go language. The **Generic Attribute** **Profile** (**Gatt**) is a general
    specification to send and receive small amounts of data, known as attributes,
    over a BLE link. Let''s run the following commands to install the `go` language:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至需要一个蓝牙的编程支持。我们将使用**Go**作为语言，**Gatt**包用于Go语言，为Go语言提供了对蓝牙低功耗的支持。**通用属性配置文件**（**Gatt**）是一个通用规范，用于在BLE链路上发送和接收小量数据，称为属性。让我们运行以下命令来安装`go`语言：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You might want to go and grab a cup of coffee here, as the last command will
    take about 40 minutes to complete. At the end of the output, you will see that
    the `go` installer asks you to add a binary directory to your path for easy access.
    The following commands can accomplish this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可能想去拿杯咖啡，因为最后一个命令将花费大约40分钟的时间。在输出的末尾，你将看到`go`安装程序要求你将一个二进制目录添加到你的路径中，以便轻松访问。以下命令可以实现这一点：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is a good idea to put these commands in the `/etc/profile` file in order
    to execute them for each session that you start in the future. Be sure to add
    them at the end of the file, though. Also, do not forget to actually execute them
    even though you have put them in the `profile` file if you want to continue without
    rebooting.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些命令放在`/etc/profile`文件中是个好主意，这样你就可以在将来每次启动会话时执行它们。但是一定要将它们添加到文件的末尾。此外，即使你已经将它们放在`profile`文件中，也不要忘记实际执行它们，如果你想在不重新启动的情况下继续。
- en: 'Then, use the following command to download the Gatt package source files:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令下载Gatt包源文件：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we will start a simple BLE server using the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用以下命令启动一个简单的BLE服务器：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'After completing this chapter, you might want to put the server startup command
    inside `crontab` using the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你可能想使用以下命令将服务器启动命令放在`crontab`中：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This way the BLE server will start each time you reboot the Pi. Add the following
    line at the end:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每次重新启动Pi时，BLE服务器都会启动。在末尾添加以下行：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It is now time to find our Raspberry Pi, which behaves like a BLE device from
    Android. We will use the **BLE Scanner** app by **BluePixel Technologies** and
    is available on the Play Store. When you start it, you will see a list of BLE
    devices available around you along with their addresses. The address of the Bluetooth
    adapter on the Pi can be seen using the `hciconfig` command. The default implementation
    of the Gatt server names the device as **Gopher**. The following screenshot illustrates
    the BLE Scanner app, showing the Pi as a BLE device:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候找到我们的树莓派了，它在安卓上表现得像一个BLE设备。我们将使用**BluePixel Technologies**的**BLE Scanner**应用程序，它可以在Play商店上找到。当你启动它时，你将看到周围可用的BLE设备列表以及它们的地址。可以使用`hciconfig`命令查看Pi上蓝牙适配器的地址。Gatt服务器的默认实现将设备命名为**Gopher**。以下截图说明了BLE
    Scanner应用程序，显示Pi作为BLE设备：
- en: '![Installing the necessary components](img/image00132.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: 安装必要的组件
- en: The BLE Scanner app showing the Pi as a BLE device
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: BLE Scanner应用程序显示Pi作为BLE设备
- en: 'The BLE stack is designed in a way that a device supports some number of services
    that users can connect to, and each service can provide read/write or notification
    characteristics, which is mainly data that you can write to, read, or get notifications
    from. Click on the device in the app and you will connect to the Pi''s newly started
    BLE server. You will be presented with four services. The one we are interested
    in is called **UNKNOWN SERVICE**, which is unnamed because it is not a standard
    service and it is implemented to only demonstrate the Gatt example server. Click
    on this service and you will see three characteristics provided by this service:
    **READ**, **WRIT**E, and **Notification**. You can recognize the type of characteristic
    by looking at which one of the three buttons on BLE Scanner app is enabled. The
    following screenshot illustrates the READ characteristics:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: BLE堆栈设计成设备支持一些用户可以连接的服务，并且每个服务可以提供读/写或通知特性，这主要是你可以写入、读取或从中获取通知的数据。在应用程序中点击设备，你将连接到Pi新启动的BLE服务器。你将看到四个服务。我们感兴趣的是称为**UNKNOWN
    SERVICE**的服务，它没有名称，因为它不是标准服务，它只是用来演示Gatt示例服务器。点击这个服务，你将看到这个服务提供的三个特性：**READ**，**WRITE**和**Notification**。你可以通过查看BLE
    Scanner应用程序上哪个按钮被启用来识别特性的类型。以下截图说明了READ特性：
- en: '![Installing the necessary components](img/image00133.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Installing the necessary components](img/image00133.jpeg)'
- en: The READ characteristic
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: READ特性
- en: Adding a sensor service to Bluetooth Low Energy
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向蓝牙低功耗添加传感器服务
- en: 'We will add a new service to the already existing example from Gatt. This new
    service will publish two new characteristics to begin with: one for humidity and
    the other for temperature measurements. We will read the measurements the same
    way using the techniques we''ve discussed in [Chapter 2](part0021.xhtml#aid-K0RQ1
    "Chapter 2. Server Management with Pi"), *Server Management with Pi*. To read
    these measurements, we will create two new files with content similar to the `sense.py`
    file that we discussed [Chapter 2](part0021.xhtml#aid-K0RQ1 "Chapter 2. Server
    Management with Pi"), *Server Management with Pi*. Let''s create two files under
    the `home` directory, and name them `humidity.py` and `temperature.py`. The `temperature.py`
    file has the following content:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向Gatt的已有示例添加一个新服务。这个新服务将首先发布两个新特性：一个用于湿度，另一个用于温度测量。我们将使用我们在[第2章](part0021.xhtml#aid-K0RQ1
    "第2章。使用Pi进行服务器管理")中讨论过的技术以相同的方式读取测量值，*使用Pi进行服务器管理*。要读取这些测量值，我们将创建两个内容类似于我们在[第2章](part0021.xhtml#aid-K0RQ1
    "第2章。使用Pi进行服务器管理")中讨论的`sense.py`文件的新文件。让我们在`home`目录下创建两个文件，分别命名为`humidity.py`和`temperature.py`。`temperature.py`文件的内容如下：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `humidity.py` file has similar content. The only difference is that it
    prints out the humidity part of the measurement instead of the temperature:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`humidity.py`文件的内容类似。唯一的区别是它打印出测量的湿度部分而不是温度：'
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We need to change the file access mode to executable as well using the following
    command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要使用以下命令将文件访问模式更改为可执行：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, you can test sensor measurements using the following commands:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用以下命令测试传感器测量：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next step is to publish these readings via the Bluetooth channel. We will
    create a new service inside the existing Gatt server example. For this purpose,
    you can start editing the server.go `source file` for the server example in the
    `/home/pi/gopath/src/github.com/paypal/gatt/examples` path. You only need to add
    three lines of code in the function definition for `onStateChanged` in between
    other service definitions. In the following content, note that the count service
    and battery service already exist. We only need to add the sensor service:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是通过蓝牙通道发布这些读数。我们将在现有的Gatt服务器示例中创建一个新服务。为此，您可以开始编辑`/home/pi/gopath/src/github.com/paypal/gatt/examples`路径中服务器示例的`server.go`源文件。您只需要在`onStateChanged`函数定义中添加三行代码，放在其他服务定义之间。在以下内容中，请注意计数服务和电池服务已经存在。我们只需要添加传感器服务：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Additionally, in the same file, change the line where new services are advertised
    to the following code in order to advertise the new service as well:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在同一文件中，更改广告新服务的行为以下代码，以便也广告新服务：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We need to add the definition for the new service also. The following code
    should be placed in a file, named `sensor.go`, under the `service` directory of
    the Gatt examples at the same level as other service definition files, such as
    `count.go` and `battery.go`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加新服务的定义。以下代码应放在名为`sensor.go`的文件中，放在Gatt示例的`service`目录下，与其他服务定义文件（如`count.go`和`battery.go`）处于同一级别：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We need to build and rerun our server code using `go`. The following commands
    that we used earlier will help us do this. Note that you should be in the /`home/pi/gopath/src/github.com/paypal/gatt`
    directory:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`go`构建和重新运行我们的服务器代码。我们之前使用的以下命令将帮助我们做到这一点。请注意，您应该在`/home/pi/gopath/src/github.com/paypal/gatt`目录中：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can use the BLE Scanner app on Android again to connect to this new service
    and read the temperature and humidity sensor values. The following screenshot
    illustrates the Gopher services:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次在Android上使用BLE Scanner应用程序连接到这项新服务并读取温度和湿度传感器数值。以下截图说明了Gopher服务：
- en: '![Adding a sensor service to Bluetooth Low Energy](img/image00134.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![向蓝牙低功耗添加传感器服务](img/image00134.jpeg)'
- en: 'After connecting to the Gopher device, you should see the newly added service
    with the `19fc95c0-c111-11e3-9904-0002a5d5c51b` ID, and new characteristics for
    that service as shown in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到Gopher设备后，您应该看到具有`19fc95c0-c111-11e3-9904-0002a5d5c51b` ID的新添加服务，以及该服务的新特征，如下截图所示：
- en: '![Adding a sensor service to Bluetooth Low Energy](img/image00135.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![向蓝牙低功耗添加传感器服务](img/image00135.jpeg)'
- en: 'Newly added characteristics: one for temperature and the other for humidity
    measurements'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 新增特征：一个用于温度，另一个用于湿度测量
- en: 'The following screenshot illustrates the characteristic details for temperature
    measurement after pressing the the **Read** button:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 按下**读取**按钮后，以下截图说明了温度测量的特征细节：
- en: '![Adding a sensor service to Bluetooth Low Energy](img/image00136.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![向蓝牙低功耗添加传感器服务](img/image00136.jpeg)'
- en: Characteristics for temperature measurement showing a current value of 27 degrees
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 温度测量特征显示当前值为27度
- en: Connecting from an Android app
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Android应用程序连接
- en: We have used an existing app to connect to the BLE service that we implemented
    on Raspberry Pi. This app, called BLE Scanner, is very general purpose and would
    work for any kind of BLE device. However, we need a more specialized app that
    only reads measurements and abstracts away details of the BLE protocol, such as
    device scan, services, and service characteristics. In this section, we will implement
    an Android app to connect to the Raspberry Pi BLE. We need to install the Android
    Studio for this purpose. Android studio is specifically designed for Android app
    development by Google. You can read more about it by visiting [http://developer.android.com/tools/studio/](http://developer.android.com/tools/studio/).
    You can find instructions for installation at [http://developer.android.com/sdk/](http://developer.android.com/sdk/).
    We will use a real device to test our app and not the built-in emulator. For this
    purpose, you may need to install device drivers specific to your Android phone
    and make configuration changes to the Android Studio installation. The [http://developer.android.com/tools/device.html](http://developer.android.com/tools/device.html)
    link will help you carry out these actions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用现有的应用程序连接到了我们在树莓派上实现的BLE服务。这个名为BLE Scanner的应用程序非常通用，可以用于任何类型的BLE设备。但是，我们需要一个更专门的应用程序，它只读取测量值并抽象出BLE协议的细节，如设备扫描、服务和服务特征。在本节中，我们将实现一个Android应用程序来连接到树莓派的BLE。为此，我们需要安装Android
    Studio。Android Studio是由Google专门为Android应用程序开发设计的。您可以通过访问[http://developer.android.com/tools/studio/](http://developer.android.com/tools/studio/)了解更多信息。您可以在[http://developer.android.com/sdk/](http://developer.android.com/sdk/)找到安装说明。我们将使用真实设备来测试我们的应用程序，而不是内置的模拟器。为此，您可能需要安装特定于您的Android手机的设备驱动程序，并对Android
    Studio安装进行配置更改。[http://developer.android.com/tools/device.html](http://developer.android.com/tools/device.html)链接将帮助您执行这些操作。
- en: Now, start the Android Studio and choose a new project to create. I will name
    the application `BLEPi` and the domain `example.com`. You should choose **Phone
    and Tablet** as the form factor, and at least **Android 5.0** as the minimum SDK
    as better BLE support is introduced with this SDK to the Android system. The core
    BLE support is actually added to Android 4.3, and the code files distributed on
    the book's website as well as the GitHub repository of the book will work for
    Android 4.3 as well as Android 5.0\. However, for the sake of simplicity and ease,
    the upcoming code is for Android 5.0 only. Note that you should have downloaded
    Android 5.0 SDK during the Android Studio installation in order to be able to
    choose it in the create project wizard. Take a look at the links we've just mentioned
    in this section for further details on this. Then, choose to add a blank activity
    to the app and do not change the name of the activity in the next step; we will
    keep it as `MainActivity`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动Android Studio并选择创建一个新项目。我将应用程序命名为`BLEPi`，域名为`example.com`。您应该选择**手机和平板电脑**作为表单因素，至少**Android
    5.0**作为最低SDK，因为该SDK引入了更好的BLE支持到Android系统。核心BLE支持实际上是在Android 4.3中添加的，本书网站上分发的代码文件以及本书的GitHub存储库也适用于Android
    4.3和Android 5.0。然而，为了简单和方便起见，即将介绍的代码仅适用于Android 5.0。请注意，在安装Android Studio时，您应该已经下载了Android
    5.0 SDK，以便能够在创建项目向导中选择它。请查看本节中刚提到的链接，以获取有关此问题的更多详细信息。然后，选择向应用程序添加一个空白活动，并在下一步中不更改活动的名称；我们将保持其为`MainActivity`。
- en: 'We will begin our implementation by adding Bluetooth permissions to the `AndroidManifest.xml`
    file inside the `manifest` and before the `application` tag:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过向`AndroidManifest.xml`文件中的`manifest`和`application`标签之间添加蓝牙权限来开始我们的实现：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we''ll begin making changes to the `MainActivity.java` file. Start by
    making the following class variable definitions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将开始对`MainActivity.java`文件进行更改。首先进行以下类变量定义：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `bluetoothAdapter` definition represents the local device's Bluetooth adapter
    and lets you perform fundamental Bluetooth tasks, such as discovering other devices
    and getting the properties of the discovered devices. `bleScanner` provides methods
    to perform scan-related operations specific to Bluetooth LE devices and `bleGatt`
    provides the Bluetooth GATT functionality to enable communication with Bluetooth
    Smart devices. The UUIDs we have defined here are the same as the ones we have
    used in the `sensor.go` file that we saved on the Pi previously for the identification
    of the new service and its two new characteristics.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`bluetoothAdapter`定义表示本地设备的蓝牙适配器，并允许您执行基本的蓝牙任务，比如发现其他设备和获取已发现设备的属性。`bleScanner`提供了执行与蓝牙LE设备特定的扫描相关操作的方法，`bleGatt`提供了蓝牙GATT功能，以实现与蓝牙智能设备的通信。我们在这里定义的UUID与我们之前在Pi上保存的`sensor.go`文件中使用的UUID相同，用于识别新服务及其两个新特征。'
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In the Android Studio, you can use the *Alt*+*Enter* shortcut key to automatically
    import missing packages. The cursor should be located on the class for which the
    import is missing in the java file. Or, alternatively, place the cursor on the
    class, keep the mouse pointer on it, and you will see a light bulb menu. In this
    menu, you can select the import class option.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中，您可以使用*Alt*+*Enter*快捷键自动导入丢失的包。光标应该位于java文件中缺少导入的类上。或者，将光标放在类上，将鼠标指针放在上面，您将看到一个灯泡菜单。在这个菜单中，您可以选择导入类选项。
- en: 'Inside the `onCreate` method, which is called by the Android system when the
    app starts for the first time, we can initialize `bluetoothAdapter`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中，当应用程序第一次启动时，Android系统会调用该方法，我们可以初始化`bluetoothAdapter`：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We need to define the `startScan` method that will be called whenever we want
    to initiate a scan of BLE devices.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义`startScan`方法，每当我们想要启动BLE设备扫描时就会调用该方法。
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we check if Bluetooth is enabled on the device first. If not, we''ll
    present a message box to let the user enable Bluetooth. If it is enabled, we''ll
    get an instance of `bleScanner`, which is used to start a scan using the `startScan`
    method. We can give a callback implementation name, such as `scanCallback`, which
    will be called whenever a scan returns some results. Now, we need to define this
    callback variable, as shown in the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先检查设备上是否启用了蓝牙。如果没有，我们将显示一个消息框，让用户启用蓝牙。如果启用了，我们将获取`bleScanner`的一个实例，该实例用于使用`startScan`方法开始扫描。我们可以给一个回调实现名称，比如`scanCallback`，每当扫描返回一些结果时就会调用该方法。现在，我们需要定义这个回调变量，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `ScanCallback` implementation overrides one important method, `onScanResult`,
    which is called whenever there is any new device to report. We then check if the
    device name is the same as the one that was defined in the `server.go` file on
    the Pi. If so, we can save the device properties and connection information to
    the `bleGatt` variable. We can even connect to the device using the `connectGatt`
    method, and provide another callback implementation, `bleGattCallback`, which
    will be called whenever an Android system establishes a connection to the device.
    We stop the scan if we have found the device we are looking for. Here is the definition
    for this callback:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScanCallback`实现覆盖了一个重要的方法`onScanResult`，每当有新设备报告时就会调用该方法。然后我们检查设备名称是否与在Pi上的`server.go`文件中定义的名称相同。如果是，我们可以将设备属性和连接信息保存到`bleGatt`变量中。我们甚至可以使用`connectGatt`方法连接到设备，并提供另一个回调实现`bleGattCallback`，每当Android系统与设备建立连接时就会调用该方法。如果找到了我们要找的设备，我们就停止扫描。这是这个回调的定义：'
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this callback implementation, we override three important methods called
    from the Android system on different times. The `onConnectionStateChange` method
    is called whenever a connection is established to the remote device through Bluetooth.
    In this case, we can initiate the service discovery of the device using the `discoverServices`
    method. The `onServicesDiscovered` method is then called when services are discovered
    on the device. In such a case, we''ll read, to begin with, the temperature characteristics
    for the sensor service that we''ve defined on the Pi using the `readCharacteristic`
    method. Whenever the value of the characteristic reading operation has succeeded
    the third overridden method, `onCharacteristicRead` is called where we read the
    next characteristic which is humidity, and then wait for this operation to succeed
    in the same method. Then, we take turns to read the humidity and temperature values
    using the `readNextCharacteristic` method that we''ll define in the same callback
    implementation. This is because the BLE protocol does not let us read both characteristics
    at the same time. Let''s take a look at the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个回调实现中，我们重写了三个在不同时间从Android系统调用的重要方法。每当通过蓝牙与远程设备建立连接时，将调用`onConnectionStateChange`方法。在这种情况下，我们可以使用`discoverServices`方法启动设备的服务发现。然后，当设备上发现服务时，将调用`onServicesDiscovered`方法。在这种情况下，我们将首先读取我们在树莓派上定义的传感器服务的温度特征，使用`readCharacteristic`方法。每当特征读取操作的值成功时，将调用第三个重写的方法`onCharacteristicRead`，在其中我们读取下一个特征，即湿度，然后在同一方法中等待此操作成功。然后，我们轮流使用`readNextCharacteristic`方法读取湿度和温度值，我们将在相同的回调实现中定义该方法。这是因为BLE协议不允许我们同时读取两个特征。让我们看一下以下代码：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Whenever the respective read operation succeeds, we get the value of the measurement
    using the `getStringValue` method of the returned `characteristic` object, and
    then show it in the UI elements that we will define in the `activity_main.xml`
    file as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每当相应的读操作成功时，我们使用返回的`characteristic`对象的`getStringValue`方法获取测量值，然后在我们将在`activity_main.xml`文件中定义的UI元素中显示它，如下所示：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For the code to be complete, we need to define the following methods as well
    in the `MainActivity.java` file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码完整，我们还需要在`MainActivity.java`文件中定义以下方法：
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `onActivityResult` method is called whenever a user enables Bluetooth, and
    we need to start scanning in this case as well as every time the user starts an
    app where `onResume` is called. If the user closes the app, the Bluetooth connection
    can be stopped through the `onPause` method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户启用蓝牙时，将调用`onActivityResult`方法，我们需要在这种情况下开始扫描，以及每当用户启动调用`onResume`的应用程序时。如果用户关闭应用程序，可以通过`onPause`方法停止蓝牙连接。
- en: This is a great opportunity to test our the first version of our app that we
    have implemented so far and verify that it works. Select **Run app** in the **Run**
    menu in the Android Studio, and you will be given an option to select the location
    to install the app. You will then see the Android device that you have attached
    to your computer in the list.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的机会，测试我们迄今为止实施的应用的第一个版本，并验证它是否有效。在Android Studio的**运行**菜单中选择**运行应用程序**，然后您将有选择安装应用程序的位置的选项。然后，您将在列表中看到连接到计算机的Android设备。
- en: Sending the reboot command from your Android phone to the Pi
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从您的Android手机向树莓派发送重启命令
- en: 'Until now, we have been receiving data from the Pi through BLE. Now, we will
    send commands to it using the same channel. We will implement a new write characteristic
    in the same service as our temperature and humidity read characteristics are,
    which were defined on the Pi. Using these new characteristics, we will send the
    reboot command to the Pi. Let''s begin by editing the **sensor.go** file again
    and put the following code at the end of it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直通过BLE从树莓派接收数据。现在，我们将使用相同的通道向其发送命令。我们将在与我们的温度和湿度读特征相同的服务中实现一个新的写特征，这些特征是在树莓派上定义的。使用这些新特征，我们将向树莓派发送重启命令。让我们从再次编辑**sensor.go**文件开始，并在其末尾放入以下代码：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Build and restart the BLE server using the following commands:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令构建和重新启动BLE服务器：
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, test the characteristics mentioned previously using the BLE Scanner app.
    Whenever you write something to these characteristics, the Pi will reboot.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用BLE Scanner应用程序测试先前提到的特征。每当您向这些特征写入内容时，树莓派将重新启动。
- en: The next step is to implement this new reboot function in the Android app that
    we have been building.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在我们一直在构建的Android应用程序中实现这个新的重启功能。
- en: 'First, add the UUID of the this new write characteristics we have just defined
    and a variable to control the operation sequences, as shown in the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加我们刚刚定义的新写特征的UUID以及控制操作顺序的变量，如下所示：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The boolean variable, `isSendReboot`, will be used to initiate the write characteristic
    operation and orchestrate it together with the read operations previously defined.
    The BLE stack cannot handle read/write operations that are too close to each other,
    and we want to avoid performing one operation before the previous one is completed.
    Then, in the `onCharacteristicRead` function of `bleGattCallback`, change the
    line where we call `readNextCharacteristic` with the following piece of code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔变量`isSendReboot`将用于启动写特征操作并与先前定义的读操作一起进行编排。BLE堆栈无法处理彼此太接近的读/写操作，我们希望在上一个操作完成之前避免执行下一个操作。然后，在`bleGattCallback`的`onCharacteristicRead`函数中，将我们调用`readNextCharacteristic`的行更改为以下代码：
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we will write a value, `reboot`, to the reboot characteristic if the
    control variable is set, by clicking a button that we will soon implement. We
    can override another method in `bleGattCallback`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果设置了控制变量，我们将向重启特征写入值`reboot`，通过点击我们即将实现的按钮。我们可以重写`bleGattCallback`中的另一个方法：
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This method is called whenever the write characteristic operation succeeds when
    we reset our control variable and continue with the read operations. Those of
    you who are observant might see a minor problem with this code, namely that we
    are sending a reboot command to the Pi, but at the same time, we're also trying
    to read characteristics from the Bluetooth device located on the same device that
    we are trying to reboot. These readings will not work when the Pi reboots, and
    our app will not be able to reconnect if we do not close and reopen it after the
    reboot has been completed successfully. The solution to this issue will be left
    as an exercise for you.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重置控制变量并继续读取操作时，将调用此方法以确保写入特征操作成功。细心的人可能会发现这段代码存在一个小问题，即我们正在向Pi发送重新启动命令，但与此同时，我们还试图从位于同一设备上的蓝牙设备读取特征。当Pi重新启动时，这些读取将无法工作，如果我们在重新启动成功完成后不关闭并重新打开应用程序，我们的应用程序将无法重新连接。解决此问题将留给您作为练习。
- en: 'The last part of the implementation is to add a button for the command to our
    user interface and connect this button to a method in the `MainAcitivity.java`
    file which will be executed whenever the button is pressed. Add the following
    lines to the `activity_main.xml` file inside the `RelativeLayout` tag to begin
    with:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的最后一部分是向我们的用户界面添加一个命令按钮，并将此按钮连接到`MainAcitivity.java`文件中的一个方法，每当按钮被按下时都会执行。首先在`activity_main.xml`文件的`RelativeLayout`标签内添加以下行：
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Define the `sendRebootCommand` method in the `MainActivity.java` file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity.java`文件中定义`sendRebootCommand`方法：
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The only thing this function does when the **Reboot** button is clicked on is
    set the control variable that we have defined previously.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当单击**重新启动**按钮时，此函数唯一要做的事情就是设置我们之前定义的控制变量。
- en: 'You can also add the following code in the `onScanResult` method of the `ScanCallback`
    class instance after the call to the `device.connectGatt` method to enable the
    button when we connect to Raspberry Pi via Bluetooth:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在`ScanCallback`类实例的`onScanResult`方法中添加以下代码，以在通过蓝牙连接到树莓派时启用按钮：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is a good place to test the app again and see if you can successfully restart
    the Pi through an Android device.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个再次测试应用程序的好地方，看看您是否可以通过Android设备成功重新启动Pi。
- en: Sending more commands from your Android phone to the Pi
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从您的Android手机发送更多命令到Pi
- en: In the previous section, we have sent the reboot command from Android to the
    Pi. In this section, we will send two new commands. One to light up a LED that
    we will connect to the Pi, and another to play sound on the Pi. These commands
    will be reused in the forthcoming sections.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们已经从Android发送了重新启动命令到Pi。在本节中，我们将发送两个新命令。一个是点亮我们将连接到Pi的LED，另一个是在Pi上播放声音。这些命令将在接下来的章节中被重复使用。
- en: Lighting the LEDs
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点亮LED灯
- en: We'll begin by connecting a LED light to the GPIO ports of the Pi. The LEDs
    usually come with a short and long leg. Connect a resistor to the short leg of
    the LED, and connect a female/female jumper to the other side of the resistor.
    This jumper should then be connected to one of the ground pins of the Pi. Take
    a look at the schema in [Chapter 2](part0021.xhtml#aid-K0RQ1 "Chapter 2. Server
    Management with Pi"), *Server Management with Pi*, to identify the pins. Note
    that we already used one of the ground pins when we connected our temperature-humidity
    sensor to the Pi. However, there are plenty of ground pins available. The long
    leg of the LED should be connected to one of the GPIO pins. We will choose number
    `17`. You can take a look the GPIO port mappings diagram in [Chapter 2](part0021.xhtml#aid-K0RQ1
    "Chapter 2. Server Management with Pi"), *Server Management with Pi*, to identify
    port `17`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将LED灯连接到Pi的GPIO端口。LED通常带有短腿和长腿。将电阻连接到LED的短腿，然后将一个母头/母头跳线连接到电阻的另一端。然后将这个跳线连接到Pi的一个地针上。查看[第2章](part0021.xhtml#aid-K0RQ1
    "第2章. 使用Pi进行服务器管理")中的模式，*使用Pi进行服务器管理*，以识别针脚。请注意，当我们将温湿度传感器连接到Pi时，我们已经使用了一个地针。但是，有很多地针可用。将LED的长腿连接到GPIO针脚之一。我们将选择编号为`17`的针脚。您可以查看[第2章](part0021.xhtml#aid-K0RQ1
    "第2章. 使用Pi进行服务器管理")中的GPIO端口映射图，以识别端口`17`。
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is a good idea to choose a resistor in the span of 270Ω to 470Ω. This resistor
    to protects the LED lamp from unexpected voltage changes. If you choose a resistor
    with lower ohm values, then the LED will be brighter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最好选择一个电阻在270Ω到470Ω之间。这个电阻可以保护LED灯免受意外电压变化的影响。如果您选择电阻值较低的电阻，LED将会更亮。
- en: 'We will access the GPIO and LED lamp using a software utility called **wiringPi**.
    We can download and install it using the following commands:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为**wiringPi**的软件实用程序来访问GPIO和LED灯。我们可以使用以下命令下载和安装它：
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'These commands have helped us to install a command-line tool called `gpio`,
    which you can now use to light the LED lamp:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令已经帮助我们安装了一个名为`gpio`的命令行工具，您现在可以使用它来点亮LED灯：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can turn it off using the following comand:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令关闭它：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We need to add two new characteristics to our BLE server implementation: the
    first to turn the light on, and the second to turn it off. Add the following lines
    to the end of the `sensor.go` file, and note that we have new UUIDs for each new
    characteristic that we create:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向BLE服务器实现添加两个新特征：一个用于打开灯，另一个用于关闭灯。在`sensor.go`文件的末尾添加以下行，并注意我们为每个新创建的特征都有新的UUID：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, build and restart the BLE server again. If you have added the BLE server
    command inside the crontab, you might need to reboot the Pi. Next, connect to
    the Pi using the BLE Scanner app again and use the **Write** button on characteristics
    section in the app to write values to these characteristics. You will need to
    provide some text to write to, otherwise, the BLE Scanner app will not send commands.
    Once you do this, you will be able to turn the LED on and off.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次构建和重启BLE服务器。如果你已经将BLE服务器命令添加到crontab中，你可能需要重新启动树莓派。接下来，再次使用BLE Scanner应用连接到树莓派，并在应用程序中的特性部分使用**Write**按钮向这些特性写入值。你需要提供一些文本来写入，否则BLE
    Scanner应用将不会发送命令。一旦你这样做了，你就可以打开和关闭LED灯。
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is always a good idea to check the new characteristics you've added in BLE
    Scanner app before you try to access it with the app that we are building. This
    way, we can be sure that we have added the characteristics correctly on the Pi
    side.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试使用我们正在构建的应用程序访问之前，最好在BLE Scanner应用中检查你已经在树莓派上添加的新特性。这样，我们就可以确保我们已经正确地在树莓派端添加了特性。
- en: 'The next step is to implement this new function in our app. We can begin by
    introducing two new buttons in the `activity_main.xml` file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在我们的应用程序中实现这个新功能。我们可以从`activity_main.xml`文件中引入两个新按钮开始：
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In `MainActivity.java`, define the new UUID and control variables for the new
    characteristics:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity.java`中，为新特性定义新的UUID和控制变量：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the `onScanResult` method of `scanCallback`, add the following code in the
    if-statement to enable these two buttons just after enabling the reboot button:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`scanCallback`的`onScanResult`方法中，在启用重启按钮后，添加以下代码以启用这两个按钮：
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `onCharacteristicRead` method of `bleGattCallback`, add new else-if
    statements to the existing check of the control variable for `isSendReboot`. The
    new code will look similar to the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bleGattCallback`的`onCharacteristicRead`方法中，为`isSendReboot`的控制变量的现有检查添加新的else-if语句。新代码将类似于以下内容：
- en: '[PRE46]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the `onCharacteristicWrite` method, add the following code snippet to reset
    the control variables:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCharacteristicWrite`方法中，添加以下代码片段以重置控制变量：
- en: '[PRE47]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, add new functions that can be called on click events for the new buttons:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在新按钮的点击事件上添加可以调用的新函数：
- en: '[PRE48]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Your app will look similar to the following screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用将类似于以下截图：
- en: '![Lighting the LEDs](img/image00137.jpeg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![点亮LED灯](img/image00137.jpeg)'
- en: The final version of the app
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 应用的最终版本
- en: Be patient to see the effects of the new buttons after clicking on them as it
    will take a few seconds for the messages to arrive in the Pi, and for the the
    LED lamp to be turned on.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮后，请耐心等待新按钮的效果，因为消息需要几秒钟才能到达树莓派，并且LED灯需要点亮。
- en: Playing sounds on your Pi
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在树莓派上播放声音
- en: To be able to play sounds on the Pi, sound modules should be loaded on reboot.
    To do this, we need to add sound module specifications to the `/etc/modules` file.
    Add `snd-bcm2835` in this file if it does not already exist there.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在树莓派上播放声音，声音模块应该在重启时加载。为了做到这一点，我们需要将声音模块的规格添加到`/etc/modules`文件中。如果文件中不存在`snd-bcm2835`，则需要在文件中添加这一规格。
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can use the `lsmod` command-line tool to see which modules are loaded at
    the moment:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`lsmod`命令行工具查看当前加载的模块：
- en: '[PRE49]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This command loads the sound module without rebooting for the contents of the
    `/etc/modules` file to take effect.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令在不重启的情况下加载声音模块，以使`/etc/modules`文件的内容生效。
- en: 'We even need to find an audio file to play, which we can download using the
    following command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至需要找到一个可以播放的音频文件，可以使用以下命令进行下载：
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can now play this sound using the following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用以下命令播放这个声音：
- en: '[PRE51]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Tip
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Note that that the audio channel might default due to HDMI output and you may
    not hear anything on your 3.5mm jack. In this case, you can run the following
    command to set the default audio player to the 3.5mm jack:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于HDMI输出，音频通道可能会默认，你可能无法在3.5mm插孔上听到任何声音。在这种情况下，你可以运行以下命令将默认音频播放器设置为3.5mm插孔：
- en: '[PRE52]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The next step is to add the new write characteristic to the `sensor.go` file,
    as shown in the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将新的写特性添加到`sensor.go`文件中，如下所示：
- en: '[PRE53]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Do not forget to build and restart the Pi using the `go` `build` `examples/server.go`
    command. Next, define a new button in the `activity_main.xml` file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记使用`go build examples/server.go`命令构建和重启树莓派。接下来，在`activity_main.xml`文件中定义一个新按钮：
- en: '[PRE54]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Define a new event handler for the `onClick` event in the `MainActivity.java`
    file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity.java`文件中为`onClick`事件定义一个新的事件处理程序：
- en: '[PRE55]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, add new the UUID and control variables to the same file:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将新的UUID和控制变量添加到同一个文件中：
- en: '[PRE56]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Enable the new button in the `onScanResult` method of the `scanCallback` instance
    variable inside the if-statement for the `bleGatt` null check:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在`scanCallback`实例变量的`onScanResult`方法中，在`bleGatt`的null检查的if语句中启用新按钮：
- en: '[PRE57]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add the following code in the new else-if statement in the `onCharacteristicRead`
    handler for the `bleGattCallback` variable:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bleGattCallback`变量的`onCharacteristicRead`处理程序中的新else-if语句中添加以下代码：
- en: '[PRE58]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Add a new statement to reset the control variable in the `onCharacteristicWrite`
    method:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCharacteristicWrite`方法中添加一个新的语句以重置控制变量：
- en: '[PRE59]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now the whistle command is ready to be tested from our app.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在哨声命令已经准备好从我们的应用程序中进行测试。
- en: Combining the commands and being informed on incoming calls
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合命令并在来电时获得通知
- en: 'In this last section, we will combine the whistle and LED light up commands
    and initiate this new command whenever our phone rings. By now, we are used to
    creating new characteristics. Here is a new one to be added to `sensor.go` file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们将结合哨声和LED点亮命令，并在手机响铃时启动这个新命令。到目前为止，我们已经习惯了创建新特性。这里是要添加到`sensor.go`文件中的新特性：
- en: '[PRE60]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can combine these two commands to save ourselves from the development details
    of sending two separate commands as a single transaction. We need a new permission
    in the `AndroidManifest.xml` file to get an incoming call state from the Android
    system:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这两个命令组合起来，以免自己从发送两个单独命令的开发细节中解脱出来。我们需要在`AndroidManifest.xml`文件中获取来自Android系统的来电状态的新权限：
- en: '[PRE61]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We also need new instance variables in `MainActivity.java`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`MainActivity.java`中添加新的实例变量：
- en: '[PRE62]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, we need to get an instance of a system phone service and attach our own
    listener to it. Add these two lines of code in the `onCreate` method:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要获取系统电话服务的实例，并将我们自己的监听器附加到它上面。在`onCreate`方法中添加这两行代码：
- en: '[PRE63]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, define a local `PhoneListener` class:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个本地的`PhoneListener`类：
- en: '[PRE64]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here, whenever we get a state change on the phone, we check if this is a `CALL_STATE_RINGING`
    state. If it is, we can set the control variable for the newly created command
    in the same way as the button click event handlers did for previously defined
    commands. Then, we can add this additional else-if statement in the `onCharacteristic`
    read method as well:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每当我们在手机上得到一个状态变化时，我们会检查这是否是`CALL_STATE_RINGING`状态。如果是，我们可以像按钮点击事件处理程序为先前定义的命令一样设置新创建命令的控制变量。然后，我们也可以在`onCharacteristic`读取方法中添加这个额外的else-if语句：
- en: '[PRE65]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, we''ll reset the control variable in the `onCharacteristicWrite` method
    as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`onCharacteristicWrite`方法中重置控制变量如下：
- en: '[PRE66]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now, you will be able to see the LED lamp turned on and hear the whistle sound
    on the Pi as soon as your phone rings. Note that our app needs to be started and
    visible for this to work. This is caused by one of the two main issues with the
    code we have. All the communication with the Pi through BLE should actually be
    done in side an Android service, and phone events need to be handled inside `BroadcastReceiver`
    instead of in an **activity**. Both of these implementations, that is, Pi communication
    and phone state interception, should actually be separated from the **activity**.
    An activity should actually be a UI component and nothing more. However, our intention
    here was to show you only the fun parts and be quick and dirty. These further
    improvements on the Android code will be left as an exercise for you.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您的手机响铃时，您将能够看到LED灯亮起并在树莓派上听到哨声。请注意，我们的应用程序需要启动并可见才能正常工作。这是由我们代码中的两个主要问题之一引起的。所有通过BLE与树莓派的通信实际上应该在Android服务中进行，电话事件需要在`BroadcastReceiver`中处理，而不是在**activity**中。这两个实现，即树莓派通信和电话状态拦截，实际上应该与**activity**分开。活动实际上应该是一个UI组件，仅此而已。然而，我们在这里的意图是只向您展示有趣的部分，并快速粗糙地完成。这些对Android代码的进一步改进将留作您的练习。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered a lot of content, ranging from BLE implementations
    on the Pi to details of the Android BLE code. We had great fun with the Pi and
    came up with a useful project that can be developed further.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容，从树莓派上的BLE实现到Android BLE代码的细节。我们在树莓派上玩得很开心，并提出了一个可以进一步开发的有用项目。
- en: In the next chapter, we will learn more ways to make use of BLE equipment on
    the Pi and use our phones not just as Android devices, but also as access points
    for the Pi.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多的方法来利用树莓派上的BLE设备，并且不仅将我们的手机作为Android设备，还将其作为树莓派的访问点。
