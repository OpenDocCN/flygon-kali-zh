["```kt\n    #ifndef _PACKT_INPUTHANDLER_HPP_\n    #define _PACKT_INPUTHANDLER_HPP_\n\n    #include <android/input.h>\n\n    class InputHandler {\n    public:\n        virtual ~InputHandler() {};\n\n        virtual bool onTouchEvent(AInputEvent* pEvent) = 0;\n    };\n    #endif\n    ```", "```kt\n    ...\n    #include \"ActivityHandler.hpp\"\n    #include \"InputHandler.hpp\"\n\n    #include <android_native_app_glue.h>\n\n    class EventLoop {\n    public:\n    EventLoop(android_app* pApplication,\n                ActivityHandler& pActivityHandler,\n                InputHandler& pInputHandler);\n        ...\n    private:\n        ...\n        void processAppEvent(int32_t pCommand);\n        int32_t processInputEvent(AInputEvent* pEvent);\n\n        static void callback_appEvent(android_app* pApplication,\n                int32_t pCommand);\n        static int32_t callback_input(android_app* pApplication,\n     AInputEvent* pEvent);\n\n        ...\n        ActivityHandler& mActivityHandler;\n        InputHandler& mInputHandler;\n    };\n    #endif\n    ```", "```kt\n    ...\n    EventLoop::EventLoop(android_app* pApplication,\n        ActivityHandler& pActivityHandler, InputHandler& pInputHandler):\n            mApplication(pApplication),\n            mActivityHandler(pActivityHandler),\n            mEnabled(false), mQuit(false),\n            mInputHandler(pInputHandler) {\n        mApplication->userData = this;\n        mApplication->onAppCmd = callback_appEvent;\n     mApplication->onInputEvent = callback_input;\n    }\n\n    ...\n\n    int32_t EventLoop::callback_input(android_app* pApplication,\n     AInputEvent* pEvent) {\n     EventLoop& eventLoop = *(EventLoop*) pApplication->userData;\n     return eventLoop.processInputEvent(pEvent);\n    }\n    ...\n    ```", "```kt\n    ...\n    int32_t EventLoop::processInputEvent(AInputEvent* pEvent) {\n        if (!mEnabled) return 0;\n\n        int32_t eventType = AInputEvent_getType(pEvent);\n        switch (eventType) {\n        case AINPUT_EVENT_TYPE_MOTION:\n            switch (AInputEvent_getSource(pEvent)) {\n            case AINPUT_SOURCE_TOUCHSCREEN:\n                return mInputHandler.onTouchEvent(pEvent);\n                break;\n            }\n            break;\n        }\n        return 0;\n    }\n    ```", "```kt\n    #ifndef _PACKT_INPUTMANAGER_HPP_\n    #define _PACKT_INPUTMANAGER_HPP_\n\n    #include \"GraphicsManager.hpp\"\n    #include \"InputHandler.hpp\"\n    #include \"Types.hpp\"\n\n    #include <android_native_app_glue.h>\n\n    class InputManager : public InputHandler {\n    public:\n        InputManager(android_app* pApplication,\n                 GraphicsManager& pGraphicsManager);\n\n        float getDirectionX() { return mDirectionX; };\n        float getDirectionY() { return mDirectionY; };\n        void setRefPoint(Location* pRefPoint) { mRefPoint = pRefPoint; };\n\n        void start();\n\n    protected:\n        bool onTouchEvent(AInputEvent* pEvent);\n\n    private:\n        android_app* mApplication;\n        GraphicsManager& mGraphicsManager;\n\n        // Input values.\n        float mScaleFactor;\n        float mDirectionX, mDirectionY;\n        // Reference point to evaluate touch distance.\n        Location* mRefPoint;\n    };\n    #endif\n    ```", "```kt\n    #include \"InputManager.hpp\"\n    #include \"Log.hpp\"\n\n    #include <android_native_app_glue.h>\n    #include <cmath>\n\n    InputManager::InputManager(android_app* pApplication,\n            GraphicsManager& pGraphicsManager) :\n        mApplication(pApplication), mGraphicsManager(pGraphicsManager),\n        mDirectionX(0.0f), mDirectionY(0.0f),\n        mRefPoint(NULL) {\n    }\n    ...\n    ```", "```kt\n    ...\n    void InputManager::start() {\n        Log::info(\"Starting InputManager.\");\n        mDirectionX = 0.0f, mDirectionY = 0.0f;\n        mScaleFactor = float(mGraphicsManager.getRenderWidth())\n                           / float(mGraphicsManager.getScreenWidth());\n    }\n    ...\n    ```", "```kt\n    ...\n    bool InputManager::onTouchEvent(AInputEvent* pEvent) {\n        static const float TOUCH_MAX_RANGE = 65.0f; // In game units.\n\n        if (mRefPoint != NULL) {\n            if (AMotionEvent_getAction(pEvent)\n                            == AMOTION_EVENT_ACTION_MOVE) {\n                float x = AMotionEvent_getX(pEvent, 0) * mScaleFactor;\n                float y = (float(mGraphicsManager.getScreenHeight())\n                         - AMotionEvent_getY(pEvent, 0)) * mScaleFactor;\n                // Needs a conversion to proper coordinates\n                // (origin at bottom/left). Only moveY needs it.\n                float moveX = x - mRefPoint->x;\n                float moveY = y - mRefPoint->y;\n                float moveRange = sqrt((moveX * moveX) + (moveY * moveY));\n\n                if (moveRange > TOUCH_MAX_RANGE) {\n                    float cropFactor = TOUCH_MAX_RANGE / moveRange;\n                    moveX *= cropFactor; moveY *= cropFactor;\n                }\n\n                mDirectionX = moveX / TOUCH_MAX_RANGE;\n                mDirectionY   = moveY / TOUCH_MAX_RANGE;\n            } else {\n                mDirectionX = 0.0f; mDirectionY = 0.0f;\n            }\n        }\n        return true;\n    }\n    ```", "```kt\n    #ifndef _PACKT_MOVEABLEBODY_HPP_\n    #define _PACKT_MOVEABLEBODY_HPP_\n\n    #include \"InputManager.hpp\"\n    #include \"PhysicsManager.hpp\"\n    #include \"Types.hpp\"\n\n    class MoveableBody {\n    public:\n        MoveableBody(android_app* pApplication,\n           InputManager& pInputManager, PhysicsManager& pPhysicsManager);\n\n        PhysicsBody* registerMoveableBody(Location& pLocation,\n                int32_t pSizeX, int32_t pSizeY);\n\n        void initialize();\n        void update();\n\n    private:\n        PhysicsManager& mPhysicsManager;\n        InputManager& mInputManager;\n\n        PhysicsBody* mBody;\n    };\n    #endif\n    ```", "```kt\n    #include \"Log.hpp\"\n    #include \"MoveableBody.hpp\"\n\n    MoveableBody::MoveableBody(android_app* pApplication,\n          InputManager& pInputManager, PhysicsManager& pPhysicsManager) :\n        mInputManager(pInputManager),\n        mPhysicsManager(pPhysicsManager),\n        mBody(NULL) {\n    }\n\n    PhysicsBody* MoveableBody::registerMoveableBody(Location& pLocation,\n    int32_t pSizeX, int32_t pSizeY) {\n        mBody = mPhysicsManager.loadBody(pLocation, pSizeX, pSizeY);\n        mInputManager.setRefPoint(&pLocation);\n        return mBody;\n    }\n    ...\n    ```", "```kt\n    ...\n    void MoveableBody::initialize() {\n        mBody->velocityX = 0.0f;\n        mBody->velocityY = 0.0f;\n    }\n\n    void MoveableBody::update() {\n        static const float MOVE_SPEED = 320.0f;\n        mBody->velocityX = mInputManager.getDirectionX() * MOVE_SPEED;\n        mBody->velocityY = mInputManager.getDirectionY() * MOVE_SPEED;\n    }\n    ```", "```kt\n    ...\n    #include \"EventLoop.hpp\"\n    #include \"GraphicsManager.hpp\"\n    #include \"InputManager.hpp\"\n    #include \"MoveableBody.hpp\"\n    #include \"PhysicsManager.hpp\"\n    #include \"Resource.hpp\"\n    ...\n\n    class DroidBlaster : public ActivityHandler {\n        ...\n    private:\n        TimeManager     mTimeManager;\n        GraphicsManager mGraphicsManager;\n        PhysicsManager  mPhysicsManager;\n        SoundManager    mSoundManager;\n        InputManager    mInputManager;\n        EventLoop mEventLoop;\n        ...\n        Asteroid mAsteroids;\n        Ship mShip;\n        StarField mStarField;\n        SpriteBatch mSpriteBatch;\n        MoveableBody mMoveableBody;\n    };\n    #endif\n    ```", "```kt\n    ...\n    DroidBlaster::DroidBlaster(android_app* pApplication):\n        mTimeManager(),\n        mGraphicsManager(pApplication),\n        mPhysicsManager(mTimeManager, mGraphicsManager),\n        mSoundManager(pApplication),\n        mInputManager(pApplication, mGraphicsManager),\n     mEventLoop(pApplication, *this, mInputManager),\n        ...\n        mAsteroids(pApplication, mTimeManager, mGraphicsManager,\n        mPhysicsManager),\n        mShip(pApplication, mGraphicsManager, mSoundManager),\n        mStarField(pApplication, mTimeManager, mGraphicsManager,\n                STAR_COUNT, mStarTexture),\n        mSpriteBatch(mTimeManager, mGraphicsManager),\n        mMoveableBody(pApplication, mInputManager, mPhysicsManager) {\n        ...\n        Sprite* shipGraphics = mSpriteBatch.registerSprite(mShipTexture,\n                SHIP_SIZE, SHIP_SIZE);\n        shipGraphics->setAnimation(SHIP_FRAME_1, SHIP_FRAME_COUNT,\n                SHIP_ANIM_SPEED, true);\n        Sound* collisionSound =\n                mSoundManager.registerSound(mCollisionSound);\n        mMoveableBody.registerMoveableBody(shipGraphics->location,\n     SHIP_SIZE, SHIP_SIZE);\n        mShip.registerShip(shipGraphics, collisionSound);\n\n        // Creates asteroids.\n        ...\n    }\n    ...\n    ```", "```kt\n    ...\n    status DroidBlaster::onActivate() {\n        Log::info(\"Activating DroidBlaster\");\n        if (mGraphicsManager.start() != STATUS_OK) return STATUS_KO;\n        if (mSoundManager.start() != STATUS_OK) return STATUS_KO;\n        mInputManager.start();\n\n        mSoundManager.playBGM(mBGM);\n\n        mAsteroids.initialize();\n        mShip.initialize();\n        mMoveableBody.initialize();\n\n        mTimeManager.reset();\n        return STATUS_OK;\n    }\n\n    ...\n\n    status DroidBlaster::onStep() {\n        mTimeManager.update();\n        mPhysicsManager.update();\n\n        mAsteroids.update();\n        mMoveableBody.update();\n\n        return mGraphicsManager.update();\n    }\n    ...\n    ```", "```kt\nAMotionEvent_getAction()\n```", "```kt\nAMotionEvent_getX()\nAMotionEvent_getY()\n```", "```kt\nAMotionEvent_getDownTime()\nAMotionEvent_getEventTime()\n```", "```kt\nAMotionEvent_getPressure()\nAMotionEvent_getSize()\n\n```", "```kt\nAMotionEvent_getHistorySize()\nAMotionEvent_getHistoricalX()\nAMotionEvent_getHistoricalY()\n```", "```kt\nAMotionEvent_getPointerCount()\n```", "```kt\nAMotionEvent_getPointerId()\n```", "```kt\n    #ifndef _PACKT_INPUTHANDLER_HPP_\n    #define _PACKT_INPUTHANDLER_HPP_\n\n    #include <android/input.h>\n\n    class InputHandler {\n    public:\n        virtual ~InputHandler() {};\n\n        virtual bool onTouchEvent(AInputEvent* pEvent) = 0;\n        virtual bool onKeyboardEvent(AInputEvent* pEvent) = 0;\n     virtual bool onTrackballEvent(AInputEvent* pEvent) = 0;\n    };\n    #endif\n    ```", "```kt\n    ...\n    int32_t EventLoop::processInputEvent(AInputEvent* pEvent) {\n        if (!mEnabled) return 0;\n\n        int32_t eventType = AInputEvent_getType(pEvent);\n        switch (eventType) {\n        case AINPUT_EVENT_TYPE_MOTION:\n            switch (AInputEvent_getSource(pEvent)) {\n            case AINPUT_SOURCE_TOUCHSCREEN:\n                return mInputHandler.onTouchEvent(pEvent);\n                break;\n\n            case AINPUT_SOURCE_TRACKBALL:\n     return mInputHandler.onTrackballEvent(pEvent);\n     break;\n            }\n            break;\n\n        case AINPUT_EVENT_TYPE_KEY:\n     return mInputHandler.onKeyboardEvent(pEvent);\n     break;\n        }\n    return 0;\n    }\n    ...\n    ```", "```kt\n    ...\n    class InputManager : public InputHandler {\n        ...\n    protected:\n        bool onTouchEvent(AInputEvent* pEvent);\n        bool onKeyboardEvent(AInputEvent* pEvent);\n     bool onTrackballEvent(AInputEvent* pEvent);\n\n        ...\n    };\n    #endif\n    ```", "```kt\n    ...\n    bool InputManager::onKeyboardEvent(AInputEvent* pEvent) {\n        static const float ORTHOGONAL_MOVE = 1.0f;\n\n        if (AKeyEvent_getAction(pEvent) == AKEY_EVENT_ACTION_DOWN) {\n            switch (AKeyEvent_getKeyCode(pEvent)) {\n            case AKEYCODE_DPAD_LEFT:\n                mDirectionX = -ORTHOGONAL_MOVE;\n                return true;\n            case AKEYCODE_DPAD_RIGHT:\n                mDirectionX = ORTHOGONAL_MOVE;\n                return true;\n            case AKEYCODE_DPAD_DOWN:\n                mDirectionY = -ORTHOGONAL_MOVE;\n                return true;\n            case AKEYCODE_DPAD_UP:\n                mDirectionY = ORTHOGONAL_MOVE;\n                return true;\n            }\n        } else {\n            switch (AKeyEvent_getKeyCode(pEvent)) {\n            case AKEYCODE_DPAD_LEFT:\n            case AKEYCODE_DPAD_RIGHT:\n                mDirectionX = 0.0f;\n                return true;\n            case AKEYCODE_DPAD_DOWN:\n            case AKEYCODE_DPAD_UP:\n                mDirectionY = 0.0f;\n                return true;\n            }\n        }\n        return false;\n    }\n    ...\n    ```", "```kt\n    ...\n    bool InputManager::onTrackballEvent(AInputEvent* pEvent) {\n        static const float ORTHOGONAL_MOVE = 1.0f;\n        static const float DIAGONAL_MOVE   = 0.707f;\n        static const float THRESHOLD       = (1/100.0f);\n\n         if (AMotionEvent_getAction(pEvent) == AMOTION_EVENT_ACTION_MOVE) {\n            float directionX = AMotionEvent_getX(pEvent, 0);\n            float directionY = AMotionEvent_getY(pEvent, 0);\n            float horizontal, vertical;\n\n            if (directionX < -THRESHOLD) {\n                if (directionY < -THRESHOLD) {\n                    horizontal = -DIAGONAL_MOVE;\n                    vertical   = DIAGONAL_MOVE;\n                } else if (directionY > THRESHOLD) {\n                    horizontal = -DIAGONAL_MOVE;\n                    vertical   = -DIAGONAL_MOVE;\n                } else {\n                    horizontal = -ORTHOGONAL_MOVE;\n                    vertical   = 0.0f;\n                }\n            } else if (directionX > THRESHOLD) {\n                if (directionY < -THRESHOLD) {\n                    horizontal = DIAGONAL_MOVE;\n                    vertical   = DIAGONAL_MOVE;\n                } else if (directionY > THRESHOLD) {\n                    horizontal = DIAGONAL_MOVE;\n                    vertical   = -DIAGONAL_MOVE;\n                } else {\n                    horizontal = ORTHOGONAL_MOVE;\n                    vertical   = 0.0f;\n                }\n            } else if (directionY < -THRESHOLD) {\n                horizontal = 0.0f;\n                vertical   = ORTHOGONAL_MOVE;\n            } else if (directionY > THRESHOLD) {\n                horizontal = 0.0f;\n                vertical   = -ORTHOGONAL_MOVE;\n            }\n    ...\n    ```", "```kt\n            ...\n            // Ends movement if there is a counter movement.\n            if ((horizontal < 0.0f) && (mDirectionX > 0.0f)) {\n                mDirectionX = 0.0f;\n            } else if ((horizontal > 0.0f) && (mDirectionX < 0.0f)) {\n                mDirectionX = 0.0f;\n            } else {\n                mDirectionX = horizontal;\n            }\n\n            if ((vertical < 0.0f) && (mDirectionY > 0.0f)) {\n                mDirectionY = 0.0f;\n            } else if ((vertical > 0.0f) && (mDirectionY < 0.0f)) {\n                mDirectionY = 0.0f;\n            } else {\n                mDirectionY = vertical;\n            }\n        } else {\n            mDirectionX = 0.0f; mDirectionY = 0.0f;\n        }\n        return true;\n    }\n    ```", "```kt\n    #ifndef _PACKT_INPUTHANDLER_HPP_\n    #define _PACKT_INPUTHANDLER_HPP_\n\n    #include <android/input.h>\n    #include <android/sensor.h>\n\n    class InputHandler {\n    public:\n        virtual ~InputHandler() {};\n\n        virtual bool onTouchEvent(AInputEvent* pEvent) = 0;\n        virtual bool onKeyboardEvent(AInputEvent* pEvent) = 0;\n        virtual bool onTrackballEvent(AInputEvent* pEvent) = 0;\n        virtual bool onAccelerometerEvent(ASensorEvent* pEvent) = 0;\n    };\n    #endif\n    ```", "```kt\n        #ifndef _PACKT_EVENTLOOP_HPP_\n        #define _PACKT_EVENTLOOP_HPP_\n\n        #include \"ActivityHandler.hpp\"\n        #include \"InputHandler.hpp\"\n\n        #include <android_native_app_glue.h>\n\n        class EventLoop {\n            ...\n        private:\n            void activate();\n            void deactivate();\n            void activateAccelerometer();\n         void deactivateAccelerometer();\n\n            void processAppEvent(int32_t pCommand);\n            int32_t processInputEvent(AInputEvent* pEvent);\n            void processSensorEvent();\n\n            static void callback_appEvent(android_app* pApplication,\n                    int32_t pCommand);\n            static int32_t callback_input(android_app* pApplication,\n                    AInputEvent* pEvent);\n            static void callback_sensor(android_app* pApplication,\n         android_poll_source* pSource);\n\n            ...\n            InputHandler& mInputHandler;\n\n            ASensorManager* mSensorManager;\n         ASensorEventQueue* mSensorEventQueue;\n         android_poll_source mSensorPollSource;\n         const ASensor* mAccelerometer;\n        };\n        #endif\n        ```", "```kt\n    #include \"EventLoop.hpp\"\n    #include \"Log.hpp\"\n\n    EventLoop::EventLoop(android_app* pApplication,\n        ActivityHandler& pActivityHandler, InputHandler& pInputHandler):\n            mApplication(pApplication),\n            mActivityHandler(pActivityHandler),\n            mEnabled(false), mQuit(false),\n            mInputHandler(pInputHandler),\n            mSensorPollSource(), mSensorManager(NULL),\n            mSensorEventQueue(NULL), mAccelerometer(NULL) {\n        mApplication->userData = this;\n        mApplication->onAppCmd = callback_appEvent;\n        mApplication->onInputEvent = callback_input;\n    }\n    ...\n    ```", "```kt\n    ...\n    void EventLoop::activate() {\n        if ((!mEnabled) && (mApplication->window != NULL)) {\n            mSensorPollSource.id = LOOPER_ID_USER;\n     mSensorPollSource.app = mApplication;\n     mSensorPollSource.process = callback_sensor;\n     mSensorManager = ASensorManager_getInstance();\n     if (mSensorManager != NULL) {\n     mSensorEventQueue = ASensorManager_createEventQueue(\n     mSensorManager, mApplication->looper,\n     LOOPER_ID_USER, NULL, &mSensorPollSource);\n     if (mSensorEventQueue == NULL) goto ERROR;\n     }\n     activateAccelerometer();\n\n            mQuit = false; mEnabled = true;\n            if (mActivityHandler.onActivate() != STATUS_OK) {\n                goto ERROR;\n            }\n        }\n        return;\n\n    ERROR:\n        mQuit = true;\n        deactivate();\n        ANativeActivity_finish(mApplication->activity);\n    }\n    ...\n    ```", "```kt\n    ...\n    void EventLoop::deactivate() {\n        if (mEnabled) {\n            deactivateAccelerometer();\n     if (mSensorEventQueue != NULL) {\n     ASensorManager_destroyEventQueue(mSensorManager,\n     mSensorEventQueue);\n     mSensorEventQueue = NULL;\n     }\n     mSensorManager = NULL;\n\n            mActivityHandler.onDeactivate();\n            mEnabled = false;\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    void EventLoop::callback_sensor(android_app* pApplication,\n        android_poll_source* pSource) {\n        EventLoop& eventLoop = *(EventLoop*) pApplication->userData;\n        eventLoop.processSensorEvent();\n    }\n\n    void EventLoop::processSensorEvent() {\n        ASensorEvent event;\n        if (!mEnabled) return;\n\n        while (ASensorEventQueue_getEvents(mSensorEventQueue,\n                &event, 1) > 0) {\n            switch (event.type) {\n            case ASENSOR_TYPE_ACCELEROMETER:\n                mInputHandler.onAccelerometerEvent(&event);\n                break;\n            }\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    void EventLoop::activateAccelerometer() {\n        mAccelerometer = ASensorManager_getDefaultSensor(\n                mSensorManager, ASENSOR_TYPE_ACCELEROMETER);\n        if (mAccelerometer != NULL) {\n            if (ASensorEventQueue_enableSensor(\n                    mSensorEventQueue, mAccelerometer) < 0) {\n                Log::error(\"Could not enable accelerometer\");\n                return;\n            }\n\n            int32_t minDelay = ASensor_getMinDelay(mAccelerometer);\n            if (ASensorEventQueue_setEventRate(mSensorEventQueue,\n                    mAccelerometer, minDelay) < 0) {\n                Log::error(\"Could not set accelerometer rate\");\n            }\n        } else {\n            Log::error(\"No accelerometer found\");\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    void EventLoop::deactivateAccelerometer() {\n        if (mAccelerometer != NULL) {\n            if (ASensorEventQueue_disableSensor(mSensorEventQueue,\n                    mAccelerometer) < 0) {\n                Log::error(\"Error while deactivating sensor.\");\n            }\n            mAccelerometer = NULL;\n        }\n    }\n    ```", "```kt\n    typedef struct ASensorEvent {\n        int32_t version;\n        int32_t sensor;\n        int32_t type;\n        int32_t reserved0;\n        int64_t timestamp;\n        union {\n            float           data[16];\n            ASensorVector   vector;\n            ASensorVector   acceleration;\n            ASensorVector   magnetic;\n            float           temperature;\n            float           distance;\n            float           light;\n            float           pressure;\n        };\n        int32_t reserved1[4];\n    } ASensorEvent;\n    ```", "```kt\ntypedef struct ASensorVector {\n    union {\n        float v[3];\n        struct {\n            float x;\n            float y;\n            float z;\n        };\n        struct {\n            float azimuth;\n            float pitch;\n            float roll;\n        };\n    };\n    int8_t status;\n    uint8_t reserved[3];\n} ASensorVector;\n```", "```kt\n    #ifndef _PACKT_CONFIGURATION_HPP_\n    #define _PACKT_CONFIGURATION_HPP_\n\n    #include \"Types.hpp\"\n\n    #include <android_native_app_glue.h>\n    #include <jni.h>\n\n    typedef int32_t screen_rot;\n\n    const screen_rot ROTATION_0   = 0;\n    const screen_rot ROTATION_90  = 1;\n    const screen_rot ROTATION_180 = 2;\n    const screen_rot ROTATION_270 = 3;\n\n    class Configuration {\n    public:\n        Configuration(android_app* pApplication);\n\n        screen_rot getRotation() { return mRotation; };\n\n    private:\n        void findRotation(JNIEnv* pEnv);\n\n        android_app* mApplication;\n        screen_rot mRotation;\n    };\n    #endif\n    ```", "```kt\n    #include \"Configuration.hpp\"\n    #include \"Log.hpp\"\n\n    #include <stdlib.h>\n\n    Configuration::Configuration(android_app* pApplication) :\n        mApplication(pApplication),\n        mRotation(0) {\n        AConfiguration* configuration = AConfiguration_new();\n        if (configuration == NULL) return;\n\n        int32_t result;\n        char i18NBuffer[] = \"__\";\n        static const char* orientation[] = {\n            \"Unknown\", \"Portrait\", \"Landscape\", \"Square\"\n        };\n        static const char* screenSize[] = {\n            \"Unknown\", \"Small\", \"Normal\", \"Large\", \"X-Large\"\n        };\n        static const char* screenLong[] = {\n            \"Unknown\", \"No\", \"Yes\"\n        };\n\n        // Dumps current configuration.\n        AConfiguration_fromAssetManager(configuration,\n            mApplication->activity->assetManager);\n        result = AConfiguration_getSdkVersion(configuration);\n        Log::info(\"SDK Version : %d\", result);\n        AConfiguration_getLanguage(configuration, i18NBuffer);\n        Log::info(\"Language    : %s\", i18NBuffer);\n        AConfiguration_getCountry(configuration, i18NBuffer);\n        Log::info(\"Country     : %s\", i18NBuffer);\n        result = AConfiguration_getOrientation(configuration);\n        Log::info(\"Orientation : %s (%d)\", orientation[result], result);\n        result = AConfiguration_getDensity(configuration);\n        Log::info(\"Density     : %d dpi\", result);\n        result = AConfiguration_getScreenSize(configuration);\n        Log::info(\"Screen Size : %s (%d)\", screenSize[result], result);\n        result = AConfiguration_getScreenLong(configuration);\n        Log::info(\"Long Screen : %s (%d)\", screenLong[result], result);\n        AConfiguration_delete(configuration);\n    ...\n    ```", "```kt\n    ...\n        JavaVM* javaVM = mApplication->activity->vm;\n        JavaVMAttachArgs javaVMAttachArgs;\n        javaVMAttachArgs.version = JNI_VERSION_1_6;\n        javaVMAttachArgs.name = \"NativeThread\";\n        javaVMAttachArgs.group = NULL;\n        JNIEnv* env;\n        if (javaVM->AttachCurrentThread(&env,\n                        &javaVMAttachArgs) != JNI_OK) {\n            Log::error(\"JNI error while attaching the VM\");\n            return;\n        }\n        // Finds screen rotation and get-rid of JNI.\n        findRotation(env);\n        mApplication->activity->vm->DetachCurrentThread();\n    }\n    ...\n    ```", "```kt\n    WindowManager mgr = (InputMethodManager)\n    myActivity.getSystemService(Context.WINDOW_SERVICE);\n    int rotation = mgr.getDefaultDisplay().getRotation();\n    ```", "```kt\n    ...\n    void Configuration::findRotation(JNIEnv* pEnv) {\n        jobject WINDOW_SERVICE, windowManager, display;\n        jclass ClassActivity, ClassContext;\n        jclass ClassWindowManager, ClassDisplay;\n        jmethodID MethodGetSystemService;\n        jmethodID MethodGetDefaultDisplay;\n        jmethodID MethodGetRotation;\n        jfieldID FieldWINDOW_SERVICE;\n\n        jobject activity = mApplication->activity->clazz;\n\n        // Classes.\n        ClassActivity = pEnv->GetObjectClass(activity);\n        ClassContext = pEnv->FindClass(\"android/content/Context\");\n        ClassWindowManager = pEnv->FindClass(\n            \"android/view/WindowManager\");\n        ClassDisplay = pEnv->FindClass(\"android/view/Display\");\n\n        // Methods.\n        MethodGetSystemService = pEnv->GetMethodID(ClassActivity,\n            \"getSystemService\",\n            \"(Ljava/lang/String;)Ljava/lang/Object;\");\n        MethodGetDefaultDisplay = pEnv->GetMethodID(\n            ClassWindowManager, \"getDefaultDisplay\",\n            \"()Landroid/view/Display;\");\n        MethodGetRotation = pEnv->GetMethodID(ClassDisplay,\n            \"getRotation\", \"()I\");\n\n        // Fields.\n        FieldWINDOW_SERVICE = pEnv->GetStaticFieldID(\n          ClassContext, \"WINDOW_SERVICE\", \"Ljava/lang/String;\");\n\n        // Retrieves Context.WINDOW_SERVICE.\n        WINDOW_SERVICE = pEnv->GetStaticObjectField(ClassContext,\n            FieldWINDOW_SERVICE);\n        // Runs getSystemService(WINDOW_SERVICE).\n        windowManager = pEnv->CallObjectMethod(activity,\n            MethodGetSystemService, WINDOW_SERVICE);\n        // Runs getDefaultDisplay().getRotation().\n        display = pEnv->CallObjectMethod(windowManager,\n            MethodGetDefaultDisplay);\n        mRotation = pEnv->CallIntMethod(display, MethodGetRotation);\n\n        pEnv->DeleteLocalRef(ClassActivity);\n        pEnv->DeleteLocalRef(ClassContext);\n        pEnv->DeleteLocalRef(ClassWindowManager);\n        pEnv->DeleteLocalRef(ClassDisplay);\n    }\n    ```", "```kt\n    ...\n    #include \"Configuration.hpp\"\n    #include \"GraphicsManager.hpp\"\n    #include \"InputHandler.hpp\"\n    ...\n    class InputManager : public InputHandler {\n        ...\n    protected:\n        bool onTouchEvent(AInputEvent* pEvent);\n        bool onKeyboardEvent(AInputEvent* pEvent);\n        bool onTrackballEvent(AInputEvent* pEvent);\n        bool onAccelerometerEvent(ASensorEvent* pEvent);\n     void toScreenCoord(screen_rot pRotation,\n     ASensorVector* pCanonical, ASensorVector* pScreen);\n\n    private:\n        ...\n        float mScaleFactor;\n        float mDirectionX, mDirectionY;\n         // Reference point to evaluate touch distance.\n         Location* mRefPoint;\n        screen_rot mRotation;\n    };\n    #endif\n    ```", "```kt\n    ...\n     InputManager::InputManager(android_app* pApplication,\n             GraphicsManager& pGraphicsManager) :\n            mApplication(pApplication), mGraphicsManager(pGraphicsManager),\n            mDirectionX(0.0f), mDirectionY(0.0f),\n            mRefPoint(NULL) {\n        Configuration configuration(pApplication);\n     mRotation = configuration.getRotation();\n    }\n    ...\n    ```", "```kt\n    ...\n    bool InputManager::onAccelerometerEvent(ASensorEvent* pEvent) {\n        static const float GRAVITY =  ASENSOR_STANDARD_GRAVITY / 2.0f;\n        static const float MIN_X = -1.0f; static const float MAX_X = 1.0f;\n        static const float MIN_Z =  0.0f; static const float MAX_Z = 2.0f;\n        static const float CENTER_X = (MAX_X + MIN_X) / 2.0f;\n        static const float CENTER_Z = (MAX_Z + MIN_Z) / 2.0f;\n\n        // Converts from canonical to screen coordinates.\n        ASensorVector vector;\n        toScreenCoord(mRotation, &pEvent->vector, &vector);\n\n        // Roll tilt.\n        float rawHorizontal = pEvent->vector.x / GRAVITY;\n        if (rawHorizontal > MAX_X) {\n            rawHorizontal = MAX_X;\n        } else if (rawHorizontal < MIN_X) {\n            rawHorizontal = MIN_X;\n        }\n        mDirectionX = CENTER_X - rawHorizontal;\n\n        // Pitch tilt. Final value needs to be inverted.\n        float rawVertical = pEvent->vector.z / GRAVITY;\n        if (rawVertical > MAX_Z) {\n            rawVertical = MAX_Z;\n        } else if (rawVertical < MIN_Z) {\n            rawVertical = MIN_Z;\n        }\n        mDirectionY = rawVertical - CENTER_Z;\n        return true;\n    }\n    ...\n    ```", "```kt\n    ...\n    void InputManager::toScreenCoord(screen_rot pRotation,\n        ASensorVector* pCanonical, ASensorVector* pScreen) {\n        struct AxisSwap {\n            int8_t negX; int8_t negY;\n            int8_t xSrc; int8_t ySrc;\n        };\n        static const AxisSwap axisSwaps[] = {\n             {  1, -1, 0, 1},  // ROTATION_0\n             { -1, -1, 1, 0},  // ROTATION_90\n             { -1,  1, 0, 1},  // ROTATION_180\n             {  1,  1, 1, 0}}; // ROTATION_270\n        const AxisSwap& swap = axisSwaps[pRotation];\n\n        pScreen->v[0] = swap.negX * pCanonical->v[swap.xSrc];\n        pScreen->v[1] = swap.negY * pCanonical->v[swap.ySrc];\n        pScreen->v[2] = pCanonical->v[2];\n    }\n    ```"]