- en: Configuring Jenkins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Jenkins
- en: 'We have seen how to configure and use Docker. In this chapter, we will present
    Jenkins, which can be used separately or together with Docker. We will show that
    the combination of these two tools outcomes in the surprisingly good results:
    automated configuration and flexible scalability.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何配置和使用Docker。在本章中，我们将介绍Jenkins，它可以单独使用，也可以与Docker一起使用。我们将展示这两个工具的结合产生了令人惊讶的好结果：自动配置和灵活的可扩展性。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Introducing Jenkins and its advantages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Jenkins及其优势
- en: Installing and starting Jenkins
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和启动Jenkins
- en: Creating the first pipeline
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建第一个流水线
- en: Scaling Jenkins with agents
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代理扩展Jenkins
- en: Configuring Docker-based agents
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置基于Docker的代理
- en: Building custom master and slave Docker images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自定义主从Docker镜像
- en: Configuring strategies for the security and backup
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置安全和备份策略
- en: What is Jenkins?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins是什么？
- en: Jenkins is an open source automation server written in Java. With the very active
    community-based support and a huge number of plugins, it is the most popular tool
    to implement the Continuous Integration and Continuous Delivery processes. Formerly
    known as Hudson, it was renamed after Oracle bought Hudson and decided to develop
    it as the proprietary software. Jenkins remained under the MIT license and is
    highly valued for its simplicity, flexibility, and versatility.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins是用Java编写的开源自动化服务器。凭借非常活跃的基于社区的支持和大量的插件，它是实施持续集成和持续交付流程的最流行工具。以前被称为Hudson，Oracle收购Hudson并决定将其开发为专有软件后更名为Jenkins。Jenkins仍然在MIT许可下，并因其简单性、灵活性和多功能性而备受推崇。
- en: Jenkins outstands other Continuous Integration tools and is the most widely
    used software of its kind. That is all possible because of its features and capabilities.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins优于其他持续集成工具，是最广泛使用的其类软件。这一切都是可能的，因为它的特性和能力。
- en: Let's walk through the most interesting parts of the Jenkins' characteristics.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Jenkins特性中最有趣的部分。
- en: '**Language agnostic**: Jenkins has a lot of plugins, which support most of
    the programming languages and frameworks. Moreover, since it can use any shell
    command and any software installed, it is suitable for every automation process
    that can be imagined.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言无关**：Jenkins有很多插件，支持大多数编程语言和框架。此外，由于它可以使用任何shell命令和任何安装的软件，因此适用于可以想象的每个自动化流程。'
- en: '**Extensible by plugins**: Jenkins has a great community and a lot of plugins
    available (1000 plus). It also allows you to write your own plugins in order to
    customize Jenkins for your needs.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展的插件**：Jenkins拥有一个庞大的社区和大量可用的插件（1000多个）。它还允许您编写自己的插件，以定制Jenkins以满足您的需求。'
- en: '**Portable**: Jenkins is written in Java, so it can be run on any operating
    system. For convenience, it is also delivered in a lot of versions: web application
    archive (WAR), Docker image, Windows binary, Mac binary, and Linux binaries.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**便携**：Jenkins是用Java编写的，因此可以在任何操作系统上运行。为了方便，它还以许多版本提供：Web应用程序存档（WAR）、Docker镜像、Windows二进制、Mac二进制和Linux二进制。'
- en: '**Supports most SCM**: Jenkins integrates with virtually every source code
    management or build tool that exists. Again, because of its wide community and
    plugins, there is no other continuous integration tool that supports so many external
    systems.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持大多数SCM**：Jenkins与几乎所有现有的源代码管理或构建工具集成。再次，由于其广泛的社区和插件，没有其他持续集成工具支持如此多的外部系统。'
- en: '**Distributed**: Jenkins has a built-in mechanism for the master/slave mode,
    which distributes its executions across multiple nodes located on multiple machines.
    It can also use heterogeneous environment, for example, different nodes can have
    different operating system installed.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式**：Jenkins具有内置的主/从模式机制，可以将其执行分布在位于多台机器上的多个节点上。它还可以使用异构环境，例如，不同的节点可以安装不同的操作系统。'
- en: '**Simplicity**: The installation and configuration process is simple. There
    is no need to configure any additional software, nor the database. It can be configured
    completely via GUI, XML, or Groovy scripts.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：安装和配置过程简单。无需配置任何额外的软件，也不需要数据库。可以完全通过GUI、XML或Groovy脚本进行配置。'
- en: '**Code-oriented**: Jenkins pipelines are defined as code. Also, the Jenkins
    itself can be configured using XML files or Groovy scripts. That allows keeping
    the configuration in the source code repository and helps in the automation of
    the Jenkins configuration.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向代码**：Jenkins管道被定义为代码。此外，Jenkins本身可以使用XML文件或Groovy脚本进行配置。这允许将配置保存在源代码存储库中，并有助于自动化Jenkins配置。'
- en: Jenkins installation
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins安装
- en: The Jenkins installation process is quick and simple. There are different methods
    to do it, but since we're already familiar with the Docker tool and the benefits
    it gives, we will start from the Docker-based solution. This is also the easiest,
    the most predictable, and the smartest way to go. However, let's mention the installation
    requirements first.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins安装过程快速简单。有不同的方法可以做到这一点，但由于我们已经熟悉Docker工具及其带来的好处，我们将从基于Docker的解决方案开始。这也是最简单、最可预测和最明智的方法。然而，让我们先提到安装要求。
- en: Requirements for installation
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装要求
- en: 'The minimal system requirements are relatively low:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最低系统要求相对较低：
- en: Java 8
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8
- en: 256MB free memory
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 256MB可用内存
- en: 1 GB+ free disk space
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 GB以上的可用磁盘空间
- en: However, it's essential to understand that the requirements strictly depend
    on what you plan to do with Jenkins. If Jenkins is used to serve the whole team
    as the Continuous Integration server, then even in case of a small team, it's
    advised to have 1 GB plus free memory and 50 GB plus free disk space. Needless
    to say, Jenkins also performs some computations and transfers a lot of data across
    the network, so CPU and bandwidth are crucial.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要明白的是，要求严格取决于您打算如何使用Jenkins。如果Jenkins用于为整个团队提供持续集成服务器，即使是小团队，建议具有1 GB以上的可用内存和50
    GB以上的可用磁盘空间。不用说，Jenkins还执行一些计算并在网络上传输大量数据，因此CPU和带宽至关重要。
- en: To get a feeling what could be the requirements in case of a big company, the
    Netflix example is presented in the *Jenkins architecture* section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解在大公司的情况下可能需要的要求，*Jenkins架构*部分介绍了Netflix的例子。
- en: Installing on Docker
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker上安装
- en: Let’s see the step-by-step procedure to install Jenkins using Docker.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用Docker安装Jenkins的逐步过程。
- en: 'The Jenkins image is available in the official Docker Hub registry, so in order
    to install it we should execute the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins镜像可在官方Docker Hub注册表中找到，因此为了安装它，我们应该执行以下命令：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We need to specify the first `host_port` parameter—the port under which Jenkins
    is visible outside of the container. The second parameter, `host_volume`, specifies
    the directory where the Jenkins home is mapped. It needs to be specified as volume,
    and therefore persisted permanently, because it contains the configuration, pipeline
    builds, and logs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要指定第一个`host_port`参数——Jenkins在容器外可见的端口。第二个参数`host_volume`指定了Jenkins主目录映射的目录。它需要被指定为卷，并因此永久持久化，因为它包含了配置、管道构建和日志。
- en: As an example, let's see what the installation steps would look like in case
    of the Docker host on Linux/Ubuntu.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看在Linux/Ubuntu上Docker主机的安装步骤会是什么样子。
- en: '**Prepare the volume directory**: We need a separate directory with the admin
    ownership to keep the Jenkins home. Let''s prepare one with the following commands:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**准备卷目录**：我们需要一个具有管理员所有权的单独目录来保存Jenkins主目录。让我们用以下命令准备一个：'
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Run the Jenkins container**: Let''s run the container as a daemon and give
    it a proper name:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行Jenkins容器**：让我们将容器作为守护进程运行，并给它一个合适的名称：'
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '** Check if Jenkins is running**: After a moment, we can check whether Jenkins
    has started correctly by printing the logs:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查Jenkins是否正在运行**：过一会儿，我们可以通过打印日志来检查Jenkins是否已经正确启动：'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the production environment, you may also want to set up the reverse proxy
    in order to hide the Jenkins infrastructure behind the proxy server. The short
    description how to do it using the Nginx server can be found at [https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+with+Docker](https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+with+Docker).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，您可能还希望设置反向代理，以隐藏Jenkins基础设施在代理服务器后面。如何使用Nginx服务器进行设置的简要说明可以在[https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+with+Docker](https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+with+Docker)找到。
- en: 'After performing these few steps, Jenkins is ready to use. The Docker-based
    installation has two major advantages:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这几个步骤后，Jenkins就可以使用了。基于Docker的安装有两个主要优点：
- en: '**Failure recovery**: If Jenkins crashes, then it''s enough to run a new container
    with the same volume specified.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故障恢复**：如果Jenkins崩溃，只需运行一个指定了相同卷的新容器。'
- en: '**Custom images**: You can configure Jenkins as per your needs and store it
    as the Jenkins image. Then it can be shared within your organization or team,
    and there is no need to repeat the same configuration steps all the time, many
    times.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义镜像**：您可以根据自己的需求配置Jenkins并将其存储为Jenkins镜像。然后可以在您的组织或团队内共享，而无需一遍又一遍地重复相同的配置步骤。'
- en: Everywhere in this book, we use Jenkins in version 2.60.1.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的所有地方，我们使用的是版本2.60.1的Jenkins。
- en: Installing without Docker
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在没有Docker的情况下安装
- en: 'For the reasons mentioned earlier, the Docker installation is recommended.
    However, if it''s not an option or there are other reasons to proceed otherwise,
    then the installation process is just as simple. As an example, in case of Ubuntu,
    it''s enough to run:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 出于前面提到的原因，建议安装Docker。但是，如果这不是一个选择，或者有其他原因需要采取其他方式进行安装，那么安装过程同样简单。例如，在Ubuntu的情况下，只需运行：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All installation guides (Ubuntu, Mac, Windows, and others) can be found on the
    official Jenkins page [https://jenkins.io/doc/book/getting-started/installing/](https://jenkins.io/doc/book/getting-started/installing/).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所有安装指南（Ubuntu、Mac、Windows等）都可以在官方Jenkins页面[https://jenkins.io/doc/book/getting-started/installing/](https://jenkins.io/doc/book/getting-started/installing/)上找到。
- en: Initial configuration
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始配置
- en: 'No matter which installation you choose, the first start of Jenkins requires
    a few configuration steps. Let''s walk through them step by step:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您选择哪种安装方式，Jenkins的第一次启动都需要进行一些配置步骤。让我们一步一步地走过它们：
- en: 'Open Jenkins in the browser: `http://localhost:49001` (for binary installations,
    the default port is `8080`).'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开Jenkins：`http://localhost:49001`（对于二进制安装，默认端口为`8080`）。
- en: 'Jenkins should ask for the administrator password. It can be found in the Jenkins
    logs:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins应该要求输入管理员密码。它可以在Jenkins日志中找到：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After accepting the initial password, Jenkins asks whether to install the suggested
    plugins, which are adjusted to the most common use cases. Your answer depends,
    of course, on your needs. However, as the first Jenkins installation, it's reasonable
    to let Jenkins install all the recommended plugins.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受初始密码后，Jenkins会询问是否安装建议的插件，这些插件适用于最常见的用例。您的答案当然取决于您的需求。然而，作为第一个Jenkins安装，让Jenkins安装所有推荐的插件是合理的。
- en: After the plugin installation, Jenkins asks to set up username, password, and
    other basic information. If you skip it, the token from step 2 will be used as
    the admin password.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装插件后，Jenkins要求设置用户名、密码和其他基本信息。如果你跳过它，步骤2中的令牌将被用作管理员密码。
- en: 'The installation is complete and you should see the Jenkins dashboard:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您应该看到Jenkins仪表板：
- en: '![](assets/5823b433-89cb-43d1-a878-8f7995171901.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5823b433-89cb-43d1-a878-8f7995171901.png)'
- en: We are ready to use Jenkins and create the first pipeline.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好使用Jenkins并创建第一个管道。
- en: Jenkins hello world
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins 你好世界
- en: Everything in the entire IT world starts from the Hello World example.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 整个IT世界的一切都始于Hello World的例子。
- en: 'Let''s follow this rule and see the steps to create the first Jenkins pipeline:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遵循这个规则，看看创建第一个Jenkins管道的步骤：
- en: Click on New Item.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击*新建项目*。
- en: Enter `hello world` as the item name, choose Pipeline, and click on OK.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`hello world`输入为项目名称，选择管道，然后点击确定。
- en: There are a lot of options. We will skip them for now and go directly to the
    Pipeline section.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有很多选项。我们现在会跳过它们，直接进入管道部分。
- en: 'There, in the Script textbox, we can enter the pipeline script:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本文本框中，我们可以输入管道脚本：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Click on Save.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击*保存*。
- en: Click on Build Now.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击*立即构建*。
- en: 'We should see #1 under the Build History. If we click on it, and then on Console
    Output, we will see the log from the Pipeline build.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在构建历史下看到#1。如果我们点击它，然后点击*控制台输出*，我们将看到管道构建的日志。
- en: '![](assets/28b3c9dd-cd74-4912-a9af-b7b3a7724347.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/28b3c9dd-cd74-4912-a9af-b7b3a7724347.png)'
- en: We have just seen the first example and its successful output means that Jenkins
    is installed correctly. Now, let's move to slightly more advanced Jenkins configuration.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了第一个例子，成功的输出意味着Jenkins已经正确安装。现在，让我们转移到稍微更高级的Jenkins配置。
- en: We will describe more on the pipeline syntax in [Chapter 4](a07d252d-3812-45ad-a567-1c70dae74d9d.xhtml),
    *Continuous Integration Pipeline*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第4章](a07d252d-3812-45ad-a567-1c70dae74d9d.xhtml)中更详细地描述管道语法，*持续集成管道*。
- en: Jenkins architecture
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins架构
- en: The hello world job executed in almost no time at all. However, the pipelines
    are usually more complex and spend time on tasks such as downloading files from
    the internet, compiling the source code, or running tests. One build can take
    from minutes to hours.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: hello world作业几乎没有时间执行。然而，管道通常更复杂，需要时间来执行诸如从互联网下载文件、编译源代码或运行测试等任务。一个构建可能需要几分钟到几小时。
- en: In common scenarios, there are also many concurrent pipelines. Usually, the
    whole team, or even the whole organization, uses the same Jenkins instance. How
    to ensure that the builds will run quickly and smoothly?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在常见情况下，也会有许多并发的管道。通常，整个团队，甚至整个组织，都使用同一个Jenkins实例。如何确保构建能够快速顺利地运行？
- en: Master and slaves
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主节点和从节点
- en: Jenkins becomes overloaded sooner than it seems. Even in case of a small (micro)
    service, the build can take a few minutes. That means that one team committing
    frequently can easily kill the Jenkins instance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins很快就会变得过载。即使是一个小的（微）服务，构建也可能需要几分钟。这意味着一个频繁提交的团队很容易就能够使Jenkins实例崩溃。
- en: For that reason, unless the project is really small, Jenkins should not execute
    builds at all, but delegate them to the slave (agent) instances. To be precise,
    the Jenkins we're currently running is called the Jenkins master and it can delegate
    to the Jenkins agents.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除非项目非常小，Jenkins不应该执行构建，而是将它们委托给从节点（代理）实例。准确地说，我们当前运行的Jenkins称为Jenkins主节点，它可以委托给Jenkins代理。
- en: 'Let''s look at the diagram presenting the master-slave interaction:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下呈现主从交互的图表：
- en: '![](assets/1d28685d-ac8c-474b-9052-ed0f1e340e33.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1d28685d-ac8c-474b-9052-ed0f1e340e33.png)'
- en: 'In a distributed builds environment, the Jenkins master is responsible for:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式构建环境中，Jenkins主节点负责：
- en: Receiving build triggers (for example, after a commit to GitHub)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收构建触发器（例如，提交到GitHub后）
- en: Sending notifications (for example, email or HipChat message sent after the
    build failure)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送通知（例如，在构建失败后发送电子邮件或HipChat消息）
- en: Handling HTTP requests (interaction with clients)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理HTTP请求（与客户端的交互）
- en: Managing the build environment (orchestrating the job executions on slaves)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理构建环境（在从节点上编排作业执行）
- en: The build agent is a machine that take care of everything that happens after
    the build is started.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 构建代理是一个负责构建开始后发生的一切的机器。
- en: 'Since the responsibilities of the master and the slaves are different, they
    have different environmental requirements:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于主节点和从节点的责任不同，它们有不同的环境要求：
- en: '**Master**: This is usually (unless the project is really small) a dedicated
    machine with RAM ranging from 200 MB for small projects to 70GB plus for huge
    single-master projects.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主节点**：这通常是一个专用的机器，内存从小型项目的200 MB到大型单主项目的70GB以上不等。'
- en: '**Slave**: There are no general requirements (other than the fact that it should
    be capable of executing a single build, for example, if the project is a huge
    monolith that requires 100 GB of RAM, then the slave machine needs to satisfy
    these needs).'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从节点**：没有一般性要求（除了它应该能够执行单个构建之外，例如，如果项目是一个需要100GB RAM的巨型单体，那么从节点机器需要满足这些需求）。'
- en: 'Agents should also be as generic as possible. For instance, if we have different
    projects: one in Java, one in Python, and one in Ruby, then it would be perfect
    if each agent could build any of these projects. In such a case, the agents can
    be interchanged, which helps to optimize the usage of resources.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代理也应尽可能通用。例如，如果我们有不同的项目：一个是Java，一个是Python，一个是Ruby，那么每个代理都可以构建任何这些项目将是完美的。在这种情况下，代理可以互换，有助于优化资源的使用。
- en: If agents cannot be generic enough to match all projects, then it's possible
    to label (tag) agents and projects, so that the given build would be executed
    on a given type of agent.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代理不能足够通用以匹配所有项目，那么可以对代理和项目进行标记，以便给定的构建将在给定类型的代理上执行。
- en: Scalability
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性
- en: We can use Jenkins slaves to balance the load and scale up the Jenkins infrastructure.
    Such a process is called the horizontal scaling. The other possibility would be
    to use only one master node and increase resources of its machine. That process
    is called the vertical scaling. Let's look closer at these two concepts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Jenkins从节点来平衡负载和扩展Jenkins基础架构。这个过程称为水平扩展。另一种可能性是只使用一个主节点并增加其机器的资源。这个过程称为垂直扩展。让我们更仔细地看看这两个概念。
- en: Vertical scaling
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垂直扩展
- en: 'Vertical scaling means that, when the master''s load grows, then more resources
    are applied to the master''s machine. So, when new projects appear in our organization,
    we buy more RAM, add CPU cores, and extend the HDD drives. This may sound like
    a no-go solution; however, it''s often used, even by well-known organizations.
    Having a single Jenkins master set on the ultra-efficient hardware has one very
    strong advantage: maintenance. Any upgrades, scripts, security settings, roles
    assignment, or plugin installations have to be done in one place only.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直扩展意味着当主机负载增加时，会向主机的机器应用更多资源。因此，当我们的组织中出现新项目时，我们会购买更多的RAM，增加CPU核心，并扩展HDD驱动器。这可能听起来像是一个不可行的解决方案；然而，它经常被使用，甚至被知名组织使用。将单个Jenkins主设置在超高效的硬件上有一个非常强大的优势：维护。任何升级、脚本、安全设置、角色分配或插件安装都只需在一个地方完成。
- en: Horizontal scaling
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 水平扩展
- en: Horizontal scaling means that, when an organization grows, then more master
    instances are launched. This requires a smart allocation of instances to teams
    and, in the extreme case, each team can have its own Jenkins master. In that case,
    it might even happen that no slaves are needed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 水平扩展意味着当组织增长时，会启动更多的主实例。这需要将实例智能分配给团队，并且在极端情况下，每个团队都可以拥有自己的Jenkins主实例。在这种情况下，甚至可能不需要从属实例。
- en: 'The drawbacks are that it may be difficult to automate cross-project integrations
    and that a part of the team''s development time is spent on the Jenkins maintenance.
    However, the horizontal scaling has some significant advantages:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是可能难以自动化跨项目集成，并且团队的一部分开发时间花在了Jenkins维护上。然而，水平扩展具有一些显著的优势：
- en: Master machines don't need to be special in terms of hardware
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机器在硬件方面不需要特殊。
- en: Different teams can have different Jenkins settings (for example, different
    set of plugins)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的团队可以有不同的Jenkins设置（例如，不同的插件集）
- en: Teams usually feel better and work with Jenkins more efficiently if the instance
    is their own
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队通常会感到更好，并且如果实例是他们自己的话，他们会更有效地使用Jenkins。
- en: If one master instance is down, it does not impact the whole organization
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个主实例宕机，不会影响整个组织
- en: The infrastructure can be segregated into standard and mission-critical
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施可以分为标准和关键任务
- en: Some maintenance aspects can be simplified, for example, the team of five could
    reuse the same Jenkins password, so we may skip the roles and security settings
    (surely that is possible only if the corporate network is well firewalled)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些维护方面可以简化，例如，五人团队可以重用相同的Jenkins密码，因此我们可以跳过角色和安全设置（当然，只有在企业网络受到良好防火墙保护的情况下才可能）
- en: Test and production instances
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和生产实例
- en: 'Apart from the scaling approach, there is one more issue: how to test the Jenkins
    upgrades, new plugins, or pipeline definitions? Jenkins is critical to the whole
    company. It guarantees the quality of the software and (in case of Continuous
    Delivery) deploys to the production servers. That is why it needs to be highly
    available, so it is definitely not for the purpose of testing. It means there
    should always be two instances of the same Jenkins infrastructure: test and production.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了扩展方法，还有一个问题：如何测试Jenkins升级、新插件或流水线定义？Jenkins对整个公司至关重要。它保证了软件的质量，并且（在持续交付的情况下）部署到生产服务器。这就是为什么它需要高可用性，因此绝对不是为了测试的目的。这意味着应该始终存在两个相同的Jenkins基础架构实例：测试和生产。
- en: Test environment should always be as similar as possible to the production,
    so it also requires the similar number of agents attached.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 测试环境应该尽可能与生产环境相似，因此也需要相似数量的附加代理。
- en: Sample architecture
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例架构
- en: We already know that there should be slaves, (possibly multiple) master(s),
    and that everything should be duplicated into the test and production environments.
    However, what would the complete picture look like?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道应该有从属者，（可能是多个）主节点，以及一切都应该复制到测试和生产环境中。然而，完整的情况会是什么样子呢？
- en: Luckily, there are a lot of companies that published how they used Jenkins and
    what kind of architectures they created. It would be difficult to measure if more
    of them preferred vertical or horizontal scaling, but it ranged from having only
    one master instance to having one master for each team.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有很多公司发布了他们如何使用Jenkins以及他们创建了什么样的架构。很难衡量更多的公司是偏好垂直扩展还是水平扩展，但从只有一个主节点实例到每个团队都有一个主节点都有。范围很广。
- en: 'Let''s look at the example of Netflix to have a complete picture of the Jenkins
    infrastructure (they shared it as the **planned infrastructure** at Jenkins User
    Conference San Francisco 2012):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Netflix为例，来完整了解Jenkins基础设施的情况（他们在2012年旧金山Jenkins用户大会上分享了**计划中的基础设施**）：
- en: '![](assets/df2ac293-dafb-433e-8d17-f0f7ff006e6a.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/df2ac293-dafb-433e-8d17-f0f7ff006e6a.png)'
- en: They have test and production master instances, each of them owning a poll of
    slaves and additional ad hoc slaves. Altogether, it serves around 2000 builds
    per day. Note also that a part of their infrastructure is hosted on AWS and a
    part is on their own servers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 他们有测试和生产主节点实例，每个实例都拥有一组从属者和额外的临时从属者。总共，它每天提供大约2000个构建。还要注意，他们的基础设施部分托管在AWS上，部分托管在他们自己的服务器上。
- en: We should already have at least a rough idea of what the Jenkins infrastructure
    can look like depending on the type of the organization.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该已经对Jenkins基础设施的外观有一个大致的想法，这取决于组织的类型。
- en: Let's now focus on the practical aspects of setting the agents.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们专注于设置代理的实际方面。
- en: Configuring agents
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置代理
- en: We've seen what the agents are and when they can be used. However, how to set
    up an agent and let it communicate with the master? Let's start with the second
    part of the question and describe the communication protocols between the master
    and the agent.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道代理是什么，以及何时可以使用。但是，如何设置代理并让其与主节点通信呢？让我们从问题的第二部分开始，描述主节点和代理之间的通信协议。
- en: Communication protocols
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信协议
- en: In order for the master and the agent to communicate, the bi-directional connection
    has to be established.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让主节点和代理进行通信，必须建立双向连接。
- en: 'There are different options how it can be initiated:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的选项可以启动它：
- en: '**SSH**: Master connects to slave using the standard SSH protocol. Jenkins
    has an SSH-client built-in, so the only requirement is the SSHD server configured
    on slaves. This is the most convenient and stable method because it uses standard
    Unix mechanisms.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSH**：主节点使用标准的SSH协议连接到从属者。Jenkins内置了SSH客户端，所以唯一的要求是从属者上配置了SSHD服务器。这是最方便和稳定的方法，因为它使用标准的Unix机制。'
- en: '**Java Web Start**: Java application is started on each agent machine and the
    TCP connection is established between the Jenkins slave application and the master
    Java application. This method is often used if the agents are inside the firewalled
    network and the master cannot initiate the connection.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java Web Start**：在每个代理机器上启动Java应用程序，并在Jenkins从属应用程序和主Java应用程序之间建立TCP连接。如果代理位于防火墙网络内，主节点无法启动连接，通常会使用这种方法。'
- en: '**Windows service**: The master registers an agent on the remote machine as
    a Windows service. This method is discouraged since the setup is tricky and there
    are limitations on the graphical interfaces usage.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows服务**：主节点在远程机器上注册代理作为Windows服务。这种方法不鼓励使用，因为设置很棘手，图形界面的使用也有限制。'
- en: If we know the communication protocols, let's see how we can use them to set
    the agents.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道通信协议，让我们看看如何使用它们来设置代理。
- en: Setting agents
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置代理
- en: 'At the low level, agents communicate with the Jenkins master always using one
    of the protocols described above. However, at the higher level, we can attach
    slaves to the master in various ways. The differences concern two aspects:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在低级别上，代理始终使用上面描述的协议与Jenkins主服务器通信。然而，在更高级别上，我们可以以各种方式将从节点附加到主服务器。差异涉及两个方面：
- en: '**static versus dynamic**: The simplest option is to add slaves permanently
    in the Jenkins master. The drawback of such solution is that we always need to
    manually change something if we need more (or less) slave nodes. A better option
    is to dynamically provision slaves as they are needed.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态与动态**：最简单的选项是在Jenkins主服务器中永久添加从节点。这种解决方案的缺点是，如果我们需要更多（或更少）的从节点，我们总是需要手动更改一些东西。更好的选择是根据需要动态提供从节点。'
- en: '**specific versus general-purpose**: Agents can be specific (for example, different
    agents for the projects based on Java 7 and different agents for Java 8) or general-purpose
    (an agent acts as a Docker host and a pipeline is built inside a Docker container).'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定与通用**：代理可以是特定的（例如，基于Java 7的项目有不同的代理，基于Java 8的项目有不同的代理），也可以是通用的（代理充当Docker主机，流水线在Docker容器内构建）。'
- en: 'These differences resulted in four common strategies how agents are configured:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些差异导致了四种常见的代理配置策略：
- en: Permanent agents
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永久代理
- en: Permanent Docker agents
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永久Docker代理
- en: Jenkins Swarm agents
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins Swarm代理
- en: Dynamically provisioned Docker agents
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态提供的Docker代理
- en: Let's examine each of the solutions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个检查每种解决方案。
- en: Permanent agents
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 永久代理
- en: We start from the simplest option which is to permanently add specific agent
    nodes. It can be done entirely via the Jenkins web interface.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从最简单的选项开始，即永久添加特定代理节点。可以完全通过Jenkins Web界面完成。
- en: Configuring permanent agents
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置永久代理
- en: 'In the Jenkins master, when we open Manage Jenkins and then Manage Nodes, we
    can view all the attached agents. Then, by clicking on New Node, giving it a name,
    and confirming with the OK button, we should finally see the agent''s setup page:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jenkins主服务器上，当我们打开“管理Jenkins”，然后点击“管理节点”，我们可以查看所有已附加的代理。然后，通过点击“新建节点”，给它一个名称，并点击“确定”按钮，最终我们应该看到代理的设置页面：
- en: '![](assets/8cc335f3-a054-4fe9-851d-a08de74aa7cc.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8cc335f3-a054-4fe9-851d-a08de74aa7cc.png)'
- en: 'Let''s walk through the parameters we need to fill:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们需要填写的参数：
- en: '**Name**: This is the unique name of the agent'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：这是代理的唯一名称'
- en: '**Description**: This is any human-readable description of the agent'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：这是代理的任何可读描述'
- en: '**# of executors**: This is the number of concurrent builds that can be run
    on the slave'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行器数量**：这是从节点上可以并行运行的构建数量'
- en: '**Remote root directory**: This is the dedicated directory on the slave machine
    that the agent can use to run build jobs (for example, `/var/jenkins`); the most
    important data is transferred back to the master, so the directory is not critical'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程根目录**：这是从节点上的专用目录，代理可以用它来运行构建作业（例如，`/var/jenkins`）；最重要的数据被传输回主服务器，因此目录并不重要'
- en: '**Labels**: This includes the tags to match only the specific builds (tagged
    the same), for example, only projects based on Java 8'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**：这包括匹配特定构建的标签（相同标记），例如，仅基于Java 8的项目'
- en: '**Usage**: This is the option to decide whether the agent should be used only
    for matched labels (for example, only for Acceptance Testing builds) or for any
    builds'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用法**：这是决定代理是否仅用于匹配标签（例如，仅用于验收测试构建）还是用于任何构建的选项'
- en: '**Launch method**: This includes the following:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动方法**：这包括以下内容：'
- en: '**Launch agent via Java Web Star**t: Here, the connection will be established
    by the agent; it is possible to download the JAR file and the instructions on
    how to run it on the slave machine'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过Java Web Start启动从属**：在这里，代理将建立连接；可以下载JAR文件以及在从属机器上运行它的说明'
- en: '**Launch agent via execution of command on the master**: This is the custom
    command run on the master to start the slave; in most cases it will send the Java
    Web Start JAR application and start it on the slave (for example, `ssh <slave_hostname>
    java -jar ~/bin/slave.jar`)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过在主节点上执行命令启动从属**：这是在主节点上运行的自定义命令，大多数情况下它会发送Java Web Start JAR应用程序并在从属上启动它（例如，`ssh
    <slave_hostname> java -jar ~/bin/slave.jar`）'
- en: '**Launch slave agents via SSH:** Here, the master will connect to the slave
    using the SSH protocol'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过SSH启动从属代理**：在这里，主节点将使用SSH协议连接到从属'
- en: '**Let Jenkins control this Windows slave as a Windows service**: Here, the
    master will start a remote management facility built into Windows'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**让Jenkins将此Windows从属作为Windows服务进行控制**：在这里，主节点将启动内置于Windows中的远程管理设施'
- en: '**Availability**: This is the option to decide whether the agent should be
    up all the time or the master should turn it offline under certain conditions'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：这是决定代理是否应该一直在线或者在某些条件下主节点应该将其离线的选项'
- en: When the agents are set up correctly, it's possible to switch the master node
    offline, so that no builds would be executed on it and it would serve only as
    the Jenkins UI and the builds' coordinator.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当代理正确设置后，可以将主节点离线，这样就不会在其上执行任何构建，它只会作为Jenkins UI和构建协调器。
- en: Understanding permanent agents
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解永久从属
- en: 'As already mentioned, the drawback of such a solution is that we need to maintain
    multiple slave types (labels) for different project types. Such a situation is
    presented in the following diagram:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，这种解决方案的缺点是我们需要为不同的项目类型维护多个从属类型（标签）。这种情况如下图所示：
- en: '![](assets/43523171-6bcf-41c4-bed4-3658b0e1437c.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/43523171-6bcf-41c4-bed4-3658b0e1437c.png)'
- en: In our example, if we have three types of projects (**java7**, **java8**, and
    **ruby**), then we need to maintain three separately labeled (sets of) slaves.
    That is the same issue we had while maintaining multiple production server types,
    as described in [Chapter 2](aa58c16d-41c0-4364-9eae-26b60a05c510.xhtml), *Introducing
    Docker*. We addressed the issue by having the Docker Engine installed on the production
    servers. Let's try to do the same with Jenkins slaves.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，如果我们有三种类型的项目（**java7**，**java8**和**ruby**），那么我们需要维护三个分别带有标签的（集合）从属。这与我们在维护多个生产服务器类型时遇到的问题相同，如[第2章](aa58c16d-41c0-4364-9eae-26b60a05c510.xhtml)
    *引入Docker*中所述。我们通过在生产服务器上安装Docker Engine来解决了这个问题。让我们尝试在Jenkins从属上做同样的事情。
- en: Permanent Docker agents
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 永久Docker从属
- en: The idea behind this solution is to permanently add general-purpose slaves.
    Each slave is identically configured (Docker Engine installed) and each build
    is defined together with the Docker image inside which the build is run.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案的理念是永久添加通用从属。每个从属都配置相同（安装了Docker Engine），并且每个构建与Docker镜像一起定义，构建在其中运行。
- en: Configuring permanent Docker agents
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置永久Docker从属
- en: The configuration is static, so it's done exactly the same way as we did for
    the permanent agents. The only difference is that we need to install Docker on
    each machine that will be used as a slave. Then, we usually don't need labels
    because all slaves can be the same. After the slaves are configured, we define
    the Docker image in each pipeline script.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 配置是静态的，所以它的完成方式与我们为永久从属所做的完全相同。唯一的区别是我们需要在每台将用作从属的机器上安装Docker。然后，通常我们不需要标签，因为所有从属都可以是相同的。在从属配置完成后，我们在每个流水线脚本中定义Docker镜像。
- en: '[PRE7]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the build is started, the Jenkins slave starts a container from the Docker
    image `openjdk:8-jdk-alpine` and then executes all pipeline steps inside that
    container. This way, we always know the execution environment and don't have to
    configure each slave separately depending on the particular project type.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建开始时，Jenkins从服务器会从Docker镜像`openjdk:8-jdk-alpine`启动一个容器，然后在该容器内执行所有流水线步骤。这样，我们始终知道执行环境，并且不必根据特定项目类型单独配置每个从服务器。
- en: Understanding permanent Docker agents
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解永久Docker代理
- en: 'Looking at the same scenario we took for the permanent agents, the diagram
    looks like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 看着我们为永久代理所采取的相同场景，图表如下：
- en: '![](assets/243f8a95-9de6-4851-bc72-5ec31765a752.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/243f8a95-9de6-4851-bc72-5ec31765a752.png)'
- en: Each slave is exactly the same and if we would like to build a project that
    depends on Java 8, then we define the appropriate Docker image in the pipeline
    script (instead of specifying the slave label).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 每个从服务器都是完全相同的，如果我们想构建一个依赖于Java 8的项目，那么我们在流水线脚本中定义适当的Docker镜像（而不是指定从服务器标签）。
- en: Jenkins Swarm agents
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins Swarm代理
- en: So far, we always had to permanently define each of the agents in the Jenkins
    master. Such a solution, even though good enough in many cases, can be a burden
    if we need to frequently scale the number of slave machines. Jenkins Swarm allows
    you to dynamically add slaves without the need to configure them in the Jenkins
    master.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们总是不得不在Jenkins主服务器中永久定义每个代理。这样的解决方案，即使在许多情况下都足够好，如果我们需要频繁扩展从服务器的数量，可能会成为负担。Jenkins
    Swarm允许您动态添加从服务器，而无需在Jenkins主服务器中对其进行配置。
- en: Configuring Jenkins Swarm agents
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Jenkins Swarm代理
- en: The first step to use Jenkins Swarm is to install the **Self-Organizing Swarm
    Plug-in Modules** plugin in Jenkins. We can do it via the Jenkins web UI under
    Manage Jenkins and Manage Plugins. After this step, the Jenkins master is prepared
    for Jenkins slaves to be dynamically attached.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jenkins Swarm的第一步是在Jenkins中安装**自组织Swarm插件模块**插件。我们可以通过Jenkins Web UI在“管理Jenkins”和“管理插件”下进行。完成此步骤后，Jenkins主服务器准备好动态附加Jenkins从服务器。
- en: The second step is to run the Jenkins Swarm slave application on every machine
    that would act as a Jenkins slave. We can do it using the `swarm-client.jar` application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是在每台将充当Jenkins从服务器的机器上运行Jenkins Swarm从服务器应用程序。我们可以使用`swarm-client.jar`应用程序来完成。
- en: 'The `swarm-client.jar` application can be downloaded from the Jenkins Swarm
    plugin page: [https://wiki.jenkins-ci.org/display/JENKINS/Swarm+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Swarm+Plugin).
    On that page, you can also find all the possible options of its execution.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`swarm-client.jar`应用程序可以从Jenkins Swarm插件页面下载：[https://wiki.jenkins-ci.org/display/JENKINS/Swarm+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Swarm+Plugin)。在该页面上，您还可以找到其执行的所有可能选项。'
- en: 'In order to attach the Jenkins Swarm slave node, it''s enough to run the following
    command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要附加Jenkins Swarm从节点，只需运行以下命令：
- en: '[PRE8]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By the time of writing this book, there was an open bug that `client-slave.jar`
    didn't work via the secured HTTPS protocol, so it was necessary to add the `-disableSslVerification` option
    to the command execution.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，存在一个`client-slave.jar`无法通过安全的HTTPS协议工作的未解决错误，因此需要在命令执行中添加`-disableSslVerification`选项。
- en: 'After the successful execution, we should notice that a new slave appeared
    on the Jenkins master as presented on the screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 成功执行后，我们应该注意到Jenkins主服务器上出现了一个新的从服务器，如屏幕截图所示：
- en: '![](assets/644e56d6-3e6e-4509-878c-b9fed436136b.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/644e56d6-3e6e-4509-878c-b9fed436136b.png)'
- en: Now, when we run a build, it will be started on this agent.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行构建时，它将在此代理上启动。
- en: The other possibility to add the Jenkins Swarm agent is to use the Docker image
    built from the `swarm-client.jar` tool. There are a few of them available on the
    Docker Hub. We can use the `csanchez/jenkins-swarm-slave` image.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 添加Jenkins Swarm代理的另一种可能性是使用从`swarm-client.jar`工具构建的Docker镜像。Docker Hub上有一些可用的镜像。我们可以使用`csanchez/jenkins-swarm-slave`镜像。
- en: Understanding Jenkins Swarm agents
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Jenkins Swarm代理
- en: Jenkins Swarm allows to dynamically add agents, but it says nothing about whether
    to use specific or Docker-based slaves, so we can use it for both. At first glance,
    Jenkins Swarm may not seem very useful. After all, we moved setting agents from
    master to slave, but still have to do it manually. However, as we will see later
    in [Chapter 8](05fbbfd9-ff58-4ee8-be5d-90cb291f6320.xhtml), *Clustering with Docker
    Swarm*, Jenkins Swarm enables dynamic scaling of slaves on a cluster of servers.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins Swarm允许动态添加代理，但它没有说明是否使用特定的或基于Docker的从属，所以我们可以同时使用它。乍一看，Jenkins Swarm可能看起来并不是很有用。毕竟，我们将代理设置从主服务器移到了从属，但仍然需要手动完成。然而，正如我们将在[第8章](05fbbfd9-ff58-4ee8-be5d-90cb291f6320.xhtml)中看到的那样，*使用Docker
    Swarm进行集群*，Jenkins Swarm可以在服务器集群上动态扩展从属。
- en: Dynamically provisioned Docker agents
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态配置的Docker代理
- en: Another option is to set up Jenkins to dynamically create a new agent each time
    a build is started. Such a solution is obviously the most flexible one since the
    number of slaves dynamically adjust to the number of builds. Let's have a look
    at how to configure Jenkins this way.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是设置Jenkins在每次启动构建时动态创建一个新的代理。这种解决方案显然是最灵活的，因为从属的数量会动态调整到构建的数量。让我们看看如何以这种方式配置Jenkins。
- en: Configuring dynamically provisioned Docker agents
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置动态配置的Docker代理
- en: 'We need to first install the Docker plugin. As always with Jenkins plugins,
    we can do in Manage Jenkins and Manage Plugins. After the plugin is installed,
    we can start the following configuration steps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先安装Docker插件。与Jenkins插件一样，我们可以在“管理Jenkins”和“管理插件”中进行。安装插件后，我们可以开始以下配置步骤：
- en: Open the Manage Jenkins page.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“管理Jenkins”页面。
- en: Click on the Configure System link.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“配置系统”链接。
- en: At the bottom of the page, there is the Cloud section.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面底部，有云部分。
- en: Click on Add a new cloud and choose Docker.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“添加新的云”并选择Docker。
- en: Fill the Docker agent details.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写Docker代理的详细信息。
- en: '![](assets/98d44429-9c8f-451e-9744-68fe5b895396.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/98d44429-9c8f-451e-9744-68fe5b895396.png)'
- en: 'Most parameters do not need to be changed; however, we need to set two of them
    as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数参数不需要更改；但是，我们需要设置其中两个如下：
- en: '**Docker URL**: The address of the Docker host machine where agents will be
    run'
  id: totrans-196
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker URL**：代理将在其中运行的Docker主机机器的地址'
- en: '**Credentials**: The credentials in case the Docker host requires authentication'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**凭据**：如果Docker主机需要身份验证的凭据'
- en: If you plan to use the same Docker host where the master is running, then the
    Docker daemon needs to listen on the `docker0` network interface. You can do it
    in a similar way as described in the *Installing on a server* section ofts of)
    slaves. That is the same issue we had while maintaining multiple production server
    types, as described in [Chapter 2](aa58c16d-41c0-4364-9eae-26b60a05c510.xhtml), *Introducing
    Docker*, by changing one line in the `/lib/systemd/system/docker.service` file
    to `ExecStart=/usr/bin/dockerd -H 0.0.0.0:2375 -H fd://`
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划在运行主服务器的相同Docker主机上使用它，则Docker守护程序需要在`docker0`网络接口上进行监听。您可以以与*在服务器上安装*部分中描述的类似方式进行操作。这与我们在维护多个生产服务器类型时遇到的问题相同，如[第2章](aa58c16d-41c0-4364-9eae-26b60a05c510.xhtml)中所述，*介绍Docker*，通过更改`/lib/systemd/system/docker.service`文件中的一行为`ExecStart=/usr/bin/dockerd
    -H 0.0.0.0:2375 -H fd://`
- en: Click on Add Docker Template and select Docker Template.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“添加Docker模板”并选择Docker模板。
- en: 'Fill the details about the Docker slave image:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写有关Docker从属镜像的详细信息：
- en: '![](assets/f56c7001-d4c7-466c-b687-ad946d915267.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f56c7001-d4c7-466c-b687-ad946d915267.png)'
- en: 'We can use the following parameters:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下参数：
- en: '**Docker Image**: The most popular slave image from the Jenkins community is
    `evarga/jenkins-slave`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker镜像**：Jenkins社区中最受欢迎的从属镜像是`evarga/jenkins-slave`'
- en: '**Credentials**: The credentials to the `evarga/jenkins-slave` image are:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**凭据**：对`evarga/jenkins-slave`镜像的凭据是：'
- en: 'username: `jenkins`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名：`jenkins`
- en: 'password: `jenkins`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码：`jenkins`
- en: '**Instance capacity**: This defines the maximum number of agents running at
    the same time; for the beginning, it can be set to 10'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例容量**：这定义了同时运行的代理的最大数量；初始设置可以为10'
- en: Instead of `evarga/jenkins-slave`, it's possible to build and use your own slave
    images. This is necessary when there are specific environment requirements, for
    example, the Python interpreter installed. In all examples for this book we used `leszko/jenkins-docker-slave`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`evarga/jenkins-slave`之外，也可以构建和使用自己的从属镜像。当存在特定的环境要求时，例如安装了Python解释器时，这是必要的。在本书的所有示例中，我们使用了`leszko/jenkins-docker-slave`。
- en: After saving, everything is set up. We could run the pipeline to observe that
    the execution really takes place on the Docker agent, but first let's dig a little
    deeper to understand how the Docker agents work.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 保存后，一切都设置好了。我们可以运行流水线来观察执行是否真的在Docker代理上进行，但首先让我们深入了解一下Docker代理的工作原理。
- en: Understanding dynamically provisioned Docker agents
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解动态提供的Docker代理
- en: Dynamically provisioned Docker agents can be treated as a layer over the standard
    agent mechanism. It changes neither the communication protocol nor how the agent
    is created. So, what does Jenkins do with the Docker agent configuration we provided?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 动态提供的Docker代理可以被视为标准代理机制的一层。它既不改变通信协议，也不改变代理的创建方式。那么，Jenkins会如何处理我们提供的Docker代理配置呢？
- en: 'The following diagram presents the Docker master-slave architecture we''ve
    configured:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了我们配置的Docker主从架构：
- en: '![](assets/cba2207e-e746-428b-950c-da8e766e7886.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cba2207e-e746-428b-950c-da8e766e7886.png)'
- en: 'Let''s describe step by step how the Docker agent mechanism is used:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步描述Docker代理机制的使用方式：
- en: When the Jenkins job is started, the master runs a new container from the `jenkins-slave`
    image on the slave Docker host.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Jenkins作业启动时，主机会在从属Docker主机上从`jenkins-slave`镜像运行一个新的容器。
- en: The jenkins-slave container is, actually, the ubuntu image with the SSHD server
    installed.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: jenkins-slave容器实际上是安装了SSHD服务器的ubuntu镜像。
- en: The Jenkins master automatically adds the created agent to the agent list (same
    as what we did manually in the *Setting agents* section).
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins主机会自动将创建的代理添加到代理列表中（与我们在*设置代理*部分手动操作的方式相同）。
- en: The agent is accessed using the SSH communication protocol to perform the build.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理是通过SSH通信协议访问以执行构建的。
- en: After the build, the master stops and removes the slave container.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建完成后，主机会停止并移除从属容器。
- en: Running Jenkins master as a Docker container is independent from running Jenkins
    agents as Docker containers. It's reasonable to do both, but any of them will
    work separately.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 将Jenkins主机作为Docker容器运行与将Jenkins代理作为Docker容器运行是独立的。两者都是合理的选择，但它们中的任何一个都可以单独工作。
- en: 'The solution is somehow similar to the permanent Docker agents solution, because
    in result, we run the build inside a Docker container. The difference is, however,
    in the slave node configuration. Here, the whole slave is dockerized, not only
    the build environment. Therefore, it has two great advantages as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案在某种程度上类似于永久的Docker代理解决方案，因为最终我们是在Docker容器内运行构建。然而，不同之处在于从属节点的配置。在这里，整个从属都是docker化的，不仅仅是构建环境。因此，它具有以下两个巨大的优势：
- en: '**Automatic agent lifecycle**: The process of creating, adding, and removing
    the agent is automated.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动代理生命周期：创建、添加和移除代理的过程是自动化的。
- en: '**Scalability**: Actually, the slave Docker host could be not a single machine,
    but a cluster composed of multiple machines (we''ll cover clustering using Docker
    Swarm in [Chapter 8](05fbbfd9-ff58-4ee8-be5d-90cb291f6320.xhtml), *Clustering
    with Docker Swarm*). In that case, adding more resources is as simple as adding
    a new machine to the cluster and does not require any changes in Jenkins.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性：实际上，从容器主机可能不是单个机器，而是由多台机器组成的集群（我们将在[第8章](05fbbfd9-ff58-4ee8-be5d-90cb291f6320.xhtml)中介绍使用Docker
    Swarm进行集群化，*使用Docker Swarm进行集群化*）。在这种情况下，添加更多资源就像添加新机器到集群一样简单，并且不需要对Jenkins进行任何更改。
- en: Jenkins build usually needs to download a lot of project dependencies (for example,
    Gradle/Maven dependencies), which may take a lot of time. If Docker slaves are
    automatically provisioned for each build, then it may be worth to set up a Docker
    volume for them to enable caching between the builds.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins构建通常需要下载大量项目依赖项（例如Gradle/Maven依赖项），这可能需要很长时间。如果Docker代理自动为每个构建进行配置，那么值得为它们设置一个Docker卷，以便在构建之间启用缓存。
- en: Testing agents
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代理
- en: No matter which agent configuration you chose, we should now check if it works
    correctly.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 无论选择了哪种代理配置，现在我们应该检查它是否正常工作。
- en: 'Let''s go back to the hello world pipeline. Usually, the builds last longer
    than the hello-world example, so we can simulate it by adding sleeping to the
    pipeline script:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到hello world流水线。通常，构建的持续时间比hello-world示例长，所以我们可以通过在流水线脚本中添加睡眠来模拟它：
- en: '[PRE9]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After clicking on Build Now and going to the Jenkins main page, we should see
    that the build is executed on an agent. Now, if we click on build many times,
    then different agents should be executing different builds (as shown in the following
    screenshot):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“立即构建”并转到Jenkins主页后，我们应该看到构建是在代理上执行的。现在，如果我们多次点击构建，不同的代理应该执行不同的构建（如下截图所示）：
- en: '![](assets/b1e20218-bee3-4352-a90f-5e613c98d421.png)To prevent job executions
    on master, remember about turning the master node offline or setting **# of executors** to
    `0` in the Manage Nodes configuration.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止作业在主节点上执行，记得将主节点设置为离线或在节点管理配置中将**执行器数量**设置为`0`。
- en: Having seen that the agents are executing our builds, we've confirmed that they
    are configured correctly. Now, let's see how and for what reason we could create
    our own Jenkins images.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察代理执行我们的构建，我们确认它们已经正确配置。现在，让我们看看为什么以及如何创建我们自己的Jenkins镜像。
- en: Custom Jenkins images
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义Jenkins镜像
- en: So far, we have used the Jenkins images pulled from the internet. We used `jenkins`
    for the master container and `evarga/jenkins-slave` for the slave container. However,
    we may want to build our own images to satisfy the specific build environment
    requirements. In this section, we cover how to do it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了从互联网上拉取的Jenkins镜像。我们使用`jenkins`作为主容器，`evarga/jenkins-slave`作为从容器。然而，我们可能希望构建自己的镜像以满足特定的构建环境要求。在本节中，我们将介绍如何做到这一点。
- en: Building Jenkins slave
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Jenkins从容器
- en: Let's start from the slave image, because it's more often customized. The build
    execution is performed on the agent, so it's the agent that needs to have the
    environment adjusted to the project we would like to build. For example, it may
    require the Python interpreter if our project is written in Python. The same is
    applied to any library, tool, testing framework, or anything that is needed by
    the project.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从从容器镜像开始，因为它经常被定制。构建执行是在代理上执行的，因此需要调整代理的环境以适应我们想要构建的项目。例如，如果我们的项目是用Python编写的，可能需要Python解释器。同样的情况也适用于任何库、工具、测试框架或项目所需的任何内容。
- en: You can check what is already installed inside the `evarga/jenkins-slave` image
    by looking at its Dockerfile at [https://github.com/evarga/docker-images](https://github.com/evarga/docker-images).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看其Dockerfile来查看`evarga/jenkins-slave`镜像中已安装的内容[https://github.com/evarga/docker-images](https://github.com/evarga/docker-images)。
- en: 'There are three steps to build and use the custom image:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和使用自定义镜像有三个步骤：
- en: Create a Dockerfile.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Dockerfile。
- en: Build the image.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建镜像。
- en: Change the agent configuration on master.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改主节点上的代理配置。
- en: 'As an example, let''s create a slave that serves the Python project. We can
    build it on top of the `evarga/jenkins-slave` image for the sake of simplicity.
    Let''s do it using the following three steps:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，让我们创建一个为Python项目提供服务的从节点。为了简单起见，我们可以基于`evarga/jenkins-slave`镜像构建它。让我们按照以下三个步骤来做：
- en: '**Dockerfile**:Let''s create a new directory inside the Dockerfile with the
    following content:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Dockerfile**：让我们在Dockerfile中创建一个新目录，内容如下：'
- en: '[PRE10]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The base Docker image `evarga/jenkins-slave` is suitable for the dynamically
    provisioned Docker agents solution. In case of permanent Docker agents, it's enough
    to use `alpine`, `ubuntu`, or any other image, since it's not the slave that is
    dockerized, but only the build execution environment.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 基础Docker镜像`evarga/jenkins-slave`适用于动态配置的Docker代理解决方案。对于永久性Docker代理，只需使用`alpine`、`ubuntu`或任何其他镜像即可，因为docker化的不是从节点，而只是构建执行环境。
- en: '**Build the image**: We can build the image by executing the following command:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建镜像**：我们可以通过执行以下命令来构建镜像：'
- en: '[PRE11]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Configure the master**: The last step, of course, is to set `jenkins-slave-python`
    instead of `evarga/jenkins-slave` in the Jenkins master''s configuration (as described
    in the *Setting Docker agent* section).'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置主节点**：当然，最后一步是在Jenkins主节点的配置中设置`jenkins-slave-python`，而不是`evarga/jenkins-slave`（如*设置Docker代理*部分所述）。'
- en: The slave Dockerfile should be kept in the source code repository and the image
    build can be performed automatically by Jenkins. There is nothing wrong with building
    the new Jenkins slave image using the old Jenkins slave.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 从节点的Dockerfile应该保存在源代码仓库中，并且可以由Jenkins自动执行构建。使用旧的Jenkins从节点构建新的Jenkins从节点镜像没有问题。
- en: 'What if we need Jenkins to build two different kinds of projects, for example,
    one based on Python and another based on Ruby? In that case, we could prepare
    an agent, which is generic enough to support both: Python and Ruby. However, in
    case of Docker, it''s recommended to create the second slave image (`jenkins-slave-ruby`
    by analogy). Then, in the Jenkins configuration we need to create two Docker templates
    and label them accordingly.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要Jenkins构建两种不同类型的项目，例如一个基于Python，另一个基于Ruby，该怎么办？在这种情况下，我们可以准备一个足够通用以支持Python和Ruby的代理。然而，在Docker的情况下，建议创建第二个从节点镜像（通过类比创建`jenkins-slave-ruby`）。然后，在Jenkins配置中，我们需要创建两个Docker模板并相应地标记它们。
- en: Building Jenkins master
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Jenkins主节点
- en: We already have a custom slave image. Why would we also want to build our own
    master image? One of the reasons might be that we don't want to use slaves at
    all, and, since the execution would be done on master, its environment has to
    be adjusted to the project's needs. That is, however, a very rare case. More often,
    we will want to configure the master itself.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个自定义的从节点镜像。为什么我们还想要构建自己的主节点镜像呢？其中一个原因可能是我们根本不想使用从节点，而且由于执行将在主节点上进行，它的环境必须根据项目的需求进行调整。然而，这是非常罕见的情况。更常见的情况是，我们会想要配置主节点本身。
- en: 'Imagine the following scenario, your organization scales Jenkins horizontally
    and each team has its own instance. There is, however, some common configuration,
    for example: a set of base plugins, backup strategies, or the company logo. Then,
    repeating the same configuration for each of the teams is a waste of time. So,
    we can prepare the shared master image and let the teams use it.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下以下情景，您的组织将Jenkins水平扩展，每个团队都有自己的实例。然而，有一些共同的配置，例如：一组基本插件，备份策略或公司标志。然后，为每个团队重复相同的配置是一种浪费时间。因此，我们可以准备共享的主镜像，并让团队使用它。
- en: Jenkins is configured using XML files and it provides the Groovy-based DSL language
    to manipulate over them. That is why we can add the Groovy script to the Dockerfile
    in order to manipulate the Jenkins configuration. What is more, there are special
    scripts to help with the Jenkins configuration if it requires something more than
    XML changes, for instance, plugin installation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins使用XML文件进行配置，并提供基于Groovy的DSL语言来对其进行操作。这就是为什么我们可以将Groovy脚本添加到Dockerfile中，以操纵Jenkins配置。而且，如果需要比XML更多的更改，例如插件安装，还有特殊的脚本来帮助Jenkins配置。
- en: All possibilities of the Dockerfile instructions are well described on the GitHub
    page [https://github.com/jenkinsci/docker](https://github.com/jenkinsci/docker).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile指令的所有可能性都在GitHub页面[https://github.com/jenkinsci/docker](https://github.com/jenkinsci/docker)上有详细描述。
- en: 'As an example, let''s create a master image with the docker-plugin already
    installed and a number of executors set to 5\. In order to do it, we need to:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个已经安装了docker-plugin并将执行者数量设置为5的主镜像。为了做到这一点，我们需要：
- en: Create the Groovy script to manipulate on `config.xml` and set the number of
    executors to `5`.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Groovy脚本以操纵`config.xml`并将执行者数量设置为`5`。
- en: Create the Dockerfile to install docker-plugin and execute the Groovy script.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Dockerfile以安装docker-plugin并执行Groovy脚本。
- en: Build the image.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建图像。
- en: Let's use the three steps mentioned and build the Jenkins master image.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用提到的三个步骤构建Jenkins主镜像。
- en: '** Groovy script**: Let''s create a new directory inside the `executors.groovy` file
    with the following content:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Groovy脚本**：让我们在`executors.groovy`文件内创建一个新目录，内容如下：'
- en: '[PRE12]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The complete Jenkins API can be found on the official page [http://javadoc.jenkins.io/](http://javadoc.jenkins.io/).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的Jenkins API可以在官方页面[http://javadoc.jenkins.io/](http://javadoc.jenkins.io/)上找到。
- en: '** Dockerfile**: In the same directory, let''s create the Dockerfile:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Dockerfile**：在同一目录下，让我们创建Dockerfile：'
- en: '[PRE13]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '** Build the image**: We can finally build the image:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建图像**：我们最终可以构建图像：'
- en: '[PRE14]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After the image is created, each team in the organization can use it to launch
    their own Jenkins instance.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图像后，组织中的每个团队都可以使用它来启动自己的Jenkins实例。
- en: Having our own master and slave images lets us provide the configuration and
    the build environment for the teams in our organization. In the next section,
    we'll see what else is worth being configured in Jenkins.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有自己的主从镜像可以为我们组织中的团队提供配置和构建环境。在接下来的部分，我们将看到Jenkins中还有哪些值得配置。
- en: Configuration and management
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置和管理
- en: 'We have already covered the most crucial part of the Jenkins configuration:
    agents provisioning. Since Jenkins is highly configurable, you can expect much
    more possibilities to adjust it to your needs. The good news is that the configuration
    is intuitive and accessible via the web interface, so it does not require any
    detailed description. Everything can be changed under the Manage Jenkins subpage.
    In this section, we will focus only on a few aspects that are most likely to be
    changed: plugins, security, and backup.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了Jenkins配置的最关键部分：代理配置。由于Jenkins具有高度可配置性，您可以期望有更多的可能性来调整它以满足您的需求。好消息是配置是直观的，并且可以通过Web界面访问，因此不需要任何详细的描述。所有内容都可以在“管理Jenkins”子页面下更改。在本节中，我们只会关注最有可能被更改的一些方面：插件、安全和备份。
- en: Plugins
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件
- en: Jenkins is highly plugin-oriented, which means that a lot of features are delivered
    by the use of plugins. They can extend Jenkins almost in the unlimited way, which,
    taking into consideration the large community, is one of the reasons why Jenkins
    is such a successful tool. With Jenkins' openness, comes the risk and it's better
    to download plugins only from the reliable source or check their source code.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins是高度面向插件的，这意味着许多功能都是通过插件提供的。它们可以以几乎无限的方式扩展Jenkins，考虑到庞大的社区，这是Jenkins如此成功的原因之一。Jenkins的开放性带来了风险，最好只从可靠的来源下载插件或检查它们的源代码。
- en: There are literally tons of plugins to choose from. Some of them were already
    installed automatically during the initial configuration. Another one (Docker
    plugin) was installed while setting the Docker agents. There are plugins for cloud
    integration, source control tools, code coverage, and much more. You can also
    write your own plugin, but it's better to check first if the one you need is not
    already written.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 选择插件的数量实际上有很多。其中一些在初始配置过程中已经自动安装了。另一个（Docker插件）是在设置Docker代理时安装的。有用于云集成、源代码控制工具、代码覆盖等的插件。你也可以编写自己的插件，但最好先检查一下你需要的插件是否已经存在。
- en: There is an official Jenkins page to browse plugins from [https://plugins.jenkins.io/](https://plugins.jenkins.io/).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个官方的Jenkins页面可以浏览插件[https://plugins.jenkins.io/](https://plugins.jenkins.io/)。
- en: Security
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全
- en: The way you should approach the Jenkins security depends on the Jenkins architecture
    you have chosen within your organization. If you have a Jenkins master for every
    small team, then you may not need it at all (under the assumption that the corporate
    network is firewalled). However, if you have a single Jenkins master instance
    for the whole organization, then you'd better be sure you secured it well.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该如何处理Jenkins安全取决于您在组织中选择的Jenkins架构。如果您为每个小团队都有一个Jenkins主服务器，那么您可能根本不需要它（假设企业网络已设置防火墙）。然而，如果您为整个组织只有一个Jenkins主服务器实例，那么最好确保您已经很好地保护了它。
- en: Jenkins comes with its own user database-we have already created a user during
    the initial configuration process. You can create, delete, and modify users by
    opening the Manage Users setting page. The built-in database can be a solution
    in case of small organizations; however, for the large group of users, you will
    probably want to use LDAP instead. You can choose it on the Configure Global Security page.
    There, you can also assign roles, groups, and users. By default, the Logged-in
    users can do anything option is set, but in a large-scale organization you should
    probably think of more detailed granularity.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins自带自己的用户数据库-我们在初始配置过程中已经创建了一个用户。您可以通过打开“管理用户”设置页面来创建、删除和修改用户。内置数据库可以在小型组织的情况下使用；然而，对于大量用户，您可能希望使用LDAP。您可以在“配置全局安全”页面上选择它。在那里，您还可以分配角色、组和用户。默认情况下，“已登录用户可以做任何事情”选项被设置，但在大规模组织中，您可能需要考虑更详细的细粒度。
- en: Backup
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备份
- en: 'As the old saying goes: <q>There are two types of people: those who backup,
    and those who will backup</q>. Believe it or not, the backup is something you
    probably want to configure. What files to back up and from which machines? Luckily,
    agents automatically send all the relevant data back to the master, so we don''t
    need to bother about them. If you run Jenkins in the container, then the container
    itself is also not interesting, since it does not hold any persistent state. The
    only place we are interested in is the Jenkins home directory.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 俗话说：“有两种人：那些备份的人，和那些将要备份的人”。信不信由你，备份可能是你想要配置的东西。要备份哪些文件，从哪些机器备份？幸运的是，代理自动将所有相关数据发送回主服务器，所以我们不需要担心它们。如果你在容器中运行Jenkins，那么容器本身也不重要，因为它不保存任何持久状态。我们唯一感兴趣的地方是Jenkins主目录。
- en: 'We can either install a Jenkins plugin (which will help us to set periodic
    backups) or simply set a cron job to archive the directory into a safe place.
    To reduce the size, we can exclude the subfolders which are not interesting (that
    will depend on your needs; however, almost certainly, you don''t need to copy:
    "war", "cache", "tools", and "workspace").'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安装一个Jenkins插件（帮助我们设置定期备份），或者简单地设置一个cron作业将目录存档到一个安全的地方。为了减小大小，我们可以排除那些不感兴趣的子文件夹（这将取决于你的需求；然而，几乎可以肯定的是，你不需要复制："war"，"cache"，"tools"和"workspace"）。
- en: There are quite a few plugins, which can help with the backup process; the most
    common one is called **Backup Plugin**.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多插件可以帮助备份过程；最常见的一个叫做**备份插件**。
- en: Blue Ocean UI
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝色海洋UI
- en: The first version of Hudson (former Jenkins) was released in 2005\. It's been
    on the market for more than 10 years now. However, its look and feel hasn't changed
    much. We've already used it for a while and it's hard to deny that it looks outdated.
    Blue Ocean is the plugin, which redefines the user experience of Jenkins. If Jenkins
    is aesthetically displeasing to you, then it's definitely worth giving a try.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Hudson（Jenkins的前身）的第一个版本于2005年发布。它已经在市场上超过10年了。然而，它的外观和感觉并没有改变太多。我们已经使用它一段时间了，很难否认它看起来过时。Blue
    Ocean是一个重新定义了Jenkins用户体验的插件。如果Jenkins在美学上让你不满意，那么值得一试。
- en: You can read more on the Blue Ocean page at [https://jenkins.io/projects/blueocean/](https://jenkins.io/projects/blueocean/).![](assets/8bc21c85-2ef8-4974-8bdf-24d022228c4f.png)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://jenkins.io/projects/blueocean/](https://jenkins.io/projects/blueocean/)的蓝色海洋页面上阅读更多信息！[](assets/8bc21c85-2ef8-4974-8bdf-24d022228c4f.png)
- en: Exercises
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: We have learned a lot about Jenkins configuration throughout this chapter. To
    consolidate the knowledge, we recommend two exercises on preparing the Jenkins
    images and testing the Jenkins environment.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了很多关于Jenkins配置的知识。为了巩固这些知识，我们建议进行两个练习，准备Jenkins镜像并测试Jenkins环境。
- en: 'Create Jenkins master and slave Docker images and use them to run the Jenkins
    infrastructure capable of building the Ruby projects:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Jenkins主和从属Docker镜像，并使用它们来运行能够构建Ruby项目的Jenkins基础设施：
- en: Create the master Dockerfile, which automatically installs the Docker plugin.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建主Dockerfile，自动安装Docker插件。
- en: Build the master image and run the Jenkins instance
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建主镜像并运行Jenkins实例
- en: Create the slave Dockerfile (suitable for the dynamic slave provisioning), which
    installs the Ruby interpreter
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建从属Dockerfile（适用于动态从属供应），安装Ruby解释器
- en: Build the slave image
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建从属镜像
- en: Change the configuration in the Jenkins instance to use the slave image
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Jenkins实例中更改配置以使用从属镜像
- en: 'Create a pipeline, which runs a Ruby script printing `Hello World from Ruby`:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个流水线，运行一个打印`Hello World from Ruby`的Ruby脚本：
- en: Create a new pipeline
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的流水线
- en: 'Use the following shell command to create the `hello.rb` script on the fly:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下shell命令即时创建`hello.rb`脚本：
- en: '`sh "echo "puts ''Hello World from Ruby''" > hello.rb"`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`sh "echo "puts ''Hello World from Ruby''" > hello.rb"`'
- en: Add the command to run `hello.rb` using the Ruby interpreter
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加命令以使用Ruby解释器运行`hello.rb`
- en: Run the build and observe the console output
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行构建并观察控制台输出
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have covered the Jenkins environment and its configuration.
    The knowledge gained is sufficient to set up the complete Docker-based Jenkins
    infrastructure. The key takeaway from the chapter is as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经介绍了Jenkins环境及其配置。所获得的知识足以建立完整基于Docker的Jenkins基础设施。本章的关键要点如下：
- en: Jenkins is a general-purpose automation tool that can be used with any language
    or framework.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins是一种通用的自动化工具，可与任何语言或框架一起使用。
- en: Jenkins is highly extensible by plugins, which can be written or found on the
    internet.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins可以通过插件进行高度扩展，这些插件可以自行编写或在互联网上找到。
- en: Jenkins is written in Java, so it can be installed on any operating system.
    It's also officially delivered as a Docker image.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins是用Java编写的，因此可以安装在任何操作系统上。它也作为Docker镜像正式提供。
- en: Jenkins can be scaled using the master-slave architecture. The master instances
    can be scaled horizontally or vertically depending on the organization's needs.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins可以使用主从架构进行扩展。主实例可以根据组织的需求进行水平或垂直扩展。
- en: Jenkins' agents can be implemented with the use of Docker, which helps in automatic
    configuration and dynamic slaves allocation.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins的代理可以使用Docker实现，这有助于自动配置和动态分配从机。
- en: 'Custom Docker images can be created for both: Jenkins master and Jenkins slave.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以为Jenkins主和Jenkins从创建自定义Docker镜像。
- en: 'Jenkins is highly configurable and the aspects that should always be considered
    are: security and backups.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins是高度可配置的，应始终考虑的方面是：安全性和备份。
- en: In the next chapter, we will focus on the part that we've already touched with
    the "hello world" example, pipelines. We will describe the idea and the method
    to build a complete Continuous Integration pipeline.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于已经通过“hello world”示例接触过的部分，即管道。我们将描述构建完整持续集成管道的思想和方法。
