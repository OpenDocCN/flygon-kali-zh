- en: '*Chapter 13*: Anonymous Classes – Bringing Android Widgets to Life'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：匿名类-让Android小部件活起来'
- en: This chapter could have been called *Even More OOP*, as anonymous classes are
    very much still part of that subject. However, as you will see, anonymous classes
    offer us so much flexibility, especially when it comes to interacting with the
    **User Interface** (**UI**), that I thought they deserved a chapter dedicated
    to them and their key use in Android.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章本来可以被称为*更多OOP*，因为匿名类仍然是这个主题的一部分。然而，正如您将看到的，匿名类为我们提供了如此多的灵活性，特别是在与**用户界面**（**UI**）交互时，我认为它们值得有一章专门介绍它们及它们在Android中的关键用途。
- en: Now that we have a good overview of both the layout and coding of an Android
    app, along with our newly acquired insight into **Object-Oriented Programming**
    (**OOP**), and how we can manipulate the UI from our Java code, we are ready to
    experiment with more widgets from the palette alongside anonymous classes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对Android应用的布局和编码有了一个很好的概述，再加上我们新获得的对**面向对象编程**（**OOP**）的见解，以及我们如何可以从Java代码中操作UI，我们准备尝试使用调色板上的更多小部件以及匿名类。
- en: OOP is a tricky thing at times, and anonymous classes are known to be a bit
    awkward for beginners. However, by gradually learning these new concepts and then
    practicing them repeatedly, over time, they will become our friends.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程有时是一个棘手的事情，匿名类对于初学者来说可能有点尴尬。然而，通过逐渐学习这些新概念，然后反复练习，随着时间的推移，它们将成为我们的朋友。
- en: In this chapter, we will diversify a lot by going back to the Android Studio
    palette and looking at half a dozen widgets that we have either not seen at all
    or have not fully used yet.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过回到Android Studio调色板，查看半打我们根本没有看到过或者还没有完全使用过的小部件，来进行大量的多样化。
- en: Once we have done this, we will put them all into a layout and practice manipulating
    them with Java code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们做到了这一点，我们将把它们全部放入一个布局中，并用Java代码练习操作它们。
- en: 'In this chapter, we will focus on the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注以下主题：
- en: Declaring and initializing layout widgets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明和初始化布局小部件
- en: Creating widgets with just Java code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只使用Java代码创建小部件
- en: The `EditText`, `ImageView`, `RadioButton` (and `RadioGroup`), `Switch`, `CheckBox`,
    and `TextClock` widgets
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EditText`，`ImageView`，`RadioButton`（和`RadioGroup`），`Switch`，`CheckBox`和`TextClock`小部件'
- en: Using WebView
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WebView
- en: How to use an anonymous class
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用匿名类
- en: Making a widget demo mini app using all of the preceding widgets and some anonymous
    classes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用所有前述小部件和一些匿名类创建小部件演示迷你应用程序
- en: Let's begin with a quick recap.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始一个快速回顾。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2013.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件，网址为https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2013。
- en: Declaring and initializing the objects
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明和初始化对象
- en: We know that when we call the `setContentView` method from the `onCreate` method,
    Android inflates all the widgets and layouts and turns them into *real* Java objects
    on the heap.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，当我们从`onCreate`方法调用`setContentView`方法时，Android会将所有小部件和布局膨胀，并将它们转换为堆上的*真正*的Java对象。
- en: Additionally, we know that to use a widget from the heap, we must first declare
    an object of the correct type and then use it to get a reference to the UI widget
    object on the heap by using its unique `id` property.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们知道要使用堆中的小部件，我们必须首先声明正确类型的对象，然后使用它来通过其唯一的`id`属性获取对堆上的UI小部件对象的引用。
- en: 'For example, we get a reference to a `TextView` widget with an `id` property
    of `txtTitle` and assign it to a new Java object, called `myTextView`, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们通过`id`属性为`txtTitle`的`TextView`小部件获取一个引用，并将其赋值给一个新的Java对象，称为`myTextView`，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, using our `myTextView` instance variable, we can do anything that the
    `TextView` class was designed to do. For example, we can set the text to show
    the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用我们的`myTextView`实例变量，我们可以做任何`TextView`类设计的事情。例如，我们可以设置文本显示如下：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Additionally, we can make it disappear as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以按如下方式使其消失：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can change its text again and make it reappear:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次更改它的文本并使其重新出现：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is worth mentioning we can manipulate any property in Java that we set using
    XML in the previous chapters. Furthermore, we have hinted at – but not actually
    seen – the creation of widgets from nothing, using just Java code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，我们可以在Java中操纵在前几章中使用XML设置的任何属性。此外，我们已经暗示过-但实际上没有看到-使用纯Java代码从无到有地创建小部件。
- en: Creating UI widgets from pure Java without XML
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在纯Java中创建UI小部件而不使用XML
- en: 'We can also create widgets from Java objects that are not a reference to an
    object in our layout. We can declare, instantiate, and set a widget''s attributes
    all in code, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从不是指向布局中对象的Java对象创建小部件。我们可以在代码中声明、实例化和设置小部件的属性，如下所示：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code creates a new `Button` by using the `new()` keyword. The
    only caveat is that the `Button` has to be part of a layout before it can be seen
    by the user. So, we could either get a reference to a layout element from our
    XML layout or create a new one, in code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码通过使用`new()`关键字创建了一个新的`Button`。唯一的注意事项是`Button`必须是布局的一部分，才能被用户看到。因此，我们可以从XML布局中获取对布局元素的引用，或者在代码中创建一个新的布局。
- en: 'If we assume that we have a `LinearLayout` in our XML with an `id` property
    equal to `linearLayout1`, we could put our `Button` from the earlier line of code
    into it, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设我们的XML中有一个`id`属性等于`linearLayout1`的`LinearLayout`，我们可以将我们之前代码行中的`Button`放入其中，如下所示：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We could even create an entire layout in pure Java code by, first, creating
    a new layout and then all the widgets we want to add. Then, finally, we call the
    `setContentView` method on the layout that has our widgets.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过纯Java代码创建一个完整的布局，首先创建一个新布局，然后创建我们想要添加的所有小部件。最后，我们在具有我们小部件的布局上调用`setContentView`方法。
- en: 'In the following code, we have created a layout in pure Java, albeit a very
    simple one with a single `Button` inside a `LinearLayout`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们用纯Java创建了一个布局，尽管它非常简单，只有一个`LinearLayout`里面有一个`Button`：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is probably obvious – but well worth pointing out – that designing a detailed
    and nuanced layout using only Java is significantly more awkward, harder to visualize,
    and not the way it is usually done. However, there are times when we will find
    it useful to do things this way.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的是，仅使用Java设计详细和细致的布局会更加麻烦，更难以可视化，并且通常不是通常的做法。然而，有时我们会发现以这种方式做事情是有用的。
- en: We are getting quite advanced now with layouts and widgets. However, it is evident
    that there are a whole bunch of other widgets from the palette that we have not
    explored or interacted with. So, let's fix that.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经相当高级了，涉及到布局和小部件。然而，很明显，调色板中还有许多其他小部件，我们尚未探索或与之交互。所以，让我们解决这个问题。
- en: Exploring the palette – part 1
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索调色板 – 第1部分
- en: Let's take a whirlwind tour of some of those previously unexplored/unused items
    from the palette. Then, we can drag a bunch of them onto a layout and see some
    of the methods they have that might be useful. We can then implement a project
    to put them all to use.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下调色板中以前未探索/未使用的一些项目。然后，我们可以将它们拖放到布局中，查看它们可能有用的一些方法。然后，我们可以实现一个项目来使用它们。
- en: We already explored the `Button` and `TextView` widgets in the last chapter.
    Let's take a closer look at some additional widgets.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章已经探索了`Button`和`TextView`小部件。让我们更仔细地看看一些其他小部件。
- en: The EditText widget
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EditText小部件
- en: The `EditText` widget does as its name suggests. If we make an `EditText` widget
    available to our users, then they will indeed be able to *edit* the *text* inside
    it. We looked at this in an earlier chapter; however, we didn't actually achieve
    anything with it. What we didn't explore was how to capture the information from
    within it, or where we would type this text-capturing code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditText`小部件就像其名称所示。如果我们向用户提供`EditText`小部件，他们确实可以在其中*编辑* *文本*。我们在早期的章节中已经看过这个了；然而，我们实际上并没有做任何事情。我们没有探索的是如何捕获其中的信息，或者我们将在哪里输入这个捕获文本的代码。'
- en: 'The following block of code assumes that we have declared an object of the
    `EditText` type and used it to get a reference to an `EditText` widget in our
    XML layout. We might write code similar to the following code for a button click,
    for example, a submit button for a form. However, it could go anywhere we deem
    necessary for our app:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块假设我们已经声明了一个`EditText`类型的对象，并使用它来获取我们XML布局中的`EditText`小部件的引用。例如，我们可能会为按钮点击编写类似以下代码的代码，例如，表单的提交按钮。但是，它可以放在我们认为对我们的应用程序必要的任何地方：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will use this in a real-life context in the next mini-app.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个迷你应用程序中在实际环境中使用它。
- en: The ImageView widget
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ImageView小部件
- en: 'We have already put an image onto our layout a couple of times so far, but
    we have never got a reference to one from our Java code or done anything with
    it before. The process of getting a reference to an `ImageView` widget is the
    same as any other widget:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经几次将图像放到我们的布局中，但以前从未从我们的Java代码中获取引用或对其进行任何操作。获取对`ImageView`小部件的引用的过程与任何其他小部件相同：
- en: Declare an object.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个对象。
- en: 'Get a reference using the `findViewById` method and a valid `id` property,
    such as the following:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`findViewById`方法和有效的`id`属性获取引用，例如以下内容：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we can go on to do some quite neat things with our image by using code
    that is similar to the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用类似以下的代码对我们的图像做一些相当不错的事情：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Important note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The odd-looking `f` simply lets the compiler know the value is of the `float`
    type, as required by the `setAlpha` method.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来奇怪的`f`只是让编译器知道值是`float`类型，这是`setAlpha`方法所需的。
- en: In the preceding, we use the `setAlpha` method on `imageView`. The `setAlpha`
    method takes a value between 0 and 1\. An image that is completely see-through
    is 0, while an image with no transparency at all is 1\.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们在`imageView`上使用了`setAlpha`方法。`setAlpha`方法接受一个介于0和1之间的值。完全透明的图像为0，而完全不透明的图像为1。
- en: Tip
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: There is also an overloaded `setAlpha` method that takes an integer value from
    0 (completely see-through) to 255 (no transparency). We can choose whichever is
    the most appropriate at the time. If you want a reminder about method overloading,
    please refer back to [*Chapter 9*](B16773_09_ePub_RK.xhtml#_idTextAnchor169),
    *Learning* *Java Methods*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个重载的`setAlpha`方法，它接受一个从0（完全透明）到255（不透明）的整数值。我们可以在需要时选择最合适的方法。如果您想了解方法重载的内容，请参考[*第9章*](B16773_09_ePub_RK.xhtml#_idTextAnchor169)，*学习Java方法*。
- en: We will use some of the `ImageView` class' methods in our next app.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个应用程序中使用`ImageView`类的一些方法。
- en: Radio buttons and groups
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单选按钮和组
- en: 'A `RadioButton` widget is used when there are two or more mutually exclusive
    options for the user to choose from. This means that when one option is chosen,
    the other options are not – just like on an old-fashioned radio. Take a look at
    a simple `RadioGroup` with a few `RadioButton` widgets in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户需要选择两个或更多互斥的选项时，会使用`RadioButton`小部件。这意味着当选择一个选项时，其他选项就不会被选择，就像在老式收音机上一样。请看下面截图中带有几个`RadioButton`小部件的简单`RadioGroup`：
- en: '![Figure 13.1 – RadioButton widget'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.1 – RadioButton小部件'
- en: '](img/Figure_13.01_B16773.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.01_B16773.jpg)'
- en: Figure 13.1 – RadioButton widget
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – RadioButton小部件
- en: 'As the user selects a choice, the other options will automatically be deselected.
    We control `RadioButton` widgets by placing them within a `RadioGroup` in our
    UI layout. We can, of course, use the visual designer to simply drag a bunch of
    `RadioButtons` onto a `RadioGroup`. When we do so within a `ConstraintLayout`
    layout, the XML will look similar to the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择一个选项时，其他选项将自动取消选择。我们通过将`RadioButton`小部件放置在UI布局中的`RadioGroup`中来控制它们。当然，我们可以使用可视化设计工具简单地将一堆`RadioButtons`拖放到`RadioGroup`中。当我们在`ConstraintLayout`布局中这样做时，XML将类似于以下内容：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note, as highlighted in the previous code, that each `RadioButton` instance
    has an appropriate `id` attribute set. We can then get a reference to them, as
    we might expect, as this code shows us:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，正如前面的代码所强调的，每个`RadioButton`实例都设置了适当的`id`属性。然后，我们可以像这段代码所示的那样引用它们：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In practice, however, as you will see, we can manage almost everything from
    the `RadioGroup` reference alone. Additionally, you will learn that we can assign
    an `id` property to the `RadioGroup` widget for this purpose.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，正如你将看到的，我们几乎可以仅通过`RadioGroup`引用来管理几乎所有的事情。此外，你将了解到我们可以为`RadioGroup`小部件分配一个`id`属性以实现这个目的。
- en: You might be thinking, how do we know when they have been clicked on? Or, you
    might wonder whether keeping track of the one that has been selected might be
    awkward. We will need some help from the Android API and Java in the form of anonymous
    classes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，我们怎么知道它们被点击了呢？或者，你可能会想知道是否跟踪被选中的那个可能会很尴尬。我们需要一些来自Android API和Java的帮助，以匿名类的形式。
- en: Anonymous classes
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名类
- en: In [*Chapter 12*](B16773_12_ePub_RK.xhtml#_idTextAnchor218)*, The Stack, the
    Heap, and the Garbage Collector*, we briefly introduced anonymous classes. Here,
    we will discuss it in a little more detail and examine how they can help us. When
    a `RadioButton` widget is part of a `RadioGroup` widget, the visual appearance
    of them all is coordinated for us. All we need to do is react when any given `RadioButton`
    widget is pressed. Of course, as with any other button, we need to know when they
    have been clicked on.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第12章*](B16773_12_ePub_RK.xhtml#_idTextAnchor218)*，堆栈、堆和垃圾收集器*中，我们简要介绍了匿名类。在这里，我们将更详细地讨论它，并探讨它如何帮助我们。当`RadioButton`小部件是`RadioGroup`小部件的一部分时，它们的所有视觉外观都是为我们协调好的。我们所需要做的就是在任何给定的`RadioButton`小部件被按下时做出反应。当然，就像任何其他按钮一样，我们需要知道它们何时被点击。
- en: A `RadioButton` widget behaves differently to a regular `Button`, and simply
    listening for clicks in `onClick` (after implementing `OnClickListener`) will
    not work because `RadioButton` is not designed that way.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`RadioButton`小部件的行为与常规的`Button`不同，仅仅监听`onClick`（在实现`OnClickListener`之后）的点击是行不通的，因为`RadioButton`并非设计为这样。'
- en: 'What we need to do is use another Java feature. We need to implement a class,
    that is, an anonymous class, for the sole purpose of listening for clicks on the
    `RadioGroup` widget. The next block of code assumes that we have a reference to
    a `RadioGroup` widget, called `radioGroup`. Here is the code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是使用另一个Java特性。我们需要实现一个类，也就是一个匿名类，唯一的目的是监听`RadioGroup`小部件上的点击。下面的代码块假设我们有一个名为`radioGroup`的`RadioGroup`小部件的引用。这是代码：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code, specifically, `RadioGroup.OnCheckedChangedListener` from
    its opening `{` to closing `}`, is what is known as an **anonymous** class. This
    is because it has no name.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码，特别是从`{`到`}`的`RadioGroup.OnCheckedChangedListener`被称为**匿名**类。这是因为它没有名字。
- en: If we place the preceding code in the `onCreate` method, then, surprisingly,
    the code does not run when `onCreate` is called. It simply prepares the new anonymous
    class to be ready to handle any clicks on `radioGroup`. We will now discuss this
    in more detail.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的代码放在`onCreate`方法中，那么令人惊讶的是，当调用`onCreate`时代码并不运行。它只是准备好新的匿名类，以便在`radioGroup`上处理任何点击。我们现在将更详细地讨论这一点。
- en: This class is more technically known as an **anonymous inner** class because
    it is inside another class. Inner classes can be anonymous or have names. We will
    learn about inner classes with names in [*Chapter 16*](B16773_16_ePub_RK.xhtml#_idTextAnchor285),
    *Adapters and Recyclers*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类更正式地称为**匿名内部**类，因为它在另一个类内部。内部类可以是匿名的或者有名字的。我们将在[*第16章*](B16773_16_ePub_RK.xhtml#_idTextAnchor285)中学习有名字的内部类，*适配器和回收器*。
- en: I remember the first time I saw an anonymous class, and it made me want to hide
    in a cupboard. However, it is not as complex as it might appear at first.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得第一次看到匿名类时，我想躲进橱柜里。然而，它并不像一开始看起来那么复杂。
- en: What we are doing is adding a listener to `radioGroup`. This has, very much,
    the same effect as when we implemented `View.OnClickListener` in [*Chapter 12*](B16773_12_ePub_RK.xhtml#_idTextAnchor218),
    *The Stack, the Heap, and the Garbage Collector*. However, this time, we are declaring
    and instantiating a listener class, preparing it to listen to `radioGroup`, while
    simultaneously overriding the required method, which, in this case, is `onCheckedChanged`.
    This is like the `RadioGroup` equivalent of `onClick`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在为`radioGroup`添加一个监听器。这与我们在[*第12章*](B16773_12_ePub_RK.xhtml#_idTextAnchor218)中实现`View.OnClickListener`的效果非常相似，*堆栈、堆和垃圾收集器*。然而，这一次，我们声明并实例化了一个监听器类，准备好监听`radioGroup`，同时重写了所需的方法，这种情况下是`onCheckedChanged`。这就像`RadioGroup`中的`onClick`等效。
- en: 'Let''s step through the process:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解这个过程：
- en: 'First, we call the `setOnCheckedChangedListener` method on our `radioGroup`
    instance:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在`radioGroup`实例上调用`setOnCheckedChangedListener`方法：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We then provide a new anonymous class implementation that includes the details
    of this class'' overridden method as an argument to the `setOnCheckedChangedListener`
    method:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们提供一个新的匿名类实现，将该类的重写方法的细节作为参数传递给`setOnCheckedChangedListener`方法：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we have the closing parenthesis of the method along with, of course,
    the semicolon to mark the end of the line of code. The only reason we present
    it on multiple lines is to make it more readable. As far as the compiler is concerned,
    it could be all lumped together:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有方法的闭合括号，当然，还有分号标记代码行的结束。我们将它呈现在多行上的唯一原因是为了使其更易读。就编译器而言，它可以全部合并在一起：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we use the preceding code to create and instantiate a class that listens
    for clicks to our `RadioGroup`, perhaps in the `onCreate` method, it will listen
    and respond for the entire life of the Activity. All we need to learn now is how
    to handle the clicks in the `onCheckedChanged` method that we override.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用前面的代码来创建和实例化一个类，监听我们的`RadioGroup`的点击，也许在`onCreate`方法中，它将在整个Activity的生命周期内监听和响应。现在我们需要学习的是如何处理我们重写的`onCheckedChanged`方法中的点击。
- en: Notice that one of the parameters of the `onCheckedChanged` method, which is
    passed in when `radioGroup` is pressed, is `int checkedId`. This holds the `id`
    property of the currently selected `RadioButton` widget. This is just what we
    need – well, almost.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`onCheckedChanged`方法的一个参数（在`radioGroup`被按下时传入）是`int checkedId`。这保存了当前选定的`RadioButton`小部件的`id`属性。这正是我们需要的
    – 好吧，几乎是。
- en: It might be surprising to know that `checkedId` is an `int`. Android stores
    all IDs as `int`, even though we declare them with alphanumeric characters such
    as `radioButton1` and `radioGroup`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 也许令人惊讶的是，`checkedId`是一个`int`。Android将所有ID存储为`int`，即使我们使用字母数字字符声明它们，比如`radioButton1`和`radioGroup`。
- en: All our human-friendly names are converted into integers when the app is compiled.
    So, how do we know which integer value refers to which `id` attribute value such
    as `radioButton1` or `radioButton2`?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序编译时，所有我们人性化的名称都会转换为整数。那么，我们如何知道哪个整数值指的是哪个`id`属性值，比如`radioButton1`或`radioButton2`？
- en: 'What we need to do is to get a reference to the actual object that the integer
    is an identifier for. We can do so by using the `int CheckedId` parameter and
    then asking the object for its human-friendly `id` attribute value. We do this
    as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是获取整数标识符的实际对象的引用。我们可以通过使用`int CheckedId`参数来实现，然后询问对象其人性化的`id`属性值。我们可以这样做：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we can retrieve the familiar `id` attribute value that we used for the
    currently selected `RadioButton` widget, for which we now have a reference stored
    in `rb`, using the `getId` method, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`getId`方法检索当前选定的`RadioButton`小部件的熟悉的`id`属性值，我们现在已经将其存储在`rb`中：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We could, therefore, handle any `RadioButton` widget clicks by using a `switch`
    block with a `case`, for each possible `RadioButton` widget that could be pressed,
    and `rb.getId()`, as the `switch` block's expression.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过使用`switch`块和`case`来处理任何`RadioButton`小部件的点击，对于每个可能被按下的`RadioButton`小部件，我们可以使用`rb.getId()`作为`switch`块的表达式。
- en: 'Th following code shows the entire contents of the `onCheckedChanged` method
    that we just discussed:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了我们刚讨论的`onCheckedChanged`方法的全部内容：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To make this clearer, we will view this in action in the next working app, where
    we can press the buttons in real time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这更清晰，我们将在下一个工作应用程序中实时查看它的运行情况，我们可以按下按钮。
- en: Let's continue with our palette exploration.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探索调色板。
- en: Exploring the palette and more anonymous classes – part 2
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索调色板和更多匿名类 – 第2部分
- en: Now that we have seen how anonymous classes work, specifically with `RadioGroup`
    and `RadioButton`, we can continue to explore the palette and examine how anonymous
    classes work with some more UI widgets.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了匿名类是如何工作的，特别是与`RadioGroup`和`RadioButton`一起，我们可以继续探索调色板，并查看匿名类如何与更多UI小部件一起工作。
- en: Switch
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Switch
- en: The `Switch` (not to be confused with the lowercase `switch` Java keyword) widget
    is just like a `Button` widget, except it has two possible states that can be
    read and responded to.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Switch`（不要与小写的`switch` Java关键字混淆）小部件就像`Button`小部件一样，只是它有两种可能的状态可以读取和响应。'
- en: One obvious use for the `Switch` widget is to show or hide something. Remember
    that in our Java Meet UI app, in [*Chapter 12*](B16773_12_ePub_RK.xhtml#_idTextAnchor218),
    *The Stack, the Heap, and the Garbage Collector*, we used a `Button` widget to
    show and hide a `TextView` widget.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Switch`小部件的一个明显用途是显示或隐藏某些内容。请记住，在我们的Java Meet UI应用程序中，在[*第12章*](B16773_12_ePub_RK.xhtml#_idTextAnchor218)中，*堆栈、堆和垃圾收集器*，我们使用了`Button`小部件来显示和隐藏`TextView`小部件。'
- en: 'Each time we hid or showed the `TextView` widget, we changed the `text` property
    on the `Button` widget to make it clear what would happen if it was clicked on
    again. What might have been more intuitive for the user, and more straightforward
    for us as programmers, would have been to use a `Switch` widget, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们隐藏或显示`TextView`小部件时，我们都会更改`Button`小部件上的`text`属性，以清楚地表明如果再次点击它会发生什么。对于用户来说，以及对我们作为程序员来说，更直观、更简单的做法可能是使用`Switch`小部件，如下所示：
- en: '![Figure 13.2 – Switch widget'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.2 – Switch小部件'
- en: '](img/Figure_13.02_B16773.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.02_B16773.jpg)'
- en: Figure 13.2 – Switch widget
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – Switch小部件
- en: The following code assumes that we already have an object called `mySwitch`,
    which is a reference to the `Switch` object in the layout. We could show and hide
    a `TextView` widget just like we did in our Java Meet UI app in [*Chapter 12*](B16773_12_ePub_RK.xhtml#_idTextAnchor218),
    *The Stack, the Heap, and the Garbage Collector*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码假设我们已经有一个名为`mySwitch`的对象，它是布局中`Switch`对象的引用。我们可以像在我们的Java Meet UI应用程序中[*第12章*](B16773_12_ePub_RK.xhtml#_idTextAnchor218)中那样显示和隐藏`TextView`小部件。
- en: To listen for and respond to clicks, we, again, use an anonymous class. However,
    this time, we use the `CompoundButton` version of `OnCheckedChangedListener` instead
    of the `RadioGroup` version.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了监听并响应点击，我们再次使用匿名类。但是，这一次，我们使用`CompoundButton`版本的`OnCheckedChangedListener`，而不是`RadioGroup`版本。
- en: We need to override the `onCheckedChanged` method, and that method has a Boolean
    parameter, called `isChecked`. The `isChecked` variable is simply `false` for
    off and `true` for on.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重写`onCheckedChanged`方法，该方法有一个名为`isChecked`的布尔参数。`isChecked`变量对于关闭来说只是`false`，对于打开来说只是`true`。
- en: 'Here is how we could, more intuitively, replace that text hiding/showing code
    from [*Chapter 12*](B16773_12_ePub_RK.xhtml#_idTextAnchor218), *The Stack, the
    Heap, and the Garbage Collector*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何更直观地替换[*第12章*](B16773_12_ePub_RK.xhtml#_idTextAnchor218)中的文本隐藏/显示代码，*堆栈、堆和垃圾收集器*：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the anonymous class code still looks a little odd, don't worry because it
    will become more familiar as you keep using it. We will do so now when we look
    at the `CheckBox` widget.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果匿名类代码看起来有点奇怪，不要担心，因为随着您不断使用它，它会变得更加熟悉。现在我们将在查看`CheckBox`小部件时这样做。
- en: CheckBox
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复选框
- en: 'This is a `CheckBox` widget. It is either checked or unchecked. In the following
    screenshot, it is checked:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`CheckBox`小部件。它可以是选中的，也可以是未选中的。在下面的屏幕截图中，它是选中的：
- en: '![Figure 13.3 – CheckBox widget'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.3 – CheckBox小部件'
- en: '](img/Figure_13.03_B16773.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.03_B16773.jpg)'
- en: Figure 13.3 – CheckBox widget
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 - CheckBox小部件
- en: 'With a `CheckBox` widget, we can simply detect its state (checked or unchecked)
    at a given moment – for example, at the moment when a specific button is clicked
    on. The following code gives us a glimpse at how this might happen, again using
    an inner class to act as a listener:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CheckBox`小部件，我们可以简单地在特定时刻检测其状态（选中或未选中）-例如，在特定按钮被点击时。以下代码让我们可以看到这种情况是如何发生的，再次使用内部类作为监听器：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the previous code, we assume that `myCheckBox` has been declared and initialized.
    Then, we use the same type of anonymous class that we did for `Switch`, in order
    to detect and respond to clicks.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们假设`myCheckBox`已经被声明和初始化。然后，我们使用了与`Switch`相同类型的匿名类，以便检测和响应点击。
- en: TextClock
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TextClock
- en: 'In our next app, we will use the `TextClock` widget to show off some of its
    features. We will need to add the XML directly, as this widget is not available
    to drag and drop from the palette. The `TextClock` widget looks similar to the
    following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个应用程序中，我们将使用`TextClock`小部件展示一些它的特性。我们需要直接添加XML，因为这个小部件不能从调色板中拖放。`TextClock`小部件看起来类似于以下截图：
- en: '![Figure 13.4 – TextClock widget'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.4 - TextClock小部件'
- en: '](img/Figure_13.04_B16773.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.04_B16773.jpg)'
- en: Figure 13.4 – TextClock widget
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 - TextClock小部件
- en: 'Let''s look at an example of using `TextClock`. This is how we would set its
    time to the same time as it is in Brussels, Europe:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用`TextClock`的例子。这是我们如何将其时间设置为与布鲁塞尔，欧洲的时间相同的方法：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code assumes that `tClock` is a reference to a `TextClock` widget
    in the layout.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码假设`tClock`是布局中`TextClock`小部件的引用。
- en: Using WebView
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用WebView
- en: WebView is quite a powerful widget. It can be used to show a web page in your
    app's UI. You can even implement a basic web browser app with just half a dozen
    lines of code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: WebView是一个非常强大的小部件。它可以用来在应用的UI中显示网页。你甚至可以只用几行代码来实现一个基本的网页浏览器应用程序。
- en: Tip
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Normally, you wouldn't implement an entire web browser; rather, you would use
    the user's preferred web browser.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你不会实现一个完整的网页浏览器；相反，你会使用用户首选的网页浏览器。
- en: 'To simply get a reference to a `WebView` widget that is present in the XML
    and display a website, you would only need two lines of code. This code loads
    my website – [https://gamecodeschool.com](https://gamecodeschool.com) – assuming
    that there is a `WebView` widget in the layout with the `id` property set to `webView`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要简单地获取XML中存在的`WebView`小部件的引用并显示一个网站，你只需要两行代码。这段代码加载了我的网站- [https://gamecodeschool.com](https://gamecodeschool.com)
    - 假设布局中有一个`id`属性设置为`webView`的`WebView`小部件：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With all of this extra information, let's make an app that uses the Android
    widgets more extensively than we have so far.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些额外的信息，让我们制作一个比我们迄今为止更广泛地使用Android小部件的应用程序。
- en: The Widget Exploration app
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小部件探索应用程序
- en: 'So far, we have discussed seven widgets: `EditText`, `ImageView`, `RadioButton`
    (and `RadioGroup`), `Switch`, `CheckBox`, `TextClock`, and `WebView`. Let''s make
    a working app and do something real with each of them. We will also use a `Button`
    widget and a `TextView` widget again.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了七个小部件：`EditText`、`ImageView`、`RadioButton`（和`RadioGroup`）、`Switch`、`CheckBox`、`TextClock`和`WebView`。让我们制作一个可工作的应用程序，并对每个小部件做一些真实的事情。我们还将再次使用`Button`小部件和`TextView`小部件。
- en: Remember that you can refer to the completed code in the download bundle. This
    app can be found in [*Chapter 13*](B16773_13_ePub_RK.xhtml#_idTextAnchor228)`/Widget
    Exploration`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你可以在下载包中找到已完成的代码。这个应用程序可以在[*第13章*](B16773_13_ePub_RK.xhtml#_idTextAnchor228)`/小部件探索`中找到。
- en: Setting up the Widget Exploration project and UI
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置小部件探索项目和UI
- en: 'First, we will set up a new project and prepare the UI layout. These steps
    will arrange all the widgets on the screen and set the `id` properties, ready
    to grab a reference to them. It is useful to look at the target layout – while
    it is up and running – before we get started. Take a look at the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将设置一个新项目并准备UI布局。这些步骤将在屏幕上排列所有小部件并设置`id`属性，准备好引用它们。在开始之前，看一下目标布局是很有用的-当它正在运行时。看一下以下截图：
- en: '![Figure 13.5 – Widget exploration layout'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.5 - 小部件探索布局'
- en: '](img/Figure_13.05_B16773.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.05_B16773.jpg)'
- en: Figure 13.5 – Widget exploration layout
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 - 小部件探索布局
- en: 'Here is how this app will demonstrate these widgets:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序将演示这些小部件：
- en: The radio buttons allow the user to change the time displayed on the clock to
    a choice of three time zones.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单选按钮允许用户将时钟显示的时间更改为三个时区中的一个选择。
- en: The `TextView` widget (which is on the right) to whatever is currently in the
    `EditText` widget (which is on the left).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextView`小部件（在右侧）显示`EditText`小部件（在左侧）中当前的内容。'
- en: The three `CheckBox` widgets will add and remove visual effects from the Android
    robot image.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这三个`CheckBox`小部件将为Android机器人图像添加和删除视觉效果。
- en: The `Switch` widget will turn on and off the `TextView` widget, which displays
    information entered in the `EditText` widget and is captured at the push of a
    button.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Switch`小部件将打开和关闭`TextView`小部件，显示在`EditText`小部件中输入的信息，并在按下按钮时捕获。'
- en: The `WebView` widget will occupy the full width and bottom half of the app.
    Keep this in mind when adding widgets to the layout; try and get them all in the
    top half.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebView`小部件将占据应用程序的整个宽度和下半部分。在添加小部件到布局时要记住这一点；尽量将它们全部放在上半部分。'
- en: The exact layout positions are not essential, but the `id` properties that are
    specified must match exactly. If you just want to view/use the code, you can find
    all of the files in the [*Chapter 13*](B16773_13_ePub_RK.xhtml#_idTextAnchor228)`/Widget
    Exploration` folder of the download bundle.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 确切的布局位置并不重要，但指定的`id`属性必须完全匹配。如果你只想查看/使用代码，你可以在下载包的[*第13章*](B16773_13_ePub_RK.xhtml#_idTextAnchor228)`/小部件探索`文件夹中找到所有文件。
- en: 'So, let''s perform the following steps to set up a new project and prepare
    the UI layout:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们执行以下步骤来设置一个新项目并准备UI布局：
- en: Create a new project, called `Widget Exploration`. Set the `API 17:Android 4.2
    (Jelly Bean)`. Then, use an Empty Activity and keep all the other settings at
    their defaults. We are using `API 17` because one of the features of the `TextClock`
    widget requires us to. We can still support in excess of 99% of all Android devices.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Widget Exploration`的新项目。设置`API 17:Android 4.2 (Jelly Bean)`。然后，使用一个空活动，并保持所有其他设置为默认值。我们使用`API
    17`是因为`TextClock`小部件的一个功能需要我们这样做。我们仍然可以支持超过99%的所有Android设备。
- en: Switch to the `activity_main.xml` layout file and make sure you are in the design
    view. Delete the default `TextView` widget.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`activity_main.xml`布局文件，并确保您处于设计视图中。删除默认的`TextView`小部件。
- en: Using the drop-down controls that are displayed above the design view (as shown
    in the following screenshot), select a tablet in landscape orientation. I chose
    the **Pixel C** option:![Figure 13.6 – Selecting the orientation options
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用显示在设计视图上方的下拉控件（如下面的屏幕截图所示），选择横向方向的平板电脑。我选择了**Pixel C**选项：![图13.6 - 选择方向选项
- en: '](img/Figure_13.06_B16773.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.06_B16773.jpg)'
- en: Figure 13.6 – Selecting the orientation options
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 - 选择方向选项
- en: Important note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For a reminder of how to make a tablet emulator, please refer to [*Chapter 3*](B16773_03_ePub_RK.xhtml#_idTextAnchor064),
    *Exploring Android Studio and the Project Structure*. For additional advice on
    how to manipulate the orientation of the emulator, please refer to [*Chapter 5*](B16773_05_ePub_RK.xhtml#_idTextAnchor101),
    *Beautiful Layouts with CardView and ScrollView*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何制作平板模拟器的提醒，请参阅[*第3章*](B16773_03_ePub_RK.xhtml#_idTextAnchor064)，*探索Android
    Studio和项目结构*。有关如何操作模拟器方向的其他建议，请参阅[*第5章*](B16773_05_ePub_RK.xhtml#_idTextAnchor101)，*使用CardView和ScrollView创建美丽的布局*。
- en: Drag a **Switch** widget from the **Button** category of the palette to near
    the upper-right corner of the layout. Then, just below this, add a **TextView**
    widget. The upper-right corner of your layout should now look similar to the following
    screenshot:![Figure 13.7 – Switch widget to the layout
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从调色板的**按钮**类别中拖动一个**开关**小部件到布局的右上角附近。然后，在这下面，添加一个**TextView**小部件。您的布局的右上角现在应该看起来类似于以下的屏幕截图：![图13.7
    - 将开关小部件添加到布局
- en: '](img/Figure_13.07_B16773.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.07_B16773.jpg)'
- en: Figure 13.7 – Switch widget to the layout
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 - 将开关小部件添加到布局
- en: Drag three `sym_def_app_icon` to use the Android icon as the image for the `ImageView`.
    The central portion of the layout should now look similar to the following screenshot.
    For more context on the final layout, please refer back to the screenshot showing
    the completed app:![Figure 13.8 – CheckBox widget
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动三个`sym_def_app_icon`以使用Android图标作为`ImageView`的图像。布局的中间部分现在应该看起来类似于以下的屏幕截图。有关最终布局的更多上下文，请参考显示完成的应用程序的屏幕截图：![图13.8
    - 复选框小部件
- en: '](img/Figure_13.08_B16773.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.08_B16773.jpg)'
- en: Figure 13.8 – CheckBox widget
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8 - 复选框小部件
- en: Drag **RadioGroup** to the upper-left corner of the layout.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**RadioGroup**拖到布局的左上角。
- en: Add three **RadioButton** widgets within the **RadioGroup**. This step can be
    easily done using the **Component Tree** window.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**RadioGroup**内添加三个**RadioButton**小部件。可以使用**组件树**窗口轻松完成此步骤。
- en: Underneath **RadioGroup**, drag a **Plain Text** widget from the **Text** category
    of the palette. Remember, despite its name, this is a widget that allows the user
    to type some text into it. Later, we will learn how to capture and use the entered
    text.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**RadioGroup**下面，从调色板的**文本**类别中拖动一个**纯文本**小部件。请记住，尽管它的名字是这样，但这是一个允许用户在其中输入一些文本的小部件。稍后，我们将学习如何捕获和使用输入的文本。
- en: Add a **Button** widget underneath the **Plain Text** widget. The left-hand
    side of your layout should look similar to the following screenshot:![Figure 13.9
    – Adding a Button widget
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**纯文本**小部件下面添加一个**按钮**小部件。您的布局的左侧应该看起来类似于以下的屏幕截图：![图13.9 - 添加一个按钮小部件
- en: '](img/Figure_13.09_B16773.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.09_B16773.jpg)'
- en: Figure 13.9 – Adding a Button widget
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 - 添加一个按钮小部件
- en: 'Now, add the following attributes to the widgets we have just laid out:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为我们刚刚布置的小部件添加以下属性：
- en: Important note
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that some of the attributes might already be correct by default.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一些属性可能已经默认正确。
- en: '![](img/B16773_table_1.1.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16773_table_1.1.jpg)'
- en: The penultimate widget is a bit different, so I thought we would handle it separately.
    Add another regular `TextView` widget underneath the `Button` widget on the left-hand
    side, and set its `id` property to `textClock`. Remember to keep this widget,
    as with all of the other widgets, above the approximate halfway point vertically.
    Readjust some of the widgets above it if required.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 倒数第二个小部件有点不同，所以我认为我们应该单独处理它。在左侧的按钮小部件下方再添加一个常规的`TextView`小部件，并将其`id`属性设置为`textClock`。请记住，与所有其他小部件一样，保持此小部件在垂直方向上大约中点以上。如果需要，重新调整其上方的一些小部件。
- en: Switch to the code view and find the `TextView` widget that we are working on
    – the one with `textClock` as its `id` property value.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到代码视图，并找到我们正在处理的`TextView`小部件 - 其`id`属性值为`textClock`的那个。
- en: 'Observe the start of the XML code, as shown in the following code snippet,
    with a couple of key parts highlighted:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察XML代码的开头，如下面的代码片段所示，其中突出显示了一些关键部分：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Switch to the **Design** tab.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**设计**选项卡。
- en: Now it's time for the final widget. Drag a `WebView` widget from the `WebView`
    widget is apparently missing. In fact, if you look very carefully, you can see
    a tiny indication that the widget is in the upper-left corner of the layout. We
    will configure the position and size of the `WebView` widget slightly differently.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是最后一个小部件的时间了。从`WebView`小部件中拖动一个`WebView`小部件。实际上，如果你仔细观察，你会发现`WebView`小部件似乎不见了。事实上，如果你仔细观察，你会发现`WebView`小部件在布局的左上角有一个微小的指示。我们将稍微不同地配置`WebView`小部件的位置和大小。
- en: Make sure that the `WebView` widget is selected in the component tree window.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在组件树窗口中选择了`WebView`小部件。
- en: Change the `id` attribute to `webView` (if it isn't this value already).
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`id`属性更改为`webView`（如果尚未是此值）。
- en: For this next step to work correctly, all the other widgets must be constrained.
    Therefore, click on the **Infer Constraints** button to secure all of the other
    widgets.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使下一步正常工作，所有其他小部件都必须受到约束。因此，单击**推断约束**按钮以确保所有其他小部件。
- en: At the moment, our `WebView` widget is not constrained to anything, and it is
    not possible to grab the constraint handles that we need. Now, find the **Layout**
    section in the attributes window, as shown in the following screenshot:![Figure
    13.10 – Adding constraint
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们的`WebView`小部件没有受到任何约束，也无法抓取我们需要的约束手柄。现在，在属性窗口中找到**布局**部分，如下面的屏幕截图所示：![图13.10
    – 添加约束
- en: '](img/Figure_13.10_B16773.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.10_B16773.jpg)'
- en: Figure 13.10 – Adding constraint
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10 – 添加约束
- en: Left-click on the add constraint to the bottom button, as highlighted in the
    previous screenshot. Now, we have a constraint where the bottom of the `WebView`
    widget is constrained to the bottom of the layout. This is almost perfect, but
    the default margin is set very high.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击上一个屏幕截图中突出显示的添加约束到底部按钮。现在，我们有一个约束，其中`WebView`小部件的底部受到布局底部的约束。这几乎是完美的，但默认边距设置得非常高。
- en: Find the `layout_margin_bottom` property in the properties window and change
    it to `0dp`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在属性窗口中找到`layout_margin_bottom`属性，并将其更改为`0dp`。
- en: Change the `layout_height` property in the properties window to `400dp`. Note
    that when this project is complete, if your `WebView` widget is too tall or too
    short, then you can come back and tweak this value.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在属性窗口中将`layout_height`属性更改为`400dp`。请注意，当此项目完成时，如果您的`WebView`小部件太高或太矮，那么您可以回来调整此值。
- en: 'Tweak your layout to resemble the following reference diagram as much as possible.
    However, if you have the appropriate types of UI with the correct `id` attributes,
    then the code will still work even if the layout isn''t identical. Remember that
    the `WebView` widget is not visible, but it will take up the entire bottom half
    of the screen once we have done some coding:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整您的布局，使其尽可能地类似于以下参考图。但是，如果您具有正确的UI类型和正确的`id`属性，即使布局不完全相同，代码仍将起作用。请记住，`WebView`小部件是不可见的，但是一旦我们进行了一些编码，它将占据屏幕的下半部分。
- en: '![Figure 13.11 – Tweaking layout'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.11 – 调整布局'
- en: '](img/Figure_13.11_B16773.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.11_B16773.jpg)'
- en: Figure 13.11 – Tweaking layout
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11 – 调整布局
- en: We have just laid out and set the required attributes for our layout. There
    is nothing here that we haven't done before, except that some of the widget types
    are new to us and the layout is slightly more intricate.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚布置并设置了布局所需的属性。除了一些小部件类型对我们来说是新的，布局略微更加复杂之外，这里没有我们以前没有做过的事情。
- en: Now we can get on with using all of these widgets in our Java code.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始在我们的Java代码中使用所有这些小部件了。
- en: Coding the Widget Exploration app
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Widget Exploration应用程序的代码
- en: 'There are many `import` statements needed for this app. So, let''s add them
    all now to save us from having to mention them all the time. Add the following
    `import` statements:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序需要许多`import`语句。因此，让我们现在添加它们，以免每次都提到它们。添加以下`import`语句：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let's get a reference to all the parts of the UI that we will be using in the
    Java code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Java代码中获取我们将在UI中使用的所有部分的引用。
- en: Getting a reference to all the parts of the UI
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取对UI的所有部分的引用
- en: This next block of code looks quite long and sprawling, but all we are doing
    is getting a reference to each of the widgets in our layout. When we come to use
    them, we will discuss the code in more detail.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下一块代码看起来相当长而杂乱，但我们所做的只是获取布局中每个小部件的引用。当我们使用它们时，我们将更详细地讨论代码。
- en: The only thing that is new in this next block of code is that some of the objects
    are declared as `final`. This is needed as they are going to be used within an
    anonymous class.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一块代码中唯一新的是，一些对象被声明为`final`。这是必要的，因为它们将在匿名类中使用。
- en: But doesn't `final` mean that the object cannot be changed?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`final`不是意味着对象不能被更改吗？
- en: If you recall [*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)*, More
    Object-Oriented Programming*, we learned that variables declared as `final` could
    not be changed, that is, they are a constant. So, how are we going to change the
    attributes of these objects? Remember that objects are reference type variables.
    This means that they refer to an object on the heap. They are not the object themselves.
    We can think of them as holding an address of an object. It is the address that
    cannot change. We can still use the address to reference the object on the heap
    and change the actual object as much as we like. Let's take the address analogy
    further. If you live at a particular address and if the address is final, then
    you cannot move to a new house. However, you are unrestricted in what you can
    do at that address. For example, you can still rearrange your house, perhaps repaint
    the living room, and put the bath in the kitchen and the sofa on the roof.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回忆[*第11章*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)*，更多面向对象编程*，我们学到声明为`final`的变量不能被更改，也就是说，它们是常量。那么，我们如何改变这些对象的属性呢？请记住，对象是引用类型变量。这意味着它们引用堆上的一个对象。它们不是对象本身。我们可以将它们视为持有对象的地址。地址是不会改变的。我们仍然可以使用地址引用堆上的对象，并随意更改实际对象。让我们进一步使用地址的类比。如果您住在特定地址，如果地址是最终的，那么您就不能搬到新房子。但是，您在该地址上可以做任何事情。例如，您仍然可以重新布置您的房子，也许重新粉刷客厅，并在厨房放浴缸，把沙发放在屋顶上。
- en: 'Enter the following code just after the call to the `setContentView` method
    in the `onCreate` method:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中的`setContentView`方法调用之后立即输入以下代码：
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We now have a reference, in our Java code, to all of the UI elements in our
    layout that we need to manipulate.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在我们的Java代码中引用了我们需要操作的布局中的所有UI元素。
- en: Coding the checkboxes
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写复选框的代码
- en: Now, we can create an anonymous class to listen for and handle clicks on the
    checkboxes. The next three blocks of code each implement an anonymous class for
    each of the checkboxes in turn. However, what is different in each of the following
    three blocks of code is how we respond to a click; we will discuss each in turn.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个匿名类来监听和处理复选框的点击。接下来的三个代码块分别实现了每个复选框的匿名类。然而，每个以下三个代码块中的不同之处在于我们如何响应点击；我们将依次讨论每个。
- en: Changing the transparency
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改透明度
- en: The first checkbox is labeled `setAlpha` method in `imageView` to change how
    transparent (or see-through) it is. The `setAlpha` method takes a floating-point
    value between 0 and 1 as an argument.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个复选框标记为`imageView`中的`setAlpha`方法，以更改其透明度。`setAlpha`方法以0到1之间的浮点值作为参数。
- en: 0 is invisible, and 1 refers to no transparency at all. So, when this checkbox
    is checked, we set the alpha to `.1`, which means that the image is barely visible.
    And when it is unchecked, we set it to `1`, which means that it is completely
    visible with no transparency. The `boolean isChecked` parameter of `onCheckedChanged`
    contains `true` or `false` to show whether the checkbox is checked or not.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 0是不可见的，1表示完全不透明。因此，当选中此复选框时，我们将alpha设置为`.1`，这意味着图像几乎不可见。当取消选中时，我们将其设置为`1`，这意味着它完全可见，没有透明度。`onCheckedChanged`的`boolean
    isChecked`参数包含`true`或`false`，以显示复选框是否被选中。
- en: 'Add this code after the previous block of code in the `onCreate` method:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中的上一个代码块之后添加以下代码：
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the next anonymous class, we will handle the checkbox labeled **Tint.**
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个匿名类中，我们将处理标记为**Tint**的复选框。
- en: Changing the color
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改颜色
- en: In the `onCheckedChanged` method, we use the `setColorFilter` method in `imageView`
    to overlay a color layer on the image. When `isChecked` is true, we layer a color,
    and when `isChecked` is false, we remove it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCheckedChanged`方法中，我们使用`imageView`中的`setColorFilter`方法在图像上叠加一个颜色层。当`isChecked`为true时，我们叠加一个颜色，当`isChecked`为false时，我们移除它。
- en: The `setColorFilter` method takes a color in `argb`, of the `Color` class. The
    four arguments of the `argb` method are, as you might expect, values for alpha,
    red, green, and blue. These four values create a color. In our case, the value
    of `150`, `255`, `0`, `0` creates a strong red tint. Alternatively, the value
    of `0`, `0`, `0`, `0` creates no tint at all.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`setColorFilter`方法接受`Color`类中的`argb`颜色。`argb`方法的四个参数分别是alpha、red、green和blue的值。这四个值创建了一种颜色。在我们的情况下，值`150`，`255`，`0`，`0`创建了强烈的红色色调。另外，值`0`，`0`，`0`，`0`则完全没有色调。'
- en: Important note
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: 'To understand more about the `Color` class, check out the Android developer
    site at [http://developer.android.com/reference/android/graphics/Color.html](http://developer.android.com/reference/android/graphics/Color.html).
    Additionally, to understand the RGB color system in more detail, please refer
    to the following Wikipedia page: [https://en.wikipedia.org/wiki/RGB_color_model](https://en.wikipedia.org/wiki/RGB_color_model).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`Color`类的信息，请访问Android开发者网站[http://developer.android.com/reference/android/graphics/Color.html](http://developer.android.com/reference/android/graphics/Color.html)。此外，要更详细地了解RGB颜色系统，请参考以下维基百科页面：[https://en.wikipedia.org/wiki/RGB_color_model](https://en.wikipedia.org/wiki/RGB_color_model)。
- en: 'Add this code after the previous block of code in the `onCreate` method:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中的上一个代码块之后添加以下代码：
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now we will look at how to scale the UI.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看看如何调整UI的比例。
- en: Changing the size
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改大小
- en: In the anonymous class that handles the labeled `setScaleX` method to resize
    the robot image. When we call `setScaleX(2)` and `setScaleY(2)` in `imageView`,
    we will double the size of the image, and `setScaleX(1)` and `setScaleY(1)` will
    return it to normal.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理标记为`setScaleX`方法的匿名类中，可以调整机器人图像的大小。当我们在`imageView`中调用`setScaleX(2)`和`setScaleY(2)`时，我们将使图像的大小加倍，而`setScaleX(1)`和`setScaleY(1)`将使其恢复正常。
- en: 'Add this code after the previous block of code in the `onCreate` method:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中的上一个代码块之后添加以下代码：
- en: '[PRE28]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now we will handle the three radio buttons.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将处理这三个单选按钮。
- en: Coding the radio buttons
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写单选按钮
- en: As they are part of a `RadioGroup` widget, we can handle them much more succinctly
    than we did the `CheckBox` objects. Here is how we do it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是`RadioGroup`小部件的一部分，我们可以处理它们的方式比处理`CheckBox`对象要简洁得多。我们是这样做的。
- en: First, we make sure they are clear to start with, by calling `clearCheck()`
    in `radioGroup`. Then, we create our anonymous class of the `OnCheckedChangedListener`
    type and override the `onCheckedChanged` method.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确保它们一开始是清除的，通过在`radioGroup`中调用`clearCheck()`。然后，我们创建`OnCheckedChangedListener`类型的匿名类，并重写`onCheckedChanged`方法。
- en: This method will be called when any `RadioButton` widget from `RadioGroup` is
    clicked on. All we need to do is get the `id` property of the `RadioButton` widget
    that was clicked on and respond accordingly. We can achieve this by using a `switch`
    statement with three possible cases, one for each `RadioButton`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击`RadioGroup`中的任何`RadioButton`小部件时，将调用此方法。我们需要做的就是获取被点击的`RadioButton`小部件的`id`属性，并做出相应的响应。我们可以通过使用一个`switch`语句来实现这一点，有三种可能的情况，每种情况对应一个`RadioButton`。
- en: 'You will remember that when we first talked about `RadioButton` widgets, we
    mentioned that the value supplied in the `checkedId` parameter of the `onCheckedChanged`
    method is an integer. This is why we must first create a new `RadioButton` instance
    from the `checkedId` parameter:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您会记得当我们第一次谈论`RadioButton`小部件时，我们提到`onCheckedChanged`方法的`checkedId`参数中提供的值是一个整数。这就是为什么我们必须首先从`checkedId`参数创建一个新的`RadioButton`实例的原因：
- en: '[PRE29]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we can call `getId` on the new `RadioButton` instance as the condition
    for the `switch` block:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在新的`RadioButton`实例上调用`getId`作为`switch`块的条件：
- en: '[PRE30]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Then, in each `case` option, we use the `setTimeZone` method with the proper
    Android time zone code as an argument.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在每个`case`选项中，我们使用带有适当Android时区代码的`setTimeZone`方法。
- en: Tip
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can view all the Android time zone codes at [https://gist.github.com/arpit/1035596](https://gist.github.com/arpit/1035596).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://gist.github.com/arpit/1035596](https://gist.github.com/arpit/1035596)查看所有Android时区代码。
- en: 'Take a look at the following code, which incorporates everything we just discussed.
    Add it to the `onCreate` method after the previous code that we entered to handle
    the checkboxes:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码，它包含了我们刚刚讨论的所有内容。在先前输入的处理复选框的代码之后，将其添加到`onCreate`方法中：
- en: '[PRE31]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now for something a little bit new.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来点新鲜的东西。
- en: Using an anonymous class for a regular Button
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用匿名类处理普通按钮
- en: In the next block of code, we will write and use an anonymous class to handle
    the clicks on a regular `Button`. We call `button.setOnclickListener` just as
    we have done so before. However, this time, instead of passing `this` as an argument,
    we create a brand-new class of the `View.OnClickListener` type and override the
    `onClick` method as the argument – just like we did with our other anonymous classes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一段代码中，我们将编写并使用一个匿名类来处理普通`Button`的点击。我们调用`button.setOnclickListener`，就像以前一样。但是，这一次，我们不是像以前那样将`this`作为参数传递，而是创建一个全新的`View.OnClickListener`类型的类，并覆盖`onClick`方法作为参数
    - 就像我们以前的其他匿名类一样。
- en: Tip
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: This method is preferable in this situation because there is only one button.
    If we had lots of buttons, then having `MainActivity` implement `View.OnClickListener`,
    and then overriding the `onClick` method to handle all clicks in one method, would
    probably be preferable, as we have done previously.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这种方法是可取的，因为只有一个按钮。如果我们有很多按钮，那么让`MainActivity`实现`View.OnClickListener`，然后覆盖`onClick`方法以处理所有点击的方法可能更可取，就像我们以前做过的那样。
- en: In the `onClick` method, we use the `setText` method to set the `text` property
    on `textView` and the `getText` method of `editText` to get whatever text is currently
    in the `EditText` widget.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onClick`方法中，我们使用`setText`方法在`textView`上设置`text`属性，并使用`editText`的`getText`方法获取`EditText`小部件中当前的文本。
- en: 'Add the following code after the previous block of code in the `onCreate` method:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中的先前代码块之后添加以下代码：
- en: '[PRE32]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Coding the Switch widget
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写Switch小部件
- en: Next, we will create yet another anonymous class to listen for and handle changes
    to our `Switch` widget.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建另一个匿名类来监听和处理`Switch`小部件的更改。
- en: When the `isChecked` variable is `true`, we show `textView`; when it is `false`,
    we hide it.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当`isChecked`变量为`true`时，我们显示`textView`；当它为`false`时，我们隐藏它。
- en: 'Add the following code after the previous block of code in the `onCreate` method:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中的先前代码块之后添加以下代码：
- en: '[PRE33]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now we can move on to the `WebView` widget.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续进行`WebView`小部件。
- en: Using WebView
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WebView
- en: Your manifest must include the `INTERNET` permission. This is how we add it.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您的清单必须包括`INTERNET`权限。这是我们添加它的方式。
- en: 'Open the `AndroidManifest.xml` file, and add the following line of highlighted
    code, which is shown with a bit of context:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`AndroidManifest.xml`文件，并添加以下突出显示的代码行，显示了一些上下文：
- en: '[PRE34]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we will add two more lines of code in order to grab a reference to
    the `WebView` widget and load up a website. It should be a relatively straightforward
    process to modify the code in order to load any website that you like. Add the
    following lines of code to the end of the `onCreate` method:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加另外两行代码，以便获取对`WebView`小部件的引用并加载网站。修改代码以加载您喜欢的任何网站应该是一个相对简单的过程。在`onCreate`方法的末尾添加以下代码行：
- en: '[PRE35]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now we can run our app and try out all the features.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行我们的应用程序并尝试所有功能。
- en: Running the Widget Exploration app
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Widget Exploration应用程序
- en: Run the app in the usual way, making sure that you use your tablet emulator.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以通常的方式在平板模拟器上运行应用程序。
- en: Tip
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The Android emulators can be rotated into landscape mode by pressing the *Ctrl
    + F11* keyboard combination on a PC or *Ctrl + fn+ F11* on a Mac.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Android模拟器可以通过在PC上按下*Ctrl + F11*键组合或在Mac上按下*Ctrl + fn+ F11*来旋转为横向模式。
- en: 'Here is the entire app, including the `WebView` widget, which is now visible:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这是整个应用程序，包括现在可见的`WebView`小部件：
- en: '![Figure 13.12 – Final app layout'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.12 - 最终应用程序布局'
- en: '](img/Figure_13.12_B16773.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.12_B16773.jpg)'
- en: Figure 13.12 – Final app layout
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12 - 最终应用程序布局
- en: 'Try checking the radio buttons to see the time zone change on the clock. In
    the following diagram, I have Photoshopped a few cropped screenshots together
    to show that the time changes when a new time zone is selected:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试选中单选按钮，看看时区在时钟上的变化。在下图中，我将一些裁剪的屏幕截图合在一起，以显示选择新时区时时间的变化：
- en: '![Figure 13.13 – Time zones'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.13 - 时区'
- en: '](img/Figure_13.13_B16773.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.13_B16773.jpg)'
- en: Figure 13.13 – Time zones
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.13 - 时区
- en: 'To test out the **CAPTURE** button, the editable text, and the switch, follow
    these steps (we have also listed them in the adjoining screenshot):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试**CAPTURE**按钮、可编辑文本和开关，请按照以下步骤进行（我们也在相邻的屏幕截图中列出了它们）：
- en: Enter different values into the `EditText` widget (which is on the left).
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EditText`小部件（位于左侧）中输入不同的值。
- en: Click on the **CAPTURE** button.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**CAPTURE**按钮。
- en: Make sure that the `Switch` widget is on.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`Switch`小部件是打开的。
- en: 'View the message:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看消息：
- en: '![Figure 13.14 – Testing the CAPTURE button'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.14 - 测试CAPTURE按钮'
- en: '](img/Figure_13.14_B16773.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.14_B16773.jpg)'
- en: Figure 13.14 – Testing the CAPTURE button
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14 - 测试CAPTURE按钮
- en: 'You can change what the preceding diagram looks like with different combinations
    of checked and unchecked checkboxes, and you can hide and show the `TextView`
    widget by using the switch above it. The following screenshot shows what happens
    to the `ImageView` widget when you have the **Tint** and **Re-size** options selected:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过不同的选中和未选中复选框的组合来更改前面的图表外观，并且您可以使用上面的开关来隐藏和显示`TextView`小部件。以下屏幕截图显示了当您选择**Tint**和**Re-size**选项时`ImageView`小部件会发生什么：
- en: '![Figure 13.15 – Testing the ImageView widget'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.15 - 测试ImageView小部件'
- en: '](img/Figure_13.15_B16773.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.15_B16773.jpg)'
- en: Figure 13.15 – Testing the ImageView widget
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.15 - 测试ImageView小部件
- en: Oops! The size of the icon has been increased so much that it overlaps with
    the **Re-size** checkbox.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕！图标的大小增加得太多，以至于它与**Re-size**复选框重叠。
- en: Tip
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Transparency doesn't show very clearly in a printed book, so I haven't shown
    a visual example of the **Transparency** box being checked. Be sure to try this
    out on an emulator or real device.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 透明度在印刷书籍中并不清晰，所以我没有展示“透明度”框被选中的视觉示例。一定要在模拟器或真实设备上尝试一下。
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have learned so much in this chapter, and we have explored a plethora of
    widgets. We learned how to implement widgets in Java code without any XML, and
    we used our first anonymous classes to handle clicks on a widget and put all our
    new widget prowess into a working app.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了很多，并且探索了大量的小部件。我们学会了如何在Java代码中实现小部件而不需要任何XML，并且我们使用了我们的第一个匿名类来处理小部件上的点击，并将我们所有新的小部件技能应用到一个工作中的应用程序中。
- en: Now, let's move on to look at another way in which we can significantly enhance
    our UIs.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续看看另一种显著增强我们UI的方式。
- en: In the next chapter, we will look at a totally new UI element that we can't
    simply drag and drop from the palette, but we will still have plenty of help from
    the Android API. Next up are dialog windows. Additionally, we will also make a
    start on our most significant app so far, the Note to Self app, for memos, to-do
    lists, and personal notes.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到一个全新的UI元素，我们不能简单地从调色板中拖放，但我们仍然会得到来自Android API的大量帮助。接下来是对话框窗口。此外，我们还将开始制作迄今为止最重要的应用程序，即备忘录、待办事项列表和个人笔记的“自我备忘录”应用程序。
