- en: 12\. Dependency Injection with Dagger and Koin
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12. 使用Dagger和Koin进行依赖注入
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter covers the concept of dependency injection and the benefits it
    provides to an Android application. We will look at how we can perform dependency
    injection manually with the help of container classes. We will also cover some
    of the frameworks available for Android, Java, and Kotlin that can help developers
    when it comes to applying this concept. By the end of this chapter, you will be
    able to use Dagger and Koin to manage your app's dependencies, and you will know
    how to organize them efficiently.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了依赖注入的概念以及它为Android应用程序提供的好处。我们将看看如何通过容器类手动执行依赖注入。我们还将介绍一些可用于Android、Java和Kotlin的框架，这些框架可以帮助开发人员应用这一概念。通过本章的学习，您将能够使用Dagger和Koin来管理应用程序的依赖项，并且将知道如何有效地组织它们。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we looked at how to structure code into different components,
    including ViewModels, repositories, API components, and persistence components.
    One of the difficulties that always emerged was the dependencies between all of
    these components, especially when it came to how we approached the unit tests
    for them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何将代码结构化为不同的组件，包括ViewModels、repositories、API组件和持久性组件。其中一个经常出现的困难是所有这些组件之间的依赖关系，特别是当我们为它们编写单元测试时。
- en: We have constantly used the `Application` class to create instances of these
    components and pass them in the constructors of the components one layer above
    (we created the API and Room instances, then the Repository instances, and so
    on). What we were doing was a simplistic version of dependency injection.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直使用`Application`类来创建这些组件的实例，并将它们传递给上一层组件的构造函数（我们创建了API和Room实例，然后是Repository实例，依此类推）。我们所做的是依赖注入的简化版本。
- en: '`ViewModels`). The reason for this is to increase the reusability and testability
    of the code and to shift the responsibility for creating instances from our components
    to the `Application` class. One of the benefits of DI comes with regard to how
    objects are created across the code base. DI separates the creation of an object
    from its usage. In other words, one object shouldn''t care how another object
    is created; it should only be concerned with the interaction with the other object.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModels`）。这样做的原因是为了增加代码的可重用性和可测试性，并将创建实例的责任从我们的组件转移到`Application`类。DI的一个好处在于对象在整个代码库中的创建方式。DI将对象的创建与其使用分离。换句话说，一个对象不应该关心另一个对象是如何创建的；它只应该关心与另一个对象的交互。'
- en: 'In this chapter, we will analyze three ways of how we can inject dependencies
    in Android: manual DI, Dagger, and Koin.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将分析在Android中注入依赖项的三种方式：手动DI、Dagger和Koin。
- en: '**Manual DI** is a technique in which developers handle DI manually by creating
    container classes. In this chapter, we will look over how we can do this in Android.
    By studying how we manually manage dependencies, we will get some insight into
    how other DI frameworks operate and get a basis for how we can integrate these frameworks.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**手动DI**是一种技术，开发人员通过创建容器类来手动处理DI。在本章中，我们将看看如何在Android中实现这一点。通过研究我们如何手动管理依赖项，我们将了解其他DI框架的运作方式，并为我们如何集成这些框架奠定基础。'
- en: '**Dagger** is a DI framework developed for Java. It allows you to group your
    dependencies in different **modules**. You can also define **components**, where
    the modules are added in order to create the dependency graph, and which Dagger
    automatically implements in order to perform the injection. It relies on annotation
    processors to generate the necessary code in order to perform the injection.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dagger**是为Java开发的DI框架。它允许您将依赖项分组到不同的**模块**中。您还可以定义**组件**，在这些组件中添加模块以创建依赖图，Dagger会自动实现以执行注入。它依赖于注解处理器来生成必要的代码以执行注入。'
- en: '**Koin** is a lightweight DI library developed for Kotlin. It doesn''t rely
    on annotation processors; it relies on Kotlin''s mechanisms to perform the injection.
    Here we can also split dependencies into **modules**.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Koin**是为Kotlin开发的轻量级DI库。它不依赖于注解处理器；它依赖于Kotlin的机制来执行注入。在这里，我们还可以将依赖项拆分成**模块**。'
- en: In what follows, we will explore how both these libraries work and the steps
    required to add them to a simple Android application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨这两个库的工作原理以及将它们添加到简单Android应用程序所需的步骤。
- en: Manual DI
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动DI
- en: In order to understand how DI works, we can first analyze how we can manually
    inject dependencies into different objects across an Android application. This
    can be achieved by creating container objects that will contain the dependencies
    required across the app. You can also create multiple containers representing
    different scopes that are required across the application. Here, you can define
    dependencies that will only be required as long as a particular screen is displayed,
    and when the screen is destroyed, the instances can also be garbage collected.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解DI的工作原理，我们可以首先分析如何在Android应用程序中手动注入依赖项到不同的对象中。这可以通过创建包含应用程序中所需依赖项的容器对象来实现。您还可以创建代表应用程序中所需不同范围的多个容器。在这里，您可以定义只在特定屏幕显示时才需要的依赖项，并且当屏幕被销毁时，实例也可以被垃圾回收。
- en: 'A sample of a container that will hold instances as long as an application
    lives is shown here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一个将持续存在应用程序的实例的容器示例：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An `Application` class using that container looks something like the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该容器的`Application`类如下所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see in the preceding example, the responsibility for creating the
    dependencies shifted from the `Application` class to the `Container` class. Activities
    across the code base can still access the dependencies using the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的示例中所看到的，创建依赖项的责任已经从`Application`类转移到了`Container`类。代码库中的活动仍然可以使用以下命令访问依赖项：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Modules with a limited scope could be used for something such as creating `ViewModel`
    factories, which, in turn, are used by the framework to create `ViewModel`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 具有有限范围的模块可以用于创建`ViewModel`工厂之类的东西，这些工厂又被框架用来创建`ViewModel`：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This particular container can be used by an activity or fragment to initialize `ViewModel`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的容器可以被一个活动或片段用来初始化`ViewModel`：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Again, we see here that the responsibility of creating the `Factory` class was
    shifted from the `Activity` class to the `Container` class. `MyContainer` could
    be expanded to provide instances required by `MyActivity` in situations where
    the life cycle of those instances should be the same as the activity, or the constructor
    could be expanded to provide instances with a different life cycle.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们在这里看到，创建`Factory`类的责任已从`Activity`类转移到`Container`类。`MyContainer`可以扩展以在需要的情况下提供与活动相同的实例，或者构造函数可以扩展以提供具有不同生命周期的实例。
- en: Now, let's apply some of these examples to an exercise.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将其中一些示例应用于练习。
- en: 'Exercise 12.01: Manual Injection'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.01：手动注入
- en: 'In this exercise, we will write an Android application that will apply the
    concept of manual DI. The application will have a Repository, which will generate
    a random number and a `ViewModel` object with a `LiveData` object responsible
    for retrieving the number generated by the Repository and publishing it in the
    `LiveData` object. In order to do so, we will need to create two containers that
    will manage the following dependencies:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个应用程序，应用手动DI的概念。该应用程序将具有一个存储库，该存储库将生成一个随机数，并具有一个`ViewModel`对象，其中包含一个`LiveData`对象，负责检索存储库生成的数字并在`LiveData`对象中发布它。为了做到这一点，我们需要创建两个管理以下依赖项的容器：
- en: Repository
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库
- en: A `ViewModel` factory responsible for creating `ViewModel`
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责创建`ViewModel`的`ViewModel`工厂
- en: 'The app itself will display the randomly generated number each time a button
    is clicked:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序本身将在每次点击按钮时显示随机生成的数字：
- en: 'Let''s start by adding the `ViewModel` and `LiveData` library to the `app/build.gradle`
    file:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先将`ViewModel`和`LiveData`库添加到`app/build.gradle`文件中：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, let''s write a `NumberRepository` interface, which will contain a method
    to retrieve an integer:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们编写一个`NumberRepository`接口，其中将包含一个检索整数的方法：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we will provide the implementation for this. We can use the `java.util.Random`
    class to generate a random number:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将为此提供实现。我们可以使用`java.util.Random`类来生成随机数：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will now move on to the `MainViewModel` class, which will contain a `LiveData`
    object containing each generated number from the repository:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将继续创建`MainViewModel`类，其中将包含一个包含存储库中每个生成的数字的`LiveData`对象：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, let''s move on to create our UI containing `TextView` for displaying
    the number and `Button` for generating the next random number. This will be part
    of the `res/layout/activity_main.xml` file:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们继续创建包含用于显示数字的`TextView`和用于生成下一个随机数字的`Button`的UI。这将成为`res/layout/activity_main.xml`文件的一部分：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Make sure to add the string for the button to the `res/values/strings.xml` file:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将按钮的字符串添加到`res/values/strings.xml`文件中：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And now let''s create the `MainActivity` class responsible for rendering the
    preceding UI:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建负责呈现前述UI的`MainActivity`类：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s create our `Application` class:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的`Application`类：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s also add the `Application` class to the `AndroidManifest.xml` file in
    the `application` tag:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还将`Application`类添加到`AndroidManifest.xml`文件中的`application`标签中：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s create our first container responsible for managing the `NumberRepository`
    dependency:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的第一个容器，负责管理`NumberRepository`依赖项：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s add this container to the `RandomApplication` class:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将此容器添加到`RandomApplication`类中：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We now move on to creating `MainContainer`, which will need a reference to
    the `NumberRepository` dependency and will provide a dependency to the `ViewModel`
    factory required to create `MainViewModel`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在继续创建`MainContainer`，它将需要引用`NumberRepository`依赖项，并将提供一个依赖项给创建`MainViewModel`所需的`ViewModel`工厂：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we can modify `MainActivity` to inject our dependencies from our containers
    and connect the UI elements in order to display the output:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以修改`MainActivity`以从我们的容器中注入依赖项，并连接UI元素以显示输出：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the highlighted code, we can see that we are using the repository defined
    in `ApplicationContainer` and injecting it into `MainContainer`, which will then
    inject it into `ViewModel` through `ViewModelProvider.Factory`. The preceding
    example should render the output presented in *Figure 12.1*:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在突出显示的代码中，我们可以看到我们正在使用`ApplicationContainer`中定义的存储库，并将其注入到`MainContainer`中，然后通过`ViewModelProvider.Factory`将其注入到`ViewModel`中。前面的示例应该呈现出*图12.1*中呈现的输出：
- en: '![Figure 12.1: Emulator output of Exercise 12.01 displaying a randomly generated
    number'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1：练习12.01的模拟器输出，显示随机生成的数字'
- en: '](img/B15216_12_01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_12_01.jpg)'
- en: 'Figure 12.1: Emulator output of Exercise 12.01 displaying a randomly generated
    number'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：练习12.01的模拟器输出，显示随机生成的数字
- en: Manual DI is an easy way to set up your dependencies in situations where the
    app is small, but it can become extremely difficult as the app grows. Imagine
    if, in *Exercise 12.01*, *Manual Injection*, we had two classes that extended
    from `NumberRepository`. How would we handle such a scenario? How would developers
    know which one went in what activity? These types of questions become very common
    in most of the well-known apps on Google Play, which is why manual DI is rarely
    used. When used, it will probably take the form of a DI framework similar to the
    ones we will look over next.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 手动DI是在应用程序较小的情况下设置依赖项的一种简单方法，但随着应用程序的增长，它可能变得非常困难。想象一下，在*练习12.01*，*手动注入*中，我们有两个类都扩展自`NumberRepository`。我们将如何处理这种情况？开发人员如何知道哪个类适用于哪个活动？这些类型的问题在Google
    Play上大多数知名应用程序中变得非常普遍，这就是为什么很少使用手动DI。在使用时，它可能会采用我们接下来将要查看的DI框架类似的形式。
- en: Dagger
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dagger
- en: 'Dagger offers a comprehensive way to organize your application''s dependencies.
    It has the advantage of being adopted first on Android by the developer community
    before Kotlin was introduced. This is one of the reasons that many Android applications
    use Dagger as their DI framework. Another advantage the framework holds is for
    Android projects written in Java, because the library is developed in the same
    language. The framework was initially developed by Square (Dagger 1) and later
    transitioned to Google (Dagger 2). We will cover Dagger 2 in this chapter and
    describe its benefits. Some of the key functionalities Dagger 2 provides are the
    following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Dagger提供了一种全面组织应用程序依赖关系的方式。它在Kotlin引入之前首先被Android开发者社区采用，这是许多Android应用程序将Dagger作为它们的DI框架的原因之一。该框架的另一个优势是对于用Java编写的Android项目，因为该库也是用相同的语言开发的。该框架最初由Square（Dagger
    1）开发，后来过渡到了Google（Dagger 2）。我们将在本章中介绍Dagger 2并描述其优势。Dagger 2提供的一些关键功能包括：
- en: Injection
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入
- en: Dependencies grouped in modules
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化的依赖项
- en: Components used to generate dependency graphs
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于生成依赖图的组件
- en: Qualifiers
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限定符
- en: Scopes
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域
- en: Subcomponents
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子组件
- en: 'Annotations are the key elements when dealing with Dagger, because it generates
    the code required to perform the DI through an annotation processor. The main
    annotations can be grouped as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注解是处理Dagger时的关键元素，因为它生成所需的代码来执行通过注解处理器进行DI。主要注解可以分为以下几类：
- en: '`@Module` are responsible for providing an object (dependent object) that can
    be injected.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Module`负责提供可以被注入的对象（依赖对象）。'
- en: '`@Inject` annotation is used to define a dependency.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Inject`注解用于定义依赖关系。'
- en: '`@Component`-annotated interface defines the connection between the provider
    and the consumer.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Component`注解的接口定义了提供者和消费者之间的连接。'
- en: 'In order to add Dagger to your project, in the `app/build.gradle` file, you
    will need the following dependencies:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将Dagger添加到您的项目中，在`app/build.gradle`文件中，您将需要以下依赖项：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Since we are dealing with annotation processors, in the same `build.gradle`
    file, you will need to add the plugin for them:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理注解处理器，在同一个`build.gradle`文件中，您需要为它们添加插件：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Consumers
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费者
- en: 'Dagger uses `javax.inject.Inject` to identify objects that require injection.
    There are multiple ways to inject dependencies, but the recommended ways are through
    constructor injection and field injection. Constructor injection looks similar
    to the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Dagger使用`javax.inject.Inject`来识别需要注入的对象。有多种注入依赖的方式，但推荐的方式是通过构造函数注入和字段注入。构造函数注入看起来类似于以下代码：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When constructors are annotated with `@Inject`, Dagger will generate `Factory`
    classes that will be responsible for instantiating the objects. In the example
    of `ClassB`, Dagger will try to find the appropriate dependencies that fit the
    signature of the constructor, which, in this example, is `ClassA`, which Dagger
    already created an instance for.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当构造函数被`@Inject`注解时，Dagger将生成`Factory`类来负责实例化对象。在`ClassB`的示例中，Dagger将尝试找到符合构造函数签名的适当依赖项，而在这个例子中，就是`ClassA`，而Dagger已经为其创建了一个实例。
- en: 'If you do not want Dagger to manage the instantiation of `ClassB` but still
    have the dependency to `ClassA` injected, you can use field injection and it will
    look something like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不希望Dagger管理`ClassB`的实例化，但仍然希望注入对`ClassA`的依赖关系，您可以使用字段注入，代码看起来会像这样：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this case, Dagger will generate the necessary code just to inject the dependency
    between `ClassB` and `ClassA`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Dagger将生成必要的代码来注入`ClassB`和`ClassA`之间的依赖关系。
- en: Providers
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供者
- en: 'You will find yourself in situations where your application uses external dependencies.
    That means that you will not be able to provide instances through constructor
    injections. Another situation where constructor injection is not possible is when
    interfaces or abstract classes are used. In this situation, Dagger offers the
    possibility to provide the instance using the `@Provides` annotation. You will
    then need to group the methods where instances are provided into modules annotated
    with `@Module`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现自己处于应用程序使用外部依赖的情况。这意味着您将无法通过构造函数注入提供实例。另一种构造函数注入不可能的情况是使用接口或抽象类。在这种情况下，Dagger提供了使用`@Provides`注解来提供实例的可能性。然后，您需要将提供实例的方法分组到用`@Module`注解的模块中：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see in the preceding example, `ClassA` and `ClassB` don't have any
    Dagger annotations. A module was created that will provide the instance for `ClassA`,
    which will then be used to provide the instance for `ClassB`. In this case, Dagger
    will generate a `Factory` class for each of the `@Provides` annotated methods.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，`ClassA`和`ClassB`没有任何Dagger注解。创建了一个模块，将为`ClassA`提供实例，然后用于提供`ClassB`的实例。在这种情况下，Dagger将为每个`@Provides`注解的方法生成一个`Factory`类。
- en: Connectors
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接器
- en: 'Assuming we will have multiple modules, we will need to combine them in a graph
    of dependencies that can be used across the application. Dagger offers the `@Component`
    annotation. This is usually used for an interface or an abstract class that will
    be implemented by Dagger. Along with assembling the dependency graph, components
    also offer the functionality to add methods to inject dependencies into a certain
    object''s members. In components, you can specify provision methods that return
    dependencies provided in the modules:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将有多个模块，我们需要将它们组合成一个依赖图，可以在整个应用程序中使用。Dagger提供了`@Component`注解。这通常用于由Dagger实现的接口或抽象类。除了组装依赖图之外，组件还提供了向某个对象的成员注入依赖的功能。在组件中，您可以指定返回模块中提供的依赖项的提供方法：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For the preceding `Component`, Dagger will generate a `DaggerMyComponent` class
    and we can build it as described in the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的`Component`，Dagger将生成一个`DaggerMyComponent`类，并且我们可以按照以下代码进行构建：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `Application` class will create the Dagger dependency graph and component.
    The `inject` method in `Component` allows us to perform DI on the variables in
    the `Application` class annotated with `@Inject`, giving us access to the `ClassB`
    object defined in the module.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application`类将创建Dagger依赖项图和组件。`Component`中的`inject`方法允许我们对`Application`类中用`@Inject`注释的变量执行DI，从而让我们访问模块中定义的`ClassB`对象。'
- en: Qualifiers
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限定符
- en: 'If you want to provide multiple instances of the same class (such as injecting
    different Strings or Integers across an application), you can use qualifiers.
    These are annotations that can help you identify instances. One of the most common
    ones is the `@Named` qualifier, as described in the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要提供同一类的多个实例（例如在整个应用程序中注入不同的字符串或整数），可以使用限定符。这些是可以帮助您标识实例的注释。其中最常见的是`@Named`限定符，如下面的代码所述：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this example, we create two instances of `ClassA` and we give them different
    names. We then use the first instance whenever possible to create `ClassB`. We
    can also create custom qualifiers instead of the `@Named` annotation, as described
    in the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们创建了两个`ClassA`的实例，并为它们分配了不同的名称。然后，我们尽可能使用第一个实例来创建`ClassB`。我们还可以创建自定义限定符，而不是`@Named`注释，如下面的代码所述：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The module can be updated like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像这样更新模块：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Scopes
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域
- en: 'If you want to keep track of the life cycle of your components and your dependencies,
    you can use scopes. Dagger offers a `@Singleton` scope. This usually indicates
    that your component will live as long as your application will. Scoping has no
    impact on the life cycle of the objects; they are built to help developers identify
    the life cycles of objects. It is recommended to give your components one scope
    and group your code to reflect that scope. Some common Dagger scopes on Android
    are related to the activity or fragment:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要跟踪组件和依赖项的生命周期，可以使用作用域。Dagger提供了`@Singleton`作用域。这通常表示您的组件将与应用程序一样长。作用域对对象的生命周期没有影响；它们旨在帮助开发人员识别对象的生命周期。建议为组件指定一个作用域，并将代码分组以反映该作用域。Android上一些常见的Dagger作用域与活动或片段相关：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The annotation can be used in the module where the dependency is provided:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注释可以在提供依赖项的模块中使用：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The code for `Component` will be as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Component`的代码将如下所示：'
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding example would indicate that `Component` can only use objects with
    the same scope. If any of the modules that are part of this `Component` contain
    dependencies with different scopes, Dagger will throw an error indicating that
    there is something wrong with the scopes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例表明`Component`只能使用具有相同作用域的对象。如果此`Component`的任何模块包含具有不同作用域的依赖项，Dagger将抛出错误，指示作用域存在问题。
- en: Subcomponents
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子组件
- en: Something that goes hand-in-hand with scopes is subcomponents. They allow you
    to organize your dependencies for smaller scopes. One common use case on Android
    is to create subcomponents for activities and fragments. Subcomponents inherit
    dependencies from the parent and they generate a new dependency graph for the
    scope of the subcomponent.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与作用域紧密相关的是子组件。它们允许您为较小的作用域组织您的依赖项。Android上的一个常见用例是为活动和片段创建子组件。子组件从父组件继承依赖项，并为子组件的作用域生成新的依赖项图。
- en: 'Let''s assume we have a separate module:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们有一个单独的模块：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'A `Subcomponent` that will generate a dependency graph for that module would
    look something like the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将为该模块生成依赖项图的`Subcomponent`将如下所示：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The parent component would need to declare the new component, as shown in the
    following code snippet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件需要声明新组件，如下面的代码片段所示：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And you can inject `ClassC` into your activity as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`ClassC`注入到您的活动中，如下所示：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With this knowledge, let's move on to an exercise.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，让我们继续进行练习。
- en: 'Exercise 12.02: Dagger Injection'
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.02：Dagger注入
- en: 'In this exercise, we will write an Android application that will apply the
    concept of DI with Dagger. The application will have the same `Repository` and
    `ViewModel` defined in *Exercise 12.01*, *Manual Injection*. We will need to use
    Dagger to expose the same two dependencies:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个Android应用程序，该应用程序将应用Dagger的DI概念。该应用程序将具有与“Exercise 12.01”，“手动注入”中定义的相同的`Repository`和`ViewModel`。我们需要使用Dagger来公开相同的两个依赖项：
- en: '`Repository`: This will have the `@Singleton` scope and will be provided by
    `ApplicationModule`. Now, `ApplicationModule` will be exposed as part of `ApplicationComponent`.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Repository`：这将具有`@Singleton`作用域，并将由`ApplicationModule`提供。现在，`ApplicationModule`将作为`ApplicationComponent`的一部分公开。'
- en: '`ViewModelProvider.Factory`: This will have the custom-defined scope named
    `MainScope` and will be provided by `MainModule`. Now, `MainModule` will be exposed
    by `MainSubComponent`. Also, `MainSubComponent` will be generated by `ApplicationComponent`.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewModelProvider.Factory`：这将具有名为`MainScope`的自定义作用域，并将由`MainModule`提供。现在，`MainModule`将由`MainSubComponent`公开。此外，`MainSubComponent`将由`ApplicationComponent`生成。'
- en: 'The app itself will display a randomly generated number each time a button
    is clicked:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序本身将在每次单击按钮时显示随机生成的数字：
- en: 'Let''s start by adding Dagger and the `app/build.gradle` file:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在`app/build.gradle`文件中添加Dagger和：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We also need the `kapt` plugin in the `app/build.gradle` module. Attach the
    plugin as shown here:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在`app/build.gradle`模块中添加`kapt`插件。按照以下方式附加插件：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We now need to add the `NumberRepository`, `NumberRepositoryImpl`, `MainViewModel`,
    and `RandomApplication` classes and build our UI with `MainActivity`. This can
    be done by following *Steps 2-9* from *Exercise 12.01*, *Manual Injection*.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要添加`NumberRepository`，`NumberRepositoryImpl`，`MainViewModel`和`RandomApplication`类，并使用`MainActivity`构建我们的UI。可以通过按照“Exercise
    12.01”，“手动注入”的*步骤2-9*来完成。
- en: 'Now, let''s move on to `ApplicationModule`, which will provide the `NumberRepository`
    dependency:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行`ApplicationModule`，它将提供`NumberRepository`依赖项：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s create `MainModule`, which will provide the instance of `ViewModel.Factory`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建`MainModule`，它将提供`ViewModel.Factory`的实例：
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, let''s create `MainScope`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建`MainScope`：
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We will need `MainSubcomponent`, which will use the preceding scope:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要`MainSubcomponent`，它将使用前面的作用域：
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we will require `ApplicationComponent`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将需要`ApplicationComponent`：
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We will need to navigate to `Build` and click on `Rebuild project` in Android
    Studio so that we generate the Dagger code for performing the DI.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要导航到`Build`，在Android Studio中点击`Rebuild project`，以便生成Dagger代码来执行DI。
- en: 'Next, we modify the `RandomApplication` class in order to add the code required
    to initialize the Dagger dependency graph:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们修改`RandomApplication`类，以添加所需的代码来初始化Dagger依赖图：
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We now modify the `MainActivity` class to inject `ViewModelProvider.Factory`
    and initialize `ViewModel` so that we can display the random number:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们修改`MainActivity`类，以注入`ViewModelProvider.Factory`并初始化`ViewModel`，以便显示随机数字：
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you run the preceding code, it will build an application that will display
    a different random output when you click the button:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行上述代码，将构建一个应用程序，当您点击按钮时将显示不同的随机输出：
- en: '![Figure 12.2: Emulator output of Exercise 12.02 displaying a randomly generated
    number'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2：Exercise 12.02的模拟器输出，显示随机生成的数字'
- en: '](img/B15216_12_02.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_12_02.jpg)'
- en: 'Figure 12.2: Emulator output of Exercise 12.02 displaying a randomly generated
    number'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：Exercise 12.02的模拟器输出，显示随机生成的数字
- en: '*Figure 12.2* shows what the application looks like. You can view the generated
    Dagger code in the `app/build` folder:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*图12.2*显示了应用程序的外观。您可以在`app/build`文件夹中查看生成的Dagger代码：'
- en: '![Figure 12.3: Generated Dagger code for Exercise 12.02'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3：Exercise 12.02的生成Dagger代码'
- en: '](img/B15216_12_03.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_12_03.jpg)'
- en: 'Figure 12.3: Generated Dagger code for Exercise 12.02'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：Exercise 12.02的生成Dagger代码
- en: In *Figure 12.3*, we can see the code that Dagger generated in order to satisfy
    the relationship between dependencies. For every dependency that needs to be injected,
    Dagger will generate an appropriate `Factory` class (based on the `Factory` design
    pattern), which will be responsible for creating the dependency. Dagger also looks
    at the places where dependencies will need to be injected and generates an `Injector`
    class, which will have the responsibility of assigning the value to the dependency
    (in this case, it will assign the value to the members annotated with `@Inject`
    in the `MainActivity` class). Finally, Dagger creates implementations for the
    interfaces that have the `@Component` annotation. In the implementation, Dagger
    will handle how the modules are created and also provide a builder in which developers
    can specify how modules can be built.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图12.3*中，我们可以看到Dagger生成的代码，以满足依赖关系。对于每个需要注入的依赖项，Dagger将生成一个适当的`Factory`类（基于`Factory`设计模式），它将负责创建依赖项。Dagger还会查看需要注入依赖项的位置，并生成一个`Injector`类，它将负责为依赖项分配值（在本例中，它将为`MainActivity`类中标有`@Inject`的成员分配值）。最后，Dagger为具有`@Component`注解的接口创建实现。在实现中，Dagger将处理模块的创建，并提供一个构建器，开发人员可以指定如何构建模块。
- en: Dagger Android
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dagger Android
- en: 'In the previous example, you have probably noticed that in the activity, you
    had to call the components and subcomponents to perform the injection. That tends
    to get repetitive in an application. It''s also not recommended for activities
    and fragments to know who is performing the injection. All of this comes from
    the fundamental conflict between Dagger and the Android framework. In Dagger,
    you are responsible for providing and injecting your dependencies. In Android,
    fragments and activities are instantiated by the system. In other words, you cannot
    move the creation of your activity or fragment into a Dagger module and inject
    the dependencies, so you have to resort to building subcomponents. By using subcomponents,
    you then create a dependency between the subcomponent and the activity. Luckily,
    Dagger provides a set of libraries to address these issues for Android, which
    can be added to your `build.gradle` file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您可能已经注意到在活动中，您必须调用组件和子组件来执行注入。这在应用程序中往往会变得重复。也不建议活动和片段知道谁在执行注入。所有这些都来自Dagger和Android框架之间的根本冲突。在Dagger中，您负责提供和注入您的依赖关系。在Android中，片段和活动是由系统实例化的。换句话说，您不能将活动或片段的创建移到Dagger模块中并注入依赖关系，因此您必须求助于构建子组件。通过使用子组件，然后创建子组件和活动之间的依赖关系。幸运的是，Dagger提供了一套库来解决这些Android问题，可以添加到您的`build.gradle`文件中：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The Android Dagger libraries provide specialized injection methods that Dagger
    uses to inject dependencies into activities and fragments. This setup also simplifies
    the dependency setup for simpler projects by eliminating the need for subcomponents.
    A module that would set up the injection into an activity will look something
    like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Android Dagger库提供了专门的注入方法，Dagger使用这些方法将依赖项注入到活动和片段中。这种设置还通过消除子组件的需要，简化了较简单项目的依赖设置。一个设置注入到活动的模块将看起来像这样：
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: (Please note that import statements are not shown for these examples.)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，这些示例中没有显示导入语句。）
- en: 'One important thing here is the introduction of the `@ContributesAndroidInjector`
    annotation, which, when applied to an abstract method, allows Dagger to create
    an implementation in which it will create `AndroidInjector`, which will then be
    used to perform the injection into the activity. The `Application` component will
    need a dedicated `AndroidInjectionModule` or `AndroidSupportInjection` module
    (if you are using the compatibility library to implement your fragments):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个重要事项是引入`@ContributesAndroidInjector`注解，当应用于抽象方法时，允许Dagger创建一个实现，其中它将创建`AndroidInjector`，然后用于对活动进行注入。`Application`组件将需要一个专用的`AndroidInjectionModule`或`AndroidSupportInjection`模块（如果您正在使用兼容库来实现您的片段）：
- en: '[PRE46]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`AndroidSupportInjectionModule` comes from the Dagger Android library and provides
    a set of bindings that prove useful when using the Android framework classes by
    keeping track of the different injectors you''ve added to your `Application`,
    `Activity`, and `Fragment` classes. This is how Dagger will know how each dependency
    should be injected into your activity or fragment.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`AndroidSupportInjectionModule`来自Dagger Android库，并提供了一组绑定，当使用Android框架类时，通过跟踪您添加到`Application`、`Activity`和`Fragment`类的不同注入器，这些绑定会变得有用。这就是Dagger将知道如何将每个依赖项注入到您的活动或片段中。'
- en: 'In your `Application` class, you will need a `HasAndroidInjector` implementation.
    This will be responsible for providing the injection into each of your application''s
    activities. The same rule can be applied if you are using services or `ContentProvider`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`Application`类中，您将需要一个`HasAndroidInjector`实现。这将负责为您的应用程序的每个活动提供注入。如果您正在使用服务或`ContentProvider`，可以应用相同的规则：
- en: '[PRE47]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'What Dagger will do in your `Application` class, in `onCreate()`, is to create
    the graph and inject an `AndroidInjector` object into the `Application` class.
    The `AndroidInjector` object will then be used to inject dependencies into each
    of the specified activities. Finally, in your activity, you can use the `AndroidInjection.inject()`
    method to inject the dependencies. When `inject()` gets called, Dagger will look
    up the injector responsible for DI. If `inject()` gets called from an activity,
    then it will use the application injector. This is the point where the `androidInjector()`
    method from the application will be called by Dagger. If the injector is valid,
    then DI will be performed. If `inject()` is called from a fragment, then Dagger
    will look for an injector in the parent activity. If `inject()` is called from
    a nested fragment, then Dagger will look for an injector in the parent fragment,
    which is why it is only limited to one nested fragment:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Dagger将在您的`Application`类中，在`onCreate()`中创建图形，并将`AndroidInjector`对象注入`Application`类。然后，`AndroidInjector`对象将用于将依赖项注入到每个指定的活动中。最后，在您的活动中，您可以使用`AndroidInjection.inject()`方法来注入依赖项。当调用`inject()`时，Dagger将查找负责DI的注入器。如果从活动中调用`inject()`，那么它将使用应用程序注入器。这是Dagger将调用应用程序中的`androidInjector()`方法的时刻。如果注入器有效，则将执行DI。如果从片段中调用`inject()`，那么Dagger将在父活动中查找注入器。如果从嵌套片段中调用`inject()`，那么Dagger将在父片段中查找注入器，这就是为什么它只限于一个嵌套片段：
- en: '[PRE48]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In order to perform DI in your fragments, a similar principle must be followed
    for each of your activities that was executed previously. Let''s assume that `MyActivity`
    has `MyFragment`. We will need to implement `HasAndroidInjector` for `MyActivity`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在您的片段中执行DI，必须遵循每个先前执行的活动的类似原则。假设`MyActivity`有`MyFragment`。我们将需要为`MyActivity`实现`HasAndroidInjector`：
- en: '[PRE49]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we will need a provider module for our fragment that is similar to the
    provider module for the activity:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将需要一个与活动的提供程序模块类似的片段的提供程序模块：
- en: '[PRE50]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, in `ActivityProviderModule`, you need to add `FragmentProviderModule`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`ActivityProviderModule`中，您需要添加`FragmentProviderModule`：
- en: '[PRE51]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is required for every activity that has fragments that have dependencies
    that require injection.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于每个具有需要注入的依赖项的片段的活动都是必需的。
- en: 'Dagger Android provides a set of classes that have the `HasAndroidInjector`
    implementation. If you wish to avoid implementing the `HasAndroidInjector` method
    in your classes, use some of the following classes: `DaggerApplication`, `DaggerActivity`,
    `DaggerFragment`, and `DaggerSupportFragment`. Using them just requires them to
    be extended instead of `Application`, `Activity`, and so on.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Dagger Android提供了一组具有`HasAndroidInjector`实现的类。如果您希望避免在您的类中实现`HasAndroidInjector`方法，可以使用以下一些类：`DaggerApplication`、`DaggerActivity`、`DaggerFragment`和`DaggerSupportFragment`。只需扩展它们而不是`Application`、`Activity`等即可。
- en: 'Exercise 12.03: Changing Injectors'
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.03：更改注入器
- en: 'In this exercise, we will change *Exercise 12.02*, *Dagger Injection*, to add
    the Android injector features. The output will be to display a randomly generated
    number and the same dependencies will need to be exposed in the following way:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将更改*Exercise 12.02*，*Dagger Injection*，以添加Android注入器功能。输出将显示一个随机生成的数字，并且相同的依赖项需要以以下方式公开：
- en: '`Repository`: This will have the `@Singleton` scope and will be provided by
    `ApplicationModule`. Now, `ApplicationModule` will be exposed as part of `ApplicationComponent`
    (the same as for *Exercise 12.02*, *Dagger Injection*).'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Repository`：这将具有`@Singleton`范围，并将由`ApplicationModule`提供。现在，`ApplicationModule`将作为`ApplicationComponent`的一部分公开（与*Exercise
    12.02*，*Dagger Injection*相同）。'
- en: '`ViewModelProvider.Factory`: This will have the custom-defined scope named
    `MainScope` and will be provided by `MainModule`. Now, `MainModule` will be exposed
    by `MainProviderModule`.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewModelProvider.Factory`：这将具有名为`MainScope`的自定义范围，并将由`MainModule`提供。现在，`MainModule`将由`MainProviderModule`公开。'
- en: The dependencies will be injected into `MainActivity` using the Android injector.
    The Android injector will be added to `RandomApplication` in order for the injection
    to work properly.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项将使用Android注入器注入到`MainActivity`中。Android注入器将被添加到`RandomApplication`中，以便注入正常工作。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: 'Let''s add the Dagger Android dependencies to the `app/build.gradle` file,
    which will make your dependencies look something like this:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将Dagger Android依赖项添加到`app/build.gradle`文件中，这将使您的依赖项看起来像这样：
- en: '[PRE52]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Next, delete the `MainSubcomponent` class.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，删除`MainSubcomponent`类。
- en: 'Create a `MainProviderModule` class, which will provide the `MainActivity` reference:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`MainProviderModule`类，它将提供`MainActivity`的引用：
- en: '[PRE53]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Update `ApplicationComponent` in order to add an `inject` method to the `Application`
    class and to add `ActivityProviderModule` and `AndroidSupportInjectionModule`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`ApplicationComponent`以添加`Application`类的`inject`方法，并添加`ActivityProviderModule`和`AndroidSupportInjectionModule`：
- en: '[PRE54]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Change the `Application` class to implement `HasAndroidInjector` and to have
    Dagger inject an injector object into it:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Application`类更改为实现`HasAndroidInjector`，并让Dagger将一个注入器对象注入其中：
- en: '[PRE55]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In `MainActivity`, replace the old injection with the `AndroidInjection.inject`
    method:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`中，用`AndroidInjection.inject`方法替换旧的注入：
- en: '[PRE56]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The final output will be as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最终输出将如下所示：
- en: '![Figure 12.4: Emulator output of Exercise 12.03 displaying a randomly generated
    number'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4：练习12.03的模拟器输出显示随机生成的数字'
- en: '](img/B15216_12_04.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_12_04.jpg)'
- en: 'Figure 12.4: Emulator output of Exercise 12.03 displaying a randomly generated
    number'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：练习12.03的模拟器输出显示随机生成的数字
- en: 'Have a look at the code generated when the app is built:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序时查看生成的代码：
- en: '![Figure 12.5: Generated Dagger code for Exercise 12.03'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5：练习12.03的生成的Dagger代码'
- en: '](img/B15216_12_05.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_12_05.jpg)'
- en: 'Figure 12.5: Generated Dagger code for Exercise 12.03'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：练习12.03的生成的Dagger代码
- en: Running the preceding code shouldn't change the outcome of the exercise or the
    scope of the dependencies presented in *Figure 12.3*. You can observe how the
    `MainActivity` object no longer has a dependency on the `Application` class or
    any of the components or subcomponents. *Figure 12.5* shows the generated code
    with the Dagger Android injectors. Most of it is similar to the existing one,
    but we can see the generated code for `MainProviderModule`, which actually generates
    a subcomponent.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码不应该改变练习的结果或*图12.3*中呈现的依赖关系的范围。您可以观察到`MainActivity`对象不再依赖于`Application`类或任何组件或子组件。*图12.5*显示了Dagger
    Android注入器的生成代码。其中大部分与现有代码类似，但我们可以看到为`MainProviderModule`生成的代码，它实际上生成了一个子组件。
- en: 'A common setup you will find for Android applications when it comes to organizing
    their dependencies is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及组织其依赖关系时，您将发现Android应用程序的常见设置如下：
- en: '**ApplicationModule**: This is where dependencies common for the entire project
    are defined. Objects such as context, resources, and other Android framework objects
    can be provided here.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ApplicationModule**：这是定义整个项目通用依赖关系的地方。可以在这里提供诸如上下文、资源和其他Android框架对象之类的对象。'
- en: '**NetworkModule**: This is where dependencies related to API calls are stored.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NetworkModule**：这是存储与API调用相关的依赖关系的地方。'
- en: '`DatabaseModule`, `FilesModule`, `SharedPreferencesModule`, and so on.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DatabaseModule`，`FilesModule`，`SharedPreferencesModule`等等。'
- en: '`ViewModels` or `ViewModel` factories are stored.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewModels`或`ViewModel`工厂被存储。'
- en: '`ViewModel`. Here, either subcomponents or Android injectors are used for this
    purpose.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewModel`。在这里，要么使用子组件，要么使用Android注入器来实现这一目的。'
- en: We've raised some questions about how manual DI can go wrong. Now we have seen
    how Dagger can address these issues. Although it does the job, and it does it
    quickly when it comes to performance, it is also a complex framework with a very
    steep learning curve.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提出了一些关于手动DI可能出错的问题。现在我们已经看到了Dagger如何解决这些问题。虽然它能够胜任工作，并且在性能方面做得很快，但它也是一个非常复杂的框架，学习曲线非常陡峭。
- en: Koin
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Koin
- en: Koin is a lighter framework that is suitable for smaller apps. It requires no
    code generation and is built based on Kotlin's functional extensions. It is also
    a **Domain Specific language** (**DSL**). You may have noticed that when using
    Dagger, there's a lot of code that must be written in order to set up the DI.
    Koin's approach to DI solves most of those issues, allowing faster integration.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Koin是一个适用于较小应用的轻量级框架。它不需要代码生成，并且是基于Kotlin的函数扩展构建的。它也是一种**领域特定语言**（**DSL**）。您可能已经注意到，使用Dagger时，必须编写大量代码来设置DI。Koin对DI的处理方式解决了大部分这些问题，可以实现更快的集成。
- en: 'Koin can be added to your project by adding the following dependency to your
    `build.gradle` file:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将以下依赖项添加到您的`build.gradle`文件中将Koin添加到您的项目中：
- en: '[PRE57]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In order to set up Koin in your application, you need the `startKoin` call
    with the DSL syntax:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在您的应用程序中设置Koin，您需要使用DSL语法进行`startKoin`调用：
- en: '[PRE58]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here, you can configure what your application context is (in the `androidContext`
    method), specify property files to define Koin configurations (in the `androidFileProperties`),
    state the Logger Level for Koin, which will output in `LogCat` results of Koin
    operations depending on the Level (in the `androidLogger` method), and list the
    modules your application uses. A similar syntax is used to create the modules:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以配置您的应用程序上下文（在`androidContext`方法中），指定属性文件以定义Koin配置（在`androidFileProperties`中），指定Koin的Logger
    Level，在`LogCat`中输出Koin操作的结果，具体取决于Level（在`androidLogger`方法中），并列出您的应用程序使用的模块。创建模块时使用类似的语法：
- en: '[PRE59]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the preceding example, the two objects will have two different life cycles.
    When a dependency is provided using the **single** notation, then only one instance
    will be used across the entire life cycle of the application. This is useful for
    repositories, databases, and API components, where multiple instances will be
    costly for the application. The **factory** notation will create a new object
    every time an injection is performed. This may be useful in the situation where
    an object needs to live as long as an activity or fragment.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，这两个对象将具有两个不同的生命周期。当使用**single**符号提供依赖项时，那么整个应用程序生命周期内只会使用一个实例。这对于存储库、数据库和API组件非常有用，因为多个实例对应用程序来说成本很高。**factory**符号将在执行注入时创建一个新对象。这在对象需要与活动或片段一样长寿的情况下可能很有用。
- en: 'The dependency can be injected using the `by inject()` method or the `get()`
    method, as shown in the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`by inject()`方法或`get()`方法注入依赖项，如下所示：
- en: '[PRE60]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Koin also offers the possibility of using qualifiers with the help of the `named()`
    method when the module is created. This allows you to provide multiple implementations
    of the same type (for example, providing two or more list objects with different
    content):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Koin还提供了使用`named()`方法和限定符的可能性，当创建模块时可以使用。这允许您提供相同类型的多个实现（例如，提供两个或更多具有不同内容的列表对象）：
- en: '[PRE61]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'One of Koin''s main features for Android applications is scopes for activities
    and fragments and can be defined as shown in the following code snippet:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Koin的一个主要特性是为Android应用程序提供活动和片段的作用域，可以按照以下代码片段中所示进行定义：
- en: '[PRE62]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The preceding example connects the life cycle of the `ClassB` dependency to
    the life cycle of `MainActivity`. In order for you to inject your instance into
    your activity you will need to extend the `ScopeActivity` class. This class is
    responsible for holding a reference as long as the activity lives. Similar classes
    exist for other Android components like Fragments (`ScopeFragment`) and Services
    (`ScopeService`)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例将`ClassB`的生命周期依赖项连接到`MainActivity`的生命周期。为了将实例注入到您的活动中，您需要扩展`ScopeActivity`类。该类负责在活动存在期间保持引用。其他Android组件（如片段（`ScopeFragment`）和服务（`ScopeService`））也存在类似的类。
- en: '[PRE63]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You can inject the instance using the `inject()` method into your activity.
    This is useful in situations where you wish to limit who gets to access the dependency.
    In the preceding example, if another activity had wanted to access the reference
    to `ClassB`, then it wouldn't be able to find it in the scope.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`inject()`方法将实例注入到您的活动中。这在您希望限制谁可以访问依赖项的情况下非常有用。在前面的示例中，如果另一个活动想要访问对`ClassB`的引用，那么它将无法在作用域中找到它。
- en: 'Another feature that comes in handy for Android is the `ViewModel` injections.
    To set this up, you will need to add the library to `build.gradle`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个对Android非常有用的功能是`ViewModel`注入。为了设置这个，您需要将库添加到`build.gradle`中：
- en: '[PRE64]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If you recall, `ViewModels` require `ViewModelProvider.Factories` in order
    to be instantiated. Koin automatically solves this, allowing `ViewModels` to be
    injected directly and to handle the factory work:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，`ViewModels`需要`ViewModelProvider.Factories`才能被实例化。Koin自动解决了这个问题，允许直接注入`ViewModels`并处理工厂工作：
- en: '[PRE65]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In order to inject the dependency of `ViewModel` into your activity, you can
    use the `viewModel()` method:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`ViewModel`的依赖项注入到您的活动中，您可以使用`viewModel()`方法：
- en: '[PRE66]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Alternatively, you can use the method directly:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以直接使用该方法：
- en: '[PRE67]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As we can see in the preceding setup, Koin takes full advantage of Kotlin's
    language features and reduces the amount of boilerplate required to define your
    modules and their scopes.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的设置中所看到的，Koin充分利用了Kotlin语言的特性，并减少了定义模块及其作用域所需的样板代码量。
- en: 'Exercise 12.04: Koin Injection'
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.04：Koin注入
- en: 'Here, we will write an Android application that will perform DI using Koin.
    The application will be based on *Exercise 12.01*, *Manual Injection*, by keeping
    `NumberRepository`, `NumberRepositoryImpl`, `MainViewModel`, and `MainActivity`.
    The following dependencies will be injected:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将编写一个Android应用程序，该应用程序将使用Koin执行DI。该应用程序将基于*练习12.01*，*手动注入*，保留`NumberRepository`，`NumberRepositoryImpl`，`MainViewModel`和`MainActivity`。将注入以下依赖项：
- en: '`Repository`: As part of a module named `appModule`.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Repository`：作为名为`appModule`的模块的一部分。'
- en: '`MainViewModel`: This will rely on Koin''s specialized implementation for `ViewModels`.
    This will be provided as part of a module named `mainModule` and will have the
    scope of `MainActivity`.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainViewModel`：这将依赖于Koin对`ViewModels`的专门实现。这将作为名为`mainModule`的模块的一部分提供，并且将具有`MainActivity`的作用域。'
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: 'The app itself will display a randomly generated number each time a button
    is clicked. Let''s start by adding the Koin libraries:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序本身将在每次单击按钮时显示一个随机生成的数字。让我们从添加Koin库开始：
- en: '[PRE68]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Let''s start by defining the `appModule` variable inside the `MyApplication`
    class. This will have a similar structure to `AppModule` with the Dagger setup:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在`MyApplication`类中定义`appModule`变量开始。这将与Dagger设置的`AppModule`具有类似的结构：
- en: '[PRE69]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, let''s add the activity module variable after `appModule`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`appModule`之后添加活动模块变量：
- en: '[PRE70]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, let''s initialize `Koin` in the `onCreate()` method of `RandomApplication`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`RandomApplication`的`onCreate()`方法中初始化`Koin`：
- en: '[PRE71]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Finally, let''s inject the dependencies into the activity:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将依赖项注入到活动中：
- en: '[PRE72]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If you run the preceding code, the app should work as per the previous examples.
    However, if you check `LogCat`, you will see a similar output to this:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您运行前面的代码，应用程序应该按照之前的示例正常工作。但是，如果您检查`LogCat`，您将看到类似于这样的输出：
- en: '[PRE73]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In *Figure 12.6*, we can see the same output as in previous exercises:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图12.6*中，我们可以看到与以前练习中相同的输出：
- en: '![Figure 12.6: Emulator output of Exercise 12.04 displaying a randomly generated
    number'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6：模拟器输出练习12.04显示随机生成的数字'
- en: '](img/B15216_12_06.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_12_06.jpg)'
- en: 'Figure 12.6: Emulator output of Exercise 12.04 displaying a randomly generated
    number'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：模拟器输出练习12.04显示随机生成的数字
- en: As we can see from this exercise, Koin is much faster and easier to integrate,
    especially with its `ViewModel` library. This comes in handy for small projects,
    but its performance will be impacted once projects grow.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个练习中可以看出，Koin集成起来更快更容易，特别是其`ViewModel`库。这对于小型项目非常方便，但一旦项目增长，其性能将受到影响。
- en: 'Activity 12.01: Injected Repositories'
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动12.01：注入的存储库
- en: In this activity, you are going to create an app in Android Studio that connects
    to a sample API, [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts),
    using the Retrofit library and retrieves a list of posts from the web page, which
    will then be displayed on the screen. You will then need to set up a UI test in
    which you will assert that the data is asserted correctly on the screen, but instead
    of connecting to the actual endpoint, you will provide dummy data for the test
    to display on the screen. You will take advantage of the DI concept in order to
    swap the dependencies when the app is executed as opposed to when the app is being
    tested.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您将在Android Studio中创建一个应用程序，该应用程序连接到一个示例API，[https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)，使用Retrofit库检索网页上的帖子列表，然后在屏幕上显示。然后，您需要设置一个UI测试，其中您将断言数据在屏幕上正确显示，但是不是连接到实际端点，而是提供虚拟数据供测试显示在屏幕上。您将利用DI概念，在应用程序执行时交换依赖项，而不是在进行测试时。
- en: 'In order to achieve this, you will need to build the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，您需要构建以下内容：
- en: A network component responsible for downloading and parsing the JSON file
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责下载和解析JSON文件的网络组件
- en: A repository that accesses the data from the API layer
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从API层访问数据的存储库
- en: A `ViewModel` instance that accesses the Repository
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个访问存储库的`ViewModel`实例
- en: An activity with `RecycleView` that displays the data
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有`RecycleView`的活动，显示数据
- en: A Dagger module for providing the repository instance and one for providing
    the `ViewModel` factory instance, and a test module that will swap the repository
    dependency
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供存储库实例的Dagger模块和提供`ViewModel`工厂实例的模块，以及一个将交换存储库依赖项的测试模块
- en: One UI test that will assert the rows and uses a dummy object to generate the
    API data
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个UI测试，断言行并使用虚拟对象生成API数据
- en: Note
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Error handling can be avoided for this activity.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本次活动可以避免错误处理。
- en: 'Perform the following steps in order to complete this activity:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序执行以下步骤以完成此活动：
- en: In Android Studio, create an application with `Empty Activity` (`MainActivity`)
    and add an `api` package where your API calls are stored.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中，创建一个带有`Empty Activity`（`MainActivity`）的应用程序，并添加一个`api`包，其中存储了API调用。
- en: Define a class responsible for the API calls.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个负责API调用的类。
- en: Create a `repository` package.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`repository`包。
- en: Define a repository interface that will have one method, returning `LiveData`
    with the list of posts.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个存储库接口，该接口将具有一个方法，返回帖子列表的`LiveData`。
- en: Create the implementation for the repository class.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建存储库类的实现。
- en: Create a `ViewModel` instance, which will call the repository to retrieve the
    data.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ViewModel`实例，该实例将调用存储库以检索数据。
- en: Create an adapter for the rows of the UI.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为UI的行创建一个适配器。
- en: Create the activity that will render the UI.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建渲染UI的活动。
- en: Set up a Dagger module that will initialize the network-related dependencies.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个Dagger模块，用于初始化与网络相关的依赖项。
- en: Create a Dagger module that will be responsible for defining the dependencies
    required for the activity.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Dagger模块，负责定义活动所需的依赖项。
- en: Create a subcomponent that will use the associated module and have the injection
    in the activity.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个子组件，该子组件将使用相关模块，并在活动中进行注入。
- en: Create `AppComponent`, which will manage all of the modules.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`AppComponent`，它将管理所有模块。
- en: Set up the UI tests and a test application and provide a separate `RepositoryModule`,
    class, which will return a dependency holding dummy data.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置UI测试和测试应用程序，并提供一个单独的`RepositoryModule`类，该类将返回一个包含虚拟数据的依赖项。
- en: Implement the UI test.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实施UI测试。
- en: Note
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: http://packt.live/3sKj1cp'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下网址找到：http://packt.live/3sKj1cp
- en: 'Activity 12.02: Koin-Injected Repositories'
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Activity 12.02：Koin-Injected Repositories
- en: In this activity, you will migrate the app built in *Activity 12.01*, *Injected
    Repositories*, from Dagger to Koin, keeping the requirements intact.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您将迁移*Activity 12.01*中构建的应用程序，即*Injected Repositories*，从Dagger到Koin，保持要求不变。
- en: 'Assuming that the components in your code are the same as for the previous
    activity, the following steps need to be followed in order to complete the activity:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的代码中的组件与上一个活动的相同，需要按照以下步骤完成活动：
- en: Remove the Dagger 2 dependencies from `build.gradle` and the `kapt` plugin.
    The compilation errors this will generate will be able to guide you in removing
    unnecessary code.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`build.gradle`和`kapt`插件中删除Dagger 2的依赖项。这将产生编译错误，可以指导您删除不必要的代码。
- en: Add the standard `Koin` library and the one for `ViewModels`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加标准的`Koin`库和`ViewModels`库。
- en: Delete the Dagger modules and components from your code.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从代码中删除Dagger模块和组件。
- en: Create the `networkModule`, `repositoryModule`, and `activityModule` modules.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`networkModule`、`repositoryModule`和`activityModule`模块。
- en: Set up Koin with the preceding modules.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上述模块设置Koin。
- en: Inject `ViewModel` into `MainActivity`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ViewModel`注入`MainActivity`。
- en: Override `repositoryModule` in `TestApplication` to return `DummyRepository`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TestApplication`中覆盖`repositoryModule`，返回`DummyRepository`。
- en: Note
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: http://packt.live/3sKj1cp'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下网址找到：http://packt.live/3sKj1cp
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we analyzed the concept of DI and how it should be applied
    in order to separate concerns and prevent objects from having the responsibility
    of creating other objects and how this is of great benefit for testing. We started
    the chapter by analyzing the concept of manual DI. This served as a good example
    of how DI works and how it can be applied to an Android application; it served
    as the baseline when comparing the DI frameworks.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了DI的概念以及如何应用它以分离关注点，并防止对象具有创建其他对象的责任，以及这对于测试的巨大好处。我们从分析手动DI的概念开始本章。这是DI如何工作以及如何应用于Android应用程序的一个很好的例子；它作为比较DI框架时的基线。
- en: We also analyzed two of the most popular frameworks that help developers with
    injecting dependencies. We started with a powerful and fast framework in the form
    of Dagger 2, which relies on annotation processors to generate code to perform
    an injection. We also looked into Koin, which is a lightweight framework written
    in Kotlin with slower performance but a simpler integration and a lot of focus
    on Android components.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还分析了两种帮助开发人员进行依赖注入的最流行框架。我们首先介绍了一个强大而快速的框架，即Dagger 2，它依赖于注解处理器来生成代码以执行注入。我们还研究了Koin，这是一个用Kotlin编写的轻量级框架，性能较慢，但集成更简单，且非常关注Android组件。
- en: The exercises in this chapter were intended to explore how the same problem
    can be solved using multiple solutions and compare the degrees of difficulty between
    the solutions. In the activities for this chapter, we leveraged Dagger's and Koin's
    modules in order to inject certain dependencies when running the app and other
    dependencies when running the tests on an application that uses `ViewModels`,
    repositories, and APIs to load data. This is designed to show the seamless integration
    of multiple frameworks that achieve different goals. The activities also represented
    the combination of the different skills learned in previous chapters, from the
    basic ones that taught you how to display data on the UI to the more complex ones,
    such as those to do with networking, testing, `ViewModels`, repositories, and
    DI.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习旨在探索如何使用多种解决方案解决同一问题，并比较解决方案之间的难度程度。在本章的活动中，我们利用Dagger和Koin的模块来在运行应用程序时注入某些依赖项，并在运行使用`ViewModels`、存储库和API加载数据的测试时注入其他依赖项。这旨在展示多个框架的无缝集成，这些框架实现了不同的目标。这些活动还代表了在先前章节中学到的不同技能的结合，从教您如何在UI上显示数据的基本技能到与网络、测试、`ViewModels`、存储库和依赖注入相关的更复杂的技能。
- en: In the following chapters, you will have the opportunity to build upon the knowledge
    acquired thus far by adding concepts related to threading and how to handle background
    operations. You will get the opportunity to explore libraries such as RxJava and
    its reactive approach to threading, and you will also learn about coroutines,
    which takes a different approach to threading. You will also observe how coroutines
    and RxJava can combine very effectively with libraries such as Room and Retrofit.
    Finally, you will be able to combine all of these concepts in a robust application
    that will have a high degree of scalability for the future.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将有机会在已经获得的知识基础上构建，通过添加与线程和处理后台操作相关的概念。您将有机会探索诸如RxJava及其对线程的响应式方法，以及协程等库，后者对线程采取了不同的方法。您还将观察到协程和RxJava如何与Room和Retrofit等库结合得非常有效。最后，您将能够将所有这些概念结合在一个具有高度可扩展性的强大应用程序中。
