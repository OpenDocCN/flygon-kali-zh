- en: Chapter 7. Inheritance and Polymorphism
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。继承和多态性
- en: In this chapter, we will examine how Java supports several important object-oriented
    concepts including inheritance and polymorphism. When the term "inheritance" comes
    to mind, we think of that rich uncle who will leave us his vast fortune. Or we
    say that she has her mother's eyes. In programming terms we talk about classes
    and how they are related to each other. The terms, "parent class" and "child class",
    are used to describe an inheritance relationship between classes where the class
    has access to the capabilities of the parent class.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究Java如何支持包括继承和多态性在内的几个重要的面向对象的概念。当提到“继承”这个词时，我们会想到那位会留下巨额财富的富有的叔叔。或者我们会说她有她母亲的眼睛。在编程术语中，我们谈论类及它们之间的关系。术语“父类”和“子类”用于描述类之间的继承关系，其中类可以访问父类的功能。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are several terms used to designate a parent class and a child class.
    You may see the parent class referred to as the super class or base class. The
    child class may be called the subclass or the derived class. In this chapter we
    will use the terms **base class** and **derived class** .
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个术语用于指定父类和子类。您可能会看到父类被称为超类或基类。子类可能被称为子类或派生类。在本章中，我们将使用术语**基类**和**派生类**。
- en: The base class typically has methods that implement common functionality needed
    by that class and the classes that are derived from that class. For example, we
    may have a *person* class that represents an individual. It may have methods that
    allow us to maintain the name or age of a person. We may create other classes
    that represent different types of people—butcher, baker, or candle-stick maker.
    These different types of people have different capabilities above and beyond those
    capabilities we define for the *person* class.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 基类通常具有实现该类和从该类派生的类所需的公共功能的方法。例如，我们可能有一个代表个人的 *person* 类。它可能有允许我们维护个人姓名或年龄的方法。我们可能创建其他代表不同类型的人的类——屠夫、面包师或蜡烛制造商。这些不同类型的人具有超出我们为
    *person* 类定义的功能之外的不同功能。
- en: When we implement a baker for example, that class might have a method called
    *cook* that is used to cook something. However, the baker still has a name and
    an age. Instead of re-implementing the code to support the modification of the
    name or age we would prefer to re-use the code we developed for the person class.
    The process of doing this is called inheritance.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们实现一个面包师时，该类可能有一个名为 *cook* 的方法，用于烹饪。然而，面包师仍然有姓名和年龄。我们不希望重新实现支持修改姓名或年龄的代码，而是希望重用我们为
    person 类开发的代码。这个过程称为继承。
- en: Inheritance allows us to re-use the capabilities of the base class. This, in
    turn, promotes the re-use of software and can make the developer more productive.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 继承允许我们重用基类的功能。这反过来促进了软件的重用，并可以使开发人员更加高效。
- en: We will also explain how polymorphism is supported in Java. This concept is
    important and assists in making an application more maintainable. Polymorphism
    is the result of overriding methods of a base class. Overriding is similar to
    overloading but it uses the same signature as a base class method.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将解释Java如何支持多态性。这个概念很重要，有助于使应用程序更易于维护。多态性是重写基类方法的结果。重写类似于重载，但它使用与基类方法相同的签名。
- en: Polymorphism is frequently used in conjunction with abstract classes. An abstract
    class is one which cannot be instantiated. That is, it is not possible to create
    an instance of that class. While we cannot create an instance of an abstract class,
    we can create an instance of a class derived from the abstract class. This capability
    can enhance the structure of an application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性经常与抽象类一起使用。抽象类是一种不能被实例化的类。也就是说，不可能创建该类的实例。虽然我们不能创建抽象类的实例，但可以创建从抽象类派生的类的实例。这种能力可以增强应用程序的结构。
- en: With inheritance comes the need to invoke constructors of a base class. We will
    examine the approach used by Java to control the initialization sequence. Also,
    the idea of determining the type of a class and casting between classes of an
    inheritance hierarchy becomes important in some situations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 继承需要调用基类的构造函数。我们将研究Java用于控制初始化顺序的方法。此外，在某些情况下，确定类的类型和在继承层次结构中的类之间进行转换变得重要。
- en: The last topic addressed in this chapter is concerned with the organization
    of memory as it relates to inheritance. Understanding how memory is organized
    and handled will deepen your understanding of the language and assist in debugging
    applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后讨论的主题涉及与继承相关的内存组织。了解内存的组织和处理方式将加深您对语言的理解，并有助于调试应用程序。
- en: Inheritance
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: 'Inheritance is concerned with the relationship between two classes—the base
    class and the derived class. In this section we will cover the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 继承涉及两个类之间的关系——基类和派生类。在本节中，我们将涵盖以下内容：
- en: Implementing a subclass
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现子类
- en: Using the `protected` keyword
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `protected` 关键字
- en: Overriding methods
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写方法
- en: Using the `@Override` annotation
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@Override` 注解
- en: Using the `final` keyword with classes
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `final` 关键字与类
- en: Creating abstract methods and classes
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建抽象方法和类
- en: The use of constructors and inheritance is covered in the *The super keyword
    and constructors* section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数和继承的使用在 *The super keyword and constructors* 部分中有所涉及。
- en: When inheritance occurs, the derived class inherits all of the methods and attributes
    of the base class. However, it can only access the public and protected members
    of the class. It cannot access the private members of the class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当继承发生时，派生类继承了基类的所有方法和属性。但它只能访问类的公共和受保护成员。它不能访问类的私有成员。
- en: When a method is added to a derived class that has the same signature and accessibility
    of a base class method, the method is said to override the base class method.
    This allows the derived class to redefine the meaning of that method. The examples
    in this chapter will use a `Employee` base class and a `SalaryEmployee` class
    that is derived from the base class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当向派生类添加一个与基类方法具有相同签名和可访问性的方法时，该方法被称为覆盖基类方法。这允许派生类重新定义该方法的含义。本章的示例将使用一个`Employee`基类和一个从基类派生的`SalaryEmployee`类。
- en: Implementing a subclass
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现子类
- en: 'A class is implemented through the use of the `extends` keyword, followed by
    the base classname. In the following example, the `Employee` base class is defined:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类是通过使用`extends`关键字实现的，后面跟着基类名。在下面的例子中，定义了`Employee`基类：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `SalaryEmployee` class can be derived from the base class `Employee`, as
    shown in the following code snippet:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`SalaryEmployee`类可以从基类`Employee`派生，如下面的代码片段所示：'
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inheritance is used extensively throughout Java libraries. For example, applets
    are created by extending the `Applet` class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 继承在Java库中被广泛使用。例如，小程序是通过扩展`Applet`类创建的。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A significant part of becoming a skilled Java programmer is learning to find,
    understand, and use those classes found in libraries relevant to your application's
    domain.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 成为一名熟练的Java程序员的重要部分是学会找到、理解和使用与应用程序领域相关的库中的类。
- en: 'In the following example, the `HelloWorldApplet` class extends and inherits
    all of the methods and properties of this class. In this case, the `paint` method
    is overridden by `HelloWorldApplet`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，`HelloWorldApplet`类扩展并继承了这个类的所有方法和属性。在这种情况下，`paint`方法被`HelloWorldApplet`覆盖：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is possible, and entirely desirable, for a base class to have one or more
    derived classes. In the case of the `Employee` base class, we might create not
    only a `SalaryEmployee` class but also a `HourlyEmployee` class. They will share
    the common capabilities of the base class and yet contain their own unique capabilities.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基类可以有一个或多个派生类，这是可能的，也是完全可取的。对于`Employee`基类，我们可能不仅创建一个`SalaryEmployee`类，还可能创建一个`HourlyEmployee`类。它们将共享基类的通用功能，但又包含自己独特的功能。
- en: 'Let''s examine the `Employee` base class and the `SalaryEmployee` class more
    carefully. First, let''s start with a more detailed implementation of the `Employee`
    class, as shown in the following code snippet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细研究`Employee`基类和`SalaryEmployee`类。首先，让我们从`Employee`类的更详细实现开始，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this implementation we have only included a private `age` instance variable
    and a getter and setter method for it. In the following `SalaryEmployee` class,
    we have not added any fields:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们只包括了一个私有的`age`实例变量和一个用于它的getter和setter方法。在接下来的`SalaryEmployee`类中，我们没有添加任何字段：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, even though we haven''t added anything new to the `SalaryEmployee`
    class, it has the capabilities of the base class. In the following sequence we
    create an instance of both classes and use their methods:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使我们没有向`SalaryEmployee`类添加任何新内容，它也具有基类的功能。在下面的序列中，我们创建了两个类的实例并使用它们的方法：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the code is executed, we get the following output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码执行时，我们得到以下输出：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As the `getAge` and `setAge` methods were public we can use them with the `SalaryEmployee`
    class even though we haven''t defined new versions. However, if we attempt to
    access the private `age` variable, as shown in the following code snippet, we
    will get a syntax error:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`getAge`和`setAge`方法是公共的，我们可以在`SalaryEmployee`类中使用它们，即使我们没有定义新版本。然而，如果我们尝试访问私有的`age`变量，如下面的代码片段所示，我们将得到一个语法错误：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The syntax error generated is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的语法错误如下：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the *A review of scope* section, we will explore scoping and inheritance
    in more depth.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在*作用域审查*部分，我们将更深入地探讨作用域和继承。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Java does not support multiple inheritance between classes. That is, a derived
    class cannot extend more than one class. A derived class can extend one and only
    one class. However, Java does support multiple inheritance between interfaces.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Java不支持类之间的多重继承。也就是说，派生类不能扩展多个类。派生类只能扩展一个类。然而，Java支持接口之间的多重继承。
- en: Using the protected keyword
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用受保护的关键字
- en: 'In the previous example, we determined that we cannot access private members
    from an instance variable, `employee2.age` in the example. We cannot access it
    from methods or constructors of the derived class either. In the following implementation
    of the `SalaryEmployee` class, we attempt to initialize the `age` variable in
    its default constructor:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们确定无法从实例变量`employee2.age`中访问私有成员。我们也无法从派生类的方法或构造函数中访问它。在下面的`SalaryEmployee`类的实现中，我们尝试在其默认构造函数中初始化`age`变量：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The syntax error is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 语法错误如下：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: However, any base class members declared as public can be accessed from either
    a member method, or constructor of the derived class, or by an instance variable
    referencing the derived class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，任何声明为公共的基类成员都可以从派生类的成员方法或构造函数中访问，或者通过引用派生类的实例变量。
- en: There are situations where a member variable should be accessible from a derived
    class constructor, or method, but not from its instance variables. We may want
    to restrict access to the member at a finer level than either public or private.
    In the case of the `age` variable, we may trust the derived class to use the variable
    correctly but we may not trust the user of the instance variable. Using a protected
    field limits where the field can be modified within the application and where
    potential problems can be introduced.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，成员变量应该可以从派生类的构造函数或方法中访问，但不能从其实例变量中访问。我们可能希望在比公共或私有更细的级别上限制对成员的访问。对于`age`变量，我们可能信任派生类正确使用变量，但可能不信任实例变量的使用者。使用受保护字段限制了应用程序中可以修改字段的位置以及可能引入问题的位置。
- en: This is where the protected access modifier comes in. By using the keyword,
    `protected`, with a base class member, we restrict access to that member. It is
    accessible from only within the base class or from derived class constructors
    or methods.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`protected`访问修饰符的作用。通过在基类成员中使用`protected`关键字，我们限制对该成员的访问。它只能从基类内部或派生类的构造函数或方法中访问。
- en: 'In the following implementation of the `Employee` class, the `age` variable
    is declared as protected:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Employee`类的以下实现中，`age`变量被声明为`protected`：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `age` variable is now accessible from the `SalaryEmployee` class, as illustrated
    below where it is initialized:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`age`变量现在可以从`SalaryEmployee`类中访问，如下所示进行初始化：'
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This initialization does not generate a syntax error. However, we still cannot
    access the `age` variable from an instance reference variable. The following code
    will still result in a syntax error assuming that the class the statement resides
    in is not in the same package as the `SalaryEmployee` class. This is explained
    in the *A review of scope* section:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种初始化不会产生语法错误。然而，我们仍然无法从实例引用变量中访问`age`变量。假设该语句所在的类不在与`SalaryEmployee`类相同的包中，以下代码仍将导致语法错误。这在*作用域复习*部分中有解释：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `protected` keyword can also be used with methods. Its use with methods
    furthers your ability to control access to class members. As an example, the following
    implementation of the `Employee` class uses the `protected` keyword with the `setAge`
    method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected`关键字也可以用于方法。它与方法一起进一步增强了您对类成员访问的控制能力。例如，下面的`Employee`类的实现使用`protected`关键字与`setAge`方法：'
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This means that any user of the class can use the `getAge` method but only the
    base class, classes in the same package, or derived classes can access the `setAge`
    method.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着类的任何用户都可以使用`getAge`方法，但只有基类、相同包中的类或派生类才能访问`setAge`方法。
- en: Overriding methods
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖方法
- en: 'While methods of a base are automatically available for use in a derived class,
    the actual implementation may not be correct for a derived class. Consider the
    use of a method to compute the pay of an employee. A `computePay` method in the
    `Employee` class may simply return a base amount, as shown in the following code
    snippet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基类的方法在派生类中自动可用，但实际的实现可能对派生类不正确。考虑使用一个方法来计算员工的工资。`Employee`类中的`computePay`方法可能只是返回一个基本金额，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This example is based on the float data type which is not necessarily the best
    data type for representing currency values. The `java.math.BigDecimal` class is
    better suited for this purpose. We used the float data type here to simplify the
    example.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是基于浮点数据类型的，这并不一定是表示货币值的最佳数据类型。`java.math.BigDecimal`类更适合这个目的。我们在这里使用浮点数据类型是为了简化示例。
- en: 'However, for a derived class such as `HourlyEmployee`, the `computePay` method
    is not correct. This situation can be rectified by overriding the `computePay`
    method, as shown in the following simplified `HourlyEmployee` implementation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于派生类如`HourlyEmployee`，`computePay`方法是不正确的。这种情况可以通过覆盖`computePay`方法来纠正，如下所示的简化的`HourlyEmployee`实现：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'An overridden method possesses two basic characteristics:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖的方法具有两个基本特征：
- en: Has an identical signature as a base class method
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有与基类方法相同的签名
- en: Is found in the derived class
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在派生类中找到
- en: The signature of a class is composed of its name, the number of parameters,
    the type of the parameters, and the order of the parameters. This is discussed
    in more detail in the *Signature* section of [Chapter 6](ch06.html "Chapter 6. Classes,
    Constructors, and Methods"), *Classes, Constructors, and Methods*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 类的签名由其名称、参数数量、参数类型和参数顺序组成。这在[第6章](ch06.html "第6章。类、构造函数和方法")的*签名*部分中有更详细的讨论，*类、构造函数和方法*。
- en: 'The terms overloading and overriding are easily confused. The following table
    summarizes the key differences between these terms:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重载和覆盖这两个术语很容易混淆。以下表格总结了这些术语之间的关键区别：
- en: '| Characteristic | Overloading | Overriding |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 特征 | 重载 | 覆盖 |'
- en: '| --- | --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Method name | Same | Same |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: 方法名称 | 相同 | 相同 |
- en: '| Signature | Different | Same |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 签名 | 不同 | 相同 |'
- en: '| Class | Same class | In a derived class |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 相同类 | 在派生类中 |'
- en: 'Let''s look at the use of the `computePay` method. In the following sequence,
    the `computePay` method is executed against the `employee1` and `employee3` instance
    variables:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`computePay`方法的使用。在以下顺序中，`computePay`方法针对`employee1`和`employee3`实例变量执行：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output will be as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `computePay` method of the `Employee` base class is executed against the
    `employee1` reference variable while the `computePay` method of `HourlyEmployee`
    is executed against the `employee3` reference variable. The **Java Virtual Machine**
    (**JVM**) determines which method to use as the program executes. This is actually
    an example of polymorphic behavior, which we will address in the *Polymorphism*
    section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Employee`基类的`computePay`方法针对`employee1`引用变量执行，而`HourlyEmployee`的`computePay`方法针对`employee3`引用变量执行。**Java虚拟机**（**JVM**）在程序执行时确定要使用哪个方法。这实际上是多态行为的一个例子，我们将在*多态*部分中讨论。'
- en: In a more complex hierarchy of classes, intermediate classes may not override
    a method. For example, if a `SupervisorEmployee` class was derived from the `SalaryEmployee`
    class it is not necessary for the `SalaryEmployee` class to implement the `computePay`
    method. The `SupervisorEmployee` class can override the `computePay` method of
    `Employee`, whether or not its immediate base class overrode it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的类层次结构中，中间类可能不会覆盖一个方法。例如，如果`SupervisorEmployee`类是从`SalaryEmployee`类派生的，那么`SalaryEmployee`类不需要实现`computePay`方法。`SupervisorEmployee`类可以覆盖`Employee`的`computePay`方法，无论其直接基类是否覆盖了它。
- en: The @Override annotation
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '@Override注解'
- en: 'One Java language design issue concerns method overriding. The problem is that
    a developer may intend to override a method but may not, due to a simple error
    in the method declaration. In the following attempt to override the `computePay`
    method, however, the method name is misspelled:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Java语言设计问题涉及方法重写。问题在于开发人员可能打算重写一个方法，但由于方法声明中的简单错误，可能没有实际重写。然而，在以下尝试重写`computePay`方法时，方法名拼写错误：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'While it may (or may not be) obvious that the method is misspelled, the developer
    may not notice the mistake. Using the previous example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然方法拼写错误可能很明显（或者可能不明显），但开发人员可能没有注意到这个错误。使用前面的例子：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The program will still execute but will not generate the expected output as
    shown below:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 程序仍将执行，但不会生成预期的输出，如下所示：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that the base class' `computePay` method is used in both cases. This
    is because the `computePay` method was invoked instead of the misspelled `computPay`
    method. As the `HourlyEmployee` class no longer has a `computePay` method, the
    JVM uses the base class method. Obviously, this is not what was intended.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在两种情况下都使用了基类的`computePay`方法。这是因为调用了`computePay`方法，而不是拼写错误的`computPay`方法。由于`HourlyEmployee`类不再有`computePay`方法，JVM使用了基类方法。显然，这不是预期的结果。
- en: 'It can be hard to immediately spot these types of errors. To assist in preventing
    these types of mistakes, we can use the `@Override` annotation with the method
    as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 很难立即发现这些类型的错误。为了帮助防止这些类型的错误，我们可以在方法中使用`@Override`注解，如下所示：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This annotation informs the compiler to make sure that the method that follows,
    actually overrides a base class method. In this case, it does not because the
    name of the method is misspelled. When this happens, a syntax error is generated
    indicating that there is a problem. The syntax error message is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注解通知编译器确保接下来的方法实际上重写了基类方法。在这种情况下，它没有，因为方法名拼写错误。当这种情况发生时，将生成一个语法错误，指示存在问题。语法错误消息如下：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When the spelling of the method is corrected, the syntax error message will
    go away.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法的拼写被纠正时，语法错误消息将消失。
- en: As the name annotation implies, an annotation is a way of adding additional
    information to parts of a Java application that can be processed at a later time.
    In the case of the `@Override` annotation at compile time, a check is made to
    verify that overriding actually took place. Annotations can be used for other
    purposes, such as marking a method as deprecated.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称注解所暗示的，注解是一种在稍后可以处理的Java应用程序部分中添加附加信息的方式。在编译时，`@Override`注解会进行检查以验证是否实际发生了重写。注解也可以用于其他目的，比如标记方法为弃用。
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is a good practice to always use the `@Override` annotation with overridden
    methods.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用`@Override`注解与重写的方法是一个好习惯。
- en: Using the final keyword with classes
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用final关键字与类
- en: The `public`, `abstract`, and `final` keywords can be used when declaring a
    class. The `public` keyword specifies the scope of the class, as will be explained
    in the *A review of scope* section. The use of the `abstract` keyword is covered
    in the next section, *Abstract methods and classes*. When the `final` keyword
    is used before the `class` keyword, it signifies that the class cannot be extended.
    It will be the last class in that branch of the inheritance hierarchy.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明类时，可以使用`public`、`abstract`和`final`关键字。`public`关键字指定了类的范围，将在*范围回顾*部分中解释。`abstract`关键字的使用在下一节*抽象方法和类*中介绍。当在`class`关键字之前使用`final`关键字时，表示该类不能被扩展。它将是继承层次结构中的那个分支中的最后一个类。
- en: 'In the following example, the `Employee` class is designated as a final class.
    While it will not make sense to make the `Employee` class final for this chapter''s
    examples, it does illustrate the syntax required to make a class final:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，`Employee`类被指定为final类。虽然对于本章的例子来说，将`Employee`类设为final没有意义，但它确实说明了使类成为final所需的语法：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By restricting other classes from extending a class, you can be assured that
    the intended operation of the class will not be compromised by a derived class'
    overriding a base class method. If it is well implemented, this can result in
    a more reliable foundation from which to build applications.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过限制其他类扩展类，可以确保类的预期操作不会被派生类覆盖基类方法而破坏。如果实现得当，这可以导致更可靠的应用程序基础。
- en: The `java.lang.String` class is an example of a class found in the core JDK
    that is defined as final. It is not possible to extend this class or modify its
    behavior. This means that developers worldwide can use the class and not worry
    about the possibility of inadvertently using a derived class instead of the `String`
    class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.String`类是核心JDK中的一个类的例子，它被定义为final。不可能扩展这个类或修改它的行为。这意味着全世界的开发人员可以使用这个类，而不必担心意外使用派生类而不是`String`类。'
- en: The `final` keyword can also be used with a method definition. When used in
    this context, it means that the method cannot be overridden in a derived class.
    This provides more flexibility than making a class final. The developer can specify
    those methods that may be overridden and those that cannot be overridden.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`关键字也可以与方法定义一起使用。在这种情况下使用时，它意味着该方法不能在派生类中被重写。这比使一个类final提供了更多的灵活性。开发人员可以指定哪些方法可以被重写，哪些方法不能被重写。'
- en: 'The following illustrates making the `getAge` method final in the `Employee`
    class:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了在`Employee`类中将`getAge`方法设为final：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we attempt to override the method in a derived class, such as the `SalaryEmployee`
    class, we will get the following error message:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在派生类中重写方法，比如`SalaryEmployee`类，我们将得到以下错误消息：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Abstract methods and classes
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象方法和类
- en: Abstract classes are useful in the design of an object-oriented inheritance
    hierarchy. They are typically used to force a derived class to implement a specific
    set of methods. The base class and/or one or more methods of the class are declared
    as abstract. An abstract class cannot be instantiated. A non-abstract class, in
    contrast, must have all of the abstract methods in its hierarchy tree, if any,
    implemented.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类在面向对象继承层次结构的设计中非常有用。它们通常用于强制派生类实现特定的一组方法。基类和/或类的一个或多个方法被声明为抽象。抽象类不能被实例化。相反，非抽象类必须在其层次树中实现所有抽象方法（如果有的话）。
- en: 'The following example illustrates how to make the `Employee` class abstract.
    In this example, there are no abstract methods but the `abstract` keyword was
    used to designate the class as abstract:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何使`Employee`类成为抽象类。在这个例子中，没有抽象方法，但使用了`abstract`关键字来指定类为抽象类：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As the `Employee` class has no abstract methods, none of the derived classes
    will be forced to implement any additional methods. The above definition effectively
    has no effect on the previous examples in this chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Employee`类没有抽象方法，因此派生类都不会被强制实现任何额外的方法。上述定义对本章中先前的示例没有实际影响。
- en: 'The next definition of the `Employee` class makes the `computePay` method abstract.
    Notice that the method does not have a body but is terminated with a semicolon
    instead:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Employee`类的下一个定义使`computePay`方法成为抽象方法。注意该方法没有主体，而是以分号结束：'
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: All classes that are immediately derived from the `Employee` class must implement
    the abstract method or they, themselves, will become abstract. If they elect not
    to implement the `computePay` method, the class must be declared as abstract.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所有直接从`Employee`类派生的类必须实现抽象方法，否则它们本身将变成抽象类。如果它们选择不实现`computePay`方法，则必须将该类声明为抽象类。
- en: When we declare a method as abstract, we are forced to use the `abstract` keyword
    with the class. An abstract class can also possess non-abstract methods.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个方法声明为抽象时，我们被迫在类中使用`abstract`关键字。抽象类也可以拥有非抽象方法。
- en: In complex hierarchies you may find a mixture of non-abstract and abstract classes.
    For example, in the `java.awt` package you will find that the non-abstract `Container`
    class extends the abstract `Component` class that extends the non-abstract `Object`
    class. An abstract class may be introduced at any level in a hierarchy to meet
    the needs of the library.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的层次结构中，你可能会发现非抽象类和抽象类的混合。例如，在`java.awt`包中，你会发现非抽象的`Container`类扩展了抽象的`Component`类，而`Component`类又扩展了非抽象的`Object`类。抽象类可以在层次结构的任何级别引入，以满足库的需求。
- en: Abstract classes can have final methods but they cannot be declared as final.
    That is, the `final` keyword cannot be used as a modifier of an abstract class
    or method. If this was possible, it would be impossible to extend the class. As
    it is abstract it could never be instantiated and, thus, would be useless. However,
    an abstract class can have final methods. These methods must be implemented in
    that abstract class. The class can still be extended, but the final methods cannot
    be overridden.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类可以拥有最终方法，但不能被声明为最终。也就是说，`final`关键字不能用作抽象类或方法的修饰符。如果这是可能的，那么扩展该类将是不可能的。因为它是抽象的，所以它永远不能被实例化，因此将是无用的。但是，抽象类可以拥有最终方法。这些方法必须在该抽象类中实现。该类仍然可以被扩展，但最终方法不能被覆盖。
- en: Polymorphism
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态
- en: Polymorphism is a key object-oriented programming concept but it can be hard
    to understand initially. The primary purpose of using polymorphism is to make
    applications more maintainable. When we speak of polymorphism, we typically say
    that a method exhibits polymorphic behavior.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是一个关键的面向对象编程概念，但最初可能很难理解。使用多态的主要目的是使应用程序更易于维护。当我们谈论多态时，通常说一个方法表现出多态行为。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A method is said to be polymorphic if the behavior of the method is dependent
    on the object it is executing against.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法的行为取决于它正在执行的对象，则该方法被称为多态方法。
- en: Suppose we want to draw something. Each class may have a method called `draw`
    that it can use to draw itself. For example, a circle class might have a draw
    method that actually draws itself as a circle. A person class might have a draw
    method that displays an image of that person. The signature of the methods is
    identical.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要绘制某些东西。每个类可能都有一个名为`draw`的方法，它可以用来绘制自己。例如，圆形类可能有一个绘制自身为圆形的绘制方法。人类可能有一个显示该人的图像的绘制方法。这些方法的签名是相同的。
- en: Thus, if we apply the `draw` method against different objects of different classes
    with the same ultimate base class, then the result of the draw will differ depending
    on whether we are applying the `draw` method against a circle or a person. That
    is polymorphic behavior.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们对不同类的不同对象应用`draw`方法，这些类都有相同的基类，那么根据我们是对圆形还是对人应用`draw`方法，绘制的结果将不同。这就是多态行为。
- en: By designing our application to use polymorphism, we can add new classes that
    have a draw method and integrate them into our application a lot easier than previously
    possible in non-object oriented programming languages.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设计我们的应用程序使用多态，我们可以更容易地添加具有绘制方法的新类，并将它们集成到我们的应用程序中，这比在非面向对象的编程语言中以前可能的要容易得多。
- en: When an instance of an object is created, the object goes through a series of
    initialization steps as detailed in the *Java initialization sequence* section
    in [Chapter 6](ch06.html "Chapter 6. Classes, Constructors, and Methods"), *Classes,
    Constructors, and Methods*. This applies to objects that are derived from base
    classes also. Java memory management is dynamic and automatic. When the `new`
    keyword is used, it automatically allocates memory from the heap.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建对象的实例时，对象会经历一系列初始化步骤，详细信息请参阅[第6章](ch06.html "第6章。类，构造函数和方法")中的*Java初始化顺序*部分，*类，构造函数和方法*。这也适用于从基类派生的对象。Java内存管理是动态和自动的。当使用`new`关键字时，它会自动从堆中分配内存。
- en: In Java, a reference to a base class and any of its derived classes can be assigned
    to a base class reference variable. This is possible because of the way memory
    is allocated for base and derived classes. In a derived class, the instance variables
    of the base class are allocated first, followed by the instance variables of the
    derived class. When a base class reference variable is assigned to a derived class
    object, it sees the base class instance variables that it expects plus the "extra"
    derived class instance variables.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，可以将对基类及其派生类的引用分配给基类引用变量。这是可能的，因为为基类和派生类分配内存的方式。在派生类中，首先分配基类的实例变量，然后是派生类的实例变量。当将基类引用变量分配给派生类对象时，它会看到它所期望的基类实例变量以及“额外”的派生类实例变量。
- en: 'Let''s use the following definitions of the `Employee` and `SalaryEmployee`
    classes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下`Employee`和`SalaryEmployee`类的定义：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the following example, assigning either a `Employee` or a `SalaryEmployee`
    object to the base class reference makes sense from the perspective of the reference
    variable because it expects to see the instance variables `name` and `age`. We
    can assign a new `Employee` object to the `employee` variable, as shown in the
    following code snippet:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，从引用变量的角度来看，将`Employee`或`SalaryEmployee`对象分配给基类引用是有意义的，因为它期望看到`name`和`age`的实例变量。我们可以将新的`Employee`对象分配给`employee`变量，如下面的代码片段所示：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is also illustrated in the following diagram:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这也在以下图表中说明：
- en: '![Polymorphism](img/7324_07_01.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![多态性](img/7324_07_01.jpg)'
- en: 'We can also assign a new `SalaryEmployee` object to the `employee` variable
    using the following code. Notice that in the previous figure, and in this figure,
    the `employee` reference variable points to a `name` and a `age` field in that
    order. The `employee` reference variable expects a `Employee` object consisting
    of a `name` field and then an `age` field and that is what it sees:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下代码将新的`SalaryEmployee`对象分配给`employee`变量。请注意，在前一个图中和这个图中，`employee`引用变量指向按顺序排列的`name`和`age`字段。`employee`引用变量期望一个由`name`字段和`age`字段组成的`Employee`对象，这就是它看到的。
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This scenario is depicted in the following diagram:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况在以下图表中描述：
- en: '![Polymorphism](img/7324_07_02.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![多态性](img/7324_07_02.jpg)'
- en: 'If the following code snippet is executed, based upon the previous declarations
    of the `Employee` and `SalaryEmployee` classes, the `computePay` method of `SalaryEmployee`
    will be executed, and not that of the `Employee` class:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行以下代码片段，基于`Employee`和`SalaryEmployee`类的先前声明，将执行`SalaryEmployee`的`computePay`方法，而不是`Employee`类的：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `computePay` method is said to be polymorphic in relation to the object
    it is running against. If the `computePay` method ran against an `Employee` object,
    the `Employee`'s `computePay` method would execute.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`computePay`方法在与其运行的对象相关时被称为多态的。如果`computePay`方法针对`Employee`对象运行，将执行`Employee`的`computePay`方法。'
- en: 'A reference to a derived object can be assigned to that class'' object reference
    variable or to any of that class'' base classes. The advantage of polymorphic
    behavior can be better understood through the next example. Here, the sum of all
    of the employee''s pay from the `employees` array is calculated:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将对派生对象的引用分配给该类的对象引用变量或该类的任何基类。通过下一个示例可以更好地理解多态行为的优势。在这里，计算`employees`数组中所有员工的工资总和：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `computePay` method is executed against each element of the array. Based
    on the object it is executing against, the appropriate `computePay` method is
    invoked. If a new class is derived from the `Employee` class, such as a `SalesEmployee`
    class, the only modification needed to make the summation process work is to add
    a `SalesEmployee` object to the array. No other changes are needed. The result
    is a more maintainable and extensible application.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`computePay`方法针对数组的每个元素执行。根据它正在执行的对象，会调用适当的`computePay`方法。如果从`Employee`类派生出一个新类，比如`SalesEmployee`类，使求和过程正常工作所需的唯一修改是向数组中添加一个`SalesEmployee`对象。不需要进行其他更改。结果是一个更易维护和可扩展的应用程序。'
- en: 'The allocation of the memory for derived classes helps explain how polymorphism
    works. We can assign a reference to a `SalaryEmployee` to either a `SalaryEmployee`
    reference variable or to an `Employee` reference variable. This is illustrated
    in the following code sequence:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为派生类分配内存有助于解释多态的工作原理。我们可以将对`SalaryEmployee`的引用分配给`SalaryEmployee`引用变量或`Employee`引用变量。这在以下代码序列中有所说明：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'All of the above assignments are legal. It is possible to assign a derived
    class object to a base class reference variable because the base class reference
    variable is actually pointing to the memory whose first part contains the base
    class instance variables. This is illustrated in the following diagram, where
    each stack reflects the cumulative effect of the four assignment statements:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以上所有分配都是合法的。可以将派生类对象分配给基类引用变量，因为基类引用变量实际上指向的是其第一部分包含基类实例变量的内存。这在以下图表中有所说明，其中每个堆栈反映了四个分配语句的累积效果：
- en: '![Polymorphism](img/7324_07_03.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![多态性](img/7324_07_03.jpg)'
- en: Notice that some objects are no longer referenced by the application. These
    objects are eligible for garbage collection. At some point, if needed, they will
    be returned to the heap.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一些对象不再被应用程序引用。这些对象有资格进行垃圾回收。如果需要，它们将在某个时候返回到堆中。
- en: Managing classes and objects
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理类和对象
- en: 'This section is concerned with a number of issues relating to the general management
    of classes and objects. It includes the:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涉及与类和对象的一般管理相关的一些问题。它包括：
- en: Creation and initialization of objects
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和初始化对象
- en: Accessing methods of a base class
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问基类的方法
- en: Determining the type of objects
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定对象的类型
- en: Use of the `Object` class
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Object`类
- en: Casting objects
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象转换
- en: Controlling the scope of classes and members
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制类和成员的范围
- en: The super keyword and constructors
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: super关键字和构造函数
- en: 'As we saw in the *Using the this Keyword* section of [Chapter 6](ch06.html
    "Chapter 6. Classes, Constructors, and Methods"), *Classes, Constructors, and
    Methods*, the `this` keyword refers to the current object. It can be used to:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第6章](ch06.html "第6章。类，构造函数和方法")的*使用this关键字*部分中所看到的，`this`关键字指的是当前对象。它可以用于：
- en: Access instance variables
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问实例变量
- en: Pass the current object to a method
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将当前对象传递给方法
- en: Return the current object from a method
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从方法返回当前对象
- en: 'The `super` keyword is used in a complementary fashion within a derived class.
    It is used to:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`super`关键字在派生类中以一种互补的方式使用。它用于：'
- en: Call the base class constructor
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用基类构造函数
- en: Access an overridden method in the base class
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问基类中的重写方法
- en: Calling a base class constructor
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用基类构造函数
- en: Let's examine its use in calling base class constructors. When a derived class
    object is created, it is initialized by calling its constructor. The use of constructors
    is covered in the *Constructors* section of [Chapter 6](ch06.html "Chapter 6. Classes,
    Constructors, and Methods"), *Classes, Constructors, and Methods*. However, before
    a derived class constructor is executed, the base class constructor is invoked.
    This results in the base class being initialized before the derived class. This
    is particularly important should the derived class use any of the base class methods
    in the initialization sequence.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在调用基类构造函数时的使用。当创建派生类对象时，会通过调用其构造函数来初始化。构造函数的使用在[第6章](ch06.html "第6章。类，构造函数和方法")的*构造函数*部分中有所涵盖。但是，在执行派生类构造函数之前，会调用基类构造函数。这导致基类在派生类之前被初始化。这在派生类在初始化序列中使用任何基类方法时尤为重要。
- en: 'The invocation of the base class'' default constructor occurs automatically
    unless we use the `super` keyword to invoke an alternative base class constructor.
    The following is an implementation of the `Employee` class which defines two constructors—a
    default constructor and a three argument constructor:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们使用`super`关键字调用替代的基类构造函数，否则基类的默认构造函数会自动调用。以下是`Employee`类的实现，它定义了两个构造函数——一个默认构造函数和一个三个参数的构造函数：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Notice the use of the `this` keyword to call the three argument constructor.
    The following is a partial implementation of the `SalaryEmployee` class. Only
    a default constructor is defined:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`this`关键字调用三个参数的构造函数。以下是`SalaryEmployee`类的部分实现。只定义了一个默认构造函数：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this example, the default constructor of the `Employee` class is automatically
    invoked. However, we can make this invocation explicit by using the `super` keyword
    followed by a set of open and close parentheses, as shown below:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Employee`类的默认构造函数会被自动调用。但是，我们可以通过使用`super`关键字后跟一对括号来显式地进行这个调用，如下所示：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In both cases, member variables of the `Employee` base class in the `SalaryEmployee`
    object are initialized as specified in the base class constructor.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`SalaryEmployee`对象中`Employee`基类的成员变量将按照基类构造函数中指定的方式进行初始化。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we explicitly use the `super` keyword to invoke a base class constructor,
    it must be the first line of the derived class' constructor. The `this` keyword
    must be the first statement in a constructor to invoke another constructor of
    the same class. Both of these keywords cannot be used in the same constructor
    to invoke another constructor.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们明确使用`super`关键字来调用基类构造函数，它必须是派生类构造函数的第一行。`this`关键字必须是构造函数中调用同一类的另一个构造函数的第一个语句。这两个关键字不能在同一个构造函数中用于调用另一个构造函数。
- en: 'However, there are situations where we may wish to invoke some constructor
    other than the default base class constructor. To do this we use the `super` keyword
    as the first statement in a derived class constructor and supply a list of parameters
    that match those of another base class constructor. In the following example,
    the four argument constructor of `SalaryEmployee` calls the base class'' three
    argument constructor:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些情况下，我们可能希望调用除默认基类构造函数之外的其他构造函数。为此，我们使用`super`关键字作为派生类构造函数中的第一个语句，并提供与另一个基类构造函数相匹配的参数列表。在以下示例中，`SalaryEmployee`的四个参数构造函数调用了基类的三个参数构造函数：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If we could not choose the base class constructor, then we would need to explicitly
    call the appropriate setter methods to initialize the base class variables after
    the base class'' default constructor has executed. This is illustrated in the
    following code snippet:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法选择基类构造函数，那么我们需要在基类的默认构造函数执行后显式调用适当的setter方法来初始化基类变量。这在以下代码片段中有所说明：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This approach is not the preferred approach. It is best to allow the base class
    to initialize its own member variables. A derived class is not always in a position
    to determine how they should be initialized, and if they are completely hidden
    the derived class may not even be aware of their existence.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法并不是首选方法。最好让基类初始化自己的成员变量。派生类并不总是能够确定它们应该如何初始化，如果它们完全隐藏了，派生类甚至可能不知道它们的存在。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If a constructor invokes base class methods, these methods should be declared
    as final. Otherwise, a derived class that overrides them could adversely affect
    the initialization sequence.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构造函数调用了基类方法，这些方法应该声明为final。否则，覆盖它们的派生类可能会对初始化序列产生不利影响。
- en: Accessing an overridden method in the base class
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问基类中的重写方法
- en: 'We can also use the `super` keyword to access the overridden method of a base
    class method. For example, it is always a good idea to override the `toString`
    method of a class to return a string that represents that instance of the class.
    One possible implementation of this method for the `Employee` class is provided
    in the following code snippet:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`super`关键字来访问基类方法的重写方法。例如，重写`toString`方法以返回表示该类实例的字符串总是一个好主意。以下代码片段提供了`Employee`类的此方法的一种可能实现：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'An implementation for the `SalaryEmployee` class is shown in the following
    code snippet, which uses the base class getter methods to return the name and
    age:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`SalaryEmployee`类的一个实现如下代码片段所示，它使用基类的getter方法返回名称和年龄：'
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: However, this implementation is awkward, as it requires invocation of the getter
    methods. Another problem with this approach is that each derived class may provide
    a different representation of the base class variables resulting in possible confusion
    on the part of the user of this method.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种实现方式很笨拙，因为它需要调用getter方法。这种方法的另一个问题是，每个派生类可能会提供基类变量的不同表示，可能会让使用这种方法的用户感到困惑。
- en: 'Ideally, we would simply call the base class'' `toString` method in this example
    to get the string representation of the base class. However, calling the `toString`
    method from within the derived class''s `toString` method results in a recursive
    call. That is, the runtime system thinks we are calling the current method. This
    is illustrated in the following code snippet:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，在这个例子中我们应该简单地调用基类的`toString`方法来获得基类的字符串表示。然而，从派生类的`toString`方法中调用`toString`方法会导致递归调用。也就是说，运行时系统认为我们正在调用当前方法。这在下面的代码片段中得到了证明：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can avoid these issues by using the `super` keyword to invoke a base class
    method. This is done by prefixing the name of the base class method with the `super`
    keyword and a period, as shown in the following code snippet:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`super`关键字来调用基类方法来避免这些问题。这是通过在基类方法的名称前加上`super`关键字和一个句点来实现的，如下面的代码片段所示：
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The effect of using the `super` keyword is illustrated in the next code sequence:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`super`关键字的效果在下一个代码序列中得到了证明：
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output will appear as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice that the `toString` method is not explicitly invoked in the `println`
    method. When an object reference is used within a `print` or a `println` method,
    the `toString` method is automatically invoked if no other methods are used with
    the reference variable.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`println`方法中并没有显式调用`toString`方法。当在`print`或`println`方法中使用对象引用时，如果没有使用其他方法，`toString`方法会自动被调用。
- en: Unlike having to use the `super` keyword as the first statement in a constructor
    to invoke a base class constructor, when used to invoke a derived class method
    the `super` keyword can be used anywhere. It does not have to be used in the same
    overridden method.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 不像必须在构造函数中使用`super`关键字作为第一条语句来调用基类构造函数，当用于调用派生类方法时，`super`关键字可以在任何地方使用。它不必在相同的重写方法中使用。
- en: 'In the example that follows, the `display` method invokes the base class''s
    `toString` method:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的例子中，`display`方法调用了基类的`toString`方法：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here, the `display` method is invoked against the `employee2` reference variable:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`display`方法被调用来对`employee2`引用变量进行操作：
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The resulting output follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出如下：
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'It is not possible to call a base method above the current base class. That
    is, assuming an inheritance hierarchy of `Employee` – `SalaryEmployee` – `Supervisor`,
    a base class method of the `Employee` class cannot be called directly from a `Supervisor`
    method. The following code will result in a syntax error message:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能调用当前基类以上的基类方法。也就是说，假设`Employee` - `SalaryEmployee` - `Supervisor`的继承层次结构，`Employee`类的基类方法不能直接从`Supervisor`方法中调用。以下代码将导致语法错误消息：
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Determining the type of an object
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定对象的类型
- en: There are times when it is useful to know an object's class. There are a couple
    of ways to determine its type. The first approach is to get the classname using
    the `Class` class. The second approach is to use the `instanceof` operator.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候知道对象的类是很有用的。有几种方法可以确定它的类型。第一种方法是使用`Class`类获取类名。第二种方法是使用`instanceof`运算符。
- en: 'There is actually a class in Java named `Class` and it is found in the `java.lang`
    package. It is used to obtain information regarding the current object. For our
    purposes we will use its `getName` method to return the name of the class. First
    we obtain an instance of `Class` using the `getClass` method. This method is a
    member of the `Object` class. The following illustrates this approach:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在Java中有一个名为`Class`的类，它位于`java.lang`包中。它用于获取有关当前对象的信息。为了我们的目的，我们将使用它的`getName`方法来返回类的名称。首先，我们使用`getClass`方法获取`Class`的一个实例。这个方法是`Object`类的一个成员。以下是这种方法的示例：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When this sequence is executed, we get the following output. In this example,
    the class names are prefixed with the name of their package. All classes developed
    for this book were placed within the **packt** package:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行这个序列时，我们得到以下输出。在这个例子中，类名都是以它们的包名为前缀的。本书中开发的所有类都放在**packt**包中：
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'While knowing the name of the class may be useful in some situations, the `instanceof`
    operator is frequently more useful. We can use the operator to determine whether
    one object is an instance of a class. This is demonstrated in the following example
    where we determine the type of classes referenced by the `employee1` and `employee2`
    variables:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在某些情况下知道类的名称可能很有用，但`instanceof`运算符通常更有用。我们可以使用这个运算符来确定一个对象是否是一个类的实例。这在下面的例子中得到了证明，我们确定了`employee1`和`employee2`变量引用的类的类型：
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This sequence displays a true or false value based on the operator''s operands.
    The output is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列根据运算符的操作数显示一个true或false值。输出如下：
- en: '[PRE53]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The Object class
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Object类
- en: 'The `Object` class is found in the `java.lang` package. This class is the ultimate
    base class of all Java classes. If a class does not explicitly extend a class,
    Java will automatically extend that class from the `Object` class. To illustrate
    this, consider the following definition of the `Employee` class:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object`类位于`java.lang`包中。这个类是所有Java类的最终基类。如果一个类没有明确地扩展一个类，Java将自动从`Object`类扩展该类。为了说明这一点，考虑`Employee`类的以下定义：'
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'While we did not explicitly extend the `Object` class, it is extended from
    the `Object` class. To verify this, consider the following code sequence:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们没有显式扩展`Object`类，但它是从`Object`类扩展的。要验证这一点，请考虑以下代码序列：
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output is as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE56]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The application of the `instanceof` operator confirms that the `Employee` class
    is ultimately an object of `Object`. The above definition of the `Employee` class
    has the same effect as if we had derived it from the `Object` explicitly, as shown
    in the following code snippet:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof`运算符的应用确认`Employee`类最终是`Object`的对象。上述`Employee`类的定义具有与我们明确从`Object`派生它的效果相同，如下面的代码片段所示：'
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Using a common base class in Java guarantees that all classes have common methods.
    The `Object` class possesses several methods that most classes may need, as listed
    in the following table:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中使用一个共同的基类可以保证所有类都有共同的方法。`Object`类拥有大多数类可能需要的几种方法，如下表所示：
- en: '| Method | Meaning |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 意义 |'
- en: '| --- | --- |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `clone` | Produces a copy of the object. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `clone` | 生成对象的副本。 |'
- en: '| `equals` | Returns true if two objects are "equal". |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `equals` | 如果两个对象“相等”，则返回true。 |'
- en: '| `toString` | Returns a string representation of the object. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `toString` | 返回对象的字符串表示。 |'
- en: '| `finalize` | Performed before an object is returned to the heap manager.
    |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `finalize` | 在对象返回给堆管理器之前执行。 |'
- en: '| `getClass` | Returns a `Class` object that provides additional information
    about an object. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `getClass` | 返回一个提供有关对象的附加信息的`Class`对象。 |'
- en: '| `hashCode` | Returns a unique hash code for the object. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `hashCode` | 返回对象的唯一哈希码。 |'
- en: '| `notify` | Used in thread management. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `notify` | 用于线程管理。 |'
- en: '| `notifyAll` | Also used in thread management. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `notifyAll` | 也用于线程管理。 |'
- en: '| `wait` | Overloaded method used in thread management. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `wait` | 重载方法，用于线程管理。 |'
- en: Tip
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When a new class is created it is always a good idea to override the `toString`,
    `equals`, and `hashCode` methods.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新类时，始终要重写`toString`、`equals`和`hashCode`方法是一个好主意。
- en: Note
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before an object can be cloned, its class must implement the `java.lang.Cloneable`
    interface. The `clone` method is protected.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象可以克隆之前，它的类必须实现`java.lang.Cloneable`接口。`clone`方法是受保护的。
- en: Casting objects
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象转换
- en: 'In Java, we are able to cast an object to a different class, other than that
    of the original object. The cast can be up or down the hierarchy chain. When we
    cast a derived class object to a base class reference variable, it is called **upcasting**
    . When we cast a base class object to a derived class reference variable, it is
    called **downcasting** . Let''s start with the following declaration where `Employee`
    is the base class of `SalaryEmployee`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们能够将一个对象转换为原始对象以外的不同类。转换可以沿着层次结构向上或向下进行。当我们将一个派生类对象转换为基类引用变量时，称为**向上转型**。当我们将一个基类对象转换为派生类引用变量时，称为**向下转型**。让我们从以下声明开始，其中`Employee`是`SalaryEmployee`的基类：
- en: '[PRE58]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The following example illustrates upcasting. An instance of the derived class,
    `SalaryEmployee` is assigned to the base class reference variable `employee1`.
    This is legal and is an important part of polymorphic behavior:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了向上转型。将派生类`SalaryEmployee`的实例分配给基类引用变量`employee1`。这是合法的，也是多态行为的重要部分：
- en: '[PRE59]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The next statement attempts to perform downcasting. An instance of the base
    class is being assigned to the derived class reference variable. This statement
    will result in a syntax error:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条语句尝试执行向下转型。将基类的实例分配给派生类引用变量。这条语句将导致语法错误：
- en: '[PRE60]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'However, the syntax error can be avoided by using the cast operator as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可以通过使用转换运算符来避免语法错误，如下所示：
- en: '[PRE61]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'But, a `ClassCastException` exception, shown as follows, will be thrown when
    the preceding statement is executed:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当执行上述语句时，将抛出`ClassCastException`异常，如下所示：
- en: '[PRE62]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Upcasting is possible because the derived object contains everything that the
    base class has, plus something more. Downcasting is not a good idea as the reference
    variable expects an object with more capabilities than is supplied.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 向上转型是可能的，因为派生对象包含基类具有的一切，以及更多的东西。向下转型不是一个好主意，因为引用变量期望提供比所提供的更多功能的对象。
- en: 'Notice, with upcasting, that the methods available to the reference variable
    are those of the base class and not the derived class. Even though the reference
    variable points to the derived class object, it can only use the base class methods
    because that''s what we''ve told the Java compiler the object is. This is illustrated
    in the following statement where we try to use the derived class'' `setStock`
    method:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过向上转型，引用变量可用的方法是基类的方法，而不是派生类的方法。即使引用变量指向派生类对象，它也只能使用基类方法，因为这是我们告诉Java编译器对象的方式。这在以下语句中得到了说明，我们尝试使用派生类的`setStock`方法：
- en: '[PRE63]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The following syntax error will be generated for this statement:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此语句将生成以下语法错误：
- en: '[PRE64]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: A review of scope
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域的回顾
- en: Scope refers to when a variable is visible and can be accessed. In earlier chapters
    we learned how the `public` and `private` keywords are used to control the scope
    of member variables. In the *Using the protected keyword* section of this chapter,
    we explored how the `protected` keyword works. However, the declaration of a member
    variable does not require the use of any of these keywords. When modifiers are
    not used, the variable declaration is called **package-private** . As the name
    implies, the scope of the variable is restricted to those classes in the same
    package.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域是指变量何时可见和可访问。在早期的章节中，我们学习了`public`和`private`关键字如何用于控制成员变量的作用域。在本章的*使用protected关键字*部分，我们探讨了`protected`关键字的工作原理。然而，成员变量的声明不需要使用任何这些关键字。当不使用修饰符时，变量声明称为**包私有**。顾名思义，变量的作用域仅限于同一包中的那些类。
- en: We also need to consider the use of the `public` keyword when used with a class
    definition. If a class is declared as public, it is visible to all classes. If
    no declaration is used, its visibility is limited to the current package. The
    class is said to have package-private visibility.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要考虑在类定义中使用`public`关键字。如果一个类声明为public，它对所有类都是可见的。如果没有使用声明，它的可见性被限制在当前包内。该类被称为具有包私有可见性。
- en: Note
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The use of the `private` and `protected` keywords cannot be used with a class
    definition unless the class is an inner class. An inner class is a class that
    is declared within another class.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`private`和`protected`关键字不能与类定义一起使用，除非该类是内部类。内部类是在另一个类中声明的类。'
- en: 'The following table summarizes the scope of access modifiers as applied to
    class member variables and methods:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了应用于类成员变量和方法的访问修饰符的作用域：
- en: '| Modifier | Class | Package | Derived Class | Other |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 修饰符 | 类 | 包 | 派生类 | 其他 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| public | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| public | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    |'
- en: '| private | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon2.jpg)
    | ![A review of scope](img/7324EN_07_icon2.jpg) | ![A review of scope](img/7324EN_07_icon2.jpg)
    |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| private | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon2.jpg)
    | ![A review of scope](img/7324EN_07_icon2.jpg) | ![A review of scope](img/7324EN_07_icon2.jpg)
    |'
- en: '| protected | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of
    scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    | ![A review of scope](img/7324EN_07_icon2.jpg) |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| protected | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of
    scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    | ![A review of scope](img/7324EN_07_icon2.jpg) |'
- en: '| none | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    | ![A review of scope](img/7324EN_07_icon2.jpg) | ![A review of scope](img/7324EN_07_icon2.jpg)
    |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| none | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    | ![A review of scope](img/7324EN_07_icon2.jpg) | ![A review of scope](img/7324EN_07_icon2.jpg)
    |'
- en: 'Let''s also consider the following package/class arrangement, which provides
    a more detailed look into the scoping rules:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也考虑以下的包/类安排，这提供了对作用域规则的更详细的了解：
- en: '![A review of scope](img/7324_07_04.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![A review of scope](img/7324_07_04.jpg)'
- en: 'Assume that class `A` has the following declarations:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 假设类`A`有以下声明：
- en: '[PRE65]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The following table summarizes the scoping rules for these declarations. These
    rules apply to both variables and methods declared in class `A`. It is slightly
    different from the previous table as it illustrates the placement of a derived
    class in a different package. Thus, the access permissions in the protected row
    appear to be different from the previous table:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了这些声明的作用域规则。这些规则适用于类`A`中声明的变量和方法。它与前一个表格略有不同，因为它说明了派生类在不同包中的放置。因此，受保护行中的访问权限似乎与前一个表格不同：
- en: '| Variable | A | B | C | D | E |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | A | B | C | D | E |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| `public int v1;` | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review
    of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `public int v1;` | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review
    of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    |'
- en: '| `private int v2;` | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review
    of scope](img/7324EN_07_icon2.jpg) | ![A review of scope](img/7324EN_07_icon2.jpg)
    | ![A review of scope](img/7324EN_07_icon2.jpg) | ![A review of scope](img/7324EN_07_icon2.jpg)
    |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `private int v2;` | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review
    of scope](img/7324EN_07_icon2.jpg) | ![A review of scope](img/7324EN_07_icon2.jpg)
    | ![A review of scope](img/7324EN_07_icon2.jpg) | ![A review of scope](img/7324EN_07_icon2.jpg)
    |'
- en: '| `protected int v3;` | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A
    review of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    | ![A review of scope](img/7324EN_07_icon2.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `protected int v3;` | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A
    review of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    | ![A review of scope](img/7324EN_07_icon2.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    |'
- en: '| `int v4;` | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of
    scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    | ![A review of scope](img/7324EN_07_icon2.jpg) | ![A review of scope](img/7324EN_07_icon2.jpg)
    |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `int v4;` | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of
    scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    | ![A review of scope](img/7324EN_07_icon2.jpg) | ![A review of scope](img/7324EN_07_icon2.jpg)
    |'
- en: 'It may be necessary to declare an instance of class `A` in some of these classes
    in order to have access to the instances variables of `A`. For example, in class
    `D` the following code is needed to access class `A`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些类中，可能需要声明类`A`的一个实例，以便访问`A`的实例变量。例如，在类`D`中，需要以下代码来访问类`A`：
- en: '[PRE66]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Tip
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In general, use the most restrictive access that makes sense. This will improve
    the reliability of the application by avoiding situations where accidental access
    to a member results in unanticipated consequences.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，使用最严格的访问权限是有意义的。这将通过避免意外访问成员导致意想不到的后果来提高应用程序的可靠性。
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we have studied inheritance and polymorphic behavior, as defined
    by Java. We have examined how objects are allocated in memory to gain a more comprehensive
    understanding of how polymorphism and constructors work. The use of the `this`
    and `super` keywords were examined with regards to their use in constructors and
    derived class methods. In addition, abstract classes were examined, along with
    how they impact on polymorphic behavior.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了Java定义的继承和多态行为。我们研究了对象在内存中的分配，以更全面地了解多态性和构造函数的工作原理。还研究了`this`和`super`关键字在构造函数和派生类方法中的使用。此外，还研究了抽象类以及它们对多态行为的影响。
- en: The `protected` and `final` keywords were covered. We saw how the `final` keyword
    can affect inheritance and overriding methods. The `protected` keyword allowed
    us to better control the access to information in a derived class.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 涵盖了`protected`和`final`关键字。我们看到`final`关键字如何影响继承和重写方法。`protected`关键字允许我们更好地控制派生类中的信息访问。
- en: The management of classes and objects was addressed including the organization
    of classes in a package and how to obtain information about objects using the
    `Class` class. The use of package-protected members was introduced. Also covered
    was the use of casting with classes.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了类和对象的管理，包括如何在包中组织类以及如何使用`Class`类获取关于对象的信息。介绍了包保护成员的使用。还涵盖了类的转换使用。
- en: In the next chapter we will cover the important topic of exception handling.
    Knowing how to properly use exception handling will enable you to create more
    robust and maintainable programs.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将涵盖异常处理这一重要主题。了解如何正确使用异常处理将使您能够创建更健壮和可维护的程序。
- en: Certification objectives covered
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 涵盖的认证目标
- en: 'The certification objectives addressed in this chapter include:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及的认证目标包括：
- en: Implementing inheritance
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现继承
- en: Developing the code that demonstrates the use of polymorphism
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发演示多态使用的代码
- en: Differentiating between the type of a reference and the type of an object
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分引用类型和对象类型
- en: Determining when casting is necessary
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定何时需要转换
- en: Using `super` and `this` to access objects and constructors
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`super`和`this`访问对象和构造函数
- en: Using abstract classes and interfaces
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象类和接口
- en: Test your knowledge
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: Which set of statements result in `ClassB` and `ClassC` being derived from `ClassA`?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪组语句导致`ClassB`和`ClassC`从`ClassA`派生？
- en: a. `class ClassB extends ClassA {}`
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: a. `ClassB类扩展自ClassA类{}`
- en: b. `class ClassB extends ClassC {}`
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: b. `ClassB类扩展自ClassC类{}`
- en: c. `class ClassA extends ClassB {}`
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: c. `ClassA类扩展自ClassB类{}`
- en: d. `class ClassC extends ClassB {}`
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: d. `ClassC类扩展自ClassB类{}`
- en: e. No combination will work
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: e. 没有组合会起作用
- en: Which of the following must be true for a method to support polymorphism?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些条件必须为方法支持多态性？
- en: a. The method must override a base class method
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: a. 该方法必须重写基类方法
- en: b. The method must overload a base class method
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: b. 该方法必须重载基类方法
- en: c. The method's class must extend a base class that has the overridden method
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: c. 该方法的类必须扩展具有被重写方法的基类
- en: d. The method must execute against a base class reference variable
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: d. 该方法必须针对基类引用变量执行
- en: What method is used to determine the type of an object?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于确定对象类型的方法是什么？
- en: a. `isType`
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: a. `isType`
- en: b. `typeOf`
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: b. `typeOf`
- en: c. `instanceof`
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: c. `instanceof`
- en: d. `instanceOf`
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: d. `instanceOf`
- en: Which of the following are valid casts?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是有效的转换？
- en: a. `num1 = num2;`
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: a. `num1 = num2;`
- en: b. `num1 = (int)num2;`
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: b. `num1 = (int)num2;`
- en: c. `num1 = (float)num2;`
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: c. `num1 = (float)num2;`
- en: d. `num1(int) = num2;`
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: d. `num1(int) = num2;`
- en: 'Given the following class definitions:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定以下类定义：
- en: '[PRE67]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'What statement is needed at the comment line to generate the following output:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释行需要什么语句才能生成以下输出：
- en: '[PRE68]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: a. `super();`
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: a. `super();`
- en: b. `super().someMethod;`
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: b. `super().someMethod;`
- en: c. `super.someMethod();`
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: c. `super.someMethod();`
- en: d. `someMethod();`
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: d. `someMethod();`
- en: e. None of the above
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: e. 以上都不是
- en: Which of the following statements are true?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些陈述是真实的？
- en: a. An abstract class must use the abstract keyword when declared
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: a. 抽象类在声明时必须使用abstract关键字
- en: b. An abstract class must have one or more abstract methods
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: b. 抽象类必须有一个或多个抽象方法
- en: c. An abstract class cannot extend a non-abstract class
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: c. 抽象类不能扩展非抽象类
- en: d. An abstract class cannot implement an interface
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: d. 抽象类不能实现接口
