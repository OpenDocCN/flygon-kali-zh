- en: Chapter 4. Thread Executors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。线程执行器
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating a thread executor
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建线程执行器
- en: Creating a fixed-size thread executor
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建固定大小的线程执行器
- en: Executing tasks in an executor that returns a result
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行器中执行返回结果的任务
- en: Running multiple tasks and processing the first result
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行多个任务并处理第一个结果
- en: Running multiple tasks and processing all the results
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行多个任务并处理所有结果
- en: Running a task in an executor after a delay
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行器中延迟运行任务
- en: Running a task in an executor periodically
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行器中定期运行任务
- en: Canceling a task in an executor
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消执行器中的任务
- en: Controlling a task finishing in an executor
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行器中控制任务的完成
- en: Separating the launching of tasks and the processing of their results in an
    executor
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行器中分离任务的启动和结果的处理
- en: Controlling the rejected tasks of an executor
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制执行器的被拒绝任务
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'Usually, when you develop a simple, concurrent-programming application in Java,
    you create some `Runnable` objects and then create the corresponding `Thread`
    objects to execute them. If you have to develop a program that runs a lot of concurrent
    tasks, this approach has the following disadvantages:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在Java中开发简单的并发编程应用程序时，您会创建一些`Runnable`对象，然后创建相应的`Thread`对象来执行它们。如果必须开发运行大量并发任务的程序，这种方法有以下缺点：
- en: You have to implement all the code-related information to the management of
    the `Thread` objects (creation, ending, obtaining results).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须实现与`Thread`对象管理相关的所有代码信息（创建、结束、获取结果）。
- en: You create a `Thread` object per task. If you have to execute a big number of
    tasks, this can affect the throughput of the application.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个任务创建一个`Thread`对象。如果必须执行大量任务，这可能会影响应用程序的吞吐量。
- en: You have to control and manage efficiently the resources of the computer. If
    you create too many threads, you can saturate the system.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须有效地控制和管理计算机的资源。如果创建了太多线程，可能会使系统饱和。
- en: Since Java 5, the Java concurrency API provides a mechanism that aims at resolving
    problems. This mechanism is called the **Executor framework** and is around the
    `Executor` interface, its subinterface `ExecutorService`, and the `ThreadPoolExecutor`
    class that implements both interfaces.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java 5以来，Java并发API提供了一个旨在解决问题的机制。这个机制称为**Executor框架**，围绕着`Executor`接口、它的子接口`ExecutorService`以及实现了这两个接口的`ThreadPoolExecutor`类。
- en: This mechanism separates the task creation and its execution. With an executor,
    you only have to implement the `Runnable` objects and send them to the executor.
    It is responsible for their execution, instantiation, and running with necessary
    threads. But it goes beyond that and improves performance using a pool of threads.
    When you send a task to the executor, it tries to use a pooled thread for the
    execution of this task, to avoid continuous spawning of threads.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制将任务的创建和执行分开。有了执行器，您只需实现`Runnable`对象并将它们发送到执行器。执行器负责它们的执行、实例化和使用必要的线程运行。但它不仅如此，还使用线程池来提高性能。当您将任务发送到执行器时，它会尝试使用池化线程来执行此任务，以避免不断产生线程。
- en: 'Another important advantage of the Executor framework is the `Callable` interface.
    It''s similar to the `Runnable` interface, but offers two improvements, which
    are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器框架的另一个重要优势是`Callable`接口。它类似于`Runnable`接口，但提供了两个改进，如下所示：
- en: The main method of this interface, named `call()`, may return a result.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该接口的主要方法名为`call()`，可能会返回一个结果。
- en: When you send a `Callable` object to an executor, you get an object that implements
    the `Future` interface. You can use this object to control the status and the
    result of the `Callable` object.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您将`Callable`对象发送到执行器时，您会得到一个实现`Future`接口的对象。您可以使用此对象来控制`Callable`对象的状态和结果。
- en: This chapter presents 11 recipes that show you how to work with the Executor
    framework using the classes mentioned earlier and other variants provided by the
    Java Concurrency API.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了11个示例，向您展示如何使用Executor框架使用Java并发API提供的类和其他变体。
- en: Creating a thread executor
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建线程执行器
- en: The first step to work with the Executor framework is to create an object of
    the `ThreadPoolExecutor` class. You can use the four constructors provided by
    that class or use a factory class named `Executors` that creates `ThreadPoolExecutor`.
    Once you have an executor, you can send `Runnable` or `Callable` objects to be
    executed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Executor框架的第一步是创建`ThreadPoolExecutor`类的对象。您可以使用该类提供的四个构造函数，或者使用一个名为`Executors`的工厂类来创建`ThreadPoolExecutor`。一旦您有了执行器，就可以发送`Runnable`或`Callable`对象进行执行。
- en: In this recipe, you will learn how these two operations implement an example
    that will simulate a web server processing requests from various clients.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何实现这两个操作，模拟一个从各个客户端接收请求的Web服务器。
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should read the *Creating and running a thread* recipe in [Chapter 1](ch01.html
    "Chapter 1. Thread Management") to learn the basic mechanism of thread creation
    in Java. You can compare both mechanisms and select the best one depending on
    the problem.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该阅读[第1章](ch01.html "第1章。线程管理")中的*创建和运行线程*示例，以了解Java中线程创建的基本机制。您可以比较这两种机制，并根据问题选择最佳的机制。
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例已使用Eclipse IDE实现。如果您使用Eclipse或其他IDE，如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: First, you have to implement the tasks that will be executed by the server.
    Create a class named `Task` that implements the `Runnable` interface.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您必须实现将由服务器执行的任务。创建一个名为`Task`的类，实现`Runnable`接口。
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Declare a `Date` attribute named `initDate` to store the creation date of the
    task and a `String` attribute named `name` to store the name of the task.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`initDate`的`Date`属性，用于存储任务的创建日期，以及一个名为`name`的`String`属性，用于存储任务的名称。
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Implement the constructor of the class that initializes both attributes.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现初始化两个属性的类的构造函数。
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Implement the `run()` method.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, write to the console the `initDate` attribute and the actual date, which
    is the starting date of the task.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将`initDate`属性和实际日期写入控制台，即任务的开始日期。
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then, put the task to sleep for a random period of time.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让任务随机休眠一段时间。
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, write to the console the completion date of the task.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将任务的完成日期写入控制台。
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, implement the `Server` class that will execute every task it receives using
    an executor. Create a class named `Server`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现`Server`类，它将使用执行器执行接收到的每个任务。创建一个名为`Server`的类。
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Declare a `ThreadPoolExecutor` attribute named `executor`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`executor`的`ThreadPoolExecutor`属性。
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Implement the constructor of the class that initializes the `ThreadPoolExecutor`
    object using the `Executors` class.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现初始化`ThreadPoolExecutor`对象的类的构造函数，使用`Executors`类。
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Implement the `executeTask()` method. It receives a `Task` object as a parameter
    and sends it to the executor. First, write a message to the console indicating
    that a new task has arrived.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`executeTask()`方法。它接收一个`Task`对象作为参数，并将其发送到执行器。首先，在控制台上写入一条消息，指示新任务已到达。
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then, call the `execute()` method of the executor to send it the task.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调用执行器的`execute()`方法来发送任务。
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, write some executor data to the console to see its status.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将一些执行器数据写入控制台，以查看其状态。
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Implement the `endServer()` method. In this method, call the `shutdown()` method
    of the executor to finish its execution.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`endServer()`方法。在这个方法中，调用执行器的`shutdown()`方法来结束其执行。
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finally, implement the main class of the example by creating a class named `Main`
    and implement the `main()` method.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过创建一个名为`Main`的类并实现`main()`方法来实现示例的主类。
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The key of this example is the `Server` class. This class creates and uses `ThreadPoolExecutor`
    to execute tasks.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的关键是`Server`类。这个类创建并使用`ThreadPoolExecutor`来执行任务。
- en: The first important point is the creation of `ThreadPoolExecutor` in the constructor
    of the `Server` class. The `ThreadPoolExecutor` class has four different constructors
    but, due to their complexity, the Java concurrency API provides the `Executors`
    class to construct executors and other related objects. Although we can create
    `ThreadPoolExecutor` directly using one of its constructors, it's recommended
    to use the `Executors` class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个重要的点是在`Server`类的构造函数中创建`ThreadPoolExecutor`。`ThreadPoolExecutor`类有四个不同的构造函数，但是由于其复杂性，Java并发API提供了`Executors`类来构造执行器和其他相关对象。虽然我们可以直接使用其中一个构造函数来创建`ThreadPoolExecutor`，但建议使用`Executors`类。
- en: In this case, you have created a cached thread pool using the `newCachedThreadPool()`
    method. This method returns an `ExecutorService` object, so it's been cast to
    `ThreadPoolExecutor` to have access to all its methods. The cached thread pool
    you have created creates new threads if needed to execute the new tasks, and reuses
    the existing ones if they have finished the execution of the task they were running,
    which are now available. The reutilization of threads has the advantage that it
    reduces the time taken for thread creation. The cached thread pool has, however,
    a disadvantage of constant lying threads for new tasks, so if you send too many
    tasks to this executor, you can overload the system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你使用`newCachedThreadPool()`方法创建了一个缓存线程池。这个方法返回一个`ExecutorService`对象，因此被转换为`ThreadPoolExecutor`以便访问其所有方法。你创建的缓存线程池在需要执行新任务时创建新线程，并在现有线程完成任务执行后重用它们，这些线程现在可用。线程的重用有一个优点，就是它减少了线程创建所需的时间。然而，缓存线程池的缺点是为新任务不断保持线程，因此如果你向这个执行器发送太多任务，可能会使系统超载。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use the executor created by the `newCachedThreadPool()` method only when you
    have a reasonable number of threads or when they have a short duration.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在有合理数量的线程或者线程执行时间较短时，才使用`newCachedThreadPool()`方法创建的执行器。
- en: Once you have created the executor, you can send tasks of the `Runnable` or
    `Callable` type for execution using the `execute()` method. In this case, you
    send objects of the `Task` class that implements the `Runnable` interface.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了执行器，就可以使用`execute()`方法发送`Runnable`或`Callable`类型的任务进行执行。在这种情况下，你发送实现`Runnable`接口的`Task`类的对象。
- en: 'You also have printed some log messages with information about the executor.
    Specifically, you have used the following methods:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你还打印了一些关于执行器的日志信息。具体来说，你使用了以下方法：
- en: '`getPoolSize()`: This method returns the actual number of threads in the pool
    of the executor'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPoolSize()`: 此方法返回执行器池中实际的线程数量'
- en: '`getActiveCount()`: This method returns the number of threads that are executing
    tasks in the executor'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getActiveCount()`: 此方法返回执行器中正在执行任务的线程数量'
- en: '`getCompletedTaskCount()`: This method returns the number of tasks completed
    by the executor'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCompletedTaskCount()`: 此方法返回执行器完成的任务数量'
- en: One critical aspect of the `ThreadPoolExecutor` class, and of the executors
    in general, is that you have to end it explicitly. If you don't do this, the executor
    will continue its execution and the program won't end. If the executor doesn't
    have tasks to execute, it continues waiting for new tasks and it doesn't end its
    execution. A Java application won't end until all its non-daemon threads finish
    their execution, so, if you don't terminate the executor, your application will
    never end.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPoolExecutor`类和执行器的一个关键方面是你必须显式地结束它。如果不这样做，执行器将继续执行，程序将无法结束。如果执行器没有要执行的任务，它将继续等待新任务，并且不会结束执行。Java应用程序直到所有非守护线程执行完毕才会结束，因此如果不终止执行器，你的应用程序将永远不会结束。'
- en: To indicate to the executor that you want to finish it, you can use the `shutdown()`
    method of the `ThreadPoolExecutor` class. When the executor finishes the execution
    of all pending tasks, it finishes its execution. After you call the `shutdown()`
    method, if you try to send another task to the executor, it will be rejected and
    the executor will throw a `RejectedExecutionException` exception.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要指示执行器您要结束它，可以使用`ThreadPoolExecutor`类的`shutdown()`方法。当执行器完成所有待处理任务的执行时，它将结束执行。在调用`shutdown()`方法后，如果尝试向执行器发送另一个任务，将被拒绝，并且执行器将抛出`RejectedExecutionException`异常。
- en: 'The following screenshot shows part of one execution of this example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了此示例的一次执行的部分：
- en: '![How it works...](img/7881_04_01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/7881_04_01.jpg)'
- en: When the last task arrives to the server, the executor has a pool of 100 tasks
    and 97 active threads.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当最后一个任务到达服务器时，执行器有一个包含100个任务和97个活动线程的池。
- en: There's more...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `ThreadPoolExecutor` class provides a lot of methods to obtain information
    about its status. We used in the example the `getPoolSize()`, `getActiveCount()`,
    and `getCompletedTaskCount()` methods to obtain information about the size of
    the pool, the number of threads, and the number of completed tasks of the executor.
    You can also use the `getLargestPoolSize()` method that returns the maximum number
    of threads that has been in the pool at a time.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPoolExecutor`类提供了许多方法来获取有关其状态的信息。我们在示例中使用了`getPoolSize()`、`getActiveCount()`和`getCompletedTaskCount()`方法来获取有关池大小、线程数量和执行器已完成任务数量的信息。您还可以使用`getLargestPoolSize()`方法，该方法返回池中曾经同时存在的最大线程数。'
- en: 'The `ThreadPoolExecutor` class also provides other methods related with the
    finalization of the executor. These methods are:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPoolExecutor`类还提供了与执行器的完成相关的其他方法。这些方法包括：'
- en: '`shutdownNow()`: This method shut downs the executor immediately. It doesn''t
    execute the pending tasks. It returns a list with all these pending tasks. The
    tasks that are running when you call this method continue with their execution,
    but the method doesn''t wait for their finalization.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdownNow()`: 此方法立即关闭执行器。它不执行待处理的任务。它返回一个包含所有这些待处理任务的列表。当您调用此方法时正在运行的任务将继续执行，但该方法不会等待它们完成。'
- en: '`isTerminated()`: This method returns `true` if you have called the `shutdown()`
    or `shutdownNow()` methods and the executor finishes the process of shutting it
    down.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isTerminated()`: 如果您调用了`shutdown()`或`shutdownNow()`方法，并且执行器完成了关闭过程，则此方法返回`true`。'
- en: '`isShutdown()`: This method returns `true` if you have called the `shutdown()`
    method of the executor.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isShutdown()`: 如果您调用了执行器的`shutdown()`方法，则此方法返回`true`。'
- en: '`awaitTermination(long``timeout,``TimeUnit``unit)`: This method blocks the
    calling thread until the tasks of the executor have ended or the timeout occurs.
    The `TimeUnit` class is an enumeration with the following constants: `DAYS`, `HOURS`,
    `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awaitTermination(long``timeout,``TimeUnit``unit)`: 此方法阻塞调用线程，直到执行器的任务结束或超时发生。`TimeUnit`类是一个枚举，具有以下常量：`DAYS`、`HOURS`、`MICROSECONDS`、`MILLISECONDS`、`MINUTES`、`NANOSECONDS`和`SECONDS`。'
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to wait for the completion of the tasks, regardless of their duration,
    use a big timeout, for example, `DAYS`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想等待任务完成，无论其持续时间如何，可以使用较长的超时时间，例如`DAYS`。
- en: See also
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Controlling rejected tasks of an executor* recipe in [Chapter 4](ch04.html
    "Chapter 4. Thread Executors"), *Thread Executors*
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章 线程执行器") *线程执行器* 中的 *控制执行器的拒绝任务* 配方'
- en: The *Monitoring an Executor framework* recipe in [Chapter 8](ch08.html "Chapter 8. Testing
    Concurrent Applications"), *Testing Concurrent Applications*
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章 并发应用测试") *测试并发应用* 中的 *监视执行器框架* 配方'
- en: Creating a fixed-size thread executor
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建固定大小线程执行器
- en: When you use basic `ThreadPoolExecutor` created with the `newCachedThreadPool()`
    method of the `Executors` class, you can have a problem with the number of threads
    the executor is running at a time. The executor creates a new thread for each
    task that receives, (if there is no pooled thread free) so, if you send a large
    number of tasks and they have long duration, you can overload the system and provoke
    a poor performance of your application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用使用`Executors`类的`newCachedThreadPool()`方法创建的基本`ThreadPoolExecutor`时，可能会出现执行器同时运行的线程数量问题。执行器为每个接收到的任务创建一个新线程（如果没有空闲的池线程），因此，如果您发送大量任务并且它们持续时间很长，可能会过载系统并导致应用程序性能不佳。
- en: If you want to avoid this problem, the `Executors` class provides a method to
    create a fixed-size thread executor. This executor has a maximum number of threads.
    If you send more tasks than the number of threads, the executor won't create additional
    threads and the remaining tasks will be blocked until the executor has a free
    thread. With this behavior, you guarantee that the executor won't yield a poor
    performance of your application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要避免此问题，`Executors`类提供了一个创建固定大小线程执行器的方法。此执行器具有最大线程数。如果发送的任务多于线程数，执行器将不会创建额外的线程，并且剩余的任务将被阻塞，直到执行器有空闲线程。通过这种行为，您可以确保执行器不会导致应用程序性能不佳。
- en: In this recipe, you are going to learn how to create a fixed-size thread executor
    modifying the example implemented in the first recipe of this chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，您将学习如何创建一个固定大小的线程执行器，修改本章第一个配方中实现的示例。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You should read the *Creating a thread executor* recipe in this chapter and
    implement the example explained in it, because you're going to modify this example.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该阅读本章中的 *创建线程执行器* 配方，并实现其中解释的示例，因为您将修改此示例。
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的示例是使用Eclipse IDE实现的。如果您使用Eclipse或其他IDE（如NetBeans），请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Implement the example described in the first recipe of this chapter. Open the
    `Server` class and modify its constructor. Use the `newFixedThreadPool()` method
    to create the executor and pass the number `5` as the parameter.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现本章第一个示例中描述的示例。打开`Server`类并修改其构造函数。使用`newFixedThreadPool()`方法创建执行器，并将数字`5`作为参数传递。
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Modify the `executeTask()` method including an additional line of log message.
    Call the `getTaskCount()` method to obtain the number of tasks that have been
    sent to the executor.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`executeTask()`方法，包括一行额外的日志消息。调用`getTaskCount()`方法来获取已发送到执行器的任务数量。
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this case, you have used the `newFixedThreadPool()` method of the `Executors`
    class to create the executor. This method creates an executor with a maximum number
    of threads. If you send more tasks than the number of threads, the remaining tasks
    will be blocked until there is a free thread to process them This method receives
    the maximum number of threads as a parameter you want to have in your executor.
    In your case, you have created an executor with five threads.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您已经使用了`Executors`类的`newFixedThreadPool()`方法来创建执行器。此方法创建一个具有最大线程数的执行器。如果发送的任务多于线程数，剩余的任务将被阻塞，直到有空闲线程来处理它们。此方法接收最大线程数作为您希望在执行器中拥有的参数。在您的情况下，您已创建了一个具有五个线程的执行器。
- en: 'The following screenshot shows part of the output of one execution of this
    example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此示例的一次执行的部分输出：
- en: '![How it works...](img/7881_04_02.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_04_02.jpg)'
- en: 'To write the output of the program, you have used some methods of the `ThreadPoolExecutor`
    class, including:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写程序的输出，您已经使用了`ThreadPoolExecutor`类的一些方法，包括：
- en: '`getPoolSize()`: This method returns the actual number of threads in the pool
    of the executor'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPoolSize()`: 此方法返回执行器池中实际线程的数量'
- en: '`getActiveCount()`: This method returns the number of threads that are executing
    tasks in the executor'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getActiveCount()`: 此方法返回执行器中正在执行任务的线程数'
- en: You can see how the output of these methods is **5**, indicating that the executor
    has five threads. It does not exceed the established maximum number of threads.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到这些方法的输出是**5**，表示执行器有五个线程。它没有超过设定的最大线程数。
- en: When you send the last task to the executor, it has only **5** active threads.
    The remaining 95 tasks are waiting for free threads. We used the `getTaskCount()`
    method to show how many you have sent to the executor.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将最后一个任务发送到执行器时，它只有**5**个活动线程。剩下的95个任务正在等待空闲线程。我们使用`getTaskCount()`方法来显示您已发送到执行器的数量。
- en: There's more...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Executors` class also provides the `newSingleThreadExecutor()` method.
    This is an extreme case of a fixed-size thread executor. It creates an executor
    with only one thread, so it can only execute one task at a time.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executors`类还提供了`newSingleThreadExecutor()`方法。这是一个固定大小线程执行器的极端情况。它创建一个只有一个线程的执行器，因此一次只能执行一个任务。'
- en: See also
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a thread executor* recipe in [Chapter 4](ch04.html "Chapter 4. Thread
    Executors"), *Thread Executors*
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章. 线程执行器")中的*创建线程执行器*示例，*线程执行器*'
- en: The *Monitoring an Executor framework* recipe in [Chapter 8](ch08.html "Chapter 8. Testing
    Concurrent Applications"), *Testing Concurrent Applications*
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章. 测试并发应用")中的*监视执行器框架*示例，*测试并发应用*'
- en: Executing tasks in an executor that returns a result
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在返回结果的执行器中执行任务
- en: 'One of the advantages of the Executor framework is that you can run concurrent
    tasks that return a result. The Java Concurrency API achieves this with the following
    two interfaces:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器框架的一个优点是可以运行返回结果的并发任务。Java并发API通过以下两个接口实现了这一点：
- en: '`Callable`: This interface has the `call()` method. In this method, you have
    to implement the logic of a task. The `Callable` interface is a parameterized
    interface, meaning you have to indicate the type of data the `call()` method will
    return.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Callable`: 此接口有`call()`方法。在此方法中，您必须实现任务的逻辑。`Callable`接口是一个参数化接口，这意味着您必须指示`call()`方法将返回的数据类型。'
- en: '`Future`: This interface has some methods to obtain the result generated by
    a `Callable` object and to manage its state.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Future`: 此接口有一些方法，用于获取`Callable`对象生成的结果并管理其状态。'
- en: In this recipe, you will learn how to implement tasks that return a result and
    run them on an executor.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，您将学习如何实现返回结果的任务并在执行器上运行它们。
- en: Getting ready...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例已使用Eclipse IDE实现。如果您使用Eclipse或其他IDE，如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `FactorialCalculator`. Specify that it implements the `Callable`
    interface parameterized with the `Integer` type.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`FactorialCalculator`的类。指定它实现了带有`Integer`类型的`Callable`接口。
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`Declare` a private `Integer` attribute called `number` to store the number
    that this task will use for its calculations.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`声明`一个私有的`Integer`属性叫做`number`，用于存储此任务将用于计算的数字。'
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Implement the constructor of the class that initializes the attribute of the
    class.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现初始化类属性的类构造函数。
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Implement the `call()` method. This method returns the factorial of the `number`
    attribute of `FactorialCalculator`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`call()`方法。此方法返回`FactorialCalculator`的`number`属性的阶乘。
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, create and initialize the internal variables used in the method.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建并初始化方法中使用的内部变量。
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If the number is `0` or `1`, return `1`. Otherwise, calculate the factorial
    of the number. Between two multiplications, and for educational purposes, put
    this task to sleep for 20 milliseconds.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数字是`0`或`1`，则返回`1`。否则，计算数字的阶乘。在两次乘法之间，出于教育目的，让此任务休眠20毫秒。
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Write a message to the console with the result of the operation.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台上写入一条消息，其中包含操作的结果。
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Return the result of the operation.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回操作的结果。
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Implement the main class of the example by creating a class named `Main` and
    implement the `main()` method.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并实现`main()`方法来实现示例的主类。
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Create `ThreadPoolExecutor` to run the tasks using the `newFixedThreadPool()`
    method of the `Executors` class. Pass `2` as the parameter.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Executors`类的`newFixedThreadPool()`方法创建`ThreadPoolExecutor`来运行任务。将`2`作为参数传递。
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Create a list of `Future<Integer>` objects.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Future<Integer>`对象列表。
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Create a random number generator with the `Random` class.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Random`类创建一个随机数生成器。
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Generate 10 new random integers between zero and 10.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成10个新的随机整数，介于零和10之间。
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Create a `FactorialCaculator` object passing this random number as a parameter.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`FactorialCaculator`对象，传递这个随机数作为参数。
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Call the `submit()` method of the executor to send the `FactorialCalculator`
    task to the executor. This method returns a `Future<Integer>` object to manage
    the task, and eventually get its result.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用执行器的`submit()`方法，将`FactorialCalculator`任务发送到执行器。这个方法返回一个`Future<Integer>`对象来管理任务，并最终获得它的结果。
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Add the `Future` object to the list created before.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Future`对象添加到之前创建的列表中。
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Create a `do` loop to monitor the status of the executor.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`do`循环来监视执行器的状态。
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, write a message to the console indicating the number of completed tasks
    with the `getCompletedTaskNumber()` method of the executor.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用执行器的`getCompletedTaskNumber()`方法向控制台写入一条消息，指示已完成的任务数。
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Then, for the 10 `Future` objects in the list, write a message indicating whether
    the tasks that it manages have finished or not using the `isDone()` method.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，对列表中的10个`Future`对象，使用`isDone()`方法编写一条消息，指示它管理的任务是否已经完成。
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Put the thread to sleep for 50 milliseconds.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让线程睡眠50毫秒。
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Repeat this loop while the number of completed tasks of the executor is less
    than 10.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行器的已完成任务数小于10时重复此循环。
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Write to the console the results obtained by each task. For each `Future` object,
    get the `Integer` object returned by its task using the `get()` method.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个任务获得的结果写入控制台。对于每个`Future`对象，使用`get()`方法获取其任务返回的`Integer`对象。
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Then, print the number to the console.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将数字打印到控制台。
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Finally, call the `shutdown()` method of the executor to finalize its execution.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用执行器的`shutdown()`方法来结束其执行。
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, you have learned how to use the `Callable` interface to launch
    concurrent tasks that return a result. You have implemented the `FactorialCalculator`
    class that implements the `Callable` interface with `Integer` as the type of the
    result. Hence, it returns before type of the `call()` method.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您已经学会了如何使用`Callable`接口来启动返回结果的并发任务。您已经实现了`FactorialCalculator`类，该类实现了`Callable`接口，结果类型为`Integer`。因此，它在`call()`方法的返回类型之前返回。
- en: 'The other critical point of this example is in the `Main` class. You send a
    `Callable` object to be executed in an executor using the `submit()` method. This
    method receives a `Callable` object as a parameter and returns a `Future` object
    that you can use with two main objectives:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的另一个关键点在于`Main`类。您使用`submit()`方法将一个`Callable`对象发送到执行器中执行。这个方法接收一个`Callable`对象作为参数，并返回一个`Future`对象，您可以用它来实现两个主要目标：
- en: 'You can control the status of the task: you can cancel the task and check if
    it has finished. For this purpose, you have used the `isDone()` method to check
    if the tasks had finished.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以控制任务的状态：您可以取消任务并检查它是否已完成。为此，您已经使用了`isDone()`方法来检查任务是否已完成。
- en: You can get the result returned by the `call()` method. For this purpose, you
    have used the `get()` method. This method waits until the `Callable` object has
    finished the execution of the `call()` method and has returned its result. If
    the thread is interrupted while the `get()` method is waiting for the result,
    it throws an `InterruptedException` exception. If the `call()` method throws an
    exception, this method throws an `ExecutionException` exception.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以获得`call()`方法返回的结果。为此，您已经使用了`get()`方法。该方法等待，直到`Callable`对象完成`call()`方法的执行并返回其结果。如果在`get()`方法等待结果时线程被中断，它会抛出`InterruptedException`异常。如果`call()`方法抛出异常，该方法会抛出`ExecutionException`异常。
- en: There's more...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When you call the `get()` method of a `Future` object and the task controlled
    by this object hasn't finished yet, the method blocks until the task finishes.
    The `Future` interface provides another version of the `get()` method.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用`Future`对象的`get()`方法时，如果由该对象控制的任务尚未完成，该方法将阻塞直到任务完成。`Future`接口提供了`get()`方法的另一个版本。
- en: '`get(long``timeout,``TimeUnit``unit)`: This version of the get method, if the
    result of the task isn''t available, waits for it for the specified time. If the
    specified period of time passes and the result isn''t yet available, the method
    returns a `null` value. The `TimeUnit` class is an enumeration with the following
    constants: `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`,
    and `SECONDS`.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(long``timeout,``TimeUnit``unit)`: 如果任务的结果不可用，此版本的`get`方法会等待指定的时间。如果指定的时间段过去了，结果仍然不可用，该方法将返回`null`值。`TimeUnit`类是一个枚举，具有以下常量：`DAYS`、`HOURS`、`MICROSECONDS`、`MILLISECONDS`、`MINUTES`、`NANOSECONDS`和`SECONDS`。'
- en: See also
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a thread executor* recipe in [Chapter 4](ch04.html "Chapter 4. Thread
    Executors"), *Thread Executors*
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章 线程执行器")中的*创建线程执行器*配方，*线程执行器*'
- en: The *Running multiple tasks and processing the first result* recipe in [Chapter
    4](ch04.html "Chapter 4. Thread Executors"), *Thread Executors*
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章 线程执行器")中的*运行多个任务并处理第一个结果*配方，*线程执行器*'
- en: The *Running multiple tasks and processing all the results* recipe in [Chapter
    4](ch04.html "Chapter 4. Thread Executors"), *Thread Executors*
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章 线程执行器")中的*运行多个任务并处理所有结果*配方，*线程执行器*'
- en: Running multiple tasks and processing the first result
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行多个任务并处理第一个结果
- en: A common problem in concurrent programming is when you have various concurrent
    tasks that solve a problem, and you are only interested in the first result of
    those tasks. For example, you want to sort an array. You have various sort algorithms.
    You can launch all of them and get the result of the first one that sorts these,
    that is, the fastest sorting algorithm for a given array.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程中的一个常见问题是当您有各种并发任务来解决一个问题，而您只对这些任务的第一个结果感兴趣。例如，您想对数组进行排序。您有各种排序算法。您可以启动它们所有，并获得首个对数组进行排序的结果，也就是说，对于给定数组来说，最快的排序算法。
- en: In this recipe, you will learn how to implement this scenario using the `ThreadPoolExecutor`
    class. You are going to implement an example where a user can be validated by
    two mechanisms. The user will be validated if one of those mechanisms validates
    it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，您将学习如何使用`ThreadPoolExecutor`类实现此场景。您将实现一个示例，其中用户可以通过两种机制进行验证。如果其中一种机制对用户进行验证，则用户将通过验证。
- en: Getting ready
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例使用Eclipse IDE实现。如果您使用Eclipse或其他IDE，如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `UserValidator` that will implement the process of user
    validation.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`UserValidator`的类，它将实现用户验证的过程。
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Declare a private `String` attribute named `name` that will store the name of
    a user validation system.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`name`的私有`String`属性，它将存储用户验证系统的名称。
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Implement the constructor of the class that initializes its attributes.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现初始化其属性的类的构造函数。
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Implement the `validate()` method. It receives two `String` parameters with
    the name and the password of the user you want to validate.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`validate()`方法。它接收两个`String`参数，分别是要验证的用户的名称和密码。
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Create a `Random` object named `random`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`random`的`Random`对象。
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Wait for a random period of time to simulate the process of user validation.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待随机一段时间以模拟用户验证过程。
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Return a random `Boolean` value. The method returns a `true` value when the
    user is validated and a `false` value when the user is not validated.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个随机的`Boolean`值。当用户通过验证时，该方法返回`true`值，当用户未通过验证时，该方法返回`false`值。
- en: '[PRE47]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Implement the `getName()` method. This method returns the value of the name
    attribute.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`getName()`方法。此方法返回名称属性的值。
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now, create a class named `TaskValidator` that will execute a validation process
    with a `UserValidation` object as a concurrent task. Specify that it implements
    the `Callable` interface parameterized with the `String` class.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`TaskValidator`的类，它将使用`UserValidation`对象作为并发任务执行验证过程。指定它实现了参数化为`String`类的`Callable`接口。
- en: '[PRE49]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Declare a private `UserValidator` attribute named `validator`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`validator`的私有`UserValidator`属性。
- en: '[PRE50]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Declare two private `String` attributes named `user` and `password`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个名为`user`和`password`的私有`String`属性。
- en: '[PRE51]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Implement the constructor of the class that will initialize all the attributes.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现将初始化所有属性的类的构造函数。
- en: '[PRE52]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Implement the `call()` method that will return a `String` object.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现将返回`String`对象的`call()`方法。
- en: '[PRE53]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If the user is not validated by the `UserValidator` object, write a message
    to the console indicating this circumstance and throw an `Exception` exception.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户未通过`UserValidator`对象进行验证，则向控制台写入一条消息指示此情况，并抛出`Exception`异常。
- en: '[PRE54]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Otherwise, write a message to the console indicating that the user has been
    validated and return the name of the `UserValidator` object.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，向控制台写入一条消息，指示用户已经通过验证，并返回`UserValidator`对象的名称。
- en: '[PRE55]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now, implement the main class of the example by creating a class named `Main`
    and add the `main()` method to it.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过创建一个名为`Main`的类并向其中添加`main()`方法来实现示例的主类。
- en: '[PRE56]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Create two `String` objects named `user` and `password` and initialize them
    with the `test` value.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个名为`user`和`password`的`String`对象，并将它们初始化为`test`值。
- en: '[PRE57]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Create two `UserValidator` objects named `ldapValidator` and `dbValidator`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个名为`ldapValidator`和`dbValidator`的`UserValidator`对象。
- en: '[PRE58]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Create two `TaskValidator` objects named `ldapTask` and `dbTask`. Initialize
    them with `ldapValidator` and `dbValidator` respectively.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个名为`ldapTask`和`dbTask`的`TaskValidator`对象。将它们分别初始化为`ldapValidator`和`dbValidator`。
- en: '[PRE59]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Create a list of `TaskValidator` objects and add to it the two objects that
    you have created.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`TaskValidator`对象列表，并将您创建的两个对象添加到其中。
- en: '[PRE60]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Create a new `ThreadPoolExecutor` object using the `newCachedThreadPool()` method
    of the `Executors` class and a `String` object named `result`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Executors`类的`newCachedThreadPool()`方法创建一个新的`ThreadPoolExecutor`对象和一个名为`result`的`String`对象。
- en: '[PRE61]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Call the `invokeAny()` method of the `executor` object. This method receives
    `taskList` as a parameter and returns `String`. Also, it writes the `String` object
    returned by this method to the console.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`executor`对象的`invokeAny()`方法。此方法接收`taskList`作为参数并返回`String`。此外，它将由此方法返回的`String`对象写入控制台。
- en: '[PRE62]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Terminate the executor using the `shutdown()` method and write a message to
    the console to indicate that the program has ended.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法终止执行程序，并向控制台写入一条消息以指示程序已结束。
- en: '[PRE63]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key of the example is in the `Main` class. The `invokeAny()` method of the
    `ThreadPoolExecutor` class receives a list of tasks, launches them, and returns
    the result of the first task that finishes without throwing an exception. This
    method returns the same data type that the `call()` method of the tasks you launch
    returns. In this case, it returns a `String` value.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的关键在于`Main`类。`ThreadPoolExecutor`类的`invokeAny()`方法接收任务列表，启动它们，并返回第一个完成而不抛出异常的任务的结果。此方法返回与您启动的任务的`call()`方法返回的相同的数据类型。在本例中，它返回一个`String`值。
- en: 'The following screenshot shows the output of an execution of the example when
    one task validates the user:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了示例执行的输出，当一个任务验证了用户时：
- en: '![How it works...](img/7881_04_03.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_04_03.jpg)'
- en: The example has two `UserValidator` objects that return a random `boolean` value.
    Each `UserValidator` object is used by a `Callable` object, implemented by the
    `TaskValidator` class. If the `validate()` method of the `UserValidator` class
    returns a `false` value, the `TaskValidator` class throws `Exception`. Otherwise,
    it returns the `true` value.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 示例有两个`UserValidator`对象，返回一个随机的`boolean`值。每个`UserValidator`对象都被一个`Callable`对象使用，由`TaskValidator`类实现。如果`UserValidator`类的`validate()`方法返回`false`值，`TaskValidator`类会抛出`Exception`。否则，它返回`true`值。
- en: 'So, we have two tasks that can return the `true` value or throw an `Exception`
    exception. You can have the following four possibilities:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有两个任务，可以返回`true`值，也可以抛出`Exception`异常。您可以有以下四种可能性：
- en: Both tasks return the `true` value. The result of the `invokeAny()` method is
    the name of the task that finishes in the first place.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个任务都返回`true`值。`invokeAny()`方法的结果是第一个完成的任务的名称。
- en: The first task returns the `true` value and the second one throws `Exception`.
    The result of the `invokeAny()` method is the name of the first task.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个任务返回`true`值，第二个任务抛出`Exception`。`invokeAny()`方法的结果是第一个任务的名称。
- en: The first task throws `Exception` and the second one returns the `true` value.
    The result of the `invokeAny()` method is the name of the second task.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个任务抛出`Exception`，第二个任务返回`true`值。`invokeAny()`方法的结果是第二个任务的名称。
- en: Both tasks throw `Exception`. In that class, the `invokeAny()` method throws
    an `ExecutionException` exception.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个任务都会抛出`Exception`。在该类中，`invokeAny()`方法会抛出`ExecutionException`异常。
- en: If you run the examples several times, you get the four possible solutions you
    can get.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多次运行示例，您可以得到四种可能的解决方案。
- en: 'The following screenshot shows the output of the application when both tasks
    throw an exception:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了应用程序的输出，当两个任务都抛出异常时：
- en: '![How it works...](img/7881_04_04.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/7881_04_04.jpg)'
- en: There's more...
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `ThreadPoolExecutor` class provides another version of the `invokeAny()`
    method:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPoolExecutor`类提供了`invokeAny()`方法的另一个版本：'
- en: '`invokeAny(Collection<?``extends``Callable<T>>``tasks,``long``timeout,``TimeUnit``unit)`:
    This method executes all the tasks and returns the result of the first one that
    finishes without throwing an exception, if it finishes before the given timeout
    passes. The `TimeUnit` class is an enumeration with the following constants: `DAYS`,
    `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit
    unit)`: 此方法执行所有任务，并在给定的超时时间之前完成的第一个任务的结果，如果在给定的超时时间之前完成而不抛出异常，则返回。`TimeUnit`类是一个枚举，具有以下常量：`DAYS`，`HOURS`，`MICROSECONDS`，`MILLISECONDS`，`MINUTES`，`NANOSECONDS`和`SECONDS`。'
- en: See also
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Running multiple tasks and processing all the results* recipe in [Chapter
    4](ch04.html "Chapter 4. Thread Executors"), *Thread Executors*
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章. 线程执行程序")中的*运行多个任务并处理所有结果*示例，*线程执行程序*'
- en: Running multiple tasks and processing all the results
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行多个任务并处理所有结果
- en: The Executor framework allows you to execute concurrent tasks without worrying
    about thread creation and execution. It provides you the `Future` class that you
    can use to control the status and get the results of any task executed in an executor.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Executor框架允许您执行并发任务，而无需担心线程的创建和执行。它为您提供了`Future`类，您可以使用它来控制任何在执行程序中执行的任务的状态并获取结果。
- en: 'When you want to wait for the finalization of a task, you can use the following
    two methods:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要等待任务的完成时，可以使用以下两种方法：
- en: The `isDone()` method of the `Future` interface returns `true` if the task has
    finished its execution.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Future`接口的`isDone()`方法在任务完成执行时返回`true`。'
- en: The `awaitTermination()` method of the `ThreadPoolExecutor` class puts the thread
    to sleep until all the tasks have finished their execution after a call to the
    `shutdown()` method.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThreadPoolExecutor`类的`awaitTermination()`方法使线程休眠，直到所有任务在调用`shutdown()`方法后完成执行。'
- en: These two methods have some drawbacks. With the first one, you can only control
    the completion of a task, and with the second one, you have to shutdown the executor
    to wait for a thread, otherwise the method's call returns immediately.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有一些缺点。使用第一种方法，您只能控制任务的完成，而使用第二种方法，您必须关闭执行程序以等待线程，否则方法的调用会立即返回。
- en: The `ThreadPoolExecutor` class provides a method that allows you to send to
    the executor a list of tasks and wait for the finalization of all the tasks in
    the list. In this recipe, you will learn how to use this feature by implementing
    an example with three tasks executed and their results printed out when they finish.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPoolExecutor`类提供了一种方法，允许您向执行程序发送任务列表，并等待列表中所有任务的完成。在这个示例中，您将学习如何通过实现一个包含三个任务的示例来使用这个特性，并在它们完成时打印出它们的结果。'
- en: Getting ready
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例已使用Eclipse IDE实现。如果您使用Eclipse或其他IDE，如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `Result` to store the results generated in the concurrent
    tasks of this example.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Result`的类，用于存储此示例中并发任务生成的结果。
- en: '[PRE64]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Declare two private attributes. One `String` attribute named `name` and one
    `int` attribute named `value`.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个私有属性。一个名为`name`的`String`属性，一个名为`value`的`int`属性。
- en: '[PRE65]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Implement the corresponding `get()` and `set()` methods to set and return the
    value of the name and value attributes.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现相应的`get()`和`set()`方法来设置和返回名称和值属性的值。
- en: '[PRE66]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Create a class named `Task` that implements the `Callable` interface parameterized
    with the `Result` class.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，实现带有`Result`类参数的`Callable`接口。
- en: '[PRE67]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Declare a private `String` attribute named `name`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`name`的私有`String`属性。
- en: '[PRE68]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Implement the constructor of the class that initializes its attribute.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现初始化其属性的类的构造函数。
- en: '[PRE69]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Implement the `call()` method of the class. In this case, this method will return
    a `Result` object.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的`call()`方法。在这种情况下，此方法将返回一个`Result`对象。
- en: '[PRE70]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: First, write a message to the console to indicate that the task is starting.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，向控制台写入一条消息，指示任务正在开始。
- en: '[PRE71]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Then, wait for a random period of time.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，等待随机一段时间。
- en: '[PRE72]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: To generate an `int` value to return in the `Result` object, calculate the sum
    of five random numbers.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了生成要在`Result`对象中返回的`int`值，计算五个随机数的总和。
- en: '[PRE73]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Create a `Result` object and initialize it with the name of this task and the
    result of the operation done earlier.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Result`对象，并使用此任务的名称和先前完成的操作的结果对其进行初始化。
- en: '[PRE74]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Write a message to the console to indicate that the task has finished.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控制台写入一条消息，指示任务已经完成。
- en: '[PRE75]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Return the `Result` object.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`Result`对象。
- en: '[PRE76]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Finally, implement the main class of the example by creating a class named `Main`
    and add the `main()` method to it.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过创建一个名为`Main`的类并向其中添加`main()`方法来实现示例的主类。
- en: '[PRE77]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Create a `ThreadPoolExecutor` object using the `newCachedThreadPool()` method
    of the `Executors` class.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Executors`类的`newCachedThreadPool()`方法创建一个`ThreadPoolExecutor`对象。
- en: '[PRE78]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Create a list of `Task` objects. Create three `Task` objects and save them on
    that list.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Task`对象列表。创建三个`Task`对象并将它们保存在该列表中。
- en: '[PRE79]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Create a list of `Future` objects. These objects are parameterized with the
    `Result` class.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Future`对象列表。这些对象使用`Result`类进行参数化。
- en: '[PRE80]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Call the `invokeAll()` method of the `ThreadPoolExecutor` class. This class
    will return the list of the `Future` objects created earlier.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`ThreadPoolExecutor`类的`invokeAll()`方法。此类将返回先前创建的`Future`对象的列表。
- en: '[PRE81]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Finalize the executor using the `shutdown()` method.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法终止执行程序。
- en: '[PRE82]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Write the results of the tasks processing the list of the `Future` objects.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入处理`Future`对象列表的任务结果。
- en: '[PRE83]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: How it works...
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, you have learned how to send a list of tasks to an executor
    and wait for the finalization of all of them using the `invokeAll()` method. This
    method receives a list of the `Callable` objects and returns a list of the `Future`
    objects. This list will have a `Future` object per task in the list. The first
    object in the list of the `Future` objects will be the object that controls the
    first task in the list of the `Callable` objects, and so on.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您已经学会了如何将任务列表发送到执行程序，并使用`invokeAll()`方法等待它们全部完成。此方法接收`Callable`对象的列表并返回`Future`对象的列表。此列表将为列表中的每个任务具有一个`Future`对象。`Future`对象列表中的第一个对象将是控制列表中`Callable`对象的第一个任务的对象，依此类推。
- en: 'The first point to take into consideration is that the type of data used for
    the parameterization of the `Future` interface in the declaration of the list
    that stores the result objects must be compatible with the one used to parameterized
    the `Callable` objects. In this case, you have used the same type of data: the
    `Result` class.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要考虑的一点是，在存储结果对象的列表的声明中，用于参数化`Future`接口的数据类型必须与用于参数化`Callable`对象的数据类型兼容。在这种情况下，您使用了相同类型的数据：`Result`类。
- en: Another important point about the `invokeAll()` method is that you will use
    the `Future` objects only to get the results of the tasks. As the method finishes
    when all the tasks have finished, if you call the `isDone()` method of the `Future`
    objects that is returned, all the calls will return the `true` value.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`invokeAll()`方法的另一个重要点是，您将仅使用`Future`对象来获取任务的结果。由于该方法在所有任务完成时结束，如果调用返回的`Future`对象的`isDone()`方法，所有调用都将返回`true`值。
- en: There's more...
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `ExecutorService` class provides another version of the `invokeAll()` method:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecutorService`类提供了`invokeAll()`方法的另一个版本：'
- en: '`invokeAll(Collection<?``extends``Callable<T>>``tasks,``long``timeout,``TimeUnit``unit)`:
    This method executes all the tasks and returns the result of their execution when
    all of them have finished, if they finish before the given timeout passes. The
    `TimeUnit` class is an enumeration with the following constants: `DAYS`, `HOURS`,
    `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokeAll(Collection<?``extends``Callable<T>>``tasks,``long``timeout,``TimeUnit``unit)`:
    此方法执行所有任务，并在所有任务都完成时返回它们的执行结果，如果它们在给定的超时时间之前完成。`TimeUnit`类是一个枚举，具有以下常量：`DAYS`，`HOURS`，`MICROSECONDS`，`MILLISECONDS`，`MINUTES`，`NANOSECONDS`和`SECONDS`。'
- en: See also
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Executing tasks in an executor that returns a result* recipe in [Chapter
    4](ch04.html "Chapter 4. Thread Executors"), *Thread Executors*
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章. 线程执行程序")中的*在返回结果的执行程序中执行任务*食谱，*线程执行程序*'
- en: The *Running multiple tasks and processing the first result* recipe in [Chapter
    4](ch04.html "Chapter 4. Thread Executors"), *Thread Executors*
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章. 线程执行程序")中的*运行多个任务并处理第一个结果*食谱，*线程执行程序*'
- en: Running a task in an executor after a delay
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在延迟后在执行程序中运行任务
- en: The Executor framework provides the `ThreadPoolExecutor` class to execute `Callable`
    and `Runnable` tasks with a pool of threads, which avoid you all the thread creation
    operations. When you send a task to the executor, it's executed as soon as possible,
    according to the configuration of the executor. There are used cases when you
    are not interested in executing a task as soon as possible. You may want to execute
    a task after a period of time or to execute a task periodically. For these purposes,
    the Executor framework provides the `ScheduledThreadPoolExecutor` class.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 执行程序框架提供了`ThreadPoolExecutor`类，用于使用线程池执行`Callable`和`Runnable`任务，避免了所有线程创建操作。当您将任务发送到执行程序时，它将根据执行程序的配置尽快执行。有些情况下，您可能不希望尽快执行任务。您可能希望在一段时间后执行任务，或者定期执行任务。为此，执行程序框架提供了`ScheduledThreadPoolExecutor`类。
- en: In this recipe, you will learn how to create `ScheduledThreadPoolExecutor` and
    how to use it to schedule execution of a task after a given period of time.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将学习如何创建`ScheduledThreadPoolExecutor`以及如何使用它在一定时间后安排任务的执行。
- en: Getting ready
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的例子是使用Eclipse IDE实现的。如果你使用Eclipse或其他IDE如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `Task` that implements the `Callable` interface parameterized
    with the `String` class.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，实现参数为`String`类的`Callable`接口。
- en: '[PRE84]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Declare a private `String` attribute named `name` that will store the name of
    the task.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的`String`属性，名为`name`，用来存储任务的名称。
- en: '[PRE85]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Implement the constructor of the class that initializes the `name` attribute.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现初始化`name`属性的类的构造函数。
- en: '[PRE86]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Implement the `call()` method. Write a message to the console with the actual
    date and return a text, for example, `Hello, world`.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`call()`方法。在控制台上写入一个带有实际日期的消息，并返回一个文本，例如`Hello, world`。
- en: '[PRE87]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并在其中添加`main()`方法来实现示例的主类。
- en: '[PRE88]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Create an executor of the `ScheduledThreadPoolExecutor` class using the `newScheduledThreadPool()`
    method of the `Executors` class passing `1` as a parameter.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Executors`类的`newScheduledThreadPool()`方法创建一个`ScheduledThreadPoolExecutor`类的执行器，传递`1`作为参数。
- en: '[PRE89]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Initialize and start a few tasks (five in our case) with the `schedule()` method
    of the `ScheduledThreadPoolExecutor` instance.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化并启动一些任务（在我们的例子中为五个），使用`ScheduledThreadPoolExecutor`实例的`schedule()`方法。
- en: '[PRE90]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Request the finalization of the executor using the `shutdown()` method.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法请求执行器的完成。
- en: '[PRE91]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Wait for the finalization of all the tasks using the `awaitTermination()` method
    of the executor.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用执行器的`awaitTermination()`方法等待所有任务的完成。
- en: '[PRE92]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Write a message to indicate the time when the program finishes.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一条消息来指示程序完成的时间。
- en: '[PRE93]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: How it works...
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key point of this example is the `Main` class and the management of `ScheduledThreadPoolExecutor`.
    As with class `ThreadPoolExecutor`, to create a scheduled executor, Java recommends
    the utilization of the `Executors` class. In this case, you have to use the `newScheduledThreadPool()`
    method. You have passed the number `1` as a parameter to this method. This parameter
    is the number of threads you want to have in the pool.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的关键点是`Main`类和`ScheduledThreadPoolExecutor`的管理。与`ThreadPoolExecutor`类一样，为了创建一个定时执行器，Java建议使用`Executors`类。在这种情况下，你需要使用`newScheduledThreadPool()`方法。你需要将数字`1`作为参数传递给这个方法。这个参数是你想要在池中拥有的线程数。
- en: 'To execute a task in this scheduled executor after a period of time, you have
    to use the `schedule()` method. This method receives the following three parameters:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要在定时执行器中在一段时间后执行任务，你需要使用`schedule()`方法。这个方法接收以下三个参数：
- en: The task you want to execute
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要执行的任务
- en: The period of time you want the task to wait before its execution
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你希望任务在执行之前等待的时间段
- en: The unit of the period of time, specified as a constant of the `TimeUnit` class
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间段的单位，指定为`TimeUnit`类的常量。
- en: In this case, each task will wait for a number of seconds (`TimeUnit.SECONDS`)
    equal to its position in the array of tasks plus one.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个任务将等待一定数量的秒数（`TimeUnit.SECONDS`），等于其在任务数组中的位置加一。
- en: Note
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to execute a task at a given time, calculate the difference between
    that date and the current date and use that difference as the delay of the task.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在特定时间执行一个任务，计算那个日期和当前日期之间的差异，并将这个差异作为任务的延迟。
- en: 'The following screenshot shows the output of an execution of this example:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此示例执行的输出：
- en: '![How it works...](img/7881_04_05.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_04_05.jpg)'
- en: You can see how the tasks start their execution one per second. All the tasks
    are sent to the executor at the same time, but each one with a delay of 1 second
    later than the previous task.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到任务如何每秒开始执行一次。所有任务都同时发送到执行器，但每个任务的延迟比前一个任务晚1秒。
- en: There's more...
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can also use the `Runnable` interface to implement the tasks, because the
    `schedule()` method of the `ScheduledThreadPoolExecutor` class accepts both types
    of tasks.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`Runnable`接口来实现任务，因为`ScheduledThreadPoolExecutor`类的`schedule()`方法接受这两种类型的任务。
- en: Although the `ScheduledThreadPoolExecutor` class is a child class of the `ThreadPoolExecutor`
    class and, therefore, inherits all its features, Java recommends the utilization
    of `ScheduledThreadPoolExecutor` only for scheduled tasks.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`ScheduledThreadPoolExecutor`类是`ThreadPoolExecutor`类的子类，因此继承了所有的特性，但Java建议仅将`ScheduledThreadPoolExecutor`用于定时任务。
- en: Finally, you can configure the behavior of the `ScheduledThreadPoolExecutor`
    class when you call the `shutdown()` method and there are pending tasks waiting
    for the end of their delay time. The default behavior is that those tasks will
    be executed despite the finalization of the executor. You can change this behavior
    using the `setExecuteExistingDelayedTasksAfterShutdownPolicy()` method of the
    `ScheduledThreadPoolExecutor` class. With `false`, at the time of `shutdown()`,
    pending tasks won't get executed.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当你调用`shutdown()`方法并且有待处理的任务等待其延迟时间结束时，你可以配置`ScheduledThreadPoolExecutor`类的行为。默认行为是，尽管执行器已经完成，这些任务仍将被执行。你可以使用`ScheduledThreadPoolExecutor`类的`setExecuteExistingDelayedTasksAfterShutdownPolicy()`方法来改变这个行为。使用`false`，在`shutdown()`时，待处理的任务将不会被执行。
- en: See also
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Executing tasks in an executor that returns a result* recipe in [Chapter
    4](ch04.html "Chapter 4. Thread Executors"), *Thread Executors*
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章. 线程执行器")中的*在返回结果的执行器中执行任务*食谱，*线程执行器*'
- en: Running a task in an executor periodically
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定期在执行器中运行任务
- en: The Executor framework provides the `ThreadPoolExecutor` class to execute concurrent
    tasks using a pool of threads that avoids you all the thread creation operations.
    When you send a task to the executor, according to its configuration, it executes
    the task as soon as possible. When it ends, the task is deleted from the executor
    and, if you want to execute them again, you have to send it again to the executor.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: Executor框架提供了`ThreadPoolExecutor`类，使用线程池执行并发任务，避免了所有线程创建操作。当您将任务发送到执行程序时，根据其配置，它会尽快执行任务。当任务结束时，任务将从执行程序中删除，如果您想再次执行它们，您必须再次将其发送到执行程序。
- en: But the Executor framework provides the possibility of executing periodic tasks
    through the `ScheduledThreadPoolExecutor` class. In this recipe, you will learn
    how to use this functionality of that class to schedule a periodic task.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，Executor框架提供了通过`ScheduledThreadPoolExecutor`类执行定期任务的可能性。在这个食谱中，您将学习如何使用该类的这个功能来安排一个定期任务。
- en: Getting ready
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的例子是使用Eclipse IDE实现的。如果您使用Eclipse或其他IDE，如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `Task` and specify that it implements the `Runnable` interface.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，并指定它实现`Runnable`接口。
- en: '[PRE94]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Declare a private `String` attribute named `name` that will store the name of
    the task.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`name`的私有`String`属性，它将存储任务的名称。
- en: '[PRE95]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Implement the constructor of the class that initializes that attribute.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现初始化该属性的类的构造函数。
- en: '[PRE96]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Implement the `run()` method. Write a message to the console with the actual
    date to verify that the task is executed within the specified period.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。向控制台写入一个带有实际日期的消息，以验证任务是否在指定的时间内执行。
- en: '[PRE97]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Implement the main class of the example by creating a class named `Main` and
    implement the `main()` method in it.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并在其中实现`main()`方法来实现示例的主类。
- en: '[PRE98]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Create `ScheduledThreadPoolExecutor` using the `newScheduledThreadPool()` method
    of the `Executors` class. Pass the number `1` as the parameter to that method.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Executors`类的`newScheduledThreadPool()`方法创建`ScheduledThreadPoolExecutor`。将数字`1`作为该方法的参数。
- en: '[PRE99]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Write a message to the console with the actual date.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控制台写入一个带有实际日期的消息。
- en: '[PRE100]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Create a new `Task` object.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Task`对象。
- en: '[PRE101]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Send it to the executor using the `scheduledAtFixRate()` method. Use as parameters
    the task created earlier, the number one, the number two, and the constant `TimeUnit.SECONDS`.
    This method returns a `ScheduledFuture` object that you can use to control the
    status of the task.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`scheduledAtFixRate()`方法将其发送到执行程序。将任务创建的参数、数字一、数字二和常量`TimeUnit.SECONDS`作为参数。该方法返回一个`ScheduledFuture`对象，您可以使用它来控制任务的状态。
- en: '[PRE102]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Create a loop with 10 steps to write the time remaining for the next execution
    of the task. In the loop, use the `getDelay()` method of the `ScheduledFuture`
    object to get the number of milliseconds until the next execution of the task.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个循环，有10个步骤来写入任务下次执行的剩余时间。在循环中，使用`ScheduledFuture`对象的`getDelay()`方法来获取直到任务下次执行的毫秒数。
- en: '[PRE103]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Finish the executor using the `shutdown()` method.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法结束执行程序。
- en: '[PRE104]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Put the thread to sleep for 5 seconds to verify that the periodic tasks have
    finished.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将线程休眠5秒，以验证定期任务是否已经完成。
- en: '[PRE105]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Write a message to indicate the end of the program.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一条消息来指示程序的结束。
- en: '[PRE106]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: How it works...
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you want to execute a periodic task using the Executor framework, you need
    a `ScheduledExecutorService` object. To create it (as with every executor), Java
    recommends the use of the `Executors` class. This class works as a factory of
    executor objects. In this case, you should use the `newScheduledThreadPool()`
    method to create a `ScheduledExecutorService` object. That method receives as
    a parameter the number of threads of the pool. As you have only one task in this
    example, you have passed the value `1` as a parameter.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要使用Executor框架执行定期任务时，您需要一个`ScheduledExecutorService`对象。要创建它（与每个执行程序一样），Java建议使用`Executors`类。这个类作为执行程序对象的工厂。在这种情况下，您应该使用`newScheduledThreadPool()`方法来创建一个`ScheduledExecutorService`对象。该方法接收池中线程的数量作为参数。在这个例子中，您已经将值`1`作为参数传递了。
- en: 'Once you have the executor needed to execute a periodic task, you send the
    task to the executor. You have used the `scheduledAtFixedRate()` method. This
    method accepts four parameters: the task you want to execute periodically, the
    delay of time until the first execution of the task, the period between two executions,
    and the time unit of the second and third parameters. It''s a constant of the
    `TimeUnit` class. The `TimeUnit` class is an enumeration with the following constants:
    `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and
    `SECONDS`.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了执行定期任务所需的执行程序，您就可以将任务发送给执行程序。您已经使用了`scheduledAtFixedRate()`方法。该方法接受四个参数：您想要定期执行的任务，直到任务第一次执行之间的延迟时间，两次执行之间的时间间隔，以及第二个和第三个参数的时间单位。它是`TimeUnit`类的一个常量。`TimeUnit`类是一个枚举，具有以下常量：`DAYS`、`HOURS`、`MICROSECONDS`、`MILLISECONDS`、`MINUTES`、`NANOSECONDS`和`SECONDS`。
- en: An important point to consider is that the period between two executions is
    the period of time between these two executions that begins. If you have a periodic
    task that takes 5 sceconds to execute and you put a period of 3 seconds, you will
    have two instances of the task executing at a time.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的要考虑的点是两次执行之间的时间间隔是开始这两次执行之间的时间间隔。如果您有一个需要5秒执行的周期性任务，并且您设置了3秒的时间间隔，那么您将有两个任务实例同时执行。
- en: The method `scheduleAtFixedRate()` returns a `ScheduledFuture` object, which
    extends the `Future` interface, with methods to work with scheduled tasks. `ScheduledFuture`
    is a parameterized interface. In this example, as your task is a `Runnable` object
    that is not parameterized, you have to parameterize them with the `?` symbol as
    a parameter.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`scheduleAtFixedRate()`方法返回一个`ScheduledFuture`对象，它扩展了`Future`接口，具有用于处理计划任务的方法。`ScheduledFuture`是一个参数化接口。在本例中，由于您的任务是一个未参数化的`Runnable`对象，因此您必须使用`?`符号对其进行参数化。'
- en: You have used one method of the `ScheduledFuture` interface. The `getDelay()`
    method returns the time until the next execution of the task. This method receives
    a `TimeUnit` constant with the time unit in which you want to receive the results.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经使用了`ScheduledFuture`接口的一个方法。`getDelay()`方法返回任务下一次执行的时间。此方法接收一个`TimeUnit`常量，其中包含您希望接收结果的时间单位。
- en: 'The following screenshot shows the output of an execution of the example:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了示例执行的输出：
- en: '![How it works...](img/7881_04_06.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/7881_04_06.jpg)'
- en: You can see the task executing every 2 seconds (denoted with `Task:` prefix)
    and the delay written in the console every 500 milliseconds. That's how long the
    main thread has been put to sleep. When you shut down the executor, the scheduled
    task ends its execution and you don't see more messages in the console.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到任务每2秒执行一次（以`Task:`前缀表示），并且控制台中每500毫秒写入延迟。这就是主线程被挂起的时间。当您关闭执行器时，计划任务结束执行，您将不会在控制台中看到更多消息。
- en: There's more...
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`ScheduledThreadPoolExecutor` provides other methods to schedule periodic tasks.
    It is the `scheduleWithFixedRate()` method. It has the same parameters as the
    `scheduledAtFixedRate()` method, but there is a difference worth noticing. In
    the `scheduledAtFixedRate()` method, the third parameter determines the period
    of time between the starting of two executions. In the `scheduledWithFixedRate()`
    method, parameter determines the period of time between the end of an execution
    of the task and the beginning of the next execution.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScheduledThreadPoolExecutor`提供了其他方法来安排周期性任务。它是`scheduleWithFixedRate()`方法。它与`scheduledAtFixedRate()`方法具有相同的参数，但有一个值得注意的区别。在`scheduledAtFixedRate()`方法中，第三个参数确定两次执行开始之间的时间间隔。在`scheduledWithFixedRate()`方法中，参数确定任务执行结束和下一次执行开始之间的时间间隔。'
- en: You can also configure the behavior of an instance of the `ScheduledThreadPoolExecutor`
    class with the `shutdown()` method. The default behavior is that the scheduled
    tasks finish when you call that method. You can change this behavior using the
    `setContinueExistingPeriodicTasksAfterShutdownPolicy()` method of the `ScheduledThreadPoolExecutor`
    class with a `true` value. The periodic tasks won't finish upon calling the `shutdown()`
    method.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`shutdown()`方法配置`ScheduledThreadPoolExecutor`类的实例的行为。默认行为是在调用该方法时计划任务结束。您可以使用`ScheduledThreadPoolExecutor`类的`setContinueExistingPeriodicTasksAfterShutdownPolicy()`方法来更改此行为，并使用`true`值。调用`shutdown()`方法时，周期性任务不会结束。
- en: See also
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a thread executor* recipe in [Chapter 4](ch04.html "Chapter 4. Thread
    Executors"), *Thread Executors*
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章 线程执行器")中的*创建线程执行器*食谱，*线程执行器*'
- en: The *Running a task in an executor after a delay* recipe in [Chapter 4](ch04.html
    "Chapter 4. Thread Executors"), *Thread Executors*
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章 线程执行器")中的*在延迟后在执行器中运行任务*食谱，*线程执行器*'
- en: Canceling a task in an executor
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在执行器中取消任务
- en: When you work with an executor, you don't have to manage threads. You only implement
    the `Runnable` or `Callable` tasks and send them to the executor. It's the executor
    that's responsible for creating threads, managing them in a thread pool, and finishing
    them if they are not needed. Sometimes, you may want to cancel a task that you
    sent to the executor. In that case, you can use the `cancel()` method of `Future`
    that allows you to make that cancellation operation. In this recipe, you will
    learn how to use this method to cancel the tasks that you have sent to an executor.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用执行器时，无需管理线程。您只需实现`Runnable`或`Callable`任务并将其发送到执行器。执行器负责创建线程，在线程池中管理它们，并在不需要时完成它们。有时，您可能希望取消发送到执行器的任务。在这种情况下，您可以使用`Future`的`cancel()`方法来执行取消操作。在本示例中，您将学习如何使用此方法来取消发送到执行器的任务。
- en: Getting ready
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例使用Eclipse IDE实现。如果您使用Eclipse或其他IDE（如NetBeans），请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `Task` and specify that it implements the `Callable` interface
    parameterized with the `String` class. Implement the `call()` method. Write a
    message to the console and put it to sleep for 100 milliseconds inside an infinite
    loop.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，并指定它实现了参数化为`String`类的`Callable`接口。实现`call()`方法。在无限循环中向控制台写入消息并将其挂起100毫秒。
- en: '[PRE107]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并向其中添加`main()`方法来实现示例的主类。
- en: '[PRE108]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Create a `ThreadPoolExecutor` object using the `newCachedThreadPool()` method
    of the `Executors` class.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Executors`类的`newCachedThreadPool()`方法创建一个`ThreadPoolExecutor`对象。
- en: '[PRE109]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Create a new `Task` object.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Task`对象。
- en: '[PRE110]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Send the task to the executor using the `submit()` method.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`submit()`方法将任务发送到执行器。
- en: '[PRE111]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Put the main task to sleep for 2 seconds.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主任务挂起2秒。
- en: '[PRE112]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Cancel the execution of the task using the `cancel()` method of the `Future`
    object named `result` returned by the `submit()` method. Pass the `true` value
    as a parameter of the `cancel()` method.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`submit()`方法返回的名为`result`的`Future`对象的`cancel()`方法取消任务的执行。将`true`值作为`cancel()`方法的参数传递。
- en: '[PRE113]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Write to the console the result of a calling to the methods `isCancelled()`
    and `isDone()` to verify that the task has been canceled and hence, is already
    done.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控制台写入调用`isCancelled()`和`isDone()`方法的结果，以验证任务是否已被取消，因此已经完成。
- en: '[PRE114]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Finish the executor with the `shutdown()` method and write a message indicating
    the finalization of the program.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法完成执行程序，并写入指示程序完成的消息。
- en: '[PRE115]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: How it works...
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You use the `cancel()` method of the `Future` interface when you want to cancel
    a task that you have sent to an executor. Depending on the parameter of the `cancel()`
    method and the status of the task, the behavior of this method is different:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要取消发送到执行程序的任务时，可以使用`Future`接口的`cancel()`方法。根据`cancel()`方法的参数和任务的状态，此方法的行为不同：
- en: If the task has finished or has been canceled earlier or it can't be canceled
    for other reasons, the method will return the `false` value and the task won't
    be canceled.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任务已经完成或之前已被取消，或者由于其他原因无法取消，则该方法将返回`false`值，任务将不会被取消。
- en: If the task is waiting in the executor to get a `Thread` object that will execute
    it, the task is canceled and never begins its execution. If the task is already
    running, it depends on the parameter of the method. The `cancel()` method receives
    a `Boolean` value as a parameter. If the value of that parameter is `true` and
    the task is running, it will be canceled. If the value of the parameter is `false`
    and the task is running, it won't be canceled.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任务正在等待执行它的`Thread`对象，则任务将被取消并且永远不会开始执行。如果任务已经在运行，则取决于方法的参数。`cancel()`方法接收一个`Boolean`值作为参数。如果该参数的值为`true`并且任务正在运行，则将取消任务。如果参数的值为`false`并且任务正在运行，则不会取消任务。
- en: 'The following screenshot shows the output of an execution of this example:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了此示例执行的输出：
- en: '![How it works...](img/7881_04_07.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_04_07.jpg)'
- en: There's more...
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you use the `get()` method of a `Future` object that controls a task that
    has been canceled, the `get()` method will throw a `CancellationException` exception.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用控制已取消任务的`Future`对象的`get()`方法，`get()`方法将抛出`CancellationException`异常。
- en: See also
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Executing tasks in an executor that returns a result* recipe in [Chapter
    4](ch04.html "Chapter 4. Thread Executors"), *Thread Executors*
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章. 线程执行程序")中的*在返回结果的执行程序中执行任务*食谱，*线程执行程序*'
- en: Controlling a task finishing in an executor
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在执行程序中控制任务完成
- en: The `FutureTask` class provides a method called `done()` that allows you to
    execute some code after the finalization of a task executed in an executor. It
    can be used to make some post-process operations, generating a report, sending
    results by e-mail, or releasing some resources. This method is called internally
    by the `FutureTask` class when the execution of the task that this `FutureTask`
    object is controlling finishes. The method is called after the result of the task
    is set and its status is changed to the `isDone` status, regardless of whether
    the task has been canceled or finished normally.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '`FutureTask`类提供了一个名为`done()`的方法，允许您在执行程序中执行任务完成后执行一些代码。它可以用于执行一些后处理操作，生成报告，通过电子邮件发送结果或释放一些资源。当控制此`FutureTask`对象的任务的执行完成时，`FutureTask`类在内部调用此方法。该方法在任务的结果设置并且其状态更改为`isDone`状态后调用，无论任务是否已被取消或正常完成。'
- en: By default, this method is empty. You can override the `FutureTask` class and
    implement this method to change this behavior. In this recipe, you will learn
    how to override this method to execute code after the finalization of the tasks.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此方法为空。您可以重写`FutureTask`类并实现此方法以更改此行为。在本示例中，您将学习如何重写此方法以在任务完成后执行代码。
- en: Getting ready
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project..
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的示例已使用Eclipse IDE实现。如果您使用Eclipse或其他IDE（如NetBeans），请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `ExecutableTask` and specify that it implements the `Callable`
    interface parameterized with the `String` class.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ExecutableTask`的类，并指定它实现了参数为`String`类的`Callable`接口。
- en: '[PRE116]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Declare a private `String` attribute named `name`. It will store the name of
    the task. Implement the method `getName()` to return the value of this attribute.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`name`的私有`String`属性。它将存储任务的名称。实现`getName()`方法以返回此属性的值。
- en: '[PRE117]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Implement the constructor of the class to initialize the name of the task.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化任务的名称。
- en: '[PRE118]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Implement the `call()` method. Put the task to sleep for a random period of
    time and return a message with the name of the task.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`call()`方法。让任务休眠一段随机时间并返回带有任务名称的消息。
- en: '[PRE119]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Implement a class named `ResultTask` that extends the `FutureTask` class parameterized
    with the `String` class.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为`ResultTask`的类，它扩展了参数为`String`类的`FutureTask`类。
- en: '[PRE120]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Declare a private `String` attribute named `name`. It will store the name of
    the task.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`name`的私有`String`属性。它将存储任务的名称。
- en: '[PRE121]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Implement the constructor of the class. It has to receive a `Callable` object
    as a parameter. Call the constructor of the parent class and initialize the `name`
    attribute using the attribute of the task received.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数。它必须接收一个`Callable`对象作为参数。调用父类的构造函数，并使用接收到的任务的属性初始化`name`属性。
- en: '[PRE122]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Override the `done()` method. Check the value of the `isCancelled()` method
    and write a different message to the console depending on the returned value.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`done()`方法。检查`isCancelled()`方法的值，并根据返回的值向控制台写入不同的消息。
- en: '[PRE123]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并向其添加`main()`方法来实现示例的主类。
- en: '[PRE124]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Create `ExecutorService` using the `newCachedThreadPool()` method of the `Executors`
    class.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Executors`类的`newCachedThreadPool()`方法创建`ExecutorService`。
- en: '[PRE125]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Create an array to store five `ResultTask` objects.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个数组来存储五个`ResultTask`对象。
- en: '[PRE126]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Initialize the `ResultTask` objects. For each position in the array, first,
    you have to create `ExecutorTask` and then `ResultTask` using that object. Then,
    send to the executor `ResultTask` using the `submit()` method.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化`ResultTask`对象。对于数组中的每个位置，首先创建`ExecutorTask`，然后使用该对象创建`ResultTask`。然后使用`submit()`方法将`ResultTask`发送到执行器。
- en: '[PRE127]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Put the main thread to sleep for 5 seconds.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让主线程休眠5秒。
- en: '[PRE128]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Cancel all the tasks you have sent to the executor.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消所有发送到执行器的任务。
- en: '[PRE129]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Write to the console the result of those tasks that haven't been canceled using
    the `get()` method of the `ResultTask` objects.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ResultTask`对象的`get()`方法将未被取消的任务的结果写入控制台。
- en: '[PRE130]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Finish the executor using the `shutdown()` method.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法结束执行器。
- en: '[PRE131]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: How it works...
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `done()`method is called by the `FutureTask` class when the task that is
    being controlled finishes its execution. In this example, you have implemented
    a `Callable` object, the `ExecutableTask` class, and then, a subclass of the `FutureTask`
    class that controls the execution of the `ExecutableTask` objects.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 当被控制的任务完成执行时，`done()`方法由`FutureTask`类调用。在这个示例中，您已经实现了一个`Callable`对象，即`ExecutableTask`类，然后是`FutureTask`类的子类，用于控制`ExecutableTask`对象的执行。
- en: The `done()` method is called internally by the `FutureTask` class after establishing
    the return value and changing the status of the task to the `isDone` status. You
    can't change the result value of the task or change its status, but you can close
    resources used by the task, write log messages, or send notifications.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '`done()`方法在`FutureTask`类内部调用，用于确定返回值并将任务状态更改为`isDone`状态。您无法更改任务的结果值或更改其状态，但可以关闭任务使用的资源，编写日志消息或发送通知。'
- en: See also
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Executing tasks in an executor that returns a result* recipe in [Chapter
    4](ch04.html "Chapter 4. Thread Executors"), *Thread Executors*
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章. 线程执行器")中的*在返回结果的执行器中执行任务*一节，*线程执行器*'
- en: Separating the launching of tasks and the processing of their results in an
    executor
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在执行器中分离任务的启动和处理它们的结果
- en: Normally, when you execute concurrent tasks using an executor, you will send
    `Runnable` or `Callable` tasks to the executor and get `Future` objects to control
    the method. You can find situations, where you need to send the tasks to the executor
    in one object and process the results in another one. For such situations, the
    Java Concurrency API provides the `CompletionService` class.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当您使用执行器执行并发任务时，您会将`Runnable`或`Callable`任务发送到执行器，并获取`Future`对象来控制方法。您可能会遇到需要在一个对象中将任务发送到执行器，并在另一个对象中处理结果的情况。对于这种情况，Java并发API提供了`CompletionService`类。
- en: This `CompletionService` class has a method to send the tasks to an executor
    and a method to get the `Future` object for the next task that has finished its
    execution. Internally, it uses an `Executor` object to execute the tasks. This
    behavior has the advantage to share a `CompletionService` object, and sends tasks
    to the executor so the others can process the results. The limitation is that
    the second object can only get the `Future` objects for those tasks that have
    finished its execution, so these `Future` objects can only be used to get the
    results of the tasks.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`CompletionService`类有一个方法将任务发送到执行器，并有一个方法获取下一个完成执行的任务的`Future`对象。在内部，它使用一个`Executor`对象来执行任务。这种行为的优势是可以共享`CompletionService`对象，并将任务发送到执行器，以便其他对象可以处理结果。限制在于第二个对象只能获取已完成执行的任务的`Future`对象，因此这些`Future`对象只能用于获取任务的结果。
- en: In this recipe, you will learn how to use the `CompletionService` class to separate
    launching tasks in an executor from processing their results.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何使用`CompletionService`类来将在执行器中启动任务与处理它们的结果分离。
- en: Getting ready
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用Eclipse IDE实现。如果您使用Eclipse或其他IDE，如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `ReportGenerator` and specify that it implements the `Callable`
    interface parameterized with the `String` class.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ReportGenerator`的类，并指定它实现了参数化为`String`类的`Callable`接口。
- en: '[PRE132]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Declare two private `String` attributes named `sender` and `title` that will
    represent data for the report.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个私有的`String`属性，名为`sender`和`title`，它们将代表报告的数据。
- en: '[PRE133]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Implement the constructor of the class that initializes the two attributes.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，初始化两个属性。
- en: '[PRE134]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Implement the `call()` method. First, put the thread to sleep for a random period
    of time.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`call()`方法。首先让线程随机休眠一段时间。
- en: '[PRE135]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Then, generate the report as a string with the sender and title attributes and
    return that string.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用发送者和标题属性生成报告字符串，并返回该字符串。
- en: '[PRE136]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Create a class named `ReportRequest` and specify that it implements the `Runnable`
    interface. This class will simulate some report requests.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ReportRequest`的类，并指定它实现`Runnable`接口。这个类将模拟一些报告请求。
- en: '[PRE137]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Declare a private `String` attribute named `name` to store the name of `ReportRequest`.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的`String`属性，名为`name`，用于存储`ReportRequest`的名称。
- en: '[PRE138]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Declare a private `CompletionService` attribute named `service`. The `CompletionService`
    interface is a parameterized interface. Use the `String` class.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的`CompletionService`属性，名为`service`。`CompletionService`接口是一个参数化的接口。使用`String`类。
- en: '[PRE139]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Implement the constructor of the class that initializes the two attributes.
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，初始化两个属性。
- en: '[PRE140]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Implement the `run()` method. Create three `ReportGenerator` objects and send
    them to the `CompletionService` object using the `submit()` method.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。创建三个`ReportGenerator`对象，并使用`submit()`方法将它们发送到`CompletionService`对象。
- en: '[PRE141]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Create a class named `ReportProcessor`. This class will get the results of the
    `ReportGenerator` tasks. Specify that it implements the `Runnable` interface.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`ReportProcessor`的类。这个类将获取`ReportGenerator`任务的结果。指定它实现`Runnable`接口。
- en: '[PRE142]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Declare a private `CompletionService` attribute named `service`. As the `CompletionService`
    interface is a parameterized interface, use the `String` class as parameter of
    this `CompletionService` interface.
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`service`的私有`CompletionService`属性。由于`CompletionService`接口是一个参数化接口，因此在这个`CompletionService`接口的参数中使用`String`类。
- en: '[PRE143]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Declare a private `boolean` attribute named `end`.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`end`的私有`boolean`属性。
- en: '[PRE144]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Implement the constructor of the class to initialize the two attributes.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化这两个属性。
- en: '[PRE145]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Implement the `run()` method. While the attribute `end` is `false`, call the
    `poll()` method of the `CompletionService` interface to get the `Future` object
    of the next task executed by the completion service that has finished.
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。当属性`end`为`false`时，调用`CompletionService`接口的`poll()`方法，以获取完成服务执行的下一个任务的`Future`对象。
- en: '[PRE146]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Then, get the results of the task using the `get()` method of the `Future` object
    and write those results to the console.
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`Future`对象的`get()`方法获取任务的结果，并将这些结果写入控制台。
- en: '[PRE147]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Implement the `setEnd()` method that modifies the value of the end attribute.
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`setEnd()`方法，修改`end`属性的值。
- en: '[PRE148]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建名为`Main`的类并向其中添加`main()`方法来实现示例的主类。
- en: '[PRE149]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Create `ThreadPoolExecutor` using the `newCachedThreadPool()` method of the
    `Executors` class.
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Executors`类的`newCachedThreadPool()`方法创建`ThreadPoolExecutor`。
- en: '[PRE150]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Create `CompletionService` using the executor created earlier as a parameter
    of the constructor.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用先前创建的执行器作为构造函数的参数创建`CompletionService`。
- en: '[PRE151]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Create two `ReportRequest` objects and the threads to execute them.
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个`ReportRequest`对象和执行它们的线程。
- en: '[PRE152]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Create a `ReportProcessor` object and the thread to execute it.
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ReportProcessor`对象和执行它的线程。
- en: '[PRE153]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Start the three threads.
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动三个线程。
- en: '[PRE154]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Wait for the finalization of the `ReportRequest` threads.
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待`ReportRequest`线程的最终完成。
- en: '[PRE155]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Finish the executor using the `shutdown()` method and wait for the finalization
    of the tasks with the `awaitTermination()` method.
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法完成执行器，并使用`awaitTermination()`方法等待任务的最终完成。
- en: '[PRE156]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Finish the execution of the `ReportSender` object setting the value of its end
    attribute to `true`.
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成`ReportSender`对象的执行，将其`end`属性的值设置为`true`。
- en: '[PRE157]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: How it works...
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: In the main class of the example, you have created `ThreadPoolExecutor` using
    the `newCachedThreadPool()` method of the `Executors` class. Then, you have used
    that object to initialize a `CompletionService` object because the completion
    service uses an executor to execute its tasks. To execute a task using the completion
    service, you use the `submit()` method as in the `ReportRequest` class.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例的主类中，使用`Executors`类的`newCachedThreadPool()`方法创建了`ThreadPoolExecutor`。然后，使用该对象初始化了`CompletionService`对象，因为完成服务使用执行器来执行其任务。要使用完成服务执行任务，可以像在`ReportRequest`类中一样使用`submit()`方法。
- en: When one of these tasks is executed when the completion service finishes its
    execution, the completion service stores the `Future` object used to control its
    execution in a queue. The `poll()` method accesses this queue to see if there
    is any task that has finished its execution and, if so, returns the first element
    of that queue which is a `Future` object for a task that has finished its execution.
    When the `poll()` method returns a `Future` object, it deletes it from the queue.
    In this case, you have passed two attributes to that method to indicate the time
    you want to wait for the finalization of a task, in case the queue with the results
    of the finished tasks is empty.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些任务中的一个在完成服务完成其执行时执行时，完成服务将`Future`对象存储在队列中，用于控制其执行。`poll()`方法访问此队列，以查看是否有任何已完成执行的任务，并在有任务完成执行时返回该队列的第一个元素，即已完成执行的任务的`Future`对象。当`poll()`方法返回一个`Future`对象时，它会从队列中删除。在这种情况下，您已向该方法传递了两个属性，以指示您希望等待任务完成的时间，以防已完成任务的结果队列为空。
- en: Once the `CompletionService` object is created, you create two `ReportRequest`
    objects that execute three `ReportGenerator` tasks, each one in `CompletionService`,
    and a `ReportSender` task that will process the results generated by the tasks
    sent by the two `ReportRequest` objects.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`CompletionService`对象后，创建两个`ReportRequest`对象，每个对象在`CompletionService`中执行三个`ReportGenerator`任务，并创建一个`ReportSender`任务，该任务将处理两个`ReportRequest`对象发送的任务生成的结果。
- en: There's more...
  id: totrans-553
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `CompletionService` class can execute `Callable` or `Runnable` tasks. In
    this example, you have used `Callable`, but you could also send `Runnable` objects.
    Since `Runnable` objects don't produce a result, the philosophy of the `CompletionService`
    class doesn't apply in such cases.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletionService`类可以执行`Callable`或`Runnable`任务。在这个例子中，您已经使用了`Callable`，但您也可以发送`Runnable`对象。由于`Runnable`对象不产生结果，因此`CompletionService`类的理念在这种情况下不适用。'
- en: 'This class also provides two other methods to obtain the `Future` objects of
    the finished tasks. These methods are as follows:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类还提供了另外两个方法来获取已完成任务的`Future`对象。这些方法如下：
- en: '`poll()`: The version of the `poll()` method without arguments checks if there
    are any `Future` objects in the queue. If the queue is empty, it returns `null`
    immediately. Otherwise, it returns its first element and removes it from the queue.'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poll()`: 不带参数的`poll()`方法检查队列中是否有任何`Future`对象。如果队列为空，它立即返回`null`。否则，它返回队列的第一个元素并将其从队列中删除。'
- en: '`take()`: This method, without arguments, checks if there are any `Future`
    objects in the queue. If it is empty, it blocks the thread until the queue has
    an element. When the queue has elements, it returns and deletes its first element
    from the queue.'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take()`: 这个方法没有参数，它检查队列中是否有任何`Future`对象。如果队列为空，它会阻塞线程，直到队列有元素。当队列有元素时，它会返回并从队列中删除第一个元素。'
- en: See also
  id: totrans-558
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Executing tasks in an executor that returns a result* recipe in [Chapter
    4](ch04.html "Chapter 4. Thread Executors"), *Thread Executor*
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。线程执行者")的*在返回结果的执行者中执行任务*配方中，*线程执行者*
- en: Controlling rejected tasks of an executor
  id: totrans-560
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制执行者的被拒绝任务
- en: When you want to finish the execution of an executor, you use the `shutdown()`
    method to indicate that it should finish. The executor waits for the completion
    of the tasks that are running or waiting for their execution, and then finishes
    its execution.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要完成执行者的执行时，使用`shutdown()`方法指示它应该完成。执行者等待正在运行或等待执行的任务完成，然后完成其执行。
- en: If you send a task to an executor between the `shutdown()` method and the end
    of its execution, the task is rejected, because the executor no longer accepts
    new tasks. The `ThreadPoolExecutor` class provides a mechanism, which is called
    when a task is rejected.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`shutdown()`方法和执行结束之间向执行者发送任务，则任务将被拒绝，因为执行者不再接受新任务。`ThreadPoolExecutor`类提供了一种机制，当任务被拒绝时调用该机制。
- en: In this recipe, you will learn how to manage rejecting tasks in an executor
    that is implementing with `RejectedExecutionHandler`.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将学习如何管理实现了`RejectedExecutionHandler`的执行者中的拒绝任务。
- en: Getting ready
  id: totrans-564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例已使用Eclipse IDE实现。如果您使用Eclipse或其他IDE（如NetBeans），请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-566
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `RejectedTaskController` that implements the `RejectedExecutionHandler`
    interface. Implement the `rejectedExecution()` method of that interface. Write
    to the console the name of the task that has been rejected and the name and status
    of the executor.
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`RejectedTaskController`的类，它实现`RejectedExecutionHandler`接口。实现该接口的`rejectedExecution()`方法。向控制台写入已被拒绝的任务的名称以及执行者的名称和状态。
- en: '[PRE158]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Implement a class named `Task` and specify that it implements the `Runnable`
    interface.
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为`Task`的类，并指定它实现`Runnable`接口。
- en: '[PRE159]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Declare a private `String` attribute named `name`. It will store the name of
    the task.
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`name`的私有`String`属性。它将存储任务的名称。
- en: '[PRE160]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Implement the constructor of the class. It will initialize the attribute of
    the class.
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数。它将初始化类的属性。
- en: '[PRE161]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Implement the `run()` method. Write a message to the console to indicate the
    starting of the method.
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。向控制台写入消息以指示方法的开始。
- en: '[PRE162]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Wait for a random period of time.
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待一段随机时间。
- en: '[PRE163]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Write a message to the console to indicate the finalization of the method.
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控制台写入消息以指示方法的最终化。
- en: '[PRE164]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Override the `toString()` method. Return the name of the task.
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`toString()`方法。返回任务的名称。
- en: '[PRE165]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并向其中添加`main()`方法来实现示例的主类。
- en: '[PRE166]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Create a `RejectedTaskController` object to manage the rejected tasks.
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`RejectedTaskController`对象来管理被拒绝的任务。
- en: '[PRE167]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Create `ThreadPoolExecutor` using the `newCachedThreadPool()` method of the
    `Executors` class.
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Executors`类的`newCachedThreadPool()`方法创建`ThreadPoolExecutor`。
- en: '[PRE168]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Establish the rejected task controller of the executor.
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立执行者的被拒绝任务控制器。
- en: '[PRE169]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Create three tasks and send them to the executor.
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个任务并将它们发送到执行者。
- en: '[PRE170]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Shutdown the executor using the `shutdown()` method.
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法关闭执行者。
- en: '[PRE171]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Create another task and send it to the executor.
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个任务并将其发送到执行者。
- en: '[PRE172]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Write a message to the console to indicate the finalization of the program.
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控制台写入消息以指示程序的最终化。
- en: '[PRE173]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: How it works...
  id: totrans-600
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the following screenshot, you can see the result of an execution of the
    example:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到示例执行的结果：
- en: '![How it works...](img/7881_04_08.jpg)'
  id: totrans-602
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_04_08.jpg)'
- en: You can see that the task is rejected when execution has been shut down and
    `RejectecTaskController` writes to the console information about the task and
    the executor.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行被关闭并且`RejectecTaskController`写入控制台关于任务和执行者的信息时，可以看到任务被拒绝。
- en: 'To manage rejected tasks for an executor, you should create a class that implements
    the `RejectedExecutionHandler` interface. This interface has a method called `rejectedExecution()`
    with two parameters:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理执行者的被拒绝任务，您应该创建一个实现`RejectedExecutionHandler`接口的类。该接口有一个名为`rejectedExecution()`的方法，带有两个参数：
- en: A `Runnable` object that stores the task that has been rejected
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储已被拒绝任务的`Runnable`对象
- en: An `Executor` object that stores the executor that rejected the task
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储拒绝任务的执行者对象
- en: This method is called for every task that is rejected by the executor. You need
    to establish the handler of the rejected tasks using the `setRejectedExecutionHandler()`
    method of the `Executor` class.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个被执行者拒绝的任务都会调用此方法。您需要使用`Executor`类的`setRejectedExecutionHandler()`方法来建立被拒绝任务的处理程序。
- en: There's more...
  id: totrans-608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When an executor receives a task to execute, it checks if the `shutdown()` method
    has been called. If so, it rejects the task. First, it looks for the handler established
    with `setRejectedExecutionHandler()`. If there's one, it calls the `rejectedExecution()`
    method of that class, otherwise it throws `RejectedExecutionExeption`. This is
    a runtime exception, so you don't need to put a `catch` clause to control it.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行者接收到要执行的任务时，它会检查是否调用了`shutdown()`方法。如果是，则拒绝任务。首先，它会查找使用`setRejectedExecutionHandler()`建立的处理程序。如果有一个，它会调用该类的`rejectedExecution()`方法，否则会抛出`RejectedExecutionExeption`。这是一个运行时异常，所以您不需要放置`catch`子句来控制它。
- en: See also
  id: totrans-610
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a thread executor* recipe in [Chapter 4](ch04.html "Chapter 4. Thread
    Executors"), *Thread Executors*
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。线程执行者")的*创建线程执行者*配方中，*线程执行者*
