- en: Chapter 7. Network Scalability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 网络可扩展性
- en: Network scalability is concerned with structuring an application in such a way
    that as more demands are placed on the application, it can adjust to handle the
    stress. Demands can come in the form of more users, an increased number of requests,
    more complicated requests, and changes in network characteristics.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络可扩展性涉及以一种方式构建应用程序，以便在应用程序上施加更多需求时，它可以调整以处理压力。需求可以以更多用户、增加的请求数量、更复杂的请求和网络特性的变化形式出现。
- en: 'There are several areas of concern listed as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了几个关注的领域：
- en: Server capacity
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器容量
- en: Multiple threads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程
- en: Network bandwidth and latency
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络带宽和延迟
- en: Execution environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行环境
- en: Scalability can be achieved by adding more servers, using an appropriate number
    of threads, improving the performance of the execution environment, and increasing
    the network bandwidth to eliminate bottlenecks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过增加更多的服务器、使用适当数量的线程、改进执行环境的性能以及增加网络带宽来消除瓶颈，可以实现可扩展性。
- en: Adding more servers will help by enabling load balancing between servers. However,
    if the network bandwidth or latency is the issue, then this will not help much.
    There is only so much that can be pushed through a network pipe.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 增加更多的服务器将有助于实现服务器之间的负载平衡。但是，如果网络带宽或延迟是问题，那么这将帮助不大。网络管道只能推送有限的数据。
- en: Threads are frequently used to improve the performance of a system. Using an
    appropriate number of threads for a system allows some threads to execute while
    other threads are blocked. A blocked thread may be waiting for IO to occur or
    for a user to respond. Allowing other threads to execute while some are blocked
    can increase application throughput.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 线程经常用于提高系统的性能。为系统使用适当数量的线程允许一些线程执行，而其他线程被阻塞。被阻塞的线程可能正在等待IO发生或用户响应。在一些线程被阻塞时允许其他线程执行可以增加应用程序的吞吐量。
- en: The execution environment includes the underlying hardware, the operating system,
    the JVM, and the application itself. Each of these areas is a candidate for improvement.
    We will not address the hardware environment as that is beyond our control. The
    same is true of the operating system. While some performance improvements can
    be achieved, we will not address these areas. JVM parameters that can affect network
    performance will be identified.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 执行环境包括底层硬件、操作系统、JVM和应用程序本身。这些领域中的每一个都有改进的可能性。我们不会涉及硬件环境，因为那超出了我们的控制范围。操作系统也是如此。虽然可以实现一些性能改进，但我们不会涉及这些领域。将识别可能影响网络性能的JVM参数。
- en: 'We will examine code improvement opportunities. Most of our discussion is concerned
    with the use of threads because we have more control over this architectural feature.
    We will illustrate several approaches to improve the scalability of an application
    in this chapter. These include the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究代码改进的机会。我们的大部分讨论涉及线程的使用，因为我们对这个架构特性有更多的控制。我们将在本章中说明几种改进应用程序可扩展性的方法。这些包括以下内容：
- en: Multiple threaded server
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程服务器
- en: Thread pool
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程池
- en: Futures and callables
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Futures和callables
- en: Selector (TCP/UDP)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择器（TCP/UDP）
- en: We will explore the details of using simple threads/pools because you may encounter
    them in your work and may not be able to use some of the newer technologies due
    to platform limitations. Thread pools offer the advantage of reusing threads in
    many situations. Futures and callables are a thread variation where data can be
    passed and returned from a thread. Selector allows multiple channels to be handled
    by a single thread.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨使用简单线程/池的细节，因为您可能会在工作中遇到它们，并且由于平台限制可能无法使用一些新技术。线程池在许多情况下具有重复使用线程的优势。Futures和callables是一种线程变体，其中可以传递和返回数据。选择器允许单个线程处理多个通道。
- en: Multithreaded server overview
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程服务器概述
- en: The chief advantage of a multithreaded server is that long-running client requests
    will not block the server from accepting other client requests. If a new thread
    is not created, then the current request will be processed. It is only after the
    request has been processed that new requests can be accepted. Using a separate
    thread for a request means that connections and their associated requests can
    be processed concurrently.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程服务器的主要优势是长时间运行的客户端请求不会阻塞服务器接受其他客户端请求。如果不创建新线程，那么当前请求将被处理。只有在请求被处理后才能接受新请求。为请求使用单独的线程意味着连接及其相关的请求可以同时处理。
- en: 'When using a multithreaded server, there are several of ways of configuring
    the threads as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用多线程服务器时，有几种配置线程的方式如下：
- en: Thread-per-request
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个请求一个线程
- en: Thread-per-connection
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个连接一个线程
- en: Thread-per-object
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个对象一个线程
- en: In the thread-per-request model, each request that arrives at the server is
    assigned a new thread. While this is a simple approach, it can result in the creation
    of a large number of threads. In addition, each request will often mean that a
    new connection will be created.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个请求一个线程的模型中，到达服务器的每个请求都被分配一个新线程。虽然这是一种简单的方法，但可能会导致大量线程的创建。此外，每个请求通常意味着将创建一个新连接。
- en: This model works nicely in an environment where the previous client request
    does not need to be retained. For example, if the server's sole purpose is to
    respond to a request for a specific stock quote, then a thread does not need to
    be aware of any previous requests.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型在以前的客户端请求不需要保留的环境中运行得很好。例如，如果服务器的唯一目的是响应特定股票报价的请求，那么线程不需要知道任何以前的请求。
- en: This approach is illustrated in the following figure. Each client request sent
    to the server is assigned to a new thread.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法如下图所示。发送到服务器的每个客户端请求都分配给一个新线程。
- en: '![Multithreaded server overview](img/B04915_07_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![多线程服务器概述](img/B04915_07_01.jpg)'
- en: In the thread-per-connection model, a client connection is maintained for the
    duration of the session. A session consists of a series of requests and responses.
    A session is terminated either through a specific command or after a time-out
    period has elapsed. This approach allows state information to be maintained between
    requests.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个连接一个线程的模型中，客户端连接在会话期间保持。一个会话包括一系列的请求和响应。会话要么通过特定命令终止，要么在经过一段超时时间后终止。这种方法允许在请求之间维护状态信息。
- en: This approach is illustrated in the following figure. The dash line indicates
    that multiple requests from the same client are handled by the same thread.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在下图中有所说明。虚线表示同一客户端的多个请求由同一个线程处理。
- en: '![Multithreaded server overview](img/B04915_07_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![多线程服务器概述](img/B04915_07_02.jpg)'
- en: The thread-per-object approach queues associated requests with a specific object
    that can handle the request. The object and its methods are placed in a thread
    that handles requests one at a time. Requests are queued with the thread. While
    we will not demonstrate this approach here, it is often used with thread pools.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象一个线程的方法将相关请求与可以处理请求的特定对象排队。对象及其方法被放置在一个处理请求的线程中。请求与线程排队。虽然我们在这里不会演示这种方法，但它经常与线程池一起使用。
- en: The process of creating and deleting connections can be expensive. If a client
    submits several requests, then opening and closing a connection becomes expensive
    and should be avoided.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和删除连接的过程可能是昂贵的。如果客户端提交了多个请求，那么打开和关闭连接变得昂贵，应该避免。
- en: To manage the problem of too many threads, a pool of threads is frequently used.
    When a request needs to be processed, the request is assigned to an existing unused
    thread to handle the request. Once the response has been sent, then the thread
    can be used for other requests. This assumes that state information does not need
    to be maintained.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决线程过多的问题，经常使用线程池。当需要处理请求时，请求被分配给一个现有的未使用的线程来处理请求。一旦响应被发送，那么线程就可以用于其他请求。这假设不需要维护状态信息。
- en: The thread-per-request approach
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用每个请求一个线程的方法
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started with Network Programming"),
    *Getting Started with Network Programming*, we illustrated a simple multithreaded
    echo server. This approach is reintroduced here to provide a foundation for the
    use of threads in the remainder of the chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。开始网络编程")中，*开始网络编程*，我们演示了一个简单的多线程回显服务器。这种方法在这里重新介绍，为本章剩余部分中线程的使用提供了基础。
- en: The thread-per-request server
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个请求一个线程的服务器
- en: In this example, the server will accept requests for prices when given the name
    of a part. The implementation will use the `ConcurrentHashMap` class that supports
    concurrent access to the part name and price. In a multithreaded environment,
    concurrent data structures, such as the `ConcurrentHashMap` class, handle operations
    without the potential for data corruption. Also, this map is an example of caching,
    which can be useful in improving the performance of applications.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，服务器将接受给定零件名称的价格请求。实现将使用支持对零件名称和价格进行并发访问的`ConcurrentHashMap`类。在多线程环境中，并发数据结构，如`ConcurrentHashMap`类，处理操作而不会出现数据损坏的可能性。此外，这个映射是缓存的一个例子，可以用来提高应用程序的性能。
- en: 'We start with the declaration of the server as follows. The map is declared
    as static because only one instance is needed for the server. The static initialization
    block initializes the map. The `main` method will use the `ServerSocket` class
    to accept requests from a client. They will be handled in the `run` method. The
    `clientSocket` variable will hold a reference to the client socket:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从服务器的声明开始如下。地图被声明为静态，因为服务器只需要一个实例。静态初始化块初始化地图。`main`方法将使用`ServerSocket`类来接受来自客户端的请求。它们将在`run`方法中处理。`clientSocket`变量将保存对客户端套接字的引用：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `main` method follows where the server socket waits for a client request
    and then creates a new thread, passing the client socket to the thread to process
    it. Messages are displayed showing the connection being accepted:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法如下，服务器套接字等待客户端请求，然后创建一个新线程，将客户端套接字传递给线程来处理它。显示消息，显示连接被接受：'
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `run` method processes the request, as shown next. An input stream is obtained
    from the client socket, and the part name is read. The map''s `get` method uses
    this name to retrieve a price. An input stream sends the price back to the client,
    and the progress of the operation is displayed:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，`run`方法处理请求。从客户端套接字获取输入流，并读取零件名称。地图的`get`方法使用这个名称来检索价格。输入流将价格发送回客户端，并显示操作的进度：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, let's develop a client for the server.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为服务器开发一个客户端。
- en: The thread-per-request client
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个请求一个线程的客户端
- en: 'The client application, as shown next, will connect to the server, send a request,
    wait for a response, and then display the price. For this example, the client
    and the server reside on the same machine:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，客户端应用程序将连接到服务器，发送请求，等待响应，然后显示价格。对于这个例子，客户端和服务器都驻留在同一台机器上：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, let's see how the client and the server interact.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看客户端和服务器是如何交互的。
- en: The thread-per-request applications in action
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个请求一个线程的应用程序在运行
- en: 'Start the server first, which will display the following output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先启动服务器，将显示以下输出：
- en: '**Multi-Threaded Server Started**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**多线程服务器已启动**'
- en: '**Listening for a client connection**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**正在监听客户端连接**'
- en: 'Next, start the client application. The following output will be displayed:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，启动客户端应用程序。将显示以下输出：
- en: '**Client Started**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端已启动**'
- en: '**Connected to a Server**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接到服务器**'
- en: '**Axle request sent**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**轴请求已发送**'
- en: '**Response: 238.5**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应：238.5**'
- en: '**Client Terminated**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端已终止**'
- en: 'The server will then display the following output. You will note that the **Client
    Thread Started** output follows the **Listening for a client connection** output.
    This is because there is a slight delay before the thread starts:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将显示以下输出。您会注意到**客户端线程已启动**输出跟在**正在监听客户端连接**输出之后。这是因为线程启动前有轻微延迟：
- en: '**Connected to a Client**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**已连接到客户端**'
- en: '**Listening for a client connection**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**正在监听客户端连接**'
- en: '**Client Thread Started**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端线程已启动**'
- en: '**Request for Axle and returned a price of $238.50**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求轴并返回价格为$238.50**'
- en: '**Client Connection Terminated**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端连接已终止**'
- en: '**Client Thread Terminated**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端线程已终止**'
- en: The client thread started, processed the request, and then terminated.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端线程已启动，处理了请求，然后终止。
- en: 'Add the following code to the client application just before the close operation
    to send a second price request to the server:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭操作之前，将以下代码添加到客户端应用程序以发送第二个价格请求到服务器：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When the client is executed, you will get the following output. The response
    for the second string is null. This is because the server''s response thread has
    terminated after the first request was answered:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端执行时，将得到以下输出。第二个字符串的响应为null。这是因为在第一个请求得到答复后，服务器的响应线程已终止：
- en: '**Client Started**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端已启动**'
- en: '**Connected to a Server**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**已连接到服务器**'
- en: '**Axle request sent**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求轴已发送**'
- en: '**Response: 238.5**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应：238.5**'
- en: '**Wheel request sent**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送轮子请求**'
- en: '**Response: null**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应：null**'
- en: '**Client Terminated**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端已终止**'
- en: 'To handle multiple requests using this approach, you will need to reopen the
    connection and send out separate requests. The following code illustrates this
    approach. Remove the code segment that sent the second request. Add the following
    code to the client after the socket is closed. In this sequence, the socket is
    reopened, the IO streams are recreated, and the message is re-sent:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法处理多个请求，需要重新打开连接并发送单独的请求。以下代码说明了这种方法。删除发送第二个请求的代码段。在套接字关闭后，将以下代码添加到客户端。在这个顺序中，重新打开套接字，重新创建IO流，并重新发送消息：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the client is executed, it will produce the following output, which reflects
    the two requests and their response:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端执行时，将产生以下输出，反映了两个请求及其响应：
- en: '**Client Started**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端已启动**'
- en: '**Connected to a Server**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**已连接到服务器**'
- en: '**Axle request sent**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求轴已发送**'
- en: '**Response: 238.5**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应：238.5**'
- en: '**Connected to a Server**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**已连接到服务器**'
- en: '**Wheel request sent**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送轮子请求**'
- en: '**Response: 86.3**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应：86.3**'
- en: '**Client Terminated**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端已终止**'
- en: 'On the server side, we will get the following output. Two threads were created
    to handle the requests:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们将得到以下输出。已创建两个线程来处理请求：
- en: '**Multi-Threaded Server Started**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**多线程服务器已启动**'
- en: '**Listening for a client connection**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**正在监听客户端连接**'
- en: '**Connected to a Client**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**已连接到客户端**'
- en: '**Listening for a client connection**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**正在监听客户端连接**'
- en: '**Client Thread Started**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端线程已启动**'
- en: '**Connected to a Client**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**已连接到客户端**'
- en: '**Listening for a client connection**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**正在监听客户端连接**'
- en: '**Client Thread Started**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端线程已启动**'
- en: '**Request for Axle and returned a price of $238.50**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求轴并返回价格为$238.50**'
- en: '**Client Connection Terminated**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端连接已终止**'
- en: '**Client Thread Terminated**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端线程已终止**'
- en: '**Request for Wheel and returned a price of $86.30**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求轮子并返回价格为$86.30**'
- en: '**Client Connection Terminated**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端连接已终止**'
- en: '**Client Thread Terminated**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端线程已终止**'
- en: The opening and closing of the connections can be expensive. In the next section,
    we will address this type of problem. However, if only single requests are made,
    then the thread-per-request will work.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 连接的打开和关闭可能很昂贵。在下一节中，我们将解决这种类型的问题。但是，如果只有单个请求，那么每个请求一个线程的方法将起作用。
- en: Thread-per-connection approach
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个连接一个线程的方法
- en: In this approach, a single thread is used to handle all of the client's requests.
    This approach will require that the client send some sort of notification that
    it has no further requests. In lieu of an explicit notification, a timeout may
    need to be set to automatically disconnect the client after a sufficient period
    of time has elapsed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，使用单个线程来处理客户端的所有请求。这种方法将需要客户端发送某种通知，表明它没有更多的请求。如果没有明确的通知，可能需要设置超时来在足够长的时间后自动断开客户端连接。
- en: The thread-per-connection server
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个连接一个线程的服务器
- en: 'Modify the server''s `run` method by commenting out the bulk of the try block
    where the request is handled and the response is sent to the client. Replace it
    with the following code. In the infinite loop, the command request is read. If
    the request is `quit`, then the loop is exited. Otherwise, the request is handled
    in the same way as before:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过注释掉try块中处理请求和向客户端发送响应的大部分代码段，修改服务器的`run`方法。用以下代码替换。在无限循环中，读取命令请求。如果请求是`quit`，则退出循环。否则，处理请求的方式与以前相同：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is all that needs to be modified in the server.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是服务器需要修改的全部内容。
- en: The thread-per-connection client
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个连接一个线程的客户端
- en: 'In the client, replace the code after the buffered reader has been created
    with the following code. This will send three requests to the server:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端中，在创建缓冲读取器后，用以下代码替换原代码。这将向服务器发送三个请求：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Only a single connection is opened for all three requests.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个连接被打开来处理所有三个请求。
- en: The thread-per-connection applications in action
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接的每个请求一个线程的应用程序
- en: 'When the client is executed, you will get the following output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端执行时，将得到以下输出：
- en: '**Client Started**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端已启动**'
- en: '**Connected to a Server**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**已连接到服务器**'
- en: '**Axle request sent**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求轴已发送**'
- en: '**Response: 238.5**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应：238.5**'
- en: '**Wheel request sent**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送轮子请求**'
- en: '**Response: 86.3**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应：86.3**'
- en: '**Client Terminated**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端已终止**'
- en: 'On the server side, the following output is generated. You will note that only
    one thread was created to handle the multiple requests:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，将生成以下输出。您会注意到只创建了一个线程来处理多个请求：
- en: '**Multi-Threaded Server Started**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**多线程服务器已启动**'
- en: '**Listening for a client connection**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**正在监听客户端连接**'
- en: '**Connected to a Client**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**已连接到客户端**'
- en: '**Listening for a client connection**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**正在监听客户端连接**'
- en: '**Client Thread Started**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端线程已启动**'
- en: '**Request for Axle and returned a price of $238.50**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求轮轴并返回价格为$238.50**'
- en: '**Request for Wheel and returned a price of $86.30**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求轮毂并返回价格为$86.30**'
- en: '**Client Connection Terminated**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端连接已终止**'
- en: '**Client Thread Terminated**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端线程已终止**'
- en: This is a more efficient architecture for when a client makes multiple requests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更有效的架构，当客户端发出多个请求时。
- en: Thread pools
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程池
- en: Thread pools are useful when the number of threads that are created need to
    be limited. Using a pool not only controls how many threads are created, but it
    can also eliminate the need to create and destroy threads repeatedly, an often
    expensive operation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要限制创建的线程数量时，线程池非常有用。使用线程池不仅可以控制创建多少线程，还可以消除重复创建和销毁线程的需要，这通常是一项昂贵的操作。
- en: The following figure depicts a thread pool. Requests are assigned to threads
    in the pool. Some thread pools will create new threads if there are no unused
    threads available. Others will restrict the number of threads available. This
    may result in some requests being blocked.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了一个线程池。请求被分配给池中的线程。如果没有未使用的线程可用，一些线程池将创建新线程。其他线程池将限制可用线程的数量。这可能导致一些请求被阻塞。
- en: '![Thread pools](img/B04915_07_03.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![线程池](img/B04915_07_03.jpg)'
- en: We will demonstrate thread pools using the `ThreadPoolExecutor` class. This
    class also provides methods that deliver status information regarding thread execution.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`ThreadPoolExecutor`类演示线程池。该类还提供了提供有关线程执行状态信息的方法。
- en: While the `ThreadPoolExecutor` class possesses several constructors, the `Executors`
    class provides an easy way of creating instances of the `ThreadPoolExecutor` class.
    We will demonstrate two of these methods. First, we will use the `newCachedThreadPool`
    method. The pool created by this method will reuse threads. New threads will be
    created when needed. However, this can result in too many threads being created.
    The second method, `newFixedThreadPool`, creates a fixed-size pool of threads.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`ThreadPoolExecutor`类具有多个构造函数，但`Executors`类提供了一种创建`ThreadPoolExecutor`类实例的简单方法。我们将演示其中两种方法。首先，我们将使用`newCachedThreadPool`方法。此方法创建的线程池将重用线程。需要时会创建新线程。但是，这可能导致创建太多线程。第二种方法`newFixedThreadPool`创建了一个固定大小的线程池。
- en: The ThreadPoolExecutor class characteristics
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ThreadPoolExecutor类的特性
- en: When an instance of this class is created, it will accept new tasks, which are
    passed to the thread pool. However, the pool will not close down automatically.
    If idle, it will wait until new tasks are submitted. To terminate the pool, either
    the `shutdown` or `shutdownNow` method needs to be called. The latter method shuts
    down the pool immediately and will not process pending tasks.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此类的实例后，它将接受新任务，这些任务将传递给线程池。但是，池不会自动关闭。如果空闲，它将等待提交新任务。要终止池，需要调用`shutdown`或`shutdownNow`方法。后者立即关闭池，并且不会处理待处理的任务。
- en: The `ThreadPoolExecutor` class has a number of methods that provides additional
    information. For example, the `getPoolSize` method returns the current number
    of threads in the pool. The `getActiveCount` method returns the number of active
    threads. The `getLargestPoolSize` method returns the maximum number of threads
    that were in the pool at one time. There are several other methods that are available.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPoolExecutor`类有许多方法提供额外的信息。例如，`getPoolSize`方法返回池中当前的线程数。`getActiveCount`方法返回活动线程的数量。`getLargestPoolSize`方法返回池中曾经的最大线程数。还有其他几种可用的方法。'
- en: Simple thread pool server
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单线程池服务器
- en: The server that we will use to demonstrate a thread pool will return a price
    of a part when given the name of a part. Each thread will access a `ConcurrentHashMap`
    instance that holds the part information. We use the concurrent version of the
    hash map as it may be accessed from multiple threads.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的服务器来演示线程池，当给出零件名称时，将返回零件的价格。每个线程将访问一个包含零件信息的`ConcurrentHashMap`实例。我们使用哈希映射的并发版本，因为它可能会被多个线程访问。
- en: 'The `ThreadPool` class is declared next. The `main` method uses a `WorkerThread`
    class to perform the actual work. In the `main` method, the `newCachedThreadPool`
    method is called to create a thread pool:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来声明了`ThreadPool`类。`main`方法使用`WorkerThread`类执行实际工作。在`main`方法中，调用`newCachedThreadPool`方法创建线程池：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, a try block is used to catch and handle any exceptions that may occur.
    Within the try block, a server socket is created and its `accept` method blocks
    until a client connection is requested. When a connection is established, a `WorkerThread`
    instance is created using the client socket, as shown in the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用try块来捕获和处理可能发生的任何异常。在try块内，创建了一个服务器套接字，其`accept`方法会阻塞，直到有客户端连接请求。建立连接后，使用客户端套接字创建了一个`WorkerThread`实例，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let''s examine the `WorkerThread` class that is shown next. The `ConcurrentHashMap`
    instance is declared where a string is used as the key and the object that is
    stored is a float. The hash map is initialized in a static initializer block:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下接下来显示的`WorkerThread`类。在这里声明了`ConcurrentHashMap`实例，其中使用字符串作为键，存储的对象是浮点数。哈希映射在静态初始化块中进行了初始化：
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The class''s constructor assigns the client socket to the `clientSocket` instance
    variable for later use, as shown here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 类的构造函数将客户端套接字分配给`clientSocket`实例变量以供以后使用，如下所示：
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `run` method processes the request. An input stream is obtained from the
    client socket and used to get the part name. This name is used as the argument
    of the hash map''s `get` method to obtain the corresponding price. This price
    is sent back to the client, and a message is displayed showing the response:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`方法处理请求。从客户端套接字获取输入流，并用于获取零件名称。将此名称用作哈希映射的`get`方法的参数，以获取相应的价格。将此价格发送回客户端，并显示一个显示响应的消息：'
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We are now ready to discuss the client application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备讨论客户端应用程序。
- en: Simple thread pool client
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单线程池客户端
- en: This application uses the `Socket` class to establish a connection to the server.
    Input and output streams are used to send and receive responses. This approach
    was discussed in [Chapter 1](ch01.html "Chapter 1. Getting Started with Network
    Programming"), *Getting Started with Network Programming*. The client application
    follows. A connection is established with the server and a request for a part's
    price is sent to the server. The response is obtained and displayed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序使用`Socket`类建立与服务器的连接。输入和输出流用于发送和接收响应。这种方法在[第1章](ch01.html "第1章 网络编程入门")中讨论过，*网络编程入门*。以下是客户端应用程序。与服务器建立连接，并向服务器发送部件价格的请求。获取并显示响应。
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We are now ready to see how they work together.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备看它们如何一起工作。
- en: The thread pool client/server in action
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程池客户端/服务器正在运行
- en: 'Start the server application first. You will see the following output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先启动服务器应用程序。您将看到以下输出：
- en: '**Thread Pool Server Started**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 线程池服务器已启动
- en: '**Listening for a client connection**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正在监听客户端连接
- en: 'Next, start the client. It will produce the following output where a request
    for an axle price is sent, and then a response of `238.5` is received:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，启动客户端。它将产生以下输出，发送轴价格请求，然后接收到`238.5`的响应：
- en: '**Client Started**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端已启动
- en: '**Connected to a Server**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 已连接到服务器
- en: '**Axle request sent**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 轴请求已发送
- en: '**Response: 238.5**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 响应：238.5
- en: '**Client Terminated**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端已终止
- en: 'On the server side, you will see output similar to the following one. The thread
    is created, and the request and response data is displayed. The thread then terminates.
    You will note that the name of the thread is preceded by the string "packt". This
    is the name of the package for the application:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，您将看到类似以下输出。线程已创建，并显示请求和响应数据。然后线程终止。您会注意到线程的名称前面有字符串“packt”。这是应用程序的包名称：
- en: '**Connected to a Client**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 已连接到客户端
- en: '**Task created: packt.WorkerThread@33909752**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 任务已创建：packt.WorkerThread@33909752
- en: '**Listening for a client connection**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正在监听客户端连接
- en: '**Worker Thread Started**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程已启动
- en: '**Request for Axle and returned a price of $238.50**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请求轴并返回价格为238.50美元
- en: '**Client Connection Terminated**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端连接已终止
- en: '**Worker Thread Terminated**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程已终止
- en: 'If you start a second client, the server will produce output similar to the
    following one. You will note that a new thread is created for each request:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启动第二个客户端，服务器将产生类似以下输出。您会注意到为每个请求创建了一个新线程：
- en: '**Thread Pool Server Started**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 线程池服务器已启动
- en: '**Listening for a client connection**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正在监听客户端连接
- en: '**Connected to a Client**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 已连接到客户端
- en: '**Task created: packt.WorkerThread@33909752**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 任务已创建：packt.WorkerThread@33909752
- en: '**Listening for a client connection**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正在监听客户端连接
- en: '**Worker Thread Started**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程已启动
- en: '**Request for Axle and returned a price of $238.50**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请求轴并返回价格为238.50美元
- en: '**Client Connection Terminated**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端连接已终止
- en: '**Worker Thread Terminated**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程已终止
- en: '**Connected to a Client**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 已连接到客户端
- en: '**Task created: packt.WorkerThread@3d4eac69**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 任务已创建：packt.WorkerThread@3d4eac69
- en: '**Listening for a client connection**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正在监听客户端连接
- en: '**Worker Thread Started**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程已启动
- en: '**Request for Axle and returned a price of $238.50**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请求轴并返回价格为238.50美元
- en: '**Client Connection** **Terminated**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端连接已终止
- en: '**Worker Thread Terminated**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程已终止
- en: Thread pool with Callable
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Callable的线程池
- en: Using the `Callable` and `Future` interfaces provides another approach to support
    multiple threads. The `Callable` interface supports threading where a thread needs
    to return a result. The `Runnable` interface's `run` method does not return a
    value. For some threads, this can be a problem. The `Callable` interface possesses
    a single method, `call`, which returns a value and can be used instead of the
    `Runnable` interface.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Callable`和`Future`接口提供了另一种支持多线程的方法。`Callable`接口支持需要返回结果的线程。`Runnable`接口的`run`方法不返回值。对于某些线程，这可能是一个问题。`Callable`接口具有一个`call`方法，返回一个值，可以代替`Runnable`接口。
- en: The `Future` interface is used in combination with a `Callable` object. The
    idea is that the `call` method is invoked and the current thread continues performing
    some other task. When the `Callable` object is complete, then a `get` method is
    used to retrieve the results. This method will block if necessary.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future`接口与`Callable`对象结合使用。其思想是调用`call`方法，当前线程继续执行其他任务。当`Callable`对象完成后，使用`get`方法来检索结果。必要时，此方法将阻塞。'
- en: Using a Callable
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Callable
- en: We will use the `Callable` interface to supplement the `WorkerThread` class
    that we created earlier. Instead of placing the part name hash map in the `WorkerThread`
    class, we will move it to a class called `WorkerCallable` where we will override
    the `call` method to return the price. This is actually extra work for this application,
    but it illustrates one way of using the `Callable` interface. It demonstrates
    how we can return a value from the `Callable` object.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Callable`接口来补充我们之前创建的`WorkerThread`类。我们将部件名称哈希映射移到一个名为`WorkerCallable`的类中，我们将重写`call`方法以返回价格。这实际上是对此应用程序的额外工作，但它说明了使用`Callable`接口的一种方式。它演示了如何从`Callable`对象返回一个值。
- en: 'The `WorkerCallable` class, that is declared next, uses the same code to create
    and initialize the hash map:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下面声明的`WorkerCallable`类使用相同的代码来创建和初始化哈希映射：
- en: '[PRE14]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The constructor will initialize the part name, as shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将初始化部件名称，如下所示：
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `call` method is shown next. The map obtains the price, which we display
    and then return:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来显示了`call`方法。地图获取价格，我们显示然后返回：
- en: '[PRE16]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, modify the `WorkerThread` class by removing the following statement:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过删除以下语句修改`WorkerThread`类：
- en: '[PRE17]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Replace it with the following code. A new `WorkerCallable` instance is created
    using the part name that was requested by a client. The `call` method is immediately
    invoked and will return the corresponding part''s price:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换它。使用客户端请求的零件名称创建一个新的`WorkerCallable`实例。立即调用`call`方法，并返回相应零件的价格：
- en: '[PRE18]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The application will produce the same output as before, except that you will
    see messages indicating that the `WorkerCallable` class's `call` method was executed.
    While another thread is created, we will block until the `call` method returns.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将产生与以前相同的输出，只是您将看到消息指示`WorkerCallable`类的`call`方法已执行。虽然创建了另一个线程，但我们将阻塞，直到`call`方法返回。
- en: This example does not fully demonstrate the power of this approach. The `Future`
    interface will improve on this technique.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子并没有完全展示这种方法的威力。`Future`接口将改进这种技术。
- en: Using a Future
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Future
- en: The `Future` interface represents the results of a completed `call` method.
    With this interface, we can invoke a `Callable` object and not wait for it to
    return. Assume that the process of computing a part price is more involved than
    just looking it up in a table. It is conceivable that multiple steps may be required
    to calculate a price, each of which may be involved and may take a bit of time
    to complete. Also assume that these separate steps can be performed concurrently.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future`接口表示已完成的`call`方法的结果。使用此接口，我们可以调用`Callable`对象，而不必等待其返回。假设计算零件价格的过程比仅在表中查找要复杂。可以想象需要多个步骤来计算价格，每个步骤可能都很复杂，可能需要一些时间来完成。还假设这些单独的步骤可以并发执行。'
- en: 'Replace the previous example with the following code. We create a new `ThreadPoolExecutor`
    instance to which we will assign two `Callable` objects representing a two-step
    price determination process. This is done using the `submit` method, which returns
    a `Future` instance. The implementation of the `call` methods returns `1.0` and
    `2.0` respectively to keep the example simple:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换上一个示例。我们创建一个新的`ThreadPoolExecutor`实例，将两个代表两步价格确定过程的`Callable`对象分配给它。这是使用`submit`方法完成的，该方法返回一个`Future`实例。`call`方法的实现分别返回`1.0`和`2.0`，以保持示例简单：
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, add the following try block, which uses the `get` method to obtain the
    two parts of the price. These are used to determine the price for the part. If
    the corresponding `Callable` object has not completed, then the `get` method will
    block:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加以下try块，使用`get`方法获取价格的两个部分。这些用于确定零件的价格。如果相应的`Callable`对象尚未完成，则`get`方法将阻塞：
- en: '[PRE20]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When this code is executed, you will get a price of 3.0 for the parts. The combination
    of the `Callable` and `Future` interfaces provides an easy to use this technique
    to handle threads that return a value.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码时，您将获得零件的价格为3.0。 `Callable`和`Future`接口的组合提供了一种处理返回值的线程的简单技术。
- en: Using the HttpServer executor
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HttpServer执行程序
- en: We introduced the `HTTPServer` class in [Chapter 4](ch04.html "Chapter 4. Client/Server
    Development"), *Client/Server Development*. When the HTTP Server receives a request,
    by default, it uses the thread that was created when the `start` method is called.
    However, it is possible to use a different thread. The `setExecutor` method specifies
    how these requests are assigned to threads.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](ch04.html "第4章 客户端/服务器开发")中介绍了`HTTPServer`类。当HTTP服务器接收到请求时，默认情况下会使用在调用`start`方法时创建的线程。但是，也可以使用不同的线程。`setExecutor`方法指定了如何将这些请求分配给线程。
- en: 'The argument of this method is an `Executor` object. We can use any of several
    implementations for this argument. In the following sequence, a cached thread
    pool is used:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的参数是一个`Executor`对象。我们可以为此参数使用几种实现中的任何一种。在以下顺序中，使用了一个缓存的线程池：
- en: '[PRE21]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To control the number of threads that are used by the server, we can use a
    fixed thread pool of size `5`, as shown here:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制服务器使用的线程数量，我们可以使用大小为`5`的固定线程池，如下所示：
- en: '[PRE22]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This method must be called before the `start` method of `HTTPServer` is called.
    All requests are then submitted to the executor. The following is duplicated from
    the `HTTPServer` class that was developed in [Chapter 4](ch04.html "Chapter 4. Client/Server
    Development"), *Client/Server Development*, and shows you the use of the `setExecutor`
    method:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`HTTPServer`的`start`方法之前必须调用此方法。然后所有请求都将提交给执行程序。以下是在[第4章](ch04.html "第4章
    客户端/服务器开发")中开发的`HTTPServer`类中复制的，并向您展示了`setExecutor`方法的用法：
- en: '[PRE23]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The server will execute the same way as it did before, but it will use a cached
    thread pool instead.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将以与以前相同的方式执行，但将使用缓存的线程池。
- en: Using a selector
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用选择器
- en: A selector is used in an NIO application and allows one thread to handle multiple
    channels. The selector coordinates multiple channels and their events. It identifies
    those channels that are ready for processing. If we were to use a thread per channel,
    then we will find ourselves switching between threads frequently. This switching
    process can be expensive. Using a single thread to handle multiple channels avoids
    some of this overhead.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器用于NIO应用程序，允许一个线程处理多个通道。选择器协调多个通道及其事件。它标识了准备处理的通道。如果我们每个通道使用一个线程，那么我们会经常在线程之间切换。这种切换过程可能很昂贵。使用单个线程处理多个通道可以避免部分开销。
- en: The following figure depicts this architecture. A thread is registered with
    a selector. The selector will identify the channels and events that are ready
    for processing.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了这种架构。一个线程被注册到一个选择器中。选择器将识别准备处理的通道和事件。
- en: '![Using a selector](img/B04915_07_04.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![使用选择器](img/B04915_07_04.jpg)'
- en: 'A selector is supported by two primary classes:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器由两个主要类支持：
- en: '`Selector`: This provides the primary functionality'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Selector`：提供主要功能'
- en: '`SelectionKey`: This identifies the types of events that are ready for processing'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectionKey`：这标识了准备处理的事件类型'
- en: 'To use a selector, perform the following actions:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用选择器，请执行以下操作：
- en: Create a selector
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建选择器
- en: Register channels with the selector
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用选择器注册通道
- en: Select a channel for use when it becomes available
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个通道以在可用时使用
- en: Let's examine each of these steps in more detail.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地检查每个步骤。
- en: Creating the selector
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建选择器
- en: 'There are no public `Selector` constructors. To create a `Selector` object,
    use the static `open` method, as shown here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 没有公共的 `Selector` 构造函数。要创建 `Selector` 对象，请使用静态的 `open` 方法，如下所示：
- en: '[PRE24]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There is also an `isOpen` method to determine if a selector is open and a `close`
    method to close it when it is no longer needed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 `isOpen` 方法来确定选择器是否打开，以及一个 `close` 方法在不再需要时关闭它。
- en: Registering a channel
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册通道
- en: 'The `register` method registers a channel with a selector. Any channel that
    is registered with a selector must be in a nonblocking mode. For example, a `FileChannel`
    object cannot be registered because it cannot be placed in a nonblocking mode.
    Use the `configureBlocking` method with `false` as its argument to place the channel
    in a nonblocking mode, as shown here:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`register` 方法使用选择器注册通道。任何注册到选择器的通道必须处于非阻塞模式。例如，`FileChannel` 对象不能注册，因为它不能放置在非阻塞模式。使用
    `configureBlocking` 方法并将 `false` 作为其参数来将通道置于非阻塞模式，如下所示：'
- en: '[PRE25]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `register` method is as follows. This is a method of the `ServerSocketChannel`
    and SocketChannel classes. In the following example, it is used with a `SocketChannel`
    `instance`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`register` 方法如下。这是 `ServerSocketChannel` 和 `SocketChannel` 类的方法。在下面的示例中，它与
    `SocketChannel` `实例` 一起使用：'
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `Channel` class''s `register` method possesses three arguments:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`Channel` 类的 `register` 方法具有三个参数：'
- en: The selector to register
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于注册的选择器
- en: The event type of interest
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 感兴趣的事件类型
- en: Data to be associated with the channel
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要与通道关联的数据
- en: The event type specifies the type of channel events that an application is interested
    in handling. For example, we may only want to be informed of an event if the channel
    has data that is ready to be read.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 事件类型指定应用程序感兴趣处理的通道事件类型。例如，如果通道有准备好读取的数据，我们可能只想被通知事件。
- en: 'There are four event types that are available, as listed in the following table:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种可用的事件类型，如下表所列：
- en: '| Type | Event type constants | Meaning |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 事件类型常量 | 意义 |'
- en: '| --- | --- | --- |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Connect | `SelectionKey.OP_CONNECT` | This indicates that the channel has
    successfully connected to a server |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 连接 | `SelectionKey.OP_CONNECT` | 这表示通道已成功连接到服务器 |'
- en: '| Accept | `SelectionKey.OP_ACCEPT` | This indicates that a server socket channel
    is ready to accept connection requests from a client |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 接受 | `SelectionKey.OP_ACCEPT` | 这表示服务器套接字通道已准备好接受来自客户端的连接请求 |'
- en: '| Read | `SelectionKey.OP_READ` | This indicates that the channel has data
    ready to be read |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 读取 | `SelectionKey.OP_READ` | 这表示通道有准备好读取的数据 |'
- en: '| Write | `SelectionKey.OP_WRITE` | This indicates that the channel is ready
    for write operations |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 写入 | `SelectionKey.OP_WRITE` | 这表示通道已准备好进行写操作 |'
- en: 'These types are referred to as interest sets. In the following statement, the
    channel is associated with the read interest type. The method returns a `SelectionKey`
    instance, which contains a number of useful properties:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型被称为兴趣集。在下面的语句中，通道与读取兴趣类型相关联。该方法返回一个 `SelectionKey` 实例，其中包含许多有用的属性：
- en: '[PRE27]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If there are multiple events of interest, then we can create a combination
    of these using the OR operator as shown here:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个感兴趣的事件，我们可以使用 OR 运算符创建这些事件的组合，如下所示：
- en: '[PRE28]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `SelectionKey` class possesses several properties that will help in working
    with channels. These include the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectionKey` 类具有几个属性，将有助于处理通道。其中包括以下内容：'
- en: '**Interest set**: This contains the events of interest.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兴趣集：这包含了感兴趣的事件。
- en: '**Ready set**: This is the set of operations that the channel is ready to handle.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就绪集：这是通道准备处理的操作集。
- en: '**Channel**: The `channel` method returns the channel that is associated with
    a selection key.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道：`channel` 方法返回与选择键相关联的通道。
- en: '**Selector**: The `selector` method returns the selector that is associated
    with the selection key.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择器：`selector` 方法返回与选择键相关联的选择器。
- en: '**Attached objects**: Further information can be attached using the `attach`
    method. The `attachment` method is used later to access this object.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加对象：可以使用 `attach` 方法附加更多信息。稍后使用 `attachment` 方法访问此对象。
- en: 'The `interestOps` method returns an integer representing the events of interest,
    as shown next:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`interestOps` 方法返回一个整数，表示感兴趣的事件，如下所示：'
- en: '[PRE29]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will use this to process the events.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个来处理事件。
- en: 'To determine which events are ready, we can use any of the following methods:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定哪些事件已准备就绪，我们可以使用以下任何方法之一：
- en: '`readOps`: This returns an integer containing the ready events'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readOps`：这返回一个包含准备好的事件的整数'
- en: '`isAcceptable`: This indicates that the accept event is ready'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isAcceptable`：这表示接受事件已准备就绪'
- en: '`isConnectable`: This indicates that the connection event is ready'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isConnectable`：这表示连接事件已准备就绪'
- en: '`isReadable`: This indicates that the read event is ready'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isReadable`：这表示读事件已准备就绪'
- en: '`isWritable`: This indicates that the write event is ready'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isWritable`：这表示写事件已准备就绪'
- en: Now, let's see these methods in action.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这些方法如何运作。
- en: Using the selector to support a time client/server
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用选择器支持时间客户端/服务器
- en: We will develop a time server to illustrate the use of the `Selector` class
    and related classes. This server and the time client are adapted from the time
    server and client applications that were in [Chapter 3](ch03.html "Chapter 3. NIO
    Support for Networking"), *NIO Support for Networking*. The focus here will be
    on the use of the selector. The channel and buffer operations will not be discussed
    here as they were covered earlier.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个时间服务器来说明 `Selector` 类和相关类的使用。该服务器和时间客户端是从 [第 3 章](ch03.html "第 3 章。NIO
    支持网络") 中的时间服务器和客户端应用程序改编而来，*NIO 支持网络*。这里的重点将放在选择器的使用上。通道和缓冲区操作将不在这里讨论，因为它们已经在之前讨论过。
- en: The channel time server
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通道时间服务器
- en: The time server will accept connections to client applications and send the
    current date and time to the clients every second. A client may not receive all
    of these messages as we will discover when we discuss the client.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 时间服务器将接受客户端应用程序的连接，并每秒向客户端发送当前日期和时间。当我们讨论客户端时，客户端可能无法接收所有这些消息。
- en: The time server uses an internal static class, `SelectorHandler`, to handle
    the selector and send messages. This class implements the `Runnable` interface
    and will be the selector's thread.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 时间服务器使用内部静态类`SelectorHandler`来处理选择器并发送消息。这个类实现了`Runnable`接口，并将成为选择器的线程。
- en: 'In the `main` method, the server socket accepts new channel connections and
    registers them with the selector. The `Selector` object is declared as a static
    instance variable, as shown next. This allows it to be accessed from the `SelectorHandler`
    thread and the main application thread. Sharing this object will result in potential
    synchronization problems, which we will address:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`方法中，服务器套接字接受新的通道连接并将它们注册到选择器中。`Selector`对象被声明为静态实例变量，如下所示。这允许它从`SelectorHandler`线程和主应用程序线程中访问。共享此对象将导致潜在的同步问题，我们将解决这些问题：
- en: '[PRE30]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s start with the `main` method. A server socket channel is created that
    uses port `5000`. Exceptions are caught in a try block, as shown here:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`main`方法开始。创建一个使用端口`5000`的服务器套接字通道。异常在try块中捕获，如下所示：
- en: '[PRE31]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The selector is created, and a thread for the `SelectorHandler` instance is
    started:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器被创建，并启动了一个`SelectorHandler`实例的线程：
- en: '[PRE32]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'An infinite loop will accept new connections. A message is displayed indicating
    that a connection has been made:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 无限循环将接受新的连接。显示一条消息，指示已建立连接：
- en: '[PRE33]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With a good channel, the `configureBlocking` method is called, the selector
    is woken up, and the channel is registered with the selector. A thread may be
    blocked by the `select` method. Using the `wakeup` method will cause the `select`
    method to immediately return, which allows the `register` method to unblock:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 有了一个良好的通道，将调用`configureBlocking`方法，唤醒选择器，并将通道注册到选择器。线程可能会被`select`方法阻塞。使用`wakeup`方法将导致`select`方法立即返回，从而允许`register`方法解除阻塞：
- en: '[PRE34]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Once a channel has been registered with a selector, we can start processing
    events that are associated with that channel.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通道已经注册到选择器，我们就可以开始处理与该通道关联的事件。
- en: 'The `SelectorHandler` class will use the selector object to identify events
    as they occur and associate them with specific channels. Its `run` method does
    all of the work. As shown next, an infinite loop uses the `select` method to identify
    events as they occur. The `select` method uses an argument of `500`, which specifies
    a timeout of 500 milliseconds. It returns an integer specifying how many keys
    are ready to be processed:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectorHandler`类将使用选择器对象标识事件的发生，并将它们与特定通道关联起来。它的`run`方法完成所有工作。如下所示，一个无限循环使用`select`方法标识事件的发生。`select`方法使用`500`作为参数，指定500毫秒的超时。它返回一个整数，指定有多少个密钥准备好被处理：'
- en: '[PRE35]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If the `select` method times out, it will return a value of `0`. When this
    happens, we display a message to that effect, as shown here:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`select`方法超时，它将返回值`0`。当这种情况发生时，我们会显示相应的消息，如下所示：
- en: '[PRE36]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If there are keys ready, then the `selectedKeys` method will return this set.
    An iterator is then used to process each key one at a time:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有准备好的密钥，那么`selectedKeys`方法将返回这个集合。然后使用迭代器逐个处理每个密钥：
- en: '[PRE37]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Each `SelectionKey` instance is checked to see which event type has occurred.
    In the following implementation, only the writeable events are processed. After
    processing, the thread sleeps for one second. This will have the effect of delaying
    the sending of a date and time message by at least one second. The `remove` method
    is needed to remove an event for the iterator list:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 检查每个`SelectionKey`实例，以查看发生了哪种事件类型。在以下实现中，只处理可写事件。处理完后，线程休眠一秒。这将延迟至少一秒发送日期和时间消息。需要`remove`方法来从迭代器列表中删除事件：
- en: '[PRE38]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If it is a writeable event, then the date and time is sent, as shown next.
    The `channel` method returns the channel for the event, and the message is sent
    to that client. A message is displayed showing that the message has been sent:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是可写事件，则发送日期和时间，如下所示。`channel`方法返回事件的通道，并将消息发送给该客户端。显示消息，显示消息已发送：
- en: '[PRE39]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: With the server ready, we will develop our client application.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器准备就绪后，我们将开发我们的客户端应用程序。
- en: The date and time client application
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日期和时间客户端应用程序
- en: 'The client application is almost identical to the one that was developed in
    [Chapter 3](ch03.html "Chapter 3. NIO Support for Networking"), *NIO Support for
    Networking*. The main difference is that it will request the data and time at
    random intervals. This effect will be seen when we use multiple clients with our
    server. The application''s implementation is as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序几乎与[第3章](ch03.html "第3章。NIO支持网络")中开发的应用程序相同，*NIO支持网络*。主要区别在于它将在随机间隔请求日期和时间。当我们使用多个客户端与我们的服务器时，将看到这种效果。应用程序的实现如下：
- en: '[PRE40]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We are now ready to see how the server and client work together.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好看看服务器和客户端如何一起工作。
- en: The date and time server/client in action
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正在运行的日期和时间服务器/客户端
- en: 'First, start the server. It will produce the following output:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，启动服务器。它将产生以下输出：
- en: '**Time Server started**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间服务器已启动**'
- en: '**About to select ...**'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**即将选择...**'
- en: '**No tasks available**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有可用的任务**'
- en: '**About to select ...**'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**即将选择...**'
- en: '**No tasks available**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有可用的任务**'
- en: '**About to select ...**'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**即将选择...**'
- en: '**No tasks available**'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有可用的任务**'
- en: '**...**'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**...**'
- en: This sequence will repeat itself until a client connects to the server.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列将重复，直到客户端连接到服务器。
- en: 'Next, start up the client. On the client side, you will get output similar
    to the following one:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，启动客户端。在客户端上，您将获得类似以下输出：
- en: '**Date: Wed Oct 07 17:55:43 CDT 2015**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**日期：2015年10月07日星期三17:55:43 CDT**'
- en: '**Date: Wed Oct 07 17:55:45 CDT 2015**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**日期：2015年10月07日星期三17:55:45 CDT**'
- en: '**Date: Wed Oct 07 17:55:47 CDT 2015**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**日期：2015年10月07日星期三17:55:47 CDT**'
- en: '**Date: Wed Oct 07 17:55:49 CDT 2015**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**日期：2015年10月07日星期三17:55:49 CDT**'
- en: 'On the server side, you will see output reflecting the connection and then
    the requests, as shown next. You will note that the port number, `58907`, identifies
    this client:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，您将看到反映连接和请求的输出，如下所示。您会注意到端口号`58907`标识了这个客户端：
- en: '**...**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**...**'
- en: '**Sent: Date: Wed Oct 07 17:55:43 CDT 2015 to: java.nio.channels.SocketChannel[connected
    local=/127.0.0.1:5000 remote=/127.0.0.1:58907]**'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**已发送：日期：2015年10月07日星期三17:55:43 CDT 至：java.nio.channels.SocketChannel[connected
    local=/127.0.0.1:5000 remote=/127.0.0.1:58907]**'
- en: '**...**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**...**'
- en: '**Sent: Date: Wed Oct 07 17:55:45 CDT 2015 to: java.nio.channels.SocketChannel[connected
    local=/127.0.0.1:5000 remote=/127.0.0.1:58907]**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**已发送：日期：2015年10月07日星期三17:55:45 CDT 至：java.nio.channels.SocketChannel[connected
    local=/127.0.0.1:5000 remote=/127.0.0.1:58907]**'
- en: 'Start up a second client. You will see a similar connection message but with
    a different port number. One possible connection message that follows is showing
    a client with port number `58908`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 启动第二个客户端。您将看到类似的连接消息，但端口号不同。一个可能的连接消息是显示一个端口号为`58908`的客户端：
- en: '**Socket channel accepted - java.nio.channels.SocketChannel[connected local=/127.0.0.1:5000
    remote=/127.0.0.1:58908]**'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**已接受套接字通道 - java.nio.channels.SocketChannel[connected local=/127.0.0.1:5000
    remote=/127.0.0.1:58908]**'
- en: You will then see date and time messages being sent to both clients.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将看到日期和时间消息被发送到两个客户端。
- en: Handling network timeouts
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理网络超时
- en: When an application is deployed in the real world, new network problems can
    occur that were not present when this application was developed on a LAN. Problems,
    such as network congestion, slow connections, and the loss of a network link can
    result in delays or loss of messages. It is important to detect and handle network
    timeouts.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '当应用程序部署在现实世界中时，可能会出现在局域网开发时不存在的新网络问题。问题，比如网络拥塞、慢速连接和网络链路丢失可能导致消息的延迟或丢失。检测和处理网络超时是很重要的。 '
- en: There are several socket options which provide some control over socket communications.
    The `SO_TIMEOUT` option is used to set a timeout for read operations. If the specified
    amount of time elapses, then a `SocketTimeoutException` exception is thrown.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个套接字选项可以对套接字通信进行一些控制。`SO_TIMEOUT`选项用于设置读操作的超时时间。如果指定的时间过去，那么将抛出`SocketTimeoutException`异常。
- en: 'In the following statement, the socket will expire after three seconds have
    elapsed:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的语句中，套接字将在三秒后过期：
- en: '[PRE41]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The option must be set before a blocking read operation occurs. A timeout of
    zero will never time out. Handling timeouts is an important design consideration.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 选项必须在阻塞读操作发生之前设置。超时时间为零将永远不会超时。处理超时是一个重要的设计考虑。
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we examined several approaches to address the scalability of
    applications. Scalability refers to the ability of an application to compensate
    for increased loads placed on it. While our examples focused on applying these
    techniques to servers, they are equally applicable to clients.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了几种应对应用程序可扩展性的方法。可扩展性是指应用程序在承受增加负载的能力。虽然我们的例子侧重于将这些技术应用于服务器，但它们同样适用于客户端。
- en: 'We introduced three threading architectures, and we focused on two of them:
    thread-per-request and thread-per-connection. The thread-per-request model creates
    a new thread for each request that arrives at a server. This is suitable for situations
    where a client will make a single or possibly a few requests at a time.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了三种线程架构，并重点介绍了其中的两种：每个请求一个线程和每个连接一个线程。每个请求一个线程的模型为到达服务器的每个请求创建一个新线程。这适用于客户端一次或可能一次性发出几个请求的情况。
- en: The thread-per-connection model will create a thread to handle multiple requests
    from a client. This avoids having to reconnect to the client multiple times and
    having to incur the cost of multiple thread creations. This approach is good for
    clients who need to maintain a session and possibly state information.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 每个连接一个线程的模型将创建一个线程来处理来自客户端的多个请求。这样可以避免多次重新连接客户端，避免产生多个线程的成本。这种方法适用于需要维护会话和可能状态信息的客户端。
- en: Thread pools support an approach that avoids creating and destroying threads.
    A collection of threads is managed by a thread pool. Threads that are not being
    used can be repurposed for a different request. The size of thread pools can be
    controlled and, thus limited depending on the requirements of the application
    and the environment. The `Executor` class was used to create and manage thread
    pools.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 线程池支持一种避免创建和销毁线程的方法。线程池管理一组线程。未被使用的线程可以被重新用于不同的请求。线程池的大小可以受到控制，因此可以根据应用程序和环境的要求进行限制。`Executor`类被用来创建和管理线程池。
- en: The NIO's `Selector` class was illustrated. This class makes it easier to work
    with threads and NIO channels. Channels and channel-related events are registered
    with a selector. When an event, such as a channel becoming available for a read
    operation, occurs, the selector provides access to the channel and the event.
    This allows a single thread to manage several channels.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: NIO的`Selector`类被说明了。这个类使得更容易处理线程和NIO通道。通道和与通道相关的事件被注册到选择器中。当事件发生时，比如通道可用于读操作时，选择器提供对通道和事件的访问。这允许一个单独的线程管理多个通道。
- en: We briefly re-examined the `HttpServer` class that was introduced in [Chapter
    4](ch04.html "Chapter 4. Client/Server Development"), *Client/Server Development*.
    We demonstrated how easy it is to add a thread pool to improve the server's performance.
    We also examined the nature of network timeouts and how to handle them. These
    can occur when the network fails to support timely communication between applications.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地重新审视了在[第4章](ch04.html "第4章. 客户端/服务器开发")中介绍的`HttpServer`类，*客户端/服务器开发*。我们演示了如何轻松地添加线程池以提高服务器的性能。我们还研究了网络超时的性质以及如何处理它们。当网络无法及时支持应用程序之间的通信时，这些问题可能会发生。
- en: In the next chapter, we will explore network security threats and how we can
    address them.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨网络安全威胁以及我们如何解决这些问题。
