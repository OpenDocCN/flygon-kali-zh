- en: '*Chapter 3*: Working with Forms and Data'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：使用表单和数据'
- en: In this chapter, we will write our first app for the fictional company UnoBookRail,
    which will be targeting desktops and the web. We will write a typical **line of
    business** (**LOB**) app that allows us to view, enter, and edit data. In addition
    to that, we will also cover how to export data in PDF format since this is a common
    requirement for LOB apps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将为虚构公司UnoBookRail编写我们的第一个应用程序，该应用程序将针对桌面和Web进行定位。我们将编写一个典型的**业务线**（LOB）应用程序，允许我们查看、输入和编辑数据。除此之外，我们还将介绍如何以PDF格式导出数据，因为这是LOB应用程序的常见要求。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Writing a desktop-focused Uno Platform app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写以桌面为重点的Uno平台应用程序
- en: Writing forms and validating user input
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写表单并验证用户输入
- en: Using the Windows Community Toolkit in your Uno Platform app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的Uno平台应用程序中使用Windows社区工具包
- en: Generating PDF files programmatically
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以编程方式生成PDF文件
- en: By the end of this chapter, you'll have created a desktop-focused app that can
    also run on the web that displays data, allows you to edit the data, and also
    export the data in PDF format.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将创建一个以桌面为重点的应用程序，也可以在Web上运行，显示数据，允许您编辑数据，并以PDF格式导出数据。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you already have your development environment set
    up, as well as the project templates installed, as we covered in [*Chapter 1*](B17132_01_Final_VK_ePub.xhtml#_idTextAnchor015),
    *Introducing Uno Platform*. The source code for this chapter can be found at [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter03](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter03).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已经设置好了开发环境，并安装了项目模板，就像我们在[*第1章*](B17132_01_Final_VK_ePub.xhtml#_idTextAnchor015)中介绍的那样，*介绍Uno平台*。本章的源代码可以在[https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter03](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter03)找到。
- en: 'The code in this chapter makes use of the following library: [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码使用了以下库：[https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary)。
- en: 'Check out the following video to see the code in action: [https://bit.ly/3fWYRai](https://bit.ly/3fWYRai)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的运行情况：[https://bit.ly/3fWYRai](https://bit.ly/3fWYRai)
- en: Introducing the app
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍应用程序
- en: 'In this chapter, we will build the UnoBookRail **ResourcePlanner** app, which
    will be used internally, inside UnoBookRail. UnoBookRail employees will be able
    to use this app to manage any resources within UnoBookRail, such as trains and
    stations. In this chapter, we will develop the issue-managing part of the app.
    While a real version of this app would have a lot more features, in this chapter,
    we will only develop the following features:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建UnoBookRail **ResourcePlanner**应用程序，该应用程序将在UnoBookRail内部使用。UnoBookRail的员工将能够使用这个应用程序来管理UnoBookRail内部的任何资源，比如火车和车站。在本章中，我们将开发应用程序的问题管理部分。虽然这个应用程序的真实版本会有更多的功能，但在本章中，我们只会开发以下功能：
- en: Creating a new issue
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新问题
- en: Displaying a list of issues
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示问题列表
- en: Exporting issues in PDF format
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以PDF格式导出问题
- en: Since this application is a typical line of business app, the app will be targeting
    UWP, macOS, and WASM. Let's continue by creating the app.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个应用程序是一个典型的业务线应用程序，该应用程序将针对UWP、macOS和WASM。让我们继续创建这个应用程序。
- en: Creating the app
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: 'Let''s start by creating the solution for the app:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建应用程序的解决方案：
- en: In Visual Studio, create a new project using the **Multi-Platform App (Uno Platform)**
    template.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，使用**多平台应用程序（Uno平台）**模板创建一个新项目。
- en: Name the project **ResourcePlanner**. You can use a different name if you want,
    but in this chapter, we will assume the project is named **ResourcePlanner**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为**ResourcePlanner**。如果您愿意，也可以使用其他名称，但在本章中，我们将假设项目名为**ResourcePlanner**。
- en: Remove all the project heads except those for **UWP**, **macOS**, and **WASM**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除除**UWP**、**macOS**和**WASM**之外的所有项目头。
- en: To avoid having to write more code than we need, download the shared library
    project from [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary)
    and add a reference to it. To do this, right-click on the solution node in the
    `UnoBookRail.Common.csproj` file, and click **Open**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免写更多的代码，我们需要从[https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary)下载共享库项目，并添加引用。为此，在`UnoBookRail.Common.csproj`文件中右键单击解决方案节点，然后单击**打开**。
- en: Now that we've added the project to the solution, we need to add a reference
    to the library in the platform-specific projects. For this, right-click the **UWP**
    project node in **Solution Explorer**, select **Add > Reference... > Projects**,
    check the **UnoBookRail.Common** entry, and click OK. *Repeat this process for
    the macOS and WASM projects*.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将项目添加到解决方案中，我们需要在特定于平台的项目中添加对库的引用。为此，在**解决方案资源管理器**中右键单击**UWP**项目节点，选择**添加
    > 引用... > 项目**，选中**UnoBookRail.Common**条目，然后单击确定。*对macOS和WASM项目重复此过程*。
- en: Lastly, add the following code before the closing linker tag in the `LinkerConfig.xml`
    file, inside the `LinkerConfig.xml` file tells the WebAssembly Linker to include
    the types in the compiled source code, even though the classes are not currently
    being used. If we don't specify these entries, the types that are defined in the
    assembly will not be included as the linker removes the code. This is because
    it doesn't find a direct reference to it. When using other packages or libraries,
    you may also need to specify entries for those libraries. For this chapter, though,
    the preceding entry is enough.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`LinkerConfig.xml`文件的闭合链接标签之前添加以下代码，在`LinkerConfig.xml`文件中告诉WebAssembly链接器包括编译源代码中的类型，即使这些类目前没有被使用。如果我们不指定这些条目，那么程序集中定义的类型将不会被包括，因为链接器会删除代码。这是因为它找不到直接的引用。当使用其他包或库时，您可能还需要为这些库指定条目。不过，在本章中，前面的条目就足够了。
- en: 'For our app, we will use the **Model-View-ViewModel** (**MVVM**) pattern. This
    means that our app will mostly be split into three areas:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将使用**Model-View-ViewModel**（**MVVM**）模式。这意味着我们的应用程序将主要分为三个区域：
- en: '**Model**: The **Model** contains the data of your app and the business logic.
    For example, this would handle loading data from a database or running specific
    business logic.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Model**：**Model**包含应用程序的数据和业务逻辑。例如，这将处理从数据库加载数据或运行特定业务逻辑。'
- en: '**ViewModel**: The **ViewModel** acts as the layer between the View and Model.
    It presents the app''s data in a suitable way for the View, provides ways for
    the View to interact with the Model, and notifies the View of changes to the Model.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ViewModel**：**ViewModel**充当视图和模型之间的层。它以适合视图的方式呈现应用程序的数据，提供视图与模型交互的方式，并通知视图模型的更改。'
- en: '**View**: The **View** represents data to the user and is responsible for what
    is being represented on the screen.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**View**：**View**代表用户的数据，并负责屏幕上的表示内容。'
- en: 'To make development easier, we will use the **Microsoft.Toolkit.MVVM** package,
    which we will add now. This package helps us write our ViewModels and takes care
    of the boilerplate code that is needed to support bindings with XAML:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使开发更容易，我们将使用**Microsoft.Toolkit.MVVM**包，现在我们将添加它。这个包帮助我们编写我们的ViewModel，并处理XAML绑定所需的样板代码：
- en: First, right-click the solution node in the **Solution** view and select **Manage
    NuGet Packages for solution…**.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在**解决方案**视图中右键单击解决方案节点，然后选择**管理解决方案的NuGet包...**。
- en: Now, search for **Microsoft.Toolkit.MVVM** and select the package from the list.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，搜索**Microsoft.Toolkit.MVVM**，并从列表中选择该包。
- en: Select the **macOS**, **UWP**, and **WASM** projects from the project list and
    click **Install**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目列表中选择**macOS**、**UWP**和**WASM**项目，然后单击**安装**。
- en: Since we will use them later, also create three folders called **Models**, **ViewModels**,
    and **Views**. For this, right-click the **ResourcePlanner.Shared** shared project,
    select **Add > New Folder**, and name it **Models**. Repeat this process for **ViewModels**
    and **Views**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们稍后会使用它们，还要创建三个名为**Models**、**ViewModels**和**Views**的文件夹。为此，在**ResourcePlanner.Shared**共享项目中右键单击，选择**添加
    > 新文件夹**，并命名为**Models**。对于**ViewModels**和**Views**，重复此过程。
- en: 'Now that we''ve set up the project, let''s start by adding the first pieces
    of code to our app. As is typical with line of business apps, we will be using
    the **MenuBar** control as the main way of switching views inside our app:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了项目，让我们从向我们的应用程序添加第一部分代码开始。与业务应用程序一样，我们将使用**MenuBar**控件作为切换视图的主要方式：
- en: Start by creating a new class inside the **ViewModels** folder called **NavigationViewModel**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在**ViewModels**文件夹中创建一个名为**NavigationViewModel**的新类。
- en: 'Now, replace the code inside the `NavigationViewModel.cs` file with the following:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，用以下代码替换`NavigationViewModel.cs`文件中的代码：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the class that will handle navigating to different controls. As we implement
    more views later in this chapter, we will update the `Command` objects so that
    they point to the correct views.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理导航到不同控件的类。随着我们在本章后面实现更多视图，我们将更新`Command`对象，使其指向正确的视图。
- en: 'Now, add the following code to the `MainPage` class:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`MainPage`类中添加以下代码：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will add a `NavigationViewModel` object to the `MainPage` class that we
    can bind to in our XAML.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`MainPage`类中添加一个`NavigationViewModel`对象，我们可以在XAML中绑定它。
- en: 'Finally, replace the content of your `MainPage.xaml` file with the following:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，用以下内容替换您的`MainPage.xaml`文件的内容：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code adds `MenuBar`, which users can use to navigate to different views.
    `ContentPresenter`, at the bottom, is used to display the content that was navigated
    to.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码添加了`MenuBar`，用户可以使用它导航到不同的视图。底部的`ContentPresenter`用于显示导航到的内容。
- en: 'Now, if you start the app, you will see something similar to the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果启动应用程序，您将看到类似以下的内容：
- en: '![Figure 3.1 – Running the ResourcePlanner app with MenuBar navigation'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 - 运行带有MenuBar导航的ResourcePlanner应用程序'
- en: '](img/Author_Figure_3.01_B17132.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Author_Figure_3.01_B17132.jpg)'
- en: Figure 3.1 – Running the ResourcePlanner app with MenuBar navigation
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 - 运行带有MenuBar导航的ResourcePlanner应用程序
- en: In the next section, we will add our first view to the app, which will allow
    users to create new issues.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将向应用程序添加第一个视图，允许用户创建新问题。
- en: Entering and validating data
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入和验证数据
- en: A typical requirement for line of business apps is to enter data and also provide
    input validation for said data. Uno Platform provides a variety of different controls
    to allow users to enter data, in addition to dozens of libraries that support
    Uno Platform.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 业务应用程序的典型要求是输入数据并为所述数据提供输入验证。Uno平台提供了各种不同的控件，允许用户输入数据，除了支持Uno平台的数十个库。
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'While at the time of writing, there is no built-in support for input validation,
    input validation is planned to be supported by Uno Platform. This is because neither
    UWP nor WinUI 3 fully support input validation right now. To learn more about
    the upcoming input validation support, take a look at the following issue in the
    WinUI repository: [https://github.com/microsoft/microsoft-ui-xaml/issues/179](https://github.com/microsoft/microsoft-ui-xaml/issues/179).
    The progress that''s being made on this as part of Uno Platform is being tracked
    through this issue: [https://github.com/unoplatform/uno/issues/4839](https://github.com/unoplatform/uno/issues/4839).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，尚无内置的输入验证支持，但Uno平台计划支持输入验证。这是因为目前UWP和WinUI 3都不完全支持输入验证。要了解有关即将到来的输入验证支持的更多信息，请查看WinUI存储库中的以下问题：[https://github.com/microsoft/microsoft-ui-xaml/issues/179](https://github.com/microsoft/microsoft-ui-xaml/issues/179)。Uno平台正在跟踪此问题的进展：[https://github.com/unoplatform/uno/issues/4839](https://github.com/unoplatform/uno/issues/4839)。
- en: 'To make our development process easier, first, let''s add a reference to the
    Windows Community Toolkit controls:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的开发过程更加简单，首先让我们添加对Windows社区工具包控件的引用：
- en: First, right-click the solution node in the **Solution** view and select **Manage
    NuGet Packages for solution…**.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在**解决方案**视图中右键单击解决方案节点，然后选择**管理解决方案的NuGet包…**。
- en: Search for **Microsoft.Toolkit.UI.Controls** and select the package.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索**Microsoft.Toolkit.UI.Controls**并选择该包。
- en: In the project list, select the **UWP** head and click **Install**.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目列表中选择**UWP**头，并单击**安装**。
- en: Repeat *steps 2* and *3* for the **Microsoft.Toolkit.UI.Controls.DataGrid**
    package.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对**Microsoft.Toolkit.UI.Controls.DataGrid**包重复*步骤2*和*3*。
- en: Now, search for **Uno.Microsoft.Toolkit.UI.Controls** and select the package.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，搜索**Uno.Microsoft.Toolkit.UI.Controls**并选择该包。
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While the Windows Community Toolkit only supports UWP, thanks to the effort
    of the Uno Platform team, we can also use the Windows Community Toolkit inside
    our Uno Platform app on all the supported platforms. The Uno Platform team maintains
    Uno Platform-compatible versions of the Windows Community Toolkit packages based
    on the original packages and updates them accordingly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Windows社区工具包仅支持UWP，但由于Uno平台团队的努力，我们也可以在所有支持的平台上在Uno平台应用程序中使用Windows社区工具包。Uno平台团队根据原始包维护了与Uno平台兼容的Windows社区工具包版本，并相应地更新它们。
- en: From the project list, select the **macOS** and **WASM** heads and click **Install**.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目列表中选择**macOS**和**WASM**头，并单击**安装**。
- en: Finally, repeat *steps 5* and *6* with the **Uno.Microsoft.Toolkit.UI.Controls.DataGrid**
    package.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对**Uno.Microsoft.Toolkit.UI.Controls.DataGrid**包重复*步骤5*和*6*。
- en: 'This allows us to use the Windows Community Toolkit controls inside our app.
    Since we also want to use these controls on macOS and WASM, we also installed
    the Uno Platform versions of those two packages. Since we added the **Windows
    Community Toolkit** control packages, we can start creating the Create Issue view:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够在应用程序中使用Windows社区工具包控件。由于我们还希望在macOS和WASM上使用这些控件，因此我们还安装了这两个包的Uno平台版本。由于我们添加了**Windows社区工具包**控件包，我们可以开始创建“创建问题”视图：
- en: 'First of all, create the `IssueRepository.cs` class inside the `Models` folder
    and add the following code to it:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在“Models”文件夹内创建“IssueRepository.cs”类，并将以下代码添加到其中：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the model that will collect issues. In a real-world app, this code would
    communicate with a database or API to persist issues, but for simplicity, we will
    only save them in a list.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是收集问题的模型。在现实世界的应用程序中，此代码将与数据库或API通信以持久化问题，但为简单起见，我们只会将它们保存在列表中。
- en: 'Next, create the `CreateIssueViewModel.cs` class inside the `ViewModels` folder
    and use the following code from GitHub: [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter03/ResourcePlanner.Shared/ViewModels/CreateIssueViewModel.cs](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter03/ResourcePlanner.Shared/ViewModels/CreateIssueViewModel.cs)'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在“ViewModels”文件夹中创建“CreateIssueViewModel.cs”类，并使用来自GitHub的以下代码：[https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter03/ResourcePlanner.Shared/ViewModels/CreateIssueViewModel.cs](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter03/ResourcePlanner.Shared/ViewModels/CreateIssueViewModel.cs)
- en: Now that we've created the necessary Model and ViewModel, we will continue by
    adding the user interface to create a new issue.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了必要的模型和视图模型，接下来我们将继续添加用户界面以创建新问题。
- en: 'For the user interface, we will implement input validation as this is typical
    for data entry forms in a line of business app. For this, we will implement the
    following behavior: if the user clicks on the **Create Issue** button, we will
    validate the data using a function in code behind. If we determine that the data
    is valid, we will create a new issue; otherwise, we will show an error message
    below every field that failed our custom validation using code behind. In addition
    to that, we will validate an input field every time the entered input changes.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户界面，我们将实现输入验证，因为这在业务应用程序的数据输入表单中是典型的。为此，我们将实现以下行为：如果用户单击“创建问题”按钮，我们将使用代码后台中的函数验证数据。如果我们确定数据有效，我们将创建一个新问题；否则，我们将在每个未通过自定义验证的字段下方显示错误消息。除此之外，我们将在输入更改时验证输入字段。
- en: 'Let''s continue by creating the user interface:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建用户界面：
- en: 'Create a new `UserControl` inside the `Views` folder named `CreateIssueView.xaml`
    and replace the XAML with the following:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Views”文件夹内创建一个名为“CreateIssueView.xaml”的新“UserControl”，并用以下内容替换XAML：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a basic UI that allows users to enter a title and description and lets
    the user choose the issue's type. Note that we have a `TextBlock` control below
    the text inputs so that we can show error messages to the user if the provided
    input is not valid. In addition to that, we have also added a `TextChanged` listener
    to `Title` to be able to update the error message when the text changes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的用户界面，允许用户输入标题和描述，并让用户选择问题的类型。请注意，我们在文本输入下方添加了一个`TextBlock`控件，以便在提供的输入无效时向用户显示错误消息。除此之外，我们还为`Title`添加了一个`TextChanged`监听器，以便在文本更改时更新错误消息。
- en: 'Now, replace the content of the `CreateIssueView.xaml.cs` file with the following
    code:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，用以下代码替换`CreateIssueView.xaml.cs`文件的内容：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this code, we now have input validation that's run when the text of an
    input field changes or when the user clicks on the `CreateIssueCommand` on our
    ViewModel.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，我们现在在输入字段的文本更改或用户点击`CreateIssueCommand`时，将运行输入验证。
- en: 'Finally, inside the `NavigationViewModel.cs` file, replace the creation of
    the `Issues_OpenNewIssueViewCommand` object with the following code and add the
    necessary `using` statement. That way, when the command is invoked, `CreateIssueView`
    will be displayed:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`NavigationViewModel.cs`文件中，用以下代码替换`Issues_OpenNewIssueViewCommand`对象的创建，并添加必要的`using`语句。这样，当命令被调用时，`CreateIssueView`将被显示：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, if you start the app and click on the **New Issue** option from the **Issue**
    dropdown, you will see something similar to the following *Figure 3.2*:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您启动应用程序并单击**问题**下拉菜单中的**新问题**选项，您将看到类似以下*图3.2*的内容：
- en: '![Figure 3.2 – Create new issue interface'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 - 创建新问题界面'
- en: '](img/Figure_3.02_B17132.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.02_B17132.jpg)'
- en: Figure 3.2 – Create new issue interface
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 - 创建新问题界面
- en: If you try to click on the **Create new issue** button, you will see a short
    message below the title input field that states "**Title must not be empty"**.
    Upon entering text into the **Title** field, the message will disappear. While
    we have added simple inputs, we will now add more input options using the Windows
    Community Toolkit.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试单击**创建新问题**按钮，您将在标题输入字段下方看到一条简短的消息，指出“标题不能为空”。在**标题**字段中输入文本后，消息将消失。虽然我们已经添加了简单的输入，但现在我们将使用Windows
    Community Toolkit添加更多的输入选项。
- en: Using Windows Community Toolkit controls
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Windows Community Toolkit控件
- en: 'So far, users can only enter a title and description and choose the issue''s
    type. However, we also want to allow users to input specific data based on the
    issue''s. For this, we will use one of the controls the Windows Community Toolkit
    provides: **SwitchPresenter**. The **SwitchPresenter** control allows us to render
    a certain part of the UI based on a property that''s been set, similar to how
    a switch case in C# works.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，用户只能输入标题和描述，并选择问题的类型。但是，我们还希望允许用户根据问题的类型输入特定的数据。为此，我们将使用Windows Community
    Toolkit提供的控件之一：**SwitchPresenter**。**SwitchPresenter**控件允许我们根据已设置的属性呈现UI的特定部分，类似于C#中的switch
    case的工作方式。
- en: 'Of course, **SwitchPresenter** is not the only control that''s available from
    the Windows Community Toolkit; there are many more, such as **GridSplitter**,
    **MarkdownTextBlock**, and **DataGrid**, which we will use in the *Displaying
    data using DataGrid* section. Since we''ve already installed the necessary packages
    earlier in this chapter, we will add the controls to our user interface. Let''s
    get started:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，**SwitchPresenter**不是来自Windows Community Toolkit的唯一控件；还有许多其他控件，例如**GridSplitter**，**MarkdownTextBlock**和**DataGrid**，我们将在*使用DataGrid显示数据*部分中使用。由于我们在本章的早些时候已经安装了必要的软件包，我们将向用户界面添加控件。让我们开始吧：
- en: 'Add the following XAML code below the description `TextBox` control inside
    `CreateIssueView.xaml`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CreateIssueView.xaml`的描述`TextBox`控件下方添加以下XAML代码：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This allows us to display specific input fields, depending on the issue type
    that's selected by the user. This is because `SwitchPresenter` renders a specific
    `Case` based on the `Value` property that's been set. Since we bind it to the
    `IssueType` property of our ViewModel, any time the user changes the issue type,
    it will update accordingly. Note that this binding only works if we specify the
    mode to be `OneWay` since the default binding mode of `x:Bind` is `OneTime` and,
    as such, wouldn't update.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够根据用户选择的问题类型显示特定的输入字段。这是因为`SwitchPresenter`根据已设置的`Value`属性呈现特定的`Case`。由于我们将其绑定到ViewModel的`IssueType`属性，所以每当用户更改问题类型时，它都会相应地更新。请注意，只有在我们将模式指定为`OneWay`时，此绑定才有效，因为`x:Bind`的默认绑定模式是`OneTime`，因此不会更新。
- en: 'Now, add the following code before the return statement of the `EvaluateFields`
    function inside `CreateIssueViewModel.xaml.cs`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`CreateIssueViewModel.xaml.cs`中的`EvaluateFields`函数的返回语句之前添加以下代码：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, our input validation will also take the newly added input fields into account.
    Note that we will only block the creation of an issue if input that does not meet
    the validation process is relevant to the issue. For example, if the issue type
    is `Train`, we will ignore whether the location text is passing validation or
    not and users can create a new issue, regardless of whether the location input
    passes the validation stage.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的输入验证也将考虑到新增的输入字段。请注意，只有当与问题相关的输入不符合验证过程时，我们才会阻止创建问题。例如，如果问题类型是`Train`，我们将忽略位置文本是否通过验证，用户可以创建新问题，无论位置输入是否通过验证阶段。
- en: 'Now, if you start the app and navigate to the **Create new issue** view, you
    will see something similar to the following *Figure 3.3*:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您启动应用程序并导航到**创建新问题**视图，您将看到类似以下*图3.3*的内容：
- en: '![Figure 3.3 – Updated issue creation view. Left: Issue Train type selected;
    right: Issue Station type selected'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 - 更新的问题创建视图。左：选择了问题Train类型；右：选择了问题Station类型'
- en: '](img/Figure_3.03_B17132.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.03_B17132.jpg)'
- en: 'Figure 3.3 – Updated issue creation view. Left: Issue Train type selected;
    right: Issue Station type selected'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 - 更新的问题创建视图。左：选择了问题Train类型；右：选择了问题Station类型
- en: When you change the issue type, you will notice that the form will change and
    show the correct input field, depending on the issue type. While we allow users
    to create a new issue, we currently have no way of displaying them. In the next
    section, we will change this by adding a new view to show the list of issues.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当您更改问题类型时，您会注意到表单会更改，并根据问题类型显示正确的输入字段。虽然我们允许用户创建新问题，但我们目前无法显示它们。在下一节中，我们将通过添加新视图来改变这一点，以显示问题列表。
- en: Displaying data using DataGrid
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DataGrid显示数据
- en: 'Since UnoBookRail employees will use this app to manage existing issues, it
    is important for them to view all the issues to easily get an overview of their
    current status. While there is no built-in UWP and Uno Platform control that makes
    this easy to implement, luckily, the Windows Community Toolkit contains the right
    control for this case: **DataGrid**.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于UnoBookRail员工将使用此应用程序来管理现有问题，对于他们来说，查看所有问题以便轻松了解其当前状态非常重要。虽然没有内置的UWP和Uno Platform控件可以轻松实现这一点，但幸运的是，Windows
    Community Toolkit包含了适合这种情况的正确控件：**DataGrid**。
- en: 'The **DataGrid** control allows us to render data as a table, specify which
    columns to display, and allows users to sort the table based on a column. Before
    we start using the **DataGrid** control, though, we need to create the ViewModel
    and prepare the views:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**DataGrid**控件允许我们将数据呈现为表格，指定要显示的列，并允许用户根据列对表格进行排序。然而，在开始使用**DataGrid**控件之前，我们需要创建ViewModel并准备视图：'
- en: 'First, create a new class named `IssueListViewModel.cs` inside the `ViewModels`
    `Solution` folder and add the following code to it:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`ViewModels` `Solution`文件夹中创建一个名为`IssueListViewModel.cs`的新类，并向其中添加以下代码：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since we only want to show a subset of issues, such as when navigating to the
    train issues list, the list of issues to display will be passed as a constructor
    parameter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只想显示问题的一个子集，例如导航到列车问题列表时，要显示的问题列表将作为构造函数参数传递。
- en: Now, create a new `UserControl` inside the `Views` folder named `IssueListView.xaml`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`Views`文件夹中创建一个名为`IssueListView.xaml`的新`UserControl`。
- en: 'Finally, inside the `NavigationViewModel` class constructor, replace the creation
    of the `Issues_OpenAllIssuesCommand`, `Issues_OpenTrainIssuesCommand`, `Issues_OpenTrainIssuesCommand`,
    and `Issues_OpenTrainIssuesCommand` objects with the following code:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`NavigationViewModel`类的构造函数中，用以下代码替换创建`Issues_OpenAllIssuesCommand`，`Issues_OpenTrainIssuesCommand`，`Issues_OpenTrainIssuesCommand`和`Issues_OpenTrainIssuesCommand`对象：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This allows the user to navigate to the issue list when the user clicks on the
    corresponding elements from the navigation, while also ensuring that we only show
    the issues in the list that are relevant to the navigation option. Note that we
    have chosen to create the commands using inline lambdas. However, you can also
    declare functions and use them to create the `RelayCommand` objects.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用户可以在用户从导航中单击相应元素时导航到问题列表，同时确保我们只显示与导航选项相关的列表中的问题。请注意，我们选择使用内联lambda创建命令。但是，您也可以声明函数并使用它们来创建`RelayCommand`对象。
- en: Now that we've added the necessary ViewModel and updated `NavigationViewModel`
    to allow us to navigate to the issue list view, we can continue writing the UI
    of our issue list view.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了必要的ViewModel并更新了`NavigationViewModel`以允许我们导航到问题列表视图，我们可以继续编写我们的问题列表视图的UI。
- en: Displaying data with the DataGrid control
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用DataGrid控件显示数据
- en: 'Before we implement the issue list view, let''s quickly cover the basic features
    of DataGrid that we will use. There are two ways to get started with DataGrid:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现问题列表视图之前，让我们快速介绍一下我们将使用的DataGrid的基本功能。有两种方法可以开始使用DataGrid：
- en: Let DataGrid auto-generate the columns. This has the disadvantage that the column
    headers will use the property names unless you change them inside `AutoGeneratingColumn`.
    While they are good to get started with the DataGrid control, they are often not
    the best choice. Also, using this method, you can't choose which columns to show;
    instead, it will show all columns.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让DataGrid自动生成列。这样做的缺点是，列标题将使用属性名称，除非您在`AutoGeneratingColumn`内部更改它们。虽然它们对于开始使用DataGrid控件是很好的，但通常不是最佳选择。此外，使用此方法，您无法选择要显示的列；相反，它将显示所有列。
- en: Specify which properties to include by manually specifying the columns you want.
    This option has the advantage that we can control which properties to include
    and also specify the column name. Of course, this also means that we have to ensure
    that our bindings are correct, which is a potential cause of bugs.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过手动指定要包含的属性来指定要包含的属性。这种选项的优点是我们可以控制要包含的属性，并且还可以指定列名。当然，这也意味着我们必须确保我们的绑定是正确的，这是潜在的错误原因。
- en: Specifying the columns of a DataGrid can be done by setting the DataGrid's `Columns`
    property and providing a collection of `DataGridColumn` objects. For certain data
    types, there are already built-in columns you can use, such as `DataGridTextColumn`
    for text-based data. Every column allows you to customize the header being displayed
    by specifying the `Header` property and whether users can sort the column through
    the `CanUserSort` property. For more complex data where there is no built-in `DataGridColumn`
    type, you can also implement your own `DataGridColumn object.` Alternatively,
    you can also use `DataGridTemplateColumn`, which allows you to render cells based
    on a specified template. For this, you can specify a `CellTemplate object`, which
    will be used to render cells, and a `CellEditTemplate object`, which will be used
    to let users edit the current cell's value.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置DataGrid的`Columns`属性并提供`DataGridColumn`对象的集合来指定DataGrid的列。对于某些数据类型，已经有内置的列可以使用，例如`DataGridTextColumn`用于基于文本的数据。每列都允许您通过指定`Header`属性以及用户是否可以通过`CanUserSort`属性对列进行排序来自定义显示的标题。对于没有内置`DataGridColumn`类型的更复杂数据，您还可以实现自己的`DataGridColumn`对象。或者，您还可以使用`DataGridTemplateColumn`，它允许您基于指定的模板呈现单元格。为此，您可以指定一个`CellTemplate`对象，用于呈现单元格，并一个`CellEditTemplate`对象，用于让用户编辑当前单元格的值。
- en: In addition to specifying columns, the DataGrid controls also have more features
    you can customize. For example, the DataGrid allows you to select rows and customize
    the row and cell backgrounds. Now, let's continue by writing our issue list.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指定列之外，DataGrid 控件还有更多您可以自定义的功能。例如，DataGrid 允许您选择行并自定义行和单元格背景。现在，让我们继续编写我们的问题列表。
- en: 'Now that we''ve covered the basics of DataGrid, let''s continue by writing
    our issue list display interface:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了DataGrid的基础知识，让我们继续编写我们的问题列表显示界面：
- en: 'For this, add the following code to the `IssueListView.xaml.cs` file:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，请将以下代码添加到`IssueListView.xaml.cs`文件中：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This allows us to create a binding from the DataGrid to the list issues. Note
    that we will also add a `SelectionChanged` handler function so that we can notify
    `NavigationViewModel` whether an issue has been selected. We're doing this since
    some options only make sense if an issue is selected. One of these options is
    the **Export to PDF** option, which we will implement in the *Exporting issues
    in PDF format* section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们从DataGrid创建到问题列表的绑定。请注意，我们还将添加一个`SelectionChanged`处理程序函数，以便我们可以通知`NavigationViewModel`是否已选择问题。我们这样做是因为某些选项只有在选择问题时才有意义。其中一个选项是**导出为PDF**选项，我们将在*以PDF格式导出问题*部分中实现。
- en: 'Add the following XAML namespace definition to the `IssueListView.xaml` file:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下XAML命名空间定义添加到`IssueListView.xaml`文件中：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, replace `Grid` inside the `IssueListView.xaml` file with the following
    XAML:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，请用以下XAML替换`IssueListView.xaml`文件中的`Grid`：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we added columns for the most important fields of our issue. Note that
    we only allow the title to be changed since the other fields would require more
    logic than what can easily be displayed as part of the DataGrid table layout.
    Since `x:Bind` is not supported in this case, we are using `Binding` to bind the
    properties to the columns.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为问题的最重要字段添加了列。请注意，我们只允许更改标题，因为其他字段需要比DataGrid表格布局更容易显示的更多逻辑。由于在这种情况下不支持`x:Bind`，我们使用`Binding`将属性绑定到列。
- en: 'Now, if you start the app and create an issue, you will see something similar
    to the following *Figure 3.4*:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您启动应用程序并创建一个问题，您将看到类似于以下*图3.4*的内容：
- en: '![Figure 3.4 – DataGrid showing a demo issue'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 - DataGrid显示演示问题'
- en: '](img/Figure_3.04_B17132.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.04_B17132.jpg)'
- en: Figure 3.4 – DataGrid showing a demo issue
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 - DataGrid显示演示问题
- en: 'In this section, we only covered the basics of using the Windows Community
    Toolkit DataGrid control. If you wish to learn more about the DataGrid control,
    the official documentation contains hands-on examples covering the different APIs
    that are available for it. You can find out more here: [https://docs.microsoft.com/en-us/windows/communitytoolkit/controls/datagrid](https://docs.microsoft.com/en-us/windows/communitytoolkit/controls/datagrid).
    Now that we can display the list of existing issues, we will continue by writing
    a PDF export for issues. As part of this, we will also learn how to write a custom
    Uno Platform control that we will only use for the web.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们只涵盖了使用 Windows Community Toolkit DataGrid 控件的基础知识。如果您希望了解更多关于DataGrid控件的信息，官方文档包含了涵盖不同可用API的实际示例。您可以在这里找到更多信息：[https://docs.microsoft.com/en-us/windows/communitytoolkit/controls/datagrid](https://docs.microsoft.com/en-us/windows/communitytoolkit/controls/datagrid)。现在我们可以显示现有问题列表，接下来我们将编写问题的PDF导出。作为其中的一部分，我们还将学习如何编写一个自定义的Uno
    Platform控件，我们将仅在Web上使用。
- en: Exporting issues in PDF format
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以PDF格式导出问题
- en: 'In addition to being able to view data inside a line of business app, often,
    it is desired to be able to be export data, for example, as a PDF, so that you
    can print it or send it via email. For this, we will write an interface that allows
    users to export a given issue to PDF. Since there are no built-in APIs for this,
    we will use the **iText** library for this. Note that if you want to use the library
    in your application, you either need to follow the AGPL license or buy a commercial
    license for the library. However, before we can write the code to generate the
    PDF, we will need to prepare the project:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够在业务应用程序的界面中查看数据之外，通常还希望能够导出数据，例如作为PDF，以便可以打印或通过电子邮件发送。为此，我们将编写一个允许用户将给定问题导出为PDF的接口。由于没有内置的API可用，我们将使用**iText**库。请注意，如果您想在应用程序中使用该库，您需要遵循AGPL许可证或购买该库的商业许可证。但是，在我们编写生成PDF的代码之前，我们需要准备项目：
- en: First, we need to install the **iText** NuGet package. For this, right-click
    the solution and search for **iText**. Select the package. Then, from the project
    list, select the **macOS**, **UWP**, and **WASM** heads and click **Install**.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要安装**iText** NuGet包。为此，请右键单击解决方案并搜索**iText**。选择该包。然后，从项目列表中选择**macOS**、**UWP**和**WASM**头，并单击**安装**。
- en: 'Now, create a class named `ExportIssueViewModel.cs` inside the `ViewModels`
    folder with the following code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在“ViewModels”文件夹中创建一个名为`ExportIssueViewModel.cs`的类，其中包含以下代码：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that we are adding those `using` statements now as we will need them later
    in this section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们现在添加这些`using`语句，因为我们稍后在本节中会用到它们。
- en: Now, create a new `UserControl` named `ExportIssueView.xaml` inside the **Views**
    folder.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**Views**文件夹中创建一个名为`ExportIssueView.xaml`的新`UserControl`。
- en: 'Replace the code inside `ExportIssueView.xaml.cs` with the following:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请用以下内容替换`ExportIssueView.xaml.cs`中的代码：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Replace the code inside `ExportIssueView.xaml` with the code from GitHub:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请用GitHub上的代码替换`ExportIssueView.xaml`中的代码：
- en: '[https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter03/ResourcePlanner.Shared/Views/ExportIssueView.xaml](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter03/ResourcePlanner.Shared/Views/ExportIssueView.xaml)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter03/ResourcePlanner.Shared/Views/ExportIssueView.xaml](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter03/ResourcePlanner.Shared/Views/ExportIssueView.xaml)'
- en: 'Lastly, replace the creation of `Issue_ExportIssueViewCommand` in the `NavigationViewModel.cs`
    file with the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`NavigationViewModel.cs`文件中用以下代码替换`Issue_ExportIssueViewCommand`的创建：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we've added the necessary interface, we will continue by writing the
    code for exporting an issue as a PDF. Since the behavior on the desktop will be
    different compared to that on the web, we will cover the desktop version first.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了必要的接口，接下来我们将编写将问题导出为PDF的代码。由于桌面上的行为与网络上的行为不同，我们将先介绍桌面版本。
- en: Exporting on desktop
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在桌面上导出
- en: 'Since we''ve already written the user interface to allow users to export issues,
    the only thing left is to update `ExportIssueViewModel` to generate the PDF and
    provide users with a way to access it. On the desktop, we will write the PDF file
    to the local filesystem and open it. Since the app is also a UWP app, we will
    write the file to the app''s local folder. Now, let''s update `ExportIssueViewModel`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经编写了用户界面，允许用户导出问题，唯一剩下的就是更新`ExportIssueViewModel`以生成PDF并为用户提供访问方式。在桌面上，我们将PDF文件写入本地文件系统并打开它。由于应用程序也是UWP应用程序，我们将文件写入应用程序的本地文件夹。现在，让我们更新`ExportIssueViewModel`：
- en: 'First, create a new function called `GeneratePDF` inside the `ExportIsseuViewModel`
    class with the following code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`ExportIsseuViewModel`类内创建一个名为`GeneratePDF`的新函数，代码如下：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, add the following code before the assignment inside the `using` block:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`using`块内的赋值之前添加以下代码：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This creates a new `PdfWriter` and `PdfDocument` that will be written to the
    byte array using the `MemoryStream` object.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的`PdfWriter`和`PdfDocument`，它将使用`MemoryStream`对象写入到字节数组中。
- en: 'After adding `PDFWriter`, `PDFDocument`, and `Document`, add the following
    code to write the header of the document:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加`PDFWriter`，`PDFDocument`和`Document`之后，添加以下代码来编写文档的标题：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This creates a new paragraph with the text "**Issue export:"** and the issue's
    title. It also sets the text alignment and font size to make it easier to distinguish
    as the header of the document.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的段落，其中包含文本“**问题导出：**”和问题的标题。它还设置了文本对齐和字体大小，以便更容易区分为文档的标题。
- en: 'Since we also want to export information about the issue, add the following
    code before the call to `document.Close()`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们还想导出有关问题的信息，请在调用`document.Close()`之前添加以下代码：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will add the necessary paragraph to the PDF document based on the issue's
    type. In addition to that, we will add the issue's description to the PDF document.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将根据问题的类型向PDF文档添加必要的段落。除此之外，我们还将问题的描述添加到PDF文档中。
- en: Note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Due to a bug in `NullReferenceException` when adding the first element to the
    document. Unfortunately, at the time of writing this book, there is no known workaround.
    This will only occur when the debugger is attached and will not cause any issues
    when the app is running in production. When running the app with the debugger
    attached, you can click **Continue** via the toolbar to continue debugging the
    app.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在向文档添加第一个元素时出现`NullReferenceException`的错误。不幸的是，在撰写本书时，没有已知的解决方法。这只会在调试器附加时发生，并且不会在应用程序运行时造成任何问题。在调试器附加时运行应用程序，您可以通过工具栏点击**继续**来继续调试应用程序。
- en: "Lastly, replace the creation of `SavePDFClickedCommand` with the \Lfollowing\
    \ code:"
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，用以下代码替换`SavePDFClickedCommand`的创建：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will create a PDF, save it to the `apps` temporary folder, and open it
    with the default PDF handler.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个PDF，将其保存到`apps`临时文件夹，并使用默认的PDF处理程序打开它。
- en: Note
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In this chapter, we are writing the file to a temporary folder and opening
    it using the default PDF viewer. Depending on your application and use case, `FileSavePicker`
    and other file pickers can be a very good fit. You can learn more about `FileSavePicker`
    and the other file pickers that are available here: [https://platform.uno/docs/articles/features/windows-storage-pickers.html](https://platform.uno/docs/articles/features/windows-storage-pickers.html).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将文件写入临时文件夹，并使用默认的PDF查看器打开它。根据您的应用程序和用例，`FileSavePicker`和其他文件选择器可能非常合适。您可以在这里了解更多关于`FileSavePicker`和其他可用文件选择器的信息：[https://platform.uno/docs/articles/features/windows-storage-pickers.html](https://platform.uno/docs/articles/features/windows-storage-pickers.html)。
- en: 'To try the issue export out, start the app and create a new issue. After that,
    select the issue from the issue list and click **Export to PDF** from the **Issues**
    dropdown at the top. Now, if you click on **Create PDF**, the PDF will be created.
    Shortly after that, the PDF will be opened in your default PDF viewer. The PDF
    should look something like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试问题导出，请启动应用程序并创建一个新问题。之后，从问题列表中选择问题，并从顶部的**问题**下拉菜单中单击**导出为PDF**。现在，如果单击**创建PDF**，PDF将被创建。之后不久，PDF将在您的默认PDF查看器中打开。PDF应该看起来像这样：
- en: '![Figure 3.5 – Demo issue export PDF'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 - 演示问题导出PDF'
- en: '](img/Figure_3.05_B17132.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.05_B17132.jpg)'
- en: Figure 3.5 – Demo issue export PDF
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 - 演示问题导出PDF
- en: Since we cannot write a file to the user's local filesystem when the app is
    running on the web using WASM, in the next section, we will update our app to
    provide a download link on WASM instead of the **Create PDF** button by writing
    a custom HTML-element control.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在WASM上运行应用程序时无法将文件写入用户的本地文件系统，因此在接下来的部分中，我们将通过编写自定义HTML元素控件来更新我们的应用程序，以在WASM上提供下载链接，而不是使用**创建PDF**按钮。
- en: Exporting on the web with a download link
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过下载链接在网络上导出
- en: 'While the key feature of Uno Platform is to run code that runs on all platforms,
    it also allows developers to write custom controls that are platform-specific.
    You can use this to take advantage of platform-specific controls. In our case,
    we will use this to create an HTML `a-tag` to provide a download link for the
    WASM version of our app. We will do this using the `Uno.UI.Runtime.WebAssembly.HtmlElement`
    attribute:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Uno Platform的主要功能是运行在所有平台上的代码，它还允许开发人员编写特定于平台的自定义控件。您可以利用这一点来使用特定于平台的控件。在我们的情况下，我们将使用它来创建一个HTML
    `a-tag`，为我们应用程序的WASM版本提供下载链接。我们将使用`Uno.UI.Runtime.WebAssembly.HtmlElement`属性来实现这一点：
- en: 'First, create a new class called `WasmDownloadElement.cs` inside the `Views`
    folder with the following code:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`Views`文件夹中创建一个名为`WasmDownloadElement.cs`的新类，并添加以下代码：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will be our `a` -tag, which we will use to allow users to download the
    issue-export PDF. Since we only want this control on WASM, we have placed it inside
    the `#if __WASM__` preprocessor directive.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们的`a`标签，我们将使用它来允许用户下载问题导出的PDF。由于我们只希望在WASM上使用此控件，因此我们将其放在`#if __WASM__`预处理指令内。
- en: 'To be able to customize the MIME type of the download and the name of the downloaded
    file, add the following code to the `WasmDownloadElement` class:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够自定义下载的MIME类型和下载文件的名称，请将以下代码添加到`WasmDownloadElement`类中：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: While this is a lot of code, we are only creating two `DependencyProperty` fields
    on the `WasmDownloadElement` class, namely `MimeType` and `FileName`, and allowing
    them to set the content that will be downloaded. The rest of the code handles
    setting the correct attributes on the underlying control.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是很多代码，但我们只在`WasmDownloadElement`类上创建了两个`DependencyProperty`字段，即`MimeType`和`FileName`，并允许它们设置将要下载的内容。其余的代码处理在底层控件上设置正确的属性。
- en: 'Lastly, add the following code to the constructor of `ExportIssueView`, after
    the call to `this.InitializeComponent()`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`ExportIssueView`的构造函数中添加以下代码，调用`this.InitializeComponent()`后：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will set the correct MIME type on the download link and set the correct
    content to download. Note that we defined the `WASMDownloadLink` element earlier
    in this chapter, inside the `ExportIssueView.xaml` file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在下载链接上设置正确的MIME类型，并设置正确的内容进行下载。请注意，我们在本章前面在`ExportIssueView.xaml`文件中定义了`WASMDownloadLink`元素。
- en: 'To test this, start the WASM head of your app. Once it has loaded, create an
    issue, then select it from the issue list and click **Export to PDF** via the
    **Issues** option. Instead of the **Create PDF** button, you should now see the
    **Download PDF** option, as shown in *Figure 3.6*:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这一点，请启动应用程序的WASM头。加载完成后，创建一个问题，然后从问题列表中选择它，然后通过**问题**选项点击**导出为PDF**。现在，您应该看到**下载PDF**选项，而不是**创建PDF**按钮，如*图3.6*所示：
- en: '![Figure 3.6 – Exporting a PDF on WASM'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 - 在WASM上导出PDF'
- en: '](img/Figure_3.06_B17132.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.06_B17132.jpg)'
- en: Figure 3.6 – Exporting a PDF on WASM
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 - 在WASM上导出PDF
- en: Once you click the link, the PDF export will be downloaded.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 点击链接后，PDF导出将被下载。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we built a desktop app that works on Windows, macOS, and on
    the web using WASM. We covered how to write a data input form with input validation
    and how to use the Windows Community Toolkit. After that, we learned how to display
    data using the Windows Community Toolkit DataGrid control. Lastly, we covered
    how to export data in PDF format and provided a download link by writing a custom
    HTML control.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个桌面应用程序，可以在Windows、macOS和Web上使用WASM。我们介绍了如何编写带有输入验证的数据输入表单以及如何使用Windows
    Community Toolkit。之后，我们学习了如何使用Windows Community Toolkit DataGrid控件显示数据。最后，我们介绍了如何以PDF格式导出数据，并通过编写自定义HTML控件提供了下载链接。
- en: In the next chapter, we'll build a mobile app instead. While it will also be
    designed to be used by employees of UnoBookRail, the main focus will be running
    the app on a mobile device. Among other things, we'll use this app as an opportunity
    to look at working with unreliable connectivity and using device capabilities
    such as a camera.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个移动应用程序。虽然它也将被设计用于UnoBookRail的员工使用，但主要重点将放在在移动设备上运行应用程序。除其他事项外，我们将利用这个应用程序来研究如何处理不稳定的连接以及使用设备功能，如相机。
