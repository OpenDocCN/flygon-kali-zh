- en: Chapter 5. JavaScript Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。JavaScript模式
- en: 'So far, we have looked at several fundamental building blocks necessary to
    write code in JavaScript. Once you start building larger systems using these fundamental
    constructs, you soon realize that there can be a standard way of doing a few things.
    While developing a large system, you will encounter repetitive problems; a pattern
    intends to provide a standardized solution to such known and identified problems.
    A pattern can be seen as a best practice, useful abstraction, or template to solve
    common problems. Writing maintainable code is difficult. The key to write modular,
    correct, and maintainable code is the ability to understand the repeating themes
    and use common templates to write optimized solutions to these. The most important
    text on design patterns was a book published in 1995 called *Design Patterns:
    Elements Of Reusable Object-Oriented Software* written by *Erich Gamma, Richard
    Helm, Ralph Johnson, and John Vlissides*—a group that became known as the **Gang**
    **of Four** (**GOF** for short). This seminal work gave a formal definition to
    various patterns and explained implementation details of most of the popular patterns
    that we use today. It is important to understand why patterns are important:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看了几个在JavaScript中编写代码所必需的基本构建块。一旦您开始使用这些基本构造来构建更大的系统，您很快就会意识到有一些事情可以有一个标准的方式。在开发大型系统时，您将遇到重复的问题；模式旨在为这些已知和已识别的问题提供标准化的解决方案。模式可以被视为最佳实践，有用的抽象，或者解决常见问题的模板。编写可维护的代码是困难的。编写模块化、正确和可维护的代码的关键是能够理解重复的主题，并使用常见的模板来编写这些问题的优化解决方案。设计模式上最重要的文本是1995年出版的一本书，名为《设计模式：可重用面向对象软件的元素》由Erich
    Gamma、Richard Helm、Ralph Johnson和John Vlissides撰写，他们成为了被称为“四人帮”的群体（简称GOF）。这部开创性的作品为各种模式给出了正式的定义，并解释了我们今天使用的大多数流行模式的实现细节。了解模式的重要性很重要：
- en: 'Patterns offer proven solutions to common problems: Patterns provide templates
    that are optimized to solve a particular problem. These patterns are backed by
    solid engineering experience and tested for validity.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式提供了常见问题的成熟解决方案：模式提供了针对特定问题优化的模板。这些模式是由坚实的工程经验支持并经过验证的。
- en: 'Patterns are designed to be reused: They are generic enough to fit variations
    of a problem.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式设计为可重用：它们足够通用，以适应问题的各种变化。
- en: 'Patterns define vocabulary: Patterns are well-defined structures and hence
    provide a generic vocabulary to the solution. This can be very expressive when
    communicating across a larger group.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式定义词汇：模式是明确定义的结构，因此为解决方案提供了通用词汇。在与更大的群体进行交流时，这可以非常表达。
- en: Design patterns
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: 'In this chapter, we will take a look at some of the design patterns that make
    sense for JavaScript. However, coding patterns are very specific for JavaScript
    and are of great interest to us. While we spend a lot of time and effort trying
    to understand and master design patterns, it is important to understand anti-patterns
    and how to avoid pitfalls. In the usual software development cycle, there are
    several places where bad code is introduced, mainly around the time where the
    code is nearing a release or when the code is handed over to a different team
    for maintenance. If such bad design constructs are documented as anti-patterns,
    they can provide guidance to developers in knowing what pitfalls to avoid and
    how not to subscribe to bad design patterns. Most languages have their set of
    anti-patterns. Based on the kind of problems that they solve, design patterns
    were categorized into a few broad categories by the GOF:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一些对JavaScript有意义的设计模式。然而，编码模式对JavaScript来说非常具体，对我们非常感兴趣。虽然我们花费了大量时间和精力来理解和掌握设计模式，但重要的是要了解反模式以及如何避免陷阱。在通常的软件开发周期中，有几个地方会引入糟糕的代码，主要是在代码接近发布时或将代码移交给不同团队进行维护时。如果将这些糟糕的设计构造记录为反模式，它们可以为开发人员提供指导，了解要避免的陷阱以及如何不订阅糟糕的设计模式。大多数语言都有它们的一套反模式。根据它们解决的问题类型，GOF将设计模式分为几个广泛的类别：
- en: '**Creational design patterns**: These patterns deal with various mechanisms
    of object creation. While most languages provide basic object creation methods,
    these patterns look at optimized or more controlled mechanisms of object creation.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建设计模式：这些模式处理对象创建的各种机制。虽然大多数语言提供基本的对象创建方法，但这些模式着眼于更优化或更受控的对象创建机制。
- en: '**Structural design patterns**: These patterns are all about the composition
    of objects and relationships among them. The idea is to have minimal impact on
    overall object relationships when something in the system changes.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构设计模式：这些模式都关于对象的组成和它们之间的关系。其思想是在系统发生变化时对整体对象关系的影响最小。
- en: '**Behavioral design patterns**: These patterns focus on the interdependency
    and communication between objects.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为设计模式：这些模式关注对象之间的相互依赖和通信。
- en: 'The following table is a useful ready reckoner to identify categories of patterns:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格是一个有用的快速参考，用于识别模式的类别：
- en: 'Creational patterns:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '创建模式:'
- en: Factory method
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法
- en: Abstract factory
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: Builder
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建造者
- en: Prototype
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型
- en: Singleton
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例
- en: 'Structural patterns:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构模式：
- en: Adapter
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器
- en: Bridge
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桥接
- en: Composite
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合
- en: Decorator
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰者
- en: Façade
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观
- en: Flyweight
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻量级
- en: Proxy
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Behavioral patterns
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为模式
- en: Interpreter
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器
- en: Template method
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法
- en: Chain of responsibility
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链
- en: Command
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Iterator
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: Mediator
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中介者
- en: Memento
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备忘录
- en: Observer
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者
- en: State
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态
- en: Strategy
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略
- en: Visitor
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者
- en: Some patterns that we will discuss in this chapter may not be part of this list
    as they are more specific to JavaScript or a variation of these classical patterns.
    Similarly, we will not discuss patterns that do not fit into JavaScript or are
    not in popular use.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论的一些模式可能不是这个列表的一部分，因为它们更具体于JavaScript或这些经典模式的变体。同样，我们不会讨论不适合JavaScript或不常用的模式。
- en: The namespace pattern
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间模式
- en: 'Excessive use of the global scope is almost a taboo in JavaScript. When you
    build larger programs, it is sometimes difficult to control how much the global
    scope is polluted. Namespace can reduce the number of globals created by the program
    and also helps in avoiding naming collisions or excessive name prefixing. The
    idea of using namespaces is creating a global object for your application or library
    and adding all these objects and functions to that object rather than polluting
    the global scope with objects. JavaScript doesn''t have an explicit syntax for
    namespaces, but namespaces can be easily created. Let''s consider the following
    example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中过度使用全局范围几乎是一个禁忌。当您构建更大的程序时，有时很难控制全局范围的污染程度。命名空间可以减少程序创建的全局数量，并有助于避免命名冲突或过度的名称前缀。使用命名空间的想法是为应用程序或库创建一个全局对象，并将所有这些对象和函数添加到该对象，而不是用对象污染全局范围。JavaScript没有显式的命名空间语法，但可以很容易地创建命名空间。让我们考虑以下示例：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We are creating all this in the global scope. This is an anti-pattern, and
    this is never a good idea. We can, however, refactor this code and create a single
    global object and make all the functions and objects part of this global object
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在全局范围内创建所有这些内容。这是一种反模式，这绝不是一个好主意。但是，我们可以重构这段代码，并创建一个单一的全局对象，并将所有函数和对象作为该全局对象的一部分，如下所示：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By convention, the global namespace object name is generally written in all
    caps. This pattern adds namespace to the application and prevents naming collisions
    in your code and between your code and external library that you use. Many projects
    use a distinct name after their company or project to create a unique name for
    their namespace.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，全局命名空间对象的名称通常以全大写字母写入。这种模式为应用程序添加了命名空间，并防止了代码之间以及代码与外部库之间的命名冲突。许多项目在公司或项目之后使用一个独特的名称来创建其命名空间的唯一名称。
- en: Though this seems like an ideal way to restrict your globals and add a namespace
    to your code, it is a bit verbose; you need to prefix every variable and function
    with the namespace. You need to type more and the code becomes unnecessarily verbose.
    Additionally, a single global instance would mean that any part of the code can
    modify the global instance and the rest of the functionality gets the updated
    state—this can cause very nasty side-effects. A curious thing to observe in the
    earlier example is this line—`var CARFACTORY = CARFACTORY || {};`. When you are
    working on a large code base, you can't assume that you are creating this namespace
    (or assigning a property to it) for the first time. It is possible that the namespace
    may pre-exist. To make sure that you create the namespace only if it is not already
    created, it is safe to always rely on the quick defaulting via a short-circuit
    `||` operator.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这似乎是限制全局变量并为代码添加命名空间的理想方式，但它有点冗长；您需要为每个变量和函数加上命名空间前缀。您需要输入更多内容，代码变得不必要地冗长。此外，单个全局实例意味着代码的任何部分都可以修改全局实例，其余功能会得到更新的状态——这可能会导致非常恶劣的副作用。在前面的示例中观察到的一个有趣的事情是这一行——`var
    CARFACTORY = CARFACTORY || {};`。当您在一个庞大的代码库上工作时，您不能假设您是第一次创建这个命名空间（或为其分配属性）。这个命名空间可能已经存在。为了确保只有在尚未创建命名空间时才创建命名空间，始终依赖于通过短路`||`运算符的快速默认值是安全的。
- en: The module pattern
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块模式
- en: As you build large applications, you will soon realize that it becomes increasingly
    difficult to keep the code base organized and modular. The module patterns help
    in keeping the code cleanly separated and organized.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您构建大型应用程序，您很快会意识到保持代码库组织和模块化变得越来越困难。模块模式有助于保持代码清晰分离和组织。
- en: Module separates bigger programs into smaller pieces and gives them a namespace.
    This is very important because once you separate code into modules, these modules
    can be reused in several places. Carefully designing interfaces for the modules
    will make your code very easy to reuse and extend.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 模块将大型程序分割成较小的部分，并为它们提供命名空间。这非常重要，因为一旦将代码分离成模块，这些模块就可以在多个地方重复使用。精心设计模块的接口将使您的代码非常易于重用和扩展。
- en: JavaScript offers flexible functions and objects that make it easy to create
    robust module systems. Function scopes help create namespaces that are internal
    for the module, and objects can be used to store sets of exported values.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript提供了灵活的函数和对象，使得创建健壮的模块系统变得容易。函数作用域有助于创建模块内部的命名空间，对象可用于存储一组导出值。
- en: Before we start exploring the pattern itself, let's quickly brush up on a few
    concepts that we discussed earlier.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始探讨模式本身之前，让我们快速复习一下我们之前讨论过的一些概念。
- en: 'We discussed object literals in detail. Object literals allow you to create
    name-value pairs as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细讨论了对象字面量。对象字面量允许您创建名称-值对，如下所示：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we are creating an object literal and defining key-value pairs
    to create properties and functions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个对象字面量，并定义了键值对来创建属性和函数。
- en: In JavaScript, the module pattern is used very heavily. Modules help in mimicking
    the concept of classes. Modules allow us to include both public/private methods
    and variables of an object, but most importantly, modules restrict these parts
    from the global scope. As the variables and functions are contained in the module
    scope, we automatically prevent naming conflict with other scripts using the same
    names.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，模块模式被广泛使用。模块帮助模仿类的概念。模块允许我们包含对象的公共/私有方法和变量，但最重要的是，模块限制了这些部分对全局范围的影响。由于变量和函数包含在模块范围内，我们自动防止了与使用相同名称的其他脚本的命名冲突。
- en: Another beautiful aspect of the module pattern is that we expose only a public
    API. Everything else related to the internal implementation is held private within
    the module's closure.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 模块模式的另一个美妙之处在于我们只公开了一个公共API。与模块的内部实现相关的其他所有内容都被私有地保存在模块的闭包中。
- en: Unlike other OO languages, JavaScript has no explicit access modifiers and,
    hence, there is no concept of *privacy*. You can't have public or private variables.
    As we discussed earlier, in JavaScript, the function scope can be used to enforce
    this concept. The module pattern uses closures to restrict variable and function
    access only within the module; however, variables and functions are defined in
    the object being returned, which is available to the public.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他面向对象的语言不同，JavaScript没有显式的访问修饰符，因此没有*隐私*的概念。你不能有公共或私有变量。正如我们之前讨论的，在JavaScript中，函数作用域可以用来强制执行这个概念。模块模式使用闭包来限制变量和函数的访问仅在模块内部；然而，变量和函数是在返回的对象中定义的，这对公共是可用的。
- en: 'Let''s consider the earlier example and turn this into a module. We are essentially
    using an IIFE and returning the interface of the module, namely, the `init` and
    `updateStartup` functions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑之前的例子，并将其转换为一个模块。我们基本上使用了IIFE并返回了模块的接口，即 `init` 和 `updateStartup` 函数：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, `basicServerConfig` is created as a module in the global context.
    To make sure that we are not polluting the global context with modules, it is
    important to create namespaces for the modules. Moreover, as modules are inherently
    reused, it is important to make sure that we avoid naming conflicts using namespaces.
    For the `basicServerConfig` module, the following snippet shows you the way to
    create a namespace:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`basicServerConfig` 被创建为全局上下文中的一个模块。为了确保我们不会用模块污染全局上下文，重要的是为模块创建命名空间。此外，由于模块本质上是可重用的，重要的是确保我们避免使用命名空间来避免命名冲突。对于
    `basicServerConfig` 模块，以下片段向您展示了创建命名空间的方法：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using namespace with modules is generally a good idea; however, it is not required
    that a module must have a namespace associated.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名空间与模块通常是一个好主意；然而，并不要求模块必须有一个关联的命名空间。
- en: 'A variation of the module pattern tries to overcome a few problems of the original
    module pattern. This improved variation of the module pattern is also known as
    the **revealing** **module pattern** (**RMP**). RMP was first popularized by *Christian
    Heilmann*. He disliked that it was necessary to use the module name while calling
    a public function from another function or accessing a public variable. Another
    small problem is that you have to use an object literal notation while returning
    the public interface. Consider the following example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 模块模式的一个变体试图克服原始模块模式的一些问题。这种改进的模块模式也被称为**揭示模块模式**（**RMP**）。RMP首先由*Christian Heilmann*推广。他不喜欢在调用另一个函数的公共函数或访问公共变量时必须使用模块名称。另一个小问题是在返回公共接口时必须使用对象字面量表示法。考虑以下例子：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see that we need to call `publicFnTwo()` via `modulePattern` in `publicFn()`.
    Additionally, the public interface is returned in an object literal. The improvement
    on the classic module pattern is what is known as the RMP. The primary idea behind
    this pattern is to define all of the members in the private scope and return an
    anonymous object with pointers to the private functionality that needs to be revealed
    as public.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们需要通过 `publicFn()` 中的 `modulePattern` 调用 `publicFnTwo()`。此外，公共接口以对象字面量的形式返回。对经典模块模式的改进就是所谓的RMP。这种模式的主要思想是在私有作用域中定义所有成员，并返回一个匿名对象，其中包含需要公开为公共的私有功能的指针。
- en: 'Let''s see how we can convert our previous example to an RMP. This example
    is heavily inspired from Christian''s blog:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将我们之前的示例转换为RMP。这个例子受到了Christian博客的启发：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: An important distinction here is that you define functions and variables in
    the private scope and return an anonymous object with pointers to the private
    variables and functions that you want to reveal as public. This is a much cleaner
    variation and should be preferred over the classic module pattern.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个重要区别是，你在私有作用域中定义函数和变量，并返回一个匿名对象，其中包含指向你想要公开的私有变量和函数的指针。这是一个更清晰的变体，应该优先于经典的模块模式。
- en: 'In production code, however, you would want to use more a standardized approach
    to create modules. Currently, there are two main approaches to create modules.
    The first is known as **CommonJS modules**. CommonJS modules are usually more
    suited for server-side JavaScript environments such as **Node.js**. A CommonJS
    module contains a `require()` function that receives the name of the module and
    returns the module''s interface. The format was proposed by the volunteer group
    of CommonJS; their aim was to design, prototype, and standardize JavaScript APIs.
    CommonJS modules consist of two parts. Firstly, list of variables and functions
    the module needs to expose; when you assign a variable or function to the `module.exports`
    variable, it is exposed from the module. Secondly, a `require` function that modules
    can use to import the exports of other modules:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在生产代码中，你可能希望使用更标准化的方法来创建模块。目前，有两种主要方法来创建模块。第一种被称为**CommonJS模块**。CommonJS模块通常更适用于服务器端JavaScript环境，如**Node.js**。CommonJS模块包含一个`require()`函数，该函数接收模块的名称并返回模块的接口。这种格式是由CommonJS的志愿者组提出的；他们的目标是设计、原型和标准化JavaScript
    API。CommonJS模块由两部分组成。首先，模块需要公开的变量和函数的列表；当你将变量或函数分配给`module.exports`变量时，它就会从模块中公开出来。其次，一个`require`函数，模块可以使用它来导入其他模块的导出：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: CommonJS modules are supported by Node.js on the server and **curl.js** in the
    browser.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js在服务器端和浏览器中支持**curl.js**的CommonJS模块。
- en: 'The other flavor of JavaScript modules is called **Asynchronous Module Definition**
    (**AMD**). They are browser-first modules and opt for asynchronous behavior. AMD
    uses a `define` function to define the modules. This function takes an array of
    module names and a function. Once the modules are loaded, the `define` function
    executes the function with their interface as an argument. The AMD proposal is
    aimed at the asynchronous loading of both the module and dependencies. The `define`
    function is used to define named or unnamed modules based on the following signature:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript模块的另一种类型称为**异步模块定义**（**AMD**）。它们是面向浏览器的模块，并选择异步行为。AMD使用`define`函数来定义模块。该函数接受一个模块名称数组和一个函数。一旦模块加载完成，`define`函数就会执行该函数，并将它们的接口作为参数。AMD提案旨在异步加载模块和依赖项。`define`函数用于根据以下签名定义命名或未命名模块：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can add a module without dependencies as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按以下方式添加没有依赖项的模块：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `require` module is used as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`require`模块的使用如下：'
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**RequireJS** ([http://requirejs.org/docs/whyamd.html](http://requirejs.org/docs/whyamd.html))
    is one of the module loaders that implements AMD.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**RequireJS** ([http://requirejs.org/docs/whyamd.html](http://requirejs.org/docs/whyamd.html))是实现AMD的模块加载器之一。'
- en: ES6 modules
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ES6模块
- en: 'Two separate module systems and different module loaders can be a bit intimidating.
    ES6 tries to solve this. ES6 has a proposed module specification that tries to
    keep the good aspects of both the CommonJS and AMD module patterns. The syntax
    of ES6 modules is similar to CommonJS and the ES6 modules support asynchronous
    loading and configurable module loading:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 两种不同的模块系统和不同的模块加载器可能有点令人生畏。ES6试图解决这个问题。ES6提出了一个模块规范，试图保留CommonJS和AMD模块模式的优点。ES6模块的语法类似于CommonJS，ES6模块支持异步加载和可配置的模块加载：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ES6 export lets you export a function or variable in a way similar to CommonJS.
    In the code where you want to use this imported function, you use the `import`
    keyword to specify from where you want the dependency to be imported. Once the
    dependency is imported, it can be used as a member of the program. We will discuss
    in later chapters how you can use ES6 in environments where ES6 is not supported.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ES6导出允许您以类似于CommonJS的方式导出函数或变量。在您想要使用此导入函数的代码中，您可以使用`import`关键字指定要从哪里导入依赖项。一旦导入依赖项，它就可以作为程序的成员使用。我们将在后面的章节中讨论如何在不支持ES6的环境中使用ES6。
- en: The factory pattern
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂模式
- en: 'The factory pattern is another popular object creation pattern. It does not
    require the usage of constructors. This pattern provides an interface to create
    objects. Based on the type passed to the factory, that particular type of object
    is created by the factory. A common implementation of this pattern is usually
    using a class or static method of a class. The purposes of such a class or method
    are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式是另一种流行的对象创建模式。它不需要使用构造函数。该模式提供了一个创建对象的接口。根据传递给工厂的类型，工厂将创建该特定类型的对象。通常使用类或类的静态方法来实现这种模式。这样的类或方法的目的如下：
- en: It abstracts out repetitive operations when creating similar objects
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在创建相似对象时抽象出重复的操作
- en: It allows the consumers of the factory to create objects without knowing the
    internals of the object creation
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许工厂的消费者在不了解对象创建的内部情况下创建对象
- en: 'Let''s take a common example to understand the usage of a factory. Let''s say
    that we have the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个常见的例子来理解工厂的用法。假设我们有以下内容：
- en: A constructor, `CarFactory()`
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构造函数，`CarFactory()`
- en: A static method in `CarFactory` called `make()` that knows how to create objects
    of the `car` type
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CarFactory`中的一个名为`make()`的静态方法，它知道如何创建`car`类型的对象'
- en: Specific `car` types such as `CarFactory.SUV`, `CarFactory.Sedan`, and so on
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定的`car`类型，如`CarFactory.SUV`，`CarFactory.Sedan`等
- en: 'We want to use `CarFactory` as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望按以下方式使用`CarFactory`：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here is how you would implement such a factory. The following implementation
    is fairly standard. We are programmatically calling the constructor function that
    creates an object of the specified type—`CarFactory[const].prototype = new CarFactory();`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何实现这样一个工厂。以下实现是相当标准的。我们以编程方式调用创建指定类型对象的构造函数—`CarFactory[const].prototype
    = new CarFactory();`。
- en: 'We are mapping object types to the constructors. There can be variations in
    how you can go about implementing this pattern:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将对象类型映射到构造函数。您可以在实现此模式的方式上有所不同：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We suggest that you try this example in JS Bin and understand the concept by
    actually writing its code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您在JS Bin中尝试此示例，并通过实际编写代码来理解概念。
- en: The mixin pattern
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合模式
- en: 'Mixins help in significantly reducing functional repetition in our code and
    help in function reuse. We can move this shared functionality to a mixin and reduce
    duplication of shared behavior. You can then focus on building the actual functionality
    and not keep repeating the shared behavior. Let''s consider the following example.
    We want to create a custom logger that can be used by any object instance. The
    logger will become a functionality shared across objects that want to use/extend
    the mixin:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 混合模式有助于显著减少代码中的功能重复，并有助于函数重用。我们可以将这些共享功能移动到混合模式中，减少共享行为的重复。然后您可以专注于构建实际功能，而不是重复共享行为。让我们考虑以下例子。我们想创建一个自定义记录器，可以被任何对象实例使用。记录器将成为希望使用/扩展混合模式的对象之间共享的功能：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, we are using `_.extend` from **Underscore.js**—we discussed
    this function in the previous chapter. This function is used to copy all the properties
    from the source (`Logger`) to the destination (`CustomServer.prototype`). As you
    can observe in this example, we are creating a shared `CustomLogger` object that
    is intended to be used by any object instance needing its functionality. One such
    object is `CustomServer`—in its `init()` method, we call this custom logger's
    `log()` method. This method is available to `CustomServer` because we are extending
    `CustomLogger` via Underscore's `extend()`. We are dynamically adding functionality
    of a mixin to the consumer object. It is important to understand the distinction
    between mixins and inheritance. When you have shared functionality across multiple
    objects and class hierarchies, you can use mixins. If you have shared functionality
    along a single class hierarchy, you can use inheritance. In prototypical inheritance,
    when you inherit from a prototype, any change to the prototype affects everything
    that inherits the prototype. If you do not want this to happen, you can use mixins.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了来自**Underscore.js**的`_.extend`——我们在上一章中讨论过这个函数。这个函数用于将源（`Logger`）的所有属性复制到目标（`CustomServer.prototype`）中。正如您在这个例子中所看到的，我们创建了一个共享的`CustomLogger`对象，旨在被任何需要其功能的对象实例使用。其中一个这样的对象是`CustomServer`——在它的`init()`方法中，我们调用这个自定义记录器的`log()`方法。这个方法对`CustomServer`是可用的，因为我们通过Underscore的`extend()`来扩展`CustomLogger`。我们动态地向消费者对象添加了mixin的功能。重要的是要理解mixin和继承之间的区别。当您在多个对象和类层次结构之间共享功能时，可以使用mixin。如果您在单个类层次结构中共享功能，可以使用继承。在原型继承中，当您从原型继承时，对原型的任何更改都会影响到继承原型的所有内容。如果您不希望发生这种情况，可以使用mixin。
- en: The decorator pattern
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰者模式
- en: 'The primary idea behind the decorator pattern is that you start your design
    with a plain object, which has some basic functionality. As the design evolves,
    you can use existing decorators to enhance your plain object. This is a very popular
    pattern in the OO world and especially in Java. Let''s take an example of `BasicServer`—a
    server with very basic functionality. This basic functionality can be decorated
    to serve specific purposes. We can have two different cases where this server
    can serve both PHP and Node.js and serve them on different ports. These different
    functionality are decorated to the basic server:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者模式的主要思想是，您可以从一个普通对象开始设计，该对象具有一些基本功能。随着设计的发展，您可以使用现有的装饰者来增强您的普通对象。这是面向对象世界中非常流行的模式，特别是在Java中。让我们以`BasicServer`为例——一个具有非常基本功能的服务器。这种基本功能可以被装饰以提供特定的目的。我们可以有两种不同的情况，其中这个服务器可以同时提供PHP和Node.js，并在不同的端口上提供它们。这些不同的功能被装饰到基本服务器上：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The Node.js server will have something as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js服务器将具有以下内容：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are several ways in which the decorator pattern is implemented in JavaScript.
    We will discuss a method where the pattern is implemented by a list and does not
    rely on inheritance or method call chain:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者模式在JavaScript中有几种实现方式。我们将讨论一种通过列表实现模式的方法，不依赖于继承或方法调用链：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`BasicServer.decorate()` and `BasicServer.init()` are the two methods where
    the real stuff happens. We push all decorators being applied to the list of decorators
    for `BasicServer`. In the `init()` method, we execute or apply each decorator''s
    `init()` method from this list of decorators. This is a cleaner approach to decorator
    patterns that does not use inheritance. This method was described by Stoyan Stefanov
    in his book, *JavaScript Patterns, O''Reilly Media*, and has gained prominence
    among JavaScript developers due to its simplicity.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`BasicServer.decorate()`和`BasicServer.init()`是真正发生的两个方法。我们将所有应用于`BasicServer`的装饰者推送到装饰者列表中。在`init()`方法中，我们执行或应用来自这个装饰者列表的每个装饰者的`init()`方法。这是一种不使用继承的装饰者模式的更清晰的方法。这种方法是由Stoyan
    Stefanov在他的书《JavaScript Patterns, O''Reilly Media》中描述的，并因其简单性而在JavaScript开发人员中获得了广泛的认可。'
- en: The observer pattern
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: 'Let''s first see the language-agnostic definition of the observer pattern.
    The GOF book, *Design Patterns: Elements of Reusable Object-Oriented Software*,
    defines the observer pattern as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下观察者模式的与语言无关的定义。GOF书籍《设计模式：可复用面向对象软件的元素》将观察者模式定义如下：
- en: '*One or more observers are interested in the state of a subject and register
    their interest with the subject by attaching themselves. When something changes
    in our subject that the observer may be interested in, a notify message is sent
    which calls the update method in each observer. When the observer is no longer
    interested in the subject''s state, they can simply detach themselves.*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个或多个观察者对主题的状态感兴趣，并通过附加自己来向主题注册他们的兴趣。当主题发生变化时，观察者可能感兴趣，会发送通知消息，调用每个观察者的更新方法。当观察者不再对主题的状态感兴趣时，他们可以简单地分离自己。*'
- en: 'In the observer design pattern, the subject keeps a list of objects depending
    on it (called observers) and notifies them when the state changes. The subject
    uses a broadcast to the observers to inform them of the change. Observers can
    remove themselves from the list once they no longer wish to be notified. Based
    on this understanding, we can define the participants in this pattern:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察者设计模式中，主题保留依赖于它的对象列表（称为观察者），并在状态发生变化时通知它们。主题使用广播向观察者通知变化。观察者可以在不再希望收到通知时从列表中移除自己。基于这一理解，我们可以定义这个模式中的参与者：
- en: '**Subject**: This keeps the list of observers and has methods to add, remove,
    and update observers'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：这保留观察者列表，并具有添加、删除和更新观察者的方法'
- en: '**Observer**: This provides an interface for objects that need to be notified
    when the subject''s state changes'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者**：这为需要在主题状态发生变化时得到通知的对象提供接口'
- en: 'Let''s create a subject that can add, remove, and notify observers:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个可以添加、删除和通知观察者的主题：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a fairly straightforward implementation of a `Subject`. The important
    fact about the `notify()` method is the way in which all the observer objects'
    `update()` methods are called to broadcast the update.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当直接的`Subject`实现。`notify()`方法的重要事实是调用所有观察者对象的`update()`方法来广播更新的方式。
- en: 'Now let''s define a simple object that creates random tweets. This object is
    providing an interface to add and remove observers to the `Subject` via `addObserver()`
    and `removeObserver()` methods. It also calls the `notify()` method of `Subject`
    with the newly fetched tweet. When this happens, all the observers will broadcast
    that the new tweet has been updated with the new tweet being passed as the parameter:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一个简单的对象，用于创建随机推文。该对象提供了一个接口，通过`addObserver()`和`removeObserver()`方法向`Subject`添加和删除观察者。它还使用`Subject`的`notify()`方法调用新获取的推文。当这种情况发生时，所有观察者都将广播新推文已经更新，并将新推文作为参数传递：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s now add two observers:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加两个观察者：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Both these observers will have one `update()` method that will be called by
    the `Subject.notify()` method. Now we can actually add these observers to the
    `Subject` via Tweeter''s interface:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个观察者都将有一个`update()`方法，该方法将由`Subject.notify()`方法调用。现在我们可以通过Tweeter的接口将这些观察者添加到`Subject`中：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will result in the following output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is a basic implementation to illustrate the idea of the observer pattern.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的实现，用来说明观察者模式的思想。
- en: JavaScript Model-View-* patterns
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript模型-视图-*模式
- en: '**Model-View-Controller** (**MVC**), **Model-View-Presenter** (**MVP**), and
    **Model-View-ViewModel** (**MVVM**) have been popular with server applications,
    but in recent years JavaScript applications are also using these patterns to structure
    and manage large projects. Many JavaScript frameworks have emerged that support
    **MV*** patterns. We will discuss a few examples using **Backbone.js**.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）、**模型-视图-表示器**（**MVP**）和**模型-视图-视图模型**（**MVVM**）在服务器应用程序中很受欢迎，但近年来，JavaScript应用程序也在使用这些模式来构建和管理大型项目。许多JavaScript框架已经出现，支持**MV***模式。我们将讨论一些使用**Backbone.js**的例子。'
- en: Model-View-Controller
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型-视图-控制器
- en: MVC is a popular structural pattern where the idea is to divide an application
    into three parts so as to separate the internal representations of information
    from the presentation layer. MVC consists of components. The model is the application
    object, view is the presentation of the underlying model object, and controller
    handles the way in which the user interface behaves, depending on the user interactions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: MVC是一种流行的结构模式，其思想是将应用程序分为三个部分，以便将信息的内部表示与呈现层分离。MVC由组件组成。模型是应用程序对象，视图是底层模型对象的呈现，控制器处理用户界面的行为方式，具体取决于用户的交互。
- en: Models
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: 'Models are constructs that represent data in the applications. They are agnostic
    of the user interface or routing logic. Changes to models are typically notified
    to the view layer by following the observer design pattern. Models may also contain
    code to validate, create, or delete data. The ability to automatically notify
    the views to react when the data is changed makes frameworks such as Backbone.js,
    **Amber.js**, and others very useful in building MV* applications. The following
    example shows you a typical Backbone model:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是表示应用程序中数据的构造。它们不关心用户界面或路由逻辑。通常通过遵循观察者设计模式，将对模型的更改通知到视图层。模型还可能包含用于验证、创建或删除数据的代码。当数据发生更改时，自动通知视图做出反应的能力使得Backbone.js、**Amber.js**和其他框架在构建MV*应用程序时非常有用。以下示例向您展示了一个典型的Backbone模型：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This model structure may vary between different frameworks but they usually
    have certain commonalities in them. In most real-world applications, you would
    want your model to be persisted to an in-memory store or database.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型结构在不同的框架之间可能会有所不同，但它们通常具有某些共同点。在大多数实际应用程序中，您希望将模型持久化到内存存储或数据库中。
- en: Views
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: 'Views are the visual representations of your model. Usually, the state of the
    model is processed, filtered, or massaged before it is presented to the view layer.
    In JavaScript, views are responsible for rendering and manipulating DOM elements.
    Views observe models and get notified when there is a change in the model. When
    the user interacts with the view, certain attributes of the model are changed
    via the view layer (usually via controllers). In JavaScript frameworks such as
    Backbone, the views are created using template engines such as **Handlebar.js**
    ([http://handlebarsjs.com/](http://handlebarsjs.com/)) or **mustache.js** ([https://mustache.github.io/](https://mustache.github.io/)).
    These templates themselves are not views. They observe models and keep the view
    state updated based on these changes. Let''s see an example of a view defined
    in Handlebar:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是模型的视觉表示。通常，在将模型的状态呈现给视图层之前，模型的状态会被处理、过滤或处理。在JavaScript中，视图负责呈现和操作DOM元素。视图观察模型，并在模型发生变化时得到通知。当用户与视图交互时，模型的某些属性通过视图层（通常通过控制器）进行更改。在JavaScript框架（如Backbone）中，使用模板引擎（如**Handlebar.js**
    ([http://handlebarsjs.com/](http://handlebarsjs.com/))或**mustache.js** ([https://mustache.github.io/](https://mustache.github.io/))）创建视图。这些模板本身不是视图。它们观察模型，并根据这些变化保持视图状态更新。让我们看一个在Handlebar中定义的视图的例子：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Views such as the preceding example contain markup tags containing template
    variables. These variables are delimited via a custom syntax. For example, template
    variables are delimited using `{{ }}` in Handlebar.js. Frameworks typically transmit
    data in JSON format. How the view is populated from the model is handled transparently
    by the framework.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，前面的示例中的视图包含包含模板变量的标记。这些变量通过自定义语法进行分隔。例如，在Handlebar.js中，模板变量使用`{{ }}`进行分隔。框架通常以JSON格式传输数据。视图如何从模型中填充数据由框架透明地处理。
- en: Controllers
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: 'Controllers act as a layer between models and views and are responsible for
    updating the model when the user changes the view attributes. Most JavaScript
    frameworks deviate from the classical definition of a controller. For example,
    Backbone does not have a concept called controller; they have something called
    a **router** that is responsible to handle routing logic. You can think of a combination
    of the view and router as a controller because a lot of the logic to synchronize
    models and views is done within the view itself. A typical Backbone router would
    look as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器充当模型和视图之间的层，并负责在用户更改视图属性时更新模型。大多数JavaScript框架偏离了控制器的经典定义。例如，Backbone没有称为控制器的概念；他们有一个称为**路由器**的东西，负责处理路由逻辑。您可以将视图和路由器的组合视为控制器，因为大部分用于同步模型和视图的逻辑都在视图本身中完成。典型的Backbone路由器如下所示：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The Model-View-Presenter pattern
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-Presenter模式
- en: 'Model-View-Presenter is a variation of the original MVC pattern that we discussed
    previously. Both MVC and MVP target the separation of concerns but they are different
    on many fundamental aspects. The presenter in MVP has the necessary logic for
    the view. Any invocation from the view gets delegated to the presenter. The presenter
    also observes the model and updates the views when the model updates. Many authors
    take the view that because the presenter binds the model with views, it also performs
    the role of a traditional controller. There are various implementations of MVP
    and there are no frameworks that offer classical MVP out of the box. In implementations
    of MVP, the following are the primary differences that separate MVP from MVC:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 模型-视图-Presenter是我们之前讨论过的原始MVC模式的一个变体。MVC和MVP都针对关注点的分离，但在许多基本方面有所不同。MVP中的Presenter具有视图所需的逻辑。来自视图的任何调用都会被委托给Presenter。Presenter还观察模型，并在模型更新时更新视图。许多作者认为，因为Presenter将模型与视图绑定，它也执行传统控制器的角色。MVP有各种实现，没有提供经典MVP的框架。在MVP的实现中，以下是将MVP与MVC区分开的主要区别：
- en: The view has no reference to the model
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图没有对模型的引用
- en: The presenter has a reference to the model and is responsible for updating the
    view when the model changes
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Presenter引用模型，并负责在模型更改时更新视图
- en: 'MVP is generally implemented in two flavors:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: MVP通常以两种风格实现：
- en: 'Passive view: The view is as naïve as possible and all the business logic is
    within the presenter. For example, a plain Handlebars template can be seen as
    a passive view.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被动视图：视图尽可能天真，所有业务逻辑都在Presenter中。例如，一个简单的Handlebars模板可以被视为被动视图。
- en: 'Supervising controller: Views mostly contain declarative logic. A presenter
    takes over when the simple declarative logic in the view is insufficient.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监督控制器：视图主要包含声明性逻辑。当视图中简单的声明性逻辑不足时，由一个Presenter接管。
- en: 'The following figure depicts MVP architecture:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了MVP架构：
- en: '![The Model-View-Presenter pattern](img/00009.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![模型-视图-Presenter模式](img/00009.jpeg)'
- en: Model-View-ViewModel
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-视图模型
- en: 'MVVM was originally coined by Microsoft for use with **Windows Presentation
    Foundation** (**WPF**) and **Silverlight**. MVVM is a variation of MVC and MVP
    and further tries to separate the user interface (view) from the business model
    and application behavior. MVVM creates a new model layer in addition to the domain
    model that we discussed in MVC and MVP. This model layer adds properties as an
    interface for the view. Let''s say that we have a checkbox on the UI. The state
    of the checkbox is captured in an `IsChecked` property. In MVP, the view will
    have this property and the presenter will set it. However, in MVVM, the presenter
    will have the `IsChecked` property and the view is responsible for syncing with
    it. Now that the presenter is not really doing the job of a classical presenter,
    it''s renamed as ViewModel:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM最初是由微软为**Windows Presentation Foundation**（**WPF**）和**Silverlight**开发的。MVVM是MVC和MVP的一个变体，并进一步尝试将用户界面（视图）与业务模型和应用行为分离。MVVM在MVC和MVP中讨论的领域模型之外创建了一个新的模型层。这个模型层添加了作为视图接口的属性。假设我们在UI上有一个复选框。复选框的状态在`IsChecked`属性中被捕获。在MVP中，视图将具有此属性，Presenter将设置它。然而，在MVVM中，Presenter将具有`IsChecked`属性，视图负责与其同步。现在，由于Presenter实际上并没有执行经典Presenter的工作，它被重命名为ViewModel：
- en: '![Model-View-ViewModel](img/00010.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![模型-视图-视图模型](img/00010.jpeg)'
- en: Implementation details of these approaches are dependent on the problem that
    we are trying to solve and the framework that we use.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的实现细节取决于我们试图解决的问题和我们使用的框架。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: While building large applications, we see certain problem patterns repeating
    over and over. These patterns have well-defined solutions that can be reused to
    build a robust solution. In this chapter, we discussed some of the important patterns
    and ideas around these patterns. Most modern JavaScript applications use these
    patterns. It is rare to see a large-scale system built without implementing modules,
    decorators, factories, or MV* patterns. These are foundational ideas that we discussed
    in this chapter. We will discuss various testing and debugging techniques in the
    next chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建大型应用程序时，我们经常看到某些问题模式一再重复。这些模式有明确定义的解决方案，可以被重复使用以构建强大的解决方案。在本章中，我们讨论了一些重要的模式和围绕这些模式的想法。大多数现代JavaScript应用程序使用这些模式。很少见到没有实现模块、装饰器、工厂或MV*模式的大规模系统。这些是我们在本章中讨论的基本思想。我们将在下一章讨论各种测试和调试技术。
