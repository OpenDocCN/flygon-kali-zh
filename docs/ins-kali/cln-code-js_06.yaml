- en: Naming Things Is Hard
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名事物很难
- en: Names are everywhere. They are our mind's way of abstracting the complexity
    of the universe. In the world of software, we are always engaged in crafting new
    abstractions to describe our everyday realities. A common quip in the programming
    world is *naming things is hard*. Coming up with a name isn't always hard, but
    coming up with a *good* name usually is.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 名字无处不在。它们是我们大脑抽象宇宙复杂性的方式。在软件世界中，我们总是在努力创造新的抽象来描述我们的日常现实。编程世界中的一个常见警句是*命名事物很难*。想出一个名字并不总是很难，但想出一个*好*名字通常是很难的。
- en: In the previous chapters, we have explored the principles and theory underlying
    abstractions. In this chapter, we'll provide the final key to the puzzle. An abstraction
    cannot be a good abstraction without good naming. In the names we use, we are
    distilling a concept, and that distillation will define how people end up understanding
    the concept. So, naming things isn't just the provision of arbitrary labels; it
    is the provision of understanding. Only via a good name can a user or other programmer
    be able to internalize our abstraction fully and navigate it with a full understanding.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们已经探讨了抽象背后的原则和理论。在本章中，我们将提供这个谜题的最后一把钥匙。一个抽象如果没有好的命名，就不能成为一个好的抽象。在我们使用的名字中，我们在提炼一个概念，而这种提炼将定义人们最终理解这个概念的方式。因此，命名事物不仅仅是提供任意标签；它是提供理解。只有通过一个好的名字，用户或其他程序员才能完全内化我们的抽象，并以全面的理解来使用它。
- en: In this chapter, we will use some examples to explore the key characteristics
    that make a good name. We'll also discuss the challenges of naming things in a
    dynamically typed language such as JavaScript. We should come away from this chapter
    with a clear understanding of what is involved in coming up with clean and descriptive
    names.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一些例子来探讨一个好名字的关键特征。我们还将讨论在JavaScript这样的动态类型语言中命名事物的挑战。通过本章，我们应该清楚地了解如何提出干净和描述性的名字。
- en: 'Specifically, we''ll be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将涵盖以下主题：
- en: What's in a name?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名字中有什么？
- en: Naming anti-patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名反模式
- en: Consistency and hierarchy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致性和层次结构
- en: Techniques and consideration*s*
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术和考虑*事项*
- en: What's in a name?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 名字中有什么？
- en: Breaking down the key elements of a good name is difficult. It seems to be more
    of an art than a science. The boundary between quite a good name and a very good
    name is fuzzy and liable to subjective opinions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 分解一个好名字的关键元素是困难的。它似乎更像是一门艺术而不是一门科学。一个*相当好*的名字和一个*非常好*的名字之间的界限模糊不清，容易受主观意见的影响。
- en: Consider a function that is responsible for applying multiple CSS styles to
    a button. Imagine a scenario in which this is a standalone function. Which of
    the following names would you consider to be the most suitable?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个负责将多个CSS样式应用于按钮的函数。想象一种情况，这是一个独立的函数。以下哪个名字你认为最合适？
- en: '`styleButton`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`styleButton`'
- en: '`setStyleOfButton`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setStyleOfButton`'
- en: '`setButtonCSS`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setButtonCSS`'
- en: '`stylizeButton`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stylizeButton`'
- en: '`setButtonStyles`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setButtonStyles`'
- en: '`applyButtonCSS`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`applyButtonCSS`'
- en: 'You''ve likely picked your favorite. And there is, among those of you reading
    this book, bound to be disagreements. Many of these disagreements will be founded
    in our own biases. And many of our biases will have been conditioned by factors
    such as what language we speak, what programming languages we''ve been previously
    exposed to, and what types of programs we spend our time creating. There are many
    variances that exist between all of us and yet, somehow, we have to come up with
    a non-fuzzy concept for what a good or clean name is. At the very least, we can
    say that a good name might have the following characteristics:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经选择了你喜欢的。在阅读本书的人中，肯定会有分歧。这些分歧中的许多将根植于我们自己的偏见。我们的许多偏见将受到诸如我们说什么语言、我们之前接触过哪些编程语言以及我们花时间创建哪种类型的程序等因素的影响。我们之间存在许多差异，但是，不知何故，我们必须提出一个关于好名字或干净名字的非模糊概念。至少可以说，一个好的名字可能具有以下特征：
- en: '**Purpose**: What something is for and how it behaves'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目的**：某物的用途和行为方式'
- en: '**Concept**: Its core idea and how to think about it'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**概念**：它的核心思想以及如何思考它'
- en: '**Contract**: Expectations about how it works'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合同**：关于它如何工作的期望'
- en: This doesn't completely cover the complexity of naming, but with these three
    characteristics, we have a starting point. In the remainder of this section, we
    will learn how each of these characteristics is vital to the process of naming
    things.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不能完全涵盖命名的复杂性，但是有了这三个特征，我们有了一个起点。在本节的其余部分，我们将学习这些特征如何对命名事物的过程至关重要。
- en: Purpose
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目的
- en: A good name indicates **purpose**. Purpose is what something does, or what something
    *is*. In the case of a function, its purpose is its behavior. This is why functions
    are typically named in the verbal form, such as `getUser` or `createAccount`,
    whereas things that store values are usually nouns, such as *account* or *button*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的名字表明了**目的**。目的是某物做什么，或者某物*是*什么。在函数的情况下，它的目的就是它的行为。这就是为什么函数通常以动词形式命名，比如`getUser`或`createAccount`，而存储值的东西通常是名词，比如*account*或*button*。
- en: A name that encapsulates a clear purpose will never need further explanation.
    It should be self-evident. If a name requires a comment to explain its purpose,
    then that is usually an indicator that it has not done its job as a name.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个概括清晰目的的名字永远不需要进一步解释。它应该是不言自明的。如果一个名字需要注释来解释它的目的，那通常意味着它没有完成作为名字的工作。
- en: 'The purpose of something is highly contextual and so will, therefore, be informed
    by the surrounding code and the area of the codebase in which that name resides.
    This is why it''s often okay to use a generic name as long as it is surrounded
    by context that helps to inform its purpose. For example, compare these three
    method signatures within the `TenancyAgreement` class:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 某物的目的是高度上下文化的，因此将受到周围代码和该名字所在代码库区域的影响。这就是为什么通常可以使用通用名字，只要它周围有助于说明其目的的上下文。例如，比较`TenancyAgreement`类中的这三个方法签名：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are subjectivities to this, of course, but most people would agree that,
    when we have a surrounding context that communicates its purpose well, we shouldn''t
    need to granularize the naming of every variable within that context. With this
    in mind, we can say that `Option #1` in the preceding code is too limited and
    may invite ambiguity and that `Option #3` is needlessly verbose as parts of its
    argument names are already provided by its context. `Option #2`, however, with `documentId` and `documentTimestamp`,
    is just right: it sufficiently communicates the purpose of the arguments. And
    this is all we need.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '当然，这是有主观性的，但大多数人会同意，当我们有一个能够很好地传达其目的的周围上下文时，我们不需要详细命名该上下文中的每个变量。考虑到这一点，我们可以说前面代码中的`Option
    #1`过于局限，可能会引起歧义，而`Option #3`过于冗长，因为其参数名称的一部分已经由其上下文提供。然而，`Option #2`，使用`documentId`和`documentTimestamp`，是恰到好处的：它充分传达了参数的目的。这就是我们需要的。'
- en: Purpose is absolutely central to any name. Without a description or an indication
    of purpose, a name is merely decoration, and can often mean that users of our
    code are left rummaging around between documentation and other pieces of code
    just to figure something out. Therefore, we must remember to always consider whether
    our names communicate purpose well.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 目的对于任何名称来说绝对是至关重要的。没有描述或目的的指示，名称只是装饰而已，通常意味着我们的代码使用者只能在文档和其他代码片段之间翻找，才能弄清楚某些事情。因此，我们必须记住始终考虑我们的名称是否能很好地传达目的。
- en: Concept
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概念
- en: 'A good name indicates **concept**. A name''s concept refers to the idea behind
    it, the intent in its creation, and how we should think about it. For example,
    a function named `relocateDeviceAccurately` not only tells us what it will do
    (its purpose) but informs us about the concept surrounding its behavior. From
    this name, we can see that devices are things that can be located and that locating
    such devices can be done at different levels of accuracy. A relatively simple
    name can arouse a rich concept within the minds of those who read it. This is
    part of the vital power of naming things: names are avenues to understanding.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的名称表明**概念**。名称的概念指的是其背后的想法，其创建的意图，以及我们应该如何思考它。例如，一个名为`relocateDeviceAccurately`的函数不仅告诉我们它将做什么（它的目的），还告诉我们关于其行为周围概念的概念。从这个名称中，我们可以看到设备是可以被定位的东西，并且可以以不同的精度定位这些设备。一个相对简单的名称可以在阅读它的人的头脑中唤起丰富的概念。这是命名事物的重要力量的一部分：名称是理解的途径。
- en: 'A name''s concept, like its purpose, is strongly tied to the context in which
    it exists. Context is the *shared space* that our names exist within. The other
    names that surround the name we''re interested in are absolutely instrumental
    in helping us understand its concept. Imagine the following names together:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名称的概念，就像它的目的一样，与它存在的上下文紧密相关。上下文是我们的名称存在的*共享空间*。围绕我们感兴趣的名称的其他名称绝对有助于帮助我们理解它的概念。想象一下以下名称一起出现：
- en: '`rejectedDeal`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rejectedDeal`'
- en: '`acceptedDeal`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`acceptedDeal`'
- en: '`pendingDeal`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pendingDeal`'
- en: '`stalledDeal`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stalledDeal`'
- en: By these names, we immediately understand that a *deal* is something that can
    have at least four different states. It is implied that these states are mutually
    exclusive and cannot apply to a deal at the same time, although that is unclear
    at this time. We are likely to assume that there are specific conditions related
    to whether a deal is pending or stalled, although we're not sure what those conditions
    are. So, even though there is ambiguity here, we are already starting to build
    up a rich understanding of the problem domain. That's just by looking at names—without
    even reading the implementation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些名称，我们立即理解到*deal*是一种至少可以有四种不同状态的东西。这暗示着这些状态是相互排斥的，不能同时适用于一项交易，尽管目前还不清楚。我们可能会假设是否有特定条件与交易是否待定或停滞有关，尽管我们不确定这些条件是什么。因此，即使存在歧义，我们已经开始建立对问题领域的丰富理解。这仅仅是通过查看名称，甚至没有阅读实现。
- en: 'We have spoken about context as a kind of *shared space* for names. In programming
    vernacular, we usually say that things named together in one area occupy a single
    namespace. A namespace can be thought of as a place where things share a conceptual
    area with each other. Some languages have formalized the concept of a namespace
    into its own language construct (often called a **package**, or simply a namespace).
    Even without such formal language constructs, JavaScript still makes it possible
    to construct namespaces via hierarchical constructs such as objects like so:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经谈到上下文作为名称的一种*共享空间*。在编程术语中，我们通常说在一个区域中命名的事物占据一个单一的命名空间。命名空间可以被认为是一个地方，其中事物彼此共享一个概念区域。一些语言已经将命名空间的概念正式化为自己的语言构造（通常称为**包**，或者简单地称为命名空间）。即使没有这样的正式语言构造，JavaScript仍然可以通过对象等分层构造来构建命名空间，如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Most programmers tend to think of namespaces as a very formal construct, but
    this isn''t often the case. Often, without knowing it, we are composing implied
    namespaces when we write functions with functions within them. Instead of being
    delineated by a level of an object hierarchy, the namespaces, in this case, are
    delineated by the scopes of our functions, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序员倾向于将命名空间视为一个非常正式的构造，但这并不经常是这种情况。通常，我们在编写函数时会在其中使用函数来组成暗示的命名空间，而不自知。在这种情况下，命名空间不是由对象层次结构的级别界定的，而是由我们函数的作用域界定的，如下所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are making a request to an endpoint, via `fetch`, and before we return,
    we are gathering the required data via tapping into the promise returned by `fetch`.
    To do this, we use two `then(...)` handlers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过`fetch`向一个端点发出请求，在返回之前，我们通过利用`fetch`返回的promise来收集所需的数据。为了做到这一点，我们使用了两个`then(...)`处理程序。
- en: A **promise** is a natively provided class that provides a useful abstraction
    for handling asynchronous actions. You can usually identify a promise by its then method,
    like what we used in the preceding code. It's common practice to either use promises
    or callbacks when tapping into asynchronous actions. You can read more about this
    in [Chapter 10](b41df1c6-fc76-4d51-b95c-ae39ab040ab1.xhtml), *Control Flow*, in
    the *Asynchronous control flow* section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**Promise**是一个原生提供的类，为处理异步操作提供了有用的抽象。通常可以通过其then方法来识别promise，就像我们在前面的代码中使用的那样。在利用异步操作时，通常会使用promise或回调。您可以在*异步控制流*部分的[第10章](b41df1c6-fc76-4d51-b95c-ae39ab040ab1.xhtml)中了解更多信息。'
- en: Our first `then(...)` handler names its argument *response*, while the second
    one names its argument `data`. Outside the context of `makeFilteredRequest`, these
    terms would be very ambiguous. However, because we are within the implied namespace of
    a function related to making a filtered request, the terms *response* and *data*
    are sufficient to communicate their concepts.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个`then(...)`处理程序将其参数命名为*response*，而第二个处理程序将其参数命名为`data`。在`makeFilteredRequest`的上下文之外，这些术语将非常模糊。然而，因为我们在与制作过滤请求相关的函数的暗示命名空间内，术语*response*和*data*足以传达它们的概念。
- en: 'The concepts communicated by our names, much like their purposes, are heavily
    intertwined with the contexts in which they are specified, so it''s important
    to consider not only the name itself but everything that surrounds it: the complex
    mesh of logic and behavior in which it resides. All code deals with some level
    of complexity, and a conceptual understanding of that complexity is crucial in
    being able to harness it. So, when naming something, it helps to ask yourself:
    *How do I want them to understand this complexity? *This is relevant if you''re
    crafting a simple interface to be consumed by other programmers, writing a deeply
    embedded hardware driver, or creating a GUI for non-programmers to consume.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的名称传达的概念，就像它们的目的一样，与它们指定的上下文密切相关，因此重要的是不仅要考虑名称本身，还要考虑其周围的一切：它所在的复杂逻辑和行为的错综复杂。所有代码都涉及一定程度的复杂性，对这种复杂性的概念理解对于能够掌握它至关重要。因此，在命名某物时，有助于问自己：*我希望他们如何理解这种复杂性？*如果您正在为其他程序员创建一个简单的接口，编写一个深度嵌入的硬件驱动程序，或者为非程序员创建一个GUI，这是相关的。
- en: Contract
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合同
- en: 'A good name indicates a **contract** with other parts of the surrounding abstraction.
    A variable, by its name, may indicate how it will be used or what type of value
    it contains and what general expectations we should have about its behavior. It''s
    not usually thought about, but when we name something, we are, in fact, setting
    up a series of implicit expectations or *contracts* that will define how people
    understand and use that thing. Here are some examples of the hidden contracts
    that exist in JavaScript:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的名称表示与周围抽象的其他部分的**合同**。通过其名称，变量可能指示它将如何使用或包含什么类型的值以及我们对其行为应有的一般期望。通常不会考虑，但是当我们命名某物时，实际上正在建立一系列隐含的期望或*合同*，这些期望或合同将定义人们如何理解和使用该物。以下是JavaScript中存在的隐含合同的一些示例：
- en: A variable prefixed with *is*, for example, `isUser`, is expected to be a Boolean
    type (either `true` or `false`).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以*is*开头的变量，例如`isUser`，预期是布尔类型（`true`或`false`）。
- en: A variable in all-caps is expected to be a constant (only set once and immutable),
    for example, `DEFAULT_USER_EXPIRY`.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全大写的变量预期是一个常量（只设置一次且不可变），例如`DEFAULT_USER_EXPIRY`。
- en: Variables named plurally (for example, elements) are expected to contain one
    or more items in a set-like object (for example, an array), whereas singularly
    named variables (for example, element) are only expected to contain one item (not
    in a set).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以复数命名的变量（例如elements）预期包含一个或多个项目的集合对象（例如数组），而以单数命名的变量（例如element）只预期包含一个项目（不在集合中）。
- en: Functions with names beginning with `get`, `find`, or `select` are usually expected
    to return something to you. Functions beginning with `process`, `build`, or `run` are
    more ambiguous and may not do so.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`get`、`find`或`select`开头的函数通常预期会向您返回一些东西。以`process`、`build`或`run`开头的函数更加模糊，可能不会这样做。
- en: Property or method names beginning with an underscore, such as `_processConfig`,
    are usually intended to be internal to an implementation or pseudo-private. They
    are not intended to be called publicly.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性或方法名称以下划线开头，例如`_processConfig`，通常意味着是内部实现或伪私有的。它们不打算公开调用。
- en: Whether we like it or not, all names carry with them the baggage of unavoidable
    expectations regarding their values and behaviors. It's important to be aware
    of these conventions so that we do not accidentally break the contracts that other
    programmers rely on. Every convention will have an exception where it doesn't
    apply, of course, but nonetheless, we should try to abide by them where possible.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不管我们喜欢与否，所有名称都携带着关于其值和行为的不可避免的期望。重要的是要意识到这些约定，以免意外违反其他程序员依赖的合同。当然，每个约定都会有例外，但尽管如此，我们应该尽量遵守它们。
- en: Unfortunately, there isn't a canonical list where all of these contracts have
    been defined. They are usually quite subjective and will depend on the code base.
    Nonetheless, where we do encounter such conventions, we should follow them. As
    we mentioned in [Chapter 2](fd19fa13-f04a-4e03-9bc3-ba318cacf731.xhtml), *The
    Tenets of Clean Code*, ensuring familiarity is a great way to increase the maintainability
    of our code. And there is no better way to ensure familiarity than to adopt conventions
    that other programmers have come to adopt.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并没有一个可以定义所有这些合同的规范列表。它们通常相当主观，并且将取决于代码库。尽管如此，在我们遇到这种约定的地方，我们应该遵循它们。正如我们在[第2章](fd19fa13-f04a-4e03-9bc3-ba318cacf731.xhtml)中提到的，*《清洁代码的原则》*，确保熟悉性是增加代码可维护性的好方法。而确保熟悉性的最佳方法莫过于采用其他程序员已经采用的约定。
- en: 'Many of these implied contracts are related to types, and JavaScript, as you
    may be aware, is dynamically typed. This means the types of values will be determined
    at runtime, and the type contained by any variable may be liable to change:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些暗示的合同与类型有关，而JavaScript，正如你可能知道的，是动态类型的。这意味着值的类型将在运行时确定，并且任何变量包含的类型可能会有所改变：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The fact that a variable can refer to many different types means that the contracts
    and conventions implied by the names we adopt are even more important. There is
    no static type checker to help us. We are left alone at the chaotic whim of ourselves
    and other programmers.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以引用许多不同的类型这一事实意味着我们采用的名称所暗示的合同和约定更加重要。没有静态类型检查器来帮助我们。我们只能在自己和其他程序员的混乱心情中独自面对。
- en: Later in this chapter, we'll discuss **Hungarian notation**, a type of naming
    that is useful in dynamically typed languages. Also, it's useful to know that
    there are various static type checking and type annotating tools available for
    JavaScript if you find dealing with its dynamism painful. These will be covered
    in [Chapter 15](be9ab437-faeb-4a14-8a5f-663ddba470fd.xhtml), *Tools for Cleaner
    Code*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将讨论**匈牙利命名法**，这是一种在动态类型语言中有用的命名方式。另外，值得知道的是，对于JavaScript，有各种静态类型检查和类型注释工具可用，如果你发现处理其动态性很痛苦。这将在[第15章](be9ab437-faeb-4a14-8a5f-663ddba470fd.xhtml)中进行介绍，*更干净代码的工具*。
- en: Contracts are not only important because of JavaScript's dynamically typed nature.
    They are fundamentally useful in giving us confidence in how certain values behave
    and what we can expect from them throughout the runtime of our program. Imagine
    if there was an API with a method called `getCurrentValue()` that didn't always
    return the current value. That would break its implied contract. Seeing names
    through the lens of contracts is quite a mind-warper. Soon, you will begin to
    see contracts everywhere – contracts between variables, between interfaces, and
    at the integration level between entire architectures and systems.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 合同不仅因为JavaScript的动态类型而重要。它们在给予我们对某些值的行为以及在程序运行时可以从中期望什么方面上是基本有用的。想象一下，如果有一个名为`getCurrentValue()`的方法的API并不总是返回当前值。那将违反其暗示的合同。通过合同的视角看名字是一种很有意思的方式。很快，你将开始在各处看到合同
    - 变量之间的合同，接口之间的合同，以及整个架构和系统之间的集成级别的合同。
- en: Now that we've discussed the three characteristics of a good name (purpose,
    concept, contract), we can begin to explore some anti-patterns, that is, ways
    of naming things that we should try to avoid.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了一个好名称的三个特征（目的、概念、合同），我们可以开始探讨一些反模式，也就是我们应该尽量避免的命名方式。
- en: Naming anti-patterns
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名反模式
- en: 'Much like the abstraction-building warnings of DRY and YAGNI, naming has its
    own warnings and anti-patterns. There are many ways to compose a bad name, and
    nearly all of them can be split into three broad naming anti-patterns: **needlessly
    short names**, **needlessly exotic names**, and **needlessly long names****.**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与DRY和YAGNI的抽象构建警告类似，命名也有自己的警告和反模式。有许多组成糟糕名称的方式，几乎所有这些方式都可以分为三种广泛的命名反模式：**不必要的短名称**，**不必要的奇异名称**和**不必要的长名称**。
- en: Names are the initial lenses via which we and others will view the abstractions
    we build. Therefore, it is vital to know how to avoid creating lenses that only
    end up obscuring understanding and complicating things for other programmers.
    Let's begin by exploring needlessly short names and how they can end up drastically
    limiting our ability to understand what something does.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 名称是我们和其他人将查看我们构建的抽象的初始镜头。因此，了解如何避免创建最终只会模糊理解并为其他程序员复杂化事情的镜头是至关重要的。让我们从探讨不必要的短名称开始，以及它们如何最终极大地限制我们理解某些事物的能力。
- en: Needlessly short names
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不必要的短名称
- en: 'Names that are too short are usually employing either program-specific knowledge
    or domain-specific knowledge that may not generalize well to the audience of the
    code. A lone programmer may think it reasonable to write the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 名称太短通常使用程序特定知识或领域特定知识，这些知识可能不适用于代码的受众。一个孤独的程序员可能认为写下以下代码是合理的：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We are able to discern the fact that it is related to IDs and its purpose is
    to conditionally increment a specific object''s `n` property within the `ids` array.
    Therefore, it is possible to discern what it is doing on a functional level, but
    its meaning and intent are difficult to grasp. The programmer has used single-letter
    names (`f`, `x`, `n`) and has also employed an abbreviated function name (`incId`).
    Most of these names fail to fulfill the basic characteristics that we desire from
    a name: to indicate purpose, concept, and contract. We can only guess at these
    names'' purposes and concepts by how they are being used. It would vastly help
    to refactor this with more meaningful names:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够辨别出它与ID相关，并且其目的是有条件地增加`ids`数组中特定对象的`n`属性。因此，在功能层面上，我们可以辨别出它在做什么，但其含义和意图很难理解。程序员使用了单个字母的名称（`f`，`x`，`n`），并且还使用了缩写的函数名称（`incId`）。这些名称大多未能满足我们从名称中期望的基本特征：指示目的、概念和合同。我们只能通过它们的使用方式来猜测这些名称的目的和概念。用更有意义的名称重构将大大有助于这一点。
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We now have a far clearer idea of what's going on. The arrays being iterated
    over contains jobs. The function's purpose is to find jobs with a specified ID
    and conditional on that job satisfying a specified filter. It increments the job's `nInstances`
    property by `1`. Via these new names, we already have a far richer conceptual
    understanding of this abstraction. We now understand that jobs are items that
    can have any number of instances and that the number of current instances is tracked
    via the `nInstances` property. Via the lenses provided by the names, we have been
    able to understand the underlying problem domain more clearly. Now, we can see
    that names are not just decoration or needless verboseness; names are the very
    essence of your abstractions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对情况有了更清晰的了解。被迭代的数组包含作业。函数的目的是找到具有指定ID的作业，并且在该作业满足指定过滤器的条件下递增作业的`nInstances`属性。通过这些新名称，我们已经对这个抽象有了更丰富的概念理解。我们现在明白作业是可以有任意数量实例的项目，并且当前实例的数量通过`nInstances`属性进行跟踪。通过名称提供的视角，我们能够更清晰地理解底层问题领域。现在，我们可以看到名称不仅仅是装饰或不必要的冗长；名称是你抽象的本质。
- en: 'A needlessly short name is, in many ways, just an insufficiently meaningful
    name. However, a name being short does not necessarily indicate a problem. The
    iterator variable, `i`, which we used in the preceding code, is perfectly fine
    as it is a convention that has established itself over decades. Programmers all
    over the world understand the conceptual and contractual implications of it: it
    is used only to iterate through an array and to access array elements at each
    stage of the iteration.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不必要的短名称在很多方面只是一个意义不足的名称。然而，名称的短并不一定表示问题。我们在前面的代码中使用的迭代变量`i`是完全可以的，因为这是一个几十年来已经确立的惯例。世界各地的程序员都理解它的概念和约定义：它只用于遍历数组，并在每个迭代阶段访问数组元素。
- en: On the whole, and outside of rare exceptions such as our iteration variable,
    it is incredibly important to avoid the deficit in meaning that is invited by
    short names. They are often composed initially with haste or laziness and may
    even give the programmer attuned to their meaning a sense of accomplishment. After
    all, being able to wield obscure logic is a gift for the ego. But as we've covered,
    the ego is not a friend to clean code. Whenever you feel the urge to use a short
    name, push back on the impulse and take the time to pick a name that is richer
    in meaning.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，除了我们的迭代变量等极少数例外情况外，避免使用短名称带来的意义不足非常重要。它们通常是匆忙或懒惰地组成的，甚至可能会让程序员感到有所成就。毕竟，能够运用晦涩的逻辑是一种自我陶醉的礼物。但正如我们所讨论的，自我陶醉并不是清晰代码的朋友。每当你感到想要使用短名称的冲动时，抵制这种冲动，花时间选择一个更有意义的名称。
- en: Needlessly exotic names
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不必要的异国情调的名称
- en: 'Another avenue for the ego is in the proliferation of exotic names. Exotic
    names are those that draw unnecessary attention to themselves and are often obscure
    or elusive in meaning, like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 自我陶醉的另一个方面是异国情调的名称的泛滥。异国情调的名称是那些不必要地吸引注意力的名称，通常在意义上是模糊或难以理解的，比如：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is an ostensibly simple piece of behavior obscured by needlessly exotic
    names. We can, with minimal effort, make a world of difference to the comprehensibility
    of these abstractions with only a couple of tweaks:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个表面上简单的行为，却因不必要的异国情调的名称而变得模糊。我们只需稍加努力，就可以大大提高这些抽象的可理解性：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Names, on the whole, should be boring. They should not draw attention to themselves.
    They should sit there with only their plain meaning on display and nothing that
    makes fellow programmers go, *oh that''s what it means!* or *hehe clever!* Our
    egos may have their own ideas about naming, but we should remember to limit the
    ego and think purely of the people who must endure the task of trying to understand
    our code and the interfaces we''ve created. On the whole, the following advice
    will keep us on the right track:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，名称应该是无聊的。它们不应该吸引注意力。它们应该只展示它们的简单含义，而不会让其他程序员感到*哦，原来是这个意思！*或*哈哈，好聪明！*我们的自我可能对命名有自己的想法，但我们应该记住限制自我，纯粹考虑那些必须忍受尝试理解我们的代码和我们创建的接口的人。总的来说，以下建议将使我们走上正确的道路：
- en: '**Avoid fancy or longer synonyms of regular words**: For example, using `kill`
    or `obliterate`instead of `delete`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免使用普通词的花哨或更长的同义词**：例如，使用`kill`或`obliterate`而不是`delete`'
- en: '**Avoid words that don''t exist**: For example, `deletify`, `elementize`, or `dedupify`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免不存在的词**：例如，`deletify`，`elementize`或`dedupify`'
- en: '**Avoid puns or clever insinuations**: For example, using chemical element
    names to refer to DOM elements'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免双关语或巧妙的暗示**：例如，使用化学元素名称来指代DOM元素'
- en: Being overly exotic risks alienating our audience. You may be able to easily
    understand the names you've adopted, but that does not mean they are easily understood
    by others. The wider programming community is incredibly diverse and has many
    different cultural and linguistic backgrounds. It's best to stick to names that
    are descriptive and boring so that your code is understandable to as many people
    as possible.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 过度异国情调会冒险疏远我们的受众。你可能很容易理解你采用的名称，但这并不意味着其他人也能轻松理解。程序员社区非常多样化，有许多不同的文化和语言背景。最好坚持使用描述性和无聊的名称，以便你的代码能够被尽可能多的人理解。
- en: Needlessly long names
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不必要的冗长的名称
- en: 'As we''ve already discovered, the needlessly short name is, in fact, a name
    without sufficient meaning. The needlessly long name is, therefore, a name with
    too much meaning. You may wonder how a name could have too much meaning. Meaning
    is a good thing, but too much meaning crushed into a single name can only serve
    to confuse; for example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经发现的，不必要的短名称实际上是没有足够意义的名称。因此，不必要的长名称是一个意义过多的名称。你可能会想一个名称怎么会有太多的意义。意义是好事，但是过多的意义压缩到一个名称中只会导致混淆；例如：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This name is hard to understand: is it refreshing and saving documents that
    are signed and documents that are non-pending, or is it refreshing and saving documents
    that are both signed and non-pending? It''s unclear.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名称很难理解：它是在刷新和保存已签署和非挂起的文档，还是在刷新和保存既已签署又非挂起的文档？不清楚。
- en: 'This long name gives us a clue that the underlying abstraction is needlessly
    complex. We can split the name into its constituent parts to get a full grasp
    of its interface:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个长名称给了我们一个线索，表明底层抽象是不必要地复杂。我们可以将名称分解为其组成部分，以充分了解其接口：
- en: '**refresh (verb)**: The refreshing action that occurs on a document'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**refresh (verb)**：文档上发生的刷新动作'
- en: '**save (verb)**: The saving action that occurs on a document'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**save (verb)**：文档上发生的保存动作'
- en: '**signed (adjective)**: The signed state of a document'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**signed (adjective)**：文档的已签署状态'
- en: '**non-pending (adjective)**: The non-pending state of a document'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**non-pending (adjective)**：文档的非挂起状态'
- en: '**document (noun)**: The document itself'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**document (noun)**：文档本身'
- en: 'We have a few different things happening here. With names this long, a good
    guideline is to refactor the underlying abstraction so that we only need a name
    with, at most, one verb, one adjective, and one noun. For example, we could take
    our long name and split its function into four distinct functions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们有一些不同的事情发生。对于这么长的名称，一个很好的指导原则是重构底层抽象，以便我们只需要一个最多包含一个动词，一个形容词和一个名词的名称。例如，我们可以将我们的长名称拆分为四个不同的函数：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Alternatively, if the intent is to perform actions on documents that carry
    multiple states (`SIGNED` and `NON_PENDING`), then we could implement a method
    like this for refreshing (and a similar one for the saving action):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果意图是对携带多种状态（`SIGNED`和`NON_PENDING`）的文档执行操作，那么我们可以为刷新实现这样的方法（保存动作也可以类似）：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The point is that long names are a clue to a broken or confused abstraction.
    Making a name more understandable usually goes hand in hand with making an abstraction
    more understandable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，长名称是一个破碎或混乱抽象的线索。使名称更易理解通常与使抽象更易理解相辅相成。
- en: 'As with short names, the problem is not the length of the name itself: it is
    what the length usually indicates. With long names, what is indicated is crushing
    too much meaning into a single name, indicating a confused abstraction.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与短名称一样，问题不在于名称本身的长度：而是长度通常所指的含义。长名称所指的是将太多的含义压缩到一个名称中，表明了混乱的抽象。
- en: Consistency and hierarchy
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一致性和层次结构
- en: 'So far, we''ve talked about the three most important characteristics of a name:
    *purpose,* *concept,* and *contract*. One of the easiest ways to bestow these
    characteristics upon your names is to use consistency and hierarchy to your benefit.
    Consistency here refers to using the same pattern of naming across many different
    names within a given area of code. Hierarchy, on the other hand, refers to the
    way we structure and put together different areas of code to form a holistic architecture.
    Together, they allow us to give a name a rich context that can be used to make
    strong inferences about its purpose, concept, and contract.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经谈到了名称的三个最重要的特征：*目的*，*概念*和*合同*。赋予名称这些特征的最简单的方法之一是利用一致性和层次结构。这里的一致性是指在代码的给定区域内使用相同的命名模式。另一方面，层次结构是指我们构建和组合不同代码区域以形成整体架构的方式。它们共同使我们能够为名称提供丰富的上下文，可以用来对其目的，概念和合同进行强有力的推断。
- en: 'This is best explained by looking at the JavaScript directory of a fictional
    app. We have a directory full of files, like so:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这最好通过查看虚构应用程序的JavaScript目录来解释。我们有一个满是文件的目录，如下所示：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There is no hierarchy, so we can only discern context from the names themselves
    and what they appear to relate to. For example, there is a `getURL` and a `setURL`
    file, which both presumably relate to URLs and could be considered *utilities*.
    It would, therefore, be helpful to have these occupy the same part of the hierarchy
    or a shared namespace, such as `app/utils/url`. We can also refactor other parts
    of our directory structure into a more contextually rich hierarchy:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 没有层次结构，因此我们只能从名称本身和它们似乎相关的内容中推断上下文。例如，有一个`getURL`和一个`setURL`文件，它们都可能与URL相关，并且可以被视为*实用程序*。因此，将这些占据相同层次结构的部分或共享命名空间，例如`app/utils/url`，将是有帮助的。我们还可以将目录结构的其他部分重构为更具上下文丰富的层次结构：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Immediately, things are clearer. The cognitive strain of understanding all
    of those files and what they do is now lessened by each file having its own rich
    context. You''ll also notice that we''ve been able to simplify the names at various
    parts of the hierarchy; for example, we have renamed `openModal.js` to `modal/open.js`.
    This is an additional benefit of employing hierarchies of names: at each level
    of naming, we can simplify and shorten the names, lessening comprehension time.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 立即，事情变得更清晰。理解所有这些文件及其功能的认知负担现在因每个文件都有其丰富的上下文而减轻了。您还会注意到，我们已经能够简化层次结构的各个部分的名称；例如，我们已将`openModal.js`重命名为`modal/open.js`。这是使用名称层次结构的额外好处：在每个命名级别，我们可以简化和缩短名称，减少理解时间。
- en: Names within a hierarchy naturally receive a portion of their meaning from the
    context that they reside in. This means that the name itself does not need to
    contain all the meaning. Always look for opportunities to provide a common context
    to similar abstractions so that the burden of comprehension is eased.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构内的名称自然地从其所在的上下文中获得一部分含义。这意味着名称本身不需要包含所有含义。始终寻找机会为类似的抽象提供共同的上下文，以减轻理解的负担。
- en: 'Just like we have provided meaning via the hierarchy of a directory structure,
    we can also provide meaning within the code itself. Within a function, for example,
    the names within will naturally receive a lot of their context from the function''s
    name itself and its situation within a larger module. Consider how it would be
    quite unusual to write code like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们通过目录结构的层次结构提供了含义一样，我们也可以在代码本身中提供含义。例如，在一个函数内部，名称自然会从函数的名称本身和它在更大模块中的情境中获得很多上下文。想象一下，如果写出这样的代码会很不寻常：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The names within the function are needlessly prefixed with contextual information
    (such as `modalDisplayer_...`) that the reader of the code can already get from
    the function itself. Typically, we write code that takes advantage of where a
    variable sits and the meaning that it gets from its context. It would be far more
    normal for the preceding code to appear like so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 函数内部的名称不必要地加上了上下文信息（比如`modalDisplayer_...`），而代码的读者已经可以从函数本身获取这些信息。通常，我们编写的代码会利用变量所处的位置以及从上下文中获得的含义。前面的代码更正常的写法应该是这样的：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In an previous chapter, we discussed the principle of abstraction and how the
    implementation of a module should be independent of its interface. We can see
    that this principle is expressed in this function. The scope of a function (its
    implementation) should be entirely independent (and even ignorant!) of its interface.
    So, arguably, it's not the business of the `modalInstance` variable to know which
    function it resides in and so the former naming technique, which prefixed it with
    `modalDisplayer_...`, would be in violation of the principle of abstraction.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的一章中，我们讨论了抽象原则以及模块的实现应该独立于其接口。我们可以看到这个原则在这个函数中得到了体现。函数的范围（其实现）应该完全独立（甚至无知！）于其接口。因此，可以说，`modalInstance`变量不需要知道它位于哪个函数中，因此前缀为`modalDisplayer_...`的命名技术将违反抽象原则。
- en: 'Thinking about hierarchies in terms of abstraction is key. Hierarchies aren''t
    just useful from an organizational perspective. They should, ideally, be a reflection
    of the layers of abstraction that reside within our code. Higher-level abstractions
    are at the top of the hierarchy, and the deeper we go into the hierarchy, the
    more low-level we will get. This is a good general rule to adopt: **make your
    hierarchy reflect your abstractions**.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到抽象的层次结构是关键。层次结构不仅仅在组织上有用。它们应该理想地反映出我们代码中存在的抽象层次。更高级的抽象位于层次结构的顶部，我们进入层次结构的深处，就会变得更低级。这是一个很好的一般规则：**让你的层次结构反映你的抽象**。
- en: 'Naming things with consistency complements this rule. Within a single layer of
    our abstraction, that is, within a single level of the hierarchy, we should adopt
    common naming patterns so that the reader of our code can easily navigate and
    understand its concepts. For example, if we are creating an interface that will
    be used to add and remove items from a data structure, then we should avoid naming
    similar actions in an inconsistent manner. Consider the following class schematic:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 命名事物时要保持一致性，这符合这个规则。在我们的抽象的一个层次内，也就是在层次结构的一个层级内，我们应该采用常见的命名模式，这样我们代码的读者就可以轻松地浏览和理解其中的概念。例如，如果我们正在创建一个用于向数据结构添加和删除项目的接口，那么我们应该避免以不一致的方式命名类似的操作。考虑以下类的示意图：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Very confusingly, this abstraction is offering up three different variations
    of the concept of *adding* to the data structure: *adding*, *pushing*, and *setting*.
    These names are all, in fact, referring to the same concept, so we should adopt
    a common naming pattern, such as the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 非常令人困惑的是，这个抽象提供了三种不同的*添加*概念的变体：*添加*、*推送*和*设置*。实际上，这些名称都指的是同一个概念，所以我们应该采用一个常见的命名模式，比如以下方式：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This interface is now far easier to understand. There is less ambiguity and
    less cognitive burden in using it. As a user of this abstraction, I would no longer
    need to remember whether I should be using *add*, *set*, or *push*. Consistency
    is a characteristic that results from the avoidance of needless differences. Inconsistencies
    are jarring and so they should only be used to demarcate genuine functional or
    conceptual differences.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口现在更容易理解了。使用起来更加清晰，认知负担更小。作为这个抽象的用户，我不再需要记住我应该使用*add*、*set*还是*push*。一致性是通过避免不必要的差异而产生的特征。不一致会让人感到不适，因此它们只应该用于标示真正的功能或概念差异。
- en: Techniques and considerations
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术和考虑因素
- en: 'JavaScript, due to its ever-changing nature, has gathered a huge variety of
    conflicting conventions. Many of these conventions garner strong opinions either
    in support or in disapproval. We have, however, settled on some basic conventions
    around naming that are more or less globally accepted:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript的不断变化，它积累了大量相互冲突的约定。其中许多约定在支持或反对方面都引起了强烈的意见。然而，我们已经就一些基本的命名约定达成了一致，这些约定或多或少地得到了全球范围内的接受：
- en: Constants should be named with underscore-separated capitals; for example, `DEFAULT_COMPONENT_COLOR`
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量应该用下划线分隔的大写字母命名；例如，`DEFAULT_COMPONENT_COLOR`
- en: Constructors or classes should be camel-cased with an initial uppercase letter;
    for example, `MyComponent`
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数或类应该采用驼峰命名法，首字母大写；例如，`MyComponent`
- en: Everything else should be camel-cased with an initial lower case letter; for
    example, `myComponentInstance`
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他所有内容都应该采用驼峰命名法，首字母小写；例如，`myComponentInstance`
- en: Apart from these foundational conventions, the decision of naming is left largely
    up to the creativity and skill of the programmer. The names you end up employing
    will be largely defined by what problems you're solving. Most code will inherit
    naming conventions from the APIs it interfaces with. Using the DOM API, for example,
    will usually mean that you adopt names such as *element*, *attribute*, and *node.*
    Many of the popular frameworks available will tend to dictate the names we adopt
    as well. It is absolutely useful and necessary to adopt such conventional paradigms
    from the ecosystem that you're working in, but it's also useful to have some foundational
    techniques and concepts under your belt so that you can craft beautifully named
    abstractions, even in new and alien problem domains.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些基本约定之外，命名的决定很大程度上取决于程序员的创造力和技能。你最终使用的名称将在很大程度上由你解决的问题所定义。大多数代码将继承与其接口的API的命名约定。例如，使用DOM
    API通常意味着你采用诸如*element*、*attribute*和*node*之类的名称。许多流行的可用框架也会倾向于规定我们采用的名称。从你所在的生态系统中采用这样的常规范式是非常有用和必要的，但同时拥有一些基本的技术和概念也是很有用的，这样你就可以在新的和陌生的问题领域中构建出命名得体的抽象。
- en: Hungarian notation
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匈牙利命名法
- en: JavaScript is a dynamically typed language, meaning that the type of a value
    will be determined at runtime and that the type contained by any variable may
    be liable to change during runtime. This is in contrast to statically-typed languages,
    which have compile-time warnings related to your usage of types. The implication
    of this is that, as JavaScript programmers, we need to be much more careful in
    the way we employ types and how we name our variables.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种动态类型语言，这意味着值的类型将在运行时确定，并且任何变量包含的类型可能在运行时发生变化。这与静态类型语言相反，后者在编译时会警告你关于类型的使用。这意味着，作为JavaScript程序员，我们需要在使用类型和命名变量的方式上更加小心。
- en: 'As we know, when we name things, we are implying a contract. This contract
    will define how other programmers make use of that thing. This is part of the
    reason why, in various languages, something called Hungarian notation has been
    very popular. It involves including type annotations in a name itself, like so:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，当我们命名事物时，我们是在暗示一个约定。这个约定将定义其他程序员如何使用该事物。这就是为什么在各种语言中，匈牙利命名法非常流行的部分原因。它涉及在名称本身中包含类型注释，就像这样：
- en: Instead of `button`, we may use `elButton` or `buttonElement`
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`elButton`或`buttonElement`，而不是`button`
- en: Instead of `age`, we may use `nAge` or `ageNumber`
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`nAge`或`ageNumber`，而不是`age`
- en: Instead of `details`, we may use `objDetails` or `detailsObject`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`objDetails`或`detailsObject`，而不是`details`
- en: 'Hungarian notation is useful for the following reasons:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 匈牙利命名法有以下几个原因：
- en: '**Certainty**: It provides more certainty of a name''s purpose and contract
    to the readers of your code'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定性：它为您的代码读者提供了更多关于名称目的和约定的确定性
- en: '**Consistency**: It leads to a more consistent naming approach'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：它会导致更一致的命名方式'
- en: '**Enforcement**: It may lead to better-enforced typing conventions within your
    code'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制执行：它可能导致代码内更好地执行类型约定
- en: 'However, it also has the following disadvantages:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它也有以下缺点：
- en: '**Runtime changes**: If the underlying types are changed by bad code at runtime
    (for example, if a function mutates `nAge` into a string), then the name ceases
    to be useful and may only mislead us.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时更改**：如果底层类型在运行时被糟糕的代码更改（例如，如果函数将`nAge`变成字符串），那么该名称将不再有用，甚至可能误导我们。'
- en: '**Codebase rigidity**: It may lead to a rigid code base where it''s hard to
    make appropriate changes to types. Refactoring old code may become more burdensome.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码库的僵化**：它可能导致代码库变得僵化，难以对类型进行适当的更改。重构旧代码可能变得更加繁重。'
- en: '**Lack of meaning**: Knowing only a variable''s type does not inform us as
    to its purpose, concept, or contract as much as a truly descriptive non-typed
    variable name would.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺乏含义**：仅知道变量的类型并不能告诉我们它的目的、概念或约定，就像一个真正描述性的非类型变量名那样。'
- en: 'In the landscape of JavaScript, we see Hungarian notation used in a few places:
    the most common is when naming a variable that may refer to a DOM element. The
    notations for these names will usually be in the form `elHeader`, `headerEl`,
    `headingElement`, or even `$header`. The latter, with a dollar prefix, is most
    famously used in the jQuery library. Its fame there led to it being a standard
    in various other places. **Chromium DevTools**, for example, employs a dollar
    prefix for element references and methods related to querying the DOM (for example, `$$(...)`
    is aliased to `document.querySelectorAll(...)`).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript的领域中，我们看到匈牙利命名法在一些地方被使用：最常见的是在命名可能指向DOM元素的变量时。这些名称的标注通常以`elHeader`、`headerEl`、`headingElement`或者`$header`的形式出现。以美元符号为前缀的后者最著名地用在jQuery库中。它在那里的名声导致它成为各种其他地方的标准。例如，**Chromium
    DevTools**在元素引用和与查询DOM相关的方法中使用了美元前缀（例如，`$$(...)`被别名为`document.querySelectorAll(...)`）。
- en: 'Hungarian notation is something that can be utilized partially, where you''re
    concerned there may be ambiguity. For example, you can use it where you have both
    a complex type and a primitive type referring to the same concept within a single
    scope:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 匈牙利命名法是一种可以部分利用的东西，当你担心可能存在歧义时。例如，你可以在一个作用域内同时引用复杂类型和原始类型来使用它：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we have an `article` variable that refers to an instance of the `Article`class.
    In addition to this, we also want to use a string representation of our article.
    To get around a potential naming conflict, we have used an `str` prefix to indicate
    that the variable refers to a string value. In isolated cases like these, Hungarian
    notation can be useful. You don't need to use it exhaustively, but it's a useful
    tool to have up your sleeve.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个指向`Article`类实例的`article`变量。除此之外，我们还想使用我们文章的字符串表示。为了避免潜在的命名冲突，我们使用了一个`str`前缀来表示该变量是指向一个字符串值。在这样的孤立情况下，匈牙利命名法是有用的。你不需要完全使用它，但它是一个有用的工具。
- en: Naming and abstracting functions
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名和抽象函数
- en: Most abstractions you end up crafting in JavaScript will be manifested within
    functions. Even within grand architectures, it is individual functions and methods
    that do the work, and it is in their conception that a good abstraction begins
    to reveal itself. It is, therefore, worth thinking quite deeply about how we should
    name our functions and what factors we should take into consideration when doing
    so.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，大多数抽象最终都会体现在函数中。即使在大型架构中，也是单个函数和方法在工作，而且在它们的构思中，一个好的抽象开始显现出来。因此，值得深入思考我们应该如何命名我们的函数以及在这样做时应该考虑哪些因素。
- en: A function's name should typically use what, in grammar, is called the **imperative
    form**. The imperative form is what we employ when we are giving instructions,
    such as *walk to the shop*, *buy bread*, *stop there!*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的名称通常应该使用语法中所谓的**命令形式**。当我们给出指示时，就是我们使用的命令形式，比如*走到商店*，*买面包*，*停在那里*。
- en: Although we usually use the *imperative* form when naming functions, there are
    exceptions. For example, it is also conventional to prefix functions that return
    Boolean values with *is* or *has;* for example,`isValid(...)`*.* When creating
    constructors (which are functions), we name them according to the instance they'll
    produce; for example, `Route`or `SpecialComponent`*.*
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们通常在命名函数时使用*命令*形式，但也有例外。例如，惯例上也会在返回布尔值的函数前加上*is*或*has*；例如，`isValid(...)`。在创建构造函数（它们也是函数）时，我们会根据它们将生成的实例来命名；例如，`Route`或`SpecialComponent`。
- en: 'The direct nature of the imperative form is the most understandable and readable
    in the context of programming. To find the correct imperative form for your specific
    problem, it''s best to imagine the act of giving a military order, that is, don''t
    mince your words and say exactly what it is that you want to occur:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程环境中，命令形式的直接性是最容易理解和阅读的。要找到特定问题的正确命令形式，最好想象一下发布军事命令的过程，也就是说，不要拐弯抹角，准确地说明你想要发生的事情：
- en: If you want a prompt to be displayed, use `displayPrompt()`
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想显示提示，使用`displayPrompt()`
- en: If you want elements to be removed, use `removeElements()`
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要移除元素，使用`removeElements()`
- en: If you want a random number between `x` and `y`, use `generateRandomNumber(x,
    y)`
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要一个在`x`和`y`之间的随机数，使用`generateRandomNumber(x, y)`
- en: 'Often, we wish to qualify our instructions. If you were to issue an instruction
    to a person, such as *find my bicycle*, you would likely further qualify that
    instruction with information such as *it''s blue* and *it''s missing its front
    wheel*. It is important, however, not to let a function''s name get bogged down
    with these qualifications. The following function would be an example of this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望对我们的指示进行限定。如果你要给一个人下达指示，比如*找到我的自行车*，你可能会进一步限定这个指示，比如*它是蓝色的*和*它的前轮丢了*。然而，重要的是不要让函数的名称被这些限定所拖累。以下函数就是一个例子：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we mentioned earlier, a needlessly long name is a sign of a bad abstraction.
    When we see this type of over-qualification, we should take a step back and reconsider.
    Here, it's important to draw a line between what is sensible in spoken language
    and what is sensible when programming. In programming, functions are ways of abstracting
    common behavior that can be adjusted or configured, as needed, via arguments.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，一个不必要地长的名称是一个糟糕抽象的标志。当我们看到这种过度限定的情况时，我们应该退一步重新考虑。在这里，重要的是要在口语和编程语言中划清界限。在编程中，函数是抽象常见行为的方式，可以通过参数根据需要进行调整或配置。
- en: 'So, it is via arguments that we should be expressing the qualifications of
    `blue` and `missing` front wheel. And we could, for example, express these as
    a single object argument like so:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该通过参数来表达`蓝色`和`丢失前轮`的限定。例如，我们可以将它们表达为一个单一的对象参数，如下所示：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By moving the qualifying parts of a function's name into its arguments, we are
    producing a cleaner and more comprehensible abstraction. This has the added benefit
    of increasing the configurability of the abstraction, thereby providing the user
    with more possibilities.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将函数名称的限定部分移到其参数中，我们正在产生一个更清晰和更易理解的抽象。这不仅增加了抽象的可配置性，还为用户提供了更多的可能性。
- en: 'In our case, we may wish to give users the ability to find objects other than
    bicycles. To cater to this, we would make the name of the function more generic
    (for example, `findObject`) and shift the qualifier to the arguments by adding
    a new option property (for example, `type`), like so:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们可能希望让用户能够找到除自行车以外的其他对象。为了满足这一点，我们会使函数的名称更加通用（例如，`findObject`），并通过添加一个新的选项属性（例如，`type`）将限定部分移到参数中，如下所示：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Something curious happens at this stage of the process. We have, correctly,
    moved our various qualifiers to the arguments of our function, expanding the usefulness
    and configuration of our abstraction. But now what we have is an abstraction that
    is doing many things, so at some point, it may be prudent to take a step back
    and build higher-level abstractions to encapsulate these different behaviors.
    In our case, we could achieve this via functional composition, like so:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程的阶段，发生了一些奇怪的事情。我们已经正确地将各种限定词移到函数的参数中，扩展了我们抽象的有用性和配置。但现在我们得到的是一个做很多事情的抽象，因此在某个时候，退一步构建更高级别的抽象来封装这些不同的行为可能是明智的。在我们的情况下，我们可以通过函数组合来实现这一点，如下所示：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Above all, a function is a unit of behavior. As the SRP tells us, it's important
    to ensure that they are only doing one discernible thing. When considering these
    things or units of behavior, it's important to think about what a function does
    from the perspective of those who'll use it. Technically, it's highly likely that
    our composed `findScooter` function does all manner of things beneath the surface.
    It may be incredibly complex. But at the layer of abstraction where it will be
    used, it can be said to only do one thing, and that is what's important.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，函数是行为的一个单元。正如SRP告诉我们的那样，确保它们只做一件可辨认的事情非常重要。在考虑这些事情或行为单元时，重要的是要从将使用它的人的角度考虑函数的作用。从技术上讲，我们组合的`findScooter`函数很可能在表面之下做了各种事情。它可能非常复杂。但在它将被使用的抽象层面上，可以说它只做了一件事，这才是重要的。
- en: Three bad names
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三个糟糕的名字
- en: If you're ever stuck for a name, there's a clever approach you can use to unstick
    yourself. When you have an abstraction or variable that needs a name, look carefully
    at what it does or what it contains and then come up with at least three bad names that
    describe it. Don't worry about the abstraction or interface you wish to provide
    for now; just imagine you were describing the functionality to someone who doesn't
    know anything about the codebase. Be direct and descriptive.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对名字感到困惑，有一个聪明的方法可以帮助你摆脱困境。当你有一个需要命名的抽象或变量时，仔细看看它的功能或包含的内容，然后想出至少三个描述它的糟糕名字。现在不要担心你希望提供的抽象或接口；只是想象你在向一个对代码库一无所知的人描述功能。直接而描述性。
- en: 'For example, let''s say we''re embedded in the part of the code base that deals
    with setting up new user-names. We need to check that the username does not match
    a set of specifically forbidden words, such as `admin`, `root`, or `user`. We
    want to write a function to do this but we''re not sure what name to pick. So,
    we decide to try the three bad names approach. This is what we come up with:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们嵌入在处理设置新用户名的代码库的部分。我们需要检查用户名是否与一组特定的禁止单词匹配，比如`admin`、`root`或`user`。我们想写一个函数来做这个，但我们不确定该选什么名字。因此，我们决定尝试三个糟糕的名字的方法。这是我们想出的名字：
- en: '`matchUsernameAgainstForbiddenWords`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matchUsernameAgainstForbiddenWords`'
- en: '`checkForForbiddenWordConflicts`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkForForbiddenWordConflicts`'
- en: '`isUsernameReservedWord`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isUsernameReservedWord`'
- en: Coming up with three less-than-perfect names is a lot easier than spending many
    minutes trying but failing to come up with the perfect name. It doesn't matter
    how bad these three names are. What's important is that we can come up with at
    least three. Now, having seeded the set of possibilities, we're free to compare
    and contrast the names we've found and mix and match them to find the most descriptive
    and direct way of describing the purpose of our function. In this case, we may
    have eventually decided on a name adapted from those three possibilities: `isUsernameForbiddenWord`.
    We wouldn't have got there if it wasn't for the three bad names approach.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 想出三个不太完美的名字要比花很多时间试图找到完美的名字容易得多。这三个名字有多糟糕并不重要。重要的是我们至少能想出三个。现在，我们已经有了一系列可能性，我们可以自由地比较和对比我们找到的名字，并混合它们以找到最具描述性和直接表达我们函数目的的方式。在这种情况下，我们可能最终决定采用从这三个可能性中改编的名字：`isUsernameForbiddenWord`。如果不是因为采用了三个糟糕的名字的方法，我们就不会得到这个名字。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have wrestled with the difficult art of naming things. We've
    discussed the characteristics of a good name, that is, purpose, concept, and contract.
    We've walked through examples of how to weave these characteristics into our names
    and what anti-patterns to steer clear of. We've also discussed the importance
    of hierarchy and consistency in our pursuit of clean abstractions. Finally, we
    have covered several helpful techniques and conventions that we can utilize when
    we're having a difficult time naming things.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经探讨了命名的艰难艺术。我们讨论了一个好名字的特征，即目的、概念和约定。我们通过示例讲解了如何将这些特征编织到我们的名字中，以及要避免的反模式。我们还讨论了在追求清晰抽象时层次结构和一致性的重要性。最后，我们介绍了一些有用的技术和惯例，当我们在命名事物时遇到困难时可以利用。
- en: In the next chapter, we will, at last, begin to delve into the innards of the
    JavaScript language itself and learn how to wield its constructs and syntax in
    a way that yields truly clean code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将终于开始深入了解JavaScript语言本身，并学习如何以一种能产生真正清晰代码的方式运用它的构造和语法。
