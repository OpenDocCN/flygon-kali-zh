- en: Single-Host Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单主机网络
- en: In the previous chapter, we learned about the most important architectural patterns
    and best practices that are used when dealing with a distributed application architecture.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了处理分布式应用架构时使用的最重要的架构模式和最佳实践。
- en: In this chapter, we will introduce the Docker container networking model and
    its single-host implementation in the form of the bridge network. This chapter
    also introduces the concept of software-defined networks and how they are used
    to secure containerized applications. Furthermore, we will demonstrate how container
    ports can be opened to the public and thus make containerized components accessible
    to the outside world. Finally, we will introduce Traefik, a reverse proxy, which
    can be used to enable sophisticated HTTP application-level routing between containers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Docker容器网络模型及其在桥接网络形式下的单主机实现。本章还介绍了软件定义网络的概念以及它们如何用于保护容器化应用程序。此外，我们将演示如何将容器端口对外开放，从而使容器化组件对外界可访问。最后，我们将介绍Traefik，一个反向代理，它可以用于在容器之间启用复杂的HTTP应用级别路由。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Dissecting the container network model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解剖容器网络模型
- en: Network firewalling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络防火墙
- en: Working with the bridge network
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用桥接网络
- en: The host and null network
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机和空网络
- en: Running in an existing network namespace
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现有网络命名空间中运行
- en: Managing container ports
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理容器端口
- en: HTTP-level routing using a reverse proxy
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反向代理进行HTTP级别路由
- en: 'After completing this chapter, you will be able to do the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将能够执行以下操作：
- en: Create, inspect, and delete a custom bridge network
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、检查和删除自定义桥接网络
- en: Run a container attached to a custom bridge network
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行连接到自定义桥接网络的容器
- en: Isolate containers from each other by running them on different bridge networks
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在不同的桥接网络上运行它们来使容器彼此隔离
- en: Publish a container port to a host port of your choice
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将容器端口发布到您选择的主机端口
- en: Add Traefik as a reverse proxy to enable application-level routing
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加Traefik作为反向代理以启用应用级别路由
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, the only thing you will need is a Docker host that is able
    to run Linux containers. You can use your laptop with either Docker for macOS
    or Windows or have Docker Toolbox installed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您唯一需要的是能够运行Linux容器的Docker主机。您可以使用带有Docker for macOS或Windows的笔记本电脑，或者安装了Docker
    Toolbox。
- en: Dissecting the container network model
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解剖容器网络模型
- en: 'So far, we have been mostly working with single containers. But in reality,
    a containerized business application consists of several containers that need
    to collaborate to achieve a goal. Therefore, we need a way for individual containers
    to communicate with each other. This is achieved by establishing pathways that
    we can use to send data packets back and forth between containers. These pathways are
    called **networks**. Docker has defined a very simple networking model, the so-called **container
    network model** (**CNM**), to specify the requirements that any software that
    implements a container network has to fulfill. The following is a graphical representation
    of the CNM:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们大部分时间都在处理单个容器。但实际上，一个容器化的业务应用程序由多个容器组成，它们需要合作以实现目标。因此，我们需要一种让单个容器相互通信的方式。这是通过建立我们可以用来在容器之间发送数据包的路径来实现的。这些路径被称为**网络**。
    Docker定义了一个非常简单的网络模型，即所谓的**容器网络模型**（**CNM**），以指定任何实现容器网络的软件必须满足的要求。以下是CNM的图形表示：
- en: '![](assets/01bba337-0560-4f72-a31e-7e51d7cb98ac.png)The Docker CNM'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/01bba337-0560-4f72-a31e-7e51d7cb98ac.png)Docker CNM'
- en: 'The CNM has three elements – sandbox, endpoint, and network:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: CNM有三个元素-沙盒、端点和网络：
- en: '**Sandbox:** The sandbox perfectly isolates a container from the outside world.
    No inbound network connection is allowed into the sandboxed container. But, it
    is very unlikely that a container will be of any value in a system if absolutely
    no communication with it is possible. To work around this, we have element number
    two, which is the endpoint.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**沙盒：** 沙盒完全隔离了容器与外部世界的联系。沙盒容器不允许任何入站网络连接。但是，如果绝对不可能与容器进行任何通信，那么容器在系统中就没有任何价值。为了解决这个问题，我们有第二个元素，即端点。'
- en: '**Endpoint:** An endpoint is a controlled gateway from the outside world into
    the network''s sandbox that shields the container. The endpoint connects the network
    sandbox (but not the container) to the third element of the model, which is the
    network.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端点：** 端点是从外部世界进入网络沙盒的受控网关，用于保护容器。端点将网络沙盒（但不是容器）连接到模型的第三个元素，即网络。'
- en: '**Network:** The network is the pathway that transports the data packets of
    an instance of communication from endpoint to endpoint or, ultimately, from container
    to container.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络：** 网络是传输通信实例的数据包的路径，从端点到端点，或者最终从容器到容器。'
- en: It is important to note that a network sandbox can have zero to many endpoints,
    or, said differently, each container living in a network sandbox can either be attached
    to no network at all or it can be attached to multiple different networks at the
    same time. In the preceding diagram, the middle of the three **Network Sandboxes**
    is attached to both **Network** **1** and **Network** **2** through an **endpoint**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，网络沙盒可以有零个或多个端点，或者说，生活在网络沙盒中的每个容器可以不连接到任何网络，也可以同时连接到多个不同的网络。在前面的图表中，三个**网络沙盒**中的中间一个通过一个**端点**连接到**网络1**和**网络2**。
- en: This networking model is very generic and does not specify where the individual
    containers that communicate with each other over a network run. All containers
    could, for example, run on one and the same host (local) or they could be distributed
    across a cluster of hosts (global).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种网络模型非常通用，不指定进行网络通信的各个容器在哪里运行。例如，所有容器可以在同一台主机上运行（本地），也可以分布在一个主机集群中（全球）。
- en: 'Of course, the CNM is just a model describing how networking works among containers.
    To be able to use networking with our containers, we need real implementations
    of the CNM. For both local and global scope, we have multiple implementations
    of the CNM. In the following table, we''ve given a short overview of the existing
    implementations and their main characteristics. The list is in no particular order:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，CNM只是描述容器之间网络工作方式的模型。为了能够在容器中使用网络，我们需要CNM的真正实现。对于本地和全局范围，我们有多种CNM的实现。在下表中，我们简要概述了现有实现及其主要特点。列表没有特定顺序：
- en: '| **Network** | **Company** | **Scope** | **Description** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **网络** | **公司** | **范围** | **描述** |'
- en: '| Bridge | Docker | Local | Simple network based on Linux bridges to allow
    networking on a single host |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 桥接 | Docker | 本地 | 基于Linux桥接的简单网络，允许在单个主机上进行网络连接 |'
- en: '| Macvlan | Docker | Local | Configures multiple layer 2 (that is, MAC) addresses
    on a single physical host interface |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| Macvlan | Docker | 本地 | 在单个物理主机接口上配置多个第二层（即MAC）地址 |'
- en: '| Overlay | Docker | Global | Multinode-capable container network based on **Virtual
    Extensible LAN** (**VXLan**) |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| Overlay | Docker | 全球 | 基于**虚拟可扩展局域网**（**VXLan**）的多节点容器网络 |'
- en: '| Weave Net | Weaveworks | Global | Simple, resilient, multi-host Docker networking
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| Weave Net | Weaveworks | 全球 | 简单、弹性、多主机Docker网络 |'
- en: '| Contiv Network Plugin | Cisco | Global | Open source container networking
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| Contiv网络插件 | Cisco | 全球 | 开源容器网络 |'
- en: All network types not directly provided by Docker can be added to a Docker host
    as a plugin.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有不是由Docker直接提供的网络类型都可以作为插件添加到Docker主机上。
- en: Network firewalling
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络防火墙
- en: Docker has always had the mantra of security first. This philosophy had a direct
    influence on how networking in a single and multi-host Docker environment was
    designed and implemented. Software-defined networks are easy and cheap to create,
    yet they perfectly firewall containers that are attached to this network from
    other non-attached containers, and from the outside world. All containers that
    belong to the same network can freely communicate with each other, while others
    have no means to do so.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Docker一直以安全第一为信条。这种理念直接影响了单个和多主机Docker环境中网络设计和实现的方式。软件定义网络易于创建且成本低廉，但它们可以完全防火墙连接到该网络的容器，使其与其他未连接的容器和外部世界隔离。属于同一网络的所有容器可以自由通信，而其他容器则无法这样做。
- en: 'In the following diagram, we have two networks called **front** and **back**.
    Attached to the front network, we have containers **c1** and **c2**, and attached
    to the back network, we have containers **c3** and **c4**. **c1** and **c2** can
    freely communicate with each other, as can **c3** and **c4**. But **c1** and **c2** have
    no way to communicate with either **c3** or **c4**, and vice versa:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们有两个名为**front**和**back**的网络。连接到前端网络的有容器**c1**和**c2**，连接到后端网络的有容器**c3**和**c4**。**c1**和**c2**可以自由地相互通信，**c3**和**c4**也可以。但是**c1**和**c2**无法与**c3**或**c4**通信，反之亦然：
- en: '![](assets/dc455aaa-c719-42f7-bbe6-9183e1cc50e0.png)Docker networks'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/dc455aaa-c719-42f7-bbe6-9183e1cc50e0.png)Docker网络'
- en: 'Now, what about the situation where we have an application consisting of three
    services: **webAPI**, **productCatalog**, and **database**? We want **webAPI **to
    be able to communicate with **productCatalog**, but not with the **database**, and
    we want **productCatalog **to be able to communicate with the **database **service.
    We can solve this situation by placing **webAPI** and the database on different
    networks and attaching **productCatalog** to both of these networks, as shown
    in the following diagram:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们有一个由三个服务组成的应用程序：**webAPI**，**productCatalog**和**database**？我们希望**webAPI**能够与**productCatalog**通信，但不能与**database**通信，而且我们希望**productCatalog**能够与**database**服务通信。我们可以通过将**webAPI**和数据库放在不同的网络上，并将**productCatalog**连接到这两个网络来解决这个问题，如下图所示：
- en: '![](assets/86503975-ece8-4312-b380-9454f4494e0d.png)Container attached to multiple
    networks'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/86503975-ece8-4312-b380-9454f4494e0d.png)连接到多个网络的容器'
- en: Since creating SDNs is cheap, and each network provides added security by isolating
    resources from unauthorized access, it is highly recommended that you design and
    run applications so that they use multiple networks and only run services on the
    same network that absolutely need to communicate with each other. In the preceding
    example, there is absolutely no need for the **webAPI** component to ever communicate
    directly with the **database** service, so we have put them on different networks.
    If the worst-case scenario happens and a hacker compromises the **webAPI**, they
    cannot access the **database** from there without also hacking the **productCatalog**
    service.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建SDN成本低廉，并且每个网络通过将资源与未经授权的访问隔离提供了额外的安全性，因此强烈建议您设计和运行应用程序，使其使用多个网络，并且只在绝对需要相互通信的服务上运行在同一网络上。在前面的例子中，**webAPI**组件绝对不需要直接与**database**服务通信，因此我们将它们放在了不同的网络上。如果最坏的情况发生，黑客入侵了**webAPI**，他们也无法从那里访问**database**而不同时入侵**productCatalog**服务。
- en: Working with the bridge network
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用桥接网络
- en: The Docker bridge network is the first implementation of the container network
    model that we're going to look at in detail. This network implementation is based
    on the Linux bridge. When the Docker daemon runs for the first time, it creates
    a Linux bridge and calls it `docker0`. This is the default behavior and can be
    changed by changing the configuration. Docker then creates a network with this
    Linux bridge and calls the network `bridge`. All the containers that we create
    on a Docker host and that we do not explicitly bind to another network leads to
    Docker automatically attaching to this bridge network.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Docker桥接网络是我们将要详细查看的容器网络模型的第一个实现。这个网络实现是基于Linux桥的。当Docker守护程序第一次运行时，它会创建一个Linux桥并将其命名为`docker0`。这是默认行为，可以通过更改配置来改变。然后Docker使用这个Linux桥创建一个名为`bridge`的网络。我们在Docker主机上创建的所有容器，如果没有明确绑定到另一个网络，都会自动连接到这个桥接网络。
- en: 'To verify that we indeed have a network called `bridge` of the `bridge` type defined
    on our host, we can list all the networks on the host with the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证我们的主机上确实有一个名为`bridge`的`bridge`类型网络，我们可以使用以下命令列出主机上的所有网络：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should provide an output similar to the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该提供类似以下的输出：
- en: '![](assets/593ac4e8-8745-4f2b-8e50-ed4c631a97ad.png)Listing all the Docker
    networks available by default'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列出默认情况下所有可用的Docker网络
- en: In your case, the IDs will be different, but the rest of the output should look
    the same. We do indeed have a first network called `bridge` using the `bridge` driver.
    The scope being `local` just means that this type of network is restricted to
    a single host and cannot span multiple hosts. In [Chapter 13](a6f04592-db31-452a-aad1-ca56d9999767.xhtml),
    *Introduction to Docker Swarm*, we will also discuss other types of networks that
    have a global scope, meaning they can span whole clusters of hosts.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的情况下，ID会有所不同，但输出的其余部分应该是一样的。我们确实有一个名为`bridge`的第一个网络，使用`bridge`驱动程序。范围为`local`只是意味着这种类型的网络受限于单个主机，不能跨多个主机。在[第13章](a6f04592-db31-452a-aad1-ca56d9999767.xhtml)中，*Docker
    Swarm简介*，我们还将讨论其他具有全局范围的网络类型，这意味着它们可以跨整个主机集群。
- en: 'Now, let''s look a little bit deeper into what this bridge network is all about.
    For this, we are going to use the Docker `inspect` command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入地了解一下这个桥接网络。为此，我们将使用Docker的`inspect`命令：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When executed, this outputs a big chunk of detailed information about the network
    in question. This information should look as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，会输出有关所讨论网络的大量详细信息。这些信息应该如下所示：
- en: '![](assets/443fa38e-8fb7-4a8b-a781-08bd8b40bdc4.png)Output generated when inspecting
    the Docker bridge network'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Docker桥接网络时生成的输出
- en: 'We saw the `ID`, `Name`, `Driver`, and `Scope` values when we listed all the
    networks, so that is nothing new. But let''s have a look at the **IP address management** (**IPAM**)
    block. IPAM is a piece of software that is used to track IP addresses that are
    used on a computer. The important part of the `IPAM` block is the `Config` node
    with its values for `Subnet` and `Gateway`. The subnet for the bridge network
    is defined by default as `172.17.0.0/16`. This means that all containers attached
    to this network will get an IP address assigned by Docker that is taken from the
    given range, which  is `172.17.0.2` to `172.17.255.255`. The `172.17.0.1` address is
    reserved for the router of this network whose role in this type of network is
    taken by the Linux bridge. We can expect that the very first container that will
    be attached to this network by Docker will get the `172.17.0.2 `address. All subsequent
    containers will get a higher number; the following diagram illustrates this fact:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们列出所有网络时，我们看到了`ID`、`Name`、`Driver`和`Scope`的值，所以这并不是什么新鲜事。但让我们来看看**IP地址管理**（**IPAM**）块。IPAM是用于跟踪计算机上使用的IP地址的软件。`IPAM`块的重要部分是`Config`节点及其对`Subnet`和`Gateway`的值。桥接网络的子网默认定义为`172.17.0.0/16`。这意味着连接到此网络的所有容器将获得由Docker分配的IP地址，该地址取自给定范围，即`172.17.0.2`到`172.17.255.255`。`172.17.0.1`地址保留给此网络的路由器，在这种类型的网络中，其角色由Linux桥接器承担。我们可以预期，由Docker连接到此网络的第一个容器将获得`172.17.0.2`地址。所有后续容器将获得更高的编号；下图说明了这一事实：
- en: '![](assets/305f89fe-d167-4b3b-bb00-8f6bd3b8e800.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/305f89fe-d167-4b3b-bb00-8f6bd3b8e800.png)'
- en: The bridge network
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接网络
- en: In the preceding diagram, we can see the network namespace of the host, which
    includes the host's **eth0** endpoint, which is typically a NIC if the Docker
    host runs on bare metal or a virtual NIC if the Docker host is a VM. All traffic
    to the host comes through **eth0**. The **Linux** **bridge** is responsible for
    routing the network traffic between the host's network and the subnet of the bridge
    network.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们可以看到主机的网络命名空间，其中包括主机的**eth0**端点，如果Docker主机在裸机上运行，则通常是一个NIC，如果Docker主机是一个VM，则是一个虚拟NIC。所有对主机的流量都通过**eth0**。**Linux桥接器**负责在主机网络和桥接网络子网之间路由网络流量。
- en: 'By default, only egress traffic is allowed, and all ingress is blocked. What
    this means is that while containerized applications can reach the internet, they
    cannot be reached by any outside traffic. Each container attached to the network
    gets its own **virtual ethernet** (**veth**) connection with the bridge. This
    is illustrated in the following diagram:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，只允许出站流量，所有入站流量都被阻止。这意味着，虽然容器化应用可以访问互联网，但不能被任何外部流量访问。连接到网络的每个容器都会与桥接器建立自己的**虚拟以太网**（**veth**）连接。下图中有示例：
- en: '![](assets/c4b34b80-5e37-4257-8a0e-c79110390eda.png)Details of the bridge network'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/c4b34b80-5e37-4257-8a0e-c79110390eda.png)桥接网络的详细信息'
- en: The preceding diagram shows us the world from the perspective of the **Host**.
    We will explore what this situation looks like from within a container later on
    in this section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表向我们展示了从**主机**的角度来看世界。我们将在本节的后面探讨从容器内部看这种情况是什么样子的。
- en: 'We are not limited to just the bridge network, as Docker allows us to define
    our own custom bridge networks. This is not just a feature that is nice to have, but
    it is a recommended best practice to not run all containers on the same network.
    Instead, we should use additional bridge networks to further isolate containers
    that have no need to communicate with each other. To create a custom bridge network
    called `sample-net`, use the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅限于`bridge`网络，因为Docker允许我们定义自己的自定义桥接网络。这不仅是一个很好的功能，而且建议最佳实践是不要在同一个网络上运行所有容器。相反，我们应该使用额外的桥接网络来进一步隔离那些不需要相互通信的容器。要创建一个名为`sample-net`的自定义桥接网络，请使用以下命令：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we do this, we can then inspect what subnet Docker has created for this
    new custom network, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，我们就可以检查Docker为这个新的自定义网络创建了什么子网，如下所示：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This returns the following value:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下值：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Evidently, Docker has just assigned the next free block of IP addresses to
    our new custom bridge network. If, for some reason, we want to specify our own
    subnet range when creating a network, we can do so by using the `--subnet` parameter:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Docker刚刚为我们的新自定义桥接网络分配了下一个空闲的IP地址块。如果出于某种原因，我们想要在创建网络时指定自己的子网范围，我们可以使用`--subnet`参数来实现：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To avoid conflicts due to duplicate IP addresses, make sure you avoid creating
    networks with overlapping subnets.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免由于重复的IP地址而引起的冲突，请确保避免创建具有重叠子网的网络。
- en: 'Now that we have discussed what a bridge network is and how we can create a
    custom bridge network, we want to understand how we can attach containers to these networks.
    First, let''s interactively run an Alpine container without specifying the network
    to be attached:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了桥接网络是什么，以及我们如何创建自定义桥接网络，我们想要了解如何将容器连接到这些网络。首先，让我们交互式地运行一个Alpine容器，而不指定要连接的网络：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In another Terminal window, let''s inspect the `c1` container:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，让我们检查`c1`容器：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the vast output, let''s concentrate for a moment on the part that provides
    network-related information. This can be found under the `NetworkSettings` node.
    I have it listed in the following output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在庞大的输出中，让我们集中一下提供与网络相关信息的部分。这可以在`NetworkSettings`节点下找到。我在以下输出中列出了它：
- en: '![](assets/aa6b5fcb-a394-4fa6-85bf-fbdced83fdbe.png)The NetworkSettings section
    of the container metadata'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](assets/aa6b5fcb-a394-4fa6-85bf-fbdced83fdbe.png)容器元数据的NetworkSettings部分
- en: In the preceding output, we can see that the container is indeed attached to
    the `bridge` network since `NetworkID` is equal to `026e65...`, which we can see
    from the preceding code is the ID of the `bridge` network. We can also see that
    the container got the IP address of `172.17.0.4` assigned as expected and that
    the gateway is at `172.17.0.1`. Please note that the container also had a `MacAddress` associated
    with it. This is important as the Linux bridge uses the `MacAddress` for routing.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到容器确实连接到了`bridge`网络，因为`NetworkID`等于`026e65...`，我们可以从前面的代码中看到这是`bridge`网络的ID。我们还可以看到容器获得了预期的IP地址`172.17.0.4`，网关位于`172.17.0.1`。请注意，容器还有一个与之关联的`MacAddress`。这很重要，因为Linux桥使用`MacAddress`进行路由。
- en: 'So far, we have approached this from the outside of the container''s network
    namespace. Now, let''s see what the situation looks like when we''re not only
    inside the container but inside the containers'' network namespace. Inside the `c1` container, let''s
    use the `ip` tool to inspect what''s going on. Run the `ip addr` command and observe
    the output that is generated, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经从容器的网络命名空间外部进行了讨论。现在，让我们看看当我们不仅在容器内部，而且在容器的网络命名空间内部时情况是什么样的。在`c1`容器内部，让我们使用`ip`工具来检查发生了什么。运行`ip
    addr`命令并观察生成的输出，如下所示：
- en: '![](assets/27033243-df1d-4f06-bc3f-e75f79595799.png)Container namespace, as
    seen by the IP tool'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/27033243-df1d-4f06-bc3f-e75f79595799.png)容器命名空间，如IP工具所示'
- en: The interesting part of the preceding output is number `19`, that is, the `eth0` endpoint.
    The `veth0` endpoint that the Linux bridge created outside of the container namespace
    is mapped to `eth0` inside the container. Docker always maps the first endpoint
    of a container network namespace to `eth0`, as seen from inside the namespace.
    If the network namespace is attached to an additional network, then that endpoint
    will be mapped to `eth1`, and so on.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面输出的有趣部分是数字`19`，即`eth0`端点。Linux桥在容器命名空间外创建的`veth0`端点映射到容器内的`eth0`。Docker始终将容器网络命名空间的第一个端点映射到`eth0`，从命名空间内部看。如果网络命名空间连接到其他网络，则该端点将映射到`eth1`，依此类推。
- en: 'Since at this point we''re not really interested in any endpoint other than `eth0`,
    we could have used a more specific variant of the command, which would have given
    us the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此时我们实际上对`eth0`以外的任何端点都不感兴趣，我们可以使用命令的更具体的变体，它将给我们以下内容：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the output, we can also see what MAC address (`02:42:ac:11:00:02`) and what
    IP (`172.17.0.2`) have been associated with this container network namespace by
    Docker.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们还可以看到Docker将哪个MAC地址（`02:42:ac:11:00:02`）和哪个IP（`172.17.0.2`）与该容器网络命名空间关联起来。
- en: 'We can also get some information about how requests are routed by using the `ip
    route` command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`ip route`命令获取有关请求路由的一些信息：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This output tells us that all the traffic to the gateway at `172.17.0.1` is
    routed through the `eth0` device.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出告诉我们，所有流向网关`172.17.0.1`的流量都通过`eth0`设备路由。
- en: 'Now, let''s run another container called `c2` on the same network:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在同一网络上运行另一个名为`c2`的容器：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `c2` container will also be attached to the `bridge` network since we have
    not specified any other network. Its IP address will be the next free one from
    the subnet, which is `172.17.0.3`, as we can readily test:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有指定任何其他网络，`c2`容器也将连接到`bridge`网络。它的IP地址将是子网中的下一个空闲地址，即`172.17.0.3`，我们可以轻松测试：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we have two containers attached to the `bridge` network. We can try to
    inspect this network once again to find a list of all containers attached to it
    in the output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个容器连接到`bridge`网络。我们可以再次尝试检查此网络，以在输出中找到所有连接到它的容器的列表：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This information can be found under the `Containers` node:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息可以在`Containers`节点下找到：
- en: '![](assets/86ee4f8a-562b-48c9-a5f5-f592fd090036.png)The Containers section
    of the output of the Docker network inspect bridge'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/86ee4f8a-562b-48c9-a5f5-f592fd090036.png)Docker网络检查桥的容器部分'
- en: Once again, we have shortened the output to the relevant part for readability.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，为了可读性，我们已将输出缩短为相关部分。
- en: 'Now, let''s create two additional containers, `c3` and `c4`, and attach them
    to `test-net`. For this, we''ll use the `--network` parameter:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建两个额外的容器`c3`和`c4`，并将它们附加到`test-net`。为此，我们将使用`--network`参数：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s inspect `network test-net` and confirm that containers `c3` and `c4` are
    indeed attached to it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`network test-net`并确认`c3`和`c4`容器确实连接到它：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will give us the following output for the `Containers` section:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为`Containers`部分提供以下输出：
- en: '![](assets/3ae3275a-6e10-49e8-8c51-59287cb8c746.png)Containers section of the
    docker network inspect test-net command'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/3ae3275a-6e10-49e8-8c51-59287cb8c746.png)docker network inspect
    test-net命令的容器部分'
- en: 'The next question we''re going to ask ourselves is whether the `c3` and `c4` containers can
    freely communicate with each other. To demonstrate that this is indeed the case,
    we can `exec` into the `c3` container:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要问自己的问题是，`c3`和`c4`容器是否可以自由通信。为了证明这确实是这种情况，我们可以`exec`进入`c3`容器：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once inside the container, we can try to ping container `c4` by name and by
    IP address:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 进入容器后，我们可以尝试通过名称和IP地址ping容器`c4`：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the result of the ping using the IP address of `c4`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`c4`的IP地址进行ping的结果：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The answer in both cases confirms to us that the communication between containers
    attached to the same network is working as expected. The fact that we can even use the
    name of the container we want to connect to shows us that the name resolution
    provided by the Docker DNS service works inside this network.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下的答案都向我们确认，连接到同一网络的容器之间的通信正常工作。我们甚至可以使用要连接的容器的名称，这表明Docker DNS服务提供的名称解析在这个网络内部工作。
- en: 'Now, we want to make sure that the `bridge` and the `test-net` networks are
    firewalled from each other. To demonstrate this, we can try to ping the `c2` container from
    the `c3` container, either by its name or by its IP address:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要确保`bridge`和`test-net`网络之间有防火墙。为了证明这一点，我们可以尝试从`c3`容器中ping`c2`容器，无论是通过名称还是IP地址：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the result of the ping using the IP address of the `c2` container instead:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`c2`容器的IP地址进行ping的结果：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding command remained hanging and I had to terminate the command with *Ctrl*+*C*.
    From the output of pinging `c2`, we can also see that the name resolution does
    not work across networks. This is the expected behavior. Networks provide an extra
    layer of isolation, and thus security, to containers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令一直挂起，我不得不用*Ctrl*+*C*终止命令。从ping`c2`的输出中，我们还可以看到名称解析在网络之间不起作用。这是预期的行为。网络为容器提供了额外的隔离层，因此增强了安全性。
- en: 'Earlier, we learned that a container can be attached to multiple networks.
    Let''s attach the `c5` container to the `sample-net` and `test-net` networks at
    the same time:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们了解到一个容器可以连接到多个网络。让我们同时将`c5`容器连接到`sample-net`和`test-net`网络：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, we can test that `c5` is reachable from the `c2` container, similar to
    when we tested the same for the `c4` and `c2` containers. The result will show
    that the connection indeed works.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试`c5`是否可以从`c2`容器中访问，类似于我们测试`c4`和`c2`容器时的情况。结果将显示连接确实有效。
- en: 'If we want to remove an existing network, we can use the `docker network rm` command,
    but note that we cannot accidentally delete a network that has containers attached
    to it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要删除一个现有的网络，我们可以使用`docker network rm`命令，但请注意我们不能意外地删除已连接到容器的网络：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Before we continue, let''s clean up and remove all the containers:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们清理并删除所有的容器：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can remove the two custom networks that we created:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以删除我们创建的两个自定义网络：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Alternatively, we could remove all the networks that no container is attached
    to with the `prune` command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`prune`命令删除所有未连接到容器的网络：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: I used the `--force` (or `-f`) argument here to prevent Docker from reconfirming
    that I really want to remove all unused networks.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用了`--force`（或`-f`）参数，以防止Docker重新确认我是否真的要删除所有未使用的网络。
- en: The host and null network
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机和空网络
- en: In this section, we are going to look at two predefined and somewhat unique
    types of networks, the `host` and the `null` networks. Let's start with the former.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下两种预定义且有些独特的网络类型，即`host`和`null`网络。让我们从前者开始。
- en: The host network
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机网络
- en: There are occasions where we want to run a container in the network namespace
    of the host. This can be necessary when we need to run some software in a container
    that is used to analyze or debug the host networks' traffic. But keep in mind
    that these are very specific scenarios. When running business software in containers,
    there is no good reason to ever run the respective containers attached to the
    host's network. For security reasons, it is strongly recommended that you do not
    run any such container attached to the `host` network on a production or production-like
    environment.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们希望在主机的网络命名空间中运行容器。当我们需要在容器中运行用于分析或调试主机网络流量的软件时，这可能是必要的。但请记住，这些是非常特定的场景。在容器中运行业务软件时，没有任何理由将相应的容器附加到主机的网络上。出于安全原因，强烈建议您不要在生产环境或类似生产环境中运行任何附加到`host`网络的容器。
- en: 'That said, *how can we run a container inside the network namespace of the
    host?* Simply by attaching the container to the `host` network:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，*我们如何在主机的网络命名空间中运行容器呢？*只需将容器连接到`host`网络即可：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we use the `ip` tool to analyze the network namespace from within the container,
    we will see that we get exactly the same picture as we would if we were running
    the `ip` tool directly on the host. For example, if I inspect the `eth0` device on
    my host, I get this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`ip`工具从容器内部分析网络命名空间，我们会发现得到的结果与直接在主机上运行`ip`工具时完全相同。例如，如果我检查我的主机上的`eth0`设备，我会得到这样的结果：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, I can see that `192.168.65.3` is the IP address that the host has been
    assigned and that the MAC address shown here also corresponds to that of the host.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我可以看到`192.168.65.3`是主机分配的IP地址，这里显示的MAC地址也对应于主机的MAC地址。
- en: 'We can also inspect the routes to get the following (shortened):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查路由，得到以下结果（缩短）：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Before I let you go on to the next section of this chapter, I want to once more
    point out that the use of the `host` network is dangerous and needs to be avoided
    if possible.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在让您继续阅读本章的下一部分之前，我再次要指出，使用`host`网络是危险的，如果可能的话应该避免使用。
- en: The null network
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空网络
- en: 'Sometimes, we need to run a few application services or jobs that do not need
    any network connection at all to execute the task at hand. It is strongly advised
    that you run those applications in a container that is attached to the `none` network.
    This container will be completely isolated, and is thus safe from any outside
    access. Let''s run such a container:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要运行一些不需要任何网络连接来执行任务的应用服务或作业。强烈建议您将这些应用程序运行在附加到`none`网络的容器中。这个容器将完全隔离，因此不会受到任何外部访问的影响。让我们运行这样一个容器：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once inside the container, we can verify that there is no `eth0` network endpoint
    available:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入容器，我们可以验证没有`eth0`网络端点可用：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There is also no routing information available, as we can demonstrate by using
    the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 也没有可用的路由信息，我们可以使用以下命令来证明：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This returns nothing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回空值。
- en: Running in an existing network namespace
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在现有的网络命名空间中运行
- en: Normally, Docker creates a new network namespace for each container we run.
    The network namespace of the container corresponds to the sandbox of the container
    network model we described earlier on. As we attach the container to a network,
    we define an endpoint that connects the container network namespace with the actual
    network. This way, we have one container per network namespace.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Docker为我们运行的每个容器创建一个新的网络命名空间。容器的网络命名空间对应于我们之前描述的容器网络模型的沙盒。当我们将容器连接到网络时，我们定义一个端点，将容器的网络命名空间与实际网络连接起来。这样，我们每个网络命名空间有一个容器。
- en: 'Docker provides an additional way for us to define the network namespace that
    a container runs in. When creating a new container, we can specify that it should
    be attached to (or maybe we should say included) in the network namespace of an
    existing container. With this technique, we can run multiple containers in a single
    network namespace:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Docker为我们提供了另一种定义容器运行的网络命名空间的方法。在创建新容器时，我们可以指定它应该附加到（或者我们应该说包含在）现有容器的网络命名空间中。通过这种技术，我们可以在单个网络命名空间中运行多个容器：
- en: '![](assets/fab345c0-6d16-4d82-ab56-ed17edd9cb1c.png)Multiple containers running
    in a single network namespace'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/fab345c0-6d16-4d82-ab56-ed17edd9cb1c.png)在单个网络命名空间中运行多个容器'
- en: In the preceding diagram, we can see that in the leftmost **Network** **Namespace**,
    we have two containers. The two containers, since they share the same namespace,
    can communicate on localhost with each other. The network namespace (and not the
    individual containers) is then attached to **Network 1**.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到在最左边的**网络** **命名空间**中，我们有两个容器。由于它们共享相同的命名空间，这两个容器可以在本地主机上相互通信。然后将网络命名空间（而不是单个容器）附加到**网络1**。
- en: This is useful when we want to debug the network of an existing container without
    running additional processes inside that container. We can just attach a special
    utility container to the network namespace of the container to inspect. This feature
    is also used by Kubernetes when it creates a pod. We will learn more about Kubernetes
    and pods in [Chapter 15](b8e4dc09-b2ce-4f89-9682-d8f0c6e126f6.xhtml), *Introduction
    to Kubernetes* of this book.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要调试现有容器的网络而不在该容器内运行其他进程时，这是非常有用的。我们只需将特殊的实用容器附加到要检查的容器的网络命名空间即可。这个特性也被Kubernetes在创建pod时使用。我们将在本书的[第15章](b8e4dc09-b2ce-4f89-9682-d8f0c6e126f6.xhtml)中学习更多关于Kubernetes和pod的知识，*Kubernetes简介*。
- en: 'Now, let''s demonstrate how this works:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们演示一下这是如何工作的：
- en: 'First, we create a new bridge network:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的桥接网络：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we run a container attached to this network:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们运行一个附加到这个网络的容器：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we run another container and attach it to the network of our `web` container:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们运行另一个容器并将其附加到我们的`web`容器的网络中：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Specifically, note how we define the network: `--network container:web`. This
    tells Docker that our new container shall use the same network namespace as the
    container called `web`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 特别要注意我们如何定义网络：`--network container:web`。这告诉Docker我们的新容器应该使用与名为`web`的容器相同的网络命名空间。
- en: 'Since the new container is in the same network namespace as the web container
    running nginx, we''re now able to access nginx on localhost! We can prove this
    by using the `wget` tool, which is part of the Alpine container, to connect to
    nginx. We should see the following:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于新容器与运行nginx的web容器在相同的网络命名空间中，我们现在可以在本地访问nginx！我们可以通过使用Alpine容器的一部分的`wget`工具来证明这一点，以连接到nginx。我们应该看到以下内容：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that we have shortened the output for readability. Please also note that
    there is an important difference between running two containers attached to the
    same network and two containers running in the same network namespace. In both
    cases, the containers can freely communicate with each other, but in the latter
    case, the communication happens over localhost.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了便于阅读，我们已经缩短了输出。还请注意，在运行附加到相同网络的两个容器和在相同网络命名空间中运行两个容器之间存在重要区别。在这两种情况下，容器可以自由地相互通信，但在后一种情况下，通信发生在本地主机上。
- en: 'To clean up the container and network, we can use the following command:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要清理容器和网络，我们可以使用以下命令：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the next section, we are going to learn how to expose container ports on
    the container host.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在容器主机上公开容器端口。
- en: Managing container ports
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理容器端口
- en: Now that we know how we can isolate firewall containers from each other by placing
    them on different networks, and that we can have a container attached to more
    than one network, we have one problem that remains unsolved. *How can we expose
    an application service to the outside world?* Imagine a container running a web
    server hosting our webAPI from before. We want customers from the internet to
    be able to access this API. We have designed it to be a publicly accessible API.
    To achieve this, we have to, figuratively speaking, open a gate in our firewall
    through which we can funnel external traffic to our API. For security reasons,
    we don't just want to open the doors wide; we want to have a single controlled
    gate that traffic flows through.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们可以通过将它们放在不同的网络上来隔离防火墙容器，并且我们可以让一个容器连接到多个网络，但是还有一个问题没有解决。*我们如何将应用服务暴露给外部世界？*想象一下一个容器运行着一个Web服务器，托管着我们之前的WebAPI。我们希望来自互联网的客户能够访问这个API。我们已经设计它为一个公开访问的API。为了实现这一点，我们必须象征性地打开我们防火墙中的一个门，通过这个门我们可以将外部流量传递到我们的API。出于安全原因，我们不只是想要敞开大门；我们希望有一个单一受控的门，流量可以通过。
- en: 'We can create such a gate by mapping a container port to an available port
    on the host. We''re also calling this opening a gate to the container port to
    publish a port. Remember that the container has its own virtual network stack,
    as does the host. Therefore, container ports and host ports exist completely independently
    and by default have nothing in common at all. But we can now wire a container
    port with a free host port and funnel external traffic through this link, as illustrated
    in the following diagram:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将容器端口映射到主机上的一个可用端口来创建这样的门。我们也称之为打开一个通往容器端口的门以发布一个端口。请记住，容器有自己的虚拟网络堆栈，主机也有。因此，默认情况下，容器端口和主机端口完全独立存在，根本没有任何共同之处。但是现在我们可以将一个容器端口与一个空闲的主机端口连接起来，并通过这个链接传递外部流量，如下图所示：
- en: '![](assets/ed84f752-d199-4870-90eb-1ee9216cc749.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ed84f752-d199-4870-90eb-1ee9216cc749.png)'
- en: Mapping container ports to host ports
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将容器端口映射到主机端口
- en: 'But now, it is time to demonstrate how we can actually map a container port
    to a host port. This is done when creating a container. We have different ways
    of doing so:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，是时候演示如何实际将容器端口映射到主机端口了。这是在创建容器时完成的。我们有不同的方法来做到这一点：
- en: 'First, we can let Docker decide which host port our container port shall be
    mapped to. Docker will then select one of the free host ports in the range of
    32xxx. This automatic mapping is done by using the `-P` parameter:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以让Docker决定将我们的容器端口映射到哪个主机端口。Docker将在32xxx范围内选择一个空闲的主机端口进行自动映射，这是通过使用`-P`参数完成的：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding command runs an nginx server in a container. nginx is listening
    at port `80` inside the container. With the `-P` parameter, we''re telling Docker
    to map all the exposed container ports to a free port in the 32xxx range. We can
    find out which host port Docker is using by using the `docker container port` command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令在一个容器中运行了一个nginx服务器。nginx在容器内部监听端口`80`。使用`-P`参数，我们告诉Docker将所有暴露的容器端口映射到32xxx范围内的一个空闲端口。我们可以通过使用`docker
    container port`命令找出Docker正在使用的主机端口：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The nginx container only exposes port `80`, and we can see that it has been
    mapped to the host port `32768`. If we open a new browser window and navigate
    to `localhost:32768`, we should see the following screen:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: nginx容器只暴露端口`80`，我们可以看到它已经映射到主机端口`32768`。如果我们打开一个新的浏览器窗口并导航到`localhost:32768`，我们应该会看到以下屏幕：
- en: '![](assets/6b50f760-dad5-486e-bc18-2cec42bbaae3.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6b50f760-dad5-486e-bc18-2cec42bbaae3.png)'
- en: The welcome page of nginx
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: nginx的欢迎页面
- en: 'An alternative way to find out which host port Docker is using for our container
    is to inspect it. The host port is part of the `NetworkSettings` node:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出Docker用于我们的容器的主机端口的另一种方法是检查它。主机端口是`NetworkSettings`节点的一部分：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, the third way of getting this information is to list the container:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，获取这些信息的第三种方法是列出容器：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Please note that in the preceding output, the `/tcp` part tells us that the
    port has been opened for communication with the TCP protocol, but not for the
    UDP protocol. TCP is the default, and if we want to specify that we want to open
    the port for UDP, then we have to specify this explicitly. `0.0.0.0` in the mapping
    tells us that traffic from any host IP address can now reach container port `80` of
    the `web` container.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上述输出中，`/tcp`部分告诉我们该端口已经为TCP协议通信打开，但未为UDP协议打开。TCP是默认的，如果我们想指定为UDP打开端口，那么我们必须明确指定。映射中的`0.0.0.0`告诉我们，任何主机IP地址的流量现在都可以到达`web`容器的端口`80`。
- en: 'Sometimes, we want to map a container port to a very specific host port. We
    can do this by using the `-p` parameter (or `--publish`). Let''s look at how this
    is done with the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想将容器端口映射到一个非常特定的主机端口。我们可以使用`-p`参数（或`--publish`）来实现这一点。让我们看看如何使用以下命令来实现这一点：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The value of the `-p` parameter is in the form of `<host port>:<container port>`.
    Therefore, in the preceding case, we map container port `80` to host port `8080`.
    Once the `web2` container runs, we can test it in the browser by navigating to
    `localhost:8080`, and we should be greeted by the same nginx welcome page that
    we saw in the previous example that dealt with automatic port mapping.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p`参数的值的格式为`<主机端口>:<容器端口>`。因此，在上述情况中，我们将容器端口`80`映射到主机端口`8080`。一旦`web2`容器运行，我们可以通过浏览器导航到`localhost:8080`来测试它，我们应该会看到与处理自动端口映射的上一个示例中看到的相同的nginx欢迎页面。'
- en: When using the UDP protocol for communication over a certain port, the `publish`
    parameter will look like `-p 3000:4321/udp`. Note that if we want to allow communication
    with both TCP and UDP protocols over the same port, then we have to map each protocol
    separately.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用UDP协议进行特定端口通信时，`publish`参数看起来像`-p 3000:4321/udp`。请注意，如果我们想要允许在同一端口上使用TCP和UDP协议进行通信，那么我们必须分别映射每个协议。
- en: HTTP-level routing using a reverse proxy
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用反向代理进行HTTP级别的路由
- en: Imagine you have been tasked with containerizing a monolithic application. The
    application has organically evolved over the years into an unmaintainable monster.
    Changing even a minor feature in the source code may break other features due
    to the tight coupling existing in the code base. Releases are rare due to their
    complexity and require the whole team to be on deck. The application has to be
    taken down during the release window, which costs the company a lot of money due
    to lost opportunities, not to mention their loss of reputation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你被要求将一个庞大的应用程序容器化。这个应用程序多年来已经自然地演变成了一个难以维护的怪物。由于代码库中存在紧密耦合，即使是对源代码进行微小的更改也可能会破坏其他功能。由于其复杂性，发布版本很少，并且需要整个团队全力以赴。在发布窗口期间必须关闭应用程序，这会给公司带来很大的损失，不仅是由于失去的机会，还有他们的声誉损失。
- en: Management has decided to put an end to that vicious cycle and improve the situation
    by containerizing the monolith. This alone will lead to a massively decreased
    time between releases as witnessed by the industry. In a later step, the company
    wants to break out every piece of functionality from the monolith and implement
    them as microservices. This process will continue until the monolith has been
    completely starved.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 管理层已决定结束这种恶性循环，并通过容器化单体应用来改善情况。这一举措将大大缩短发布之间的时间，正如行业所见。在随后的步骤中，公司希望从单体应用中分离出每一个功能，并将它们实现为微服务。这个过程将持续进行，直到单体应用完全被分解。
- en: But it is this second point that leads to some head-scratching in the team involved.
    How will we break down the monolith into loosely coupled microservices without
    affecting all the many clients of the monolith out there? The public API of the
    monolith, though very complex, has a well-structured design. Public URIs had been
    carefully crafted and should not be changed at all costs. For example, there is
    a product catalog function implemented in the app that can be accessed via `https://acme.com/catalog?category=bicycles` so
    that we can access a list of bicycles offered by the company.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 但正是这第二点让参与其中的团队感到困惑。我们如何将单体应用分解为松耦合的微服务，而不影响单体应用的众多客户？单体应用的公共API虽然非常复杂，但设计得很结构化。公共URI已经经过精心设计，绝对不能改变。例如，应用程序中实现了一个产品目录功能，可以通过`https://acme.com/catalog?category=bicycles`来访问，以便我们可以访问公司提供的自行车列表。
- en: On the other hand, there is a URL called `https://acme.com/checkout` that we
    can use to initiate the checkout of a customers' shopping cart, and so on. I hope
    it is clear where we are going with this.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有一个名为`https://acme.com/checkout`的URL，我们可以用它来启动客户购物车的结账，等等。我希望大家清楚我们要做什么。
- en: Containerizing the monolith
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化单体应用
- en: 'Let''s start with the monolith. I have prepared a simple code base that has
    been implemented in Python 2.7 and uses Flask to implement the public REST API.
    The sample app is not really a full-blown application but just complex enough
    to allow for some redesign. The sample code can be found in the `ch10/e-shop` folder.
    Inside this folder is a subfolder called `monolith` containing the Python application.
    Follow these steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从单体应用开始。我已经准备了一个简单的代码库，它是用Python 2.7实现的，并使用Flask来实现公共REST API。示例应用程序并不是一个完整的应用程序，但足够复杂，可以进行一些重新设计。示例代码可以在`ch10/e-shop`文件夹中找到。在这个文件夹中有一个名为`monolith`的子文件夹，其中包含Python应用程序。按照以下步骤进行：
- en: 'In a new Terminal window, navigate to that folder, install the required dependencies,
    and run the application:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的终端窗口中，导航到该文件夹，安装所需的依赖项，并运行应用程序：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The application will be starting and listening on `localhost` on port `5000`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将在`localhost`的`5000`端口上启动并监听：
- en: '![](assets/0898d2ee-bb7a-47ed-a3b3-d4b30633783d.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0898d2ee-bb7a-47ed-a3b3-d4b30633783d.png)'
- en: Running the Python monolith
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Python单体应用
- en: 'We can use `curl` to test the app. Use the following command to retrieve a
    list of all the bicycles the company offers:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`curl`来测试应用程序。使用以下命令来检索公司提供的所有自行车的列表：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You should see a JSON formatted list of three types of bicycles. OK – so far,
    so good.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一个JSON格式的自行车类型列表。好吧，目前为止一切顺利。
- en: 'Now, let''s change the `hosts` file, add an entry for `acme.com`, and map it
    to `127.0.0.1`, the loop-back address. This way, we can simulate a real client
    accessing the app with the URL `http://acme.cnoteom/catalog?category=bicycles`
    instead of using `localhost`. You need to use sudo to edit the hosts file on a
    macOS or on Linux. You should add a line to the `hosts` file that looks like this:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们更改`hosts`文件，为`acme.com`添加一个条目，并将其映射到`127.0.0.1`，即环回地址。这样，我们可以模拟一个真实的客户端使用URL
    `http://acme.cnoteom/catalog?category=bicycles` 访问应用程序，而不是使用`localhost`。在macOS或Linux上，您需要使用sudo来编辑hosts文件。您应该在`hosts`文件中添加一行，看起来像这样：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Save your changes and assert that it works by pinging `acme.com`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的更改，并通过ping `acme.com`来确认它是否正常工作：
- en: '![](assets/68e14aa6-b00c-441b-a1c9-bcc6d6804765.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/68e14aa6-b00c-441b-a1c9-bcc6d6804765.png)'
- en: Mapping `acme.com` to the loop-back address via the `hosts` fileOn Windows,
    you can edit the file by, for example, running Notepad as an administrator, opening the
    `c:\Windows\System32\Drivers\etc\hosts` file, and modifying it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`hosts`文件将`acme.com`映射到环回地址在Windows上，您可以通过以管理员身份运行记事本，打开`c:\Windows\System32\Drivers\etc\hosts`文件并修改它来编辑文件。
- en: After all this, it is time to containerize the application. The only change
    we need to make in the application is ensuring that we have the application web
    server listening on `0.0.0.0` instead of `localhost`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有这些步骤，现在是时候将应用程序容器化了。我们需要做的唯一更改是确保应用程序Web服务器侦听`0.0.0.0`而不是`localhost`。
- en: 'We can do this easily by modifying the application and adding the following
    start logic at the end of `main.py`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过修改应用程序并在`main.py`的末尾添加以下启动逻辑来轻松实现这一点：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Then, we can start the application with `python main.py`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`python main.py`启动应用程序。
- en: 'Now, add a `Dockerfile` to the `monolith` folder with the following content:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`monolith`文件夹中添加一个`Dockerfile`，内容如下：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In your Terminal window, from within the monolith folder, execute the following
    command to build a Docker image for the application:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端窗口中，从单体文件夹中执行以下命令，为应用程序构建Docker镜像：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After the image has been built, try to run the application:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建完镜像后，尝试运行应用程序：
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Notice that the output from the app now running inside a container is indistinguishable
    from what we got when running the application directly on the host. We can now
    test if the application still works as before by using the two `curl` commands
    to access the catalog and the checkout logic:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在在容器内运行的应用程序的输出与在主机上直接运行应用程序时获得的输出是无法区分的。现在，我们可以使用两个`curl`命令来访问目录和结账逻辑，测试应用程序是否仍然像以前一样工作：
- en: '![](assets/eb78770c-6b08-4775-aa10-bddd915b27ce.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/eb78770c-6b08-4775-aa10-bddd915b27ce.png)'
- en: Testing the monolith while running in a container
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中运行时测试单体应用程序
- en: Evidently, the monolith still works exactly the same way as before, even when
    using the correct URL, that is, `http://acme.com`. Great! Now, let's break out
    part of the monolith's functionality into a Node.js microservice, which will be
    deployed separately.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，即使使用正确的URL，即`http://acme.com`，单体仍然以与以前完全相同的方式工作。太好了！现在，让我们将单体的一部分功能拆分为一个Node.js微服务，这将被单独部署。
- en: Extracting the first microservice
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取第一个微服务
- en: The team, after some brainstorming, has decided that the product `catalog` is
    a good candidate for the first piece of functionality that is cohesive yet self-contained
    enough to be extracted from the monolith. They decide to implement the product
    catalog as a microservice implemented in Node.js.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 团队经过一番头脑风暴后决定，产品`catalog`是第一个具有内聚力且足够独立的功能片段，可以从单体中提取出来作为微服务实现。他们决定将产品目录实现为一个基于Node.js的微服务。
- en: 'You can find the code they came up with and the `Dockerfile` in the `catalog` subfolder
    of the project folder, that is, `e-shop`. It is a simple Express.js application
    that replicates the functionality that was previously available in the monolith.
    Let''s get started:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在项目文件夹的`e-shop`的`catalog`子文件夹中找到他们提出的代码和`Dockerfile`。这是一个简单的Express.js应用程序，复制了以前在单体中可用的功能。让我们开始吧：
- en: 'In your Terminal window, from within the `catalog` folder, build the Docker
    image for this new microservice:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端窗口中，从`catalog`文件夹中构建这个新的微服务的Docker镜像：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, run a container from the new image you just built:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从您刚刚构建的新镜像中运行一个容器：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'From a different Terminal window, try to access the microservice and validate
    that it returns the same data as the monolith:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从另一个终端窗口中，尝试访问微服务并验证它返回与单体相同的数据：
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Please notice the differences in the URL compared to when accessing the same
    functionality in the monolith. Here, we are accessing the microservice on port
    `3000` (instead of `5000`). But we said that we didn't want to have to change
    the clients that access our e-shop application. What can we do? Luckily, there
    are solutions to problems like this. We need to reroute incoming requests. We'll
    show you how to do this in the next section.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意与访问单体应用程序中相同功能时的URL的差异。在这里，我们正在访问端口`3000`上的微服务（而不是`5000`）。但是我们说过，我们不想改变访问我们电子商店应用程序的客户端。我们能做什么？幸运的是，有解决这类问题的解决方案。我们需要重新路由传入的请求。我们将在下一节中向您展示如何做到这一点。
- en: Using Traefik to reroute traffic
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Traefik重新路由流量
- en: In the previous section, we realized that we will have to reroute incoming traffic
    with a target URL starting with `http://acme.com:5000/catalog` to an alternative
    URL such as `product-catalog:3000/catalog`. We will be using Traefik to do exactly
    that.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们意识到我们将不得不将以`http://acme.com:5000/catalog`开头的目标URL的传入流量重新路由到另一个URL，例如`product-catalog:3000/catalog`。我们将使用Traefik来偏向这样做。
- en: Traefik is a cloud-native edge router and it is open source, which is great
    for our specific case. It even has a nice web UI that you can use to manage and
    monitor your routes. Traefik can be combined with Docker in a very straightforward
    way, as we will see in a moment.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Traefik是一个云原生边缘路由器，它是开源的，这对我们来说非常好。它甚至有一个漂亮的Web UI，您可以用来管理和监视您的路由。Traefik可以与Docker非常直接地结合使用，我们马上就会看到。
- en: To integrate well with Docker, Traefik relies on metadata found on each container
    or service. This metadata can be applied in the form of labels that contain the
    routing information.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与Docker很好地集成，Traefik依赖于在每个容器或服务中找到的元数据。这些元数据可以以包含路由信息的标签的形式应用。
- en: 'First, let''s look at how to run the catalog service:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下如何运行目录服务：
- en: 'Here is the Docker `run` command:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是Docker `run`命令：
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s quickly look at the four labels we define:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们快速看一下我们定义的四个标签：
- en: '`traefik.enable=true`: This tells Traefik that this particular container should
    be included in the routing (the default is `false`).'
  id: totrans-239
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traefik.enable=true`：这告诉Traefik这个特定的容器应该包括在路由中（默认值为`false`）。'
- en: '`traefik.port=3000`: The router should forward the call to port `3000` (which
    is the port that the Express.js app is listening on).'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traefik.port=3000`：路由器应将调用转发到端口`3000`（这是Express.js应用程序正在监听的端口）。'
- en: '`traefik.priority=10`: Give this route high priority. We will see why in a
    second.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traefik.priority=10`：给这条路线高优先级。我们马上就会看到为什么。'
- en: '`traefik.http.routers.catalog.rule="Host(\"acme.com\") && PathPrefix(\"/catalog\")"`:
    The route must include the hostname, `acme.com`, and the path must start with
    `/catalog` in order to be rerouted to this service. As an example, `acme.com/catalog?type=bicycles`
    would qualify for this rule.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traefik.http.routers.catalog.rule="Host(\"acme.com\") && PathPrefix(\"/catalog\")"`：路由必须包括主机名`acme.com`，路径必须以`/catalog`开头才能被重定向到该服务。例如，`acme.com/catalog?type=bicycles`符合此规则。'
- en: Please note the special form of the fourth label. Its general form is `traefik.http.routers.<service
    name>.rule`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意第四个标签的特殊形式。它的一般形式是`traefik.http.routers.<service name>.rule`。
- en: 'Now, let''s look at how we can run the `eshop` container:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何运行`eshop`容器：
- en: '[PRE52]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we forward any matching calls to port `5000`, which corresponds to the
    port where the `eshop` application is listening. Pay attention to the priority,
    which is set to `1` (low). This, in combination with the high priority of the
    `catalog` service, allows us to have all URLs starting with `/catalog` being filtered
    out and redirected to the `catalog` service, while all other URLs will go to the
    `eshop` service.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将任何匹配的调用转发到端口`5000`，这对应于`eshop`应用程序正在监听的端口。请注意优先级设置为`1`（低）。这与`catalog`服务的高优先级结合起来，使我们能够过滤出所有以`/catalog`开头的URL，并将其重定向到`catalog`服务，而所有其他URL将转到`eshop`服务。
- en: 'Now, we can finally run Traefik as the edge router that will serve as a reverse
    proxy in front of our application. This is how we start it:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们终于可以将Traefik作为边缘路由器运行，它将作为我们应用程序前面的反向代理。这是我们启动它的方式：
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note how we mount the Docker socket into the container so that Traefik can interact
    with the Docker engine. We will be able to send web traffic to port `80` of Traefik,
    from where it will be rerouted according to our rules in the routing definitions
    found in the metadata of the participating container. Furthermore, we can access
    the web UI of Traefik via port `8080`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何将Docker套接字挂载到容器中，以便Traefik可以与Docker引擎交互。我们将能够将Web流量发送到Traefik的端口`80`，然后根据参与容器的元数据中的路由定义，根据我们的规则进行重定向。此外，我们可以通过端口`8080`访问Traefik的Web
    UI。
- en: 'Now that everything is running, that is, the monolith, the first microservice
    called `catalog`, and Traefik, we can test if all works as expected. Use `curl`
    once again to do so:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都在运行，即单体应用程序，第一个名为`catalog`的微服务和Traefik，我们可以测试一切是否按预期工作。再次使用`curl`来测试：
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As we mentioned earlier, we are now sending all traffic to port `80`, which
    is what Traefik is listening on. This proxy will then reroute the traffic to the
    correct destination.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，现在我们将所有流量发送到端口`80`，这是Traefik正在监听的端口。然后，这个代理将把流量重定向到正确的目的地。
- en: 'Before proceeding, stop all containers:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请停止所有容器：
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: That's it for this chapter.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本章的全部内容。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about how containers running on a single host
    can communicate with each other. First, we looked at the CNM, which defines the
    requirements of a container network, and then we investigated several implementations
    of the CNM, such as the bridge network. We then looked at how the bridge network
    functions in detail and also what kind of information Docker provides us with
    about the networks and the containers attached to those networks. We also learned
    about adopting two different perspectives, from both outside and inside the container. Last
    but not least we introduced Traefik as a means to provide application level routing
    to our applications.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了单个主机上运行的容器如何相互通信。首先，我们看了一下CNM，它定义了容器网络的要求，然后我们调查了CNM的几种实现，比如桥接网络。然后我们详细了解了桥接网络的功能，以及Docker提供给我们有关网络和连接到这些网络的容器的信息。我们还学习了如何从容器的内外采用两种不同的视角。最后，我们介绍了Traefik作为一种提供应用级路由到我们的应用程序的手段。
- en: In the next chapter, we're going to introduce Docker Compose. We will learn
    about creating an application that consists of multiple services, each running
    in a container, and how Docker Compose allows us to easily build, run, and scale
    such an application using a declarative approach.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Docker Compose。我们将学习如何创建一个由多个服务组成的应用程序，每个服务在一个容器中运行，并且Docker Compose如何允许我们使用声明性方法轻松构建、运行和扩展这样的应用程序。
- en: Questions
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To assess the skills that you have gained from this chapter, please try to
    answer the following questions:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估您从本章中获得的技能，请尝试回答以下问题：
- en: Name the three core elements of the **container network model** (**CNM**).
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名**容器网络模型**（**CNM**）的三个核心元素。
- en: How do you create a custom bridge network called, for example, `frontend`?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建一个名为“frontend”的自定义桥接网络？
- en: How do you run two `nginx:alpine` containers attached to the `frontend` network?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何运行两个连接到“frontend”网络的“nginx:alpine”容器？
- en: 'For the `frontend` network, get the following:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于“frontend”网络，获取以下内容：
- en: The IPs of all the attached containers
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有连接的容器的IP地址
- en: The subnet associated with the network
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与网络相关联的子网
- en: What is the purpose of the `host` network?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “host”网络的目的是什么？
- en: Name one or two scenarios where the use of the `host` network is appropriate.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“host”网络适用的一个或两个场景的名称。
- en: What is the purpose of the `none` network?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “none”网络的目的是什么？
- en: In what scenarios should the `none` network be used?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下应该使用“none”网络？
- en: Why would we use a reverse proxy such as Traefik together with our containerized
    application?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们会与容器化应用一起使用反向代理，比如Traefik？
- en: Further reading
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some articles that describe the topics that were presented in this
    chapter in more detail:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些更详细描述本章主题的文章：
- en: Docker networking overview: [http://dockr.ly/2sXGzQn](http://dockr.ly/2sXGzQn)
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网络概述：[http://dockr.ly/2sXGzQn](http://dockr.ly/2sXGzQn)
- en: Container networking: [http://dockr.ly/2HJfQKn](http://dockr.ly/2HJfQKn)
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器网络：[http://dockr.ly/2HJfQKn](http://dockr.ly/2HJfQKn)
- en: What is a bridge?: [https://bit.ly/2HyC3Od](https://bit.ly/2HyC3Od)
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是桥接网络？：[https://bit.ly/2HyC3Od](https://bit.ly/2HyC3Od)
- en: Using bridge networks: [http://dockr.ly/2BNxjRr](http://dockr.ly/2BNxjRr)
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用桥接网络：[http://dockr.ly/2BNxjRr](http://dockr.ly/2BNxjRr)
- en: Using Macvlan networks: [http://dockr.ly/2ETjy2x](http://dockr.ly/2ETjy2x)
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Macvlan网络：[http://dockr.ly/2ETjy2x](http://dockr.ly/2ETjy2x)
- en: Networking using the host network: [http://dockr.ly/2F4aI59](http://dockr.ly/2F4aI59)
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用主机网络进行网络连接：[http://dockr.ly/2F4aI59](http://dockr.ly/2F4aI59)
