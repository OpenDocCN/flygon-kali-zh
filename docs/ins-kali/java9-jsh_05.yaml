- en: Chapter 5. Mutable and Immutable Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。可变和不可变类
- en: 'In this chapter, we will learn about mutable and immutable classes. We will
    understand their differences and their advantages and disadvantages when building
    object-oriented code. We will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习可变和不可变类。我们将了解它们在构建面向对象代码时的区别、优势和劣势。我们将：
- en: Create mutable classes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可变类
- en: Work with mutable objects in JShell
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JShell中使用可变对象
- en: Build immutable classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建不可变类
- en: Work with immutable objects in JShell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JShell中使用不可变对象
- en: Understand the difference between mutating and non-mutating objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解可变和不可变对象之间的区别
- en: Learn the advantages of non-mutating objects when writing concurrent code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习在编写并发代码时不可变对象的优势
- en: Work with instances of the immutable `String` class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不可变`String`类的实例
- en: Creating mutable classes in Java 9
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java 9中创建可变类
- en: When we declare instance fields without the `final` keyword, we create a mutable
    instance field, which means that we can change their values for each new instance
    we create after the field is initialized. When we create an instance of a class
    that defines at least one mutable field, we create a mutable object, which is
    an object that can change its state after its initialization.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明实例字段时没有使用`final`关键字时，我们创建了一个可变的实例字段，这意味着我们可以在字段初始化后为每个新创建的实例更改它们的值。当我们创建一个定义了至少一个可变字段的类的实例时，我们创建了一个可变对象，这是一个在初始化后可以改变其状态的对象。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A mutable object is also known as a mutating object.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 可变对象也称为可变对象。
- en: 'For example, imagine that we have to develop a Web Service that renders elements
    in the 3D world and returns a high-resolution rendered scene. Such a task requires
    us to work with 3D vectors. First, we will work with a mutable 3D vector with
    three mutable fields: `x`, `y`, and `z`. The mutable 3D vector must provide the
    following features:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们必须开发一个Web服务，渲染3D世界中的元素并返回高分辨率的渲染场景。这样的任务要求我们使用3D向量。首先，我们将使用一个可变的3D向量，其中有三个可变字段：`x`、`y`和`z`。可变的3D向量必须提供以下功能：
- en: 'Three mutable instance fields of type `double`: `x`, `y`, and `z`.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个`double`类型的可变实例字段：`x`、`y`和`z`。
- en: A constructor that creates an instance by providing the initial values for the
    `x`, `y`, and `z` fields.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构造函数，通过提供`x`、`y`和`z`字段的初始值来创建一个实例。
- en: A constructor that creates an instance with all the values initialized to `0`,
    that is, `x = 0`, `y = 0`, and `z = 0`. A 3D vector with these values is known
    as an **origin vector**.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构造函数，创建一个所有值都初始化为`0`的实例，即`x=0`、`y=0`和`z=0`。具有这些值的3D向量称为**原点向量**。
- en: A constructor that creates an instance with all the values initialized to a
    common value. For example, if we specify `3.0` as the common value, the constructor
    must generate an instance with `x = 3.0`, `y = 3.0`, and `z = 3.0`.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构造函数，创建一个所有值都初始化为一个公共值的实例。例如，如果我们指定`3.0`作为公共值，构造函数必须生成一个`x=3.0`、`y=3.0`和`z=3.0`的实例。
- en: An `absolute` method that sets each component of the 3D vector to its absolute
    value.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`absolute`方法，将3D向量的每个分量设置为其绝对值。
- en: A `negate` method that negates each component of the 3D vector in place.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`negate`方法，就地否定3D向量的每个分量。
- en: An `add` method that sets the value of the 3D vector to the sum of itself and
    the 3D vector received as an argument.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`add`方法，将3D向量的值设置为其自身与作为参数接收的3D向量的和。
- en: A `sub` method that sets the value of the 3D vector to the difference of itself
    and the 3D vector received as an argument.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`sub`方法，将3D向量的值设置为其自身与作为参数接收的3D向量的差。
- en: 'An implementation of the `toString` method that prints the values of the three
    components of the 3D vector: `x`, `y`, and `z`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toString`方法的实现，打印3D向量的三个分量的值：`x`、`y`和`z`。'
- en: The following lines declare the `Vector3d` class that represents the mutable
    version of a 3D vector in Java. The code file for the sample is included in the
    `java_9_oop_chapter_05_01` folder, in the `example05_01.java` file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`Vector3d`类，表示Java中3D向量的可变版本。示例的代码文件包含在`java_9_oop_chapter_05_01`文件夹中的`example05_01.java`文件中。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The new `Vector3d` class declares three constructors whose lines are highlighted
    in the previous code listing. The first constructor receives three `double` arguments,
    `x`, `y`, and `z`, and initializes the fields with the same names and types with
    the values received in these arguments.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`Vector3d`类声明了三个构造函数，它们的行在前面的代码列表中突出显示。第一个构造函数接收三个`double`参数`x`、`y`和`z`，并使用这些参数中接收的值初始化具有相同名称和类型的字段。
- en: The second constructor receives a single `double` argument, `valueForXYZ`, and
    uses the `this` keyword to call the previously explained constructor with the
    received argument as the value for the three arguments.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个构造函数接收一个`double`参数`valueForXYZ`，并使用`this`关键字调用先前解释的构造函数，将接收的参数作为三个参数的值。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We can use the `this` keyword within a constructor to call other constructors
    with different arguments defined in our class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在构造函数中使用`this`关键字来调用类中定义的具有不同参数的其他构造函数。
- en: The third constructor is a parameterless one and uses the `this` keyword to
    call the previously explained constructor with `0.0` as the value for the `valueForXYZ`
    argument. This way, the constructor allows us to build an origin vector.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个构造函数是一个无参数的构造函数，并使用`this`关键字调用先前解释的构造函数，将`0.0`作为`valueForXYZ`参数的值。这样，构造函数允许我们构建一个原点向量。
- en: Whenever we call the `absolute`, `negate`, `add`, or `sub` methods, we will
    mutate the instance, that is, we will change the state for the object. These methods
    change the values for the `x`, `y`, and `z` fields for the instance from which
    we call them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们调用`absolute`、`negate`、`add`或`sub`方法时，我们将改变实例的状态，也就是说，我们将改变对象的状态。这些方法改变了我们调用它们的实例的`x`、`y`和`z`字段的值。
- en: Working with mutable objects in JShell
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JShell中使用可变对象
- en: The following lines create a new `Vector3d` instance named `vector1` with `10.0`,
    `20.0`, and `30.0` for the initial values of `x`, `y`, and `z`. The second lines
    create a new `Vector3d` instance named `vector2` with `1.0`, `2.0`, and `3.0`
    for the initial values of `x`, `y`, and `z`. Then, the code calls the `System.out.println`
    method with `vector1` and then with `vector2` as an argument. Both calls to the
    `println` method will execute the `toString` method for each `Vector3d` instance
    to display the `String` representation of the mutable 3D vector. Then, the code
    calls the `add` method for `vector1` with `vector2` as an argument. The last line
    calls the `println` method again with `vector1` as an argument to print the new
    values of `x`, `y` and `z` after the object mutated with the call to the `add`
    method. The code file for the sample is included in the `java_9_oop_chapter_05_01`
    folder, in the `example05_01.java` file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行创建了一个名为`vector1`的新`Vector3d`实例，其初始值为`x`、`y`和`z`的`10.0`、`20.0`和`30.0`。第二行创建了一个名为`vector2`的新`Vector3d`实例，其初始值为`x`、`y`和`z`的`1.0`、`2.0`和`3.0`。然后，代码调用`System.out.println`方法，参数分别为`vector1`和`vector2`。对`println`方法的两次调用将执行每个`Vector3d`实例的`toString`方法，以显示可变3D向量的`String`表示。然后，代码使用`vector2`作为参数调用`vector1`的`add`方法。最后一行再次调用`println`方法，参数为`vector1`，以打印调用`add`方法后`x`、`y`和`z`的新值。示例的代码文件包含在`java_9_oop_chapter_05_01`文件夹中的`example05_01.java`文件中。
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在JShell中执行上述代码的结果：
- en: '![Working with mutable objects in JShell](img/00055.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![在JShell中使用可变对象](img/00055.jpeg)'
- en: 'The initial values for the `vector1` fields are `10.0` for `x`, `20.0` for
    `y`, and `30.0` for `z`. The `add` method changes the values of the three fields.
    Hence, the object state mutates as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector1`字段的初始值分别为`10.0`、`20.0`和`30.0`。`add`方法改变了三个字段的值。因此，对象状态发生了变化：'
- en: '`vector1.x` mutates from `10.0` to *10.0 + 1.0 = 11.0*'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector1.x`从`10.0`变为*10.0 + 1.0 = 11.0*'
- en: '`vector1.y` mutates from `20.0` to *20.0 + 2.0 = 22.0*'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector1.y`从`20.0`变为*20.0 + 2.0 = 22.0*'
- en: '`vector1.z` mutates from `30.0` to *30.0 + 3.0 = 33.0*'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector1.z`从`30.0`变为*30.0 + 3.0 = 33.0*'
- en: The values for the `vector1` fields after the call to the `add` method are `11.0`
    for `x`, `22.0` for `y`, and `33.0` for `z`. We can say that the method mutated
    the object's state. Thus, `vector1` is a mutable object and an instance of a mutable
    class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`add`方法后，`vector1`字段的值为`11.0`、`22.0`和`33.0`。我们可以说该方法改变了对象的状态。因此，`vector1`是一个可变对象，是可变类的一个实例。
- en: The following lines use the three available constructors to create three instances
    of the `Vector3d` class named `vector3`, `vector4`, and `vector5`. Then, the next
    lines call the `System.out.println` method to print the values of `x`, `y`, and
    `z` after the objects were created. The code file for the sample is included in
    the `java_9_oop_chapter_05_01` folder, in the `example05_02.java` file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行使用三个可用的构造函数创建了`Vector3d`类的三个实例，分别命名为`vector3`、`vector4`和`vector5`。然后，下一行调用`System.out.println`方法，以打印对象创建后的`x`、`y`和`z`的值。示例的代码文件包含在`java_9_oop_chapter_05_01`文件夹中的`example05_02.java`文件中。
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在JShell中执行上述代码的结果：
- en: '![Working with mutable objects in JShell](img/00056.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![在JShell中使用可变对象](img/00056.jpeg)'
- en: The next lines call many methods for the previously created instances. The code
    file for the sample is included in the `java_9_oop_chapter_05_01` folder, in the
    `example05_02.java` file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的行调用了先前创建的实例的许多方法。示例的代码文件包含在`java_9_oop_chapter_05_01`文件夹中的`example05_02.java`文件中。
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The initial value for the three `vector4` fields (`x`, `y`, and `z`) is `5.0`.
    The call to the `vector4.negate` method changes the values of the three fields
    to `-5.0`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector4`字段的初始值为`5.0`。对`vector4.negate`方法的调用将三个字段的值改变为`-5.0`。'
- en: 'The initial value for the three `vector3` fields (`x`, `y`, and `z`) is `0.0`.
    The call to the `vector3.add` method changes the values of the three fields by
    the results of the sum of each component of `vector3` and `vector4`. Hence, the
    object state mutates as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 三个`vector3`字段（`x`、`y`和`z`）的初始值为`0.0`。对`vector3.add`方法的调用通过`vector3`和`vector4`的每个分量的和的结果改变了三个字段的值。因此，对象状态发生了变化：
- en: '`vector3.x` mutates from `0.0` to *0.0 + (-5.0) = -5.0*'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector3.x`从`0.0`变为*0.0 + (-5.0) = -5.0*'
- en: '`vector3.y` mutates from `0.0` to *0.0 + (-5.0) = -5.0*'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector3.y`从`0.0`变为*0.0 + (-5.0) = -5.0*'
- en: '`vector3.z` mutates from `0.0` to *0.0 + (-5.0) = -5.0*'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector3.z`从`0.0`变为*0.0 + (-5.0) = -5.0*'
- en: The three fields for `vector3` fields are set to `-5.0` after the call to the
    `add` method. The call to the `vector4.absolute` method changes the values of
    the three fields from `-5.0` to `5.0`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector3`字段在调用`add`方法后被设置为`-5.0`。对`vector4.absolute`方法的调用将三个字段的值从`-5.0`改变为`5.0`。'
- en: 'The initial values for the `vector5` fields are `-15.5` for `x`, `-11.1` for
    `y`, and `-8.8` for `z`. The call to the `vector5.sub` method changes the values
    of the three fields by the results of the subtraction of each component of `vector5`
    and `vector4`. Hence, the object state mutates as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector5`字段的初始值分别为`-15.5`、`-11.1`和`-8.8`。对`vector5.sub`方法的调用通过`vector5`和`vector4`的每个分量的减法结果改变了三个字段的值。因此，对象状态发生了变化：'
- en: '`vector5.x` mutates from `-15.5` to *-15.5 - 5.0 = -20.5*'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector5.x`从`-15.5`变为*-15.5 - 5.0 = -20.5*'
- en: '`vector5.y` mutates from `-11.1` to *-11.1 - 5.0 = -16.1*'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector5.y`从`-11.1`变为*-11.1 - 5.0 = -16.1*'
- en: '`vector5.z` mutates from `-8.8` to *-8.8 - 5.0 = -13.8*'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector5.z`从`-8.8`变为*-8.8 - 5.0 = -13.8*'
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在JShell中执行上述代码的结果：
- en: '![Working with mutable objects in JShell](img/00057.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![在JShell中使用可变对象](img/00057.jpeg)'
- en: Building immutable classes in Java 9
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java 9中构建不可变类
- en: So far, we have been working with mutable classes and mutating objects. Whenever
    we expose mutable fields, we create a class that will generate mutable instances.
    In certain scenarios, we might prefer an object that cannot change its state after
    it has been initialized. We can design classes to be immutable and to generate
    immutable instances that cannot change their state after they were created and
    initialized.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用可变类和变异对象。每当我们暴露可变字段时，我们都会创建一个将生成可变实例的类。在某些情况下，我们可能更喜欢一个对象，在初始化后无法更改其状态。我们可以设计类为不可变，并生成不可更改的实例，这些实例在创建和初始化后无法更改其状态。
- en: A typical scenario where immutable objects are extremely useful is when we work
    with concurrent code. Objects that cannot change their state solve many typical
    concurrency problems and avoid potential bugs that might be difficult to detect
    and solve. Because immutable objects cannot change their state, it is not possible
    to end up with an object with a corrupted or inconsistent state when many different
    threads modify it without the appropriate synchronization mechanisms.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象非常有用的一个典型场景是在处理并发代码时。不能更改其状态的对象解决了许多典型的并发问题，并避免了可能难以检测和解决的潜在错误。因为不可变对象不能更改其状态，所以在许多不同的线程修改它时，不可能出现对象处于损坏或不一致状态的情况，而没有适当的同步机制。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An immutable object is also known as a non-mutating object.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象也被称为不可变对象。
- en: 'We will create an immutable version of the previously coded `Vector3d` class
    to represent an immutable 3D vector. This way, we will notice the difference between
    a mutable class and its immutable version. The immutable 3D vector must provide
    the following features:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个不可变版本的先前编码的`Vector3d`类，以表示不可变的3D向量。这样，我们将注意到可变类和其不可变版本之间的区别。不可变的3D向量必须提供以下功能：
- en: 'Three immutable instance fields of type `double`: `x`, `y`, and `z`. The value
    for these fields cannot be changed after the instance is initialized or constructed.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个`double`类型的不可变实例字段：`x`、`y`和`z`。这些字段的值在实例初始化或构造后不能更改。
- en: A constructor that creates an instance by providing the initial values for the
    `x`, `y`, and `z` immutable fields.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过为`x`、`y`和`z`不可变字段提供初始值来创建实例的构造函数。
- en: A constructor that creates an instance with all the values set to `0`, that
    is, `x = 0`, `y = 0`, and `z = 0`.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构造函数，创建一个所有值都设置为`0`的实例，即`x = 0`、`y = 0`和`z = 0`。
- en: A constructor that creates an instance with all the values initialized to a
    common value. For example, if we specify `3.0` as the common value, the constructor
    must generate an immutable instance with `x = 3.0`, `y = 3.0`, and `z = 3.0`.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构造函数，创建一个所有值都初始化为公共值的实例。例如，如果我们指定`3.0`作为公共值，构造函数必须生成一个不可变实例，其中`x = 3.0`、`y
    = 3.0`和`z = 3.0`。
- en: An `absolute` method that returns a new instance with each component of the
    new immutable 3D vector set to the absolute value of each component of the instance
    in which we call the method.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`absolute`方法，返回一个新实例，其中调用该方法的实例的每个分量的绝对值设置为该实例的每个分量的绝对值。
- en: A `negate` method that returns a new instance with each component of the new
    immutable 3D vector set to the negated value of each component of the instance
    in which we call the method.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`negate`方法，返回一个新实例，其中调用该方法的实例的每个分量的值设置为该方法的每个分量的否定值。
- en: An `add` method that returns a new instance with each component of the new immutable
    3D vector set to the sum of each component of the instance in which we call the
    method and each component of the immutable 3D vector received as an argument.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`add`方法，返回一个新实例，其中调用该方法的实例的每个分量设置为该方法和作为参数接收的不可变3D向量的每个分量的和。
- en: A `sub` method that returns a new instance with each component of the new immutable
    3D vector set to the subtraction of each component of the instance in which we
    call the method and each component of the immutable 3D vector received as an argument.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`sub`方法，返回一个新实例，其中调用该方法的实例的每个分量设置为该方法和作为参数接收的不可变3D向量的每个分量的差。
- en: 'An implementation of the `toString` method that prints the values of the three
    components of the 3D vector: `x`, `y`, and `z`.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toString`方法的实现，打印3D向量的三个分量的值：`x`、`y`和`z`。'
- en: The following lines declare the `ImmutableVector3d` class that represents the
    immutable version of a 3D vector in Java. The code file for the sample is included
    in the `java_9_oop_chapter_05_01` folder, in the `example05_03.java` file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`ImmutableVector3d`类，该类表示Java中3D向量的不可变版本。示例的代码文件包含在`java_9_oop_chapter_05_01`文件夹中的`example05_03.java`文件中。
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The new `ImmutableVector3d` class declares three immutable instance fields
    by using the `final` keyword: `x`, `y`, and `z`. The lines for the three constructors
    declared for this class are highlighted in the previous code listing. These constructors
    have the same code that we analyzed for the `Vector3d` class. The only difference
    is in the execution, because the constructors are initializing immutable instance
    fields that won''t change their values after the initialization.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`ImmutableVector3d`类通过使用`final`关键字声明了三个不可变实例字段：`x`、`y`和`z`。在此类声明的三个构造函数的行在前面的代码列表中突出显示。这些构造函数具有我们为`Vector3d`类分析的相同代码。唯一的区别在于执行，因为构造函数正在初始化不可变实例字段，这些字段在初始化后不会更改其值。
- en: Whenever we call the `absolute`, `negate`, `add`, or `sub` methods, their code
    will return a new instance of the `ImmutableVector3d` class with the result of
    each operation. We will never mutate our instance; that is, we won't change the
    state for the object.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们调用`absolute`、`negate`、`add`或`sub`方法时，它们的代码将返回`ImmutableVector3d`类的新实例，其中包含每个操作的结果。我们永远不会改变我们的实例；也就是说，我们不会改变对象的状态。
- en: Working with immutable objects in JShell
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JShell中使用不可变对象
- en: The following lines create a new `ImmutableVector3d` instance named `vector10`
    with `100.0`, `200.0`, and `300.0` for the initial values of `x`, `y`, and `z`.
    The second lines create a new `ImmutableVector3d` instance named `vector20` with
    `11.0`, `12.0`, and `13.0` for the initial values of `x`, `y`, and `z`. Then,
    the code calls the `System.out.println` method with `vector10` and then with `vector20`
    as an argument. Both calls to the `println` method will execute the `toString`
    method for each `ImmutableVector3d` instance to display the `String` representation
    of the immutable 3D vector. Then, the code calls the `add` method for `vector10`
    with `vector20` as an argument and saves the returned `ImmutableVector3d` instance
    in `vector30`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行创建了一个名为`vector10`的新`ImmutableVector3d`实例，其`x`、`y`和`z`的初始值分别为`100.0`、`200.0`和`300.0`。第二行创建了一个名为`vector20`的新`ImmutableVector3d`实例，其`x`、`y`和`z`的初始值分别为`11.0`、`12.0`和`13.0`。然后，代码分别使用`vector10`和`vector20`作为参数调用`System.out.println`方法。对`println`方法的两次调用将执行每个`ImmutableVector3d`实例的`toString`方法，以显示不可变3D向量的`String`表示。然后，代码使用`vector10`和`vector20`作为参数调用`add`方法，并将返回的`ImmutableVector3d`实例保存在`vector30`中。
- en: The last line calls the `println` method with `vector30` as an argument to print
    the values of `x`, `y`, and `z` for this instance that has the results of the
    addition operation between `vector10` and `vector20`. Enter the lines after the
    code that declares the `ImmutableVector3d` class. The code file for the sample
    is included in the `java_9_oop_chapter_05_01` folder, in the `example05_03.java`
    file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行使用`vector30`作为参数调用`println`方法，以打印此实例的`x`、`y`和`z`的值，该实例包含了`vector10`和`vector20`之间的加法操作的结果。在声明`ImmutableVector3d`类的代码之后输入这些行。示例的代码文件包含在`java_9_oop_chapter_05_01`文件夹中的`example05_03.java`文件中。
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在JShell中执行先前代码的结果：
- en: '![Working with immutable objects in JShell](img/00058.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![在JShell中使用不可变对象](img/00058.jpeg)'
- en: As a result of the `add` method, we have another immutable instance named `vector30`
    whose field values are `111.0` for `x`, `212.0` for `y`, and `313.0` for `z`.
    As a result of calling each method that computes an operation, we will have another
    immutable instance.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`add`方法的结果，我们有另一个名为`vector30`的不可变实例，其字段值为`111.0`（`x`）、`212.0`（`y`）和`313.0`（`z`）。调用每个计算操作的方法的结果，我们将得到另一个不可变实例。
- en: The following lines use the three available constructors to create three instances
    of the `ImmutableVector3d` class named `vector40`, `vector50`, and `vector60`.
    Then, the next lines call the `System.out.println` method to print the values
    of `x`, `y`, and `z` after the objects were created. The code file for the sample
    is included in the `java_9_oop_chapter_05_01` folder, in the `example05_03.java`
    file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行使用三个可用的构造函数创建了`ImmutableVector3d`类的三个实例，分别命名为`vector40`、`vector50`和`vector60`。然后，下一行调用`System.out.println`方法，以打印对象创建后`x`、`y`和`z`的值。示例的代码文件包含在`java_9_oop_chapter_05_01`文件夹中的`example05_03.java`文件中。
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在JShell中执行先前代码的结果：
- en: '![Working with immutable objects in JShell](img/00059.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![在JShell中使用不可变对象](img/00059.jpeg)'
- en: The next lines call many methods for the previously created instances and generate
    new instances of the `ImmutableVector3d` class. The code file for the sample is
    included in the `java_9_oop_chapter_05_01` folder, in the `example05_03.java`
    file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行调用了先前创建实例的许多方法，并生成了`ImmutableVector3d`类的新实例。示例的代码文件包含在`java_9_oop_chapter_05_01`文件夹中的`example05_03.java`文件中。
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The initial value for the three `vector50` fields (`x`, `y`, and `z`) is `-5.0`.
    The call to the `vector50.negate` method returns a new `ImmutableVector3d` instance
    that the code saves in `vector70`. The new instance has `5.0` as the value for
    the three fields (`x`, `y`, and `z`).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector50`字段（`x`、`y`和`z`）的初始值为`-5.0`。对`vector50.negate`方法的调用返回一个新的`ImmutableVector3d`实例，代码将其保存在`vector70`中。新实例的三个字段（`x`、`y`和`z）的值为`5.0`。'
- en: The initial value for the three `vector40` fields (`x`, `y`, and `z`) is `0`.
    The call to the `vector40.add` method, with `vector70` as an argument, returns
    a new `ImmutableVector3d` instance that the code saves in `vector80`. The new
    instance has `5.0` as the value for the three fields (`x`, `y`, and `z`).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector40`字段（`x`、`y`和`z`）的初始值为`0`。对`vector40.add`方法使用`vector70`作为参数的调用返回一个新的`ImmutableVector3d`实例，代码将其保存在`vector80`中。新实例的三个字段（`x`、`y`和`z`）的值为`5.0`。'
- en: The call to the `vector70.absolute` method returns a new `ImmutableVector3d`
    instance that the code saves in `vector90`. The new instance has `5.0` as the
    value for the three fields (`x`, `y`, and `z`). The absolute values for the fields
    were the same as the original values, but the code still generated a new instance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对`vector70.absolute`方法的调用返回一个新的`ImmutableVector3d`实例，代码将其保存在`vector90`中。新实例的三个字段（`x`、`y`和`z`）的值为`5.0`。字段的绝对值与原始值相同，但代码仍然生成了一个新实例。
- en: The initial values for the `vector60` fields are `8.0` for `x`, `9.0` for `y`,
    and `10.0` for `z`. The call to the `vector60.sub` method with `vector90` as an
    argument returns a new `ImmutableVector3d` instance that the code saves in `vector100`.
    The values for the `vector100` fields are `3.0` for `x`, `4.0` for `y`, and `5.0`
    for `z`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector60`字段的初始值分别为`8.0`（`x`）、`9.0`（`y`）和`10.0`（`z`）。对`vector60.sub`方法使用`vector90`作为参数的调用返回一个新的`ImmutableVector3d`实例，代码将其保存在`vector100`中。`vector100`字段的值分别为`3.0`（`x`）、`4.0`（`y`）和`5.0`（`z`）。'
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在JShell中执行先前代码的结果：
- en: '![Working with immutable objects in JShell](img/00060.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![在JShell中使用不可变对象](img/00060.jpeg)'
- en: Understanding the differences between mutating and non-mutating objects
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解可变和不可变对象之间的区别
- en: The immutable version adds an overhead compared with the mutable version because
    it is necessary to create a new instance of the class as a result of calling the
    `absolute`, `negate`, `add`, or `sub` methods. The previously analyzed mutable
    class named `Vector3D` just changed the values for the fields, and it wasn't necessary
    to generate a new instance. Hence, the memory footprint for the immutable version
    is higher than the mutable version.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与可变版本相比，不可变版本增加了开销，因为调用`absolute`、`negate`、`add`或`sub`方法时需要创建类的新实例。先前分析过的可变类`Vector3D`只是改变了字段的值，不需要生成新实例。因此，不可变版本的内存占用量高于可变版本。
- en: The immutable class named `ImmutableVector3d` has both a memory and performance
    overhead compared with the mutable version. It is more expensive to create a new
    instance than to change the values of a few fields. However, as previously explained,
    when we work with concurrent code, it makes sense to pay for the extra overhead
    to avoid potential issues caused by mutable objects. We just have to make sure
    we analyze the advantages and tradeoffs in order to decide which is the most convenient
    way to code our specific classes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与可变版本相比，名为`ImmutableVector3d`的不可变类在内存和性能方面都有额外的开销。创建新实例比改变少数字段的值更昂贵。然而，正如先前解释的那样，当我们使用并发代码时，为了避免可变对象可能引起的问题，为额外的开销付费是有意义的。我们只需要确保分析优势和权衡，以决定哪种方式是编写特定类最方便的方式。
- en: Now, we will write a few lines that work with the mutable version and we will
    generate the equivalent code for the immutable version. This way, we will be able
    to make a simple yet illustrative comparison of the differences between the two
    pieces of code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一些使用可变版本的代码，并生成不可变版本的等效代码。这样，我们就能够简单而生动地比较这两段代码之间的区别。
- en: The following lines create a new `Vector3d` instance named `mutableVector3d1`
    with `-30.5`, `-15.5`, and `-12.5` for the initial values of `x`, `y`, and `z`.
    Then, the code prints the `String` representation for the new instance, calls
    the `absolute` method, and prints the `String` representation of the mutated object.
    The code file for the sample is included in the `java_9_oop_chapter_05_01` folder,
    in the `example05_04.java` file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行创建了一个名为`mutableVector3d1`的新的`Vector3d`实例，初始值为`x`、`y`和`z`的值分别为`-30.5`、`-15.5`和`-12.5`。然后，代码打印了新实例的`String`表示形式，调用了`absolute`方法，并打印了变异对象的`String`表示形式。示例的代码文件包含在`java_9_oop_chapter_05_01`文件夹中的`example05_04.java`文件中。
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在JShell中执行先前代码的结果：
- en: '![Understanding the differences between mutating and non-mutating objects](img/00061.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![理解可变和不可变对象之间的区别](img/00061.jpeg)'
- en: The following lines create a new `ImmutableVector3d` instance named `immutableVector3d1`
    with `-30.5`, `-15.5`, and `-12.5` for the initial values of `x`, `y`, and `z`.
    Then, the code prints the `String` representation for the new instance, calls
    the `absolute` method that generates a new `ImmutableVector3d` instance named
    `immutableVector3d2`, and prints the `String` representation of the new object.
    The code file for the sample is included in the `java_9_oop_chapter_05_01` folder,
    in the `example05_04.java` file.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行创建了一个名为`immutableVector3d1`的新的`ImmutableVector3d`实例，初始值为`x`、`y`和`z`的值分别为`-30.5`、`-15.5`和`-12.5`。然后，代码打印了新实例的`String`表示形式，调用了`absolute`方法生成了一个名为`immutableVector3d2`的新的`ImmutableVector3d`实例，并打印了新对象的`String`表示形式。示例的代码文件包含在`java_9_oop_chapter_05_01`文件夹中的`example05_04.java`文件中。
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在JShell中执行先前代码的结果：
- en: '![Understanding the differences between mutating and non-mutating objects](img/00062.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![理解可变和不可变对象之间的区别](img/00062.jpeg)'
- en: The mutable version works with a single `Vector3d` instance. The constructor
    for the `Vector3d` class is executed only once. The original instance mutates
    its state when we called the `absolute` method.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可变版本使用单个`Vector3d`实例。`Vector3d`类的构造函数只执行一次。当调用`absolute`方法时，原始实例会改变其状态。
- en: The immutable version works with two `ImmutableVector3d` instances, and therefore,
    the memory footprint is higher than the mutable version. The constructor for the
    `ImmutableVector3d` class is executed twice. The first instance didn't mutate
    its state when we called the `absolute` method.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变版本使用两个`ImmutableVector3d`实例，因此内存占用量高于可变版本。`ImmutableVector3d`类的构造函数被执行了两次。第一个实例在调用`absolute`方法时没有改变其状态。
- en: Learning the advantages of non-mutating objects when writing concurrent code
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习在编写并发代码时不可变对象的优势
- en: Now, let's imagine we are writing concurrent code that has to access the fields
    of the previously created instances. First, we will analyze the problems with
    the mutable version and then we will understand the advantage of working with
    the non-mutating object.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想象我们正在编写必须访问先前创建实例的字段的并发代码。首先，我们将分析可变版本的问题，然后我们将了解使用不可变对象的优势。
- en: Imagine that we have two threads in which the code has a reference to the instance
    saved in `mutableVector3d1`. The first thread calls the `absolute` method for
    this mutating object. The first line of code for the `absolute` method assigns
    the result of `Math.abs` with the actual value of `x` as an argument to the `x`
    mutable field.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个线程，代码中引用了保存在`mutableVector3d1`中的实例。第一个线程调用这个可变对象的`absolute`方法。`absolute`方法的第一行代码将`Math.abs`的结果作为参数赋给`x`可变字段的实际值。
- en: At this point, the method didn't finish its execution and the next line of code
    won't be able to access the values. However, concurrent code running in another
    thread that has a reference to this instance might access the values for the `x`,
    `y` and `z` fields before the `absolute` method finishes the execution. The object
    is in a corrupt state because the values for the fields are `30.5` for `x`, `-15.5`
    for `y`, and `-12.5` for `z`. These values do not represent the 3D vector that
    we will have when the `absolute` method finishes its execution. The fact that
    there are many pieces of code running concurrently and have access to the same
    instance without any kind of synchronization mechanism generates the issue.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，方法还没有完成执行，下一行代码将无法访问这些值。然而，在另一个线程中运行的并发代码可能会在`absolute`方法完成执行之前访问`x`、`y`和`z`字段的值。对象处于损坏状态，因为`x`字段的值为`30.5`，`y`字段的值为`-15.5`，`z`字段的值为`-12.5`。这些值不代表`absolute`方法执行完成后我们将拥有的3D向量。并发运行的代码片段并且可以访问相同实例而没有任何同步机制，这会产生问题。
- en: Concurrent programming and threaded programming are complex topics that deserve
    an entire book. There are synchronization mechanisms to avoid the previously mentioned
    issue and make the class thread-safe. However, another solution is the usage of
    immutable classes that generate non-mutating objects.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程和线程编程是复杂的主题，值得一整本书来讨论。有同步机制可以避免前面提到的问题，并使类成为线程安全的。然而，另一个解决方案是使用生成不可变对象的不可变类。
- en: If we use the immutable version, the two threads can have the reference to the
    same initial instance. However, when one of the threads calls the `absolute` method,
    the original 3D vector won't mutate, and therefore the previous problem will never
    happen. The other thread will continue working with its reference to the original
    3D vector, with its original state. The thread that called the `absolute` method
    will generate a new instance that is completely independent of the original one.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用不可变版本，两个线程可以引用相同的初始实例。然而，当其中一个线程调用`absolute`方法时，原始的3D向量不会发生变化，因此之前的问题永远不会发生。另一个线程将继续使用对原始3D向量的引用，保持其原始状态。调用`absolute`方法的线程将生成一个完全独立于原始实例的新实例。
- en: Again, it is very important to understand that this topic deserves an entire
    book. However, it is important to understand why immutable classes might be a
    special requirement in specific scenarios where the instance will participate
    in concurrent code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，理解这个主题需要一整本书。然而，了解为什么不可变类可能在实例将参与并发代码的特定场景中是一个特殊要求是很重要的。
- en: Working with instances of the immutable String class
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不可变String类的实例
- en: The `String` class, specifically the `java.lang.String` class, represents character
    strings and is an immutable class that generates non-mutating objects. Hence,
    the methods provided by the `String` class do not mutate the object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`类，特别是`java.lang.String`类，表示字符字符串，是一个生成不可变对象的不可变类。因此，`String`类提供的方法不会改变对象。'
- en: For example, the following lines create a new `String`, that is, a new instance
    of the `java.lang.String` class named `welcomeMessage` with an initial value of
    `"Welcome to Virtual Creatures Land"`. Then, the code makes many calls to `System.out.println`
    with `welcomeMessage` followed by a different method as an argument. First, we
    call the `toUpperCase` method to generate a new `String` with all the characters
    converted to uppercase. Then, we call the `toLowerCase` method to generate a new
    `String` with all the characters converted to lowercase. Then, we call the `replaceAll`
    method to generate a new `String` in which the spaces were replaced by a hyphen
    (`-`). Finally, we call the `System.out.println` method again with `welcomeMessage`
    as an argument to check the value of the original `String`. The code file for
    the sample is included in the `java_9_oop_chapter_05_01` folder, in the `example05_05.java`
    file.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下行创建了一个新的`String`，也就是`java.lang.String`类的一个新实例，名为`welcomeMessage`，初始值为`"Welcome
    to Virtual Creatures Land"`。然后，代码对`welcomeMessage`进行了多次调用`System.out.println`，并将不同的方法作为参数。首先，我们调用`toUpperCase`方法生成一个所有字符都转换为大写的新`String`。然后，我们调用`toLowerCase`方法生成一个所有字符都转换为小写的新`String`。然后，我们调用`replaceAll`方法生成一个将空格替换为连字符（`-`）的新`String`。最后，我们再次调用`System.out.println`方法，并将`welcomeMessage`作为参数，以检查原始`String`的值。示例的代码文件包含在`java_9_oop_chapter_05_01`文件夹中的`example05_05.java`文件中。
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在JShell中执行前面代码的结果：
- en: '![Working with instances of the immutable String class](img/00063.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![使用不可变String类的实例](img/00063.jpeg)'
- en: The `welcomeMessage` string never changed its value. The calls to the `toUpperCase`,
    `toLowerCase`, and `replaceAll` methods generated and returned a new `String`
    instance for each of them.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`welcomeMessage`字符串从未改变其值。对`toUpperCase`、`toLowerCase`和`replaceAll`方法的调用为每个方法生成并返回了一个新的`String`实例。'
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: No matter which method we call for a `String` instance, it won't mutate the
    object. Thus, we can say `String` is an immutable class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们为`String`实例调用哪个方法，它都不会改变对象。因此，我们可以说`String`是一个不可变类。
- en: Creating the immutable version of an existing mutable class
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建现有可变类的不可变版本
- en: In the previous chapter, we created a mutable class named `VirtualCreature`.
    We provided setter methods to change the values for the `hat`, `visibilityLevel`,
    and `birthYear` fields. We were able to change the `birthYear` by calling the
    `setAge` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个名为`VirtualCreature`的可变类。我们提供了setter方法来改变`hat`、`visibilityLevel`和`birthYear`字段的值。我们可以通过调用`setAge`方法来改变`birthYear`。
- en: Virtual creatures change their age, hat, and visibility level after they evolve.
    When they evolve, they become a different creature, and therefore, it would make
    sense to generate a new instance after this evolution happens. Thus, we will create
    the immutable version of the `VirtualCreature` class and we will call it `ImmutableVirtualCreature`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟生物在进化后会改变它们的年龄、帽子和可见性级别。当它们进化时，它们会变成不同的生物，因此在这种进化发生后生成一个新实例是有意义的。因此，我们将创建`VirtualCreature`类的不可变版本，并将其称为`ImmutableVirtualCreature`。
- en: The following lines show the code for the new `ImmutableVirtualCreature` class.
    The code file for the sample is included in the `java_9_oop_chapter_05_01` folder,
    in the `example05_06.java` file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了新`ImmutableVirtualCreature`类的代码。示例的代码文件包含在`java_9_oop_chapter_05_01`文件夹中的`example05_06.java`文件中。
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `ImmutableVirtualCreature` class declares four public immutable instance
    fields with the `final` keyword: `name`, `birthYear`, `hat`, and `visibilityLevel`.
    We won''t be able to change the values for any of these fields after the instance
    has been initialized or constructed.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImmutableVirtualCreature`类使用`final`关键字声明了四个公共不可变实例字段：`name`、`birthYear`、`hat`和`visibilityLevel`。在实例被初始化或构造后，我们将无法更改这些字段的任何值。'
- en: The constructor generates an uppercased `String` from the `String` received
    in the `hat` argument and stores it in the public `hat` immutable field. We had
    a specific validation for the visibility level, and therefore, the constructor
    calls a new private method named `getValidVisibilityLevel,` with the value received
    in the `visibilityLevel` argument, to assign a valid value to the immutable field
    with the same name.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数从`hat`参数中接收的`String`生成大写的`String`并将其存储在公共的不可变字段`hat`中。我们对可见性级别有特定的验证，因此构造函数调用一个名为`getValidVisibilityLevel`的新私有方法，该方法使用`visibilityLevel`参数中接收的值来为具有相同名称的不可变字段分配一个有效值。
- en: 'We don''t have setter methods anymore because we aren''t able to change the
    values for the immutable fields after they were initialized. The class declares
    the following two new public methods that return a new `ImmutableVirtualCreature`
    instance:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再有setter方法，因为在初始化后我们无法更改不可变字段的值。该类声明了以下两个新的公共方法，它们返回一个新的`ImmutableVirtualCreature`实例：
- en: '`evolveToAge`: This method receives the desired age for the evolved virtual
    creature in the `age` argument. The code calculates the birth year based on the
    received age and the current year, and returns a new `ImmutableVirtualCreature`
    instance with the new initialization values.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`evolveToAge`：此方法接收`age`参数中进化虚拟生物的期望年龄。代码根据接收到的年龄和当前年份计算出出生年份，并返回一个具有新初始化值的新`ImmutableVirtualCreature`实例。'
- en: '`evolveToVisibilityLevel`: This method receives the desired visibility level
    for the evolved virtual creature in the `visibilityLevel` argument. The code calls
    the `getValidVisibilityLevel` method to generate a valid visibility level based
    on the received value, and returns a new `ImmutableVirtualCreature` instance with
    the new initialization values.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`evolveToVisibilityLevel`：此方法接收`visibilityLevel`参数中进化虚拟生物的期望可见性级别。代码调用`getValidVisibilityLevel`方法根据接收到的值生成一个有效的可见性级别，并返回一个具有新初始化值的新`ImmutableVirtualCreature`实例。'
- en: The following lines create an instance of the `ImmutableVirtualCreature` class
    named `meowth1`. Then the code calls the `meowth1.evolveToAge` method with `3`
    as the value for the `age` argument and saves the new `ImmutableVirtualCreature`
    instance returned by this method in the `meowth2` variable. The code prints the
    value returned by the `meowth2.getAge` method. Finally, the code calls the `meowth2.evolveToVisibilityLevel`
    method with `25` as the value for the `invisibilityLevel` argument and saves the
    new `ImmutableVirtualCreature` instance returned by this method in the `meowth3`
    variable. Then, the code prints the value stored in the `meowth3.visibilityLevel`
    immutable field. The code file for the sample is included in the `java_9_oop_chapter_05_01`
    folder, in the `example05_06.java` file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行创建了一个名为`meowth1`的`ImmutableVirtualCreature`类的实例。然后，代码使用`3`作为`age`参数的值调用`meowth1.evolveToAge`方法，并将此方法返回的新`ImmutableVirtualCreature`实例保存在`meowth2`变量中。代码打印了`meowth2.getAge`方法返回的值。最后，代码使用`25`作为`invisibilityLevel`参数的值调用`meowth2.evolveToVisibilityLevel`方法，并将此方法返回的新`ImmutableVirtualCreature`实例保存在`meowth3`变量中。然后，代码打印了存储在`meowth3.visibilityLevel`不可变字段中的值。示例的代码文件包含在`java_9_oop_chapter_05_01`文件夹中的`example05_06.java`文件中。
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在JShell中执行上述代码的结果：
- en: '![Creating the immutable version of an existing mutable class](img/00064.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![创建现有可变类的不可变版本](img/00064.jpeg)'
- en: Test your knowledge
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'A class that exposes mutable fields will:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个暴露可变字段的类将：
- en: Generate immutable instances.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成不可变实例。
- en: Generate mutable instances.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成可变实例。
- en: Generate mutable classes but immutable instances.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成可变类但不可变实例。
- en: 'Which of the following keywords, used within a constructor, allows us to call
    other constructors with different arguments defined in our class:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中使用以下哪个关键字可以调用我们类中定义的具有不同参数的其他构造函数：
- en: '`self`'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`self`'
- en: '`constructor`'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`constructor`'
- en: '`this`'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`this`'
- en: 'An object that cannot change its state after it has been initialized is known
    as:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化后无法更改其状态的对象称为：
- en: A mutable object.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个可变对象。
- en: An immutable object.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个不可变对象。
- en: An interface object.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个接口对象。
- en: 'In Java 9, `java.lang.String` generates:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Java 9中，`java.lang.String`生成：
- en: An immutable object.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个不可变对象。
- en: A mutable object.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个可变对象。
- en: An interface object.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个接口对象。
- en: 'If we call the `toUpperCase` method for a `java.lang.String`, the method will:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们为`java.lang.String`调用`toUpperCase`方法，该方法将：
- en: Convert the existing `String` to uppercase characters and change its state.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的`String`转换为大写字符并改变其状态。
- en: Return a new `String` with the contents of the original `String` converted to
    uppercase characters.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个新的`String`，其中包含原始`String`转换为大写字符的内容。
- en: Return a new `String` with the contents of the original `String`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个包含原始字符串内容的新的`String`。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned the differences between mutable and immutable classes
    and the mutating and non-mutating instances that they generate. We declared mutable
    and immutable versions of a 3D vector class in Java 9.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了可变和不可变类之间的区别，以及它们生成的可变和不可变实例。我们在Java 9中声明了可变和不可变版本的3D向量类。
- en: Then, we took advantage of JShell to easily work with the mutating and non-mutating
    instances of these classes and we analyzed the difference between changing the
    state of an object and returning a new object whenever we have to change its state.
    We analyzed the advantages and disadvantages of mutable and immutable classes
    and we understood why the latter are useful when working with concurrent code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们利用JShell轻松地处理这些类的可变和不可变实例，并分析了改变对象状态和在需要改变其状态时返回一个新对象之间的区别。我们分析了可变和不可变类的优缺点，并理解了为什么在处理并发代码时后者是有用的。
- en: Now that you have learned about mutable and immutable classes, you are ready
    to work with inheritance, abstraction, extension, and specialization, which are
    the topics we are going to discuss in the next chapter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学习了可变和不可变类，你已经准备好学习继承、抽象、扩展和专门化，这些是我们下一章要讨论的主题。
