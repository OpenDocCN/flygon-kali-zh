- en: Chapter 5. Category Theory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。范畴论
- en: 'Thomas Watson was famously quoted as saying, "I think there is a world market
    for maybe five computers". That was in 1948\. Back then, everybody knew that computers
    would only be used for two things: math and engineering. Not even the biggest
    minds in tech could predict that, one day, computers would be able to translate
    Spanish to English, or simulate entire weather systems. At the time, the fastest
    machine was IBM''s SSEC, clocking in at 50 multiplications per second, the display
    terminal wasn''t due until 15 years later and multiple-processing meant multiple
    user terminals sharing a single processor. The transistor changed everything,
    but tech''s visionaries still missed the mark. Ken Olson made another famously
    foolish prediction when, in 1977, he said "There is no reason anyone would want
    a computer in their home".'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 托马斯·沃森曾经著名地说过：“我认为世界市场上可能只需要五台计算机。”那是在1948年。当时，每个人都知道计算机只会用于两件事：数学和工程。甚至科技界最伟大的头脑也无法预测，有一天，计算机将能够将西班牙语翻译成英语，或者模拟整个天气系统。当时，最快的机器是IBM的SSEC，每秒进行50次乘法运算，显示终端要等15年才会出现，多处理意味着多个用户终端共享一个处理器。晶体管改变了一切，但科技的远见者仍然未能抓住要点。肯·奥尔森在1977年又做了一个著名的愚蠢预测，他说：“没有理由让任何人在家里放一台计算机。”
- en: It seams obvious to us now that computers are not just for scientists and engineers,
    but that's hindsight. The idea that machines can do more than just math was anything
    but intuitive 70 years ago. Watson didn't just fail to realize how computers could
    transform a society, he failed to realize the transformative and evolving powers
    of mathematics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对我们来说很明显，计算机不仅仅是为科学家和工程师准备的，但这是事后诸葛亮。70年前，机器不仅仅能做数学这个想法一点都不直观。沃森不仅没有意识到计算机如何改变社会，他也没有意识到数学的变革和发展力量。
- en: But the potential of computers and math was not lost on everybody. John McCarthy
    invented **Lisp** in 1958, a revolutionary algorithm-based language that ushered
    in a new era in computing. Since its inception, Lisp was instrumental in the idea
    of using abstraction layers—compilers, interpreters, virtualization—to push forward
    the progression of computers from hardcore math machines to what they are today.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，计算机和数学的潜力并没有被所有人忽视。约翰·麦卡锡在1958年发明了**Lisp**，这是一种革命性的基于算法的语言，开启了计算机发展的新时代。自诞生以来，Lisp在使用抽象层（编译器、解释器、虚拟化）推动计算机从严格的数学机器发展到今天的样子方面发挥了重要作用。
- en: From Lisp came **Scheme**, a direct ancestor of JavaScript. Now that brings
    us full circle. If computers are, at their core, machines that just do math, then
    it stands to reason that a math-based programming paradigm would excel.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从Lisp出现了**Scheme**，它是JavaScript的直接祖先。现在我们又回到了原点。如果计算机在本质上只是做数学，那么基于数学的编程范式就会表现出色是理所当然的。
- en: 'The term "math" is being used here not to describe the "number crunching" that
    computers can obviously do, but to describe *discrete mathematics*: the study
    of discrete, mathematical structures such as statements in logic or the instructions
    of a computer language. By treating code as a discrete mathematical structure,
    we can apply concepts and ideas in math to it. This is what has made functional
    programming so instrumental in artificial intelligence, graph search, pattern
    recognition and other big challenges in computer science.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的“数学”一词并不是用来描述计算机显然可以做的“数字计算”，而是用来描述*离散数学*：研究离散数学结构的学科，比如逻辑陈述或计算机语言的指令。通过将代码视为离散数学结构，我们可以将数学中的概念和思想应用到其中。这就是为什么函数式编程在人工智能、图搜索、模式识别和计算机科学中的其他重大挑战中如此重要。
- en: 'In this chapter, we will experiment with some of these concepts and their applications
    in everyday programming challenges. They will include:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尝试一些这些概念及其在日常编程挑战中的应用。它们将包括：
- en: Category theory
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范畴论
- en: Morphisms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 态射
- en: Functors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函子
- en: Maybes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能性
- en: Promises
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺
- en: Lenses
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜头
- en: Function composition
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组合
- en: With these concepts, we'll be able to write entire libraries and APIs very easily
    and safely. And we'll go from explaining category theory to formally implementing
    it in JavaScript.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些概念，我们将能够非常轻松和安全地编写整个库和API。我们将从解释范畴论到在JavaScript中正式实现它。
- en: Category theory
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范畴论
- en: Category theory is the theoretical concept that empowers function composition.
    Category theory and function composition go together like engine displacement
    and horsepower, like NASA and the space shuttle, like good beer and a mug to pour
    it in. Basically, you can't have one without the other.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴论是赋予函数组合力量的理论概念。范畴论和函数组合就像发动机排量和马力，像NASA和航天飞机，像好啤酒和杯子一样紧密相连。基本上，一个离不开另一个。
- en: Category theory in a nutshell
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范畴论简介
- en: Category theory really isn't too difficult a concept. Its place in math is large
    enough to fill up an entire graduate-level college course, but its place in computer
    programming can be summed up quite easily.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴论实际上并不是一个太难的概念。它在数学中的地位足以填满整个研究生课程，但它在计算机编程中的地位可以很容易地总结起来。
- en: Einstein once said, "If you can't explain it to a 6-year-old, you don't know
    it yourself". Thus, in the spirit of explaining it to a 6-year-old, *category
    theory is just connecting the dots*. Although it may be grossly over-simplifying
    category theory, it does do a good job of explaining what we need to know in a
    straightforward manner.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 爱因斯坦曾说过：“如果你不能向一个6岁的孩子解释清楚，那么你自己也不懂。”因此，在向一个6岁的孩子解释的精神下，*范畴论就是连接点*。虽然这可能严重简化了范畴论，但它确实很好地以直接的方式解释了我们需要知道的内容。
- en: First you'll need to know some terminology. **Categories** are just sets with
    the same type. In JavaScript, they're arrays or objects that contain variables
    that are explicitly declared as numbers, strings, Booleans, dates, nodes, and
    so on. **Morphisms** are pure functions that, when given a specific set of inputs,
    always return the same output. **Homomorphic operations** are restricted to a
    single category, while **polymorphic operations** can operate on multiple categories.
    For example, the homomorphic function *multiplication* only works on numbers,
    but the polymorphic function addition can work on strings too.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要了解一些术语。**范畴**只是具有相同类型的集合。在JavaScript中，它们是包含明确定义为数字、字符串、布尔值、日期、节点等的变量的数组或对象。**态射**是纯函数，当给定特定的输入集时，总是返回相同的输出。**同态操作**限于单个范畴，而**多态操作**可以在多个范畴上操作。例如，同态函数*乘法*只对数字起作用，但多态函数加法也可以对字符串起作用。
- en: '![Category theory in a nutshell](../images/00004.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![范畴论简介](../images/00004.jpeg)'
- en: The following diagram shows three categories—A, B, and C—and two morphisms—*ƒ*
    and *ɡ*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了三个范畴——A、B和C——和两个态射——*ƒ*和*ɡ*。
- en: 'Category theory tells us that, when we have two morphisms where the category
    of the first one is the expected input of the other, then they can be *composed*
    to the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴论告诉我们，当我们有两个态射，其中第一个的范畴是另一个的预期输入时，它们可以*组合*成以下内容：
- en: '![Category theory in a nutshell](../images/00005.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![范畴论简介](../images/00005.jpeg)'
- en: The *ƒ o g* symbol is the composition of morphisms *ƒ* and *g*. Now we can just
    connect the dots.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*ƒ o g*符号是态射*ƒ*和*g*的组合。现在我们可以连接点了。'
- en: '![Category theory in a nutshell](../images/00006.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![范畴论简介](../images/00006.jpeg)'
- en: And that's all it really is, just connecting dots.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的全部内容，只是连接点。
- en: Type safety
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型安全
- en: 'Let''s connect some dots. Categories contain two things:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们连接一些点。范畴包含两个东西：
- en: Objects (in JavaScript, types).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象（在JavaScript中，类型）。
- en: Morphisms (in JavaScript, pure functions that only work on types).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 态射（在JavaScript中，只对类型起作用的纯函数）。
- en: These are the terms given to category theory by mathematicians, so there is
    some unfortunate nomenclature overloading with our JavaScript terminology. **Objects**
    in category theory are more like variables with an explicit data type and not
    collections of properties and values like in the JavaScript definition of objects.
    **Morphisms** are just pure functions that use those types.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是数学家给范畴论的术语，所以我们的JavaScript术语中存在一些不幸的命名重载。范畴论中的**对象**更像是具有显式数据类型的变量，而不是JavaScript对象定义中的属性和值的集合。**态射**只是使用这些类型的纯函数。
- en: So applying the idea of category theory to JavaScript is pretty easy. Using
    category theory in JavaScript means working with one certain data type per category.
    Data types are numbers, strings, arrays, dates, objects, Booleans, and so on.
    But, with no strict type system in JavaScript, things can go awry. So we'll have
    to implement our own method of ensuring that the data is correct.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将范畴论的思想应用到JavaScript中非常容易。在JavaScript中使用范畴论意味着每个范畴都使用一种特定的数据类型。数据类型包括数字、字符串、数组、日期、对象、布尔值等。但是，在JavaScript中没有严格的类型系统，事情可能会出错。因此，我们将不得不实现自己的方法来确保数据是正确的。
- en: 'There are four primitive data types in JavaScript: numbers, strings, Booleans,
    and functions. We can create *type safety functions* that either return the variable
    or throw an error. *This fulfils the object axiom of categories*.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中有四种原始数据类型：数字、字符串、布尔值和函数。我们可以创建*类型安全函数*，它们要么返回变量，要么抛出错误。*这满足了范畴的对象公理*。
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, there's a lot of repeated code here and that isn't very functional.
    Instead, we can create a function that returns another function that is the type
    safety function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有很多重复的代码，这并不是很实用。相反，我们可以创建一个返回另一个函数的函数，这个函数是类型安全函数。
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we can use them to ensure that our functions behave as expected.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用它们来确保我们的函数表现如预期。
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's look at a meatier example. If we want to check the length of a Unix timestamp
    that is returned by the JavaScript function `Date.parse(),` not as a string but
    as a number, then we'll have to use our `str()` function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更有意思的例子。如果我们想要检查由JavaScript函数`Date.parse()`返回的Unix时间戳的长度，而不是作为字符串而是作为数字，那么我们将不得不使用我们的`str()`函数。
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Functions like this that explicitly transform one type to another (or to the
    same type) are called *morphisms*. *This fulfils the morphism axiom of category
    theory*. These forced type declarations via the type safety functions and the
    morphisms that use them are everything we need to represent the notion of a category
    in JavaScript.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样明确地将一种类型转换为另一种类型（或相同类型）的函数被称为*态射*。*这满足了范畴论的态射公理*。通过类型安全函数和使用它们的态射强制类型声明，这些都是我们在JavaScript中表示范畴概念所需要的一切。
- en: Object identities
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象标识
- en: 'There''s one other important data type: objects.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个重要的数据类型：对象。
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, objects are different. They can be inherited. Everything that is not
    a primitive—numbers, strings, Booleans, and functions—is an object, including
    arrays, dates, elements, and more.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对象是不同的。它们可以被继承。除了原始的数字、字符串、布尔值和函数之外，一切都是对象，包括数组、日期、元素等。
- en: There's no way to know what type of object something is, as in to know what
    sub-type a JavaScript 'object' is, from the `typeof` keyword, so we'll have to
    improvise. Objects have a `toString()` function that we can hijack for this purpose.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 没有办法知道某个对象是什么类型，比如从`typeof`关键字知道JavaScript的一个子类型是什么，所以我们将不得不 improvisation。对象有一个`toString()`函数，我们可以利用它来实现这个目的。
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Again, with all the objects out there, we should implement some code re-use.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，有了所有这些对象，我们应该实现一些代码重用。
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These will be very useful for our next topic: functors.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将对我们接下来的主题非常有用：函子。
- en: Functors
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函子
- en: While morphisms are mappings between types, *functors* are mappings between
    categories. They can be thought of as functions that lift values out of a container,
    morph them, and then put them into a new container. The first input is a morphism
    for the type and the second input is the container.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然态射是类型之间的映射，*函数器*是范畴之间的映射。它们可以被看作是将值从容器中提取出来，对其进行态射，然后将其放入新的容器中的函数。第一个输入是类型的态射，第二个输入是容器。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The type signature for functors looks like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 函数器的类型签名如下：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This says, "give me a function that takes `a` and returns `b` and a box that
    contains `a`(s), and I'll return a box that contains `b`(s).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，“给我一个接受`a`并返回`b`的函数和一个包含`a`的盒子，我会返回一个包含`b`的盒子”。
- en: Creating functors
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建函数器
- en: 'It turns out we already have one functor: `map()`. It grabs the values within
    the container, an array, and applies a function to it.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，我们已经有一个函数器：`map()`。它从容器中（数组）获取值，并对其应用函数。
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: However, we'll need to write it as a global function and not as a method of
    the array object. This will allow us to write cleaner, safer code later on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们需要将其编写为全局函数，而不是数组对象的方法。这将使我们能够以后编写更清洁、更安全的代码。
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This example seems like a contrived wrapper because we're just piggybacking
    onto the `map()` function. But it serves a purpose. It provides a template for
    maps of other types.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子看起来像一个人为的包装，因为我们只是依赖`map()`函数。但它有一个目的。它为其他类型的映射提供了一个模板。
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Arrays and functors
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组和函数器
- en: Arrays are the preferred way to work with data in functional JavaScript.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式JavaScript中，数组是处理数据的首选方式。
- en: Is there an easier way to create functors that are already assigned to a morphism?
    Yes, and it's called `arrayOf`. When you pass in a morphism that expects an integer
    and returns an array, you get back a morphism that expects an array of integers
    and returns an array of arrays.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有一种更简单的方法来创建已经分配给态射的函数器？是的，它被称为`arrayOf`。当你传入一个期望整数并返回一个数组的态射时，你会得到一个期望整数数组并返回一个数组的态射。
- en: It is not a functor itself, but it allows us to create functors from morphisms.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 它本身不是一个函数器，但它允许我们从态射创建函数器。
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s how to create functors by using morphism:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用态射创建函数器：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The interesting property of the `arrayOf` functor is that it works on type safeties
    as well. When you pass in the type safety function for strings, you get back a
    type safety function for an array of strings. The type safeties are treated like
    the *identity function* morphism. This can be very useful for ensuring that an
    array contains all the correct types.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`arrayOf`函数器的有趣属性是它也适用于类型安全。当你传入字符串的类型安全函数时，你会得到一个字符串数组的类型安全函数。类型安全被视为*恒等函数*态射。这对于确保数组包含所有正确的类型非常有用。'
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Function compositions, revisited
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视函数组合
- en: Functions are another type of primitive that we can create a functor for. And
    that functor is called `fcompose`. We defined functors as something that takes
    a value from a container and applies a function to it. When that container is
    a function, we just call it to get its inner value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是我们可以为其创建一个函数器的另一种原始类型。这个函数器被称为`fcompose`。我们将函数器定义为从容器中取出一个值并对其应用函数的东西。当容器是一个函数时，我们只需调用它以获取其内部值。
- en: We already know what function compositions are, but let's look at what they
    can do in a category theory-driven environment.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道函数组合是什么，但让我们看看它们在范畴论驱动的环境中能做什么。
- en: Function compositions are associative. If your high school algebra teacher was
    like mine, she taught you what the property *is* but not what it can *do*. In
    practice, compose is what the associative property can do.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合是可结合的。如果你的高中代数老师像我的一样，她教你这个性质*是*什么，但没有教你它能*做*什么。在实践中，组合是可结合性能做的事情。
- en: '![Function compositions, revisited](../images/00007.jpeg)![Function compositions,
    revisited](../images/00008.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![重新审视函数组合](../images/00007.jpeg)![重新审视函数组合](../images/00008.jpeg)'
- en: We can do any inner-compose, it doesn't matter how it's grouped. This is not
    to be confused with the commutative property. *ƒ o g* does not always equal *g
    o ƒ*. In other words, the reverse of the first word of a string is not the same
    as the first word of the reverse of a string.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进行任何内部组合，不管它是如何分组的。这与交换律属性不同。*ƒ o g*并不总是等于*g o ƒ*。换句话说，字符串的第一个单词的反向不同于字符串反向的第一个单词。
- en: What this all means is that it doesn't matter which functions are applied and
    in what order, as long as the input of each functions comes from the output of
    the previous function. But wait, if the function on the right relies on the function
    on the left, then can't there be only one order of evaluation? Left to right?
    True, but if it's encapsulated, then we can control it however we feel fit. This
    is what empowered lazy evaluation in JavaScript.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切意味着，不管应用了哪些函数以及顺序如何，只要每个函数的输入来自前一个函数的输出，就没有关系。但是，等等，如果右边的函数依赖于左边的函数，那么难道只能有一种评估顺序吗？从左到右？是的，但如果它被封装起来，那么我们可以根据自己的意愿来控制它。这就是JavaScript中懒惰评估的强大之处。
- en: '![Function compositions, revisited](../images/00009.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![重新审视函数组合](../images/00009.jpeg)'
- en: 'Let''s rewrite function composition, not as an extension of the function prototype,
    but as a stand-alone function that will allow us to get more out of it. The basic
    form is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新编写函数组合，不是作为函数原型的扩展，而是作为一个独立的函数，这将允许我们更充分地利用它。基本形式如下：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: But we'll need it to work on any number of inputs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们需要它能够处理任意数量的输入。
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that we've encapsulated the functions, we have control over them. We could
    rewrite the compose function such that *each function accepts another function
    as input, stores it, and gives back an object that does the same*. Instead of
    accepting an array as an input, doing something with it, and then giving back
    a new array for each operation, we can accept a single array for each element
    in the source, perform all operations combined (every `map()`, `filter()`, and
    so on, composed together), and finally store the results in a new array. This
    is lazy evaluation via function composition. No reason to reinvent the wheel here.
    Many libraries have a nice implementation of this concept, including the `Lazy.js`,
    `Bacon.js` and `wu.js` libraries.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经封装了这些函数，我们对它们有了控制。我们可以重写compose函数，使得*每个函数都接受另一个函数作为输入，存储它，并返回一个做同样事情的对象*。我们可以接受一个单一数组作为输入，对源中的每个元素执行所有操作（每个`map()`、`filter()`等等，组合在一起），最后将结果存储在一个新数组中。这是通过函数组合实现的惰性评估。这里没有理由重新发明轮子。许多库都有这个概念的很好的实现，包括`Lazy.js`、`Bacon.js`和`wu.js`库。
- en: 'There''s a lot more we can do as a result of this different model: asynchronous
    iteration, asynchronous event handling, lazy evaluation, and even automatic parallelization.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不同的模式使我们能够做更多的事情：异步迭代，异步事件处理，惰性评估，甚至自动并行化。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Automatic parallelization? There''s a word for that in the computer science
    industry: IMPOSSIBLE. But is it really impossible? The next evolutionary leap
    in Moore''s law might be a compiler that parallelizes our code for us, and could
    function composition be it?'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 自动并行化？在计算机科学行业中有一个词：不可能。但它真的不可能吗？摩尔定律的下一个进化飞跃可能是一个为我们的代码并行化的编译器，而函数组合可能就是这样的编译器？
- en: No, it doesn't quite work that way. The JavaScript engine is what is really
    doing the parallelization, not automatically but with well thought-out code. Compose
    just gives the engine the chance to split it into parallel processes. But that
    in itself is pretty cool.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 不，事情并不完全是这样的。JavaScript引擎才是真正进行并行化的，不是自动的，而是通过深思熟虑的代码。Compose只是给引擎一个机会将其拆分成并行进程。但这本身就很酷。
- en: Monads
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单子
- en: '**Monads** are tools that help you compose functions.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**单子**是帮助您组合函数的工具。'
- en: Like primitive types, monads are structures that can be used as the containers
    that functors "reach into". The functors grab the data, do something to it, put
    it into a new monad, and return it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 像原始类型一样，单子是可以用作函子“触及”的容器的结构。函子抓取数据，对其进行处理，将其放入一个新的单子中，并返回它。
- en: 'There are three monads we''ll focus on:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于三个单子：
- en: Maybes
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maybes
- en: Promises
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺
- en: Lenses
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lenses
- en: So in addition to arrays (map) and functions (compose), we'll have five functors
    (map, compose, maybe, promise and lens). These are just some of the many other
    functors and monads that are out there.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所以除了数组（map）和函数（compose）之外，我们还有五个函子（map、compose、maybe、promise和lens）。这些只是许多其他函子和单子中的一些。
- en: Maybes
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Maybes
- en: Maybes allow us to gracefully work with data that might be null and to have
    defaults. A maybe is a variable that either has some value or it doesn't. And
    it doesn't matter to the caller.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Maybes允许我们优雅地处理可能为空的数据，并设置默认值。也就是说，maybe是一个变量，它要么有一些值，要么没有。而对调用者来说这并不重要。
- en: 'On its own, it might seem like this is not that big a deal. Everybody knows
    that null-checks are easily accomplished with an `if-else` statement:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 单独看起来，这似乎并不是什么大不了的事。每个人都知道，使用`if-else`语句很容易实现空检查：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: But with functional programming, we're breaking away from the procedural, line-by-line
    way of doing things and instead working with pipelines of functions and data.
    If we had to break the chain in the middle just to check if the value existed
    or not, we would have to create temporary variables and write more code. Maybes
    are just tools to help us keep the logic flowing through the pipeline.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但是通过函数式编程，我们正在摆脱逐行进行程序的程序化方式，而是使用函数和数据的管道。如果我们必须在中间打断链条来检查值是否存在，我们将不得不创建临时变量并编写更多的代码。Maybes只是帮助我们保持逻辑在管道中流动的工具。
- en: To implement maybes, we'll first need to create some constructors.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现maybes，我们首先需要创建一些构造函数。
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finally, we can write the `maybe` function. It returns a new function that either
    returns nothing or a maybe. *It is a functor*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以编写`maybe`函数。它返回一个新的函数，要么返回空，要么返回一个maybe。*它是一个函子*。
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: And we can also create a functor generator just like we did with arrays.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以创建一个与数组类似的函子生成器。
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So `Maybe` is a monad, `maybe` is a functor, and `maybeOf` returns a functor
    that is already assigned to a morphism.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所以`Maybe`是一个单子，`maybe`是一个函子，`maybeOf`返回一个已经分配给一个态射的函子。
- en: We'll need one more thing before we can move forward. We'll need to add a method
    to the `Maybe` monad object that helps us use it more intuitively.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们还需要一件事。我们需要为`Maybe`单子对象添加一个帮助我们更直观地使用它的方法。
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In its raw form, maybes can be used directly.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在其原始形式中，maybes可以直接使用。
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Anything that returns a method that is then executed is complicated enough to
    be begging for trouble. So we can make it a little cleaner by calling on our `curry()`
    function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 任何返回一个然后执行的方法都足够复杂，以至于容易出问题。所以我们可以通过调用我们的`curry()`函数来使它更加简洁。
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: But the real power of maybes will become clear when the dirty business of directly
    calling the `none()` and `just()` functions is abstracted. We'll do this with
    an example object `User`, that uses maybes for the username.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当直接调用`none()`和`just()`函数的肮脏业务被抽象化时，maybes的真正力量将变得清晰。我们将通过一个使用maybes的示例对象`User`来做到这一点。
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And now we have a powerful and safe way to define defaults. Keep this `User`
    object in mind because we'll be using it later on in this chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个强大而安全的方法来定义默认值。记住这个`User`对象，因为我们将在本章后面使用它。
- en: Promises
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 承诺
- en: '*The nature of promises is that they remain immune to changing circumstances.*'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*承诺的本质是它们对变化的情况保持免疫。*'
- en: '>'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*- Frank Underwood, House of Cards*'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*- 弗兰克·安德伍德，《纸牌屋》*'
- en: 'In functional programming, we''re often working with pipelines and data flows:
    chains of functions where each function produces a data type that is consumed
    by the next. However, many of these functions are asynchronous: readFile, events,
    AJAX, and so on. Instead of using a continuation-passing style and deeply nested
    callbacks, how can we modify the return types of these functions to indicate the
    result? By wrapping them in *promises*.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，我们经常使用管道和数据流：一系列函数，其中每个函数产生一个数据类型，由下一个函数消耗。然而，许多这些函数是异步的：readFile、事件、AJAX等。我们如何修改这些函数的返回类型来指示结果，而不是使用延续传递风格和深度嵌套的回调？通过将它们包装在*promises*中。
- en: Promises are like the functional equivalent of callbacks. Obviously, callbacks
    are not all that functional because, if more than one function is mutating the
    same data, then there can be race conditions and bugs. Promises solve that problem.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Promises就像回调的函数式等价物。显然，回调并不都是函数式的，因为如果有多个函数对同一数据进行变异，就会出现竞争条件和错误。Promises解决了这个问题。
- en: 'You should use promises to turn this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用promises来完成这个：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Into the following code snippet:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 进入以下代码片段：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding code is from the README for *bluebird*: a full featured *Promises/A+*
    implementation with exceptionally good performance. *Promises/A+* is a specification
    for implementing promises in JavaScript. Given its current debate within the JavaScript
    community, we''ll leave the implementations up to the *Promises/A+* team, as it
    is much more complex than maybes.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码来自*bluebird*的README：一个功能齐全的*Promises/A+*实现，性能异常出色。*Promises/A+*是JavaScript中实现promises的规范。鉴于它在JavaScript社区内的当前辩论，我们将把实现留给*Promises/A+*团队，因为它比可能更复杂得多。
- en: 'But here''s a partial implementation:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是一个部分实现：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now we can use the `promise()` functor to transform functions that take callbacks
    into functions that return promises.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`promise()`函子将接受回调的函数转换为返回promises的函数。
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Lenses
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜头
- en: Another reason why programmers really like monads is that they make writing
    libraries very easy. To explore this, let's extend our `User` object with more
    functions for getting and setting values but, instead of using getters and setters,
    we'll use *lenses*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员真正喜欢单子的另一个原因是，它们使编写库变得非常容易。为了探索这一点，让我们扩展我们的`User`对象，增加更多用于获取和设置值的函数，但是，我们将使用*lenses*而不是使用getter和setter。
- en: Lenses are first-class getters and setters. They allow us to not just get and
    set variables, but also to run functions over it. But instead of mutating the
    data, they clone and return the new data modified by the function. They force
    data to be immutable, which is great for security and consistency as well for
    libraries. They're great for elegant code no matter what the application, so long
    as the performance-hit of introducing additional array copies is not a critical
    issue.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 镜头是一流的获取器和设置器。它们不仅允许我们获取和设置变量，还允许我们在其上运行函数。但是，它们不是对数据进行变异，而是克隆并返回由函数修改的新数据。它们强制数据是不可变的，这对于安全性和一致性以及库来说非常好。无论应用程序如何，它们都非常适合优雅的代码，只要引入额外的数组副本不会对性能造成重大影响。
- en: Before we write the `lens()` function, let's look at how it works.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写`lens()`函数之前，让我们看看它是如何工作的。
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And here's how the `lens()` function works. It returns a function with get,
    set and mod defined. The `lens()` function itself is a functor.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`lens()`函数的工作原理。它返回一个具有get、set和mod定义的函数。`lens()`函数本身是一个函子。
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let's try an example. We'll extend our `User` object from the previous example.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来试一个例子。我们将扩展我们之前例子中的`User`对象。
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: jQuery is a monad
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery是一个单子
- en: If you think all this abstract babble about categories, functors, and monads
    has no real-world application, think again. jQuery, the popular JavaScript library
    that provides an enhanced interface for working with HTML is, in-fact, a monadic
    library.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为所有这些关于范畴、函子和单子的抽象胡言没有真正的现实应用，那就再想想吧。流行的JavaScript库jQuery提供了一个增强的接口，用于处理HTML，实际上是一个单子库。
- en: 'The `jQuery` object is a monad and its methods are functors. Really, they''re
    a special type of functor called *endofunctors*. **Endofunctors** are functors
    that return the same category as the input, that is, `F :: X -> X`. Each `jQuery`
    method takes a `jQuery` object and returns a `jQuery` object, which allows methods
    to be chained, and they will have the type signature `jFunc :: jquery-obj -> jquery-obj`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`jQuery`对象是一个单子，它的方法是函子。实际上，它们是一种特殊类型的函子，称为*endofunctors*。**Endofunctors**是返回与输入相同类别的函子，即`F
    :: X -> X`。每个`jQuery`方法都接受一个`jQuery`对象并返回一个`jQuery`对象，这允许方法被链接，并且它们将具有类型签名`jFunc
    :: jquery-obj -> jquery-obj`。'
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is also what empowers jQuery's plugin framework. If the plugin takes a
    `jQuery` object as input and returns one as output, then it can be inserted into
    the chain.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是jQuery的插件框架的强大之处。如果插件以`jQuery`对象作为输入并返回一个作为输出，则可以将其插入到链中。
- en: Let's look at how jQuery was able to implement this.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看jQuery是如何实现这一点的。
- en: Monads are the containers that the functors "reach into" to get the data. In
    this way, the data can be protected and controlled by the library. jQuery provides
    access to the underlying data, a wrapped set of HTML elements, via its many methods.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 单子是函子“触及”以获取数据的容器。通过这种方式，数据可以受到库的保护和控制。jQuery通过其许多方法提供对底层数据的访问，这些数据是一组包装的HTML元素。
- en: The `jQuery` object itself is written as the result of an anonymous function
    call.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`jQuery`对象本身是作为匿名函数调用的结果编写的。'
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this highly simplified version of jQuery, it returns a function that defines
    the `j` object, which is actually just an enhanced `init` constructor.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个高度简化的jQuery版本中，它返回一个定义了`j`对象的函数，实际上只是一个增强的`init`构造函数。
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the same way that functors lift values out of a container, jQuery wraps the
    HTML elements and provides access to them as opposed to modifying the HTML elements
    directly.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与函子将值提取出容器的方式相同，jQuery包装了HTML元素并提供对它们的访问，而不是直接修改HTML元素。
- en: jQuery doesn't advertise this often, but it has its own `map()` method for lifting
    the HTML element objects out of the wrapper. Just like the `fmap()` method, the
    elements are lifted, something is done with them, and then they're placed back
    into the container. This is how many of jQuery's commands work in the backend.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery并不经常宣传，但它有自己的`map()`方法，用于将HTML元素对象从包装器中提取出来。就像`fmap()`方法一样，元素被提取出来，对它们进行处理，然后放回容器中。这就是jQuery的许多命令在后端工作的方式。
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Another library for working with HTML elements, Prototype, does not work like
    this. Prototype alters the HTML elements directly via helpers. Consequently, it
    has not faired as well in the JavaScript community.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于处理HTML元素的库Prototype不是这样工作的。Prototype通过助手直接改变HTML元素。因此，它在JavaScript社区中的表现并不好。
- en: Implementing categories
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施类别
- en: It's about time we formally defined category theory as JavaScript objects. Categories
    are objects (types) and morphisms (functions that only work on those types). It's
    an extremely high-level, totally-declarative way to program, but it ensures that
    the code is extremely safe and reliable—perfect for APIs and libraries that are
    worried about concurrency and type safety.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候我们正式将范畴论定义为JavaScript对象了。范畴是对象（类型）和态射（仅在这些类型上工作的函数）。这是一种非常高级的、完全声明式的编程方式，但它确保代码非常安全可靠——非常适合担心并发和类型安全的API和库。
- en: 'First, we''ll need a function that helps us create morphisms. We''ll call it
    `homoMorph()` because they''ll be homomorphisms. It will return a function that
    expects a function to be passed in and produces the composition of it, based on
    the inputs. The inputs are the types that the morphism accepts as input and gives
    as output. Just like our type signatures, that is, `// morph :: num -> num ->
    [num]`, only the last one is the output.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们需要一个帮助我们创建同态的函数。我们将其称为`homoMorph()`，因为它们将是同态。它将返回一个函数，该函数期望传入一个函数，并根据输入生成其组合。输入是态射接受的输入和输出的类型。就像我们的类型签名一样，即`//
    morph :: num -> num -> [num]`，只有最后一个是输出。'
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `homoMorph()` function is fairly complex. It uses a closure (see [Chapter
    2](part0019_split_000.html#page "Chapter 2. Fundamentals of Functional Programming"),
    *Fundamentals of Functional Programming*) to return a function that accepts a
    function and checks its input and output values for type safety. And for that,
    it relies on a helper function: `checkTypes`, which is defined as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`homoMorph()`函数相当复杂。它使用闭包（参见[第2章](part0019_split_000.html#page "第2章。函数式编程基础")，“函数式编程基础”）返回一个接受函数并检查其输入和输出值的类型安全性的函数。为此，它依赖于一个辅助函数：`checkTypes`，其定义如下：'
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now let's formally define some homomorphisms.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们正式定义一些同态。
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, we can bring it on home. The following example includes function composition,
    lenses, homomorphisms, and more.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以把它带回家。以下示例包括函数组合、镜头、同态和其他内容。
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code is extremely declarative, safe, reliable, and dependable.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码非常声明式，安全，可靠和可信赖。
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: What does it mean for code to be declarative? In imperative programming, we
    write sequences of instructions that tell the machine how to do what we want.
    In functional programming, we describe relationships between values that tell
    the machine what we want it to compute, and the machine figures out the instruction
    sequences to make it happen. Functional programming is declarative.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明式是什么意思？在命令式编程中，我们编写一系列指令，告诉机器如何做我们想要的事情。在函数式编程中，我们描述值之间的关系，告诉机器我们想要它计算什么，机器会找出指令序列来实现它。函数式编程是声明式的。
- en: Entire libraries and APIs can be constructed this way that allow programmers
    to write code freely without worrying about concurrency and type safety because
    those worries are handled in the backend.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 整个库和API可以通过这种方式构建，允许程序员自由编写代码，而不必担心并发和类型安全，因为这些问题在后端处理。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: About one in every 2,000 people has a condition known as synesthesia, a neurological
    phenomenon in which one sensory input bleeds into another. The most common form
    involves assigning colors with letters. However, there is an even rarer form where
    sentences and paragraphs are associated with tastes and feelings.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 大约每2000人中就有一人患有一种称为共感觉的病症，这是一种神经现象，其中一种感官输入渗入另一种感官。最常见的形式涉及将颜色与字母相匹配。然而，还有一种更罕见的形式，即将句子和段落与味道和感觉联系起来。
- en: For these people, they don't read word by word, sentence by sentence. They look
    at the whole page/document/program and get a sense for how it *tastes*—not in
    the mouth but in the *mind*. Then they put the parts of the text together like
    the pieces of a puzzle.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些人来说，他们不是逐字逐句地阅读。他们看整个页面/文档/程序，感受它的“味道”——不是口中的味道，而是“心灵”中的味道。然后他们像拼图一样把文本的部分放在一起。
- en: 'This is what it is like to write fully declarative code: code that describes
    the relationships between values that tells the machine what we want it to compute.
    The parts of the program are not instructions in line-by-line order. Synesthetics
    may be able to do it naturally, but with a little practice anyone can learn how
    to put the relational puzzle pieces together.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是编写完全声明式代码的样子：描述值之间的关系，告诉机器我们想要它计算什么。程序的部分不是按照逐行指令。共感者可能自然而然地做到这一点，但只要稍加练习，任何人都可以学会如何将关系拼图一起放在一起。
- en: In this chapter, we looked at several mathematical concepts that apply to functional
    programming and how they allow us to build relationships between data. Next, we'll
    explore recursion and other advanced topics in JavaScript.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了几个数学概念，这些概念适用于函数式编程，以及它们如何允许我们在数据之间建立关系。接下来，我们将探讨递归和JavaScript中的其他高级主题。
