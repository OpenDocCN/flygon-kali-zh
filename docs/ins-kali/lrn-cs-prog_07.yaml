- en: '*Chapter 7*: Collections'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：集合'
- en: In the previous chapter, we learned about generic programming in C#. One of
    the most important applications of generics is creating generic collections. A
    **collection** is a group of objects. We learned how to use arrays in [*Chapter
    2*](B12346_02_Final_JC_ePub.xhtml#_idTextAnchor036), *Data Types and Operators*.
    However, arrays are sequences of a fixed size and in most cases, we need to work
    with sequences of variable size.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了C#中的泛型编程。泛型的最重要的应用之一就是创建泛型集合。**集合**是一组对象。我们学习了如何在[*第2章*](B12346_02_Final_JC_ePub.xhtml#_idTextAnchor036)，*数据类型和运算符*中使用数组。然而，数组是固定大小的序列，在大多数情况下，我们需要处理可变大小的序列。
- en: The .NET frameworks provide generic classes that represent various types of
    collections, such as list, queue, set, map, and others. Using these classes, we
    can easily perform operations such as insert, update, delete, sort, and search
    on a collection of objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: .NET框架提供了代表各种类型集合的泛型类，如列表、队列、集合、映射等。使用这些类，我们可以轻松地对对象集合执行插入、更新、删除、排序和搜索等操作。
- en: 'You will learn about the following generic collections in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下泛型集合：
- en: The `List<T>` collection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<T>`集合'
- en: The `Stack<T>` collection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stack<T>`集合'
- en: The `Queue<T>` collection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Queue<T>`集合'
- en: The `LinkedList<T>` collection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkedList<T>`集合'
- en: The `Dictionary<TKey, TValue>` collection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dictionary<TKey, TValue>`集合'
- en: The `HashSet<T>` collection
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HashSet<T>`集合'
- en: By the end of this chapter, you will have a good understanding of the most important
    collections in .NET, what data structures they model, what the differences are
    between them, and when you should use them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将对.NET中最重要的集合有很好的理解，它们模拟了什么数据结构，它们之间的区别是什么，以及何时应该使用它们。
- en: All the collections mentioned previously are not thread-safe. This means they
    cannot be used in multi-threaded scenarios when a thread might be reading while
    another might be writing to the same collection, without using external synchronization
    mechanisms. However, .NET also provides several thread-safe collections in the
    `System.Collections.Concurrent` namespace that use efficient locking or lock-free
    synchronization mechanisms, and, in many scenarios, provide better performance
    than the generic collections with external locks. In this chapter, we will also
    provide a walkthrough of these collections and learn about the scenarios when
    it's suitable to use them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的所有集合都不是线程安全的。这意味着它们不能在多线程场景中使用，当一个线程可能在读取时，另一个线程可能在写入相同的集合，而不使用外部同步机制。然而，.NET还提供了几个线程安全的集合，它们位于`System.Collections.Concurrent`命名空间中，使用高效的锁定或无锁同步机制，在许多情况下，提供比使用外部锁更好的性能。在本章中，我们还将介绍这些集合，并了解何时适合使用它们。
- en: Let's start with an overview of the generic collection library by looking at
    the `System.Collections.Generic` namespace, which is where all the generic collections
    are located.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看`System.Collections.Generic`命名空间来概述泛型集合库，这是所有泛型集合的所在地。
- en: Introducing the System.Collections.Generic namespace
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍System.Collections.Generic命名空间
- en: 'The generic collection classes that we will present in this chapter are a part
    of the `System.Collections.Generic` namespace. This namespace contains interfaces
    and classes that define generic collections and operations. All the generic collections
    implement a series of generic interfaces, which are also defined in this namespace.
    These can be broadly grouped into two categories:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章介绍的泛型集合类是`System.Collections.Generic`命名空间的一部分。该命名空间包含定义泛型集合和操作的接口和类。所有泛型集合都实现了一系列泛型接口，这些接口也在该命名空间中定义。这些接口可以大致分为两类：
- en: '**Mutable**, which support operations for changing the content of the collection
    such as adding new, or removing existing elements.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变的，支持更改集合内容的操作，如添加新元素或删除现有元素。
- en: '**Read-only collections**, which do not provide methods for changing the content
    of the collection.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读集合，不提供更改集合内容的方法。
- en: 'The interfaces that represent mutable collections are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表示可变集合的接口如下：
- en: '`IEnumerable<T>`: This is the base interface for all the other interfaces and
    exposes an enumerator that supports iterating through the elements of a collection
    of `T` type.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>`：这是所有其他接口的基本接口，并公开一个支持遍历`T`类型集合元素的枚举器。'
- en: '`ICollection<T>`: This defines methods for manipulating generic collections—`Add()`,
    `Clear()`, `Contains()`, `CopyTo()`, and `Remove()`—as well as properties, such
    as `Count`. These members should be *self-explanatory*.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ICollection<T>`：这定义了操作泛型集合的方法——`Add()`、`Clear()`、`Contains()`、`CopyTo()`和`Remove()`——以及`Count`等属性。这些成员应该是*不言自明*的。'
- en: '`IList<T>`: This represents a generic collection whose elements can be accessed
    by an *index*. It defines three methods: `IndexOf()`, which retrieves the index
    of an element, `Insert()`, which inserts an element at the specified index, and
    `RemoveAt()`, which removes the element at the specified index, in addition, it
    also provides an indexer for direct element access for direct element access.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IList<T>`：表示可以通过*索引*访问其元素的泛型集合。它定义了三种方法：`IndexOf()`，用于检索元素的索引，`Insert()`，用于在指定索引处插入元素，`RemoveAt()`，用于移除指定索引处的元素，此外，它还提供了一个用于直接访问元素的索引器。'
- en: '`ISet<T>`: This is the base interface that abstracts set collections. It defines
    methods such as `Add()`, `ExceptWith()`, `IntersetWith()`, `UnionWith()`, `IsSubsetOf()`,
    and `IsSupersetOf()`.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ISet<T>`：这是抽象集合集合的基本接口。它定义了诸如`Add()`、`ExceptWith()`、`IntersetWith()`、`UnionWith()`、`IsSubsetOf()`和`IsSupersetOf()`等方法。'
- en: '`IDictionary<TKey, TValue>`: This is the base interface that abstracts a collection
    of key-value pairs. It defines the `Add()`, `ContainsKey()`, `Remove()`, and `TryGetValue()`
    methods, as well as an indexer and the `Keys` and `Values` properties, which return
    the collection of keys and values, respectively.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IDictionary<TKey, TValue>`：这是抽象出键值对集合的基本接口。它定义了`Add()`、`ContainsKey()`、`Remove()`和`TryGetValue()`方法，以及一个索引器和`Keys`和`Values`属性，分别返回键和值的集合。'
- en: 'The relationship between these interfaces is shown in the following diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口之间的关系如下图所示：
- en: '![Figure 7.1 – The hierarchy of generic collection interfaces in the System.Collections.Generic
    namespace.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 - System.Collections.Generic命名空间中通用集合接口的层次结构。'
- en: '](img/Figure_7.1_B12346.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.1_B12346.jpg)'
- en: Figure 7.1 – The hierarchy of generic collection interfaces in the System.Collections.Generic
    namespace.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 - System.Collections.Generic命名空间中通用集合接口的层次结构。
- en: 'The interfaces that represent read-only collections are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代表只读集合的接口如下：
- en: '`IReadOnlyCollection<T>`: This represents a read-only generic collection of
    elements. It only defines one member: the `Count` property.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IReadOnlyCollection<T>`：这代表了一个只读的元素的通用集合。它只定义了一个成员：`Count`属性。'
- en: '`IReadOnlyList<T>`: This represents a read-only generic collection of elements
    that can be accessed by an index. It only defines one member: a read-only indexer.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IReadOnlyList<T>`：这代表了一个只读的可以通过索引访问的元素的通用集合。它只定义了一个成员：一个只读的索引器。'
- en: '`IReadOnlyDictionary<TKey, TValue>`: This represents a read-only generic collection
    of key-value pairs. This interface defines the `ContainsKey()` and `TryGetValue()`
    methods, as well as the `Keys` and `Values` properties and a read-only indexer.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IReadOnlyDictionary<TKey, TValue>`：这代表了一个只读的键值对的通用集合。这个接口定义了`ContainsKey()`和`TryGetValue()`方法，以及`Keys`和`Values`属性和一个只读的索引器。'
- en: 'Again, the relationship of these interfaces is shown in the following diagram:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这些接口的关系如下图所示：
- en: '![Figure 7.2 – The hierarchy of interfaces for read-only generic collections.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 - 只读通用集合接口的层次结构。'
- en: '](img/Figure_7.2_B12346.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.2_B12346.jpg)'
- en: Figure 7.2 – The hierarchy of interfaces for read-only generic collections.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 - 只读通用集合接口的层次结构。
- en: 'Each generic collection implements several of these interfaces. For instance,
    `List<T>` implements `IList<T>`, `ICollection<T>`, `IEnumerable<T>`, `IReadOnlyCollection<T>`,
    and `IReadOnlyList<T>`. The following diagram shows all the interfaces being implemented
    by the generic collections that we will learn about in this chapter:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个通用集合都实现了几个这些接口。例如，`List<T>`实现了`IList<T>`、`ICollection<T>`、`IEnumerable<T>`、`IReadOnlyCollection<T>`和`IReadOnlyList<T>`。下图显示了我们将在本章学习的通用集合所实现的所有接口：
- en: '![Figure 7.3 – A class diagram showing the most important generic collections'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 - 一个类图显示了最重要的通用集合'
- en: and the interfaces they implement.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 和它们实现的接口。
- en: '](img/Figure_7.3_B12346.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.3_B12346.jpg)'
- en: Figure 7.3 – A class diagram showing the most important generic collections
    and the interfaces they implement.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 - 一个类图显示了最重要的通用集合和它们实现的接口。
- en: 'The inheritance hierarchy shown in these diagrams is actually a simplification
    of the actual one. All the generic collections have a non-generic equivalent.
    For instance, `IEnumerable<T>` is the generic equivalent of `IEnumerable`, `ICollection<T>`
    is the generic equivalent of `ICollection`, `IList<T>` is the generic equivalent
    of `Ilist`, and so on. These are legacy interfaces that are implemented by legacy
    collections such as `ArrayList`, `Queue`, `Stack`, `DictionaryBase`, `Hashtable`,
    and so on, all of which are available in the `System.Collections` namespace. These
    non-generic legacy collections are not strongly typed. Using generic collections
    is preferred for several reasons:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图表中显示的继承层次实际上是实际继承层次的简化。所有的通用集合都有一个非通用的等价物。例如，`IEnumerable<T>`是`IEnumerable`的通用等价物，`ICollection<T>`是`ICollection`的通用等价物，`IList<T>`是`Ilist`的通用等价物，依此类推。这些是由`ArrayList`、`Queue`、`Stack`、`DictionaryBase`、`Hashtable`等遗留集合实现的遗留接口，所有这些都在`System.Collections`命名空间中可用。这些非通用的遗留集合没有强类型。出于几个原因，使用通用集合是首选的：`
- en: They offer the benefit of type safety. There is no need to derive from a base
    collection and implement type-specific members.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供了类型安全的好处。不需要从基本集合派生并实现特定类型的成员。
- en: They have better performance for value types because there is no boxing and
    unboxing of elements, a process that is necessary with a non-generic collection.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于值类型，它们具有更好的性能，因为没有元素的装箱和拆箱，这是非通用集合中必要的过程。
- en: Some of the generic collections provide functionalities that are not available
    in the non-generic ones, such as methods that accept delegates that can be used
    for searching or performing an action of each element.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些通用集合提供了非通用集合中不可用的功能，比如接受委托用于搜索或对每个元素执行操作的方法。
- en: 'When you need to pass collections as arguments to functions or return collections
    from functions, you should avoid using concrete implementations and prefer using
    interfaces. `IEnumerable<T>` is suitable when you only want to iterate through
    the elements, but if you need to do that multiple times, you could use `IReadOnlyCollection<T>`.
    Read-only collections should be preferred in two cases:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要将集合作为参数传递给函数或从函数返回集合时，应该避免使用具体的实现，而是使用接口。当你只想遍历元素时，`IEnumerable<T>`是合适的，但如果你需要多次这样做，你可以使用`IReadOnlyCollection<T>`。只读集合应该在两种情况下被优先选择：
- en: When a method does not modify the collection passed as an argument
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个方法不修改作为参数传递的集合时
- en: When you return a collection if the collection is already in memory and the
    caller is not supposed to modify it
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你返回一个集合，如果集合已经在内存中，调用者不应该修改它
- en: Ultimately, the most suitable interface varies from case to case.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，最合适的接口因情况而异。
- en: In the following sections, we will introduce each of the most widely used type-safe
    generic collections. The non-generic collections are of little interest outside
    legacy code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将介绍最常用的类型安全的泛型集合。非泛型集合在遗留代码之外几乎没有什么意义。
- en: The List<T> collection
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: List<T> 集合
- en: The `List<T>` generic class represents a collection of elements that can be
    accessed by their index. `List<T>` is very similar to arrays, except that the
    size of the collection is not fixed but variable, and it can grow or decrease
    as elements are added or removed. In fact, the implementation of `List<T>` uses
    an array to store the elements. When the number of elements exceeds the size of
    the array, a new and larger array is allocated, and the content of the previous
    array is copied to the new one. This means that `List<T>` stores the elements
    in contiguous memory locations. However, for value types, these locations contain
    the values, but for reference types, they contain references to the actual objects.
    Multiple references to the same object can be added to a list.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>` 泛型类表示可以通过索引访问其元素的集合。`List<T>` 与数组非常相似，只是集合的大小不是固定的，而是可变的，可以随着元素的添加或删除而增长或减少。事实上，`List<T>`
    的实现使用数组来存储元素。当元素的数量超过数组的大小时，将分配一个新的更大的数组，并将先前数组的内容复制到新数组中。这意味着 `List<T>` 在连续的内存位置中存储元素。但是，对于值类型，这些位置包含值，但对于引用类型，它们包含对实际对象的引用。可以将对同一对象的多个引用添加到列表中。'
- en: 'The `List<T>` class implements a series of generic and non-generic interfaces,
    as shown in the following declaration of the class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>` 类实现了一系列泛型和非泛型接口，如下面的类声明所示：'
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A list can be created in several ways:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以通过几种方式创建：
- en: Using the default constructor, which results in an empty list with a default
    capacity.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认构造函数，这会导致一个具有默认容量的空列表。
- en: By specifying a particular capacity but no initial elements, which again leaves
    the list empty.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指定特定的容量但没有初始元素，这会再次使列表为空。
- en: From a collection of elements.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一系列元素中。
- en: 'In the following example, `numbers` is an empty list of integers and `words`
    is an empty list of strings:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`numbers` 是一个空的整数列表，`words` 是一个空的字符串列表：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On the other hand, the following sample initializes the list with some elements.
    The first list will contain six integers and the second list will contain two
    strings:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下示例初始化了一些元素的列表。第一个列表将包含六个整数，第二个列表将包含两个字符串：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This class supports all the typical operations that you would expect from such
    a collection—adding, removing, and searching elements. There are several ways
    to add elements to the list:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类支持你从这样的集合中期望的所有典型操作——添加、删除和搜索元素。有几种方法可以向列表中添加元素：
- en: '`Add()` adds an element to the end of the list.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add()` 将元素添加到列表的末尾。'
- en: '`AddRange()` adds a collection of elements (in the form of an `IEnumerable<T>`)
    to the end of the list.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddRange()` 将一系列元素（以 `IEnumerable<T>` 的形式）添加到列表的末尾。'
- en: '`Insert()` inserts an element at the specified position. The position must
    be a valid index, within the bounds of the list; otherwise, an `ArgumentOutOfRangeException`
    exception is thrown.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Insert()` 在指定位置插入一个元素。位置必须是有效的索引，在列表的范围内；否则，将抛出 `ArgumentOutOfRangeException`
    异常。'
- en: '`InsertRange()`inserts a range of elements (in the form of an `IEnumerable<T>`)
    at the specified index, which must be within the bounds of the list.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InsertRange()` 在指定的索引处插入一系列元素（以 `IEnumerable<T>` 的形式），该索引必须在列表的范围内。'
- en: All these operations may require the reallocation of the internal array that
    stores elements if its capacity is exceeded. `Add()` is an *O(1)* operation if
    no allocation is needed and *O(n)* when allocation is necessary.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内部数组的容量超过了，所有这些操作可能需要重新分配存储元素的内部数组。如果不需要分配空间，`Add()` 是一个 *O(1)* 操作，当需要分配空间时，为
    *O(n)*。
- en: '`AddRange()` is *O(n)* if no allocation is necessary and *O(n+k)* if allocations
    are needed. `Insert()` is always an *O(n)* operation, and `InsertRange()` is *O(n)*
    if no allocation is needed and *O(n+k)* if an allocation is necessary. In this
    notation, *n* is the number of elements in the list and *k* is the number of elements
    to add. We can see an example of these operations in the following sample:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要分配空间，`AddRange()` 的时间复杂度为 *O(n)*，如果需要分配空间，则为 *O(n+k)*。`Insert()` 操作始终为
    *O(n)*，`InsertRange()` 如果不需要分配空间，则为 *O(n)*，如果需要分配空间，则为 *O(n+k)*。在这个表示法中，*n* 是列表中的元素数量，*k*
    是要添加的元素数量。我们可以在以下示例中看到这些操作的示例：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Removing the elements is also possible in several ways using different methods:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的方法也可以以几种方式删除元素：
- en: '`Remove()` removes the specified element from the list.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Remove()` 从列表中删除指定的元素。'
- en: '`RemoveAt()` removes the element at the specified index, which must be within
    the bounds of the list.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveAt()` 删除指定索引处的元素，该索引必须在列表的范围内。'
- en: '`RemoveRange()` removes the specified number of elements, starting with the
    given index.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveRange()` 删除指定数量的元素，从给定的索引开始。'
- en: '`RemoveAll()` removes all the elements in the list that meet the requirements
    of the supplied predicate.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveAll()` 删除列表中满足提供的谓词要求的所有元素。'
- en: '`Clear()` removes all the elements in the list.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clear()` 删除列表中的所有元素。'
- en: 'All these operations are performed in *O(n)*, where *n* is the number of elements
    in the list. The exception is `RemoveAt()`, where *n* is `Count - index`. The
    reason for this is that the elements must be moved within the internal array after
    one has been removed. Examples of using these functions are shown in the following
    snippet:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作都在 *O(n)* 中执行，其中 *n* 是列表中的元素数量。`RemoveAt()` 是一个例外，其中 *n* 是 `Count - index`。原因是在删除一个元素后，必须在内部数组中移动元素。使用这些函数的示例在以下代码片段中显示：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is possible to search for elements in the list by specifying a predicate.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过指定谓词来搜索列表中的元素。
- en: Information box
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 信息框
- en: A **predicate** is a delegate that returns a bool. They are typically used when
    you filter elements, such as when you search through a collection.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**谓词** 是返回布尔值的委托。它们通常用于过滤元素，例如在搜索集合时。'
- en: 'There are several methods that can be used to search elements:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种可以用于搜索元素的方法：
- en: '`Find()` returns the first element that matches the predicate or the default
    value of `T` if none is found.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Find()` 返回与谓词匹配的第一个元素，如果找不到则返回`T`的默认值。'
- en: '`FindLast()` returns the last element that matches the predicate or the default
    value of `T` if none is found.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FindLast()` 返回与谓词匹配的最后一个元素，如果找不到则返回`T`的默认值。'
- en: '`FindAll()` returns a `List<T>` with all the elements that match the predicate
    or an empty list if none is found.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FindAll()` 返回与谓词匹配的所有元素的`List<T>`，如果找不到则返回一个空列表。'
- en: 'All these methods are performed in *O(n)*, as shown in the following code snippet:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都在*O(n)*中执行，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is possible to search for the zero-based index of an element as well. There
    are several methods that allow us to do that:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以搜索元素的从零开始的索引。有几种方法允许我们这样做：
- en: '`IndexOf()` returns the index of the first element that is equal to the supplied
    argument.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IndexOf()` 返回与提供的参数相等的第一个元素的索引。'
- en: '`LastIndexOf()` returns the last index of the searched element.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LastIndexOf()` 返回搜索元素的最后一个索引。'
- en: '`FindIndex()` returns the index of the first element that satisfies the supplied
    predicate.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FindIndex()` 返回满足提供的谓词的第一个元素的索引。'
- en: '`FindLastIndex()` returns the index of the last element that satisfies the
    supplied predicate.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FindLastIndex()` 返回满足提供的谓词的最后一个元素的索引。'
- en: '`BinarySearch()` returns the index of the first element that satisfies the
    supplied element or a comparer using binary search. This function assumes that
    the list is already sorted; otherwise, the result is incorrect.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BinarySearch()` 使用二进制搜索返回满足提供的元素或比较器的第一个元素的索引。此函数假定列表已经排序；否则，结果是不正确的。'
- en: '`BinarySearch()` is performed in *O(log n)*, while all the others are performed
    in *O(n)*. This is because they use linear search. They all return `-1` if no
    element that satisfies the search criteria is found. Examples are shown in the
    following listing:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinarySearch()` 在*O(log n)*中执行，而其他所有操作都在*O(n)*中执行。这是因为它们使用线性搜索。如果找不到满足搜索条件的元素，它们都返回`-1`。示例如下所示：'
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are methods that allow us to modify the content of the list, such as
    by sorting the elements or reverting them:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些方法允许我们修改列表的内容，例如对元素进行排序或反转：
- en: '`Sort()` sorts the list according to a default or specified criteria. There
    are several overloads that allow us to specify either a comparison delegate or
    an `IComparer<T>` object, or even a sub-range of the list to sort. This operation
    is performed in *O(n log n)* in most cases but *O (n2)* in the worst-case scenario.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sort()` 根据默认或指定的条件对列表进行排序。有几个重载允许我们指定比较委托或`IComparer<T>`对象，甚至是要排序的列表的子范围。在大多数情况下，此操作在*O(n
    log n)*中执行，但在最坏的情况下为*O(n2)*。'
- en: '`Reverse()` reverses the elements in the list. There is an overload that allows
    you to specify a sub-range to revert. This operation is performed in *O(n)*.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reverse()` 反转列表中的元素。有一个重载允许您指定要恢复的子范围。此操作在*O(n)*中执行。'
- en: 'Examples of using these functions are shown as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用这些函数的示例：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are more methods in the `List<T>` class than those shown here. However,
    going through all of them is beyond the scope of this book. You should look up
    the official documentation of the class online for a complete reference to all
    the members of this class.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>`类中有更多的方法，不仅限于此处显示的方法。但是，浏览所有这些方法超出了本书的范围。您应该在线查阅该类的官方文档，以获取该类所有成员的完整参考。'
- en: The Stack<T> collection
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Stack<T>`集合'
- en: A stack is a linear data structure that allows us to insert and delete items
    in a particular order. New items are added at the top of the stack. If we want
    to remove an item from the stack, we can only remove the top item. Since insertion
    and deletion is allowed from only one end, the item to be inserted last will be
    the item to be deleted first. Therefore, the stack is called a **Last in**, **First
    Out (LIFO)** collection.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种线性数据结构，允许我们按特定顺序插入和删除项目。新项目添加到栈顶。如果要从栈中移除项目，只能移除顶部项目。由于只允许从一端插入和删除，因此最后插入的项目将是首先删除的项目。因此，栈被称为**后进先出（LIFO）**集合。
- en: 'The following diagram depicts a stack, where *push* represents adding an item
    to the stack and *pop* represents deleting an item from the stack:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了一个栈，其中*push*表示向栈中添加项目，*pop*表示从栈中删除项目：
- en: '![Figure 7.4 – The conceptual representation of a stack.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 - 栈的概念表示。'
- en: '](img/Figure_7.4_B12346.png)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.4_B12346.png)'
- en: Figure 7.4 – The conceptual representation of a stack.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 - 栈的概念表示。
- en: '.NET provides the generic `Stack<T>` class for working with stacks. This class
    contains several constructors that allow us to create either an empty stack or
    a stack initialized with a collection of elements. Take a look at the following
    code snippet, where we are creating a stack of strings with three initial elements
    and an empty stack of integers:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: .NET提供了用于处理栈的通用`Stack<T>`类。该类包含几个构造函数，允许我们创建空栈或使用元素集合初始化栈。看一下以下代码片段，我们正在创建一个包含三个初始元素和一个空整数栈的字符串栈：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The primary operations that are supported by the stack are as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 栈支持的主要操作如下：
- en: '`Push()`: Inserts an item at the top of the stack. This is an *O(1)* operation
    if no reallocation is necessary and *O(n)* otherwise.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Push()`: 在栈顶插入一个项目。如果不需要重新分配，则这是一个*O(1)*操作，否则为*O(n)*。'
- en: '`Pop()`: Removes and returns the item from the top of the stack. This is an
    *O(1)* operation.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pop()`: 从栈顶移除并返回项目。这是一个*O(1)*操作。'
- en: '`Peek()`: Returns an item from the top of the stack without removing it. This
    is an *O(1)* operation.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Peek()`: 返回栈顶的项目，而不移除它。这是一个*O(1)*操作。'
- en: '`Clear()`: Removes all the elements from the stack. This is an *O(n)* operation.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clear()`: 从栈中移除所有元素。这是一个*O(n)*操作。'
- en: 'Let''s understand how these work with the help of the following example where,
    on the left, you can see the contents of the stack after each operation:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来理解它们是如何工作的，在左侧，您可以看到每个操作后栈的内容：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Pop()` and `Peek()` methods throw an `InvalidOperationException` exception
    if the stack is empty. In .NET Core, since version 2.0, two alternative non-throwing
    methods are available—`TryPop()` and `TryPeek()`. These methods return a Boolean
    value indicating whether a top element was found and if so, it is returned as
    an `out` argument.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pop()`和`Peek()`方法如果栈为空会抛出`InvalidOperationException`异常。在.NET Core中，自2.0版本以来，有两种替代的非抛出方法可用——`TryPop()`和`TryPeek()`。这些方法返回一个布尔值，指示是否找到了顶部元素，如果找到了，它将作为`out`参数返回。'
- en: The Queue<T> collection
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列<T>集合
- en: 'A queue is a linear data structure where insertion and deletion of elements
    is performed from two different ends. A new item is added from the rear end of
    the queue and deletion of existing items occurs from the front. Therefore, the
    item to be inserted first will be the item to be deleted first. Because of this,
    the queue is called a **First in**, **First Out (FIFO)** collection. The following
    diagram depicts a queue, where **Enqueue** represents adding an item to the queue
    and **Dequeue** represents deleting an item from the queue:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是一种线性数据结构，其中插入和删除元素是从两个不同的端口执行的。新项目从队列的后端添加，现有项目的删除从前端进行。因此，要首先插入的项目将是要首先删除的项目。因此，队列被称为**先进先出（FIFO）**集合。下图描述了一个队列，其中**Enqueue**表示向队列添加项目，**Dequeue**表示从队列中删除项目：
- en: '![Figure 7.5 – The conceptual representation of a queue.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – 队列的概念表示。'
- en: '](img/Figure_7.5_B12346.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.5_B12346.jpg)'
- en: Figure 7.5 – The conceptual representation of a queue.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 队列的概念表示。
- en: 'In .NET, the class that implements a generic queue is `Queue<T>`. Similarly,
    with `Stack<T>`, there are overloaded constructors that allow us to create an
    empty queue or a queue initialized with elements from an `IEnumerable<T>` collection.
    Take a look at the following code snippet, where we are creating a queue of strings
    with three initial elements and an empty queue of integers:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，实现通用队列的类是`Queue<T>`。类似于`Stack<T>`，有重载的构造函数，允许我们创建一个空队列或一个从`IEnumerable<T>`集合中的元素初始化的队列。看一下下面的代码片段，我们正在创建一个包含三个初始元素的字符串队列和一个空的整数队列：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The primary operations that are supported for the queue are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 队列支持的主要操作如下：
- en: '`Enqueue()`: Inserts an item at the end of the queue. This operation is *O(1)*
    unless the internal array needs to be reallocated, in which case it becomes an
    *O(n)* operation.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enqueue()`: 在队列的末尾插入一个项目。这是一个*O(1)*操作，除非需要重新分配内部数组，否则它将成为一个*O(n)*操作。'
- en: '`Dequeue()`: Removes and returns an item from the front of the queue. This
    is an *O(1)* operation.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dequeue()`: 从队列的前端移除并返回一个项目。这是一个*O(1)*操作。'
- en: '`Peek()`: Returns an item from the front of the queue without removing it.
    This is an *O(1)* operation.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Peek()`: 从队列的前端返回一个项目，但不移除它。这是一个*O(1)*操作。'
- en: '`Clear()`: Removes all the elements from the queue. This is an *O(n)* operation.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clear()`: 从队列中移除所有元素。这是一个*O(n)*操作。'
- en: 'To understand how these methods work, let''s look at the following example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这些方法如何工作，让我们看下面的例子：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Dequeue()` and `Peek()` methods throw an `InvalidOperationException` exception
    if the queue is empty. In .NET Core, since version 2.0, two alternatives non-throwing
    methods are available—`TryDequeue()` and `TryPeek()`. These methods return a Boolean
    value indicating whether a top element was found and if so, it is returned as
    an out argument.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dequeue()`和`Peek()`方法如果队列为空会抛出`InvalidOperationException`异常。在.NET Core中，自2.0版本以来，有两种替代的非抛出方法可用——`TryDequeue()`和`TryPeek()`。这些方法返回一个布尔值，指示是否找到了顶部元素，如果找到了，它将作为一个out参数返回。'
- en: As you can see from these examples, `Stack<T>` and `Queue<T>` have very similar
    implementations, although the semantics are different. Their public members are
    almost the same, with the difference being that the stack operations are called
    `Push()` and `Pop()` and the queue operations are called `Enqueue()` and `Dequeue()`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些示例中可以看出，`Stack<T>`和`Queue<T>`有非常相似的实现，尽管语义不同。它们的公共成员几乎相同，不同之处在于栈操作称为`Push()`和`Pop()`，队列操作称为`Enqueue()`和`Dequeue()`。
- en: The LinkedList<T> collection
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LinkedList<T>集合
- en: 'A linked list is a linear data structure that consists of a group of nodes
    where each node contains data as well as the address of one or more nodes. There
    are four types of linked list, as described here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 链表是一种线性数据结构，由一组节点组成，每个节点包含数据以及一个或多个节点的地址。这里有四种类型的链表，如下所述：
- en: '**Singly Linked List**: This contains nodes that store a value and a reference
    to the next node in the sequence of nodes. The reference to the next node of the
    last node will point to null.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单链表**：包含存储值和对节点序列中下一个节点的引用的节点。最后一个节点的下一个节点的引用将指向null。'
- en: '**Doubly Linked List**: Here, each node contains two links – the first link
    points to the previous node and the next link points to the next node in the sequence.
    The reference to the previous node of the first node and the reference to the
    next node of the last node will point to null.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向链表**：在这里，每个节点包含两个链接——第一个链接指向前一个节点，下一个链接指向序列中的下一个节点。第一个节点的上一个节点的引用和最后一个节点的下一个节点的引用将指向null。'
- en: '**Circular Singly Linked List**: The reference to the next node of the last
    node will point to the first node, thus forming a circular chain.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环单链表**：最后一个节点的下一个节点的引用将指向第一个节点，从而形成一个循环链。'
- en: '**Doubly Circular Linked List**: In this type of linked list, the reference
    to the next node of the last node will point to the first node and the reference
    to the previous node of the first node will point to the last node.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向循环链表**：在这种类型的链表中，最后一个节点的下一个节点的引用将指向第一个节点，第一个节点的上一个节点的引用将指向最后一个节点。'
- en: 'A conceptual representation of the doubly linked list is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表的概念表示如下：
- en: '![Figure 7.6 – A conceptual representation of a doubly linked-list.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6 – 双向链表的概念表示。'
- en: '](img/Figure_7.6_B12346.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.6_B12346.jpg)'
- en: Figure 7.6 – A conceptual representation of a doubly linked-list.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 双向链表的概念表示。
- en: Here, each node contains a value and two pointers. The **Next** pointer contains
    a reference to the next node in the sequence and allows easy navigation in the
    forward direction of the linked list. The **Prev** pointer contains a reference
    to the previous node in the sequence and allows us to move backward in the linked
    list.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个节点包含一个值和两个指针。**Next** 指针包含对序列中下一个节点的引用，并允许在链表的正向方向上进行简单导航。**Prev** 指针包含对序列中前一个节点的引用，并允许我们在链表中向后移动。
- en: .NET provides the `LinkedList<T>` class, which represents a doubly linked list.
    This class contains items of the `LinkedListNode<T>` type. Insertion and removal
    operations are performed in *O(1)* and searching is performed in *O(n)*. Nodes
    can be removed and reinserted either in the same linked list object or another.
    The list maintains an internal count, so retrieving the size of the list using
    the `Count` property is also an *O(1)* operation. The linked list does not support
    cycles, splitting, chaining, or anything else that can leave the list in an inconsistent
    state.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 提供了 `LinkedList<T>` 类，表示双向链表。该类包含 `LinkedListNode<T>` 类型的项。插入和删除操作在 *O(1)*
    中执行，搜索在 *O(n)* 中执行。节点可以从同一链表对象或另一个链表中移除和重新插入。列表维护内部计数，因此使用 `Count` 属性检索列表的大小也是
    *O(1)* 操作。链表不支持循环、分割、链接或其他可能使列表处于不一致状态的操作。
- en: 'The `LinkedListNode<T>` class has the following four properties:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedListNode<T>` 类具有以下四个属性：'
- en: '`List`: This property will return the reference to the `LinkedList<T>` object
    to which `LinkedListNode<T>` belongs.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List`：此属性将返回对 `LinkedList<T>` 对象的引用，该对象属于 `LinkedListNode<T>`。'
- en: '`Next`: Represents the reference to the next node in the `LinkedList<T>` object
    or `null` if the current node is the last node.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Next`：表示对 `LinkedList<T>` 对象中下一个节点的引用，如果当前节点是最后一个节点，则为 `null`。'
- en: '`Previous`: Represents the reference to the previous node in the `LinkedList<T>`
    object or `null` if the current node is the first node.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Previous`：表示对 `LinkedList<T>` 对象中前一个节点的引用，如果当前节点是第一个节点，则为 `null`。'
- en: '`Value`: This property is of type `T` and represents the value contained in
    the node.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Value`：此属性的类型为 `T`，表示节点中包含的值。'
- en: For value types, `LinkedListNode<T>` contains the actual value, whereas for
    reference types, it contains a reference to the object.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于值类型，`LinkedListNode<T>` 包含实际值，而对于引用类型，它包含对对象的引用。
- en: 'The class has overloaded constructors that enable us to create an empty linked
    list or one initialized with a sequence of elements, in the form of an `IEnumerable<T>`.
    Take a look at the following sample to see some examples:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 该类具有重载的构造函数，使我们能够创建一个空的链表或一个以 `IEnumerable<T>` 形式的元素序列进行初始化的链表。看一下以下示例，看一些示例：
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Adding new elements to the linked list is possible in several ways using the
    following methods:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方法可以以多种方式向链表添加新元素：
- en: '`AddFirst()` adds a new node or value at the beginning of the list.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddFirst()` 在列表开头添加一个新节点或值。'
- en: '`AddLast()` adds a new node or value at the end of the list.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddLast()` 在列表末尾添加一个新节点或值。'
- en: '`AddAfter()` adds a new node or value in the list after the specified node.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddAfter()` 在指定节点之后的列表中添加一个新节点或值。'
- en: '`AddBefore()` adds a new node or value in the list before the specified node.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddBefore()` 在指定节点之前的列表中添加一个新节点或值。'
- en: 'We can see examples of the overload that adds a new value for each of these
    methods in the following sample:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下示例中看到为这些方法添加新值的重载的示例：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Searching for elements in a linked list can be performed using one of the following
    methods:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下方法之一在链表中搜索元素：
- en: '`Contains()`: This checks whether a specified value is found in the list and
    returns a Boolean value to indicate success or failure.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Contains()`：这检查指定的值是否在列表中，并返回一个布尔值以指示成功或失败。'
- en: '`Find()`: This finds and returns the first node that contains the specified
    value.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Find()`：查找并返回包含指定值的第一个节点。'
- en: '`FindLast()`: This finds and returns the last node that contains the specified
    value.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FindLast()`：查找并返回包含指定值的最后一个节点。'
- en: 'Examples of using these functions are shown here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用这些函数的示例：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Removing elements from the list can be done in several ways using the following
    methods:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方法可以以多种方式从列表中移除元素：
- en: '`RemoveFirst()` removes the first node in the list.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveFirst()` 从列表中移除第一个节点。'
- en: '`RemoveLast()` removes the last node in the list.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveLast()` 移除列表中的最后一个节点。'
- en: '`Remove()` removes the specified node or the first occurrence of the specified
    value from the list.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Remove()` 从列表中移除指定的节点或指定值的第一个出现。'
- en: '`Clear()` removes all the elements from the list.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clear()` 从列表中移除所有元素。'
- en: 'You can see all these methods at work in the following listing:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下列表中看到所有这些方法的工作方式：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The linked list class also has several properties, including `Count`, which
    returns the number of elements in the list, `First`, which returns the first node,
    and `Last`, which returns the last node. If the list is empty, then `Count` is
    `0` and `First` and `Last` are both set to `null`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 链表类还具有几个属性，包括 `Count`，它返回列表中的元素数量，`First`，它返回第一个节点，以及 `Last`，它返回最后一个节点。如果列表为空，则
    `Count` 为 `0`，`First` 和 `Last` 都设置为 `null`。
- en: The Dictionary<TKey, TValue> collection
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Dictionary<TKey, TValue>` 集合'
- en: A dictionary is a collection of key-value pairs that allows fast lookup based
    on a key. Adding, searching, and deleting an item are very fast operations and
    are performed in *O(1)*. The exception here is adding a new value if the capacity
    must be increased, in which case it becomes *O(n)*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是一组键值对，允许根据键进行快速查找。添加、搜索和删除项目都是非常快速的操作，并且在 *O(1)* 中执行。唯一的例外是在必须增加容量时添加新值，此时它变为
    *O(n)*。
- en: In .NET, the generic `Dictionary<TKey,TValue>` class implements a dictionary.
    `TKey` represents the type of the key and `TValue` represents the type of the
    value. The elements of the dictionary are `KeyValuePair<TKey,TValue>` objects.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，泛型`Dictionary<TKey,TValue>`类实现了一个字典。`TKey`表示键的类型，`TValue`表示值的类型。字典的元素是`KeyValuePair<TKey,TValue>`对象。
- en: '`Dictionary<TKey, TValue>` has several overloaded constructors that allow us
    to create an empty dictionary or a dictionary filled with some initial values.
    The default constructor of this class will create an empty dictionary. Take a
    look at the following code snippet:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dictionary<TKey, TValue>`有几个重载的构造函数，允许我们创建一个空字典或一个填充了一些初始值的字典。该类的默认构造函数将创建一个空字典。看一下以下代码片段：'
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we are creating an empty dictionary called `languages` that has a key
    of the `int` type and a value of the `string` type. We can also initialize a dictionary
    at the time of declaration. Consider the following code snippet:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个名为`languages`的空字典，它具有`int`类型的键和`string`类型的值。我们还可以在声明时初始化字典。考虑以下代码片段：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we are creating a dictionary that is initialized with four values that
    have the keys `1`, `2`, `3`, and `4`. This is semantically equivalent to the following
    initialization:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个字典，该字典初始化了四个具有键`1`、`2`、`3`和`4`的值。这在语义上等同于以下初始化：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A dictionary must contain unique keys; however, the value can be *duplicated*.
    Similarly, a key cannot be `null`, but a value (if it is of a reference type)
    can be `null`. To add, remove, or search for dictionary values, we can use the
    following methods:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 字典必须包含唯一的键；但是，值可以是*重复*的。同样，键不能是`null`，但是值（如果是引用类型）可以是`null`。要添加、删除或搜索字典值，我们可以使用以下方法：
- en: '`Add()`: This adds a new value with the specified key to the dictionary. If
    the key is `null` or the key already exists in the dictionary, an exception is
    thrown.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add()`：这向字典中添加具有指定键的新值。如果键为`null`或键已存在于字典中，则会抛出异常。'
- en: '`Remove()`: This removes the value with the specified key.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Remove()`：这删除具有指定键的值。'
- en: '`Clear()`: This removes all the values from the dictionary.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clear()`：这从字典中删除所有值。'
- en: '`ContainsKey()`: This checks if the dictionary contains the specified key and
    returns a Boolean value to indicate that.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContainsKey()`：这检查字典是否包含指定的键，并返回一个布尔值以指示。'
- en: '`ContainsValue()`: This checks if the dictionary contains the specified value
    and returns a Boolean value to indicate that. The method performs a linear search;
    therefore, it is an *O(n)* operation.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContainsValue()`：这检查字典是否包含指定的值，并返回一个布尔值以指示。该方法执行线性搜索；因此，它是一个*O(n)*操作。'
- en: '`TryGetValue()`: This checks whether the dictionary contains the specified
    key and if so, it returns the associated value as an `out` argument. The method
    returns `true` if the value was successful fetched or `false` otherwise. If the
    key is not present, the output parameter is set to the default value of the `TValue`
    type (that is, `0` for numerical types, `false` for bool, and `null` for reference
    types).'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TryGetValue()`：这检查字典是否包含指定的键，如果是，则将关联的值作为`out`参数返回。如果成功获取了值，则该方法返回`true`，否则返回`false`。如果键不存在，则输出参数设置为`TValue`类型的默认值（即数值类型为`0`，布尔类型为`false`，引用类型为`null`）。'
- en: In .NET Core 2.0 and newer, there is one additional method called `TryAdd()`
    that attempts to add a new value to the dictionary. The method succeeds only if
    the key is not already present. It returns a Boolean value to indicate success
    or failure.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Core 2.0及更高版本中，还有一个名为`TryAdd()`的额外方法，它尝试向字典中添加新值。该方法仅在键尚未存在时成功。它返回一个布尔值以指示成功或失败。
- en: 'The class also contains a set of properties, the most important of them being
    the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还包含一组属性，其中最重要的是以下属性：
- en: '`Count`: This returns the number of key-value pairs in the dictionary.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Count`：这返回字典中键值对的数量。'
- en: '`Keys`: This returns a collection (of the `Dictionary<TKey,TValue>.KeyCollection`
    type) containing all the keys in the dictionary. The order of the keys in this
    collection is not specified.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Keys`：这返回一个集合（类型为`Dictionary<TKey,TValue>.KeyCollection`）包含字典中的所有键。此集合中键的顺序未指定。'
- en: '`Values`: This returns a collection (of the `Dictionary<TKey,TValue>.ValueCollection`
    type) containing all the values in the dictionary. The order of the values in
    this collection is not specified but it is guaranteed to be in the same order
    as their associated keys in the `Keys` collection.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Values`：这返回一个集合（类型为`Dictionary<TKey,TValue>.ValueCollection`）包含字典中的所有值。此集合中值的顺序未指定，但保证与`Keys`集合中的关联键的顺序相同。'
- en: '`Item[]`: This is an indexer that gets or sets the value associated with the
    specified key. The indexer can be used to add values to the dictionary. If the
    key does not exist, a new key-value pair is added. If the key already exists,
    the value is overwritten.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Item[]`：这是一个索引器，用于获取或设置与指定键关联的值。索引器可用于向字典中添加值。如果键不存在，则会添加新的键值对。如果键已存在，则值将被覆盖。'
- en: 'Take a look at the following sample, where we are creating a dictionary and
    then adding key-value pairs in several ways:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下示例，我们在创建一个字典，然后以几种方式添加键值对：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Initially, the dictionary contained the pairs [1, C#] [2, Java] [3, Python]
    [4, C++] and then we added [5, JavaScript] twice. However, because the second
    time `TryAdd()` is used, the operation will occur without any exception being
    thrown. We then used the indexer to add another pair, [6, F#], and also changed
    the value of the existing key, that is, 5, from JavaScript to TypeScript.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，字典包含了对[1, C#] [2, Java] [3, Python] [4, C++]的配对，然后我们两次添加了[5, JavaScript]。但是，因为第二次使用了`TryAdd()`，操作将在不抛出任何异常的情况下发生。然后我们使用索引器添加了另一对[6,
    F#]，并且还更改了现有键（即5）的值，即从JavaScript更改为TypeScript。
- en: 'We can search through the dictionary with the methods mentioned earlier:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面提到的方法搜索字典：
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can also iterate through the elements of a dictionary using an enumerator,
    in which case the key-value pairs are retrieved as `KeyValuePair<TKey, TValue>`
    objects:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过枚举器遍历字典的元素，在这种情况下，键值对被检索为`KeyValuePair<TKey, TValue>`对象：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To remove elements, we can use either `Remove()` or `Clear()`, with the latter
    for removing all the key-value pairs from the dictionary:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除元素，我们可以使用`Remove()`或`Clear()`，后者用于从字典中删除所有键值对：
- en: '[PRE22]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Another hash-based collection, which only maintains a collection of keys or
    unique values, is `HashSet<T>`. We will look at it in the following section.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个基于哈希的集合，只维护键或唯一值的集合，是`HashSet<T>`。我们将在下一节中看到它。
- en: The HashSet<T> collection
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HashSet<T>集合
- en: A set is a collection that contains only distinct items that can be in any order.
    .NET provides the `HashSet<T>` class for working with sets. This class contains
    methods to handle the elements of the set but also methods to model mathematical
    set operations such as **union** or **intersection**.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一个只包含不同项的集合，可以是任何顺序。.NET提供了`HashSet<T>`类来处理集合。该类包含处理集合元素的方法，还包含建模数学集合操作如**并集**或**交集**的方法。
- en: 'Like all the other collections, `HashSet<T>` contains several overloaded constructors
    that allow us to create either an empty set or a set filled with initial values.
    To declare an empty set, we use the default constructor (which is the constructor
    without parameters):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他集合一样，`HashSet<T>`包含多个重载的构造函数，允许我们创建空集或填充有初始值的集合。要声明一个空集，我们使用默认构造函数（即没有参数的构造函数）：
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'But we can also initialize the set with some values, as shown in the following
    example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以使用一些值初始化集合，如下例所示：
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To work with a set, we can use the following methods:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用集合，我们可以使用以下方法：
- en: '`Add()` adds a new element to the set if the element is not already present.
    The function returns a Boolean value to indicate success or failure.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add()` 如果元素尚未存在，则将新元素添加到集合中。该函数返回一个布尔值以指示成功或失败。'
- en: '`Remove()` removes the specified element from the set.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Remove()` 从集合中移除指定的元素。'
- en: '`RemoveWhere()` removes all the elements that match the supplied predicate
    from the set.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveWhere()` 从集合中删除与提供的谓词匹配的所有元素。'
- en: '`Clear()` removes all the elements from the set.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clear()` 从集合中移除所有元素。'
- en: '`Contains()` checks whether the specified element is present in the set.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Contains()` 检查指定的元素是否存在于集合中。'
- en: 'We can see these methods in action in the following sample:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下示例中看到这些方法的运行情况：
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As mentioned previously, the `HashSet<T>` class provides the following methods
    for mathematical set operations:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`HashSet<T>`类提供了以下数学集合操作的方法：
- en: '`UnionWith()`: This performs the union of two sets. The current set object
    is modified by adding all the elements from the supplied set that are not present
    in the set.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnionWith()`: 这执行两个集合的并集。当前集合对象通过添加来自提供的集合中不在集合中的所有元素来进行修改。'
- en: '`IntersectWith()`: This performs the intersection of two sets. The current
    set object is modified so that it contains only the elements that are also present
    in the supplied set.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntersectWith()`: 这执行两个集合的交集。当前集合对象被修改，以便它仅包含在提供的集合中也存在的元素。'
- en: '`ExceptWith()`: This performs set subtraction. The current set object is modified
    by removing all the elements that are also present in the supplied set.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExceptWith()`: 这执行集合减法。当前集合对象通过移除在提供的集合中也存在的所有元素来进行修改。'
- en: '`SymmetricExceptWith()`: This performs set symmetric difference. The current
    set object is modified to contain only elements that are present either in the
    set or in the supplied set but not in both.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SymmetricExceptWith()`: 这执行集合对称差。当前集合对象被修改为仅包含存在于集合或提供的集合中的元素，但不包含两者都存在的元素。'
- en: 'Examples of using these methods are shown in the following listing:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法的示例在以下清单中显示：
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In addition to these mathematical set operations, the class also provides methods
    for determining set equality, overlapping, or whether a set is a subset or superset
    of another. Some of these methods are listed here:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些数学集合操作，该类还提供了用于确定集合相等性、重叠或一个集合是否是另一个集合的子集或超集的方法。其中一些方法列在这里：
- en: '`Overlaps()` determines whether the current set and the supplied set contain
    any common elements. The method returns `true` if at least one common element
    exists or `false` otherwise.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Overlaps()` 确定当前集合和提供的集合是否包含任何共同元素。如果至少存在一个共同元素，则该方法返回`true`，否则返回`false`。'
- en: '`IsSubsetOf()` determines if the current set is a subset of another set, which
    means that all its elements are also present in the other set. An empty set is
    a subset of any set.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsSubsetOf()` 确定当前集合是否是另一个集合的子集，这意味着它的所有元素也存在于另一个集合中。空集是任何集合的子集。'
- en: '`IsSupersetOf()` determines if the current set is a superset of another set,
    which means that the current set contains all the elements of the other set.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsSupersetOf()` 确定当前集合是否是另一个集合的超集，这意味着当前集合包含另一个集合的所有元素。'
- en: 'Examples of using these methods are shown in the following snippet:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法的示例在以下片段中显示：
- en: '[PRE27]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `HashSet<T>` class contains other methods and properties. You should check
    the online documentation for a complete reference of the class members.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashSet<T>`类包含其他方法和属性。您应该查看在线文档以获取该类成员的完整参考。'
- en: Choosing the right collection type
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的集合类型
- en: 'So far, we have looked at the most widely used generic collection types, although
    the base class library provides several more. The key question that arises after
    looking at each of them individually is when these collections should be used.
    In this section, we will provide some guidelines for choosing the right collection.
    Let''s take a look:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过最常用的泛型集合类型，尽管基类库提供了更多。在单独查看每个集合后出现的关键问题是何时应该使用这些集合。在本节中，我们将提供一些选择正确集合的指南。让我们来看一下：
- en: '`List<T>` is the default collection to use when you need to store elements
    contiguously and access them directly and you don''t have other specific constraints.
    Elements of the list can be accessed directly by their index. Adding and removing
    elements at the end is very efficient, but doing so at the beginning or middle
    is costly because it involves moving at least some of the elements.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<T>` 是在需要连续存储元素并直接访问它们时的默认集合，而且没有其他特定约束时可以使用。列表的元素可以通过它们的索引直接访问。在末尾添加和删除元素非常高效，但在开头或中间这样做是昂贵的，因为它涉及移动至少一些元素。'
- en: '`Stack<T>` is the typical choice when you need a sequential list with the elements
    typically discarded after being retrieved in a LIFO manner. Elements are added
    and removed from the top of the stack, both operations requiring constant time.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stack<T>` 是在需要按 LIFO 方式检索后通常丢弃元素的顺序列表时的典型选择。元素从栈顶添加和移除，这两个操作都需要恒定时间。'
- en: '`Queue<T>` is a good choice when you need a sequential list with the elements
    also discarded after being retrieved but in a FIFO manner. Elements are added
    at the end and removed from the top of the queue. Both operations are very fast.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Queue<T>` 是在需要按 FIFO 方式检索后也通常丢弃元素的顺序列表时的一个不错的选择。元素在末尾添加并从队列顶部移除。这两个操作都非常快。'
- en: '`LinkedList<T>` is useful when you need to add and remove many elements from
    the middle of the list and do it quickly. However, this comes at the expense of
    the ability to randomly access the elements of the list (by their index). The
    linked list does not store its elements contiguously and you must traverse the
    list from one end in order to find an element.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkedList<T>` 在需要快速添加和删除列表中的许多元素时非常有用。然而，这是以牺牲通过索引随机访问列表元素的能力为代价。链表不会连续存储其元素，您必须从一端遍历列表以找到一个元素。'
- en: '`Dictionary<TKey, TValue>` should be used when you need to store values associated
    with a key. Inserts, deletes, and lookups are very fast – they require constant
    time, regardless of the size of the dictionary. The implementation uses a hash
    table, which means the keys are hashed and therefore the type of the key must
    implement `GetHashCode()` and `Equals()`. Alternatively, you need to provide an
    `IEqualityComparer` implementation upon the construction of the dictionary object.
    The elements of a dictionary are stored unordered, which prevents you from traversing
    the values in the dictionary in a particular order.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dictionary<TKey, TValue>` 应该在需要存储与键关联的值时使用。插入、删除和查找都非常快 - 无论字典的大小如何，都需要恒定时间。实现使用哈希表，这意味着键被哈希，因此键的类型必须实现
    `GetHashCode()` 和 `Equals()`。或者，您需要在构建字典对象时提供 `IEqualityComparer` 实现。字典的元素是无序存储的，这会阻止您以特定顺序遍历字典中的值。'
- en: '`HashSet<T>` is the collection you can use when you need a list of unique values.
    Inserts, deletes, and lookups are very efficient. The elements are stored unordered
    but contiguously. A hash set is logically similar to a dictionary, where the values
    are also the keys, although it is a non-associative container. For this reason,
    the type of its elements must implement `GetHashCode()` and `Equals()`, or, alternatively,
    you must provide an `IEqualityComparer` implementation upon the construction of
    the hash set.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HashSet<T>` 是在需要唯一值列表时可以使用的集合。插入、删除和查找非常高效。元素无序但连续存储。哈希集合在逻辑上类似于字典，其中值也是键，尽管它是一个非关联容器。因此，其元素的类型必须实现
    `GetHashCode()` 和 `Equals()`，或者在构建哈希集合时必须提供 `IEqualityComparer` 实现。'
- en: 'The following table summarizes the information from the previous list:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了前面列表中的信息：
- en: '![](img/Chapter_7Table_1_01.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_7Table_1_01.jpg)'
- en: If performance is key for your application, then, regardless of the choice you
    make based on guidelines and best practices, it is important to measure to see
    if the chosen collection type fits your requirements. Also, keep in mind that
    there are more collections in the base class library than the ones discussed in
    this chapter. `SortedList<TKey, TValue>`, `SortedDictionary<TKey, TValue>`, and
    `SortedSet<T>` could also be valuable in some particular scenarios.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果性能对您的应用程序至关重要，那么无论您基于指南和最佳实践做出何种选择，都很重要的是要进行测量，以查看所选的集合类型是否符合您的要求。此外，请记住，基类库中有比本章讨论的更多的集合。在某些特定场景中，`SortedList<TKey,
    TValue>`、`SortedDictionary<TKey, TValue>` 和 `SortedSet<T>` 也可能很有价值。
- en: Using thread-safe collections
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程安全集合
- en: The generic collections we have seen so far are not thread-safe. This means
    that when they're used in multithreading scenarios, you need to protect access
    to these collections with external locks, which in many cases can *degrade* performance.
    .NET offers several thread-safe collections that use efficient locking and lock-free
    synchronization mechanisms to achieve thread-safety. These collections are provided
    in the `System.Collections.Concurrent` namespace and should be used in scenarios
    where more than one thread is accessing a collection concurrently. However, the
    actual benefit may be smaller or greater than a standard collection being protected
    with an external lock. A discussion about this is provided later in this section.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们看到的泛型集合都不是线程安全的。这意味着在多线程场景中使用它们时，您需要使用外部锁来保护对这些集合的访问，这在许多情况下可能会降低性能。.NET
    提供了几种线程安全的集合，它们使用高效的锁定和无锁同步机制来实现线程安全。这些集合提供在 `System.Collections.Concurrent` 命名空间中，并应在多个线程同时访问集合的场景中使用。然而，实际的好处可能比使用外部锁保护的标准集合要小或大。本节稍后将讨论这个问题。
- en: Information box
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 信息框
- en: The topic of multithreading and asynchronous programming will be addressed in
    [*Chapter 12*](B12346_12_Final_JC_ePub.xhtml#_idTextAnchor215), *Multithreading
    and Async Programming*, where you will learn about threads and tasks, synchronization
    mechanisms, the await/async model, and others.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程和异步编程的主题将在[*第12章*](B12346_12_Final_JC_ePub.xhtml#_idTextAnchor215)中进行讨论，*多线程和异步编程*，您将学习有关线程和任务、同步机制、等待/异步模型等内容。
- en: Although the collections from the `System.Collections.Concurrent` namespace
    are thread-safe, it is not guaranteed that access to their elements through extension
    methods or explicit interface implementations is also thread-safe and they may
    require additional explicit synchronization by the caller.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`System.Collections.Concurrent`命名空间中的集合是线程安全的，但不能保证通过扩展方法或显式接口实现对其元素的访问也是线程安全的，可能需要调用者进行额外的显式同步。
- en: The thread-safe generic collections are available and are discussed in the following
    subsections.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 线程安全的通用集合是可用的，并将在以下小节中进行讨论。
- en: IProducerConsumerCollection<T>
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IProducerConsumerCollection<T>
- en: This is not an actual collection, but an interface that defines methods to manipulate
    thread-safe collections. It provides two methods called `TryAdd()` and `TryTake()`
    that enable adding and removing elements to a collection in a thread-safe way
    and also support cancellation with a `CancellationToken` object.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个实际的集合，而是一个定义了操作线程安全集合的方法的接口。它提供了两个名为`TryAdd()`和`TryTake()`的方法，可以以线程安全的方式向集合添加和移除元素，并且还支持使用`CancellationToken`对象进行取消。
- en: In addition, it has a `ToArray()` method, which copies the element from the
    underlying collection to a new array, and overloads for `CopyTo()`, which copies
    elements of the collection to an array starting at a specified index. All implementations
    must make sure that all the methods of this interface are thread-safe. This interface
    is implemented by `ConcurrentBag<T>`, `ConcurrentStack<T>`, `ConcurrentQueue<T>`,
    and `BlockingCollection<T>`. You can also provide your own implementation if the
    standard ones do not meet your needs.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还有一个`ToArray()`方法，它将元素从基础集合复制到一个新数组，并且有`CopyTo()`的重载，它将集合的元素复制到从指定索引开始的数组。所有实现都必须确保此接口的所有方法都是线程安全的。`ConcurrentBag<T>`、`ConcurrentStack<T>`、`ConcurrentQueue<T>`和`BlockingCollection<T>`都实现了这个接口。如果标准实现不满足您的需求，您也可以提供自己的实现。
- en: BlockingCollection<T>
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BlockingCollection<T>
- en: This is a class that implements the producer-consumer pattern defined by the
    `IProducerConsumerCollection<T>` interface. It is actually a simple wrapper over
    the `IProducerConsumerCollection<T>` interface and does not have an internal underlying
    storage; instead, it must be provided with one (a collection that implements the
    `IProducerConsumerCollection<T>` interface). If no implementation is provided,
    it uses the `ConcurrentQueue<T>` class by default.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实现了`IProducerConsumerCollection<T>`接口定义的生产者-消费者模式的类。它实际上是`IProducerConsumerCollection<T>`接口的简单包装器，并没有内部基础存储；相反，必须提供一个（实现了`IProducerConsumerCollection<T>`接口的集合）。如果没有提供实现，它将默认使用`ConcurrentQueue<T>`类。
- en: The `BlockingCollection<T>` class supports **bounding** and **blocking**. Bounding
    means that you can set the capacity of the collection. That means when the collection
    reaches its maximum capacity, any producer (a thread that adds elements to the
    collection) will block until a consumer (a thread that removes elements from the
    collection) removes an element.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockingCollection<T>`类支持**限制**和**阻塞**。限制意味着您可以设置集合的容量。这意味着当集合达到最大容量时，任何生产者（向集合添加元素的线程）将被阻塞，直到消费者（从集合中移除元素的线程）移除一个元素。'
- en: On the other hand, any consumer that wants to remove an element blocks when
    the collection is empty until a producer adds an element to the collection. Adding
    and removing can be done with either `Add()` and `Take()` or the `TryAdd()` and
    `TryTake()` versions, which, unlike the former, support cancellation. There is
    also a `CompleteAdding()` method that marks the collection as complete, in which
    case further adding is no longer possible, and attempts to remove elements will
    no longer block when the collection is empty.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，任何想要在集合为空时移除元素块的消费者，直到生产者向集合添加元素。添加和移除可以使用`Add()`和`Take()`，也可以使用`TryAdd()`和`TryTake()`版本，与前者不同，它们支持取消操作。还有一个`CompleteAdding()`方法，它将集合标记为完成，这种情况下进一步添加将不再可能，并且在集合为空时尝试移除元素将不再被阻塞。
- en: 'Let''s take a look at an example to understand how this works. In the following
    sample code, we have a task that is producing elements to a `BlockingCollection<int>`
    and two tasks that are consuming from it. The collection is created as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子来理解这是如何工作的。在以下示例代码中，我们有一个任务正在向`BlockingCollection<int>`中生产元素，还有两个任务正在从中消费。集合创建如下：
- en: '[PRE28]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This uses the default constructor of the class, which will instantiate it using
    the `ConcurrentQueue<int>` class as the underlying storage for the collection.
    The producer task is using the blocking collection to add numbers, which in this
    particular case are the first 12 elements of the Fibonacci sequence. Notice that,
    at the end, we are calling `CompleteAdding()` to mark the collection as complete.
    Further attempts to add would fail:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了类的默认构造函数，它将使用`ConcurrentQueue<int>`类作为集合的基础存储来实例化它。生产者任务使用阻塞集合添加数字，在这种特殊情况下是斐波那契序列的前12个元素。请注意，最后，我们调用`CompleteAdding()`来标记集合为完成。进一步尝试添加将失败：
- en: '[PRE29]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first consumer is a task that iterates indefinitely through the collection,
    taking one element at a time. The call to `Take()` blocks the calling thread if
    the collection is empty. However, if the collection is empty and it has been marked
    as complete, the operation will throw `InvalidOperationException`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个消费者是一个任务，它通过集合无限迭代，每次取一个元素。如果集合为空，调用`Take()`会阻塞调用线程。但是，如果集合为空并且已标记为完成，该操作将抛出`InvalidOperationException`：
- en: '[PRE30]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The second consumer is a task that does very similar work. However, instead
    of using an infinite loop, it uses a `foreach` statement. This is possible because
    `BlockingCollection<T>` has a method called `GetConsumingEnumerable()` that retrieves
    `IEnumerable<T>` that makes it possible to remove items from the collection with
    a `foreach` loop or `Parallel.ForEach`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个消费者是一个执行非常相似工作的任务。但是，它使用`foreach`语句而不是使用无限循环。这是因为`BlockingCollection<T>`有一个名为`GetConsumingEnumerable()`的方法，它检索`IEnumerable<T>`，使得可以使用`foreach`循环或`Parallel.ForEach`从集合中移除项目。
- en: 'Unlike the infinite loop, the enumerator provides items until the collection
    is marked as completed. If the collection is empty but not marked as completed,
    then the operation blocks until one item becomes available. The retrieving operation
    can also be canceled by using a `CancellationToken` object when calling `GetConsumingEnumerable()`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 与无限循环不同，枚举器提供项目，直到集合被标记为已完成。如果集合为空但未标记为已完成，则该操作将阻塞，直到有一个项目可用。在调用`GetConsumingEnumerable()`时，检索操作也可以通过使用`CancellationToken`对象进行取消：
- en: '[PRE31]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Having these three tasks, we should wait for them all to complete:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这三个任务，我们应该等待它们全部完成：
- en: '[PRE32]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A possible output from executing this sample is as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此示例的可能输出如下：
- en: '![Figure 7.7 – A possible output from the execution of the preceding snippet.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7 - 前面片段执行的可能输出。'
- en: '](img/Figure_7.7_B12346.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.7_B12346.jpg)'
- en: Figure 7.7 – A possible output from the execution of the preceding snippet.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 - 前面片段执行的可能输出。
- en: Notice that the output will vary for different runs (meaning that the order
    of processing the elements will not be the same and from the same task).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出将因不同运行而异（这意味着处理元素的顺序将不同且来自同一任务）。
- en: ConcurrentQueue<T>
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ConcurrentQueue<T>
- en: 'This is a thread-safe implementation of a queue (which is a FIFO collection).
    It provides three methods: `Enqueue()`, to add elements to the end of the collection,
    `TryPeek()`, to try to return the element at the beginning of the queue without
    removing it, and `TryDequeue()`, to try to remove and return the element at the
    beginning of the collection. It also provides an explicit implementation for the
    `IProducerConsumerCollection<T>` interface.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个队列（即FIFO集合）的线程安全实现。它提供了三种方法：`Enqueue()`，将元素添加到集合的末尾，`TryPeek()`，尝试返回队列开头的元素而不移除它，`TryDequeue()`，尝试移除并返回集合开头的元素。它还为`IProducerConsumerCollection<T>`接口提供了显式实现。
- en: ConcurrentStack<T>
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ConcurrentStack<T>
- en: 'This class implements a thread-safe stack (which is a LIFO collection). It
    provides four methods: `Push()`, to add an element at the top of the stack, `TryPeek()`,
    to try to return the element at the top without removing it, `TryPop()`, to try
    to remove and return the element at the top, and `TryPopRange()`, to try to remove
    and return multiple objects from the top of the stack. In addition, it also provides
    an explicit implementation for the `IProducerConsumerCollection<T>` interface.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了一个线程安全的堆栈（即LIFO集合）。它提供了四种方法：`Push()`，在堆栈顶部添加一个元素，`TryPeek()`，尝试返回顶部的元素而不移除它，`TryPop()`，尝试移除并返回顶部的元素，`TryPopRange()`，尝试移除并返回堆栈顶部的多个对象。此外，它还为`IProducerConsumerCollection<T>`接口提供了显式实现。
- en: ConcurrentBag<T>
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ConcurrentBag<T>
- en: This class represents a thread-safe unordered collection of objects. This can
    be useful when you want to store objects, including duplicates, and their order
    is not important. The implementation is optimized for scenarios where the same
    thread is both the producer and consumer of the elements in the bag. Adding is
    done with `Add()` and removing is done with `TryPeek()` and `TryTake()`. You can
    also remove all the elements of the bag with a call to `Clear()`. Like the concurrent
    stack and queue implementation, this class also provides an explicit implementation
    for the `IProducerConsumerCollection<T>` interface.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类表示一个线程安全的无序对象集合。当您想要存储对象（包括重复项）且它们的顺序不重要时，这可能很有用。该实现针对同一线程既是生产者又是消费者的情况进行了优化。添加使用`Add()`完成，移除使用`TryPeek()`和`TryTake()`完成。您还可以通过调用`Clear()`来移除包中的所有元素。与并发堆栈和队列实现一样，该类还为`IProducerConsumerCollection<T>`接口提供了显式实现。
- en: ConcurrentDictionary<TKey, TValue>
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ConcurrentDictionary<TKey, TValue>
- en: This represents a thread-safe collection of key-value pairs. It provides methods
    such as `TryAdd()`, to try to add a new key-value pair, `TryUpdate()`, to try
    to update an existing item, `AddOrUpdate()`, to either add a new or update an
    existing item, and `GetOrAdd()`, to either retrieve an existing item or add a
    new one if the key is not found.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了一个线程安全的键值对集合。它提供了诸如`TryAdd()`（尝试添加新的键值对）、`TryUpdate()`（尝试更新现有项）、`AddOrUpdate()`（添加新项或更新现有项）和`GetOrAdd()`（检索现有项或添加新项（如果找不到键））等方法。
- en: These operations are atomic and thread-safe with the exception of their overloads,
    which take delegates. These are executed outside the locks, and therefore their
    code is not part of the atomicity of the operation. In addition, `TryGetValue()`
    attempts to get the value of a specified key, and `TryRemove()` attempts to remove
    and return the value associated with the specified key.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作是原子的，并且是线程安全的，但其重载除外，它们采用委托。这些在锁之外执行，因此它们的代码不是操作的原子性的一部分。此外，`TryGetValue()`尝试获取指定键的值，`TryRemove()`尝试移除并返回与指定键关联的值。
- en: Choosing the right concurrent collection type
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的并发集合类型
- en: 'Now that we have seen what the concurrent collections are, the important question
    is when these should be used, especially in relation to the non-thread-safe collections.
    In general, you can use them as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了并发集合是什么，重要的问题是何时应该使用它们，特别是与非线程安全集合相关。一般来说，您可以按以下方式使用它们：
- en: '`BlockingCollection<T>` for when bounding and blocking scenarios are necessary.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlockingCollection<T>`用于需要边界和阻塞场景。'
- en: '`ConcurrentQueue<T>` should be preferred over `Queue<T>` with an external lock
    when the processing time is at least 500 `ConcurrentQueue<T>` performs best if
    one thread enqueues and another is dequeuing.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处理时间至少为500时，应优先选择`ConcurrentQueue<T>`而不是带有外部锁的`Queue<T>`。`ConcurrentQueue<T>`在一个线程进行入队操作，另一个线程进行出队操作时表现最佳。
- en: '`ConcurrentStack<T>` should be preferred over `Stack<T>` with an external lock
    if the same thread can either add or remove elements, in which case it is faster
    for both small and large processing times. However, if one thread adds and another
    thread removes elements, then `ConcurrentStack<T>` and `Stack<T>` with an external
    lock will perform relatively the same. But when the number of threads increases,
    `Stack<T>` might actually perform better.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果同一个线程可以添加或移除元素，则应优先选择`ConcurrentStack<T>`而不是带有外部锁的`Stack<T>`，在这种情况下，无论处理时间长短都更快。然而，如果一个线程添加，另一个线程移除元素，则`ConcurrentStack<T>`和带有外部锁的`Stack<T>`的性能相对相同。但是当线程数量增加时，`Stack<T>`实际上可能表现更好。
- en: '`ConcurrentDictionary<TKey, TValue>` performs better than `Dictionary<TKey,
    TValue>` in all scenarios where adding and updating is done concurrently from
    multiple threads, although if the updates are frequent but the reads are rare,
    the benefits are very small. If both reads and updates are frequent, then `ConcurrentDictionary<TKey,
    TValue>` is significantly faster. `Dictionary<TKey, TValue>` is only suitable
    for scenarios where all the threads perform only reads and no updates.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有同时进行多线程添加和更新的场景中，`ConcurrentDictionary<TKey, TValue>`的性能优于`Dictionary<TKey,
    TValue>`，尽管如果更新频繁但读取很少，则好处非常小。如果读取和更新都频繁，那么`ConcurrentDictionary<TKey, TValue>`会显著更快。`Dictionary<TKey,
    TValue>`只适用于所有线程只进行读取而不进行更新的场景。
- en: '`ConcurrentBag<T>` is suitable for scenarios where the same thread is both
    adding and consuming elements. However, in scenarios where a thread only either
    adds or removes, then it is slower than all the other concurrent collections.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentBag<T>`适用于同一个线程既添加又消耗元素的场景。然而，在只添加或只移除的场景中，它比所有其他并发集合都慢。'
- en: Keep in mind that the preceding list represents only guidelines and general
    behavior and it might not apply in all cases. In general, when you deal with concurrency
    and parallelism, you need to account for the particular aspects of your scenarios.
    Whatever algorithms and data structures you are using, you must profile their
    execution to see how it performs, both in relation to a sequential implementation
    or other concurrent alternatives.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，前面的列表只代表指南和一般行为，可能并不适用于所有情况。一般来说，当你处理并发和并行时，你需要考虑你的场景的特定方面。无论你使用什么算法和数据结构，你都必须对它们的执行进行分析，看它们的表现如何，无论是与顺序实现还是其他并发替代方案相比。
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about generic collections in .NET, the data structures
    they model, and the interfaces they implement. We looked at the most important
    collections in the `System.Collections.Generic` namespaces, `List<T>`, `Stack<T>`,
    `Queue<T>`, `LinkedList<T>`, `Dictionary<TKey, TValue>`, and `HashSet<T>`, and
    learned how to use them and perform operations such as adding, removing, or searching
    elements. In the last part of this chapter, we also looked at the `System.Collection.Concurrent`
    namespace and the thread-safe collections it provides. Then, we learned about
    the particularities of each collection and the typical scenarios where they are
    suitable to be used.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了.NET中的通用集合，它们模拟的数据结构以及它们实现的接口。我们看了`System.Collections.Generic`命名空间中最重要的集合，`List<T>`、`Stack<T>`、`Queue<T>`、`LinkedList<T>`、`Dictionary<TKey,
    TValue>`和`HashSet<T>`，并学习了如何使用它们以及执行添加、移除或搜索元素等操作。在本章的最后部分，我们还看了`System.Collection.Concurrent`命名空间和它提供的线程安全集合。然后，我们了解了每个集合的特点以及它们适合使用的典型场景。
- en: In the next chapter, we will explore some advanced topics such as delegates
    and events, tuples, regular expressions, pattern matching, and extension methods.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些高级主题，如委托和事件、元组、正则表达式、模式匹配和扩展方法。
- en: Test what you learned
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你所学到的知识
- en: Under which namespace are the generic collections present?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通用集合位于哪个命名空间下？
- en: What is the base interface for all the other interfaces that define functionalities
    for generic collections?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有定义通用集合功能的其他接口的基本接口是什么？
- en: What is the benefit of using generic collections instead of non-generic collections?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用通用集合而不是非通用集合的好处是什么？
- en: What is `List<T>` and how do you add and remove elements to or from it?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`List<T>`是什么，如何向其中添加或移除元素？'
- en: What is `Stack<T>` and how do you add and remove elements to or from it?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Stack<T>`是什么，如何向其中添加或移除元素？'
- en: What is `Queue<T>?` What is the difference between its `Dequeue()` and `Peek()`
    methods?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Queue<T>`是什么？它的`Dequeue()`和`Peek()`方法有什么区别？'
- en: What is `LinkedList<T>`? What methods can you use to add elements to the collection?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LinkedList<T>`是什么？你可以使用哪些方法向集合中添加元素？'
- en: What is `Dictionary<K, V>` and what type are its elements?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Dictionary<K, V>`是什么，它的元素是什么类型？'
- en: What is `HashSet<T>` and how does it differ from `Dictionary<K, V>`?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HashSet<T>`是什么，它与`Dictionary<K, V>`有什么不同？'
- en: What is `BlockingCollection<T>`? What concurrent scenarios is it suitable for?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BlockingCollection<T>`是什么？它适用于哪些并发场景？'
