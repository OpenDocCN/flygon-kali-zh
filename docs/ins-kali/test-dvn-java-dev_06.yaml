- en: Mocking – Removing External Dependencies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟 - 消除外部依赖
- en: '"Talk is cheap. Show me the code."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “空谈是廉价的。给我看代码。”
- en: – Linus Torvalds
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- Linus Torvalds'
- en: TDD is about speed. We want to quickly demonstrate whether an idea, concept,
    or implementation is valid or not. Further on, we want to run all tests quickly.
    A major bottleneck to this speed is external dependencies. Setting up the DB data
    required by tests can be time-consuming. The execution of tests that verify code
    that uses third-party APIs can be slow. Most importantly, writing tests that satisfy
    all external dependencies can become too complicated to be worthwhile. Mocking
    both external and internal dependencies helps us solve these problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是关于速度的。我们希望快速证明一个想法、概念或实现是否有效。此外，我们希望快速运行所有测试。这种速度的主要瓶颈是外部依赖关系。设置测试所需的数据库数据可能是耗时的。执行验证使用第三方API的代码的测试可能会很慢。最重要的是，编写满足所有外部依赖关系的测试可能会变得太复杂，不值得。模拟内部和外部依赖关系有助于解决这些问题。
- en: We'll build on what we did in [Chapter 3](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml),
    *Red-Green-Refactor – From Failure Through Success until Perfection*. We'll extend
    Tic-Tac-Toe to use MongoDB as data storage. None of our unit tests will actually
    use MongoDB since all communications will be mocked. At the end, we'll create
    an integration test that will verify that our code and MongoDB are indeed integrated.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml)中构建*红-绿-重构 - 从失败到成功直至完美*中所做的工作。我们将扩展井字棋以使用MongoDB作为数据存储。我们的单元测试实际上不会使用MongoDB，因为所有通信都将被模拟。最后，我们将创建一个集成测试，验证我们的代码和MongoDB确实集成在一起。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Mocking
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟
- en: Mockito
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mockito
- en: Tic-Tac-Toe v2 requirements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 井字棋v2的要求
- en: Developing Tic-Tac-Toe v2
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发井字棋v2
- en: Integration tests
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: Mocking
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟
- en: Everyone who has done any of the applications more complicated than *Hello World*
    knows that Java code is full of dependencies. There can be classes and methods
    written by other members of the team, third-party libraries, or external systems
    that we communicate with. Even libraries found inside JDK are dependencies. We
    might have a business layer that communicates with the data access layer which,
    in turn, uses database drivers to fetch data. When working with unit tests, we
    take dependencies even further and often consider all public and protected methods
    (even those inside the class we are working on) as dependencies that should be
    isolated.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个做过比*Hello World*更复杂的应用程序的人都知道，Java代码充满了依赖关系。可能有团队其他成员编写的类和方法、第三方库或我们与之通信的外部系统。甚至JDK内部的库也是依赖关系。我们可能有一个业务层，它与数据访问层通信，后者又使用数据库驱动程序来获取数据。在进行单元测试时，我们进一步考虑所有公共和受保护的方法（甚至是我们正在工作的类内部的方法）都是应该被隔离的依赖关系。
- en: When doing TDD on the unit tests level, creating specifications that contemplate
    all those dependencies can be so complex that the tests themselves would become
    bottlenecks. Their development time can increase so much that the benefits gained
    with TDD quickly become overshadowed by the ever-increasing cost. More importantly,
    those same dependencies tend to create such complex tests that they contain more
    bugs than the implementation itself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试级别进行TDD时，创建考虑所有这些依赖关系的规范可能会非常复杂，以至于测试本身会成为瓶颈。它们的开发时间可能会增加到TDD带来的好处很快被不断增加的成本所掩盖。更重要的是，这些依赖关系往往会创建非常复杂的测试，这些测试包含的错误比实际实现本身还要多。
- en: The idea of unit testing (especially when tied to TDD) is to write specifications
    that validate whether the code of a single unit works regardless of dependencies.
    When dependencies are internal, they are already tested, and we know that they
    do what we expect them to do. On the other hand, external dependencies require
    trust. We must believe that they work correctly. Even if we don't, the task of
    performing deep testing of, let's say, the JDK `java.nio` classes is too big for
    most of us. Besides, those potential problems will surface when we run functional
    and integration tests.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的想法（特别是与TDD结合在一起时）是编写验证单个单元代码是否有效的规范，而不考虑依赖关系。当依赖关系是内部的时，它们已经经过测试，我们知道它们会按我们的期望工作。另一方面，外部依赖关系需要信任。我们必须相信它们能正确工作。即使我们不相信，对JDK
    `java.nio`类进行深度测试的任务对大多数人来说太大了。此外，这些潜在问题将在运行功能和集成测试时出现。
- en: While focused on units, we must try to remove all dependencies that a unit may
    use. Removal of those dependencies is accomplished through a combination of design
    and mocking.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在专注于单元时，我们必须尽量消除单元可能使用的所有依赖关系。通过设计和模拟的组合来实现这些依赖关系的消除。
- en: The benefits of using mocks include reduced code dependency and faster text
    execution.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟的好处包括减少代码依赖性和更快的文本执行。
- en: Mocks are prerequisites for the fast execution of tests and the ability to concentrate
    on a single unit of functionality. By mocking dependencies external to the method
    that is being tested, the developer is able to focus on the task at hand without
    spending time setting them up. In a case of bigger or multiple teams working together,
    those dependencies may not even be developed. Also, the execution of tests without
    mocks tends to be slow. Good candidates for mocks are databases, other products,
    services, and so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是测试快速执行和集中在单个功能单元上的能力的先决条件。通过模拟被测试方法外部的依赖关系，开发人员能够专注于手头的任务，而不必花时间设置它们。在更大的团队或多个团队一起工作的情况下，这些依赖关系甚至可能尚未开发。此外，没有模拟的测试执行往往会很慢。模拟的良好候选对象包括数据库、其他产品、服务等。
- en: Before we go deeper into mocks, let us go through reasons why one would employ
    them in the first place.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究模拟之前，让我们先看看为什么有人会首先使用它们。
- en: Why mocks?
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要使用模拟？
- en: 'The following list represents some of the reasons why we employ mock objects:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表列出了我们使用模拟对象的一些原因：
- en: 'The object generates nondeterministic results. For example, `java.util.Date()`
    provides a different result every time we instantiate it. We cannot test that
    its result is as expected:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象生成不确定的结果。例如，`java.util.Date()`每次实例化时都会提供不同的结果。我们无法测试其结果是否符合预期：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The object does not yet exist. For example, we might create an interface and
    test against it. The object that implements that interface might not have been
    written at the time we test code that uses that interface.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象尚不存在。例如，我们可能创建一个接口并针对其进行测试。在我们测试使用该接口的代码时，实现该接口的对象可能尚未编写。
- en: The object is slow and requires time to process. The most common example would
    be databases. We might have a code that retrieves all records and generates a
    report. This operation can last minutes, hours, or, in some cases, even days.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象速度慢，需要时间来处理。最常见的例子是数据库。我们可能有一个检索所有记录并生成报告的代码。这个操作可能持续几分钟、几小时，甚至在某些情况下可能持续几天。
- en: The preceding reasons in the support of mock objects apply to any type of testing.
    However, in the case of unit tests and, especially, in the context of TDD, there
    is one more reason, perhaps more important than others. Mocking allows us to isolate
    all dependencies used by the method we are currently working on. This empowers
    us to concentrate on a single unit and ignore the inner workings of the code that
    the unit invokes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持模拟对象的前述原因适用于任何类型的测试。然而，在单元测试的情况下，尤其是在TDD的背景下，还有一个原因，也许比其他原因更重要。模拟允许我们隔离当前正在工作的方法使用的所有依赖项。这使我们能够集中精力在单个单元上，并忽略该单元调用的代码的内部工作。
- en: Terminology
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 术语
- en: '**Terminology** can be a bit confusing, especially since different people use
    different names for the same thing. To make things even more complicated, mocking
    frameworks tend not to be consistent when naming their methods.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 术语可能有点令人困惑，特别是因为不同的人对同一件事使用不同的名称。更让事情变得更加复杂的是，模拟框架在命名其方法时往往不一致。
- en: Before we proceed, let us briefly go through terminology.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们简要介绍一下术语。
- en: '**Test doubles** is a generic name for all of the following types:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试替身**是以下所有类型的通用名称：'
- en: Dummy object's purpose is to act as a substitute for a real method argument
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟对象的目的是充当真实方法参数的替代品
- en: Test stub can be used to replace a real object with a test-specific object that
    feeds the desired indirect inputs into the system under test
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试存根可用于使用特定于测试的对象替换真实对象，向被测系统提供所需的间接输入
- en: '**Test Spy** captures the indirect output calls made to another component by
    the **System Under Test** (**SUT**) for later verification by the test'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试间谍**捕获了**被测系统**（**SUT**）间接输出给另一个组件的调用，以便后续由测试进行验证'
- en: Mock object replaces an object the SUT depends on, with a test-specific object
    that verifies that it is being used correctly by the SUT
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟对象替换了SUT依赖的对象，使用一个特定于测试的对象来验证SUT是否正确使用它
- en: Fake object replaces a component that the SUT depends on with a much lighter-weight
    implementation
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟对象用更轻量级的实现替换了SUT依赖的组件
- en: If you are confused, it may help you to know that you are not the only one.
    Things are even more complicated than this, since there is no clear agreement,
    nor a naming standard, between frameworks or authors. Terminology is confusing
    and inconsistent, and the terms mentioned earlier are by no means accepted by
    everyone.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您感到困惑，知道您并不是唯一一个可能会有帮助。事情比这更复杂，因为在框架或作者之间没有明确的协议，也没有命名标准。术语令人困惑且不一致，前面提到的术语绝不是所有人都接受的。
- en: To simplify things, throughout this book we'll use the same naming used by Mockito
    (our framework of choice). This way, methods that you'll be using will correspond
    with the terminology that you'll be reading further on. We'll continue using mocking
    as a general term for what others might call **test doubles**. Furthermore, we'll
    use a mock or spy term to refer to `Mockito` methods.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化事情，在本书中我们将使用Mockito（我们选择的框架）使用相同的命名。这样，您将使用的方法将与您将在后面阅读的术语对应。我们将继续使用模拟作为其他人可能称为**测试替身**的通用术语。此外，我们将使用模拟或间谍术语来指代`Mockito`方法。
- en: Mock objects
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟对象
- en: Mock objects simulate the behavior of real (often complex) objects. They allow
    us to create an object that will replace the real one used in the implementation
    code. A mocked object will expect a defined method with defined arguments to return
    the expected result. It knows in advance what is supposed to happen and how we
    expect it to react.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象模拟了真实（通常是复杂的）对象的行为。它允许我们创建一个将替换实现代码中使用的真实对象的对象。模拟对象将期望一个定义的方法和定义的参数返回期望的结果。它预先知道应该发生什么以及我们期望它如何反应。
- en: 'Let''s take a look at one simple example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, we defined `collection` to be a `mock` of `TicTacToeCollection`. At this
    moment, all methods from this mocked object are fake and, in the case of Mockito,
    return default values. This is confirmed in the second line, where we `assert`
    that the `drop` method returns `false`. Further on, we specify that our mocked
    object collection should return `true` when the `drop` method is invoked. Finally,
    we `assert` that the `drop` method returns `true`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义`collection`为`TicTacToeCollection`的`mock`。此时，来自该模拟对象的所有方法都是虚假的，并且在Mockito的情况下返回默认值。这在第二行得到了确认，我们`assert`了`drop`方法返回`false`。接着，我们指定我们的模拟对象`collection`在调用`drop`方法时应返回`true`。最后，我们`assert`了`drop`方法返回`true`。
- en: We created a mock object that returns default values and, for one of its methods,
    defined what should be the return value. At no point was a real object used.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个模拟对象，它返回默认值，并且对其方法之一定义了应该返回的值。在任何时候都没有使用真实对象。
- en: Later on, we'll work with spies that have this logic inverted; an object uses
    real methods unless specified otherwise. We'll see and learn more about mocking
    soon when we start extending our Tic-Tac-Toe application. Right now, we'll take
    a look at one of the Java mocking frameworks called Mockito.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将使用具有此逻辑反转的间谍；一个对象使用真实方法，除非另有规定。当我们开始扩展我们的井字棋应用程序时，我们将很快看到并学到更多关于模拟的知识。现在，让我们先看看一个名为Mockito的Java模拟框架。
- en: Mockito
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mockito
- en: 'Mockito is a mocking framework with a clean and simple API. Tests produced
    with Mockito are readable, easy to write, and intuitive. It contains three major
    static methods:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito是一个具有清晰简洁API的模拟框架。使用Mockito生成的测试可读性强，易于编写，直观。它包含三个主要的静态方法：
- en: '`mock()`: This is used to create mocks. Optionally, we can specify how those
    mocks behave with `when()` and `given()`.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mock()`: 用于创建模拟。可选地，我们可以使用`when()`和`given()`指定这些模拟的行为。'
- en: '`spy()`: This can be used for partial mocking. Spied objects invoke real methods
    unless we specify otherwise. As with `mock()`, behavior can be set for every public
    or protected method (excluding static). The major difference is that `mock()`
    creates a fake of the whole object, while `spy()` uses the real object.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spy()`: 这可以用于部分模拟。间谍对象调用真实方法，除非我们另有规定。与`mock()`一样，行为可以针对每个公共或受保护的方法进行设置（不包括静态方法）。主要区别在于`mock()`创建整个对象的伪造，而`spy()`使用真实对象。'
- en: '`verify()`: This is used to check whether methods were called with given arguments.
    It is a form of assert.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verify()`: 用于检查是否使用给定参数调用了方法。这是一种断言形式。'
- en: We'll go deeper into Mockito once we start coding our Tic-Tac-Toe v2 application.
    First, however, let us quickly go through a new set of requirements.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始编写井字棋v2应用程序，我们将深入研究Mockito。然而，首先让我们快速浏览一组新的需求。
- en: Tic-Tac-Toe v2 requirements
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 井字棋v2需求
- en: The requirements of our Tic-Tac-Toe v2 application are simple. We should add
    a persistent storage so that players can continue playing the game at some later
    time. We'll use MongoDB for this purpose.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的井字棋v2应用程序的需求很简单。我们应该添加一个持久存储，以便玩家可以在以后的某个时间继续玩游戏。我们将使用MongoDB来实现这一目的。
- en: Add MongoDB persistent storage to the application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将MongoDB持久存储添加到应用程序中。
- en: Developing Tic-Tac-Toe v2
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发井字棋v2
- en: 'We''ll continue where we left off with Tic-Tac-Toe in [Chapter 3](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml),
    *Red-Green-Refactor – From Failure Through Success until Perfection*. The complete
    source code of the application developed so far can be found at [https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo.git](https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo.git).
    Use the VCS|Checkout from Version Control|Git option from the IntelliJ IDEA to
    clone the code. As with any other project, the first thing we need to do is add
    the dependencies to `build.gradle`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml)中继续进行井字棋的工作，*红-绿-重构 - 从失败到成功直至完美*。到目前为止，已开发的应用程序的完整源代码可以在[https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo.git](https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo.git)找到。使用IntelliJ
    IDEA的VCS|从版本控制|Git选项来克隆代码。与任何其他项目一样，我们需要做的第一件事是将依赖项添加到`build.gradle`中：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Importing the MongoDB driver should be self-explanatory. Jongo is a very helpful
    set of utility methods that make working with Java code much more similar to the
    Mongo query language. For the testing part, we'll continue using JUnit with the
    addition of Mockito mocks, spies, and validations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 导入MongoDB驱动程序应该是不言自明的。Jongo是一组非常有用的实用方法，使得使用Java代码更类似于Mongo查询语言。对于测试部分，我们将继续使用JUnit，并添加Mockito的模拟、间谍和验证功能。
- en: You'll notice that we won't install MongoDB until the very end. With Mockito,
    we will not need it, since all our Mongo dependencies will be mocked.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，我们直到最后才会安装MongoDB。使用Mockito，我们将不需要它，因为我们所有的Mongo依赖项都将被模拟。
- en: Once dependencies are specified, remember to refresh them in the IDEA Gradle
    Projects dialogue.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦指定了依赖项，请记得在IDEA Gradle项目对话框中刷新它们。
- en: The source code can be found in the `00-prerequisites` branch of the `tdd-java-ch06-tic-tac-toe-mongo`
    Git repository ([https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/00-prerequisites](https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/00-prerequisites)).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在`tdd-java-ch06-tic-tac-toe-mongo` Git存储库的`00-prerequisites`分支中找到（[https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/00-prerequisites](https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/00-prerequisites)）。
- en: Now that we have prerequisites set, let's start working on the first requirement.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了先决条件，让我们开始处理第一个需求。
- en: Requirement 1 – store moves
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求1 - 存储移动
- en: We should be able to save each move to the DB. Since we already have all the
    game logic implemented, this should be trivial to do. Nonetheless, this will be
    a very good example of mock usage.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能够将每个移动保存到数据库中。由于我们已经实现了所有的游戏逻辑，这应该很容易做到。尽管如此，这将是模拟使用的一个非常好的例子。
- en: Implement an option to save a single move with the turn number, the *x* and
    *y* axis positions, and the player (`X` or `O`).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个选项，可以保存单个移动与轮数、*x*和*y*轴位置以及玩家（`X`或`O`）。
- en: We should start by defining the Java bean that will represent our data storage
    schema. There's nothing special about it, so we'll skip this part with only one
    note.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该首先定义代表我们数据存储模式的Java bean。这没有什么特别的，所以我们将跳过这一部分，只有一个注释。
- en: Do not spend too much time defining specifications for Java boilerplate code.
    Our implementation of the bean contains overwritten `equals` and `hashCode`. Both
    are generated automatically by IDEA and do not provide a real value, except to
    satisfy the need to compare two objects of the same type (we'll use that comparison
    later on in specifications). TDD is supposed to help us design better and write
    better code. Writing 15-20 specifications to define boilerplate code that could
    be written automatically by IDE (as is the case with the `equals` method) does
    not help us meet these objectives. Mastering TDD means not only learning how to
    write specifications, but also knowing when it's not worth it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不要花太多时间为Java样板代码定义规范。我们的bean实现包含重写的`equals`和`hashCode`。这两者都是由IDEA自动生成的，除了满足比较相同类型的两个对象的需求之外，它们并没有提供真正的价值（我们稍后将在规范中使用该比较）。TDD应该帮助我们设计更好的代码。编写15-20个规范来定义可以由IDE自动编写的样板代码（如`equals`方法）并不会帮助我们实现这些目标。精通TDD不仅意味着学会如何编写规范，还意味着知道何时不值得。
- en: That being said, consult the source code to see the bean specification and implementation
    in it's entirety.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，查看源代码以查看bean规范和实现的全部内容。
- en: The source code can be found in the `01-bean` branch of the `tdd-java-ch06-tic-tac-toe-mongo`
    Git repository ([https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/01-bean](https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/01-bean)).
    The particular classes are `TicTacToeBeanSpec` and `TicTacToeBean`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在`tdd-java-ch06-tic-tac-toe-mongo` Git存储库的`01-bean`分支中找到（[https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/01-bean](https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/01-bean)）。特定的类是`TicTacToeBeanSpec`和`TicTacToeBean`。
- en: Now, let's go to a more interesting part (but still without mocks, spies, and
    validations). Let's write specifications related to saving data to MongoDB.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来到一个更有趣的部分（但仍然没有模拟、间谍和验证）。让我们编写与将数据保存到MongoDB相关的规范。
- en: 'For this requirement, we''ll create two new classes inside the `com.packtpublishing.tddjava.ch03tictactoe.mongo`
    package:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个要求，我们将在`com.packtpublishing.tddjava.ch03tictactoe.mongo`包内创建两个新类：
- en: '`TicTacToeCollectionSpec` (inside `src/test/java`)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TicTacToeCollectionSpec`（在`src/test/java`内）'
- en: '`TicTacToeCollection` (inside `src/main/java`)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TicTacToeCollection`（在`src/main/java`内）'
- en: Specification – DB name
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范-数据库名称
- en: 'We should specify what the name of the DB that we''ll use will be:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该指定我们将使用的数据库的名称：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We are instantiating a new `TicTacToeCollection` class and verifying that the
    DB name is what we expect.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在实例化一个新的`TicTacToeCollection`类，并验证DB名称是否符合我们的预期。
- en: Implementation
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'The implementation is very straightforward, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实施非常简单，如下所示：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When instantiating the `TicTacToeCollection` class, we're creating a new `MongoCollection`
    with the specified DB name (`tic-tac-toe`) and assigning it to the local variable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化`TicTacToeCollection`类时，我们正在创建一个新的`MongoCollection`，并将指定的DB名称（`tic-tac-toe`）分配给局部变量。
- en: Bear with us. There's only one more specification left until we get to the interesting
    part where we'll use mocks and spies.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请耐心等待。在我们使用模拟和间谍的有趣部分之前，只剩下一个规范了。
- en: Specification – a name for the Mongo collection
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范-用于Mongo集合的名称
- en: 'In the previous implementation, we used `bla` as the name of the collection
    because `Jongo` forced us to put some string. Let''s create a specification that
    will define the name of the Mongo collection that we''ll use:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的实现中，我们使用`bla`作为集合的名称，因为`Jongo`强制我们放一些字符串。让我们创建一个规范，来定义我们将使用的Mongo集合的名称：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This specification is almost identical to the previous one and probably self
    explanatory.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范几乎与上一个规范相同，可能是不言自明的。
- en: Implementation
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'All we have to do to implement this specification is change the string we used
    to set the collection name:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的就是改变我们用来设置集合名称的字符串：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Refactoring
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: You might have got the impression that refactoring is reserved only for the
    implementation code. However, when we look the objectives behind refactoring (more
    readable, optimal, and faster code), they apply as much to specifications as to
    the implementation code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会有这样的印象，即重构仅适用于实现代码。然而，当我们看重构背后的目标（更易读、更优化和更快的代码）时，它们与规范代码一样适用于实现代码。
- en: 'The last two specifications have the instantiation of the `TicTacToeCollection`
    class repeated. We can move it to a method annotated with `@Before`. The effect
    will be the same (the class will be instantiated before each method annotated
    with `@Test` is run) and we''ll remove the duplicated code. Since the same instantiation
    will be needed in further specs, removing duplication now will provide even more
    benefits later on. At the same time, we''ll save ourselves from throwing `UnknownHostException`
    over and over again:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个规范重复了`TicTacToeCollection`类的实例化。我们可以将其移动到一个用`@Before`注释的方法中。效果将是相同的（在运行用`@Test`注释的方法之前，类将被实例化），并且我们将删除重复的代码。由于在后续规范中将需要相同的实例化，现在删除重复将在以后提供更多的好处。同时，我们将免去一遍又一遍地抛出`UnknownHostException`的麻烦：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Use setup and teardown methods. The benefits of these allow preparation or setup
    and disposal or teardown code to be executed before and after the class or each
    test method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设置和拆卸方法。这些方法的好处允许在类或每个测试方法之前和之后执行准备或设置和处理或拆卸代码。
- en: In many cases, some code needs to be executed before the test class or each
    method in a class. For this purpose, JUnit has the `@BeforeClass` and `@Before`
    annotations that should be used in the setup phase. The `@BeforeClass` executes
    the associated method before the class is loaded (before the first test method
    is run). `@Before` executes the associated method before each test is run. Both
    should be used when there are certain preconditions required by tests. The most
    common example is setting up test data in the (hopefully in-memory) database.
    On the opposite end are the `@After` and `@AfterClass` annotations, which should
    be used as the teardown phase. Their main purpose is to destroy the data or state
    created during the setup phase or by tests themselves. Each test should be independent
    from others. Moreover, no test should be affected by the others. The teardown
    phase helps maintain the system as if no test were previously executed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，一些代码需要在测试类或类中的每个方法之前执行。为此，JUnit有`@BeforeClass`和`@Before`注解，应该在设置阶段使用。`@BeforeClass`在类加载之前（在第一个测试方法运行之前）执行相关方法。`@Before`在每次测试运行之前执行相关方法。当测试需要特定的前提条件时，应该使用这两个。最常见的例子是在（希望是内存中的）数据库中设置测试数据。相反的是`@After`和`@AfterClass`注解，应该用作拆卸阶段。它们的主要目的是销毁在设置阶段或测试本身创建的数据或状态。每个测试应该独立于其他测试。此外，没有测试应该受到其他测试的影响。拆卸阶段有助于保持系统，就好像以前没有执行任何测试一样。
- en: Now let's do some mocking, spying, and verifying!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进行一些模拟、监听和验证！
- en: Specification – adding items to the Mongo collection
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范-向Mongo集合添加项目
- en: We should create a method that saves data to MongoDB. After studying Jongo documentation,
    we discovered that there is the `MongoCollection.save` method, which does exactly
    that. It accepts any object as a method argument and transforms it (using Jackson)
    into JSON, which is natively used in MongoDB. The point is that after playing
    around with Jongo, we decided to use and, more importantly, trust this library.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该创建一个保存数据到MongoDB的方法。在研究Jongo文档之后，我们发现了`MongoCollection.save`方法，它正是我们需要的。它接受任何对象作为方法参数，并将其（使用Jackson）转换为JSON，这在MongoDB中是原生使用的。重点是，在使用Jongo玩耍后，我们决定使用并且更重要的是信任这个库。
- en: We can write Mongo specifications in two ways. One more traditional and appropriate
    for **End2End** (**E2E**) or integration tests would be to bring up a MongoDB
    instance, invoke the Jongo's save method, query the database, and confirm that
    data has indeed been saved. It does not end here, as we would need to clean up
    the database before each test to always guarantee that the same state is unpolluted
    by the execution of previous tests. Finally, once all tests are finished executing,
    we might want to stop the MongoDB instance and free server resources for some
    other tasks.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以两种方式编写Mongo规范。一种更传统的方式，适合**端到端**（E2E）或集成测试，是启动一个MongoDB实例，调用Jongo的保存方法，查询数据库，并确认数据确实已经保存。这还没有结束，因为我们需要在每个测试之前清理数据库，以始终保证相同的状态不受先前测试的执行而污染。最后，一旦所有测试执行完毕，我们可能希望停止MongoDB实例，并为其他任务释放服务器资源。
- en: As you might have guessed, there is quite a lot of work involved for a single
    test written in this way. Also, it's not only about work that needs to be invested
    into writing such tests. The execution time would be increased quite a lot. Running
    one test that communicates with a DB does not take long. Running ten tests is
    usually still fast. Running hundreds or thousands can take quite a lot of time.
    What happens when it takes a lot of time to run all unit tests? People lose patience
    and start dividing them into groups or give up on TDD all together. Dividing tests
    into groups means that we lose confidence in the fact that nothing got broken,
    since we are continuously testing only parts of it. Giving up on TDD... Well,
    that's not the objective we're trying to accomplish. However, if it takes a lot
    of time to run tests, it's reasonable to expect developers to not want to wait
    until they are finished running before they move to the next specification, and
    that is the point when we stop doing TDD. What is a reasonable amount of time
    to allow our unit tests to run? There is no one-fits-all rule that defines this;
    however, as a rule of thumb, if the time is longer than 10-15 seconds, we should
    start worrying, and dedicate time to optimizing them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到，以这种方式编写单个测试涉及相当多的工作。而且，不仅仅是需要投入编写这些测试的工作。执行时间会大大增加。运行一个与数据库通信的测试不需要很长时间。通常运行十个测试仍然很快。运行数百或数千个测试可能需要很长时间。当运行所有单元测试需要很长时间时会发生什么？人们会失去耐心，开始将它们分成组，或者完全放弃TDD。将测试分成组意味着我们失去了对没有任何东西被破坏的信心，因为我们不断地只测试它的部分。放弃TDD...好吧，这不是我们试图实现的目标。然而，如果运行测试需要很长时间，可以合理地期望开发人员不愿意等待它们完成后再转移到下一个规范，这就是我们停止进行TDD的时候。允许我们的单元测试运行的合理时间是多久？没有一个适用于所有的规则来定义这一点；然而，作为一个经验法则，如果时间超过10-15秒，我们应该开始担心，并且花时间来优化它们。
- en: Tests should run quickly. The benefits are that the tests are used often.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该快速运行。好处是测试经常被使用。
- en: If it takes a lot of time to run tests, developers will stop using them or run
    only a small subset related to the changes they are making. One benefit of fast
    tests, besides fostering their usage, is fast feedback. The sooner the problem
    is detected, the easier it is to fix it. Knowledge about the code that produced
    the problem is still fresh. If a developer has already started working on the
    next feature while waiting for the completion of the execution of tests, they
    might decide to postpone fixing the problem until that new feature is developed.
    On the other hand, if they drops their current work to fix the bug, time is lost
    in context switching.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行测试需要很长时间，开发人员将停止使用它们，或者只运行与他们正在进行的更改相关的一个小子集。快速测试的一个好处，除了促进它们的使用，就是快速反馈。问题被检测到的越早，修复起来就越容易。对产生问题的代码的了解仍然很新鲜。如果开发人员在等待测试执行完成时已经开始了下一个功能的工作，他们可能会决定推迟修复问题，直到开发了新功能。另一方面，如果他们放弃当前的工作来修复错误，那么在上下文切换中就会浪费时间。
- en: If using live DB to run unit tests is not a good option, then what is the alternative?
    Mocking and spying! In our example, we know which method of a third-party library
    should be invoked. We also invested enough time to trust this library (besides
    integration tests that will be performed later on). Once we know how to use the
    library, we can limit our job to verifying that correct invocations of that library
    have been made.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用实时数据库来运行单元测试不是一个好选择，那么还有什么选择？模拟和监视！在我们的例子中，我们知道应该调用第三方库的哪个方法。我们还投入了足够的时间来信任这个库（除了以后要执行的集成测试）。一旦我们知道如何使用这个库，我们就可以将我们的工作限制在验证该库的正确调用上。
- en: Let us give it a try.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试。
- en: 'First, we should modify our existing code and convert our instantiation of
    the `TicTacToeCollection` into a `spy`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该修改我们现有的代码，并将我们对`TicTacToeCollection`的实例化转换为`spy`：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Spying on a class is called **partial** mocking. When applied, the class will
    behave exactly the same as it would if it was instantiated normally. The major
    difference is that we can apply partial mocking and substitute one or more methods
    with mocks. As a general rule, we tend to use spies mostly on classes that we're
    working on. We want to retain all the functionality of a class that we're writing
    specifications for, but with an additional option to, when needed, mock a part
    of it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对一个类进行**部分**模拟被称为监视。应用后，该类的行为将与正常实例化时完全相同。主要区别在于我们可以应用部分模拟并用模拟替换一个或多个方法。一般规则是，我们倾向于在我们正在工作的类上使用监视。我们希望保留我们为其编写规范的类的所有功能，但在需要时，可以模拟其中的一部分。
- en: 'Now let us write the specification itself. It could be the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写规范本身。它可能是以下内容：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Static methods, such as `mock`, `doReturn`, and `verify`, are all from the `org.mockito.Mockito`
    class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法，比如`mock`、`doReturn`和`verify`，都来自`org.mockito.Mockito`类。
- en: 'First, we''re creating a new `TicTacToeBean`. There''s nothing special there.
    Next, we are creating a `mock` object out of the `MongoCollection`. Since we already
    established that, when working on a unit level, we want to avoid direct communication
    with the DB, mocking this dependency will provide this for us. It will convert
    a real  class into a mocked one. For the class using `mongoCollection`, it''ll
    look like a real one; however, behind the scenes, all its methods are shallow
    and do not actually do anything. It''s like overwriting that class and replacing
    all the methods with empty ones:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的`TicTacToeBean`。没有什么特别的。接下来，我们将`MongoCollection`创建为一个`mock`对象。由于我们已经确定，在单元级别工作时，我们希望避免与数据库直接通信，模拟这种依赖关系将为我们提供这种功能。它将把一个真实的类转换成一个模拟的类。对于使用`mongoCollection`的类来说，它看起来像是一个真实的类；然而，在幕后，它的所有方法都是浅层的，实际上并不执行任何操作。这就像覆盖该类并用空方法替换所有方法一样：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we''re telling that a mocked `mongoCollection` should be returned whenever
    we call the `getMongoCollection` method of the collection spied class. In other
    words, we''re telling our class to use a fake collection instead of the real one:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们告诉一个模拟的`mongoCollection`应该在我们调用集合监视类的`getMongoCollection`方法时返回。换句话说，我们告诉我们的类使用一个假的集合而不是真实的集合：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we''re calling the method that we are working on:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用我们正在工作的方法：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we should verify that the correct invocation of the `Jongo` library
    is performed once:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该验证`Jongo`库的正确调用是否执行了一次：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let's try to implement this specification.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着实现这个规范。
- en: Implementation
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: 'To better understand the specification we just wrote, let us do only a partial
    implementation. We''ll create an empty method, `saveMove`. This will allow our
    code to compile without implementing the specification yet:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解我们刚刚编写的规范，让我们只进行部分实现。我们将创建一个空方法`saveMove`。这将允许我们的代码在不实现规范的情况下编译：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we run our specifications (`gradle test`), the result is the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的规范（`gradle test`）时，结果如下：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Mockito tells us that, according to our specification, we expect the `mongoCollection.save`
    method to be invoked, and that the expectation was not fulfilled. Since the test
    is still failing, we need to go back and finish the implementation. One of the
    biggest sins in TDD is to have a failing test and move onto something else.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito告诉我们，根据我们的规范，我们期望调用`mongoCollection.save`方法，但这个期望没有实现。由于测试仍然失败，我们需要回去完成实现。在TDD中最大的罪过之一就是有一个失败的测试然后转移到其他事情上。
- en: All tests should pass before a new test is written. The benefits of this are
    that the focus is maintained on a small unit of work, and implementation code
    is (almost) always in a working condition.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写新测试之前，所有测试都应该通过。这样做的好处是，它可以保持对一个小单位的工作的关注，并且实现代码（几乎）总是处于工作状态。
- en: It is sometimes tempting to write multiple tests before the actual implementation.
    In other cases, developers ignore problems detected by the existing tests and
    move towards new features. This should be avoided whenever possible. In most cases,
    breaking this rule will only introduce technical debt that will need to be paid
    with interest. One of the goals of TDD is ensuring that the implementation code
    is (almost) always working as expected. Some projects, due to pressures to reach
    the delivery date or maintain the budget, break this rule and dedicate time to
    new features, leaving the fixing of the code associated with failed tests for
    later. Those projects usually end up postponing the inevitable.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候在实际实现之前编写多个测试是很诱人的。在其他情况下，开发人员会忽略现有测试检测到的问题，转向新功能。尽可能避免这种情况。在大多数情况下，违反这个规则只会引入技术债务，需要付出利息来偿还。TDD的一个目标是确保实现代码（几乎）总是按预期工作。一些项目由于压力要达到交付日期或维持预算，违反这个规则并将时间用于新功能，留下与失败测试相关的代码修复以后再做。这些项目通常最终推迟了不可避免的事情。
- en: 'Let''s modify the implementation too, for example, the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也修改实现，例如，以下内容：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we run our specifications again, the result is the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行我们的规范，结果如下：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This time we are invoking the expected method, but the arguments we are passing
    to it are not what we hoped for. In the specification, we set the expectation
    to a bean (new `TicTacToeBean(3, 2, 1, 'Y')`) and in the implementation, we passed
    null. Not only that, Mockito verifications can tell us whether a correct method
    was invoked, and also whether the arguments passed to that method are correct.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次我们调用了期望的方法，但是我们传递给它的参数并不是我们希望的。在规范中，我们将期望设置为一个bean（新的`TicTacToeBean(3, 2,
    1, 'Y')`），而在实现中，我们传递了null。不仅如此，Mockito的验证可以告诉我们是否调用了正确的方法，以及传递给该方法的参数是否正确。
- en: 'The correct implementation of the specification is the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 规范的正确实现如下：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This time all specifications should pass, and we can, happily, proceed to the
    next one.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次所有的规范都应该通过，我们可以愉快地继续下一个。
- en: Specification – adding operation feedback
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范-添加操作反馈
- en: 'Let us change the return type of our `saveMove` method to `boolean`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`saveMove`方法的返回类型更改为`boolean`：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Implementation
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'This implementation is very straightforward. We should change the method return
    type. Remember that one of the rules of TDD is to use the simplest possible solution.
    The simplest solution is to return `true` as in the following example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现非常直接。我们应该改变方法的返回类型。记住TDD的一个规则是使用最简单的解决方案。最简单的解决方案是返回`true`，就像下面的例子一样：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Refactoring
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: 'You have probably noticed that the last two specifications have the first two
    lines duplicated. We can refactor the specifications code by moving them to the
    method annotated with `@Before`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到最后两个规范有前两行重复。我们可以通过将它们移到用`@Before`注释的方法中来重构规范代码：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Specification – error handling
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范-错误处理
- en: 'Now let us contemplate the option that something might go wrong when using
    MongoDB. When, for example, an exception is thrown, we might want to return `false`
    from our `saveMove` method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一下在使用MongoDB时可能出现问题的选项。例如，当抛出异常时，我们可能希望从我们的`saveMove`方法中返回`false`：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we introduce to another Mockito method: `doThrow`. It acts in a similar
    way to `doReturn` and throws an `Exception` when set conditions are fulfilled.
    The specification will throw the `MongoException` when the save method inside
    the `mongoCollection` class is invoked. This allows us to `assert` that our `saveMove`
    method returns `false` when an exception is thrown.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们介绍了另一个Mockito方法：`doThrow`。它的作用方式类似于`doReturn`，当设置条件满足时抛出一个`Exception`。规范将在调用`mongoCollection`类内部的`save`方法时抛出`MongoException`。这使我们能够`assert`我们的`saveMove`方法在抛出异常时返回`false`。
- en: Implementation
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'The implementation can be as simple as adding a `try`/`catch` block:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可以简单到添加一个`try`/`catch`块：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Specification – clear state between games
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范-在游戏之间清除状态
- en: This is a very simple application that, at least at this moment, can store only
    one game session. Whenever a new instance is created, we should start over and
    remove all data stored in the database. The easiest way to do this is to simply
    drop the MongoDB collection. Jongo has the `MongoCollection.drop()` method that
    can be used for that. We'll create a new method, `drop`, that will act in a similar
    way to `saveMove`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的应用程序，至少在这一刻，它只能存储一个游戏会话。每当创建一个新实例时，我们应该重新开始并删除数据库中存储的所有数据。这样做的最简单方法就是简单地删除MongoDB集合。Jongo有`MongoCollection.drop()`方法可以用于这个目的。我们将创建一个新的方法`drop`，它将以类似于`saveMove`的方式工作。
- en: If you haven't worked with Mockito, MongoDB, and/or Jongo, the chances are you
    were not able to do the exercises from this chapter by yourself, and just decided
    to follow the solutions we provided. If that's the case, this is the moment when
    you may want to switch gears and try to write the specifications and implementation
    by yourself.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用Mockito、MongoDB和/或Jongo工作过，那么你可能无法自己完成本章的练习，只能决定按照我们提供的解决方案进行。如果是这种情况，那么现在可能是你想要改变方向，尝试自己编写规范和实现的时候了。
- en: 'We should verify that `MongoCollection.drop()` is invoked from our own method
    `drop()` inside the `TicTacToeCollection` class. Try it by yourself before looking
    at the following code. It should be almost the same as what we did with the `save`
    method:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该验证`MongoCollection.drop()`是否从我们自己的`drop()`方法内部的`TicTacToeCollection`类中调用。在查看以下代码之前，请自己尝试一下。这几乎与我们对`save`方法所做的事情相同：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Implementation
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'Since this is a wrapper method, implementing this specification should be fairly
    easy:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个包装方法，实现这个规范应该相当容易：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Specification – drop operation feedback
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范-删除操作反馈
- en: We're almost done with this class. There are only two specifications left.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了这个类。只剩下两个规范。
- en: 'Let us make sure that, in normal circumstances, we return `true`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保在正常情况下返回`true`：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Implementation
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'If things look too easy with TDD, then that is on purpose. We are splitting
    tasks into such small entities that, in most cases, implementing a specification
    is a piece of cake. This one is no exception:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用TDD看起来太容易了，那是有意为之的。我们将任务分解成如此小的实体，以至于在大多数情况下，实现规范都是小菜一碟。这个也不例外：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Specification – error handling
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范-错误处理
- en: 'Finally, let us make sure that the `drop` method returns `false` in case of
    an `Exception`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们确保`drop`方法在出现`异常`时返回`false`：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Implementation
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'Let us just add a `try`/`catch` block:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个`try`/`catch`块：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this implementation, we are finished with the `TicTacToeCollection` class
    that acts as a layer between our `main` class and MongoDB.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个实现，我们完成了`TicTacToeCollection`类，它充当了我们的`main`类和MongoDB之间的层。
- en: The source code can be found in the `02-save-move` branch of the `tdd-java-ch06-tic-tac-toe-mongo`
    Git repository ([https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/02-save-move](https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/02-save-move)).
    The classes in particular are `TicTacToeCollectionSpec` and `TicTacToeCollection`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在`tdd-java-ch06-tic-tac-toe-mongo` Git存储库的`02-save-move`分支中找到（[https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/02-save-move](https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/02-save-move)）。特别的类是`TicTacToeCollectionSpec`和`TicTacToeCollection`。
- en: Requirement 2 – store every turn
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求2-存储每一步
- en: Let us employ the `TicTacToeCollection` methods inside our main class `TicTacToe`.
    Whenever a player plays a turn successfully, we should save it to the DB. Also,
    we should drop the collection whenever a new class is instantiated so that a new
    game does not overlap the old one. We could make it much more elaborate than this;
    however, for the purpose of this chapter and learning how to use mocking, this
    requirement should do for now.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的主类`TicTacToe`中使用`TicTacToeCollection`方法。每当玩家成功玩一个回合时，我们应该将其保存到数据库中。此外，我们应该在实例化新类时删除集合，以防新游戏与旧游戏重叠。我们可以把它做得更复杂；然而，对于本章的目的和学习如何使用模拟，这个要求现在就足够了。
- en: Save each turn to the database and make sure that a new session cleans the old
    data.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将每一步保存到数据库，并确保新会话清除旧数据。
- en: Let's do some setup first.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先做一些设置。
- en: Specification – creating new collection
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范-创建新的集合
- en: 'Since all our methods that will be used to communicate with MongoDB are in
    the `TicTacToeCollection` class, we should make sure that it is instantiated.
    The specification could be the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将用于与MongoDB通信的所有方法都在`TicTacToeCollection`类中，我们应该确保它被实例化。规范可能如下：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The instantiation of `TicTacToe` is already done in the method annotated with `@Before`.
    With this specification, we're making sure that the collection is instantiated
    as well.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`TicTacToe`的实例化已经在用`@Before`注解的方法中完成了。通过这个规范，我们确保集合也被实例化。'
- en: Implementation
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: There is nothing special about this implementation. We should simply overwrite
    the default constructor and assign a new instance to the `ticTacToeCollection`
    variable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现没有什么特别之处。我们应该简单地重写默认构造函数，并将一个新实例分配给`ticTacToeCollection`变量。
- en: 'To begin with, we should add a local variable and a getter for `TicTacToeCollection`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该添加一个本地变量和一个`TicTacToeCollection`的getter：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now all that''s left is to instantiate a new `collection` and assign it to
    the variable when the `main` class is instantiated:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是实例化一个新的`collection`并在`main`类实例化时将其分配给变量：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We also created another way to instantiate the class by passing `TicTacToeCollection`
    as an argument. This will come in handy inside specifications as an easy way to
    pass a mocked collection.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了另一种通过传递`TicTacToeCollection`作为参数来实例化类的方法。这在规范中作为传递模拟集合的简单方法会很方便。
- en: Now let us go back to the specifications class and make use of this new constructor.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到规范类，并利用这个新的构造函数。
- en: Specification refactoring
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范重构
- en: 'To utilize a newly created `TicTacToe` constructor, we can do something such
    as the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用新创建的`TicTacToe`构造函数，我们可以做一些类似以下的事情：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now all our specifications will use a mocked version of the `TicTacToeCollection`.
    There are other ways to inject mocked dependencies (for example, with Spring);
    however, when possible, we feel that simplicity trumps complicated frameworks.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所有的规范都将使用`TicTacToeCollection`的模拟版本。还有其他注入模拟依赖的方法（例如，使用Spring）；然而，可能的话，我们觉得简单胜过复杂的框架。
- en: Specification – storing current move
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范-存储当前移动
- en: 'Whenever we play a turn, it should be saved to the DB. The specification can
    be the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们玩一个回合，它都应该保存到数据库中。规范可以是以下内容：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'By now, you should be familiar with Mockito, but let us go through the code
    as a refresher:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该对Mockito很熟悉了，但让我们通过代码来复习一下：
- en: 'First, we are instantiating a `TicTacToeBean` since it contains the data that
    our collections expect:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们实例化一个`TicTacToeBean`，因为它包含了我们的集合所期望的数据：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, it is time to play an actual turn:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，是时候玩一个真正的回合了：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we need to verify that the `saveMove` method is really invoked:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要验证`saveMove`方法是否真的被调用了：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As we have done throughout this chapter, we isolated all external invocations
    and focused only on the unit (`play`) that we're working on. Keep in mind that
    this isolation is limited only to the public and protected methods. When it comes
    to the actual implementation, we might choose to add the `saveMove` invocation
    to the `play` public method or one of the private methods that we wrote as a result
    of the refactoring we did earlier.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中所做的那样，我们隔离了所有外部调用，只专注于我们正在处理的单元(`play`)。请记住，这种隔离仅限于公共和受保护的方法。当涉及到实际的实现时，我们可能选择将`saveMove`调用添加到`play`公共方法或我们之前重构的一个私有方法中。
- en: Implementation
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: This specification poses a couple of challenges. First, where should we place
    the invocation of the `saveMove` method? The `setBox` private method looks like
    a good place. That's where we are doing validations of if the turn is valid, and
    if it is, we can call the `saveMove` method. However, that method expects a `bean`
    instead of the variables `x`, `y`, and `lastPlayer` that are being used right
    now, so we might want to change the signature of the `setBox` method.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范提出了一些挑战。首先，我们应该在哪里调用`saveMove`方法？`setBox`私有方法看起来是一个不错的地方。那里我们正在验证轮次是否有效，如果有效，我们可以调用`saveMove`方法。然而，该方法期望一个`bean`而不是当前正在使用的变量`x`，`y`和`lastPlayer`，所以我们可能需要更改`setBox`方法的签名。
- en: 'This is how the method looks now:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该方法现在的样子：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is how it looks after the necessary changes are applied:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在必要的更改应用后的外观：
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The change of the `setBox` signature triggers a few other changes. Since it
    is invoked from the `play` method, we''ll need to instantiate the `bean` there:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`setBox`签名的更改触发了一些其他更改。由于它是从`play`方法中调用的，我们需要在那里实例化`bean`：'
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You might have noticed that we used a constant value `1` as a turn. There is
    still no specification that says otherwise, so we took a shortcut. We'll deal
    with it later.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们使用常量值`1`作为轮次。仍然没有规范表明否则，所以我们采取了一种捷径。我们以后再处理它。
- en: All those changes were still very simple, and it took a reasonably short period
    of time to implement them. If the changes were bigger, we might have chosen a
    different path; and made a simpler change to get to the final solution through
    refactoring. Remember that speed is the key. You don't want to get stuck with
    an implementation that does not pass tests for a long time.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些更改仍然非常简单，并且实施它们所花费的时间相当短。如果更改更大，我们可能会选择不同的路径；并进行简单的更改以通过重构最终解决方案。记住速度是关键。您不希望长时间无法通过测试的实现。
- en: Specification – error handling
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范-错误处理
- en: What happens if a move could not be saved? Our helper method `saveMove` returns
    `true` or `false` depending on the MongoDB operation outcome. We might want to
    throw an exception when it returns `false`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果移动无法保存会发生什么？我们的辅助方法`saveMove`根据MongoDB操作结果返回`true`或`false`。当它返回`false`时，我们可能希望抛出异常。
- en: 'First things first: we should change the implementation of the `before` method
    and make sure that, by default, `saveMove` returns `true`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先：我们应该更改`before`方法的实现，并确保默认情况下`saveMove`返回`true`：
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now that we have stubbed the mocked collection with what we think is the default
    behavior (return `true` when `saveMove` is invoked), we can proceed and write
    the specification:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用我们认为是默认行为（在调用`saveMove`时返回`true`）对模拟集合进行了存根处理，我们可以继续编写规范：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We're using Mockito to return `false` when `saveMove` is invoked. Since, in
    this case, we don't care about a specific invocation of `saveMove`, we used `any(TicTacToeBean.class)`
    as the method argument. This is another one of Mockito's static methods.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`saveMove`时，我们使用Mockito返回`false`。在这种情况下，我们不关心`saveMove`的特定调用，所以我们使用`any(TicTacToeBean.class)`作为方法参数。这是Mockito的另一个静态方法。
- en: Once everything is set, we use a JUnit expectation in the same way as we did
    before throughout [Chapter 3](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml), *Red-Green-Refactor –
    From Failure Through Success until Perfection*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪后，我们将像在[第3章](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml)中一样使用JUnit期望，*从失败到成功再到完美的红绿重构*。
- en: Implementation
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'Let''s do a simple `if` and throw a `RuntimeException` when the result is not
    expected:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个简单的`if`，当结果不符合预期时抛出`RuntimeException`：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Specification – alternate players
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范-交替玩家
- en: Do you remember the turn that we hard coded to be always `1`? Let's fix that
    behavior.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您还记得我们硬编码为始终为“1”的轮次吗？让我们修复这个行为。
- en: 'We can invoke the `play` method twice and verify that the turn changes from
    `1` to `2`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用`play`方法两次并验证轮次从`1`变为`2`：
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Implementation
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'As with almost everything else done in the TDD fashion, implementation is fairly
    easy:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 与几乎所有其他以TDD方式完成的工作一样，实施起来相当容易：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Exercises
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: A few more specifications and their implementations are still missing. We should
    invoke the `drop()` method whenever our `TicTacToe` class is instantiated. We
    should also make sure that `RuntimeException` is thrown when `drop()` returns
    `false`. We'll leave those specifications and their implementations as an exercise
    for you.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些规范及其实施尚未完成。我们应该在我们的`TicTacToe`类实例化时调用`drop()`方法。我们还应该确保在`drop()`返回`false`时抛出`RuntimeException`。我们将把这些规范及其实施留给您作为练习。
- en: The source code can be found in the `03-mongo` branch of the `tdd-java-ch06-tic-tac-toe-mongo`
    Git repository ([https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/03-mongo](https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/03-mongo)).
    The classes in particular are `TicTacToeSpec` and `TicTacToe`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在`tdd-java-ch06-tic-tac-toe-mongo` Git存储库的`03-mongo`分支中找到（[https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/03-mongo](https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/03-mongo)）。特别的类是`TicTacToeSpec`和`TicTacToe`。
- en: Integration tests
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: We did a lot of unit tests. We relied a lot on trust. Unit after unit was specified
    and implemented. While working on specifications, we isolated everything but the
    units we were working on, and verified that one invoked the other correctly. However,
    the time has come to validate that all those units are truly able to communicate
    with MongoDB. We might have made a mistake or, more importantly, we might not
    have MongoDB up and running. It would be a disaster to discover that, for example,
    we deployed our application, but forgot to bring up the DB, or that the configuration
    (IP, port, and so on) is not set correctly.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了很多单元测试。我们非常依赖信任。一个接一个地指定和实现单元。在编写规范时，我们隔离了除了我们正在处理的单元之外的一切，并验证一个单元是否正确调用了另一个单元。然而，现在是时候验证所有这些单元是否真的能够与MongoDB通信了。我们可能犯了一个错误，或者更重要的是，我们可能没有将MongoDB启动和运行。发现，例如，我们部署了我们的应用程序，但忘记启动数据库，或者配置（IP、端口等）没有设置正确，这将是一场灾难。
- en: The integration test's objective is to validate, as you might have guessed,
    the integration of separate components, applications, systems, and so on. If you
    remember the testing pyramid, it states that unit tests are the easiest to write
    and fastest to run, so we should keep other types of tests limited to things that
    UTs did not cover.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的目标是验证，正如你可能已经猜到的那样，独立组件、应用程序、系统等的集成。如果你记得测试金字塔，它指出单元测试是最容易编写和最快运行的，因此我们应该将其他类型的测试限制在单元测试未覆盖的范围内。
- en: We should isolate our integration tests in a way that they can be run occasionally
    (before we push our code to repository, or as a part of our **continuous integration**
    (**CI**) process) and keep unit test as a continuous feedback loop.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该以一种可以偶尔运行的方式隔离我们的集成测试（在将代码推送到存储库之前，或作为我们的持续集成（CI）过程的一部分），并将单元测试作为持续反馈循环。
- en: Tests separation
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试分离
- en: If we follow some kind of convention, it is fairly easy to separate tests in
    Gradle. We can have our tests in different directories and distinct packages or,
    for example, with different file suffixes. In this case, we choose the latter.
    All our specification classes are named with the `Spec` suffix (that is, `TicTacToeSpec`).
    We can make a rule that all integration tests have the `Integ` suffix.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遵循某种约定，那么在Gradle中分离测试就会相当容易。我们可以将测试放在不同的目录和不同的包中，或者，例如，使用不同的文件后缀。在这种情况下，我们选择了后者。我们所有的规范类都以`Spec`后缀命名（即`TicTacToeSpec`）。我们可以制定一个规则，即所有集成测试都具有`Integ`后缀。
- en: With that in mind, let us modify our `build.gradle` file.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们修改我们的`build.gradle`文件。
- en: 'First, we''ll tell Gradle that only classes ending with `Spec` should be used
    by the `test` task:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将告诉Gradle只有以`Spec`结尾的类才应该被`test`任务使用：
- en: '[PRE46]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we can create a new task, `testInteg`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建一个新任务`testInteg`：
- en: '[PRE47]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'With those two additions to `build.gradle`, we continue having the test tasks
    that we used heavily throughout the book; however, this time, they are limited
    only to specifications (unit tests). In addition, all integration tests can be
    run by clicking the `testInteg` task from the Gradle projects IDEA window or running
    the following command from command prompt:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个对`build.gradle`的添加，我们继续使用本书中大量使用的测试任务；然而，这一次，它们仅限于规范（单元测试）。此外，所有集成测试都可以通过从Gradle项目IDEA窗口点击`testInteg`任务或从命令提示符运行以下命令来运行：
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Let us write a simple integration test.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简单的集成测试。
- en: The integration test
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'We''ll create a `TicTacToeInteg` class inside the `com.packtpublishing.tddjava.ch03tictactoe`
    package in the `src/test/java` directory. Since we know that Jongo throws an exception
    if it cannot connect to the database, a test class can be as simple as the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`src/test/java`目录中的`com.packtpublishing.tddjava.ch03tictactoe`包内创建一个`TicTacToeInteg`类。由于我们知道Jongo如果无法连接到数据库会抛出异常，所以测试类可以简单如下：
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The invocation of `assertEquals` is just as a precaution. The real objective
    of this test is to make sure that no `Exception` is thrown. Since we did not start
    MongoDB (unless you are very proactive and did it yourself, in which case you
    should stop it), `test` should fail:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertEquals`的调用只是作为一种预防措施。这个测试的真正目的是确保没有抛出`Exception`。由于我们没有启动MongoDB（除非你非常主动并且自己启动了它，在这种情况下你应该停止它），`test`应该失败：'
- en: '![](img/43e8e2b6-439a-45e2-ac2a-206f307010a9.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43e8e2b6-439a-45e2-ac2a-206f307010a9.png)'
- en: Now that we know that the integration test works, or in other words, that it
    indeed fails when MongoDB is not up and running, let us try it again with the
    DB started. To bring up MongoDB, we'll use Vagrant to create a virtual machine
    with Ubuntu OS. MongoDB will be run as a Docker.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道集成测试是有效的，或者换句话说，当MongoDB没有启动和运行时，它确实会失败，让我们再次尝试一下，看看数据库启动后的情况。为了启动MongoDB，我们将使用Vagrant创建一个带有Ubuntu操作系统的虚拟机。MongoDB将作为Docker运行。
- en: 'Make sure that the 04-integration branch is checked out:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 确保检出了04-integration分支：
- en: '![](img/c0e5e0fa-4005-4021-9cd1-e2dc393f35fe.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0e5e0fa-4005-4021-9cd1-e2dc393f35fe.png)'
- en: 'From the command prompt, run the following command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令提示符运行以下命令：
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Be patient until VM is up and running (it might take a while when executed
    for the first time, especially on a slower bandwidth). Once finished, rerun integration
    tests:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请耐心等待VM启动和运行（当第一次执行时可能需要一段时间，特别是在较慢的带宽上）。完成后，重新运行集成测试：
- en: '![](img/60c4a316-d999-4143-9697-359e4df6e661.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60c4a316-d999-4143-9697-359e4df6e661.png)'
- en: It worked, and now we're confident that we are indeed integrated with MongoDB.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 它起作用了，现在我们确信我们确实与MongoDB集成了。
- en: This was a very simplistic integration test, and in the real-world, we would
    do a bit more than this single test. We could, for example, query the DB and confirm
    that data was stored correctly. However, the purpose of this chapter was to learn
    both how to mock and that we should not depend only on unit tests. The next chapter
    will explore integration and functional tests in more depth.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的集成测试，在现实世界中，我们会做更多的工作而不仅仅是这一个测试。例如，我们可以查询数据库并确认数据是否被正确存储。然而，本章的目的是学习如何模拟以及我们不应该仅依赖单元测试。下一章将更深入地探讨集成和功能测试。
- en: The source code can be found in the `04-integration` branch of the `tdd-java-ch06-tic-tac-toe-mongo`
    Git repository ([https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/04-integration](https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/04-integration)).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在`tdd-java-ch06-tic-tac-toe-mongo` Git存储库的`04-integration`分支中找到（[https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/04-integration](https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/04-integration)）。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Mocking and spying techniques are used to isolate different parts of code or
    third-party libraries. They are essential if we are to proceed with great speed,
    not only while coding, but also while running tests. Tests without mocks are often
    too complex to write and can be so slow that, with time, TDD tends to become close
    to impossible. Slow tests mean that we won't be able to run all of them every
    time we write a new specification. That in itself leads to deterioration in the
    confidence we have in the our tests, since only a part of them is run.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟和间谍技术被用来隔离代码或第三方库的不同部分。它们是必不可少的，如果我们要以极快的速度进行，不仅在编码时，而且在运行测试时也是如此。没有模拟的测试通常太复杂，写起来很慢，随着时间的推移，TDD往往变得几乎不可能。慢速测试意味着我们将无法在每次编写新规范时运行所有测试。这本身就导致我们对测试的信心下降，因为只有其中的一部分被运行。
- en: Mocking is not only useful as a way to isolate external dependencies, but also
    as a way to isolate our own code from a unit we're working on.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟不仅作为隔离外部依赖的一种方式，还作为隔离我们自己正在处理的单元的一种方式。
- en: In this chapter, we presented Mockito as, in our opinion, the framework with
    the best balance between functionality and ease of use. We invite you to investigate
    its documentation in more detail ([http://mockito.org/](http://mockito.org/)),
    as well as other Java frameworks dedicated to mocking. EasyMock ([http://easymock.org/](http://easymock.org/)),
    JMock ([http://www.jmock.org/](http://www.jmock.org/)), and PowerMock ([https://code.google.com/p/powermock/](https://code.google.com/p/powermock/))
    are a few of the most popular.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将Mockito作为我们认为在功能和易用性之间具有最佳平衡的框架进行介绍。我们邀请您更详细地调查其文档（[http://mockito.org/](http://mockito.org/)），以及其他专门用于模拟的Java框架。EasyMock（[http://easymock.org/](http://easymock.org/)）、JMock（[http://www.jmock.org/](http://www.jmock.org/)）和PowerMock（[https://code.google.com/p/powermock/](https://code.google.com/p/powermock/)）是一些最受欢迎的框架。
- en: In the next chapter we are going to put some functional programming concepts
    as well as some TDD concepts applied to them. For that matter, part of the Java
    functional API is going to be presented.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一些函数式编程概念以及应用于它们的一些TDD概念。为此，将介绍Java函数式API的一部分。
