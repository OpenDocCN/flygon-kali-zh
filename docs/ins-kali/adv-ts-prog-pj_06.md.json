["```ts\n{\n  \"compileOnSave\": true,\n  \"compilerOptions\": {\n    \"incremental\": true,\n    \"target\": \"es5\",\n    \"module\": \"commonjs\",\n    \"outDir\": \"./dist\",\n    \"removeComments\": true,\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"inlineSourceMap\": true,\n    \"experimentalDecorators\": true,\n  }\n}\n```", "```ts\nexport function Mongo(connection: string) {\n  return function (constructor: Function) {\n    mongoose.connect(connection, { useNewUrlParser: true}, (e:unknown) => {\n      if (e) {\n        console.log(`Unable to connect ${e}`);\n      } else {\n        console.log(`Connected to the database`);\n      }\n    });\n  }\n}\n```", "```ts\n@Mongo('mongodb://localhost:27017/packt_atp_chapter_06')\nexport class SocketServer {\n}\n```", "```ts\nexport abstract class DataAccessBase<T extends mongoose.Document>{\n  private model: Model;\n  protected constructor(model: Model) {\n    this.model = model;\n  }\n}\n```", "```ts\nAdd(item: T): Promise<boolean> {\n  return new Promise<boolean>((callback, error) => {\n    this.model.create(item, (err: unknown, result: T) => {\n      if (err) {\n        error(err);\n      }\n      callback(!result);\n    });\n  });\n}\n```", "```ts\nGetAll(conditions: unknown, fields: unknown): Promise<unknown[]> {\n  return new Promise<T[]>((callback, error) => {\n    this.model.find(conditions, fields, (err: unknown, result: T[]) => {\n      if (err) {\n        error(err);\n      }\n      if (result) {\n        callback(result);\n      }\n    });\n  });\n}\n```", "```ts\nexport interface IMessageSchema extends mongoose.Document{\n  room: string;\n  messageText: string;\n  received: Date;\n}\n```", "```ts\nexport const MessageSchema = new Schema({\n  room: String,\n  messageText: String,\n  received: Date\n});\n```", "```ts\nexport const MessageModel = mongoose.model<IMessageSchema>('message', MessageSchema, 'messages', false);\nexport class MessageDataAccess extends DataAccessBase<IMessageSchema> {\n  constructor() {\n    super(MessageModel);\n  }\n}\n```", "```ts\nnpm install --save socket.io @types/socket.io\n```", "```ts\nexport class SocketServer {\n  public Start() {\n    const appSocket = socket(3000);\n    this.OnConnect(appSocket);\n  }\n\n  private OnConnect(io: socket.Server) {\n  }\n}\nnew SocketServer.Start();\n```", "```ts\nio.on('connection', (socket:any) => {\n});\n```", "```ts\nthis.messageDataAccess.GetAll({room: room}, {messageText: 1, _id: 0}).then((msgs: string[]) =>{   socket.emit('allMessages', msgs);  });\n```", "```ts\nng new Client --style scss --prefix atp --routing true\n```", "```ts\nnpm install --save ngx-socket-io\n```", "```ts\nimport { SocketIoModule, SocketIoConfig } from 'ngx-socket-io';\nconst config: SocketIoConfig = { url: 'http://localhost:3000', options: {}}\n```", "```ts\nimports: [   BrowserModule,   AppRoutingModule,   SocketIoModule.forRoot(config),\n```", "```ts\nexport function Log() {\n  return function(target: Object,\n  propertyName: string,\n  propertyDesciptor: PropertyDescriptor): PropertyDescriptor {\n  const method = propertyDesciptor.value;\n  propertyDesciptor.value = function(...args: unknown[]) {\n  const params = args.map(arg => JSON.stringify(arg)).join();\n  const result = method.apply(this, args);\n  if (args && args.length > 0) {\n  console.log(`Calling ${propertyName} with ${params}`);\n } else {\n  console.log(`Calling ${propertyName}. No parameters present.`)\n }  return result;\n };  return propertyDesciptor;\n } } \n```", "```ts\nnpm install bootstrap --save\n```", "```ts\n\"styles\": [   \"src/styles.scss\",   \"node_modules/bootstrap/dist/css/bootstrap.min.css\"  ],\n```", "```ts\nng g c components/navigation\n```", "```ts\n<atp-navigation></atp-navigation> <router-outlet></router-outlet> \n```", "```ts\n<nav class=\"navbar navbar-expand-lg navbar-dark bg-dark\">\n <a class=\"navbar-brand\" href=\"#\">Navbar</a>\n <div class=\"collapse navbar-collapse\" id=\"navbarNavAltMarkup\">\n <div class=\"navbar-nav\">\n <a class=\"nav-item nav-link active\" routerLink=\"/general\">General</a>\n <a class=\"nav-item nav-link\" routerLink=\"/secret\" *ngIf=\"auth.IsAuthenticated\">Secret</a>\n <a class=\"nav-item nav-link active\" (click)=\"auth.Login()\" routerLink=\"#\" *ngIf=\"!auth.IsAuthenticated\">Login</a>\n <a class=\"nav-item nav-link active\" (click)=\"auth.Logout()\" routerLink=\"#\" *ngIf=\"auth.IsAuthenticated\">Logout</a>\n </div>\n </div> </nav> \n```", "```ts\nexport class Authorization {\n  constructor(private socket: Socket);\n  public IdToken: string;\n  public AccessToken: string;\n  public Expired: number;\n  public Email: string; }\n```", "```ts\n@Log()  public SetFromAuthorizationResult(authResult: any): void {   if (authResult && authResult.accessToken && authResult.idToken) {   this.IdToken = authResult.idToken;   this.AccessToken = authResult.accessToken;   this.Expired = (authResult.expiresIn * 1000) + Date.now();   this.Email = authResult.idTokenPayload.email;   this.socket.emit('loggedOn', this.Email);  }  }\n```", "```ts\n@Log()  public Clear(): void {   this.socket.emit('loggedOff', this.Email);   this.IdToken = '';   this.AccessToken = '';   this.Expired = 0;   this.Email = '';  }\n```", "```ts\npublic get IsAuthenticated(): boolean {   return this.AccessToken && this.Expired > Date.now();  }\n```", "```ts\nnpm install --save auth0-js\n```", "```ts\n<script type=\"text/javascript\" src=\"node_modules/auth0-js/build/auth0.js\"></script>\n```", "```ts\nng g s services/OauthAuthorization\n```", "```ts\nexport class OauthAuthorizationService {\n  private readonly authorization: Authorization;\n  constructor(private router: Router, private socket: Socket) {\n    this.authorization = new Authorization(socket);\n  } }\n```", "```ts\nauth0 = new auth0.WebAuth({   clientID: 'IvDHHA20ZKx7zvUQWNPrMy15vLTsFxx4',   domain: 'dev-gdhoxa3c.eu.auth0.com',   responseType: 'token id_token',   redirectUri: 'http://localhost:4200/callback',   scope: 'openid email'  });\n```", "```ts\n@Log()  public Login(): void {   this.auth0.authorize();  }\n```", "```ts\n@Log()\npublic Logout(): void {   this.authorization.Clear();   this.auth0.logout({   return_to: window.location.origin\n  });  }\n```", "```ts\n@Log()  public CheckAuthentication(): void {   this.auth0.parseHash((err, authResult) => {   if (!err) {   this.authorization.SetFromAuthorizationResult(authResult);   window.location.hash = '';   this.router.navigate(['/secret']);  } else {   this.router.navigate(['/general']);   console.log(err);  }  });  }\n```", "```ts\n@Log()  public Renew(): void {   this.auth0.checkSession({}, (err, authResult) => {   if (authResult && authResult.accessToken && authResult.idToken) {   this.authorization.SetFromAuthorizationResult(authResult);  } else if (err) {   this.Logout();  }  });  }\n```", "```ts\nconstructor(private auth: OauthAuthorizationService) {   this.auth.CheckAuthentication();  }\n\nngOnInit() {\n  if (this.auth.IsAuthenticated) {\n    this.auth.Renew();\n  }\n}\n```", "```ts\nconstructor(private auth: OauthAuthorizationService) {  }\n```", "```ts\nng g s services/Authorization\n```", "```ts\nexport class AuthorizationService implements CanActivate {\n  constructor(private router: Router, private authorization: OauthAuthorizationService) {}\n}\n```", "```ts\ncanActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot):   Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {   if (!this.authorization.IsAuthenticated) {   this.router.navigate(['general']);   return false;  }   return true; }\n```", "```ts\nng g c components/GeneralChat\nng g c components/SecretChat\n```", "```ts\nconst routes: Routes = [{\n  path: '',\n  redirectTo: 'general',\n  pathMatch: 'full' }, {\n  path: 'general',\n  component: GeneralchatComponent }, {\n  path: 'secret',\n  component: SecretchatComponent,\n  canActivate: [AuthorizationService] }]; \n```", "```ts\nng g s services/ChatMessages\n```", "```ts\nexport class ChatMessagesService {   constructor(private socket: Socket) { }\n}\n```", "```ts\npublic SendMessage = (message: string) => {   this.socket.emit('message', message);  };\n```", "```ts\nprivate JoinRoom = (room: string) => {   this.socket.emit('joinRoom', room);  };\n```", "```ts\npublic GetMessages = (room: string) => {   this.JoinRoom(room);   return Observable.create((ob) => {\n this.socket.fromEvent<UserLogon>('userLogOn').subscribe((user:UserLogon) => {\n      ob.next(`${user.user} logged on at ${user.time}`);\n    });  this.socket.on('message', (msg:string) => {   ob.next(msg);  });   this.socket.on('allMessages', (msg:string[]) => {   msg.forEach((text:any) => ob.next(text.messageText));  });  });  }\n```", "```ts\nsocket.on('joinRoom', (room: string) => {   if (lastRoom !== '') {   socket.leave(lastRoom);  }   if (room !== '') {   socket.join(room);  }   this.messageDataAccess.GetAll({room: room}, {messageText: 1, _id: 0}).then((msgs: string[]) =>{   socket.emit('allMessages', msgs);  });   lastRoom = room;  });\n```", "```ts\nsocket.on('message', (msg: string) => {   this.WriteMessage(io, msg, lastRoom);  });\n```", "```ts\nprivate WriteMessage(io: socket.Server, message: string, room: string) {   this.SaveToDatabase(message, room).then(() =>{   if (room !== '') {   io.sockets.in(room).emit('message', message);   return;  }   io.emit('message', message);  });  }\n```", "```ts\nprivate async SaveToDatabase(message: string, room: string) {   const model: IMessageSchema = <IMessageSchema>{   messageText: message,   received: new Date(),   room: room   };   try{   await this.messageDataAccess.Add(model);  }catch (e) {   console.log(`Unable to save ${message}`);  }  }\n```", "```ts\nsocket.on('loggedOn', (msg: any) => {   io.sockets.in('secret').emit('userLogOn', { user: msg, time: new Date() });  });\n```", "```ts\nconst socket = io.of('/customSocket');\nsocket.on('connection', function(socket) {\n  ...\n});\n```", "```ts\n<div class=\"container-fluid\">\n <div class=\"row\">\n <div *ngFor=\"let msg of messages\" class=\"col-12\">\n {{msg}}\n </div>\n </div> </div>\n```", "```ts\n<nav class=\"navbar navbar-dark bg-dark mt-5 fixed-bottom\">\n <div class=\"navbar-expand m-auto navbar-text\">\n <div class=\"input-group mb-6\">\n <input type=\"text\" class=\"form-control\" placeholder=\"Message\" aria-label=\"Message\" \n        aria-describedby=\"basic-addon2\" [(ngModel)]=\"CurrentMessage\" />\n <div class=\"input-group-append\">\n <button class=\"btn btn-outline-secondary\" type=\"button\" (click)=\"SendMessage()\">Send</button>\n </div>\n </div>\n </div> </nav>\n```", "```ts\nexport class GeneralchatComponent implements OnInit, OnDestroy {   private subscription: Subscription;\n  constructor(private chatService: ChatMessagesService) { }\n\n  CurrentMessage: string;\n  messages: string[] = []; }\n```", "```ts\nSendMessage(): void {   this.chatService.SendMessage(this.CurrentMessage);   this.CurrentMessage = '';  }\n```", "```ts\nngOnInit() {   this.subscription = this.chatService.GetMessages('').subscribe((msg: string) =>{   this.messages.push(msg);  });  }\n```", "```ts\nngOnDestroy() {   if (this.subscription) {   this.subscription.unsubscribe();  }  }\n```"]