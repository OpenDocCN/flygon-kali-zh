- en: Working with the Kubernetes API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes API。
- en: In [Chapter 7](text00137.html) , *Introduction to Kubernetes* , and [Chapter
    8](text00159.html) , *Using Kubernetes with Java* , we learned about the Kubernetes
    concepts and used them in practice by installing local Kubernetes clusters with
    `minikube` . We know all the pieces of Kubernetes architecture, such as pods,
    nodes, deployment, and services, for example. We have also mentioned one of the
    main components residing on the Master node, which is the API server. As you remember
    from [Chapter 7](text00137.html) , *Introduction to Kubernetes* , the API server
    is technically a process named `kube-apiserver` that accepts and responds to `HTTP
    REST` requests using JSON. The API server's main purpose is to validate and process
    data of cluster resources, such as Pods, services, or deployments. The API Server
    is the central management entity. It's also the only Kubernetes component that
    directly connects to `etcd` , a distributed key-value data store where Kubernetes
    stores all its cluster state.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](text00137.html)中，*Kubernetes简介*，和[第8章](text00159.html)，*使用Java与Kubernetes*，我们学习了Kubernetes的概念，并通过安装本地Kubernetes集群`minikube`来实践使用它们。我们了解了Kubernetes架构的所有组件，比如pod、节点、部署和服务等。我们还提到了驻留在Master节点上的主要组件之一，即API服务器。正如你在[第7章](text00137.html)中所记得的，API服务器在技术上是一个名为`kube-apiserver`的进程，它接受并响应使用JSON的`HTTP
    REST`请求。API服务器的主要目的是验证和处理集群资源的数据，比如Pod、服务或部署等。API服务器是中央管理实体。它也是唯一直接连接到`etcd`的Kubernetes组件，`etcd`是Kubernetes存储其所有集群状态的分布式键值数据存储。
- en: In previous chapters, we've been using a `kubectl` command-line tool to manage
    our cluster. `Kubectl` is a useful utility, whenever we want to execute commands
    against our cluster, either for creating, editing, or removing resources. In fact
    `kubectl` also communicates with the API server; you may have noticed that almost
    every action in Kubernetes that changes something is basically editing a resource.
    If you want to scale up or down your application, this will be done by modifying
    the deployment resource. Kubernetes will pick up the change on the fly and apply
    it to the resource. Also, read-only operations such as listing Pods or deployments,
    will execute the corresponding `GET` request.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们一直在使用`kubectl`命令行工具来管理我们的集群。`kubectl`是一个有用的实用工具，每当我们想要针对我们的集群执行命令时，无论是创建、编辑还是删除资源。事实上，`kubectl`也与API服务器通信；你可能已经注意到，在Kubernetes中几乎每个改变某些东西的操作基本上都是在编辑资源。如果你想要扩展或缩减你的应用程序，这将通过修改部署资源来完成。Kubernetes将即时捕捉到变化并将其应用到资源上。此外，诸如列出Pod或部署的只读操作，将执行相应的`GET`请求。
- en: 'In fact, you can see what `REST` calls are being made by the `kubectl` command
    if you run it with a higher level of verbosity, with the `--v=6` or `--v=9` option,
    we will get back to it later in this chapter. We can access the API using `kubectl`
    , `client` libraries, or by making `REST` requests. When can the `REST` API be
    useful? Well, you can create a `REST` call in every programming or scripting language.
    This creates a whole new level of flexibility, you can manage Kubernetes from
    your own Java application, from your continuous delivery flow in Jenkins, or from
    the build tool you are using, let it be Maven for example. Possibilities are almost
    endless. In this chapter, we will get to know the API overview, its structure,
    and example requests. We will be doing this using the `REST` calls with the command-line
    `curl` utility. This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果您以更高级别的详细程度运行kubectl命令，例如使用“--v=6”或“--v=9”选项，您可以看到正在进行的REST调用。我们稍后将回到这个问题。我们可以使用kubectl、客户端库或进行REST请求来访问API。REST
    API何时有用？嗯，您可以在任何编程或脚本语言中创建REST调用。这创造了一个全新的灵活性水平，您可以从自己的Java应用程序中管理Kubernetes，从Jenkins中的持续交付流程中管理，或者从您正在使用的构建工具中管理，例如Maven。可能性几乎是无限的。在本章中，我们将通过使用命令行curl实用程序进行REST调用来了解API概述、其结构和示例请求。本章将涵盖以下主题：
- en: Explanation about the API versioning
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于API版本控制的解释
- en: Authentication (determining who is who)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证（确定谁是谁）
- en: Authorization (determining who can do what)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权（确定谁能做什么）
- en: Using the API by making some example calls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过进行一些示例调用来使用API
- en: OpenAPI Swagger documentation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenAPI Swagger文档
- en: Let's gets started with an API overview.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始API概述。
- en: API versioning
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API版本控制
- en: 'Kubernetes grows continuously. Its features change and this results in the
    API changing as well. To deal with those changes and to not break compatibility
    with existing clients over an extended period of time, Kubernetes supports multiple
    API versions, each with a different API path, such as `/api/v1` or `/apis/extensions/v1beta1`
    . There are three API levels in the Kubernetes API specification: alpha, beta,
    and stable. Let''s get to know the difference.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes不断发展。其功能发生变化，这也导致API发生变化。为了处理这些变化，并且在较长时间内不破坏与现有客户端的兼容性，Kubernetes支持多个API版本，每个版本都有不同的API路径，例如“/api/v1”或“/apis/extensions/v1beta1”。Kubernetes
    API规范中有三个API级别：alpha，beta和stable。让我们了解一下它们的区别。
- en: Alpha
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Alpha
- en: The alpha version level is disabled by default, as with the other software,
    an alpha version should be considered as buggy and not production ready. Also,
    you should note that any featured introduced in the alpha version might not always
    be available later, in the stable version. Also, the changes in the API may be
    incompatible in the next release. You should not use the `alpha` version, unless
    you are very eager to test new features or do some experiments.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Alpha版本级别默认禁用，与其他软件一样，Alpha版本应被视为有错误并且不适合生产。此外，您应该注意，Alpha版本中引入的任何功能可能在稳定版本中并不总是可用。此外，API的更改可能在下一个版本中不兼容。除非您非常渴望测试新功能或进行一些实验，否则不应使用“alpha”版本。
- en: Beta
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Beta
- en: The beta level totally different from the `alpha` level of the API, code is
    tested (it still may have some bugs, as it is still not the `stable` release).
    Also, in contrast to the `alpha` level, features in `beta` will not be dropped
    in the future releases. If there is a breaking, not backward compatible change
    in the API, Kubernetes team will provide a guide on how to migrate. Using `beta`
    on a production environment is not the best idea, but you can safely use `beta`
    on a non-business critical cluster. You are also encouraged to provide feedback
    from using `beta` , this will make Kubernetes better for everyone of us using
    it. A version name in the `beta` level will contain the word `beta` , such as
    `v1beta1` for example.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Beta级别与API的`alpha`级别完全不同，代码经过测试（仍然可能存在一些错误，因为它仍然不是`稳定`版本）。此外，与`alpha`级别相比，`beta`中的功能将不会在将来的版本中被删除。如果API中有破坏性的、不向后兼容的更改，Kubernetes团队将提供迁移指南。在生产环境中使用`beta`并不是最好的主意，但您可以在非业务关键的集群上安全地使用`beta`。您也被鼓励从使用`beta`中提供反馈，这将使我们所有人使用的Kubernetes变得更好。`beta`级别中的版本名称将包含单词`beta`，例如`v1beta1`。
- en: Stable
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 稳定
- en: The stable level of the API is a tested, production-ready software. The version
    name in the stable API will be `vX` where `X` is an integer number, such as `v1`
    for example.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: API的稳定级别是经过测试的，已经准备好投入生产的软件。稳定API中的版本名称将是`vX`，其中`X`是一个整数，例如`v1`。
- en: 'Kubernetes API utilizes a concept of API groups. API groups have been introduced
    to make it easier to extend the Kubernetes API in the future. The API group is
    specified in a `REST` path and in the `apiVersion` field of a call''s JSON payload.
    Currently, there are several API groups in use: core, batch, and extensions. The
    group name is a part of the `REST` path of an API call: `/apis/$GROUP_NAME/$VERSION`
    . The core group is an exception, it does not show up in the `REST` path, for
    example: `/api/v1` **.** You can find the full list of supported API groups in
    the Kubernetes API reference.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API利用了API组的概念。引入API组是为了将来更容易地扩展Kubernetes API。API组在`REST`路径和调用的JSON负载的`apiVersion`字段中指定。目前，有几个API组正在使用：core、batch和extensions。组名是API调用的`REST`路径的一部分：`/apis/$GROUP_NAME/$VERSION`。核心组是一个例外，它不显示在`REST`路径中，例如：`/api/v1`**。**您可以在Kubernetes
    API参考中找到支持的API组的完整列表。
- en: 'By using the API, you can do almost anything with your cluster, as you would
    normally do using the `kubectl` command. This can be dangerous; that''s why Kubernetes
    supports authentication (determining who you are) and authorization (what you
    can do). The basic flow of calling the API service is presented in the following
    diagram:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用API，您几乎可以像使用`kubectl`命令一样对集群进行任何操作。这可能是危险的；这就是为什么Kubernetes支持认证（确定您是谁）和授权（您可以做什么）。调用API服务的基本流程如下图所示：
- en: '![](Image00106.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00106.jpg)'
- en: Let's begin with the authentication.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从认证开始。
- en: Authentication
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证
- en: 'By default, the Kubernetes API server serves `HTTP` requests on two ports:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kubernetes API服务器在两个端口上提供`HTTP`请求：
- en: '**Localhost** , **unsecured port** : By default, the IP address is `localhost`
    and a port number is `8080` . There is no TLS communication, all requests on this
    port bypasses authentication and authorization plugins. This is intended for testing
    and bootstrap, and for other components of the master node. This is also used
    to other Kubernetes components such as scheduler or controller-manager to execute
    API calls. You can change the port number with the `--insecure-port` switch, and
    the default IP by using the `--insecure-bind-address` command-line switch.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地主机**，**不安全端口**：默认情况下，IP地址为`localhost`，端口号为`8080`。没有TLS通信，此端口上的所有请求都将绕过身份验证和授权插件。这是为了测试和引导，以及主节点的其他组件。这也用于其他Kubernetes组件，如调度程序或控制器管理器来执行API调用。您可以使用`--insecure-port`开关更改端口号，并使用`--insecure-bind-address`命令行开关更改默认IP。'
- en: '**Secure port** : The default port number is `6443` (it can be changed with
    the ``--secure-port` switch), usually it''s `443` on Cloud providers. It uses
    TLS communication. A certificate can be set with a `--tls-cert-file` switch. A
    private SSL key can be provided with a `--tls-private-key-file` switch. All requests
    coming through this port will be handled by authentication and authorization modules
    and admission control modules. You should use the secure port whenever possible.
    By having your API clients verify the TLS certificate presented by the `api-server`
    , they can verify that the connection is both encrypted and not susceptible to
    man-in-the-middle attacks. You should also be running the `api-server` where the
    insecure port is only accessible to localhost, so that connections that come across
    the network use `HTTP` ''s.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全端口**：默认端口号是`6443`（可以使用`--secure-port`开关进行更改），通常在云提供商上是`443`。它使用TLS通信。可以使用`--tls-cert-file`开关设置证书。可以使用`--tls-private-key-file`开关提供私有SSL密钥。通过此端口传入的所有请求将由身份验证和授权模块以及准入控制模块处理。尽可能使用安全端口。通过让API客户端验证`api-server`呈现的TLS证书，它们可以验证连接既加密又不易受中间人攻击。您还应该在仅本地主机可以访问不安全端口的情况下运行`api-server`，以便通过网络传入的连接使用`HTTP`。'
- en: With minikube, to access the API server directly, you'll need to use the custom
    SSL certs that have been generated by minikube. The client certificate and key
    are typically stored in `~/.minikube/apiserver.crt` and `~/.minikube/apiserver.key`
    . You'll have to load them into your `HTTP` 'S client when you make `HTTP` requests.
    If you're using `curl` use the`--cert` and the `--key` options to use the `cert`
    and `key` file.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用minikube直接访问API服务器时，您需要使用minikube生成的自定义SSL证书。客户端证书和密钥通常存储在`~/.minikube/apiserver.crt`和`~/.minikube/apiserver.key`中。在进行`HTTP`请求时，您需要将它们加载到您的`HTTP`客户端中。如果您使用`curl`，请使用`--cert`和`--key`选项来使用`cert`和`key`文件。
- en: The access to the API server can be simplified through the proxy, which we will
    start later in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: API服务器的访问可以通过代理简化，在本章后面我们将开始介绍。
- en: If you want to send requests to the Kubernetes API from a different domain,
    you will need to enable `cors` on `api-server` . You do that by adding a `--cors-allowed-origins=["http://*"]`
    argument to `kube-apiserver` configuration, typically in the `/etc/default/kube-apiserver`
    file and restart `kube-apiserver` .
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想从不同的域发送请求到Kubernetes API，您需要在`api-server`上启用`cors`。您可以通过在`kube-apiserver`配置中添加`--cors-allowed-origins=["http://*"]`参数来实现。通常在`/etc/default/kube-apiserver`文件中进行配置，并重新启动`kube-apiserver`。
- en: Note that Kubernetes cluster does not manage users by itself. Instead, users
    are assumed to be managed by an outside, independent service. There is no resource
    in Kubernetes cluster that represents normal user accounts*.* That's why users
    cannot be added to a cluster through an API call.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Kubernetes集群不会自行管理用户。相反，用户被假定由外部独立服务管理。Kubernetes集群中没有代表普通用户帐户的资源。这就是为什么用户不能通过API调用添加到集群中。
- en: Kubernetes does not manage user accounts by itself.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes不会自行管理用户帐户。
- en: 'The Kubernetes API supports multiple forms of authentication: `HTTP` basic
    auth, bearer token, and client certificates. They are called authentication strategies.
    When launching the `api-server` , you can enable or disable each of these authentication
    strategies with command-line flags. Let''s look what''s possible, starting with
    the simplest, basic auth strategy.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API支持多种身份验证形式：`HTTP`基本身份验证、持有者令牌和客户端证书。它们被称为身份验证策略。在启动`api-server`时，您可以使用命令行标志来启用或禁用这些身份验证策略。让我们看看可能的情况，从最简单的基本身份验证策略开始。
- en: HTTP basic auth
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP基本身份验证
- en: 'To use this authentication strategy, you will need to start the `api-server`
    with the `--basic-auth-file=<path_to_auth_file>` switch. It should be a `csv`
    file with the following entry for each user:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此身份验证策略，您需要使用`--basic-auth-file=<path_to_auth_file>`开关启动`api-server`。它应该是一个包含每个用户以下条目的`csv`文件：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can also specify an optional fourth column containing group names, separated
    by a comma. If there is more than one group for the user, the whole column contents
    must be enclosed in double quotes, for example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指定一个可选的第四列，其中包含用逗号分隔的组名。如果用户有多个组，整个列的内容必须用双引号括起来，例如：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the `api-server` utilizes the basic auth strategy, it will expect all `REST`
    calls to be made with the `Authorization` header containing username and password
    encoded in `BASE64` (similar to ordinary basic auth protected web calls), for
    example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`api-server`使用基本身份验证策略，它将期望所有的`REST`调用都包含在`Authorization`头中，其中包含用`BASE64`编码的用户名和密码（类似于普通的基本身份验证保护的web调用），例如：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To generate the authorization header value, you can use the following command
    in the shell, it will generate the value for user having password secret:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成授权头值，您可以在shell中使用以下命令，它将为具有密码secret的用户生成值：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that any changes to the basic `auth` file will require a restart of the
    `api-server` to pick up the changes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对基本`auth`文件的任何更改都需要重新启动`api-server`才能生效。
- en: '`HTTP` basic auth is typically used as default when running Kubernetes in the
    cloud. For example, once you launch your container cluster on Google Container
    Engine, you will have a master running the `api-server` on a VM in your GCP project.
    If you run a `gcloud preview container clusters` list, you will see the endpoint
    at which the `api-server` listens for requests as well as the credentials needed
    to access it. You will find more on running Kubernetes in the cloud in [Chapter
    10](text00205.html) , *Deploying Java on Kubernetes in the Cloud* .'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在云中运行Kubernetes时，通常会使用`HTTP`基本身份验证作为默认。例如，一旦在Google容器引擎上启动容器集群，您将在GCP项目中的VM上运行`api-server`。如果运行`gcloud
    preview container clusters`列表，您将看到`api-server`监听请求的端点以及访问它所需的凭据。您将在[第10章](text00205.html)中找到更多关于在云中运行Kubernetes的内容，*在云上部署Java到Kubernetes*。
- en: Static token file
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态令牌文件
- en: 'To make `api-server` use this scheme, it needs to be started with the `--token-auth-file=<PATH_TO_TOKEN_FILE>`
    switch. Similar to the `HTTP` basic auth strategy, the provided file is a `csv`
    file with a record for every user. The record needs to be in the following format:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`api-server`使用此方案，需要使用`--token-auth-file=<PATH_TO_TOKEN_FILE>`开关启动。与`HTTP`基本身份验证策略类似，提供的文件是一个包含每个用户记录的`csv`文件。记录需要采用以下格式：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Again, the group name is optional and if there is more than one group for the
    user, you will need to separate them with a comma and enclose them in double quotes.
    The token is just a `base64` encoded string. An example command to generate a
    token on Linux can be as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，组名是可选的，如果用户有多个组，您需要用逗号分隔它们并用双引号括起来。令牌只是一个`base64`编码的字符串。在Linux上生成令牌的示例命令可以如下：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output will be a token, which you then enter into the `token` file, for
    example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是一个令牌，然后您将其输入到`token`文件中，例如：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When using this strategy, `api-server` will be expecting an `Authorization`
    header with a value of `Bearer <` `TOKEN>` . In our example, this will looks the
    same as the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用这种策略时，`api-server`将期望一个值为`Bearer <` `TOKEN>`的`Authorization`头。在我们的示例中，这将看起来与以下内容相同：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tokens last indefinitely, and the token list cannot be changed without restarting
    API server.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌永久有效，并且令牌列表在不重新启动API服务器的情况下无法更改。
- en: Client certificates
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端证书
- en: 'In order to use this scheme, the `api-server` needs to be started with the
    following switch:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这个方案，`api-server`需要使用以下开关启动：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `CA_CERTIFICATE_FILE` must contain one or more certificates authorities
    that can be used to validate client certificates presented to the `api-server`
    . The /CN (common name) of the client certificate is used as the username. Client
    certificates can also indicate a user''s group memberships using the organization
    fields. To include multiple group memberships for a user you will need to include
    multiple organization fields in the certificate. For example, using the `openssl`
    command-line tool to generate a certificate signing request:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`CA_CERTIFICATE_FILE`必须包含一个或多个证书颁发机构，用于验证提交给`api-server`的客户端证书。客户端证书的/CN（通用名称）用作用户名。客户端证书还可以使用组织字段指示用户的组成员资格。要为用户包括多个组成员资格，您需要在证书中包括多个组织字段。例如，使用`openssl`命令行工具生成证书签名请求：'
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This would create a certificate signing request for the username `user` , belonging
    to two groups, `group1` and `group2` .
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为用户名`user`创建一个证书签名请求，属于两个组`group1`和`group2`。
- en: OpenID
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenID
- en: OpenID connect 1.0 is a simple identity layer on top of the OAuth 2.0 protocol.
    You can read more about OpenID connect on the internet at `https://openid.net/connect`
    . It allows clients to verify the identity of the end-user based on the authentication
    performed by an authorization server, as well as to obtain basic profile information
    about the end-user in an interoperable and `REST` -like manner. All cloud providers,
    including Azure, Amazon, and Google support OpenID. The main difference with `OAuth2`
    is the additional field returned with the access token called an `id_token` .
    This token is a **JSON Web Token** (**JWT** ) with well-known fields (user's email
    for example), signed by the server. To identify the user, the authenticator uses
    the `id_token` from the `OAuth2token` response as a bearer token. To use the OpenID
    authentication, you will need to log in to your identity provider, which will
    provide you with an `id_token` (and also standard OAuth 2.0 `access_token` and
    a `refresh_token` **)** .
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID connect 1.0是OAuth 2.0协议之上的一个简单身份验证层。您可以在互联网上阅读有关OpenID connect的更多信息，网址为`https://openid.net/connect`。它允许客户端根据授权服务器执行的身份验证来验证最终用户的身份，并以一种可互操作和类似于`REST`的方式获取有关最终用户的基本配置信息。所有云提供商，包括Azure、Amazon和Google都支持OpenID。与`OAuth2`的主要区别在于访问令牌中返回的附加字段称为`id_token`。这个令牌是一个带有众所周知字段（例如用户的电子邮件）的**JSON
    Web Token**（**JWT**），由服务器签名。为了识别用户，认证器使用`OAuth2token`响应中的`id_token`作为持有者令牌。要使用OpenID身份验证，您需要登录到您的身份提供者，该提供者将为您提供一个`id_token`（以及标准的OAuth
    2.0 `access_token`和`refresh_token`**）**。
- en: Since all of the data needed to do the authentication is contained within the
    `id_token` , Kubernetes does not need to make an additional call to the identity
    provider. This is very important from the scalability purposes, every request
    is stateless.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于进行身份验证所需的所有数据都包含在`id_token`中，Kubernetes不需要向身份提供者发出额外的调用。这对于可扩展性非常重要，每个请求都是无状态的。
- en: To provide a token value to the `kubectl` command, you will need to use the
    `--token` flag. Alternatively, you can add it directly to your `kubeconfig` file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`kubectl`命令提供一个令牌值，您需要使用`--token`标志。或者，您可以直接将其添加到您的`kubeconfig`文件中。
- en: 'This is the simplified flow of things that will happen if you execute a `HTTP`
    call to your `api-server` :'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当您执行对您的`api-server`的`HTTP`调用时会发生的事情的简化流程：
- en: '`kubectl` will send your `id_token` in an `authorization` header to the API
    server'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl`将在`authorization`标头中发送您的`id_token`到API服务器。'
- en: The API server will validate the JWT signature by checking against the certificate
    named in the configuration
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API服务器将通过检查配置中命名的证书来验证JWT签名
- en: The API server will check to make sure the `id_token` hasn't expired
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API服务器将检查`id_token`是否已过期
- en: The API server will make sure the user is authorized, and returns a response
    to `kubectl` if so
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API服务器将确保用户经过授权，并且如果是这样的话会向`kubectl`返回一个响应。
- en: By default, anyone who has access credentials to the `api-server` has full access
    to the cluster. You can also configure more fine grained authorization policies,
    let's look at authorization now.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，任何具有对`api-server`的访问凭据的人都可以完全访问集群。您还可以配置更精细的授权策略，现在让我们来看看授权。
- en: Authorization
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: 'The next step after the successful authentication is to check what operations
    are allowed for the authenticated user. Kubernetes supports four types of authorization
    policy schemes as of today. To utilize the specific authorization schema, use
    the `--authorization-mode` switch when starting `api-server` . The syntax is:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 成功验证后的下一步是检查经过授权的用户允许进行哪些操作。截至今天，Kubernetes支持四种类型的授权策略方案。要使用特定的授权模式，启动`api-server`时使用`--authorization-mode`开关。语法是：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `<mode>` parameter contains an ordered list of authorization plugins that
    Kubernetes is supposed to authenticate users with. When multiple authentication
    plugins are enabled, the first one that will successfully authenticate the request
    will make Kubernetes skip executing all remaining plugins.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`<mode>`参数包含了Kubernetes应该用来对用户进行身份验证的授权插件的有序列表。当启用了多个身份验证插件时，第一个成功验证请求的插件将使Kubernetes跳过执行所有剩余的插件。'
- en: The default authorization mode is `AlwaysAllow` , which allows all requests.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 默认授权模式是`AlwaysAllow`，允许所有请求。
- en: 'The following authorization schemes are supported:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 支持以下授权方案：
- en: Attribute-based control
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于属性的控制
- en: Role-based control
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于角色的控制
- en: Webhook
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webhook
- en: '`AlwaysDeny`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AlwaysDeny`'
- en: '`AlwaysAllow`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AlwaysAllow`'
- en: Let's describe them, one by one, briefly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地逐一描述它们。
- en: Attribute-based access control
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于属性的访问控制
- en: '**Attribute-Based Access Control** (**ABAC** ) policy will be used if you start
    the `api-server` with the `--authorization-mode=ABAC` option. This policy uses
    local files in which you can, in a flexible way, define permission every user
    should have. There is an additional option to provide a policy file: `--authorization-policy-file`
    , so the complete syntax to use this policy will be:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于属性的访问控制**（**ABAC**）策略将在使用`--authorization-mode=ABAC`选项启动`api-server`时使用。该策略使用本地文件，您可以以灵活的方式在其中定义每个用户应具有的权限。还有一个提供策略文件的额外选项：`--authorization-policy-file`，因此使用此策略的完整语法将是：'
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that any changes to policy file will require a restart of the `api-server`
    .
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对策略文件的任何更改都将需要重新启动`api-server`。
- en: 'As you remember from [Chapter 7](text00137.html) , *Introduction to Kubernetes*
    , Kubernetes clusters use the concept of namespaces to group related resources,
    such as Pods, deployments, or services. The authorization schemas in the `api-server`
    ''s make use of these namespaces. The `ABAC` policy file syntax is rather clear
    and readable. Each entry is a JSON object describing the authorization rule. Consider
    the following entry in the policy file, which gives user `john` complete access
    to the namespace `myApp` :'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从[第7章](text00137.html)中记得的，*Kubernetes简介*，Kubernetes集群使用命名空间的概念来对相关资源进行分组，如Pod、部署或服务。`api-server`中的授权模式利用了这些命名空间。`ABAC`策略文件语法相当清晰和可读。每个条目都是描述授权规则的JSON对象。考虑策略文件中的以下条目，它为用户`john`提供对命名空间`myApp`的完全访问权限：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The next example will give user `admin` complete access to all the namespaces:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例将为用户`admin`提供对所有命名空间的完全访问权限：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And finally, an example that gives all users read-only access to the entire
    cluster:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个示例，为所有用户提供对整个集群的只读访问权限：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Role-based access control (RBAC)
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于角色的访问控制（RBAC）
- en: 'The **Role-Based Access Control** (**RBAC** ), policy implementation is deeply
    integrated into Kubernetes. In fact, Kubernetes uses it internally for the system
    components, to grant the permissions necessary for them to function. `RBAC` is
    100% API driven, roles and bindings are API resources that an administrator can
    write and create on the cluster such as other resources such as Pods, deployments,
    or services. Enabling `RBAC` mode is as easy as passing a flag to `kube-apiserver`
    :'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于角色的访问控制**（**RBAC**），策略实施深度集成到了Kubernetes中。事实上，Kubernetes在内部使用它来为系统组件授予必要的权限以使其正常运行。`RBAC`是100%的API驱动，角色和绑定是管理员可以在集群上编写和创建的API资源，就像其他资源（如Pod、部署或服务）一样。启用`RBAC`模式就像向`kube-apiserver`传递一个标志一样简单：'
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This mode allows you to create and store policies using the Kubernetes API.
    In the `RBAC` API, a set of permission is represented by the concept of role.
    There is a distinction between namespace roles, represented by a `Role` resource,
    and a whole cluster role, represented by a `ClusterRole` resource. A `ClusterRole`
    can define the same all permissions a `Role` can define, but also some cluster-related
    permission, such as managing cluster nodes or modifying resources across all available
    namespaces. Note that once `RBAC` is enabled, every aspect of the API is disallowed
    access.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式允许您使用Kubernetes API创建和存储策略。在`RBAC` API中，一组权限由角色的概念表示。命名空间角色和整个集群角色之间有区别，由`Role`资源表示，整个集群角色由`ClusterRole`资源表示。`ClusterRole`可以定义与`Role`相同的所有权限，但也可以定义一些与集群相关的权限，例如管理集群节点或修改所有可用命名空间中的资源。请注意，一旦启用了`RBAC`，API的每个方面都将被禁止访问。
- en: Permissions are additive; there are no deny rules.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 权限是可累加的；没有拒绝规则。
- en: 'This is an example of role that gives the whole set of available permissions
    to all operations on all resources:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个角色的示例，它为所有资源的所有操作提供了整套可用权限：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The Role is a resource, as you remember from [Chapter 8](text00159.html) ,
    *Using Kubernetes with Java* , to create resource using the file, you execute
    the `kubectl create` command, for example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 角色是一个资源，正如你从[第8章](text00159.html)中记得的，*使用Java与Kubernetes*，要使用文件创建资源，你执行`kubectl
    create`命令，例如：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A `Role` and `ClusterRole` defines the set of permissions, but does not assign
    them to users or groups directly. There is another resource for that in Kubernetes
    API, which is `RoleBinding` or `ClusterRoleBinding` . They bind `Role` or `ClusterRole`
    to the specific subject, which can be user, group, or service user. To bind the
    `Role` or `ClusterRole` , you will need to execute the `kubectl create rolebinding`
    command. Take a look at the following examples. To grant the `adminClusterRole`
    to a user named `john` in the namespace `myApp` :'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Role`和`ClusterRole`定义了一组权限，但不直接将它们分配给用户或组。在Kubernetes API中有另一个资源，即`RoleBinding`或`ClusterRoleBinding`。它们将`Role`或`ClusterRole`绑定到特定的主体，可以是用户、组或服务用户。要绑定`Role`或`ClusterRole`，您需要执行`kubectl
    create rolebinding`命令。看一下以下示例。要在命名空间`myApp`中向名为`john`的用户授予`adminClusterRole`：'
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next one will grant the `cluster-admin ClusterRole` to a user named `admin`
    across the entire cluster:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个将在整个集群中向名为`admin`的用户授予`cluster-admin ClusterRole`：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The equivalent YAML file to use with `kubectl create -f` will be as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl create -f`的等效YAML文件如下：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: WebHook
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebHook
- en: When the `api-server` is started with the `--authorization-mode=Webhook` option,
    it will make calls to external `HTTP` server to authorize the user. This gives
    you the capability to create your own authorization servers. In other words, a
    WebHook is an `HTTP` callback mode that allows you to manage authorization using
    a remote `REST` server, either developed on your own, or a third-party authorization
    server.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当`api-server`以`--authorization-mode=Webhook`选项启动时，它将调用外部的`HTTP`服务器来对用户进行授权。这使您能够创建自己的授权服务器。换句话说，WebHook是一种`HTTP`回调模式，允许您使用远程`REST`服务器来管理授权，无论是您自己开发的，还是第三方授权服务器。
- en: 'When doing the authorization check, the `api-server` will execute a `HTTP POST`
    request, with a JSON payload containing a serialized `api.authorization.v1beta1.SubjectAccessReview`
    object. This object describes the user making request to the `api-server` , the
    action which this user would like to execute, and the details about the resource
    being the subject of this action. An example request payload could look like the
    following example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行授权检查时，`api-server`将执行`HTTP POST`请求，其中包含一个序列化的`api.authorization.v1beta1.SubjectAccessReview`对象的JSON有效负载。此对象描述了向`api-server`发出请求的用户，此用户想要执行的操作，以及作为此操作主题的资源的详细信息。示例请求有效负载可能如下例所示：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The remote authorization server should provide a response, saying if this user
    is authorized to execute the specified action on a specified resource. The response
    should contain the `SubjectAccessReviewStatus` field, specifying if the `api-server`
    should either allow or disallow access. A permissive JSON response would looks
    the same as the this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 远程授权服务器应提供响应，指示此用户是否被授权在指定资源上执行指定操作。响应应包含`SubjectAccessReviewStatus`字段，指定`api-server`是否应允许或拒绝访问。宽松的JSON响应看起来与此相同：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The negative response will appear as in the following example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 负面响应将如下例所示出现：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Having the possibility to delegate the authorization to another service makes
    the authorization process very flexible, imagine your own software that authorizes
    a user to do certain things in your cluster depending on the roles they have in
    the corporate `LDAP` directory for example.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将授权委托给另一个服务的可能性使授权过程非常灵活，想象一下，根据用户在企业`LDAP`目录中的角色，您自己的软件授权用户在集群中执行某些操作。
- en: AlwaysDeny
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AlwaysDeny
- en: This policy denies all requests. If will be used if you start the `api-server`
    with a `--authorization-mode=AlwaysDeny` switch. This can be useful if you are
    doing some testing or would like to block incoming requests without actually stopping
    the `api-server` .
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此策略拒绝所有请求。如果您使用`--authorization-mode=AlwaysDeny`开关启动`api-server`，则将使用它。如果您正在进行一些测试或希望阻止传入请求而不实际停止`api-server`，这可能很有用。
- en: AlwaysAllow
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AlwaysAllow
- en: If you start the `api-server` with `--authorization-mode=AlwaysAllow` , all
    requests will be accepted, without using any authorization schema. Use this flag
    only if you do not require authorization for your API requests.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`--authorization-mode=AlwaysAllow`开启`api-server`，则所有请求将被接受，而不使用任何授权模式。只有在不需要对API请求进行授权时才使用此标志。
- en: 'As you can see, the authentication and authorization possibilities in Kubernetes
    are very flexible. On the diagram at the beginning of this chapter we have seen
    the third phase of the API call flow: the admission control. What role does the
    admission control play? Let''s find out.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Kubernetes中的身份验证和授权可能性非常灵活。在本章开头的图表中，我们已经看到了API调用流程的第三阶段：准入控制。准入控制扮演着什么角色？让我们找出来。
- en: Admission control
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准入控制
- en: An admission control plug-in intercepts requests to the Kubernetes API server
    after the request is authenticated and authorized, but prior to making any changes
    to the API resource. These plug-ins run in sequence, before a request is accepted
    into the cluster. The Kubernetes API server supports a flag, `admission-control`
    that takes a comma-delimited, ordered list of admission control plugins.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 准入控制插件在请求经过身份验证和授权后，但在对API资源进行任何更改之前拦截对Kubernetes API服务器的请求。这些插件按顺序运行，在请求被接受到集群之前运行。Kubernetes
    API服务器支持一个标志`admission-control`，它接受一个逗号分隔的有序准入控制插件列表。
- en: Now that we have an overview of how the API call looks the same, let's actually
    make some use of it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了API调用的外观，让我们实际利用一些。
- en: Using the API
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用API
- en: The API reference is a detailed document, available on the internet [https://kubernetes.io/docs/api-reference/v1.6/](https://kubernetes.io/docs/api-reference/v1.6/)
    ; [of course the API version will change in the future, `v1.6` was the current
    one at the time of writing.](https://kubernetes.io/docs/api-reference/v1.6/)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: API参考是一份详细的文档，可以在互联网上找到[https://kubernetes.io/docs/api-reference/v1.6/](https://kubernetes.io/docs/api-reference/v1.6/)；[当然，API版本将来会更改，`v1.6`是写作时的当前版本。](https://kubernetes.io/docs/api-reference/v1.6/)
- en: Before we make some actual calls to the `api-server` , it's worth knowing that
    `kubectl` also communicates with Kubernetes cluster using the API. As we mentioned
    earlier, you can see what `REST` calls are being made by the `kubectl` command.
    Looking at what's being sent to the server during the usage of `kubectl` is a
    great way to become familiar with Kubernetes API.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对`api-server`进行一些实际调用之前，值得知道`kubectl`也使用API与Kubernetes集群进行通信。正如我们之前提到的，您可以通过`kubectl`命令查看正在进行的`REST`调用。查看在使用`kubectl`时发送到服务器的内容是熟悉Kubernetes
    API的好方法。
- en: To see `REST` requests being executed by `kubectl` , run it with a higher level
    of verbosity, for example with a `--v=6` or `--v=9` option.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`kubectl`执行的`REST`请求，可以以更高的详细级别运行它，例如使用`--v=6`或`--v=9`选项。
- en: Before we start making actual `REST` calls, let's briefly see what API operations
    are possible.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实际进行`REST`调用之前，让我们简要地看一下API操作有哪些可能。
- en: API operations
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API操作
- en: 'Kubernetes API defines the CRUD (create, update, read, and delete) set of operations:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API定义了CRUD（创建、更新、读取和删除）一组操作：
- en: '`Create` : Create operations will create the resource in the cluster. The JSON
    payload that you will need to provide with your `REST` call is the resource manifest.
    It''s the equivalent of the YAML file we''ve been constructing in the [Chapter
    8](text00159.html) , *Using Kubernetes with Java* . This time, it will be in the
    JSON format.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Create`：创建操作将在集群中创建资源。您需要在您的`REST`调用中提供的JSON有效负载是资源清单。这相当于我们在[第8章](text00159.html)中构建的YAML文件，*使用Java与Kubernetes*。这次，它将以JSON格式呈现。'
- en: '`Update` : The update operation can be either `Replace` or `Patch` . A `Replace`
    will simply replace the whole resource object (a Pod, for example) with the provided
    spec. A `Patch` , on the other hand, will apply a change only to a specific field.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update`：更新操作可以是`Replace`或`Patch`。`Replace`将简单地用提供的规范替换整个资源对象（例如Pod）。另一方面，`Patch`将仅对特定字段应用更改。'
- en: '`Read` : A read operation can be either `Get` , `List,` or `Watch` . By executing
    `Get` , you will be given a specific resource object by its name. Executing `List`
    will retrieve all resource objects of a specific type within a namespace. You
    can use the selector query. A special form of the `List` operation is `List All
    Namespaces` , as the name says this will retrieve resources across all namespaces.
    A `Watch` operation will stream results for an object or a of list objects as
    they are updated.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Read`：读取操作可以是`Get`、`List`或`Watch`。通过执行`Get`，您将得到一个特定资源对象的名称。执行`List`将检索命名空间内特定类型的所有资源对象。您可以使用选择器查询。`List`操作的一种特殊形式是`List
    All Namespaces`，正如其名称所示，这将检索所有命名空间中的资源。`Watch`操作将流式传输对象或列表对象的结果，因为它们被更新。'
- en: '`Delete` : Will simply delete a resource.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除：将简单地删除资源。
- en: Kubernetes `api-server` also exposes some additional, resource-specific operations.
    This includes `Rollback` , which rollbacks a Pod template to a previous version
    or read /write scale, which reads or updates the number of replicas for the given
    resource.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes `api-server`还公开了一些其他特定于资源的操作。这包括`Rollback`，它将Pod模板回滚到先前的版本，或者读取/写入规模，它读取或更新给定资源的副本数量。
- en: Example calls
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例调用
- en: In the following examples, we will be using a command-line `HTTP` client, `curl`
    . You are not limited to `curl` , you can freely use the `HTTP` client you find
    convenient. Using the `HTTP` client with the user interface is often very handy,
    they usually present the `HTTP` response in a structured form and sometimes also
    do some request validation, if it's well formed. My recommended GUI clients will
    be Postman (for Windows, Linux, or Mac), or PAW for Mac.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用命令行`HTTP`客户端`curl`。您不限于`curl`，可以自由使用您觉得方便的`HTTP`客户端。使用带有用户界面的`HTTP`客户端通常非常方便，它们通常以结构化形式呈现`HTTP`响应，并有时还会进行一些请求验证，如果它是格式良好的。我推荐的GUI客户端将是Postman（适用于Windows、Linux或Mac），或者Mac的PAW。
- en: 'Before making any calls, let''s first start a proxy to the Kubernetes API server.
    The `kubectl` needs to be configured first, to be able to communicate with your
    cluster. In our local Kubernetes installation with `minikube` , the `kubectl`
    command will be automatically configured. To start a proxy to the `api-server`
    , execute the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何调用之前，让我们首先启动一个代理到Kubernetes API服务器。首先需要配置`kubectl`，以便能够与您的集群通信。在我们的本地Kubernetes安装中，使用`minikube`，`kubectl`命令将自动配置。要启动到`api-server`的代理，请执行以下命令：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'While the proxy session is running, any request sent to `localhost:8000` will
    be forwarded to the Kubernetes API server. To check if our `api-server` is running,
    let''s ask for the API version it supports:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在代理会话运行时，发送到`localhost:8000`的任何请求将被转发到Kubernetes API服务器。要检查我们的`api-server`是否正在运行，让我们询问它支持的API版本：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If the `api-server` is running and waiting for incoming requests, it should
    give you an output similar to this one:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`api-server`正在运行并等待传入请求，它应该给您一个类似于这样的输出：
- en: '![](Image00107.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00107.jpg)'
- en: It seems to be running fine; let's continue and make some use of the exposed
    API, starting, the same as previously, by creating a service.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来一切都很顺利；让我们继续利用暴露的API，开始创建服务，与之前一样。
- en: Creating a service using the API
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用API创建服务
- en: 'First, let''s create a service manifest file. Note that if you have your services,
    deployments, and Pods created in [Chapter 8](text00159.html) , *Using Kubernetes
    with Java* , by using the `kubectl` , you will need to delete them using `kubectl`
    or the Kubernetes dashboard. We are going to use the same names for the service
    and a deployment. When using `curl` with larger payloads, it''s more convenient
    to have the payload in the external file and not type it in the command-line.
    The JSON file that we will use as the payload is very similar to the one we have
    been using when creating a Pod with `kubectl` , but in JSON format this time.
    Let''s create a file named `service.json` :'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个服务清单文件。请注意，如果您在[第8章](text00159.html)中使用`kubectl`创建了您的服务、部署和Pod，*使用Java与Kubernetes*，您将需要使用`kubectl`或Kubernetes仪表板将它们删除。我们将使用相同的名称来创建服务和部署。在使用`curl`发送较大有效负载时，最好将有效负载放在外部文件中，而不是在命令行中输入。我们将使用的JSON文件作为有效负载与我们使用`kubectl`创建Pod时使用的文件非常相似，但这次是以JSON格式。让我们创建一个名为`service.json`的文件：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that the contents of the JSON file are basically identical to the one we've
    been using when we were creating resources using YAML files. Yes, you can clearly
    see how the `kubectl` command is implemented, it just creates a JSON payload from
    the file input, there is no magic behind the scenes, at all.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，JSON文件的内容基本上与我们在使用YAML文件创建资源时使用的内容相同。是的，您可以清楚地看到`kubectl`命令是如何实现的，它只是从文件输入创建一个JSON有效负载，一点魔术都没有。
- en: You can convert between YAML to JSON and vice-versa using one of the YAML/JSON
    converters available online. The Kubernetes `api-server` will accept such JSON
    as `Kubectl` accepts the YAML file.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在网上使用其中一个YAML/JSON转换器在YAML和JSON之间进行转换。Kubernetes `api-server`将接受这样的JSON，就像`Kubectl`接受YAML文件一样。
- en: 'Having our JSON file ready, the next step is to create the service resource
    in our cluster by invoking the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好我们的JSON文件，下一步是通过调用以下命令在我们的集群中创建服务资源：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Having our service defined, let's create a deployment.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了我们的服务，让我们创建一个部署。
- en: Creating a deployment using the API
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用API创建部署
- en: 'Creating a deployment is very similar to creating a service, it''s creating
    another type of Kubernetes resource, after all. All we need is a proper JSON payload
    file that we will be sending to the `api-server` using the `POST HTTP` method.
    Our `rest-example` deployment manifest in JSON can look as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 创建部署与创建服务非常相似，毕竟它是创建另一种类型的Kubernetes资源。我们所需要的只是一个适当的JSON有效负载文件，我们将使用`POST HTTP`方法将其发送到`api-server`。我们的JSON格式的`rest-example`部署清单可以如下所示：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s save the file using the `deployment.json` filename. Again, all we need
    to do now is to post this file to the `api-server` . This process is very similar
    to the creation of the service, it will be just a `POST` to the different endpoint
    with a different payload. To create a deployment from the shell using `curl` ,
    execute the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`deployment.json`文件名保存文件。再次，我们现在需要做的就是将这个文件发布到`api-server`。这个过程与创建服务非常相似，只是向不同的端点发送不同的有效负载进行`POST`。要使用`curl`从shell创建部署，请执行以下命令：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding example, you should note that deployment related API commands
    are in another API group: `extensions` . That''s why the endpoint will have a
    different `REST` path.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您应该注意到与部署相关的API命令位于另一个API组：`extensions`。这就是为什么端点将具有不同的`REST`路径。
- en: 'After executing those two `REST HTTP` requests, we should have our service
    and deployment created in the cluster. Of course, because of the deployment manifest
    contains the number of replicas with the value `1` , one Pod will be created as
    well. Let''s check if it''s true, by executing the following commands:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这两个`REST HTTP`请求后，我们应该在集群中创建了我们的服务和部署。当然，因为部署清单包含副本数为`1`，一个Pod也将被创建。让我们通过执行以下命令来检查是否属实：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you can see in the following screenshot, all of the resources exist on our
    cluster. This time, however, they were created by two simple `HTTP POST` requests
    to the Kubernetes `api-servers` , without using `kubectl` :'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在以下截图中所看到的，所有资源都存在于我们的集群中。然而，这一次，它们是通过两个简单的`HTTP POST`请求到Kubernetes `api-servers`创建的，而不是使用`kubectl`：
- en: '![](Image00108.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00108.jpg)'
- en: 'We have said before that we can observe what `HTTP` requests are being executed
    by the `kubectl` tool. Let''s verify that. We will execute the last command to
    get the list of Pods, but with additional verbosity level, the same as this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，我们可以观察`kubectl`工具执行的`HTTP`请求。让我们验证一下。我们将执行最后一个命令以获取Pod的列表，但使用相同的额外详细级别，就像这样：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output should be similar to the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '![](Image00109.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00109.jpg)'
- en: 'There''s a bunch of log lines about getting information from the cluster cache,
    but the last line is especially interesting, it contains the actual `HTTP` request
    being made by `kubectl` :'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有一堆关于从集群缓存获取信息的日志行，但最后一行特别有趣，它包含了`kubectl`正在进行的实际`HTTP`请求：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you now run the `curl GET` command using this URL, all the authentication
    and authorization mechanisms would come into play. But having the `api-server`
    proxy running, we can skip authorization and authentication by executing the call
    on the proxied port (note that `curl` executes the `GET` method by default):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在使用此URL运行`curl GET`命令，所有身份验证和授权机制都会生效。但是通过运行`api-server`代理，我们可以通过在代理端口上执行调用来跳过授权和身份验证（请注意，`curl`默认执行`GET`方法）：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As the output, you will be given the JSON response containing detailed information
    about Pods in your cluster. The API is working, as you can see in the following
    screenshot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输出，您将获得包含有关集群中Pod的详细信息的JSON响应。API正在工作，正如您在以下截图中所看到的：
- en: '![](Image00110.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00110.jpg)'
- en: Deleting a service and deployment
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除服务和部署
- en: 'If you decide it''s time to do some clean up, you may delete the service and
    the deployment by executing the `HTTP DELETE` request, for example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定进行一些清理工作，您可以通过执行`HTTP DELETE`请求来删除服务和部署，例如：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finding out the proper API operation `REST` paths (endpoints) can be very inconvenient
    just by looking at the web documentation or by spying what URLs are being called
    by `kubectl` . There's a better way of doing this; OpenAPI specification of the
    Kubernetes `api-server` . Let's look at how we can get this specification.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看Web文档或窥探`kubectl`调用的URL来找到正确的API操作`REST`路径（端点）可能非常不方便。有一种更好的方法；Kubernetes
    `api-server`的OpenAPI规范。让我们看看如何获取这个规范。
- en: Swagger docs
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger文档
- en: The Kubernetes `api-server` provides the list of available API commands by utilizing
    the OpenAPI specification. The OpenAPI Specification defines a standard, language-agnostic
    interface to `REST` APIs that allows both humans and computers to discover and
    understand the capabilities of the service without access to source code, documentation,
    or through network traffic inspection. It's very convenient to browse the API
    commands catalogue using the SwaggerUI tool that comes with Kubernetes `api-server`
    . You can also execute the `HTTP` commands using SwaggerUI.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的`api-server`利用OpenAPI规范提供了可用API命令的列表。OpenAPI规范定义了一种标准的、与语言无关的REST
    API接口，允许人类和计算机在没有访问源代码、文档或通过网络流量检查的情况下发现和理解服务的能力。使用随Kubernetes`api-server`一起提供的SwaggerUI工具浏览API命令目录非常方便。您也可以使用SwaggerUI执行HTTP命令。
- en: 'Note that the SwaggerUI is not enabled by default if you are running the local
    cluster using Minikube. You will need to enable it during the cluster startup,
    using the following command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您正在使用Minikube运行本地集群，默认情况下未启用SwaggerUI。您需要在集群启动期间使用以下命令启用它：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Having the `api-server` proxy still running using port `8080` , visit the following
    host in your web browser to see the SwaggerUI screen:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在端口`8080`上仍在运行`api-server`代理的情况下，访问以下主机在您的Web浏览器中查看SwaggerUI屏幕：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You will be presented with a list of available API commands, grouped into API
    groups:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个可用API命令的列表，分组为API组：
- en: '![](Image00111.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00111.jpg)'
- en: Expanding each API section will give you all the available endpoints with the
    description of each operation. The SwaggerUI is a great tool to explore an API
    in a clear and readable form.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 展开每个API部分将为您提供所有可用的端点以及每个操作的描述。SwaggerUI是一个探索API的清晰可读形式的绝佳工具。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As you can see, the API exposed by Kubernetes is a very powerful tool in your
    arsenal. Any task that can be performed through the dashboard or `kubectl` client
    is exposed as an API. You can do almost anything with your cluster simply by utilizing
    `HTTP` calls. Kubernetes takes an API-first approach that makes it programmable
    and extensible. As we have seen it is easy to get started with the API. Our service
    and deployment creating examples, may be simple but should give you an idea how
    to experiment with the `api-server` . Using the API you can create and retrieve
    cluster resources not only from the command-line using `kubectl` , but also from
    your own application, build scripts, or continuous delivery pipelines. Only your
    imagination and the sky is the limit, and speaking of the sky, it's time to move
    there and see how Kubernetes can be used in the cloud.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Kubernetes公开的API是您工具库中非常强大的工具。可以通过仪表板或`kubectl`客户端执行的任何任务都作为API公开。您可以通过使用`HTTP`调用简单地执行集群中的几乎任何操作。Kubernetes采用API优先的方法，使其可编程和可扩展。正如我们所看到的，使用API很容易入门。我们的服务和部署创建示例可能很简单，但应该让您了解如何使用`api-server`进行实验。使用API，您不仅可以从命令行使用`kubectl`，还可以从您自己的应用程序、构建脚本或持续交付流水线中创建和检索集群资源。只有您的想象力和天空是极限，说到天空，现在是时候移动到那里，看看Kubernetes如何在云中使用了。
