- en: New Features in C# 7.0
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 7.0中的新功能
- en: 'In this first chapter, we will take a look at the C# 7.0 features by covering
    them in the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过以下配方来查看C# 7.0的功能：
- en: Working with Tuples - getting started
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元组-入门
- en: Working with Tuples - going deeper
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元组-深入了解
- en: Pattern matching
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Out variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出变量
- en: Deconstruction
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解构
- en: Local functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地函数
- en: Improvements to literals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文字的改进
- en: Ref returns and locals
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用返回和本地变量
- en: Generalized async return types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用异步返回类型
- en: Expression bodies for accessors, constructors, and finalizers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问器、构造函数和终结器的表达式主体
- en: throw expressions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出表达式
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: C# 7.0 brings a lot of new functionality to the C# language. If you were left
    wanting more after the release of C# 6.0, then C# 7.0 will not disappoint you
    at all. It focuses on consuming data, simplifying code, and improving performance.
    Mads Torgersen who is the C# Program Manager noted that C# 7.0's biggest feature
    by far is **Tuples**. The other is **pattern matching**. These two features (as
    well as the others) were met with enthusiasm from C# developers worldwide. It
    is, therefore, no guess that developers will immediately start implementing these
    new features introduced in C# 7.0\. It will, therefore, be very beneficial to
    get to grips with what C# 7.0 has to offer and implement the new language features
    in your development projects as soon as possible.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.0为C#语言带来了许多新功能。如果在C# 6.0发布后仍感到不满意，那么C# 7.0绝对不会让您失望。它专注于消耗数据，简化代码和提高性能。C#程序经理Mads
    Torgersen指出，C# 7.0最大的功能是**元组**。另一个是**模式匹配**。这两个功能（以及其他功能）受到了全球C#开发人员的热情欢迎。因此，毫无疑问，开发人员将立即开始实施C#
    7.0引入的这些新功能。因此，尽快了解C# 7.0提供的内容并在开发项目中实施新的语言功能将非常有益。
- en: Throughout this book, I will be using the release candidate of Visual Studio
    2017\. Some features and methods of doing things might change between the time
    of writing and the final release of Visual Studio 2017.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我将使用Visual Studio 2017的发行候选版。在撰写和最终发布Visual Studio 2017之间，某些功能和方法可能会发生变化。
- en: Working with Tuples - getting started
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用元组-入门
- en: I have come across many instances where I wanted to return more than one value
    from a method. As Mads Torgersen pointed out, the existing options available to
    developers are not optimal. C# 7.0 has, therefore, introduced **Tuple types**
    and **Tuple literals** to allow developers an easy way of returning multiple values
    from methods. Developers can also rest easy when creating Tuples. Tuples are structs,
    which are value types. This means that they are created locally and are passed
    by copying the contents. Tuples are also mutable and Tuple elements are public
    mutable fields. I am personally very excited about using Tuples. Let's explore
    Tuples in closer detail in the following recipe.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我遇到了许多情况，我想从一个方法中返回多个值。正如Mads Torgersen指出的，开发人员现有的选项并不理想。因此，C# 7.0引入了**元组类型**和**元组文字**，以便让开发人员轻松地从方法中返回多个值。开发人员在创建元组时也可以放心。元组是结构体，是值类型。这意味着它们是在本地创建的，并且通过复制内容传递。元组也是可变的，元组元素是公共可变字段。我个人对使用元组感到非常兴奋。让我们在下一个配方中更详细地探讨元组。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: Start off by creating a regular console application in Visual Studio 2017\.
    Simply call the project you create cookbook. Before I can jump into using Tuples
    in C# 7.0, I need to add in a NuGet package. Bear in mind that I am using the
    release candidate of Visual Studio. This process might change between now and
    the final release of the product.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在Visual Studio 2017中创建一个常规控制台应用程序。只需将您创建的项目命名为烹饪书。在我开始使用C# 7.0中的元组之前，我需要添加一个NuGet包。请记住，我正在使用Visual
    Studio的发行候选版。这个过程可能会在产品最终发布之前发生变化。
- en: To do this, head on over to Tools, NuGet Package Manager and then, click on
    Manage NuGet Packages for Solution....
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，请转到工具，NuGet包管理器，然后单击“解决方案的NuGet包管理器...”。
- en: '![](img/B06434_01_01-1.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_01-1.png)'
- en: Select the Browse tab and type in ValueTuple in the search box. The System.ValueTuple
    by Microsoft NuGet package should be displayed. Select the cookbook project under
    Manage Packages for Solution and click on the Install button.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择浏览选项卡，然后在搜索框中键入ValueTuple。应显示Microsoft NuGet包中的System.ValueTuple。在“解决方案的管理包”下选择烹饪书项目，然后单击“安装”按钮。
- en: Take note that I am using Visual Studio 2017 RC while writing portions of this
    book. You probably will not need to add `System.ValueTuple` from NuGet some time
    in the future after the final release. Adding `System.ValueTuple` from NuGet might,
    however, remain a requirement. Only time will tell.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在撰写本书的部分内容时使用的是Visual Studio 2017 RC。在最终版本发布后，您可能不需要从NuGet添加`System.ValueTuple`。然而，从NuGet添加`System.ValueTuple`可能仍然是一个要求。只有时间会告诉我们。
- en: '![](img/B06434_01_02.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_02.png)'
- en: Visual Studio will now show you a prompt to review the changes you are about
    to make to your project. Just click on the OK button. Lastly, you will need to
    provide the License Agreement required by Microsoft. Just click on the I Accept
    button. Visual Studio will now start the NuGet package installation. It will show
    you its progress in the Output window.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio现在会显示一个提示，让您审查即将对项目进行的更改。只需单击“确定”按钮。最后，您需要提供Microsoft要求的许可协议。只需单击“我接受”按钮。Visual
    Studio现在将开始安装NuGet包。它将在输出窗口中显示其进度。
- en: '![](img/B06434_01_05-1.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_05-1.png)'
- en: 'After all this is complete, my Visual Studio solution looks as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，我的Visual Studio解决方案如下：
- en: '![](img/B06434_01_06.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_06.png)'
- en: You will now be ready to create your first method that works with Tuples. Let's
    see how to do that next.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将准备好创建与元组一起使用的第一个方法。让我们看看如何做到这一点。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Start off by creating a new class in the `Program.cs` file of your Visual Studio
    console application. You can call your class anything, but for the purposes of
    this book I will simply be calling my class `Chapter1`. Your code should now look
    as follows:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在Visual Studio控制台应用程序的`Program.cs`文件中创建一个新类。你可以随意命名你的类，但出于本书的目的，我将简单地称我的类为`Chapter1`。你的代码现在应该如下所示：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the format we will be using throughout this chapter. Let's assume that
    we want to write a method that needs to calculate the average score for a variable
    number of students. No grade has the same number of students in each class. Therefore,
    we want our method to return the number of students in the class for the calculated
    average score. Change the `static void main` method to contain a list of scores.
    We are also creating a new instance of the `Chapter1` class and calling the method
    `GetAverageAndCount()`, which will be used to return the two values we need.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们将在本章中使用的格式。假设我们想要编写一个方法，需要计算变量数量的学生的平均分数。每个班级的学生人数都不相同。因此，我们希望我们的方法返回用于计算平均分数的班级学生人数。更改`static
    void main`方法以包含分数列表。我们还创建了`Chapter1`类的新实例，并调用`GetAverageAndCount()`方法，该方法将用于返回我们需要的两个值。
- en: I will be hardcoding this for illustration purposes; in reality, though these
    scores can be for any number of students. Be sure to add the values exactly as
    I have in the code listing as I will be illustrating a final gotcha at the end
    of this recipe.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我将为了说明目的而硬编码这些值；但实际上，这些分数可以是任意数量的学生。确保按照我在代码清单中的方式添加值，因为我将在本教程的最后说明一个问题。
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is here that we can use the power of Tuples to declare the `GetAverageAndCount()`
    method in the `Chapter1` class. It accepts an array of integer scores and looks
    as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以利用元组的强大功能来声明`Chapter1`类中的`GetAverageAndCount()`方法。它接受一个整数分数数组，并如下所示：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Pay close attention to the return Tuple type `(int, int)`. We are only returning
    two values from the `GetAverageAndCount()` method, but in reality you can return
    several values if needed. In order to run your code sample, we will create a dummy
    implementation of this method. To do this, just include a Tuple literal that returns
    two zeros.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意返回的元组类型`(int, int)`。我们只从`GetAverageAndCount()`方法返回两个值，但实际上，如果需要，可以返回多个值。为了运行代码示例，我们将创建此方法的虚拟实现。只需包含一个返回两个零的元组文字即可。
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Go back to the `static void Main` method where the Tuple returning method is
    called and write code to consume the return values. Every Tuple you create will
    expose members called `Item1`, `Item2`, `Item3`, and so on. These are used to
    get the values returned from a Tuple returning method.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到调用元组返回方法的`static void Main`方法，并编写代码来使用返回值。你创建的每个元组都将公开名为`Item1`、`Item2`、`Item3`等的成员。这些用于获取从元组返回方法返回的值。
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Be sure to add the following `using` the directive before the namespace.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命名空间之前添加以下`using`指令。
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You will notice that we used `s.Item1` and `s.Item2` to reference the return
    values returned from our `GetAverageAndCount()` method. While this is totally
    legal, it isn''t very descriptive and makes it difficult to infer the usage of
    the variable returned. It basically means that you would have to remember that
    `Item1` is the average value and `Item2` is the count value. Perhaps, it is the
    other way around? Is `Item1` the count and `Item2` the average? It really depends
    on what you are doing inside the `GetAverageAndCount()` method (which can change
    over time). Our Tuple returning method can therefore be enhanced as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到我们使用`s.Item1`和`s.Item2`来引用从`GetAverageAndCount()`方法返回的返回值。虽然这是完全合法的，但它并不是很描述性，使得难以推断变量的使用方式。这基本上意味着你必须记住`Item1`是平均值，`Item2`是计数值。也许，情况正好相反？`Item1`是计数，`Item2`是平均值？这实际上取决于你在`GetAverageAndCount()`方法中所做的事情（这可能随时间而改变）。因此，我们的元组返回方法可以进行如下增强：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The Tuple return type can now declare variable names for its elements. This
    makes it easy for the caller of the `GetAverageAndCount()` method to know which
    value is which. You can still keep on using `s.Item1` and `s.Item2`, but it is
    now much easier to change the calling code in the `static void Main` method accordingly:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，元组返回类型可以为其元素声明变量名。这使得调用`GetAverageAndCount()`方法的调用者可以轻松知道哪个值是哪个。你仍然可以继续使用`s.Item1`和`s.Item2`，但现在更容易相应地更改`static
    void Main`方法中的调用代码：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Changing the interpolated string in `WriteLine`, we see that the usage of the
    values returned by the Tuple is much clearer. You now know that the first value
    is the average and that the second value is the count of the students used to
    calculate the average. Tuples, however, allow developers more flexibility. Remember
    the Tuple literal in the `GetAverageAndCount()` method? We simply added this in
    the dummy implementation as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`WriteLine`中的插值字符串，我们可以看到元组返回的值的使用方式更加清晰。现在你知道第一个值是平均值，第二个值是用于计算平均值的学生数量。然而，元组允许开发人员更灵活地操作。记得`GetAverageAndCount()`方法中的元组文字吗？我们只需在虚拟实现中添加如下内容：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'C# 7.0 also allows developers to add names to Tuple literals. Inside the `GetAverageAndCount()`
    method, change your Tuple literal as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C# 7.0还允许开发人员向元组文字添加名称。在`GetAverageAndCount()`方法中，将元组文字更改如下：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I have just named the first value a name of `ave` (for average) and the second
     `sCount` (for student count). This is some really exciting stuff! After you have
    modified your Tuple literal, your dummy implementation of the `GetAverageAndCount()`
    method should look as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我刚刚给第一个值命名为`ave`（表示平均值），第二个值命名为`sCount`（表示学生人数）。这真是令人兴奋的事情！在修改了元组文字之后，`GetAverageAndCount()`方法的虚拟实现应如下所示：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tuples play really nicely together. As long as the Tuple types match up, you
    do not have to worry that the `ave` and `sCount` names in the Tuple literal don't
    match the `average` and `studentCount` names of the return type.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 元组之间的配合非常好。只要元组类型匹配，你就不必担心元组文字中的“ave”和“sCount”名称与返回类型的“average”和“studentCount”名称不匹配。
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: So far in this recipe, we have seen that Tuples give developers a lot of flexibility
    when you need to return several values from a method. While the dummy implementation
    of `GetAverageAndCount()` simply returns the zero-valued Tuple literal, it gives
    you some idea how Tuples are *wired up*. This recipe is the foundation for the
    next recipe. I encourage you to go through both recipes thoroughly in order to
    gain the full benefit from understanding Tuples and how to use them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本示例中，我们已经看到元组在需要从方法返回多个值时为开发人员提供了很大的灵活性。虽然`GetAverageAndCount()`的虚拟实现只是返回了值为零的元组文字，但它让您对元组是如何*连接*有了一些想法。这个示例是下一个示例的基础。我鼓励您彻底阅读这两个示例，以充分理解元组及其用法。
- en: Working with Tuples - going deeper
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用元组-深入研究
- en: I will now start adding more meat to the dummy implementation of the `GetAverageAndCount()`
    method we created in the previous recipe. If you are new to Tuples, and have not
    worked through the previous recipe, I encourage you to do so first before starting
    to work through this recipe.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将开始为我们在上一个示例中创建的`GetAverageAndCount()`方法的虚拟实现添加更多内容。如果您对元组不熟悉，并且还没有完成上一个示例，请先完成上一个示例，然后再开始本示例的工作。
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to have completed the code steps in the recipe *Working with Tuples
    - getting started,* in order to work through this recipe. Ensure that you have
    added the required NuGet package as specified in the previous recipe.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要完成上一个示例*使用元组-入门*中的代码步骤，才能继续进行本示例的工作。确保您已添加了上一个示例中指定的所需NuGet软件包。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's take a look at the calling code again. We can further simplify the code
    in the `static void Main` method by getting rid of the `var s`. When we called
    the `GetAverageAndCount()` method, we returned the Tuple into `var s`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次看一下调用代码。通过摆脱`var s`，我们可以进一步简化`static void Main`方法中的代码。当我们调用`GetAverageAndCount()`方法时，我们将元组返回到`var
    s`中。
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We do not have to do this. C# 7.0 allows us to immediately split the Tuple
    into its respective parts as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不必这样做。C# 7.0允许我们立即将元组分割为其各自的部分，如下所示：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now consume the values returned by the Tuple directly as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以直接使用元组返回的值：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Before we implement the `GetAverageAndCount()` method, make sure that your
    `static void Main` method looks as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现`GetAverageAndCount()`方法之前，请确保您的`static void Main`方法如下所示：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Secondly, ensure that the `GetAverageAndCount()` method''s dummy implementation
    looks as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，确保`GetAverageAndCount()`方法的虚拟实现如下所示：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Go ahead and run your console application. You will see that the two values,
    `average` and `studentCount` are returned from our dummy implementation of `GetAverageAndCount()`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续运行控制台应用程序。您将看到`average`和`studentCount`两个值从我们的`GetAverageAndCount()`虚拟实现中返回。
- en: '![](img/B06434_01_07.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_07.png)'
- en: 'The values are obviously still zero because we have not defined any logic inside
    the method. We will do this next. Before we write the implementation, make sure
    that you have added the following `using` statement:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数值显然仍然为零，因为我们还没有在方法内定义任何逻辑。我们接下来会这样做。在编写实现之前，请确保已添加以下`using`语句：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Because we are using an array of integers for the variable `scores`, we can
    easily return the results we need. LINQ allows us to get the sum of the student
    scores contained in the `scores` array, simply by writing `scores.Sum()`. We can
    also easily get the count of the student scores from the `scores` array by writing
    `scores.Count()`. The average, therefore, would logically be the sum of the scores
    divided by the count of the student scores `(scores.Sum()/scores.Count())`. We
    then put the values into our `returnTuple` literal as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们在变量`scores`上使用了整数数组，所以我们可以轻松地返回所需的结果。通过编写`scores.Sum()`，LINQ允许我们获得`scores`数组中包含的学生成绩的总和。我们还可以通过编写`scores.Count()`轻松地获得`scores`数组中学生成绩的计数。因此，平均值逻辑上应该是分数之和除以学生成绩的计数`(scores.Sum()/scores.Count())`。然后，我们将值放入我们的`returnTuple`文字中，如下所示：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run your console application to see the result displayed as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序以查看以下显示的结果：
- en: '![](img/B06434_01_08.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_08.png)'
- en: 'We can see that the class average isn''t too great, but that is of little importance
    to our code. Another piece of code that isn''t too great is this line:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到班级平均分并不太好，但这对我们的代码来说并不重要。另一行代码也不太好的是这一行：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It is clunky and doesn''t read very nicely. Let''s simplify this a bit. Remember
    that I mentioned previously that Tuples play nicely together as long as their
    types match? This means that we can do this:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这有点笨拙，读起来不太顺畅。让我们简化一下。记住我之前提到过，只要它们的类型匹配，元组就可以很好地配合使用？这意味着我们可以这样做：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run your console application again and notice that the result stays the same:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行控制台应用程序，注意结果保持不变：
- en: '![](img/B06434_01_08.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_08.png)'
- en: So why did we give the Tuple literal names to begin with? Well, it allows you
    to reference them easily within your `GetAverageAndCount()` method. It is also
    really very useful when using a `foreach` loop in your method. Consider the following
    scenario. In addition to returning the count and average of the student scores,
    we need to return an additional Boolean value if the class average is below a
    certain threshold. For this example, we will be making use of an extension method
    called `CheckIfBelowAverage()` and it will take a `threshold` value as an integer
    parameter. Start off by creating a new static class called `ExtensionMethods`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那么为什么一开始要给元组文字名称呢？好吧，这样可以让您在`GetAverageAndCount()`方法中轻松引用它们。在方法中使用`foreach`循环时，这也非常有用。考虑以下情况。除了返回学生成绩的计数和平均值之外，我们还需要在班级平均分低于某个阈值时返回一个额外的布尔值。在本示例中，我们将使用一个名为`CheckIfBelowAverage()`的扩展方法，并将一个整数参数作为`threshold`值。首先创建一个名为`ExtensionMethods`的新静态类。
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Inside the `static` class, create a new method called `CheckIfBelowAverage()`
    and pass it an integer value called `threshold`. The implementation of this extension
    method is pretty straightforward, so I will not go into much detail here.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`static`类中，创建一个名为`CheckIfBelowAverage()`的新方法，并传递一个名为`threshold`的整数值。这个扩展方法的实现非常简单，所以我不会在这里详细介绍。
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the `Chapter1` class, overload the `GetAverageAndCount()` method by changing
    its signature and passing a value for the threshold that needs to be applied.
    You will remember that I mentioned that a Tuple return type method can return
    several values, not just two. In this example, we are returning a third value
    called `belowAverage` that will indicate if the calculated class average is below
    the threshold value we pass to it.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter1`类中，通过更改其签名并传递需要应用的阈值的值，重载`GetAverageAndCount()`方法。您会记得我提到过元组返回类型的方法可以返回多个值，不仅仅是两个。在这个例子中，我们返回了一个名为`belowAverage`的第三个值，它将指示计算出的班级平均值是否低于我们传递给它的阈值值。
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Modify the Tuple literal, adding it to `subAve` ,and default it to `true`, because
    a class average of zero will logically be below any threshold value we pass to
    it.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改元组文字，将其添加到`subAve`，并将其默认为`true`，因为零的班级平均值在逻辑上低于我们传递给它的任何阈值值。
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can now call the extension method `CheckIfBelowAverage()` on the `returnTuple.ave`
    value we defined in our Tuple literal and pass through it the `threshold` variable.
    Just how useful giving the Tuple literal logical names becomes evident when we
    use it to call the extension method.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在我们的元组文字值上调用扩展方法`CheckIfBelowAverage()`，并通过`threshold`变量传递它。当我们用它来调用扩展方法时，给元组文字起逻辑名称变得非常有用。
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Your completed `GetAverageAndCount()` method will now look as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的完成的`GetAverageAndCount()`方法现在应该如下所示：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Modify your calling code to make use of the overloaded `GetAverageAndCount()`
    method as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改您的调用代码，以使用重载的`GetAverageAndCount()`方法如下所示：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Lastly, modify the interpolated string to read as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，修改插值字符串如下所示：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The completed code in your `static void Main` method should now look as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的`static void Main`方法中的完成代码现在应该如下所示：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Run your console application to view the result.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的控制台应用程序以查看结果。
- en: '![](img/B06434_01_09.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_09.png)'
- en: To test that the ternary operator `?` is working correctly inside the interpolated
    string, modify your threshold value to be lower than the average returned.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试三元运算符`?`在插值字符串中是否正确工作，将您的阈值值修改为低于返回的平均值。
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Running your console application a second time will result in a passing average
    class score.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行您的控制台应用程序将得到一个通过的平均班级分数。
- en: '![](img/B06434_01_10.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_10.png)'
- en: 'Finally, there is one glaring problem that I need to highlight with this recipe.
    It is one that I am sure you have picked up on already. If not, don''t worry.
    It is a bit of a sneaky one. This is the gotcha I was referring to at the start
    of this recipe and I intentionally wanted to include it to illustrate the bug
    in the code. Our array of student scores is defined as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我需要强调这个食谱中存在一个明显的问题。我相信你已经注意到了。如果没有，不要担心。这有点狡猾。这是我在这个食谱开始时提到的陷阱，我故意想要包括它来说明代码中的错误。我们的学生成绩数组定义如下：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The sum of these equals to 400 and because there are only 8 scores, the value
    will work out correctly because it divides up to a whole number *(400 / 8 = 50)*.
    But what would happen if we had another student score in there? Let''s take a
    look. Modify your scores array as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些总和等于400，因为只有8个分数，所以值将正确计算，因为它分成一个整数 *(400 / 8 = 50)*。但是如果我们在其中加入另一个学生的分数会发生什么呢？让我们来看看。修改您的分数数组如下：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run your console application again and look at the result.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行您的控制台应用程序并查看结果。
- en: '![](img/B06434_01_11.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_11.png)'
- en: The problem here is that the average is incorrect. It should be 49.89\. We know
    that we want a double (unless your application of this is intended to return an
    integer). We, therefore, need to pay attention to casting the values correctly
    in the return type and the Tuple literal. We also need to handle this in the extension
    method `CheckIfBelowAverage()`. Start off by changing the extension method signature
    as follows to act on a double.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题在于平均值是不正确的。它应该是49.89。我们知道我们想要一个double（除非您的应用程序意图返回一个整数）。因此，我们需要注意在返回类型和元组文字中正确地转换值。我们还需要在扩展方法`CheckIfBelowAverage()`中处理这个问题。首先，通过以下方式更改扩展方法签名以作用于double。
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then we need to change the data type of the `average` variable in the Tuple
    method return type as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要将元组方法返回类型中的`average`变量的数据类型更改为如下：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, modify the Tuple literal so `ave` is a double by using `ave: 0D`.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后，通过使用`ave: 0D`，修改元组文字，使`ave`成为一个double。'
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Cast the average calculation to a `double`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将平均值计算转换为`double`。
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the following `using` statement to your application:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向您的应用程序添加以下`using`语句：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Lastly, use the `Round` method to format the `average` variable in the interpolated
    string to two decimals.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在插值字符串中使用`Round`方法将`average`变量格式化为两位小数。
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If everything is done correctly, your `GetAverageAndCount()` method should
    look as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切都做得正确，您的`GetAverageAndCount()`方法应该如下所示：
- en: '[PRE38]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Your calling code should also look as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的调用代码也应该如下所示：
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Run the console application to see the correctly rounded average for the student
    scores.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，以查看学生成绩的正确平均值。
- en: '![](img/B06434_01_12.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_12.png)'
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Tuples are structs, and therefore value types that are created locally. You,
    therefore, do not have to worry about using and assigning Tuples on-the-fly or
    that it creating a lot of allocations. Their contents are merely copied when passed.
    Tuples are mutable and the elements are publicly scoped mutable fields. Using
    the code example in this recipe, I can, therefore, do the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是结构体，因此是在本地创建的值类型。因此，您不必担心在使用和分配元组时产生大量分配。它们的内容在传递时仅仅是复制。元组是可变的，元素是公开范围的可变字段。使用本配方中的代码示例，因此我可以做以下事情：
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: C# 7.0 is allowing me to first update the average value (shifting the average
    up) and then decrementing the count field. Tuples are a very powerful feature
    of C# 7.0, and it will be of great benefit to many developers when implemented
    it correctly.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.0允许我首先更新平均值（将平均值上移），然后递减计数字段。元组是C# 7.0的一个非常强大的特性，当正确实现时，对许多开发人员将大有裨益。
- en: Pattern matching
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: 'C# 7.0 introduces an aspect common to functional programming languages with
    pattern matching. This new kind of construct can test values in different ways.
    To accomplish this, two language constructs in C# 7.0 have been enhanced to take
    advantage of patterns. These are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.0引入了一种与函数式编程语言常见的方面相同的模式匹配。这种新类型的结构可以以不同的方式测试值。为了实现这一点，C# 7.0中的两种语言构造已经得到增强，以利用模式。这些如下：
- en: The `is` expression
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is`表达式'
- en: The `case` clause in `switch` statements
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch`语句中的`case`子句'
- en: With regard to the is expression, developers can now have a pattern on the right
    instead of just a type. When it comes to `switch` statements, the `case` clause
    can now match on patterns. The `switch` statement is no longer limited to primitive
    types and can switch on anything. Let's start by looking at the `is` expression.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`is`表达式，开发人员现在可以在右侧使用模式，而不仅仅是类型。在`switch`语句中，`case`子句现在可以匹配模式。`switch`语句不再局限于原始类型，可以在任何东西上进行切换。让我们首先看一下`is`表达式。
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To illustrate the concept of pattern matching, assume the following scenario.
    We have two object types called `Student` and `Professor`. We want to minimize
    code, so we want to create a single method to output the data from the object
    passed to it. This object can be a `Student` or a `Professor` object. The method
    needs to figure out which object it is working with and act accordingly. But first,
    we need to do a few things inside our console application to set things up:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明模式匹配的概念，假设以下情景。我们有两种对象类型，称为`Student`和`Professor`。我们想要最小化代码，所以我们想要创建一个单一的方法来输出传递给它的对象的数据。这个对象可以是`Student`或`Professor`对象。该方法需要弄清楚它正在处理哪个对象，并相应地采取行动。但首先，我们需要在控制台应用程序中做一些事情来设置好一切：
- en: Ensure that you have added the following `using` statement.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已添加以下`using`语句。
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You now need to create two new classes called `Student` and `Professor`. The
    code for the `Student` class needs to look as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要创建两个名为`Student`和`Professor`的新类。`Student`类的代码需要如下所示：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, the code for the `Professor` class needs to look as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`Professor`类的代码需要如下所示：
- en: '[PRE43]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: To understand where we are going with pattern matching, we first need to understand
    where we have come from. I will start the next section off by showing you how
    developers might have written this code before C# 7.0.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解我们使用模式匹配的目的，我们首先需要了解我们来自何处。我将在下一节开始时向您展示开发人员在C# 7.0之前可能如何编写此代码。
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the `Chapter1` class, create a new method called `OutputInformation()` that
    takes a person object as parameter.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter1`类中，创建一个名为`OutputInformation()`的新方法，该方法以一个人对象作为参数。
- en: '[PRE44]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Inside this method, we would need to check what type of object is passed to
    it. Traditionally, we would need to do the following:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法中，我们需要检查传递给它的对象的类型。传统上，我们需要做以下事情：
- en: '[PRE45]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We have two `if` statements. We are expecting either a `Student` object or
    a `Professor` object. The complete `OutputInformation()` method should look as
    follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有两个`if`语句。我们期望的是`Student`对象或`Professor`对象。完整的`OutputInformation()`方法应如下所示：
- en: '[PRE46]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Calling this method from the `static void Main` is easy enough. The objects
    are similar, but differ in the list they contain. A `Student` object exposes a
    list of course codes, while a `Professor` exposes a list of subjects taught to
    students.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`static void Main`中调用这个方法非常容易。这两个对象是相似的，但它们包含的列表不同。`Student`对象公开了一个课程代码列表，而`Professor`公开了一个教给学生的科目列表。
- en: '[PRE47]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Run the console application and see the `OutputInformation()` method in action.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，看看`OutputInformation()`方法的运行情况。
- en: '![](img/B06434_01_13.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_13.png)'
- en: 'While the information we see in the console application is what we expect,
    we can simplify the code in the `OutputInformation()` method much more with pattern
    matching. To do this, modify the code as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然我们在控制台应用程序中看到的信息是我们所期望的，但我们可以通过模式匹配更简化`OutputInformation()`方法中的代码。为此，请修改代码如下：
- en: '[PRE48]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The first `if` expression checks to see if the object `person` is of type `Student`.
    If so, it stores that value in the `student` variable. The same logic is true
    for the second `if` expression. If true, the value of `person` is stored inside
    the variable `prof`. For code execution to reach the code between the curly braces
    of each `if` expression, the condition had to evaluate to true. We can, therefore,
    dispense with the cast of the `person` object to a `Student` or `Professor` type,
    and just use the `student` or `prof` variable directly, like so:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个`if`表达式检查对象`person`是否是`Student`类型。如果是，它将该值存储在`student`变量中。对于第二个`if`表达式也是如此。如果为真，则将`person`的值存储在`prof`变量中。为了使代码执行到每个`if`表达式的大括号之间的代码，条件必须评估为真。因此，我们可以省去将`person`对象转换为`Student`或`Professor`类型的转换，直接使用`student`或`prof`变量，如下所示：
- en: '[PRE49]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Running the console application again, you will see that the output is exactly
    the same as before. We have, however, written better code that uses type pattern
    matching to determine the correct output to display.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行控制台应用程序，您将看到输出与以前完全相同。但是，我们编写了更好的代码，使用类型模式匹配来确定要显示的正确输出。
- en: '![](img/B06434_01_13.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_13.png)'
- en: 'Patterns, however, don''t stop there. You can also use them in constant patterns,
    which are the simplest type of pattern to use. Let''s take a look at the check
    for the constant `null`. With pattern matching we can enhance our `OutputInformation()`
    method as follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，模式并不止于此。您还可以在常量模式中使用它们，这是最简单的模式类型。让我们看看对常量`null`的检查。通过模式匹配，我们可以改进我们的`OutputInformation()`方法如下：
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Change the code that is calling the `OutputInformation()` method and set it
    to `null`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改调用`OutputInformation()`方法的代码并将其设置为`null`。
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Run your console application and see the message displayed.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的控制台应用程序并查看显示的消息。
- en: '![](img/B06434_01_14.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_14.png)'
- en: It is good practice to use the `nameof` keyword here. If the variable name `person`
    ever has to change, the corresponding output will be changed also.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用`nameof`关键字是一个好习惯。如果变量名`person`需要更改，相应的输出也将被更改。
- en: Lastly, `switch` statements in C# 7.0 have been improved to make use of pattern
    matching. C# 7.0 allows us to switch on anything, not just primitive types and
    strings. The `case` clauses now make use of patterns, which is really exciting.
    Let's have a look at how to implement this in the following code examples. We
    will keep using the `Student` and `Professor` types to illustrate the concept
    of pattern matching in `switch` statements. Modify the `OutputInformation()` method
    and include the boilerplate `switch` statement as follows. The `switch` statement
    still has defaults, but it can now do so much more.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，C# 7.0中的`switch`语句已经改进，以利用模式匹配。C# 7.0允许我们切换到任何内容，而不仅仅是基本类型和字符串。`case`子句现在使用模式，这真的很令人兴奋。让我们看看如何在以下代码示例中实现这一点。我们将继续使用`Student`和`Professor`类型来说明`switch`语句中模式匹配的概念。修改`OutputInformation()`方法并包括如下的样板`switch`语句。`switch`语句仍然具有默认值，但现在可以做更多事情。
- en: '[PRE52]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can expand the `case` statement to check for the `Professor` type. If it
    matches an object to the `Professor` type, it can act on that object and use it
    as a `Professor` type in the body of the `case` statement. This means we can call
    the `Professor`-specific `TeachesSubjects` property. We do it like this:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以扩展`case`语句以检查`Professor`类型。如果它将对象匹配到`Professor`类型，它可以在`case`语句的主体中对该对象进行操作并将其用作`Professor`类型。这意味着我们可以调用`Professor`特定的`TeachesSubjects`属性。我们可以这样做：
- en: '[PRE53]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can also do the same for `Student` types. Change the code of the `switch`
    as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以对`Student`类型执行相同的操作。更改`switch`的代码如下：
- en: '[PRE54]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'One final (and great) feature of `case` statements remains to be illustrated.
    We can also implement a `when` condition, similar to what we saw in C# 6.0 with
    exception filters. The `when` condition simply evaluates to a Boolean and further
    filters the input that it triggers on. To see this in action, change the `switch`
    accordingly:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`case`语句的最后一个（也是很棒的）特性尚待说明。我们还可以实现一个`when`条件，类似于我们在C# 6.0中看到的异常过滤器。`when`条件只是评估为布尔值，并进一步过滤它触发的输入。要看到这一点的效果，请相应地更改`switch`：'
- en: '[PRE55]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Lastly, to come full circle and check for null values, we can modify our `switch`
    statement to cater for those too. The completed `switch` statement is, therefore,
    as follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了全面检查空值，我们可以修改我们的`switch`语句以适应这些情况。因此，完成的`switch`语句如下所示：
- en: '[PRE56]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Running the console application again, you will see that the first case statement
    containing the `when` condition is triggered for the `Student` type.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行控制台应用程序，您将看到第一个包含`when`条件的`case`语句对`Student`类型触发。
- en: '![](img/B06434_01_15.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_15.png)'
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: With pattern matching, we saw that patterns are used to test whether a value
    is of a certain type.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过模式匹配，我们看到模式用于测试值是否属于某种类型。
- en: You will also hear some developers say that they test whether the value has
    a certain *shape*.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会听到一些开发人员说他们测试值是否具有特定的*形状*。
- en: When we find a match we can get to the information specific to that type (or
    shape). We saw this in the code where we accessed the `CourseCodes` property,
    which was specific to the `Student` type and the  `TeachesSubjects` property,
    which was specific to the `Professor` type.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们找到匹配时，我们可以获取特定于该类型（或形状）的信息。我们在访问特定于`Student`类型的`CourseCodes`属性的代码中看到了这一点，以及特定于`Professor`类型的`TeachesSubjects`属性。
- en: Lastly, you now need to pay careful attention to the order of your `case` statements,
    which now matters. The `case` statement that uses the `when` clause is more specific
    than the statement that simply checks for a `Student` type. This means that the
    `when` case needs to happen before the `Student` case because both of these cases
    are of type `Student`. If the `Student` case happens before the `when` clause,
    it will never trigger the `switch` for `Students` that have course code 203.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您现在需要仔细注意您的`case`语句的顺序，这很重要。使用`when`子句的`case`语句比仅检查`Student`类型的语句更具体。这意味着`when`情况需要在`Student`情况之前发生，因为这两种情况都是`Student`类型。如果`Student`情况发生在`when`子句之前，它将永远不会触发具有课程代码203的`Students`的`switch`。
- en: Another important thing to remember is that the `default` clause will always
    be evaluated last, irrespective of where it appears in the `switch` statement.
    It is, therefore, good practice to write it as the last clause in a `switch` statement.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事情要记住的是，`default`子句将始终最后进行评估，无论它出现在`switch`语句的何处。因此，在`switch`语句中将其写为最后一个子句是一个很好的做法。
- en: Out variables
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出变量
- en: C# 7.0 has taken a fresh look at `out` variables. This is a small change, but
    really one that improves the readability and flow of the code. Previously, we
    first had to declare a variable to use as an out parameter in a method. In C#
    7.0 we no longer need to do that.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.0对`out`变量进行了重新审视。这是一个小改变，但确实改善了代码的可读性和流畅性。以前，我们首先必须声明一个变量作为方法中的out参数。在C#
    7.0中，我们不再需要这样做。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using an often used method to test if a value is of a specific type.
    Yes, you guessed it, we're going to be using `TryParse`. I can already hear some
    of you groan (or is it just me?). Using `TryParse `is (for me anyway) such a bittersweet
    thing to do. It's great being able to try and parse something to test if it is
    valid, but the use of the `out` variable was never as neat and tidy as I would
    have liked. If you are not familiar with the `TryParse` method, it is a method
    that tests to see if a value parses to a specific type. If it does, `TryParse`
    will return a Boolean value of `true` ; otherwise, it will return `false`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个经常使用的方法来测试值是否为特定类型。是的，你猜对了，我们将使用`TryParse`。我已经能听到一些人抱怨了（还是只有我？）。对我来说，使用`TryParse`是一件苦乐参半的事情。能够尝试解析一些东西以测试其是否有效是很好的，但是`out`变量的使用从来没有像我想象的那样整洁。如果您不熟悉`TryParse`方法，它是一个测试值是否解析为特定类型的方法。如果是，`TryParse`将返回一个布尔值`true`；否则，它将返回`false`。
- en: How to do it...
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The following code example will illustrate how we used to have to use `TryParse`
    to check if a string value is a valid integer. You will notice that we had to
    declare the integer variable `intVal`, which was used as the `out` variable. The
    `intVal` variable would just sort of hang there in mid air, usually not initialized
    and waiting to be used in  `TryParse`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码示例将说明我们以前如何使用`TryParse`来检查字符串值是否为有效整数。您会注意到，我们不得不声明整数变量`intVal`，它被用作`out`变量。`intVal`变量通常悬空在那里，通常没有初始化，等待在`TryParse`中使用。
- en: '[PRE57]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In C# 7.0 this has been simplified, as can be seen in the following code example.
    We can now declare the `out` variable at the point where it is passed as an out
    parameter, like so:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C# 7.0中，这已经简化了，如下面的代码示例所示。我们现在可以在将其作为out参数传递的地方声明`out`变量，就像这样：
- en: '[PRE58]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is a small change, but a very nice one. Run the console application and
    check the output displayed.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个小改变，但非常好。运行控制台应用程序并检查显示的输出。
- en: '![](img/B06434_01_16.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_16.png)'
- en: 'As we are declaring the `out` variable as an argument to the `out` parameter,
    the compiler will be able to infer what the type should be. This means that we
    can also use the `var` keyword, like this:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们将`out`变量声明为`out`参数的参数时，编译器将能够推断出类型应该是什么。这意味着我们也可以使用`var`关键字，就像这样：
- en: '[PRE59]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The changes that C# 7.0 has made to `out` variables are not major. They are,
    however, a major convenience to those developers who use it often. So far in this
    chapter, we have seen the use of Tuples, pattern matching, and `out` variables.
    We can easily combine some of what we have learned to create something truly unique.
    Consider the use of extension methods, Tuples, and `out` variables. We can easily
    create an extension method called `ToInt()` that has the following implementation:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.0对`out`变量所做的更改并不重大。然而，对于经常使用它的开发人员来说，这是一个很大的便利。到目前为止，在本章中，我们已经看到了元组的使用，模式匹配和`out`变量。我们可以轻松地将我们学到的一些内容结合起来，创造出一些真正独特的东西。考虑使用扩展方法，元组和`out`变量。我们可以轻松地创建一个名为`ToInt()`的扩展方法，其实现如下：
- en: '[PRE60]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We create a Tuple literal that will be returned in the event of the `TryParse`
    returning false. If the `TryParse` is `true`, I set the `t.toIntegerValue` and
    `t.isInt` values. The code that calls the extension method looks as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个Tuple文字，如果`TryParse`返回false，它将被返回。如果`TryParse`为`true`，我设置了`t.toIntegerValue`和`t.isInt`值。调用扩展方法的代码如下：
- en: '[PRE61]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: When you run your console application, you will see that the output is exactly
    the same as before. This just illustrates the power of the new features in C#
    7.0 when combined with each other. Throw some pattern matching into the mix, and
    we will have a very potent extension method. I'll leave you folks to play around
    with this some more. There is a lot to discover.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行控制台应用程序时，您会发现输出与以前完全相同。这只是说明了C# 7.0中新功能与彼此结合的强大力量。再加上一些模式匹配，我们将拥有一个非常有效的扩展方法。我会让你们继续玩耍。有很多东西等待你们去发现。
- en: Deconstruction
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构
- en: Tuples can be consumed using a deconstruction declaration. This simply splits
    a Tuple into its individual parts and assigns these parts to new variables. This
    is called **deconstruction**, and it is not only reserved for Tuples.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 元组可以使用解构声明进行消耗。这只是将元组拆分为其各个部分，并将这些部分分配给新变量。这称为**解构**，不仅适用于元组。
- en: Getting ready
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Remember when we used Tuples at the beginning of this chapter? Well we were
    using code similar to the following to get the values returned by the Tuple literal.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在本章开头使用元组吗？嗯，我们使用类似以下代码来获取元组文字返回的值。
- en: '[PRE62]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This was deconstructing the parts of the Tuple into the new variables `average`
    and `studentCount`. I do not, however, want to take a look at Tuples again. What
    I want to do is show how you can implement a deconstruction declaration on any
    type. To do this, all that we need to do is ensure that  the type has a deconstructor
    method. We will modify our existing `Student` class to add a deconstructor.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将元组的部分解构为新变量`average`和`studentCount`。然而，我不想再看一下元组。我想做的是展示如何在任何类型上实现解构声明。为此，我们需要确保该类型具有解构方法。我们将修改现有的`Student`类以添加解构方法。
- en: How to do it...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'If you created the `Student` class earlier, you should have something similar
    to this in your code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您之前创建了`Student`类，您的代码中应该有类似于以下内容：
- en: '[PRE63]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: To create a deconstructor, add a `Deconstruct` method to your `Student` class.
    You will notice that this is a `void` method that takes two `out` parameters (in
    this instance). We then just assign the values of `Name` and `LastName` to the
    `out` parameters.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个析构函数，需要在`Student`类中添加一个`Deconstruct`方法。您会注意到这是一个`void`方法，它带有两个`out`参数（在这种情况下）。然后我们只需将`Name`和`LastName`的值分配给`out`参数。
- en: If we wanted to deconstruct more values in the `Student` class, we would pass
    in more `out` parameters, one for each value we wanted to deconstruct.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在`Student`类中解构更多的值，我们将传入更多的`out`参数，每个值都要解构一个参数。
- en: '[PRE64]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Your modified `Student` class should now look as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您修改后的`Student`类现在应该如下所示：
- en: '[PRE65]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Consuming our `Student` class (just like we did with Tuples) can now be accomplished
    as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以像使用元组一样使用我们的`Student`类了：
- en: '[PRE66]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Running the Console Application will display the deconstructed values returned
    from the `Student` class.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序将显示从`Student`类返回的解构值。
- en: '![](img/B06434_01_17.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_17.png)'
- en: 'Deconstructors can just as easily be used in extension methods. This is quite
    a nice way to extend the existing type to include a deconstruction declaration.
    To implement this, we need to remove the deconstructor from our `Student` class.
    You can just comment it out for now, but essentially this is what we are after:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 析构函数同样可以轻松地用于扩展方法中。这是扩展现有类型以包括析构声明的一种不错的方式。要实现这一点，我们需要从`Student`类中删除析构函数。您现在可以将其注释掉，但本质上这就是我们要做的：
- en: '[PRE67]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `Student` class now does not contain a deconstructor. Head on over to the
    extension methods class and add the following extension method:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Student`类现在不包含析构函数。转到扩展方法类并添加以下扩展方法：'
- en: '[PRE68]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The extension method acts on a `Student` type only. It follows the same basic
    implementation of the deconstructor created earlier in the `Student` class itself.
    Running the console application again, you will see the same result as before.
    The only difference is that the code is now using the extension method to deconstruct
    values in the `Student` class.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展方法仅对`Student`类型起作用。它遵循了先前在`Student`类本身中创建的析构函数的基本实现。再次运行控制台应用程序，您将看到与以前相同的结果。唯一的区别是现在代码使用扩展方法来解构`Student`类中的值。
- en: '![](img/B06434_01_17.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_17.png)'
- en: How it works...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In the code example, we set the student name and last name to specific values.
    This was just to illustrate the use of deconstruction. A more likely scenario
    would be to pass a student number to the `Student` class (in the constructor perhaps),
    as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例中，我们将学生名和姓氏设置为特定值。这只是为了说明解构的使用。更可能的情况是将学生编号传递给`Student`类（可能是在构造函数中），如下所示：
- en: '[PRE69]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The implementation within the `Student` class would then perform a database
    lookup using the student number passed through in the constructor. This will then
    return the student details. A more likely implementation of the `Student` class
    would probably look as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`Student`类中的实现将使用通过构造函数传递的学生编号进行数据库查找。然后将返回学生详细信息。`Student`类的更可能的实现可能如下所示：'
- en: '[PRE70]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: You will notice that the `GetStudentDetails()` method is just a dummy implementation.
    This is where the database lookup will start and the values will be returned from
    here. The code that calls the `Student` class now makes more sense. We call the
    `Student` class, pass it a student number, and deconstruct it to find the student's
    first name and surname.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到`GetStudentDetails()`方法只是一个虚拟实现。这是数据库查找将开始并且值将从这里返回的地方。现在调用`Student`类的代码更有意义。我们调用`Student`类，传递给它一个学生编号，并对其进行解构以找到学生的名字和姓氏。
- en: '[PRE71]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Local functions
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地函数
- en: The use of local functions might seem a little strange at first. They are in
    fact quite often used in most functional languages. C# 7.0 now allows us to do
    the same. So what exactly is a local function? Well, think of it as a helper method
    for a specific method. This helper method only really makes sense when used from
    the specific method and will not be useful for other methods in your application.
    It, therefore, makes sense to use it *inside* your existing method. Some might
    think that an extension method might be just as well suited, but extension methods
    should really be used to extend the functionality of many other methods. The usefulness
    of local functions will become evident in the following code example.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始使用本地函数可能会有点奇怪。实际上，在大多数函数式语言中经常使用它们。C# 7.0现在允许我们做同样的事情。那么什么是本地函数呢？嗯，把它想象成一个特定方法的辅助方法。这个辅助方法只有在从特定方法中使用时才真正有意义，并且对于应用程序中的其他方法来说并不有用。因此，在现有方法*内部*使用它是有意义的。有些人可能认为扩展方法可能同样适用，但扩展方法实际上应该用于扩展许多其他方法的功能。本地函数的用处将在以下代码示例中变得明显。
- en: Getting ready
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: There is nothing you need to specifically get ready or set up beforehand to
    be able to use local functions. To illustrate the use of local functions, I will
    create a method that calculates the floor space of a building after the common
    area space has been subtracted from the total floor space.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要特别准备或预先设置任何内容来使用本地函数。为了说明本地函数的使用，我将创建一个方法，该方法在从总楼层面积中减去公共区域空间后计算建筑的楼层面积。
- en: How to do it...
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a method called `GetShopfloorSpace()` that takes three parameters: for
    the common area space, the building width, and the building length.'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`GetShopfloorSpace()`的方法，它接受三个参数：公共区域空间，建筑宽度和建筑长度。
- en: '[PRE72]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We are returning a `Building` type, so create a class called `Building` that
    has a single property called `TotalShopFloorSpace`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在返回一个`Building`类型，因此创建一个名为`Building`的类，它有一个名为`TotalShopFloorSpace`的属性。
- en: '[PRE73]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Our local function will simply take the `width` and `length` of the building
    to calculate the total floor area and then subtract the `common` area from that
    to get the usable floor space for shops. The local function will look as follows:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的本地函数将简单地获取建筑物的`宽度`和`长度`来计算总楼层面积，然后从中减去`公共`区域，以获得商店可用的楼层空间。本地函数将如下所示：
- en: '[PRE74]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This is where it gets interesting. Add the local function inside the `GetShopfloorSpace()`
    method and add the rest of the code in the following code example:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是有趣的地方。在`GetShopfloorSpace()`方法内添加本地函数，并在以下代码示例中添加其余代码：
- en: '[PRE75]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In the calling code, inside the `static void Main` method, call the method
    as follows:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用代码中，在`static void Main`方法内，调用方法如下：
- en: '[PRE76]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Run your console application and see the output displayed as follows:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '运行控制台应用程序并查看输出如下显示： '
- en: '![](img/B06434_01_18.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_18.png)'
- en: How it works...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The beauty of local functions is that you can call them from anywhere inside
    your method. To illustrate this, add the following line of code just before the
    `return` statement of the `GetShopfloorSpace()` method. This essentially overrides
    whatever we passed to the method initially.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 本地函数的美妙之处在于您可以从方法的任何地方调用它们。为了说明这一点，在`GetShopfloorSpace()`方法的`return`语句之前添加以下代码行。这实质上覆盖了我们最初传递给方法的任何内容。
- en: '[PRE77]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The modified method will now look like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的方法现在看起来是这样的：
- en: '[PRE78]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Run your console application again. This time you will see that the values are
    totally different. The second call to the local function overrode the first call
    and illustrates that the local function can be called throughout the method containing
    it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行控制台应用程序。这次您将看到值完全不同。对本地函数的第二次调用覆盖了第一次调用，并说明本地函数可以在包含它的方法中随时调用。
- en: '![](img/B06434_01_19.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_19.png)'
- en: I can think of a few instances where I might have been able to use this in the
    past. It isn't something I think that I'll use often. It is however a very nice
    addition to the C# language and great that it is available to developers.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以想到一些以前可能可以使用这个的情况。我不认为我会经常使用它。但是这确实是C#语言的一个非常好的补充，并且对开发人员可用。
- en: Improvements to literals
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文字的改进
- en: This is another minor improvement to the C# language, but one that I'm sure
    will often be used by developers. One of my first jobs as a young man was working
    for a logistics company. These folks used to supply parts to Volkswagen, and the
    most critical parts were flown in by air freight from Germany or elsewhere. I
    will never forget the 9- and 12-digit shipping numbers the logistics people used
    to throw around in casual conversation. I wondered how they were able to remember
    literally hundreds of varying shipping numbers during the course of a year. After
    listening to them for a while, I noticed that they were saying these numbers with
    slight pauses after every third number. Even just looking at the  12-digit number
    395024102833 is visually taxing. Imagine doing this several times a day, including
    memorizing the fast movers on the next shipment (I'm not even going to go into
    the printed shipment manifest, which was a nightmare). It is, therefore, easier
    to think of the number as 395-024-102-833 and this makes it easier to spot patterns.
    This is essentially exactly what C# 7.0 now allows developers to do with literals.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这是C#语言的另一个小改进，但我相信开发人员经常会使用它。我年轻时的第一份工作是在一家物流公司工作。这些人过去常常向大众供应零部件，而最关键的零部件是通过空运从德国或其他地方运来的。我永远不会忘记物流人员在随意交谈中提到的9位和12位的运输编号。我想知道他们是如何在一年中记住成百上千个不同的运输编号的。听了一会儿后，我注意到他们在每三个数字后稍作停顿。即使只是看着12位数395024102833也是一种视觉负担。想象一天要做这样几次，包括记住下一批货物的快速移动者（我甚至不想谈论印刷的货物清单，那简直是一场噩梦）。因此，更容易将数字视为395-024-102-833，这样更容易发现模式。这基本上正是C#
    7.0现在允许开发人员使用文字的方式。
- en: Getting ready
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Number literals can sometimes be difficult to read. This is why C# 7.0 introduces
    the underscore (`_`) to act as a digit separator inside of number literals. C#
    7.0 also introduces binary literals, which allow you to specify bit patterns directly
    without needing to know hexadecimal.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 数字文字有时可能很难阅读。这就是为什么C# 7.0引入了下划线（`_`）作为数字文字中的数字分隔符。C# 7.0还引入了二进制文字，允许您直接指定位模式，而无需知道十六进制。
- en: How to do it...
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Add the following lines of code to your project. It is clear that the `newNum`
    literal is easier to read, especially if you read it in groups of three.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到您的项目中。很明显，`newNum`文字更容易阅读，特别是如果您以三个一组阅读它。
- en: '[PRE79]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If you run the console application, you will see that the values of the two
    number literals are exactly the same:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果运行控制台应用程序，您将看到两个数字文字的值完全相同：
- en: '![](img/B06434_01_20.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_20.png)'
- en: 'The same logic is true for binary literals. You can now express them as follows:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于二进制文字也是如此。您现在可以将它们表示如下：
- en: '[PRE80]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: How it works...
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This is merely syntactical sugar for literals. I'm sure that there is much more
    to it going on in the background, but the implementation of this in your code
    is really straightforward.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是文字的语法糖。我相信背后还有更多的东西，但是在您的代码中实现这一点确实非常简单。
- en: Ref returns and locals
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用返回和本地变量
- en: Passing objects by reference in C# is nothing new. This is done using the `ref`
    keyword. In C# 7.0, however, you can now return objects by reference and store
    these objects in a local variable by reference.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中通过引用传递对象并不新鲜。这是使用`ref`关键字完成的。然而，在C# 7.0中，您现在可以通过引用返回对象，并将这些对象存储在本地变量中。
- en: Getting ready
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is important to understand the concept of the `ref` keyword. When you pass
    a `ref` parameter, you are working with the variable itself, not just the value
    of the variable. This means that, if the value is changed, the original place
    in memory is updated, not only the value which would be a copy of the parameter.
    This becomes clearer in the following example.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解`ref`关键字的概念。当你传递一个`ref`参数时，你是在处理变量本身，而不仅仅是变量的值。这意味着，如果值被改变，原始的内存位置会被更新，而不仅仅是参数的副本。这在下面的例子中变得更清楚。
- en: How to do it...
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Inside the `Chapter1` class, create a new method called `GetLargest()`. The
    method is nothing special. It only gets the largest of two values and returns
    it to the calling code.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter1`类中，创建一个名为`GetLargest()`的新方法。该方法并不特别。它只是获取两个值中的最大值并将其返回给调用代码。
- en: '[PRE81]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Create a second method with the same name. Only this time, add the `ref` keyword.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个同名的第二个方法。只是这一次，添加`ref`关键字。
- en: '[PRE82]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In the `static void Main` method, create an instance to the `Chapter1` class
    and call the `GetLargest()` method. Increment the variable `val` and write the
    variable values to the console window.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`static void Main`方法中，创建一个`Chapter1`类的实例并调用`GetLargest()`方法。增加变量`val`并将变量值写入控制台窗口。
- en: '[PRE83]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Then, write the following code just after the previous calling code, but call
    the `ref ch1.GetLargest()` method. Increment the `refVal` variable and write the
    variable values to the console window.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在前面的调用代码之后写入以下代码，但调用`ref ch1.GetLargest()`方法。增加`refVal`变量并将变量值写入控制台窗口。
- en: '[PRE84]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Run your console application and consider the output displayed.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并考虑显示的输出。
- en: '![](img/B06434_01_22.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_22.png)'
- en: How it works...
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the console window, you will see two very different results. Simply put,
    in the first line, the variable `a` is the variable `a`, the variable `b` is the
    variable `b`, and the variable `val` is the variable `val`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台窗口中，你会看到两个非常不同的结果。简单地说，在第一行中，变量`a`是变量`a`，变量`b`是变量`b`，变量`val`是变量`val`。
- en: In the second line, the variable`a` is the variable `a`, the variable `b` is
    the variable `b`, and the variable `refVal` is the variable `b`. This is the whole
    crux of the `ref` keyword. In the first `GetLargest()` method, we returned the
    largest value into the variable `val`. This value was 20\. The variable `val`
    and the variable `b` had no relation to one another as they were allocated different
    spaces in memory.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行中，变量`a`是变量`a`，变量`b`是变量`b`，变量`refVal`是变量`b`。这就是`ref`关键字的全部关键所在。在第一个`GetLargest()`方法中，我们将最大值返回到变量`val`中。这个值是20。变量`val`和变量`b`之间没有关系，因为它们在内存中分配了不同的空间。
- en: In the second `GetLargest()` method, we returned the largest variable itself
    (which was `b`) into the variable `refVal`. The variable `refVal` therefore becomes
    an alias of the variable `b` because they both point to the same space allocated
    in memory. To illustrate this even more clearly, let us have a look at the memory
    addresses for the variables.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个`GetLargest()`方法中，我们将最大的变量本身（即`b`）返回到变量`refVal`中。因此，变量`refVal`成为变量`b`的别名，因为它们都指向内存中分配的相同空间。为了更清楚地说明这一点，让我们看一下变量的内存地址。
- en: From the Project menu, go to the Properties of the current project. In the Build
    tab, check the option to Allow unsafe code and save the properties.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目菜单中，转到当前项目的属性。在生成选项卡中，选中允许不安全代码的选项并保存属性。
- en: '![](img/B06434_01_24.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_24.png)'
- en: 'Add the following code to your console application:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的控制台应用程序中：
- en: '[PRE85]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This code is not really related to the recipe on `ref` returns and locals, so
    I'm not even going to go into it in any detail. If you want to learn more about
    pointers in C#, start with the MSDN article on *Pointer types (C# Programming
    Guide):* [https://msdn.microsoft.com/en-us/library/y31yhkeb.aspx](https://msdn.microsoft.com/en-us/library/y31yhkeb.aspx).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与`ref`返回和本地变量的配方没有真正关系，所以我甚至不会详细介绍它。如果你想了解更多关于C#中指针的知识，请从MSDN上的*指针类型（C#编程指南）*文章开始：[https://msdn.microsoft.com/en-us/library/y31yhkeb.aspx](https://msdn.microsoft.com/en-us/library/y31yhkeb.aspx)。
- en: 'Run your console application and take a look at the memory addresses listed:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并查看列出的内存地址：
- en: '![](img/B06434_01_25.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_25.png)'
- en: You will notice straightaway that variable `b` and variable `refVal` have the
    same memory address of `11531252`, while variable `b` and variable `val` have
    different memory addresses.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你会立刻注意到变量`b`和变量`refVal`具有相同的内存地址`11531252`，而变量`b`和变量`val`具有不同的内存地址。
- en: 'So now for the million dollar question: Why is this feature in C# 7.0 even
    useful? Well, simply put, it can improve performance. Many developers mention
    that it will be quite useful for game programmers, who can now pass these aliases
    around to reference large data structures. This means that they don''t have to
    make a copy of a large array (for example) in order to work with it. Using `ref`,
    they can create an alias that points to the original memory location of the array
    and read or modify it directly. Thinking of it this way suddenly brings the usefulness
    of this C# 7.0 feature into perspective.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 那么现在是百万美元的问题：C# 7.0中的这个特性有什么用？简单地说，它可以提高性能。许多开发人员提到，对于游戏程序员来说，这将非常有用，他们现在可以传递这些别名来引用大型数据结构。这意味着他们不必复制大型数组（例如）以便处理它。使用`ref`，他们可以创建一个指向数组原始内存位置的别名，并直接读取或修改它。以这种方式思考，突然之间这个C#
    7.0特性的用处就显而易见了。
- en: Will I ever use it? I don't really know. Perhaps not often but, as with local
    functions, this feature of C# 7.0 is really a great addition to the developer's
    toolkit. It solves some really tricky problems when you want to get away from
    copying around large structures in your code.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我会经常使用它吗？我真的不知道。也许不经常，但是，就像本地函数一样，C# 7.0的这个特性确实是开发人员工具包的一个很好的补充。当你想要摆脱在代码中传递大型结构时，它解决了一些非常棘手的问题。
- en: Generalized async return types
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广义异步返回类型
- en: 'If you use async/await (if not, check it out) the following feature of C# 7.0
    will come in really handy. The only supported return types used to be `Task<T>`,
    `Task`, and `void`. Even then, `void` was also only used with event handlers such
    as a button click. The challenge, however, was that a `Task<T>` was allocated
    in situations where the result of the `async` operation was available at the time
    of awaiting. But, what does this even mean? Well consider an `async` method that
    returns a `Task<T>` : and that value has a time to live of *n* amount of seconds.
    If the `async` method is called within the time to live period, why go to the
    trouble of allocating another `Task<T>` object? This is where the `ValueTask<T>`
    comes into play; it will allow other types to be defined so that you can return
    them from an `async` method. This, therefore, reduces the `Task<T>` allocations,
    which in turn will lead to performance gains.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用async/await（如果没有，请查看一下），那么C# 7.0的以下特性将非常方便。以前唯一支持的返回类型是`Task<T>`、`Task`和`void`。即使是`void`也只用于事件处理程序，比如按钮点击。然而，挑战在于，在等待时分配了`Task<T>`，而`async`操作的结果在等待时是可用的。但是，这到底意味着什么呢？考虑一个返回`Task<T>`的`async`方法：该值的生存时间为*n*秒。如果在生存时间内调用`async`方法，为什么要费力分配另一个`Task<T>`对象呢？这就是`ValueTask<T>`发挥作用的地方；它将允许定义其他类型，以便您可以从`async`方法中返回它们。因此，这减少了`Task<T>`的分配，从而带来了性能上的提升。
- en: Getting ready
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Start off by creating a new WinForms application and performing the following
    steps:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的WinForms应用程序，并执行以下步骤：
- en: Add a button, label, timer, and textbox to the Windows form.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows表单中添加一个按钮、标签、定时器和文本框。
- en: '![](img/B06434_01_27-1.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_27-1.png)'
- en: We need to add the `System.Threading.Tasks.Extensions` package from NuGet to
    implement the  `ValueTask<T>` struct. This process should be familiar to you if
    you completed the Tuples recipe. Select the winform project and click on the Install
    button.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要从NuGet添加`System.Threading.Tasks.Extensions`包以实现`ValueTask<T>`结构。如果您完成了元组的使用，这个过程对您来说应该很熟悉。选择winform项目，然后点击安装按钮。
- en: Note that I am using Visual Studio 2017 RC while writing this book. You probably
    will not need to add `System.Threading.Tasks.Extensions` from NuGet in the final
    release.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在撰写本书时使用的是Visual Studio 2017 RC。在最终版本中，您可能不需要从NuGet添加`System.Threading.Tasks.Extensions`。
- en: '![](img/B06434_01_28-1.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_28-1.png)'
- en: A confirmation screen will be displayed to allow you to review the changes that
    are about to be made. Just click on OK. Accept the license agreement. Also make
    sure that you have added this `using` statement to your project.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将显示确认屏幕以允许您审查即将进行的更改。只需点击确定。接受许可协议。还要确保已将此`using`语句添加到您的项目中。
- en: '[PRE86]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We are now ready to write our code. The Windows app will call an `async`  `Task<T>`
    method if the time to live has passed. Once it does that, the method will read
    a value and cache it. This cached value will be valid for 10 seconds (which is
    the time to live). If the method is run within the time to live period, then the
    cached value will be used and returned to the form. If the time to live has passed,
    the process repeats and the `Task<T>` method is called. The implementation will
    become clearer when you review the following code samples.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好编写我们的代码了。Windows应用程序将在生存时间到期后调用一个`async` `Task<T>`方法。一旦这样做，该方法将读取一个值并将其缓存。这个缓存值将在10秒内有效（即生存时间）。如果在生存时间内运行该方法，则将使用并返回缓存值到表单。如果生存时间已过，则重复该过程并调用`Task<T>`方法。当您审查以下代码示例时，实现将变得更加清晰。
- en: How to do it...
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Start by adding the following variables to your form.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在您的表单中添加以下变量。
- en: '[PRE87]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In the form load event, set the label with the timer text.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗体加载事件中，使用计时器文本设置标签。
- en: Strictly speaking, this is all just fluff. It's not really necessary when it
    comes to illustrating generalized async return types, but it helps us to visualize
    and understand the concept.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，这只是一些花里胡哨的东西。当涉及到说明一般化的异步返回类型时，这并不是真正必要的，但它有助于我们理解和理解这个概念。
- en: '[PRE88]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Set the timer interval on the designer to 1000 ms and add the following code
    to the `timer1_Tick` event.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设计器上将定时器间隔设置为1000毫秒，并将以下代码添加到`timer1_Tick`事件中。
- en: '[PRE89]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Now create a method that simulates some sort of longer running task. Delay this
    for a second. Use the `Random` keyword to generate a random number and assign
    it to the `cacheValue` variable. Set the time to live, start the timer, and return
    the cached value to the calling code.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个模拟某种较长运行任务的方法。延迟一秒钟。使用`Random`关键字生成一个随机数，并将其赋值给`cacheValue`变量。设置生存时间，启动定时器，并将缓存值返回给调用代码。
- en: '[PRE90]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In the calling code, check to see if the time to live is still valid for the
    current cached value. If the time to live has expired, run the code that allocates
    and returns a `Task<T>` to get and set the cached value. If the time to live is
    still valid, just return the cached integer value.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用代码中，检查当前缓存值的生存时间是否仍然有效。如果生存时间已过期，则运行分配并返回`Task<T>`以获取和设置缓存值的代码。如果生存时间仍然有效，则只返回缓存的整数值。
- en: You will notice that I am passing a Boolean `out` variable to indicate that
    a cached value has been read or set.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我传递了一个布尔`out`变量，以指示已读取或设置了缓存值。
- en: '[PRE91]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The code for the button click uses the `out` variable `isCachedValue` and sets
    the text in the textbox accordingly.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮点击的代码使用`out`变量`isCachedValue`，并相应地设置文本框中的文本。
- en: '[PRE92]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: When you finish adding all the code, run your application and click on the Test
    async button. This will read a new value from the `GetValue()` method, cache it,
    and start the time to live count down.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您完成添加所有代码后，运行您的应用程序并点击测试异步按钮。这将从`GetValue()`方法中读取一个新值，将其缓存，并开始生存时间倒计时。
- en: '![](img/B06434_01_31.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_31.png)'
- en: If you click on the button again before the time to live has expired, the cached
    value is returned.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在生存时间到期之前再次点击按钮，则返回缓存值。
- en: '![](img/B06434_01_32.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_32.png)'
- en: When the time to live expires, clicking on the Test async button will call the
    `GetValue()` method again and the process repeats.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当生存时间到期时，单击“测试异步”按钮将再次调用`GetValue()`方法，进程重复。
- en: '![](img/B06434_01_33.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_33.png)'
- en: How it works...
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`ValueTask<T>` is a very nice addition to C# 7.0\. Microsoft, however, does
    suggest that you benchmark the performance of `Task<T>` versus `ValueTask<T>`
    when doing additional optimizing of your methods. A simple optimization however
    would be to simply replace the instances of `Task<T>` with `ValueTask<T>`.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValueTask<T>`是C# 7.0的一个非常好的补充。然而，微软建议在对方法进行额外优化时对`Task<T>`与`ValueTask<T>`的性能进行基准测试。然而，一个简单的优化就是简单地用`ValueTask<T>`替换`Task<T>`的实例。'
- en: Expression bodies for accessors, constructors, and finalizers
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问器、构造函数和终结器的表达式主体
- en: 'Expression-bodied members have been a big hit with the C# developer community,
    so much so that Microsoft has expanded the allowed members that can be implemented
    as expressions. You can now use this feature with:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式主体成员在C#开发者社区中非常受欢迎，以至于微软已经扩展了可以实现为表达式的允许成员。您现在可以在以下情况下使用此功能：
- en: Constructors
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数
- en: Finalizers (used when you need to release unmanaged code)
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终结器（在需要释放非托管代码时使用）
- en: '`get` and `set` accessors on properties and indexers'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性和索引器上的`get`和`set`访问器
- en: Getting ready
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: There is nothing you specifically need to get ready in order to use this recipe.
    The following code will make use of an old-versus-new approach to demonstrate
    the differences and implementation of each.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个配方不需要特别准备什么。以下代码将使用旧与新的方法来演示每个方法的差异和实现。
- en: How to do it...
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Consider the class `SomeClass`. It contains a constructor, finalizer, and a
    property.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑类`SomeClass`。它包含一个构造函数，终结器和一个属性。
- en: '[PRE93]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: With expression-bodied members, the class `SomeClass` can be simplified and
    the number of lines of code reduced.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用表达式主体成员，类`SomeClass`可以简化，并且代码行数减少。
- en: '[PRE94]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: How it works...
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you have used expression-bodied members before in C# 6.0, you will undoubtedly
    be excited to use the expanded functionality. Personally, I'm really glad that
    constructors can now be implemented as an expression.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前在C# 6.0中使用过表达式主体成员，您肯定会很高兴使用扩展功能。就我个人而言，我真的很高兴构造函数现在可以实现为一个表达式。
- en: throw expressions
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抛出异常
- en: Traditionally, `throw` has been a statement in C#. As we know, because it is
    a statement and not an expression, we could not use it in certain places. Thanks
    to expression-bodied members, C# 7.0 introduced `throw` expressions. There isn't
    any difference in how an exception is thrown, only in where you can throw them
    from.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，`throw`在C#中一直是一个语句。正如我们所知，因为它是一个语句而不是一个表达式，我们不能在某些地方使用它。由于表达式主体成员，C# 7.0引入了`throw`表达式。抛出异常的方式没有任何区别，只是可以从哪里抛出它们。
- en: Getting ready
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Throwing exceptions is nothing new. You have been doing it ever since you have
    been writing code. I will admit that `throw` expressions are a very welcome addition
    to C# and it's all thanks to expression-bodied members.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常并不是什么新鲜事。自从写代码以来，您一直在这样做。我承认`throw`表达式是C#中一个非常受欢迎的补充，这都归功于表达式主体成员。
- en: How to do it...
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: To illustrate the use of a `throw` expression, create a method called `GetNameLength()` in
    the `Chapter1` class. All it does is check to see if the length of a name is not
    zero. If it is, then the method will throw an exception right there in the expression.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了说明`throw`表达式的使用，创建一个名为`GetNameLength()`的方法在`Chapter1`类中。它只是检查名称的长度是否不为零。如果是，那么该方法将在表达式中立即抛出异常。
- en: '[PRE95]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: To see the `throw` expression in action, create an instance of the `Chapter1`
    class and call the `GetNameLength()` method. Pass it two blank strings as parameters.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要看到`throw`表达式的实际效果，请创建`Chapter1`类的实例并调用`GetNameLength()`方法。将两个空字符串作为参数传递。
- en: '[PRE96]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Running your console application will then return the exception message as the
    output.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序将返回异常消息作为输出。
- en: '![](img/B06434_01_21.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_01_21.png)'
- en: How it works...
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Being able to use `throw` expressions makes your code easier to write and easier
    to read. The new features in C# 7.0 build on top of the fantastic foundation laid
    down by C# 6.0.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 能够使用`throw`表达式使您的代码更容易编写和阅读。C# 7.0中的新功能建立在C# 6.0奠定的出色基础之上。
