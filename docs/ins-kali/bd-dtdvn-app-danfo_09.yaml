- en: '*Chapter 7*: Data Aggregation and Group Operations'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：数据聚合和分组操作'
- en: '`groupby` operations (aggregations or transformations) to the grouped data
    to produce a new set of values. The resulting values are then combined into a
    single data group.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对分组数据进行`groupby`操作（聚合或转换）以生成一组新值。然后将结果值组合成单个数据组。
- en: 'This approach is popularly known as **split-apply-combine**. The term was actually
    coined by Hadley Wickham, the author of many popular **R** packages, to describe
    group operations. *Figure 7.1* describes the idea of split-apply-combine graphically:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通常被称为**split-apply-combine**。这个术语实际上是由Hadley Wickham创造的，他是许多流行的**R**包的作者，用来描述分组操作。*图7.1*以图形方式描述了split-apply-combine的概念：
- en: '![Figure 7.1 – groupby illustration'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 – groupby说明'
- en: '](img/B17076_07_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_01.jpg)'
- en: Figure 7.1 – groupby illustration
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – groupby说明
- en: 'In this chapter, we look into ways of performing group operations: how to group
    data by column keys and perform data aggregation on grouped data jointly or independently.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨执行分组操作的方法：如何按列键对数据进行分组，并在分组数据上联合或独立地执行数据聚合。
- en: This chapter will also show how to access grouped data by keys. It also gives
    insight into how to create a custom aggregate function for your data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将展示如何通过键访问分组数据。它还提供了如何为您的数据创建自定义聚合函数的见解。
- en: 'The following are the topics to be covered in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Grouping data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据分组
- en: Iterating through grouped data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历分组数据
- en: Using the `.apply` method
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`.apply`方法
- en: Data aggregation of grouped data
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分组数据的数据聚合
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to follow along with this chapter, you should have the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章，您应该具有以下内容：
- en: A modern browser such as Chrome, Safari, Opera, or Firefox
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像Chrome、Safari、Opera或Firefox这样的现代浏览器
- en: '**Node.js**, **Danfo.js**, and **Dnotebook** installed on your system'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js**、**Danfo.js**和**Dnotebook**已安装在您的系统上'
- en: 'The code for this chapter is available here: [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter07](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter07).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码在此处可用：[https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter07](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter07)。
- en: Grouping data
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据分组
- en: Danfo.js only provides the ability to group data by means of values in a specific
    column. For the current version of Danfo.js, the specified number of columns for
    grouping can only be one or two.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Danfo.js只提供了通过特定列中的值对数据进行分组的能力。对于当前版本的Danfo.js，分组的指定列数只能是一列或两列。
- en: In this section, we will show how to group by single and double columns.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何按单个列和双列进行分组。
- en: Single-column grouping
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单列分组
- en: 'First, let''s start by creating a DataFrame and then group it by a single column:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过创建一个DataFrame然后按单个列对其进行分组来开始：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code involves the following steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码涉及以下步骤：
- en: First, we create a DataFrame by using an `object` method.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用`object`方法创建一个DataFrame。
- en: We then make a call to the `groupby` method.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们调用`groupby`方法。
- en: Then, we specify that the DataFrame should be grouped by column `A`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们指定DataFrame应该按列`A`进行分组。
- en: '`df.groupby([''A''])` returns a `groupby` data structure that contains all
    the necessary methods needed for grouping data.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`df.groupby([''A''])`返回一个`groupby`数据结构，其中包含对数据进行分组所需的所有必要方法。'
- en: We can decide to perform our data operations on all the columns grouped by `A`
    or we specify any other column.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以决定对由`A`分组的所有列执行数据操作，或者指定任何其他列。
- en: 'The preceding code outputs the following table:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码输出以下表：
- en: '![Figure 7.2 – DataFrame'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 – DataFrame'
- en: '](img/B17076_07_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_02.jpg)'
- en: Figure 7.2 – DataFrame
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – DataFrame
- en: 'In the following code, we will see how we can perform some common `groupby`
    operations on the grouped data:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将看到如何对分组数据执行一些常见的`groupby`操作：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using the `groupby_df` operations created in the preceding code snippet, we
    make a call to the `groupby` `mean` method. This method calculates the mean per
    group as shown in the following figure:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述代码片段中创建的`groupby_df`操作，我们调用`groupby`的`mean`方法。该方法计算每个组的平均值，如下图所示：
- en: '![Figure 7.3 – groupby DataFrame'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 – groupby DataFrame'
- en: '](img/B17076_07_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_03.jpg)'
- en: Figure 7.3 – groupby DataFrame
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – groupby DataFrame
- en: 'The following figure shows the operation of the preceding code graphically
    and how the preceding table output is generated:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下图以图形方式显示了上述代码的操作以及如何生成上述表的输出：
- en: '![Figure 7.4 – Graphical depiction of the groupby method'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 – groupby方法的图形描述'
- en: '](img/B17076_07_04.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_04.jpg)'
- en: Figure 7.4 – Graphical depiction of the groupby method
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – groupby方法的图形描述
- en: Based on the split-apply-combine method that we discussed at the beginning of
    this chapter, `df.groupby(['A'])` groups the DataFrame into two keys – `foo` and
    `bar`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 根据本章开头讨论的split-apply-combine方法，`df.groupby(['A'])`将DataFrame分成两个键-`foo`和`bar`。
- en: With the DataFrame grouped into `foo` and `bar` keys, the values in other columns
    (`C` and `D`) are assigned to each of these keys respectively based on their row
    alignment. To nail this point, if we pick the `bar` key, from *Figure 7.2*, we
    can see that column `C` has three data points (`3`, `4`, `2`) in the `bar` rows.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将DataFrame分组为`foo`和`bar`键后，其他列（`C`和`D`）中的值分别根据它们的行对齐分配给每个键。为了强调这一点，如果我们选择`bar`键，从*图7.2*中，我们可以看到列`C`在`bar`行中有三个数据点（`3`、`4`、`2`）。
- en: Hence, if we were to perform a data aggregation operation, such as calculating
    the mean of the data assigned to the `bar` key, the data point belonging to column
    `C` assigned to the `bar` key will have a mean of `3`, which corresponds to the
    table in *Figure 7.3*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们要执行数据聚合操作，比如计算分配给`bar`键的数据的平均值，分配给`bar`键的列`C`的数据点将具有平均值`3`，这对应于*图7.3*中的表。
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The same operation as described in the preceding paragraph occurs for the `foo`
    key and all other data points are assigned
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面段落中描述的相同操作发生在`foo`键上，所有其他数据点都被分配
- en: 'As I said before, this call to the group mean method is applied to all the
    columns grouped by `A`. Let''s choose a column to which we would like to specifically
    apply the group operation, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所说，这次对分组均值方法的调用适用于所有按`A`分组的列。让我们选择一个特定应用组操作的列，如下所示：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'First, we make a call to the `col` method in `groupby`. This method takes in
    an array of column names. The main purpose of the preceding code is to obtain
    the sum of column `C` for each of the grouped keys (`foo` and `bar`) and this
    gives the following table output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用`groupby`中的`col`方法。该方法接受一个列名的数组。上述代码的主要目的是获取每个分组键（`foo`和`bar`）的列`C`的总和，这给出以下表格输出：
- en: '![Figure 7.5 – The groupby operation on column C'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – 列C的分组操作'
- en: '](img/B17076_07_05.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_05.jpg)'
- en: Figure 7.5 – The groupby operation on column C
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 列C的分组操作
- en: 'The same operation can be applied to any other column in the grouped data,
    as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的操作可以应用于分组数据中的任何其他列，如下所示：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code snippet follows the same approach as the preceding code, just that
    the `count` `groupby` operation is applied to column `D`, which gives us the following
    output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段遵循与上述代码相同的方法，只是将`count` `groupby`操作应用于列`D`，这给出了以下输出：
- en: '![Figure 7.6 – The groupby "count" operation on column D'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6 – 列D的groupby“count”操作'
- en: '](img/B17076_07_06.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_06.jpg)'
- en: Figure 7.6 – The groupby "count" operation on column D
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 列D的groupby“count”操作
- en: A DataFrame can also be grouped by two columns; the operation shown for single-column
    grouping is also applicable to two-column grouping, as we will see in the next
    sub-section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame也可以按两列进行分组；单列分组所示的操作也适用于双列分组，我们将在下一小节中看到。
- en: Double-column grouping
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双列分组
- en: 'First, let''s create a DataFrame and add an extra column as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个DataFrame并添加一个额外的列，如下所示：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We added an extra column, `B`, which contains categoric data – `one`, `two`,
    and `three`. The DataFrame is grouped by columns `A` and `B`, as shown in the
    following table:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个额外的列`B`，其中包含分类数据 - `one`，`two`和`three`。DataFrame按列`A`和`B`进行分组，如下表所示：
- en: '![Figure 7.7 – DataFrame including column B'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7 – 包含列B的DataFrame'
- en: '](img/B17076_07_07.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_07.jpg)'
- en: Figure 7.7 – DataFrame including column B
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 包含列B的DataFrame
- en: 'We can also calculate the mean as shown with the single-column grouping, as
    follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以像单列分组一样计算平均值，如下所示：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This applies the mean to columns `C` and `D` based on the group key of columns
    `A` and `B`. For example, in *Figure 7.7*, we can see that we have a group key
    from columns `A` and `B` named (`foo`, `one`). This key occurs twice in the data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将根据列`A`和`B`的分组键对列`C`和`D`应用平均值。例如，在*图7.7*中，我们可以看到我们有一个来自列`A`和`B`的分组键，名为（`foo`，`one`）。这个键在数据中出现了两次。
- en: 'The preceding code outputs the following table:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码输出以下表格：
- en: '![Figure 7.8 – The groupby mean of the groupby A and B DataFrame'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8 – 按A和B分组的groupby均值DataFrame'
- en: '](img/B17076_07_08.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_08.jpg)'
- en: Figure 7.8 – The groupby mean of the groupby A and B DataFrame
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 按A和B分组的groupby均值DataFrame
- en: In *Figure 7.7*, column `C` has the values `1` and `6` belonging to the (`foo`,
    `one`) key. Also, `D` has the values `3` and `7` belonging to the same key. If
    we were to take the mean, we would see that it corresponds to the first column
    in *Figure 7.8*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图7.7*中，列`C`的值为`1`和`6`，属于（`foo`，`one`）键。同样，`D`的值为`3`和`7`，属于相同的键。如果我们计算平均值，我们会发现它对应于*图7.8*中的第一列。
- en: 'We can also go ahead and obtain the sum for one of the columns grouped by columns
    `A` and `B`. Let''s choose column `C`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以继续按列`A`和`B`对分组的一列进行求和。让我们选择列`C`：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We obtained column `C` from the grouped data and then calculated the sum per
    the group keys, as shown in the following table:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从分组数据中获取了列`C`，然后计算了每个分组键的总和，如下表所示：
- en: '![Figure 7.9 – Sum of column C per group'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.9 – 每组列C的总和'
- en: '](img/B17076_07_09.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_09.jpg)'
- en: Figure 7.9 – Sum of column C per group
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – 每组列C的总和
- en: In this section, we saw how we can group data by single or double columns. We
    also looked into performing data aggregation and accessing column data of a grouped
    DataFrame. In the next section, we'll look into how to access grouped data per
    grouped keys.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何按单列或双列分组数据。我们还研究了执行数据聚合和访问分组DataFrame的列数据。在下一节中，我们将看看如何访问按分组键分组的数据。
- en: Iterating through grouped data
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历分组数据
- en: In this section, we will see how to access grouped data based on grouped keys,
    loop through this grouped data, and perform data aggregation operations on it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何根据分组键访问分组数据，循环遍历这些分组数据，并对其执行数据聚合操作。
- en: Iterating through single- and double-column grouped data
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过单列和双列分组数据进行迭代
- en: In this section, we will see how Danfo.js provides the means of iterating through
    each of the groups created during the `groupby` operations. This data is grouped
    by the keys contained in the `groupby` column.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到Danfo.js如何提供迭代通过`groupby`操作创建的每个组的方法。这些数据是按`groupby`列中包含的键进行分组的。
- en: The keys are stored as a dictionary or object in a class attribute called `data_tensors`.
    This object contains the grouped key as its keys and also stores the DataFrame
    data associated with the keys as the object values.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 键存储为一个名为`data_tensors`的类属性中的字典或对象。该对象包含分组键作为其键，并将与键关联的DataFrame数据存储为对象值。
- en: 'Using the previous DataFrame, let''s group by column `A` and then iterate through
    `data_tensors`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一个DataFrame，让我们按列`A`进行分组，然后遍历`data_tensors`：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We group the DataFrame by column `A` and then print out `data_tensors,` as
    shown in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按列`A`对DataFrame进行分组，然后打印出`data_tensors`，如下截图所示：
- en: '![Figure 7.10 – data_tensors output'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10 – data_tensors输出'
- en: '](img/B17076_07_10.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_10.jpg)'
- en: Figure 7.10 – data_tensors output
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – data_tensors输出
- en: '*Figure 7.10* contains more detailed information about what the `data_tensors`
    attribute contains, but the whole content can be summarized into the following
    structure:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.10*包含了关于`data_tensors`属性包含的更详细信息，但整个内容可以总结为以下结构：'
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The keys are the values of column `A` and the values for the keys are the DataFrame
    associated with these keys.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 键是列`A`的值，键的值是与这些键关联的DataFrame。
- en: 'We can iterate through `data_tensors` and print out the `DataFrame` table to
    see what they contain, as shown in the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以迭代`data_tensors`并打印出`DataFrame`表格，以查看它们包含的内容，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'First, we access `data_tensors`, which is a `groupby` class attribute, and
    assign it to a variable called `grouped_data`. We then loop through `grouped_data`,
    access each of its keys, and print their corresponding DataFrame as a table, as
    shown in the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们访问`data_tensors`，这是一个`groupby`类属性，并将其赋值给一个名为`grouped_data`的变量。然后我们循环遍历`grouped_data`，访问每个键，并将它们对应的DataFrame打印为表格，如下面的截图所示：
- en: '![Figure 7.11 – groupby keys and their DataFrame'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.11 – groupby键和它们的DataFrame'
- en: '](img/B17076_07_11.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_11.jpg)'
- en: Figure 7.11 – groupby keys and their DataFrame
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – groupby键和它们的DataFrame
- en: 'Also, we can apply this same approach, as shown in the preceding code, to data
    grouped by two columns:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以将与前面代码相同的方法应用到由两列分组的数据上，如下所示：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here are the steps we followed in the preceding code snippet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在前面的代码片段中遵循的步骤：
- en: First of all, the `df` DataFrame is grouped by two columns (`A` and `B`).
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`df` DataFrame按两列（`A`和`B`）进行分组。
- en: We assign `data_tensors` to a variable called `grouped_data`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`data_tensors`赋值给一个名为`grouped_data`的变量。
- en: We loop through `grouped_data` to obtain the keys.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们循环遍历`grouped_data`以获取键。
- en: 'We loop through the `grouped_data` object and also loop through its inner object
    (`key_data`) per key, due to the object data format generated for `grouped_data`,
    as shown:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们循环遍历`grouped_data`对象，也循环遍历其内部对象（`key_data`）每个键，由于为`grouped_data`生成的对象数据格式，如下所示：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The code snippet gives us the following output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段给我们提供了以下输出：
- en: '![Figure 7.12 – The output of a two-column grouping of a DataFrame'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.12 – DataFrame的两列分组输出'
- en: '](img/B17076_07_12.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_12.jpg)'
- en: Figure 7.12 – The output of a two-column grouping of a DataFrame
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 – DataFrame的两列分组输出
- en: In this section, we went through how to iterate through grouped data. We saw
    how the object format for `data_tensor` varies by how the data is being grouped,
    either by single or double columns.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何迭代分组数据。我们看到了`data_tensor`的对象格式如何根据数据的分组方式而变化，无论是单列还是双列。
- en: We saw how to iterate `data_tensor` to obtain the keys and their associated
    data. In the next sub-section, we will see how we can obtain the data associated
    with each key without looping through `data_tensor` manually.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何迭代`data_tensor`以获取键和它们关联的数据。在下一小节中，我们将看到如何在不手动循环`data_tensor`的情况下获取与每个键关联的数据。
- en: Using the get_groups method
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`get_groups`方法
- en: Danfo.js provides a method called `get_groups()` that enables easy access to
    each of the key-value DataFrames without looping through the `data_tensors` object.
    This is handy whenever we need to access particular data belonging to a set of
    key combinations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Danfo.js提供了一个名为`get_groups()`的方法，可以轻松访问每个键值DataFrame，而无需循环遍历`data_tensors`对象。每当我们需要访问属于一组键组合的特定数据时，这将非常方便。
- en: 'Let''s start with a single-column grouping, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从单列分组开始，如下所示：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We group by column `A`, and then make a call to the `get_groups` method. The
    `get_groups` method takes in a key combination as an array.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按列`A`进行分组，然后调用`get_groups`方法。`get_groups`方法接受一个键组合作为数组。
- en: 'For a single-column grouping, we only have a single key combination. Hence,
    we pass in one of the keys called `foo` and then print out the corresponding grouped
    data, as shown in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单列分组，我们只有一个键组合。因此，我们传入名为`foo`的其中一个键，然后打印出相应的分组数据，如下面的截图所示：
- en: '![Figure 7.13 – get_groups of the foo key'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.13 – foo键的get_groups'
- en: '](img/B17076_07_13.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_13.jpg)'
- en: Figure 7.13 – get_groups of the foo key
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 – foo键的get_groups
- en: 'Also, the same thing can be applied to all other keys as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的方法也可以应用于所有其他键，如下所示：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code gives us the following output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码给我们提供了以下输出：
- en: '![Figure 7.14 – get_groups for the bar key'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.14 – bar键的get_groups'
- en: '](img/B17076_07_14.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_14.jpg)'
- en: Figure 7.14 – get_groups for the bar key
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 – bar键的get_groups
- en: 'The same approach as shown for the single-column, `groupby` is also applicable
    to two-column grouping:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与单列`groupby`相同的方法也适用于两列分组：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Remember that the `get_groups` method takes in the combination of keys as an
    array. Hence, for two-column grouping, we pass in the key combination of columns
    `A` and `B` that we want. Therefore, we obtain the following output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`get_groups`方法接受键的组合作为数组。因此，对于两列分组，我们传入要使用的列`A`和`B`的键组合。因此，我们获得以下输出：
- en: '![Figure 7.15 – Obtaining a DataFrame for the foo key and one combination'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.15 – 获取foo键和一个组合的DataFrame'
- en: '](img/B17076_07_15.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_15.jpg)'
- en: Figure 7.15 – Obtaining a DataFrame for the foo key and one combination
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 – 获取foo键和一个组合的DataFrame
- en: 'The same thing can be done for any other key combination. Let''s try for the
    `bar` and `two` keys, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对任何其他键组合做同样的操作。让我们尝试`bar`和`two`键，如下所示：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We obtain the following output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获得以下输出：
- en: '![Figure 7.16 – DataFrame for the bar and two keys'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.16 – bar和two键的DataFrame'
- en: '](img/B17076_07_16.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_16.jpg)'
- en: Figure 7.16 – DataFrame for the bar and two keys
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 – bar和two键的DataFrame
- en: In this section, we went through how to iterate grouped data, data grouped by
    either single or double columns. We also saw how the internal `data_tensor` data
    object is formatted based on how the data is being grouped. We also saw how to
    access data associated with each grouped key without looping.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了如何迭代分组数据，数据可以按单列或双列进行分组。我们还看到了内部的`data_tensor`数据对象是如何根据数据的分组方式进行格式化的。我们还看到了如何在不循环的情况下访问与每个分组键相关联的数据。
- en: In the next section, we'll also look into creating custom data aggregation functions
    by using the `.apply` method.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们还将研究如何使用.apply方法创建自定义数据聚合函数。
- en: Using the .apply method
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用.apply方法
- en: In this section, we will be using the `.apply` method to create custom data
    aggregation functions that can be applied to our grouped data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`.apply`方法创建自定义数据聚合函数，可以应用于我们的分组数据。
- en: The `.apply` method enables custom functions to be applied to grouped data.
    It is the major function of the split-apply-combine method discussed earlier in
    this chapter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`.apply`方法使得可以将自定义函数应用于分组数据。这是本章前面讨论的分割-应用-合并方法的主要函数。'
- en: The `groupby` method implemented in Danfo.js only contains a small set of data
    aggregation methods needed for group data, hence the `.apply` method gives users
    the ability to construct a special data aggregation method from the grouped data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Danfo.js中实现的`groupby`方法只包含了一小部分用于组数据的数据聚合方法，因此`.apply`方法使用户能够从分组数据中构建特殊的数据聚合方法。
- en: 'Using the previous data, we will create a new DataFrame excluding column `B`
    as seen in the previous DataFrame, and then create a custom function that will
    be applied to the grouped data:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的数据，我们将创建一个新的DataFrame，不包括前一个DataFrame中的列`B`，然后创建一个将应用于分组数据的自定义函数：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we group the DataFrame by column `A`, and then proceed
    to create a custom function called `add` that adds the value `2` to all the data
    points in the grouped data.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们按列`A`对DataFrame进行分组，然后创建一个名为`add`的自定义函数，将值`2`添加到分组数据中的所有数据点。
- en: Note
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The parameter to be passed into this function, `add`, and similar functions,
    such as `sub`, `mul`, and `div`, can be either a DataFrame, Series, array, or
    an integer value.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '要传递到这个函数的参数`add`和类似的函数，如`sub`、`mul`和`div`，可以是DataFrame、Series、数组或整数值。 '
- en: 'The preceding code generates the following output:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码生成了以下输出：
- en: '![Figure 7.17 – Applying a custom function to group data'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.17 - 将自定义函数应用于组数据'
- en: '](img/B17076_07_17.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_17.jpg)'
- en: Figure 7.17 – Applying a custom function to group data
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17 - 将自定义函数应用于组数据
- en: 'Let''s create another custom function to subtract the minimum value of each
    grouped data from each of the group values:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个自定义函数，从每个分组数据中减去最小值：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, we created a DataFrame containing columns `A`, `B`, `C`, and `D`. Then,
    we grouped the DataFrame by columns `A` and `C`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个包含列`A`、`B`、`C`和`D`的DataFrame。然后，我们按列`A`和`C`对DataFrame进行分组。
- en: A custom function called `subMin` is created to take in grouped data, to obtain
    the minimum values of the grouped data, and to subtract the minimum value from
    each of the data points in the grouped data.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`subMin`的自定义函数，用于获取分组数据的最小值，并从分组数据中的每个数据点中减去最小值。
- en: 'This custom function is then applied to the `group_df` grouped data via the
    `.apply` method, hence we obtain the following output table:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过.apply方法将这个自定义函数应用于`group_df`分组数据，因此我们得到了以下输出表：
- en: '![Figure 7.18 – The subMin custom apply function'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.18 - subMin自定义应用函数'
- en: '](img/B17076_07_18.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_18.jpg)'
- en: Figure 7.18 – The subMin custom apply function
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18 - subMin自定义应用函数
- en: If we look at the table in the preceding figure, we can see that some group
    data only occurs once, such as group data belonging to the `bar` and `two`, `bar`
    and `one`, `bar` and `three`, and `foo` and `three` keys.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下前面图中的表，我们可以看到一些组数据只出现一次，比如属于`bar`和`two`、`bar`和`one`、`bar`和`three`以及`foo`和`three`键的组数据。
- en: The group data belonging to previous key has only one item, hence the minimum
    is also the single value contained in the group; therefore, it has a value of
    `0` for the `C_apply` and `D_apply` columns.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个键的组数据只有一个项目，因此最小值也是组中包含的单个值；因此，`C_apply`和`D_apply`列的值为`0`。
- en: 'We can adjust the `subMin` custom function to only subtract the minimum from
    each value if the key pair has more than one row, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调整`subMin`自定义函数，只有在键对有多行时才从每个值中减去最小值，如下所示：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The custom function gives us the following output table:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义函数给出了以下输出表：
- en: '![Figure 7.19 – Custom apply function'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.19 - 自定义apply函数'
- en: '](img/B17076_07_19.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_19.jpg)'
- en: Figure 7.19 – Custom apply function
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19 - 自定义apply函数
- en: 'The following figure shows a graphical representation of the preceding code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了前面代码的图形表示：
- en: '![Figure 7.20 – groupby and subMin apply method illustration'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.20 - groupby和subMin apply方法示例'
- en: '](img/B17076_07_20.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_20.jpg)'
- en: Figure 7.20 – groupby and subMin apply method illustration
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20 - groupby和subMin apply方法示例
- en: The `.apply` method also gives us the ability to perform a data normalization
    process per group on the data.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`.apply`方法还使我们能够对数据进行分组后的数据归一化处理。'
- en: In machine learning, we have what we called **standardization**, which involves
    rescaling the data between the range -1 and 1\. This process of standardization
    involves subtracting the mean of the data from the data and then dividing by the
    standard deviation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，我们有所谓的**标准化**，它涉及将数据重新缩放到范围-1和1之间。标准化的过程涉及从数据中减去数据的平均值，然后除以标准差。
- en: 'Using the preceding DataFrame, let''s create a custom function to apply standardization
    to the data per group:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的DataFrame，让我们创建一个自定义函数，对数据进行标准化处理：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we first group the data by column `A`. We then create
    a custom function called `norm`, which contains the standardization process that
    is being applied to the data, to give the following output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先按列`A`对数据进行分组。然后，我们创建了一个名为`norm`的自定义函数，其中包含正在应用于数据的标准化过程，以产生以下输出：
- en: '![Figure 7.21 – Standardizing grouped data'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.21 - 对分组数据进行标准化'
- en: '](img/B17076_07_21.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_21.jpg)'
- en: Figure 7.21 – Standardizing grouped data
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21 - 对分组数据进行标准化
- en: We've seen how to use the `.apply` method to create custom functions for `groupby`
    operations. Hence, we can create custom functions as needed based on the kind
    of operation we want to perform on the data.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用`.apply`方法为`groupby`操作创建自定义函数。因此，我们可以根据所需的操作类型创建自定义函数。
- en: In the next section, we'll look into data aggregation and how to assign different
    data aggregation operations to different columns of grouped data.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将研究数据聚合以及如何将不同的数据聚合操作分配给分组数据的不同列。
- en: Data aggregation of grouped data
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对分组数据进行数据聚合
- en: Data aggregation involves the process of gathering data and presenting it in
    a summary form, such as showing its statistics. Aggregation itself is the process
    of gathering data for statistical purposes and presenting it as a number. In this
    section, we look at how to perform data aggregation in Danfo.js
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 数据聚合涉及收集数据并以摘要形式呈现，例如显示其统计数据。聚合本身是为统计目的收集数据并将其呈现为数字的过程。在本节中，我们将看看如何在Danfo.js中执行数据聚合
- en: 'Here is a list of all the available aggregation methods:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是所有可用的聚合方法列表：
- en: '`mean()`: To calculate the mean of grouped data'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mean()`: 计算分组数据的平均值'
- en: '`std()`: To calculate the standard deviation'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std()`: 计算标准差'
- en: '`sum()`: To get the sum of values in a group'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum()`: 获取组中值的总和'
- en: '`count()`: To count the total number of values per group'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count()`: 计算每组的总值数'
- en: '`min()`: To get the minimum value per group'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min()`: 获取每组的最小值'
- en: '`max()`: To get the maximum value per group'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max()`: 获取每组的最大值'
- en: At the start of this chapter, we saw how we can call some of the aggregate methods
    listed previously on group data. The `groupby` class also contains a method called
    `.agg`, which allows us to apply different aggregate operations to different columns
    at the same time.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们看到了如何在组数据上调用先前列出的一些聚合方法。`groupby`类还包含一个名为`.agg`的方法，它允许我们同时对不同列应用不同的聚合操作。
- en: Data aggregation on single-column grouping
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对单列分组进行数据聚合
- en: 'We will create a DataFrame and group the DataFrame by a column, and then apply
    two different aggregation methods on different columns:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个DataFrame，并按列对DataFrame进行分组，然后在不同列上应用两种不同的聚合方法：
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We created a DataFrame and then grouped the DataFrame by column `A`. The grouped
    data is then aggregated by calling the `.agg` method.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个DataFrame，然后按列`A`对DataFrame进行分组。然后通过调用`.agg`方法对分组数据进行聚合。
- en: 'The `.agg` method takes in an object whose keys are names of columns in the
    DataFrame and the values are the aggregation methods we want to apply to each
    of the columns. In the preceding block of code, we specified the keys to be `C`
    and `D` and the values to be `mean` and `count`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`.agg`方法接受一个对象，其键是DataFrame中列的名称，值是我们要应用于每个列的聚合方法。在前面的代码块中，我们指定了键为`C`和`D`，值为`mean`和`count`：'
- en: '![Figure 7.22 – Aggregation method on group data'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.22 - 对组数据进行聚合方法'
- en: '](img/B17076_07_22.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_22.jpg)'
- en: Figure 7.22 – Aggregation method on group data
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.22 - 对组数据进行聚合方法
- en: We've seen how data aggregation can be done on single-column grouping. Let's
    now see how to perform the same operation on a DataFrame grouped by double columns.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在单列分组上进行数据聚合。现在让我们看看如何在由双列分组的DataFrame上执行相同的操作。
- en: Data aggregation on double-column grouping
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对双列分组进行数据聚合
- en: 'For double-column grouping, let''s apply the same aggregation methods:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于双列分组，让我们应用相同的聚合方法：
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code gives the following output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码给出了以下输出：
- en: '![Figure 7.23 – Aggregation method on two-column grouped data'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.23 - 对两列分组数据进行聚合方法'
- en: '](img/B17076_07_23.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_23.jpg)'
- en: Figure 7.23 – Aggregation method on two-column grouped data
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.23 - 对两列分组数据进行聚合方法
- en: In this section, we've seen how we can use the `.apply` method to create a custom
    function for grouped data, and also how to perform joint data aggregation on each
    column of the grouped data. The examples shown here can be extended to any specific
    data and custom functions can be created as desired.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经看到了如何使用`.apply`方法为分组数据创建自定义函数，以及如何对分组数据的每一列执行联合数据聚合。这里显示的示例可以扩展到任何特定数据，并且可以根据需要创建自定义函数。
- en: A simple application of groupby on real data
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在真实数据上应用groupby的简单示例
- en: We've seen how to use `groupby` methods on dummy data. In this section, we will
    see how we can use `groupby` to analyze data.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在虚拟数据上使用`groupby`方法。在本节中，我们将看到如何使用`groupby`来分析数据。
- en: 'We''ll make use of the popular `titanic` dataset available here: [https://web.stanford.edu/class/archive/cs/cs109/cs109.1166/stuff/titanic.csv](https://web.stanford.edu/class/archive/cs/cs109/cs109.1166/stuff/titanic.csv).
    We will see how we can estimate the average number of people that survive the
    Titanic accident based on their gender and their class.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用此处提供的流行的`titanic`数据集：[https://web.stanford.edu/class/archive/cs/cs109/cs109.1166/stuff/titanic.csv](https://web.stanford.edu/class/archive/cs/cs109/cs109.1166/stuff/titanic.csv)。我们将看看如何根据性别和阶级估计幸存泰坦尼克号事故的平均人数。
- en: 'Let''s read the `titanic` dataset into a DataFrame and output some of its rows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`titanic`数据集读入DataFrame并输出其中的一些行：
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code should output the following table:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码应该输出以下表格：
- en: '![Figure 7.24 – DataFrame table'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.24 - DataFrame表'
- en: '](img/B17076_07_24.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_24.jpg)'
- en: Figure 7.24 – DataFrame table
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.24 - DataFrame表
- en: From the dataset, we want to estimate the average number of people that survived
    based on their sex (the `Sex` column) and their traveling class (the `Pclass`
    column).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据集中，我们想要估计根据性别（`Sex`列）和他们的旅行等级（`Pclass`列）生存的人数。
- en: 'The following code shows how to estimate the average rate of survival as described
    previously:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何估计先前描述的平均生存率：
- en: '[PRE23]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following table shows the average survival per sex:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了每个性别的平均生存率：
- en: '![Figure 7.25 – Average rate of survival based on sex'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.25 - 基于性别的平均生存率'
- en: '](img/B17076_07_25.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_25.jpg)'
- en: Figure 7.25 – Average rate of survival based on sex
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.25 - 基于性别的平均生存率
- en: 'The following table shows the average survival per class:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了每个等级的平均生存率：
- en: '![Figure 7.26 – Average rate of survival based on Pclass'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.26 - 基于Pclass的平均生存率'
- en: '](img/B17076_07_26.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_07_26.jpg)'
- en: Figure 7.26 – Average rate of survival based on Pclass
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.26 - 基于Pclass的平均生存率
- en: In this section, we saw a brief introduction of how to use the `groupby` operation
    to analyze real-life data.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要介绍了如何使用`groupby`操作来分析现实生活中的数据。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we extensively discussed the `groupby` operation as implemented
    in Danfo.js. We discussed grouping data and mentioned that at the moment, Danfo.js
    only supports grouping by single and double columns; there is a plan to make this
    more flexible in coming versions of Danfo.js. We also showed how to iterate through
    grouped data and access group keys and their associated grouped data. We looked
    at how to obtain grouped data associated with a group key without looping.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们广泛讨论了在Danfo.js中实现的`groupby`操作。我们讨论了对数据进行分组，并提到目前，Danfo.js仅支持按单列和双列进行分组；计划在未来的版本中使其更加灵活。我们还展示了如何遍历分组数据并访问组键及其关联的分组数据。我们看了如何在不循环的情况下获得与组键相关的分组数据。
- en: We also saw how the `.apply` method gives us the ability to create custom data
    aggregation functions for our grouped data, and finally, we demonstrated how to
    perform different aggregation functions on different columns of grouped data at
    the same time.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了`.apply`方法如何为我们提供了创建自定义数据聚合函数的能力，最后，我们演示了如何同时对分组数据的不同列执行不同的聚合函数。
- en: This chapter equipped us with the knowledge of grouping our data, and more essentially,
    it introduced us to the internals of Danfo.js. With this, we can reshape the `groupby`
    method to our desired taste and have the ability to contribute to Danfo.js.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使我们具备了对数据进行分组的知识，更重要的是，它向我们介绍了Danfo.js的内部工作原理。有了这个，我们可以将`groupby`方法重塑成我们想要的味道，并且有能力为Danfo.js做出贡献。
- en: In the next chapter, we will move on to more application basics, including how
    to use Danfo.js to build a data analysis web app, a no-code environment. We will
    also see how to turn Danfo.js methods into React components.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续介绍更多应用基础知识，包括如何使用Danfo.js构建数据分析Web应用程序，一个无代码环境。我们还将看到如何将Danfo.js方法转换为React组件。
