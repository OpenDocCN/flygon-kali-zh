- en: Chapter 4. Getting Started with Layouts and Material Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章.开始使用布局和材料设计
- en: We have already seen the Android Studio UI designer, as well as a little bit
    more of Kotlin in action. In this hands-on chapter, we will build three more layouts
    – still quite simple, yet a step up from what we have done so far.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了安卓工作室的UI设计师，以及Kotlin的一些实际应用。在这个动手实践的章节中，我们将构建三个更多的布局-仍然相当简单，但比我们迄今为止所做的更进一步。
- en: Before we get to the hands-on part, we will have a quick introduction to the
    concept of **Material Design**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始动手之前，我们将快速介绍**材料设计**的概念。
- en: We will look at another type of layout, called `LinearLayout`, and walk through
    it, using it to create a usable UI. We will take things a step further using `ConstraintLayout`,
    both to understand constraints and to design more complex and precise UI designs.
    Finally, we will meet the `TableLayout` to lay data out in an easily readable
    table.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看另一种布局类型，称为`LinearLayout`，并通过使用它来创建可用的UI来详细介绍它。我们将进一步使用`ConstraintLayout`，既了解约束，又设计更复杂和精确的UI设计。最后，我们将介绍`TableLayout`，以便在易于阅读的表格中布置数据。
- en: We will also write some Kotlin code to switch between our different layouts
    within one app/project. This is the first major app that links together multiple
    topics into one neat parcel. The app is called Exploring Layouts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将编写一些Kotlin代码，以在一个应用程序/项目中在不同的布局之间进行切换。这是第一个将多个主题整合到一个整洁包裹中的重要应用程序。该应用程序名为“探索布局”。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Material Design
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材料设计
- en: Building a `LinearLayout` and learning when it is best to use this type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`LinearLayout`并学习何时最好使用此类型
- en: Building another, slightly more advanced, `ConstraintLayout` and finding out
    a bit more about using constraints
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建另一个稍微更高级的`ConstraintLayout`，并了解更多关于使用约束的信息
- en: Building a `TableLayout` and filling it with data to display
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`TableLayout`并填充数据以显示
- en: Linking everything together in a single app called Exploring Layouts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有内容链接在一个名为“探索布局”的单个应用程序中
- en: First on the list is material design.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是材料设计。
- en: Material design
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材料设计
- en: You might have heard of material design, but what exactly is it? The objective
    of material design is, quite simply, to achieve beautiful user interfaces. It
    is also, however, about making these user interfaces consistent across Android
    devices. Material design is not a new idea. It is taken straight from the design
    principles used in pen-and-paper design, like having visually pleasing embellishments
    such as shadows and depth.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过材料设计，但它究竟是什么？材料设计的目标很简单，就是实现美观的用户界面。然而，它也是为了使这些用户界面在安卓设备上保持一致。材料设计并不是一个新的想法。它直接采用了纸和笔设计中使用的设计原则，比如具有视觉上令人愉悦的装饰，如阴影和深度。
- en: Material design uses the concept of layers of materials that you can think of
    in the same way you would think of layers in a photo-editing app. Consistency
    is achieved with a set of principles, rules, and guidelines. It must be stressed
    that material design is entirely optional, but it also must be stressed that material
    design works, and, if you are not following it, there is a good chance your design
    will be disliked by the user. The user, after all, has become used to a certain
    type of UI, and that UI was most likely created using material design principles.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 材料设计使用材料层的概念，您可以将其视为照片编辑应用程序中的图层。一套原则、规则和指南实现了一致性。必须强调材料设计完全是可选的，但也必须强调材料设计是有效的，如果您不遵循它，用户很可能不喜欢您的设计。毕竟，用户已经习惯了某种类型的UI，而该UI很可能是使用材料设计原则创建的。
- en: So, material design is a sensible standard to strive for, but while we are learning
    the details of material design, we mustn't let it hold us back from learning how
    to get started with Android.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，材料设计是一个值得努力的合理标准，但在学习材料设计的细节时，我们不应该让它阻碍我们学习如何开始使用安卓。
- en: This book will focus on getting things done, while occasionally pointing out
    when material design is influencing how we do it, as well as pointing you to further
    resources for those who want to look at material design in more depth right away.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将专注于完成任务，同时偶尔指出材料设计如何影响我们的做法，并指向更深入了解材料设计的进一步资源。
- en: Exploring Android UI design
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索安卓UI设计
- en: We will see with Android UI design that so much of what we learn is context-sensitive.
    The way that a given widget's x attribute will influence its appearance might
    depend on a widget's y attribute, or even on an attribute on another widget. It
    isn't easy to learn this verbatim. It is best to expect to gradually achieve better
    and faster results with practice.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到在安卓UI设计中，我们学到的很多东西都是依赖上下文的。给定小部件的x属性如何影响其外观可能取决于小部件的y属性，甚至取决于另一个小部件的属性。这并不容易直接学习。最好期望通过实践逐渐取得更好和更快的结果。
- en: For example, if you play with the designer by dragging and dropping widgets
    onto the design, the XML code that is generated will vary considerably depending
    upon which layout type you are using. We will see this as we proceed through this
    chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您通过将小部件拖放到设计中来玩转设计师，生成的XML代码将根据您使用的布局类型而有很大不同。随着我们在本章中的进行，我们将看到这一点。
- en: This is because different layout types use different means to decide the position
    of their children. For example, the `LinearLayout`, which we will explore next,
    works very differently to `ConstraintLayout`, which was added by default to our
    project in [Chapter 1](ch01.html "Chapter 1. Getting Started with Android and
    Kotlin"), *Getting Started with Android and Kotlin*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为不同的布局类型使用不同的方法来决定其子元素的位置。例如，我们将在下一节中探索的`LinearLayout`与我们项目中默认添加的`ConstraintLayout`的工作方式完全不同，[第1章](ch01.html
    "第1章.开始使用安卓和Kotlin")中已经介绍了*开始使用安卓和Kotlin*。
- en: This information might initially seem like a problem, or even a bad idea, and
    it certainly can be a little awkward. What we will begin to learn, however, is
    that this clear abundance of layout options and their individual quirks are a
    good thing, because they give us almost unlimited design potential. There are
    very few layouts you can imagine that are not possible to achieve.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息可能起初看起来像是一个问题，甚至是一个坏主意，当然可能有点尴尬。然而，我们将开始学习的是，这种清晰的布局选项的丰富性及其各自的怪癖是一件好事，因为它们为我们提供了几乎无限的设计潜力。您几乎可以想象不可能实现的布局很少。
- en: As implied, however, this almost unlimited potential comes with a bit of complexity.
    The best way to start to get to grips with this is to build some working examples
    of several types. In this chapter, we will see three – a `LinearLayout`, a `ConstraintLayout`,
    and a `TableLayout`. We will see how to make things easier using the distinctive
    features of the visual designer, and we will also pay some attention to the XML
    that is auto-generated to make our understanding more rounded.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如所暗示的，这种几乎无限的潜力伴随着一些复杂性。开始掌握这一点的最佳方法是构建几种类型的工作示例。在本章中，我们将看到三种 - `LinearLayout`，`ConstraintLayout`和`TableLayout`。我们将看到如何使用可视化设计师的独特功能使事情变得更容易，并且我们还将对自动生成的XML进行一些关注，以使我们的理解更全面。
- en: Layouts
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: We have already seen `ConstraintLayout,` but there are more. Layouts are the
    building blocks that group together the other UI elements/widgets. Layouts can,
    and often do, contain other layouts themselves.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`ConstraintLayout`，但还有更多。布局是将其他UI元素/小部件组合在一起的构建块。布局本身可以包含其他布局。
- en: Let's look at some commonly used layouts in Android, because knowing the different
    layouts and their pros and cons will make us more aware of what can be achieved,
    and therefore will expand our horizons of what is possible.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些在Android中常用的布局，因为了解不同的布局及其优缺点将使我们更加了解可以实现什么，因此将扩展我们对可能性的认识。
- en: We have already seen that, once we have designed a layout, we can put it into
    action using the `setContentView` function in our Kotlin code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，一旦我们设计了一个布局，我们就可以在Kotlin代码中使用`setContentView`函数将其付诸实践。
- en: Let's build three designs with different layout types and then put `setContentView`
    to work and switch between them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用不同的布局类型构建三种设计，然后将`setContentView`付诸实践并在它们之间切换。
- en: Creating the Exploring Layouts project
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建“探索布局”项目
- en: 'One of the toughest things in Android is not just finding out how to do something,
    but finding out how to do something amongst other things. That is why, throughout
    this book, as well as showing you how to do some neat stuff, we will link lots
    of topics together into apps that span multiple topics and often chapters. The
    **Exploring Layouts** project is the first app of this type. We will learn how
    to build multiple types of layout while linking them all together in one handy
    app:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中最困难的事情之一不仅是找出如何做某事，而是在其他事物中找出如何做某事。这就是为什么在本书中，除了向您展示如何做一些很酷的东西之外，我们还将把许多主题链接到跨越多个主题和章节的应用程序中。**探索布局**项目是这种类型的第一个应用程序。我们将学习如何构建多种类型的布局，同时将它们全部链接在一个方便的应用程序中：
- en: Create a new project in Android Studio. If you already have a project open,
    select **File** | **New Project**. When prompted, choose **Open in same window**,
    as we do not need to refer to our previous project.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新项目。如果您已经打开了一个项目，请选择**文件** | **新建项目**。在提示时，选择**在同一窗口中打开**，因为我们不需要参考我们之前的项目。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are on the start screen of Android Studio, you can create a new project
    simply by clicking the **Start a new Android Studio project** option.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Android Studio的启动屏幕上，只需点击**开始新的Android Studio项目**选项即可创建一个新项目。
- en: Select the **Empty Activity** project template, as we will build most of the
    UI from scratch. Click the **Next** button.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**空活动**项目模板，因为我们将从头开始构建大部分UI。点击**下一步**按钮。
- en: Enter `Exploring Layouts` for the name of the project.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为项目命名为“探索布局”。
- en: All the rest of the settings are the same as we have used for the previous three
    projects.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其余所有设置与我们之前使用的三个项目相同。
- en: Click the **Finish** button.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**完成**按钮。
- en: 'Look at the `MainActivity.kt` file. Here is the entirety of the code, excluding
    the `import…` statements:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`MainActivity.kt`文件。以下是整个代码，不包括`import…`语句：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Locate the call to `setContentView` and delete the entire line. The line is
    shown highlighted in the previous code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 找到`setContentView`的调用并删除整行。该行在上一个代码中显示为高亮显示。
- en: This is just what we want, because now we can build our very own layouts, explore
    the underlying XML, and write our own Kotlin code to display these layouts. If
    you run the app now, you will just get a blank screen with a title; not even a
    Hello World! message.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们想要的，因为现在我们可以构建自己的布局，探索底层的XML，并编写自己的Kotlin代码来显示这些布局。如果您现在运行该应用程序，您将只获得一个带有标题的空白屏幕；甚至没有“Hello
    World！”消息。
- en: The first type of layout we will explore is the `LinearLayout`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的第一种布局类型是`LinearLayout`。
- en: Building a menu with LinearLayout
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LinearLayout构建菜单
- en: '`LinearLayout` is probably the simplest layout that Android offers. As the
    name suggests, all the UI items within it are laid out linearly. You have just
    two choices – vertical and horizontal. By adding the following line of code (or
    editing via the Attribute window), you can configure a `LinearLayout` to lay things
    out vertically:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearLayout`可能是Android提供的最简单的布局。顾名思义，其中的所有UI项都是线性布局的。您只有两个选择 - 垂直和水平。通过添加以下代码行（或通过属性窗口进行编辑），您可以配置`LinearLayout`以垂直布局：'
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can then (as you could probably have guessed) change `"vertical"` to `"horizontal"`
    to lay things out horizontally.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后（您可能已经猜到了）将“vertical”更改为“horizontal”以水平布局。
- en: Before we can do anything with `LinearLayout`, we need to add one to a layout
    file. And, as we are building three layouts in this project, we also need a new
    layout file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以对`LinearLayout`执行任何操作之前，我们需要将其添加到布局文件中。而且，由于我们在此项目中构建了三个布局，因此我们还需要一个新的布局文件。
- en: Adding a LinearLayout to the project
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向项目添加LinearLayout
- en: 'In the project window, expand the `res` folder. Now right-click the `layout`
    folder and select **New**. Notice that there is an option for **Layout resource**
    **file,** as shown in the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目窗口中，展开`res`文件夹。现在右键单击`layout`文件夹，然后选择**New**。注意到有一个**Layout resource file**选项，如下截图所示：
- en: '![Adding a LinearLayout to the project](img/B12806_04_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![将LinearLayout添加到项目](img/B12806_04_03.jpg)'
- en: 'Select **Layout resource file** and you will see the **New Resource File**
    dialog window:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**Layout resource file**，然后会看到**New Resource File**对话框窗口：
- en: '![Adding a LinearLayout to the project](img/B12806_04_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![将LinearLayout添加到项目](img/B12806_04_04.jpg)'
- en: In the **File name** field, enter `main_menu`. The name is arbitrary, but this
    layout is going to be our "main" menu that is used to select the other layouts,
    so the name seems appropriate.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在**File name**字段中输入`main_menu`。名称是任意的，但这个布局将成为我们的“主”菜单，用于选择其他布局，所以这个名称似乎合适。
- en: Notice that it has already selected **LinearLayout** as the **Root** **element**
    option.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它已经选择了**LinearLayout**作为**Root** **element**选项。
- en: Click the **OK** button, and Android Studio will generate a new `LinearLayout`
    in an XML file called `main_menu` and place it in the `layout` folder ready for
    us to build our new main menu UI. Android Studio will also open the UI designer
    with the palette on the left and the attributes window on the right.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 单击**OK**按钮，Android Studio将在名为`main_menu`的XML文件中生成一个新的`LinearLayout`，并将其放置在`layout`文件夹中，准备好构建我们的新主菜单UI。Android
    Studio还将打开带有左侧调色板和右侧属性窗口的UI设计器。
- en: Preparing your workspace
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作区
- en: 'Adjust the windows by dragging and resizing their borders (as you can in most
    windowed apps) to make the palette, design, and attributes as clear as possible,
    but no bigger than necessary. This small screenshot shows the approximate window
    proportions I chose to make designing our UI and exploring the XML as clear as
    possible. The detail in the screenshot is not important:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拖动和调整窗口边界的大小（就像大多数窗口化应用程序一样），调整窗口的大小，使调色板、设计和属性尽可能清晰，但不要超出必要的范围。这个小截图显示了我选择的大致窗口比例，以使设计我们的UI和探索XML尽可能清晰。截图中的细节并不重要：
- en: '![Preparing your workspace](img/B12806_04_05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作区](img/B12806_04_05.jpg)'
- en: Observe that I have made the project, palette, and attribute windows as narrow
    as possible, yet without obscuring any content. I have also closed the build/logcat
    window at the bottom of the screen, the result being that I have a nice clear
    canvas on which to build the UI.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我已经尽可能地缩小了项目、调色板和属性窗口，但没有遮挡任何内容。我还关闭了屏幕底部的构建/logcat窗口，结果是我有一个很清晰的画布来构建UI。
- en: Examining the generated XML
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查生成的XML
- en: 'Click on the **Text** tab and we will have a look at the current state of the
    XML code that forms our design at this stage. Here is the code so that we can
    discuss this further:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 单击**Text**选项卡，我们将查看当前阶段形成我们设计的XML代码的当前状态。以下是代码，以便我们进一步讨论：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have the usual starting and closing tags and, as we could have predicted,
    they are `<LinearLayout` and `</LinearLayout>`. There is no child element yet,
    but there are three attributes. We know they are attributes, and not children,
    of the `LinearLayout`, because they appear before the first closing `>`. The three
    attributes that define this `LinearLayout` have been highlighted in the previous
    code for clarity.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有通常的起始和结束标签，正如我们可以预测的那样，它们是`<LinearLayout`和`</LinearLayout>`。目前还没有子元素，但有三个属性。我们知道它们是`LinearLayout`的属性，而不是子元素，因为它们出现在第一个闭合`>`之前。为了清晰起见，前面的代码中突出显示了定义这个`LinearLayout`的三个属性。
- en: The first attribute is `android:orientation`, or, more succinctly, we will just
    refer to the attributes without the `android:` part. The `orientation` attribute
    has a value of `vertical`. This means that, when we start to add items to this
    layout, it will arrange them vertically from top to bottom. We could change the
    value from `vertical` to `horizontal` and it would lay things out from left to
    right.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个属性是`android:orientation`，或者更简洁地说，我们将只是提到没有`android:`部分的属性。`orientation`属性的值是`vertical`。这意味着，当我们开始向这个布局添加项目时，它将垂直地从上到下排列它们。我们可以将值从`vertical`更改为`horizontal`，它将从左到右布局。
- en: The next two attributes are `layout_width` and `layout_height`. These determine
    the size of the `LinearLayout`. The value given to both attributes is `match_parent`.
    The parent of a layout is the entire available space. By matching the parent horizontally
    and vertically, therefore, the layout will fill the entire space available.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个属性是`layout_width`和`layout_height`。这些属性确定了`LinearLayout`的大小。给定给这两个属性的值都是`match_parent`。布局的父级是整个可用空间。因此，通过水平和垂直匹配父级，布局将填充整个可用空间。
- en: Adding a TextView to the UI
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向UI添加一个TextView
- en: Switch back to the **Design** tab and we will add some elements to the UI.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回**Design**选项卡，我们将向UI添加一些元素。
- en: First, find the **TextView** in the palette. This can be found in both the **Common**
    and **Text** categories. Left-click and drag the **TextView** onto the UI, and
    notice that it sits neatly at the top of the `LinearLayout`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在调色板中找到**TextView**。这可以在**Common**和**Text**类别中找到。左键单击并将**TextView**拖放到UI上，注意它整齐地位于`LinearLayout`的顶部。
- en: 'Look at the XML on the **Text** tab and confirm that it is a child of the `LinearLayout`
    and that it is indented by one tab to make this clear. Here is the code for the
    `TextView` without the surrounding code for the `LinearLayout`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 查看**Text**选项卡上的XML，并确认它是`LinearLayout`的子元素，并且缩进了一个制表符以清晰地表示这一点。以下是`TextView`的代码，没有周围的`LinearLayout`代码：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that it has four attributes: `id`, in case we need to refer to it from
    another UI element or from our Kotlin code; `layout_width` is set to `match_parent`,
    which means the that `TextView` stretches across the whole width of the `LinearLayout`;
    a `layout_height` attribute is set to `wrap_content`, which means the that `TextView`
    is precisely tall enough to contain the text within it; and finally, for now,
    it has a `text` element that determines the actual text it will display, and this
    is currently just set to `TextView.`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它有四个属性：`id`，以防我们需要从另一个UI元素或我们的Kotlin代码中引用它；`layout_width`设置为`match_parent`，这意味着`TextView`横跨整个`LinearLayout`的宽度；`layout_height`属性设置为`wrap_content`，这意味着`TextView`的高度恰好足够容纳其中的文本；最后，目前，它具有一个`text`元素，用于确定它将显示的实际文本，目前仅设置为`TextView`。
- en: Switch back to the design tab and we will make some changes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回设计选项卡，我们将进行一些更改。
- en: 'We want this text to be the heading text of this screen, which is the main
    menu screen. In the attributes window, click the search icon, type `text` into
    the search box, and change the **text** attribute to `Menu`, as shown in the following
    screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这段文本成为此屏幕的标题文本，即主菜单屏幕。在属性窗口中，单击搜索图标，输入`text`到搜索框中，并将**text**属性更改为`Menu`，如下截图所示：
- en: '![Adding a TextView to the UI](img/B12806_04_06.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![将TextView添加到UI](img/B12806_04_06.jpg)'
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find any attribute by searching or just by scrolling through the options.
    When you have found the attribute you want to edit, left-click it to select it
    and then press the *Enter* key on the keyboard to make it editable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过搜索或滚动选项来查找任何属性。找到要编辑的属性后，左键单击选择它，然后按键盘上的*Enter*键使其可编辑。
- en: Next, find the `textSize` attribute using your preferred search technique and
    set `textSize` to `50sp`. When you have entered this new value, the text size
    will increase.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用您喜欢的搜索技术找到`textSize`属性，并将`textSize`设置为`50sp`。输入新值后，文本大小将增加。
- en: The `sp` stands for scalable pixels. This means that when the user changes the
    font size settings on their Android device, the font will dynamically rescale
    itself.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`sp`代表可伸缩像素。这意味着当用户在其Android设备上更改字体大小设置时，字体将动态重新调整大小。'
- en: 'Now, search for the **gravity** attribute and expand the options by clicking
    the little arrow indicated in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，搜索**gravity**属性，并通过单击以下截图中指示的小箭头展开选项：
- en: '![Adding a TextView to the UI](img/B12806_04_07.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![将TextView添加到UI](img/B12806_04_07.jpg)'
- en: 'Set **gravity** to **center_horizontal,** as shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将**gravity**设置为**center_horizontal**，如下截图所示：
- en: '![Adding a TextView to the UI](img/B12806_04_08.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![将TextView添加到UI](img/B12806_04_08.jpg)'
- en: The `gravity` attribute refers to the gravity within the `TextView` itself,
    and our change has the effect of moving the actual text inside the `TextView`
    to the center.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`gravity`属性指的是`TextView`本身的重力，我们的更改会使`TextView`内的实际文本移动到中心。'
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Note that `gravity` is different to `layout_gravity`. The `layout_gravity`
    property sets the gravity within the layout: in this case, the parent `LinearLayout`.
    We will use `layout_gravity` later in this project.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`gravity`与`layout_gravity`是不同的。`layout_gravity`属性设置了布局内的重力：在这种情况下，是父`LinearLayout`。我们将在项目的后续部分使用`layout_gravity`。
- en: 'At this point, we have changed the text of the `TextView`, increased its size,
    and centered it horizontally. The UI designer should now look like the following
    diagram:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已更改了`TextView`的文本，增加了其大小，并使其水平居中。UI设计师现在应该如下图所示：
- en: '![Adding a TextView to the UI](img/B12806_04_09.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![将TextView添加到UI](img/B12806_04_09.jpg)'
- en: 'A quick glance at the **Text** tab to see the XML would reveal the following
    code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 快速浏览**Text**选项卡，查看XML代码，会发现以下代码：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can see the new attributes as follows: `gravity`, which is set to `center_horizontal`;
    text, which has changed to `Menu`; and `textSize`, which is set to `50sp`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到新的属性如下：`gravity`设置为`center_horizontal`；文本更改为`Menu`；`textSize`设置为`50sp`。
- en: If you run the app, you might not see what you expected. This is because we
    haven't called `setContentView` in our Kotlin code to load the UI. You will still
    see the blank UI. We will fix this once we have made a bit more progress with
    the UI.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行应用程序，可能看不到预期的效果。这是因为我们在Kotlin代码中没有调用`setContentView`来加载UI。您仍然会看到空白的UI。我们将在UI有了更多进展后解决这个问题。
- en: Adding a multi-line TextView to the UI
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将多行TextView添加到UI
- en: Switch back to **Design** tab, find the **Multiline Text** in the **Text** category
    of the palette, and drag it onto the design just below the `TextView` we added
    a moment ago.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回**Design**选项卡，在调色板的**Text**类别中找到**Multiline Text**，并将其拖放到刚刚添加的`TextView`下方的设计中。
- en: Using your preferred search technique, set **text** to `Select a layout type
    to view an example. The onClick attribute of each button will call a function
    which executes setContentView to load the new layout`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的搜索技术，将**text**设置为`选择布局类型以查看示例。每个按钮的onClick属性将调用一个函数，该函数执行setContentView以加载新布局`。
- en: 'Your layout will now look like the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您的布局现在将如下截图所示：
- en: '![Adding a multi-line TextView to the UI](img/B12806_04_10.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![将多行TextView添加到UI](img/B12806_04_10.jpg)'
- en: 'Your XML will be updated with another child in the `LinearLayout`, after the
    `TextView`, that looks like the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您的XML将在`TextView`之后的`LinearLayout`中更新为另一个子元素，代码如下：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see the details of the UI item and it turns out that the description
    on the palette of **Multiline Text** was not entirely obvious as to exactly what
    this would be. A look at the XML reveals that we have an `inputType` attribute,
    indicating that this text is editable by the user. There is also another attribute
    that we haven't seen before, and that is `ems`. The `ems` attribute controls how
    many characters can be entered per line, and the value of `10` was chosen automatically
    by Android Studio. However, another attribute, `layout_width="match_parent"`,
    overrides this value because it causes the element to expand to fit its parent;
    in other words, to cover the whole width of the screen.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看UI项的详细信息，结果发现**多行文本**的调色板上的描述并不明显，究竟是什么。查看XML后，我们发现有一个`inputType`属性，表示用户可以编辑此文本。还有另一个我们以前没有见过的属性，那就是`ems`。`ems`属性控制每行可以输入多少个字符，而`10`的值是Android
    Studio自动选择的。然而，另一个属性`layout_width="match_parent"`覆盖了这个值，因为它使元素扩展以适应其父元素；换句话说，覆盖整个屏幕的宽度。
- en: When you run the app (in the next section), you will see that the text is, indeed,
    editable – although, for the purposes of this demo app, it serves no practical
    purpose.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行应用程序（在下一节中），您将看到文本确实是可编辑的-尽管对于这个演示应用程序的目的来说，它没有实际用途。
- en: Wiring up the UI with the Kotlin code (part 1)
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用Kotlin代码连接UI（第1部分）
- en: 'To achieve an interactive app, we will do the following three things:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个交互式的应用程序，我们将做以下三件事：
- en: We will call `setContentView` from the `onCreate` function to show the progress
    of our UI when we run the app.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从`onCreate`函数中调用`setContentView`来显示我们运行应用程序时的UI进度。
- en: We will write two more functions of our own and each one will call `setContentView`
    on a different layout (that we have yet to design).
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将编写另外两个我们自己的函数，每个函数将在不同的布局上调用`setContentView`（我们还没有设计）。
- en: Then, later in this chapter, when we design two more UI layouts, we will be
    able to load them at the click of a button.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在本章后面，当我们设计另外两个UI布局时，我们将能够在点击按钮时加载它们。
- en: As we will be building a `ConstraintLayout` and a `TableLayout`, we will call
    our new functions, `loadConstraintLayout` and `loadTableLayout`, respectively.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将构建一个`ConstraintLayout`和一个`TableLayout`，所以我们将分别调用我们的新函数`loadConstraintLayout`和`loadTableLayout`。
- en: Let's do that now, and then we'll see how we can add some buttons that call
    these functions alongside some neatly formatted text.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们这样做，然后我们将看到如何添加一些按钮，调用这些函数以及一些整齐格式的文本。
- en: 'Inside the `onCreate` function, add the following highlighted code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`函数中，添加以下突出显示的代码：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The code uses the `setContentView` function to load the UI we are currently
    working on. You can now run the app to see the following results:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码使用`setContentView`函数来加载我们当前正在工作的UI。现在您可以运行应用程序，看到以下结果：
- en: '![Wiring up the UI with the Kotlin code (part 1)](img/B12806_04_11.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![用Kotlin代码连接UI（第1部分）](img/B12806_04_11.jpg)'
- en: 'Add these two new functions inside the `MainActivity` class after the `onCreate`
    function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`类的`onCreate`函数之后，添加这两个新函数：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There is one error with the first function and two with the second. The first
    we can fix by adding an `import` statement so that Android Studio is aware of
    the `View` class. Left-click the word `View` to select the error. Hold down the
    *Alt* key and then tap the *Enter* key. You will see the following popup:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数有一个错误，第二个函数有两个错误。第一个我们可以通过添加一个`import`语句来修复，以便Android Studio意识到`View`类。左键单击`View`单词选择错误。按住*Alt*键，然后点击*Enter*键。您将看到以下弹出窗口：
- en: '![Wiring up the UI with the Kotlin code (part 1)](img/B12806_04_12.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![用Kotlin代码连接UI（第1部分）](img/B12806_04_12.jpg)'
- en: 'Chose **Import class**. The error is now gone. If you scroll to the top of
    the code, you will see that a new line of code has been added by that shortcut
    we just performed. Here is the new code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**导入类**。错误现在已经消失。如果您滚动到代码的顶部，您将看到刚才执行的快捷方式添加了一行新代码。以下是新代码：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Android Studio no longer considers the `View` class an error.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio不再将`View`类视为错误。
- en: 'The second function still has an error, however. The problem is that the function
    calls the `setContentView` function to load a new UI (`R.layout.my_table_layout`).
    As this UI layout does not exist yet, it produces an error. You can comment out
    this call to remove the error until we create the file and design the UI layout
    later this chapter. Add the double forward slash (`//`), as highlighted in the
    following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第二个函数仍然有一个错误。问题在于该函数调用`setContentView`函数来加载一个新的UI（`R.layout.my_table_layout`）。由于此UI布局尚不存在，因此会产生错误。您可以注释掉此调用以消除错误，直到我们在本章后面创建文件并设计UI布局。添加双斜杠（`//`），如下面的代码中所突出显示的那样：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now we can add some buttons that we can click to call our new functions and
    load the new layouts we will be building soon. But adding a couple of buttons
    with some text on is too easy – we have done that before. What we want to do is
    line up some text with a button to the right of it. The problem is that our `LinearLayout`
    has the `orientation` attribute set to `vertical` and, as we have seen, all the
    new parts we add to the layout will be lined up vertically.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加一些按钮，我们可以点击这些按钮来调用我们的新函数，并加载我们即将构建的新布局。但是，添加一对带有一些文本的按钮太容易了-我们以前已经做过了。我们想要做的是将一些文本与按钮对齐，使其位于文本的右侧。问题在于我们的`LinearLayout`的`orientation`属性设置为`vertical`，正如我们所见，我们添加到布局中的所有新部分都将垂直排列。
- en: Adding layouts within layouts
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在布局中添加布局
- en: The solution to laying out some elements with a different orientation to others
    is to nest layouts within layouts. Here is how to do it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将一些元素以不同方向布局的解决方案是在布局中嵌套布局。以下是如何做到的。
- en: 'From the **Layouts** category of the palette, drag a **LinearLayout (Horizontal)**
    onto the design, placing it just below the **Multiline Text**. Notice that there
    is a blue border occupying all the space below the **Multiline Text**:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从调色板的**布局**类别中，将**LinearLayout（水平）**拖放到设计中，将其放置在**多行文本**的下方。注意，有一个蓝色边框占据了**多行文本**下方的所有空间：
- en: '![Adding layouts within layouts](img/B12806_04_13.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![在布局中添加布局](img/B12806_04_13.jpg)'
- en: This indicates that our new **LinearLayout (Horizontal)** is filling the space.
    Keep this blue border area in mind, as it is where we will put the next item on
    our UI.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们的新**LinearLayout（水平）**正在填充空间。请记住这个蓝色边框区域，因为我们将在UI上放置下一个项目。
- en: 'Now, go back to the **Text** category of the palette and drag a **TextView**
    onto the new `LinearLayout` we just added. Notice how the `TextView` sits snuggly
    in the top left-hand corner of the new `LinearLayout`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，返回到调色板的**Text**类别，并将一个**TextView**拖放到我们刚刚添加的新**LinearLayout**中。请注意，`TextView`紧密地位于新`LinearLayout`的左上角：
- en: '![Adding layouts within layouts](img/B12806_04_14.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![在布局中添加布局](img/B12806_04_14.jpg)'
- en: At first, this seems no different to what happened with the previous vertical
    `LinearLayout` that was part of our UI from the start. But watch what happens
    when we add our next piece of the UI.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这似乎与我们UI中一开始的垂直`LinearLayout`发生的情况没有什么不同。但是当我们添加UI的下一个部分时，看看会发生什么。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The term used to refer to adding layouts within layouts is **nesting**. The
    Android term applied to any item that appears on the UI (buttons and text, for
    example) is **view**, and anything that contains views is a **view group.** As
    the terms **view** and **view group** do not always make their meanings clear
    in certain contexts, I will usually refer to parts of the UI either specifically
    (such as `TextView`, `Button`, and `LinearLayout`) or more broadly (UI element,
    item, or widget).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 用于指代在布局中添加布局的术语是**嵌套**。应用于UI上的任何项目（例如按钮和文本）的Android术语是**视图**，而包含视图的任何内容都是**视图组**。由于**视图**和**视图组**这两个术语在某些情境下并不总是清晰表达其含义，我通常会具体指称UI的部分（如`TextView`、`Button`和`LinearLayout`）或更广泛地（UI元素、项目或小部件）。
- en: 'From the **Button** category, drag a **Button** onto the right-hand side of
    the previous `TextView`. Notice that the button sits to the right of the text,
    as shown in the following screenshot:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从**Button**类别中，将一个**Button**拖放到先前`TextView`的右侧。请注意，按钮位于文本的右侧，如下图所示：
- en: '![Adding layouts within layouts](img/B12806_04_15.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![在布局中添加布局](img/B12806_04_15.jpg)'
- en: 'Next, select the `LinearLayout` (the horizontal one) by clicking on an empty
    part of it. Find the `layout_height` attribute and set it to `wrap_content`. Observe
    that the `LinearLayout` is now taking up only as much space as it needs:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过单击其空白部分选择`LinearLayout`（水平的）。找到`layout_height`属性并将其设置为`wrap_content`。注意，`LinearLayout`现在只占用所需的空间：
- en: '![Adding layouts within layouts](img/B12806_04_16.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![在布局中添加布局](img/B12806_04_16.jpg)'
- en: Let's configure the text attribute of the `TextView` and the `Button` before
    we add the next part of the UI. Change the `text` attribute of the `Button` to
    `LOAD`. Change the text attribute of our new `TextView` to `Load ConstraintLayout`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加UI的下一部分之前，让我们配置`TextView`和`Button`的`text`属性。将`Button`的`text`属性更改为`LOAD`。将我们的新`TextView`的文本属性更改为`Load
    ConstraintLayout`。
- en: Tip
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Did you work out how to achieve the previous instruction for yourself? Yes?
    Excellent! You are now familiar with editing attributes of Android views. No?
    Left-click the item you want to edit (in this case, the `TextView`), search using
    the search icon or scroll to find the attribute you want to edit in the **Attributes**
    window (in this case, the `text` attribute), select the attribute, and press *Enter*
    to edit it. I can now give more succinct instructions on how to build future UI
    projects, and this makes your journey to becoming an Android ninja much quicker.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你自己解决了如何实现之前的指令吗？是的？太棒了！现在你已经熟悉了编辑Android视图属性。没有？左键单击要编辑的项目（在本例中为`TextView`），使用搜索图标搜索或滚动查找要在**属性**窗口中编辑的属性（在本例中为`text`属性），选择属性，然后按*Enter*进行编辑。现在我可以更简洁地说明如何构建未来的UI项目，这将使你成为Android忍者的旅程更快。
- en: 'Now we can repeat ourselves and add another `TextView` and `Button` attribute
    within another **LinearLayout (Horizontal)** just below the one we have just finished.
    To do so, follow these steps in order:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以重复自己，在刚刚完成的另一个**LinearLayout（水平）**中添加另一个`TextView`和`Button`属性。要这样做，请按顺序执行以下步骤：
- en: Add another **LinearLayout (Horizontal)**, just below the previous one
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前一个下方再添加一个**LinearLayout（水平）**
- en: Add a **TextView** to the new `LinearLayout`
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的`LinearLayout`中添加一个**TextView**
- en: Change the `text` attribute of the `TextView` to `Load TableLayout`
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`TextView`的`text`属性更改为`Load TableLayout`
- en: Add a `Button` on the right-hand side of the `TextView`
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TextView`的右侧添加一个`Button`
- en: Change the `text` attribute of the `Button` to `LOAD`
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Button`的`text`属性更改为`LOAD`
- en: Resize the `LinearLayout` by changing the `layout_height` attribute to `wrap_content`
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`layout_height`属性更改为`wrap_content`来调整`LinearLayout`的大小
- en: Now we have two neatly (and horizontally) aligned texts and buttons.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个整齐（水平）对齐的文本和按钮。
- en: 'Just for fun, and for the sake of exploring the palette a bit more, find the
    **Widgets** category of the palette and drag a **RatingBar** onto the design just
    below the final `LinearLayout`. Now, your UI should look very similar to this
    next screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了好玩，也为了更多地探索调色板，找到调色板的**小部件**类别，并将一个**RatingBar**拖放到最终`LinearLayout`的下方。现在，你的UI应该看起来与下一个截图非常相似：
- en: '![Adding layouts within layouts](img/B12806_04_17.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![在布局中添加布局](img/B12806_04_17.jpg)'
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the previous two screenshots, I hadn't yet changed the `text` attribute of
    the two `Button` elements. Everything else should be the same as yours.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个截图中，我还没有更改两个`Button`元素的`text`属性。其他所有内容应该与你的一样。
- en: Let's add some visual finishing touches to the layout.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为布局添加一些视觉上的修饰。
- en: Making the layout look pretty
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使布局看起来漂亮
- en: 'In this section, we will explore some more attributes that control the finer
    details of our UI. You have probably noticed how the UI looks a bit squashed in
    some places, and wonky and unsymmetrical in others. As we progress through the
    book, we will continually add to our repertoire to improve our layouts, but these
    short steps will introduce and take care of some of the basics:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些控制UI细节的更多属性。您可能已经注意到UI在某些地方看起来有点挤，而在其他地方看起来不对称。随着我们在书中的进展，我们将不断增加我们的技能来改善我们的布局，但这些简短的步骤将介绍并处理一些基础知识：
- en: Select the `Multiline Text`, and then expand the `Padding` attribute. Set the
    `all` option to `15sp`. This has made a neat area of space around the outside
    of the text.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`多行文本`，然后展开`Padding`属性。将`all`选项设置为`15sp`。这样在文本周围留出了整洁的空间。
- en: To make a nice space below the `Multiline text`, find and expand the `Layout_Margin`
    attribute and set `bottom` to `100sp`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在`多行文本`下方留出一个漂亮的空间，找到并展开`Layout_Margin`属性，将`bottom`设置为`100sp`。
- en: On both `TextView` widgets that are aligned/related to the buttons, set the
    `textSize` attribute to `20sp`, the `layout_gravity` to `center_vertical`, the
    `layout_width` to `match_parent`, and the `layout_weight` to `.7`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与按钮对齐/相关的两个`TextView`小部件上，将`textSize`属性设置为`20sp`，`layout_gravity`设置为`center_vertical`，`layout_width`设置为`match_parent`，`layout_weight`设置为`.7`。
- en: On both buttons, set the weight to `.3`. Notice how both buttons now take up
    exactly `.3` of the width and the text `.7` of the `LinearLayout`, making the
    whole appearance more pleasing.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个按钮上，将权重设置为`.3`。注意现在两个按钮的宽度都是`.3`，文本占据`LinearLayout`的`.7`，整体外观更加美观。
- en: On the `RatingBar`, find the `Layout_Margin` attribute, and then set `left`
    and `right` to `15sp`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RatingBar`上，找到`Layout_Margin`属性，然后将`left`和`right`设置为`15sp`。
- en: Still with the `RatingBar` and the `Layout_Margin` attribute, change `top` to
    `75sp`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然使用`RatingBar`和`Layout_Margin`属性，将`top`更改为`75sp`。
- en: 'You can now run the app and see our first full layout in all its glory:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以运行应用程序，看到我们的第一个完整布局的全部荣耀。
- en: '![Making the layout look pretty](img/B12806_04_18.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![使布局看起来漂亮](img/B12806_04_18.jpg)'
- en: Notice that you can play with the `RatingBar`, although the rating won't persist
    when the app is turned off.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以玩`RatingBar`，尽管在关闭应用程序时评分不会保留。
- en: Tip
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: By way of a reader challenge, find an attribute or two that could further improve
    the appearance of the `LoadConstraintLayout` and `LoadTableLayout` text. They
    look a little bit close to the edges of the screen. Refer to the section Attributes
    – a quick summary at the start of [Chapter 5](ch05.html "Chapter 5. Beautiful
    Layouts with CardView and ScrollView"), *Beautiful Layouts with CardView and ScrollView*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 作为读者挑战，找到一个或两个属性，可以进一步改善`LoadConstraintLayout`和`LoadTableLayout`文本的外观。它们看起来离屏幕边缘有点近。参考[第5章](ch05.html
    "第5章。使用CardView和ScrollView创建美丽的布局")开头的快速摘要部分，*使用CardView和ScrollView创建美丽的布局*。
- en: Unfortunately, the buttons don't do anything yet. Let's fix that.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，按钮目前还没有功能。让我们解决这个问题。
- en: Wiring up the UI with the Kotlin code (part 2)
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kotlin代码连接UI（第2部分）
- en: Select the button next to the `Load ConstraintLayout` text. Find the `onClick`
    attribute and set it to `loadConstraintLayout`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`Load ConstraintLayout`文本旁边的按钮。找到`onClick`属性，将其设置为`loadConstraintLayout`。
- en: Select the button next to the `Load TableLayout` text. Find the `onClick` attribute
    and set it to `loadTableLayout`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`Load TableLayout`文本旁边的按钮。找到`onClick`属性，将其设置为`loadTableLayout`。
- en: Now, the buttons will call the functions, but the code inside the `loadTableLayout`
    function is commented out to avoid errors. Feel free to run the app and see that
    you can switch to the `ConstraintLayout` by clicking the `loadConstraintLayout`
    button. But all it has is a **Hello World** message.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按钮将调用函数，但`loadTableLayout`函数内的代码已被注释掉以避免错误。随时运行应用程序，看看您是否可以通过单击`loadConstraintLayout`按钮切换到`ConstraintLayout`。但它只有一个**Hello
    World**消息。
- en: We can now move on to building this `ConstraintLayout`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续构建这个`ConstraintLayout`。
- en: Building a precise UI with ConstraintLayout
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ConstraintLayout构建精确的UI
- en: Open the `ConstraintLayout` that was auto-generated when we created the project.
    It is probably already in a tab at the top of the editor. If not, it will be in
    the `res`/`layout` folder. Its name is `activity_main.xml`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 打开创建项目时自动生成的`ConstraintLayout`。它可能已经在编辑器顶部的选项卡中。如果没有，它将在`res`/`layout`文件夹中。它的名称是`activity_main.xml`。
- en: Inspect the XML in the **Text** tab and note that it is empty, apart from a
    `TextView` that says `Hello World`. Switch back to the **Design** tab, left-click
    the `TextView` to select it, and tap the *Delete* key to get rid of it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 检查**Text**选项卡中的XML，并注意它是空的，除了一个说`Hello World`的`TextView`。切换回**Design**选项卡，左键单击`TextView`以选择它，然后按*Delete*键将其删除。
- en: Now we can build ourselves a simple, yet intricate, UI. `ConstraintLayout` is
    very useful when you want to position parts of your UI very precisely and/or relative
    to the other parts.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以构建一个简单而复杂的UI。当您想要非常精确地定位UI的部分和/或相对于其他部分时，`ConstraintLayout`非常有用。
- en: Adding a CalenderView
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加日历视图
- en: To get started, look in the **Widgets** category of the palette and find the
    `CalenderView`. Drag and drop the `CalenderView` near the top and horizontally
    central. As you drag the `CalenderView` around, notice that it jumps/snaps to
    certain locations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在调色板的**Widgets**类别中找到`CalenderView`。将`CalenderView`拖放到靠近顶部且水平居中的位置。当您拖动`CalenderView`时，注意它会跳到某些位置。
- en: 'Also notice the subtle visual cues that show when the view is aligned. I have
    highlighted the horizontally central visual cue in the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意视图对齐时的微妙视觉提示。我在以下截图中突出显示了水平中心的视觉提示：
- en: '![Adding a CalenderView](img/B12806_04_19.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![添加日历视图](img/B12806_04_19.jpg)'
- en: Let go when it is horizontally central, as it is in the screenshot. Now, we
    will resize it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当它水平居中时，释放它，就像截图中一样。现在，我们将调整它的大小。
- en: Resizing a view in a ConstraintLayout
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在ConstraintLayout中调整视图大小
- en: 'Left-click and hold one of the corner squares that are revealed when you let
    go of the `CalenderView`, and drag inwards to decrease the size of the `CalenderView`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 左键单击并按住一个角落的方块，当你放开`CalenderView`时会显示出来，向内拖动以减小`CalenderView`的大小：
- en: '![Resizing a view in a ConstraintLayout](img/B12806_04_20.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![在ConstraintLayout中调整视图大小](img/B12806_04_20.jpg)'
- en: 'Reduce the size by about half and leave the `CalenderView` near the top, horizontally
    centered. You might need to reposition it a little after you have resized it,
    a bit like the following diagram:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将大小减小约一半，将`CalenderView`留在屏幕顶部，水平居中。在调整大小后，你可能需要重新调整一下位置，就像下面的图示一样：
- en: '![Resizing a view in a ConstraintLayout](img/B12806_04_21.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![在ConstraintLayout中调整视图大小](img/B12806_04_21.jpg)'
- en: You do not need to place the `CalenderView` in exactly the same place as me.
    The purpose of the exercise is to get familiar with the visual cues that inform
    you where you have placed it, not to create a carbon copy of my layout.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要把`CalenderView`放在和我完全一样的位置。练习的目的是熟悉指示你放置位置的视觉线索，而不是创建一个和我的布局一模一样的副本。
- en: Using the Component Tree window
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用组件树窗口
- en: Now look at the **Component Tree** window – the one to the left of the visual
    designer and below the palette. The component tree is a way of visualizing the
    layout of the XML, but without all the details.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看一下**组件树**窗口 - 就在可视化设计师的左边和调色板下面。组件树是一种可视化XML布局的方式，但没有所有的细节。
- en: In the following screenshot, we can see that the `CalenderView` is indented
    to the right of the `ConstraintLayout`, and is therefore a child. In the next
    UI we build, we will see that we sometimes need to take advantage of the **Component
    Tree** to build the UI.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，我们可以看到`CalenderView`向右缩进到`ConstraintLayout`的右侧，因此是一个子元素。在我们构建的下一个UI中，我们将看到我们有时需要利用**组件树**来构建UI。
- en: 'For now, I just want you to observe that there is a warning sign by our `CalenderView`.
    I have highlighted it in the following screenshot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我只是想让你观察一下我们的`CalenderView`旁边有一个警告标志。我在下面的截图中已经用颜色标出来了：
- en: '![Using the Component Tree window](img/B12806_04_22.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![使用组件树窗口](img/B12806_04_22.jpg)'
- en: The error says **This view is not constrained. It only has designtime positions,
    so it will jump to (0,0) at runtime unless you add the constraints**. Remember
    when we first added buttons to the screen in [Chapter 2](ch02.html "Chapter 2. Kotlin,
    XML, and the UI Designer"), *Kotlin, XML, and the UI Designer*, that they simply
    disappeared off to the top-left corner?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 错误提示说**此视图没有约束。它只有设计时的位置，因此在运行时会跳转到(0,0)，除非你添加约束**。还记得我们在[第2章](ch02.html "第2章
    Kotlin、XML和UI设计师")中首次将按钮添加到屏幕上时，它们只是简单地消失在左上角吗？
- en: Tip
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Run the app now and click on the **Load ConstraintLayout** button if you want
    to be reminded of this problem.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序，如果你想提醒自己这个问题，点击**加载ConstraintLayout**按钮。
- en: 'Now, we could fix this by clicking the **Infer constraints** button that we
    used in [Chapter 2](ch02.html "Chapter 2. Kotlin, XML, and the UI Designer"),
    *Kotlin, XML, and the UI Designer*. Here it is again as a reminder:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过点击**推断约束**按钮来修复这个问题，就像我们在[第2章](ch02.html "第2章 Kotlin、XML和UI设计师")中使用的那样，*Kotlin、XML和UI设计师*。这里再次提醒一下：
- en: '![Using the Component Tree window](img/B12806_04_23.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![使用组件树窗口](img/B12806_04_23.jpg)'
- en: But learning to add the constraints manually is worthwhile because it offers
    us more options and flexibility. And, as your layouts become more complex, there
    is always an item or two that doesn't behave as you want it to, and fixing it
    manually is nearly always necessary.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但学会手动添加约束是值得的，因为它为我们提供了更多的选项和灵活性。随着你的布局变得更加复杂，总会有一两个项目不按照你的意愿行事，手动修复几乎总是必要的。
- en: Adding constraints manually
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动添加约束
- en: 'Make sure that the `CalenderView` is selected and observe the four small circles
    at the top, bottom, left, and right:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`CalenderView`被选中，并观察顶部、底部、左侧和右侧的四个小圆圈：
- en: '![Adding constraints manually](img/B12806_04_24.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![手动添加约束](img/B12806_04_24.jpg)'
- en: These are the constraint handles. We can click and drag them to anchor them
    with other parts of the UI or the sides of the screen. By anchoring the `CalenderView`
    with the four edges of the screen, we can lock it into position when the app is
    run.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是约束手柄。我们可以点击并拖动它们，将它们锚定到UI的其他部分或屏幕的边缘。通过将`CalenderView`与屏幕的四个边缘锚定，我们可以在应用程序运行时将其锁定到位置。
- en: One at a time, click and drag the top handle to the top of the design, the right
    to the right of the design, the bottom to the bottom of the design, and the left
    to the left of the design.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 依次点击并拖动顶部手柄到设计的顶部，右侧手柄到设计的右侧，底部手柄到设计的底部，左侧手柄到设计的左侧。
- en: 'Observe that the `CalenderView` is now constrained in the center. Left-click
    and drag the `CalenderView` back to the upper part of the screen somewhere, as
    in the following diagram. Use the visual cues (also shown in the following screenshot)
    to make sure the `CalenderView` is horizontally centered:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到`CalenderView`现在被约束在中心。左键单击并拖动`CalenderView`回到屏幕的上部某个位置，就像下面的图示一样。使用视觉线索（也显示在下面的截图中）确保`CalenderView`水平居中：
- en: '![Adding constraints manually](img/B12806_04_25.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![手动添加约束](img/B12806_04_25.jpg)'
- en: At this stage, you could run the app and the `CalenderView` would be positioned
    as shown in the preceding screenshot.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可以运行应用程序，`CalenderView`将会被定位到前面截图中显示的位置。
- en: Let's add a couple more items to the UI and see how to constrain them.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向UI添加几个项目，并看看如何约束它们。
- en: Adding and constraining more UI elements
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和约束更多的UI元素
- en: Drag an `ImageView` from the **Widgets** category of the palette and position
    it below and to the left of the `CalenderView`. When you place the `ImageView`,
    a pop-up window will prompt you to choose an image. Select **Project** | **ic_launcher,**
    and then click **OK**.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从调色板的**小部件**类别中拖动一个`ImageView`，并将其放置在`CalenderView`的下方和左侧。当你放置`ImageView`时，会弹出一个窗口提示你选择一个图像。选择**项目**
    | **ic_launcher**，然后点击**确定**。
- en: 'Constrain the left-hand side of the `ImageView` and the bottom of the `ImageView`
    to the left and bottom of the UI, respectively. Here is the position you should
    be in now:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ImageView`的左侧和底部约束到UI的左侧和底部。现在，您应该处于以下位置：
- en: '![Adding and constraining more UI elements](img/B12806_04_26.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![添加和约束更多的UI元素](img/B12806_04_26.jpg)'
- en: 'The `ImageView` is constrained in the bottom-left corner. Now, grab the top
    constraint handle on the `ImageView` and drag it to the bottom constraint handle
    of the `CalenderView`. This is now the current situation:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageView`在左下角被约束。现在，抓住`ImageView`上的顶部约束手柄，并将其拖动到`CalenderView`的底部约束手柄。现在的情况是这样的：'
- en: '![Adding and constraining more UI elements](img/B12806_04_27.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![添加和约束更多的UI元素](img/B12806_04_27.jpg)'
- en: The `ImageView` is only constrained horizontally on one side, so is pinned/constrained
    to the left. It is also constrained vertically and equally between the `CalenderView`
    and the bottom of the UI.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageView`只在一个侧面水平约束，因此被固定/约束在左侧。它还在垂直方向上被约束，并且在`CalenderView`和UI的底部之间是均匀约束的。'
- en: 'Next, add a `TextView` to the right of the `ImageView`. Constrain the right
    of the `TextView` to the right of the UI and constrain the left of the `TextView`
    to the right of the `ImageView`. Constrain the top of the `TextView` to the top
    of the `ImageView` and constrain the bottom of the `TextView` to the bottom of
    the UI. Now you will be left with something resembling the following diagram:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`ImageView`的右侧添加一个`TextView`。将`TextView`的右侧约束到UI的右侧，并将`TextView`的左侧约束到`ImageView`的右侧。将`TextView`的顶部约束到`ImageView`的顶部，并将`TextView`的底部约束到UI的底部。现在，您将得到类似以下图表的东西：
- en: '![Adding and constraining more UI elements](img/B12806_04_28.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![添加和约束更多的UI元素](img/B12806_04_28.jpg)'
- en: Notice that all the warnings in the **Component Tree** window about unconstrained
    items are gone.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，**Component Tree**窗口中关于未约束项的所有警告都消失了。
- en: Note
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are warnings about hardcoded strings because we are adding text directly
    to the layout instead of the `strings.xml` file and a warning about missing the
    **contentDescription** attribute. The **contentDescription** attribute should
    be used to add a textual description so that visually impaired users can get a
    spoken description of images in the app. For the sake of making rapid progress
    with the `ConstraintLayout`, we will ignore these two warnings. We will look at
    adding string resources correctly in [Chapter 18,](ch18.html "Chapter 18. Localization")
    *Localization*, and you can read about accessibility features in Android Studio
    on the Android developer's website, at [https://developer.android.com/studio/intro/accessibility](https://developer.android.com/studio/intro/accessibility).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有关硬编码字符串的警告，因为我们直接向布局添加文本而不是`strings.xml`文件，并且有关缺少**contentDescription**属性的警告。**contentDescription**属性应该用于添加文本描述，以便视觉障碍用户可以在应用中获得图像的口头描述。为了快速推进`ConstraintLayout`，我们将忽略这两个警告。我们将在[第18章](ch18.html
    "第18章。本地化")*本地化*中正确添加字符串资源，并且您可以在Android开发者网站的Android Studio上阅读有关辅助功能的信息，网址为[https://developer.android.com/studio/intro/accessibility](https://developer.android.com/studio/intro/accessibility)。
- en: 'You can move the three UI elements around and line them up neatly, just how
    you want them. Notice that when you move the `ImageView`, the `TextView` moves
    with it because the `TextView` is constrained to the `ImageView`. But also notice
    that you can move the `TextView` independently, and wherever you drop it, this
    represents its new constrained position relative to the `ImageView`. Whatever
    an item is constrained to, its position will always be relative to that item.
    And, as we have seen, the horizontal and vertical constraints are distinct from
    each other. I positioned mine as shown in the following diagram:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以移动三个UI元素并将它们整齐地排列，就像您想要的那样。请注意，当您移动`ImageView`时，`TextView`也会随之移动，因为`TextView`被约束到`ImageView`。但也请注意，您可以独立移动`TextView`，并且无论您放置在哪里，这都代表了它相对于`ImageView`的新约束位置。无论项被约束到什么，其位置始终相对于该项。而且，正如我们所看到的，水平和垂直约束是彼此独立的。我将我的位置放置如下图所示：
- en: '![Adding and constraining more UI elements](img/B12806_04_29.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![添加和约束更多的UI元素](img/B12806_04_29.jpg)'
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '`ConstraintLayout` is the newest layout type, and, while it is more complex
    than the other layouts, it is the most powerful, as well as the one that runs
    the best on our user''s device. It is worth spending more time looking at some
    more tutorials about `ConstraintLayout`. Especially look on YouTube, as video
    is a great medium to learn about tweaking `ConstraintLayout`. We will return to
    `ConstraintLayout` throughout the book, and you do not need to know any more than
    we have covered already to be able to move on.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConstraintLayout`是最新的布局类型，虽然它比其他布局更复杂，但它是最强大的，也是在用户设备上运行最好的。值得花更多时间查看有关`ConstraintLayout`的更多教程。特别是在YouTube上查看，因为视频是学习调整`ConstraintLayout`的好方法。我们将在整本书中回到`ConstraintLayout`，而且您不需要知道比我们已经涵盖的更多内容才能继续前进。'
- en: Making the text clickable
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使文本可点击
- en: We are nearly done with our `ConstraintLayout`. We just want to wire up a link
    back to the main menu screen. This is a good opportunity to demonstrate that `TextView`
    (and most other UI items) are also clickable. In fact, clickable text is probably
    more common in modern Android apps than conventional-looking buttons.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了我们的`ConstraintLayout`。我们只想要将一个链接返回到主菜单屏幕。这是一个很好的机会来演示`TextView`（以及大多数其他UI项）也是可点击的。实际上，可点击的文本在现代Android应用程序中可能比传统的按钮更常见。
- en: Change the `text` attribute of the `TextView` to `Back to the menu`. Now, find
    the `onClick` attribute and enter `loadMenuLayout`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 将`TextView`的`text`属性更改为`返回菜单`。现在，找到`onClick`属性并输入`loadMenuLayout`。
- en: 'Now, add the following function to the `MainActivity.kt` file just after the
    `loadTableLayout` function, as highlighted here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`MainActivity.kt`文件中添加以下函数，就在`loadTableLayout`函数之后，如下所示：
- en: '[PRE10]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, whenever the user clicks the `Back to the menu` text, the `loadMenuLayout`
    function will be called and the `setContentView function` will load the layout
    in `main_menu.xml`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当用户点击“返回菜单”文本时，`loadMenuLayout`函数将被调用，`setContentView`函数将加载`main_menu.xml`中的布局。
- en: You can run the app, and click back and forth between the main menu (`LinearLayout`)
    and the `CalenderView` widget (`ConstraintLayout`).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行应用程序，在主菜单（`LinearLayout`）和`CalenderView`小部件（`ConstraintLayout`）之间来回切换。
- en: Let's build the final layout for this chapter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为本章构建最终的布局。
- en: Laying out data with TableLayout
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TableLayout布局数据
- en: In the project window, expand the `res` folder. Now, right-click the `layout`
    folder and select **New**. Notice that there is an option for **Layout resource**
    **file**.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目窗口中，展开`res`文件夹。现在，右键单击`layout`文件夹，然后选择**新建**。注意，有一个**布局资源文件**的选项。
- en: Select **Layout resource file**, and you will see the **New Resource File**
    dialog window.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**布局资源文件**，你会看到**新建资源文件**对话框窗口。
- en: In the **File name** field, enter `my_table_layout`. This is the same name we
    used in the call to `setContentView` within the `loadTableLayout` function.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在**文件名**字段中输入`my_table_layout`。这与我们在`loadTableLayout`函数中调用`setContentView`时使用的名称相同。
- en: Notice that it has already selected **LinearLayout** as the **Root** element
    option. Delete `LinearLayout` and type `TableLayout` in its place.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它已经选择了**LinearLayout**作为**根**元素选项。删除`LinearLayout`，并在其位置键入`TableLayout`。
- en: Click the **OK** button and Android Studio will generate a new `TableLayout`
    in an XML file called `my_table_layout` and place it in the `layout` folder ready
    for us to build our new table-based UI. Android Studio will also open the UI designer
    (if it isn't already) with the palette on the left and the attributes window on
    the right.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**按钮，Android Studio将在名为`my_table_layout`的XML文件中生成一个新的`TableLayout`，并将其放在`layout`文件夹中，准备为我们构建基于表格的新UI。Android
    Studio还将打开UI设计师（如果尚未打开），左侧是调色板，右侧是属性窗口。
- en: 'You can now uncomment the `loadTableLayout` function:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，取消注释`loadTableLayout`函数：
- en: '[PRE11]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can now switch to the `TableLayout`-based screen when you run the app, although
    currently, it is blank.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行应用程序时，你可以切换到基于`TableLayout`的屏幕，尽管目前它是空白的。
- en: Adding a TableRow to TableLayout
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向TableLayout添加TableRow
- en: Drag a `TableRow` element from the `Layouts` category on to the UI design. Notice
    that the appearance of this new `TableRow` is virtually imperceptible, so much
    so that it is not worth inserting a diagram in the book. There is just a thin
    blue line at the top of the UI. This is because the `TableRow` has collapsed itself
    around its content, which is currently empty.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 从**布局**类别中将一个`TableRow`元素拖放到UI设计中。注意，这个新的`TableRow`的外观几乎是看不见的，以至于不值得在书中插入图表。UI顶部只有一条蓝线。这是因为`TableRow`已经将自己围绕其内容折叠起来，而目前内容是空的。
- en: It is possible to drag and drop our chosen UI elements onto this thin blue line,
    but it is also a little awkward, even counter intuitive. Furthermore, once we
    have multiple `TableRow` elements next to each other, it gets even harder. The
    solution lies in the **Component Tree** window, which we introduced briefly when
    building the `ConstraintLayout`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将选择的UI元素拖放到这条蓝线上，但这也有点别扭，甚至有点违反直觉。此外，一旦我们在一起有多个`TableRow`元素，情况就会变得更加困难。解决方案在于**组件树**窗口，我们在构建`ConstraintLayout`时简要介绍过。
- en: Using the Component Tree when the visual designer won't do
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当视觉设计师无法完成时使用组件树
- en: 'Look at the **Component Tree** and notice how you can see the `TableRow` as
    a child of the `TableLayout`. We can drag our UI directly onto the `TableRow`
    in the **Component Tree**. Drag three `TextView` objects onto the `TableRow` in
    the **Component Tree** and that should leave you with the following layout. I
    have photoshopped the following screenshot to show you the **Component Tree**
    and the regular UI designer in the same diagram:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 查看**组件树**，注意你可以看到`TableRow`作为`TableLayout`的子级。我们可以直接将UI拖放到**组件树**中的`TableRow`上。在**组件树**中将三个`TextView`对象拖放到`TableRow`上，这样就会得到以下布局。我已经用photoshop修改了以下截图，以展示**组件树**和常规UI设计师在同一图表中：
- en: '![Using the Component Tree when the visual designer won''t do](img/B12806_04_30.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![当视觉设计师无法完成时使用组件树](img/B12806_04_30.jpg)'
- en: Now add another two `TableRow` objects (from the **Layouts** category). You
    can add them via the **Component Tree** window or the UI designer.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加另外两个`TableRow`对象（从**布局**类别）。你可以通过**组件树**窗口或UI设计师添加它们。
- en: Tip
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You need to drop them on the far-left of the window, otherwise the new `TableRow`
    will become a child of the previous `TableRow`. This will leave the whole table
    a bit of a muddle. If you accidentally add a `TableRow` as a child of the previous
    `TableRow,` you can either select it, then tap the *Delete* key, use the *Ctrl*
    + Z keyboard combination to undo it, or drag the mispositioned `TableRow` to the
    left (in the **Component Tree**) to make it a child of the Table – as it should
    be.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将它们放在窗口的最左边，否则新的`TableRow`将成为前一个`TableRow`的子级。这将使整个表格有点混乱。如果你意外地将`TableRow`添加为前一个`TableRow`的子级，你可以选择它，然后点击*删除*键，使用*Ctrl*
    + Z键组合来撤消，或者将位置错误的`TableRow`拖到左边（在**组件树**中）使其成为表格的子级 - 这是应该的。
- en: 'Now, add three `TextView` objects to each of the new `TableRow` items. This
    will be most easily achieved by adding them via the **Component Tree** window.
    Check your layout to make sure it is as in the following screenshot:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为每个新的`TableRow`项目添加三个`TextView`对象。最简单的方法是通过**组件树**窗口添加它们。检查你的布局，确保它与以下截图中的一样：
- en: '![Using the Component Tree when the visual designer won''t do](img/B12806_04_31.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![当视觉设计师无法完成时使用组件树](img/B12806_04_31.jpg)'
- en: Let's make the table look more like a genuine table of data that you might get
    in an app by changing some attributes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让表格看起来更像是一个真正的数据表，通过改变一些属性。
- en: On the `TableLayout`, set the `layout_width` and `layout_height` attributes
    to `wrap_content`. This gets rid of extra cells.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TableLayout`上，将`layout_width`和`layout_height`属性设置为`wrap_content`。这样就可以去掉多余的单元格。
- en: Change the color of all the outer (along the top and down the left-hand side)
    `TextView` objects to black by editing the `textColor` attribute. You achieve
    this by selecting the first `TextView`, searching for its `color` attribute, and
    then typing `black` in the `color` attribute values field. You will then be able
    to select `@android:color/black` from a drop-down list. Do this for each of the
    outer `TextView` elements.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编辑`textColor`属性将所有外部（沿顶部和左侧）的`TextView`对象的颜色更改为黑色。您可以通过选择第一个`TextView`，搜索其`color`属性，然后在`color`属性值字段中输入`black`来实现这一点。然后，您将能够从下拉列表中选择`@android:color/black`。对每个外部`TextView`元素都要这样做。
- en: Edit the `padding` of each `TextView` and change the `all` attribute to `10sp`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑每个`TextView`的`padding`并将`all`属性更改为`10sp`。
- en: Organizing the table columns
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织表格列
- en: It might seem at this point that we are done, but we need to organize the data
    better. Our table, like many tables, will have a blank cell in the top-left to
    divide the column and row titles. To achieve this, we need to number all the cells.
    For this, we need to edit the `layout_column` attribute.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此时似乎我们已经完成了，但是我们需要更好地组织数据。我们的表格，像许多表格一样，将在左上角有一个空白单元格来分隔列和行标题。为了实现这一点，我们需要对所有单元格进行编号。为此，我们需要编辑`layout_column`属性。
- en: Tip
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Cell numbers are numbered from zero from the left.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 单元格编号从左边开始编号为零。
- en: Start by deleting the top-left `TextView`. Notice that the `TextView` from the
    right has moved into the top-left position.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 首先删除左上角的`TextView`。注意右侧的`TextView`已经移动到左上角位置。
- en: Next, in the new top-left `TextView,` edit the `layout_column` attribute to
    be `1` (this assigns it to the second cell, because the first is `0` and we want
    to leave the first one empty) and, for the next cell along, edit the `layout_column`
    attribute to be `2`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在新的左上角`TextView`中，编辑`layout_column`属性为`1`（这将把它分配给第二个单元格，因为第一个是`0`，我们想要留下第一个为空），然后，对于下一个单元格，编辑`layout_column`属性为`2`。
- en: For the next two rows of cells, edit their `layout_column` attributes from `0`
    to `2` from left to right.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接下来的两行单元格，将它们的`layout_column`属性从左到右从`0`更改为`2`。
- en: 'If you want clarification on the precise code for this row after editing, here
    is a snippet, and remember to look in the download bundle in the `Chapter04` `/LayoutExploration`
    folder to see the whole file in context:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要在编辑后了解此行的确切代码，请参阅以下片段，并记得在`Chapter04`的`/LayoutExploration`文件夹中查看整个文件的上下文：
- en: '[PRE12]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Try to complete this exercise, however, using the **Attributes** window if possible.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试完成这个练习，但是如果可能的话，请使用**属性**窗口。
- en: Linking back to the main menu
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接回主菜单
- en: Finally, for this layout, we will add a button that links back to the main menu.
    Add another `TableRow` via the **Component Tree**. Drag a button onto the new
    `TableRow`. Edit its `layout_column` attribute to `1` so that it is in the middle
    of the row. Edit its `text` attribute to `Menu` and edit its `onClick` attribute
    to match our already existing `loadMenuLayout` function.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于这个布局，我们将添加一个按钮，链接回主菜单。通过**组件树**添加另一个`TableRow`。将按钮拖放到新的`TableRow`上。编辑其`layout_column`属性为`1`，使其位于行的中间。编辑其`text`属性为`Menu`，并编辑其`onClick`属性以匹配我们已经存在的`loadMenuLayout`函数。
- en: You can now run the app and switch back and forth between the different layouts.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以运行应用程序并在不同的布局之间来回切换。
- en: 'If you want to, you can add some meaningful titles and data to the table by
    editing all the `text` attributes of the `TextView` widgets, as I have done in
    this following screenshot, showing the `TableLayout` running in the emulator:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以通过编辑`TextView`小部件的所有`text`属性来向表格添加一些有意义的标题和数据，就像我在下面的截图中所做的那样，显示了在模拟器中运行的`TableLayout`：
- en: '![Linking back to the main menu](img/B12806_04_32.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![链接回主菜单](img/B12806_04_32.jpg)'
- en: As a final thought, think about an app that presents tables of data. Chances
    are that data will be added to the table dynamically, not by the developer at
    design time as we have just done, but more likely by the user or from a database
    on the web. In [Chapter 16,](ch16.html "Chapter 16. Adapters and Recyclers") *Adapters
    and Recyclers*, we will see how to dynamically add data to different types of
    layout using adapters, and, in [Chapter 27](ch27.html "Chapter 27. Android Databases"),
    *Android Databases*, we will also see how to create and use databases in our apps.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，思考一下一个呈现数据表的应用程序。很可能数据将动态地添加到表中，而不是由开发人员在设计时添加，而更可能是由用户或来自网络数据库的数据。在[第16章](ch16.html
    "第16章。适配器和回收器")*适配器和回收器*中，我们将看到如何使用适配器动态地向不同类型的布局添加数据，而在[第27章](ch27.html "第27章。Android数据库")*Android数据库*中，我们还将看到如何在我们的应用程序中创建和使用数据库。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have covered many topics in just a few dozen pages. We have not only built
    three different types of layout, including `LinearLayout` with nested layouts,
    `ConstraintLayout` with manually configured constraints, and `TableLayout` (albeit
    with fake data), but we have also wired all the layouts together with clickable
    buttons and text that trigger our Kotlin code to switch between all these different
    layouts.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在几十页中涵盖了许多主题。我们不仅构建了三种不同类型的布局，包括具有嵌套布局的`LinearLayout`，手动配置约束的`ConstraintLayout`，以及`TableLayout`（尽管使用的是假数据），而且我们还通过可点击的按钮和文本将所有布局连接在一起，触发我们的Kotlin代码在所有这些不同的布局之间切换。
- en: In the next chapter, we will stick with the topic of layouts. We will review
    the many attributes we have seen, and we will build our most aesthetically pleasing
    layout so far by incorporating multiple `CardView` layouts, complete with depth
    and shadow, into a smooth-scrolling `ScrollView` layout.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论布局的主题。我们将回顾我们所见过的许多属性，并通过将多个`CardView`布局整合到平滑滚动的`ScrollView`布局中，构建迄今为止最美观的布局。
