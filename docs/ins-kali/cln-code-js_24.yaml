- en: Case Study
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: In this book, we have discussed a litany of principles, walked through almost
    every aspect of the JavaScript language, and have discussed, at length, what constitutes
    *clean code*. This has all been working toward a final destination where we are
    fully equipped to write beautiful and clean JavaScript code that tackles real
    and challenging problem domains. The pursuit of clean code, however, is never
    complete; new challenges will always arise that make us think in new and paradigm-shifting
    ways about the code we write.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们已经讨论了一系列原则，几乎涵盖了JavaScript语言的方方面面，并且长篇大论地讨论了什么是*干净的代码*。这一切都是为了最终能够撰写美丽而干净的JavaScript代码，解决真实而具有挑战性的问题领域。然而，追求干净的代码永远不会完成；新的挑战总会出现，让我们以新的、颠覆性的方式思考我们所写的代码。
- en: 'In this chapter, we''ll be walking through the process of creating a new piece
    of functionality in JavaScript. This will involve both client-side and server-side
    parts, and will force us to apply many of the principles and knowledge we''ve
    gathered throughout the book. The specific problem we''ll be tackling has been
    adapted from a real-life project that I was responsible for, and while we won''t
    be going into every nook and cranny of its implementation, we will be covering
    the most important parts. The completed project is available for you to view on
    GitHub at the following link: [https://github.com/PacktPublishing/Clean-Code-in-JavaScript](https://github.com/PacktPublishing/Clean-Code-in-JavaScript).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将走过JavaScript中创建新功能的过程。这将涉及客户端和服务器端的部分，并且将迫使我们应用我们在整本书中积累的许多原则和知识。我们将要解决的具体问题是从我负责的一个真实项目中改编的，虽然我们不会涉及其实施的每一个细节，但我们将涵盖最重要的部分。完成的项目可以在以下链接的GitHub上查看：[https://github.com/PacktPublishing/Clean-Code-in-JavaScript](https://github.com/PacktPublishing/Clean-Code-in-JavaScript)。
- en: 'In this chapter, we''re going to cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: '**The problem**: We''ll define and explore the problem'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：我们将定义并探讨问题'
- en: '**The design**: We''ll design a UX and architecture that solves the problem'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计**：我们将设计一个解决问题的用户体验和架构'
- en: '**The implementation**: We''ll implement our design'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实施**：我们将实施我们的设计'
- en: The problem
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The problem we''ll be solving relates to a core part of our web application''s
    user experience. The web application we''ll be working on is a frontend to a large
    plant database with tens of thousands of different species of plants. Among other
    functionality, it allows users to find specific plants and add them to collections
    so that they can keep track of their exotic greenhouses and botanical research
    inventories. The illustration is shown as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要解决的问题涉及到我们网页应用程序用户体验的核心部分。我们将要处理的网页应用程序是一个大型植物数据库的前端，其中有成千上万种不同的植物。除了其他功能外，它允许用户找到特定的植物并将它们添加到集合中，以便他们可以跟踪他们的异国温室和植物研究清单。如下图所示：
- en: '![](assets/e254a325-cd9f-4839-bbfe-f4930bc8f91c.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e254a325-cd9f-4839-bbfe-f4930bc8f91c.png)'
- en: 'Currently, when users wish to find a plant, they must use a search facility
    that involves entering a plant name *(the full Latin name*) into a text field,
    clicking Search, and receiving a set of results, as shown in the following screenshot:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，当用户希望找到一种植物时，他们必须使用一个涉及将植物名称（*全拉丁名称*）输入到文本字段中，点击搜索，并收到一组结果的搜索设施，如下截图所示：
- en: '![](assets/e74e911d-7b93-4c8b-9eb0-e8d3de98270d.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e74e911d-7b93-4c8b-9eb0-e8d3de98270d.png)'
- en: For the purposes of our case study, the plant names only exist as their full
    Latin names, which includes a family (for example, Acanthaceae), a genus (for
    example, Acanthus), and a species (for example, Carduaceus). This highlights the
    challenges involved in catering to complex problem domains.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的案例研究，植物名称只存在于它们的全拉丁名称中，其中包括一个科（例如，Acanthaceae）、一个属（例如，Acanthus）和一个种（例如，Carduaceus）。这突显了满足复杂问题领域所涉及的挑战。
- en: 'This works well enough, but following some user focus groups and online feedback,
    it has been decided that we need to offer a better UX for users that enables them
    to more quickly find the plants they''re interested in. Specific points that were
    raised are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做已经足够好了，但在一些用户焦点小组和在线反馈之后，我们决定需要为用户提供更好的用户体验，让他们更快地找到他们感兴趣的植物。提出的具体问题如下：
- en: I find it burdensome and slow to find species sometimes. I wish it were more
    immediate and flexible, so that I didn't have to keep going back and making a
    change to my query, especially if I've spelled it incorrectly.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时候我觉得查找物种很麻烦而且慢。我希望它更即时和灵活，这样我就不必一直回去修改我的查询，特别是如果我拼错了的话。
- en: Often, when I know the name of a plant species or genus, I'll still get it slightly
    wrong and get no results. I'll then have to go back and adjust my spelling or
    search elsewhere online.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，当我知道植物的种或属的名称时，我仍然会稍微出错，没有得到结果。然后我就不得不回去调整我的拼写或在其他地方进行搜索。
- en: I wish I could see the species and genuses come up as I type. That way I can
    more quickly find the appropriate plant and not waste any time.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我希望我在输入时能看到种和属的出现。这样我就可以更快地找到适当的植物，不浪费时间。
- en: 'There are a number of usability concerns expressed here. We can distill them
    into the following three topics:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提出了一些可用性问题。我们可以将它们归纳为以下三个主题：
- en: '**Performance**: The current search facility is slow and clunky to use'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：当前的搜索功能使用起来很慢且笨拙'
- en: '**Error** **c****orrection**: The process of having to correct typing errors
    is annoying and burdensome'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误** **更正**：不得不纠正打字错误的过程令人讨厌和繁琐'
- en: '**Feedback**: It would be useful to get feedback about existing *genuses*/*species*
    while typing'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反馈**：在输入时获得有关现有*属*/*种*的反馈将是有用的'
- en: The task is now becoming clearer. We need to improve the UX so that users are
    able to query the database of plants in a way that is faster, provides more immediate
    feedback, and lets them prevent or correct typing errors along the way.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 任务现在变得更加清晰。我们需要改进用户体验，使用户能够以更快的方式查询植物数据库，提供更即时的反馈，并让他们在途中防止或纠正输入错误。
- en: The design
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计
- en: 'After some brainstorming, we decided that we can solve our problem in quite
    a conventional way; we can simply transform the input field into one that provides
    an auto-suggestion dropdown. Here''s a mockup:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些头脑风暴，我们决定可以以相当传统的方式解决我们的问题；我们可以简单地将输入字段转换为提供自动建议下拉框的字段。这是一个模拟：
- en: '![](assets/8e2c2309-6bc8-406d-86fd-f1bfa89b9a68.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8e2c2309-6bc8-406d-86fd-f1bfa89b9a68.png)'
- en: 'This auto-suggestion dropdown would have the following characteristics:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自动建议下拉框将具有以下特点：
- en: When a term is typed, it will display a prioritized list of plant names that
    contain that term as a prefix, for example, searching for `car` will yield the
    result `carnea` but not `encarea`
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当输入一个术语时，它将显示一个按优先级排序的植物名称列表，这些名称包含该术语作为前缀，例如，搜索`car`将产生结果`carnea`，但不会产生`encarea`
- en: When a term is selected either by click, the arrow (up/down), or *Enter* key,
    it will run a specified function (which may later be used to add selected items
    to the user's collection)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通过点击、箭头（上/下）或*Enter*键选择一个术语时，它将运行指定的函数（以后可能用于将选定的项目添加到用户的集合中）
- en: When no matching plant names can be found, the user will be told with a notice
    such as `No plants with that name exist`
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当找不到匹配的植物名称时，用户将收到通知，例如“没有该名称的植物存在”
- en: These are the core behaviors of our component, and in order to implement them,
    we'll need to consider both client-side and server-side parts. Our client will
    have to render `<input>` to the user, and as they type, it will have to dynamically
    adjust the list of suggestions. The server will have to provide to the client
    a list of suggestions for each potential query, while taking into consideration
    the fact that results will need to be delivered quickly. Any significant latency
    will drastically reduce the benefit of the user experience that we're trying to
    create.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们组件的核心行为，为了实现它们，我们需要考虑客户端和服务器端的部分。我们的客户端将不得不向用户呈现`<input>`，并且当他们输入时，它将不得不动态调整建议列表。服务器将不得不为每个潜在的查询提供给客户端一个建议列表，同时考虑到结果需要快速交付。任何显著的延迟都将严重降低我们试图创建的用户体验的好处。
- en: The implementation
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: It just so happens that this new Plant Selection component will be the first
    piece of significant client-side code within our web application, and as such,
    it's important to note that our design decisions will impact not only this specific
    component but also any other components we consider building in the future.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 恰好这个新的植物选择组件将是我们网页应用中第一个重要的客户端代码片段，因此，重要的是要注意我们的设计决策不仅会影响到这个特定的组件，还会影响到我们将来考虑构建的任何其他组件。
- en: To aid us in our implementation, and considering the possibility of other potential
    additions in the near future, we've decided to adopt a JavaScript library to assist
    in the manipulation of the DOM, and a supporting toolset that enables us to work
    swiftly and to a high-level of quality. In this instance, we've decided to use
    React on the client side, with webpack and Babel to aid in compilation and bundling,
    and Express on the server side for HTTP routing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们实施，并考虑到将来可能的其他潜在添加，我们决定采用JavaScript库来辅助DOM的操作，并采用支持工具集，使我们能够迅速高质量地工作。在这种情况下，我们决定在客户端使用React，使用webpack和Babel进行编译和打包，并在服务器端使用Express进行HTTP路由。
- en: The Plant Selection application
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 植物选择应用
- en: As discussed, we've decided to build our *Plant Selection* functionality as
    its own self-contained application with both a client (the React component) and
    a server (the plant-data API). Having this level of isolation allows us to focus
    purely on the problem of selecting plants, but there's no reason that this couldn't
    be integrated into a larger code base at a later time.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如讨论的那样，我们决定将*植物选择*功能构建为一个独立的应用，包括客户端（React组件）和服务器（植物数据API）。这种隔离程度使我们能够纯粹地专注于选择植物的问题，但这并不意味着这不能在以后集成到更大的代码库中。
- en: 'Our directory structure is roughly as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目录结构大致如下：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In addition to reducing complexity for us (the programmers) the separation of
    server and client means that the server-side application (that is, the Plant Selection
    API) can be run on its own distinct server if necessary, while the client can
    be served up statically from a CDN, requiring only the server-side's address in
    order to access its REST API.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为我们（程序员）减少复杂性之外，服务器和客户端的分离意味着服务器端应用（即植物选择API）可以在必要时在自己独立的服务器上运行，而客户端可以从CDN静态提供，只需要服务器端的地址即可访问其REST
    API。
- en: Creating the REST API
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建REST API
- en: The server of `EveryPlantSelectionApp` is responsible for retrieving the plant
    names (the plant *families*, *genuses,* and *species*) and making them available
    to our client-side code via a simple REST API. To do this, we can use the `express`
    Node.js library, which enables us to route HTTP requests to specific functions,
    easily delivering JSON to our client.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`EveryPlantSelectionApp`的服务器负责检索植物名称（植物*科*、*属*和*种*），并通过简单的REST API使它们可用于我们的客户端代码。为此，我们可以使用`express`
    Node.js库，它使我们能够将HTTP请求路由到特定的函数，轻松地向客户端提供JSON。'
- en: 'Here''s the skeletal beginnings of our server implementation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们服务器实现的基本框架：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, we''re implementing just one route (`/plants/:query`). This
    will be requested by the client whenever a user enters a partial plant name into
    the `<input/>`, so that a user typing `Carduaceus` may produce the following set
    of requests to the server:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们只实现了一个路由（`/plants/:query`）。每当用户在`<input/>`中输入部分植物名称时，客户端将请求这个路由，因此用户输入`Carduaceus`可能会产生以下一系列请求到服务器：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can imagine how this may result in a larger number of expensive and possibly
    redundant requests, especially if a user is typing quickly. It's possible that
    a user will type `cardua` before any of the previous requests can complete. For
    that reason, when we come around to implementing the client side, it'll be appropriate
    for us to use some kind of request throttling (or request debouncing) to ensure
    that we're only making a reasonable number of requests.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象这可能导致更多昂贵且可能冗余的请求，特别是如果用户输入速度很快。有可能用户在任何之前的请求完成之前就输入了`cardua`。因此，当我们开始实现客户端时，我们需要使用某种请求节流（或请求防抖）来确保我们只发出合理数量的请求。
- en: '**Request throttling** is the act of reducing the overall amount of requests
    by only allowing a new request to be performed at a specified time interval, meaning
    that 100 requests spanned over five seconds, throttled to an interval of one second,
    would produce only five requests. **Request debouncing** is similar, though instead
    of performing a single request on every interval, it''ll wait a predesignated
    amount of time for incoming requests to stop being made before enacting an actual
    request. So, 100 requests over five seconds, debounced by five seconds, would
    only produce a single final request at the five second mark.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求节流**是通过只允许在指定时间间隔内执行新请求来减少总请求量的行为，这意味着在五秒内跨度为100个请求，节流到一个间隔为一秒，将只产生五个请求。**请求防抖**类似，不过它不是在每个间隔上执行单个请求，而是在实际请求之前等待一定的时间，以便停止产生请求。因此，在五秒内进行100个请求，通过五秒的防抖，将在五秒标记处只产生一个最终请求。'
- en: In order to implement the `/plants/` endpoint, we need to consider the most
    optimal way to search through the names of over *300,000* different plant species
    for matches. To accomplish this, we'll be using a special in-memory data structure
    called a **trie**. This is also known as a *prefix tree *and is very common to
    use in situations where autosuggestion or autocompletion needs to occur.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现`/plants/`端点，我们需要考虑通过超过*300,000*不同植物物种的名称进行匹配的最佳搜索方式。为了实现这一点，我们将使用一种特殊的内存数据结构，称为**trie**。这也被称为*前缀树*，在需要自动建议或自动完成的情况下非常常见。
- en: 'A trie is a tree-like structure that stores chunks of letters that appear next
    to each other as a series of nodes attached by branches. It''s much easier to
    visualize than to describe, so let''s imagine that we need a trie based on the
    following data:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Trie是一种类似树状结构的数据结构，它将相邻的字母块存储为一系列通过分支连接的节点。它比描述起来更容易可视化，所以让我们想象一下，我们需要基于以下数据创建一个trie：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using that data, the produced trie might look something like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些数据，生成的trie可能看起来像这样：
- en: '![](assets/0fd9a5f9-ff9b-4291-b9b3-10a7c13975d9.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0fd9a5f9-ff9b-4291-b9b3-10a7c13975d9.png)'
- en: As you can see, our dataset of four words has been represented as a tree-like
    structure where the first common letter, `"A"`, serves as the root. The `"CORN"` suffix
    branches off from this. Additionally, the `"PP"` branch (forming `"APP"`), branches
    off, and the last `"P"` of that then branches off to `"L"`, which itself then
    branches off to `"E"` (forming `"APPLE"`) and `"ICATION"` (forming `"APPLICATION"`).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的四个单词的数据集已被表示为类似树状结构的结构，其中第一个共同的字母`"A"`作为根。 `"CORN"`后缀从这里分支出来。此外， `"PP"`分支（形成`"APP"`）分支出来，然后最后的`"P"`分支到`"L"`，然后分支到`"E"`（形成`"APPLE"`）和`"ICATION"`（形成`"APPLICATION"`）。
- en: This may seem convoluted, but given this trie structure, we can, given an initial
    prefix typed by a user like `"APPL"`, easily find all matching words (`"APPLE"`
    and `"APPLICATION"`) by simply stepping through the nodes of the tree. This is
    far more performant than any linear search algorithm. For our purposes, given
    a prefix of a plant name, we want to be able to performantly display every plant
    name that the prefix may lead to.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很复杂，但是鉴于这种trie结构，我们可以根据用户输入的初始前缀（如`"APPL"`）轻松地通过树的节点找到所有匹配的单词（`"APPLE"`和`"APPLICATION"`）。这比任何线性搜索算法都要高效得多。对于我们的目的，给定植物名称的前缀，我们希望能够高效地显示前缀可能导致的每个植物名称。
- en: 'Our specific dataset will include over 300,000 different plant species, but
    for the purposes of this case study, we''ll only be using species from the `Acanthaceae` family,
    which amounts to around 8,000 species. These are available to use in the form
    of JSON as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的特定数据集将包括超过300,000种不同的植物物种，但在本案例研究中，我们将只使用`Acanthaceae`科的物种，大约有8,000种。这些可以以JSON的形式使用，如下所示：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We'll be feeding this data into a third-party trie implementation called **trie-search** on
    NPM. This package has been selected because it fulfills our requirements and seems
    like a well-tested and well-maintained library.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这些数据输入到一个名为**trie-search**的第三方trie实现中。选择这个包是因为它满足我们的要求，并且似乎是一个经过充分测试和维护良好的库。
- en: 'In order for the trie to operate as we desire, we''ll need to concatenate the
    *family*, *genus*, and *species* of each plant into a singular string. This enables
    the trie to include both the fully qualified plant name (for example, `"Acanthaceae
    Pararuellia alata"`) and the split names (`["Acanthaceae", "Pararuellia", "alata"]`).
    The *split* name is automatically generated by the trie implementation we''re
    using (meaning it splits strings on whitespace, via the regex `/\s/g`):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使trie按我们的期望运行，我们需要将每种植物的*科*、*属*和*种*连接成一个字符串。这使得trie可以包括完全合格的植物名称（例如`"Acanthaceae
    Pararuellia alata"`）和分割名称（`["Acanthaceae", "Pararuellia", "alata"]`）。*分割*名称是由我们使用的trie实现自动生成的（意思是它通过正则表达式`/\s/g`在空格上分割字符串）：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code enters our dataset into the trie. Following this, it can
    be queried by simply passing a prefix string to its `get(...)` method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将我们的数据集输入到trie中。之后，可以通过简单地将前缀字符串传递给其`get(...)`方法来查询它：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Such a query (for the prefix, `laxi`) would return the following from our dataset:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的查询（例如前缀`laxi`）将从我们的数据集中返回以下内容：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, with regard to our REST endpoint, `/photos/:query`, all it needs to do
    is return a JSON payload that contains whatever we get from `trie.get(query)`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的REST端点`/photos/:query`，它所需要做的就是返回一个JSON有效负载，其中包含我们从`trie.get(query)`获取的内容：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To separate our concerns a little better and to ensure we''re not mixing too
    many different layers of abstraction (in possible violation of The Law of Demeter),
    we can abstract away our trie data structure and plant data to a module of its
    own. We can call this `plantData` to communicate the fact that it encapsulates
    and provides access to the plant data. The nature of how it works, which happens
    to be via an in-memory trie data structure, does not need to be known to its consumers:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地分离我们的关注点，并确保我们没有混合太多不同的抽象层（可能违反了迪米特法则），我们可以将我们的trie数据结构和植物数据抽象到自己的模块中。我们可以称之为`plantData`，以传达它封装和提供对植物数据的访问的事实。它的工作方式，恰好是通过内存trie数据结构，不需要为其使用者所知：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, this module returns an interface that provides one method,
    `query()`, which our main HTTP routing code can utilize to deliver the JSON result
    for `/plants/:query`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此模块返回一个接口，提供一个`query()`方法，我们的主HTTP路由代码可以利用它来为`/plants/:query`提供JSON结果：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Because we have isolated and contained the plant-querying functionality, it
    is now far easier to make assertions about it. Writing some tests that target
    the `plantData` abstraction will give us a high level of confidence that our HTTP
    layer is using a reliable abstraction, minimizing the potential bugs that can
    crop up within our HTTP layer itself.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经隔离和包含了植物查询功能，现在更容易对其进行断言。编写一些针对`plantData`抽象的测试将使我们对我们的HTTP层使用可靠的抽象具有高度的信心，最大程度地减少了HTTP层内部可能出现的潜在错误。
- en: At this point, since this is the first set of tests we'll be writing for our
    project, we'll be installing Jest (`npm install jest --save-dev`). There are a
    large number of testing frameworks available, with varying styles, but for our
    purposes, Jest is suitable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，由于这是我们为项目编写的第一组测试，我们将安装Jest（`npm install jest --save-dev`）。有许多可用的测试框架，风格各异，但对于我们的目的来说，Jest是合适的。
- en: 'We can write tests for our `plantData` module in a file intuitively located
    alongside it and named `plantData.test.js`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在与之直观地位于一起并命名为`plantData.test.js`的文件中为我们的`plantData`模块编写测试。
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are a large number of tests within `plantData.test.js` that aren't included
    here for the sake of brevity; however, you can view them in the GitHub repository: [https://github.com/PacktPublishing/Clean-Code-in-JavaScript](https://github.com/PacktPublishing/Clean-Code-in-JavaScript).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`plantData.test.js`中有许多测试未在此处包含，以保持简洁；但是，您可以在GitHub存储库中查看它们：[https://github.com/PacktPublishing/Clean-Code-in-JavaScript](https://github.com/PacktPublishing/Clean-Code-in-JavaScript)。'
- en: 'As you can see, this test is asserting whether an `Acanthaceae Thunbergia` query
    intuitively returns plants that have a fully qualified name containing these terms.
    In our dataset, this will only include plants that have an `Acanthaceae` family
    and a `Thunbergia` genus, so we can simply confirm that the results match that
    expectation. We can also check that partial searches, such as `Acantu Thun`, also
    intuitively return any plants that have either *family*, *genus*, or *species*
    names beginning with `Acantu` or `Thun`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此测试断言`Acanthaceae Thunbergia`查询是否直观地返回包含这些术语的完全限定名称的植物。在我们的数据集中，这将仅包括具有`Acanthaceae`家族和`Thunbergia`属的植物，因此我们可以简单地确认结果是否符合预期。我们还可以检查部分搜索，例如`Acantu
    Thun`，是否也直观地返回任何以`Acantu`或`Thun`开头的*家族*、*属*或*种*名称的植物：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We confirm our expectations here by asserting that every returned result's `fullyQualifiedName`
    matches the regular `/\bAcant/i` and `/\bThun/i` expressions. The `/i` expression
    indicates case sensitivity. The `\b` expression here represents a word boundary
    so that we can ensure that the `Acant` and `Thun` substrings appear at the beginning
    of individual words and are not embedded within words. For example, imagine a
    plant called `Luathunder`. We don't want our autosuggestion mechanism to match
    such instances. We only want it to match prefixes, as that is how users will be
    entering plant *families*, *genuses*, or *species* into `<input />` (from the
    start of each word).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过断言每个返回结果的`fullyQualifiedName`是否与正则表达式`/\bAcant/i`和`/\bThun/i`匹配来确认我们的期望。`/i`表达式表示区分大小写。这里的`\b`表达式表示单词边界，以便我们可以确保`Acant`和`Thun`子字符串出现在单词的开头，并且不嵌入在单词中。例如，想象一个名为`Luathunder`的植物。我们不希望我们的自动建议机制匹配这样的实例。我们只希望它匹配前缀，因为用户将输入植物*家族*、*属*或*种*到`<input
    />`中（从每个单词的开头）。
- en: Now that we have a well-tested and isolated server-side architecture, we can
    begin to move onto the client side, where we will be rendering the plant names
    provided by `/plants/:query` in response to the user typing.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了经过充分测试和隔离的服务器端架构，我们可以开始转向客户端，我们将在用户输入时呈现由`/plants/:query`提供的植物名称。
- en: Creating the client-side build process
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建客户端构建过程
- en: 'Our first step, on the client, is to introduce *React* and a supporting toolset
    that can aid us in development. In the old days of web development, it was, and
    arguably still is, entirely possible to build things without complicated tools
    and build steps. In times past, we were able to simply create an HTML page, include
    any third-party dependencies inline, and then begin writing our JavaScript without
    having to worry about anything else:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在客户端的第一步是引入*React*和一个支持开发的工具集。在以前的网页开发时代，可以在没有复杂工具和构建步骤的情况下构建东西，这在某种程度上仍然是可能的。在过去，我们可以简单地创建一个HTML页面，内联包含任何第三方依赖项，然后开始编写我们的JavaScript，而不必担心其他任何事情：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Technically we can still do this. Even when using modern frontend frameworks
    such as React, we could opt to just include it as a `<script>` dependency and
    then write vanilla JavaScript inline. However, by doing this, we would not be
    receiving the following advantages:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们仍然可以这样做。即使使用现代前端框架如React，我们也可以选择将其作为`<script>`依赖项包含在内，然后内联编写原始JavaScript。然而，通过这样做，我们将无法获得以下优势：
- en: '**Newer JavaScript syntax** (ES 2019 and beyond): The ability to use modern
    JavaScript syntax and have it compiled to JavaScript that is safe to use in all
    environments/browsers.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新的JavaScript语法**（ES 2019及更高版本）：能够使用现代JavaScript语法，并将其编译为在所有环境/浏览器中安全使用的JavaScript。'
- en: '**Custom syntax and language extensions**: The ability to use language extensions
    (such as JSX or FlowJS) or other languages that compile to JavaScript (such as
    TypeScript or CoffeeScript).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义语法和语言扩展**：能够使用语言扩展（如JSX或FlowJS）或编译为JavaScript的其他语言（如TypeScript或CoffeeScript）。'
- en: '**Dependency tree management**: The ability to specify your dependencies easily
    (for example, using an `import` statement) and have these automatically reconciled
    and combined into a bundle, without having to manually fiddle with the `<script>`
    tags and versioning nightmares.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖树管理**：能够轻松指定您的依赖关系（例如使用`import`语句），并将这些自动协调和合并成一个捆绑，而无需手动操作`<script>`标签和版本化噩梦。'
- en: '**Performance improvements**: Intelligent compilation and bundling can provide
    meaningful HTTP and runtime performance gains by reducing the overall footprint
    of your JavaScript and CSS.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能改进**：智能编译和打包可以通过减少JavaScript和CSS的整体占用空间，从而提供有意义的HTTP和运行时性能增益。'
- en: '**Linters and analysers**: The ability to use linters and other forms of analysis
    on your JavaScript (and your CSS and HTML), giving us a detailed insight into
    code quality and prospective bugs.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查器和分析器**：能够在您的JavaScript（以及您的CSS和HTML）上使用检查器和其他形式的分析，让我们深入了解代码质量和潜在的错误。'
- en: Fundamentally, the very nature of web applications is more complicated now,
    especially on the frontend. For our purposes of creating an autosuggestion component,
    we need to ensure that we've got a good foundation of tools and build steps so
    that ongoing development can be seamless and simple. This can create a headache
    when setting things up but is worth it in the long run.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上说，现在Web应用的性质更加复杂，特别是在前端。为了创建一个自动建议组件，我们需要确保我们有一套良好的工具和构建步骤基础，以便持续开发可以无缝和简单。在设置这些东西时可能会带来一些麻烦，但从长远来看是值得的。
- en: 'In order to compile our JavaScript (including React''s JSX), we''ll be using
    *Babel*, which can take our JavaScript and convert it into widely supported regular
    JavaScript syntax. To add Babel as a dependency within `EveryPlantSelectionApp/client`,
    we can use `npm` to install it and its various preset configurations:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译我们的JavaScript（包括React的JSX），我们将使用*Babel*，它可以将我们的JavaScript转换为广泛支持的常规JavaScript语法。要在`EveryPlantSelectionApp/client`中添加Babel作为依赖项，我们可以使用`npm`来安装它及其各种预设配置：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Babel will manage the compilation of our JavaScript to a syntax that is widely
    supported. But in order to make these files ready for delivery to a browser, we
    need to bundle them into a singular file that can be delivered by itself within
    our HTML like so:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Babel将管理我们的JavaScript的编译，使其成为广泛支持的语法。但是，为了使这些文件准备好交付给浏览器，我们需要将它们捆绑成一个单一的文件，可以像这样在我们的HTML中单独交付：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To accomplish this, we will need to use a bundler, such as webpack. Webpack
    can carry out the following tasks for us:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要使用一个打包工具，比如webpack。Webpack可以为我们执行以下任务：
- en: It can compile the JavaScript via Babel
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以通过Babel编译JavaScript
- en: It can then reconcile each module, including any of its dependencies
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后它可以协调每个模块，包括任何依赖项
- en: It can produce a singular bundled JavaScript file that includes all dependencies
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以生成一个包含所有依赖关系的单一捆绑的JavaScript文件
- en: 'In order to use webpack, we need to install several related dependencies:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用webpack，我们需要安装几个相关的依赖项：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Webpack also requires its own configuration file, named `webpack.config.js`.
    Within this file, we must tell it how to bundle our code and whereabouts in our
    project we want the bundled code to output to:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack还需要自己的配置文件，名为`webpack.config.js`。在这个文件中，我们必须告诉它如何打包我们的代码，以及我们希望打包的代码输出到项目中的哪个位置：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This configuration is essentially telling webpack the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置基本上告诉webpack以下内容：
- en: Please begin at `EveryPlantSelectionApp/client/app/index.jsx `
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请从`EveryPlantSelectionApp/client/app/index.jsx`开始
- en: Please use Babel to compile this module and all its dependencies that end in
    `.jsx` or `.js `
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请使用Babel来编译此模块及其以`.jsx`或`.js`结尾的所有依赖项
- en: Please output the compiled and bundled file to `EveryPlantSelectionApp/client/dist/`
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请将编译和捆绑文件输出到`EveryPlantSelectionApp/client/dist/`
- en: 'Lastly, we need to install React so that we''re ready to create our plant selection
    component:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要安装React，这样我们就可以准备创建我们的植物选择组件：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It may seem like this is a lot of work just to render a basic UI component,
    but what we've actually done is created a foundation upon which we can accommodate
    many new features, and we've created a build pipeline that will make it easier
    to ship our development code base to production.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来好像这样做很多工作只是为了渲染一个基本的UI组件，但实际上我们已经创建了一个基础，可以容纳许多新功能，并且我们已经创建了一个构建流水线，可以更容易地将我们的开发代码库交付到生产环境。
- en: Creating the component
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建组件
- en: Our component's job is to display an enhanced `<input>` element that will, when
    focused, react to what the user types by rendering a dropdown-style list of available
    options that the user can then select from.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组件的工作是显示一个增强的`<input>`元素，当聚焦时，会根据用户输入的内容呈现一个下拉式的可用选项列表，用户可以从中选择。
- en: 'As a primitive outline, we can imagine the component as containing `<div>`,
    `<input>` into which the user can type, and `<ol>` to display the suggestions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个原始的大纲，我们可以想象组件包含`<div>`，用户可以在其中输入的`<input>`，以及显示建议的`<ol>`：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `role` and `aria-autocomplete` attributes on `<input>` are used to instruct
    the browser (and any screen readers) that the user will be provided with a set
    of predefined choices when typing. This is of vital importance to accessibility.
    The `autoComplete` attribute is used to simply enable or disable the browser's
    default autocompletion behavior. In our case, we want it disabled as we are providing
    our own custom autocompletion/suggestion functionality.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`<input>`上的`role`和`aria-autocomplete`属性用于指示浏览器（以及任何屏幕阅读器），用户在键入时将提供一组预定义的选择。这对于可访问性至关重要。`autoComplete`属性用于简单地启用或禁用浏览器的默认自动完成行为。在我们的情况下，我们希望禁用它，因为我们提供了自己的自定义自动完成/建议功能。'
- en: 'We only want `<ol>` to display when `<input>` is focused. In order to accomplish
    this, we''ll need to bind to both the focus ad blur events of `<input>` and then
    create a distinct piece of state that can track whether we should consider the
    component open or not. We can call this piece of state `isOpen`, and we can conditionally
    render or not render `<ol>` based on its Boolean value:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只希望在`<input>`聚焦时显示`<ol>`。为了实现这一点，我们需要绑定到`<input>`的焦点和失焦事件，然后创建一个可以跟踪我们是否应该考虑组件打开或关闭的独立状态。我们可以称这个状态为`isOpen`，并根据它的布尔值有条件地渲染或不渲染`<ol>`：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: React has its own conventions around state management, which may look rather
    bizarre if you've not been exposed before. The `const [foo, setFoo] = useState(null)` code
    creates a piece of state (called `foo`), which we can change in response to certain
    events. Whenever this state changes, React would then know to trigger a re-render
    of the related component. Flick back to [Chapter 12](5df59321-fd46-4504-93ed-5e8555b33b01.xhtml)*, Real-World
    Challenges*, and look at the *DOM binding and reconciliation* section for a refresher
    on this topic.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: React有自己关于状态管理的约定，如果你之前没有接触过，可能看起来很奇怪。`const [foo, setFoo] = useState(null)`代码创建了一个状态（称为`foo`），我们可以根据某些事件来改变它。每当这个状态改变时，React就会知道触发相关组件的重新渲染。回到[第12章](5df59321-fd46-4504-93ed-5e8555b33b01.xhtml)*，真实世界的挑战*，看看*DOM绑定和协调*部分，以便重新了解这个主题。
- en: 'The next step is for us to bind to the `change` event of `<input>` so that
    we can take whatever the user has typed and trigger a request to our `/plants/:query`
    endpoint in order to discern what suggestions to show the user. First, however,
    we want to create a mechanism via which the request can occur. In the React world,
    it suggests modeling this functionality as a *Hook* of its own. Remembering that
    Hooks are, by convention, prefixed with a *use* verb, we could call this something
    like `usePlantLike`. As its sole argument, it can accept a `query` field (the
    string typed by the user), it can return an object with a `loading` field (to
    indicate the current loading state) and a `plants` field (to contain the suggestions):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要绑定到`<input>`的`change`事件，以便获取用户输入的内容，并触发对我们的`/plants/:query`端点的请求，以便确定向用户显示什么建议。然而，首先，我们希望创建一个机制，通过它可以发出请求。在React世界中，它建议将这种功能建模为自己的*Hook*。记住，按照约定，Hook通常以*use*动词为前缀，我们可以将其称为`usePlantLike`。作为它的唯一参数，它可以接受一个`query`字段（用户键入的字符串），它可以返回一个带有`loading`字段（指示当前加载状态）和`plants`字段（包含建议）的对象：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Our implementation of `usePlantsLike` is thankfully quite simple:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`usePlantsLike`的实现非常简单：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we are using another *React* state management pattern, `useEffect()`,
    to run a specific function whenever the `query` argument changes. So, if `usePlantLike`
    receives a new `query` argument, for example, `Acantha`, then the loading state
    will be set to `true` and a new `fetch()` will be instigated, the result of which
    will populate the `plants` state. This can be difficult to wrap one's head around,
    but for the purposes of the case study, all we really need to appreciate is the
    fact that this `usePlantsLike` abstraction is encapsulating the complexity of
    issuing the `/plants/:query` requests to the server.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用另一种*React*状态管理模式`useEffect()`，以便在`query`参数发生变化时运行特定的函数。因此，如果`usePlantLike`接收到一个新的`query`参数，例如`Acantha`，那么加载状态将被设置为`true`，并且将启动一个新的`fetch()`，其结果将填充`plants`状态。这可能很难理解，但就案例研究而言，我们真正需要理解的是`usePlantsLike`这种抽象封装了向服务器发出`/plants/:query`请求的复杂性。
- en: '**It is wise to separate rendering logic from data logic**. Doing so ensures
    a good hierarchy of abstraction and separation of concerns, and enshrines each
    module as an area of *single responsibility*. Conventional MVC and MVVM frameworks
    helpfully force this separation, while more modern rendering libraries such as
    React give you a little more choice. So here, we''ve chosen to isolate the data
    and server-communication logic within a React Hook, which is then utilized by
    our component.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**将渲染逻辑与数据逻辑分开是明智的**。这样做可以确保良好的抽象层次和关注点分离，并将每个模块作为*单一责任*的领域。传统的MVC和MVVM框架有助于强制进行这种分离，而更现代的渲染库（如React）则给了你更多的选择。因此，在这里，我们选择将数据和服务器通信逻辑隔离在一个React
    Hook中，然后由我们的组件使用。'
- en: 'We can now use our new React Hook whenever the user types something into `<input>`.
    To do this, we can bind to its `change` event and every time it''s triggered,
    grab its `value`, and then pass it as the `query` argument to `usePlantsLike`
    in order to derive a new set of suggestions for the user. These can then be rendered
    within our `<ol>` container:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当用户在`<input>`中键入内容时，我们可以使用我们的新React Hook。为了做到这一点，我们可以绑定到它的`change`事件，每次触发时，获取它的`value`，然后将其作为`query`参数传递给`usePlantsLike`，以便为用户派生一组新的建议。然后可以在我们的`<ol>`容器中呈现这些建议：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we've added a new piece of state, `query`, which we set via `setQuery`
    within the `onChange` handler of `<input>`. This `query` mutation will then cause
    `usePlantsLike` to issue a new request from the server and populate `<ol>` with
    multiple `<li>` elements, each representing an individual plant name suggestion.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个新的状态`query`，通过`<input>`的`onChange`处理程序设置它。然后，这个`query`变化将导致`usePlantsLike`从服务器发出一个新的请求，并用多个`<li>`元素填充`<ol>`，每个元素代表一个单独的植物名称建议。
- en: 'And with that, we have completed the basic implementation of our component.
    In order to make use of it, we can render it in our `client/index.jsx` entry point:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一点，我们已经完成了组件的基本实现。为了使用它，我们可以在我们的`client/index.jsx`入口点中呈现它：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This code attempts to render `<PlantSelectionInput/>` to an element with a `"root"` ID.
    As outlined previously, webpack, our bundling tool, will automatically bundle
    our compiled JavaScript into a singular `main.js` file and place it in `dist/`
    (that is, distribution) directory. This will sit alongside our `index.html` file,
    which will serve as a user-facing portal to our application. For our purposes,
    this only needs to be a simple page that demonstrates `PlantSelectionInput`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码尝试将`<PlantSelectionInput/>`呈现到具有“root”ID的元素上。如前所述，我们的捆绑工具webpack将自动将编译后的JavaScript捆绑成一个名为`main.js`的文件，并将其放置在`dist/`（即分发）目录中。这将与我们的`index.html`文件并排，后者将作为用户界面的入口到我们的应用程序。对于我们的目的，这只需要是一个简单的页面，用于演示`PlantSelectionInput`：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can place any relevant CSS within the `<style>` tag here in `index.html`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`index.html`中的`<style>`标签中放置任何相关的CSS：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In larger projects, it's wise to come up with a scaled CSS solution that works
    well with many different components. Examples that work well with *React* include
    *CSS modules* or s*tyled component**s*, both of which allow you to define CSS
    scoped just to individual components, avoiding the headache of juggling global
    CSS.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在较大的项目中，最好提出一个可以很好地与许多不同组件配合使用的缩放CSS解决方案。在*React*中运行良好的示例包括*CSS模块*或*styled components*，两者都允许您定义仅针对单个组件的CSS，避免了全局CSS的麻烦。
- en: 'The styling of our component is not particularly challenging as it is just
    a list of textual items. The main challenge is in ensuring that, when the component
    is in its fully opened state, the list of suggestions appears atop any other content
    on the page. This can be achieved by relatively positioning the `<input>` container
    and then absolutely positioning `<ol>`, visualized here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组件的样式并不特别具有挑战性，因为它只是一个文本项的列表。主要挑战在于确保当组件处于完全打开状态时，建议列表出现在页面上的任何其他内容之上。这可以通过相对定位`<input>`容器，然后绝对定位`<ol>`来实现，如下所示：
- en: '![](assets/f6a48501-2aea-4bf9-80ea-22f15d752833.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f6a48501-2aea-4bf9-80ea-22f15d752833.png)'
- en: 'This concludes the implementation of our component, but we should also implement
    a basic level of testing (at least). To accomplish this, we''ll be using Jest,
    a testing library, and its snapshot matching functionality. This will enable us
    to confirm that our React component produces the expected hierarchy of DOM elements
    and will protect us from future regressions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们组件的实现，但我们还应该实现基本级别的测试（至少）。为了实现这一点，我们将使用Jest，一个测试库，以及它的快照匹配功能。这将使我们能够确认我们的React组件生成了预期的DOM元素层次结构，并将保护我们免受未来的回归：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Jest helpfully saves the produced snapshots to a `__snapshots__` directory and
    then compares any future executions of the tests against these saved snapshots.
    In addition to these tests, we'll also be able to implement regular functional,
    or even E2E tests that can encode expectations such as *When the user types, the
    list of suggestions updates correspondingly*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Jest会将生成的快照保存到`__snapshots__`目录中，然后将任何将来执行的测试与这些保存的快照进行比较。除了这些测试，我们还可以实现常规的功能性测试，甚至是E2E测试，可以编码期望，比如*当用户输入时，建议列表相应更新*。
- en: This concludes our construction of the component and our case study. If you
    have a look at our GitHub repository, you can see the completed project, play
    with the component, run the tests yourself, and you can fork the repository to
    make your own changes too.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对组件和案例研究的构建。如果您查看我们的GitHub存储库，您可以看到已完成的项目，与组件一起玩耍，自己运行测试，并且您还可以分叉存储库以进行自己的更改。
- en: Here's the link to the GitHub repository: [https://github.com/PacktPublishing/Clean-Code-in-JavaScript](https://github.com/PacktPublishing/Clean-Code-in-JavaScript).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是GitHub存储库的链接：[https://github.com/PacktPublishing/Clean-Code-in-JavaScript](https://github.com/PacktPublishing/Clean-Code-in-JavaScript)。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this, the final chapter, we have explored a real-world problem through the
    lens of the principles and learnings that we have gathered throughout the book.
    We posed a problem that users were encountering and then designed and implemented
    a user experience that solved their problem in a clean way. This included both
    server-side and client-side pieces, enabling us to see, from start to finish,
    what a self-contained JavaScript project may look like. Although we haven''t been
    able to cover every single detail, I hope that this chapter has been helpful in
    cementing the core ideas behind *clean code* and that you now feel better prepared
    to write clean JavaScript code to tackle all types of problem domains. One core
    tenet I hope you can take away with you is simply this: **focus on the user**.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这最后一章中，我们通过书中积累的原则和经验，探讨了一个真实世界的问题。我们提出了用户遇到的问题，然后设计和实现了一个干净的用户体验来解决他们的问题。这包括了服务器端和客户端的部分，使我们能够从头到尾看到一个独立的JavaScript项目可能是什么样子。虽然我们无法涵盖每一个细节，但我希望这一章对于巩固*干净代码*背后的核心思想有所帮助，现在您应该更有信心编写干净的JavaScript代码来解决各种问题领域。我希望您能带走的一个核心原则就是：**专注于用户**。
