- en: Chapter 9. Network Interoperability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 网络互操作性
- en: Network interoperability refers to the ability of systems that differ in implementation
    technology to reliably and accurately interchange information. This means that
    the factors, such as the underlying hardware, operating system, and implementation
    language, may differ between platforms, yet they will not adversely affect the
    ability of these systems to communicate.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络互操作性指的是不同实现技术的系统可靠准确地交换信息的能力。这意味着底层硬件、操作系统和实现语言等因素可能在平台之间有所不同，但它们不会对这些系统进行通信的能力产生不利影响。
- en: There are several factors that can impact interoperability. These range from
    low-level issues, such as the byte order that is used by primitive data types,
    to higher-level technologies, such as web services that largely hide much of their
    implementation details. In this chapter, we will explore many of these factors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个因素可能会影响互操作性。这些因素从低级问题，如原始数据类型使用的字节顺序，到更高级的技术，如大部分隐藏其实现细节的Web服务。在本章中，我们将探讨许多这些因素。
- en: We start with a discussion of the byte order that is used to support primitive
    data types. This is fundamental to the transfer of data. Different byte orders
    will result in significant differences in how information is interpreted.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论支持原始数据类型的字节顺序。这对于数据传输是至关重要的。不同的字节顺序会导致信息解释方式的显著差异。
- en: Next, we will discuss how Java applications can interact with applications that
    are written in different languages. These may be JVM-based languages or languages
    that are radically different from Java.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论Java应用程序如何与用不同语言编写的应用程序进行交互。这些可能是基于JVM的语言或与Java截然不同的语言。
- en: The fundamental network communication construct is the socket. This entity typically
    functions in a TCP/IP environment. We will demonstrate how Java sockets can interact
    with sockets that are written in different languages, specifically C#.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的网络通信构造是套接字。这个实体通常在TCP/IP环境中运行。我们将演示Java套接字如何与用不同语言（特别是C#）编写的套接字进行交互。
- en: The most significant support for interoperability exists in the form of communications
    standards that are typified by web services. These applications support communication
    between disparate systems using standardized middleware. Much of the details of
    communication are hidden by these middleware implementations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的互操作性支持存在于以Web服务为代表的通信标准形式中。这些应用程序支持使用标准化中间件在不同系统之间进行通信。这些中间件实现大部分通信细节。
- en: 'We will investigate the following interoperability topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调查以下互操作性主题：
- en: How Java handles byte order
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java如何处理字节顺序
- en: Interfacing with other languages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他语言进行接口
- en: Communicating with sockets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过套接字通信
- en: Using middleware to achieve interoperability
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用中间件实现互操作性
- en: So, let's start with a discussion of byte order and how it can impact interoperability.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从讨论字节顺序及其对互操作性的影响开始。
- en: Byte order in Java
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中的字节顺序
- en: 'There are two types of byte order: **big endian**, and **little endian**. These
    terms refer to the order that a multi-byte quantity is stored in memory. To illustrate
    this, consider how an integer is stored in memory. As an integer consists of 4
    bytes, these bytes are assigned to a 4-byte region of memory. However, these bytes
    can be stored in different ways. Big endian places the most significant byte first,
    while little endian places the least significant byte first.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种字节顺序：**大端序**和**小端序**。这些术语指的是多字节数量在内存中存储的顺序。为了说明这一点，考虑整数在内存中的存储方式。由于整数由4个字节组成，这些字节被分配给内存的4字节区域。然而，这些字节可以以不同的方式存储。大端序将最重要的字节放在最前面，而小端序将最不重要的字节放在最前面。
- en: 'Consider the following declaration and initialization of an integer:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下整数的声明和初始化：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the following example, the four bytes of memory are shown using big endian,
    assuming that the integer has been allocated to address `1000`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，假设整数已分配到地址`1000`，使用大端序显示内存的四个字节：
- en: '| Address | Byte |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 地址 | 字节 |'
- en: '| --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1000 | 01 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 1000 | 01 |'
- en: '| 1001 | 23 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 1001 | 23 |'
- en: '| 1002 | 45 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 1002 | 45 |'
- en: '| 1003 | 67 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 1003 | 67 |'
- en: 'The following table shows how the integer will be stored using little endian:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了使用小端序存储整数的方式：
- en: '| Address | Byte |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 地址 | 字节 |'
- en: '| --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1000 | 67 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 1000 | 67 |'
- en: '| 1001 | 45 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 1001 | 45 |'
- en: '| 1002 | 23 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 1002 | 23 |'
- en: '| 1003 | 01 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 1003 | 01 |'
- en: 'The endianness varies by machines in the following ways:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 机器的字节顺序有以下几种方式：
- en: Intel-based processors uses little endian
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Intel的处理器使用小端序
- en: ARM processors may use little endian or big endian
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARM处理器可能使用小端序或大端序
- en: Motorola 68K processors use big endian
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Motorola 68K处理器使用大端序
- en: Motorola PowerPC use big endian
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Motorola PowerPC使用大端序
- en: Sun SPARK processors use big endian
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sun SPARK处理器使用大端序
- en: Sending data, such as ASCII strings, is not an issue because these bytes are
    stored in consecutive order. For other data types, such as floats, and longs,
    it can be an issue.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 发送数据，如ASCII字符串，不是问题，因为这些字节是按顺序存储的。对于其他数据类型，如浮点数和长整型，可能会有问题。
- en: 'If we need to know which representation the current machine supports, the `ByteOder`
    class in the `java.nio` package can determine the current byte order. The following
    statement will display the endianness for the current platform:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要知道当前机器支持哪种表示形式，`java.nio`包中的`ByteOder`类可以确定当前的字节顺序。以下语句将显示当前平台的字节序：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For a Windows platform, it will display the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows平台，它将显示如下内容：
- en: '**LITTLE_ENDIAN**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**LITTLE_ENDIAN**'
- en: 'The `DataOutputStream` class''s methods automatically use big endian. The `ByteBuffer`
    class also uses big endian by default. However, as shown next, the order can be
    specified:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataOutputStream`类的方法自动使用大端序。`ByteBuffer`类也默认使用大端序。然而，如下所示，顺序可以被指定：'
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will display the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示如下内容：
- en: '**BIG_ENDIAN**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**BIG_ENDIAN**'
- en: '**LITTLE_ENDIAN**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**LITTLE_ENDIAN**'
- en: 'Once established, other methods, such as the `slice` method, do not change
    the byte order that is used, as demonstrated here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立，其他方法，比如`slice`方法，不会改变使用的字节顺序，如下所示：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output will be as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '**LITTLE_ENDIAN**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**LITTLE_ENDIAN**'
- en: The endianness is normally handled automatically on a machine. However, when
    we transfer data between machines that use different endianness, we can have a
    problem. It is possible that the bytes transferred will be in the wrong order
    at their destination.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 字节序通常会在机器上自动处理。然而，当我们在使用不同字节序的机器之间传输数据时，可能会出现问题。传输的字节可能会在目的地以错误的顺序。
- en: Networks typically use big endian, which is also known as **network byte order**.
    Any data sent through a socket should use big endian. When sending information
    between Java applications, the endianness is not normally an issue. However, the
    endianness is more significant when interacting with non-Java technologies.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 网络通常使用大端序，也称为**网络字节顺序**。通过套接字发送的任何数据都应该使用大端序。在Java应用程序之间发送信息时，字节序通常不是一个问题。然而，当与非Java技术交互时，字节序更为重要。
- en: Interfacing with other languages
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与其他语言进行接口
- en: Sometimes, it is necessary to access libraries that are written in a different
    language. While this is not exclusively a network issue, Java provides support
    in a number of ways. Direct interface with other languages does not take place
    across a network, but rather occurs on the same machine. We will briefly examine
    some of these interface issues.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，有必要访问用不同语言编写的库。虽然这不是一个纯粹的网络问题，但Java以多种方式提供支持。直接与其他语言进行接口不是通过网络进行的，而是在同一台机器上进行的。我们将简要地检查一些这些接口问题。
- en: If we are using another Java library, then we simply need to load the classes.
    If we need to interface with non-Java languages, then we can use the **Java Native
    Interface** (**JNI**) API or some other library. However, if this language is
    a JVM-based language, then the process is much easier.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用另一个Java库，那么我们只需要加载类。如果我们需要与非Java语言进行接口，那么我们可以使用**Java本地接口**（**JNI**）API或其他库。然而，如果这种语言是基于JVM的语言，那么这个过程会更容易。
- en: Interfacing with JVM based languages
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与基于JVM的语言进行接口
- en: 'The **Java Virtual Machine** (**JVM**) executes Java byte codes. However, this
    is not the only language that uses a JVM. Other languages include the following
    ones:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java虚拟机**（**JVM**）执行Java字节码。然而，不仅有Java使用JVM。其他语言包括以下几种：'
- en: '**Nashorn**: This uses JavaScript'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nashorn**：这使用JavaScript'
- en: '**Clojure**: This is a Lisp dialect'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Clojure**：这是一种Lisp方言'
- en: '**Groovy**: This is a scripting language'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Groovy**：这是一种脚本语言'
- en: '**Scala**: This combines the object-oriented and functional programming approaches'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Scala**：这结合了面向对象和函数式编程方法'
- en: '**JRuby**: This is the Java implementation of Ruby'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JRuby**：这是Ruby的Java实现'
- en: '**Jthon**: This is the Java implementation of Python'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jthon**：这是Python的Java实现'
- en: '**Jacl**: This is the Java implementation of Tcl'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jacl**：这是Tcl的Java实现'
- en: '**TuProlog**: This is the Java-based implementation of Prolog'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TuProlog**：这是Prolog的基于Java的实现'
- en: A more complete list of JVM-based languages can be found at [https://en.wikipedia.org/wiki/List_of_JVM_languages](https://en.wikipedia.org/wiki/List_of_JVM_languages).
    Using the same JVM base will facilitate the sharing of code and libraries. Often,
    it is possible to not only use libraries that were developed in a different JVM-based
    language, but to also derive from classes that were developed in different languages.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 更完整的基于JVM的语言列表可以在[https://en.wikipedia.org/wiki/List_of_JVM_languages](https://en.wikipedia.org/wiki/List_of_JVM_languages)找到。使用相同的JVM基础将有助于共享代码和库。通常，不仅可以使用在不同基于JVM的语言中开发的库，还可以从不同语言中开发的类中派生。
- en: Many languages have been ported to JVM because it is easier to use the JVM than
    create multiple compilers or interpreters for different platforms. For example,
    Ruby and Python have JVM implementations for this reason. These languages can
    take advantage of the JVM's portability and its **Just-In-Time** (**JIT**) compilation
    process. In addition to this, the JVM has a large library of well-tested code
    to build upon.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言已经移植到JVM，因为使用JVM比为不同平台创建多个编译器或解释器更容易。例如，Ruby和Python有JVM实现的原因。这些语言可以利用JVM的可移植性和其**即时编译**（**JIT**）过程。除此之外，JVM还有一个大型的经过充分测试的代码库可供利用。
- en: 'Nashorn is a JavaScript engine that is built on top of the JVM and was added
    in Java 8\. This allows JavaScript code to be readily integrated into a Java application.
    The following code sequence illustrates this process. An instance of the JavaScript
    engine is obtained and then JavaScript code is executed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Nashorn是构建在JVM之上并在Java 8中添加的JavaScript引擎。这允许JavaScript代码被轻松地集成到Java应用程序中。以下代码序列说明了这个过程。首先获得JavaScript引擎的一个实例，然后执行JavaScript代码：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of this sequence is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列的输出如下：
- en: '**Executing JavaScript code**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**执行JavaScript代码**'
- en: More sophisticated JavaScript processing is possible. More details about this
    technology can be found at [https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/](https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的JavaScript处理是可能的。关于这项技术的更多细节可以在[https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/](https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/)找到。
- en: Interfacing with non-JVM languages
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与非JVM语言进行接口
- en: A common technique to access code in a different language is through the JNI
    API. This API provides a means of accessing C/C++ code. This approach is well
    documented and will not be demonstrated here. However, a good introduction to
    this API can be found at [http://www.ibm.com/developerworks/java/tutorials/j-jni/j-jni.html](http://www.ibm.com/developerworks/java/tutorials/j-jni/j-jni.html).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 访问不同语言中的代码的常见技术是通过JNI API。这个API提供了访问C/C++代码的方法。这种方法有很好的文档，这里不会进行演示。然而，可以在[http://www.ibm.com/developerworks/java/tutorials/j-jni/j-jni.html](http://www.ibm.com/developerworks/java/tutorials/j-jni/j-jni.html)找到这个API的很好介绍。
- en: It is possible to access .NET code from Java. One technique uses JNI to access
    C#. An example of how to access C++, managed C++, and C# code is found at [http://www.codeproject.com/Articles/13093/C-method-calls-within-a-Java-program](http://www.codeproject.com/Articles/13093/C-method-calls-within-a-Java-program).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从Java访问.NET代码。一种技术使用JNI访问C#。如何访问C++、托管C++和C#代码的示例可在[http://www.codeproject.com/Articles/13093/C-method-calls-within-a-Java-program](http://www.codeproject.com/Articles/13093/C-method-calls-within-a-Java-program)找到。
- en: Communication through simple sockets
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过简单的套接字进行通信
- en: It is possible to transfer information between applications that are written
    in different languages using sockets. The socket concept is not unique to Java
    and has been implemented in many languages. As sockets work at the TCP/IP level,
    they can communicate without much effort.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用套接字可以在不同语言编写的应用程序之间传输信息。套接字概念并不是Java独有的，已经在许多语言中实现。由于套接字在TCP/IP级别工作，它们可以在不费吹灰之力的情况下进行通信。
- en: The primary interoperability consideration concerns the data that is transmitted.
    Incompatibilities can occur when the internal representation of data differs significantly
    between two different languages. This may be due to the use of big endian versus
    little endian in how a data type is represented internally, and whether a particular
    data type even exists in another language. For example, in C there is no distinct
    Boolean data type. It is represented using an integer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的互操作性考虑涉及传输的数据。当数据的内部表示在两种不同的语言之间有显着差异时，可能会发生不兼容性。这可能是由于数据类型在内部的表示中使用大端或小端，以及特定数据类型是否存在于另一种语言中。例如，在C中没有明确的布尔数据类型。它是用整数表示的。
- en: In this section, we will develop a server in Java and a client in C#. To demonstrate
    the use sockets, a string will be transferred between these two applications.
    We will find that transferring even a simple data type, such as strings, can be
    more difficult than it seems.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在Java中开发一个服务器，在C#中开发一个客户端。为了演示使用套接字，在这两个应用程序之间传输一个字符串。我们将发现，即使是传输简单的数据类型，比如字符串，也可能比看起来更困难。
- en: The Java server
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java服务器
- en: 'The server is declared in the `JavaSocket` class, as shown next. It looks very
    similar to previous versions of the echo server that was developed in this book.
    A server socket is created and then blocks until the `accept` method returns with
    a socket connected to a client:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在`JavaSocket`类中声明，如下所示。它看起来与本书中开发的以前版本的回显服务器非常相似。创建服务器套接字，然后阻塞，直到`accept`方法返回与客户端连接的套接字：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Scanner` class is used to read messages that are sent from a client. A
    `PrintWriter` instance is used to reply to the client:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scanner`类用于读取从客户端发送的消息。`PrintWriter`实例用于回复客户端：'
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `nextLine` method retrieves a message, which is displayed and sent back
    to the client:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextLine`方法检索消息，显示并发送回客户端：'
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The server will then terminate.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将终止。
- en: Now, let's examine the C# application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看C#应用程序。
- en: The C# client
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#客户端
- en: The `CSharpClient` class, as shown next, implements the client. C# is similar
    in form and syntax to Java, though the class libraries are often different. We
    will not provide a detailed explanation of the code, but we will cover the important
    features of the application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`CSharpClient`类，如下所示，实现了客户端。C#在形式和语法上类似于Java，尽管类库通常不同。我们不会提供代码的详细解释，但我们将介绍应用程序的重要特性。'
- en: 'The `using` statement corresponds to the import statement in Java. Similar
    to Java, the first method to execute is the `Main` method. C# typically uses a
    different indention style and name convention than Java:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`语句对应于Java中的导入语句。与Java类似，要执行的第一个方法是`Main`方法。C#通常使用不同的缩进样式和命名约定：'
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `IPEndPoint` variable represents an Internet address, and the `Socket`
    class, as you may expect, represents a socket. The `Connect` method connects to
    the server:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPEndPoint`变量表示Internet地址，`Socket`类，正如你可能期望的那样，表示套接字。`Connect`方法连接到服务器：'
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Console` class''s `Write` method displays information in a command window.
    Here, the user is prompted for a message to send to the server. The `ReadLine`
    method reads in the user input:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Console`类的`Write`方法在命令窗口中显示信息。在这里，用户被提示输入要发送到服务器的消息。`ReadLine`方法读取用户输入：'
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `Send` method will transmit data to the server. However, it requires the
    data to be placed into a byte buffer, as shown next. The message and an appended
    carriage return/line feed character is encoded and inserted into the buffer. The
    appended character is needed so that the server can read the string correctly
    and know when the string is terminated:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Send`方法将数据传输到服务器。但是，它需要将数据放入字节缓冲区，如下所示。消息和附加的回车/换行字符被编码并插入到缓冲区中。需要附加字符以便服务器可以正确读取字符串并知道字符串何时终止：'
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `Receive` method reads the server''s response. Similar to the `Send` method,
    it requires a byte buffer. This buffer was created with a size of 32 bytes. This
    limits the size of the message, but we will discuss how to overcome this limitation
    shortly:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Receive`方法读取服务器的响应。与`Send`方法类似，它需要一个字节缓冲区。这个缓冲区的大小为32字节。这限制了消息的大小，但我们将讨论如何克服这个限制：'
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The receiving buffer is converted into a string and displayed. The beginning
    and closing brackets are used to clearly delineate the buffer:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接收缓冲区被转换为字符串并显示。开始和结束括号用于清楚地界定缓冲区：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The socket is closed and the application terminates:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字关闭，应用程序终止：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The client/server in action
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端/服务器操作
- en: Start the server and then the client. The client's user will be prompted for
    a message. Enter a message. The message will be sent and the response will be
    displayed in the client window.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 启动服务器，然后启动客户端。客户端用户将被提示输入消息。输入消息。消息将被发送，并在客户端窗口中显示响应。
- en: 'The server output is displayed here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器输出显示在这里：
- en: '**Server Started**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器已启动**'
- en: '**Client connection completed**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端连接完成**'
- en: '**Server received: The message**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器收到：消息**'
- en: '**Server sent: The message**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器发送：消息**'
- en: '**Server Terminated**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器终止**'
- en: 'The client side appears as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端界面如下：
- en: '**Client Started**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端已启动**'
- en: '**Enter message: The message**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入消息：The message**'
- en: '**Client received: [The message**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端收到：[The message**'
- en: '**]**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**]**'
- en: '**Client Terminated**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端终止**'
- en: '**Press any key to continue . . .**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**按任意键继续. . .**'
- en: You will note that the received message is larger than expected. This is because
    the client's receive byte buffer was 32 bytes long. This implementation used a
    fixed-size buffer. As the size of the response from the server may not always
    be known, the buffer needs to be large enough to hold responses. A size of 32
    was used to limit the server's output.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到收到的消息比预期的要大。这是因为客户端的接收字节缓冲区长度为32字节。这个实现使用了固定大小的缓冲区。由于来自服务器的响应大小可能并不总是已知的，因此缓冲区需要足够大以容纳响应。32的大小用于限制服务器的输出。
- en: This limitation can be overcome in a number of ways. One approach appends a
    special character at the end of the string and then uses this marker to construct
    the response. Another approach sends the length of the response first, followed
    by the response. The receiving buffer can be allocated based on the response's
    length.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过多种方式克服这个限制。一种方法是在字符串末尾附加一个特殊字符，然后使用此标记构造响应。另一种方法是首先发送响应的长度，然后是响应。接收缓冲区可以根据响应的长度进行分配。
- en: Sending a string is useful to transmit formatted information. For example, the
    message that was sent could have been an XML or JSON document. This will facilitate
    the transmission of more sophisticated content.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 发送字符串对于传输格式化信息很有用。例如，发送的消息可以是XML或JSON文档。这将有助于传输更复杂的内容。
- en: Interoperability through middleware
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过中间件实现互操作性
- en: Network technologies have evolved considerably over the last 20 years. Low-level
    socket support provides the foundation for most of these technologies. However,
    they are hidden from the user through multiple layers of software. These layers
    are referred to as **middleware**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的20年里，网络技术已经有了很大的发展。低级套接字支持为大多数这些技术提供了基础。然而，它们通过多层软件隐藏在用户之下。这些层被称为**中间件**。
- en: Interoperability is achieved through middleware, such as JMI, SOAP, and JAX-WS—to
    mention a few. The Java EE edition is aimed primarily at supporting these middleware-type
    technologies. Java EE started with **servlets**, a Java application that was used
    to support web pages. It has evolved to include **Java Server Pages** (**JSP**)
    and eventually to **Faclets** both of which hide underlying Servlets.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过中间件（如JMI、SOAP和JAX-WS等）实现了互操作性。Java EE版主要旨在支持这些中间件类型的技术。Java EE从**servlets**开始，这是一个用于支持网页的Java应用程序。它已经发展到包括**Java服务器页面**（**JSP**），最终到**Faclets**，这两者都隐藏了底层的Servlets。
- en: These technologies are concerned with providing services to users whether they
    are a human at a browser or another application. The users are not necessarily
    aware of how the service is implemented. Communication is achieved through a number
    of different standards and data is frequently encapsulated in language neutral
    XML documents. Thus, a server and a client can be written in different languages
    and run in different execution environments promoting interoperability.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术涉及为用户提供服务，无论是在浏览器上的人还是其他应用程序。用户不一定知道服务是如何实现的。通信是通过多种不同的标准实现的，并且数据经常封装在语言中立的XML文档中。因此，服务器和客户端可以用不同的语言编写，并在不同的执行环境中运行，促进了互操作性。
- en: 'While there are a number of technologies that are available, there are two
    common approaches that are used: RESTful Web Services, and SOAP-based Web Services.
    **REpresentational State Transfer Web Services** (**RESTful Web Services**) use
    HTTP and the standard commands (`PUT`, `POST`, `GET`, `DELETE`) to support the
    distribution of web pages and other resources. Its intent is to simplify how these
    types of services can be created. The interaction between the client and the server
    is stateless. That is, what was previously processed will not affect how the current
    request will be handled.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多可用的技术，但通常使用两种常见的方法：RESTful Web服务和基于SOAP的Web服务。**表述状态转移Web服务**（**RESTful
    Web服务**）使用HTTP和标准命令（`PUT`、`POST`、`GET`、`DELETE`）来支持Web页面和其他资源的分发。其目的是简化这些类型的服务的创建方式。客户端和服务器之间的交互是无状态的。也就是说，先前处理的内容不会影响当前请求的处理方式。
- en: '**SOAP-based Web Services** uses the **Simple Object Access Protocol** (**SOAP**)
    to exchange structured information. It uses application layer protocols, such
    as HTTP, and SMTP, and communicates using XML. We will focus on JAX-RS.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于SOAP的Web服务**使用**简单对象访问协议**（**SOAP**）来交换结构化信息。它使用应用层协议，如HTTP和SMTP，并使用XML进行通信。我们将专注于JAX-RS。'
- en: The **Java API for RESTful Web Services** (**JAX-RS**) is an API supporting
    the development of RESTful services. It uses a series of annotations to map resources
    to Java implementations. To demonstrate how this technology works, we will create
    a simple RESTful application using NetBeans.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**用于RESTful Web服务的Java API**（**JAX-RS**）是支持RESTful服务开发的API。它使用一系列注解将资源映射到Java实现。为了演示这项技术的工作原理，我们将使用NetBeans创建一个简单的RESTful应用程序。'
- en: Creating a RESTful service
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建RESTful服务
- en: We will create the server first and then a simple console-based application
    to access the server. We will use NetBeans IDE 8.0.2 to develop this service.
    NetBeans can be downloaded from [https://netbeans.org/downloads/](https://netbeans.org/downloads/).
    Choose the Java EE Edition.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建服务器，然后创建一个简单的基于控制台的应用程序来访问服务器。我们将使用NetBeans IDE 8.0.2来开发此服务。NetBeans可以从[https://netbeans.org/downloads/](https://netbeans.org/downloads/)下载。选择Java
    EE版本。
- en: 'Once NetBeans has been installed, start it and then create a new project from
    the **File** | **New Project…** menu item. This will bring up the **New Project**
    dialog box, as shown next. Select the **Java Web** category and the **Web Application**
    project. Then, select the **Next** button:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 安装NetBeans后，启动它，然后从**文件** | **新建项目...**菜单项创建一个新项目。这将弹出**新建项目**对话框，如下所示。选择**Java
    Web**类别和**Web应用程序**项目。然后，选择**下一步**：
- en: '![Creating a RESTful service](img/B04915_09_01.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![创建RESTful服务](img/B04915_09_01.jpg)'
- en: 'Give the project a name. In the following figure, we used `SimpleRestfulService`
    as its name. Choose an appropriate location to save the project and then select
    **Next**:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 给项目命名。在下图中，我们使用了`SimpleRestfulService`作为其名称。选择一个适当的位置保存项目，然后选择**下一步**：
- en: '![Creating a RESTful service](img/B04915_09_02.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![创建RESTful服务](img/B04915_09_02.jpg)'
- en: 'In the **Server and Settings** step, choose the GlassFish server and Java EE7
    Web. GlassFish is a web server that we will use to host the service. The **Context
    Path** field will become part of the URL passed to the server. Click on **Next**
    again:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在**服务器和设置**步骤中，选择GlassFish服务器和Java EE7 Web。GlassFish是我们将用于托管服务的Web服务器。**上下文路径**字段将成为传递给服务器的URL的一部分。再次点击**下一步**：
- en: '![Creating a RESTful service](img/B04915_09_03.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![创建RESTful服务](img/B04915_09_03.jpg)'
- en: 'We can choose from one of three design patterns to create our RESTful service.
    For this example, choose the first one, **Simple Root Resource**, and then click
    on **Next**:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从三种设计模式中选择一种来创建我们的RESTful服务。在本例中，选择第一种**简单根资源**，然后点击**下一步**：
- en: '![Creating a RESTful service](img/B04915_09_04.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![创建RESTful服务](img/B04915_09_04.jpg)'
- en: 'In the **Specify Resource Classes** step, complete the dialog box, as shown
    next. The resource package is where the Java classes will be placed. The path
    is used to identify the resource to the user. The class name field will be the
    name of the Java class supporting the resource. When done, click on **Finish**:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在**指定资源类**步骤中，填写对话框，如下所示。资源包是Java类将放置的位置。路径用于向用户标识资源。类名字段将是支持资源的Java类的名称。完成后，点击**完成**：
- en: '![Creating a RESTful service](img/B04915_09_05.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![创建RESTful服务](img/B04915_09_05.jpg)'
- en: The IDE will then generate the files, including the `ApplicationConfig.java`
    and `SimpleRestfulService.java` files. The `ApplicationConfig.java` file is used
    to configure the service. Our main interest is the `SimpleRestfulService.java`
    file.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后IDE将生成文件，包括`ApplicationConfig.java`和`SimpleRestfulService.java`文件。`ApplicationConfig.java`文件用于配置服务。我们主要关注的是`SimpleRestfulService.java`文件。
- en: 'In the `SimpleRestfulService` class is the `getHtml` method, as duplicated
    next. Its purpose is to generate a response to the `GET` command. The first annotation
    designates this method as the method to call when the `HTTP GET` command is used.
    The second annotation specifies that the intended output of this method is HTML
    text. The return statement that is generated by the IDE has been replaced with
    a simple HTML response:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SimpleRestfulService`类中有`getHtml`方法，如下所示。它的目的是生成对`GET`命令的响应。第一个注释指定了当使用`HTTP
    GET`命令时要调用的方法。第二个注释指定了该方法的预期输出是HTML文本。IDE生成的返回语句已被简单的HTML响应替换：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When the service is requested with a `GET` command, the HTML text will be returned.
    All of the intermediate steps, including the use of sockets, are hidden, simplifying
    the development process.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`GET`命令请求服务时，将返回HTML文本。所有中间步骤，包括套接字的使用，都被隐藏，简化了开发过程。
- en: Testing the RESTful service
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试RESTful服务
- en: 'We will develop a client application to access this resource. However, we can
    test the resource using built-in facilities. To test the service, right-click
    on the project''s name in the **Project Explorer** window and select the **Test
    RESTful Web Services** menu item. This will bring up the following window. Click
    on **OK**:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个客户端应用程序来访问此资源。但是，我们可以使用内置设施测试资源。要测试服务，请在**项目资源管理器**窗口中右键单击项目名称，然后选择**测试RESTful
    Web服务**菜单项。这将弹出以下窗口。点击**确定**：
- en: '![Testing the RESTful service](img/B04915_09_06.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![测试RESTful服务](img/B04915_09_06.jpg)'
- en: 'You may receive a security alert on Windows as follows. Select the **Allow
    access** button if this occurs:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上可能会收到安全警报。如果发生这种情况，请选择**允许访问**按钮：
- en: '![Testing the RESTful service](img/B04915_09_07.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![测试RESTful服务](img/B04915_09_07.jpg)'
- en: 'Your default browser will display the test page, as shown next. Select the
    **packt** node:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 默认浏览器将显示测试页面，如下所示。选择**packt**节点：
- en: '![Testing the RESTful service](img/B04915_09_08.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![测试RESTful服务](img/B04915_09_08.jpg)'
- en: 'The resource will then appear on the right-hand side, as shown next. This allows
    us to select the test method. As the `GET` command has been chosen by default,
    click on the **Test** button:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后资源将显示在右侧，如下所示。这使我们可以选择测试方法。由于默认选择了`GET`命令，因此点击**测试**按钮：
- en: '![Testing the RESTful service](img/B04915_09_09.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![测试RESTful服务](img/B04915_09_09.jpg)'
- en: The `GET` command is then sent to the server and the response is displayed,
    as shown next.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`GET`命令发送到服务器，并显示响应，如下所示。
- en: '![Testing the RESTful service](img/B04915_09_10.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![测试RESTful服务](img/B04915_09_10.jpg)'
- en: More sophisticated processing can be performed using JAX_RS. However, this illustrates
    the basic approach.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用JAX_RS执行更复杂的处理。但是，这说明了基本方法。
- en: Creating a RESTful client
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建RESTful客户端
- en: The RESTful service can be called by any number of applications that are written
    in various languages. Here, we will create a simple Java client to access this
    service.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful服务可以被写成各种语言的任意数量的应用程序调用。在这里，我们将创建一个简单的Java客户端来访问此服务。
- en: 'Create a new project and select the **RESTful Java Client** option from the
    **Web Services** category, as shown next. Then click on **Next**:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新项目，并从**Web服务**类别中选择**RESTful Java客户端**选项，如下所示。然后点击**下一步**：
- en: '![Creating a RESTful client](img/B04915_09_11.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![创建RESTful客户端](img/B04915_09_11.jpg)'
- en: 'The **Name and Location** step dialog box will appear, as shown in the following
    screenshot. We need to select the RESTful resource. We can perform this by clicking
    on the **Browse…** button:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称和位置**步骤对话框将显示如下截图所示。我们需要选择RESTful资源。我们可以通过单击**浏览...**按钮来执行此操作：'
- en: '![Creating a RESTful client](img/B04915_09_12.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![创建RESTful客户端](img/B04915_09_12.jpg)'
- en: 'The **Available REST Resources** dialog will appear, as shown next. Expand
    our RESTful project and select the resource, as shown in the next screenshot,
    and then click on **OK**:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**可用的REST资源**对话框将显示如下。展开我们的RESTful项目并选择资源，如下截图所示，然后单击**确定**：'
- en: '![Creating a RESTful client](img/B04915_09_13.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![创建RESTful客户端](img/B04915_09_13.jpg)'
- en: 'The completed dialog box should appear as follows. Click on **Finish**:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的对话框应如下所示。单击**完成**：
- en: '![Creating a RESTful client](img/B04915_09_14.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![创建RESTful客户端](img/B04915_09_14.jpg)'
- en: 'The `RestfulClient` class is then generated. We are interested in the `getHtml`
    method, as shown next. This will return the HTML text from the service:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后生成`RestfulClient`类。我们对`getHtml`方法感兴趣，如下所示。这将从服务返回HTML文本：
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To test the application, add the following `main` met`hod, which invokes the
    `getHtml` method:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试应用程序，请添加以下`main`方法，调用`getHtml`方法：
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Make sure that the GlassFish server is running, and execute the program. The
    output will be as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 确保GlassFish服务器正在运行，并执行程序。输出将如下所示：
- en: '**<html><body><h1>Simple Restful Example</body></h1></html>**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**<html><body><h1>简单的Restful示例</body></h1></html>**'
- en: While we will not normally display HTML text in a console, this illustrated
    the process that we use to obtain information from a RESTful service.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们通常不会在控制台中显示HTML文本，但这说明了我们从RESTful服务获取信息的过程。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored many of the factors that impact network interoperability.
    At a low-level, the byte order becomes important. We learned that systems either
    use a big endian or a little endian byte order. The order can be determined and
    controlled by Java applications. Network communication normally uses big endian
    when transferring data.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了许多影响网络互操作性的因素。在低级别上，字节顺序变得重要。我们了解到系统使用大端或小端字节顺序。顺序可以由Java应用程序确定和控制。网络通信在传输数据时通常使用大端。
- en: If we need to communicate with other languages, we found that JVM-based languages
    are easier to work with because they share the same byte code base. If we need
    to work with other languages, then JNI is commonly used.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要与其他语言通信，我们发现基于JVM的语言更容易使用，因为它们共享相同的字节码基础。如果我们需要与其他语言一起工作，那么通常使用JNI。
- en: A socket is not a Java-unique concept. It normally is used in a TCP/IP environment,
    which implies that a socket that is written in one language can easily communicate
    with a socket that is written in a different language. We demonstrated this ability
    using a Java server and a C# client.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字不是Java独有的概念。它通常用于TCP/IP环境，这意味着用一种语言编写的套接字可以轻松地与用另一种语言编写的套接字进行通信。我们使用Java服务器和C#客户端演示了这种能力。
- en: We also explored how middleware can support interoperability by abstracting
    much of the low-level communication detail. Using concepts, such as web services,
    we learned that the details of low-level socket interactions are hidden. We demonstrated
    this using JAX-RS, which supports a RESTful approach where HTTP commands, such
    as GET, and POST, are mapped to specific Java functionality.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了中间件如何通过抽象化大部分低级通信细节来支持互操作性。使用诸如Web服务之类的概念，我们了解到低级套接字交互的细节被隐藏起来。我们使用JAX-RS进行了演示，它支持RESTful方法，其中HTTP命令（如GET和POST）被映射到特定的Java功能。
- en: Network interoperability is an important consideration in enterprise-level applications
    where the enterprise's functionality is distributed using various technologies.
    This interoperability is possible through the use of standard middleware protocols
    and products.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 网络互操作性是企业级应用程序中的重要考虑因素，企业的功能是通过各种技术进行分布的。通过使用标准中间件协议和产品，可以实现这种互操作性。
