- en: Chapter 8. Orchestrating Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 容器编排
- en: In the earlier chapters, we laid down a strong foundation for the need for container
    networking, how to run a service inside a Docker container, and how to expose
    this service to the outside world by opening up network ports and other prerequisites.
    However, recently, there are advanced mechanisms being made available and a few
    third-party orchestration platforms hitting the market for sagaciously establishing
    dynamic and decisive linkages between distributed and differently enabled containers
    in order to compose powerful containers for comprehensively, yet compactly containing
    process-centric, multi-tiered, and enterprise-class distributed applications.
    In this extremely diversified yet connected world, the concept of orchestration
    cannot be kept away from its deserved prominence for long. This chapter is precisely
    devoted for explaining the nitty-gritty of container orchestration, and its direct
    role in picking up discrete containers to systematically compose sophisticated
    containers that are more directly aligned to the varying business expectations
    and expediencies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的章节中，我们为容器网络的需求奠定了坚实的基础，以及如何在Docker容器内运行服务，以及如何通过打开网络端口和其他先决条件来将此服务暴露给外部世界。然而，最近，已经提供了先进的机制，并且一些第三方编排平台进入市场，以明智地建立分布式和不同功能的容器之间的动态和决定性联系，以便为全面但紧凑地包含面向过程、多层和企业级分布式应用程序组合强大的容器。在这个极其多样化但相互连接的世界中，编排的概念不能长期远离其应有的突出地位。本章专门用于解释容器编排的细枝末节，以及它在挑选离散容器并系统地组合成更直接符合不同业务期望和迫切需求的复杂容器方面的直接作用。
- en: 'In this chapter, we will discuss the details associated with the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题的相关细节：
- en: Linking containers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接容器
- en: Orchestrating containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编排容器
- en: Container orchestration using the `docker-compose` tool
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`docker-compose`工具进行容器编排
- en: As mission-critical applications are overwhelmingly being built through loosely
    coupled, yet highly cohesive components/services destined to run on geographically
    distributed IT infrastructures and platforms, the concept of composition is getting
    a lot of attention and attraction. For sustaining the well-begun containerization
    journey, the orchestration of containers is being prescribed as one of the most
    critical and crucial requirements in the ensuing instant-on, adaptive, and smart
    IT era. There are a few proven and promising methods and standards-compliant tools
    for enabling the enigmatic orchestration goals.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 随着关键任务的应用程序主要是通过松散耦合但高度内聚的组件/服务构建，旨在在地理分布的IT基础设施和平台上运行，组合的概念受到了很多关注和吸引力。为了维持良好的容器化旅程，容器的编排被认为是在即时、自适应和智能的IT时代中最关键和至关重要的要求之一。有一些经过验证和有前途的方法和符合标准的工具，可以实现神秘的编排目标。
- en: Linking containers
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接容器
- en: One of the prominent features of the Docker technology is linking containers.
    That is, cooperating containers can be linked together to offer complex and business-aware
    services. The linked containers have a kind of source-recipient relationship,
    wherein the source container gets linked to the recipient container, and the recipient
    securely receives a variety of information from the source container. However,
    the source container would know nothing about the recipients to which it is linked
    to. Another noteworthy feature of linking containers, in a secured setup, is that
    the linked containers can communicate using secured tunnels without exposing the
    ports used for the setup, to the external world.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Docker技术的一个显著特点之一是链接容器。也就是说，合作容器可以链接在一起，提供复杂和业务感知的服务。链接的容器具有一种源-接收关系，其中源容器链接到接收容器，并且接收容器安全地从源容器接收各种信息。但是，源容器对其链接的接收者一无所知。链接容器的另一个值得注意的特性是，在安全设置中，链接的容器可以使用安全隧道进行通信，而不会将用于设置的端口暴露给外部世界。
- en: The Docker engine provides the `--link` option in the `docker run` subcommand
    to link a source container to a recipient container.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Docker引擎在`docker run`子命令中提供了`--link`选项，以将源容器链接到接收容器。
- en: 'The format of the `--link` option is as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`--link`选项的格式如下：'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `<container>` is the name of the source container and `<alias>` is the
    name seen by the recipient container. The name of the container must be unique
    in a Docker host, whereas alias is very specific and local to the recipient container,
    and hence, the alias need not be unique to the Docker host. This gives a lot of
    flexibility towards implementing and incorporating functionalities with a fixed
    source alias name inside the recipient container.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<container>`是源容器的名称，`<alias>`是接收容器看到的名称。容器的名称在Docker主机中必须是唯一的，而别名非常具体且局限于接收容器，因此别名不需要在Docker主机上是唯一的。这为在接收容器内部使用固定的源别名名称实现和整合功能提供了很大的灵活性。
- en: 'When two containers are linked together, the Docker engine automatically exports
    a few environment variables to the recipient container. These environment variables
    have a well-defined naming convention, where the variables are always prefixed
    with capitalized form of the alias name. For instance, if `src` is the alias name
    given to the source container, then the exported environment variables would begin
    with `SRC_`. Docker exports three categories of environment variables, as enumerated
    here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个容器链接在一起时，Docker引擎会自动向接收容器导出一些环境变量。这些环境变量具有明确定义的命名约定，其中变量始终以别名名称的大写形式作为前缀。例如，如果`src`是源容器的别名，则导出的环境变量将以`SRC_`开头。Docker导出三类环境变量，如下所列：
- en: '`NAME`: This is the first category of environment variables. This variable
    takes the form of `<ALIAS>_NAME`, and it carries the recipient container''s hierarchical
    name as its value. For instance, if the source container''s alias is `src` and
    the recipient container''s name is `rec`, then the environment variable and its
    value would be `SRC_NAME=/rec/src`.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`名称`：这是环境变量的第一类。这个变量采用`<ALIAS>_NAME`的形式，并将接收容器的分层名称作为其值。例如，如果源容器的别名是`src`，接收容器的名称是`rec`，那么环境变量及其值将是`SRC_NAME=/rec/src`。'
- en: '`ENV`: This is the second category of environment variables. These variables
    export the environment variables configured in the source container by the `-e`
    option of the `docker run` subcommand or the `ENV` instruction of `Dockerfile`.
    This type of an environment variable takes the form of `<ALIAS>_ENV_<VAR_NAME>`.
    For instance, if the source container''s alias is `src` and the variable name
    is `SAMPLE`, then the environment variable would be `SRC_ENV_SAMPLE`.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ENV`：这是环境变量的第二类。这些变量通过`docker run`子命令的`-e`选项或`Dockerfile`的`ENV`指令在源容器中配置的环境变量。这种类型的环境变量采用`<ALIAS>_ENV_<VAR_NAME>`的形式。例如，如果源容器的别名是`src`，变量名是`SAMPLE`，那么环境变量将是`SRC_ENV_SAMPLE`。'
- en: '`PORT`: This is the final and third category of environment variables that
    is used to export the connectivity details of the source container to the recipient.
    Docker creates a bunch of variables for each port exposed by the source container
    through the `-p` option of the `docker run` subcommand or the `EXPOSE` instruction
    of the `Dockerfile`.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PORT`：这是最终的第三类环境变量，用于将源容器的连接详细信息导出给接收方。Docker为源容器通过`docker run`子命令的`-p`选项或`Dockerfile`的`EXPOSE`指令暴露的每个端口创建一组变量。'
- en: 'These variables take the form:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量采用以下形式：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This form is used to share the source''s IP address, port, and protocol as
    an URL. For example, if the source container''s alias is `src`, the exposed port
    is `8080`, the protocol is `tcp`, and the IP address is `172.17.0.2`, then the
    environment variable and its value would be `SRC_PORT_8080_TCP=tcp://172.17.0.2:8080`.
    This URL further splits into the following three environment variables:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此形式用于共享源的IP地址、端口和协议作为URL。例如，如果源容器的别名是`src`，暴露的端口是`8080`，协议是`tcp`，IP地址是`172.17.0.2`，那么环境变量及其值将是`SRC_PORT_8080_TCP=tcp://172.17.0.2:8080`。此URL进一步分解为以下三个环境变量：
- en: '`<ALIAS>_PORT_<port>_<protocol>_ADDR`: This form carries the IP address part
    of the URL (For example: `SRC_PORT_8080_TCP_ADDR= 172.17.0.2`)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ALIAS>_PORT_<port>_<protocol>_ADDR`：此形式包含URL的IP地址部分（例如：`SRC_PORT_8080_TCP_ADDR=
    172.17.0.2`）'
- en: '`<ALIAS>_PORT_<port>_<protocol>_PORT`: This form carries the port part of the
    URL (For example: `SRC_PORT_8080_TCP_PORT=8080`)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ALIAS>_PORT_<port>_<protocol>_PORT`：此形式包含URL的端口部分（例如：`SRC_PORT_8080_TCP_PORT=8080`）'
- en: '`<ALIAS>_PORT_<port>_<protocol>_PROTO`: This form carries the protocol part
    of the URL (For example: `SRC_PORT_8080_TCP_PROTO=tcp`)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ALIAS>_PORT_<port>_<protocol>_PROTO`：此形式包含URL的协议部分（例如：`SRC_PORT_8080_TCP_PROTO=tcp`）'
- en: In addition to the preceding environment variables, the Docker engine exports
    one more variable in this category, that is, of the form `<ALIAS>_PORT`, and its
    value would be the URL of the lowest number of all the exposed ports of the source
    container. For instance, if the source container's alias is `src`, the exposed
    port numbers are `7070`, `8080`, and `80`, the protocol is `tcp`, and the IP address
    is `172.17.0.2`, then the environment variable and its value would be `SRC_PORT=tcp://172.17.0.2:80`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前述的环境变量之外，Docker引擎还在此类别中导出了一个变量，即`<ALIAS>_PORT`的形式，其值将是源容器暴露的所有端口中最低的URL。例如，如果源容器的别名是`src`，暴露的端口号是`7070`、`8080`和`80`，协议是`tcp`，IP地址是`172.17.0.2`，那么环境变量及其值将是`SRC_PORT=tcp://172.17.0.2:80`。
- en: Docker exports these auto-generated environment variables in a well-structured
    format so that they can be easily discovered programmatically. Thus, it becomes
    very easy for the recipient container to discover the information about the source
    container. In addition, Docker automatically updates the source IP address and
    its alias as an entry in the recipient's `/etc/hosts` file.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Docker以良好结构的格式导出这些自动生成的环境变量，以便可以轻松地通过程序发现。因此，接收容器可以很容易地发现有关源容器的信息。此外，Docker会自动将源IP地址及其别名更新为接收容器的`/etc/hosts`文件中的条目。
- en: In this chapter, we will take you deep into the mentioned features provided
    by the Docker engine for container linkage through a bevy of pragmatic examples.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过一系列实用示例深入介绍Docker引擎提供的容器链接功能。
- en: 'To start with, let''s choose a simple container linking example. Here, we will
    show you how to establish a linkage between two containers, and transfer some
    basic information from the source container to the recipient container, as illustrated
    in the following steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们选择一个简单的容器链接示例。在这里，我们将向您展示如何在两个容器之间建立链接，并将一些基本信息从源容器传输到接收容器，如下所示的步骤：
- en: 'We begin by launching an interactive container that can be used as a source
    container for linking, using the following command:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先启动一个交互式容器，可以作为链接的源容器使用，使用以下命令：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The container is named `example` using the `--name` option. In addition, the
    `--rm` option is used to clean up the container as soon as you exit from the container.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 容器使用`--name`选项命名为`example`。此外，使用`--rm`选项在退出容器时清理容器。
- en: 'Display the `/etc/hosts` entry of the source container using the `cat` command:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cat`命令显示源容器的`/etc/hosts`条目：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the first entry in the `/etc/hosts` file is the source container's IP
    address (`172.17.0.3`) and its hostname (`a02895551686`).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`/etc/hosts`文件中的第一个条目是源容器的IP地址（`172.17.0.3`）和其主机名（`a02895551686`）。
- en: 'We will continue to display the environment variables of the source container
    using the `env` command:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续使用`env`命令显示源容器的环境变量：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Having launched the source container, from another terminal of the same Docker
    host, let''s launch an interactive recipient container by linking it to our source
    container using the `--link` option of the `docker run` subcommand, as shown here:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动源容器后，从相同Docker主机的另一个终端，让我们使用`docker run`子命令的`--link`选项启动一个交互式接收容器，将其链接到我们的源容器，如下所示：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, the source container named `example` is linked to the recipient container
    with `ex` as its alias.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，名为`example`的源容器与接收容器链接，其别名为`ex`。
- en: 'Let''s display the content of the `/etc/hosts` file of the recipient container
    using the `cat` command:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`cat`命令显示接收容器的`/etc/hosts`文件的内容：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Of course, as always, the first entry of the `/etc/hosts` file is the container's
    IP address and its hostname. However, the noteworthy entry in the `/etc/hosts`
    file is the last entry, where the source container's IP address (`172.17.0.3`)
    and its alias (`ex`) are added automatically.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，像往常一样，`/etc/hosts`文件的第一个条目是容器的IP地址和其主机名。然而，`/etc/hosts`文件中值得注意的条目是最后一个条目，其中源容器的IP地址（`172.17.0.3`）和其别名（`ex`）会自动添加。
- en: 'We will continue to display the recipient container''s environment variable
    using the `env` command:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续使用`env`命令显示接收容器的环境变量：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Apparently, a new `EX_NAME` environment variable is added automatically to `/berserk_mcclintock/ex`,
    as its value. Here `EX` is the capitalized form of the alias `ex` and `berserk_mcclintock`
    is the auto-generated name of the recipient container.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，一个新的`EX_NAME`环境变量会自动添加到`/berserk_mcclintock/ex`，作为其值。这里`EX`是别名`ex`的大写形式，`berserk_mcclintock`是接收容器的自动生成名称。
- en: 'As a final step, ping the source container using the widely used `ping` command
    for two counts, and use the alias name as the ping address:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步，使用广泛使用的`ping`命令对源容器进行两次ping，并使用别名作为ping地址：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Evidently, the source container's alias `ex` is resolved to the IP address `172.17.0.3`,
    and the recipient container is able to successfully reach the source. In the case
    of secured container communication, pinging between containers is not allowed.
    We have given more details on the aspect of securing containers in [Chapter 11](ch11.html
    "Chapter 11. Securing Docker Containers"), *Securing Docker Containers*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，源容器的别名`ex`被解析为IP地址`172.17.0.3`，并且接收容器能够成功到达源容器。在安全容器通信的情况下，容器之间是不允许ping的。我们在[第11章](ch11.html
    "第11章 安全Docker容器")中对保护容器方面进行了更多详细说明，*保护Docker容器*。
- en: In the preceding example, we could link two containers together, and also, observe
    how elegantly, networking is enabled between the containers by updating the source
    container's IP address in the `/etc/hosts` file of the recipient container.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以将两个容器链接在一起，并且观察到源容器的IP地址如何优雅地更新到接收容器的`/etc/hosts`文件中，从而实现容器之间的网络连接。
- en: 'The next example is to demonstrate how container-linking exports the source
    container''s environment variables, which are configured using the `-e` option
    of the `docker run` subcommand or the `ENV` instruction of `Dockerfile`, to the
    recipient container. For this purpose, we are going to craft a `Dockerfile` with
    the `ENV` instruction, build an image, launch a source container using this image,
    and then launch a recipient container by linking it to the source container:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例是演示容器链接如何导出源容器的环境变量，这些环境变量是使用`docker run`子命令的`-e`选项或`Dockerfile`的`ENV`指令配置的，然后导入到接收容器中。为此，我们将编写一个带有`ENV`指令的`Dockerfile`，构建一个镜像，使用该镜像启动一个源容器，然后通过链接到源容器来启动一个接收容器：
- en: 'We begin with composing a `Dockerfile` with the `ENV` instruction, as shown
    here:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先编写一个带有`ENV`指令的`Dockerfile`，如下所示：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we are setting up two environment variables `BOOK` and `CHAPTER`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了两个环境变量`BOOK`和`CHAPTER`。
- en: 'Proceed with building a Docker image `envex` using the `docker build` subcommand
    from the preceding `Dockerfile`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续使用前面的`Dockerfile`从头构建一个名为`envex`的Docker镜像：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s launch an interactive source container with the name `example`
    using the `envex` image, we just built:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用刚刚构建的`envex`镜像启动一个交互式源容器，名称为`example`：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'From the source container prompt, display all the environment variables by
    invoking the `env` command:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从源容器提示符中，通过调用`env`命令显示所有环境变量：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In all the preceding environment variables, both the `BOOK` and the `CHAPTER`
    variables are configured with the `ENV` instruction of the `Dockerfile`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前述的环境变量中，`BOOK`和`CHAPTER`变量都是使用`Dockerfile`的`ENV`指令配置的。
- en: 'As a final step, to illustrate the `ENV` category of environment variables,
    launch the recipient container with the `env` command, as shown here:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步，为了说明环境变量的`ENV`类别，启动接收容器并使用`env`命令，如下所示：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example is also available on GitHub at [https://github.com/thedocker/learning-docker/blob/master/chap08/Dockerfile-Env](https://github.com/thedocker/learning-docker/blob/master/chap08/Dockerfile-Env).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例也可以在GitHub上找到：[https://github.com/thedocker/learning-docker/blob/master/chap08/Dockerfile-Env](https://github.com/thedocker/learning-docker/blob/master/chap08/Dockerfile-Env)。
- en: Strikingly, in the preceding output, the variables that are prefixed with `EX_`
    are the outcomes of container-linking. The environment variables of interest are
    `EX_ENV_BOOK` and `EX_ENV_CHAPTER`, which were originally set through the `Dockerfile`
    as `BOOK` and `CHAPTER` but modified to `EX_ENV_BOOK` and `EX_ENV_CHAPTER`, as
    an effect of container-linking. Though the environment variable names get translated,
    the values stored in these environment variables are preserved as is. We already
    discussed the `EX_NAME` variable name in the previous example.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 引人注目的是，在前面的输出中，以`EX_`为前缀的变量是容器链接的结果。感兴趣的环境变量是`EX_ENV_BOOK`和`EX_ENV_CHAPTER`，它们最初是通过`Dockerfile`设置为`BOOK`和`CHAPTER`，但由于容器链接而修改为`EX_ENV_BOOK`和`EX_ENV_CHAPTER`。尽管环境变量名称被翻译，但存储在这些环境变量中的值保持不变。我们在前面的示例中已经讨论了`EX_NAME`变量名。
- en: In the preceding example, we could experience how elegantly and effortlessly
    Docker exports the `ENV` category variables from the source container to the recipient
    container. These environment variables are completely decoupled from the source
    and the recipient, thus the change in the value of these environment variables
    in one container does not impact the other. To be even more precise, the values
    the recipient container receives are the values set during the launch time of
    the source container. Any changes made to the value of these environment variables
    in the source container after its launch has no effect on the recipient container.
    It does not matter when the recipient container is launched because the values
    are being read from the JSON file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以体验到Docker如何优雅而轻松地将源容器中的`ENV`类别变量导出到接收容器中。这些环境变量与源和接收完全解耦，因此一个容器中这些环境变量值的更改不会影响另一个容器。更准确地说，接收容器接收的值是在启动源容器时设置的值。在源容器启动后对这些环境变量值进行的任何更改都不会影响接收容器。接收容器的启动时间并不重要，因为这些值是从JSON文件中读取的。
- en: 'In our final illustration of linking containers, we are going to show you how
    to take advantage of the Docker feature to share the connectivity details between
    two containers. In order to share the connectivity details between containers,
    Docker uses the `PORT` category of environment variables. The following are the
    steps used to craft two containers and share the connectivity details between
    them:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最后的容器链接示例中，我们将向您展示如何利用Docker功能来共享两个容器之间的连接详细信息。为了共享容器之间的连接详细信息，Docker使用环境变量的`PORT`类别。以下是用于创建两个容器并共享它们之间连接详细信息的步骤：
- en: 'Craft a `Dockerfile` to expose port `80` and `8080` using the `EXPOSE` instruction,
    as shown here:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`Dockerfile`，使用`EXPOSE`指令来公开端口`80`和`8080`，如下所示：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Proceed to build a Docker image `portex` using the `docker build` subcommand
    from the `Dockerfile`, we created just now, by running the following command:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续使用`docker build`子命令从刚刚创建的`Dockerfile`构建Docker镜像`portex`，运行以下命令：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s launch an interactive source container with the name, `example`
    using the earlier built image `portex`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用之前构建的镜像`portex`启动一个名为`example`的交互式源容器：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that we have launched the source container, let''s continue to create a
    recipient container on another terminal by linking it to the source container,
    and invoke the `env` command to display all the environment variables, as shown
    here:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经启动了源容器，让我们继续在另一个终端上创建一个接收容器，并将其链接到源容器，然后调用`env`命令来显示所有环境变量，如下所示：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example is also available on GitHub at [https://github.com/thedocker/learning-docker/blob/master/chap08/Dockerfile-Expose](https://github.com/thedocker/learning-docker/blob/master/chap08/Dockerfile-Expose).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例也可以在GitHub上找到：[https://github.com/thedocker/learning-docker/blob/master/chap08/Dockerfile-Expose](https://github.com/thedocker/learning-docker/blob/master/chap08/Dockerfile-Expose)。
- en: From the preceding output of the `env` command, it is quite evident that, the
    Docker engine exported a bunch of four `PORT` category environment variables for
    each port that was exposed using the `EXPOSE` instruction in the `Dockerfile`.
    In addition, Docker also exported another `PORT` category variable `EX_PORT`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从`env`命令的前面输出可以很明显地看出，Docker引擎为每个使用`Dockerfile`中的`EXPOSE`指令暴露的端口导出了一组四个`PORT`类别的环境变量。此外，Docker还导出了另一个`PORT`类别的变量`EX_PORT`。
- en: Orchestration of containers
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器的编排
- en: The pioneering concept of orchestration in the IT domain has been there for
    a long time now. For instance, in the **service computing** (**SC**) arena, the
    idea of service orchestration has been thriving in an unprecedented manner in
    order to produce and sustain highly robust and resilient services. Discrete or
    atomic services do not serve any substantial purpose unless, they are composed
    together in a particular sequence to derive process-aware composite services.
    As orchestrated services are more strategically advantageous for businesses in
    expressing and exposing their unique capabilities in the form of identifiable/discoverable,
    interoperable, usable, and composable services to the outside world; corporates
    are showing exemplary interest in having an easily searchable repository of services
    (atomic as well as composite). This repository, in turn, enables businesses in
    realizing large-scale data as well as process-intensive applications. It is clear
    that the multiplicity of services is very pivotal for organizations to grow and
    glow. This increasingly mandated requirement gets solved using the proven and
    promising orchestration capabilities, cognitively.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: IT领域中编排的开创性概念已经存在很长时间了。例如，在**服务计算**（**SC**）领域，服务编排的概念以前所未有的方式蓬勃发展，以生产和维护高度健壮和有弹性的服务。离散或原子服务除非按特定顺序组合在一起以获得具有过程感知的复合服务，否则不会起到实质作用。由于编排服务在表达和展示企业独特能力方面更具战略优势，可以以可识别/可发现、可互操作、可用和可组合的服务形式向外界展示；企业对拥有一个易于搜索的服务库（原子和复合）表现出了极大的兴趣。反过来，这个库使企业能够实现大规模的数据和过程密集型应用。很明显，服务的多样性对于组织的增长和发展非常关键。这个日益受到强制要求的需求通过经过验证和有前途的编排能力得到了解决，具有认知能力。
- en: Now, as we are fast heading toward containerized IT environments; application
    and data containers ought to be smartly composed to realize a host of new generation
    software services.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着我们迅速向容器化的IT环境迈进；应用程序和数据容器应该被巧妙地组合起来，以实现一系列新一代软件服务。
- en: However, for producing highly competent orchestrated containers, both purpose-specific
    as well as agnostic containers need to be meticulously selected and launched in
    the right sequence in order to create orchestrated containers. The sequence can
    come from the process (control as well as data) flow diagrams. Doing this complicated
    and daunting activity manually evokes a series of cynicisms and criticisms. Fortunately,
    there are orchestration tools in the Docker space that come in handy to build,
    run, and manage multiple containers to build enterprise-class services. The Docker
    firm, which has been in charge of producing and promoting, the generation, and
    assembling of, Docker-inspired containers, has come out with a standardized and
    simplified orchestration tool (named as `docker-compose`) in order to reduce the
    workloads of developers as well as system administrators.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要生成高度有效的编排容器，需要精心选择并按正确顺序启动特定目的和不可知目的的容器，以创建编排容器。顺序可以来自过程（控制和数据）流程图。手动完成这一复杂而艰巨的活动引发了一系列怀疑和批评。幸运的是，在Docker领域有编排工具可以帮助构建、运行和管理多个容器，以构建企业级服务。Docker公司负责生产和推广Docker启发的容器的生成和组装，推出了一种标准化和简化的编排工具（名为`docker-compose`），以减轻开发人员和系统管理员的工作负担。
- en: The proven composition technique of the service computing paradigm is being
    replicated here in the raging containerization paradigm in order to reap the originally
    envisaged benefits of containerization, especially in building powerful application-aware
    containers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 服务计算范式的成熟组合技术正在这里复制到激烈的容器化范式中，以实现容器化最初设想的好处，特别是构建功能强大的应用程序感知容器。
- en: The **microservice architecture** is an architectural concept that aims to decouple
    a software solution by decomposing its functionality into a pool of discrete services.
    This is done by applying the standard principles at the architectural level. The
    microservice architecture is slowly emerging as a championed way to design and
    build large-scale IT and business systems. It not only facilitates loose and light
    coupling and software modularity, but it is also a boon to continuous integration
    and deployment for the agile world. Any changes being made to one part of the
    application mandate has meant, massive changes being made to the application.
    This has been a bane and barrier to the aspect of continuous deployment. Micro
    services aim to resolve this situation, and hence, the microservice architecture
    needs light-weight mechanisms, small, independently deployable services, and ensures
    scalability and portability. These requirements can be met using Docker-sponsored
    containers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是一种旨在通过将其功能分解为一组离散服务的架构概念，以解耦软件解决方案的方法。这是通过在架构层面应用标准原则来实现的。微服务架构正在逐渐成为设计和构建大规模IT和业务系统的主导方式。它不仅有助于松散和轻量级耦合和软件模块化，而且对于敏捷世界的持续集成和部署也是一个福音。对应用程序的任何更改都意味着必须进行大规模的更改。这一直是持续部署方面的一大障碍。微服务旨在解决这种情况，因此，微服务架构需要轻量级机制、小型、可独立部署的服务，并确保可扩展性和可移植性。这些要求可以通过Docker赞助的容器来满足。
- en: Micro services are being built around business capabilities and can be independently
    deployed by fully automated deployment machinery. Each micro service can be deployed
    without interrupting the other micro services, and containers provide an ideal
    deployment and execution environment for these services along with other noteworthy
    facilities, such as the reduced time of deployment, isolation management, and
    a simple life cycle. It is easy to quickly deploy new versions of services inside
    containers. All of these factors led to the explosion of micro services using
    the features that Docker had to offer.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是围绕业务能力构建的，并且可以通过完全自动化的部署机制独立部署。每个微服务都可以在不中断其他微服务的情况下部署，容器为这些服务提供了理想的部署和执行环境，以及其他值得注意的设施，如减少部署时间、隔离管理和简单的生命周期。在容器内快速部署新版本的服务非常容易。所有这些因素导致了使用Docker提供的功能爆炸般的微服务增长。
- en: As explained, Docker is being posited as the next-generation containerization
    technology, which provides a proven and potentially sound mechanism to distribute
    applications in a highly efficient and distributed fashion. The beauty is that
    developers can tweak the application pieces within the container, while maintaining
    the overall integrity of the container. This has a bigger impact as the brewing
    trend is that, instead of large monolithic applications hosted on a single physical
    or virtual server, companies are building smaller, self-defined, easily manageable,
    and discrete services to be contained inside standardized and automated containers.
    In short, the raging containerization technology from Docker has come as a boon
    for the ensuing era of micro services.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所解释的，Docker被提出作为下一代容器化技术，它提供了一种经过验证且潜在有效的机制，以高效和分布式的方式分发应用程序。美妙之处在于开发人员可以在容器内调整应用程序的部分，同时保持容器的整体完整性。这对于当前的趋势有着更大的影响，即公司正在构建更小、自定义、易于管理和离散的服务，以包含在标准化和自动化的容器内，而不是托管在单个物理或虚拟服务器上的大型单片应用程序。简而言之，来自Docker的狂热容器化技术已成为即将到来的微服务时代的福音。
- en: Docker was built and sustained to fulfill the elusive goal of *run it once and
    run it everywhere*. Docker containers are generally isolated at process level,
    portable across IT environments, and easily repeatable. A single physical host
    can host multiple containers, and hence, every IT environment is generally stuffed
    with a variety of Docker containers. The unprecedented growth of containers is
    to spell out troubles for effective container management. The multiplicity and
    the associated heterogeneity of containers are used to sharply increase the management
    complexities of containers. Hence, the technique of orchestration and the flourishing
    orchestration tools have come as a strategic solace for accelerating the containerization
    journey in safe waters.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的建立和持续发展是为了实现“运行一次，到处运行”的难以捉摸的目标。Docker容器通常在进程级别上进行隔离，在IT环境中可移植，并且易于重复。单个物理主机可以托管多个容器，因此，每个IT环境通常都充斥着各种Docker容器。容器的空前增长意味着有效的容器管理存在问题。容器的多样性和相关的异质性被用来大幅增加容器管理的复杂性。因此，编排技术和蓬勃发展的编排工具已成为加速容器化旅程的战略安慰，使其安全地前行。
- en: Orchestrating applications that span multiple containers containing micro services
    has become a major part of the Docker world, via projects, such as Google's Kubernetes
    or Flocker. Decking is another option used to facilitate the orchestration of
    Docker containers. Docker's new offering in this area is a set of three orchestration
    services designed to cover all aspects of the dynamic life cycle of distributed
    applications from application development to deployment and maintenance. Helios
    is another Docker orchestration platform used to deploy and manage containers
    across an entire fleet. In the beginning, `fig` was the most preferred tool for
    container orchestration. However, in the recent past, the company at the forefront
    of elevating the Docker technology has come out with an advanced container orchestration
    tool (`docker-compose`) to make life easier for developers working with Docker
    containers, as they move through the container life cycle.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 编排跨越包含微服务的多个容器的应用程序已经成为Docker世界的一个重要部分，通过项目，如Google的Kubernetes或Flocker。 Decking是另一个选项，用于促进Docker容器的编排。
    Docker在这个领域的新提供是一套三个编排服务，旨在涵盖分布式应用程序的动态生命周期的所有方面，从应用程序开发到部署和维护。 Helios是另一个Docker编排平台，用于在整个舰队中部署和管理容器。起初，“fig”是最受欢迎的容器编排工具。然而，在最近，处于提升Docker技术前沿的公司推出了一种先进的容器编排工具（`docker-compose`），以使开发人员在处理Docker容器时更加轻松，因为它们通过容器生命周期。
- en: Having realized the significance of having the capability of container orchestration
    for next generation, business-critical, and containerized workloads, the Docker
    company purchased the company that originally conceived and concretized the `fig`
    tool. Then, the Docker company appropriately renamed the tool as `docker-compose`
    and brought in a good number of enhancements to make the tool more tuned to the
    varying expectations of container developers and operation teams.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 意识到对于下一代、业务关键和容器化工作负载具有容器编排能力的重要性后，Docker公司收购了最初构想和具体化“fig”工具的公司。然后，Docker公司适当地将该工具更名为`docker-compose`，并引入了大量增强功能，使该工具更加符合容器开发人员和运营团队的不断变化的期望。
- en: Here is a gist of `docker-compose`, which is being positioned as a futuristic
    and flexible tool used for defining and running complex applications with Docker.
    With `docker-compose`, you define your application's components (their containers,
    configuration, links, volumes, and so on) in a single file, and then, you can
    spin everything up with a single command, which does everything to get it up and
    running.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`docker-compose`的要点，它被定位为一种用于定义和运行复杂应用程序的未来和灵活的工具。使用`docker-compose`，您可以在单个文件中定义应用程序的组件（它们的容器、配置、链接、卷等），然后，您可以用一个命令启动所有内容，这样就可以使其运行起来。
- en: This tool simplifies the container management by providing a set of built-in
    tools to do a number of jobs that are being performed manually at this point in
    time. In this section, we supply all the details for using `docker-compose` to
    perform orchestration of containers in order to have a stream of next-generation
    distributed applications.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具通过提供一组内置工具来简化容器管理，以执行目前手动执行的许多工作。在本节中，我们提供了使用`docker-compose`执行容器编排的所有细节，以便拥有一系列下一代分布式应用程序。
- en: Orchestrate containers using docker-compose
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用docker-compose编排容器
- en: In this section, we will discuss the widely used container orchestration tool
    `docker-compose`. The `docker-compose` tool is a very simple, yet powerful tool
    and has been conceived and concretized to facilitate the running of a group of
    Docker containers. In other words, `docker-compose` is an orchestration framework
    that lets you define and control a multi-container service.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论广泛使用的容器编排工具`docker-compose`。`docker-compose`工具是一个非常简单但功能强大的工具，旨在简化运行一组Docker容器。换句话说，`docker-compose`是一个编排框架，可以定义和控制多容器服务。
- en: It enables you to create a fast and isolated development environment as well
    as the ability to orchestrate multiple Docker containers in production. The `docker-compose`
    tool internally leverages the Docker engine for pulling images, building the images,
    starting the containers in a correct sequence, and making the right connectivity/linking
    among the containers/services based on the definition given in the `docker-compose.yml`
    file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它使您能够创建一个快速和隔离的开发环境，以及在生产环境中编排多个Docker容器的能力。`docker-compose`工具在内部利用Docker引擎来拉取镜像、构建镜像、按正确顺序启动容器，并根据`docker-compose.yml`文件中给定的定义在容器/服务之间进行正确的连接/链接。
- en: Installing docker-compose
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装docker-compose
- en: At the time of writing this book, the latest release of `docker-compose` is
    1.2.0, and it is recommended that you use it with Docker release 1.3 or above.
    You can find the latest official release of `docker-compose` at the GitHub location
    ([https://github.com/docker/compose/releases/latest](https://github.com/docker/compose/releases/latest)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，最新版本的`docker-compose`是1.2.0，建议您将其与Docker 1.3或更高版本一起使用。您可以在GitHub位置([https://github.com/docker/compose/releases/latest](https://github.com/docker/compose/releases/latest))找到最新的官方发布的`docker-compose`。
- en: 'The Linux x86-64 binary for `docker-compose` version 1.2.0 is available at
    [https://github.com/docker/compose/releases/download/1.2.0/docker-compose-Linux-x86_64](https://github.com/docker/compose/releases/download/1.2.0/docker-compose-Linux-x86_64),
    which you can directly install using either the `wget` tool or the `curl` tool,
    as shown here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose`版本1.2.0的Linux x86-64二进制文件可在[https://github.com/docker/compose/releases/download/1.2.0/docker-compose-Linux-x86_64](https://github.com/docker/compose/releases/download/1.2.0/docker-compose-Linux-x86_64)下载，您可以直接使用`wget`工具或`curl`工具进行安装，如下所示：'
- en: 'Using the `wget` tool:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`wget`工具：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using the `curl` tool:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`curl`工具：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, `docker-compose` is also available as a Python package, which
    you can install using the `pip` installer, as shown here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`docker-compose`也作为一个Python包可用，您可以使用`pip`安装程序进行安装，如下所示：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that if `pip` is not installed on the system, please install the `pip`
    package before the `docker-compose` installation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果系统上未安装`pip`，请在安装`docker-compose`之前安装`pip`包。
- en: 'Having successfully installed `docker-compose`, you can check the `docker-compose`
    version, as shown here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 成功安装`docker-compose`后，您可以检查`docker-compose`的版本，如下所示：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The docker-compose.yml file
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker-compose.yml文件
- en: 'The `docker-compose` tool orchestrates containers using the `docker-compose.yml`
    file, in which you can define the services that need to be crafted, the relationships
    between these services, and their runtime properties. The `docker-compose.yml`
    file is a **YAML Ain''t Markup Language** (**YAML**) format file, which is a human-friendly
    data serialization format. The default `docker-compose` file is `docker-compose.yml`,
    which can be changed using the `-f` option of the `docker-compose` tool. The following
    is the format of the `docker-compose.yml` file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose`工具使用`docker-compose.yml`文件编排容器，在其中可以定义需要创建的服务、这些服务之间的关系以及它们的运行时属性。`docker-compose.yml`文件是**YAML
    Ain''t Markup Language**（**YAML**）格式文件，这是一种人类友好的数据序列化格式。默认的`docker-compose`文件是`docker-compose.yml`，可以使用`docker-compose`工具的`-f`选项进行更改。以下是`docker-compose.yml`文件的格式：'
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, `<service>` is the name of the service. You can have more than one service
    definition in a single `docker-compose.yml` file. The service name should be followed
    by one or more keys. However, all the services must either have an `image` or
    a `build` key, followed by any number of optional keys. Except the `image` and
    `build` keys, the rest of the keys can be directly mapped to the options in the
    `docker run` subcommand. The value can be either a single value or multiple values.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<service>`是服务的名称。您可以在单个`docker-compose.yml`文件中有多个服务定义。服务名称后面应跟一个或多个键。但是，所有服务必须具有`image`或`build`键，后面可以跟任意数量的可选键。除了`image`和`build`键之外，其余的键可以直接映射到`docker
    run`子命令中的选项。值可以是单个值或多个值。
- en: 'The following is a list of keys supported in the `docker-compose` version 1.2.0:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`docker-compose`版本1.2.0中支持的键列表：
- en: '`image`: This is the tag or image ID'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`：这是标签或镜像ID'
- en: '`build`: This is the path to a directory containing a `Dockerfile`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`：这是包含`Dockerfile`的目录路径'
- en: '`command`: This key overrides the default command'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command`：此键覆盖默认命令'
- en: '`links`: This key links to containers in another service'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`links`：此键链接到另一个服务中的容器'
- en: '`external_links`: This key links to containers started either by some other
    `docker-compose.yml` or by some other means (not by `docker-compose`)'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`external_links`：此键链接到由其他`docker-compose.yml`或其他方式（而不是`docker-compose`）启动的容器'
- en: '`ports`: This key exposes ports and specifies both the ports `HOST_port:CONTAINER_port`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports`：此键公开端口并指定端口`HOST_port:CONTAINER_port`'
- en: '`expose`: This key exposes ports without publishing them to the host machine'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expose`：此键公开端口，但不将其发布到主机'
- en: '`volumes`: This key mounts paths as volumes'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volumes`：此键将路径挂载为卷'
- en: '`volumes_from`: This key mounts all of the volumes from another container'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volumes_from`：此键从另一个容器挂载所有卷'
- en: '`environment`: This adds environment variables and uses either an array or
    a dictionary'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment`：此键添加环境变量，并使用数组或字典'
- en: '`env_file`: This adds environment variables to a file'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env_file`：此键将环境变量添加到文件'
- en: '`extends`: This extends another service defined in the same or different configuration
    file'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extends`：这扩展了同一或不同配置文件中定义的另一个服务'
- en: '`net`: This is the networking mode, which has the same values as the Docker
    client `--net` option'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net`：这是网络模式，具有与Docker客户端`--net`选项相同的值'
- en: '`pid`: This enables the PID space sharing between the host and the containers'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pid`：这使主机和容器之间共享PID空间'
- en: '`dns`: This sets custom DNS servers'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dns`：这设置自定义DNS服务器'
- en: '`cap_add`: This adds a capability to the container'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cap_add`：这会向容器添加一个功能'
- en: '`cap_drop`: This drops a capability of the container'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cap_drop`：这会删除容器的某个功能'
- en: '`dns_search`: This sets custom DNS search servers'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dns_search`：这设置自定义DNS搜索服务器'
- en: '`working_dir`: This changes the working directory inside the container'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`working_dir`：这会更改容器内的工作目录'
- en: '`entrypoint`: This overrides the default entrypoint'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entrypoint`：这会覆盖默认的入口点'
- en: '`user`: This sets the default user'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`用户`: 这设置默认用户'
- en: '`hostname`: This sets a container''s host name'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`主机名`: 这设置了容器的主机名'
- en: '`domainname`: This sets the domain name'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`域名`: 这设置域名'
- en: '`mem_limit`: This limits the memory'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mem_limit`: 这限制内存'
- en: '`privileged`: This gives extended privileges'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`特权`: 这给予扩展权限'
- en: '`restart`: This sets the restart policy of the container'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`重启`: 这设置容器的重启策略'
- en: '`stdin_open`: This enables the standard input facility'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stdin_open`: 这启用标准输入设施'
- en: '`tty`: This enables text based control such as a terminal'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tty`: 这启用基于文本的控制，如终端'
- en: '`cpu_shares`: This sets the CPU shares (relative weight)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpu_shares`: 这设置CPU份额(相对权重)'
- en: The docker-compose command
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker-compose命令
- en: 'The `docker-compose` tool provides sophisticated orchestration functionality
    with a handful of commands. All the `docker-compose` commands use the `docker-compose.yml`
    file as the base to orchestrate one or more services. The following is the syntax
    of the `docker-compose` command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose`工具提供了一些命令的复杂编排功能。所有`docker-compose`命令都使用`docker-compose.yml`文件作为一个或多个服务的编排基础。以下是`docker-compose`命令的语法:'
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `docker-compose` tool supports the following options:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose`工具支持以下选项:'
- en: '`--verbose`: This shows more output'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--verbose`: 这显示更多输出'
- en: '`--version`: This prints the version and exits'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--版本`: 这打印版本并退出'
- en: '`-f, --file <file>`: This specifies an alternate file for `docker-compose`
    (default is the `docker-compose.yml` file)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f, --file <file>`: 这指定`docker-compose`的替代文件(默认为`docker-compose.yml`文件)'
- en: '`-p`, `--project-name <name>`: This specifies an alternate project name (default
    is the directory name)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`, `--project-name <name>`: 这指定替代项目名称(默认为目录名称)'
- en: 'The `docker-compose` tool supports the following commands:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose`工具支持以下命令:'
- en: '`build`: This builds or rebuilds services'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`构建`: 这构建或重建服务'
- en: '`kill`: This kills containers'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`杀死`: 这杀死容器'
- en: '`logs`: This displays the output from the containers'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`日志`: 这显示容器的输出'
- en: '`port`: This prints the public port for a port binding'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`端口`: 这打印端口绑定的公共端口'
- en: '`ps`: This lists the containers'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps`: 这列出容器'
- en: '`pull`: This pulls the service images'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`拉取`: 这拉取服务镜像'
- en: '`rm`: This removes the stopped containers'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm`: 这删除已停止的容器'
- en: '`run`: This runs a one-off command'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`运行`: 这运行一次性命令'
- en: '`scale`: This sets a number of containers for a service'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`规模`: 这为服务设置容器数量'
- en: '`start`: This starts services'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`开始`: 这启动服务'
- en: '`stop`: This stops services'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`停止`: 这停止服务'
- en: '`up`: This creates and starts containers'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`启动`: 这创建并启动容器'
- en: Common usage
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见用法
- en: 'In this section, with the help of an example, we are going to experience the
    power of the orchestration feature provided by the Docker-Compose framework. For
    this purpose, we are going to build a two-tiered web application that will receive
    your inputs through a URL and respond back with the associated response text.
    This application is built using the following two services, as enumerated here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '在本节中，我们将通过一个示例来体验Docker-Compose框架提供的编排功能的威力。为此，我们将构建一个接收您输入的URL并以相关响应文本回复的两层Web应用程序。该应用程序使用以下两个服务构建，如下所列:'
- en: '`Redis`: This is a key-value database used to store a key and its associated
    value'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Redis`: 这是一个用于存储键和其关联值的键值数据库'
- en: '`Node.js`: This is a JavaScript runtime environment used to implement web server
    functionality as well as the application logic'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Node.js`: 这是一个用于实现Web服务器功能和应用逻辑的JavaScript运行环境'
- en: 'Each of these services is packed inside two different containers that are stitched
    together using the `docker-compose` tool. The following is the architectural representation
    of the services:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '这些服务中的每一个都打包在两个不同的容器中，这些容器使用`docker-compose`工具进行组合。以下是服务的架构表示:'
- en: '![Common usage](graphics/7937OT_08_01.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![常见用法](graphics/7937OT_08_01.jpg)'
- en: Here, in this example, we begin with implementing the `example.js` module, a
    `node.js` file to realize the web server and the key lookup functionality. Further
    on, we will craft the `Dockerfile` on the same directory as `example.js` to package
    the `node.js` runtime environment, and then, define the service orchestration
    using a `docker-compose.yml` file on the same directory as `example.js`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先实现了`example.js`模块，这是一个`node.js`文件，用于实现Web服务器和键查找功能。接下来，我们将在与`example.js`相同的目录中编写`Dockerfile`，以打包`node.js`运行环境，然后使用与`example.js`相同的目录中的`docker-compose.yml`文件定义服务编排。
- en: 'The following is the `example.js` file, which is a `node.js` implementation
    of the simple Request/Response web application. For demonstration purposes, in
    this code, we restrict the `build` and `kill docker-compose` commands. For the
    code to be self-explanatory, we added the comments in between the code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`example.js`文件，它是一个简单的请求/响应Web应用程序的`node.js`实现。为了便于演示，在这段代码中，我们限制了`build`和`kill
    docker-compose`命令。为了使代码更加易懂，我们在代码之间添加了注释：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example is also available at [https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose](https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例也可在[https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose](https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose)找到。
- en: 'The following text is the content of `Dockerfile` that packs the `node.js`
    image, the `redis` driver for `node.js`, and the `example.js` file as defined
    earlier:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文本是`Dockerfile`的内容，该文件打包了`node.js`镜像、`node.js`的`redis`驱动程序和之前定义的`example.js`文件：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This code is also available at [https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose](https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码也可在[https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose](https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose)找到。
- en: 'The following text is from the `docker-compose.yml` file that the defines the
    service orchestration for `docker compose` tool to act upon:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文本来自`docker-compose.yml`文件，该文件定义了`docker compose`工具要执行的服务编排：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example is also available at [https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose](https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例也可在[https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose](https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose)找到。
- en: 'We defined two services in this `docker-compose.yml` file, wherein these services
    serve the following purposes:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个`docker-compose.yml`文件中定义了两个服务，这些服务有以下用途：
- en: The service named `web` is built using the `Dockerfile` in the current directory.
    Also, it is instructed to launch the container by running the node (the `node.js`
    runtime) with `/myapp/example.js` (web application implementation), as its argument.
    The container is linked to the `redis` container, and the container port `80`
    is mapped to the Docker host's port `8080`.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名为`web`的服务是使用当前目录中的`Dockerfile`构建的。同时，它被指示通过运行node（`node.js`运行时）并以`/myapp/example.js`（web应用程序实现）作为参数来启动容器。该容器链接到`redis`容器，并且容器端口`80`映射到Docker主机的端口`8080`。
- en: The service named `redis` is instructed to launch a container with the `redis:latest`
    image. If the image is not present in the Docker host, the Docker engine will
    pull it from the central repository or the private repository.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务名为`redis`的服务被指示使用`redis:latest`镜像启动一个容器。如果该镜像不在Docker主机上，Docker引擎将从中央仓库或私有仓库中拉取该镜像。
- en: 'Now, let''s continue with our example by building the Docker images using the
    `docker-compose build` command, launch the containers using the `docker-compose
    up` command, and connect with a browser to verify the request/response functionality,
    as explained step by step here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续我们的示例，使用`docker-compose build`命令构建Docker镜像，使用`docker-compose up`命令启动容器，并使用浏览器连接以验证请求/响应功能，如下逐步解释：
- en: 'The `docker-compose` commands must be executed from the directory in which
    the `docker-compose.yml` file is stored. The `docker-compose` tool considers each
    `docker-compose.yml` file as a project, and it assumes the project name from the
    `docker-compose.yml` file''s directory. Of course, this can be overridden using
    the `-p` option. So, as a first step, let''s change the directory, wherein the
    `docker-compose.yml` file is stored:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker-compose`命令必须从存储`docker-compose.yml`文件的目录中执行。`docker-compose`工具将每个`docker-compose.yml`文件视为一个项目，并且它假定项目名称来自`docker-compose.yml`文件的目录。当然，可以使用`-p`选项覆盖此设置。因此，作为第一步，让我们更改存储`docker-compose.yml`文件的目录：'
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Build the services using the `docker-compose build` command:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker-compose build`命令构建服务：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Proceed to bring up the services as indicated in the `docker-compose.yml`,
    file using the `docker-compose up` command:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照`docker-compose.yml`文件中指示的服务启动服务，使用`docker-compose up`命令：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since the directory name is `example`, the `docker-compose` tool has assumed
    that the project name is `example`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目录名为`example`，`docker-compose`工具假定项目名称为`example`。
- en: 'Having successfully orchestrated the services using the `docker-compose` tool,
    let''s invoke the `docker-compose ps` command from a different terminal to list
    the containers associated with the example `docker-compose` project:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功使用`docker-compose`工具编排服务后，让我们从不同的终端调用`docker-compose ps`命令，以列出与示例`docker-compose`项目关联的容器：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Evidently, the two `example_redis_1` and `example_web_1` containers are up and
    running. The container name is prefixed with `example_`, which is the `docker-compose`
    project name.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，两个`example_redis_1`和`example_web_1`容器正在运行。容器名称以`example_`为前缀，这是`docker-compose`项目名称。
- en: 'Explore the functionality of our own request/response web application on a
    different terminal of the Docker host, as illustrated here:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Docker主机的不同终端上探索我们自己的请求/响应Web应用程序的功能，如下所示：
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Here, we are directly connecting to the web service using `http://0.0.0.0:8080`
    because the web service is bound to the Docker host on port `8080`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们直接使用`http://0.0.0.0:8080`连接到Web服务，因为Web服务绑定到Docker主机的端口`8080`。
- en: Cool, isn't it? With very minimal effort, and the help of the `docker-compose.yml`
    file, we are able to compose two different services together and offer a composite
    service.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，不是吗？凭借极少的努力和`docker-compose.yml`文件的帮助，我们能够将两个不同的服务组合在一起并提供一个复合服务。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has been incorporated in the book in order to provide all the probing
    and prescribing details on seamlessly orchestrating multiple containers. We extensively
    discussed the need for container orchestration and the tools that enable us to
    simplify and streamline the increasingly complicated process of container orchestration.
    In order to substantiate how orchestration is handy and helpful in crafting enterprise-class
    containers, and to illustrate the orchestration process, we took the widely followed
    route of explaining the whole gamut through a simple example. We developed a web
    application and contained it within a standard container. Similarly, we took a
    database container, which is a backend for the frontend web application and the
    database was executed inside another container. We saw how to make the web application
    container aware of the database, using different technologies through the container-linkage
    feature of the Docker engine. We used the open source tool (`docker-compose`)
    for this purpose.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已纳入书中，以提供有关无缝编排多个容器的所有探查和指定细节。我们广泛讨论了容器编排的需求以及使我们能够简化和流畅进行容器编排日益复杂过程的工具。为了证实编排如何在打造企业级容器中方便和有用，并且为了说明编排过程，我们采用了通过一个简单的例子来解释整个范围的广泛做法。我们开发了一个网络应用并将其包含在一个标准容器中。同样，我们使用了一个数据库容器，它是前端网络应用的后端，并且数据库在另一个容器中执行。我们看到如何通过Docker引擎的容器链接功能，使用不同的技术使网络应用容器意识到数据库。我们使用了开源工具（`docker-compose`）来实现这一目的。
- en: In the next chapter, we will discuss how Docker facilitates software testing,
    especially integration testing with a few pragmatic examples.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Docker如何促进软件测试，特别是通过一些实用的例子进行集成测试。
