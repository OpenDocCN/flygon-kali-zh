- en: Chapter 3. Setting Up the Functional Programming Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。设置函数式编程环境
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Do we need to know advanced math—category theory, Lambda calculus, polymorphisms—just
    to write applications with functional programming? Do we need to reinvent the
    wheel? The short answer to both these questions is *no*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否需要了解高级数学——范畴论、Lambda演算、多态——才能使用函数式编程编写应用程序？我们是否需要重新发明轮子？对这两个问题的简短回答都是*不*。
- en: In this chapter, we will do our best to survey everything that can impact the
    way we write our functional applications in JavaScript.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尽力调查一切可能影响我们在JavaScript中编写函数式应用程序的方式。
- en: Libraries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库
- en: Toolkits
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具包
- en: Development environments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发环境
- en: Functional language that compiles to JavaScript
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译为JavaScript的函数式语言
- en: And more
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等
- en: Please understand that the current landscape of functional libraries for JavaScript
    is a very fluid one. Like all aspects of computer programming, the community can
    change in a heartbeat; new libraries can be adopted and old ones can be abandoned.
    For instance, during the writing process of this very book, the popular and stable
    `Node.js` platform for I/O has been forked by its open source community. Its future
    is vague.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 请理解，JavaScript的函数库当前的格局是非常不确定的。就像计算机编程的所有方面一样，社区可能会在一瞬间发生变化；新的库可能会被采用，旧的库可能会被抛弃。例如，在撰写本书的过程中，流行且稳定的`Node.js`平台已被其开源社区分叉。它的未来是模糊的。
- en: Therefore, the most important concept to be gained from this chapter is not
    how to use the current libraries for functional programming, but how to use any
    library that enhances JavaScript's functional programming method. This chapter
    will not focus on just one or two libraries, but will explore as many as possible
    with the goal of surveying all the many styles of functional programming that
    exist within JavaScript.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从本章中获得的最重要的概念不是如何使用当前的库进行函数式编程，而是如何使用任何增强JavaScript函数式编程方法的库。本章不会专注于只有一两个库，而是将尽可能多地探索所有存在于JavaScript中的函数式编程风格。
- en: Functional libraries for JavaScript
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript的函数库
- en: It's been said that every functional programmer writes their own library of
    functions, and functional JavaScript programmers are no exception. With today's
    open source code-sharing platforms such as GitHub, Bower, and NPM, it's easier
    to share, collaborate, and grow these libraries. Many libraries exist for functional
    programming with JavaScript, ranging from tiny toolkits to monolithic module libraries.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 据说每个函数式程序员都会编写自己的函数库，函数式JavaScript程序员也不例外。如今的开源代码共享平台，如GitHub、Bower和NPM，使得分享、合作和发展这些库变得更加容易。存在许多用于JavaScript函数式编程的库，从微小的工具包到庞大的模块库不等。
- en: 'Each library promotes its own style of functional programming. From a rigid,
    math-based style to a relaxed, informal style, each library is different but they
    all share one common feature: they all have abstract JavaScript functional capabilities
    to increase code re-use, readability, and robustness.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个库都推广其自己的函数式编程风格。从严格的、基于数学的风格到轻松的、非正式的风格，每个库都不同，但它们都有一个共同的特点：它们都具有抽象的JavaScript函数功能，以增加代码重用、可读性和健壮性。
- en: At the time of writing, however, a single library has not established itself
    as the de-facto standard. Some might argue that `underscore.js` is the one but,
    as you'll see in the following section, it might be advisable to avoid `underscore.js`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在撰写本文时，尚未有一个库确立为事实上的标准。有人可能会认为`underscore.js`是其中一个，但正如你将在下一节中看到的，最好避免使用`underscore.js`。
- en: Underscore.js
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Underscore.js
- en: Underscore has become the standard functional JavaScript library in the eyes
    of many. It is mature, stable, and was created by *Jeremy Ashkenas*, the man behind
    the `Backbone.js` and `CoffeeScript` libraries. Underscore is actually a reimplementation
    of Ruby's `Enumerable` module, which explains why CoffeeScript was also influenced
    by Ruby.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多人眼中，Underscore已成为标准的函数式JavaScript库。它成熟、稳定，并由`Jeremy Ashkenas`创建，他是`Backbone.js`和`CoffeeScript`库背后的人物。Underscore实际上是Ruby的`Enumerable`模块的重新实现，这也解释了为什么CoffeeScript也受到Ruby的影响。
- en: 'Similar to jQuery, Underscore doesn''t modify native JavaScript objects and
    instead uses a symbol to define its own object: the underscore character "`_`".
    So, using Underscore would work like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与jQuery类似，Underscore不修改原生JavaScript对象，而是使用一个符号来定义自己的对象：下划线字符"`_`"。因此，使用Underscore的方式如下：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ve already seen JavaScrip''s native `map()` method for the `Array` object,
    which works like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了JavaScript原生的`Array`对象的`map()`方法，它的工作方式如下：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The difference is that, in Underscore, both the `Array` object and the `callback()`
    function are passed as parameters to the Underscore object's `map()` method (`_.map`),
    as opposed to passing only the callback to the array's native `map()` method (`Array.prototype.map`).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于，在Underscore中，`Array`对象和`callback()`函数都作为参数传递给Underscore对象的`map()`方法(`_.map`)，而不是仅将回调传递给数组的原生`map()`方法(`Array.prototype.map`)。
- en: But there's way more than just `map()` and other built-in functions to Underscore.
    It's full of super handy functions such as `find()`, `invoke()`, `pluck()`, `sortyBy()`,
    `groupBy()`, and more.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但Underscore不仅仅是`map()`和其他内置函数。它充满了非常方便的函数，比如`find()`、`invoke()`、`pluck()`、`sortyBy()`、`groupBy()`等等。
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And it provides a way of chaining methods together:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了一种将方法链接在一起的方式：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `_.chain()` method returns a wrapped object that holds all the Underscore
    functions. The `_.value` method is then used to extract the value of the wrapped
    object. Wrapped objects are also very useful for mixing Underscore with object-oriented
    programming.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`_.chain()`方法返回一个包装对象，其中包含所有Underscore函数。然后使用`_.value`方法来提取包装对象的值。包装对象对于将Underscore与面向对象编程混合使用非常有用。'
- en: Despite its ease of use and adaptation by the community, the `underscore.js`
    library has been criticized for forcing you to write overly verbose code and for
    encouraging the wrong patterns. Underscore's structure may not be ideal or even
    function!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它易于使用并被社区所接受，但`underscore.js`库因迫使你编写过于冗长的代码和鼓励错误的模式而受到批评。Underscore的结构可能不是理想的，甚至不起作用！
- en: Until version 1.7.0, released shortly after Brian Lonsdorf's talk entitled *Hey
    Underscore, you're doing it wrong!*, landed on YouTube, Underscore explicitly
    prevented us from extending functions such as `map()`, `reduce()`, `filter()`,
    and more.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 直到版本1.7.0发布后不久，Brian Lonsdorf的演讲*嘿，Underscore，你做错了！*在YouTube上发布，Underscore明确阻止我们扩展`map()`、`reduce()`、`filter()`等函数。
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can watch the video of Brian Lonsdorf's talk at [www.youtube.com/watch?v=m3svKOdZij](http://www.youtube.com/watch?v=m3svKOdZij).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[www.youtube.com/watch?v=m3svKOdZij](http://www.youtube.com/watch?v=m3svKOdZij)观看Brian
    Lonsdorf的演讲视频。
- en: Map, in terms of category theory, is a homomorphic functor interface (more on
    this in [Chapter 5](part0032_split_000.html#page "Chapter 5. Category Theory"),
    *Category Theory*). And we should be able to define `map` as a functor for whatever
    we need it for. So that's not very functional of Underscore.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在范畴论的术语中，映射是一个同态函子接口（在[第5章](part0032_split_000.html#page "第5章。范畴论")*范畴论*中有更多介绍）。我们应该能够根据需要为`map`定义一个函子。所以Underscore并不是非常函数式的。
- en: And because JavaScript doesn't have built-in immutable data, a functional library
    should be careful to not allow its helper functions to mutate the objects passed
    to it. A good example of this problem is shown below. The intention of the snippet
    is to return a new `selected` list with one option set as the default. But what
    actually happens is that the `selected` list is mutated in place.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript没有内置的不可变数据，一个函数库应该小心不要让它的辅助函数改变传递给它的对象。这个问题的一个很好的例子如下所示。片段的意图是返回一个新的`selected`列表，并将一个选项设置为默认值。但实际发生的是`selected`列表被就地改变。
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We would have to insert the line `opt = opt.cloneNode();` to the `callback()`
    function to make a copy of each object within the list being passed to the function.
    Underscore's `map()` function cheats to boost performance, but it is at the cost
    of functional *feng shui*. The native `Array.prototype.map()` function wouldn't
    require this because it makes a copy, but it also doesn't work on `nodelist` collections.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在`callback()`函数中插入`opt = opt.cloneNode();`这一行，以便复制传递给函数的列表中的每个对象。Underscore的`map()`函数作弊以提高性能，但这是以牺牲函数式的*风水*为代价。本地的`Array.prototype.map()`函数不需要这样做，因为它会复制，但它也不能用于`nodelist`集合。
- en: Underscore may be less than ideal for mathematically-correct, functional programming,
    but it was never intended to extend or transform JavaScript into a pure functional
    language. It defines itself as *a JavaScript library that provides a whole mess
    of useful functional programming helpers*. It may be a little more than a spurious
    collection of functional-like helpers, but it's no serious functional library
    either.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore可能不太适合数学上正确的函数式编程，但它从来没有打算将JavaScript扩展或转换为纯函数式语言。它定义自己为*一个提供大量有用的函数式编程辅助函数的JavaScript库*。它可能不仅仅是一堆类似函数式的辅助函数，但它也不是一个严肃的函数库。
- en: Is there a better library out there? Perhaps one that is based on mathematics?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有更好的库？也许是基于数学的库？
- en: Fantasy Land
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fantasy Land
- en: Sometimes, the truth is stranger than fiction.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，事实比小说更离奇。
- en: '**Fantasy Land** is a collection of functional base libraries and a formal
    specification for how to implement "algebraic structures" in JavaScript. More
    specifically, Fantasy Land specifies the interoperability of common algebraic
    structures, or algebras for short: monads, monoids, setoids, functors, chains,
    and more. Their names may sound scary, but they''re just a set of values, a set
    of operators, and some laws it must obey. In other words, they''re just objects.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fantasy Land**是一个功能基础库的集合，也是JavaScript中如何实现“代数结构”的正式规范。更具体地说，Fantasy Land指定了常见代数结构或简称代数的互操作性：单子、幺半群、集合、函子、链等等。它们的名字听起来可能很可怕，但它们只是一组值、一组运算符和一些必须遵守的定律。换句话说，它们只是对象。'
- en: Here's how it works. Each algebra is a separate Fantasy Land specification and
    may have dependencies on other algebras that need to be implemented.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的。每个代数都是一个单独的Fantasy Land规范，并且可能依赖于需要实现的其他代数。
- en: '![Fantasy Land](../images/00002.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Fantasy Land](../images/00002.jpeg)'
- en: 'Some of the algebra specifications are:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一些代数规范是：
- en: 'Setoids:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合：
- en: Implement the reflexivity, symmetry and transitivity laws
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现反射、对称和传递定律
- en: Define the `equals()` method
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`equals()`方法
- en: Semigroups
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 半群
- en: Implement the associativity law
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现结合定律
- en: Define the `concat()` method
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`concat()`方法
- en: Monoid
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幺半群
- en: Implement right identity and left identity
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现右恒等和左恒等
- en: Define the `empty()` method
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`empty()`方法
- en: Functor
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函子
- en: Implement the identity and composition laws
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现恒等和组合定律
- en: Define the `map()` method
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`map()`方法
- en: The list goes on and on.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 清单不断延续。
- en: We don't necessarily need to know exactly what each algebra is for but it certainly
    helps, especially if you're writing your own library that conforms to the specifications.
    It's not just abstract nonsense, it outlines a means of implementing a high-level
    abstraction called category theory. A full explanation of category theory can
    be found in [Chapter 5](part0032_split_000.html#page "Chapter 5. Category Theory"),
    *Category Theory*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不一定需要确切知道每个代数的用途，但这肯定有所帮助，特别是如果你正在编写符合规范的自己的库。这不仅仅是抽象的胡言乱语，它概述了一种实现称为范畴论的高级抽象的方法。范畴论的完整解释可以在[第5章](part0032_split_000.html#page
    "第5章。范畴论")*范畴论*中找到。
- en: 'Fantasy Land doesn''t just tell us how to implement functional programming,
    it does provide a set of functional modules for JavaScript. However, many are
    incomplete and documentation is pretty sparse. But Fantasy Land isn''t the only
    library out there to implement its open source specifications. Others have too,
    namely: **Bilby.js**.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Fantasy Land不仅告诉我们如何实现函数式编程，还为JavaScript提供了一组函数模块。然而，许多模块是不完整的，文档也相当稀少。但Fantasy
    Land并不是唯一一个实现其开源规范的库。其他库也有，比如：**Bilby.js**。
- en: Bilby.js
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bilby.js
- en: What the heck is a bilby? No, it's not a mythical creature that might exist
    in Fantasy Land. It exists here on Earth as a freaky/cute cross between a mouse
    and a rabbit. Nonetheless, `bibly.js` library is compliant with Fantasy Land specifications.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到底什么是bilby？不，它不是一个可能存在于Fantasy Land中的神话生物。它存在于地球上，是一种奇怪/可爱的鼠和兔的混合物。尽管如此，`bibly.js`库符合Fantasy
    Land的规范。
- en: 'In fact, `bilby.js` is a serious functional library. As its documentation states,
    it is, *Serious, meaning it applies category theory to enable highly abstract
    code. Functional, meaning it enables referentially transparent programs*. Wow,
    that is pretty serious. The documentation located at [http://bilby.brianmckenna.org/](http://bilby.brianmckenna.org/)
    goes on to say that it provides:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`bilby.js`是一个严肃的函数库。正如其文档所述，它是*严肃的，意味着它应用范畴论来实现高度抽象的代码。功能性的，意味着它实现了引用透明的程序*。哇，这真的很严肃。文档位于[http://bilby.brianmckenna.org/](http://bilby.brianmckenna.org/)，并且提供了以下内容：
- en: Immutable multi-methods for ad-hoc polymorphism
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于特定多态性的不可变多方法
- en: Functional data structures
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式数据结构
- en: Operator overloading for functional syntax
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于函数式语法的运算符重载
- en: Automated specification testing (**ScalaCheck**, **QuickCheck**)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化规范测试（**ScalaCheck**，**QuickCheck**）
- en: By far the most mature library that conforms to the Fantasy Land specifications
    for algebraic structures, `Bilby.js` is a great resource for fully committing
    to the functional style.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，符合Fantasy Land规范的最成熟的库是`Bilby.js`，它是致力于函数式风格的重要资源。
- en: 'Let''s try an example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一个例子：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is category theory and ad-hoc polymorphism in action. Again, category theory
    will be covered in full in [Chapter 5](part0032_split_000.html#page "Chapter 5. Category
    Theory"), *Category Theory*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是范畴论和特定多态性的实践。再次强调，范畴论将在[第5章](part0032_split_000.html#page "Chapter 5. Category
    Theory")中全面介绍，*范畴论*。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Category theory is a recently invigorated branch of mathematics that functional
    programmers use to maximize the abstraction and usefulness of their code. *But
    there is a major drawback: it''s difficult to conceptualize and quickly get started
    with.*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴论是函数式程序员最近振奋的数学分支，用于最大程度地抽象和提高代码的实用性。*但有一个主要缺点：很难理解并快速上手。*
- en: The truth is that Bilby and Fantasy Land are really stretching the possibilities
    of functional programming in JavaScript. Although it's exciting to see the evolution
    of computer science, the world may just not be ready for the kind of hard-core
    functional style that Bibly and Fantasy Land are pushing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Bilby和Fantasy Land确实在JavaScript中推动了函数式编程的可能性。尽管看到计算机科学的发展是令人兴奋的，但世界可能还没有准备好接受Bibly和Fantasy
    Land所推动的那种硬核函数式风格。
- en: Maybe such a grandiose library on the bleeding-edge of functional JavaScript
    is not our thing. After all, we set out to explore the functional techniques that
    complement JavaScript, not to build functional programming dogma. Let's turn our
    attention to another new library, `Lazy.js`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 也许这样一个位于函数式JavaScript前沿的宏伟库并不适合我们。毕竟，我们的目标是探索与JavaScript相辅相成的函数式技术，而不是建立函数式编程教条。让我们把注意力转向另一个新库，`Lazy.js`。
- en: Lazy.js
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lazy.js
- en: Lazy is a utility library more along the lines of the `underscore.js` library
    but with a lazy evaluation strategy. Because of this, Lazy makes the impossible
    possible by functionally computing results of series that won't be available with
    immediate interpretation. It also boasts a significant performance boost.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Lazy是一个实用库，更接近于`underscore.js`库，但采用了惰性求值策略。因此，Lazy通过函数式计算结果的方式实现了不会立即得到解释的系列。它还拥有显著的性能提升。
- en: The `Lazy.js` library is still very young. But it has a lot of momentum and
    community enthusiasm behind it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lazy.js`库仍然非常年轻。但它有很大的动力和社区热情支持。'
- en: 'The idea is that, in Lazy, everything is a sequence that we can iterate over.
    Owing to the way the library controls the order in which methods are applied,
    many really cool things can be achieved: asynchronous iteration (parallel programming),
    infinite sequences, functional reactive programming, and more.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Lazy中的一切都是我们可以迭代的序列。由于库控制方法应用的顺序，可以实现许多非常酷的事情：异步迭代（并行编程），无限序列，函数式反应式编程等。
- en: 'The following examples show off a bit of everything:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一些内容：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: More examples and use-cases are covered in [Chapter 4](part0027_split_000.html#page
    "Chapter 4. Implementing Functional Programming Techniques in JavaScript"), *Implementing
    Functional Programming Techniques in JavaScript*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 更多示例和用例在[第4章](part0027_split_000.html#page "Chapter 4. Implementing Functional
    Programming Techniques in JavaScript")中有详细介绍，*在JavaScript中实现函数式编程技术*。
- en: But its not entirely correct to fully credit the `Lazy.js` library with this
    idea. One of its predecessors, the `Bacon.js` library, works in much the same
    way.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但完全归功于`Lazy.js`库这个想法并不完全正确。它的前身之一，`Bacon.js`库，也是以类似的方式工作。
- en: Bacon.js
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bacon.js
- en: 'The logo of `Bacon.js` library is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bacon.js`库的标志如下：'
- en: '![Bacon.js](../images/00003.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Bacon.js](../images/00003.jpeg)'
- en: The mustachioed hipster of functional programming libraries, `Bacon.js` is itself
    a library for *functional reactive programming*. Functional reactive programming
    just means that functional design patterns are used to represent values that are
    reactive and always changing, like the position of the mouse on the screen, or
    the price of a company's stock. In the same way that Lazy can get away with creating
    infinite sequences by not calculating the value until it's needed, Bacon can avoid
    having to calculate ever-changing values until the very last second.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程库的有胡子的嬉皮士，`Bacon.js`本身是一个*函数式响应式编程*库。函数式响应式编程意味着使用函数式设计模式来表示具有反应性和不断变化的值，比如屏幕上鼠标的位置或公司股票的价格。就像Lazy可以通过在需要时不计算值来创建无限序列一样，Bacon可以避免在最后一刻之前计算不断变化的值。
- en: What are called sequences in Lazy are known as EventStreams and Properties in
    Bacon because they're more suited for working with events (`onmouseover`, `onkeydown`,
    and so on) and reactive properties (scroll position, mouse position, toggles,
    and so on).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lazy中称为序列的东西在Bacon中称为EventStreams和Properties，因为它们更适合处理事件（`onmouseover`，`onkeydown`等）和响应属性（滚动位置，鼠标位置，切换等）。
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Bacon is a little bit older than Lazy but its feature set is about half the
    size and its community enthusiasm is about equal.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon比Lazy要老一点，但它的功能集大约是一半大小，社区的热情也差不多。
- en: Honorable mentions
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 荣誉提及
- en: There are simply too many libraries out there to do them all justice within
    the scope of this book. Let's look at a few more libraries for functional programming
    in JavaScript.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的范围内，有太多的库，无法对它们进行公正的评价。让我们再看看JavaScript中的一些函数式编程库。
- en: '`Functional`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Functional`'
- en: Possibly the first library for functional programming in JavaScript, `Functional`
    is a library that includes comprehensive higher-order function support as well
    as `string` lambdas
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能是JavaScript中第一个函数式编程库，`Functional`是一个包括全面的高阶函数支持以及`string` lambda的库。
- en: '`wu.js`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wu.js`'
- en: Especially prized for its `curryable()` function, `wu.js` library is a very
    nice Library for functional programming. It was the first library (that I know
    of) to implement lazy evaluation, getting the ball rolling for `Bacon.js`, `Lazy.js`
    and other libraries
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特别受欢迎的`curryable()`函数，`wu.js`库是一个非常好的函数式编程库。它是第一个（我知道的）实现惰性评估的库，为`Bacon.js`，`Lazy.js`和其他库打下了基础
- en: Yes, it is named after the infamous rap group *Wu Tang Clan*
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的，它是以臭名昭著的说唱组合*Wu Tang Clan*命名的
- en: '`sloth.js`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sloth.js`'
- en: Very similar to the `Lazy.js` libraries, but much smaller
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`Lazy.js`库非常相似，但比它小得多
- en: '`stream.js`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream.js`'
- en: The `stream.js` library supports infinite streams and not much else
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream.js`库支持无限流，除此之外没有太多功能'
- en: Absolutely tiny in size
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绝对微小
- en: '`Lo-Dash.js`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lo-Dash.js`'
- en: As the name might imply, the `lo-dash.js` library was inspired by the `underscore.js`
    library
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顾名思义，`lo-dash.js`库受到了`underscore.js`库的启发
- en: Highly optimized
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度优化
- en: '`Sugar`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sugar`'
- en: '`Sugar` is a support library for functional programming techniques in JavaScript,
    like Underscore, but with some key differences in how it''s implemented.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sugar`是JavaScript中函数式编程技术的支持库，类似于Underscore，但在实现方式上有一些关键的不同。'
- en: Instead of doing `_.pluck(myObjs, 'value')` in Underscore, it's just `myObjs.map('value')`
    in Sugar. This means that it modifies native JavaScript objects, so there is a
    small risk of it not playing nicely with other libraries that do the same such
    as Prototype.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Underscore中执行`_.pluck(myObjs, 'value')`，在Sugar中只需`myObjs.map('value')`。这意味着它修改了原生JavaScript对象，因此有一定风险，可能无法与其他执行相同操作的库（如Prototype）很好地配合。
- en: Very good documentation, unit tests, analyzers, and more.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常好的文档，单元测试，分析器等。
- en: '`from.js`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from.js`'
- en: A new functional library and **LINQ** (**Language Integrated Query**) engine
    for JavaScript that supports most of the same LINQ functions that .NET provides
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新的函数库和JavaScript的**LINQ**（**语言集成查询**）引擎，支持大部分.NET提供的相同LINQ函数
- en: 100% lazy evaluation and supports lambda expressions
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 100%的惰性评估和支持lambda表达式
- en: Very young but documentation is excellent
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常年轻，但文档非常好
- en: JSLINQ
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSLINQ
- en: Another functional LINQ engine for JavaScript
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript的另一个函数式LINQ引擎
- en: Much older and more mature than `from.js` library
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比`from.js`库更老，更成熟
- en: '`Boiler.js`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boiler.js`'
- en: 'Another utility library that extends JavaScript''s functional methods to more
    primitives: strings, numbers, objects, collections and arrays'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个实用库，将JavaScript的函数方法扩展到更多的原语：字符串，数字，对象，集合和数组
- en: '**Folktale**'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Folktale**'
- en: Like the `Bilby.js` library, Folktale is another new library that implements
    the Fantasy Land specifications. And like its forefather, Folktale is also a collection
    of libraries for functional programming in JavaScript. It's very young but could
    have a bright future.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像`Bilby.js`库一样，Folktale是另一个实现Fantasy Land规范的新库。和它的前辈一样，Folktale也是一个用于JavaScript中的函数式编程的库集合。它还很年轻，但可能会有一个光明的未来。
- en: '**jQuery**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jQuery**'
- en: Surprised to see jQuery mentioned here? Although jQuery is not a tool used to
    perform functional programming, it nevertheless is functional itself. jQuery might
    be one of the most widely used libraries that has its roots in functional programming.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看到jQuery被提到感到惊讶？尽管jQuery不是用于执行函数式编程的工具，但它本身也是函数式的。jQuery可能是最广泛使用的库之一，它的根源是函数式编程。
- en: 'The jQuery object is actually a monad. jQuery uses the monadic laws to enable
    method chaining:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQuery对象实际上是一个单子。jQuery使用单子定律来实现方法链式调用：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A full explanation of this can be found in [Chapter 7](part0041_split_000.html#page
    "Chapter 7. Functional and Object-oriented Programming in JavaScript"), *Functional
    and Object-oriented Programming in JavaScript*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这一点的详细解释可以在[第7章](part0041_split_000.html#page "第7章。JavaScript中的函数式和面向对象编程")中找到，*JavaScript中的函数式和面向对象编程*。
- en: 'And some of its methods are higher-order:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的一些方法是高阶的：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As of jQuery 1.8, the `deferred.then` parameter implements a functional concept
    known as Promises.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从jQuery 1.8开始，`deferred.then`参数实现了一种称为Promises的函数概念。
- en: jQuery is an abstraction layer, mainly for the DOM. It's not a framework or
    a toolkit, just a way to use abstraction to increase code-reuse and reduce ugly
    code. And isn't that what functional programming is all about?
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQuery是一个抽象层，主要用于DOM。它不是一个框架或工具包，只是一种利用抽象来增加代码重用和减少丑陋代码的方法。这难道不正是函数式编程的全部意义吗？
- en: Development and production environments
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发和生产环境
- en: It does not matter in terms of programming style what type of environment the
    application is being developed in and will be deployed in. But it does matter
    to the libraries a lot.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从编程风格的角度来看，应用程序是在哪种环境中开发和部署的并不重要。但对于库来说却很重要。
- en: Browsers
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器
- en: The majority of JavaScript applications are designed to run on the client side,
    that is, in the client's browser. Browser-based environments are excellent for
    development because browsers are ubiquitous, you can work on the code right on
    your local machine, the interpreter is the browser's JavaScript engine, and all
    browsers have a developer console. Firefox's FireBug provides very useful error
    messages and allows for break-points and more, but it's often helpful to run the
    same code in Chrome and Safari to cross-reference the error output. Even Internet
    Explorer contains developer tools.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数JavaScript应用程序都设计为在客户端运行，也就是在客户端的浏览器中。基于浏览器的环境非常适合开发，因为浏览器无处不在，你可以在本地机器上直接编写代码，解释器是浏览器的JavaScript引擎，所有浏览器都有开发者控制台。Firefox的FireBug提供非常有用的错误消息，并允许设置断点等，但在Chrome和Safari中运行相同的代码以交叉参考错误输出通常也很有帮助。即使是Internet
    Explorer也包含开发者工具。
- en: The problem with browsers is that they evaluate JavaScript differently! Though
    it's not common, it is possible to write code that returns very different results
    in different browsers. But usually the differences are in the way they treat the
    document object model and not how prototypes and functions work. Obviously, `Math.sqrt(4)`
    method returns `2` to all browsers and shells. But the `scrollLeft` method depends
    on the browser's layout policies.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器的问题在于它们以不同的方式评估JavaScript！虽然不常见，但有可能编写的代码在不同的浏览器中返回非常不同的结果。但通常差异在于它们处理文档对象模型的方式，而不是原型和函数的工作方式。显然，`Math.sqrt(4)`方法对所有浏览器和shell都返回`2`。但`scrollLeft`方法取决于浏览器的布局策略。
- en: Writing browser-specific code is a waste of time, and that's another reason
    why libraries should be used.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 编写特定于浏览器的代码是浪费时间，这也是为什么应该使用库的另一个原因。
- en: Server-side JavaScript
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端JavaScript
- en: 'The `Node.js` library has become the standard platform for creating server-side
    and network-based applications. Can functional programming be used for server-side
    application programming? Yes! Ok, but do there exist any functional libraries
    that are designed for this performance-critical environment? The answer to that
    is also: yes.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node.js`库已成为创建服务器端和基于网络的应用程序的标准平台。函数式编程可以用于服务器端应用程序编程吗？可以！好吧，但是否存在专为这种性能关键环境设计的函数式库？答案也是：是的。'
- en: All the functional libraries outlined in this chapter will work in the `Node.js`
    library, and many depend on the `browserify.js` module to work with browser elements.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中概述的所有函数式库都可以在`Node.js`库中工作，并且许多依赖于`browserify.js`模块来处理浏览器元素。
- en: A functional use case in the server-side environment
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端环境中的函数式用例
- en: In our brave new world of network systems, server-side application developers
    are often concerned with concurrency, and rightly so. The classic example is an
    application that allows multiple users to modify the same file. But if they try
    to modify it at the same time, you will get into an ugly mess. This is the *maintenance
    of state* problem that has plagued programmers for decades.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个充满网络系统的新世界中，服务器端应用程序开发人员经常关注并且理所当然地关注并发性。经典的例子是允许多个用户修改同一个文件的应用程序。但如果他们同时尝试修改它，就会陷入一团糟。这是困扰程序员几十年的*状态维护*问题。
- en: 'Assume the following scenario:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设以下情景：
- en: One morning, Adam opens a report for editing but he doesn't save it before leaving
    for lunch.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一天早晨，亚当打开一个报告进行编辑，但在离开吃午饭前没有保存。
- en: Billy opens the same report, adds his notes, and then saves it.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比利打开同样的报告，添加了他的笔记，然后保存了。
- en: Adam comes back from lunch, adds his notes to the report, and then saves it,
    unknowingly overwriting Billy's notes.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 亚当从午饭回来，添加了他的笔记到报告中，然后保存了，无意中覆盖了比利的笔记。
- en: The next day, Billy finds out that his notes are missing. His boss yells at
    him; everybody gets mad and they gang up on the misguided application developer
    who unfairly loses his job.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二天，比利发现他的笔记不见了。他的老板对他大喊大叫；每个人都生气了，他们联合起来对那个误入歧途的应用程序开发人员进行了不公正的解雇。
- en: For a long time, the solution to this problem was to create a state about the
    file. Toggle a lock status to *on* when someone begins editing it, which prevents
    others from being able to edit it, and then toggle it to *off* once they save
    it. In our scenario, Billy would not be able to do his work until Adam gets back
    from lunch. And if it's never saved (if, say, Adam decided to quit his job in
    the middle of the lunch break), then no one will ever be able to edit it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间，解决这个问题的方法是创建一个关于文件的状态。当有人开始编辑时，切换锁定状态为*on*，这样其他人就无法编辑它，然后在保存后切换为*off*。在我们的情景中，比利在亚当回来吃午饭之前无法完成工作。如果从未保存（比如说，亚当决定在午饭休息时辞职），那么就永远无法编辑它。
- en: This is where functional programming's ideas about immutable data and state
    (or lack thereof) can really be put to work. Instead of having users modify the
    file directly, with a functional approach they would modify a copy of the file,
    which is a new revision. If they go to save the revision and a new revision already
    exists, then we know that someone else has already modified the old one. Crisis
    averted.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是函数式编程关于不可变数据和状态（或缺乏状态）的想法真正可以发挥作用的地方。与其让用户直接修改文件，采用函数式方法，他们会修改文件的副本，也就是一个新的版本。如果他们试图保存该版本，而新版本已经存在，那么我们就知道其他人已经修改了旧版本。危机得以避免。
- en: 'Now the scenario from before would unfold like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在之前的情景会是这样展开的：
- en: One morning, Adam opens a report for editing. But he doesn't save it before
    going to lunch.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一天早晨，亚当打开一个报告进行编辑。但他在午餐前没有保存它。
- en: Billy opens the same report, adds his notes, and saves it as a new revision.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比利打开相同的报告，添加他的笔记，并将其保存为新的修订版本。
- en: Adam returns from lunch to add his notes. When he attempts to save the new revision,
    the application tells him that a newer revision now exists.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 亚当从午餐回来添加他的笔记。当他试图保存新的修订版本时，应用程序告诉他现在存在一个更新的修订版本。
- en: Adam opens the new revisions, adds his notes to it, and saves another new revision.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 亚当打开新的修订版本，添加了他的笔记，并保存了另一个新的修订版本。
- en: By looking at the revision history, the boss sees that everything is working
    smoothly. Everyone is happy and the application developer gets a promotion and
    a raise.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过查看修订历史，老板发现一切都运行顺利。每个人都很高兴，应用程序开发人员得到了晋升和加薪。
- en: This is known as *event sourcing*. There is no explicit state to be maintained,
    only events. The process is much cleaner and there is a clear history of events
    that can be reviewed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为*事件溯源*。没有明确的状态需要维护，只有事件。这个过程更加清洁，有一个可以审查的明确事件历史。
- en: This idea and many others are why functional programming in server-side environments
    is on the rise.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法和许多其他想法是为什么服务器端环境中的功能性编程正在兴起。
- en: CLI
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CLI
- en: Although web and the `node.js` library are the two main JavaScript environments,
    some pragmatic and adventurous users are finding ways to use JavaScript in the
    command line.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Web和`node.js`库是两个主要的JavaScript环境，一些务实和冒险的用户正在寻找方法在命令行中使用JavaScript。
- en: Using JavaScript as a **Command Line Interface** (**CLI**) scripting language
    might be one of the best opportunities to apply function programming. Imagine
    being able to use lazy evaluation when searching for local files or to rewrite
    an entire bash script into a functional JavaScript one-liner.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将JavaScript用作命令行界面（CLI）脚本语言可能是应用函数编程的最佳机会之一。想象一下，当搜索本地文件或将整个bash脚本重写为功能性JavaScript一行时，能够使用惰性评估。
- en: Using functional libraries with other JavaScript modules
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与其他JavaScript模块一起使用功能库
- en: 'Web applications are made up of all sorts of things: frameworks, libraries,
    APIs and more. They can work along side each other as dependents, plugins, or
    just as coexisting objects.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序由各种组件组成：框架、库、API等。它们可以作为依赖项、插件或并存对象一起工作。
- en: '`Backbone.js`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Backbone.js`'
- en: An **MVP** (**model-view-provider**) framework with a RESTful JSON interface
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有RESTful JSON接口的MVP（模型-视图-提供者）框架
- en: Requires the `underscore.js` library, Backbone's only hard dependency
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要`underscore.js`库，Backbone的唯一硬依赖
- en: jQuery
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQuery
- en: The `Bacon.js` library has bindings for mixing with jQuery
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bacon.js`库具有与jQuery混合的绑定'
- en: Underscore and jQuery complement each other very well
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Underscore和jQuery非常好地互补了彼此
- en: Prototype JavaScript Framework
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型JavaScript框架
- en: Provides JavaScript with collection functions in the manner closest to Ruby's
    Enumerable
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供JavaScript与Ruby的Enumerable最接近的集合函数
- en: '`Sugar.js`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sugar.js`'
- en: Modifies native objects and their methods
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改本地对象及其方法
- en: Must be careful when mixing with other libraries, especially Prototype
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在与其他库混合使用时必须小心，特别是Prototype
- en: Functional languages that compile into JavaScript
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译为JavaScript的功能语言
- en: Sometimes the thick veneer of C-like syntax over JavaScript's inner functionality
    can be enough to make you want to switch to another functional language. Well,
    you can!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，JavaScript的内部功能上的C样式厚重外观足以让你想切换到另一种功能性语言。好吧，你可以！
- en: Clojure and ClojureScript
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure和ClojureScript
- en: Closure is a modern Lisp implementation and a full-featured functional language
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包是现代Lisp实现和功能齐全的功能语言
- en: ClojureScript trans-compiles Clojure into JavaScript
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ClojureScript将Clojure转译为JavaScript
- en: CoffeeScript
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CoffeeScript
- en: CoffeeScript is the name of both a functional language and a compiler for trans-compiling
    the language into JavaScript
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CoffeeScript既是一种功能性语言的名称，也是一种将该语言转译为JavaScript的编译器。
- en: 1-to-1 mapping between expressions in CoffeeScript and expression in JavaScript
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CoffeeScript中的表达式与JavaScript中的表达式之间存在一对一的映射
- en: There are many more out there, including **Pyjs**, **Roy**, **TypeScript**,
    **UHC** and more.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他选择，包括Pyjs，Roy，TypeScript，UHC等。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Which library you choose to use depends on what your needs are. Need functional
    reactive programming to handle events and dynamic values? Use the `Bacon.js` library.
    Only need infinite streams and nothing else? Use the `stream.js` library. Want
    to complement jQuery with functional helpers? Try the `underscore.js` library.
    Need a structured environment for serious ad hoc polymorphism? Check out the `bilby.js`
    library. Need a well-rounded tool for functional programming? Use the `Lazy.js`
    library. Not happy with any of these options? Write your own!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择使用哪个库取决于你的需求。需要功能性反应式编程来处理事件和动态值吗？使用`Bacon.js`库。只需要无限流而不需要其他东西吗？使用`stream.js`库。想要用功能性助手补充jQuery吗？试试`underscore.js`库。需要一个结构化环境来进行严肃的特定多态性吗？看看`bilby.js`库。需要一个全面的功能性编程工具吗？使用`Lazy.js`库。对这些选项都不满意吗？自己写一个！
- en: Any library is only as good as the way it's used. Although a few of the libraries
    outlined in this chapter have a few flaws, most faults occur somewhere between
    the keyboard and the chair. It's up to you to use the libraries correctly and
    to suit your needs.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 任何库的好坏取决于它的使用方式。尽管本章概述的一些库存在一些缺陷，但大多数故障发生在键盘和椅子之间的某个地方。你需要正确使用库来满足你的需求。
- en: 'And if we''re importing code libraries into our JavaScript environment, then
    maybe we can import ideas and principles too. Maybe we can channel *The Zen of
    Python*, by *Tim Peter*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将代码库导入JavaScript环境，也许我们也可以导入想法和原则。也许我们可以借鉴*Python之禅*，由*Tim Peter*：
- en: '*Beautiful is better than ugly*'
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*美丽胜于丑陋*'
- en: '>'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Explicit is better than implicit.*'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*显式胜于隐式*'
- en: '>'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Simple is better than complex.*'
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*简单胜于复杂*'
- en: '>'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Complex is better than complicated.*'
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*复杂胜于复杂*'
- en: '>'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Flat is better than nested.*'
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*平面胜于嵌套*'
- en: '>'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Sparse is better than dense.*'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*稀疏胜于密集*'
- en: '>'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Readability counts.*'
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*可读性很重要。*'
- en: '>'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Special cases aren''t special enough to break the rules.*'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*特殊情况并不特别到足以打破规则。*'
- en: '>'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Although practicality beats purity.*'
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*尽管实用性胜过纯粹。*'
- en: '>'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Errors should never pass silently.*'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*错误不应该悄悄地通过。*'
- en: '>'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Unless explicitly silenced.*'
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*除非明确要求保持沉默。*'
- en: '>'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*In the face of ambiguity, refuse the temptation to guess.*'
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*面对模棱两可，拒绝猜测的诱惑。*'
- en: '>'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*There should be one—and preferably only one—obvious way to do it.*'
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*应该有一种——最好只有一种——明显的方法来做到这一点。*'
- en: '>'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Although that way may not be obvious at first unless you''re Dutch.*'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*尽管这种方式一开始可能不明显，除非你是荷兰人。*'
- en: '>'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Now is better than never.*'
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*现在总比永远好。*'
- en: '>'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Although never is often better than "right" now.*'
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*尽管永远往往比“现在”更好。*'
- en: '>'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*If the implementation is hard to explain, it''s a bad idea.*'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果实现很难解释，那是个坏主意。*'
- en: '>'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*If the implementation is easy to explain, it may be a good idea.*'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果实现很容易解释，那可能是个好主意。*'
- en: '>'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Namespaces are one honking great idea—let''s do more of those!*'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*命名空间是一个非常好的主意——让我们做更多这样的事情！*'
