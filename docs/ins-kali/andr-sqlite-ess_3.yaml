- en: Chapter 3. Sharing is Caring
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。分享就是关怀
- en: '|   | *"Data really powers everything that we do."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"数据真的驱动着我们所做的一切。"* |   |'
- en: '|   | --*– Jeff Weiner, LinkedIn* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*– Jeff Weiner, LinkedIn* |'
- en: In the last chapter, we started programming our very own contact manager. We
    came across various building blocks of a database-centric application; we covered
    database handlers and building queries in order to get meaningful data from our
    database. We also explored how to make a connection between our UI and database
    and present it in a consumable manner for the end user.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开始编写我们自己的联系人管理器。我们遇到了数据库中心应用程序的各种构建模块；我们涵盖了数据库处理程序和构建查询，以便从我们的数据库中获取有意义的数据。我们还探讨了如何在我们的UI和数据库之间建立连接，并以一种可消费的方式呈现给最终用户。
- en: In this chapter, we will learn how to access other application's data via means
    of content providers. We will also learn how to build our very own content provider
    in order to share our data with other applications. We will look into Android's
    providers such as **contactprovider**. To wrap things up, we will construct a
    test application to use our newly constructed content provider.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学习如何通过内容提供程序访问其他应用程序的数据。我们还将学习如何构建自己的内容提供程序，以便与其他应用程序共享我们的数据。我们将研究Android的提供者，如**contactprovider**。最后，我们将构建一个测试应用程序来使用我们新构建的内容提供程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is a content provider?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是内容提供程序？
- en: Creating a content provider
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建内容提供程序
- en: Implementing the core methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现核心方法
- en: Using a content provider
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内容提供程序
- en: What is a content provider?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是内容提供程序？
- en: A content provider is the fourth component of an Android application. It is
    used to manage access to a structured set of data. Content providers encapsulate
    the data, and provide abstraction and the mechanism to define data security. However,
    content providers are primarily intended to be used by other applications that
    access the provider using a provider's client object. Together, providers and
    provider clients offer a consistent, standard interface for data, which also handles
    interprocess communication and secure data access.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 内容提供程序是Android应用程序的第四个组件。它用于管理对结构化数据集的访问。内容提供程序封装数据，并提供抽象和定义数据安全性的机制。然而，内容提供程序主要用于被其他应用程序使用，这些应用程序使用提供程序的客户端对象访问提供程序。提供程序和提供程序客户端一起为数据提供了一致的标准接口，还处理了进程间通信和安全数据访问。
- en: 'A content provider allows one app to share data with other applications. By
    design, an Android SQLite database created by an application is private to the
    application; it is excellent if you consider the security point of view, but troublesome
    when you want to share data across different applications. This is where a content
    provider comes to the rescue; you can easily share data by building your content
    provider. It is important to note that although our discussion will focus on a
    database, a content provider is not limited to it. It can also be used to serve
    file data that normally goes into files, such as photos, audio, or videos:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 内容提供程序允许一个应用程序与其他应用程序共享数据。按设计，由应用程序创建的Android SQLite数据库对应用程序是私有的；从安全的角度来看，这是很好的，但当你想要在不同的应用程序之间共享数据时会很麻烦。这就是内容提供程序发挥作用的地方；通过构建自己的内容提供程序，您可以轻松地共享数据。重要的是要注意，尽管我们的讨论将集中在数据库上，但内容提供程序并不局限于此。它也可以用来提供通常存储在文件中的文件数据，如照片、音频或视频：
- en: '![What is a content provider?](img/2951OS_03_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![什么是内容提供程序？](img/2951OS_03_01.jpg)'
- en: In the preceding diagram, notice how the interaction between Applications A
    and B happens while exchanging data. Here, we have an **Application A** whose
    activity needs to access the database of **Application B**. As we have already
    seen, the database of **Application B** is stored in the internal memory and cannot
    be directly accessed by **Application A**. This is where **Content Provider**
    comes into the picture; it allows us to share data and modify access to other
    applications. The content provider implements methods to query, insert, update,
    and delete data in databases. **Application A** now requests the content provider
    to perform some desired operations on behalf of it. We will explore both sides
    of the coin, but we will first use **Content Provider** to fetch contacts from
    a phone's contact database, and then we will build our very own content provider
    for others to pick data from our database.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，注意应用程序A和B之间交换数据的交互方式。在这里，我们有一个**应用程序A**，其活动需要访问**应用程序B**的数据库。正如我们已经看到的，**应用程序B**的数据库存储在内部存储器中，无法直接被**应用程序A**访问。这就是**内容提供程序**出现的地方；它允许我们共享数据并修改对其他应用程序的访问。内容提供程序实现了查询、插入、更新和删除数据库中的数据的方法。**应用程序A**现在请求内容提供程序代表它执行一些所需的操作。我们将探索这个问题的两面，但我们将首先使用**内容提供程序**从手机的联系人数据库中获取联系人，然后我们将构建我们自己的内容提供程序，供其他人从我们的数据库中获取数据。
- en: Using existing content providers
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用现有内容提供程序
- en: Android lists a lot of standard content providers that we can use. Some of them
    are `Browser`, `CalendarContract`, `CallLog`, `Contacts`, `ContactsContract`,
    `MediaStore`, `userDictionary`, and so on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Android列出了许多标准内容提供程序，我们可以使用。其中一些是`Browser`、`CalendarContract`、`CallLog`、`Contacts`、`ContactsContract`、`MediaStore`、`userDictionary`等。
- en: In our current contact manager application, we will add a new feature. In the
    UI of the `AddNewContactActivity` class, we will add a small button to fetch contacts
    from a phone's contact list with help from the system's existing `ContentProvider`
    and `ContentResolver` providers. We will be using the `ContactsContract` provider
    for this purpose.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的联系人管理应用程序中，我们将添加一个新功能。在`AddNewContactActivity`类的UI中，我们将添加一个小按钮，以帮助系统的现有`ContentProvider`和`ContentResolver`提供程序从手机的联系人列表中获取联系人。我们将使用`ContactsContract`提供程序来实现这个目的。
- en: What is a content resolver?
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是内容解析器？
- en: The `ContentResolver` object in the application's context is used to communicate
    with the provider as a client. The `ContentResolver` object communicates with
    the provider object—an instance of a class that implements `ContentProvider`.
    The provider object receives data requests from clients, performs the requested
    action, and returns the results.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序上下文中的`ContentResolver`对象用于作为客户端与提供程序进行通信。`ContentResolver`对象与提供程序对象通信——提供程序对象是实现`ContentProvider`的类的实例。提供程序对象接收来自客户端的数据请求，执行请求的操作，并返回结果。
- en: '`ContentResolver` is a single, global instance in our application that provides
    access to other application''s content providers; we do not need to worry about
    handling interprocess communication. The `ContentResolver` methods provide the
    basic CRUD (create, retrieve, update, and delete) functions of persistent storage;
    it has methods that call identically named methods in the provider object but
    does not know the implementation. We will cover `ContentResolver` in more detail
    as we progress through this chapter.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentResolver`是我们应用程序中的一个单一的全局实例，它提供了对其他应用程序的内容提供程序的访问；我们不需要担心处理进程间通信。`ContentResolver`方法提供了持久存储的基本CRUD（创建、检索、更新和删除）功能；它有调用提供程序对象中同名方法的方法，但不知道实现。随着我们在本章中的进展，我们将更详细地介绍`ContentResolver`。'
- en: '![What is a content resolver?](img/2951_03_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![什么是内容解析器？](img/2951_03_02.jpg)'
- en: 'In the preceding screenshot, notice the new icon on the right-hand side to
    add contacts directly from the phone contacts; we modified the existing XML to
    add the icon. The corresponding class `AddNewContactActivity` will also be modified:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，注意右侧的新图标，可以直接从手机联系人中添加联系人；我们修改了现有的XML以添加这个图标。相应的类`AddNewContactActivity`也将被修改：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We added a new method `pickContact()` to prepare an intent in order to pick
    contacts. `Intent.ACTION_PICK` allows us to pick an item from a data source; in
    addition, all we need to know is the **Uniform Resource Identifier** (**URI**)
    of the provider, which in our case is `ContactsContract.Contacts.CONTENT_URI`.
    This functionality is also provided by Messaging, Gallery, and Contacts. If you
    look into the code from [Chapter 2](ch02.html "Chapter 2. Connecting the Dots"),
    *Connecting the Dots*, you will find we have used the same code to pick images
    from Gallery. The Contacts screen will pop up allowing us to browse or search
    for contacts we require to migrate to our new application. Notice `onActivityResult`,
    that is, our next stop we will modify this method to handle our corresponding
    request to handle contacts. Let us look at the code we have to add to pick contacts
    from an Android''s contact provider:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新的方法`pickContact()`来准备一个意图以选择联系人。`Intent.ACTION_PICK`允许我们从数据源中选择一个项目；此外，我们只需要知道提供程序的**统一资源标识符**（**URI**），在我们的情况下是`ContactsContract.Contacts.CONTENT_URI`。这个功能也由消息、画廊和联系人提供。如果您查看[第2章](ch02.html
    "第2章。连接点")的代码，*连接点*，您会发现我们已经使用了相同的代码从画廊中选择图像。联系人屏幕将弹出，允许我们浏览或搜索我们需要迁移到我们的新应用程序的联系人。注意`onActivityResult`，也就是说，我们的下一站我们将修改这个方法来处理我们对联系人的相应请求。让我们看看我们需要添加的代码，以从Android的联系人提供程序中选择联系人：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To add a little flair to your application, download the entire set of stencils,
    sources, the action bar icon pack, color swatches, and the Roboto font family
    from the Android developer site, [http://goo.gl/4Msuct](http://goo.gl/4Msuct).
    Designing a functional application is incomplete without a consistent UI that
    follows Android guidelines.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为您的应用程序增添一些特色，可以从Android开发者网站[http://goo.gl/4Msuct](http://goo.gl/4Msuct)下载整套模板、源代码、操作栏图标包、颜色样本和Roboto字体系列。设计一个功能性应用程序是不完整的，如果没有遵循Android指南的一致UI。
- en: We start by checking whether the request code matches ours. Then, we cross-check
    `resultcode`. We get the `ContentResolver` object by making a call to `getcontentresolver`
    on the `Context` object; it is a method of the `android.content.Context` class.
    As we are in an activity that inherits from `Context`, we do not need to be explicit
    in making a call to it. The same goes for services. We will now verify whether
    the contact we picked has a phone number or not. After verifying the necessary
    details, we pull the data that we require, such as contact name and phone number,
    and set them in relevant fields.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查请求代码是否与我们的匹配。然后，我们交叉检查`resultcode`。我们通过在`Context`对象上调用`getcontentresolver`来获取`ContentResolver`对象；这是`android.content.Context`类的一个方法。由于我们在一个继承自`Context`的活动中，我们不需要显式地调用它。服务也是一样。现在我们将验证我们选择的联系人是否有电话号码。在验证必要的细节之后，我们提取我们需要的数据，比如联系人姓名和电话号码，并将它们设置在相关字段中。
- en: Creating a content provider
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建内容提供程序
- en: 'A content provider provides access to data in two ways: one is structured data
    that goes in the form of a database, as the example we are working on currently,
    or in the form of file data, that is, data that goes in the form of pictures,
    audio, video, and so on stored in the private space of the application. Before
    we begin digging into how to create a content provider, we should also retrospect
    whether we need one. If we want to offer data to other applications, allow users
    to copy data from our app to another, or use the search framework in our application,
    then the answer is yes.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 内容提供程序以两种方式提供数据访问：一种是以数据库的形式进行结构化数据，就像我们目前正在处理的例子一样，或者以文件数据的形式，也就是说，以图片、音频、视频等形式存储在应用程序的私有空间中。在我们开始深入研究如何创建内容提供程序之前，我们还应该回顾一下我们是否需要一个。如果我们想要向其他应用程序提供数据，允许用户从我们的应用程序复制数据到另一个应用程序，或者在我们的应用程序中使用搜索框架，那么答案就是肯定的。
- en: 'Just like other Android components (`Activity`, `Service`, or `BroadcastReceiver`),
    a content provider is created by extending the `ContentProvider` class. Since
    `ContentProvider` is an abstract class, we have to implement the six abstract
    methods. These methods are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他Android组件（`Activity`、`Service`或`BroadcastReceiver`）一样，内容提供程序是通过扩展`ContentProvider`类来创建的。由于`ContentProvider`是一个抽象类，我们必须实现这六个抽象方法。这些方法如下：
- en: '| Method | Usage |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 用法 |'
- en: '| --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `void onCreate()` | Initializes the provider |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `void onCreate()` | 初始化提供程序 |'
- en: '| `String getType(Uri)` | Returns the MIME type of data in the content provider
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `String getType(Uri)` | 返回内容提供程序中数据的MIME类型 |'
- en: '| `int delete(Uri uri, String selection, String[] selectionArgs)` | Deletes
    data from the content provider |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `int delete(Uri uri, String selection, String[] selectionArgs)` | 从内容提供程序中删除数据
    |'
- en: '| `Uri insert(Uri uri, ContentValues values)` | Inserts new data into the content
    provider |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `Uri insert(Uri uri, ContentValues values)` | 将新数据插入内容提供程序 |'
- en: '| `Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
    String sortOrder)` | Returns data to the caller |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
    String sortOrder)` | 返回数据给调用者 |'
- en: '| `int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)`
    | Updates the existing data in the content provider |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)`
    | 更新内容提供程序中的现有数据 |'
- en: These methods will be dealt with in more detail later as we progress through
    the chapter and build our application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在本章中的进展和应用程序的构建，这些方法将在以后更详细地讨论。
- en: Understanding content URIs
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解内容URI
- en: 'Every data access method of `ContentProvider` has a content URI, as an argument
    that allows it to determine the table, row, or file to access. It generally follows
    the following structure:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentProvider`的每个数据访问方法都有一个内容URI作为参数，允许它确定要访问的表、行或文件。它通常遵循以下结构：'
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's analyze the breakdown of the components of the `content://` URI. The scheme
    for content providers is always `content`. The colon and double-slash (`://`)
    act as a separator from the authority part. Then, we have the `authority` part.
    By rule, authorities have to be unique for every content provider. The naming
    convention the Android documentation recommends using is the fully qualified class
    name of your content provider subclass. Generally, it is built as a package name
    plus a qualifier for each content provider we publish.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析`content://` URI组件的分解。内容提供程序的方案始终是`content`。冒号和双斜杠(`://`)充当与权限部分的分隔符。然后，我们有`authority`部分。根据规则，每个内容提供程序的权限都必须是唯一的。Android文档推荐使用的命名约定是内容提供程序子类的完全限定类名。通常，它是一个包名称加上我们发布的每个内容提供程序的限定符。
- en: The remaining part is optional, also referred to as **path**, and is used for
    segregation between different types of data our content provider can provide.
    A very good example is the `MediaStore` provider which needs to distinguish between
    audio, video, and image files.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的部分是可选的，也称为**path**，用于区分内容提供程序可以提供的不同类型的数据。一个很好的例子是`MediaStore`提供程序，它需要区分音频、视频和图像文件。
- en: Another optional part is `id`, which points to a specific record; depending
    on whether `id` is present or not, the URI becomes ID-based or directory-based,
    respectively. Another way to understand it would be that an ID-based URI enables
    us to interact with data individually at row level, whereas a directory-based
    URI enables us to interact with multiple rows of a database.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可选部分是`id`，它指向特定记录；根据`id`是否存在，URI分别成为基于ID或基于目录。另一种理解方式是，基于ID的URI使我们能够在行级别单独与数据交互，而基于目录的URI使我们能够与数据库的多行交互。
- en: For example, consider `content://com.personalcontactmanager.provider/contacts`;
    we will encounter this soon enough as we move ahead with the chapter where we
    define how to access the content provider we are currently building.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑`content://com.personalcontactmanager.provider/contacts`；随着我们继续本章的进展，我们很快就会遇到这个。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'On a side note, the package name for applications should always be unique;
    this is because all the applications on Play Store are identified by their package
    name. All the updates for an application on Play Store need to have the same package
    name and be signed with the same keystore used initially. For instance, the following
    is the Play Store link of a Gmail application; notice that at the end of URL,
    we will find the package name of the application:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，应用程序的包名称应始终是唯一的；这是因为Play商店上的所有应用程序都是通过其包名称进行识别的。Play商店上的应用程序的所有更新都需要具有相同的包名称，并且必须使用最初使用的相同密钥库进行签名。例如，以下是Gmail应用程序的Play商店链接；请注意，在URL的末尾，我们将找到应用程序的包名称：
- en: '[play.google.com/store/apps/details?id=com.google.android.gm](http://play.google.com/store/apps/details?id=com.google.android.gm)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[play.google.com/store/apps/details?id=com.google.android.gm](http://play.google.com/store/apps/details?id=com.google.android.gm)'
- en: Declaring our contract class
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明我们的合同类
- en: Declaring a contract is a very important part of building our content provider.
    This class, as the name suggests, will act as a contract between our content provider
    and the application that is going to access our content provider. It is a `public
    final` class, which contains constant definitions for URIs, column names, and
    other metadata. It can also contain Javadoc, but the biggest advantage is that
    the developer using it need not worry about the names of tables, columns, and
    constants, leading to less error-prone code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 声明合同是构建内容提供程序的非常重要的部分。这个类，正如其名称所示，将充当我们的内容提供程序和将要访问我们的内容提供程序的应用程序之间的合同。它是一个`public
    final`类，其中包含URI、列名和其他元数据的常量定义。它也可以包含Javadoc，但最大的优势是使用它的开发人员不需要担心表的名称、列和常量的名称，从而减少了容易出错的代码。
- en: The contract class provides us with the necessary abstraction; we can change
    the underlying operations as and when required and we can also change the corresponding
    data manipulation affecting other dependent applications. An important thing to
    note is that we need to be careful while changing the contract in future; if we
    are not careful, we might break the other applications that are using our contract
    class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 合同类为我们提供了必要的抽象；我们可以根据需要更改底层操作，也可以更改影响其他依赖应用程序的相应数据操作。需要注意的一点是，我们在未来更改合同时需要小心；如果我们不小心，可能会破坏使用我们合同类的其他应用程序。
- en: 'Our contract class looks like the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的合同类看起来像下面这样：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`AUTHORITY` is the symbolic name that identifies the provider among many other
    providers registered as part of an Android system. `BASE_PATH` is the path of
    the table. `CONTENT_URI` is the URI of the table encapsulated by the provider.
    `CONTENT_TYPE` is the Android platform''s base MIME type for content URI containing
    a cursor of zero or more items. `CONTENT_ITEM_TYPE` is the Android platform''s
    base MIME type for content URIs containing a cursor of a single item. `PROJECTION_ALL`
    and `Columns` contain the column IDs of the table.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`AUTHORITY`是在Android系统中注册的许多其他提供程序中标识提供程序的符号名称。`BASE_PATH`是表的路径。`CONTENT_URI`是提供程序封装的表的URI。`CONTENT_TYPE`是包含零个或多个项目的游标的内容URI的Android平台的基本MIME类型。`CONTENT_ITEM_TYPE`是包含单个项目的游标的内容URI的Android平台的基本MIME类型。`PROJECTION_ALL`和`Columns`包含表的列ID。'
- en: Without this information, other developers will not be able to access your provider
    even though it is open for access.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这些信息，其他开发人员将无法访问您的提供程序，即使它是开放访问的。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There can be many tables inside a provider and each should have a unique path;
    the path is not a real physical path but an identifier.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 提供程序内部可能有许多表，每个表都应该有一个唯一的路径；路径不是真正的物理路径，而是一个标识符。
- en: Creating UriMatcher definitions
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建UriMatcher定义
- en: '`UriMatcher` is a utility class, which aids in matching URIs in content providers.
    The `addURI()` method takes the content URI patterns that the provider should
    recognize. We add a URI to match, and the code to return when this URI is matched:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`UriMatcher`是一个实用类，它帮助匹配内容提供程序中的URI。`addURI()`方法接受提供程序应该识别的内容URI模式。我们添加一个要匹配的URI，以及在匹配此URI时返回的代码：'
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We pass `authority`, a `path` pattern, and an integer value to the `addURI()`
    method of `UriMatcher`; it returns the `int` value, which we defined as constant
    when we tried to match patterns.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`authority`、`path`模式和整数值传递给`UriMatcher`的`addURI()`方法；当我们尝试匹配模式时，它返回我们定义的常量作为`int`值。
- en: 'Our `UriMatcher` looks like the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`UriMatcher`看起来像下面这样：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that it also supports the use of wildcards; we have used hashtag (`#`)
    in the preceding code snippet, we can also use wildcards such as `*`. In our case,
    with the hashtag, `" content://com.personalcontactmanager.provider/contacts/2"`
    this expression matches, but using `* "content://com.personalcontactmanager.provider/contacts`
    it doesn't.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它还支持使用通配符；我们在前面的代码片段中使用了井号（`#`），我们也可以使用通配符，比如`*`。在我们的情况下，使用井号，`"content://com.personalcontactmanager.provider/contacts/2"`这个表达式匹配，但使用`*
    "content://com.personalcontactmanager.provider/contacts`就不匹配了。
- en: Implementing the core methods
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现核心方法
- en: In order to build our content provider, the next step will be to prepare our
    core database access and data modifying methods, better known as CRUD methods.
    This is where the core logic of how we want to interact with our data depending
    on the insert, query, or delete calls received is specified. We will also implement
    the Android architecture's life cycle methods such as `onCreate()`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的内容提供程序，下一步将是准备我们的核心数据库访问和数据修改方法，也就是CRUD方法。这是我们希望根据接收到的插入、查询或删除调用与数据交互的核心逻辑所在。我们还将实现Android架构的生命周期方法，比如`onCreate()`。
- en: Initializing the provider through the onCreate() method
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过onCreate()方法初始化提供程序
- en: 'We create an object of our database manager class in `onCreate()`. There should
    be minimum operations in `oncreate()` as it runs on the Main UI thread, and it
    may cause lag for some users. It is good practice to avoid long-running tasks
    in `oncreate()` as it increases the startup time of the provider. It is even recommended
    to defer database creation and data loading until our provider actually receives
    a request for the data, that is, to move long-lasting actions to the CRUD methods:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`onCreate()`中创建我们的数据库管理器类的对象。`oncreate()`中应该有最少的操作，因为它在主UI线程上运行，可能会导致某些用户的延迟。最好避免在`oncreate()`中进行长时间运行的任务，因为这会增加提供程序的启动时间。甚至建议将数据库创建和数据加载推迟到我们的提供程序实际收到对数据的请求时，也就是将持续时间长的操作移到CRUD方法中：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Querying records through the query() method
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过query()方法查询记录
- en: 'The `query()` method will return a cursor over the result set. The URI is passed
    to our `UriMatcher` to see whether it matches any patterns we defined earlier.
    In our switch case statement, if it is a table-item-related case, we check whether
    the `selection` statement is empty; in case it is, we build our selection statement
    up to the `lastpathsegment`, else we append the selection to the `lastpathsegment`
    statement. We use a `DatabaseManager` object to a run query on the database and
    get a cursor as a result. It is expected of the `query()` method to throw an `IllegalArgumentException`
    to inform of an unknown URI; it is also good practice to throw a `nullPointerException`
    in case we encounter an internal error during the query process:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`query()`方法将返回结果集上的游标。将URI传递给我们的`UriMatcher`，以查看它是否与我们之前定义的任何模式匹配。在我们的switch
    case语句中，如果是与表项相关的情况，我们检查`selection`语句是否为空；如果是，我们将选择语句构建到`lastpathsegment`，否则我们将选择附加到`lastpathsegment`语句。我们使用`DatabaseManager`对象在数据库上运行查询，并得到一个游标作为结果。`query()`方法预期会抛出`IllegalArgumentException`来通知未知的URI；在查询过程中遇到内部错误时，抛出`nullPointerException`也是一个良好的做法：'
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Remember that an Android system must be able to communicate the exception across
    process boundaries. Android can do this for the following exceptions that may
    be useful in handling query errors:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Android系统必须能够跨进程边界通信异常。Android可以为以下异常执行此操作，这些异常在处理查询错误时可能有用：
- en: '`IllegalArgumentException`: You may choose to throw this if your provider receives
    an invalid content URI'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IllegalArgumentException`：如果您的提供程序收到无效的内容URI，您可以选择抛出此异常'
- en: '`NullPointerException`: This is thrown when the object is null and we try to
    access its field or method'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NullPointerException`：当对象为空且我们尝试访问其字段或方法时抛出'
- en: Adding records through the insert() method
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过insert()方法添加记录
- en: 'As the name suggests, the `insert()` method is used to insert a value in our
    database. It returns the URI of the inserted row and, while checking the URI,
    we need to remember that an insertion can happen at the table level, hence the
    operations in the method are processed at the URI that matches the table. After
    matching, we use the standard `DatabaseManager` object to insert our new value
    into the database. The content URI for the new row is constructed by appending
    the new row''s `_ID` value to the table''s content URI:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，`insert()`方法用于在我们的数据库中插入一个值。它返回插入行的URI，并且在检查URI时，我们需要记住插入可以发生在表级别，因此方法中的操作在与表匹配的URI上进行处理。匹配后，我们使用标准的`DatabaseManager`对象将新值插入到数据库中。新行的内容URI是通过将新行的`_ID`值附加到表的内容URI构造的：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Updating records through the update() method
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过update()方法更新记录
- en: The `update()` method updates an existing row in the appropriate table, using
    the values in the `ContentValues` argument. First, we identify the URI, whether
    it is directory-based or ID-based, then we build our selection statement as we
    did in the `query()` method. Now, we will execute the standard `updateRow()` method
    of `DatabaseManager` that we defined earlier while building this application in
    [Chapter 2](ch02.html "Chapter 2. Connecting the Dots"), *Connecting the Dots*,
    which returns the number of affected rows.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`方法更新适当表中的现有行，使用`ContentValues`参数中的值。首先，我们确定URI，无论是基于目录还是基于ID，然后我们构建选择语句，就像我们在`query()`方法中所做的那样。现在，我们将执行我们在[第2章](ch02.html
    "第2章。连接点")中构建此应用程序时定义的标准`DatabaseManager`的`updateRow()`方法，该方法返回受影响的行数。'
- en: 'The `update()` method returns the number of rows updated. Based on the selection
    clause, one or more rows can be updated:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`方法返回更新的行数。根据选择条件，可以更新一行或多行：'
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Deleting records through the delete() method
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过delete()方法删除记录
- en: 'The `delete()` method is very similar to the `update()` method and the process
    of using it is similar; here, the call is made to delete a row instead of updating
    it. The `delete()` method returns the number of rows deleted. Based on the selection
    clause, one or more rows can be deleted:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete()`方法与`update()`方法非常相似，使用它的过程类似；在这里，调用是用来删除一行而不是更新它。`delete()`方法返回删除的行数。根据选择条件，可以删除一行或多行：'
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Getting the return type of data through the getType() method
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过getType()方法获取数据的返回类型
- en: The signature of this simple method takes a URI and returns a string value;
    every content provider must return the content type for its supported URIs. A
    very interesting fact is that no permissions are needed for an application to
    access this information; if our content provider requires permissions, or is not
    exported, all the applications can still call this method regardless of their
    access permissions to retrieve MIME types.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单方法的签名接受一个URI并返回一个字符串值；每个内容提供者必须为其支持的URI返回内容类型。一个非常有趣的事实是，应用程序访问这些信息时不需要任何权限；如果我们的内容提供者需要权限，或者没有被导出，所有的应用程序仍然可以调用这个方法，而不管它们对检索MIME类型的访问权限如何。
- en: 'All these MIME types should be declared in the contract class:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些MIME类型都应在合同类中声明：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adding a provider to a manifest
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将提供者添加到清单中
- en: 'Another important step is to add our content provider to a manifest, like we
    do with other Android components. We can register multiple providers here. The
    important bit here, other than `android:authorities`, is `android:exported`; it
    defines whether the content provider is available for other applications to use.
    In case of `true`, the provider is available to other applications; if it is `false`,
    the provider is not available to other applications. If applications have the
    same user ID (UID) as the provider, they will have access to it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的步骤是将我们的内容提供者添加到清单中，就像我们对其他Android组件所做的那样。我们可以在这里注册多个提供者。这里的重要部分，除了`android:authorities`之外，还有`android:exported`；它定义了内容提供者是否可供其他应用程序使用。如果为`true`，则提供者可供其他应用程序使用；如果为`false`，则提供者不可供其他应用程序使用。如果应用程序具有与提供者相同的用户ID（UID），它们将可以访问它：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Another important concept is **permissions**. We can add additional security
    by adding read and write permissions, which the other application has to add in
    their manifest XML file and, in turn, automatically inform a user that they are
    going to use a particular application''s content provider either to read, write,
    or both. We can add permissions in the following manner:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的概念是**权限**。我们可以通过添加读取和写入权限来增加额外的安全性，其他应用程序必须在其清单XML文件中添加这些权限，并自动通知用户他们将要使用特定应用程序的内容提供者来读取、写入或两者兼而有之。我们可以通过以下方式添加权限：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using a content provider
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内容提供者
- en: 'The main reason we built a content provider was to allow other applications
    to access the complex data store in our database and perform CRUD operations.
    We will now build one more application in order to test our newly built content
    provider. The test application is very simple, comprising of only one activity
    class and one layout file. It has standard buttons to perform actions. Nothing
    fancy, just the tools for us to test the functionality we just implemented. We
    will now delve into the `TestMainActivity` class and look into its implementation:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建内容提供者的主要原因是允许其他应用程序访问我们数据库中的复杂数据存储并执行CRUD操作。现在我们将构建另一个应用程序来测试我们新构建的内容提供者。测试应用程序非常简单，只包括一个活动类和一个布局文件。它有标准按钮来执行操作。没有花哨的东西，只是用来测试我们刚刚实现的功能的工具。现在我们将深入研究`TestMainActivity`类并查看其实现：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To access a content provider, we need details such as `AUTHORITY` and `BASE_PATH`
    and the names of the columns of database tables; we need to access the public
    class `Columns` for this purpose. We have more tables and we will see more of
    these classes. Generally, all this necessary information will be taken from the
    published contract class of the content provider. Some content providers also
    require implementing read or write permissions in the manifest:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问内容提供程序，我们需要诸如`AUTHORITY`和`BASE_PATH`的详细信息，以及数据库表的列名称；我们需要访问公共类`Columns`。为此目的。我们有更多的表，我们将看到更多这些类。通常，所有这些必要的信息将从内容提供程序的已发布合同类中获取。一些内容提供程序还需要在清单中实现读取或写入权限：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In some cases, the content provider we need to access can ask us to add permissions
    in our manifest. When the users install the application, they will see an added
    permission in their permission list:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们需要访问的内容提供程序可能会要求我们在清单中添加权限。当用户安装应用程序时，他们将在其权限列表中看到一个添加的权限：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To try out some other app's content provider, refer to [http://goo.gl/NEX2hN](http://goo.gl/NEX2hN).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试其他应用程序的内容提供程序，请参阅[http://goo.gl/NEX2hN](http://goo.gl/NEX2hN)。
- en: It lists how you can use the Any.do's content provider—a very famous task application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它列出了如何使用Any.do的内容提供程序-一个非常著名的任务应用程序。
- en: We will set our layout and initialize the views we require in `onCreate()` of
    activity. To query, we first need to prepare the URI object that matches the table.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在活动的`onCreate()`中设置我们的布局并初始化我们需要的视图。要查询，我们首先需要准备与表匹配的URI对象。
- en: 'Content resolver now comes into play; it acts as a resolver for the content
    URI we prepared. Our `getContentResolver.query()` method, in this case, will fetch
    all the columns and rows. We will now move the cursor to the first position in
    order to read the result. For testing purposes, it''s read as a string:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在内容解析器开始发挥作用；它充当我们准备的内容URI的解析器。在这种情况下，我们的`getContentResolver.query()`方法将获取所有列和行。现在，我们将游标移动到第一个位置，以便读取结果。出于测试目的，它被读取为一个字符串：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we build a URI to read a particular row instead of a complete table. We
    already mentioned that to make URI ID-based, we need to add the ID part to our
    existing `contenturi`. Now, we build our projection string array to be passed
    as a parameter in our `query()` method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们构建一个URI来读取特定行，而不是完整的表。我们已经提到，为了使URI基于ID，我们需要将ID部分添加到我们现有的`contenturi`中。现在，我们构建我们的投影字符串数组，以作为我们`query()`方法中的参数传递：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `getFirstRowId()` method gets the ID of the first row in the table. It
    is done because the ID of the first row will not always be `1`. It changes when
    the rows are deleted. If the first item in the table with row ID `1` is deleted,
    then the second item with row ID `1` becomes the first item:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`getFirstRowId()`方法获取表中第一行的ID。这是因为第一行的ID并不总是`1`。当行被删除时，它会发生变化。如果具有行ID`1`的表中的第一项被删除，那么具有行ID`1`的第二项将成为第一项：'
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s take a closer look at the `query()` method:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下`query()`方法：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Present in API level 1, the `query()` method returns a cursor over the result
    set against the parameters we supplied. The following are the parameters of the
    preceding code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在API级别1中，`query()`方法根据我们提供的参数返回结果集上的游标。以下是前面代码的参数：
- en: '`uri`: This is `contentURI` in our case, using the `content://` scheme for
    the content to be retrieved. It can be ID-based or directory-based.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uri`：这是我们的情况下的`contentURI`，使用`content://`方案来检索内容。它可以基于ID或基于目录。'
- en: '`projection`: This is a list of the columns to be returned as we have prepared
    using the column names. Passing `null` will return all the columns.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`projection`：这是要返回的列的列表，我们已经使用列名准备好了。传递`null`将返回所有列。'
- en: '`selection`: Formatted as a SQL `WHERE` clause, excluding the `WHERE` itself,
    this acts as a filter declaring which rows to return.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selection`：格式化为SQL `WHERE`子句，不包括`WHERE`本身，这充当一个过滤器，声明要返回哪些行。'
- en: '`selectionArgs`: We may include `?` parameter markers in `selection`. Android
    SQL query builder will replace the `?` parameter markers by the values bound as
    string from `selectionArgs`, in the order that they appear in the `selection`.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selectionArgs`：我们可以在`selection`中包含`?`参数标记。Android SQL查询构建器将使用从`selectionArgs`绑定为字符串的值替换`?`参数标记，按照它们在`selection`中出现的顺序。'
- en: '`sortOrder`: This tells us how to order the rows, formatted as an SQL `ORDER
    BY` clause. A `null` value will use the default sort order.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sortOrder`：这告诉我们如何对行进行排序，格式化为SQL `ORDER BY`子句。`null`值将使用默认排序顺序。'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'According to official documentation, there are a few guidelines we should follow
    for optimum performance:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方文档，我们应该遵循一些指导方针以获得最佳性能：
- en: Provide an explicit projection to prevent reading data from storage that isn't
    going to be used.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供明确的投影，以防止从存储中读取不会使用的数据。
- en: Use question mark parameter markers such as `phone=?` instead of explicit values
    in the selection parameter, so that queries that differ only by those values will
    be recognized as the same for caching purposes.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在选择参数中使用问号参数标记，例如`phone=?`，而不是显式值，以便仅由这些值不同的查询将被识别为相同以进行缓存。
- en: The same process we used earlier to check for `null` values and an empty cursor
    is performed, and finally, a required value is extracted from the cursor.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用的相同过程用于检查`null`值和空游标，并最终从游标中提取所需的值。
- en: Now, let us look at the `insert` method for our test application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下我们测试应用程序的`insert`方法。
- en: We start by building our content value object and relevant key-value pairs,
    for instance, putting a phone number in the relevant `Columns.TABLE_ROW_PHONENUM`
    field. Notice that because details such as a column's name were shared with us
    in the form of a class, we need not worry about details such as the actual column
    name. We just need to access it via means of the `Columns` class. This ensures
    that we only need to update the relevant values. If in future the content provider
    undergoes some change and changes the table names, the rest of the functionality
    and implementation remains the same. We build our projection string array with
    the column names we required, as we did earlier in the case of querying the content
    provider for data.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先构建我们的内容值对象和相关的键值对，例如，在相关的`Columns.TABLE_ROW_PHONENUM`字段中放入电话号码。请注意，因为诸如列名之类的细节以类的形式与我们共享，所以我们不需要担心实际的列名等细节。我们只需要通过`Columns`类的方式访问它。这确保我们只需要更新相关的值。如果将来内容提供程序发生某些更改并更改表名，其余功能和实现仍然保持不变。我们像之前在查询内容提供程序数据的情况下一样，构建我们所需的列名的投影字符串数组。
- en: 'We also build our content URI; notice that it matches the table and not individual
    rows. The `insert()` method also returns a URI unlike the `query()` method, which
    returned a cursor over the result set:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还构建我们的内容URI；请注意，它与表匹配，而不是单独的行。`insert()`方法也返回一个URI，不像`query()`方法返回结果集上的游标：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `getRandomName()` and `getRandomNumber()` methods generate a random name
    and number to insert in the table:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRandomName()`和`getRandomNumber()`方法生成要插入表中的随机名称和数字：'
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s take a closer look at the `insert()` method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看`insert()`方法：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following are the parameters of the preceding line of code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上一行代码的参数：
- en: '`url`: The URL of the table to insert the data into'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`：要插入数据的表的URL'
- en: '`values`: The values for the newly inserted row in the form of a `ContentValues`
    object, the key is the column name for the field'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values`：以`ContentValues`对象的形式为新插入的行的值，键是字段的列名'
- en: Notice that after inserting, we are running the `query()` method again with
    the URI that was returned by the `insert()` method. We run this to see that the
    value we intended to insert has been inserted; this query will return columns
    as per the projection of the row whose ID is appended.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在插入后，我们再次运行了`query()`方法，使用了`insert()`方法返回的URI。我们运行这个查询是为了看到我们打算插入的值是否已经插入；这个查询将根据附加了ID的行的投影返回列。
- en: So far, we have covered the `query()` and `insert()` methods; now, we will cover
    the `update()` method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了`query()`和`insert()`方法；现在，我们将涵盖`update()`方法。
- en: 'We progressed in the `insert()` method by preparing the `ContentValues` object.
    Similarly, we will prepare an object that we will use in the `update()` method
    of `ContentResolver` to update an existing row. We will build our URI in this
    case up to the ID, as this operation is ID based. Update the row as pointed by
    the `rowUri` object and it will return the number of rows updated, which will
    be the same as the URI; in this case, it is `rowUri` that points to only a single
    row. An alternate method could be using a combination of `contentUri` (which points
    to the table) and `selection`/`selectionArgs`. In this case, the rows updated
    could be more than one as per the `selection` clause:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`insert()`方法中通过准备`ContentValues`对象来进行了进展。类似地，我们将准备一个对象，我们将在`ContentResolver`的`update()`方法中使用来更新现有行。在这种情况下，我们将构建我们的URI直到ID，因为这个操作是基于ID的。更新由`rowUri`对象指向的行，它将返回更新的行数，这将与URI相同；在这种情况下，它是指向单个行的`rowUri`。另一种方法可能是使用指向表的`contentUri`和`selection`/`selectionArgs`的组合。在这种情况下，根据`selection`子句，更新的行可能多于一个：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s take a closer look at the `update()` method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看`update()`方法：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following are the parameters of the preceding line of code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上一行代码的参数：
- en: '`uri`: This is the content URI we wish to modify'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uri`：这是我们希望修改的内容URI'
- en: '`values`: This is similar to the values we used earlier with other methods;
    passing a `null` value will remove an existing field value'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values`：这类似于我们之前在其他方法中使用的值；传递`null`值将删除现有字段值'
- en: '`where`: A SQL `WHERE` clause that acts as a filter to rows before updating
    them'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`where`：作为过滤器对行进行更新之前的SQL `WHERE`子句'
- en: We can run the `query()` method again to see whether the change is reflected;
    this activity has been left as an exercise for you.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次运行`query()`方法来查看更改是否反映出来；这个活动留给你作为练习。
- en: 'The last method is `delete()`, which we require in order to complete our arsenal
    of CRUD methods. The `delete()` method begins in a similar fashion as the rest
    of the methods do; first, prepare our content URI at the directory level and then
    build it for the ID level, that is, at the individual row level. After that, we
    pass it to the `delete()` method of `ContentResolver`. Unlike the `query()` and
    `insert()` methods that return an integer value, the `delete()` method deletes
    a row as pointed by our ID-based content URI object `rowUri` and returns the number
    of rows deleted. This will be `1` in our case as our URI points to only one row.
    An alternate method could be using a combination of `contentUri`, which points
    to the table, and `selection`/`selectionArgs`. In this case, the rows deleted
    could be more than 1 as per the `selection` clause:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法是`delete()`，我们需要它来完成我们的CRUD方法。`delete()`方法的开始方式与其他方法类似；首先，准备我们的内容URI在目录级别，然后在ID级别构建它，也就是在单个行级别。之后，我们将其传递给`ContentResolver`的`delete()`方法。与`query()`和`insert()`方法返回整数值不同，`delete()`方法删除由我们基于ID的内容URI对象`rowUri`指向的行，并返回删除的行数。在我们的情况下，这将是`1`，因为我们的URI只指向一行。另一种方法可能是使用指向表的`contentUri`和`selection`/`selectionArgs`的组合。在这种情况下，根据`selection`子句，删除的行可能多于1：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The UI and output look like the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: UI和输出如下：
- en: '![Using a content provider](img/2951_03_03.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![使用内容提供程序](img/2951_03_03.jpg)'
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to dive in a little more into how an Android content provider actually
    manages various write and read calls between various tables (hint: it uses `CountDownLatch`),
    you can check out the video at Coursera by Dr. Douglas C. Schmidt for more information.
    The video can be found at [https://class.coursera.org/posa-002/lecture/49](https://class.coursera.org/posa-002/lecture/49).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更深入地了解Android内容提供程序是如何在各个表之间管理各种写入和读取调用的（提示：它使用`CountDownLatch`），你可以查看Coursera上Douglas
    C. Schmidt博士的视频以获取更多信息。视频可以在[https://class.coursera.org/posa-002/lecture/49](https://class.coursera.org/posa-002/lecture/49)找到。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the basics of content providers. We learned how
    to access system-provided content providers and even our own version of a content
    provider. We went from creating a basic contact manager to evolving it into a
    fully-fledged citizen of the Android ecosystem by implementing `ContentProvider`
    in order to share data across other applications.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了内容提供程序的基础知识。我们学习了如何访问系统提供的内容提供程序，甚至我们自己的内容提供程序版本。我们从创建一个基本的联系人管理器，逐渐发展成为Android生态系统中的一个完整的成员，通过实现`ContentProvider`来在其他应用程序之间共享数据。
- en: In the following chapter, we will cover `Loaders`, `CursorAdapters`, nifty hacks
    and tips, and some open source libraries to make our life easier while working
    with the SQLite database.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍`Loaders`、`CursorAdapters`、巧妙的技巧和提示，以及一些开源库，以使我们在使用SQLite数据库时更轻松。
