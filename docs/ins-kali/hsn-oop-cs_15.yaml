- en: Understanding Design Patterns and Principles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解设计模式和原则
- en: 'Over the years, software has become increasingly complicated. Now, software
    is not only used for mathematical calculations or simple **create, read, update,
    and delete **(**CRUD**) operations: we are employing it to carry out complex tasks,
    such as controlling rocket engines or managing huge amounts of data every day.
    Businesses from a vast range of sectors have started to adopt software systems,
    including banks, insurance companies, research institutes, education institutes,
    and government agencies. The higher the demand for software, the more people begin
    to build careers in software development. From assembly-language programming,
    came procedural programming, before the introduction of the era of **Object-oriented
    programming** (**OOP**), which is still the most popular model, despite the emergence
    of other types of programming, such as functional programming. OOP has helped
    developers write good, modular software that is easy to maintain and extend. In
    this chapter, we are going to discuss some of the most important design principles
    and patterns that are followed by thousands of developers, and we are going to
    cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，软件变得越来越复杂。现在，软件不仅用于数学计算或简单的**创建、读取、更新和删除**（CRUD）操作：我们正在使用它来执行复杂的任务，如控制火箭发动机或每天管理大量数据。来自各个行业的企业已经开始采用软件系统，包括银行、保险公司、研究机构、教育机构和政府机构。对软件的需求越高，越多的人开始在软件开发领域建立职业。从汇编语言编程开始，经过了过程式编程，然后是**面向对象编程**（OOP）时代的介绍，尽管出现了其他类型的编程，如函数式编程，但OOP仍然是最受欢迎的模型。OOP帮助开发人员编写易于维护和扩展的良好模块化软件。在本章中，我们将讨论一些最重要的设计原则和模式，这些原则和模式被成千上万的开发人员遵循，我们将涵盖以下主题：
- en: Design principles in software development
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件开发中的设计原则
- en: Different design patterns in software development
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件开发中的不同设计模式
- en: Creational design patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建设计模式
- en: Behavioral design patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为设计模式
- en: Structural design patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构设计模式
- en: The **Model-View-Controller** (**MVC**) pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（MVC）模式'
- en: Design principles
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计原则
- en: Before we start discussing design principles, let's think about what we mean
    by **design principles **in software development. When we develop software, we
    first design its architecture, and then we start writing its code. We want to
    write our code in such a way that it generates no bugs, or so it is easy to find
    bugs if there are any. We also want the code to be easily understandable when
    we read it and we want it to be structured in such a way that it can be changed
    later if required. Although it is difficult to write the best-possible code, there
    are various principles in software development that have been developed by experienced
    computer scientists. Using these, developers can write very clean code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论设计原则之前，让我们思考一下在软件开发中我们所说的**设计原则**是什么意思。当我们开发软件时，我们首先设计其架构，然后开始编写其代码。我们希望以这样的方式编写我们的代码，即它不会产生错误，或者如果有错误，很容易找到。我们还希望在阅读代码时能够轻松理解它，并且希望它的结构能够在以后需要时进行更改。虽然很难编写最佳代码，但有许多在软件开发中由经验丰富的计算机科学家开发的原则。使用这些原则，开发人员可以编写非常干净的代码。
- en: 'The software developer Robert C. Martin, also known as Uncle Bob, came up with
    five software design principles. These principles are so effective and helpful
    for developers that they have become a norm in the software industry. Collectively,
    they are known as the SOLID principle, which represents the following different
    definitions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发人员Robert C. Martin，也被称为Uncle Bob，提出了五个软件设计原则。这些原则对开发人员非常有效和有帮助，以至于它们已经成为软件行业的一种规范。它们统称为SOLID原则，代表以下不同的定义：
- en: '**S **stands for the **single responsibility principle**'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**代表**单一职责原则**'
- en: '**O **stands for the **open-closed principle**'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**代表**开闭原则**'
- en: '**L **stands for the **Liskov substitution principle**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**代表**Liskov替换原则**'
- en: '**I **stands for the **interface segregation principle**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**代表**接口隔离原则**'
- en: '**D **stands for the **dependency inversion principle**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**代表**依赖反转原则**'
- en: Let's discuss these principles one by one.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一讨论这些原则。
- en: The single responsibility principle
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: '"A class should have one, only one reason to change."'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '"一个类应该有一个，只有一个更改的原因。"'
- en: – *Robert C. Martin*
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: – *Robert C. Martin*
- en: This means that when we write a class, we should design it in such a way that
    it has only one responsibility. You should only need to change the class for one
    reason. If you have multiple reasons to change the class, it is violating the
    single responsibility principle.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们编写一个类时，我们应该以只有一个职责的方式设计它。您应该只需要更改类的一个原因。如果您有多个更改类的原因，它就违反了单一职责原则。
- en: If a class has more than one responsibility and you make changes to a piece
    of code, this might break another piece of code, as they are in the same class
    and share some dependencies. Your code might not be very decoupled.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类具有多个职责，并且您对一段代码进行更改，这可能会破坏另一段代码，因为它们位于同一个类中并共享一些依赖关系。您的代码可能不太解耦。
- en: The open-closed principle
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开闭原则
- en: Code needs to be written in such a way that adding new things in a software
    entity, such as classes, modules, or functions, is good, but modifying the entity
    itself should not be allowed. This reduces the possibility of bugs being generated.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 代码需要以这样的方式编写，即在软件实体（如类、模块或函数）中添加新内容是好的，但不应允许修改实体本身。这减少了产生错误的可能性。
- en: The Liskov substitution principle
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Liskov替换原则
- en: '"Derived types must be completely substitutable for their base types."'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '"派生类型必须完全可替代其基本类型。"'
- en: – *Barbara Liskov*
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: – *Barbara Liskov*
- en: This principle states that when you write a class, if it is derived from another
    class, it should be replaceable with the base class. Otherwise, your code will
    be very fragile and coupled. This principle was first discovered by Barbara Liskov,
    so it is named after her.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该原则规定，当你编写一个类时，如果它是从另一个类派生的，它应该能够被基类替换。否则，你的代码将非常脆弱和耦合。这个原则是由芭芭拉·利斯科夫首次发现的，因此以她的名字命名。
- en: The interface segregation principle
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: Sometimes, developers create large interfaces that contain too much information.
    Many classes might use this interface, but they might not need everything in it.
    This is what you should avoid in order to follow this principle. This principle
    supports small interfaces instead of big interfaces and, if necessary, a class
    can inherit multiple small interfaces that are actually applicable for the class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，开发人员会创建包含太多信息的大接口。许多类可能使用这个接口，但它们可能并不需要其中的所有内容。为了遵循这个原则，你应该避免这种情况。这个原则支持小接口而不是大接口，如果必要，一个类可以继承多个适用于该类的小接口。
- en: The dependency inversion principle
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖反转原则
- en: '"High-level modules should not depend on low-level modules; both should depend
    on abstractions. Abstractions should not depend on details. Details should depend
    upon abstractions"'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: “高层模块不应该依赖低层模块；两者都应该依赖抽象。抽象不应该依赖细节。细节应该依赖抽象。”
- en: – *Robert C. Martin*
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '- *罗伯特·C·马丁*'
- en: We know that, in software development, we work with layers. To make the layers
    decoupled, we have to design the dependencies of these layers in such a way that,
    instead of depending on each other, the layers should depend on abstraction. Therefore,
    if you change something in a high-level module or a low-level module, it won't
    harm the system. When we create these abstractions, we have to design them in
    such a way that they are not dependent on the implementation details. The abstractions
    should be independent and the classes that implement these interfaces or abstract
    classes should depend on those abstractions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，在软件开发中，我们使用层。为了使这些层解耦，我们必须以这样的方式设计这些层的依赖关系，以便这些层不是相互依赖，而是依赖于抽象。因此，如果你改变高层模块或低层模块中的某些内容，它不会损害系统。当我们创建这些抽象时，我们必须以这样的方式设计它们，使它们不依赖于实现细节。这些抽象应该是独立的，实现这些接口或抽象类的类应该依赖于这些抽象。
- en: Creational design patterns
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创造性设计模式
- en: In OOP, where all things are treated as objects, it's very important to keep
    track of how an object is created and managed. If a developer doesn't pay much
    attention to this topic, the objects of the software could make the software fragile
    and coupled. It's important to maintain the objects appropriately to keep the
    application easily extendable. Creational design patterns are patterns that help
    create objects in a manner where the most common problems regarding object creation
    can be avoided.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，一切都被视为对象，因此跟踪对象的创建和管理非常重要。如果开发人员不太关注这个话题，软件的对象可能会使软件变得脆弱和耦合。保持对象适当地维护对于保持应用程序易于扩展非常重要。创造性设计模式是帮助以避免对象创建的最常见问题的方式创建对象的模式。
- en: 'There are two main concepts that exist in creational design patterns:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创造性设计模式中存在两个主要概念：
- en: Encapsulating knowledge about the concrete classes the system uses
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装系统使用的具体类的知识
- en: Hide creating and combining instances of the concrete classes
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏具体类的创建和组合实例
- en: Creational design patterns are classified into object-creational patterns and
    class-creational patterns, in which **object-creational patterns** deal with the
    creation of objects and **class-creational patterns** deal with the discovery
    of classes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创造性设计模式分为对象创建模式和类创建模式，其中**对象创建模式**处理对象的创建，**类创建模式**处理类的发现。
- en: 'There are five main creational design patterns in the industry:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 行业中有五种主要的创造性设计模式：
- en: The abstract factory pattern
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: The builder pattern
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建造者模式
- en: The factory method pattern
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法模式
- en: The prototype pattern
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型模式
- en: The singleton pattern
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式
- en: The abstract factory pattern
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: 'The definition of this pattern from *Design Patterns: Elements of Reusable
    Object-Oriented* *Software* by the Gang of Four is to provide a combination to
    build families of similar or reliant objects without specifying their concrete
    classes.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 《设计模式：可复用面向对象软件的元素》一书中，四人组提出的这种模式的定义是提供一种组合来构建类似或依赖对象家族，而不指定它们的具体类。
- en: The most important thing that this pattern offers is separation or abstraction
    of object creation. If you are not following any pattern, the simplest thing that
    comes to mind when you are creating an object is to use the `new` keyword and
    create an object wherever you need it. For example, if I need a `Person` object
    in my `Bank` class, the easiest way to do this would be to instantiate a `Person`
    object using a `new` keyword in the `Bank` class. However, using this approach
    sometimes creates complexity in the software. To avoid that, we can use the abstract
    factory pattern.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式提供的最重要的东西是对象创建的分离或抽象。如果你不遵循任何模式，当你创建一个对象时，最简单的方法就是在需要的地方使用`new`关键字创建一个对象。例如，如果我在我的`Bank`类中需要一个`Person`对象，最简单的方法就是在`Bank`类中使用`new`关键字实例化一个`Person`对象。然而，使用这种方法有时会使软件变得复杂。为了避免这种情况，我们可以使用抽象工厂模式。
- en: The abstract factory pattern is mainly used in cases where you have objects
    from the same family, or that are related or dependent in some way. The idea is
    to create factory classes to carry out the work of object creation. If an object `A`,
    needs an instance of another object `B`, object `A` should ask the factory of
    object `B` to create an object of `B` and pass it to object `A`. In this way,
    object `A` is independent of the creation of object `B`. Now, in the abstract
    factory pattern, there is another layer of abstraction. The factory classes are
    also abstracted. This means that object `A` won't call the factory of object `B`
    directly, but instead use an abstraction. There should be a mechanism that determines
    which `Factory` class needs to be called. This means that object `A` is not dependent
    on any particular factory of another object.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式主要用于有着相同家族的对象，或者以某种方式相关或依赖的情况。其思想是创建工厂类来执行对象创建的工作。如果一个对象`A`需要另一个对象`B`的实例，对象`A`应该要求对象`B`的工厂创建一个`B`的对象并将其传递给对象`A`。这样，对象`A`独立于对象`B`的创建。现在，在抽象工厂模式中，还有另一层抽象。工厂类也被抽象化了。这意味着对象`A`不会直接调用对象`B`的工厂，而是使用一个抽象。应该有一个机制来确定需要调用哪个`Factory`类。这意味着对象`A`不依赖于另一个对象的任何特定工厂。
- en: The builder pattern
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建造者模式
- en: Separating the plan of a complicated object from its imitation is the main idea
    of the builder pattern. In object-oriented software development, we sometimes
    need to create objects that are quite complex. For example, we might create an
    object that uses other objects, which in turn use other objects. Creating or instantiating
    this kind of object could be difficult when you just need that object to carry
    out another kind of work. It might also make the code more complex and reduce
    its readability.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将复杂对象的计划与其实现分离是建造者模式的主要思想。在面向对象的软件开发中，我们有时需要创建相当复杂的对象。例如，我们可能创建一个使用其他对象的对象，而这些对象又使用其他对象。当你只需要该对象执行另一种工作时，创建或实例化这种对象可能会很困难。这可能使代码变得更加复杂，降低其可读性。
- en: Let's think about an example. Imagine that you are making some burgers, some
    of which are chicken burgers and some of which are beef burgers. When creating
    the chicken burger objects, you have to create a chicken burger patty object,
    a tomato ketchup object, a cheese object, and a bread object every time you create
    a chicken burger object, which leads to messy code. You also have to follow the
    same process when creating a beef burger object. This is a really complex way
    of handling and creating these objects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想想一个例子。想象一下，你正在制作一些汉堡，其中一些是鸡肉汉堡，一些是牛肉汉堡。在创建鸡肉汉堡对象时，你必须每次创建一个鸡肉汉堡对象时创建一个鸡肉汉堡肉饼对象、一个番茄酱对象、一个奶酪对象和一个面包对象，这会导致混乱的代码。当创建牛肉汉堡对象时，你也必须遵循相同的流程。这是一种处理和创建这些对象的非常复杂的方式。
- en: The builder pattern provides a nice way to solve this complexity. Using this
    pattern, we create a class called `Builder` whose main task is to create complex
    objects and return the newly-created object. With the builder pattern, we use
    another type of class, which is normally called the `director` class. The task
    of this class is to call the `Builder` class and get the object from it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式提供了一种解决这种复杂性的好方法。使用这种模式，我们创建一个名为`Builder`的类，其主要任务是创建复杂对象并返回新创建的对象。使用建造者模式，我们使用另一种类型的类，通常称为`director`类。这个类的任务是调用`Builder`类并从中获取对象。
- en: Let's return to our burger example. We can have a `ChickenBurgerBuilder` class
    and a `BeefBurgerBuilder` class. These will set the items, the burger patty, the
    bread, the ketchup, and the cheese, in the class. When the `BurgerDirector` class
    wants to create a `chicken burger`, it will call `ChickenBurgerBuilder`. To create
    a `beef burger`, it will call `BeefBurgerBuilder`. The complexity of creating
    the `burger patty` and the other ingredients will be handled by the `Builder`
    class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的汉堡示例。我们可以有一个`ChickenBurgerBuilder`类和一个`BeefBurgerBuilder`类。这些类将在类中设置项目、汉堡肉饼、面包、番茄酱和奶酪。当`BurgerDirector`类想要创建一个`鸡肉汉堡`时，它将调用`ChickenBurgerBuilder`。要创建一个`牛肉汉堡`，它将调用`BeefBurgerBuilder`。创建`汉堡肉饼`和其他配料的复杂性将由`Builder`类处理。
- en: The factory method pattern
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法模式
- en: The factory method pattern is very similar to the abstract factory pattern.
    The difference is that, in the factory method pattern, the factory layer is not
    abstracted. Using this pattern means that you will create a factory class that
    will handle the creation of classes that implement the same abstraction. This
    means that, if there is an interface that is defined by many subclasses, a `Factory`
    class can create any of those subclasses depending on the logic passed to `Factory`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法模式与抽象工厂模式非常相似。不同之处在于，在工厂方法模式中，工厂层不是抽象的。使用这种模式意味着你将创建一个工厂类，该类将处理实现相同抽象的类的创建。这意味着，如果有一个由许多子类定义的接口，`Factory`类可以根据传递给`Factory`的逻辑创建任何这些子类中的任何一个。
- en: Let's think about an example. We will use the Factory method pattern to solve
    our burger-creating problem from the Builder pattern example we mentioned in the
    section, *The builder Pattern*. We will create a `Factory`, called `BurgerFactory`,
    that will take an input, such as `typeOfBurger` (Chicken or Beef). Then, `BurgerFactory`
    will decide which `Burger` type of object should be created. Let's suppose we
    have an Interface called `Burger` that both `ChickenBurger` and `BeefBurger` implement.
    This means that `BurgerFactory` will return an object of the `Burger` type. The
    client will not be aware which `Burger` Object will be created and returned. By
    using this pattern, we are isolating the client from a specific object, which
    increases the flexibility of the code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来想一个例子。我们将使用工厂方法模式来解决我们在生成器模式示例中提到的制作汉堡的问题。我们将创建一个名为`BurgerFactory`的`Factory`，它将接受一个输入，比如`typeOfBurger`（鸡肉或牛肉）。然后，`BurgerFactory`将决定应该创建哪种`Burger`类型的对象。假设我们有一个名为`Burger`的接口，`ChickenBurger`和`BeefBurger`都实现了这个接口。这意味着`BurgerFactory`将返回一个`Burger`类型的对象。客户端将不知道将创建和返回哪个`Burger`对象。通过使用这种模式，我们将客户端与特定对象隔离开来，从而增加了代码的灵活性。
- en: The prototype pattern
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型模式
- en: This design pattern is used when you want to avoid creating new classes of the
    same type or sub-type using traditional object-creation mechanisms, such as new
    keywords. Put simply, this pattern states that we should clone an object and then
    work with the cloned object as another newly-created object. This way, the traditional
    method of object creation is avoided.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要避免使用传统的对象创建机制（如new关键字）创建相同类型或子类型的新类时，可以使用这种设计模式。简而言之，这种模式规定我们应该克隆一个对象，然后将克隆的对象作为另一个新创建的对象来处理。这样就避免了传统的对象创建方法。
- en: The singleton pattern
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式
- en: The singleton pattern is a very simple design pattern. It involves creating
    only one object of a class in the whole application. A **singleton object** is
    an object that can't have multiple instances. Whenever a piece of code needs to
    use this singleton object, it won't create a new object; instead, it will use
    the old object that is already available.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式是一个非常简单的设计模式。它涉及在整个应用程序中只创建一个类的对象。**单例对象**是一个不能有多个实例的对象。每当一段代码需要使用这个单例对象时，它不会创建一个新对象，而是使用已经存在的旧对象。
- en: This design pattern is applicable when you want to handle some information from
    one source only. The best example of when we might use a singleton pattern is
    in a database connection string. In an application, if there are multiple database
    connections used, the database might get corrupted and cause exceptions in the
    application. Here, it's better to make the connection string a singleton object,
    meaning that only one instance is used for all communication. This reduces the
    chance of discrepancy.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只想处理来自一个来源的一些信息时，可以使用这种设计模式。单例模式的最佳示例是数据库连接字符串。在应用程序中，如果使用了多个数据库连接，数据库可能会损坏并导致应用程序异常。在这种情况下，最好将连接字符串作为单例对象，这意味着所有通信都使用同一个实例。这减少了出现差异的机会。
- en: Structural design patterns
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构设计模式
- en: 'Some of the design patterns that are available in software development are
    related to the code structure. These patterns help you to design your code in
    such a way that you will be able to avoid common structural problems. In the *Design
    Patterns: Elements of Reusable Object-Oriented Software* book by the Gang of Four,
    there are seven structural design patterns. In this section, we are just going
    to discuss four of these, which are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中有一些与代码结构相关的设计模式。这些模式可以帮助你以一种能够避免常见结构问题的方式设计你的代码。在《设计模式：可复用面向对象软件的元素》一书中，由四人组成的设计模式一书中有七种结构设计模式。在本节中，我们只讨论其中的四种，分别是：
- en: The adapter pattern
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器模式
- en: The decorator pattern
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: The facade pattern
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观模式
- en: The proxy pattern
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理模式
- en: 'If you want to find out more about the other three, take a look at the book
    *Design Patterns: Elements of Reusable Object-Oriented Software* by the Gang of
    Four. At first, it might be a little confusing to start using these patterns,
    but, as you get more experienced, it will become easier to identify which pattern
    is appropriate for which situation.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解其他三种模式的更多信息，请参阅四人组的《设计模式：可复用面向对象软件的元素》一书。起初，开始使用这些模式可能会有点困惑，但随着经验的增加，识别哪种模式适合哪种情况将变得更容易。
- en: The adapter pattern
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器模式
- en: Normally, when we think of the word adapter, we think about a small device that
    helps us plug our electronic devices into a power socket with a different kind
    of interface on the plug. The adapter design pattern actually does the same thing
    in software code. This design pattern states that, if two modules of a software
    want to communicate with each other, but the interface that one module expects
    is different from the interface that the other module has, instead of changing
    one interface to match the other interface, an adapter should be used. The benefit
    of doing this is that, in the future, if you want your code to talk to another
    interface, you won't have to change your code, but just use another adapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们想到适配器这个词时，我们会想到一个小设备，它可以帮助我们将电子设备插入具有不同接口的电源插座。适配器设计模式实际上在软件代码中做同样的事情。这种设计模式规定，如果软件的两个模块想要相互通信，但一个模块期望的接口与另一个模块具有的接口不同，那么应该使用适配器，而不是改变一个接口以匹配另一个接口。这样做的好处是，将来如果你想让你的代码与另一个接口通信，你不需要改变你的代码，只需要使用另一个适配器。
- en: For example, imagine you have an Interface, `A`, but the code that you want
    to talk to wants another Interface, `B`. Instead of changing Interface `A` to
    Interface `B`, you use an adapter that converts interface `A` to interface `B`.
    This way, the code that uses interface `A` will not break, and you will be able
    to communicate with the code that asks for interface `B`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下，你有一个接口`A`，但你想要与之通信的代码需要另一个接口`B`。你可以使用一个适配器将接口`A`转换为接口`B`，而不是将接口`A`更改为接口`B`。这样，使用接口`A`的代码不会出错，你将能够与要求接口`B`的代码进行通信。
- en: The decorator pattern
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰者模式
- en: The decorator pattern allows us to add new behaviors to objects dynamically.
    When this new behavior is added to an object, it shouldn't affect any other behavior
    that already exists on that object. This pattern provides a solution when you
    have to add new behaviors to an object at runtime. It also removes the need to
    create subclasses just to add a behavior to a task.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者模式允许我们动态地向对象添加新的行为。当这种新行为被添加到对象时，它不应该影响对象上已经存在的任何其他行为。当你需要在运行时向对象添加新行为时，这种模式提供了一种解决方案。它还消除了创建子类只是为了向任务添加行为的需要。
- en: The facade pattern
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观模式
- en: 'Sometimes, if you have complex object relationships, it is hard to map them
    all and use them in your code. The facade pattern states that you should use a
    middle object to deal with the object-relational issues and give the client an
    easy point of contact. Let''s think about an example: when you go to a restaurant
    and order some food, you actually don''t go to each chef or person in the kitchen
    and collect food portions and make your own food; you tell the waiter what food
    you want. You don''t know how the item will be prepared or who will prepare it.
    You have no control over the making of the food, you just know that you will get
    the item that you have asked for. Here, the person taking the order is working
    as a facade. They take your order and ask different people to prepare the item
    you asked for.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果你有复杂的对象关系，很难将它们全部映射并在代码中使用。外观模式指出，你应该使用一个中间对象来处理对象关系问题，并为客户端提供一个简单的联系点。让我们想想一个例子：当你去餐厅点餐时，你实际上不会去找厨师或厨房里的人收集食物，然后自己做饭；你告诉服务员你想要什么食物。你不知道这个项目将如何准备或者谁会准备它。你无法控制食物的制作，你只知道你会得到你要求的项目。在这里，接受订单的人就是一个外观。他们接受你的订单，并要求不同的人准备你要求的项目。
- en: 'Let''s say that you ordered a beef burger. You call a `GetBeefBurger()` method
    and the facade will actually call the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你点了一份牛肉汉堡。你调用一个`GetBeefBurger()`方法，外观实际上会调用以下内容：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding methods are not real methods. I just want to give you an idea
    that the work of a facade is actually to hide the complexity from the client.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法并不是真正的方法。我只是想给你一个想法，外观的工作实际上是隐藏客户端的复杂性。
- en: The proxy pattern
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理模式
- en: This pattern is very similar to the other structural design patterns that we
    have discussed. If there is a situation in which a piece of code should not call
    another piece of code directly for whatever reason, the proxy pattern can be used.
    The proxy pattern is especially useful when a piece of code doesn't have access
    rights to call another piece of code or when calling a piece of code directly
    is expensive in terms of resources. An example of when we might want to use a
    proxy pattern would be if we wanted to use a third-party library in our application,
    but we don't want our code to call the library directly for security reasons.
    In this case, we can create a proxy and let it communicate with the third-party
    code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式与我们讨论过的其他结构设计模式非常相似。如果有一种情况，一个代码片段不应该直接调用另一个代码片段，不管出于什么原因，都可以使用代理模式。代理模式在代码片段没有权限调用另一个代码片段或者直接调用代码片段在资源方面是昂贵的情况下特别有用。如果我们想在应用程序中使用第三方库，但出于安全原因不希望我们的代码直接调用该库，我们可以创建一个代理并让它与第三方代码进行通信。
- en: Behavioral design patterns
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为设计模式
- en: 'Behavioral design patterns are design patterns that deal with communication
    between objects. These design patterns allow your objects to communicate in a
    way that avoids the common issues that developers face related to object behavior.
    There are many patterns in this category:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 行为设计模式是处理对象之间通信的设计模式。这些设计模式允许你的对象以一种避免开发人员面临的与对象行为相关的常见问题的方式进行通信。在这个类别中有许多模式：
- en: The chain-of-responsibility pattern
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链模式
- en: The command pattern
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式
- en: The interpreter pattern
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器模式
- en: The iterator pattern
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器模式
- en: The mediator pattern
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中介者模式
- en: The memento pattern
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备忘录模式
- en: The observer pattern
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The state pattern
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态模式
- en: The strategy pattern
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式
- en: The template-method pattern
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法模式
- en: The visitor pattern
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者模式
- en: 'In this book, however, we are only going to talk about the following behavioral
    design patterns:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本书中，我们只会讨论以下行为设计模式：
- en: The command pattern
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式
- en: The observer pattern
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The strategy pattern
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式
- en: 'If you want to find out more, refer to the *Design Patterns: Elements of Reusable
    Object-Oriented Software* book by the Gang of Four that we mentioned earlier.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多，请参考我们之前提到的四人帮的《设计模式：可复用面向对象软件的元素》一书。
- en: The command pattern
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令模式
- en: This pattern states that, when an object wants to notify another object or call
    a method of another object, it should use another object instead of doing so directly.
    The object that will establish the communication is known as the command object.
    The command will encapsulate the object that holds the method to be called, the
    method name to be called, and the parameters that are to be passed, if there are
    any. The command pattern helps to decouple the relationship between the invoker
    and the receiver.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式规定，当一个对象想要通知另一个对象或调用另一个对象的方法时，它应该使用另一个对象而不是直接这样做。建立通信的对象称为命令对象。命令将封装持有要调用的方法、要调用的方法名称以及要传递的参数（如果有的话）的对象。命令模式有助于解耦调用者和接收者之间的关系。
- en: The observer pattern
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The **observer pattern** is a solution to a problem in which many objects need
    to know when a particular object changes because they might have to update the
    data on their end. One way to do this is that all the objects, or observers, should
    ask the object, or the observable, whether the data has changed. If the data has
    changed in the observable, the observer will do its work. However, if we do this,
    the observers have to ask the observable about data changes very frequently to
    avoid slowing down your application. This requires a lot of resources.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察者模式**是解决一个问题的解决方案，即许多对象需要知道特定对象何时发生变化，因为它们可能需要更新其端上的数据。一种方法是所有对象或观察者应该询问对象或可观察对象数据是否已更改。如果可观察对象中的数据已更改，观察者将执行其工作。然而，如果这样做，观察者必须经常询问可观察对象关于数据变化，以避免减慢应用程序的速度。这需要大量资源。'
- en: The observer pattern says that the observable should know the list of the observers
    that want to know about the data changes in the subject and notify each observer
    when the data in the subject is changed. This could be done by calling a method
    of the observers. A good use of this pattern is event and delegate in C#.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式表示可观察对象应该知道想要了解主题数据变化的观察者列表，并在主题数据发生变化时通知每个观察者。这可以通过调用观察者的方法来实现。这种模式的一个很好的应用是C#中的事件和委托。
- en: The strategy pattern
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式
- en: 'Let''s take a look at a definition of the strategy pattern from the *Design
    Patterns: Elements of Reusable Object-Oriented Software* book by the Gang of Four:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下《设计模式：可重用面向对象软件的元素》一书中的策略模式的定义：
- en: For example, a method could have different types of implementations depending
    on which class is using it. The definition, therefore, means that we need to make
    these different algorithms implement a base class or interface so that they belong
    to the same family and can be used interchangeably by the clients. The last part
    of the definition means that this pattern will allow clients to use different
    algorithms without affecting other clients.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个方法可以根据使用它的类的不同类型的实现而有所不同。因此，这个定义意味着我们需要使这些不同的算法实现一个基类或接口，以便它们属于同一个家族，并可以被客户端互换使用。定义的最后一部分意味着这种模式将允许客户端使用不同的算法而不影响其他客户端。
- en: Let's imagine that we have a class, called `Animal`, that has a few common properties,
    such as `eat`, `walk`, and `noise`. Now, let's say you want to add another property,
    such as `fly`. Most of the animals in your class can fly, but a few can't. You
    could break the `Animal` class into two different classes, such as `AnimalWhichCanFly`
    and `AnimalWhichCantFly`. However, splitting this `Animal` class into two could
    over-complicate things as these animals could have other different attributes
    as well. Instead of using inheritance, therefore, you could use composition, which
    means you can add a property called `fly` in the `Animal` class and use it to
    indicate this behavior.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`Animal`的类，它具有一些常见属性，如`eat`，`walk`和`noise`。现在，假设您想添加另一个属性，如`fly`。您的类中的大多数动物都可以飞，但有一些不能。您可以将`Animal`类分成两个不同的类，如`AnimalWhichCanFly`和`AnimalWhichCantFly`。然而，将`Animal`类分成两个可能会使事情过于复杂，因为这些动物可能还具有其他不同的属性。因此，您可以使用组合而不是继承，这意味着您可以在`Animal`类中添加一个名为`fly`的属性，并使用它来指示此行为。
- en: The strategy pattern states that instead of using a fixed type, `fly`, as the
    property type, we should use an interface, such as `IFly`, and then create `subclasses`
    that implement `IFly` and have different algorithms. Then, we can take advantage
    of polymorphism and assign the specific subclass at runtime when the subclasses
    of the `Animal` class are created.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式规定，我们应该使用接口（例如`IFly`）而不是固定类型（`fly`）作为属性类型，然后创建实现`IFly`并具有不同算法的`子类`。然后，我们可以利用多态性，并在创建`Animal`类的子类时在运行时分配特定的子类。
- en: 'Let''s try to apply this on the preceding example. In the `Animal` class, instead
    of using the `Fly` property, we will use `IFly` and then implement different classes
    that implement `IFly`. For example, we create the `CanFly : IFly` and `CannotFly
    : IFly` classes. `CanFly` and `CannotFly` will have different implementations
    of the `Fly` method. If we create a `Dog` class that implements the `Animal` class,
    we will set the `Fly` property as the `CannotFly` class. If we create a `Bird`
    class, we will create an instance of `CanFly` and assign it to the `Fly` property.
    By applying this pattern, we have achieved a less-complicated object structure
    and easily-changeable algorithms.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将这种模式应用于前面的例子。在`Animal`类中，我们将使用`IFly`而不是使用`Fly`属性，然后实现实现`IFly`的不同类。例如，我们创建`CanFly：IFly`和`CannotFly：IFly`类。`CanFly`和`CannotFly`将有`Fly`方法的不同实现。如果我们创建一个实现`Animal`类的`Dog`类，我们将把`Fly`属性设置为`CannotFly`类。如果我们创建一个`Bird`类，我们将创建`CanFly`的实例并将其分配给`Fly`属性。通过应用这种模式，我们实现了一个不那么复杂的对象结构和易于更改的算法。
- en: The MVC pattern
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC模式
- en: 'The MVC pattern is one of the most popular design patterns in the industry.
    You might have heard about it already, even if you are very new to the industry.
    This pattern is heavily used in web development. Many popular web-development
    frameworks use this design pattern. Some popular frameworks that use the MVC pattern
    are given here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式是行业中最流行的设计模式之一。您可能已经听说过它，即使您是行业的新手。这种模式在Web开发中被广泛使用。许多流行的Web开发框架使用这种设计模式。以下是一些使用MVC模式的流行框架：
- en: '**C#:** ASP.NET MVC Web Framework'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'C#: ASP.NET MVC Web Framework'
- en: '**Java:** Spring framework'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java:** Spring框架'
- en: '**PHP:** Laravel framework, Codeigniter framework'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PHP:** Laravel框架，Codeigniter框架'
- en: '**Ruby:** Rails framework'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ruby:** Rails框架'
- en: 'The MVC design pattern states that we should divide a web application into
    three parts:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: MVC设计模式规定我们应该将Web应用程序分为三个部分：
- en: Model
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型
- en: View
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图
- en: Controller
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器
- en: The **model** is the part that will hold the data models or objects and will
    be used in database transactions. **View** refers to the frontend of the application,
    which the users or customers look at. Finally, the **controller** is the part
    that handles all the business logic of the application. All the logic and decision-making
    parts will be in the controller.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型**是将保存数据模型或对象并将用于数据库事务的部分。**视图**指的是应用程序的前端，用户或客户所看到的部分。最后，**控制器**是处理应用程序所有业务逻辑的部分。所有逻辑和决策部分都将在控制器中。'
- en: The benefit of the MVC pattern is that your application is decoupled. Your view
    is independent from your business logic and your business logic is independent
    of your data source. This way, you can easily change one part of your application
    without affecting other parts of the application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式的好处在于您的应用程序是解耦的。您的视图独立于您的业务逻辑，您的业务逻辑独立于您的数据源。这样，您可以轻松地更改应用程序的一部分，而不会影响应用程序的其他部分。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Software development is interesting because it changes all the time. There are
    many ways in which you can develop, design, or code something. None of these can
    be classified as the best way, because your code might need to change depending
    on the situation. However, because software development is a type of engineering,
    there are various rules that will make your software stronger and more reliable.
    Software design principles and design patterns are examples of these kinds of
    rules. Knowing these concepts and applying them to your own situation will make
    your life as a developer much easier.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发之所以有趣，是因为它一直在变化。您可以以许多方式开发、设计或编写代码。这些方式都不能被归类为最佳方式，因为您的代码可能需要根据情况进行更改。然而，由于软件开发是一种工程类型，有各种规则可以使您的软件更加强大和可靠。软件设计原则和设计模式就是这些规则的例子。了解这些概念并将其应用于您自己的情况将使您作为开发人员的生活更加轻松。
- en: This chapter has hopefully given you an idea of the basics of design patterns
    and shown you where you can look for more information. In the next chapter, we
    will get to know a very powerful and interesting software called Git. Git is a
    version-control system that helps to keep track of software code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本章希望给您一个设计模式基础的概念，并向您展示可以查找更多信息的地方。在下一章中，我们将了解一个非常强大和有趣的软件，叫做Git。Git是一个版本控制系统，有助于跟踪软件代码。
