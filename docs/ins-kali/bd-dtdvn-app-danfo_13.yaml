- en: '*Chapter 10*: Introduction to TensorFlow.js'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：TensorFlow.js简介'
- en: In the previous chapter, you were introduced to the basics of **machine learning**
    (**ML**), and you learned some theoretical foundations that are required in order
    to build and use ML models.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你已经了解了**机器学习**（**ML**）的基础知识，并学习了一些理论基础，这些基础是构建和使用ML模型所必需的。
- en: In this chapter, we'll introduce you to an efficient and popular ML library
    in JavaScript called TensorFlow.js. By the end of this chapter, you'll know how
    to install and use TensorFlow.js, how to create tensors, how to operate on tensors
    using the Core **application programming interface** (**API**), as well as how
    to build a regression model using TensorFlow.js's Layer API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向你介绍JavaScript中一个高效且流行的ML库TensorFlow.js。在本章结束时，你将知道如何安装和使用TensorFlow.js，如何创建张量，如何使用Core
    **应用程序编程接口**（**API**）对张量进行操作，以及如何使用TensorFlow.js的Layer API构建回归模型。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is TensorFlow.js?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是TensorFlow.js？
- en: Installing and using TensorFlow.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和使用TensorFlow.js
- en: Tensors and basic operations on tensors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 张量和张量的基本操作
- en: Building a simple regression model with TensorFlow.js
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TensorFlow.js构建简单的回归模型
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along in this chapter, you should have these tools or resources:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你应该具备以下工具或资源：
- en: A modern browser such as Chrome, Safari, Opera, or Firefox.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代浏览器，如Chrome、Safari、Opera或Firefox。
- en: Node.js installed on your system
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的系统上安装了Node.js
- en: A stable internet connection for downloading packages and datasets
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定的互联网连接，用于下载软件包和数据集
- en: The code for this chapter is available and can be cloned from GitHub at [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter10](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter10)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码可在GitHub上克隆并获取，网址为[https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter10](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter10)
- en: What is TensorFlow.js?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是TensorFlow.js？
- en: '**TensorFlow.js** (**tfjs**) is a JavaScript library for creating, training,
    and deploying ML models in the browser or in Node.js. It was created at Google
    by Nikhil Thorat and Daniel Smilkov and was initially called Deeplearn.js, before
    being merged into the TensorFlow team in 2018 and renamed as TensorFlow.js.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**TensorFlow.js**（**tfjs**）是一个JavaScript库，用于在浏览器或Node.js中创建、训练和部署ML模型。它是由Google的Nikhil
    Thorat和Daniel Smilkov创建的，最初被称为Deeplearn.js，在2018年并入TensorFlow团队并更名为TensorFlow.js。'
- en: 'TensorFlow.js provides two main layers, outlined as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow.js提供了两个主要层，如下所述：
- en: '**CoreAPI**: This is the low-level API that deals directly with tensors—the
    core data structure of TensorFlow.js.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CoreAPI**：这是直接处理张量的低级API——TensorFlow.js的核心数据结构。'
- en: '**LayerAPI**: A high-level layer built on top of the CoreAPI layer for easily
    building ML models.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LayerAPI**：这是建立在CoreAPI层之上的高级层，用于轻松构建ML模型。'
- en: In later sections, *Tensors and basic operations on tensors* and *Building a
    simple regression model with TensorFlow.js*, you will learn more details about
    the CoreAPI and LayerAPI layers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，*张量和张量的基本操作*和*使用TensorFlow.js构建简单的回归模型*，你将学到更多关于CoreAPI和LayerAPI层的细节。
- en: 'With TensorFlow.js, you can do the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TensorFlow.js，你可以做到以下几点：
- en: Perform hardware-accelerated mathematical operations
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行硬件加速的数学运算
- en: Develop ML models for the browser or Node.js
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为浏览器或Node.js开发ML模型
- en: Retrain existing ML models using **transfer learning** (**TL**)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**迁移学习**（**TL**）重新训练现有的ML模型
- en: Reuse existing ML models trained with Python
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重用使用Python训练的现有ML模型
- en: In this chapter, we will cover performing hardware-accelerated mathematical
    operations and developing ML models with TensorFlow.js. If you want to learn about
    the last two use cases—retraining and reusing ML models—then the official TensorFlow.js
    documentation ([https://www.tensorflow.org/js/guide](https://www.tensorflow.org/js/guide))
    is a great place to start.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍执行硬件加速的数学运算以及使用TensorFlow.js开发ML模型。如果你想了解最后两种用例——重新训练和重用ML模型——那么官方的TensorFlow.js文档([https://www.tensorflow.org/js/guide](https://www.tensorflow.org/js/guide))是一个很好的起点。
- en: Now we have the introduction out of the way, in the next section, we'll show
    you how to install and use TensorFlow.js in both the browser and Node.js environment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍完了，接下来的章节中，我们将向你展示如何在浏览器和Node.js环境中安装和使用TensorFlow.js。
- en: Installing and using TensorFlow.js
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和使用TensorFlow.js
- en: As we mentioned earlier, TensorFlow.js can be installed and run in both the
    browser and Node.js environment. In the following paragraphs, we'll show you how
    to achieve this, starting off with the browser.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，TensorFlow.js可以在浏览器和Node.js环境中安装和运行。在接下来的段落中，我们将向你展示如何实现这一点，从浏览器开始。
- en: Setting up TensorFlow.js in the browser
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在浏览器中设置TensorFlow.js
- en: 'There are two ways of installing TensorFlow.js in the browser. These are outlined
    here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中安装TensorFlow.js有两种方式。这里进行了概述：
- en: Via script tags
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过脚本标签
- en: Using package managers such as **Node Package Manager** (**npm**) or **Yarn**
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用诸如**Node Package Manager**（**npm**）或**Yarn**之类的包管理器
- en: Installing via script tags
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过脚本标签安装
- en: 'Installing TensorFlow.js via a `script` tag is easy. Just place the `script`
    tag in the header file of your **HyperText Markup Language** (**HTML**) file,
    as shown in the following code snippet:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`script`标签安装TensorFlow.js很容易。只需将`script`标签放在你的**超文本标记语言**（**HTML**）文件的头文件中，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To confirm that TensorFlow.js is installed, open the HTML file in the browser,
    and check the network tabs. You should see the name `tf.min.js` and a status code
    of `200`, as shown in the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认TensorFlow.js已安装，打开浏览器中的HTML文件，并检查网络标签。你应该看到名称为`tf.min.js`和状态码为`200`，如下截图所示：
- en: '![Figure 10.1 – Network tab showing the successful installation of tfjs'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 - 网络标签显示了tfjs成功安装'
- en: '](img/B17076_10_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_10_01.jpg)'
- en: Figure 10.1 – Network tab showing the successful installation of tfjs
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 - 网络标签显示了tfjs成功安装
- en: 'You can add a simple script in the body of your HTML file to confirm the successful
    installation of `tfjs`. In a `script` section of your HTML file, add the following
    code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在HTML文件的body中添加一个简单的脚本来确认成功安装`tfjs`。在HTML文件的`script`部分中，添加以下代码：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code snippet logs the text `Tensorflow.js loaded` `successfully!`
    to the browser console, as soon as TensorFlow.js is loaded and ready on the page.
    To see the output, open the HTML file in the browser and check the console output.
    You should see an output result, as shown in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段将在浏览器控制台中记录文本`Tensorflow.js loaded` `successfully!`，一旦TensorFlow.js加载并准备好在页面上使用。要查看输出，请在浏览器中打开HTML文件并检查控制台输出。您应该会看到一个输出结果，如下面的屏幕截图所示：
- en: '![Figure 10.2 – Tensor output from add operation'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2 - add操作的张量输出'
- en: '](img/B17076_10_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_10_02.jpg)'
- en: Figure 10.2 – Tensor output from add operation
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 - add操作的张量输出
- en: Next, let's see how to install `tfjs` via package managers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何通过软件包管理器安装`tfjs`。
- en: Installing via package managers
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过软件包管理器安装
- en: You can install `tfjs` via package managers such as `npm` or `yarn`. This is
    useful when you need to use `tfjs` in client-side projects such as React and Vue
    projects.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`npm`或`yarn`等软件包管理器安装`tfjs`。当您需要在客户端项目（如React和Vue项目）中使用`tfjs`时，这是非常有用的。
- en: 'To install with `npm`, run the following command in your **command-line interface**
    (**CLI**):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`npm`安装，请在**命令行界面**（**CLI**）中运行以下命令：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And to install with `yarn`, just run the following command in the CLI as well:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`yarn`安装，也可以在CLI中运行以下命令：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before you can successfully install packages using `npm` or `yarn` via the
    CLI, you must have either of them installed in your system—preferably globally.
    If you have Node.js installed, then you already have `npm`. To install `yarn`,
    you can follow the steps here: [https://classic.yarnpkg.com/en/docs/install/#mac-stable](https://classic.yarnpkg.com/en/docs/install/#mac-stable).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过CLI成功安装软件包之前，您必须在系统中安装`npm`或`yarn`之一，最好是全局安装。如果您已经安装了Node.js，那么您已经有了`npm`。要安装`yarn`，您可以按照这里的步骤进行操作：[https://classic.yarnpkg.com/en/docs/install/#mac-stable](https://classic.yarnpkg.com/en/docs/install/#mac-stable)。
- en: 'On successful installation, you can import and use `tfjs`, as shown in the
    following code snippet:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 安装成功后，您可以导入并使用`tfjs`，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Running the preceding code snippet will produce the following output in the
    console:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上面的代码片段将在控制台中产生以下输出：
- en: '![Figure 10.3 – Output from testing tfjs installed with package managers'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3 - 使用软件包管理器安装tfjs的输出'
- en: '](img/B17076_10_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_10_03.jpg)'
- en: Figure 10.3 – Output from testing tfjs installed with package managers
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 - 使用软件包管理器安装tfjs的输出
- en: By following the steps in the preceding code blocks, you should be able to install
    and use `tfjs` in the browser or client-side frameworks. In the next section,
    we'll show you how to install `tfjs` in a Node.js environment.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按照上面的代码块中的步骤，您应该能够在浏览器或客户端框架中安装和使用`tfjs`。在下一节中，我们将向您展示如何在Node.js环境中安装`tfjs`。
- en: Installing TensorFlow.js in Node.js
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Node.js中安装TensorFlow.js
- en: Installing `tfjs` in Node.js is quite simple, but first, ensure you have Node.js,
    `npm`, or `yarn` installed on your system.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中安装`tfjs`非常简单，但首先确保您的系统上已安装了Node.js、`npm`或`yarn`。
- en: TensorFlow.js in Node.js has three options, and the choice of installation will
    depend on your system specification. In the following sub-sections, we'll show
    you these three options.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js中的TensorFlow.js有三个选项，安装的选择将取决于您的系统规格。在接下来的子章节中，我们将向您展示这三个选项。
- en: Installing TensorFlow.js with native C++ bindings
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用本机C++绑定安装TensorFlow.js
- en: The `@tensorflow/tfjs-node` ([https://www.npmjs.com/package/@tensorflow/tfjs-node](mailto:https://www.npmjs.com/package/%40tensorflow/tfjs-node?subject=))
    version of `tfjs` connects directly to TensorFlow's native C++ bindings. This
    makes it fast, as well as giving it a close performance with the Python version
    of TensorFlow. This means that both `tfjs-node` and `tf.keras` use the same C++
    bindings under the hood.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`@tensorflow/tfjs-node`（[https://www.npmjs.com/package/@tensorflow/tfjs-node](mailto:https://www.npmjs.com/package/%40tensorflow/tfjs-node?subject=)）版本的`tfjs`直接连接到TensorFlow的本机C++绑定。这使它快速，并且使其与TensorFlow的Python版本具有接近的性能。这意味着`tfjs-node`和`tf.keras`在内部使用相同的C++绑定。 '
- en: 'To install `tfjs-node`, just run the following command via the CLI:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`tfjs-node`，只需通过CLI运行以下命令：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or, if using `yarn`, run the following command via the CLI:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果使用`yarn`，也可以通过CLI运行以下命令：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Installing TensorFlow.js with GPU support
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装支持GPU的TensorFlow.js
- en: The `@tensorflow/tfjs-node-gpu` version of `tfjs` provides support for running
    operations on `tfjs-node-gpu` are generally faster than that of `tfjs-node` as
    operations can be easily vectorized.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`@tensorflow/tfjs-node-gpu`版本的`tfjs`支持在`tfjs-node-gpu`上运行操作，通常比`tfjs-node`快，因为操作可以很容易地进行矢量化。'
- en: 'To install `tfjs-node-gpu`, just run the following command via the CLI:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`tfjs-node-gpu`，只需通过CLI运行以下命令：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Or, if you''re using `yarn`, run the following command via the CLI:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您使用`yarn`，也可以通过CLI运行以下命令：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Installing plain TensorFlow.js
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装普通的TensorFlow.js
- en: The `@tensorflow/tfjs` version is the pure JavaScript version of `tfjs`. It
    is the slowest in terms of performance and should rarely be used.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`@tensorflow/tfjs`版本是`tfjs`的纯JavaScript版本。在性能方面它是最慢的，应该很少使用。'
- en: 'To install this version, just run the following command via the CLI:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装此版本，只需通过CLI运行以下命令：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Or, if you''re using `yarn`, run the following command via the CLI:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您使用`yarn`，也可以通过CLI运行以下命令：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you followed the preceding steps, then you should have at least one of the
    versions of `tfjs` installed. You can test for successful installation using the
    following code example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照上述步骤操作，那么您应该至少安装了`tfjs`的一个版本。您可以使用以下代码示例测试安装是否成功：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We call the `print()` function on a tensor when we want to see the underlying
    data. If we use the default `console.log`, we get the `Tensor` object instead.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要查看底层数据时，我们在张量上调用`print()`函数。如果我们使用默认的`console.log`，我们将得到`Tensor`对象。
- en: 'Running the preceding code should output the following in the console:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码应该在控制台中输出以下内容：
- en: '![Figure 10.4 – Output from testing tfjs installed in Node.js'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4 - 在Node.js中测试tfjs的输出'
- en: '](img/B17076_10_04.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_10_04.jpg)'
- en: Figure 10.4 – Output from testing tfjs installed in Node.js
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 - 在Node.js中测试tfjs的输出
- en: Now you have successfully installed `tfjs` in your project, in the next section,
    we'll introduce you to the core data structure of `tfjs`—tensors.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经成功在项目中安装了`tfjs`，在下一节中，我们将向您介绍`tfjs`的核心数据结构——张量。
- en: Tensors and basic operations on tensors
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 张量和张量的基本操作
- en: A tensor is a basic data structure in `tfjs`. You can think of tensors as a
    generalization of vectors, matrices, or high-dimensional arrays. The **CoreAPI**,
    which we introduced in the *What is TensorFlow.js?* section, exposes different
    functions for creating and working with tensors.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 张量是`tfjs`中的基本数据结构。您可以将张量视为向量、矩阵或高维数组的泛化。我们在*什么是TensorFlow.js？*部分介绍的**CoreAPI**公开了不同的函数，用于创建和处理张量。
- en: 'The following screenshot shows a simple comparison between scalars, vectors,
    and a matrix with a tensor:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了标量、向量和矩阵与张量之间的简单比较：
- en: '![Figure 10.5 – Comparison between simple n-dimensional arrays and a tensor'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.5 - 简单的n维数组与张量的比较'
- en: '](img/B17076_10_05.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_10_05.jpg)'
- en: Figure 10.5 – Comparison between simple n-dimensional arrays and a tensor
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 - 简单的n维数组与张量的比较
- en: Tip
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: A matrix is a grid of `m x n` numbers, where `m` represents the number of rows
    and `n` represents the number of columns. A matrix can be of one or more dimensions,
    and matrixes of the same shape support direct mathematical operations on each
    other.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是一个`m x n`数字的网格，其中`m`表示行数，`n`表示列数。矩阵可以是一维或多维的，形状相同的矩阵支持彼此的直接数学运算。
- en: A vector, on the other hand, is a one-dimensional matrix with shape (1, 1);
    that is, it has a single row and column—for example, [2, 3], [3, 1, 4].
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，向量是一个一维矩阵，形状为（1，1）；也就是说，它有一行和一列，例如，[2, 3]，[3, 1, 4]。
- en: 'We mentioned earlier that a tensor is more of a generalized matrix—that is,
    it extends the concept of a matrix. Tensors can be described by their rank. A
    rank is similar to the idea of a shape but is represented by a single number as
    opposed to a shape. In the following list, we see the different types of tensor
    ranks with examples:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，张量更像是一个广义的矩阵，它扩展了矩阵的概念。张量可以通过它们的秩来描述。秩类似于形状的概念，但是用一个数字表示，而不是形状。在下面的列表中，我们看到了不同类型的张量秩及其示例：
- en: A tensor of rank 0 is a scalar—for example, 1, 20, or 100\.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩为0的张量是标量，例如，1、20或100。
- en: A tensor with rank 1 is a vector—for example, [1, 20] or [20, 100, 23.6].
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩为1的张量是向量，例如，[1, 20]或[20, 100, 23.6]。
- en: A tensor with a rank of 2 is a matrix—for example, [[1, 3, 6], [2.3, 5, 7]].
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩为2的张量是矩阵，例如，[[1, 3, 6], [2.3, 5, 7]]。
- en: 'Note that we can have tensors of rank 4 or more, and these are called higher
    dimension tensors and can be difficult to visualize. See the following screenshot
    for a better understanding of tensors:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以有秩为4或更高的张量，这些被称为更高维度的张量，可能难以可视化。请参见下面的屏幕截图，以更好地理解张量：
- en: '![Figure 10.6 – Comparison of tensors with different ranks'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.6 - 不同秩的张量比较'
- en: '](img/B17076_10_06.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_10_06.jpg)'
- en: Figure 10.6 – Comparison of tensors with different ranks
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 - 不同秩的张量比较
- en: 'Besides the rank, tensors have other properties such as `dtype`, `data`, `axis`,
    and `shape`. These are described in more detail here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了秩，张量还具有其他属性，如`dtype`、`data`、`axis`和`shape`。这些在这里更详细地描述：
- en: The `dtype` property (data type) is the type of data a tensor holds—for example,
    a rank 1 tensor with the following data [2.5, 3.8] has a dtype of `float32`. By
    default, numeric tensors have a dtype of `float32`, but this can be changed during
    creation. TensorFlow.js supports `float32`, `int32`, `bool`, `complex64`, and
    `string` data types.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dtype`属性（数据类型）是张量持有的数据类型，例如，秩为1的张量具有以下数据[2.5, 3.8]，其dtype为`float32`。默认情况下，数值张量的dtype为`float32`，但可以在创建过程中更改。TensorFlow.js支持`float32`、`int32`、`bool`、`complex64`和`string`数据类型。'
- en: The `data` property is the content of a tensor. This is usually stored as an
    array.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`属性是张量的内容。这通常存储为数组。'
- en: The `axis` property is the particular dimension of a tensor—for example, an
    *m x n* tensor has an axis of *m* or *n*. The axis can be used to specify which
    dimension an operation is performed on.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`axis`属性是张量的特定维度，例如，*m x n*张量具有*m*或*n*的轴。轴可用于指定在哪个维度上执行操作。'
- en: The `shape` property is the dimension of the tensor. Think of the shape as the
    number of elements across each axis of a tensor.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shape`属性是张量的维度。将形状视为张量每个轴上的元素数量。'
- en: Now you have a basic understanding of what tensors are, in the next sub-section,
    we'll show you how to create tensors and perform some basic operations on or with
    them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对张量是什么有了基本的了解，在下一小节中，我们将向您展示如何创建张量并对其进行一些基本操作。
- en: Creating tensors
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建张量
- en: 'A tensor can be created with the `tf.tensor()` method, as shown in the following
    code snippet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 张量可以使用`tf.tensor()`方法创建，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code snippet, we pass a flat array (vector) to the `tf.tensor()`
    method to create a `tfjs` tensor. After creating this, we now have access to different
    properties and functions that can be used to manipulate or transform the tensor.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将一个平坦数组（向量）传递给`tf.tensor()`方法，以创建一个`tfjs`张量。创建后，我们现在可以访问不同的属性和函数，用于操作或转换张量。
- en: 'One such property is the `shape` property, which we can call as shown in the
    following code snippet:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个属性是`shape`属性，我们可以按照下面的代码片段中所示进行调用：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Notice that when you log the tensor with `console.log`, you get a tensor object.
    If you need to see the underlying tensor array, you can call the `print()` function
    on the tensor, as shown in the following code snippet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当您使用`console.log`记录张量时，您会得到一个张量对象。如果您需要查看底层张量数组，可以在张量上调用`print()`函数，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you need access to the underlying data of a tensor, you can call the `array()`
    or `arraySync()` method. The difference between the two is that `array()` runs
    asynchronously and returns a promise that resolves to the underlying array, while
    `arraySync()` runs synchronously. You can see an example of this here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要访问张量的基础数据，可以调用`array()`或`arraySync()`方法。两者之间的区别在于，`array()`是异步运行的，并返回一个解析为基础数组的promise，而`arraySync()`是同步运行的。您可以在这里看到一个示例：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can also create tensors by specifying a `shape` parameter. For example,
    in the following code snippet, we create a 2 x 2 (**two-dimensional** (**2D**))
    tensor from a flat array:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过指定`shape`参数来创建张量。例如，在下面的代码片段中，我们从一个平坦数组创建一个2 x 2（**二维**（**2D**））张量：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Or, we can create a 1 x 4 (**one-dimensional** (**1D**)) tensor, as shown in
    the following code snippet:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以创建一个1 x 4（**一维**（**1D**））张量，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note, however, that the shapes must match the number of elements—for example,
    you cannot create a `2 x 5`-dimensional tensor from a flat array with four elements.
    The following code will throw a shape error:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，形状必须匹配元素的数量，例如，您不能从具有四个元素的平坦数组创建一个`2 x 5`维的张量。以下代码将引发形状错误：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 10.7 – Error thrown from shape mismatch'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.7 – 形状不匹配引发的错误'
- en: '](img/B17076_10_07.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_10_07.jpg)'
- en: Figure 10.7 – Error thrown from shape mismatch
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 形状不匹配引发的错误
- en: '`Tfjs` explicitly provides functions for creating 1D, 2D, `shape` parameter.
    You can read more about creating tensors from the official `tfjs` API here: [https://js.tensorflow.org/api/latest/#Tensors-Creation](https://js.tensorflow.org/api/latest/#Tensors-Creation).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tfjs`明确提供了用于创建1D、2D、`shape`参数的函数。您可以在官方`tfjs` API中阅读更多关于创建张量的信息：[https://js.tensorflow.org/api/latest/#Tensors-Creation](https://js.tensorflow.org/api/latest/#Tensors-Creation)。'
- en: 'By default, a tensor has a `dtype` property of `float32`, so any and every
    tensor you create will have a `dtype` of `float32`. If this is not the desired
    `dtype`, you can specify the type on tensor creation, as we demonstrate in the
    following code snippet:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，张量具有`float32`的`dtype`属性，因此您创建的每个张量都将具有`float32`的`dtype`。如果这不是所需的`dtype`，您可以在张量创建时指定类型，就像我们在以下代码片段中演示的那样：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now you know how to create a tensor, we are going to move on to operating on
    tensors.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何创建张量，我们将继续对张量进行操作。
- en: Operating on tensors
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对张量进行操作
- en: Tensors, as we said earlier, store data in grids and allow numerous operations
    for manipulating or transforming this data. `tfjs` provides many operators for
    linear algebra and ML.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，张量以网格形式存储数据，并允许进行许多操作来操作或转换这些数据。`tfjs`提供了许多用于线性代数和机器学习的运算符。
- en: 'Operations in `tfjs` are grouped into different sections. Here is an explanation
    of some of the common operations:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`tfjs`中的操作被分成不同的部分。以下是一些常见操作的解释：'
- en: '`add()` for the addition of tensors, `sub()` for the subtraction of tensors,
    `mul()` for the multiplication of tensors, and `div()` for the division of tensors.
    See a full list with examples here: [https://js.tensorflow.org/api/3.7.0/#Operations-Arithmetic](https://js.tensorflow.org/api/3.7.0/#Operations-Arithmetic).'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add()`用于张量的加法，`sub()`用于张量的减法，`mul()`用于张量的乘法，`div()`用于张量的除法。在这里可以看到带有示例的完整列表：[https://js.tensorflow.org/api/3.7.0/#Operations-Arithmetic](https://js.tensorflow.org/api/3.7.0/#Operations-Arithmetic)。'
- en: '`cos()` for computing the cosine of a tensor, `sin()` for computing the sine
    of a tensor, `exp()` for computing the exponential of a tensor, and `log()` for
    computing the natural logarithm of a tensor. See a full list with examples here:
    [https://js.tensorflow.org/api/3.7.0/#Operations-Basic%20math](https://js.tensorflow.org/api/3.7.0/#Operations-Basic%20math).'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cos()`用于计算张量的余弦，`sin()`用于计算张量的正弦，`exp()`用于计算张量的指数，`log()`用于计算张量的自然对数。在这里可以看到带有示例的完整列表：[https://js.tensorflow.org/api/3.7.0/#Operations-Basic%20math](https://js.tensorflow.org/api/3.7.0/#Operations-Basic%20math)。'
- en: '**Matrices**: These operators are used for matrix operations such as dot products,
    norms, or transposes. You can see a full list of supported operators here: [https://js.tensorflow.org/api/3.7.0/#Operations-Matrices](https://js.tensorflow.org/api/3.7.0/#Operations-Matrices).'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**矩阵**：这些运算符用于矩阵运算，如点积、范数或转置。您可以在这里看到支持的运算符的完整列表：[https://js.tensorflow.org/api/3.7.0/#Operations-Matrices](https://js.tensorflow.org/api/3.7.0/#Operations-Matrices)。'
- en: '`conv1d`, which computes a 1D convolution over the input `x`, and `maxpool3D`,
    which computes a 3D max-pooling operation. See a full list here: [https://js.tensorflow.org/api/3.7.0/#Operations-Convolution](https://js.tensorflow.org/api/3.7.0/#Operations-Convolution).'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conv1d`，用于计算输入`x`的1D卷积，以及`maxpool3D`，用于计算3D最大池化操作。在这里可以看到完整列表：[https://js.tensorflow.org/api/3.7.0/#Operations-Convolution](https://js.tensorflow.org/api/3.7.0/#Operations-Convolution)。'
- en: '`min`, `max`, `sum`, `mean`, `argMax`, and `argMin`. You can see a full list
    with examples here: [https://js.tensorflow.org/api/3.7.0/#Operations-Reduction](https://js.tensorflow.org/api/3.7.0/#Operations-Reduction).'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min`、`max`、`sum`、`mean`、`argMax`和`argMin`。您可以在这里看到带有示例的完整列表：[https://js.tensorflow.org/api/3.7.0/#Operations-Reduction](https://js.tensorflow.org/api/3.7.0/#Operations-Reduction)。'
- en: '`equal`, `greater`, `greaterEqual`, and `less`. You can see a full list with
    examples here: [https://js.tensorflow.org/api/3.7.0/#Operations-Logical](https://js.tensorflow.org/api/3.7.0/#Operations-Logical).'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equal`、`greater`、`greaterEqual`和`less`。您可以在这里看到带有示例的完整列表：[https://js.tensorflow.org/api/3.7.0/#Operations-Logical](https://js.tensorflow.org/api/3.7.0/#Operations-Logical)。'
- en: 'You can see a full list of supported operations in the official API here: [https://js.tensorflow.org/api/3.7.0/#Operations](https://js.tensorflow.org/api/3.7.0/#Operations).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方API中看到支持的操作的完整列表：[https://js.tensorflow.org/api/3.7.0/#Operations](https://js.tensorflow.org/api/3.7.0/#Operations)。
- en: Now you have a basic understanding of the available tensor operators, we'll
    show some code examples.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对可用的张量运算符有了基本的了解，我们将展示一些代码示例。
- en: Applying arithmetic operations on tensors
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对张量应用算术运算
- en: 'We can add two tensors by directly calling the `add()` method on the first
    tensor and passing the second tensor as an argument, as illustrated in the following
    code snippet:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过直接在第一个张量上调用`add()`方法并将第二个张量作为参数传递来添加两个张量，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that you can also add or apply any operator directly by calling the operator
    on the `tf` object, as shown in the following code snippet:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您还可以通过在“tf”对象上调用运算符来直接添加或应用任何运算符，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Using this knowledge, you can perform other arithmetic operations such as subtraction,
    multiplication, division, and power operations, as we demonstrate in the following
    code snippet:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些知识，您可以执行其他算术运算，如减法、乘法、除法和幂运算，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It is worth mentioning that the order of the tensors passed to the operators
    matter, as a change in the order causes the result to be different. For example,
    if we swap the order of the preceding `div` operation from `const tfsub = tf.sub(b,
    a)` to `const tfsub = tf.sub(a, b)`, then we get a negative result, as shown in
    the following output:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，传递给运算符的张量的顺序很重要，因为顺序的改变会导致结果不同。例如，如果我们将前面的`div`操作的顺序从`const tfsub = tf.sub(b,
    a)`改为`const tfsub = tf.sub(a, b)`，那么我们会得到一个负结果，如下面的输出所示：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that all operations involving two tensors will only work if both tensors
    have the same shape. For example, the following operation would throw an invalid
    shape error:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，涉及两个张量的所有操作只有在两个张量具有相同形状时才能工作。例如，以下操作将引发无效形状错误：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![Figure 10.8 – Invalid shape error when performing an operation on tensors
    with a different shape'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.8–在具有不同形状的张量上执行操作时出现无效形状错误'
- en: '](img/B17076_10_08.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_10_08.jpg)'
- en: Figure 10.8 – Invalid shape error when performing an operation on tensors with
    a different shape
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8–在具有不同形状的张量上执行操作时出现无效形状错误
- en: In the next sub-section, we look at some examples of basic math operations on
    tensors.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将看一些关于张量的基本数学运算的例子。
- en: Applying basic math operations on tensors
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在张量上应用基本数学运算
- en: 'Following the example format from the previous sub-section, *Applying arithmetic
    operations on tensors*, we give some examples of computing math operations on
    tensors, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前一小节的示例格式，*在张量上应用算术运算*，我们给出了一些在张量上计算数学运算的示例，如下所示：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is shown here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we mentioned earlier, you can call operators directly from the `tf` object—for
    example, `x.cos()` becomes `tf.cos(x)`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，您可以直接从“tf”对象调用运算符，例如，`x.cos()`变成了`tf.cos(x)`。
- en: Applying reduction operations on tensors
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在张量上应用减少操作
- en: 'We can also apply reduction operations such as `mean`, `min`, `max`, `argMin`,
    and `argMax` to tensors. Here are some examples of `mean`, `min`, `max`, `argMin`,
    and `argMax` in the following code snippet:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对张量应用诸如`mean`、`min`、`max`、`argMin`和`argMax`之类的减少操作。以下是一些`mean`、`min`、`max`、`argMin`和`argMax`的例子：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is shown here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Armed with the basic knowledge of ML, tensors, and operations that can be performed
    on tensors, you are now ready to build a simple ML model. In the next section
    of this chapter, we will consolidate all that you have learned in this section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了ML、张量和可以在张量上执行的操作的基本知识，现在您已经准备好构建一个简单的ML模型了。在本章的下一节中，我们将总结您在本节中学到的所有内容。
- en: Building a simple regression model with TensorFlow.js
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TensorFlow.js构建一个简单的回归模型
- en: In the previous chapter, [*Chapter 9*](B17076_09_ePub_RK.xhtml#_idTextAnchor166),
    *Basics of Machine Learning*, you were introduced to the basics of ML, especially
    the theoretical aspect of regression and classification models. In this section,
    we'll show you how to create and train a regression model using `tfjs` **LayerAPI**.
    Specifically, by the end of this section, you'll have a regression model that
    can predict sales prices from supermarket data.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章[*第9章*]（B17076_09_ePub_RK.xhtml#_idTextAnchor166），*机器学习基础*中，您已经了解了ML的基础知识，特别是回归和分类模型的理论方面。在本节中，我们将向您展示如何使用`tfjs`
    **LayerAPI**创建和训练回归模型。具体来说，在本节结束时，您将拥有一个可以从超市数据中预测销售价格的回归模型。
- en: Setting up your environment locally
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在本地设置您的环境
- en: Before building the regression model, you have to set up your environment locally.
    In this section, we'll be working in a Node.js environment. This means that we'll
    be using the `node` version of TensorFlow.js and Danfo.js.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建回归模型之前，您必须在本地设置您的环境。在本节中，我们将在Node.js环境中工作。这意味着我们将使用TensorFlow.js和Danfo.js的`node`版本。
- en: 'Follow the steps here to set up your environment:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这里的步骤设置您的环境：
- en: 'In a new work directory, create a folder for your project. We will create one
    called `sales_predictor`, as demonstrated in the following code snippet:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的工作目录中，为您的项目创建一个文件夹。我们将创建一个名为`sales_predictor`的文件夹，如下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, open a Terminal in the folder directory and initialize a new `npm` project
    by running the following command:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在文件夹目录中打开终端，并通过运行以下命令初始化一个新的`npm`项目：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, install the `Danfo.js` node package, as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按照以下步骤安装`Danfo.js`节点包：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Also from the terminal, create an `src` folder and add `train.js`, `model.js`,
    and `data` `_proc.js` files. You can create these folders/files manually from
    your code editor or by running the following command in the terminal:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还可以从终端创建一个`src`文件夹，并添加`train.js`，`model.js`和`data` `_proc.js`文件。您可以通过代码编辑器手动创建这些文件夹/文件，也可以通过在终端中运行以下命令来创建：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now you have your project and files set up, we'll move on to the data retrieval
    and processing step in the next section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经设置好了项目和文件，我们将在下一节中继续进行数据检索和处理步骤。
- en: Retrieving and processing the training dataset
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索和处理训练数据集
- en: The dataset we'll be using for model training is called the *BigMart sales dataset*
    ([https://www.kaggle.com/devashish0507/big-mart-sales-prediction](https://www.kaggle.com/devashish0507/big-mart-sales-prediction)).
    It is available as a public dataset on Kaggle, which is a popular data science
    competition platform.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于模型训练的数据集称为*BigMart销售数据集*（[https://www.kaggle.com/devashish0507/big-mart-sales-prediction](https://www.kaggle.com/devashish0507/big-mart-sales-prediction)）。它作为一个公共数据集在Kaggle上可用，这是一个流行的数据科学竞赛平台。
- en: 'You can download the dataset directly from this chapter''s code repository
    here: [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter10/sales_predictor/src/dataset/Train.csv](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter10/sales_predictor/src/dataset/Train.csv).
    After successful download, create a folder called `dataset` in your project directory
    and copy the dataset into it.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接从本章的代码库中下载数据集：[https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter10/sales_predictor/src/dataset/Train.csv](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter10/sales_predictor/src/dataset/Train.csv)。成功下载后，在您的项目目录中创建一个名为`dataset`的文件夹，并将数据集复制到其中。
- en: 'To confirm everything is in order, your project `src` folder should have the
    following file structure:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认一切都正常，您的项目`src`文件夹应该具有以下文件结构：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As with all data science problems, a general problem statement is made available
    to guide you on the problem you''re solving. In terms of the BigMart sales dataset,
    the problem statement is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有数据科学问题一样，通常会提供一个通用的问题陈述，以指导您解决的问题。就BigMart销售数据集而言，问题陈述如下：
- en: '*BigMart have collected 2013 sales data for 1,559 products across 10 stores
    in different cities. Also, certain attributes of each product and store have been
    defined. The aim is to build a predictive model and find out the sales of each
    product at a particular store.*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*BigMart已经收集了2013年在不同城市的10家商店中1,559种产品的销售数据。此外，每种产品和商店的某些属性已经被定义。目标是建立一个预测模型，找出每种产品在特定商店的销售情况。*'
- en: From the preceding problem statement, you will notice that the aim of building
    this model is to help BigMart effectively predict sales of each product at a particular
    store. Now, sales price here means a continuous value, so as such, we have a regression
    problem.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的问题陈述中，您将注意到构建此模型的目的是帮助BigMart有效预测每种产品在特定商店的销售情况。现在，这里的销售价格意味着一个连续的值，因此，我们有一个回归问题。
- en: Now you have access to the data and have understood the problem statement, you're
    going to load the dataset with `Danfo.js` and perform some data processing and
    cleaning.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经可以访问数据并理解了问题陈述，您将使用`Danfo.js`加载数据集并进行一些数据处理和清理。
- en: Note
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'We have provided a separate **Danfo Notebook** (**Dnotebook**) file in the
    code repository here: [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter10/sales_predictor/src/bigmart%20sales%20notebook.json](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter10/sales_predictor/src/bigmart%20sales%20notebook.json).
    In the notebook, we did some data exploration and analysis of the sales dataset,
    a majority of which will help us in the following processing steps.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码库中提供了一个单独的**Danfo Notebook**（**Dnotebook**）文件：[https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter10/sales_predictor/src/bigmart%20sales%20notebook.json](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter10/sales_predictor/src/bigmart%20sales%20notebook.json)。在笔记本中，我们对销售数据集进行了一些数据探索和分析，其中大部分将帮助我们进行以下处理步骤。
- en: 'With the `data_proc.js` file opened in your code editor, follow the steps given
    here to process the BigMart sales dataset:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中打开`data_proc.js`文件，按照这里给出的步骤处理BigMart销售数据集：
- en: 'First, we will import `danfojs-node`, as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入`danfojs-node`，如下所示：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we create a function called `processData` that accepts the dataset path,
    as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个名为`processData`的函数，该函数接受数据集路径，如下所示：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, in the body of the `processData` function, we load the dataset using
    the `read_csv` function and print the header, as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`processData`函数的主体中，我们使用`read_csv`函数加载数据集并打印标题，如下所示：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To ensure data loading works, you can pass the path of your dataset to the
    `processData` function, as shown in the following code snippet:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保数据加载正常工作，您可以将数据集的路径传递给`processData`函数，如下面的代码片段所示：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And in your terminal, run the `data_proc.js` file using the following command:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端中，使用以下命令运行`data_proc.js`文件：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This outputs the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '![Figure 10.9 – Displaying the head value of the BigMart sales dataset'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.9 - 显示BigMart销售数据集的头部值'
- en: '](img/B17076_10_09.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_10_09.jpg)'
- en: Figure 10.9 – Displaying the head value of the BigMart sales dataset
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 - 显示BigMart销售数据集的头部值
- en: 'From the analysis in the Dnotebook file, we noticed that two columns, `Item_Weight`
    and `Outlet_Sales`, have missing values. In the following code snippet, we''ll
    fill these missing values using the mean and the modal value respectively:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Dnotebook文件的分析中，我们注意到`Item_Weight`和`Outlet_Sales`两列存在缺失值。在下面的代码片段中，我们将使用均值和众数分别填充这些缺失值：
- en: '[PRE39]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As we have noticed, the dataset is a mixture of categorical (strings) columns
    and numeric (`float32` and `int32`) columns. This means we must convert all categorical
    columns to numeric form before we can pass them to our model. In the following
    code snippet, we use Danfo.js''s `LabelEncoder` to encode each categorical column
    to a numeric one:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们注意到的，数据集是混合的分类（字符串）列和数值（`float32`和`int32`）列。这意味着我们必须在将它们传递给我们的模型之前，将所有分类列转换为数值形式。在下面的代码片段中，我们使用Danfo.js的`LabelEncoder`将每个分类列编码为数值列：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we''ll separate the target from the training dataset. The target, as
    we have noticed from the problem statement, is the sales price. This corresponds
    to the last column, `Item_Outlet_Sales`. In the following code snippet, we''ll
    split the dataset using the `iloc` function:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将从训练数据集中分离出目标。目标，正如我们从问题陈述中注意到的那样，是销售价格。这对应于最后一列`Item_Outlet_Sales`。在下面的代码片段中，我们将使用`iloc`函数拆分数据集：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we''ll standardize our dataset. Standardizing our dataset forces every
    column to be in the scale, and as such improves model training. In the following
    code snippet, we use Danfo.js''s `StandardScaler` to standardize the dataset:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将标准化我们的数据集。标准化数据集会强制使每一列都在同一比例上，从而提高模型训练。在下面的代码片段中，我们使用Danfo.js的`StandardScaler`来标准化数据集：
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, to complete the `processData` function, we''ll return the raw tensors,
    as shown in the following code snippet:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了完成`processData`函数，我们将返回原始张量，如下面的代码片段所示：
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can see the full code in the code repository here: [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter10/sales_predictor/src/data-proc.js](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter10/sales_predictor/src/data-proc.js).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处的代码存储库中查看完整的代码：[https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter10/sales_predictor/src/data-proc.js](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter10/sales_predictor/src/data-proc.js)。
- en: 'Executing and printing the tensors from the final `data_proc.js` file should
    give you tensors like those shown in the following screenshot:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 执行并打印最终的`data_proc.js`文件中的张量应该会给您类似于以下截图中显示的张量：
- en: '![Figure 10.10 – Final BigMart data tensors after processing'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.10 - 处理后的Final BigMart数据张量'
- en: '](img/B17076_10_10.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_10_10.jpg)'
- en: Figure 10.10 – Final BigMart data tensors after processing
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 - 处理后的Final BigMart数据张量
- en: Now you have a function that can process a raw dataset and return tensors, let's
    move on to creating models with `tfjs`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有一个可以处理原始数据集并返回张量的函数，让我们继续使用`tfjs`创建模型。
- en: Creating models with TensorFlow.js
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用TensorFlow.js创建模型
- en: As we mentioned earlier, `tfjs` provides a Layers API that can be used to define
    and create ML models. The Layers API is similar to the popular Keras API, and
    as such, Python developers already familiar with Keras can easily port their code
    to `tfjs`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，`tfjs`提供了一个Layers API，可用于定义和创建ML模型。Layers API类似于流行的Keras API，因此已经熟悉Keras的Python开发人员可以轻松地将其代码移植到`tfjs`。
- en: The Layers API provides two ways of creating models—a sequential and a model
    format. We'll briefly explain and give examples of these in the following sub-sections.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Layers API提供了创建模型的两种方式 - 顺序和模型格式。我们将在以下子部分中简要解释并举例说明这两种方式。
- en: The sequential way of creating models
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建模型的顺序方式
- en: This is the easiest and most common way of creating models. It is simply a stack
    of multiple model layers, where the first layer in the stack defines the input
    and the last layer defines the output, while the middle layers can be as many
    as required.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建模型的最简单和最常见的方式。它只是一个多个模型层的堆叠，其中堆栈中的第一层定义了输入，最后一层定义了输出，而中间层可以有很多。
- en: 'An example of a two-layer sequential model is shown in the following code snippet:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了一个两层顺序模型的示例：
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You will notice from the preceding code snippet that the first layer in the
    sequence provides an `inputShape` parameter. This means that the model is expecting
    an input with `50` columns.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到前面的代码片段中，序列中的第一层提供了`inputShape`参数。这意味着模型期望输入有`50`列。
- en: 'You can also create a sequential layer by passing a list of layers, as demonstrated
    in the following code snippet:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过传递层列表来创建顺序层，如下面的代码片段所示：
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Next, let's look at the model format.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看模型格式。
- en: The model way of creating models
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建模型的模型方式
- en: The model format of creating models provides more flexibility when creating
    models. Instead of simply accepting a stack of linear layers, models defined with
    the model layer can be non-linear, cyclical, and as advanced or connected as you
    want.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模型格式创建模型在创建模型时提供了更大的灵活性。与仅接受线性层堆叠的模型不同，使用模型层定义的模型可以是非线性的、循环的，可以像您想要的那样高级或连接。
- en: 'For example, in the following code snippet, we create a two-layer network using
    the model format:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下代码片段中，我们使用模型格式创建了一个两层网络：
- en: '[PRE46]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: From the preceding example code, you can see that we are explicitly calling
    the `apply` function and passing the layer we want to connect as a parameter.
    This way, we can build hybrid and highly complex models that have graph-like connections.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例代码中，您可以看到我们明确调用了`apply`函数，并将要连接的层作为参数传递。这样，我们可以构建具有类似图形连接的混合和高度复杂的模型。
- en: 'You can learn more about the Layers API from the official `tfjs` documentation
    here: [https://js.tensorflow.org/api/latest/#Models](https://js.tensorflow.org/api/latest/#Models).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方`tfjs`文档中了解有关Layers API的更多信息：[https://js.tensorflow.org/api/latest/#Models](https://js.tensorflow.org/api/latest/#Models)。
- en: Now you know how to create models with the Layer API, we are going to create
    a simple three-layer regression model in the next section.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何使用Layer API创建模型，我们将在下一节中创建一个简单的三层回归模型。
- en: Creating a simple three-layer regression model
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的三层回归模型
- en: 'A regression model, as we have explained in the previous chapter, [*Chapter
    9*](B17076_09_ePub_RK.xhtml#_idTextAnchor166), *Basics of Machine Learning*, is
    a model with a continuous output. To create a regression model with `tfjs`, we
    define stacks of layers, and in the last layer, we set the number of `units` to
    `1`. For example, open the `model.js` file in the code repository. On *lines 7-11*,
    you should see the following sequential model definition:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 回归模型，正如我们在上一章[*第9章*](B17076_09_ePub_RK.xhtml#_idTextAnchor166)，*机器学习基础*中所解释的，是具有连续输出的模型。要使用`tfjs`创建回归模型，我们定义层的堆栈，并在最后一层将`units`的数量设置为`1`。例如，打开代码存储库中的`model.js`文件。在*第7-11行*，您应该看到以下顺序模型定义：
- en: '[PRE47]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Notice that in the first layer, we set the `inputShape` parameter to `11`. This
    is because we have `11` training columns in our BigMart dataset. You can confirm
    this by printing the shape of the processed tensors. In the last layer, we set
    the `units` property to `1` because we want to predict a single continuous value.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第一层中，我们将`inputShape`参数设置为`11`。这是因为我们的BigMart数据集中有`11`个训练列。您可以通过打印处理后的张量的形状来确认这一点。在最后一层，我们将`units`属性设置为`1`，因为我们想要预测一个单一的连续值。
- en: The layers in between can be as many we want, and the units can take on any
    number. So, in essence, adding more layers in between gives us a deeper model,
    and adding more units gives us a wider model. The choice of layers to use will
    depend not only on the problem but also on performing multiple experiments and
    training.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 中间的层可以有很多，单位可以取任意数量。因此，在本质上，增加中间层会给我们一个更深的模型，增加单位会给我们一个更宽的模型。选择要使用的层不仅取决于问题，还取决于执行多次实验和训练。
- en: And with just those few lines of code, you have successfully created a three-layer
    regression model in `tfjs`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这几行代码，您已经成功地在`tfjs`中创建了一个三层回归模型。
- en: After creating a model, the next thing you would normally do is compile the
    model. So, what does compilation do? Well, compilation is the process of preparing
    a model for training and evaluation. This means that, in the compilation stage,
    we have to set the model's optimizers, loss, and/or training metrics.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模型后，您通常要做的下一件事是编译模型。那么，编译是什么？编译是为训练和评估准备模型的过程。这意味着在编译阶段，我们必须设置模型的优化器、损失和/或训练指标。
- en: A `tfjs` model must be compiled before you can start training. So, how do we
    compile a model in `tfjs`? This can be done by calling the `compile` function
    on a defined model and setting the optimizer and metrics you want to calculate.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始训练之前，`tfjs`模型必须先进行编译。那么，在`tfjs`中如何编译模型呢？这可以通过在已定义的模型上调用`compile`函数，并设置您想要计算的优化器和指标来完成。
- en: 'On *lines 13-17* of the `model.js` file, we compiled our regression model by
    setting the optimizer to `Adam`, and the `loss` and `metrics` properties to `meanSquaredError`.
    See the following code snippet to view this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在`model.js`文件的*13-17行*中，我们通过将优化器设置为`Adam`，将`loss`和`metrics`属性设置为`meanSquaredError`来编译了我们的回归模型。请查看以下代码片段：
- en: '[PRE48]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: It is worth mentioning that there are different types of optimizers to pick
    from; see a full list at [https://js.tensorflow.org/api/latest/#Training-Optimizers](https://js.tensorflow.org/api/latest/#Training-Optimizers).
    The choice of which optimizer to use will depend on your experience, as well as
    on multiple experimentations.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，有不同类型的优化器可供选择；请在[https://js.tensorflow.org/api/latest/#Training-Optimizers](https://js.tensorflow.org/api/latest/#Training-Optimizers)上查看完整列表。选择使用哪种优化器将取决于您的经验，以及多次实验。
- en: In terms of loss, the problem will inform you on which loss function to use.
    In our case, since it's a regression problem, we can use the **mean squared error**
    (**MSE**) function. To see a full list of available loss functions, visit [https://js.tensorflow.org/api/latest/#Training-Losses](https://js.tensorflow.org/api/latest/#Training-Losses).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在损失方面，问题将告诉您使用哪种损失函数。在我们的情况下，由于这是一个回归问题，我们可以使用**均方误差**（**MSE**）函数。要查看可用损失函数的完整列表，请访问[https://js.tensorflow.org/api/latest/#Training-Losses](https://js.tensorflow.org/api/latest/#Training-Losses)。
- en: And finally, in terms of metrics that are calculated and displayed during model
    training, we can specify multiple options, and just as with the loss, the specified
    metric will depend on the problem you are trying to solve. In our case, we can
    also calculate an MSE. To see the full list of supported metrics, visit [https://js.tensorflow.org/api/latest/#Metrics](https://js.tensorflow.org/api/latest/#Metrics).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在模型训练期间计算和显示的指标方面，我们可以指定多个选项，就像损失一样，指定的指标将取决于您要解决的问题。在我们的情况下，我们也可以计算MSE。要查看支持的指标的完整列表，请访问[https://js.tensorflow.org/api/latest/#Metrics](https://js.tensorflow.org/api/latest/#Metrics)。
- en: Now you have defined and compiled the model, we will move on to the next and
    final part of this chapter, which is about training the model.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经定义并编译了模型，我们将继续进行本章的下一个也是最后一个部分，即模型训练。
- en: Training the model with the processed dataset
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用处理过的数据集训练模型
- en: 'The `train.js` file contains the code for training the three-layer regression
    model on the processed dataset. In the following steps, we''ll walk you through
    the whole process of model training:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`train.js`文件包含了对处理过的数据集进行三层回归模型训练的代码。在接下来的步骤中，我们将带您完成整个模型训练的过程：'
- en: 'First, let''s load and process the dataset using the `processData` function,
    as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用`processData`函数加载和处理数据集，如下所示：
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we load the model using the `getModel` function, as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`getModel`函数加载模型，如下所示：
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, and very importantly, we call the `fit` function on the model, pass the
    training data, the target, and a couple of parameters such as the `epoch`, `batchSize`,
    and `validationSplits` parameters, and a callback function called `onEpochEnd`,
    as follows:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，非常重要的是，我们在模型上调用`fit`函数，传递训练数据、目标和一些参数，如`epoch`、`batchSize`和`validationSplits`参数，以及一个名为`onEpochEnd`的回调函数，如下所示：
- en: '[PRE51]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s understand what the parameters we passed to the `fit` function do, as
    follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下我们传递给`fit`函数的参数的作用，如下所示：
- en: '`Xtrain`: The training data.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Xtrain`：训练数据。'
- en: '`ytrain`: The target data.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ytrain`：目标数据。'
- en: '`epoch`: The epoch size is the number of times to iterate over the training
    data.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`epoch`：epoch大小是迭代训练数据的次数。'
- en: '`batchSize`: The batch size is the number of data points or samples used in
    computing one gradient update.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`batchSize`：批量大小是用于计算一个梯度更新的数据点或样本的数量。'
- en: '`validationSplit`: The validation split is a handy parameter that tells `tfjs`
    to reserve the specified percentage of data for validation. This can be used when
    we do not want to manually split our dataset into train and test sets.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validationSplit`：验证分割是一个方便的参数，告诉`tfjs`保留指定百分比的数据用于验证。当我们不想手动将数据集分割成训练集和测试集时，可以使用这个参数。'
- en: '`callbacks`: A callback, as the name suggests, accepts a list of functions
    that are called during different life cycles of the model training. Callbacks
    are important in monitoring model training. See a full list of callbacks here:
    [https://js.tensorflow.org/api/latest/#tf.Sequential.fitDataset](https://js.tensorflow.org/api/latest/#tf.Sequential.fitDataset).'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callbacks`：回调函数，顾名思义，接受在模型训练的不同生命周期中调用的函数列表。回调函数在监控模型训练中非常重要。在这里可以看到完整的回调函数列表：[https://js.tensorflow.org/api/latest/#tf.Sequential.fitDataset](https://js.tensorflow.org/api/latest/#tf.Sequential.fitDataset)。'
- en: 'Finally, we save the model so that we can use it in making new predictions,
    as follows:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们保存模型，以便在进行新预测时使用：
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Running the `train.js` file will load and process the dataset, load the model,
    and run the model training for the specified number of epochs. The callback (`onEpochEnd`)
    we have specified will print out the loss and the root MSE after each epoch, as
    shown in the following screenshot:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`train.js`文件将加载和处理数据集，加载模型，并对指定数量的epochs运行模型训练。我们指定的回调函数(`onEpochEnd`)将在每个epoch结束后打印出损失和均方根误差，如下面的截图所示：
- en: '![Figure 10.11 – Model training logs showing loss and root MSE'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.11 – 显示损失和均方根误差的模型训练日志'
- en: '](img/B17076_10_11.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_10_11.jpg)'
- en: Figure 10.11 – Model training logs showing loss and root MSE
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 显示损失和均方根误差的模型训练日志
- en: And that's it! You have successfully created, trained, and saved a regression
    model that can predict sale prices using TensorFlow.js. In the next and final
    section of this chapter, we'll show you how to load your saved model and use it
    to make predictions.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！您已经成功地创建、训练和保存了一个可以使用TensorFlow.js预测销售价格的回归模型。在本章的下一个和最后一节中，我们将向您展示如何加载您保存的模型并用它进行预测。
- en: Making predictions with the trained model
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用训练好的模型进行预测
- en: 'In order to make predictions, we have to load the saved model and call the
    `predict` function on it. TensorFlow.js provides a `loadLayersModel` function
    that can be used to load saved models from a filesystem. In the following steps,
    we show you how to achieve this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行预测，我们必须加载保存的模型，并在其上调用`predict`函数。TensorFlow.js提供了一个`loadLayersModel`函数，用于从文件系统加载保存的模型。在以下步骤中，我们将向您展示如何实现这一点：
- en: Create a new file called `predict.js`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`predict.js`的新文件。
- en: 'In the `predict.js` file, add the following code:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`predict.js`文件中，添加以下代码：
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The preceding code loads the saved model from the file path and prints a summary.
    The output of the summary should be similar to that shown in the following screenshot:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码从文件路径加载了保存的模型并打印了摘要。摘要的输出应该与下面的截图类似：
- en: '![Figure 10.12 – Model summary of the saved model'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.12 – 保存模型的模型摘要'
- en: '](img/B17076_10_12.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_10_12.jpg)'
- en: Figure 10.12 – Model summary of the saved model
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 – 保存模型的模型摘要
- en: 'Now, create a new function called `predict` that uses the saved model to make
    a prediction, as shown in the following code snippet:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`predict`的新函数，该函数使用保存的模型进行预测，如下面的代码片段所示：
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output is shown here:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE55]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding function, we call the `predict` function on the model and pass
    a tensor with the correct shape (batch, 11) our model is expecting. This returns
    a tensor of the prediction and from this tensor, we get the underlying value.
    From this, we can tell a product with those specific values will sell for approximately
    **US Dollars** (**USD**) $739.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们在模型上调用`predict`函数，并传递一个具有正确形状（批次，11）的张量，这是我们的模型所期望的。这将返回一个预测的张量，从这个张量中，我们可以得到基础值。从这个值，我们可以得知具有这些特定值的产品大约会售价**美元**（**USD**）$739。
- en: Note
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In a real-world application, you would generally load a test dataset from another
    **comma-separated values** (**CSV**) file and apply the same data processing steps
    as we did during training. The example uses an inline data point, just to demonstrate
    using a saved model to make predictions.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，您通常会从另一个**逗号分隔值**（**CSV**）文件中加载测试数据集，并应用与训练过程中相同的数据处理步骤。本示例使用内联数据点，只是为了演示如何使用保存的模型进行预测。
- en: That brings us to the end of this chapter! Congratulations on making it this
    far. I'm sure you have learned a lot. In the next chapter, we'll go deeper by
    building a more practical application—a recommendation system!
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本章的结束了！恭喜您走到了这一步。我相信您已经学到了很多。在下一章中，我们将通过构建一个更实用的应用程序——一个推荐系统来深入探讨！
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced you to the basics of TensorFlow.js. Specifically,
    you learned how to install TensorFlow.js both in the browser and Node.js environment,
    you learned about tensors and the core data structure of `tfjs`, you learned about
    the Core and Layer APIs, and finally, you learned how to build, train, and save
    a regression model.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们向您介绍了TensorFlow.js的基础知识。具体来说，您学习了如何在浏览器和Node.js环境中安装TensorFlow.js，学习了张量和`tfjs`的核心数据结构，学习了核心和层API，最后，您学会了如何构建、训练和保存回归模型。
- en: In the next chapter, we'll go deeper into a more practical and hands-on project,
    and the knowledge gained here will help you build great products with TensorFlow.js
    and Danfo.js.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨一个更实用和动手的项目，这里所学到的知识将帮助您使用TensorFlow.js和Danfo.js构建出色的产品。
