- en: Algorithms and Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法和数据结构
- en: Problems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 45\. Priority queue
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 45. 优先级队列
- en: 'Write a data structure that represents a priority queue that provides constant
    time lookup for the largest element, but has logarithmic time complexity for adding
    and removing elements. A queue inserts new elements at the end and removes elements
    from the top. By default, the queue should use `operator<` to compare elements,
    but it should be possible for the user to provide a comparison function object
    that returns `true` if the first argument is less than the second. The implementation
    must provide at least the following operations:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个表示优先级队列的数据结构，该队列提供最大元素的常数时间查找，但对于添加和删除元素具有对数时间复杂度。队列在末尾插入新元素，并从顶部删除元素。默认情况下，队列应该使用`operator<`来比较元素，但用户应该能够提供一个比较函数对象，如果第一个参数小于第二个参数，则返回`true`。实现必须至少提供以下操作：
- en: '`push()` to add a new element'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push()`添加一个新元素'
- en: '`pop()` to remove the top element'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop()`删除顶部元素'
- en: '`top()` to provide access to the top element'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top()`提供对顶部元素的访问'
- en: '`size()` to indicate the number of elements in the queue'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size()`指示队列中的元素数量'
- en: '`empty()` to indicate whether the queue is empty'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`empty()`指示队列是否为空'
- en: 46\. Circular buffer
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 46. 循环缓冲区
- en: 'Create a data structure that represents a circular buffer of a fixed size.
    A circular buffer overwrites existing elements when the buffer is being filled
    beyond its fixed size. The class you must write should:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个表示固定大小的循环缓冲区的数据结构。当缓冲区填满超出其固定大小时，循环缓冲区会覆盖现有元素。您必须编写的类应该：
- en: Prohibit default construction
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁止默认构造
- en: Support the creation of objects with a specified size
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持使用指定大小创建对象
- en: Allow checking of the buffer capacity and status (`empty()`, `full()`, `size()`, `capacity()`)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许检查缓冲区容量和状态（`empty()`，`full()`，`size()`，`capacity()`）
- en: Add a new element, an operation that could potentially overwrite the oldest
    element in the buffer
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个新元素，这个操作可能会覆盖缓冲区中最旧的元素
- en: Remove the oldest element from the buffer
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从缓冲区中删除最旧的元素
- en: Support iteration through its elements
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持通过其元素进行迭代
- en: 47\. Double buffer
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 47. 双缓冲
- en: Write a class that represents a buffer that could be written and read at the
    same time without the two operations colliding. A read operation must provide
    access to the old data while a write operation is in progress. Newly written data
    must be available for reading upon completion of the write operation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个表示缓冲区的类，可以同时进行写和读操作，而不会发生两个操作的冲突。读操作必须在进行写操作时提供对旧数据的访问。新写入的数据必须在写操作完成后可供读取。
- en: 48\. The most frequent element in a range
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 48. 范围内最频繁的元素
- en: Write a function that, given a range, returns the most frequent element and
    the number of times it appears in the range. If more than one element appears
    the same maximum number of times then the function should return all the elements.
    For instance, for the range `{1,1,3,5,8,13,3,5,8,8,5}`, it should return `{5,
    3}` and `{8, 3}`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，给定一个范围，返回出现最频繁的元素以及它在范围内出现的次数。如果有多个元素出现相同的最大次数，则函数应返回所有这些元素。例如，对于范围`{1,1,3,5,8,13,3,5,8,8,5}`，它应该返回`{5,
    3}`和`{8, 3}`。
- en: 49\. Text histogram
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 49. 文本直方图
- en: Write a program that, given a text, determines and prints a histogram with the
    frequency of each letter of the alphabet. The frequency is the percentage of the
    number of appearances of each letter from the total count of letters. The program
    should count only the appearances of letters and ignore digits, signs, and other
    possible characters. The frequency must be determined based on the count of letters
    and not the text size.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，给定一个文本，确定并打印每个字母的频率直方图。频率是每个字母出现的次数占字母总数的百分比。程序应该只计算字母的出现次数，忽略数字、符号和其他可能的字符。频率必须基于字母计数而不是文本大小确定。
- en: 50\. Filtering a list of phone numbers
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 50. 过滤电话号码列表
- en: Write a function that, given a list of phone numbers, returns only the numbers
    that are from a specified country. The country is indicated by its phone country
    code, such as 44 for Great Britain. Phone numbers may start with the country code,
    a `+` followed by the country code, or have no country code. The ones from this
    last category must be ignored.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，给定一个电话号码列表，仅返回来自特定国家的号码。国家由其电话国家代码表示，例如英国的44。电话号码可能以国家代码开头，后面跟着国家代码的`+`，或者没有国家代码。来自最后一类的电话号码必须被忽略。
- en: 51\. Transforming a list of phone numbers
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 51. 转换电话号码列表
- en: 'Write a function that, given a list of phone numbers, transforms them so they
    all start with a specified phone country code, preceded by the `+` sign. Any whitespaces
    from a phone number should also be removed. The following is a list of input and
    output examples:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，给定一个电话号码列表，将它们转换为都以指定电话国家代码开头，前面加上`+`号。电话号码中的任何空格也应该被移除。以下是输入和输出示例列表：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 52\. Generating all the permutations of a string
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 52. 生成字符串的所有排列
- en: 'Write a function that, prints on the console all the possible permutations
    of a given string. You should provide two versions of this function: one that
    uses recursion, and one that does not.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，在控制台上打印给定字符串的所有可能排列。您应该提供此函数的两个版本：一个使用递归，一个不使用递归。
- en: 53\. Average rating of movies
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 53. 电影的平均评分
- en: Write a program that calculates and prints the average rating of a list of movies.
    Each movie has a list of ratings from 1 to 10 (where 1 is the lowest and 10 is
    the highest rating). In order to compute the rating, you must remove 5% of the
    highest and lowest ratings before computing their average. The result must be
    displayed with a single decimal point.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个计算并打印电影列表的平均评分的程序。每部电影都有一个从1到10的评分列表（其中1是最低分，10是最高分）。为了计算评分，您必须在计算平均值之前删除最高和最低评分的5%。结果必须以一个小数点显示。
- en: 54\. Pairwise algorithm
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 54. 两两算法
- en: Write a general-purpose function that, given a range, returns a new range with
    pairs of consecutive elements from the input range. Should the input range have
    an odd number of elements, the last one must be ignored. For example, if the input
    range was `{1, 1, 3, 5, 8, 13, 21}`, the result must be `{ {1, 1}, {3, 5}, {8,
    13}}`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个通用函数，给定一个范围，返回一个由输入范围的连续元素对组成的新范围。如果输入范围的元素数是奇数，最后一个元素必须被忽略。例如，如果输入范围是`{1,
    1, 3, 5, 8, 13, 21}`，结果必须是`{{1, 1}, {3, 5}, {8, 13}}`。
- en: 55\. Zip algorithm
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 55.压缩算法
- en: Write a function that, given two ranges, returns a new range with pairs of elements
    from the two ranges. Should the two ranges have different sizes, the result must
    contain as many elements as the smallest of the input ranges. For example, if
    the input ranges were `{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }` and `{ 1, 1, 3, 5, 8,
    13, 21 }`, the result should be `{{1,1}, {2,1}, {3,3}, {4,5}, {5,8}, {6,13}, {7,21}}`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，给定两个范围，返回一个由两个范围的元素对组成的新范围。如果两个范围的大小不同，结果必须包含与输入范围中最小的元素一样多的元素。例如，如果输入范围是`{1,
    2, 3, 4, 5, 6, 7, 8, 9, 10}`和`{1, 1, 3, 5, 8, 13, 21}`，结果应该是`{{1,1}, {2,1}, {3,3},
    {4,5}, {5,8}, {6,13}, {7,21}}`。
- en: 56\. Select algorithm
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 56.选择算法
- en: 'Write a function that, given a range of values and a projection function, transforms
    each value into a new one and returns a new range with the selected values. For
    instance, if you have a type book that has an `id`, `title`, and `author`, and
    have a range of such book values, it should be possible for the function to select
    only the title of the books. Here is an example of how the function should be
    used:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，给定一个值范围和一个投影函数，将每个值转换为一个新值，并返回一个选择的值的新范围。例如，如果你有一个具有`id`、`title`和`author`的书类型，并且有一系列这样的书值，函数应该能够选择书的标题。以下是函数应该如何使用的示例：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 57\. Sort algorithm
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 57.排序算法
- en: 'Write a function that, given a pair of random-access iterators to define its
    lower and upper bounds, sorts the elements of the range using the quicksort algorithm.
    There should be two overloads of the sort function: one that uses `operator<` to
    compare the elements of the range and put them in ascending order, and one that
    uses a user-defined binary comparison function for comparing the elements.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '编写一个函数，给定一对随机访问迭代器来定义它的下限和上限，使用快速排序算法对范围的元素进行排序。排序函数应该有两个重载：一个使用`operator<`来比较范围的元素并按升序放置它们，另一个使用用户定义的二进制比较函数来比较元素。 '
- en: 58\. The shortest path between nodes
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 58.节点之间的最短路径
- en: 'Write a program that, given a network of nodes and the distances between them,
    computes and displays the shortest distance from a specified node to all the others,
    as well as the path between the start and end node. As input, consider the following
    undirected graph:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，给定节点之间的网络和距离，计算并显示从指定节点到其他所有节点的最短距离，以及起点和终点节点之间的路径。作为输入，考虑以下无向图：
- en: '![](img/5162fe54-036c-4624-bdbe-6ed6cfe211be.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5162fe54-036c-4624-bdbe-6ed6cfe211be.png)'
- en: 'The program output for this graph should be the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图的程序输出应该是以下内容：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 59\. The Weasel program
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 59.鼬程序
- en: 'Write a program that implements Richard Dawkins'' weasel computer simulation,
    described in Dawkins'' words as follows (*The Blind Watchmaker*, chapter 3):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个实现理查德·道金斯的鼬计算机模拟的程序，道金斯在《盲目的看守者》第3章中描述如下：
- en: We again use our computer monkey, but with a crucial difference in its program.
    It again begins by choosing a random sequence of 28 letters, just as before ...
    it duplicates it repeatedly, but with a certain chance of random error – 'mutation'
    – in the copying. The computer examines the mutant nonsense phrases, the 'progeny'
    of the original phrase, and chooses the one which, however slightly, most resembles
    the target phrase, METHINKS IT IS LIKE A WEASEL.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用我们的计算机猴子，但它的程序有一个关键的不同。它再次开始选择一个随机序列的28个字母，就像以前一样……它重复复制它，但在复制过程中有一定的随机错误的机会
    - '突变'。计算机检查原始短语的突变无意义短语，“后代”，并选择那个最像目标短语的短语，即使只是稍微像，METHINKS IT IS LIKE A WEASEL。
- en: 60\. The Game of Life
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 60.生命游戏
- en: 'Write a program that implements the *Game of Life* cellular automaton proposed
    by *John Horton Conway*. The universe of this game is a grid of square cells that
    could have one of two states: dead or alive. Every cell interacts with its adjacent
    neighbors, with the following transactions occurring on every step:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个实现*约翰·霍顿·康威*提出的*生命游戏*细胞自动机的程序。这个游戏的宇宙是一个正方形单元格的网格，可以有两种状态之一：死或活。每个单元格与其相邻的邻居进行交互，每一步都会发生以下交易：
- en: Any live cell with fewer than two live neighbors dies, as if caused by under-population
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何活细胞如果少于两个活邻居，则死亡，就像是由于人口不足。
- en: Any live cell with two or three live neighbors lives on to the next generation
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何有两个或三个活邻居的活细胞都会继续到下一代。
- en: Any live cell with more than three live neighbors dies, as if by overpopulation
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何活细胞如果有超过三个活邻居，则死亡，就像是过度密集。
- en: Any dead cell with exactly three live neighbors becomes a live cell, as if by
    reproduction
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何有三个活邻居的死细胞都会变成活细胞，就像是通过繁殖。
- en: The status of the game on each iteration should be displayed on the console,
    and for convenience, you should pick a reasonable size, such as 20 rows x 50 columns.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏每次迭代的状态应该显示在控制台上，为了方便起见，你应该选择一个合理的大小，比如20行x50列。
- en: Solutions
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 45\. Priority queue
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 45.优先级队列
- en: A priority queue is an abstract data type whose elements have a priority attached
    to them. Instead of working as a first-in-first-out container, a priority queue
    makes elements available in the order of their priority. This data structure is
    used in algorithms such as Dijkstra's shortest path, Prim's algorithm, heap sort,
    the A* search algorithm, in Huffman codes used for data compression, and others.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级队列是一个抽象数据类型，其元素附有优先级。优先级队列不像先进先出容器那样工作，而是按照它们的优先级顺序提供元素。这种数据结构在算法中被用于Dijkstra的最短路径、Prim算法、堆排序、A*搜索算法、用于数据压缩的Huffman编码等算法中。
- en: A very simple approach to implement a priority queue would be to use an `std::vector` as
    the underlying container of elements and always maintain it sorted. That means
    the maximum and minimum elements are always at the two ends. However, this approach
    does not provide the most efficient operations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 实现优先队列的一个非常简单的方法是使用`std::vector`作为元素的基础容器，并始终保持其排序。这意味着最大和最小的元素总是在两端。然而，这种方法并不提供最有效的操作。
- en: 'The most suitable data structure that can be used to implement a priority queue
    is a heap. This is a tree-based data structure that satisfies the following property:
    if *P* is a parent node of *C*, then the key (the value) of *P* is either greater
    than or equal to (in a max heap) or less than or equal to (in a min heap) the
    key of *C*.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用来实现优先队列的最合适的数据结构是堆。这是一种基于树的数据结构，满足以下属性：如果*P*是*C*的父节点，则*P*的键（值）要么大于或等于（在最大堆中）*C*的键，要么小于或等于（在最小堆中）*C*的键。
- en: 'The standard library provides several operations for working with heaps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了几个用于处理堆的操作：
- en: '`std::make_heap()`: This creates a max heap for the given range, using either `operator<` or
    a user-provided comparison function to order the elements'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::make_heap()`: 这为给定范围创建一个最大堆，使用`operator<`或用户提供的比较函数来对元素进行排序'
- en: '`std::push_heap()`: This inserts a new element at the end of the max heap'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::push_heap()`: 这在最大堆的末尾插入一个新元素'
- en: '`std::pop_heap()`: This removes the first element of the heap (by swapping
    the values in the first and last position and making the sub-range `[first, last-1)` a
    max heap)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::pop_heap()`: 这会移除堆的第一个元素（通过交换第一个和最后一个位置的值，并使子范围`[first, last-1)`成为最大堆）'
- en: 'A priority queue implementation, that uses `std::vector` to hold data and the
    standard functions for heaps, can look as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优先队列的实现，使用`std::vector`来保存数据和堆的标准函数，可以如下所示：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This class can be used as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类可以这样使用：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 46\. Circular buffer
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 46\. 循环缓冲
- en: A circular buffer is a fixed-size container that behaves as if its two ends
    were connected to form a virtual circular memory layout. Its main benefit is that
    you don't need a large amount of memory to retain data, as older entries are overwritten
    by newer ones. Circular buffers are used in I/O buffering, bounded logging (when
    you only want to retain the last messages), buffers for asynchronous processing,
    and others.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 循环缓冲区是一个固定大小的容器，其行为就好像它的两端连接在一起形成一个虚拟的循环内存布局。它的主要好处是你不需要大量的内存来保留数据，因为旧条目会被新条目覆盖。循环缓冲区用于I/O缓冲，有界日志（当您只想保留最后的消息时），异步处理的缓冲区等等。
- en: 'We can differentiate between two situations:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分两种情况：
- en: The number of elements added to the buffer has not reached its capacity (its
    user-defined fixed size). In this case, it behaves likes a regular container,
    such as a vector.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加到缓冲区的元素数量尚未达到其容量（用户定义的固定大小）。在这种情况下，它的行为类似于一个常规容器，比如vector。
- en: The number of elements added to the buffer has reached and exceeded its capacity.
    In this case, the buffer's memory is reused and older elements are being overwritten.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加到缓冲区的元素数量已经达到并超过了其容量。在这种情况下，缓冲区的内存被重用，并且旧元素被覆盖。
- en: 'We could represent such a structure using:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下方式表示这样的结构：
- en: A regular container with a pre-allocated number of elements
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有预分配数量元素的常规容器
- en: A head pointer to indicate the position of the last inserted element
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个头指针来指示最后插入元素的位置
- en: A size counter to indicate the number of elements in the container, which cannot
    exceed its capacity (since elements are being overwritten in this case)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个大小计数器来指示容器中元素的数量，不能超过其容量（因为在这种情况下元素被覆盖）
- en: 'The two main operations with a circular buffer are:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 循环缓冲区的两个主要操作是：
- en: Adding a new element to the buffer. We always insert at the next position of
    the head pointer (or index). This is the `push()` method shown below.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向缓冲区中添加一个新元素。我们总是在头指针（或索引）的下一个位置插入。下面是`push()`方法。
- en: Removing an existing element from the buffer. We always remove the oldest element.
    That element is at position `head - size` (this must account for the circular
    nature of the index). This is the `pop()` method shown below.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从缓冲区中移除一个现有元素。我们总是移除最旧的元素。该元素位于`head - size`的位置（这必须考虑索引的循环特性）。下面是`pop()`方法。
- en: 'The implementation of such a data structure is shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据结构的实现如下所示：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Because of the circular nature of the indexes mapped on a contiguous memory
    layout, the iterator type for this class cannot be a pointer type. The iterators
    must be able to point elements by applying modulo operations on the index. Here
    is a possible implementation for such an iterator:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于索引在连续内存布局上的循环特性，这个类的迭代器类型不能是指针类型。迭代器必须能够通过在索引上应用模运算来指向元素。以下是这样一个迭代器的可能实现：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With all these implemented, we could write code such as the following. Notice
    that in the comments, the first range shows the actual content of the internal
    vector, and the second range shows the logical content as exposed with iterator
    access:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些实现，我们可以编写如下的代码。请注意，在注释中，第一个范围显示了内部向量的实际内容，第二个范围显示了通过迭代器访问时的逻辑内容：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 47\. Double buffer
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 47\. 双缓冲
- en: The problem described here is a typical double buffering situation. Double buffering
    is the most common case of multiple buffering, which is a technique that allows
    a reader to see a complete version of the data and not a partially updated version
    produced by a writer. This is a common technique – especially in computer graphics
    – for avoiding flickering.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的问题是典型的双缓冲情况。双缓冲是多重缓冲的最常见情况，它允许读者看到数据的完整版本，而不是由写入者产生的部分更新版本。这是一种常见的技术，特别是在计算机图形学中，用于避免闪烁。
- en: 'In order to implement the requested functionality, the buffer class that we
    should write must have two internal buffers: one that contains temporary data
    being written, and another one that contains completed (or committed) data. Upon
    the completion of a write operation, the content of the temporary buffer is written
    in the primary buffer. For the internal buffers, the implementation below uses `std::vector`.
    When the write operation completes, instead of copying data from one buffer to
    the other, we just swap the content of the two, which is a much faster operation.
    Access to the completed data is provided with either the `read()` function, which
    copies the content of the read buffer into a designated output, or with direct
    element access (overloaded `operator[]`). Access to the read buffer is synchronized
    with an `std::mutex` to make it safe to read from one thread while another is
    writing to the buffer:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现所请求的功能，我们应该编写的缓冲类必须有两个内部缓冲区：一个包含正在写入的临时数据，另一个包含已完成（或提交）的数据。在写操作完成后，临时缓冲区的内容将被写入主缓冲区。对于内部缓冲区，下面的实现使用`std::vector`。当写操作完成时，我们不是从一个缓冲区复制数据到另一个缓冲区，而是交换两者的内容，这是一个更快的操作。对已完成数据的访问是通过`read()`函数提供的，该函数将读缓冲区的内容复制到指定的输出，或者通过直接元素访问（重载的`operator[]`）。对读缓冲区的访问与`std::mutex`同步，以确保在一个线程从缓冲区读取时，另一个线程正在向缓冲区写入是安全的：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is an example of how this double buffer class can be used for
    both writing and reading by two different entities:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个双缓冲类如何被两个不同的实体用于写入和读取的示例：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 48\. The most frequent element in a range
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 48\. 在一个范围内最频繁的元素
- en: 'In order to determine and return the most frequent element in a range you should
    do the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定并返回范围内最频繁的元素，你应该做以下操作：
- en: Count the appearances of each element in an `std::map`. The key is the element
    and the value is its number of appearances.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算每个元素在`std::map`中的出现次数。键是元素，值是它的出现次数。
- en: Determine the maximum element of the map using `std::max_element()`. The result
    is a map element, that is, a pair containing the element and its number of appearances.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::max_element()`确定地图的最大元素。结果是一个地图元素，即包含元素及其出现次数的一对。
- en: Copy all map elements that have the value (appearance count) equal to the maximum
    element's value and return that as the final result.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制所有地图元素，其值（出现次数）等于最大元素的值，并将其作为最终结果返回。
- en: 'An implementation of the steps described previously is shown in the following
    listing:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 先前描述的步骤的实现如下所示：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `find_most_frequent()` function can be used as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_most_frequent()`函数可以如下使用：'
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 49\. Text histogram
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 49\. 文本直方图
- en: 'A histogram is a representation of the distribution of numerical data. Widely
    known histograms are the color and image histograms that are used in photography
    and image processing. A text histogram, as described here, is a representation
    of the frequency of letters in a given text. This problem is partially similar
    to the previous one, except that the range elements are characters now and we
    must determine the frequency of them all. To solve this problem you should:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图是数值数据分布的表示。广为人知的直方图是摄影和图像处理中使用的颜色和图像直方图。如此描述的文本直方图是给定文本中字母频率的表示。这个问题在某种程度上与之前的问题类似，只是现在的范围元素是字符，我们必须确定它们的频率。要解决这个问题，你应该：
- en: Count the appearances of each letter using a map. The key is the letter and
    the value is its appearance count.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用地图计算每个字母的出现次数。键是字母，值是它的出现次数。
- en: When counting, ignore all characters that are not letters. Uppercase and lowercase
    characters must be treated as identical, as they represent the same letter.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数时，忽略所有不是字母的字符。大写和小写字符必须被视为相同，因为它们代表相同的字母。
- en: Use `std::accumulate()` to count the total number of appearances of all the
    letters in the given text.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::accumulate()`来计算给定文本中所有字母的总出现次数。
- en: Use `std::for_each()` or a range-based `for` loop to go through all the elements
    of the map and transform the appearance count into a frequency.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::for_each()`或基于范围的`for`循环来遍历地图的所有元素，并将外观计数转换为频率。
- en: 'The following is a possible implementation of the problem:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是问题的一个可能实现：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following program prints the frequency of the letters from a text on the
    console:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序在控制台上打印文本中字母的频率：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 50\. Filtering a list of phone numbers
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 50\. 过滤电话号码列表
- en: 'The solution to this problem is relatively simple: you have to iterate through
    all the phone numbers and copy to a separate container (such as an `std::vector`)
    the phone numbers that start with the country code. If the specified country code
    is, for instance, 44, then you must check for both 44 and +44\. Filtering the
    input range in this manner is possible using the `std::copy_if()` function. A
    solution to this problem is shown here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方案相对简单：你必须遍历所有的电话号码，并将以国家代码开头的电话号码复制到一个单独的容器（如`std::vector`）中。如果指定的国家代码是44，那么你必须同时检查44和+44。使用`std::copy_if()`函数可以以这种方式过滤输入范围。这个问题的解决方案如下所示：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is how this function can be used:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的使用方法如下：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 51\. Transforming a list of phone numbers
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 51\. 转换电话号码列表
- en: 'This problem is somewhat similar in some aspects to the previous one. However,
    instead of selecting phone numbers that start with a specified country code, we
    must transform each number so that they all start with that country code preceded
    by a `+`. There are several cases that must be considered:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在某些方面与之前的问题有些相似。但是，我们不是选择以指定国家代码开头的电话号码，而是必须转换每个号码，使它们都以该国家代码开头，前面加上`+`。有几种情况必须考虑：
- en: The phone number starts with a 0\. That indicates a number without a country
    code. To modify the number to include the country code we must replace the 0 with
    the actual country code, preceded by `+`.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话号码以0开头。这表示没有国家代码的号码。要修改号码以包含国家代码，我们必须用实际的国家代码替换0，前面加上`+`。
- en: The phone number starts with the country code. In this case, we just prepend
    `+` sign to the beginning.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话号码以国家代码开头。在这种情况下，我们只需在开头添加`+`号。
- en: The phone number starts with `+` followed by the country code. In this case,
    the number is already in the expected format.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话号码以`+`开头，后面跟着国家代码。在这种情况下，号码已经是预期格式。
- en: None of these cases applies, therefore the result is obtained by concatenating
    the country code preceded by `+` and the phone number.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有适用于这些情况的情况，因此结果是通过将以`+`为前缀的国家代码和电话号码连接而获得的。
- en: For simplicity, we will ignore the possibility that the number is actually prefixed
    with another country code. You can take it as a further exercise to modify the
    implementation so that it can handle phone numbers with a different country prefix.
    These numbers should be removed from the list.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我们将忽略号码实际上可能以另一个国家代码为前缀的可能性。您可以将其视为进一步练习，以修改实现，使其能够处理带有不同国家前缀的电话号码。这些号码应从列表中删除。
- en: In all of the preceding cases, it is possible that the number could contain
    spaces. According to the requirements, these must be removed. The `std::remove_if()`
    and `isspace()` functions are used for this purpose.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前述情况中，号码可能包含空格。根据要求，这些必须被移除。`std::remove_if()`和`isspace()`函数用于此目的。
- en: 'The following is an implementation of the described solution:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是所描述解决方案的实现：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following program normalizes a given list of phone numbers according to
    the requirement and prints them on the console:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序根据要求对给定的电话号码列表进行规范化，并将它们打印在控制台上：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 52\. Generating all the permutations of a string
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 52. 生成字符串的所有排列
- en: 'You can solve this problem by taking advantage of some general-purpose algorithms
    from the standard library. The simplest of the two required versions is the non-recursive
    one, at least when you use `std::next_permutation()`. This function transforms
    the input range (that is required to be sorted) into the next permutation from
    the set of all possible permutations, ordered lexicographically with `operator<`
    or the specified comparison function object. If such a permutation exists then
    it returns `true`, otherwise, it transforms the range into the first permutation
    and returns `false`. Therefore, a non-recursive implementation based on `std::next_permuation()`
    looks like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以利用标准库中一些通用算法来解决这个问题。所需版本中最简单的是非递归版本，至少在使用`std::next_permutation()`时是这样。此函数将输入范围（需要排序）转换为下一个排列，从所有可能的排列中按字典顺序排序，使用`operator<`或指定的比较函数对象。如果存在这样的排列，则返回`true`，否则，它将范围转换为第一个排列并返回`false`。因此，基于`std::next_permuation()`的非递归实现如下：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The recursive alternative is a little bit more complex. One way to implement
    it is to have an input and output string; initially, the input string is the string
    for which we want to generate permutations and the output string is empty. We
    take one character at a time from the input string and put it in the output string.
    When the input string becomes empty, the output string represents the next permutation.
    The recursive algorithm for doing this is the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 递归的替代方法稍微复杂一些。实现它的一种方法是有一个输入和输出字符串；最初，输入字符串是我们想要生成排列的字符串，输出字符串为空。我们从输入字符串中一次取一个字符并将其放入输出字符串。当输入字符串变为空时，输出字符串表示下一个排列。执行此操作的递归算法如下：
- en: If the input string is empty, then print the output string and return
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入字符串为空，则打印输出字符串并返回
- en: 'Otherwise iterate through all the characters in the input string, and for each
    element:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，迭代输入字符串中的所有字符，并对每个元素执行以下操作：
- en: Call the method recursively by removing the first character from the input string
    and concatenating it at the end of the output string
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从输入字符串中删除第一个字符并将其连接到输出字符串的末尾来递归调用该方法
- en: Rotate the input string so that the first character becomes the last, the second
    becomes the first, and so on
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转输入字符串，使第一个字符变为最后一个，第二个变为第一个，依此类推
- en: 'This algorithm is visually explained in the following diagram:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法在以下图表中有可视化解释：
- en: '![](img/79469191-710c-4b50-a6b6-ce67c8e5cdcf.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79469191-710c-4b50-a6b6-ce67c8e5cdcf.png)'
- en: 'For rotating the input string, we could use the standard library function `std::rotate()`,
    which performs a left rotation on a range of elements. An implementation of the
    described recursive algorithm looks like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转输入字符串，我们可以使用标准库函数`std::rotate()`，它对一系列元素执行左旋转。所描述的递归算法的实现如下：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is how both of these implementations can be used:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这两种实现的用法：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 53\. Average rating of movies
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 53. 电影的平均评分
- en: The problem requires the computing of a movie rating using a truncated mean.
    This is a statistical measure of a central tendency where the mean is calculated
    after discarding parts of a probability distribution or sample at the high and
    low ends. Typically, this is done by removing an equal amount of points at the
    two ends. For this problem, you are required to remove 5% of both the highest
    and lowest user ratings.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题要求使用截断均值计算电影评分。这是一种统计测量中心趋势的方法，其中在高端和低端丢弃概率分布或样本的部分后计算均值。通常，这是通过在两端删除相等数量的点来完成的。对于这个问题，您需要删除最高和最低用户评分的5%。
- en: 'A function that calculates a truncated mean for a given range should do the
    following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 应该编写一个计算给定范围的截断均值的函数，它应该执行以下操作：
- en: Sort the range so that elements are ordered (either ascending or descending)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对范围进行排序，使元素有序（升序或降序）
- en: Remove the required percentage of elements at both ends
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两端删除所需百分比的元素
- en: Count the sum of all remaining elements
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算所有剩余元素的总和
- en: Compute the average by dividing the sum to the remaining count of elements
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将总和除以剩余元素的数量来计算平均值
- en: 'The `truncated_mean()` function shown here implements the described algorithm:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的`truncated_mean()`函数实现了所描述的算法：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A program that uses this function in order to calculate and print movie average
    ratings may look like the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数来计算并打印电影平均评分的程序可能如下所示：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 54\. Pairwise algorithm
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 54. 两两算法
- en: 'The pairwise function proposed for this problem must pair adjacent elements
    of an input range and produce `std::pair` elements that are added to an output
    range. The following code listing provides two implementations:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个问题提出的成对函数必须对输入范围的相邻元素进行配对，并产生添加到输出范围的`std::pair`元素。以下代码清单提供了两种实现：
- en: 'A general function template that takes iterators as arguments: a begin and
    end iterator define the input range, and an output iterator defines the position
    in the output range where the results are to be inserted'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以迭代器作为参数的通用函数模板：开始和结束迭代器定义输入范围，输出迭代器定义结果要插入的输出范围中的位置
- en: 'An overload that takes an `std::vector<T>` as the input argument and returns
    an `std::vector<std::pair<T, T>>` as the result; this one simply calls the first
    overload:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个以`std::vector<T>`作为输入参数，并返回`std::vector<std::pair<T, T>>`作为结果的重载；这个只是调用第一个重载：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following program pairs the elements of a vector of integers and prints
    the pairs on the console:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序对整数向量的元素进行配对，并在控制台上打印配对：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 55\. Zip algorithm
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 55. 压缩算法
- en: 'This problem is relatively similar to the previous one, although there are
    two input ranges instead of just one. The result is again a range of `std::pair`.
    However, the two input ranges may hold elements of different types. Again, the
    implementation shown here contains two overloads:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题与前一个问题相对类似，尽管有两个输入范围而不是一个。结果再次是一个`std::pair`的范围。然而，两个输入范围可能包含不同类型的元素。同样，这里显示的实现包含两个重载：
- en: A general-purpose function with iterators as arguments. A begin and end iterator
    for each input range define its bounds, and an output iterator defines the position
    in the output range where the result must be written.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个以迭代器作为参数的通用函数。每个输入范围的开始和结束迭代器定义其边界，输出迭代器定义结果必须写入的输出范围中的位置。
- en: 'A function that takes two `std::vector` arguments, one that holds elements
    of type `T` and one that holds elements of type `U` and returns an `std::vector<std::pair<T,
    U>>`. This overload simply calls the previous one:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接受两个`std::vector`参数的函数，一个保存类型为`T`的元素，另一个保存类型为`U`的元素，并返回一个`std::vector<std::pair<T,
    U>>`。这个重载只是调用前一个：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the following listing, you can see two vectors of integers zipped together
    and the result printed on the console:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的清单中，您可以看到两个整数向量被压缩在一起，并且结果打印在控制台上：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 56\. Select algorithm
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 56. 选择算法
- en: The `select()` function that you have to implement takes an `std::vector<T>`
    as an input argument and a function of type `F` and returns a `std::vector<R>`
    as the result, where `R` is the result of applying `F` to `T`. We could use `std::result_of()`
    to deduce the return type of an invoke expression at compile time. Internally,
    the `select()` function should use `std::transform()` to iterate over the elements
    of the input vector, apply function `f` to each element, and insert the result
    in an output vector.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须实现的`select()`函数以`std::vector<T>`作为输入参数，并以`F`类型的函数返回`std::vector<R>`作为结果，其中`R`是将`F`应用于`T`的结果。我们可以使用`std::result_of()`在编译时推断调用表达式的返回类型。在内部，`select()`函数应该使用`std::transform()`来迭代输入向量的元素，将函数`f`应用于每个元素，并将结果插入输出向量。
- en: 'The following listing shows the implementation for this function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下清单显示了此函数的实现：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This function can be used as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以这样使用：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 57\. Sort algorithm
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 57. 排序算法
- en: '**Quicksort** is a comparison sorting algorithm for elements of an array for
    which a total order is defined. When implemented well, it is significantly faster
    than *merge sort* or *heap sort*.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序是一个比较排序算法，用于定义了总体顺序的数组元素。当实现得当时，它比归并排序或堆排序要快得多。
- en: 'Although in worst-case scenarios the algorithm makes ![](img/d0f773fd-4c52-4f1c-ac3a-43aad74ac919.png)
    comparisons (when the range is already sorted), on average the complexity is only
    ![](img/052b20b9-c6ee-407f-9169-9f60e59fcd12.png). Quicksort is a divide and conquer
    algorithm; it partitions (divides) a large range into smaller ones and sorts them
    recursively. There are several partitioning schemes. In the implementation shown
    here, we use the original one developed by *Tony Hoare*. The algorithm for this
    scheme is described in pseudocode as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在最坏的情况下，算法进行了![](img/d0f773fd-4c52-4f1c-ac3a-43aad74ac919.png)次比较（当范围已经排序），但平均复杂度只有![](img/052b20b9-c6ee-407f-9169-9f60e59fcd12.png)。快速排序是一种分而治之的算法；它将一个大范围分成较小的范围，并递归地对它们进行排序。有几种分区方案。在这里显示的实现中，我们使用了*Tony
    Hoare*开发的原始方案。该方案的算法如下伪代码描述：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A general-purpose implementation of the algorithm should use iterators and
    not arrays and indexes. The requirement for the following implementation is that
    the iterators are random-access (so they could be moved to any element in constant
    time):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的通用实现应该使用迭代器而不是数组和索引。以下实现的要求是迭代器是随机访问的（因此它们可以在常数时间内移动到任何元素）：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `quicksort()` function, shown as follows, can be used to sort various types
    of containers:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示的`quicksort()`函数可用于对各种类型的容器进行排序：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The requirement was that the sorting algorithm must allow the specifying of
    a user-defined comparison function. The only change, in this case, is the partitioning
    function, where instead of using `operator <` and `>` to compare the current element
    with the pivot, we use the user-defined comparison function:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要求是排序算法必须允许指定用户定义的比较函数。在这种情况下，唯一的变化是分区函数，其中我们使用用户定义的比较函数来比较当前元素与枢轴，而不是使用`operator
    <`和`>`：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With this overload we could sort a range in descending order, as shown in the
    following example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种重载，我们可以按降序对范围进行排序，如下例所示：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It is possible to implement an iterative version of the quicksort algorithm
    also. The performance of the iterative version is the same as for the recursive
    version ![](img/3ca8d288-8880-429d-aa80-7c340746023e.png) for most cases, but
    degrading to ![](img/93a576b4-a09d-46aa-83d2-29b43033fde1.png) in the worst case
    when the range is already sorted). Converting from the recursive version of the
    algorithm to an iterative one is relatively simple; it is done by using a stack
    to emulate the recursive calls and to store the bounds of the partitions. The
    following is an iterative implementation of the version that uses `operator<`
    to compare elements:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以实现快速排序算法的迭代版本。迭代版本的性能在大多数情况下与递归版本相同，但在最坏的情况下会降级到已经排序的范围中。从算法的递归版本转换为迭代版本相对简单；通过使用堆栈来模拟递归调用并存储分区的边界来完成。以下是使用`operator<`比较元素的迭代实现版本：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This iterative implementation can be used just like its recursive counterpart:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个迭代实现可以像递归版本一样使用：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 58\. The shortest path between nodes
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 58\. 节点之间的最短路径
- en: To solve the proposed problem you must use the Dijkstra algorithm for finding
    the shortest path in a graph. Although the original algorithm finds the shortest
    path between two given nodes, the requirement here is to find the shortest path
    between one specified node and all the others in the graph, which is another version
    of the algorithm.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决提出的问题，必须使用Dijkstra算法来找到图中的最短路径。尽管原始算法找到两个给定节点之间的最短路径，但这里的要求是找到指定节点与图中所有其他节点之间的最短路径，这是算法的另一个版本。
- en: 'An efficient way to implement the algorithm is using a priority queue. The
    pseudocode for the algorithm (see [https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm))
    is the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 实现该算法的有效方法是使用优先队列。算法的伪代码如下：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To represent the graph we could use the following data structure, which can
    be used for both directional or unidirectional graphs. The class provides support
    for adding new vertices and edges, and can return the list of vertices and the
    neighbors of a specified vertex (that is, both the nodes and the distance to them):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示图，我们可以使用以下数据结构，它可以用于有向或无向图。该类支持添加新顶点和边，并可以返回顶点列表和指定顶点的邻居（即节点和到它们的距离）：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The implementation of the shortest path algorithm as described in the preceding
    pseudocode could look like the following. An `std::set` (that is, a self-balancing
    binary search tree) is used instead of the priority queue. `std::set` has the
    same ![](img/d099c811-290c-4643-951a-91cf936fe579.png) complexity for adding and
    removing the top element as a binary heap (used for a priority queue). On the
    other hand, `std::set` also allows finding and removing any other element in ![](img/61c9a4de-7e8e-4c76-bbf0-8f86a6828406.png), which
    is helpful in order to implement the decrease-key step in logarithmic time by
    removing and inserting again:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '如前述伪代码中描述的最短路径算法的实现可能如下所示。使用`std::set`（即自平衡二叉搜索树）代替优先队列。`std::set`对于添加和删除顶部元素具有相同的复杂度，就像二叉堆（用于优先队列）一样。另一方面，`std::set`还允许在`O(log
    n)`中找到和删除任何其他元素，这有助于通过删除和再次插入来以对数时间实现减小键步骤： '
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following helper functions print the results in the specified format:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下辅助函数以指定的格式打印结果：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following program solves the given task:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序解决了给定的任务：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 59\. The Weasel program
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 59\. Weasel程序
- en: 'The Weasel program is a thought experiment proposed by Richard Dawkins, intended
    to demonstrate how the accumulated small improvements (mutations that bring a
    benefit to the individual so that it is chosen by natural selection) produce fast
    results as opposed to the mainstream misinterpretation that evolution happens
    in big leaps. The algorithm for the Weasel simulation, as described on Wikipedia
    (see [https://en.wikipedia.org/wiki/Weasel_program](https://en.wikipedia.org/wiki/Weasel_program)),
    is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Weasel程序是理查德·道金斯提出的一个思想实验，旨在演示积累的小改进（对个体有益的突变，使其被自然选择）与主流误解相反，即进化是以大的飞跃发生的。Weasel模拟的算法如维基百科所述，如下所示：
- en: Start with a random string of 28 characters.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个28个字符的随机字符串开始。
- en: Make 100 copies of this string, with a 5% chance per character of that character
    being replaced with a random character.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作这个字符串的100个副本，每个字符有5%的机会被替换为随机字符。
- en: Compare each new string with the target METHINKS IT IS LIKE A WEASEL, and give
    each a score (the number of letters in the string that are correct and in the
    correct position).
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个新字符串与目标METHINKS IT IS LIKE A WEASEL进行比较，并为每个字符串打分（字符串中正确位置的字母数）。
- en: If any of the new strings has a perfect score (28), then stop.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任何新字符串得分完美（28），则停止。
- en: Otherwise, take the highest-scoring string and go to step 2.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，取得分最高的字符串并转到步骤2。
- en: 'A possible implementation is as follows. The `make_random()` function creates
    a random starting sequence of the same length as the target; the `fitness()` function
    computes the score of each mutated string (that is, resemblance with the target);
    the `mutate()` function produces a new string from a parent with a given chance
    for each character to mutate:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的实现如下。`make_random()`函数创建与目标相同长度的随机起始序列；`fitness()`函数计算每个变异字符串的得分（即与目标的相似度）；`mutate()`函数从父字符串产生一个新字符串，并为每个字符变异提供给定的机会：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is how the class can be used:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是类的使用方式：
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 60\. The Game of Life
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 60\. 生命游戏
- en: 'The class `universe` presented below implements the game as described. There
    are several functions of interest:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 下面介绍的`universe`类实现了如下所述的游戏。有几个感兴趣的函数：
- en: '`initialize()` generates a starting layout; although the code accompanying
    the book contains more options, only two are listed here: `random`, which generates
    a random layout, and `ten_cell_row`, which represents a line of 10 cells in the
    middle of the grid.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialize()` 生成一个起始布局；尽管书中附带的代码包含更多选项，这里只列出了两个：`random`，生成一个随机布局，和 `ten_cell_row`，表示网格中间的一行有10个细胞。'
- en: '`reset()` sets all the cells as `dead`.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset()` 将所有细胞设置为 `dead`。'
- en: '`count_neighbors()` returns the number of alive neighbors. It uses a helper
    variadic function template `count_alive()`. Although this could be implemented
    with fold expressions, this is not yet supported in Visual C++ and therefore I
    have opted not to use it here.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count_neighbors()` 返回活着的邻居数量。它使用一个辅助可变函数模板 `count_alive()`。尽管这可以用折叠表达式来实现，但在Visual
    C++中还不支持，因此我选择不在这里使用它。'
- en: '`next_generation()` produces a new state of the game based on the transition
    rules.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next_generation()` 根据转换规则产生游戏的新状态。'
- en: '`display()` shows the game status on the console; this uses a system call to
    erase the console, although you could use other means to do so, such as specific
    operating system APIs.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display()` 在控制台上显示游戏状态；这使用了一个系统调用来擦除控制台，尽管你可以使用其他方法来做到，比如特定的操作系统API。'
- en: '`run()` initializes the starting layout and then produces a new generation
    at a user-specified interval, for a user-specified number of iterations, or indefinitely
    (if the number of iterations was set to 0).'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run()` 初始化起始布局，然后以用户指定的间隔产生新的一代，进行用户指定次数的迭代，或者无限期地进行（如果迭代次数设置为0）。'
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is how the game can be run for 100 iterations starting from a random state:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何从一个随机状态开始运行100次迭代的游戏：
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here is an example of the program output (the screenshot represents a single
    iteration in the Game of Life''s universe):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序输出的一个例子（屏幕截图表示生命游戏宇宙中的一个迭代）：
- en: '![](img/64f1b7b8-0beb-4758-b368-be239d3cb368.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64f1b7b8-0beb-4758-b368-be239d3cb368.png)'
