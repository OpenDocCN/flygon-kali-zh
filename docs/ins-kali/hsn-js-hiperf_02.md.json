["```js\nconst newObj = Object.assign({}, obj);\nconst newArr = [...arr];\n```", "```js\nconst obj2 = {item : 'thing', another : 'what'};\nconst arr2 = ['yes', 'no', 'nope'];\n\nconst newObj2 = Object.assign({}, obj2);\nconst newArr2 = [...arr2]\n```", "```js\nconst addTodo = function(test) {\n    return { type : ACTIONS.ADD_TODO, text };\n}\nconst toggleTodo = function(index) {\n    return { type : ACTIONS.TOGGLE_TODO, index };\n}\nconst setVisibilityFilter = function(filter) {\n    return { type : ACTIONS.SET_VISIBILITY_FILTER, filter };\n}\n```", "```js\nconst visibilityFilter = function(state = 'SHOW_ALL', action) {\n    switch(action.type) {\n        case 'SET_VISIBILITY_FILTER': {\n            return action.filter;\n        }\n        default: {\n            return state;\n        }\n    }\n}\n\nconst todo = function(state = [], action) {\n    switch(action.type) {\n        case 'ADD_TODO': {\n            return [\n                ...state,\n                {\n                    text : action.text,\n                    completed : false\n                }\n        }\n        case 'TOGGLE_TODO': {\n            return state.map((todo, index) => {\n                if( index === action.index ) {\n                    return Object.assign({}, todo, {\n                        completed : !todo.completed\n                    });\n                }\n                return todo;\n            }\n        }\n        default: {\n            return state;\n        }\n    }\n}\n```", "```js\nstore.subscribe(() => \n    const state = store.getState();\n    // first type of actions ADD_TODO\n    if( prevState.todo.length !== state.todo.length ) {\n     container.appendChild(createTodo(state.todo[state.todo.length\n     - 1].text));\n    // second type of action SET_VISIBILITY_FILTER\n    } else if( prevState.visibilityFilter !== \n      state.visibilityFilter ) {\n        setVisibility(container.children, state);\n    // final type of action TOGGLE_TODO\n    } else {\n        const todos = container.children;\n        for(let i = 0; i < todos.length; i++) {\n            if( state.todo[i].completed ) {\n                todos[i].classList.add('completed');\n            } else {\n                todos[i].classList.remove('completed');\n            }\n        }\n    }\n    prevState = state;\n});\n```", "```js\n<input id=\"year\" type=\"number\" placeholder=\"Year\" />\n<input id=\"month\" type=\"number\" placeholder=\"Month\" />\n<input id=\"day\" type=\"number\" placeholder=\"Day\" />\n```", "```js\n<button id=\"SHOW_OVERDUE\">Overdue</button>\n```", "```js\nconst year = document.getElementById('year');\nconst month = document.getElementById('month');\nconst day = document.getElementById('day');\nstore.dispatch(addTodo(input.value), {year : year.value, month : month.value, day : day.value}));\nyear.value = \"\";\nmonth.value = \"\";\nday.value = \"\";\n```", "```js\ncase visibilityFilters.SHOW_OVERDUE: {\n    const currTodo = state.todo[i];\n    const tempTime = currTodo.date;\n    const tempDate = new Date(`${tempTime.year}/${tempTime.month}/${tempTime.day}`);\n    if( tempDate < currDay && !currTodo.completed ) {\n        todos[i].classList.remove('hide');\n    } else {\n        todos[i].classList.add('hide');\n    }\n}\n```", "```js\ndocument.getElementById('UPDATE_LAST_YEAR').onclick = function(e) {\n    store.dispatch({ type : ACTIONS.UPDATE_LAST_YEAR, year :  \n     document.getElementById('updateYear').value });\n}\n```", "```js\ncase 'UPDATE_LAST_YEAR': {\n    const prevState = state;\n    const tempObj = Object.assign({}, state[state.length - \n     1].date);\n    tempObj.year = action.year;\n    state[state.length - 1].date = tempObj;\n    return state;\n}\n```", "```js\nif( prevState === state ) {\n    return;\n}\n```", "```js\ncase 'UPDATE_LAST_YEAR': {\n    const prevState = state;\n    const tempObj = Object.assign({}, state[state.length - 1].date);\n    tempObj.year = action.year;\n    state[state.length - 1].date = tempObj;\n    return [...state];\n}\n```", "```js\nconst fArr = new Array(fillArr.length - 1);\nconst rowSize = fillArr[0].length;\nconst keys = new Array(rowSize);\nfor(let i = 0; i < rowSize; i++) {\n    keys[i] = fillArr[0][i];\n}\nfor(let i = 1; i < fillArr.length; i++) {\n    const obj = {};\n    for(let j = 0; j < rowSize; j++) {\n        obj[keys[j]] = fillArr[i][j];\n    }\n    fArr[i - 1] = obj;\n}\n```", "```js\nconst l = Immutable.List(fillArr);\nconst _k = Immutable.List(fillArr[0]);\nconst tFinal = l.map((val, index) => {\n    if(!index ) return;\n    return Immutable.Map(_k.zip(val));\n});\nconst final = tfinal.shift();\n```", "```js\nconst tempArr = new Array(100000);\nfor(let i = 0; i < tempArr.length; i++) {\n    if( i === 50000 ) { tempArr[i] = 'wrong'; }\n    else { tempArr[i] = i; }\n}\n```", "```js\nconst mutArr = Array.apply([], tempArr);\nconst errs = [];\nfor(let i = 0; i < mutArr.length; i++) {\n    if( mutArr[i] !== i ) {\n        errs.push(`Error at loc ${i}. Value : ${mutArr[i]}`);\n        mutArr[i] = i;\n    }\n}\n```", "```js\nconst mut2Arr = Array.apply([], tempArr);\nconst errs2 = [];\nconst fArr = mut2Arr.map((val, index) => {\n    if( val !== index ) {\n        errs2.push(`Error at loc: ${index}. Value : ${val}`);\n        return index;\n    }\n    return val;\n});\n```", "```js\nconst immArr = Immutable.List(tempArr);\nconst ierrs = [];\nconst corrArr = immArr.map((item, index) => {\n    if( item !== index ) {\n        ierrs.push(`Error at loc ${index}. Value : ${item}`);\n        return index;\n    }\n    return item;\n});\n```", "```js\nfor(let i = 0; i < tempArr.length; i++) {\n    if( Math.random() < 0.4 ) {\n        tempArr[i] = 'wrong';\n    } else {\n        tempArr[i] = i;\n    }\n}\n```", "```js\nlet x = {};\nlet y = x;\nconsole.log( x === y );\ny = Object.assign({}, x);\nconsole.log( x === y );\n```", "```js\nArray.prototype._map = function(fun) {\n    if( typeof fun !== 'function' ) {\n        return null;\n    }\n    const arr = new Array(this.length);\n    for(let i = 0; i < this.length; i++) {\n        arr[i] = fun(this[i]);\n    }\n    return arr;\n}\n```", "```js\nArray.prototype._reduce = function(fun, initial=null) {\n    if( typeof fun !== 'function' ) {\n        return null;\n    }\n    let val = initial ? initial : this[0];\n    const startIndex = initial ? 0 : 1;\n    for(let i = startIndex; i < this.length; i++) {\n        val = fun(val, this[i], i, this);\n    }\n    return val;\n}\n```", "```js\nvar glob = 'a single point system';\nconst implement = function(x) {\n    glob = glob.concat(' more');\n    return x += 2;\n}\n```", "```js\nconst updateState = function(update) {\n    const x = Object.keys(update);\n    for(let i = 0; i < x.length; i++) {\n        state[x[i]] = update[x[i]];\n    }\n}\n```", "```js\nconst state = {};\n(function(scope) {\n    const _state = {};\n    scope.update = function(obj) {\n        const x = Object.keys(obj);\n        for(let i = 0; i < x.length; i++) {\n            _state[x[i]] = obj[x[i]];\n        }\n    }\n    scope.set = function(key, val) {\n        _state[key] = val;\n    }\n    scope.get = function(key) {\n        return _state[key];\n    }\n    scope.getAll = function() {\n        return Object.assign({}, _state);\n    }\n})(state);\nObject.freeze(state);\n```", "```js\nconst getNestedProperty = function(key) {\n    const tempArr = key.split('.');\n    let temp = _state;\n    while( tempArr.length > 1 ) {\n        temp = temp[tempArr.shift()];\n        if( temp === undefined ) {\n            throw new Error('Unable to find key!');\n        }\n    }\n    return {obj : temp, finalKey : tempArr[0] };\n}\nscope.set = function(key, val) {\n    const {obj, finalKey} = getNestedProperty(key);\n    obj[finalKey] = val;\n}\nscope.get = function(key) {\n    const {obj, finalKey} = getNestedProperty(key);\n    return obj[finalKey];\n}\n```", "```js\nconst _state = {},\ncheckPrimitives = function(item) {\n    return item === null || typeof item === 'boolean' || typeof item === \n     'string' || typeof item === 'number' || typeof item === 'undefined';\n},\ncloneFunction = function(fun, scope=null) {\n    return fun.bind(scope);\n},\ncloneObject = function(obj) {\n    const newObj = {};\n    const keys = Object.keys(obj);\n    for(let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const item = obj[key];\n        newObj[key] = runUpdate(item);\n    }\n    return newObj;\n},\ncloneArray = function(arr) {\n    const newArr = new Array(arr.length);\n    for(let i = 0; i < arr.length; i++) {\n        newArr[i] = runUpdate(arr[i]);\n    }\n    return newArr;\n},\nrunUpdate = function(item) {\n    return checkPrimitives(item) ?\n        item : \n        typeof item === 'function' ?\n            cloneFunction(item) :\n        Array.isArray(item) ?\n            cloneArray(item) :\n            cloneObject(item);\n};\n\nscope.update = function(obj) {\n    const x = Object.keys(obj);\n    for(let i = 0; i < x.length; i++) {\n        _state[x[i]] = runUpdate(obj[x[i]]);\n    }\n}\n```", "```js\nconst getData = function() {\n    return document.getElementById('container').value;\n};\nconst encodeData = function(data) {\n    let te = new TextEncoder();\n    return te.encode(data);\n};\nconst hashData = function(algorithm) {\n    let str = getData();\n    let finData = encodeData(str);\n    str = null;\n    return crypto.subtle.digest(algorithm, finData);\n};\n{\n    let but = document.getElementById('submit');\n    but.onclick = function(ev) {\n        let algos = ['SHA-1', 'SHA-256', 'SHA-384', 'SHA-512'];\n        let out = document.getElementById('output');\n        for(let i = 0; i < algos.length; i++) {\n            const newEl = document.createElement('li');\n            hashData(algos[i]).then((res) => {\n                let te = new TextDecoder();\n                newEl.textContent = te.decode(res);\n                out.append(newEl);\n            });\n        }\n        out = null;\n    }\n    but = null;\n}\n```", "```js\nfor(let i = 0; i < algos.length; i++) {\n    let temp = out;\n    const newEl = document.createElement('li');\n    hashData(algos[i]).then((res) => {\n        let te = new TextDecoder();\n        newEl.textContent = te.decode(res);\n        temp.append(newEl);\n        temp = null\n    });\n}\n```", "```js\nconst showHashData = function(parent, algorithm) {\n    const newEl = document.createElement('li');\n    hashData(algorithm).then((res) => {\n        let te = new TextDecoder();\n        newEl.textContent = te.decode(res);\n        parent.append(newEl);\n    });\n}\n```", "```js\nconst addReadableProperty = function(item) {\n    Object.defineProperty(item, 'readonly', {\n        value : true,\n        writable :false\n    });\n    return item;\n}\n```", "```js\nif(!parent.readonly ) {\n    parent.append(newEl);\n}\n```", "```js\nconst ReaderWriter = function() {\n    let data = {};\n    let readers = 0;\n    let readyForSet = new CustomEvent('readydata');\n    this.getData = function() {\n        readers += 1;\n        return data;\n    }\n    this.releaseData = function() {\n        if( readers ) {\n            readers -= 1;\n            if(!readers ) {\n                document.dispatchEvent(readyForSet);\n            }\n        }\n        return readers;\n    }\n    this.setData = function(d) {\n        return new Promise((resolve, reject) => {\n            if(!readers ) {\n                data = d;\n                resolve(true);\n            } else {\n                document.addEventListener('readydata', function(e) {\n                    data = d;\n                    resolve(true);\n                }, { once : true });\n            }\n        });\n    }\n}\n```", "```js\nconst simpleGenerator = function*() {\n    let it = 0;\n    for(;;) {\n        yield it;\n        it++;\n    }\n}\n\nconst sg = simpleGenerator();\nfor(let i = 0; i < 10; i++) {\n    console.log(sg.next().value);\n}\nsg.return();\nconsole.log(sg.next().value);\n```", "```js\nconst timing = function*(time) {\n    yeild Date.now() - time;\n}\nconst time = timing(Date.now());\nlet sum = 0;\nfor(let i = 0; i < 1000000; i++) {\n    sum = sum + i;\n}\nconsole.log(time.next().value);\n```", "```js\nconst nums = function*(fn=null) {\n    let i = 0;\n    for(;;) {\n        yield i;\n        if( fn ) {\n            i += fn(i);\n        } else {\n            i += 1;\n        }\n    }\n}\nconst data = {};\nconst gen = nums();\nfor(let i of gen) {\n    console.log(i);\n    if( i > 100 ) {\n        break;\n    }\n    data.push(i);\n}\n\nconst fakestream = function*(data) {\n    const chunkSize = 10;\n    const dataLength = data.length;\n    let i = 0;\n    while( i < dataLength) {\n        const outData = [];\n        for(let j = 0; j < chunkSize; j++) {\n            outData.push(data[i]);\n            i+=1;\n        }\n        yield outData;\n    }\n}\n\nfor(let i of fakestream(data)) {\n    console.log(i);\n}\n```", "```js\nconst _d = new Array(100000);\nfor(let i = 0; i < _d.length; i++) {\n    _d[i] = i;\n}\nconst recurseSummer = function(data, sum=0) {\n    if(!data.length ) {\n        return sum;\n    }\n    return recurseSummer(data.slice(1), sum + data[0]);\n}\nconsole.log(recurseSummer(_d));\n```", "```js\nconst trampoline = (fun) => {\n    return (...arguments) => {\n        let result = fun(...arguments);\n        while( typeof result === 'function' ) {\n            result = result();\n        }\n        return result;\n    }\n}\n\nconst _d = new Array(100000);\nfor(let i = 0; i < _d.length; i++) {\n    _d[i] = i;\n}\nconst recurseSummer = function(data, sum=0) {\n    if(!data.length ) {\n        return sum;\n    }\n    return () => recurseSummer(data.slice(1), sum + data[0]);\n}\nconst final = trampoline(recurseSummer);\nconsole.log(final(_d));\n```", "```js\nconst recurseFilter = function(data, con, filtered=[]) {\n    if(!data.length ) {\n        return filtered;\n    }\n    return () => recurseFilter(data.slice(1), con, con(data[0]) ? \n     filtered.length ? new Array(...filtered), data[0]) : [data[0]] : filtered);\n\nconst finalFilter = trampoline(recurseFilter);\nconsole.log(finalFilter(_d, item => item % 2 === 0));\n```", "```js\nconst add = function(a) {\n    return function(b) {\n        return a + b;\n    }\n}\n```", "```js\nconsole.log(add(2)(5), 'this will be 7');\nconst add5 = add(5);\nconsole.log(add5(5), 'this will be 10');\n```", "```js\nconst fullFun = function(a, b, c) {\n    console.log('a', a);\n    console.log('b', b);\n    console.log('c', c);\n}\nconst tempFun = fullFun.bind(null, 2);\nsetTimeout(() => {\n    const temp2Fun = tempFun.bind(null, 3);\n    setTimeout(() => {\n        const temp3Fun = temp2Fun.bind(null, 5);\n        setTimeout() => {\n            console.log('temp3Fun');\n            temp3Fun();\n        }, 1000);\n    }, 1000);\n    console.log('temp2Fun');\n    temp2Fun(5);\n}, 1000);\nconsole.log('tempFun');\ntempFun(3, 5);\n```", "```js\nconst calculateArtbitraryValueWithPrecision = function(prec=0, val) {\n    return function(val) {\n        return parseFloat((val / 1000).toFixed(prec));\n    }\n}\nconst arr = new Array(50000);\nfor(let i = 0; i < arr.length; i++) {\n    arr[i] = i + 1000;\n}\nconsole.log(arr.map(calculatorArbitraryValueWithPrecision(2)));\n```"]