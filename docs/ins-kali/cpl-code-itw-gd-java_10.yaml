- en: '*Chapter 8*:'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '*第8章*：'
- en: Recursion and Dynamic Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归和动态规划
- en: 'This chapter covers one of the favorite topics of interviewers: Recursion and
    Dynamic Programming. Both work hand in hand, so you must be able to cover both.
    Commonly, the interviewer expects to see a plain recursive solution. However,
    they may ask you to provide some optimization hints or even to code an optimized
    version of your code. In other words, your interviewer will want to see Dynamic
    Programming at work.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了面试官最喜欢的主题之一：递归和动态规划。两者密切相关，因此您必须能够同时掌握两者。通常，面试官希望看到纯递归解决方案。但是，他们可能要求您提供一些优化提示，甚至编写代码的优化版本。换句话说，您的面试官希望看到动态规划的工作。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Recursion in a nutshell
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简而言之，递归
- en: Dynamic Programming in a nutshell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简而言之，动态规划
- en: Coding challenges
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码挑战
- en: 'By the end of this chapter, you will be able to implement a wide range of recursive
    algorithms. You''ll have a significant number of recursive patterns and approaches
    you can use to recognize and implement recursive algorithms in minutes in your
    toolbelt. Let''s start with the first topic of our agenda: recursion.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，您将能够实现各种递归算法。您将拥有大量递归模式和方法，可以在几分钟内识别和实现递归算法。让我们从我们议程的第一个主题开始：递归。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will find all the code presented in this chapter on GitHub at [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter08](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter08).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中提供的所有代码[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter08](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter08)。
- en: Recursion in a nutshell
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之，递归
- en: 'A method that calls itself directly/indirectly is called recursion. This method
    is known as a recursive method. The famous Fibonacci numbers problem can be implemented
    recursively, as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 直接/间接调用自身的方法称为递归。这种方法称为递归方法。著名的斐波那契数问题可以按照以下方式进行递归实现：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are two important parts in this code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中有两个重要部分：
- en: '**Base case**: Returns a value without subsequent recursive calls. For special
    input(s), the function can be evaluated without recursion.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本情况**：在没有后续递归调用的情况下返回一个值。对于特殊的输入，函数可以在没有递归的情况下进行评估。'
- en: '`fibonacci()` method calls itself, we have a recursive method.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fibonacci()`方法调用自身，我们有一个递归方法。'
- en: Recognizing a recursive problem
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别递归问题
- en: Before we try to solve a problem via a recursive algorithm, we must recognize
    it as a good candidate for such an algorithm. Most of the recursive problems used
    in interviews are famous, so we recognize them by name. For example, problems
    such as Fibonacci numbers, summing a list of numbers, greatest common divisor,
    the factorial of a number, recursive Binary Search, reversing a string, and so
    on are well-known recursive problems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试通过递归算法解决问题之前，我们必须将其识别为适合这种算法的良好候选。面试中使用的大多数递归问题都很有名，因此我们可以通过名称来识别它们。例如，斐波那契数、对列表中的数字求和、最大公约数、阶乘、递归二分查找、字符串反转等问题都是众所周知的递归问题。
- en: 'But what do all these problems have in common? Once we know the answer to this
    question, we will be able to recognize other recursive problems as well. The answer
    is quite simple: all these problems can be built off of sub-problems. In other
    words, we say that we can express the value returned by a method in terms of other
    values returned by that method.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，所有这些问题有什么共同之处呢？一旦我们知道了这个问题的答案，我们将能够识别其他递归问题。答案非常简单：所有这些问题都可以建立在子问题的基础上。换句话说，我们可以说我们可以用方法返回的其他值来表示方法返回的值。
- en: Important Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When a problem can be built off sub-problems, it is a good candidate for being
    solved recursively. Typically, such problems include the words *list top/last
    n ..., compute the n*th *or all..., count/find all solutions that ..., generate
    all cases that ...*, and so on. In order to compute *the n*th*...*, we must compute
    *n*th-1*, n*th-2, and so on so that we can divide the problem into sub-problems.
    In other words, computing f(*n*) requires computing f(*n*-1), f(*n*-2), and so
    on.*Practice* is the keyword in recognizing and solving recursive problems. Solving
    a lot of recursive problems will help you recognize them just as easily as you
    blink.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当问题可以建立在子问题的基础上时，它是适合递归解决的良好候选。通常，这类问题包括诸如*列出前/后n个...，计算第n个...或所有...，计算所有解...，生成所有情况...*等词语。为了计算*第n个*...，我们必须计算*f(n-1)*、*f(n-2)*等，以便将问题分解为子问题。换句话说，计算*f(n)*需要计算*f(n-1)*、*f(n-2)*等。*练习*是识别和解决递归问题的关键词。解决大量递归问题将帮助您像眨眼一样轻松地识别它们。
- en: Next, we'll highlight the main aspects of Dynamic Programming and learn how
    to optimize plain recursion via Dynamic Programming.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重点介绍动态规划的主要方面，并学习如何通过动态规划优化纯递归。
- en: Dynamic Programming in a nutshell
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之，动态规划
- en: When we talk about optimizing recursion, we talk about Dynamic Programming.
    This means that solving recursive problems can be done using plain recursive algorithms
    or Dynamic Programming.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论优化递归时，我们谈论动态规划。这意味着可以使用纯递归算法或动态规划来解决递归问题。
- en: 'Now, let''s apply Dynamic Programming to the Fibonacci numbers, starting with
    the plain recursive algorithm:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将动态规划应用于斐波那契数，从简单的递归算法开始：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The plain recursive algorithm for the Fibonacci numbers has a runtime of O(2n)
    and a space complexity of O(n) – you can find the explanation in [*Chapter 7*](B15403_07_Final_JM_ePub.xhtml#_idTextAnchor135)*,
    Big O Analysis of Algorithms*. If we set *k*=7 and represent the call stack as
    a tree of calls, then we obtain the following diagram:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数的纯递归算法的运行时间为O(2n)，空间复杂度为O(n) - 您可以在[*第7章*](B15403_07_Final_JM_ePub.xhtml#_idTextAnchor135)*，算法的大O分析*中找到解释。如果我们设置*k*=7，并将调用堆栈表示为调用树，则我们将获得以下图表：
- en: '![Figure 8.1 – Tree of calls (plain recursion)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 - 调用树（纯递归）'
- en: '](img/Figure_8.1_B15403.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.1_B15403.jpg)'
- en: Figure 8.1 – Tree of calls (plain recursion)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 - 调用树（普通递归）
- en: If we check the Big O chart from [*Chapter 7*](B15403_07_Final_JM_ePub.xhtml#_idTextAnchor135)*,
    Big O Analysis of Algorithms*, then we'll notice that O(2n) is far from being
    efficient. Exponential runtimes fit the **Horrible** area of the Big O chart.
    Can we do this better? Yes, via the *Memoization*approach.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查[*第7章*](B15403_07_Final_JM_ePub.xhtml#_idTextAnchor135)*，算法的大O分析*中的大O图表，我们会注意到O(2n)远非高效。指数运行时间适合大O图表的**可怕**区域。我们能做得更好吗？是的，通过*备忘录*方法。
- en: Memoization (or Top-Down Dynamic Programming)
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备忘录（或自顶向下的动态规划）
- en: 'When a recursive algorithm has repeated calls for the same inputs, this indicates
    that it performs duplicate work. In other words, a recursive problem may have
    overlapping sub-problems, so the road to the solution involves solving the same
    sub-problem multiple times. For example, if we redraw the tree of calls for Fibonacci
    numbers and we highlight the overlapping problems, then we obtain the following
    diagram:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个递归算法对相同的输入进行重复调用时，这表明它执行了重复的工作。换句话说，递归问题可能存在重叠子问题，因此解决方案的路径涉及多次解决相同的子问题。例如，如果我们重新绘制斐波那契数的调用树，并突出显示重叠的问题，那么我们会得到以下图表：
- en: '![Figure 8.2 – Tree of calls (duplicate work)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 - 调用树（重复工作）'
- en: '](img/Figure_8.2_B15403.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.2_B15403.jpg)'
- en: Figure 8.2 – Tree of calls (duplicate work)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 - 调用树（重复工作）
- en: It is obvious that more than half of the calls are duplicate calls.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，超过一半的调用是重复的调用。
- en: '*Memoization* is a technique that''s used to remove duplicate work in a method.
    It guarantees that a method is called for the same input only once. To achieve
    this, *Memoization* caches the results of the given inputs. This means that, when
    the method should be called to compute an input that has already been computed,
    *Memoization* will avoid this call by returning the result from the cache.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*备忘录*是一种用于消除方法中重复工作的技术。它保证一个方法只对相同的输入调用一次。为了实现这一点，*备忘录*缓存了给定输入的结果。这意味着，当方法应该被调用来计算已经计算过的输入时，*备忘录*将通过从缓存中返回结果来避免这次调用。'
- en: 'The following code uses *Memoization* to optimize the plain recursive algorithm
    for the Fibonacci numbers (the cache is represented by the `cache` array):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用*备忘录*来优化斐波那契数的普通递归算法（缓存由`cache`数组表示）：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we redraw the tree of calls from the preceding code, then we obtain the
    following diagram:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新绘制前面代码的调用树，那么我们会得到以下图表：
- en: '![Figure 8.3 – Tree of calls (Memoization)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 - 调用树（备忘录）'
- en: '](img/Figure_8.3_B15403.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.3_B15403.jpg)'
- en: Figure 8.3 – Tree of calls (Memoization)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 - 调用树（备忘录）
- en: Here, it is obvious that *Memoization* has drastically reduced the number of
    recursive calls. This time, the `fibonacci()` method take advantage of cached
    results. The runtime was reduced from O(2n) to O(n), so from exponential to polynomial.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，很明显*备忘录*大大减少了递归调用的次数。这次，`fibonacci()`方法利用了缓存的结果。运行时间从O(2n)降低到O(n)，因此从指数降低到多项式。
- en: Important note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: '*Memoization* is also referred to as a *Top-Down*approach. The *Top-Down* approach
    is not very intuitive because we start developing the final solution immediately
    by explaining how we develop it from smaller solutions. This is like saying the
    following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*备忘录*也被称为*自顶向下*方法。*自顶向下*方法并不直观，因为我们立即开始开发最终解决方案，解释我们如何从较小的解决方案中开发它。这就像说以下内容：'
- en: '*I wrote a book. How? I wrote its chapters. How? I wrote the sections of each
    chapter. How? I wrote the paragraphs of each section*.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*我写了一本书。怎么写的？我写了它的章节。怎么写的？我写了每个章节的部分。怎么写的？我写了每个部分的段落*。'
- en: The space complexity remains O(n). Can we improve it? Yes, via the *Tabulation*
    approach.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 空间复杂度仍然是O(n)。我们能改进吗？是的，通过*Tabulation*方法。
- en: Tabulation (or Bottom-Up Dynamic Programming)
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tabulation（或自底向上的动态规划）
- en: '*Tabulation*, or the *Bottom-Up*approach, is more intuitive than *Top-Down*.
    Essentially, a recursive algorithm (often) starts from the end and works backward,
    while a *Bottom-Up* algorithm starts right from the beginning. The *Bottom-Up*
    approach avoids recursion and improves space complexity.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*Tabulation*，或*自底向上*方法，比*自顶向下*更直观。基本上，递归算法（通常）从末尾开始向后工作，而*自底向上*算法从一开始就开始。*自底向上*方法避免了递归并改进了空间复杂度。'
- en: '**Important note**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要说明**'
- en: '*Tabulation* is commonly referred to as a *Bottom-Up* approach. Going bottom-up
    is an approach that avoids recursion and is quite natural. It''s like saying the
    following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*Tabulation*通常被称为*自底向上*方法。自底向上是一种避免递归并且相当自然的方法。就像说以下内容：'
- en: '*I wrote the paragraphs of each section. And? And I wrote the sections of each
    chapter. And? And I wrote all the chapters. And? And I wrote a book.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*我写了每个部分的段落。然后呢？然后我写了每个章节的部分。然后呢？然后我写了所有的章节。然后呢？然后我写了一本书。*'
- en: '*Bottom-Up* reduces the memory cost imposed by recursion when it builds up
    the call stack, which means that *Bottom-Up* eliminates the vulnerability of getting
    stack overflow errors. This may happen if the call stack gets too large and runs
    out of space.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*自底向上*减少了递归构建调用栈时所施加的内存成本，这意味着*自底向上*消除了发生堆栈溢出错误的脆弱性。如果调用栈变得太大并且空间不足，就可能发生这种情况。'
- en: 'For example, when we compute `fibonacci(k)` via the recursive approach, we
    start with *k* and continue with *k*-1, *k*-2, and so on until 0\. With the *Bottom-Up*
    approach, we start with 0 and continue with 1, 2, and so on until *k*. As shown
    in the following code, this is an iterative approach:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们通过递归方法计算`fibonacci(k)`时，我们从*k*开始，然后继续到*k*-1，*k*-2，依此类推直到0。通过*自底向上*方法，我们从0开始，然后继续到1，2等，直到*k*。如下代码所示，这是一种迭代方法：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The runtime of this algorithm is still O(n), but the space complexity was brought
    down from O(n) to O(1). So, to recap the Fibonacci numbers algorithms, we have
    that the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的运行时间仍然是O(n)，但空间复杂度已从O(n)降低到O(1)。因此，总结斐波那契数算法，我们有以下内容：
- en: The **plain recursion** algorithm has a runtime of O(2n) and a space complexity
    of O(n).
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通递归算法的运行时间为O(2n)，空间复杂度为O(n)。
- en: The **Memoization recursion** algorithm has a runtime of O(n) and a space complexity
    of O(n).
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备忘录递归算法的运行时间为O(n)，空间复杂度为O(n)。
- en: The **T****abulation** algorithm has a runtime of O(n) and a space complexity
    of O(1).
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制表法算法的运行时间为O(n)，空间复杂度为O(1)。
- en: Now, it's time to practice some coding challenges.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候练习一些编码挑战了。
- en: Coding challenges
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码挑战
- en: In the following 15 coding challenges, we will exploit recursion and Dynamic
    Programming. These problems have been carefully crafted to help you understand
    and cover a wide range of problems from this category. By the end of this coding
    challenge session, you should be able to recognize and solve recursive problems
    in the context of an interview.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的15个编码挑战中，我们将利用递归和动态规划。这些问题经过精心设计，旨在帮助您理解和解决这一类别中的各种问题。在本编码挑战会话结束时，您应该能够在面试环境中识别和解决递归问题。
- en: Coding challenge 1 – Robot grid (I)
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战1 - 机器人网格（I）
- en: '**Adobe**, **Microsoft**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Adobe，Microsoft
- en: '**Problem**: We have an *m* x *n* grid. A robot is placed at the top-left corner
    of this grid. The robot can only move either right or down at any point in time,
    but it is not allowed to move in certain cells. The robot''s goal is to find a
    path from the top-left corner to the bottom-right corner of the grid.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：我们有一个*m* x *n*网格。一个机器人被放置在这个网格的左上角。机器人只能在任何时候向右或向下移动，但不允许移动到某些单元格。机器人的目标是找到从网格的左上角到右下角的路径。
- en: '**Solution**: First, we need to set some conventions of the *m* x *n* grid.
    Let''s assume that the bottom-right corner has the coordinates (0, 0), while the
    top-left corner has the coordinates (*m, n*), where *m* is the row and *n* is
    the column of the grid. So, the robot starts from (*m, n*) and must find a path
    to (0, 0). If we try to sketch an example for a 6x6 grid, then we can obtain something
    like the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：首先，我们需要设置*m* x *n*网格的一些约定。假设右下角的坐标为(0, 0)，而左上角的坐标为(*m, n*)，其中*m*是网格的行，*n*是网格的列。因此，机器人从(*m,
    n*)开始，必须找到一条到(0, 0)的路径。如果我们尝试为一个6x6网格绘制一个示例，那么我们可以得到如下的东西：
- en: '![Figure 8.4 – Determining the moving pattern'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4 - 确定移动模式'
- en: '](img/Figure_8.4_B15403.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.4_B15403.jpg)'
- en: Figure 8.4 – Determining the moving pattern
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 - 确定移动模式
- en: Here, we can see that the robot can go from one cell (*m, n*) to an adjacent
    cell, which can be (*m*-1*, n*) or (*m, n*-1). For example, if the robot is placed
    at (5, 5), then it can go to (4, 5) or (5, 4). Furthermore, from (4, 5), it can
    go to (3, 5) or (4, 4), while from (5, 4), it can go to (5, 3) or (4, 4).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到机器人可以从一个单元格(*m, n*)到相邻的单元格，可以是(*m*-1*, n*)或(*m, n*-1)。例如，如果机器人放置在(5,
    5)，那么它可以到达(4, 5)或(5, 4)。此外，从(4, 5)，它可以到达(3, 5)或(4, 4)，而从(5, 4)，它可以到达(5, 3)或(4,
    4)。
- en: So, we have a problem that can be divided into sub-problems. We must find the
    final path for the cells (the problem), which we can do if we are able to find
    the path to an adjacent cell (sub-problem). This sounds like a recursive algorithm.
    In recursion, we approach the problem from top to down, so we start from (*m,
    n*) and move back to the origin (0, 0), as shown in the preceding diagram. This
    means that from cell (*m, n*), we try to go into (*m, n*-1) or (*m*-1*, n*).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们有一个可以分解成子问题的问题。我们必须找到单元格的最终路径（问题），如果我们能找到到相邻单元格的路径（子问题），我们就可以做到这一点。这听起来像是一个递归算法。在递归中，我们从上到下解决问题，所以我们从(*m,
    n*)开始，然后回到原点(0, 0)，如前面的图表所示。这意味着从单元格(*m, n*)，我们尝试进入(*m, n*-1)或(*m*-1*, n*)。
- en: 'Putting this into code can be done as follows (the `maze[][]` matrix is a `boolean`
    matrix that has values of `true` for cells that we are not allowed to go in –
    for example, `maze[3][1] = true` means that we are not allowed in cell (3,1)):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个问题转化为代码可以这样做（`maze[][]`矩阵是一个`boolean`矩阵，对于我们不允许进入的单元格具有`true`的值 - 例如，`maze[3][1]
    = true`表示我们不允许进入单元格(3,1)）：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The returned path is stored as a `LinkedHashSet<Point>`. Each path contains
    *m+n* steps and there are only two valid choices we can make at each step; therefore,
    the runtime is O(2m+n). But we can reduce this runtime to O(mn) if we cache the
    cells that failed (returned `false`). This way, the *Memoization* approach saves
    the robot from trying to go in a failed cell multiple times. The complete application
    is called *RobotGridMaze*. It also contains the *Memoization* code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的路径存储为`LinkedHashSet<Point>`。每条路径包含*m+n*步，每一步我们只能做两个有效的选择；因此，运行时间为O(2m+n)。但是，如果我们缓存了失败的单元格（返回`false`），我们可以将这个运行时间减少到O(mn)。这样，*备忘录*方法可以避免机器人多次尝试进入一个失败的单元格。完整的应用程序称为*RobotGridMaze*。它还包含了*备忘录*代码。
- en: Another popular problem of using a robot is as follows. Let's say we have an
    *m* x *n* grid. A robot is placed at the top-left corner of this grid. The robot
    can only move either right or down at any point in time. The robot's goal is to
    find all the unique paths from the top-left corner to the bottom-right corner
    of the grid.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用机器人的另一个流行问题如下。假设我们有一个*m* x *n*网格。一个机器人被放置在这个网格的左上角。机器人只能在任何时候向右或向下移动。机器人的目标是找到从网格的左上角到右下角的所有唯一路径。
- en: The plain recursive solution and *Bottom-Up* approach are available in the *RobotGridAllPaths*
    application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 普通递归解决方案和自底向上方法都包含在*RobotGridAllPaths*应用程序中。
- en: Coding challenge 2 – Tower of Hanoi
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 编码挑战2 - 汉诺塔
- en: '**Problem**: This is a classical problem that can occur in an interview at
    any time. The Tower of Hanoi is a problem with three rods (*A,* *B,* and *C*)
    and *n* disks. Initially, all the disks are placed in ascending order on a single
    rod (the largest disk is on the bottom (disk *n*), a smaller one sitting on it
    (*n*-1), and so on (*n*-2*, n*-3*, ...*) until the smallest disk is on the top
    (disk 1). The aim is to move all the disks from this rod to another rod while
    respecting the following rules:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：这是一个经典问题，可能随时在面试中出现。汉诺塔是一个有三根杆（*A*，*B*和*C*）和*n*个磁盘的问题。最初，所有的磁盘都按升序放置在一个杆上（最大的磁盘在底部（磁盘*n*），一个较小的磁盘放在它上面（*n*-1），依此类推（*n*-2，*n*-3，...）直到最小的磁盘在顶部（磁盘1）。目标是将所有的磁盘从这根杆移动到另一根杆，同时遵守以下规则：'
- en: Only one disk can be moved at a time.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次只能移动一个磁盘。
- en: A move means to slide the upper disk from one rod to another rod.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次移动意味着将顶部的磁盘从一个杆滑动到另一个杆。
- en: A disk cannot be placed on top of a smaller disk.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个磁盘不能放在比它更小的磁盘上。
- en: '**Solution**: Trying to solve such problems means that we need to visualize
    some cases. Let''s consider that we want to move the disks from rod *A* to rod
    *C*. Now, let''s put *n* disks on rod *A*:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：尝试解决这样的问题意味着我们需要可视化一些情况。让我们假设我们想要将磁盘从杆*A*移动到杆*C*。现在，让我们在杆*A*上放置*n*个磁盘：'
- en: 'For *n=*1: Having a single disk, we need to move one disk from rod *A* to *C*.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*n=*1：有一个单独的磁盘，我们需要将一个磁盘从杆*A*移动到*C*。
- en: 'For *n=*2: We know how to move a single disk. To move two, we need to complete
    the following steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*n=*2：我们知道如何移动一个单独的磁盘。为了移动两个磁盘，我们需要完成以下步骤：
- en: Move disk 1 from *A* to *B* (rod *B* acts as an intermediate for disk 1).
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将磁盘1从*A*移动到*B*（杆*B*作为磁盘1的中间杆）。
- en: Move disk 2 from *A* to *C* (disk 2 goes directly in its final place).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将磁盘2从*A*移动到*C*（磁盘2直接移动到最终位置）。
- en: Move disk 1 from *B* to *C* (disk 1 can be moved on top of disk 2 on rod *C*).
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将磁盘1从*B*移动到*C*（磁盘1可以移动到杆*C*上的磁盘2上）。
- en: 'For *n=*3: Let''s get some help from the following diagram:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*n=*3：让我们从以下图表中获得一些帮助：
- en: '![Figure 8.5 – Tower of Hanoi (three disks)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 - 汉诺塔（三个磁盘）'
- en: '](img/Figure_8.5_B15403.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.5_B15403.jpg)'
- en: Figure 8.5 – Tower of Hanoi (three disks)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 - 汉诺塔（三个磁盘）
- en: 'Due to *n=*2, we know how to move the top two disks from *A* (origin) to *C*
    (target). In other words, we know how to move the top two disks from one rod to
    another rod. Let''s move them from *A* to *B*, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*n=*2，我们知道如何将顶部两个磁盘从*A*（起点）移动到*C*（目标）。换句话说，我们知道如何将顶部两个磁盘从一个杆移动到另一个杆。让我们将它们从*A*移动到*B*，如下所示：
- en: Move disk 1 from *A* to *C* (this time, we use *C* as the intermediate).
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将磁盘1从*A*移动到*C*（这次我们使用*C*作为中间杆）。
- en: Move disk 2 from *A* to *B.*
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将磁盘2从*A*移动到*B*。
- en: Move disk 1 from *C* to *B.*
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将磁盘1从*C*移动到*B*。
- en: 'OK, so this is something that we''ve done before. Next, we can move disks 2
    and 3 onto *C*, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是我们以前做过的事情。接下来，我们可以将磁盘2和3移动到*C*，如下所示：
- en: Move disk 3 from *A* to *C.*
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将磁盘3从*A*移动到*C*。
- en: Move disk 1 from *B* to *A* (we use *A* as the intermediate).
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将磁盘1从*B*移动到*A*（我们使用*A*作为中间杆）。
- en: Move disk 2 from *B* to *C.*
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将磁盘2从*B*移动到*C*。
- en: Finally, move disk 3 from *A* to *C.*
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将磁盘3从*A*移动到*C*。
- en: 'Continuing with this logic, we can intuit that we can move four disks because
    we know how to move three, we can move five disks because we know how to move
    four, and so on. With rod *A* as the origin, rod *B* as the intermediate, and
    rod *C* as the target, we can conclude that we can move *n* disks by doing the
    following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 继续这种逻辑，我们可以直观地得出我们可以移动四个磁盘，因为我们知道如何移动三个，我们可以移动五个磁盘，因为我们知道如何移动四个，依此类推。以杆*A*为起点，杆*B*为中间杆，杆*C*为目标杆，我们可以得出我们可以通过以下步骤移动*n*个磁盘：
- en: Move the top *n* - 1 disks from the origin to the intermediate, using the target
    as an intermediate.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将顶部的*n* - 1个磁盘从起点移动到中间杆，使用目标杆作为中间杆。
- en: Move the top *n* - 1 disks from the intermediate to the target, using the origin
    as an intermediate.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将顶部的*n* - 1个磁盘从中间杆移动到目标杆，使用起点作为中间杆。
- en: 'At this point, it is clear that we have a problem that can be divided into
    sub-problems. Based on the preceding two bullets, we can code this as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，很明显我们有一个可以分解为子问题的问题。基于前面两个项目符号，我们可以编写代码如下：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The complete application is called *HanoiTowers*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*HanoiTowers*。
- en: Coding challenge 3 – Josephus
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战3 - Josephus
- en: '**Amazon, Google, Adobe, Microsoft, Flipkart**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊，谷歌，Adobe，微软，Flipkart
- en: '**Problem**: Consider a group of *n* men arranged in a circle (1, 2, 3, ...,
    *n*). Every *k*th man will be killed around the circle until only one survivor
    remains. Write an algorithm that finds the *k* position of this survivor. This
    is known as the Josephus problem.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个排成圆圈的*n*个人（1，2，3，...，*n*）。每隔*k*个人将在圆圈中被杀，直到只剩下一个幸存者。编写一个算法，找到这个幸存者的*k*位置。这就是所谓的Josephus问题。'
- en: '**Solution**: Remember that we had a note previously saying that when a problem
    contains the words *compute the n*thand similar expressions, then it is possibly
    a good candidate for being solved via recursion. Here, we have *find the k position*,
    which is a problem that can be divided into sub-problems and be solved via recursion.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：记住我们之前有一个注释，当一个问题包含*计算第n个*之类的表达时，它可能是递归解决的一个很好的候选。在这里，我们有*找到第k个位置*，这是一个可以分解为子问题并通过递归解决的问题。'
- en: 'Let''s consider *n*=15 and *k*=3\. So, there are 15 men and every third man
    will be eliminated from the circle until only one remains. Let''s visualize this
    via the following diagram (this is very useful for figuring out the pattern of
    killings):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑*n*=15和*k*=3。所以，有15个人，每三个人中的一个将在圆圈中被淘汰，直到只剩下一个人。让我们通过以下图表来可视化这一点（这对于找出杀人的模式非常有用）：
- en: '![Figure 8.6 – Josephus for n=15 and k=3'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6 - n=15和k=3的Josephus'
- en: '](img/Figure_8.6_B15403.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.6_B15403.jpg)'
- en: Figure 8.6 – Josephus for n=15 and k=3
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 - n=15和k=3的Josephus
- en: 'So, we have five rounds until we find the survivor, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们需要进行五轮，直到找到幸存者，如下所示：
- en: 'Round 1: The first elimination is position 3; next, 6, 9, 12, and 15 are eliminated.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1轮：第一个淘汰的是位置3；接下来是6，9，12和15。
- en: 'Round 2: The first elimination is position 4 (1 and 2 are skipped, since position
    15 was the last eliminated in round 1); next, 8 and 13 are eliminated.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2轮：第一个淘汰的是位置4（1和2被跳过，因为位置15是第1轮最后被淘汰的）；接下来，淘汰8和13。
- en: 'Round 3: The first elimination is position 2 (14 and 1 are skipped, since position
    13 was the last eliminated in round 2); next, 10 and 1 are eliminated.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3轮：第一个淘汰的是位置2（14和1被跳过，因为位置13是第2轮最后被淘汰的）；接下来，淘汰10和1。
- en: 'Round 4: The first elimination position is 11, followed by position 7.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4轮：第一个淘汰的位置是11，接着是位置7。
- en: 'Round 5: 14 is eliminated and 5 is the survivor.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第5轮：淘汰14，5是幸存者。
- en: 'Trying to identify a pattern or a recursive call can be done based on the following
    observations. After the first man (*k*th) is eliminated, *n*-1 men are left. This
    means that we call `josephus(n – 1, k)` to get the position of the *n*-1th man.
    However, notice that the position returned by `josephus(n – 1, k)` will take into
    account the position starting from *k%n* + 1\. In other words, we have to adjust
    the position returned by `josephus(n – 1, k)` to obtain (`josephus(n - 1, k) +
    k - 1) % n + 1`. The recursive method is shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试识别模式或递归调用可以基于以下观察来完成。在第一个人（*k*个）被淘汰后，剩下*n*-1个人。这意味着我们调用`josephus(n – 1, k)`来得到第*n*-1个人的位置。然而，请注意，`josephus(n
    – 1, k)`返回的位置将考虑从*k%n* + 1开始的位置。换句话说，我们必须调整`josephus(n – 1, k)`返回的位置以获得(`josephus(n
    - 1, k) + k - 1) % n + 1`。递归方法如下所示：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you find this approach quite tricky, then you can try an iterative approach
    based on a queue. First, fill up the queue with *n* men. Next, loop the queue
    and, for each man, retrieve and remove the head of this queue (`poll()`). If the
    retrieved man is not the *k*th, then insert this man back in the queue (`add()`).
    If this is the *k*th man, then break the loop and repeat this process until the
    queue''s size is 1\. The code for this is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您觉得这种方法非常棘手，那么您可以尝试基于队列的迭代方法。首先，用*n*个人填充队列。接下来，循环队列，并且对于每个人，检索并删除此队列的头部（`poll()`）。如果检索到的人不是第*k*个，则将此人重新插入队列（`add()`）。如果这是第*k*个人，则中断循环，并重复此过程，直到队列的大小为1。这个代码如下：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The complete application is called *Josephus*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*Josephus*。
- en: Coding challenge 4 – Color spots
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 编码挑战4-彩色斑点
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊，谷歌，Adobe，微软，Flipkart
- en: '**Problem**: Consider an *r* x *c* grid where *r* stands for rows and *c* stands
    for columns. Each cell has a color represented by a number *k* (for example, for
    three colors, *k*=3). We define the connected set of a cell (or a color spot)
    as the total cells in which we can go from the respective cell by successive displacements
    on the row or the column, thus keeping the color. The goal is to determine the
    color and the number of cells of the maximum connected set. In other words, we
    need to determine the biggest color spot.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个*r* x *c*网格，其中*r*代表行，*c*代表列。每个单元格都有一个用数字*k*表示的颜色（例如，对于三种颜色，*k*=3）。我们将单元格的连接集（或颜色斑点）定义为我们可以通过对行或列的连续位移从相应单元格到达的总单元格数，从而保持颜色。目标是确定最大连接集的颜色和单元格数。换句话说，我们需要确定最大的颜色斑点。'
- en: '**Solution**: Let''s consider a 5x5 grid and three colors, where we have *r=c=*5
    and *k=*3\. Next, let''s represent the grid as shown in the following diagrams:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们考虑一个5x5的网格和三种颜色，其中*r=c=*5，*k=*3。接下来，让我们按照以下图示来表示网格：'
- en: '![Figure 8.7 – Biggest color spot ((a) – initial grid, (b) – solved grid)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7-最大颜色斑点（a）-初始网格，（b）-解决网格）'
- en: '](img/Figure_8.7_B15403.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.7_B15403.jpg)'
- en: Figure 8.7 – Biggest color spot ((a) – initial grid, (b) – solved grid)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7-最大颜色斑点（a）-初始网格，（b）-解决网格
- en: Let's focus on image (a). Here, we can see that moving from a cell to another
    cell can be done in a maximum of four directions (up, down, left, and right).
    This means that, from a cell (*r,c*), we can try to go to (*r*-1, *c*), (*r*+1,
    *c*), (*r*, *c*-1), and (*r*, *c*+1). We cannot perform a move if we risk falling
    from the grid or the targeted cell has another color than the current cell. So,
    by iterating each cell ((0, 0), (0, 1), ... (*r*, *c*)), we can determine the
    size of the connected set of that cell (the size of the color spot) by visiting
    each allowed cell and counting it. In image (a), we have four spots that are color
    1 whose sizes are 1, 1, 1, and 2\. We also have six spots that are color 2 whose
    sizes are 1, 1, 2, 1, 1, and 1\. Finally, we have three spots that are color 3
    whose sizes are 11, 1, and 1\.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于图像（a）。在这里，我们可以看到从一个单元格移动到另一个单元格最多可以有四个方向（上，下，左，右）。这意味着，从一个单元格（*r，c*）到另一个单元格（*r*-1，*c*），（*r*+1，*c*），（*r*，*c*-1），和（*r*，*c*+1）。如果我们冒着从网格上掉下来的风险，或者目标单元格的颜色与当前单元格不同，我们就不能进行移动。因此，通过迭代每个单元格（（0，0），（0，1），...（*r，c*）），我们可以通过访问每个允许的单元格并计数来确定该单元格的连接集的大小（颜色斑点的大小）。在图像（a）中，我们有四个颜色为1的斑点，它们的大小分别为1、1、1和2。我们还有六个颜色为2的斑点，它们的大小分别为1、1、2、1、1和1。最后，我们有三个颜色为3的斑点，它们的大小分别为11、1和1。
- en: From this, we can conclude that the biggest color spot has a size of 11 and
    a color of 3\. Mainly, we can consider that the color spot of the first cell is
    the maximum spot and that each time we find a color spot bigger than this one,
    we replace this one with the one we found.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以得出最大的颜色斑点大小为11，颜色为3。主要的是，我们可以认为第一个单元格的颜色斑点是最大的，每当我们找到一个比这个更大的颜色斑点时，我们就用我们找到的那个来替换这个。
- en: Now, let's focus on image (b). Why do we have negative values? Because when
    we visit a cell, we switch its *color* value to *-color*. This is a convenient
    convention that's used to avoid computing the same connected set of a cell multiple
    times. It is like saying that we mark this cell as visited. By convention, we
    cannot move in a cell that has a negative value for a color, so we will not compute
    the size of the same color spot twice.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于图像（b）。为什么我们有负值？因为当我们访问一个单元格时，我们将其*颜色*值切换为*-颜色*。这是一个方便的约定，用于避免多次计算单元格的相同连接集。这就像是说我们标记了这个单元格已被访问。按照约定，我们不能移动到具有颜色的负值的单元格，因此我们不会计算相同颜色斑点的大小两次。
- en: 'Now, gluing these observations together to make a recursive method leads to
    the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将这些观察结果组合成一个递归方法，得到以下代码：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'While the preceding recursive method, `computeColorSpot()`, can compute the
    size of a color spot, starting from the given cell, the following method determines
    the biggest color spot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定单元格开始时，前面的递归方法`computeColorSpot()`可以计算颜色斑点的大小，而以下方法确定了最大的颜色斑点：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The complete application is called *BiggestColorSpot*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*BiggestColorSpot*。
- en: Coding challenge 5 – Coins
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 编码挑战5 - 硬币
- en: '**Google**, **Adobe**, **Microsoft**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google**，**Adobe**，**Microsoft**'
- en: '**Problem**: Consider an amount of *n* cents. Count the ways you can change
    this amount using any number of quarters (25 cents), dimes (10 cents), nickels
    (5 cents), and pennies (1 cent).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑n美分的金额。计算您可以使用任意数量的25美分，10美分，5美分和1美分来更改此金额的方式。'
- en: '**Solution**: Let''s imagine that we have to change 50 cents. Right from the
    start, we can see that changing 50 cents is a problem that can be solved via sub-problems.
    For example, we can change 50 cents using 0, 1, or 2 quarters. Or we can do it
    using 0, 1, 2, 3, 4, or 5 dimes. We can also do it using 0, 1, 2, 3, 4, 5, 6,
    7, 8, 9, or 10 nickels. Finally, we can do it using 0, 1, 2, 3, ..., 50 pennies.
    Let''s assume that we have 1 quarter, 1 dime, 2 nickels, and 5 pennies. We can
    use our quarter to say the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：假设我们必须更改50美分。从一开始，我们就可以看到更改50美分是一个可以通过子问题解决的问题。例如，我们可以使用0、1或2个25美分来更改50美分。或者我们可以使用0、1、2、3、4或5个10美分来做到这一点。我们还可以使用0、1、2、3、4、5、6、7、8、9或10个5美分。最后，我们可以使用0、1、2、3、...、50个1美分。假设我们有1个25美分，1个10美分，2个5美分和5个1美分。我们可以使用我们的25美分来说以下内容：'
- en: '*calculateChange***(50) = 1 quarters + ...**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*calculateChange***(50) = 1个25美分 + ...**'
- en: 'But this is like saying the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但这就像说以下内容：
- en: '*calculateChange***(25) = 0 quarters + ...**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*calculateChange***(25) = 0个25美分 + ...**'
- en: 'We don''t have more quarters; therefore, we add a dime:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有更多的25美分；因此，我们添加一个10美分：
- en: '*calculateChange***(25) = 0 quarters + 1 dimes + ...**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*calculateChange***(25) = 0个25美分 + 1个10美分 + ...**'
- en: 'This can be reduced, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以简化如下：
- en: '*calculateChange***(15) = 0 quarters + 0 dimes + ...**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*calculateChange***(15) = 0个25美分 + 0个10美分 + ...**'
- en: 'We don''t have any more dimes. We add the nickels:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有更多的10美分。我们添加了5美分：
- en: '*calculateChange***(15) = 0 quarters + 0 dimes + 2 nickel + ...**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*calculateChange***(15) = 0个25美分 + 0个10美分 + 2个5美分 + ...**'
- en: 'This can be reduced to the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以简化为以下内容：
- en: '*calculateChange***(5) = 0 quarters + 0 dimes + 0 nickel + ...**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*calculateChange***(5) = 0个25美分 + 0个10美分 + 0个5美分 + ...**'
- en: 'Finally, since we don''t have more nickels, we add the pennies:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们没有更多的5美分，我们添加了1美分：
- en: '*calculateChange***(5) = 0 quarters + 0 dimes + 0 nickel + 5 pennies**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*calculateChange***(5) = 0个25美分 + 0个10美分 + 0个5美分 + 5个1美分**'
- en: 'This can be reduced to the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以简化为以下内容：
- en: '*calculateChange***(0) = 0 quarters + 0 dimes + 0 nickel + 0 pennies**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*calculateChange***(0) = 0个25美分 + 0个10美分 + 0个5美分 + 0个1美分**'
- en: 'If we try to represent all the possible reductions, we obtain the following
    diagram:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们试图表示所有可能的减少，我们得到以下图表：
- en: '![Figure 8.8 – Changing n cents into quarters, dimes, nickels, and pennies'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8 - 将n美分换成25美分，10美分，5美分和1美分'
- en: '](img/Figure_8.8_B15403.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.8_B15403.jpg)'
- en: Figure 8.8 – Changing n cents into quarters, dimes, nickels, and pennies
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 - 将n美分换成25美分，10美分，5美分和1美分
- en: 'Implementing this reducible algorithm can be done via recursion, as shown in
    the following code. Notice that we are using *Memoization* to avoid changing the
    same amount multiple times:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过递归实现这种可简化的算法，如下代码所示。请注意，我们使用*Memoization*来避免多次更改相同的金额：
- en: '[PRE10]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The complete application is called *Coins*. It also contains the plain recursive
    approach (without *Memoization*).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*Coins*。它还包含了纯递归方法（不包括*Memoization*）。
- en: Coding challenge 6 – Five towers
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战6 - 五座塔
- en: '**Problem**: Consider a 5x5 grid with five defensive towers spread across the
    grid. To provide an optimal defense for the grid, we have to build a tower on
    each row of the grid. Find all the solutions for building these towers so that
    none of them share the same column and diagonal.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个5x5的网格，网格上分布着五座防御塔。为了为网格提供最佳防御，我们必须在网格的每一行上建造一座塔。找出建造这些塔的所有解决方案，以便它们没有共享相同的列和对角线。'
- en: '**Solution**: We know that, on each row, we must build a tower and that it
    is not important in what order we build them on the grid. Let''s sketch a solution
    and a failure, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：我们知道，在每一行上，我们必须建造一座塔，并且在网格上建造它们的顺序并不重要。让我们草拟一个解决方案和一个失败，如下所示：'
- en: '![Figure 8.9(a) – Failure and solution'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9(a) - 失败和解决方案'
- en: '](img/Figure_8.9(a)_B15403.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.9(a)_B15403.jpg)'
- en: Figure 8.9(a) – Failure and solution
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9(a) - 失败和解决方案
- en: 'Let''s focus on the solution and start from the first row: row 0\. We can build
    a tower on this row in any column; therefore, we can say the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于解决方案，并从第一行开始：第0行。我们可以在任何列上的这一行上建造一座塔；因此，我们可以说以下内容：
- en: '![Figure 8.9(b): Part 1 of the logic to build the towers'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9(b)：构建塔的逻辑的第1部分'
- en: '](img/Figure_8.9(b)_B15403.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.9(b)_B15403.jpg)'
- en: 'Figure 8.9(b): Part 1 of the logic to build the towers'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9(b)：构建塔的逻辑的第1部分
- en: 'If we continue with the same logic, then we can say the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续使用相同的逻辑，那么我们可以说以下内容：
- en: '![Figure 8.9(c): Part 2 of the logic to build the towers'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9(c)：构建塔的逻辑的第2部分'
- en: '](img/Figure_8.9(c)_B15403.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.9(c)_B15403.jpg)'
- en: 'Figure 8.9(c): Part 2 of the logic to build the towers'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9(c)：构建塔的逻辑的第2部分
- en: 'So, we start from the first row and build the first tower on (0,0). We go to
    the second row and try to build the second tower so that we don''t share the column
    or diagonal with the first tower. We go to the third row and try to build the
    third tower so that we don''t share the column or diagonal with the first two
    towers. We follow the same logic for the fourth and fifth towers. This is our
    solution. Now, we repeat this logic – we build the first tower at (0,1) and continue
    building until we find the second solution. Next, we build the first tower at
    (0, 2), (0, 3) and finally at (0,4) while we repeat the process. We can write
    this recursive algorithm as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们从第一行开始，在(0,0)处建立第一个塔。我们转到第二行，并尝试建立第二个塔，以便不与第一个塔共享列或对角线。我们转到第三行，并尝试建立第三个塔，以便不与前两个塔共享列或对角线。我们对第四和第五个塔采用相同的逻辑。这是我们的解决方案。现在，我们重复此逻辑-我们在(0,1)处建立第一个塔，并继续建立，直到找到第二个解决方案。接下来，我们在(0,2)、(0,3)和最后在(0,4)处建立第一个塔，同时重复这个过程。我们可以将这个递归算法写成如下：
- en: '[PRE11]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The complete application is called *FiveTowers*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*FiveTowers*。
- en: Coding challenge 7 – Magic index
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 编码挑战7-魔术索引
- en: '**Adobe, Microsoft**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Adobe，Microsoft
- en: '**Problem**: Consider a sorted array of *n* elements that allows duplicates.
    An index *k* is magic if *array*[*k*] = *k*. Write a recursive algorithm that
    finds the first magic index.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个允许重复的*n*个元素的排序数组。如果*array*[*k*] = *k*，则索引*k*是魔术索引。编写一个递归算法，找到第一个魔术索引。'
- en: '**Solution**: First, let''s quickly draw two sorted arrays containing 18 elements,
    as shown in the following diagram. The array at the top of the image contains
    no duplicates, while the array at the bottom contains duplicates. This way, we
    can observe the influence of these duplicates:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：首先，让我们快速绘制包含18个元素的两个排序数组，如下图所示。图像顶部的数组不包含重复项，而图像底部的数组包含重复项。这样，我们可以观察到这些重复项的影响：'
- en: '![Figure 8.10 – Sorted array of 18 elements'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.10-18个元素的排序数组'
- en: '](img/Figure_8.10_B15403.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.10_B15403.jpg)'
- en: Figure 8.10 – Sorted array of 18 elements
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10-18个元素的排序数组
- en: If we halve the array with no duplicates, then we can conclude that the magic
    index must be on the right-hand side because *array*[8] < 8\. This is true since
    the magic index is 11, so *array*[11] = 11.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将不包含重复项的数组减半，那么我们可以得出结论，魔术索引必须在右侧，因为*array*[8] < 8。这是正确的，因为魔术索引是11，所以*array*[11]
    = 11。
- en: If we halve the array with duplicates, we cannot get the same conclusion we
    received previously. The magic index can be on both sides. Here, we have *array*[5]
    = 5 and *array*[12] = 12\. We must find the first magic index, so we should search
    the left-hand side first.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将包含重复项的数组减半，我们无法得出与之前相同的结论。魔术索引可以在两侧。在这里，我们有*array*[5] = 5和*array*[12] =
    12。我们必须找到第一个魔术索引，所以我们应该首先搜索左侧。
- en: But how do we find it? The most obvious approach consists of looping the array
    and checking if *array*[*i*] = *i*. While this works for any ordered array, it
    will not impress the interviewer since it is not recursive, so we need another
    approach.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何找到它呢？最明显的方法是循环数组并检查*array*[i] = *i*。虽然这对于任何有序数组都有效，但它不会给面试官留下深刻印象，因为它不是递归的，所以我们需要另一种方法。
- en: 'In [*Chapter 7*](B15403_07_Final_JM_ePub.xhtml#_idTextAnchor135)*, Big O Analysis
    of Algorithms*, you saw an example of searching in a sorted array via the Binary
    Search algorithm. This algorithm can be implemented via recursion since, at each
    step, we halve the previous array and create a sub-problem. Since the indexes
    of an array are ordered, we can adapt the Binary Search algorithm. The main issue
    that we face is that duplicated elements complicate the search. When we halve
    the array, we cannot say that the magic index is on the left or the right, so
    we have to search in both directions, as shown in the following code (first, we
    search the left-hand side):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B15403_07_Final_JM_ePub.xhtml#_idTextAnchor135)*，算法的大O分析*中，您看到了通过二分搜索算法在排序数组中搜索的示例。由于在每一步中，我们都将前一个数组减半并创建一个子问题，因此可以通过递归实现此算法。由于数组的索引是有序的，我们可以调整二分搜索算法。我们面临的主要问题是重复元素使搜索变得复杂。当我们将数组减半时，我们无法说魔术索引在左侧还是右侧，因此我们必须在两个方向搜索，如下面的代码所示（首先，我们搜索左侧）：
- en: '[PRE12]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The complete application is called *MagicIndex*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*MagicIndex*。
- en: Coding challenge 8 – The falling ball
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战8-下落的球
- en: '**Problem**: Consider an *m* x *n* grid where each (*m, n*) cell has an elevation
    represented by a number between 1 and 5 (5 is the highest elevation). A ball is
    placed in a cell of the grid. This ball can fall into another cell, as long as
    that cell has a smaller elevation than the ball cell. The ball can fall in four
    directions: north, west, east, and south. Display the initial grid, as well as
    the grid after the ball falls on all possible paths. Mark the paths with 0.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个*m* x *n*的网格，其中每个(*m, n*)单元格的高程由1到5之间的数字表示（5是最高的高程）。一个球放在网格的一个单元格中。只要该单元格的高程小于球单元格，球就可以掉落到另一个单元格。球可以向四个方向掉落：北、西、东和南。显示初始网格，以及球在所有可能路径上掉落后的网格。用0标记路径。'
- en: '**Solution**: Always pay attention to the problem requests. Notice that we
    must display the solved grid, not list the paths or count them. The easiest way
    to display a grid is to use two loops, as shown in the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：始终注意问题的要求。注意我们必须显示解决的网格，而不是列出路径或计数。显示网格的最简单方法是使用两个循环，如下面的代码所示：'
- en: '[PRE13]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s sketch a 5x5 grid and view an input and its output. The following
    image shows the initial grid in the form of a 3D model, along with a possible
    path and the solved grid:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们勾画一个5x5的网格，并查看一个输入及其输出。下图显示了初始网格的3D模型形式，以及可能的路径和解决的网格：
- en: '![Figure 8.11 – The falling ball'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.11-下落的球'
- en: '](img/Figure_8.11_B15403.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.11_B15403.jpg)'
- en: Figure 8.11 – The falling ball
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11-下落的球
- en: 'I think we have enough experience to intuit that this problem can be solved
    via recursion. Mainly, we move the ball in all acceptable directions and mark
    each visited cell with 0\. When we have the ball in the (*i, j*) cell, we can
    go in (*i*-1*, j*), (*i+*1*, j*), (*i, j*-1), and (*i, j+*1) directions, as long
    those cells have smaller elevations. In terms of code, we have the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们有足够的经验来直觉地认为这个问题可以通过递归来解决。主要是，我们将球移动到所有可接受的方向，并用0标记每个访问的单元格。当我们将球放在(*i,
    j*)单元格中时，我们可以朝着(*i*-1*, j*)，(*i+*1*, j*)，(*i, j*-1)和(*i, j+*1*)的方向前进，只要这些单元格的高度较小。在代码方面，我们有以下内容：
- en: '[PRE14]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The complete application is called *TheFallingBall*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*TheFallingBall*。
- en: Coding challenge 9 – The highest colored tower
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程挑战9 - 最高彩色塔
- en: '**Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**Adobe**，**Microsoft**，**Flipkart**'
- en: '**Problem**: Consider *n* boxes of different widths (*w*1...n), heights (*h*1...n),
    and colors (*c*1...n). Find the highest tower of boxes that respects the following
    conditions:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑不同宽度（*w*1...n）、高度（*h*1...n）和颜色（*c*1...n）的*n*个盒子。找到符合以下条件的最高的盒子塔：'
- en: You cannot rotate the boxes.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能旋转盒子。
- en: You cannot place two successive boxes of the same color.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能连续放置两个相同颜色的盒子。
- en: Each box is strictly larger than the box above it in terms of their width and
    height.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个盒子在宽度和高度上都严格大于它上面的盒子。
- en: '**Solution**: Let''s try to visualize this, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们试着将这个可视化，如下所示：'
- en: '![Figure 8.12(a) – The highest colored tower'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12(a) - 最高的彩色塔'
- en: '](img/Figure_8.12_B15403.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.12_B15403.jpg)'
- en: Figure 8.12(a) – The highest colored tower
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12(a) - 最高的彩色塔
- en: 'We have seven boxes of different sizes and colors. We can imagine that the
    highest tower will contain all these boxes, *b*1...*b*7\. But we have several
    constraints that don''t allow us to simply stack the boxes. We can choose one
    of the boxes as the base box and place another allowed box on top of it, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有七个不同尺寸和颜色的盒子。我们可以想象最高的塔将包含所有这些盒子，*b*1...*b*7。但是我们有一些约束条件，不允许我们简单地堆叠这些盒子。我们可以选择一个盒子作为基础盒子，并将另一个允许的盒子放在其顶部，如下所示：
- en: '![Figure 8.12(b) The logic to select the boxes to build the highest tower'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12(b) 选择盒子建造最高塔的逻辑'
- en: '](img/Figure_8.12(b)_The_logic_to_select_the_boxes_to_build_the_highest_tower.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.12(b)_选择盒子建造最高塔的逻辑.jpg)'
- en: Figure 8.12(b) The logic to select the boxes to build the highest tower
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12(b) 选择盒子建造最高塔的逻辑
- en: So, we identified a pattern. We choose a box as the base, and we try to see
    which of the remaining boxes can go on top as the second level. We do the same
    for the third level and so on. When we are done (we cannot add more boxes or no
    boxes are left), we store the size of the highest tower. Next, we repeat this
    scenario with another base box.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们找到了一个模式。我们选择一个盒子作为基础，然后尝试看看剩下的盒子中哪个可以作为第二层放在顶部。我们对第三层也是同样的操作。当我们完成时（不能再添加盒子或没有剩余的盒子时），我们存储最高塔的大小。接下来，我们用另一个基础盒子重复这种情况。
- en: Since every box must be larger in terms of width and height than the box above
    it, we can sort the boxes by width or height in descending order (it is not important
    which one we choose). This way, for any tower of *b*0*,...b*k*, k < n* boxes,
    we can find the next valid box by searching the *b*k+1...*n* interval.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个盒子在宽度和高度上都必须大于上面的盒子，我们可以按宽度或高度按降序对盒子进行排序（选择哪一个并不重要）。这样，对于*k < n*的盒子的任何塔，我们可以通过搜索*b*k+1...*n*区间来找到下一个有效的盒子。
- en: 'Moreover, we can avoid recalculating the best solution for the same base box
    by caching the best solutions via *Memoization*:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过*记忆化*来避免为相同的基础盒子重新计算最佳解决方案：
- en: '[PRE15]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The complete application is called *HighestColoredTower*. The code also contains
    the plain recursion approach to this problem (without *Memoization*).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*HighestColoredTower*。代码还包含了这个问题的纯递归方法（没有*记忆化*）。
- en: Coding challenge 10 – String permutations
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程挑战10 - 字符串排列
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**Amazon**，**Google**，**Adobe**，**Microsoft**，**Flipkart**'
- en: '**Problem**: Write an algorithm that computes all the permutations of a string
    and accommodates the following two conditions:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：编写一个算法，计算字符串的所有排列，并满足以下两个条件：'
- en: The given string can contain duplicates.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定的字符串可以包含重复项。
- en: The returned list of permutations should not contain duplicates.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的排列列表不应包含重复项。
- en: '**Solution**: Like in any recursive problem, the key consists of recognizing
    the relationship and patterns between the different sub-problems. Right away,
    we can intuit that permuting a string with duplicates should be more complicated
    than permuting a string with unique characters. This means that we must understand
    the permutations of a string with unique characters first.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：就像在任何递归问题中一样，关键在于识别不同子问题之间的关系和模式。我们立刻就能直观地感觉到，对具有重复字符的字符串进行排列应该比对具有唯一字符的字符串进行排列更复杂。这意味着我们必须先理解具有唯一字符的字符串的排列。'
- en: 'The most natural way of permuting the characters of a string can follow a simple
    pattern: each character of the string will become the first character of the string
    (swap their positions) and then permute all the remaining letters using a recursive
    call. Let''s delve into the general case. For a string containing a single character,
    we have a single permutation:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对字符串的字符进行排列的最自然的方式可以遵循一个简单的模式：字符串的每个字符将成为字符串的第一个字符（交换它们的位置），然后使用递归调用对所有剩余的字母进行排列。让我们深入研究一般情况。对于包含单个字符的字符串，我们有一个排列：
- en: P(*c*1) = *c*1
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: P(*c*1) = *c*1
- en: 'If we add another character, then we can express the permutations as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加另一个字符，那么我们可以按如下方式表示排列：
- en: P(*c*1*c*2) = *c*1*c*2 and *c*2*c*1
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: P(*c*1*c*2) = *c*1*c*2 和 *c*2*c*1
- en: 'If we add another character, then we must express the permutations using *c*1*c*2\.
    Each permutation of *c*1*c*2*c*3 represents an ordering of *c*1*c*2, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加另一个字符，那么我们必须使用*c*1*c*2来表示排列。每个*c*1*c*2*c*3的排列代表了*c*1*c*2的顺序，如下所示：
- en: '*c*1*c*2 -> *c*1*c*2*c*3,*c*1*c*3*c*2,*c*3*c*1*c*2'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*c*1*c*2 -> *c*1*c*2*c*3,*c*1*c*3*c*2,*c*3*c*1*c*2'
- en: '*c*2*c*1 -> *c*2*c*1*c*3,*c*2*c*3*c*1,*c*3*c*2*c*1'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*c*2*c*1 -> *c*2*c*1*c*3,*c*2*c*3*c*1,*c*3*c*2*c*1'
- en: 'Let''s replace *c*1*c*2*c*3 with ABC. Next, we represent P(ABC) as a diagram:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用ABC替换*c*1*c*2*c*3。接下来，我们将P(ABC)表示为图表：
- en: '![Figure 8.13 – Permuting ABC'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.13 – 对ABC进行排列'
- en: '](img/Figure_8.13_B15403.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.13_B15403.jpg)'
- en: Figure 8.13 – Permuting ABC
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – 对ABC进行排列
- en: 'If we add another character, then we must express the permutations using *c*1*c*2*c*3*c*4\.
    Each permutation of *c*1*c*2*c*3*c*4 represents an ordering of *c*1*c*2*c*3, as
    follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加另一个字符，那么我们必须使用*c*1*c*2*c*3*c*4来表示排列。*c*1*c*2*c*3*c*4的每个排列代表*c*1*c*2*c*3的排序，如下所示：
- en: '*c*1*c*2*c*3 -> *c*1*c*2*c*3*c*4,*c*1*c*2*c*4*c*3,*c*1*c*4*c*2*c*3,*c*4*c*1*c*2*c*3'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*c*1*c*2*c*3 -> *c*1*c*2*c*3*c*4,*c*1*c*2*c*4*c*3,*c*1*c*4*c*2*c*3,*c*4*c*1*c*2*c*3'
- en: '*c*1*c*3*c*2 -> *c*1*c*3*c*2*c*4,*c*1*c*3*c*4*c*2,*c*1*c*4*c*3*c*2,*c*4*c*1*c*3*c*2'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*c*1*c*3*c*2 -> *c*1*c*3*c*2*c*4,*c*1*c*3*c*4*c*2,*c*1*c*4*c*3*c*2,*c*4*c*1*c*3*c*2'
- en: '*c*3*c*1*c*2 -> *c*3*c*1*c*2*c*4,*c*3*c*1*c*4*c*2,*c*3*c*4*c*1*c*2,*c*4*c*3*c*1*c*2'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*c*3*c*1*c*2 -> *c*3*c*1*c*2*c*4,*c*3*c*1*c*4*c*2,*c*3*c*4*c*1*c*2,*c*4*c*3*c*1*c*2'
- en: '*c*2c1*c*3 -> *c*2*c*1*c*3*c*4,*c*2*c*1*c*4*c*3,*c*2*c*4*c*1*c*3,*c*4*c*2*c*1*c*3'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*c*2c1*c*3 -> *c*2*c*1*c*3*c*4,*c*2*c*1*c*4*c*3,*c*2*c*4*c*1*c*3,*c*4*c*2*c*1*c*3'
- en: '*c*2*c*3*c*1 -> *c*2*c*3*c*1*c*4,*c*2*c*3*c*4*c*1,*c*2*c*4*c*3*c*1,*c*4*c*2*c*3*c*1'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*c*2*c*3*c*1 -> *c*2*c*3*c*1*c*4,*c*2*c*3*c*4*c*1,*c*2*c*4*c*3*c*1,*c*4*c*2*c*3*c*1'
- en: '*c*3*c*2*c*1 -> *c*3*c*2*c*1*c*4,*c*3*c*2*c*4*c*1,*c*3*c*4*c*2*c*1,*c*4*c*3*c*2*c*1'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*c*3*c*2*c*1 -> *c*3*c*2*c*1*c*4,*c*3*c*2*c*4*c*1,*c*3*c*4*c*2*c*1,*c*4*c*3*c*2*c*1'
- en: We can continue like this forever, but I think it is quite clear what pattern
    can be used for generating *P*(*c*1, *c*2, ..., *c*n).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以一直这样继续下去，但我认为可以很清楚地知道可以用什么模式来生成*P*(*c*1, *c*2, ..., *c*n)。
- en: 'So, this is the right moment to take our logic a step further. Now, it is time
    to ask the following questions: if we know how to compute all the permutations
    for strings of *k*-1 characters (*c*1*c*2...*c*k-1), then how we can use this
    information to compute all the permutations for strings of *k* characters (*c*1*c*2...*c*k-1*c*k)?
    For example, if we know how to compute all the permutations for the *c*1*c*2*c*3
    string, then how we can express all the permutations of the *c*1*c*2*c*3*c*4 string
    using *c*1*c*2*c*3 permutations? The answer is to take each character from the
    *c*1*c*2...*c*k string and append the *c*1*c*2...*c*k-1 permutation to it, as
    follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在是时候进一步推进我们的逻辑了。现在，是时候问以下问题了：如果我们知道如何计算*k*-1个字符的字符串的所有排列（*c*1*c*2...*c*k-1），那么我们如何使用这些信息来计算*k*个字符的字符串的所有排列（*c*1*c*2...*c*k-1*c*k）？例如，如果我们知道如何计算*c*1*c*2*c*3字符串的所有排列，那么我们如何使用*c*1*c*2*c*3的排列来表示*c*1*c*2*c*3*c*4字符串的所有排列？答案是从*c*1*c*2...*c*k字符串中取出每个字符，并将*c*1*c*2...*c*k-1排列附加到它，如下所示：
- en: P(*c*1*c*2*c*3*c*4) = [*c*1 + P(*c*2*c*3*c*4)] + [*c*2 + P(*c*1*c*3*c*4)] +
    [*c*3 + P(*c*1*c*2*c*4)] + [*c*4 + P(*c*1*c*2*c*3)]
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: P(*c*1*c*2*c*3*c*4) = [*c*1 + P(*c*2*c*3*c*4)] + [*c*2 + P(*c*1*c*3*c*4)] +
    [*c*3 + P(*c*1*c*2*c*4)] + [*c*4 + P(*c*1*c*2*c*3)]
- en: '[*c*1 + P(*c*2*c*3*c*4)] -> *c*1*c*2*c*3*c*4,*c*1*c*2*c*4*c*3,*c*1*c*3*c*2*c*4,*c*1*c*3*c*4*c*2,*c*1*c*4*c*2*c*3,*c*1*c*4*c*3*c*2'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[*c*1 + P(*c*2*c*3*c*4)] -> *c*1*c*2*c*3*c*4,*c*1*c*2*c*4*c*3,*c*1*c*3*c*2*c*4,*c*1*c*3*c*4*c*2,*c*1*c*4*c*2*c*3,*c*1*c*4*c*3*c*2'
- en: '[*c*2 + P(*c*1*c*3*c*4)] -> *c*2*c*1*c*3*c*4,*c*2*c*1*c*4*c*3,*c*2*c*3*c*1*c*4,*c*2*c*3*c*4*c*1,*c*2*c*4*c*1*c*3,*c*2*c*4*c*3*c*1'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[*c*2 + P(*c*1*c*3*c*4)] -> *c*2*c*1*c*3*c*4,*c*2*c*1*c*4*c*3,*c*2*c*3*c*1*c*4,*c*2*c*3*c*4*c*1,*c*2*c*4*c*1*c*3,*c*2*c*4*c*3*c*1'
- en: '[*c*3 + P(*c*1*c*2*c*4)] -> *c*3*c*1*c*2*c*4,*c*3*c*1*c*4*c*2,*c*3*c*2*c*1*c*4,*c*3*c*2*c*4*c*1,*c*3*c*4*c*1*c*2,*c*3*c*4*c*2*c*1'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[*c*3 + P(*c*1*c*2*c*4)] -> *c*3*c*1*c*2*c*4,*c*3*c*1*c*4*c*2,*c*3*c*2*c*1*c*4,*c*3*c*2*c*4*c*1,*c*3*c*4*c*1*c*2,*c*3*c*4*c*2*c*1'
- en: '[*c*4 + P(*c*1*c*2*c*3)] -> *c*4*c*1*c*2*c*3,*c*4*c*1*c*3*c*2,*c*4*c*2*c*1*c*3,*c*4*c*2*c*3*c*1,*c*4*c*3*c*1*c*2,*c*4*c*3*c*2*c*1'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[*c*4 + P(*c*1*c*2*c*3)] -> *c*4*c*1*c*2*c*3,*c*4*c*1*c*3*c*2,*c*4*c*2*c*1*c*3,*c*4*c*2*c*3*c*1,*c*4*c*3*c*1*c*2,*c*4*c*3*c*2*c*1'
- en: 'We can continue to add another character and repeat this logic so that we have
    a recursive pattern that can be expressed in terms of code as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续添加另一个字符并重复此逻辑，以便我们有一个可以用代码表示的递归模式，如下所示：
- en: '[PRE16]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code will work fine. Because we use a `Set` (not a `List`), we respect
    the requirement stating that *the returned list of permutations should not contain
    duplicates*. However, we do generate duplicates. For example, if the given string
    is *aaa*, then we generate six identical permutations, even if there is only one.
    The only difference is that they are not added to the result since a `Set` doesn't
    accept duplicates. This is far from being efficient.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将正常工作。因为我们使用的是`Set`（而不是`List`），我们遵守了*返回的排列列表不应包含重复项*的要求。但是，我们确实生成了重复项。例如，如果给定的字符串是*aaa*，那么我们生成了六个相同的排列，即使只有一个。唯一的区别是它们没有被添加到结果中，因为`Set`不接受重复项。这远非高效。
- en: 'We can avoid generating duplicates in several ways. One approach starts by
    counting the characters of a string and storing them in a map. For example, for
    the given string *abcabcaa*,the key-value map can be *a*=4, *b*=2, and *c*=2\.
    We can do this via a simple helper method, as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过多种方式避免生成重复项。一种方法是通过计算字符串的字符数并将其存储在映射中。例如，对于给定的字符串*abcabcaa*，键值映射可以是*a*=4，*b*=2，*c*=2。我们可以通过一个简单的辅助方法来实现这一点，如下所示：
- en: '[PRE17]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we choose one of these characters as the first character and find all
    the permutations of the remaining characters. We can express this as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们选择其中一个字符作为第一个字符，并找到其余字符的所有排列。我们可以表示如下：
- en: P(*a=*4*,b=*2*,c=*2) *=* [*a +* P(*a=*3*,b=*2*,c=*2)] *+* [*b +* P(*a=*4*,b=*1*,c=*1)]
    *+* [*c +* P(*a=*4*,b=*2*,c=*1)]
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: P(*a=*4*,b=*2*,c=*2) *=* [*a +* P(*a=*3*,b=*2*,c=*2)] *+* [*b +* P(*a=*4*,b=*1*,c=*1)]
    *+* [*c +* P(*a=*4*,b=*2*,c=*1)]
- en: P(*a=*3*,b=*2*,c=*2) *=* [*a +* P(*a=*2*,b=*2*,c=*2)] *+* [*b +* P(*a=*3*,b=*1*,c=*1)]
    *+* [*c +* P(*a=*3*,b=*2*,c=*1)]
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: P(*a=*3*,b=*2*,c=*2) *=* [*a +* P(*a=*2*,b=*2*,c=*2)] *+* [*b +* P(*a=*3*,b=*1*,c=*1)]
    *+* [*c +* P(*a=*3*,b=*2*,c=*1)]
- en: P(*a=*4*,b=*1*,c=*1*) =* [*a +* P(*a=*3*,b=*1*,c=*1)] *+* [*b +* P(*a=*4*,b=*0*,c=*1)]
    *+* [*c +* P(*a=*4*,b=*1*,c=*0)]
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: P(*a=*4*,b=*1*,c=*1*) =* [*a +* P(*a=*3*,b=*1*,c=*1)] *+* [*b +* P(*a=*4*,b=*0*,c=*1)]
    *+* [*c +* P(*a=*4*,b=*1*,c=*0)]
- en: P(*a=*4*,b=*2*,c=*1*) =* [*a +* P(*a=*3*,b=*2*,c=*1)] *+* [*b +* P(*a=*4*,b=*1*,c=*1)]
    *+* [*c +* P(*a=*4*,b=*2*,c=*0)]
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: P(*a=*4*,b=*2*,c=*1*) =* [*a +* P(*a=*3*,b=*2*,c=*1)] *+* [*b +* P(*a=*4*,b=*1*,c=*1)]
    *+* [*c +* P(*a=*4*,b=*2*,c=*0)]
- en: P(*a=*2*,b=*2*,c=*2) *=* [*a +* P(*a=*1*,b=*2*,c=*2)] *+* [*b +* P(*a=*2*,b=*1*,c=*2)]
    *+* [*c +* P(*a=*2*,b=*2*,c=*1)]
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: P(*a=*2*,b=*2*,c=*2) *=* [*a +* P(*a=*1*,b=*2*,c=*2)] *+* [*b +* P(*a=*2*,b=*1*,c=*2)]
    *+* [*c +* P(*a=*2*,b=*2*,c=*1)]
- en: P(*a=*3*,b=*1*,c=*1) *= ...*
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: P（* a = * 3 *，b = * 1 *，c = * 1）* = ...*
- en: 'We can continue writing until there are no remaining characters. Now, it should
    be quite simple to put this into lines of code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续写，直到没有剩余字符。现在，将这些放入代码行应该相当简单：
- en: '[PRE18]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The complete application is called *Permutations*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*排列*。
- en: Coding challenge 11 – Knight tour
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战11 - 骑士之旅
- en: '**Amazon**, **Google**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**'
- en: '**Problem**: Consider a chessboard (an 8x8 grid). Place a knight on this board
    and print all its unique movements.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：考虑一个棋盘（8x8网格）。在这个棋盘上放一个骑士，并打印出它所有独特的移动。
- en: '**Solution**: As you''ve already seen, the best way to tackle such problems
    is to take a piece of paper and a pen and sketch the scenario. A picture is worth
    a thousand words:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：正如您已经看到的，解决这类问题的最佳方法是拿出一张纸和一支笔，勾画出情景。一幅图胜过千言万语：'
- en: '![Figure 8.14 – Knight tour'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.14 - 骑士之旅'
- en: '](img/Figure_8.14_B15403.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.14_B15403.jpg)'
- en: Figure 8.14 – Knight tour
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 - 骑士之旅
- en: As we can see, a knight can move from a (*r*, *c*) cell into a maximum of eight
    other valid cells; that is, (*r*+2, *c*+1), (*r*+1, *c*+2), (*r*-1,*c*+2), (*r*-2,
    *c*+1), (*r*-2, *c*-1), (*r*-1, *c*-2), (*r*+1, *c*-2), and (*r*+2, *c*-1). So,
    in order to obtain the path from 1 to 64 (as shown in the right-hand side of the
    preceding diagram), we can start from a given location and recursively try to
    visit each valid movement. If the current path doesn't represent a solution or
    we've tried all eight cells, then we backtrack.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，骑士可以从一个（*r*，*c*）单元格移动到最多八个其他有效单元格；也就是说，（*r*+2，*c*+1），（*r*+1，*c*+2），（*r*-1，*c*+2），（*r*-2，*c*+1），（*r*-2，*c*-1），（*r*-1，*c*-2），（*r*+1，*c*-2），和（*r*+2，*c*-1）。因此，为了获得从1到64的路径（如前图右侧所示），我们可以从给定位置开始，并递归地尝试访问每个有效的移动。如果当前路径不代表一个解决方案，或者我们已经尝试了所有八个单元格，那么我们就会回溯。
- en: 'To be as efficient as possible, we consider the following aspects:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能高效，我们考虑以下几个方面：
- en: 'We start from a corner of the chessboard: This way, the knight can initially
    go in only two directions instead of eight.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从棋盘的一个角开始：这样，骑士最初只能朝两个方向走，而不是八个。
- en: 'We check for valid cells in a fixed sequence: Maintaining a circular path will
    help us find a new move faster than picking one randomly. The counterclockwise
    circular path from (*r*, *c*) is (*r*+2, *c*+1), (*r*+1, *c*+2), (*r*-1, *c*+2),
    (*r*-2, *c*+1), (*r*-2, *c*-1), (*r*-1, *c*-2), (*r*+1, *c*-2), and (*r*+2, *c*-1).'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们按照固定顺序检查有效单元格：保持循环路径将帮助我们比随机选择更快地找到新的移动。从（*r*，*c*）的逆时针循环路径是（*r*+2，*c*+1），（*r*+1，*c*+2），（*r*-1，*c*+2），（*r*-2，*c*+1），（*r*-2，*c*-1），（*r*-1，*c*-2），（*r*+1，*c*-2），和（*r*+2，*c*-1）。
- en: 'We compute the circular path using two arrays: We can move from (*r*, *c*)
    to (*r* + *ROW*[*i*]*,c + COL*[*i*]) with *i* in [0, 7]:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用两个数组计算循环路径：我们可以从（*r*，*c*）移动到（*r* + *ROW*[*i*]，c + COL*[*i*]）其中*i*在[0, 7]：
- en: '*COL*[] = {1,2,2,1,-1,-2,-2,-1,1};'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*COL*[] = {1,2,2,1,-1,-2,-2,-1,1};'
- en: '*ROW*[] = {2,1,-1,-2,-2,-1,1,2,2};'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*ROW*[] = {2,1,-1,-2,-2,-1,1,2,2};'
- en: We avoid cycles in paths and duplicate work (for example, visiting the same
    cell multiple times) by storing the visited cells in an *r* x *c* matrix.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过在一个*r* x *c*矩阵中存储访问的单元格来避免路径中的循环和重复工作（例如，多次访问相同的单元格）。
- en: 'By gluing everything together in terms of code, we obtain the following recursive
    approach:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将所有内容粘合在代码方面，我们得到以下递归方法：
- en: '[PRE19]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The complete application is called *KnightTour*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*KnightTour*。
- en: Coding challenge 12 – Curly braces
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战12 - 大括号
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Print all the valid combinations of *n* pairs of curly braces.
    A valid combination is when the curly braces are properly opened and closed. For
    *n*=3, the valid combinations are as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：打印出*n*对大括号的所有有效组合。当大括号正确打开和关闭时，才是有效组合。对于*n*=3，有效组合如下：
- en: '{{{}}},{{}{}},{{}}{},{}{{}},{}{}{}'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '{{{}}},{{}{}},{{}}{},{}{{}},{}{}{}'
- en: '**Solution**: The valid combination for *n*=1 is {}.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：*n*=1的有效组合是{}。'
- en: For *n=2*, we immediately see the combination as {}{}. However, another combination
    consists of adding a pair of curly braces to the previous combination; that is,
    {{}}.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*n=2*，我们立即看到组合为{}{}。然而，另一个组合包括在前一个组合中添加一对大括号；也就是说，{{}}。
- en: Going one step further, for *n*=3, we have the trivial combination {}{}{}. Following
    the same logic, we can add a pair of curly braces to combinations for *n*=2, so
    we obtain {{{}}}, {{}}{}, {}{{}}, {{}{}}.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 再进一步，对于*n*=3，我们有平凡的组合{}{}{}。按照相同的逻辑，我们可以为*n*=2的组合添加一对大括号，因此我们得到{{{}}}, {{}}{},
    {}{{}}, {{}{}}。
- en: 'Actually, this is what we obtain after we remove or ignore duplicates. Let''s
    sketch the case for the *n*=3 build based on *n*=2, as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是我们在删除或忽略重复后得到的结果。让我们根据*n*=2来勾画*n*=3的情况，如下所示：
- en: '![Figure 8.15 – Curly braces duplicate pairs'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.15 - 大括号重复对'
- en: '](img/Figure_8.15_B15403.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.15_B15403.jpg)'
- en: Figure 8.15 – Curly braces duplicate pairs
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 - 大括号重复对
- en: So, if we add a pair of curly braces inside each existing pair of curly braces
    and we add the trivial case ({}{}...{}) as well, then we obtain a pattern that
    can be implemented via recursion. However, we have to deal with a significant
    number of duplicate pairs, so we need additional checks to avoid having duplicates
    in the final result.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们在每个现有的大括号中添加一对大括号，并且我们添加平凡的情况（{}{}...{}），那么我们就会得到一个可以通过递归实现的模式。然而，我们必须处理大量重复对，因此我们需要额外的检查来避免最终结果中出现重复。
- en: 'So, let''s consider another approach, starting with a simple observation. For
    any given *n*, a combination will have 2**n* curly braces (not pairs!). For example,
    for *n*=3, we have six curly braces (three left curly braces ({{{) and three right
    curly braces (}}})) arranged in different, valid combinations. This means that
    we can try to build the solution by starting with zero curly braces and add left/right
    curly braces to it, as long as we have a valid expression. Of course, we keep
    track of the number of added curly braces so that we don''t exceed the maximum
    number, 2**n.* The rules that we must follow are as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们考虑另一种方法，从一个简单的观察开始。对于任何给定的n，一个组合将有2**n个花括号（不是一对！）。例如，对于n=3，我们有六个花括号（三个左花括号（{{{）和三个右花括号（}}}}）以不同的有效组合排列。这意味着我们可以尝试通过从零花括号开始并向其添加左/右花括号来构建解决方案，只要我们有一个有效的表达式。当然，我们要跟踪添加的花括号的数量，以便不超过最大数量2**n。我们必须遵循的规则如下：
- en: We add all left curly braces in a recursive manner.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们以递归方式添加所有左花括号。
- en: We add the right curly braces in a recursive manner, as long as the number of
    right curly braces doesn't exceed the number of left curly braces.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们以递归方式添加右花括号，只要右花括号的数量不超过左花括号的数量。
- en: 'In other words, the key to this approach is to track the number of left and
    right curly braces that are allowed. As long as we have left curly braces, we
    insert a left curly brace and call the method again (recursion). If there are
    more right curly braces remaining than there are left curly braces, then we insert
    a right curly brace and call the method (recursion). So, let''s get coding:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这种方法的关键是跟踪允许的左花括号和右花括号的数量。只要我们有左花括号，我们就插入一个左花括号并再次调用该方法（递归）。如果剩下的右花括号比左花括号多，那么我们就插入一个右花括号并调用该方法（递归）。所以，让我们开始编码：
- en: '[PRE20]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The complete application is called *Braces*.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*Braces*。
- en: Coding challenge 13 – Staircase
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战13 - 楼梯
- en: '**Amazon**, **Adobe**, **Microsoft**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**Adobe**，**微软**'
- en: '**Problem**: A person walks up a staircase. They can hop either one step, two
    steps, or three steps at a time. Count the number of possible ways they can reach
    the top of the staircase.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：一个人走上楼梯。他们可以一次跳一步、两步或三步。计算他们可以到达楼梯顶部的可能方式的数量。'
- en: '**Solution**: First, let''s set what hopping one, two, or three steps means.
    Consider that hopping one step means to go up the staircase step by step (we land
    on each step). To hop two steps means to jump over a step and land on the next
    one. Finally, to hop three steps means to jump over two steps and land on the
    third one.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：首先，让我们设定一步、两步或三步跳的含义。考虑到一步跳意味着一步一步地上楼梯（我们每步都着陆）。跳两步意味着跳过一步并着陆在下一步。最后，跳三步意味着跳过两步并着陆在第三步。'
- en: 'For example, if we consider a staircase with three steps, then we can go from
    step 0 (or, no step) to step 3 in four ways: step by step (we land on each step),
    we jump over step 1 and land on step 2 and walk on step 3, we walk on step 1 and
    jump over step 2, thereby landing on step 3, or we jump directly on step 3, as
    shown in the following diagram:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们考虑一个有三个台阶的楼梯，那么我们可以以四种方式从第0步（或者，没有步骤）到第3步：一步一步（我们每步都着陆），我们跳过第1步并着陆在第2步上并走在第3步上，我们走在第1步上并跳过第2步，从而着陆在第3步上，或者我们直接跳到第3步，如下图所示：
- en: '![Figure 8.16 – Staircase (how to reach step 3)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.16 - 楼梯（如何到达第3步）'
- en: '](img/Figure_8.16_B15403.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.16_B15403.jpg)'
- en: Figure 8.16 – Staircase (how to reach step 3)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 - 楼梯（如何到达第3步）
- en: 'By going one step further in our logic, we may ask ourselves how to reach step
    *n*. Mainly, the *n*th step can be reached if we do the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进一步推理，我们可以问自己如何到达第n步。主要是，如果我们按照以下步骤，就可以到达第n步：
- en: '*n*-1 step and hop 1 step'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: n-1步和跳1步
- en: '*n*-2 step and hop 2 steps'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: n-2步和跳2步
- en: '*n*-3 step and hop 3 steps'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: n-3步和跳3步
- en: However, reaching any of these steps – *n-*1, *n-*2, or *n-*3 – is possible
    if we follow the preceding bullets. For example, we can reach the *n-*1 step if
    we are on *n-*2 and hop 1 step, we are on *n-*3step and hop 2 steps, or we are
    on *n-*4 step and hop 3 steps.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只要我们遵循前面的要点，就可以到达这些步骤中的任何一个 - n-1、n-2或n-3。例如，如果我们在n-2上并跳1步，我们在n-3上并跳2步，或者我们在n-4上并跳3步，我们就可以到达n-1步。
- en: So, to reach the *n*th step, we have three possible paths. To reach step *n*-1th,
    we also have three possible paths. So, to reach both steps, we must have 3+3=6
    paths. Do not say 3*3=9 paths! This is wrong!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要达到第n步，我们有三条可能的路径。要达到第n-1步，我们也有三条可能的路径。因此，要达到这两个步骤，我们必须有3+3=6条路径。不要说3*3=9条路径！这是错误的！
- en: 'Now, we can conclude that adding all the paths in a recursive manner should
    give us the expected answers. Moreover, we can use our experience to add *Memoization*
    as well. This way, we avoid calling the method with the same inputs many times
    (exactly as in the case of the Fibonacci numbers):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以得出结论，以递归方式添加所有路径应该给我们预期的答案。此外，我们还可以利用我们的经验来添加*记忆化*。这样，我们就避免了多次使用相同输入调用该方法（就像斐波那契数的情况一样）：
- en: '[PRE21]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The complete application is called *Staircase*. It also contains the plain recursion
    approach (without *Memoization*).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*Staircase*。它还包含了纯递归方法（没有*记忆化*）。
- en: Coding challenge 14 – Subset sum
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战14 - 子集和
- en: '**Amazon**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider a given set (*arr*) of positive integers and a value,
    *s*. Write a snippet of code that finds out if there is a subset in this array
    whose sum is equal to the given *s*.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个给定的正整数集合（*arr*）和一个值*s*。编写一小段代码，找出数组中是否存在一个子集，其总和等于给定的*s*。'
- en: '**Solution**: Let''s consider the array, *arr* = {3, 2, 7, 4, 5, 1, 6, 7, 9}.
    If *s*=7, then a subset can contain the elements 2, 4, and 1, as shown in the
    following diagram:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们考虑数组*arr* = {3, 2, 7, 4, 5, 1, 6, 7, 9}。如果*s*=7，那么一个子集可以包含元素2、4和1，如下图所示：'
- en: '![Figure 8.17 – Subset of sum 7'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.17 - 和为7的子集'
- en: '](img/Figure_8.17_B15403.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.17_B15403.jpg)'
- en: Figure 8.17 – Subset of sum 7
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17 - 和为7的子集
- en: The subset containing the elements 2, 4, and 1 is just one of the possible subsets.
    All possible subsets include (3, 4), (2, 4, 1), (2, 5), (7), (1, 6), and (7).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 包含元素2、4和1的子集只是可能子集中的一个。所有可能的子集包括（3, 4）、（2, 4, 1）、（2, 5）、（7）、（1, 6）和（7）。
- en: Recursive approach
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归方法
- en: Let's try to find a solution via recursion. If we add the subset *arr*[0]=3,
    then we have to find the subset for *s* = *s-arr*[0] = 7-3 = 4\. Finding a subset
    for *s*=4 is a sub-problem that can be solved based on the same logic, which means
    we can add *arr*[1]=2 in the subset, and the next sub-problem will consist of
    finding the subset for *s* = *s*-*arr*[1] = 4-2 = 2.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过递归找到一个解决方案。如果我们添加子集*arr*[0]=3，那么我们必须找到和为*s* = *s-arr*[0] = 7-3 = 4的子集。找到和为*s*=4的子集是一个可以基于相同逻辑解决的子问题，这意味着我们可以将*arr*[1]=2添加到子集中，下一个子问题将包括找到和为*s*
    = *s*-*arr*[1] = 4-2 = 2的子集。
- en: 'Alternatively, we can think like this: start with *sum*=0\. We add *arr*[0]=3
    to this *sum* as *sum*=*sum+arr*[0] = 3\. Next, we check if *sum* = *s* (for example,
    if 3 = 7). If so, we found a subset. If not, we add the next element, *arr*[1]=2,
    to the *sum* as *sum = sum+arr*[1] = 3+2 =5\. We recursively continue to repeat
    this process until there are no more elements to add. At this point, we recursively
    remove elements from *sum* and check if *sum = s* upon each removal. In other
    words, we build every possible subset and check if its *sum* is equal to *s*.
    When we have this equality, we print the current subset.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以这样思考：从*sum*=0开始。我们将*arr*[0]=3加到这个*sum*上，得到*sum*=*sum+arr*[0] = 3。接下来，我们检查*sum*
    = *s*（例如，如果3 = 7）。如果是，我们找到了一个子集。如果不是，我们将下一个元素*arr*[1]=2加到*sum*上，得到*sum = sum+arr*[1]
    = 3+2 =5。我们递归地继续重复这个过程，直到没有更多的元素可以添加。在这一点上，我们递归地从*sum*中移除元素，并在每次移除时检查*sum = s*。换句话说，我们构建了每个可能的子集，并检查它的*sum*是否等于*s*。当我们有这个相等时，我们打印当前的子集。
- en: 'So far, it is clear that if we recursively solve each and every sub-problem,
    then it will lead us to the result. For each element from *arr* we must make a
    decision. Mainly, we have two options: include the current element in the subset
    or not include it. Starting from these statements, we can create the following
    algorithm:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，很明显，如果我们递归地解决每一个子问题，那么它会引导我们得到结果。对于*arr*中的每个元素，我们必须做出一个决定。主要的是，我们有两个选择：将当前元素包含在子集中或者不包含它。基于这些陈述，我们可以创建以下算法：
- en: Define a subset as an array of the same length as the given *arr*. This array
    takes only values of 1 and 0.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将子集定义为与给定*arr*长度相同的数组。这个数组只取值1和0。
- en: Recursively add each element from *arr* to the subset by setting a value of
    1 at that particular index. Check for the solution (*current sum = given sum)*.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在*arr*中递归地添加每个元素到子集中，将该特定索引处的值设置为1。检查解决方案（*当前和=给定和*）。
- en: Recursively remove each element from the subset by setting a value of 0 at that
    particular index. Check for the solution (*current sum = given sum*).
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在特定索引处将子集中的每个元素递归地移除，将该值设置为0。检查解决方案（*当前和=给定和*）。
- en: 'Let''s see the code:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE22]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The time complexity of this code is O(n2n), so it's far from being efficient.
    Now, let's try an iterative approach via Dynamic Programming. This way, we avoid
    solving the same problem repeatedly.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的时间复杂度是O(n2n)，因此远非高效。现在，让我们尝试通过动态规划的迭代方法。这样，我们就避免了重复解决同一个问题。
- en: Dynamic Programming approach
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态规划方法
- en: Via Dynamic Programming, we can solve this problem in O(s*n). More precisely,
    we can rely on the *Bottom-Up* approach and a `boolean` bidimensional matrix of
    dimension (*n*+1) x (*s*+1), where *n* is the size of the set (*arr*).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 通过动态规划，我们可以在O(s*n)的时间内解决这个问题。更确切地说，我们可以依赖*自底向上*的方法和一个维度为(*n*+1) x (*s*+1)的`boolean`二维矩阵，其中*n*是集合*arr*的大小。
- en: 'To understand this implementation, you have to understand how this matrix is
    filled up and how it is read. If we consider that the given *arr* is {5, 1, 6,
    10, 7, 11, 2} and *s*=9, then this `boolean` matrix starts from an initial state,
    as shown in the following diagram:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个实现，你必须理解这个矩阵是如何填充和读取的。如果我们考虑给定的*arr*是{5, 1, 6, 10, 7, 11, 2}，*s*=9，那么这个`boolean`矩阵从一个初始状态开始，如下图所示：
- en: '![Figure 8.18 – Initial matrix'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.18 – 初始矩阵'
- en: '](img/Figure_8.18_B15403.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.18_B15403.jpg)'
- en: Figure 8.18 – Initial matrix
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18 – 初始矩阵
- en: 'So, we have *s*+1 = 9+1 = 10 columns and *n*+1 = 7+1 = 8 rows. As you can see,
    we have filled up row and column 0\. These are the *base cases* and can be interpreted
    as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有*s*+1 = 9+1 = 10列和*n*+1 = 7+1 = 8行。你可以看到，我们已经填满了第0行和第0列。这些是*基本情况*，可以解释如下：
- en: Initialize the first row (row 0) of the matrix (*matrix*[0][]) with 0 (or `false`,
    F) except *matrix*[0][0], which is initialized with 1 (or `true`, T). In other
    words, if the given sum is not 0, then there is no subset to satisfy this sum.
    However, if the given sum is 0, then there is a subset containing only 0\. So,
    the subset containing a 0 can form a single sum equal to 0.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化矩阵的第一行（row 0）（*matrix*[0][]）为0（或`false`，F），除了*matrix*[0][0]，它初始化为1（或`true`，T）。换句话说，如果给定的和不是0，那么就没有子集可以满足这个和。然而，如果给定的和是0，那么就有一个只包含0的子集。因此，包含0的子集可以形成一个和为0的单一子集。
- en: Initialize the first column (column 0) of matrix (*matrix*[][0]) with 1 (or
    `true`, T) because, for any set, a subset is possible with 0 sum.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将矩阵的第一列（column 0）（*matrix*[][0]）初始化为1（或`true`，T），因为对于任何集合，都可以有一个和为0的子集。
- en: 'Next, we take each row (5, 1, 6, ...) and we try to fill it up with F or T.
    Let''s consider the second row, which contains the element 5\. Now, for each column,
    let''s answer the following question: can we form a sum of *column number* with
    a 5? Let''s see the output:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们取每一行（5, 1, 6, ...）并尝试用F或T填充它。让我们考虑包含元素5的第二行。现在，对于每一列，让我们回答以下问题：我们能用5形成和为*列号*的子集吗？让我们看一下输出：
- en: '![Figure 8.19 – Filling up the second row'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.19 – 填充第二行'
- en: '](img/Figure_8.19_B15403.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.19_B15403.jpg)'
- en: Figure 8.19 – Filling up the second row
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19 – 填充第二行
- en: Can we form a sum of 1 with a 5? No, so false (F).
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能用5形成和为1的子集吗？不能，所以是false（F）。
- en: Can we form a sum of 2 with a 5? No, so false (F).
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能用5形成和为2的子集吗？不能，所以是false（F）。
- en: '...'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: Can we form a sum of 5 with a 5? Yes, so true (T).
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能用5形成和为5的子集吗？能，所以是true（T）。
- en: Can we form a sum of 6 with a 5? No, so false (F).
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能够用5组成和为6的子集吗？不行，所以为假（F）。
- en: '...'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: Can we form a sum of 9 with a 5? No, so false (F).
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能够用5组成和为9的子集吗？不行，所以为假（F）。
- en: 'We can try to apply this question to each of the remaining rows, but the more
    we advance, the harder it will be. Moreover, we cannot implement this question
    in code without an algorithm. Fortunately, we can employ an algorithm that can
    be applied to each (*row, column*) cell. This algorithm contains the following
    steps:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试将这个问题应用到剩下的每一行，但是我们前进得越多，问题就会变得越困难。此外，我们没有算法无法在代码中实现这个问题。幸运的是，我们可以使用一个可以应用于每个（*row,
    column*）单元格的算法。这个算法包含以下步骤：
- en: While the element of the current row (*i*) is greater than the value of the
    current column (*j*), we just copy the preceding value (*i*-1, *j*), in the current
    (*i, j*) cell.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当当前行（*i*）的元素大于当前列（*j*）的值时，我们只需复制前一个值（*i*-1, *j*），填入当前的（*i, j*）单元格中。
- en: 'If the element of the current row (*i*) is smaller than or equal to the value
    of the current column (*j*), then we look to the (*i*-1, *j*) cell and do the
    following:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前行（*i*）的元素小于或等于当前列（*j*）的值，则我们查看（*i*-1, *j*）单元格，并执行以下操作：
- en: a. If cell (*i*-1, *j*) is T, then we fill up the (*i, j*) cell with T as well.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: a. 如果单元格（*i*-1, *j*）是T，则我们也在（*i, j*）单元格中填入T。
- en: b. If cell (*i*-1, *j*) is F, then we fill up the (*i, j*) cell with the value
    at (*i*-1, *j-element_at_this_row*).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: b. 如果单元格（*i*-1, *j*）是F，则我们在（*i, j*）单元格中填入（*i*-1, *j-element_at_this_row*）的值。
- en: 'If we apply this algorithm to the second row (containing the element 5), then
    we obtain the same result shown in the following diagram:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个算法应用于第二行（包含元素5），那么我们将得到以下图表中显示的相同结果：
- en: '![Figure 8.20 – Applying the algorithm to the second row'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.20 – 将算法应用于第二行'
- en: '](img/Figure_8.20_B15403.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.20_B15403.jpg)'
- en: Figure 8.20 – Applying the algorithm to the second row
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20 – 将算法应用于第二行
- en: Conforming to *step 1*, for 5 < 1, 5 < 2, 5 < 3, and 5 < 4, we copy the value
    from the preceding cell. When we reach cell (1, 5), we have 5=5, so we need to
    apply *step 2*. More precisely, we apply *step 2b*. The cell (1-1, 5-5) is the
    cell (0, 0) that has the value T. So, the cell (1, 5) is filled up with T. The
    same logic applies to the remaining cells. For example, cell (1, 6) is filled
    up with F since F is the value at (0, 5); the cell at (1, 7) is filled up with
    F since F is the value at (0, 6), and so on.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*步骤1*，对于5 < 1，5 < 2，5 < 3和5 < 4，我们复制前一个单元格的值。当我们到达单元格（1, 5）时，我们有5=5，所以我们需要应用*步骤2*。更确切地说，我们应用*步骤2b*。单元格（1-1,
    5-5）是单元格（0, 0），其值为T。因此，单元格（1, 5）被填入T。相同的逻辑适用于其余的单元格。例如，单元格（1, 6）被填入F，因为F是（0, 5）的值；单元格（1,
    7）被填入F，因为F是（0, 6）的值，依此类推。
- en: 'If we apply this algorithm to all the rows, then we obtain the following filled
    matrix:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个算法应用于所有行，那么我们将得到以下填充的矩阵：
- en: '![Figure 8.21 – Complete matrix'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.21 – 完整矩阵'
- en: '](img/Figure_8.21_B15403.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.21_B15403.jpg)'
- en: Figure 8.21 – Complete matrix
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 – 完整矩阵
- en: Notice that we highlighted the last cell at (7, 9). If the right-bottom cell
    has the value T, then we say that there is at least a subset that satisfies the
    given sum. If it is F, then there is no such subset.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们突出显示了最后一个单元格（7, 9）。如果右下角的单元格的值为T，则表示至少存在一个满足给定和的子集。如果为F，则表示没有这样的子集。
- en: 'So, in this case, there is a subset whose sum is equal to 9\. Can we identify
    it? Yes, we can, via the following algorithm:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，存在一个子集，其和等于9。我们能够识别它吗？是的，我们可以，通过以下算法：
- en: Start from the right-bottom cell, which is T (let's say that this cell is at
    (*i*, *j*)).
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从右下角的单元格开始，即T（假设这个单元格是（*i*, *j*））。
- en: a. If the cell above this one, (*i*-1, *j*), is F, then write down the element
    at this row (this element is part of the subset) and go to cell (*i*-1, *j*-*element_at_this_row*).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: a. 如果这个单元格上面的单元格（*i*-1, *j*）是F，则写下这一行的元素（这个元素是子集的一部分），并前往单元格（*i*-1, *j*-*element_at_this_row*）。
- en: b. While the cell above this one, (*i*-1, *j*), is T, we go up the cell (*i*-1,
    *j*).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: b. 当上方的单元格（*i*-1, *j*）是T时，我们向上移动到单元格（*i*-1, *j*）。
- en: c. Repeat this from *step 1a* until the entire subset is written down.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: c. 重复*步骤1a*，直到整个子集都被写下。
- en: 'Let'' s draw the path of the subset in our case:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们画出我们这种情况下的子集路径：
- en: '![Figure 8.22 – Subset solution path'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.22 – 子集解决路径'
- en: '](img/Figure_8.22_B15403.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.22_B15403.jpg)'
- en: Figure 8.22 – Subset solution path
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22 – 子集解决路径
- en: So, we start from the bottom-right cell, which is at (7, 9) and has the value
    T. Because this cell is T, we can attempt to find the subset that has the sum
    9\. Next, we apply *step 1a*, so we write down the element at row 7 (which is
    2) and go to cell (7-1, 9-2) = (6, 7). So far, the subset is {2}.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们从右下角的单元格开始，即（7, 9），其值为T。因为这个单元格是T，我们可以尝试找到和为9的子集。接下来，我们应用*步骤1a*，所以我们写下第7行的元素（即2），并前往单元格（7-1,
    9-2）=（6, 7）。到目前为止，子集为{2}。
- en: Next, we apply *step 1b*, so we land in cell (3, 7). The cell above (3, 7) has
    the value F, so we apply *step 1a*. First, we write down the element at row 3,
    which is 6\. Then, we go to cell (3-1, 7-6) = (2, 1). So far, the subset is {2,
    6}.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应用*步骤1b*，所以我们来到单元格（3, 7）。单元格上方的单元格（3, 7）的值为F，所以我们应用*步骤1a*。首先，我们写下第3行的元素，即6。然后，我们前往单元格（3-1,
    7-6）=（2, 1）。到目前为止，子集为{2, 6}。
- en: The cell above (2, 1) has the value F, so we apply *step 1a*. First, we write
    down the element at row 2, which is 1\. Then, we go to cell (2-1, 1-1) = (1, 0).
    Above cell (1,0), we have only T, so we stop. The current and final subset is
    {2, 6, 1}. Obviously, 2+6+1 = 9.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 上方的单元格（2, 1）的值为F，所以我们应用*步骤1a*。首先，我们写下第2行的元素，即1。然后，我们前往单元格（2-1, 1-1）=（1, 0）。在（1,0）单元格上方，我们只有T，所以我们停止。当前和最终的子集为{2,
    6, 1}。显然，2+6+1=9。
- en: 'The following code will clarify any other details (this code can tell if the
    given sum at least has a corresponding subset):'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将澄清任何其他细节（这段代码可以告诉我们给定的和至少有一个对应的子集）：
- en: '[PRE23]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `printSubsetMatrix()` and `printOneSubset()` methods can be found in the
    complete code named *SubsetSum*.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`printSubsetMatrix()`和`printOneSubset()`方法可以在名为*SubsetSum*的完整代码中找到。'
- en: Coding challenge 15 – Word break (this is a famous Google problem)
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战15 – 单词拆分（这是一个著名的谷歌问题）
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '`true` if the given string (*str*) can be segmented into a space-separated
    sequence of dictionary words.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的字符串（*str*）可以分割成一个以空格分隔的字典单词序列，则返回`true`。
- en: '**Solution**: This problem is common to Google and Amazon and at the time of
    writing, it is adopted by a lot of medium-large companies. If we type a string
    that doesn''t make sense into Google, then Google attempts to break it down into
    words and asks us if that is what we actually tried to type. For example, if we
    type "thisisafamousproblem", then Google will ask us if we wanted to type "this
    is a famous problem".'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：这个问题在谷歌和亚马逊中很常见，在撰写本文时，它被许多中大型公司采用。如果我们在谷歌中输入一个毫无意义的字符串，那么谷歌会尝试将其分解为单词，并问我们是否这实际上是我们想要输入的。例如，如果我们输入"thisisafamousproblem"，那么谷歌会问我们是否想要输入"this
    is a famous problem"。'
- en: Plain recursion-based solution
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于纯递归的解决方案
- en: So, if we assume that the given string is *str*`="`thisisafamousproblem" and
    the given dictionary is `{`"this" "is" "a" "famous" "problem"`}`, then we can
    form the result; that is,"this is a famous problem".
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们假设给定的字符串是*str*`="`thisisafamousproblem"，给定的字典是`{`"this" "is" "a" "famous"
    "problem"`}`，那么我们可以得到结果；即"this is a famous problem"。
- en: So, how can we obtain this? How can we check if the given string can be segmented
    into a space-separated sequence of dictionary words?
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何做到这一点呢？我们如何检查给定的字符串是否可以分割成一个以空格分隔的字典单词序列？
- en: Let's start with an observation. If we start from the first character of the
    given string, then we notice that "t" is not a word in the given dictionary. We
    can continue by appending the second character to "t", so we get "th". Since "th"
    is not a word in the given dictionary, we can append the third character, "i".
    Obviously, "thi" is not a word in the dictionary, so we append the fourth character,
    "s". This time, we found a word because "this" is a word in the dictionary. This
    word becomes part of the result.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个观察开始。如果我们从给定字符串的第一个字符开始，那么我们会注意到"t"不是给定字典中的一个单词。我们可以继续将第二个字符附加到"t"，这样我们得到"th"。由于"th"不是给定字典中的一个单词，我们可以附加第三个字符"i"。显然，"thi"不是字典中的一个单词，所以我们附加第四个字符"s"。这一次，我们找到了一个单词，因为"this"是字典中的一个单词。这个单词成为结果的一部分。
- en: Taking this logic further, if we found "this", then the initial problem is reduced
    to a smaller problem that consists of finding the remaining words. So, by appending
    every character, the problem reduces to a smaller problem but essentially remains
    the same. This sounds like an ideal case for a recursive implementation.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步推理，如果我们找到了"this"，那么最初的问题就被减小为一个更小的问题，即找到剩下的单词。因此，通过添加每个字符，问题就会减小为一个更小的问题，但本质上仍然是相同的。这听起来像是递归实现的理想案例。
- en: 'If we elaborate on the recursive algorithm, then we have the following steps
    that we must perform:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们详细说明递归算法，那么我们必须执行以下步骤：
- en: Iterate the given string, *str*, from the first character (*index* 0).
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第一个字符（*索引*0）开始迭代给定字符串*str*。
- en: Take each substring from the given string (by substring, we understand substring
    from *index* to 1, substring from *index* to 2, ...substring from *index* to *str.length*).
    In other words, as long as the current substring is not a word in the given dictionary,
    we continue to add a character from the given string, *str*.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从给定字符串（通过子字符串，我们理解为从*索引*到1的子字符串，从*索引*到2的子字符串，...从*索引*到*str.length*的子字符串）中取出每个子字符串。换句话说，只要当前子字符串不是给定字典中的一个单词，我们就继续从给定字符串*str*中添加一个字符。
- en: If the current substring is a word in the given dictionary, then we update the
    index so that it's the length of this substring and rely on recursion by checking
    the remaining string from *index* to *str.length*.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前子字符串是给定字典中的一个单词，那么我们更新索引，使其成为这个子字符串的长度，并依靠递归来检查从*索引*到*str.length*的剩余字符串。
- en: If *index* reaches the length of the string, we return `true`; otherwise, we
    return `false`.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*索引*达到字符串的长度，我们返回`true`；否则，我们返回`false`。
- en: 'The code for this is as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码如下：
- en: '[PRE24]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There is no surprise that the runtime of this code is exponential. Now, it is
    time to deploy Dynamic Programming.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间并不奇怪是指数级的。现在，是时候部署动态规划了。
- en: Bottom-up solution
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自底向上的解决方案
- en: 'We can avoid recursion and deploy Dynamic Programming instead. More precisely,
    we can use the *Bottom-Up* solution shown here:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以避免递归，而是部署动态规划。更确切地说，我们可以使用这里显示的*自底向上*解决方案：
- en: '[PRE25]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code still runs in exponential time O(n2).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码仍然以指数时间O(n2)运行。
- en: Trie-based solution
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Trie的解决方案
- en: 'The most efficient solution to solve this problem relies on Dynamic Programming
    and the Trie data structure since it provides the best time complexity. You can
    find a detailed implementation of the Trie data structure in the book *Java Coding
    Problems*: ([https://www.amazon.com/gp/product/B07Y9BPV4W/](https://www.amazon.com/gp/product/B07Y9BPV4W/)).'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最有效方法依赖于动态规划和Trie数据结构，因为它提供了最佳的时间复杂度。您可以在书籍*Java编程问题*中找到Trie数据结构的详细实现：([https://www.amazon.com/gp/product/B07Y9BPV4W/](https://www.amazon.com/gp/product/B07Y9BPV4W/))。
- en: Let's consider the problem of breaking a given string into a set of components
    representing its words. If *p* is a prefix of *str* and *q* is the suffix of *str*
    (the remaining characters), then *pq* is *str* (the concatenation of *p* with
    *q* is *str*). And, if we can break *p* and *q* into words via recursion, then
    we can break *pq = str* by merging the two sets of words.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑将给定字符串分解为表示其单词的一组组件的问题。如果*p*是*str*的前缀，*q*是*str*的后缀（剩余的字符），那么*pq*就是*str*（*p*与*q*的连接就是*str*）。如果我们可以通过递归将*p*和*q*分解为单词，那么我们可以通过合并两组单词来分解*pq=str*。
- en: 'Now, let''s continue this logic in the context of a Trie representing the given
    dictionary of words. We can assume that *p* is a word from the dictionary, and
    we must find a way to construct it. This is exactly where the Trie comes in. Because
    *p* is considered a word from the dictionary and *p* is a prefix of *str*, we
    can say that *p* must be found in the Trie via a path consisting of the first
    few letters of *str*. To accomplish this via Dynamic Programming, we use an array,
    let''s denote it as *table*. Every time we find an appropriate *q*, we signal
    it in the *table* array by setting a solution at |*p*| + 1, where |*p*| is the
    length of the prefix, *p*. This means that we can continue by checking the last
    entry to determine if the whole string can be broken up. Let''s see the code for
    this:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在给定单词字典的Trie的上下文中继续这种逻辑。我们可以假设*p*是字典中的一个单词，我们必须找到一种构造它的方法。这正是Trie派上用场的地方。因为*p*被认为是字典中的一个单词，*p*是*str*的前缀，我们可以说*p*必须通过由*str*的前几个字母组成的路径在Trie中找到。为了通过动态规划实现这一点，我们使用一个数组，让我们将其表示为*table*。每当我们找到一个合适的*q*时，我们通过在*table*数组中设置一个解决方案来表示它，解决方案在|*p*|+1处，其中|*p*|是前缀*p*的长度。这意味着我们可以通过检查最后一个条目来确定整个字符串是否可以被分解。让我们看看这段代码：
- en: '[PRE26]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Apparently, because we have two nested loops, the runtime of this solution is
    O(n2). Actually, the inner loop breaks if the node is `null`. And, in the worst-case
    scenario, this happens after *k* steps, where *k* is the deepest path in the Trie.
    So, for a dictionary that contains the longest word of size *z*, we have *k*=*z*+1\.
    This means that the time complexity of the inner loop is O(z) and that the total
    time complexity is O(nz). The extra space is O(*space of the Trie + str.length*).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，因为我们有两个嵌套循环，所以这个解决方案的运行时间是O(n2)。实际上，内部循环在节点为`null`时会中断。在最坏的情况下，这发生在*k*步之后，其中*k*是Trie中最深路径。因此，对于包含大小为*z*的最长单词的字典，我们有*k*=*z*+1。这意味着内部循环的时间复杂度是O(z)，总时间复杂度是O(nz)。额外空间是O(*Trie的空间+str.length*)。
- en: 'The complete application is called *WordBreak*. This application also contains
    a method that prints all the strings that can be generated for the given string.
    For example, if the given string is "thisisafamousproblem" and the dictionary
    is `{"`this", "th", "is", "a", "famous", "f", "a", "m", "o", "u", "s", "problem"`}`,
    then the output will contain four sequences:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*WordBreak*。该应用程序还包含一个打印可以为给定字符串生成的所有字符串的方法。例如，如果给定的字符串是"thisisafamousproblem"，字典是`{"`this",
    "th", "is", "a", "famous", "f", "a", "m", "o", "u", "s", "problem"`}`，那么输出将包含四个序列：
- en: th is is a f a m o u s problem
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个著名的问题
- en: th is is a famous problem
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个著名的问题
- en: this is a f a m o u s problem
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个著名的问题
- en: this is a famous problem
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个著名的问题
- en: Done! Now, it's time to summarize this chapter.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在是时候总结本章了。
- en: Summary
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we covered one of the most popular topics in interviews: recursion
    and Dynamic Programming. Mastering this topic requires a lot of practice. Fortunately,
    this chapter provided a comprehensive set of problems that covered the most common
    recursive patterns. From permutations to grid-based problems, from classical problems
    such as Tower of Hanoi to tricky problems such as generating curly braces, this
    chapter has covered a wide range of recursive cases.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了面试中最流行的话题之一：递归和动态规划。掌握这个话题需要大量的练习。幸运的是，本章提供了一套全面的问题，涵盖了最常见的递归模式。从排列到基于网格的问题，从经典问题如汉诺塔到棘手的问题如生成花括号，本章涵盖了广泛的递归案例。
- en: Don't forget that the key to solving recursive problems consists of drawing
    a meaningful sketch and practicing several cases. This way, you can identify patterns
    and recursive calls.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记解决递归问题的关键在于绘制有意义的草图并练习多种情况。这样，您可以识别模式和递归调用。
- en: In the next chapter, we will discuss problems that require bit manipulation.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论需要位操作的问题。
