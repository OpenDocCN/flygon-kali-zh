- en: Code Analyzers in Visual Studio
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio中的代码分析器
- en: 'In this chapter we will take a look at code analyzers and how they can assist
    developers to write better code. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一下代码分析器以及它们如何帮助开发人员编写更好的代码。我们将涵盖以下主题：
- en: Finding and installing analyzers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找并安装分析器
- en: Creating a code analyzer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建代码分析器
- en: Creating a custom code analyzer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义代码分析器
- en: Deploying your code analyzer within your organization only
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在您的组织内部部署您的代码分析器
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: With effect from Visual Studio 2015, developers have had the ability to create
    custom code analyzers that are specific to their project or their development
    team. Some development teams have a set of standards that they need to adhere
    to. Perhaps you are an indie developer and you would like to make your code conform
    to certain best practices. It doesn't really matter what your reason is; code
    analyzers open doors for developers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从Visual Studio 2015开始，开发人员可以创建特定于其项目或开发团队的自定义代码分析器。一些开发团队有一套需要遵守的标准。也许您是独立开发人员，希望使您的代码符合某些最佳实践。无论您的原因是什么，代码分析器都为开发人员打开了大门。
- en: You can be sure that the code you or your team ships measures up to your specific
    set of code quality standards. There are several code analyzers that can be downloaded
    from GitHub. We will be looking at one of those called CodeCracker for C#.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以确保您或您的团队发布的代码符合特定的代码质量标准。可以从GitHub下载几个代码分析器。我们将看一下其中一个名为CodeCracker for C#的代码分析器。
- en: Finding and installing analyzers
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找并安装分析器
- en: There are quite a few code analyzers on GitHub. A quick search returns 28 possible
    C# code analyzers out of 72 repository results. A few of these seem to be student
    projects. Check those out too; there is some very clever code in some of them.
    As for this recipe, we will be working with CodeCracker for C# to demonstrate
    how to install an analyzer from a NuGet package.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub上有很多代码分析器。快速搜索返回了72个存储库结果中的28个可能的C#代码分析器。其中一些似乎是学生项目。也检查一下这些；其中一些代码非常聪明。至于这个示例，我们将使用CodeCracker
    for C#来演示如何从NuGet包中安装分析器。
- en: '![](img/B06434_04_23.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_23.png)'
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: All that you will be doing is downloading a NuGet package for your project.
    Other than that, there is nothing you specifically need to do in order to get
    ready.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您要做的就是为项目下载一个NuGet包。除此之外，您无需做任何特别的准备。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Start off by creating a new console application. You can call it whatever you
    like. In my example, I simply called it `DiagAnalyzerDemo`.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个新的控制台应用程序。您可以随意命名。在我的示例中，我只是称它为“DiagAnalyzerDemo”。
- en: '![](img/B06434_04_01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_01.png)'
- en: From the Tools menu, select NuGet Package Manager and then Manage NuGet Packages
    for Solution....
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“工具”菜单中，选择NuGet包管理器，然后选择“解决方案的NuGet包管理器”。
- en: In the Browse tab, search for `Code-Cracker`. The results should return the
    codecracker.CSharp NuGet package. Check the project you want to apply the NuGet
    package to and click on the Install button.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“浏览”选项卡中，搜索“Code-Cracker”。结果应返回codecracker.CSharp NuGet包。选择要应用NuGet包的项目，然后单击“安装”按钮。
- en: '![](img/B06434_04_03.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_03.png)'
- en: Visual Studio will allow you to review the changes that are about to be made.
    Click on the OK button to continue.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio将允许您查看即将进行的更改。单击“确定”按钮继续。
- en: Click on I Accept when the license terms are displayed.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在显示许可条款时，单击“接受”。
- en: When the NuGet package is installed, the results will be displayed in the Output
    window.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装NuGet包后，结果将显示在“输出”窗口中。
- en: Looking at your project you will notice that the CodeCracker.CSharp analyzer
    has been added under the Analyzers node in your Solution Explorer.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看您的项目，您会注意到CodeCracker.CSharp分析器已添加到解决方案资源管理器中的“分析器”节点下。
- en: '![](img/B06434_04_07.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_07.png)'
- en: If you expand the CodeCracker.CSharp analyzer, you will see all the individual
    analyzers included in the NuGet package.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果展开CodeCracker.CSharp分析器，您将看到NuGet包中包含的所有单独的分析器。
- en: '![](img/B06434_04_08.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_08.png)'
- en: There is however a better place to review these analyzers from. From the Project
    menu, go to the `[project name]` properties menu item. In my case this is DiagAnalyzerDemo
    Properties....
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，有一个更好的地方可以查看这些分析器。从“项目”菜单中，转到“[项目名称]”属性菜单项。在我的情况下，这是DiagAnalyzerDemo属性....
- en: Click on the Open button to open the rule set.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“打开”按钮打开规则集。
- en: '![](img/B06434_04_10.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_10.png)'
- en: Here you will see a collection of all the analyzers available; from this screen,
    you can modify the action of specific analyzers.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，您将看到所有可用的分析器集合；从此屏幕，您可以修改特定分析器的操作。
- en: '![](img/B06434_04_11.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_11.png)'
- en: In your code, add the following class. You can call it whatever you like, but
    for simplicity's sake use the following example. You will see that I have a constructor
    that sets a property called `DimensionWHL`. This property just returns an array
    with the `width`, `height`, and `length` values. Not very nice code indeed.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码中，添加以下类。您可以随意命名，但为简单起见，请使用以下示例。您将看到我有一个构造函数，设置了一个名为“DimensionWHL”的属性。此属性只返回一个包含“宽度”、“高度”和“长度”值的数组。确实不是很好的代码。
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Return back to the analyzers screen and search for the word `properties`. You
    will see an analyzer returned called CA1819, which specifies that a property should
    never return an array. The Action is changed to Warning, but you can change this
    to Error should you wish by clicking on the word Warning under the Action column
    and selecting Error.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到分析器屏幕并搜索单词“属性”。您将看到一个名为CA1819的分析器，指定属性永远不应返回数组。操作更改为警告，但如果愿意，可以通过单击“操作”列下的“警告”单词并选择“错误”来更改为错误。
- en: '![](img/B06434_04_12-1.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_12-1.png)'
- en: Save the changes and go and build your console application. You will see that
    the warning for the code analyzer CA1819 is displayed in the Error List. If you
    had changed the action to Error, the build would have broken with that error.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改并构建您的控制台应用程序。您将看到代码分析器CA1819的警告显示在错误列表中。如果将操作更改为错误，构建将会因为该错误而中断。
- en: '![](img/B06434_04_13.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_13.png)'
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Code analyzers can provide you with a lot of functionality and assist developers
    in writing good code by avoiding common bad coding practices and enforcing specific
    team guidelines. Each code analyzer can be set to a different severity, with the
    most severe actually breaking the build. Keeping code analyzers under the references
    in your projects allows you to check it in to source control; this is evaluated
    whenever you build your project. You can however also store analyzers on a per-machine
    basis. These analyzers will be for personal code improvement, prompts, and personal
    use.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分析器可以为您提供许多功能，并帮助开发人员避免常见的不良编码实践，并强制执行特定的团队准则。每个代码分析器可以设置为不同的严重程度，最严重的实际上会导致构建失败。将代码分析器保留在项目的引用中允许您将其检入源代码控制；这在构建项目时进行评估。但是，您也可以将分析器存储在每台计算机上。这些分析器将用于个人代码改进、提示和个人使用。
- en: Code analyzers are perfect for modern day developers because they are under
    the control of the developer and integrate easily into Visual Studio.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分析器非常适合现代开发人员，因为它们在开发人员的控制下，并且可以轻松集成到Visual Studio中。
- en: Creating a code analyzer
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建代码分析器
- en: Some of you might already see the benefit of creating your own code analyzer.
    Being able to control certain design implementations and coding standards specific
    to your team is invaluable. This is especially true for new developers joining
    your team. I remember when I started working for a company a couple of years back;
    the development manager gave me a document of code standards that I needed to
    adhere to. At the time this was great. It showed me that they cared about code
    standards. Back then, of course, developers didn't have code analyzers. It was
    however quite a challenge keeping track of all the standards that I needed to
    implement. This was especially true for the specific code standards that the company
    implemented.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能已经看到了创建自己的代码分析器的好处。能够控制特定设计实现和团队特定的编码标准对您的团队来说是非常宝贵的。这对于加入您的团队的新开发人员尤其重要。我记得几年前开始为一家公司工作时，开发经理给了我一份需要遵守的代码标准文件。当时这很棒。它向我表明他们关心代码标准。当时，开发人员当然没有代码分析器。然而，跟踪我需要实施的所有标准是相当具有挑战性的。特别是对于公司实施的特定代码标准来说，情况尤其如此。
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before you can create your own code analyzer, you need to ensure that you have
    installed the .NET Compiler Platform SDK. To do this, perform the following steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在您创建自己的代码分析器之前，您需要确保已安装.NET编译器平台SDK。要做到这一点，请执行以下步骤：
- en: Add a new project to your solution and click on Extensibility. Select Download
    the .NET Compiler Platform SDK and click OK.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向您的解决方案添加一个新项目，然后单击可扩展性。选择下载.NET编译器平台SDK，然后单击确定。
- en: '![](img/B06434_04_14.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_14.png)'
- en: This will actually create a project with an index file. The page that opens
    will provide a download to the .NET Compiler Platform SDK. Click on that to start
    the download.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这实际上将创建一个带有索引文件的项目。打开的页面将提供下载.NET编译器平台SDK的链接。单击该链接开始下载。
- en: '![](img/B06434_04_15.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_15.png)'
- en: Just save the downloaded file to a directory on your hard drive. Then you should
    close down Visual Studio before clicking on the VSIX file.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需将下载的文件保存到硬盘上的一个目录中。然后在单击VSIX文件之前关闭Visual Studio。
- en: '![](img/B06434_04_16.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_16.png)'
- en: The .NET Compiler Platform SDK installer will now start and allow you to select
    the instance of Visual Studio to install to.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET编译器平台SDK安装程序现在将启动，并允许您选择要安装到的Visual Studio实例。
- en: When the installation is complete, restart Visual Studio again.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，再次重新启动Visual Studio。
- en: '![](img/B06434_04_18.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_18.png)'
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Add a new project to your Visual Studio solution and click on Extensibility
    and select the Analyzer with Code Fix (NuGet + VSIX) template. Give it a suitable
    name and click on OK to create the Analyzer project.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向您的Visual Studio解决方案添加一个新项目，然后单击可扩展性，选择带有代码修复的分析器（NuGet + VSIX）模板。给它一个合适的名称，然后单击确定以创建分析器项目。
- en: '![](img/B06434_04_19.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_19.png)'
- en: You will see that Visual Studio has created three projects for you: `Portable`,
    `.Test` and `.Vsix` . Ensure that the `.Vsix` project is set as the default startup
    project.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会发现Visual Studio已为您创建了三个项目：`Portable`，`.Test`和`.Vsix`。确保`.Vsix`项目设置为默认启动项目。
- en: '![](img/B06434_04_20.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_20.png)'
- en: In the `Portable` class, take a look at the `DiagnosticAnalyzer.cs` file. You
    will see a method called `AnalyzeSymbol()`. All that this code analyzer does is
    simply check for the existence of lowercase letters on the `namedTypeSymbol` variable.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Portable`类中，查看`DiagnosticAnalyzer.cs`文件。您将看到一个名为`AnalyzeSymbol()`的方法。这个代码分析器所做的一切就是简单地检查`namedTypeSymbol`变量上是否存在小写字母。
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Build your project and click on *F5* to start debugging. This will start a new
    instance of Visual Studio with its own settings. This means anything you change
    in this experimental instance of Visual Studio will not affect your current Visual
    Studio installation. You can open an existing project or create a new one. I simply
    created a console application. From the start, you will see that the `Program`
    class name is underlined. Hovering your cursor over this will display the Visual
    Studio lightbulb and tell you that the type name contains lowercase letters.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建您的项目并单击*F5*开始调试。这将启动一个新的Visual Studio实例，具有自己的设置。这意味着您在这个实验性的Visual Studio实例中所做的任何更改都不会影响您当前的Visual
    Studio安装。您可以打开现有项目或创建新项目。我只是创建了一个控制台应用程序。从一开始，您会看到`Program`类名被下划线标记。将光标悬停在此处将显示Visual
    Studio的灯泡，并告诉您类型名称包含小写字母。
- en: '![](img/B06434_04_21.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_21.png)'
- en: Clicking on *Ctrl* + *.* or on the Show potential fixes link in the tooltip
    will display the fixes you can apply to correct the error.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击*Ctrl* + *.*或在工具提示中单击“显示潜在修复”链接，将显示您可以应用以纠正错误的修复程序。
- en: '![](img/B06434_04_22.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_22.png)'
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Code analyzers will check managed assemblies and report any information relevant.
    This can be any code that violates the programming and design rules in the .NET
    *Framework Design Guidelines*. The code analyzer will display the checks it performs
    as warning messages and if possible suggest a fix like we saw in the aforementioned
    recipe. To do this, code analyzers use rule sets created by Microsoft or a custom
    rule set you define to meet a specific need.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分析器将检查托管程序集并报告任何相关信息。这可以是违反.NET *Framework Design Guidelines*中的编程和设计规则的任何代码。代码分析器将显示其执行的检查作为警告消息，并在可能的情况下建议修复，就像我们在前面的示例中看到的那样。为此，代码分析器使用由Microsoft创建的规则集或您定义的自定义规则集来满足特定需求。
- en: Creating a custom code analyzer
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义代码分析器
- en: The real magic of code analyzers come to the fore when you create one to suit
    a specific need. What would qualify as a specific need? Well anything that is
    specific to your own business requirements that is not covered in the out-of-the-box
    analyzers. Don't get me wrong; the existing analyzers that are available to developers
    really cover a lot of good programming practices. Just take a look on GitHub by
    searching for C# code analyzers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个适合特定需求的代码分析器时，代码分析器的真正魔力就会显现出来。什么样的需求会被视为特定需求呢？嗯，任何特定于您自己业务需求的东西，而这些在现有的分析器中没有涵盖。不要误会我；对开发人员可用的现有分析器确实涵盖了许多良好的编程实践。只需在GitHub上搜索C#代码分析器，就可以看到。
- en: Sometimes, however, you might have a case where something is more suited to
    your workflow or the way your company does business.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时您可能会遇到更适合您的工作流程或公司业务方式的情况。
- en: An example of this is could be to ensure that comments on all public methods
    include more information than just the standard `<summary></summary>` and parameter
    information (if any). You might want to include an additional tag with the internal
    task ID, for example (think Jira here). Another example is making sure that a
    created class conforms to a certain XML structure. Are you developing software
    that writes warehouse stock information to a database? Do you use non-stocked
    parts? How do you validate non-stocked from stocked parts in code? Code analyzers
    can provide a solution here.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以确保所有公共方法的注释包含的信息不仅仅是标准的`<summary></summary>`和参数信息（如果有）。您可能希望包含一个附加的标签，例如内部任务ID（考虑Jira）。另一个例子是确保创建的类符合特定的XML结构。您是否正在开发将仓库库存信息写入数据库的软件？您是否使用非库存零件？您如何在代码中验证非库存和库存零件？代码分析器可以在这里提供解决方案。
- en: The preceding examples are perhaps rather unique and not applicable to you or
    your needs at all, but that is the beauty of code analyzers. You can create them
    to suit your requirements. Let's take a look at a very simple example. Assume
    that developers in your organization need to use a specific code library. This
    code library is a collection of frequently used code and is well maintained. It
    is included in a Visual Studio template that developers use when creating new
    projects. We need to ensure that, if a developer creates a specific class (for
    purchase orders or sales orders), it implements a specific interface. The interfaces
    exist in the template, but the classes do not. This is because the applications
    will not always be using sales or purchase orders. The interface is to enable
    the receipt of sales and purchase orders and is called IReceivable.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例可能是相当独特的，可能与您或您的需求无关，但这就是代码分析器的美妙之处。您可以创建它们以满足您的需求。让我们看一个非常简单的例子。假设您组织中的开发人员需要使用特定的代码库。这个代码库是一组经常使用的代码，而且维护得很好。它包含在开发人员创建新项目时使用的Visual
    Studio模板中。我们需要确保，如果开发人员创建特定类（用于采购订单或销售订单），它实现了特定接口。这些接口存在于模板中，但类不存在。这是因为应用程序并不总是使用销售或采购订单。该接口是为了使销售和采购订单能够接收，称为IReceivable。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Perform the following steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Create a new Visual Studio project and call it `PurchaseOrderAnalyzer`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Visual Studio项目，命名为`PurchaseOrderAnalyzer`。
- en: '![](img/B06434_04_24.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_24.png)'
- en: Ensure that the following projects are created by default in your solution.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保默认情况下创建以下项目。
- en: '![](img/B06434_04_25-1.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_25-1.png)'
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Expand the `PurchaseOrderAnalyzer (Portable)` project and open the `DiagnosticAnalyzer.cs`
    file.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开`PurchaseOrderAnalyzer (Portable)`项目并打开`DiagnosticAnalyzer.cs`文件。
- en: '![](img/B06434_04_26.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_26.png)'
- en: 'As seen earlier, you will see your diagnostic analyzer class. It should read
    `public class PurchaseOrderAnalyzerAnalyzer : DiagnosticAnalyzer`. Add the following
    code to the top of this class, replacing the code for the `DiagnosticId`, `Title`,
    `MessageFormat`, `Description`, `Category`, and `Rule` variables. Note that I
    have added two enumerators called `ClassTypesToCheck` and `MandatoryInterfaces`
    to the class. I only want this analyzer to act on a class if it is called `PurchaseOrder`
    or `SalesOrder`. I also only want the `IReceiptable` interface to be mandatory
    on the classes defined in the `ClassTypesToCheck` enum.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如前所述，您将看到您的诊断分析器类。它应该读取`public class PurchaseOrderAnalyzerAnalyzer : DiagnosticAnalyzer`。将以下代码添加到此类的顶部，替换`DiagnosticId`、`Title`、`MessageFormat`、`Description`、`Category`和`Rule`变量的代码。请注意，我在类中添加了两个名为`ClassTypesToCheck`和`MandatoryInterfaces`的枚举器。我只希望此分析器在类名为`PurchaseOrder`或`SalesOrder`时才起作用。我还希望`IReceiptable`接口在`ClassTypesToCheck`枚举中定义的类中是强制性的。'
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Make sure that the `Initialize` method contains the following code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`Initialize`方法包含以下代码：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Create the `AnalyzeSymbol` method. You can call this method anything you like.
    Just ensure that, whatever you call this method, it matches the method name in
    the `RegisterSymbolAction()` method inside `Initialize`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`AnalyzeSymbol`方法。您可以将此方法命名为任何您喜欢的名称。只需确保无论您如何命名此方法，它都与`Initialize`中的`RegisterSymbolAction()`方法中的方法名称匹配。
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Add to that a Boolean called `blnInterfaceImplemented` that will store a `true`
    or `false` if the interface is implemented or not. The next check we do is to
    ignore abstract classes. In reality, you would probably want to check an abstract
    class too, but I want to exclude it to show the flexibility of code analyzers.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再添加一个名为`blnInterfaceImplemented`的布尔值，它将存储接口是否已实现的`true`或`false`。我们接下来要做的检查是忽略抽象类。实际上，您可能也想检查抽象类，但我想排除它以展示代码分析器的灵活性。
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You now need to get the name of the symbol you are checking. To do this, create an
    object called `namedTypeSymbol` on which you can call the `Name` method to return
    the symbol name. On a class called `PurchaseOrder`, this should return `PurchaseOrder`
    as the name. Return the `ClassTypesToCheck` enum as a `List<string>` object called
    `classesToCheck`. Then, do a check on the class name and see if it is contained
    in the `classesToCheck` list. It is important to ignore the case by adding `StringComparison.OrdinalIgnoreCase`
    to the `Equals` check. This will ensure that the analyzer will analyze classes
    called `purchaseorder`, `PURCHASEORDER`, `PurchaseOrder`, `Purchaseorder`, or
    `purchaseOrder`. Add the code inside the `if` condition excluding abstract classes.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要获取您正在检查的符号的名称。为此，请创建一个名为`namedTypeSymbol`的对象，您可以在该对象上调用`Name`方法来返回符号名称。在名为`PurchaseOrder`的类上，这应该返回`PurchaseOrder`作为名称。将`ClassTypesToCheck`枚举作为名为`classesToCheck`的`List<string>`对象返回。然后，对类名进行检查，看它是否包含在`classesToCheck`列表中。通过在`Equals`检查中添加`StringComparison.OrdinalIgnoreCase`来忽略大小写是很重要的。这将确保分析器将分析名为`purchaseorder`、`PURCHASEORDER`、`PurchaseOrder`、`Purchaseorder`或`purchaseOrder`的类。将代码添加到`if`条件中，不包括抽象类。
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The capitalization style recommended for class names is PascalCase. PascalCase
    consists of capitalizing the first letter of an identifier and each subsequent
    concatenated word. This is applied if the identifier has three or more characters.
    This means that the concatenated words purchase and order must we written in PascalCase
    when used in class names. This results in **P**urchase**O**rder. Refer to the Capitalization
    Styles article in the MSDN at [https://msdn.microsoft.com/en-us/library/x2dbyw72(v=vs.71).aspx](https://msdn.microsoft.com/en-us/library/x2dbyw72(v=vs.71).aspx).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 类名的推荐大写风格是PascalCase。PascalCase包括大写标识符的第一个字母和每个后续连接的单词。如果标识符有三个或更多字符，则应用此规则。这意味着在类名中使用连接的单词purchase和order时必须使用PascalCase。这将导致**P**urchase**O**rder。请参阅MSDN中的Capitalization
    Styles文章。
- en: Inside the `if` condition, to check if the class name is `PurchaseOrder` or
    `SalesOrder`, add the following code. Here we are going to check the interfaces
    defined on the matched `PurchaseOrder` or `SalesOrder` class. We do this by calling
    the `AllInterfaces()` method and checking to see if it matches the `nameof` the
    `IReceiptable` enumerator. In reality, we would probably want to check more than
    one interface, but for our purposes we're only checking for the implementation
    of the `IReceiptable` interface. If we find the interface as implemented on the
    class name that was matched in the earlier check, we set `blnInterfaceImplemented
    = true;` (it is currently initialized to `false`). This means that, if the interface
    is not matched, then we will produce a diagnostic for the omission of the `IReceiptable`
    interface. This is done by creating and reporting the diagnostic that contains
    the `Rule` defined earlier and the location of the class name.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`if`条件中，要检查类名是否为`PurchaseOrder`或`SalesOrder`，请添加以下代码。在这里，我们将检查匹配的`PurchaseOrder`或`SalesOrder`类上定义的接口。我们通过调用`AllInterfaces()`方法来实现这一点，并检查它是否与`IReceiptable`枚举的`nameof`匹配。实际上，我们可能希望检查多个接口，但出于我们的目的，我们只检查`IReceiptable`接口的实现。如果我们发现接口在之前检查中匹配了类名上的实现，我们将设置`blnInterfaceImplemented
    = true;`（它当前初始化为`false`）。这意味着，如果接口没有匹配，那么我们将为省略`IReceiptable`接口产生诊断。这是通过创建和报告包含先前定义的`Rule`和类名位置的诊断来完成的。
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If all the code is added to `AnalyzeSymbol()` the method should look as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有代码都添加到`AnalyzeSymbol()`方法中，该方法应如下所示：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We now need to create a fix for the code analyzer. If we see that the class
    does not implement our interface, we want to provide a quick fix for the developer
    with the lightbulb feature. Open the file called `CodeFixProvider.cs`. You will
    see that it contains a class called `public class PurchaseOrderAnalyzerCodeFixProvider
    : CodeFixProvider`. The first thing to do is locate the `title` string constant
    and change it to a more suitable title. This is the menu flyout displayed when
    you click on the lightbulb in Visual Studio.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，我们需要为代码分析器创建一个修复程序。如果我们发现类没有实现我们的接口，我们希望为开发人员提供一个快速修复的灯泡功能。打开名为`CodeFixProvider.cs`的文件。您会看到其中包含一个名为`public
    class PurchaseOrderAnalyzerCodeFixProvider : CodeFixProvider`的类。首先要做的是找到`title`字符串常量，并将其更改为更合适的标题。这是在Visual
    Studio中单击灯泡时显示的菜单弹出窗口。'
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I have left most of the code-fix code the same except for the code that does
    the actual fix. Locate the method called `RegisterCodeFixesAsync()`. I renamed
    the method to call in the `RegisterCodeFix()` method to `ImplementRequiredInterfaceAsync()`.
    The code should look as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我已经将大部分代码修复代码保持不变，除了执行实际修复的代码。找到名为`RegisterCodeFixesAsync()`的方法。我将该方法重命名为`ImplementRequiredInterfaceAsync()`，以在`RegisterCodeFix()`方法中调用。代码应如下所示：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You will notice that I have re-purposed the fix used to make the symbol an uppercase
    to implement the interface. The rest of the code is left as-is. In reality, you
    would most likely want to check if any other interfaces are implemented on the
    class and maintain those implementations. For this demonstration, we're just assuming
    a new class being created called `PurchaseOrder` or `SalesOrder` without existing
    interfaces.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到，我已经重新使用了用于将符号大写的修复程序来实现接口。其余的代码保持不变。实际上，您很可能希望检查类上是否实现了其他接口，并保持这些实现。在这个演示中，我们只是假设正在创建一个名为`PurchaseOrder`或`SalesOrder`的新类，而没有现有的接口。
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Ensure that the `PurchaseOrderAnalyzer.Vsix` project is set as the start-up
    project and click on Debug. A new instance of Visual Studio will be launched.
    Create a new console application in this Visual Studio instance and call it `PurchaseOrderConsole`.
    To this project, add a new interface called `IReceiptable` and add the following
    code.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`PurchaseOrderAnalyzer.Vsix`项目设置为启动项目，然后单击“调试”。将启动Visual Studio的新实例。在这个Visual
    Studio实例中创建一个新的控制台应用程序，并将其命名为`PurchaseOrderConsole`。向该项目添加一个名为`IReceiptable`的新接口，并添加以下代码。
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, add a new class called `PurchaseOrder` to the project with the following
    code.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向项目添加一个名为`PurchaseOrder`的新类，其中包含以下代码。
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After you have done this, your project might look as follows if you added separate
    files for `IReceiptable` and `PurchaseOrder`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，如果为`IReceiptable`和`PurchaseOrder`添加了单独的文件，您的项目可能如下所示。
- en: '![](img/B06434_04_27.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_27.png)'
- en: Viewing the `PurchaseOrder` class, you will notice a squiggly line under the
    class name `PurchaseOrder`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看`PurchaseOrder`类时，您会注意到类名`PurchaseOrder`下有一个波浪线。
- en: '![](img/B06434_04_28.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_28.png)'
- en: Hovering the mouse over the squiggly line, you will see the lightbulb displayed
    notifying you that the `IReceiptable` interface is not implemented.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在波浪线上，您将看到灯泡显示通知您`IReceiptable`接口未实现。
- en: '![](img/B06434_04_29.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_29.png)'
- en: When you view potential fixes, you will see that the `title` we changed earlier
    in the `CodeFixProvider.cs` file to read `private const string title = "Implement
    IReceiptable";` is displayed as the flyout menu text. The suggested code is then
    shown as implementing the correct interface `IReceiptable`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您查看潜在的修复时，您将看到我们在`CodeFixProvider.cs`文件中更改的`title`在飞出菜单文本中显示为`private const
    string title = "Implement IReceiptable";`。然后建议的代码显示为实现正确的接口`IReceiptable`。
- en: '![](img/B06434_04_30.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_30.png)'
- en: 'Clicking on this modifies our `PurchaseOrder` class to produce the following
    code:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击此按钮会修改我们的`PurchaseOrder`类，生成以下代码：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once the code fix has been applied, you will see that the squiggly line under
    the class name has disappeared. As expected, Visual Studio is now telling us that
    we need to implement the interface member `IReceiptable.MarkAsReceipted(int)`
    by underlining the interface name `IReceiptable` with a red squiggly line.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用代码修复后，您会看到类名下的波浪线已经消失。正如预期的那样，Visual Studio现在告诉我们需要通过在`IReceiptable`接口名称下划线标记`IReceiptable.MarkAsReceipted(int)`来实现接口成员。
- en: '![](img/B06434_04_31.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_31.png)'
- en: Hovering over the `IReceiptable` interface name, you will see the lightbulb
     the code fix. This is the standard Visual Studio analyzer at work here.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在`IReceiptable`接口名称上，您将看到代码修复的灯泡。这是标准的Visual Studio分析器在这里起作用。
- en: '![](img/B06434_04_32.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_32.png)'
- en: Clicking on the fix to be applied implements the `IReceiptable` member and the
    `PurchaseOrder` class is correctly defined in the code.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击要应用的修复程序，实现`IReceiptable`成员和`PurchaseOrder`类在代码中正确定义。
- en: '![](img/B06434_04_33.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_33.png)'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: 'The example in this recipe does not even begin to scratch the surface of what
    is possible with code analyzers. A great way to learn what is possible is to have
    a look at some of the code analyzers on GitHub. View the code and start writing
    your own code analyzers. As with most concepts in programming, the only way to
    learn this is to write the code. There is a wealth of information available on
    the Internet. A word of advice, though: before you start writing your code analyzers,
    take a look to see if there isn''t an analyzer that already does what you need
    (or is close to doing what you need).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中的示例甚至没有开始涉及代码分析器的可能性。了解可能性的一个很好方法是查看GitHub上的一些代码分析器。查看代码并开始编写自己的代码分析器。与编程中的大多数概念一样，学习的唯一方法就是编写代码。互联网上有大量的信息可供使用。不过，建议在开始编写自己的代码分析器之前，先看看是否已经有一个分析器可以满足您的需求（或者接近满足您的需求）。
- en: For example, if you need to ensure method comments include additional information,
    try to find an analyzer that already does something similar. If you find an analyzer
    that checks to see if public methods have comments, for example, you could easily
    retrofit this analyzer to suit your own needs. The best way to learn is to do,
    but everybody needs a starting point. Standing on the shoulders of others is part
    of learning new programming concepts.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您需要确保方法注释包含附加信息，请尝试查找一个已经执行类似操作的分析器。例如，如果您找到一个检查公共方法是否有注释的分析器，您可以轻松地修改此分析器以满足自己的需求。学习的最佳方法是实践，但每个人都需要一个起点。站在他人的肩膀上是学习新编程概念的一部分。
- en: Deploying your code analyzer within your organization only
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅在组织内部部署您的代码分析器
- en: Code analyzers are a fantastic method to check and correct code automatically.
    Sometimes, however, the analyzers you create will not be suitable for public consumption
    as they might contain proprietary information. With NuGet, you can create private
    repositories and share these with colleagues. You can use a shared location on
    a company server, for example, and easily manage NuGet packages from there.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分析器是一种检查和自动纠正代码的绝妙方法。然而，您创建的分析器有时可能不适合公开使用，因为它们可能包含专有信息。通过NuGet，您可以创建私有存储库并与同事共享。例如，您可以使用公司服务器上的共享位置，并轻松管理NuGet包。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you have a shared location accessible to all developers in your
    organization. This can be anywhere your network administrator has provided for
    shared file access. You will probably want to restrict the access of these packages
    to developers only. A nice solution is to create a storage account on Azure to
    share the NuGet packages to. This is the approach I followed here using a fictitious
    company I have called Acme Corporation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的组织中的所有开发人员都可以访问共享位置。这可以是您的网络管理员提供的任何共享文件访问位置。您可能希望将这些包的访问权限限制为开发人员。一个不错的解决方案是在Azure上创建一个存储账户来共享NuGet包。这是我在这里使用的方法，我使用了一个名为Acme
    Corporation的虚构公司。
- en: I will not go through setting up a storage account on Azure, but I will talk
    about accessing it from your local machine.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会详细介绍如何在Azure上设置存储账户，但我会谈谈如何从本地机器访问它。
- en: I encourage you and your organization to consider using Azure. I will not expand
    much on the benefits of using Azure other than to say that it is an incredible
    time-saver. If I want to test a specific feature of an application on a particular
    OS, within minutes I am able to spin up a VM and connect to it via a remote desktop.
    It is immediately ready to use.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你和你的组织考虑使用Azure。我不会过多扩展使用Azure的好处，只是说它可以节省大量时间。如果我想测试特定应用程序的特定功能在特定操作系统上，几分钟内我就能启动一个虚拟机并通过远程桌面连接到它。它立即可以使用。
- en: After you have created your storage account on Azure, you will find the access
    keys on the Access keys tab.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure上创建存储账户后，你会在“访问密钥”选项卡上找到访问密钥。
- en: Make a note of the keys and the Storage account name.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记下密钥和存储账户名称。
- en: '![](img/B06434_04_35.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_35.png)'
- en: I also just created a File service called packages. To get here, click on Overview.
    Then, under the Services heading, click on Files. On the File service window,
    select packages and view the property information for the file share.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我还创建了一个名为`packages`的文件服务。要到达这里，点击“概述”。然后，在“服务”标题下，点击“文件”。在文件服务窗口上，选择`packages`并查看文件共享的属性信息。
- en: Your storage account might differ from the examples in this book, depending
    on what you called it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你的存储账户可能与本书中的示例不同，这取决于你的命名。
- en: '![](img/B06434_04_36.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_36.png)'
- en: Make a note of the URL specified in the properties. Using the URL, map a network
    drive by changing the `https://` part to `\\` and any subsequent `/` to `\` in
    the path.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记下属性中指定的URL。使用该URL，通过将路径中的`https://`部分更改为`\\`，并将任何后续的`/`更改为`\`，映射一个网络驱动器。
- en: '![](img/B06434_04_37.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_37.png)'
- en: Add this path to the Folder textbox and ensure that you have checked Connect
    using different credentials.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此路径添加到文件夹文本框，并确保已选中使用不同凭据进行连接。
- en: '![](img/B06434_04_38.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_38.png)'
- en: Use the storage account name as the username and one of the keys as the password.
    You now have a network drive mapped to your Azure Storage account.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用存储账户名称作为用户名，使用其中一个密钥作为密码。现在你已经将一个网络驱动器映射到了你的Azure存储账户。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Have a look at the `PurchaseOrderAnalyzer` project we created. You will see
    that there is a `tools` folder containing two PowerShell scripts called `install.ps1`
    and `uninstall.ps1`. It is here that you can specify any installation-specific
    resources or actions to take when uninstalling the package.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看一下我们创建的`PurchaseOrderAnalyzer`项目。你会看到有一个包含两个名为`install.ps1`和`uninstall.ps1`的PowerShell脚本的`tools`文件夹。在这里，你可以指定任何特定于安装的资源或卸载软件包时要执行的操作。
- en: '![](img/B06434_04_34.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_34.png)'
- en: Opening the `Diagnostic.nuspec` file, you will note that this contains information
    regarding the NuGet package you are about to deploy. Make a point of modifying
    this file accordingly as it contains information important to developers consuming
    your NuGet package.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Diagnostic.nuspec`文件，你会注意到其中包含了关于你即将部署的NuGet程序包的信息。务必修改此文件，因为它包含了对开发人员使用你的NuGet程序包很重要的信息。
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Go ahead and build your code analyzer. You will see that a file called `PurchaseOrderAnalyzer.1.1.1.1.nupkg`
    has been created in the `bin` folder for your project. Copy that file to the mapped
    drive you created earlier in the Azure Storage account.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续构建你的代码分析器。你会看到在项目的`bin`文件夹中创建了一个名为`PurchaseOrderAnalyzer.1.1.1.1.nupkg`的文件。将该文件复制到你之前在Azure存储账户中创建的映射驱动器。
- en: Inside Visual Studio, add a new WinForms application. You can call this anything
    you like. You can now add the Storage account as a NuGet location. Go to Tools,
    NuGet Package Manager and click on Manage NuGet Packages for Solution.... You
    will notice that, next to the Package source, which is currently set to nuget.org,
    there is a small gear icon. Click on this.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，添加一个新的WinForms应用程序。你可以随意命名。现在可以将存储账户添加为NuGet位置。转到工具，NuGet程序包管理器，然后单击“解决方案的NuGet程序包管理器...”。你会注意到，在当前设置为nuget.org的包源旁边，有一个小齿轮图标。点击它。
- en: I created the Visual Studio WinForms application on a separate machine for this
    example, but if you do not have access to a separate machine, try using a VM to
    test this. If you do not have access to Azure, you can use VirtualBox.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我为这个示例在一个单独的机器上创建了Visual Studio WinForms应用程序，但如果你没有单独的机器，可以尝试使用虚拟机进行测试。如果你无法访问Azure，也可以使用VirtualBox。
- en: '![](img/B06434_04_39.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_39.png)'
- en: The Options screen allows you to add an additional source for NuGet packages
    by clicking on the green plus icon under Available package sources.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“选项”屏幕上，通过单击“可用包源”下方的绿色加号图标，可以添加一个额外的NuGet程序包源。
- en: '![](img/B06434_04_40-1.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_40-1.png)'
- en: At the bottom of the Options window, enter a suitable name for the location
    and enter the path to the Azure Storage account. This is the same path you entered
    when you mapped the network drive. Before clicking on OK, click on the Update
    button. Then click on the OK button.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“选项”窗口底部，输入一个适当的位置名称，并输入Azure存储账户的路径。这是你在映射网络驱动器时输入的相同路径。在点击“确定”之前，点击“更新”按钮。然后点击“确定”按钮。
- en: '![](img/B06434_04_41.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_41.png)'
- en: You can now change the Package source to set it to the Azure Storage account
    location you mapped to. Doing this and clicking on the Browse tab of the NuGet
    package manager will display all the packages on this file share. The information
    under the Options section to the right is the information you defined in the `Diagnostic.nuspec`
    file.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以将包源更改为设置为你映射到的Azure存储账户位置。这样做并单击NuGet程序包管理器的“浏览”选项卡将显示此文件共享上的所有程序包。右侧“选项”部分中的信息是你在`Diagnostic.nuspec`文件中定义的信息。
- en: '![](img/B06434_04_42.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_42.png)'
- en: You can now go ahead and install the code analyzer NuGet package. When you have
    completed the installation, the code analyzer will be visible under the `Analyzers`
    node under `References` in your project.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以继续安装代码分析器NuGet包。安装完成后，代码分析器将在项目的`References`下的`Analyzers`节点下可见。
- en: '![](img/B06434_04_43.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_43.png)'
- en: The code analyzer also works exactly as expected. Create a class called `PurchaseOrder`
    and see the analyzer in action.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码分析器也完全按预期工作。创建一个名为`PurchaseOrder`的类，看看分析器是如何运作的。
- en: '![](img/B06434_04_44.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_04_44.png)'
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The NuGet package is the easiest way to deploy code to a large audience or even
    a few developers. It takes all the heavy lifting out of sharing code and templates.
    It therefore makes perfect sense to use NuGet to deploy your code analyzers. Setting
    up a private repository using NuGet for sharing code within your organization
    is really simple.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: NuGet包是将代码部署到大众或少数开发人员的最简单方式。它可以轻松实现代码和模板的共享，因此使用NuGet来部署代码分析器是非常合理的。使用NuGet设置一个私有存储库来在组织内共享代码非常简单。
