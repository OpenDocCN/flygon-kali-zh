- en: '*Chapter 2*: First Contact: Java, XML, and the UI Designer'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：初次接触：Java、XML和UI设计师'
- en: 'At this stage, we have a working Android development environment and we have
    built and deployed our first app. It is obvious, however, that the auto-generated
    code from Android Studio is not going to make the next top-selling app on Google
    Play. We need to explore this auto-generated code so we can begin to understand
    Android and then learn how to build upon this useful template. With this aim in
    mind, in this chapter, we will do the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经拥有了一个可用的Android开发环境，并且已经构建并部署了我们的第一个应用程序。然而，很明显，从Android Studio生成的代码不会成为下一个畅销应用程序。我们需要探索这个自动生成的代码，以便开始理解Android，然后学习如何在这个有用的模板上进行构建。为了达到这个目的，在本章中，我们将做以下事情：
- en: See how to get technical feedback from our apps
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看如何从我们的应用程序中获得技术反馈
- en: Examine the Java code and UI XML code from our first app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查我们第一个应用程序的Java代码和UI XML代码
- en: Get our first taste of using the Android Studio **User Interface** (**UI**)
    designer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们初次体验使用Android Studio的**用户界面**（**UI**）设计师。
- en: Learn some core Java fundamentals and how they relate to Android
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习一些核心的Java基础知识以及它们与Android的关系
- en: Write our first Java code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写我们的第一个Java代码
- en: First, let's see how to get feedback from our apps.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何从我们的应用程序中获得反馈。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code for this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2002](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2002).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码[https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2002](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2002)。
- en: Examining the logcat output
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查logcat输出
- en: In the previous chapter, we mentioned that our app was running in debug mode
    on the emulator or real device, so we can monitor it and get feedback when things
    go wrong. So, where is all this feedback then?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们提到我们的应用程序在模拟器或真实设备上以调试模式运行，因此当出现问题时，我们可以监视它并获得反馈。那么，所有这些反馈在哪里呢？
- en: 'You might have noticed a whole load of scrolling text at the bottom of the
    Android Studio window. If not, click on the **Logcat** tab, as shown by the highlighted
    area labeled **1** in the next figure:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到在Android Studio窗口底部有一大堆滚动文本。如果没有，请单击**Logcat**选项卡，如下图中标记为**1**的突出显示区域所示：
- en: Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The emulator must be running, or a real device must be attached in debugging
    mode, for you to see the following window. Furthermore, if you restarted Android
    Studio for some reason and have not executed the app since restarting, then the
    **Logcat** window will be empty. Refer to the first chapter to get the app running
    on an emulator or a real device.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器必须在运行中，或者必须连接一个真实设备以调试模式运行，才能看到以下窗口。此外，如果由于某种原因重新启动了Android Studio，并且自重新启动以来尚未执行应用程序，则**Logcat**窗口将为空。请参考第一章，在模拟器或真实设备上运行应用程序。
- en: '![Figure 2.1 – The Logcat tab'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1 - Logcat标签'
- en: '](img/Figure_2.01_B16773.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.01_B16773.jpg)'
- en: Figure 2.1 – The Logcat tab
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 - Logcat标签
- en: You can drag the window to make it taller, just like you can in most other Windows
    applications if you want to see more.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要看到更多内容，可以将窗口拖动得更高，就像您可以在大多数其他Windows应用程序中一样。
- en: This window is called **logcat** or is sometimes referred to as the **console**.
    It is our app's way of telling us what is going on underneath what the user sees.
    If the app crashes or has errors, the reason or clues to the reason will appear
    here. If we need to output debugging information, we can do so here as well.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口被称为**logcat**，有时也被称为**控制台**。这是我们的应用程序告诉我们用户看不到的事情发生了什么的方式。如果应用程序崩溃或出现错误，原因或原因的线索将出现在这里。如果我们需要输出调试信息，我们也可以在这里做。
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The app we are building should not have any problems at this stage, but in the
    future, if you just cannot work out why your app is crashing, copying and pasting
    a bit of text from logcat into Google will often reveal the reason.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建的应用程序在这个阶段不应该有任何问题，但是在将来，如果您无法弄清楚您的应用程序为什么崩溃，从logcat中复制并粘贴一些文本到Google中通常会揭示原因。
- en: Filtering the logcat output
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤logcat输出
- en: You might have noticed that most if not all of the contents of logcat is almost
    unintelligible. That's OK. For now, we are only interested in errors, which will
    be highlighted in red, and the debugging information, about which we will learn
    next. So that we see less of the unneeded text in our logcat window, we can turn
    on some filters to make things clearer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，logcat的大部分内容，如果不是全部，几乎是难以理解的。没关系。目前，我们只对错误感兴趣，这些错误将以红色突出显示，以及我们将在下一步中学习的调试信息。因此，为了在logcat窗口中看到更少不需要的文本，我们可以打开一些过滤器以使事情更清晰。
- en: In the previous figure, I highlighted two more areas, as **2** and **3**. Area
    **2** is a drop-down list that controls the first filter. Left-click it now and
    change it from **Verbose** to **Info**. We have cut down the text output significantly.
    We will see how this is useful when we have made some changes to our app and redeployed
    it. We will do this after we have explored the code and the assets that make up
    our project. Also, double-check in the area that is labeled **3** that says **Show
    only the selected application**. If it doesn't, left-click on it and change it
    to **Show only the selected application** now.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一张图中，我突出显示了另外两个区域，标记为**2**和**3**。区域**2**是一个下拉列表，用于控制第一个过滤器。现在左键单击它，并将其从**Verbose**更改为**Info**。我们已经大大减少了文本输出。当我们对应用程序进行了一些更改并重新部署后，我们将看到这对我们有多有用。在我们探索了构成我们项目的代码和资产之后，我们将这样做。此外，请在标记为**3**的区域中仔细检查，看看是否写着**仅显示所选应用程序**。如果没有，现在左键单击它并将其更改为**仅显示所选应用程序**。
- en: Now we can look at what Android Studio automatically generated for us and then
    we can set about changing and adding to the code to personalize it beyond what
    we got from the project creation phase.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看看Android Studio自动生成的内容，然后开始更改和添加代码，以使其个性化超出我们从项目创建阶段获得的内容。
- en: Exploring the project Java and the main layout XML
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索项目Java和主布局XML
- en: We are going to look at the resource files that have the code that defines our
    simple UI layout and the file that has our Java code. At this stage, we will not
    try to understand it all, as we need to learn some more basics before it makes
    sense to do so. What we will see, however, is the basic contents and structure
    of both files, so we can reconcile their contents with what we already know about
    Android resources and Java.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看包含定义我们简单UI布局的代码和包含我们Java代码的资源文件。在这个阶段，我们不会试图理解所有这些，因为在理解之前我们需要学习更多的基础知识。然而，我们将看到这两个文件的基本内容和结构，以便我们可以将它们的内容与我们已经了解的Android资源和Java相协调。
- en: Examining the MainActivity.java file
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查MainActivity.java文件
- en: 'Let''s look at the Java code first. If, for some reason, this isn''t currently
    visible, you can see this code by left-clicking on the **MainActivity.java** tab,
    as shown in the next figure:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们看看Java代码。如果出于某种原因，这些代码目前不可见，您可以通过左键单击**MainActivity.java**标签来查看这些代码，如下图所示：
- en: '![Figure 2.2 – MainActivity.java tab'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 - MainActivity.java标签'
- en: '](img/Figure_2.02_B16773.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.02_B16773.jpg)'
- en: Figure 2.2 – MainActivity.java tab
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 - MainActivity.java标签
- en: 'As we are not looking at the intricate details of the code, an annotated screenshot
    is more useful than reproducing the actual code in text form. Regularly refer
    to the next figure while reading on in this section:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不会深入研究代码的细节，带注释的截图比以文本形式重现实际代码更有用。在阅读本节时，请经常参考下一张图：
- en: '![Figure 2.3 – Java code'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 - Java代码'
- en: '](img/Figure_2.03_B16773.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.03_B16773.jpg)'
- en: Figure 2.3 – Java code
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 - Java代码
- en: The first thing to note is that I have added a few empty lines among the code
    to space things out a little bit and present a clearer image.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我在代码中添加了一些空行，以便稍微间隔一下，并呈现更清晰的图像。
- en: Code folding (hiding) in Android Studio
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Android Studio中折叠（隐藏）代码
- en: Now look at the left-hand side of the figure where multiple parts are labeled
    **9**. This points to all the little + and - buttons in the editor, which can
    collapse and expand parts of the code. I have indeed collapsed some parts of the
    code, and other parts I have left visible. So, what you can see on your screen
    is slightly different to what you will see if you look at the figure. In Android
    Studio, play with the + and – buttons for a while to practice hiding and unhiding
    sections of the code. You might want to get your screen to look like the figure,
    but this is not a requirement to continue. The technical term for hiding code
    like this is **folding**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看图的左侧，标有多个部分的**9**。这指向编辑器中所有小的+和-按钮，这些按钮可以折叠和展开代码的部分。我确实折叠了一些代码的部分，而其他部分我留了出来。因此，您屏幕上看到的内容与您在图中看到的内容略有不同。在Android
    Studio中，尝试一段时间使用+和-按钮来练习隐藏和显示代码的部分。您可能希望使您的屏幕看起来像图中的样子，但这并不是继续的要求。像这样隐藏代码的技术术语是**折叠**。
- en: The package declaration
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包声明
- en: Part `package`. Every Java file will have a package declaration at the top.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 部分`package`。每个Java文件顶部都会有一个包声明。
- en: Importing classes
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入类
- en: Part `import`. After the word `import`, we can see there are various dot-separated
    words. The last word of each line is the name of the class that line imports into
    our project and all the earlier words in each line are the packages and sub-packages
    that contain these classes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 部分`import`。在`import`后面，我们可以看到有各种点分隔的单词。每行的最后一个单词是该行导入到我们项目中的类的名称，而每行中较早的单词是包含这些类的包和子包。
- en: 'For example, this next line imports the `AppCompatActivity` class from the
    `androidx.appcompat.app` package and sub-packages:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下一行从`androidx.appcompat.app`包和子包中导入`AppCompatActivity`类：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The semicolon at the end of the lines shows the compiler that it is the end
    of that line of code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 行尾的分号告诉编译器这是代码行的结束。
- en: This means that in this file we will have access to these classes. In fact,
    it is these classes that the auto-generated code uses to make the simple app that
    we saw in action in the previous chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在这个文件中，我们将可以访问这些类。实际上，正是这些类被自动生成的代码用来制作我们在上一章中看到的简单应用程序。
- en: We will not discuss all these classes in this chapter. It is just the concept
    that we can do this importing that is significant right now. Note that we can
    add extra classes from any package at any time and we will when we improve upon
    our app shortly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会讨论所有这些类。现在重要的是我们可以导入这些类的概念。请注意，我们可以随时从任何包中添加额外的类，我们将在不久的将来改进我们的应用程序时这样做。
- en: The class
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这个类
- en: 'Part **3** of our code is called the **class declaration**. Here is that line
    in full; I have highlighted one part of it:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码的**第3**部分称为**类声明**。以下是完整的一行；我已经突出显示了其中的一部分：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The class declaration is the start of a class. Notice the highlighted part,
    `MainActivity`. This is the name Android Studio gave the class when we created
    the project and it is also the same as the `MainActivity.java` filename as we
    would expect having discussed Java classes previously.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 类声明是一个类的开始。请注意高亮显示的部分，`MainActivity`。这是Android Studio在我们创建项目时给出的类名，也是我们之前讨论过的Java类的`MainActivity.java`文件名相同。
- en: The class and the file can be renamed, but since this is the key/main activity
    of our app, `MainActivity` seems appropriate. The `extends` keyword means that
    our class called `MainActivity` will be of the type `AppCompatActivity`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 类和文件可以重命名，但由于这是我们应用程序的关键/主要活动，`MainActivity`似乎是合适的。`extends`关键字意味着我们的名为`MainActivity`的类将是`AppCompatActivity`类型。
- en: We can, and will, use some classes without this `extends` part. We use `extends`
    here because we want to use all the code that went into the `AppCompatActivity`
    class, as well as adding our own code to it as well. So, we **extend** it. All
    this and more will become clear in [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*,
    Object-Oriented Programming.*
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一些类而不需要这个`extends`部分。我们在这里使用`extends`是因为我们想要使用`AppCompatActivity`类中的所有代码，并且还要添加我们自己的代码。所以，我们**扩展**它。所有这些以及更多内容将在[*第10章*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*，面向对象编程*中变得更加清晰。
- en: Finally, for part `{`. Now look at the bottom of the figure at part `}` denotes
    the end of the class. Everything in between the opening and closing curly braces,
    `{...}`, is part of the `MainActivity` class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于`{`部分。现在看图的底部`}`部分表示类的结束。在`MainActivity`类的左花括号和右花括号之间的所有内容都是`MainActivity`类的一部分。
- en: Methods inside the class
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类内的方法
- en: 'Now look at part **5** of the code. Here is that line of code in full with
    the key part for our discussion highlighted:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看一下代码的第5部分。这是完整的代码行，其中我们讨论的关键部分已经突出显示：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a method `onCreate`, is the method **name**. We make a method execute
    its code by using its name. We say we are **calling** a method when we do this.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`onCreate`方法，是方法的**名称**。我们通过使用方法的名称使方法执行其代码。当我们这样做时，我们说我们正在**调用**一个方法。
- en: Although we will not concern ourselves now with the details of the parts of
    the code on either side of the method name, you might have noticed `Bundle`, one
    of the classes we imported at part `import` line, Android Studio would not know
    what `Bundle` was and it would be unusable and indicated with a red underline
    as an error.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们现在不关心方法名称两侧代码的细节，但你可能已经注意到`Bundle`，这是我们在`import`行导入的类之一，如果没有导入`Bundle`，Android
    Studio将不知道`Bundle`是什么，它将无法使用，并且会以红色下划线表示为错误。
- en: Our code would then not compile and run. Notice the very last thing in the preceding
    line of code is an opening curly brace, `{`. This denotes the start of the code
    contained within the `onCreate` method. Now jump to part `}`. You might have guessed
    that this is the end of the method. Everything in between the opening and closing
    curly braces of the `onCreate` method is the code that executes when the method
    is called.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的代码将无法编译和运行。请注意前一行代码中的最后一件事是一个左花括号`{`。这表示`onCreate`方法中包含的代码的开始。现在跳到`}`部分。你可能已经猜到这是方法的结束。在`onCreate`方法的左花括号和右花括号之间的所有内容都是在调用该方法时执行的代码。
- en: We do not need to go into what this code does yet, but as an overview, it sets
    up the appearance/layout of the app by referring to a resource file that was auto-generated
    by Android Studio when we created the project. I have highlighted the resource
    files with an outline in the previous figure.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不需要深入了解这段代码的作用，但是总体上，它通过引用一个资源文件来设置应用程序的外观/布局，这个资源文件是在我们创建项目时由Android Studio自动生成的。我在前面的图中用轮廓标出了资源文件。
- en: Parts `onCreateOptionsMenu` and `onOptionsItemSelected`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`onCreateOptionsMenu`和`onOptionsItemSelected`部分。'
- en: We know enough about our Java code to make some progress. We will see this code
    again and change it later in this chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了足够的Java代码，可以取得一些进展。我们将在本章后面再次看到这段代码并进行更改。
- en: Summary of the Java code so far
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 到目前为止Java代码的总结
- en: It is true that contained within the code we have just had an overview of, there
    is some complex syntax. However, what we are doing is building up just enough
    knowledge about this code, so we can work with it to begin to make fast progress
    in learning Java and Android without having to learn hundreds of pages of Java
    theory first. By the end of the book, all the code will make sense, but to make
    quick progress now, we just need to accept that some of the details will remain
    a mystery for a little while longer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在我们刚刚概述的代码中包含了一些复杂的语法。然而，我们正在建立对这段代码的足够了解，以便开始快速学习Java和Android，而不必先学习数百页的Java理论。到本书结束时，所有的代码都会有意义，但为了现在快速进展，我们只需要接受一些细节将在更长一段时间内保持神秘。
- en: Examining the app layout file
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查应用程序布局文件
- en: Now we will look at just one of the many `.xml` files. There are several different
    layout files and we will meet them all throughout the course of the book, but
    let's start with the most recognizable one, which decides most of the appearance
    of our app.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将只看其中一个`.xml`文件。在整本书的过程中，我们将遇到几种不同的布局文件，但让我们从最容易识别的一个开始，它决定了我们应用程序的大部分外观。
- en: In the project explorer window, left-click on the `fragment_first.xml` file.
    The XML code contents of the file is now displayed in the main window of Android
    Studio.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目资源管理器窗口中，左键单击`fragment_first.xml`文件。文件的XML代码内容现在显示在Android Studio的主窗口中。
- en: We can ignore the **res generated** folder.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以忽略**res generated**文件夹。
- en: 'We will explore this XML code soon but first find and left-click the **Design**
    button (shown next) to switch to the design view:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快会探索这个XML代码，但首先找到并左键单击**Design**按钮（如下所示）切换到设计视图：
- en: '![Figure 2.4 – To open design view'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4 - 打开设计视图'
- en: '](img/Figure_2.04_B16773.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.04_B16773.jpg)'
- en: Figure 2.4 – To open design view
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 - 打开设计视图
- en: 'Now we can see the design view that shows us what the XML code will cause to
    be displayed when the app is run in the emulator:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到设计视图，它显示了当应用程序在模拟器中运行时XML代码将导致显示的内容：
- en: '![Figure 2.5 – App display'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5 - 应用程序显示'
- en: '](img/Figure_2.05_B16773.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.05_B16773.jpg)'
- en: Figure 2.5 – App display
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 - 应用程序显示
- en: The preceding figure should look familiar because it shows the layout of our
    first app that we ran at the end of the previous chapter – the one with the `fragment_second.xml`
    file from the same folder as `fragment_first.xml`, you will see the second layout
    we saw in the previous chapter, the one that had the **Previous** button on it.
    In fact, there are even more layout-related files than we might first expect,
    but we will get to discussing them in this chapter and the next.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图应该看起来很熟悉，因为它显示了我们在上一章末运行的第一个应用程序的布局 - 与`fragment_first.xml`文件位于同一文件夹中的`fragment_second.xml`文件，你会看到我们在上一章中看到的第二个布局，上面有**Previous**按钮。实际上，与我们最初预期的相比，与布局相关的文件甚至更多，但我们将在本章和下一章中讨论它们。
- en: Most of the work that we do throughout the book when we design apps will be
    done in this design view. It is important, however, to know what is going on behind
    the scenes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们设计应用程序时所做的大部分工作都是在设计视图中完成的。然而，了解幕后发生的事情是很重要的。
- en: 'The design view is a graphical representation of the XML code contained in
    the `fragment_first.xml` file. Click on the **Code** tab (near the **Design**
    tab in the previous figure) to see the XML code which forms the layout. I have
    annotated a screenshot of the XML text, so we can discuss it next:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 设计视图是`fragment_first.xml`文件中包含的XML代码的图形表示。点击**Design**标签旁边的**Code**标签（在上一张图中）可以看到构成布局的XML代码。我已经注释了XML文本的屏幕截图，所以我们可以接下来讨论它：
- en: '![Figure 2.6 – Screenshot of the XML text'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6 - XML文本的屏幕截图'
- en: '](img/Figure_2.06_B16773.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.06_B16773.jpg)'
- en: Figure 2.6 – Screenshot of the XML text
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 - XML文本的屏幕截图
- en: The first thing to note is that this file does not represent the entire layout.
    It does however represent most of the surface area and the entire **Hello first
    fragment** message and the **Next** button. Also, on the left-hand side, we can
    see the now-familiar + and – icons so we can fold and unfold sections of the code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，这个文件并不代表整个布局。但它确实代表了大部分的表面积以及整个**Hello first fragment**消息和**Next**按钮。此外，在左侧，我们可以看到现在熟悉的+和-图标，以便我们可以折叠和展开代码的部分。
- en: UI layout elements
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UI布局元素
- en: If we first look at the part of the code labeled `…ConstraintLayout...`. Now,
    `ConstraintLayout` is a UI element that is used to wrap other parts of the UI.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们首先看一下标记为`…ConstraintLayout...`的代码部分。现在，`ConstraintLayout`是一个用来包裹UI其他部分的UI元素。
- en: When we add a new element to a UI in Android, we always start a line with a
    `<` followed by the element's name.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，当我们向UI添加一个新元素时，我们总是以`<`开头，后面跟着元素的名称。
- en: The code that follows that rather long and cumbersome-looking line defines the
    `layout_width` and `layout_height`. All these attributes define how the `ConstraintLayout`
    element will appear on the user's screen. The attributes for the `ConstraintLayout`
    element end at the first `>` labeled **1b**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 紧随那条看起来相当长而繁琐的代码的是定义了`layout_width`和`layout_height`。所有这些属性定义了`ConstraintLayout`元素在用户屏幕上的显示方式。`ConstraintLayout`元素的属性在第一个标记为**1b**的`>`结束。
- en: If we look at the bottom of our XML screenshot, we will see some code labeled
    `</…ConstraintLayout>`, marks the end of the `ConstraintLayout` element. Anything
    in between the closing `>` of the element's attributes and `</…ConstraintLayout>`,
    which defines its end, is considered a child of the element. So, we can see that
    our `ConstraintLayout` has/contains two child elements. Let's look at those children
    now.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下我们的XML截图底部，我们会看到一些标记为`</…ConstraintLayout>`的代码，标志着`ConstraintLayout`元素的结束。在元素的属性的结束`>`和`</…ConstraintLayout>`之间的任何内容都被视为元素的子元素。因此，我们可以看到我们的`ConstraintLayout`有/包含两个子元素。现在让我们来看看这些子元素。
- en: UI text elements
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UI文本元素
- en: 'Using what we just learned, we can say that the UI element that starts at position
    `<` and its name: `<TextView...`. If we look further into our `TextView` element,
    we can see it has several attributes. It has a `text` attribute that is set to
    `"Hello first fragment"`. This of course is the exact text that our app shows
    to the user. It also has `layout_width` and `layout_height` attributes that are
    both set to `"wrap_content"`. This tells `TextView` it can take up as much space
    as the content it has needs. As we will see throughout the book, there are many
    more attributes available for this and other UI elements. The final attribute
    in `TextView` is `id`, and we will see how we and Android use the `id` attribute
    in the next section when we improve this first app.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们刚学到的知识，我们可以说UI元素从位置`<`开始，其名称为`<TextView...`。如果我们进一步查看我们的`TextView`元素，我们会发现它有几个属性。它有一个`text`属性，设置为`"Hello
    first fragment"`。当然，这就是我们的应用程序向用户显示的确切文本。它还有`layout_width`和`layout_height`属性，都设置为`"wrap_content"`。这告诉`TextView`它可以占用所需的内容空间。正如我们将在整本书中看到的，对于这个和其他UI元素，还有许多其他属性可用。`TextView`中的最后一个属性是`id`，我们将在下一节中看到我们和Android如何使用`id`属性来改进这个第一个应用程序。
- en: 'Notice that the code at `/>`. This marks the end of the `TextView` element.
    This is slightly different to how the end of the `ConstraintLayout` element was
    written. When an element in XML has no children, we can just end it like this:
    `/>`. When the element has children and its end comes further on in the code from
    where its attributes are defined, it is much clearer to end the element by repeating
    its name like this: `</…ConstraintLayout>`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`/>`的代码。这标志着`TextView`元素的结束。这与`ConstraintLayout`元素的结束方式略有不同。当XML中的元素没有子元素时，我们可以像这样结束它：`/>`。当元素有子元素，并且其结束位置在代码中的属性定义之后时，通过重复其名称来结束元素会更清晰，像这样：`</…ConstraintLayout>`。
- en: Note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You might be wondering why the element name for `TextView` is clear and concise
    (simply `TextView`) yet the full name for the `ConstraintView` is preceded by
    complicated apparent clutter (`androidx.constraintlayout.widget.ConstraintLayout`).
    This `ConstraintLayout` element is a special layout that is used to ensure our
    app's compatibility with older versions of Android. As we will see in a minute
    when we add buttons to the app, most elements have simple and concise names.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么`TextView`的元素名称清晰简洁（只是`TextView`），而`ConstraintView`的完整名称前面有复杂的表面混乱（`androidx.constraintlayout.widget.ConstraintLayout`）。这个`ConstraintLayout`元素是一个特殊的布局，用来确保我们的应用程序与较旧版本的Android兼容。正如我们将在一分钟内看到的，当我们向应用程序添加按钮时，大多数元素都有简单而简洁的名称。
- en: UI Button elements
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UI按钮元素
- en: 'Now we should be able to quickly identify that the code that starts at `<`
    and its name: `<Button...`. If we look further into our `Button`, we can see it
    has several attributes. It has a text attribute that is set to `"Next"`. This
    of course is the exact text displayed on the button the user can click. It also
    has `layout_width` and `layout_height` attributes that are both set to `"wrap_content"`.
    This, as with the `TextView` element, causes the onscreen button to take up as
    much space as the content it has needs. The final attribute in `Button` is `id`,
    and for buttons this is often a vital attribute, even more so than for some other
    parts of the UI. As the `id` attribute can distinguish this button from other
    buttons, we can program different functionality for different buttons based on
    the value held in the `id` attribute. We will see this principle in action soon.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够快速识别从`<`开始的代码及其名称：`<Button...`。如果我们进一步查看我们的`Button`，我们会发现它有几个属性。它有一个文本属性，设置为`"Next"`。当然，这是用户可以点击的按钮上显示的确切文本。它还有`layout_width`和`layout_height`属性，都设置为`"wrap_content"`。这与`TextView`元素一样，使得屏幕上的按钮占据所需的内容空间。`Button`中的最后一个属性是`id`，对于按钮来说，这通常是一个至关重要的属性，甚至比UI的其他部分更重要。由于`id`属性可以将此按钮与其他按钮区分开，我们可以根据`id`属性中保存的值为不同的按钮编写不同的功能。我们很快就会看到这个原则在实际中的应用。
- en: Notice that the code at `/>`. As we have come to know, this marks the end of
    the `Button` element.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`/>`处的代码。正如我们所知，这标志着`Button`元素的结束。
- en: We will edit and add to this XML code in the next section and learn more about
    the attributes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中编辑并添加到这个XML代码，并了解更多关于属性的知识。
- en: Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The elements of a layout are often referred to as **widgets**.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 布局的元素通常被称为**小部件**。
- en: Adding buttons to the main layout file
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将按钮添加到主布局文件
- en: Here we will add a couple of button widgets to the screen and we will then see
    a fast way to make them actually do something. We will add a button in two different
    ways, firstly using the visual designer and secondly by adding to and editing
    the XML code directly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将在屏幕上添加一对按钮小部件，然后我们将看到一种快速的方法来使它们真正做些什么。我们将以两种不同的方式添加按钮，首先使用可视化设计师，其次是通过直接添加和编辑XML代码。
- en: Adding a button via the visual designer
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过可视化设计师添加按钮
- en: 'To get started with adding our first button, `fragment_first.xml`, open it
    in the editor and switch back to the design view by clicking the **Design** tab
    (shown next):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始添加我们的第一个按钮，打开`fragment_first.xml`文件编辑器，并通过单击**Design**选项卡（如下所示）切换回设计视图：
- en: '![Figure 2.7 – Design tab'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7 – 设计选项卡'
- en: '](img/Figure_2.07_B16773.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.07_B16773.jpg)'
- en: Figure 2.7 – Design tab
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 设计选项卡
- en: 'Notice to the left-hand side of the layout we have a window that is called
    the **Palette** and is shown next:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意布局左侧有一个名为**Palette**的窗口，如下所示：
- en: '![Figure 2.8 – Palette window'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8 – 调色板窗口'
- en: '](img/Figure_2.08_B16773.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.08_B16773.jpg)'
- en: Figure 2.8 – Palette window
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 调色板窗口
- en: The palette is divided into two parts. The left-hand list has the categories
    of UI elements and allows you to select a category, and then the right-hand side
    shows you all the available UI elements from the currently selected category.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '调色板分为两部分。左侧列表显示了UI元素的类别，并允许您选择一个类别，右侧显示了当前选定类别中所有可用的UI元素。  '
- en: Make sure that the **Common** category is selected as shown in the previous
    figure. Now, left-click and hold on the **Button** widget and then drag it onto
    the layout somewhere near the top center.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 确保选择**Common**类别，如前图所示。现在，左键单击并按住**Button**小部件，然后将其拖放到布局的顶部中间附近。
- en: 'It doesn''t matter if it is not exact. It is good to practice getting it right,
    however. So, if you are not happy with the position of your button, then you can
    left-click it to select it on the layout and then tap the *Delete* key on the
    keyboard to get rid of it. Now you can repeat the previous step until you have
    a new neatly placed button that you are happy with, as here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是很准确也没关系。然而，练习做对是很好的。因此，如果您对按钮的位置不满意，可以在布局上左键单击它，然后在键盘上按*Delete*键将其删除。现在您可以重复上一步，直到您有一个新的整齐放置的按钮，您对此感到满意，如下所示：
- en: '![Figure 2.9 – Updating the layout'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9 – 更新布局'
- en: '](img/Figure_2.09_B16773.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.09_B16773.jpg)'
- en: Figure 2.9 – Updating the layout
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 更新布局
- en: 'At this point, we could run the app on the emulator or on a real device and
    the button would be there – kind of. If we clicked it, there would even be a simple
    animation to represent the button being pressed and released. Feel free to try
    this now if you like. If you do, you will notice that the button isn''t positioned
    as you expect it to be:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以在模拟器或真实设备上运行应用程序，按钮会出现 - 有点。如果我们点击它，甚至会有一个简单的动画来表示按钮被按下和释放。如果您愿意，现在可以自由尝试一下。如果这样做，您会注意到按钮的位置不如您所期望的那样：
- en: '![Figure 2.10 – Button not positioned correctly'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.10 – 按钮位置不正确'
- en: '](img/Figure_2.10_B16773.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.10_B16773.jpg)'
- en: Figure 2.10 – Button not positioned correctly
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – 按钮位置不正确
- en: Don't concern yourself with this apparent anomaly for now; we will look into
    this over the next few sections.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不要担心这个明显的异常；我们将在接下来的几节中进行研究。
- en: Next, we are going to edit the attributes of our button in the **Attributes**
    window.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编辑按钮的属性在**Attributes**窗口中。
- en: Editing the button's attributes
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑按钮的属性
- en: 'Make sure the button is selected by left-clicking it. Now find the **Attributes**
    window to the right of the editing window as shown next:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过左键单击按钮来确保按钮被选中。现在找到编辑窗口右侧的**Attributes**窗口，如下所示：
- en: '![Figure 2.11 – Attributes window'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.11 – 属性窗口'
- en: '](img/Figure_2.11_B16773.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.11_B16773.jpg)'
- en: Figure 2.11 – Attributes window
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 属性窗口
- en: In the previous figure, you can see that we have access to a wide selection
    of attributes from the currently selected UI element. To reveal more of the attributes,
    we click the different categories of attributes and scroll through them using
    the scrollbar to the right. If they are not open already by default, left-click
    on the **Common** **Attributes** and **All Attributes** sections' arrows to reveal
    their options.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个图中，你可以看到我们可以访问当前选定的UI元素的各种属性。要显示更多属性，我们点击不同类别的属性，并使用右侧的滚动条滚动。如果它们默认情况下尚未打开，请左键单击**常用属性**和**所有属性**部分的箭头以显示它们的选项。
- en: Now you can see the full details of the button and we can set about editing
    it. It might seem surprising the substantial number of attributes that something
    as simple as a button has. This is a sign of the versatility and power that the
    Android API provides for UI manipulation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到按钮的全部细节，我们可以开始编辑它。一个简单的按钮具有如此多的属性可能会让人感到惊讶。这表明了Android API为UI操作提供的多功能性和强大性。
- en: As you can see, there is a large array of different attributes that we can edit
    right here in the UI designer. In [*Chapter 13*](B16773_13_ePub_RK.xhtml#_idTextAnchor228)*,
    Anonymous Classes – Bringing Android Widgets to Life*, we will also edit and manipulate
    these attributes using our Java code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们可以在UI设计师中编辑大量不同的属性。在[*第13章*](B16773_13_ePub_RK.xhtml#_idTextAnchor228)*，匿名类-让Android小部件活起来*中，我们还将使用我们的Java代码编辑和操作这些属性。
- en: 'For now, we will edit just one attribute. Scroll the **Attributes** window
    until you see the **onClick** attribute in the **Common Attributes** section and
    then left-click it to select it for editing, as shown here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将只编辑一个属性。滚动**属性**窗口，直到在**常用属性**部分看到**onClick**属性，然后左键单击它以进行编辑，如下所示：
- en: '![Figure 2.12 – Common Attributes section'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.12-常用属性部分'
- en: '](img/Figure_2.12_B16773.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.12_B16773.jpg)'
- en: Figure 2.12 – Common Attributes section
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12-常用属性部分
- en: Note
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you ever have trouble finding an attribute, you can always find it in the
    **All Attributes** section, where attributes are arranged in alphabetical order.
    Therefore, the **onClick** attribute can also be found about two-thirds of the
    way down the lengthy list of the **All Attributes** section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在查找属性时遇到困难，你可以在**所有属性**部分找到它，属性按字母顺序排列。因此，**onClick**属性也可以在**所有属性**部分的冗长列表的下面三分之二处找到。
- en: Type `topClick` in the `t` and uppercase `C`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`t`处键入`topClick`，并大写`C`。
- en: 'The **Attributes** window will look like this when you are done:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，**属性**窗口将如下所示：
- en: '![Figure 2.13 – onClick option'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.13-onClick选项'
- en: '](img/Figure_2.13_B16773.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.13_B16773.jpg)'
- en: Figure 2.13 – onClick option
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13-onClick选项
- en: What we have done here is named the Java method in our code that we want to
    call when this button is clicked by the user. The name is arbitrary but as this
    button is in the top part of the screen, the name seems meaningful and easy to
    remember. The odd casing that we used is a convention that will help us keep our
    code clear and easy to read. We will see the benefits of this as our code gets
    longer and more complicated.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是，在我们的代码中命名我们希望在用户点击此按钮时调用的Java方法。名称是任意的，但由于此按钮位于屏幕顶部，名称似乎有意义且易于记忆。我们使用的奇怪大小写是一种约定，将帮助我们保持代码清晰易读。随着代码变得越来越长和复杂，我们将看到这种约定的好处。
- en: 'Of course, the `topClick` method doesn''t exist yet. Android Studio is very
    helpful, but there are some things we need to do ourselves. We will write this
    method using Java code after we have added another button to our UI. You could
    run the app at this point and it would still work. But if you click the button,
    it will crash, and you will get an error because the method does not exist. Android
    Studio is forewarning us of this impending crash by outlining the **onClick**
    attribute in red, as shown in the previous figure. If you hover the mouse cursor
    over this red outline, you will see the details of the problem: **Corresponding
    method handler… Not found**.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`topClick`方法还不存在。Android Studio非常有帮助，但有些事情我们需要自己做。在我们向UI添加另一个按钮之后，我们将使用Java代码编写此方法。此时你可以运行应用程序，它仍然可以工作。但是如果你点击按钮，它将崩溃，并且会出现错误，因为该方法不存在。Android
    Studio通过用红色轮廓勾画**onClick**属性来预警我们即将发生的崩溃，如前图所示。如果你将鼠标悬停在这个红色轮廓上，你将看到问题的细节:**对应的方法处理程序...未找到**。
- en: Examining the XML code for the new button
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查新按钮的XML代码
- en: Before we add our final button for this project. Click the **Code** tab to switch
    back to seeing the XML code that makes our UI.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在为此项目添加最后一个按钮之前。点击**Code**选项卡，切换回查看制作UI的XML代码。
- en: 'Notice that there is a new block of code among the XML that we examined earlier.
    Here is an image of the new block of code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们之前检查过的XML中有一个新的代码块。这是新代码块的图像：
- en: '![Figure 2.14 – New block of code among the XML'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.14-XML中的新代码块'
- en: '](img/Figure_2.14_B16773.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.14_B16773.jpg)'
- en: Figure 2.14 – New block of code among the XML
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14-XML中的新代码块
- en: 'Also, notice the following details, which should correspond to what we know
    about XML and Android UI elements:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意以下细节，这些细节应该与我们对XML和Android UI元素的了解相对应：
- en: The new code starts with the text `<Button` and ends with `/>`.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新代码以`<Button`开头，以`/>`结尾。
- en: The code has a range of attributes that define the button, including `layoutWidth`
    and `layoutHeight`.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码具有一系列属性，定义了按钮，包括`layoutWidth`和`layoutHeight`。
- en: The code includes the `onClick` attribute that we just added with a value of
    `"topClick"`.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码包括我们刚刚添加的`onClick`属性，其值为`"topClick"`。
- en: The `topClick` value of the `onClick` attribute is underlined in red, showing
    the missing method error.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onClick`属性的`topClick`值被下划线标记为红色，显示缺少方法错误。'
- en: The start and end of the code representing the button are enclosed within the
    `ConstraintLayout` element.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示按钮的代码的开始和结束都包含在`ConstraintLayout`元素中。
- en: 'As in the design view, you can hover the mouse cursor over the red-underlined
    `topClick` code to reveal the details of the problem: **Corresponding method handler…
    Not found**.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计视图中，你可以将鼠标悬停在红色下划线的`topClick`代码上，以显示问题的详细信息：**找不到对应的方法处理程序...**。
- en: Note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: During the writing of this book, Android Studio updated the way it shows errors
    in XML. Currently, it highlights the error in red, not underlining in red as shown
    in the figures and descriptions. The underlining is clearer in black and white
    print so they have been left as they are.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书期间，Android Studio更新了它显示XML中错误的方式。目前，它用红色突出显示错误，而不是像图中和描述中所示的红色下划线。下划线在黑白打印中更清晰，所以它们被保留了。
- en: We can see that the issue is that Android Studio expects a method called `topClick`
    to be implemented within our Java code. We will do this as soon as we have added
    that second button.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到问题是Android Studio期望在我们的Java代码中实现一个名为`topClick`的方法。一旦我们添加了第二个按钮，我们就会这样做。
- en: Adding a button by editing the XML code
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过编辑XML代码添加按钮
- en: Just for variety and to prove that we can, we will now add another button using
    only XML code, not the UI designer. Most of the time, we will use the UI designer,
    but this quick exercise should cement in your mind the relationship between the
    UI designer and the underlying XML code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅为了多样性和证明我们可以，我们现在将添加另一个按钮，只使用XML代码，而不是UI设计工具。大多数时候，我们会使用UI设计工具，但这个快速练习应该巩固你对UI设计工具和底层XML代码之间关系的理解。
- en: We will achieve this by copying and pasting the code for the existing button.
    We will then make some minor edits to the pasted code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过复制和粘贴现有按钮的代码来实现这一点。然后我们将对粘贴的代码进行一些小的编辑。
- en: 'Left-click just before the button code that starts `<Button`. Notice that the
    beginning and end of the code now have a slight highlight:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在按钮代码开始的`<Button`之前左键单击。注意代码的开始和结束现在有了轻微的高亮：
- en: '![Figure 2.15 – Button code'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.15 - 按钮代码'
- en: '](img/Figure_2.15_B16773.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.15_B16773.jpg)'
- en: Figure 2.15 – Button code
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 - 按钮代码
- en: 'This has identified the part of the code we want to copy. Now left-click and
    drag to select all the button code, including the highlighted start and end, as
    shown in this next figure:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经确定了我们要复制的代码部分。现在左键单击并拖动以选择所有按钮代码，包括高亮显示的开始和结束，如下图所示：
- en: '![Figure 2.16 – Select all the button code'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.16 - 选择所有按钮代码'
- en: '](img/Figure_2.16_B16773.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.16_B16773.jpg)'
- en: Figure 2.16 – Select all the button code
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16 - 选择所有按钮代码
- en: Press the *Ctrl + C* keyboard combination to copy the highlighted text. Place
    the keyboard cursor below the existing button code and tap the *Enter* key a few
    times to leave some spare empty lines.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Ctrl + C*键盘组合键复制高亮显示的文本。将键盘光标放在现有按钮代码下方，并按*Enter*键几次留下一些空行。
- en: 'Press the *Ctrl + V* keyboard combination to paste the button code. At this
    point, we have two buttons. There are a couple of problems, however:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Ctrl + V*键盘组合键粘贴按钮代码。此时，我们有两个按钮。然而，有一些问题：
- en: '![Figure 2.17 – Additional error'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.17 - 附加错误'
- en: '](img/Figure_2.17_B16773.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.17_B16773.jpg)'
- en: Figure 2.17 – Additional error
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17 - 附加错误
- en: We have an additional error in both blocks of code that represent our buttons.
    The `id` attribute (in both blocks) is underlined in red. The reason for this
    error is that both buttons have an `id` attribute that is the same. The `id` attribute
    is supposed to distinguish a UI element from all other UI elements. Let's fix
    that.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代表我们的按钮的两个代码块中都有一个额外的错误。`id`属性（在两个代码块中）被用红色下划线标出。这个错误的原因是两个按钮都有相同的`id`属性。`id`属性应该区分一个UI元素和所有其他UI元素。让我们来修复它。
- en: Giving the buttons unique id attributes
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给按钮分配唯一的id属性
- en: 'We could solve the problem by calling the second button, `button2`, but it
    would be more meaningful to change them both. Edit the code in the first button
    to give it an ID of `buttonTop`. To do so, find the following line of code (in
    the first button):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用第二个按钮`button2`来解决问题，但更有意义的是改变它们两个。编辑第一个按钮的代码，给它一个ID为`buttonTop`。要做到这一点，找到以下代码行（在第一个按钮中）：
- en: '[PRE3]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Change it to this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为：
- en: '[PRE4]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Notice the lowercase `b` in `button` and the uppercase `T` in `Top`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`button`中的小写`b`和`Top`中的大写`T`。
- en: 'Now identify this line of code in the second button:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在第二个按钮中找到这行代码：
- en: '[PRE5]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Change it to this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为：
- en: '[PRE6]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The errors on the `id` attribute lines are gone. At this point, you might think
    we can move on to solve our missing method problem.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`属性行上的错误已经消失。此时，你可能会认为我们可以继续解决我们缺少的方法问题了。'
- en: 'However, if you run the app and take a quick glance at it, you will see we
    only appear to have one button. Not only that but (as alluded to previously) the
    buttons are not in the place we expected them to be either:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你运行应用程序并快速浏览一下，你会发现我们似乎只有一个按钮。不仅如此，（如前所述）按钮的位置也不是我们期望的：
- en: '![Figure 2.18 – Single button'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.18 - 单个按钮'
- en: '](img/Figure_2.18_B16773.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.18_B16773.jpg)'
- en: Figure 2.18 – Single button
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18 - 单个按钮
- en: The reason for this is we haven't explicitly positioned them, so they have defaulted
    to the top left. The position we see on the **Design** tab is just a design-time
    position. Let's change that now.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是我们没有明确地定位它们，所以它们默认为左上角。我们在**设计**选项卡上看到的位置只是设计时的位置。让我们现在改变它。
- en: Positioning the two buttons in the layout
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在布局中定位这两个按钮
- en: The reason we can only see one button is that both buttons are in the same position.
    The second button is exactly covering the first button. And even in the **Design**
    tab (feel free to have a look), the buttons are still sat on top of each other,
    although they are in the middle of the screen.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能看到一个按钮的原因是两个按钮都在同一个位置。第二个按钮正好覆盖了第一个按钮。即使在**设计**选项卡中（随时可以查看），按钮仍然叠在一起，尽管它们位于屏幕中间。
- en: Note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You might be wondering why the UI layout tool was designed in this apparently
    counterintuitive way. The reason is flexibility. As we will see in the next two
    chapters, not only is it possible to position UI elements differently at design
    time to when the app is running but there is also a whole bunch of different layout
    schemes that the app designer (that''s you) can choose from to suit their plans.
    This flexibility results in a little awkwardness while learning about Android
    but great design power once you have got past the awkwardness. Don''t worry: we
    will move a step at a time until you have this thing beaten.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么UI布局工具以这种显然反直觉的方式设计。原因是灵活性。正如我们将在接下来的两章中看到的，不仅可以在设计时以不同的方式定位UI元素，而且还有许多不同的布局方案供应用设计者（也就是您）选择以适应他们的计划。这种灵活性在学习Android时会有些尴尬，但一旦您克服了这种尴尬，就会获得很大的设计能力。不要担心：我们会一步一步地进行，直到您掌握了这个技巧。
- en: 'We will make Android Studio solve the problem for us automatically by first
    adding to our code and then using the UI designer. First, let''s get the design-time
    layout right. In the code for the second button, find this line of code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让Android Studio自动为我们解决问题，首先通过添加到我们的代码，然后使用UI设计工具。首先，让我们正确设置设计时布局。在第二个按钮的代码中，找到这行代码：
- en: '[PRE7]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Edit it to be the same as this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将其编辑为与此相同：
- en: '[PRE8]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This subtle change will move the second button down a little, but only for design
    time. If you look in the **Design** tab, the button is positioned neatly underneath
    the first button, but if you run the app on the emulator, they are both still
    in the top-left corner and on top of one another.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微妙的变化会使第二个按钮下移一点，但只在设计时。如果您在**设计**选项卡中查看，按钮将整齐地定位在第一个按钮的下方，但如果您在模拟器上运行应用程序，它们仍然都位于左上角并且彼此重叠。
- en: Note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible, even likely, that the exact `dp` measurements in your layout
    will be slightly different to those shown in the book. As long as the second button's
    `layout_editor_absoluteY` attribute is about `70dp` greater than the first, then
    all will be neat and tidy. Feel free to play with this attribute on both buttons
    while switching between the **Code** and **Design** tabs until the buttons are
    positioned to your liking.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，甚至是肯定的，您的布局中`dp`的精确测量值会与书中所示的略有不同。只要第二个按钮的`layout_editor_absoluteY`属性比第一个大约`70dp`，那么一切都会整洁有序。在**代码**和**设计**选项卡之间切换时，随意调整这两个按钮上的此属性，直到按钮被定位到您喜欢的位置。
- en: 'When you are satisfied with the position of the buttons, switch to the **Design**
    tab and find the **Infer constraints** button, shown next:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当您对按钮的位置满意时，切换到**设计**选项卡，找到**推断约束**按钮，如下所示：
- en: '![Figure 2.19 – Infer constraints button'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.19 - 推断约束按钮'
- en: '](img/Figure_2.19_B16773.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.19_B16773.jpg)'
- en: Figure 2.19 – Infer constraints button
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19 - 推断约束按钮
- en: Click the **Infer constraints** button. Android Studio will edit the XML. Let's
    take a brief look at what has happened behind the scenes. From the end of both
    of the buttons, the following lines of code were removed.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**推断约束**按钮。Android Studio将编辑XML。让我们简要看一下幕后发生了什么。从两个按钮的末尾，以下代码行被移除。
- en: 'If the constraints aren''t being applied, hit the **Clear All Constraints**
    button, which is to the left of **Infer constraints**; sometimes Android Studio
    can get confused and needs to reset the existing constraints before inferring
    the rest:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果约束没有被应用，点击**清除所有约束**按钮，它位于**推断约束**的左侧；有时候Android Studio会混淆并需要重置现有的约束才能推断其余的：
- en: '[PRE9]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These two lines of code were what positioned the buttons horizontally (`…absoluteX`)
    and vertically (`…absoluteY`).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行代码是水平（`…absoluteX`）和垂直（`…absoluteY`）定位按钮的位置。
- en: 'Android Studio also added four lines of code to the first button and three
    to the second. Here is the code added near the start of the first button:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio还为第一个按钮添加了四行代码，为第二个按钮添加了三行。以下是在第一个按钮开头附近添加的代码：
- en: '[PRE10]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code causes the button to have a margin of 30 at the top. But at the top
    relative to what exactly? Look at these three lines of code that were added at
    the end of the first button:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码导致按钮在顶部有30的边距。但是相对于什么来说的顶部？看看添加到第一个按钮末尾的这三行代码：
- en: '[PRE11]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notice the new attributes of `layout_constraintEnd_toEndOf`, `layout_constraintStart_toStartOf`,
    and `layout_constraintTop_toTopOf`. The value assigned to each of these attributes
    is `"parent"`. This causes the first button to be positioned relative to the *parent*
    UI element. The parent is the containing layout: the `ConstraintLayout` element.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`layout_constraintEnd_toEndOf`，`layout_constraintStart_toStartOf`和`layout_constraintTop_toTopOf`的新属性。分配给这些属性的值是`"parent"`。这会导致第一个按钮相对于*parent*
    UI元素定位。父元素是包含布局：`ConstraintLayout`元素。
- en: Now look at the three lines of code added to the second (bottom) button.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看添加到第二（底部）按钮的三行代码。
- en: 'Near the start of the code, we see this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的开头附近，我们看到了这个：
- en: '[PRE12]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And at the end of the code for the second button, we see these two extra lines:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个按钮的代码末尾，我们看到了这两行额外的代码：
- en: '[PRE13]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This means that the second button is positioned with a margin of 22 relative
    to the `buttonTop` widget.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着第二个按钮相对于`buttonTop`小部件有22的边距。
- en: Note
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `dp` code is a unit of measurement/distance and will be discussed in more
    depth in [*Chapter 5*](B16773_05_ePub_RK.xhtml#_idTextAnchor101)*, Beautiful Layouts
    with CardView and ScrollView*. The precise values for the `dp` measurement will
    likely vary slightly on your layout.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`dp`代码是一个测量/距离单位，将在[*第5章*](B16773_05_ePub_RK.xhtml#_idTextAnchor101)*中更深入地讨论，使用CardView和ScrollView创建美丽的布局。`dp`测量的精确值可能会在您的布局上略有不同。'
- en: 'Now run the app and you will see we have two distinct buttons. One has an `id`
    attribute of `buttonTop` and it is above the other button, with an `id` attribute
    of `buttonBottom`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序，您会看到我们有两个不同的按钮。一个具有`buttonTop`的`id`属性，它位于另一个按钮的上方，具有`buttonBottom`的`id`属性：
- en: '![Figure 2.20 – Two button options'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.20 - 两个按钮选项'
- en: '](img/Figure_2.20_B16773.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.20_B16773.jpg)'
- en: Figure 2.20 – Two button options
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20 - 两个按钮选项
- en: Clearly, there is more to layouts than I have alluded to so far, but you have
    had your first glance at one of the options we have to design the UI of our apps.
    We will be taking a closer look at the `ConstraintLayout` layout element as well
    as exploring more layout options in [*Chapter 4*](B16773_04_ePub_RK.xhtml#_idTextAnchor076)*,
    Getting Started with Layouts and Material Design*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，布局还有更多内容，但到目前为止，我已经提到了其中一种我们可以设计应用程序UI的选项。我们将更仔细地研究`ConstraintLayout`布局元素，以及在[*第4章*](B16773_04_ePub_RK.xhtml#_idTextAnchor076)*，开始使用布局和Material
    Design*中探索更多的布局选项。
- en: We want to make one more change in our XML code.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在我们的XML代码中再做一些更改。
- en: Making the buttons call different methods
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使按钮调用不同的方法
- en: 'Switch back to the `buttonBottom`) button:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回到`buttonBottom`按钮：
- en: '[PRE14]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Edit the code to this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑代码如下：
- en: '[PRE15]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now we have two buttons, one above the other. The top one has an `id` attribute
    of `buttonTop` and an `onClick` attribute with a value of `topClick`. The other
    has an `id` attribute of `buttonBottom` and an `onClick` attribute with a value
    of `bottomClick`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个按钮，一个在另一个上面。顶部按钮具有`buttonTop`的`id`属性和值为`topClick`的`onClick`属性。另一个具有`buttonBottom`的`id`属性和值为`bottomClick`的`onClick`属性。
- en: These last XML code changes now mean we need to code two methods (`topClick`
    and `bottomClick`) in our Java code.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些最后的XML代码更改意味着我们需要在我们的Java代码中编写两个方法（`topClick`和`bottomClick`）。
- en: Note
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is OK for two buttons to call the same method when they are clicked; it is
    not a syntax error. However, most buttons do have distinct purposes, so this exercise
    will be more meaningful if our buttons do different things.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击两个按钮调用相同的方法是可以的；这不是语法错误。然而，大多数按钮确实有不同的目的，因此如果我们的按钮执行不同的操作，这个练习将更有意义。
- en: We will do that soon, but before we do, let's learn a little bit more about
    Java comments and look at some Java code we can write to send messages. We will
    learn to send messages to the user to keep them informed and to ourselves for
    debugging purposes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会做到这一点，但在我们这样做之前，让我们更多地了解一下Java注释，并查看一些我们可以编写的Java代码来发送消息。我们将学会向用户发送消息以保持他们的知情和向自己发送消息以进行调试。
- en: Leaving comments in our Java code
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的Java代码中留下注释
- en: 'In programming, it is always a clever idea to write notes, known as code comments,
    and sprinkle them liberally throughout your code. This is to remind us what we
    were thinking at the time we wrote the code. To do this, you simply append a double
    forward slash and then type your comment, as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，写笔记，即代码注释，并在代码中大量使用它们总是一个聪明的主意。这是为了提醒我们在编写代码时的想法。要做到这一点，您只需附加双斜杠，然后输入您的注释，如下所示：
- en: '[PRE16]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In addition, we can use comments to *comment out* a line of code. Suppose we
    have a line of code that we temporarily want to disable. We can do so by adding
    the two forward slashes, like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用注释来*注释掉*一行代码。假设我们有一行代码，我们暂时想要禁用它。我们可以通过添加两个斜杠来实现，就像这样：
- en: '[PRE17]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Using comments to comment out code should only be a temporary measure. Once
    you have found the correct code to use, commented-out code should be deleted to
    keep the code file clean and organized.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注释注释掉代码应该只是一个临时措施。一旦找到正确的代码使用，注释掉的代码应该被删除，以保持代码文件的清洁和有组织。
- en: Let's look at two separate ways to send messages in Android, and then we can
    write some methods that will send messages when our new UI buttons are pressed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在Android中发送消息的两种不同方式，然后我们可以编写一些方法，当我们的新UI按钮被按下时发送消息。
- en: Coding messages to the user and the developer
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写消息给用户和开发人员
- en: In the introduction to this chapter and in the previous chapter, we talked a
    bit about using other people's code, specifically via the classes and their methods,
    of the Android API. We saw that we could do some quite complex things with insignificant
    amounts of code (such as talk to satellites).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的介绍和上一章中，我们谈到了使用其他人的代码，特别是通过Android API的类和它们的方法。我们看到我们可以用微不足道的代码做一些相当复杂的事情（比如与卫星通信）。
- en: To get us started, we are going to use two different classes from the Android
    API that allow us to output messages. The first class, `Log`, allows us to output
    messages to the Logcat window. The second class, `Toast`, is not a tasty breakfast
    treat, but it will produce a toast-shaped pop-up message for our app's user to
    see.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始，我们将使用Android API中的两个不同类来输出消息。第一个类`Log`允许我们将消息输出到Logcat窗口。第二个类`Toast`不是一种美味的早餐，而是会为我们的应用用户产生一个类似吐司的弹出消息。
- en: 'Here is the code we need to write to send a message to the Logcat window:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们需要编写的代码，以向Logcat窗口发送消息：
- en: '[PRE18]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Exactly why this works will become clearer in [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*,
    Object-Oriented Programming*, but for now, we just need to know that whatever
    we put between the two sets of quote marks will be output to the Logcat window.
    We will see where to write this type of code shortly.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这样能够工作将在[*第10章*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*，面向对象编程*中变得更加清晰，但现在，我们只需要知道放在两组引号之间的任何内容都将输出到Logcat窗口。我们很快将看到在哪里编写这种类型的代码。
- en: 'Here is the code we need to write to send a message to the user''s screen:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们需要编写的代码，以向用户屏幕发送消息：
- en: '[PRE19]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is a very convoluted-looking line of code, and exactly how it works, again,
    will not become clear until [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*,
    Object-Oriented Programming.* The important thing here is that whatever we put
    between the quote marks will appear in a pop-up message to our users.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一行非常复杂的代码，它的工作原理将在[*第10章*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*，面向对象编程*中变得更加清晰。这里重要的是，我们放在引号中的任何内容都将出现在我们的用户的弹出消息中。
- en: Let's put some code, much like we have just seen, into our app for real.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把一些代码，就像我们刚刚看到的那样，放到我们的应用程序中。
- en: Writing our first Java code
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的第一个Java代码
- en: So, we now know the code that will output to Logcat or the user's screen. But
    *where* do we write the code? To answer this question, we need to understand that
    the `onCreate` method in `MainActivity.java` executes as the app is preparing
    to be shown to the user. So, if we put our code at the end of this method, it
    will execute just as the user sees the app. Sounds good.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们现在知道了将输出到 Logcat 或用户屏幕的代码。但是*在哪里*写这段代码呢？要回答这个问题，我们需要理解 `MainActivity.java`
    中的 `onCreate` 方法在应用准备展示给用户时执行。因此，如果我们将我们的代码放在这个方法的末尾，它将在用户看到应用时执行。听起来不错。
- en: Note
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'We know that to execute the code in a method, we need to call it. We have wired
    our buttons up to call a couple of methods: `topClick` and `bottomClick`. Soon
    we will write these methods. But who or what is calling `onCreate`!? The answer
    to this mystery is that the Android operating system itself calls `onCreate`.
    It does so when the user clicks the app icon to run the app. In [*Chapter 6*](B16773_06_ePub_RK.xhtml#_idTextAnchor119)*,
    The Android Lifecycle*, we will look deeper at this phenomenon, and it will be
    clear exactly what code executes and when. You don''t need to completely comprehend
    this now. I just wanted to give you an overview of what was going on.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道要执行方法中的代码，我们需要调用它。我们已经将我们的按钮连接起来调用了一些方法：`topClick` 和 `bottomClick`。很快我们将编写这些方法。但是谁或什么在调用
    `onCreate` 呢？这个谜团的答案是，Android 操作系统本身调用 `onCreate`。当用户点击应用图标运行应用时，它会这样做。在[*第6章*](B16773_06_ePub_RK.xhtml#_idTextAnchor119)*，Android
    生命周期*中，我们将更深入地研究这一现象，清楚地了解代码何时执行。你现在不需要完全理解这一点。我只是想给你一个概述。
- en: Let's quickly try this out. Switch to the `MainActivity.java` tab in Android
    Studio.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速尝试一下。在 Android Studio 中切换到 `MainActivity.java` 标签。
- en: We know that the `onCreate` method is called just before the app starts. Let's
    copy and paste some code into the `onCreate` method of our app and see what happens
    when we run it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 `onCreate` 方法在应用启动之前被调用。让我们将一些代码复制粘贴到我们应用的 `onCreate` 方法中，看看当我们运行它时会发生什么。
- en: Adding message code to the onCreate method
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将消息代码添加到 onCreate 方法
- en: 'Find the closing curly brace `}` of the `onCreate` method and add the highlighted
    code shown next. In the code, I haven''t shown the complete contents of the `onCreate`
    method but have used `…` to indicate some lines of code not being shown. The important
    thing is to place the new code (shown in full) right at the end but before that
    closing curly brace, `}`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 找到 `onCreate` 方法的结束大括号 `}`，并添加下面显示的高亮代码。在代码中，我没有显示 `onCreate` 方法的完整内容，而是使用 `…`
    表示一些未显示的代码行。重要的是将新代码（完整显示）放在最后，但在那个结束大括号 `}` 之前：
- en: '[PRE20]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that the two instances of the word `Toast` and the word `Log` are highlighted
    in red in Android Studio. They are errors. We know that `Toast` and `Log` are
    classes and that classes are containers for code.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 Android Studio 中两个 `Toast` 和 `Log` 的实例被标记为红色。它们是错误。我们知道 `Toast` 和 `Log`
    是类，而类是代码的容器。
- en: The problem is that Android Studio doesn't know about them until we tell it
    about them. We must add an `import` for each class. Fortunately, this is semi-automatic.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，Android Studio 在我们告诉它之前并不知道它们。我们必须为每个类添加一个 `import`。幸运的是，这是半自动的。
- en: Left-click on the red `Toast` code in the `onCreate` method. Now hold the *Alt*
    key and then tap *Enter*. When prompted, choose `Log`. Android Studio adds the
    import directives at the top of the code with our other imports and the errors
    are gone.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `onCreate` 方法中左键单击红色的 `Toast` 代码。现在按住 *Alt* 键，然后点击 *Enter*。在提示时，选择 `Log`。Android
    Studio 将在代码顶部添加 `import` 指令，与我们的其他导入一起，错误消失了。
- en: Note
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*Alt + Enter* is just one of many useful keyboard shortcuts. The following
    link is to a keyboard shortcut reference for Android Studio. More specifically,
    it is for the IntelliJ Idea IDE, upon which Android Studio is based. Look at and
    bookmark this web page; it will be invaluable over the course of this book: [http://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf](http://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf).'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*Alt + Enter* 只是众多有用的键盘快捷键之一。以下链接是 Android Studio 的键盘快捷键参考。更具体地说，它是基于 IntelliJ
    Idea IDE 的。查看并收藏这个网页；在本书的过程中它将非常有价值：[http://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf](http://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf)。'
- en: 'Scroll to the top of `MainActivity.java` and look at the added `import` directives.
    Here they are for your convenience:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动到 `MainActivity.java` 的顶部，查看添加的 `import` 指令。这里是为了方便你的：
- en: '[PRE21]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Run the app in the usual way and look at the output in the **Logcat** window.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 以通常的方式运行应用程序，并查看 **Logcat** 窗口中的输出。
- en: Examining the output
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查输出
- en: 'The next figure shows a screenshot of the output in the **Logcat** window:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张图显示了 Logcat 窗口中输出的屏幕截图：
- en: '![Figure 2.21 – Output in the Logcat window'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.21 – Logcat 窗口中的输出'
- en: '](img/Figure_2.21_B16773.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.21_B16773.jpg)'
- en: Figure 2.21 – Output in the Logcat window
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21 – Logcat 窗口中的输出
- en: 'Look at the **Logcat** window, you can see our message **Done creating the
    app** was output, although it is mixed up among other system messages that we
    are currently not interested in. If you watch the emulator when the app first
    starts, you will also see the neat pop-up message that the user will see:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 **Logcat** 窗口，你可以看到我们的消息 **Done creating the app** 被输出了，尽管它混在我们目前不感兴趣的其他系统消息中。当应用首次启动时，观察模拟器，你也会看到用户将看到的漂亮的弹出消息：
- en: '![Figure 2.22 – Pop-up message'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.22 – 弹出消息'
- en: '](img/Figure_2.22_B16773.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.22_B16773.jpg)'
- en: Figure 2.22 – Pop-up message
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22 – 弹出消息
- en: It is possible that you might be wondering why the messages were output at the
    time they were. The answer is that the `onCreate` method is called just *before*
    the app starts to respond to the user. It is for this reason, it's common practice
    among Android developers to put code in this method to get their apps set up and
    ready for the user.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么消息在那个时候被输出。答案是 `onCreate` 方法在应用开始响应用户之前被调用。因此，这是 Android 开发人员常见的做法，将代码放在这个方法中，为他们的应用做好准备。
- en: Now we will go a step further and write our own methods that will be called
    by our two buttons in the UI. We will place similar `Log` and `Toast` messages
    inside these new methods.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将进一步编写我们自己的方法，这些方法将由UI中的两个按钮调用。我们将在这些新方法中放置类似的`Log`和`Toast`消息。
- en: Writing our own Java methods
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写我们自己的Java方法
- en: Let's get straight on with writing our first Java methods with some more `Log`
    and `Toast` messages inside them.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接开始编写我们的第一个Java方法，其中包含更多的`Log`和`Toast`消息。
- en: Note
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Now would be a good time, if you haven't already, to get the download bundle
    that contains all the code files. You can view the completed code for each chapter.
    For example, the completed code for this chapter can be found in the [*Chapter
    2*](B16773_02_ePub_RK.xhtml#_idTextAnchor043) folder. I have further subdivided
    the [*Chapter 2*](B16773_02_ePub_RK.xhtml#_idTextAnchor043) folder into `java`
    and `res` folders (for Java and resource files). In chapters with more than one
    project, I will divide the folders further to include the project name. You should
    view these files in a text editor. My favorite is Notepad++, a free download from
    [https://notepad-plus-plus.org/download/](https://notepad-plus-plus.org/download/).
    The code viewed in a text editor is easier to read than from the book directly,
    especially the paperback version, and even more so where the lines of code are
    long. The text editor is also a great way to select sections of the code to copy
    and paste into Android Studio. You could open the code in Android Studio, but
    then you'd risk mixing up my code with the auto-generated code of Android Studio.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是一个好时机，如果你还没有的话，可以获取包含所有代码文件的下载包。您可以查看每个章节的完成代码。例如，本章的完成代码可以在[*第2章*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)文件夹中找到。我进一步将[*第2章*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)文件夹细分为`java`和`res`文件夹（用于Java和资源文件）。在有多个项目的章节中，我将进一步划分文件夹以包含项目名称。您应该在文本编辑器中查看这些文件。我的最爱是Notepad++，可以从[https://notepad-plus-plus.org/download/](https://notepad-plus-plus.org/download/)免费下载。在文本编辑器中查看的代码比直接从书中查看更容易阅读，尤其是平装版本，尤其是代码行很长的情况下。文本编辑器还是选择代码部分复制粘贴到Android
    Studio中的好方法。您可以在Android Studio中打开代码，但那样您就有可能将我的代码与Android Studio的自动生成代码混淆。
- en: Identify the closing curly brace, `}`, of the `MainActivity` class.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 找到`MainActivity`类的结束大括号`}`。
- en: Note
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You are looking for the end of the entire class, not the end of the `onCreate`
    method as in the previous section. Take your time to identify the new code and
    where it goes among the existing code.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您要寻找整个类的结束，而不是前一节中`onCreate`方法的结束。花些时间来识别新代码以及它在现有代码中的位置。
- en: Inside that curly brace, enter the following code that is highlighted.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在该大括号内，输入以下突出显示的代码。
- en: '[PRE22]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that the two instances of the word `View` might be red, indicating an
    error. Simply use the *Alt + Enter* keyboard combination to import the `View`
    class and remove the errors.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`View`这两个词可能是红色的，表示有错误。只需使用*Alt + Enter*键组合导入`View`类并删除错误。
- en: Note
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The reason I said there "might" be an error is because it depends on how you
    entered the code. If you copied and pasted the code, then Android Studio may automatically
    add the `View` class import code. If you typed the new code, then the error will
    appear, and you will need to use the *Alt + Enter* key solution. This is just
    a quirk of Android Studio.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以说这里“可能”会有错误，是因为这取决于您输入代码的方式。如果您复制并粘贴了代码，那么Android Studio可能会自动添加`View`类导入代码。如果您输入了新代码，那么错误将出现，并且您需要使用*Alt
    + Enter*键解决方案。这只是Android Studio的一个怪癖。
- en: Deploy the app to a real device or emulator in the usual way and start tapping
    the buttons so we can observe the output.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以通常的方式将应用程序部署到真实设备或模拟器，并开始点击按钮，以便我们观察输出。
- en: Examining the output
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查输出
- en: At last, our app does something we told it to do when we told it to do it. We
    can see that the method names we defined in the button `onClick` attribute are
    indeed called when the buttons are clicked, and the appropriate messages are added
    to the `Toast` messages are shown to the user.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的应用程序在我们告诉它执行操作时确实执行了我们告诉它执行的操作。我们可以看到，我们在按钮的`onClick`属性中定义的方法名称确实在点击按钮时被调用，并且适当的消息被添加到`Toast`消息中显示给用户。
- en: Admittedly, we still don't understand why or how the `Toast` and `Log` classes
    really work, neither do we fully comprehend the `public void` and `(View v)` parts
    of our method's syntax (or much of the rest of the auto-generated code). This
    will become clearer as we progress. As said previously, in [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*,
    Object-Oriented Programming*, we will take a deep dive into the world of classes,
    and in [*Chapter 9*](B16773_09_ePub_RK.xhtml#_idTextAnchor169)*, Learning Java
    Methods*, we will master the rest of the syntax associated with methods.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，我们仍然不明白`Toast`和`Log`类是如何工作的，我们也不完全理解我们方法语法中的`public void`和`(View v)`部分（或者自动生成的代码的其他部分）。随着我们的进展，这将变得更清晰。如前所述，在[*第10章*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*，面向对象编程*中，我们将深入探讨类的世界，在[*第9章*](B16773_09_ePub_RK.xhtml#_idTextAnchor169)*，学习Java方法*中，我们将掌握与方法相关的其余语法。
- en: 'Check the `onCreate` method just as before, as well as from the two methods
    that we wrote ourselves, each time you clicked one of the buttons. In the following
    figure, you can see I clicked each button three times:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 像以前一样检查`onCreate`方法，以及我们自己编写的两个方法，每次点击按钮时。在下图中，您可以看到我点击了每个按钮三次：
- en: '![Figure 2.23 – Logcat window output'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.23 - Logcat窗口输出'
- en: '](img/Figure_2.23_B16773.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.23_B16773.jpg)'
- en: Figure 2.23 – Logcat window output
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23 - Logcat窗口输出
- en: 'As you are now familiar with where to find the **Logcat** window, in future
    I will present **Logcat** output as trimmed text as follows, as it is easier to
    read:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了在哪里找到**Logcat**窗口，以后我将以修剪后的文本形式呈现**Logcat**输出，因为这样更容易阅读：
- en: '[PRE23]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And in the next figure, you can see that the top button has been clicked and
    the `topClick` method was called, triggering the pop-up `Toast` message highlighted
    here:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个图中，您可以看到顶部按钮已被点击，并调用了`topClick`方法，触发了弹出的`Toast`消息，如下所示：
- en: '![Figure 2.24 – Pop-up Toast message'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.24 – 弹出的Toast消息'
- en: '](img/Figure_2.24_B16773.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.24_B16773.jpg)'
- en: Figure 2.24 – Pop-up Toast message
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.24 – 弹出的Toast消息
- en: Throughout this book, we will regularly output to the **Logcat** window, so
    we can see what is going on behind the UI of our apps. Toast messages are more
    for notifying the user that something has occurred. This might be a download that
    has completed, a new email that has arrived, or some other occurrence that the
    user might want to be informed about.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将定期输出到**Logcat**窗口，这样我们就可以看到应用程序界面背后发生了什么。Toast消息更多用于通知用户发生了某些事情。这可能是下载完成了，收到了新的电子邮件，或者用户可能想要被告知的其他事件。
- en: Frequently asked questions
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题
- en: Can you remind me what methods are?
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能提醒我方法是什么吗？
- en: Methods are containers for our code that can be executed (called) from other
    parts of our code. Methods are contained within a class.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是我们的代码的容器，可以从代码的其他部分执行（调用）。方法包含在一个类中。
- en: Like the first, I found this chapter tough going. Do I need to reread it?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像第一章一样，我觉得这一章很难。我需要重新阅读吗？
- en: No; if you managed to build the app, you have made enough progress to handle
    the next chapter. All the blanks in your knowledge will be steadily filled in
    and replaced with glorious moments of realization as the book progresses.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 不，如果你成功构建了应用程序，你已经取得了足够的进步来处理下一章。你知识中的所有空白将会逐渐填补，并在书籍的进展中被光荣的领悟时刻所取代。
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have achieved a lot in this chapter. It is true that much of the XML code
    is still generally incomprehensible. That's OK, because in the next two chapters
    we will be really getting to grips with the visual designer and learning more
    about XML, although ultimately our aim is to use XML as little as possible.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们取得了很多成就。的确，很多XML代码仍然晦涩难懂。没关系，因为在接下来的两章中，我们将真正掌握可视化设计工具，并更多地了解XML，尽管我们的最终目标是尽量少使用XML。
- en: We have seen how, when we drag a button onto our design, the XML code is generated
    for us. Also, if we change an attribute in the **Attributes** window, then, again,
    the XML code is edited for us. Furthermore, we saw that we can type (or, in our
    case, copy and paste) XML code directly in the **Code** tab to create new buttons
    on our UI or edit existing ones.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，当我们将按钮拖放到设计中时，XML代码会为我们生成。此外，如果我们在**属性**窗口中更改属性，那么XML代码也会被编辑。此外，我们还看到我们可以直接在**代码**选项卡中输入（或者在我们的情况下，复制和粘贴）XML代码，以在我们的UI上创建新按钮或编辑现有按钮。
- en: We have seen as well as written our first Java, including comments that help
    us document our code, and we have even added our own methods to output debugging
    messages to the Logcat window and pop-up `Toast` messages to the user.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅看到了我们的第一个Java代码，还写了注释来帮助我们记录我们的代码，并且甚至添加了自己的方法来将调试消息输出到Logcat窗口和弹出`Toast`消息给用户。
- en: In the next chapter, we will take a full guided tour of Android Studio to see
    exactly where different things get done at the same time as understanding how
    our project's assets, such as files and folders, are structured and how we can
    manage them. This will prepare us to go for a more in-depth look at UI design
    in [*Chapter 4*](B16773_04_ePub_RK.xhtml#_idTextAnchor076)*, Getting Started with
    Layouts and Material Design,* and [*Chapter 5*](B16773_05_ePub_RK.xhtml#_idTextAnchor101)*,
    Beautiful Layouts with CardView and ScrollView*, when we will build some significant
    real-world layouts for our apps.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将全面介绍Android Studio，确切地了解不同的事情是如何同时完成的，同时了解我们项目的资产，如文件和文件夹的结构以及我们如何管理它们。这将为我们准备好深入研究UI设计，包括[*第4章*](B16773_04_ePub_RK.xhtml#_idTextAnchor076)*，开始使用布局和Material
    Design*，以及[*第5章*](B16773_05_ePub_RK.xhtml#_idTextAnchor101)*，使用CardView和ScrollView创建美丽的布局*，届时我们将为我们的应用程序构建一些重要的真实布局。
