- en: Building a Blog with React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React构建博客
- en: 'Hey! Good work making it to the last section of the book, where you are going
    to learn Facebook''s React library. Before we start with this chapter, let''s
    take a look at your journey through the book:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿！做到了书的最后一节，你将学习Facebook的React库。在我们开始本章之前，让我们回顾一下你在书中的学习之旅：
- en: You first built a simple ToDo list app using the JavaScript's ES6 syntax and
    then created a build script to compile it down to ES5 so that it will be compatible
    with older browsers.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你首先使用JavaScript的ES6语法构建了一个简单的待办事项应用，然后创建了一个构建脚本将其编译为ES5，以便与旧版浏览器兼容。
- en: Then, you built a Meme Creator while setting up your own automated development
    environment, learning lots of new concepts and tools along the way.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在设置自己的自动化开发环境的同时，你构建了一个Meme Creator，学习了许多新概念和工具。
- en: Next, you used the development environment and built an Event Registration app
    in which you built your first reusable JavaScript module for API calls and form
    validation.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，你使用开发环境构建了一个活动注册应用程序，在其中构建了你的第一个可重用的JavaScript模块，用于API调用和表单验证。
- en: Then, you utilized the power of JavaScript WebAPIs to build a peer-to-peer video
    calling app with WebRTC.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，你利用JavaScript WebAPI的强大功能构建了一个使用WebRTC的点对点视频通话应用程序。
- en: Lastly, you built your own HTML5 custom element that will display a weather
    widget and can be easily imported and used with other projects.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，你构建了自己的HTML5自定义元素，它将显示一个天气小部件，并可以轻松导入和在其他项目中使用。
- en: From a beginner level, you built some really awesome applications and now you
    are familiar with many important concepts of modern JavaScript. Now, it's time
    for you to employ these skills to learn a JavaScript framework, which will turbocharge
    your development process. This chapter will focus on helping you get started with
    React.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从初学者级别开始，你构建了一些非常棒的应用程序，现在你熟悉了现代JavaScript的许多重要概念。现在，是时候利用这些技能学习JavaScript框架了，这将加速你的开发过程。本章将重点帮助你开始使用React。
- en: Why use a framework?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用框架？
- en: Modern application development is all about speed, maintainability, and scalability.
    Given the web is the major platform for many applications, the same will be expected
    for any web applications. JavaScript may be a great language but writing plain
    JavaScript can be a tedious process at times when you are dealing with a large
    application in a team environment.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序开发都是关于速度、可维护性和可扩展性的。鉴于Web是许多应用程序的主要平台，对于任何Web应用程序都会有相同的期望。JavaScript可能是一种很棒的语言，但在团队环境中处理大型应用程序时，编写纯JavaScript有时可能是一个繁琐的过程。
- en: In such applications, you will have to manipulate a lot of DOM elements. Whenever
    you make changes to the CSS of a DOM element, it is called a repaint. It will
    affect how an element appears on the browser. Whenever you remove, change, or
    add an element in the DOM, then it is called a reflow. A reflow of a parent element
    causes all its child elements to reflow too. Repaints and reflows are expensive
    operations because they are synchronous. It means when a repaint or reflow happens,
    JavaScript will not be able to run at that time. This will lead to lagging or
    slow execution of web applications (especially on smaller devices, such as low-end
    smartphones). So far, we have been building very small applications; therefore,
    we haven't noticed any performance issues but for applications, such as Facebook,
    this is crucial (there are literally 1,000s of DOM elements).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的应用程序中，你将不得不操作大量的DOM元素。每当你更改DOM元素的CSS时，它被称为重绘。这将影响元素在浏览器上的显示。每当你在DOM中删除、更改或添加一个元素时，这被称为回流。父元素的回流也会导致其所有子元素的回流。重绘和回流是昂贵的操作，因为它们是同步的。这意味着当重绘或回流发生时，JavaScript将无法在那个时候运行。这将导致Web应用程序的延迟或缓慢执行（特别是在较小的设备上，如低端智能手机）。到目前为止，我们一直在构建非常小的应用程序；因此，我们还没有注意到任何性能问题，但对于像Facebook这样的应用程序来说，这是至关重要的（有成千上万的DOM元素）。
- en: Also, writing lot of JavaScript code means increasing the file size of your
    code. For mobile users who rely on 3G or lower connections, it means your application
    will take a longer time to load. This causes a bad user experience.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，编写大量的JavaScript代码意味着增加代码文件的大小。对于依赖3G或更低连接的移动用户来说，这意味着你的应用程序加载时间会更长。这会导致糟糕的用户体验。
- en: Finally, frontend JavaScript code needs to deal with a lot of side effects (events
    such as click, scroll, hover, and network requests). When working in a team environment,
    every developer should know what kind of side effects your code deals with. When
    the web application grows, every side effect needs to be properly tracked. In
    plain JavaScript, writing maintainable code in such an environment is also difficult.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，前端JavaScript代码需要处理大量的副作用（例如点击、滚动、悬停和网络请求等事件）。在团队环境中工作时，每个开发人员都应该知道你的代码处理的是什么类型的副作用。当Web应用程序增长时，每个副作用都需要被正确跟踪。在纯JavaScript中，在这样的环境中编写可维护的代码也是困难的。
- en: Luckily, the JavaScript community is well aware of all these scenarios and,
    hence, there are lots of open source JavaScript libraries and frameworks created
    and actively maintained to address the preceding issues and improve developer
    productivity.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，JavaScript社区对所有这些情况都有很好的认识，因此有许多开源的JavaScript库和框架被创建并积极维护，以解决上述问题并提高开发人员的生产力。
- en: Selecting a framework
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择一个框架
- en: Choosing a JavaScript framework in 2017 is more difficult than learning JavaScript
    itself (yeah, it's true!) due to the release of a new framework almost every week.
    But unless your requirement is very specific, you won't need to worry about most
    of them. Currently, there are a few frameworks that are really popular among the
    developers, such as React, Vue.js, Angular, Ember, and so on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在2017年选择JavaScript框架比学习JavaScript本身更困难（是的，这是真的！）因为几乎每周都会发布一个新的框架。但除非你的需求非常具体，否则大多数情况下你不需要担心它们。目前，有一些框架在开发者中非常受欢迎，比如React、Vue.js、Angular、Ember等。
- en: These frameworks are really popular because they get you up and running with
    your application in almost no time, followed by excellent support from the huge
    community of developers who use these frameworks. These frameworks also come with
    their own build tools, which will save you the trouble of setting up your own
    development environment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些框架非常受欢迎，因为它们可以让你几乎立即启动应用程序，并得到来自使用这些框架的庞大开发人员社区的出色支持。这些框架还配备了它们自己的构建工具，这将为你节省设置自己的开发环境的麻烦。
- en: React
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React
- en: In this chapter, we are going to learn the basics of building web applications
    with React. React is built and is widely used by Facebook. Many other famous applications,
    such as Instagram, Airbnb, Uber, Pinterest, Periscope, and so on, also use React
    in their web applications, which has helped to develop React into a mature and
    battle-tested JavaScript library. At the time of writing this book, React is the
    most popular frontend JavaScript framework in GitHub with an active community
    of over 70,000 developers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学习使用React构建Web应用程序的基础知识。React是由Facebook开发并广泛使用的。许多其他知名应用程序，如Instagram、Airbnb、Uber、Pinterest、Periscope等，也在它们的Web应用程序中使用React，这有助于将React发展成为一个成熟且经过实战考验的JavaScript库。在撰写本书时，React是GitHub上最受欢迎的前端JavaScript框架，拥有超过70,000名活跃开发人员的社区。
- en: Unlike most of the other JavaScript frameworks, React does not consider itself
    a framework but as a library for building user interfaces. It perfectly handles
    the view layer of your application by composing each section of your app into
    smaller functional components.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他JavaScript框架不同，React不认为自己是一个框架，而是一个用于构建用户界面的库。它通过将应用程序的每个部分组合成更小的功能组件来完美处理应用程序的视图层。
- en: 'Functions are simple JavaScript code that perform a task. We have been using
    functions since the very beginning of this book. React uses the concept of functions
    to build each component of the web app. For example, look at the following element:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是执行任务的简单JavaScript代码。我们从本书的一开始就一直在使用函数。React使用函数的概念来构建Web应用程序的每个组件。例如，看一下以下元素：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Say you want to replace the word `world` with a dynamic variable, for example,
    someone''s name. React achieves this by converting the element into a result of
    a function:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想用一个动态变量，比如某人的名字，来替换单词`world`。React通过将元素转换为函数的结果来实现这一点：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, the function `hello` contains the required elements as its result. If
    you try, `hello(''Rahul'')`, you will get the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，函数`hello`包含所需的元素作为其结果。如果你尝试`hello('Rahul')`，你将得到以下结果：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: But wait! What is that `React.createElement()` method? Forgot to tell you. That
    is how React creates HTML elements. But applying that to building applications
    is impossible for us! Imagine how many of those you will have to type in order
    to create an application with lots of DOM elements.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！那个`React.createElement()`方法是什么？忘了告诉你。这就是React创建HTML元素的方式。但是对我们来说，应用这个方法来构建应用程序是不可能的！想象一下，为了创建一个包含大量DOM元素的应用程序，你将不得不输入多少个这样的方法。
- en: 'For this purpose, React introduced **JavaScript inside XML** (**JSX**). It
    is the process of writing an XML-styled markup inside JavaScript, which gets compiled
    to the `React.createElement()` method by React to cut a long story short, you
    can also write the `hello` function as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，React引入了**JavaScript inside XML**（**JSX**）。这是在JavaScript中编写XML样式的标记的过程，它被编译成`React.createElement()`方法。简而言之，你也可以将`hello`函数写成如下形式：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will make more sense because we are simply writing HTML inside the return
    statement of JavaScript. What''s cool about this is the content of the element
    depends directly on the parameter of the function. You need to note a few things
    while working with JSX:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更有意义，因为我们只是在JavaScript的返回语句中写HTML。这样做的酷之处在于元素的内容直接取决于函数的参数。在使用JSX时，你需要注意一些事项：
- en: The attributes of JSX elements cannot contain JavaScript keywords. See that
    the class attribute is replaced with `className` because a class is a reserved
    keyword in JavaScript. Similarly, for attribute, it becomes `htmlFor`.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX元素的属性不能包含JavaScript关键字。注意，class属性被替换为`className`，因为class是JavaScript中的保留关键字。同样，对于for属性，它变成了`htmlFor`。
- en: To include variables or expressions inside JSX, you should wrap them inside
    curly braces `{}`. It is similar to `${}` we use in template strings.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在JSX中包含变量或表达式，你应该将它们包裹在花括号`{}`中。这类似于我们在模板字符串中使用的`${}`。
- en: JSX requires the Babel React preset to get compiled to JavaScript.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX需要Babel React预设来编译成JavaScript。
- en: All the HTML elements in JSX should only use small case letters.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX中的所有HTML元素应该只使用小写字母。
- en: 'For example: `<p></p>`, `<div></div>`, and `<a></a>`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：`<p></p>`、`<div></div>`和`<a></a>`。
- en: Having capital letters for HTML is invalid.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在HTML中使用大写字母是无效的。
- en: 'For example: `<Div></Div>` and `<Input></Input>` are all invalid.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：`<Div></Div>`和`<Input></Input>`都是无效的。
- en: The custom components we created should start with capital letters.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建的自定义组件应该以大写字母开头。
- en: 'For example: consider the `hello` function that we created before, which is
    a stateless React component. To include it in JSX, you should name it as `Hello`
    and include it as `<Hello></Hello>`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如：考虑我们之前创建的`hello`函数，它是一个无状态的React组件。要在JSX中包含它，你应该将它命名为`Hello`，并将其包含为`<Hello></Hello>`。
- en: The preceding function is a simple **stateless** React component. A stateless
    React component outputs elements directly depending on the variables supplied
    as parameters to the function. Its output does not depend on any other factors.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数是一个简单的**无状态**React组件。一个无状态的React组件根据作为参数传递给函数的变量直接输出元素。它的输出不依赖于任何其他因素。
- en: Detailed information on JSX can be found at: [https://facebook.github.io/react/docs/jsx-in-depth.html](https://facebook.github.io/react/docs/jsx-in-depth.html).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有关JSX的详细信息，请参阅：[https://facebook.github.io/react/docs/jsx-in-depth.html](https://facebook.github.io/react/docs/jsx-in-depth.html)。
- en: This representation is suitable for smaller elements but many DOM elements come
    with a variety of side effects, such as DOM events and AJAX calls that will cause
    modification of DOM elements from factors (or variables) outside the scope of
    the function. To address this, React came up with a concept of **stateful** components.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示适用于较小的元素，但许多DOM元素带有各种副作用，例如DOM事件和会导致DOM元素修改的AJAX调用，这些副作用来自于函数范围之外的因素（或变量）。为了解决这个问题，React提出了**有状态**组件的概念。
- en: 'A stateful component has a special variable called `state`. The `state` variable
    contains a JavaScript object and it should be immutable. We''ll look at immutability
    in a moment. For now, look at the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有状态的组件有一个特殊的变量叫做`state`。`state`变量包含一个JavaScript对象，它应该是不可变的。我们稍后会看不可变性。现在，看看以下代码：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a simple stateful React component. As you can see, we are extending
    a class from the `React.Component` interface similar to how we extended it from
    `HTMLElement` to create our custom elements in the previous chapter and, just
    like custom elements, React components also have life cycle methods.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的有状态React组件。正如你所看到的，我们正在从`React.Component`接口扩展一个类，类似于我们如何从`HTMLElement`扩展它来创建我们在上一章中的自定义元素，就像自定义元素一样，React组件也有生命周期方法。
- en: 'The react lifecycle methods are called at different stages of a component being
    inserted into the DOM or when it gets updated. The following life cycle methods
    are called (in the exact order) when a component is being inserted into the DOM:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: React生命周期方法在组件被插入到DOM中或更新时的不同阶段被调用。以下生命周期方法在组件被插入到DOM中时被调用（按照确切的顺序）：
- en: constructor()
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: constructor()
- en: componentWillMount()
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: componentWillMount()
- en: render()
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: render()
- en: componentDidMount()
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: componentDidMount()
- en: The following lifecycle methods are called when an update is caused due to change
    of state or props of the component.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下生命周期方法在组件状态或属性改变导致更新时被调用。
- en: componentWillReceiveProps()
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: componentWillReceiveProps()
- en: shouldComponentUpdate()
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: shouldComponentUpdate()
- en: componentWillUpdate()
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: componentWillUpdate()
- en: render()
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: render()
- en: componentDidUpdate()
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: componentDidUpdate()
- en: 'There is also a lifecycle method which is called when the component is being
    removed from the DOM:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个生命周期方法在组件从DOM中移除时被调用：
- en: componentWillUnmount()
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: componentWillUnmount()
- en: For a detailed explanation of how each of the lifecycle method works in react,
    refer the following page in react documentation: [https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle](https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有关React中每个生命周期方法如何工作的详细解释，请参考React文档中的以下页面：[https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle](https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle)
- en: The `render` method in the preceding `Counter` class is one of the lifecycle
    methods of a React component. As the name suggests, a `render()` method is used
    to render the elements in the DOM. The `render` method is called whenever a component
    is mounted and updated.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`Counter`类中的`render`方法是React组件的生命周期方法之一。顾名思义，`render()`方法用于在DOM中渲染元素。每当组件被挂载和更新时，都会调用`render`方法。
- en: An update in a React component happens whenever a `state` or `props` of the
    component get changed. We haven't looked at props yet. To detect the change of
    the state variable, React requires the state to be an immutable object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在React组件中，当`state`或`props`发生变化时会发生更新。我们还没有看过props。为了检测状态变量的变化，React要求状态是不可变对象。
- en: Immutable state
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变状态
- en: An immutable object is an object that cannot be changed once it is set! Yup,
    that's right. Once you create that object, there is no going back. That gets you
    wondering *"What if I need to modify a property of that object?"* Well, it's simple;
    you simply create a new object from the old object but with the new property this
    time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象是一旦设置就无法更改的对象！是的，没错。一旦你创建了那个对象，就无法回头了。这让你想知道“如果我需要修改该对象的属性怎么办？”好吧，很简单；你只需从旧对象创建一个新对象，但这次带有新属性。
- en: 'Now, that may seem like a lot of work, but trust me, it is actually better
    to create a new object. Because, most of the time, React simply needs to know
    if the object is changed to update the view. For example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这可能看起来是很多工作，但相信我，创建一个新对象实际上更好。因为大多数时候，React只需要知道对象是否改变以更新视图。例如：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a standard way of changing the property of a JavaScript object. Here,
    let's call it the mutable way. Great! You just modified the state. But how can
    React know that the state is modified and it should call its lifecycle methods
    to update the DOM elements? Now that's a problem.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是改变JavaScript对象属性的标准方式。在这里，我们称之为可变方式。太棒了！你刚刚修改了状态。但是React如何知道状态已经修改并且应该调用它的生命周期方法来更新DOM元素呢？现在这是一个问题。
- en: 'To overcome this, the React component has a special method called `setState()`,
    which can update the state in an immutable way and call the required life cycle
    methods (including `render`, which will update the DOM element). Let''s see how
    to update the state in an immutable way:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这一点，React组件有一个特殊的方法叫做`setState()`，它可以以不可变的方式更新状态并调用所需的生命周期方法（包括`render`，它将更新DOM元素）。让我们看看如何以不可变的方式更新状态：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will update your state by creating a new state object instead of the older
    one. Now, the old state and new state are two different objects:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过创建一个新的状态对象而不是旧的状态对象来更新你的状态。现在，旧状态和新状态是两个不同的对象：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: React can now easily check whether the state is changed by a simple comparison
    of two objects, `oldState !== newState`, which will return true if the state is
    changed; therefore, giving a fast update in the view. Comparing objects this way
    is much faster and efficient than iterating over the properties of each object
    and checking whether any property is changed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: React现在可以通过简单比较两个对象`oldState !== newState`来轻松检查状态是否改变，如果状态改变则返回true，因此在视图中进行快速更新。以这种方式比较对象比迭代每个对象的属性并检查是否有任何属性改变要快得多和更有效率。
- en: The goal of using `setState()` is to call the `render` method, which will update
    the view. Hence, `setState()` should not be used inside the `render` method, or
    else it will result in an infinite loop.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`setState()`的目标是调用`render`方法，这将更新视图。因此，不应该在`render`方法内部使用`setState()`，否则将导致无限循环。
- en: JavaScript data types are not immutable; however, working with immutable data
    types are very important and you'll learn more about them soon.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript数据类型不是不可变的；然而，使用不可变数据类型非常重要，您很快就会了解更多相关知识。
- en: Props
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Props
- en: 'Props are data passed to a react component from a parent component. Props are
    similar to states except that props are read-only. You should not change props
    of a component from within the component itself. For example, consider the following
    component:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Props是从父组件传递给React组件的数据。Props类似于状态，只是props是只读的。您不应该在组件内部更改组件的props。例如，考虑以下组件：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the name attribute passed to `ChildrenComponent` element inside the render
    method of `ParentComponent` has become a prop for the `ChildrenComponent`. This
    prop should not be changed by the `ChildrenComponent`. However, if the value is
    changed from the `ParentComponent`, the `ChildrenComponent` will also get re-rendered
    with the new props.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，传递给`ParentComponent`的`ChildrenComponent`元素的name属性已成为`ChildrenComponent`的prop。这个prop不应该由`ChildrenComponent`更改。但是，如果从`ParentComponent`更改了值，`ChildrenComponent`也将使用新的props重新渲染。
- en: To learn more about components and props, visit the following page in react
    documentation: [https://facebook.github.io/react/docs/components-and-props.html](https://facebook.github.io/react/docs/components-and-props.html)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于组件和props的信息，请访问react文档中的以下页面：[https://facebook.github.io/react/docs/components-and-props.html](https://facebook.github.io/react/docs/components-and-props.html)
- en: Building the Counter
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建计数器
- en: Take a look at the `Counter` class we created before. As the name suggests,
    it should render a counter that increases by 1 every second. For that, we need
    to use `setInterval` to increase the count property of the counter's state object.
    We can use either the `componentWillMount` or `componentDidMount` lifecycle methods
    to add `setInterval`. Since this process does not need any reference to DOM elements,
    we can use `componentWillMount`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下我们之前创建的`Counter`类。顾名思义，它应该呈现一个每秒增加1次的计数器。为此，我们需要使用`setInterval`来增加计数器状态对象的count属性。我们可以使用`componentWillMount`或`componentDidMount`生命周期方法来添加`setInterval`。由于这个过程不需要任何对DOM元素的引用，我们可以使用`componentWillMount`。
- en: 'Inside the `Counter` class, we need to add the following lines of code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Counter`类内部，我们需要添加以下代码行：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will automatically perform the increment every second and the `render`
    method will update the required DOM element. To see the counter in action, visit
    the following JSFiddle page: [https://jsfiddle.net/reb5ohgk/](https://jsfiddle.net/reb5ohgk/).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动每秒执行一次增量，`render`方法将更新所需的DOM元素。要查看计数器的实际效果，请访问以下JSFiddle页面：[https://jsfiddle.net/reb5ohgk/](https://jsfiddle.net/reb5ohgk/)。
- en: 'Now, on the JSFiddle page, look at the External Resources section in the top
    left corner. You should see three resources included in it, as shown in the following
    screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在JSFiddle页面上，看一下左上角的外部资源部分。您应该会看到其中包括三个资源，如下面的截图所示：
- en: '![](../images/00037.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00037.jpeg)'
- en: 'Along with this, in the JavaScript code block, I have selected the language
    as Babel+JSX. If you click on the settings icon in the top right corner of the
    JavaScript section, you will be able to see a set of options as shown in the following
    screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，在JavaScript代码块中，我已经选择了Babel+JSX作为语言。如果您点击JavaScript部分右上角的设置图标，您将能够看到一组选项，如下面的截图所示：
- en: '![](../images/00038.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00038.jpeg)'
- en: 'Here''s what the configurations are all about:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是配置的内容：
- en: The first JavaScript file I have included is the `react.js` library. The React
    library is the core that is responsible for creating the DOM elements as components.
    However, React renders the components in a *virtual DOM* instead of the real DOM.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我包含的第一个JavaScript文件是`react.js`库。React库是负责创建DOM元素作为组件的核心。但是，React将组件呈现在*虚拟DOM*中，而不是真实的DOM中。
- en: 'The second library I have included is `ReactDOM`. It is used to provide a wrapper
    for React components so that they can be rendered in the DOM. Consider the following
    line:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我包含的第二个库是`ReactDOM`。它用于为React组件提供包装器，以便它们可以在DOM中呈现。考虑以下行：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will render the `Counter` component into the `<app></app>` element in the
    DOM using the `ReactDOM.render()` method.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将使用`ReactDOM.render()`方法将`Counter`组件呈现到DOM中的`<app></app>`元素中。
- en: The third library is Bootstrap; I just added it for the styles. So, let's look
    into the next step of the configuration.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个库是Bootstrap；我只是为了样式添加了它。那么，让我们看看配置的下一步。
- en: In the JavaScript code block, I have selected the language as Babel + JSX. It
    is because the browsers only know JavaScript. They have no idea about JSX in the
    same way that older browsers didn't have any idea about ES6.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JavaScript代码块中，我已经选择了Babel + JSX作为语言。这是因为浏览器只认识JavaScript。它们对JSX一无所知，就像旧版浏览器对ES6一无所知一样。
- en: So, I just instructed JSFiddle to use the in-browser Babel transformer to compile
    the ES6 and JSX code back to normal JavaScript so that it will work with all the
    browsers.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，我刚刚指示JSFiddle使用浏览器内置的Babel转换器将ES6和JSX代码编译回普通的JavaScript，以便它可以在所有浏览器中运行。
- en: In the real applications, we will use the Webpack and Babel loaders with the
    React preset to compile JSX just as we did for ES6.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实际应用中，我们将使用Webpack和React预设的Babel加载器来编译JSX，就像我们为ES6所做的那样。
- en: By now, you should have a good idea of React So, let's get started with building
    your first React application-a ToDo list-in the next section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该对React有了一个很好的了解，那么让我们开始构建您的第一个React应用程序-一个待办事项列表-在下一节中。
- en: The React crash course
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React速成课程
- en: In this section, we are going to spend 10 minutes building your first React
    application. For this section, you don't need any text editor because you will
    be building the app in JSFiddle!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将花费10分钟构建你的第一个React应用程序。在本节中，你不需要任何文本编辑器，因为你将在JSFiddle中构建应用程序！
- en: Get started by visiting the JSFiddle page at: [https://jsfiddle.net/uhxvgcqe/](https://jsfiddle.net/uhxvgcqe/),
    where I have set up all the libraries and configurations needed for building a
    React application. You should write the code for the React crash course section
    in this page.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问JSFiddle页面[https://jsfiddle.net/uhxvgcqe/](https://jsfiddle.net/uhxvgcqe/)开始。我已经在这个页面中设置了构建React应用程序所需的所有库和配置。你应该在这个页面中为React速成课程部分编写代码。
- en: 'This page has React and `ReactDOM` available as the properties of a window
    object (global scope), since I have included these libraries in the external resources.
    We''ll also create a component object from the React object. In ES6, there is
    a trick to obtain properties or methods of an object into standalone variables.
    Look at the following example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面有React和`ReactDOM`作为window对象（全局范围）的属性可用，因为我已经在外部资源中包含了这些库。我们还将从React对象创建一个组件对象。在ES6中，有一个技巧可以将对象的属性或方法获取为独立的变量。看下面的例子：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will now create two new constants, `fourWheeler` and `twoWheeler`, from
    the vehicle object''s respective properties. This is called a destructuring assignment
    and it works with both objects and arrays. Following the same principle, in the
    first line of your JSFiddle, add the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将从车辆对象的相应属性中创建两个新的常量`fourWheeler`和`twoWheeler`。这被称为解构赋值，它适用于对象和数组。遵循相同的原则，在你的JSFiddle的第一行中，添加以下代码：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will create the component object from the component property of the React
    object. Followed by that, I have included an `<app></app>` element in the HTML
    section, which is where we are going to render our React component. So, create
    a reference to the `<app>` element using the following line of code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从React对象的组件属性创建组件对象。在HTML部分中，我已经包含了一个`<app></app>`元素，这是我们将渲染我们的React组件的地方。因此，使用以下代码创建对`<app>`元素的引用：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s create a stateful app component that will render our ToDo list. In the
    JSFiddle, type the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个有状态的应用组件，它将渲染我们的待办事项列表。在JSFiddle中，输入以下代码：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Outside the class, add the following code block that will render the React
    component in the DOM:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在类外部，添加以下代码块，它将在DOM中渲染React组件：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, click Run in the top left corner of the JSFiddle page. Your app should
    now look like this: [https://jsfiddle.net/uhxvgcqe/1/](https://jsfiddle.net/uhxvgcqe/1/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击JSFiddle页面左上角的运行。你的应用程序现在应该看起来像这样：[https://jsfiddle.net/uhxvgcqe/1/](https://jsfiddle.net/uhxvgcqe/1/)。
- en: For more information and usage details regarding destructuring assignments,
    visit the following MDN page: [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有关解构赋值的更多信息和用法详情，请访问以下MDN页面：[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)。
- en: Adding and managing states
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和管理状态
- en: 'The most important part of a stateful React component is its state, which provides
    the required data to render the DOM elements. For our application, we need two
    state variables: one containing the array of tasks while another containing the
    input value of the text field. Being a fully functional representation, we always
    need to maintain a state for every view change, including the value of input fields.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有状态的React组件最重要的部分是它的状态，它提供了渲染DOM元素所需的数据。对于我们的应用程序，我们需要两个状态变量：一个包含任务数组，另一个包含文本字段的输入值。作为一个完全功能的表示，我们总是需要为每个视图更改维护一个状态，包括输入字段的值。
- en: 'In your `App` class, add the following lines of code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`App`类中，添加以下代码行：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will add a constructor to the class, where we should make a call to `super()`
    first, since our class is an extended class. `super()` will call the constructor
    for the `Component` interface. In the next line, we have created the state variable's
    tasks and `inputValue`. `tasks` is an array, which will contain an array of strings
    with task names.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向类添加一个构造函数，在构造函数中，我们应该首先调用`super()`，因为我们的类是一个扩展类。`super()`将调用`Component`接口的构造函数。在下一行，我们创建了状态变量`tasks`和`inputValue`。`tasks`是一个数组，它将包含一个包含任务名称的字符串数组。
- en: Managing the state for the input field
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理输入字段的状态
- en: 'First, we''ll attach the `inputValue` state with the input field. Inside your
    `render()` method, add the value attribute for the input JSX element, as shown
    in the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将把`inputValue`状态与输入字段关联起来。在你的`render()`方法中，添加输入JSX元素的value属性，如下所示：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have explicitly binded the value of the input field with the state variable.
    Now, try clicking Run and editing the input field. You should not be able to edit
    it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经明确地将输入字段的值与状态变量绑定在一起。现在，尝试点击运行并编辑输入字段。你不应该能够编辑它。
- en: This is because no matter what you type into this field, the `render()` method
    will simply render what we have specified in the `return()` statement, which is
    an input field with empty `inputValue`. So, how do we change the value of the
    input field? By adding an `onChange` attribute to the input field. Let me show
    you how.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为无论你在这个字段中输入什么，`render()`方法都只会渲染我们在`return()`语句中指定的内容，即一个带有空`inputValue`的输入字段。那么，我们如何改变输入字段的值呢？通过向输入字段添加一个`onChange`属性。让我向你展示如何做。
- en: 'Inside the `App` class, add the following lines of code in the position, as
    I have specified in the following code block:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App`类中，在我指定的位置添加以下代码行：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This `handleChange` method will receive our typing event and will update the
    state based on the value of the event's target, which should be the input field.
    Note that, in the constructor, I have binded the `this` object with the `handleChange`
    method. This saves us the trouble of having to use `this.handleChange.bind(this)`
    inside the JSX elements.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`handleChange`方法将接收我们的输入事件，并根据事件目标的值更新状态，事件目标应该是输入字段。请注意，在构造函数中，我已经将`this`对象与`handleChange`方法绑定。这样我们就不必在JSX元素内使用`this.handleChange.bind(this)`了。
- en: 'Now, we need to add the `handleChange` method to the `onChange` attribute of
    the input element. In your JSX, add the `onChange` attribute to the input element,
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将`handleChange`方法添加到输入元素的`onChange`属性中。在您的JSX中，将`onChange`属性添加到输入元素，如下所示：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Click Run and you should be able to type in the input field again. But this
    time, your `inputValue` state gets updated every time you are editing the input
    field. Your JSFiddle should now look like this: [https://jsfiddle.net/uhxvgcqe/2/](https://jsfiddle.net/uhxvgcqe/2/).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 点击运行，您应该能够再次在输入字段中输入。但是这次，每当您编辑输入字段时，您的`inputValue`状态都会得到更新。您的JSFiddle现在应该看起来像这样：[https://jsfiddle.net/uhxvgcqe/2/](https://jsfiddle.net/uhxvgcqe/2/)。
- en: This is the React's one-way data flow (or one-way data binding), where data
    only flows in one direction, from the state to the `render` method. Any events
    in the rendered components will have to trigger an update to the state to update
    the view. Also, the state should only be updated in an immutable way using the
    `this.setState()` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是React的单向数据流（或单向数据绑定），其中数据只从状态流向`render`方法。渲染组件中的任何事件都必须触发对状态的更新以更新视图。此外，状态应该只以不可变的方式使用`this.setState()`方法进行更新。
- en: Managing the state for the tasks
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理任务的状态
- en: 'The second state that we need to maintain in our app is the `tasks` array.
    Currently, we have an unordered list of sample tasks. Add those tasks as strings
    inside the `tasks` array. Your `state` object inside the constructor should now
    look as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用中需要维护的第二个状态是`tasks`数组。目前，我们有一个示例任务的无序列表。将这些任务作为字符串添加到`tasks`数组中。您构造函数中的`state`对象现在应该如下所示：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s populate the tasks from the state. In your `render` method, inside
    the `<ul>` element, remove all the `<li>` elements and replace them with the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从状态中填充任务。在您的`render`方法中，在`<ul>`元素内，删除所有`<li>`元素，并用以下内容替换它们：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The curly braces `{}` in JSX only accept expressions that return a direct value
    just like `${}` in template literals. Hence, we can use the array's map method
    that returns an array of JSX elements. Whenever we return JSX elements as arrays,
    we should add a `key` attribute with a unique value, which is used by React for
    identifying that element in the array.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSX中的花括号`{}`只接受返回直接值的表达式，就像模板文字中的`${}`一样。因此，我们可以使用数组的map方法返回JSX元素的数组。每当我们将JSX元素作为数组返回时，我们应该添加一个带有唯一值的`key`属性，React用它来识别数组中的元素。
- en: 'So, in the preceding code, we need to perform the following steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在上述代码中，我们需要执行以下步骤：
- en: We iterate over the `tasks` array of the `state` and return the list items as
    an array of the JSX elements using the `map()` method of the array.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历`state`的`tasks`数组，并使用数组的`map()`方法将列表项作为JSX元素的数组返回。
- en: For the unique value of the `key` attribute, we are using the `index` of each
    element in the array.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`key`属性的唯一值，我们使用数组中每个元素的`index`。
- en: Click Run and your code should produce the same output as before, except that
    the tasks are now populated from the state. Your code should now look like this: [https://jsfiddle.net/uhxvgcqe/3/](https://jsfiddle.net/uhxvgcqe/3/).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 点击运行，您的代码应该产生与之前相同的输出，只是任务现在是从状态中填充的。您的代码现在应该看起来像这样：[https://jsfiddle.net/uhxvgcqe/3/](https://jsfiddle.net/uhxvgcqe/3/)。
- en: Adding new tasks
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新任务
- en: 'Our final step in the app is to allow users to add a new task. Let''s make
    it simple by adding a new task on hitting *Enter* or *return* on the keyboard.
    To detect the *Enter* button, we need to use an attribute on the input field similar
    to `onChange`, but it should happen before the `onChange` event. `onKeyUp` is
    one such attribute that gets called when the key is pressed and released by the
    user on the keyboard. It also happens before the `onChange` event. First create
    the method that will handle the keyup process:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用的最后一步是允许用户添加一个新任务。通过在键盘上按*Enter*或*return*来简化。要检测*Enter*按钮，我们需要在输入字段上使用一个类似于`onChange`的属性，但它应该发生在`onChange`事件之前。`onKeyUp`就是这样一个属性，当用户在键盘上按下并释放键时会调用它。它也会在`onChange`事件之前发生。首先创建处理键盘按键过程的方法：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here''s how the `handleKeyUp` method will work:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleKeyUp`方法的工作原理如下：'
- en: First, it will check whether `keyCode` of the event is `13`, which is `keyCode`
    for *Enter *(for Windows) and *return* (for Mac) keys. Then, it will check whether
    `this.state.inputValue` is available. Otherwise, it will throw an alert saying
    `'Please add a Task'`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它将检查事件的`keyCode`是否为`13`，这是*Enter*的`keyCode`（对于Windows）和*return*（对于Mac）键。然后，它将检查`this.state.inputValue`是否可用。否则，它将抛出一个警报，显示'请添加一个任务'。
- en: The second and the most important part here is updating the array without mutating
    the state. Here, I have used the spread syntax to create a new tasks array and
    update the state.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个也是最重要的部分是更新数组而不改变状态。在这里，我使用了扩展语法来创建一个新的任务数组并更新状态。
- en: 'In your `render` method, again modify the input JSX element into the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`render`方法中，再次修改输入JSX元素为以下内容：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, click Run, type a new task, and hit *Enter*. You should see that a new
    task gets added to the ToDo list. Your code should now look like [https://jsfiddle.net/uhxvgcqe/4/](https://jsfiddle.net/uhxvgcqe/4/),
    which is the completed code for the ToDo list. Before we discuss the advantages
    of using React here, let's take a look into the spread syntax we used for adding
    a task.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击运行，输入一个新任务，然后按*Enter*。您会看到一个新任务被添加到待办事项列表中。您的代码现在应该看起来像[https://jsfiddle.net/uhxvgcqe/4/](https://jsfiddle.net/uhxvgcqe/4/)，这是待办事项列表的完成代码。在我们讨论在这里使用React的优势之前，让我们看一下我们用于添加任务的扩展语法。
- en: Preventing mutations using the spread syntax
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用扩展语法防止突变
- en: 'In JavaScript, arrays and objects are passed by reference during an assignment.
    For example, open a new JSFiddle window and try the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，数组和对象在赋值过程中是按引用传递的。例如，打开一个新的JSFiddle窗口，尝试以下代码：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We are creating a new array `b` from array `a`. We then push a new value `5`
    into array `b`. If you look at the console, your output will be as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从数组`a`创建一个新数组`b`。然后我们向数组`b`中推入一个新值`5`。如果您查看控制台，输出将如下所示：
- en: '![](../images/00039.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00039.jpeg)'
- en: Surprisingly, both arrays have been updated. This is what I meant by passing
    by a reference. Both `a` and `b` are holding the reference to the same array,
    which means updating either one of them will update both. This holds true for
    both arrays and objects. This means we will evidently *mutate the state* if we
    use a normal assignment.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，两个数组都已更新。这就是我所说的按引用传递。`a`和`b`都持有对同一数组的引用，这意味着更新它们中的任何一个都会更新两者。这对数组和对象都成立。这意味着如果使用普通赋值，我们显然会*改变状态*。
- en: 'However, ES6 comes with a *spread syntax* for arrays and objects. I have used
    this in the `handleKeyUp` method, where I am creating a `newTask` array from `this.state.tasks
    array`. In the JSFiddle window where you tried the preceding code, change the
    code into the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ES6提供了用于数组和对象的*扩展语法*。我在`handleKeyUp`方法中使用了这个语法，其中我从`this.state.tasks`数组创建了一个`newTask`数组。在您尝试了上述代码的JSFiddle窗口中，将代码更改为以下内容：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See how I have created a new array `b` this time. The three dots `...` (known
    as the spread operator) are used to expand all the elements in the array `a`.
    Along with it, a new element `5` is added, and a new array is created and is assigned
    to `b`. This syntax might be confusing at first but it is how we should update
    array values in React, since this will create a new array (in an immutable way).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这次我是如何创建一个新数组`b`的。三个点`...`（称为扩展运算符）用于展开数组`a`中的所有元素。除此之外，还添加了一个新元素`5`，并创建了一个新数组并将其分配给`b`。这种语法起初可能会令人困惑，但这是我们在React中更新数组值的方式，因为这将以不可变的方式创建一个新数组。
- en: 'Likewise, for objects, you should do the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于对象，您应该执行以下操作：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: I have created a fiddle with the spread operators in [https://jsfiddle.net/bLo4wpx1/](https://jsfiddle.net/bLo4wpx1/).
    Feel free to play with it to understand the working of the spread syntax, which
    we will be using very often in this chapter and in the next.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[https://jsfiddle.net/bLo4wpx1/](https://jsfiddle.net/bLo4wpx1/)中创建了一个带有扩展运算符的小玩意。随时玩玩它，以了解扩展语法的工作方式，我们将在本章和下一章中经常使用它。
- en: For more practical examples of using the spread syntax, visit the MDN page [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多使用扩展语法的实际示例，请访问MDN页面[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator)。
- en: Advantages of using React
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React的优势
- en: We have built a ToDo list app within 10 minutes using React. At the beginning
    of this chapter, we discussed why we need a JavaScript framework and the disadvantages
    of using plain JavaScript. In this section, let's look at how React overcomes
    those factors.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在10分钟内使用React构建了一个待办事项列表应用。在本章的开头，我们讨论了为什么需要JavaScript框架以及使用纯JavaScript的缺点。在本节中，让我们看看React是如何克服这些因素的。
- en: Performance
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能
- en: DOM updates are costly. Repaints and reflows are synchronous events and therefore,
    they need to be minimized as much as possible. React deals with this scenario
    by maintaining a virtual DOM, which makes React applications really fast.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: DOM更新是昂贵的。重绘和回流是同步事件，因此需要尽量减少。React通过维护虚拟DOM来处理这种情况，使得React应用程序非常快速。
- en: Whenever we make a modification to the JSX element in the `render` method, React
    will update the virtual DOM instead of the real DOM. Updating the virtual DOM
    is fast, efficient, and much less expensive than updating the real DOM and only
    the elements that are changed in the virtual DOM will be modified in the actual
    DOM. React does this by using a smart diffing algorithm, which we mostly won't
    have to worry about.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们对`render`方法中的JSX元素进行修改时，React将更新虚拟DOM而不是真实DOM。更新虚拟DOM是快速、高效的，比更新真实DOM要便宜得多，只有虚拟DOM中更改的元素才会在实际DOM中被修改。React通过使用智能差异算法来实现这一点，我们大多数时候不必担心。
- en: 'To understand how React works in detail and its performance, you can read the
    following articles from the React documentation:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细了解React的工作原理和性能，您可以阅读React文档中的以下文章：
- en: '[https://facebook.github.io/react/docs/reconciliation.html](https://facebook.github.io/react/docs/reconciliation.html)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/react/docs/reconciliation.html](https://facebook.github.io/react/docs/reconciliation.html)'
- en: '[https://facebook.github.io/react/docs/optimizing-performance.html](https://facebook.github.io/react/docs/optimizing-performance.html)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://facebook.github.io/react/docs/optimizing-performance.html](https://facebook.github.io/react/docs/optimizing-performance.html)'
- en: Maintainability
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性
- en: React shines great in this section, since it neatly organizes the application
    into states and corresponding JSX elements grouped as components. In the ToDo
    list app, we only used a single stateful component. But we can divide its JSX
    into smaller stateless child components too. This means any modification in the
    child components will not affect the parent. Therefore, the core functionality
    will not get affected even if we modify what the list looks like.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: React在这一部分表现出色，因为它将应用程序整齐地组织为状态和相应的JSX元素分组为组件。在待办事项列表应用中，我们只使用了一个有状态的组件。但是我们也可以将其JSX分成较小的无状态子组件。这意味着对子组件的任何修改都不会影响父组件。因此，即使我们修改列表的外观，核心功能也不会受到影响。
- en: Check out the JSFiddle at: [https://jsfiddle.net/7s28bdLe/](https://jsfiddle.net/7s28bdLe/),
    where I have organized the list items in a ToDo list as smaller child components.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 查看JSFiddle：[https://jsfiddle.net/7s28bdLe/](https://jsfiddle.net/7s28bdLe/)，在那里我将待办事项列表项组织为较小的子组件。
- en: This is really useful in a team environment, where everyone can create their
    own components and they can be easily reused by others, which will boost the developer's
    productivity.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这在团队环境中非常有用，每个人都可以创建自己的组件，并且可以很容易地被其他人重用，这将提高开发人员的生产力。
- en: Size
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大小
- en: React is small. The entire React library is just around 23 KB when minified,
    while `react-dom` is around 130 KB. This means it does not cause any serious problems
    on page load times even on slow 2G/3G connections.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: React很小。整个React库在最小化时只有大约23 KB，而`react-dom`大约为130 KB。这意味着即使在2G/3G连接缓慢的情况下，它也不会对页面加载时间造成严重问题。
- en: Building a blog with React
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React构建博客
- en: The objective of this section is to learn the basics of React and how it is
    being used in web applications by building a simple blog application. So far,
    we have been learning about React but now it's time to see how it is used in real
    web applications. React will work fine in our development environment, which we
    have been using in this book so far, except that we need to add an additional
    `react` preset to `babel-loader`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是通过构建一个简单的博客应用程序来学习React的基础知识以及它在Web应用程序中的使用方式。到目前为止，我们一直在学习React，但现在是时候看看它在真实Web应用程序中的使用方式了。React将在我们迄今为止在本书中使用的开发环境中正常工作，只是我们需要向`babel-loader`添加一个额外的`react`预设。
- en: But `react-community` has come up with a better solution, which is the `create-react-app`
    command-line tool. Basically, this tool creates your project with all the necessary
    development tools, Babel compilers, and plugins so that you need to focus only
    on writing code without worrying about Webpack configurations.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 但`react-community`提出了一个更好的解决方案，即`create-react-app`命令行工具。基本上，这个工具会使用所有必要的开发工具、Babel编译器和插件为您创建项目，这样您就可以专注于编写代码，而不必担心Webpack配置。
- en: '`create-react-app` recommends using yarn instead of npm while working on React,
    but since we are very familiar with npm, we will not use yarn in this chapter.
    If you want to learn about yarn, visit: [https://yarnpkg.com/en/](https://yarnpkg.com/en/).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`create-react-app`建议在使用React时使用yarn而不是npm，但由于我们对npm非常熟悉，所以在本章中我们不会使用yarn。如果您想了解有关yarn的信息，请访问：[https://yarnpkg.com/en/](https://yarnpkg.com/en/)。'
- en: 'To see how `create-react-app` works, first let''s install the tool globally
    using npm. Open up your Terminal and type the following command (Since this is
    a global install it will work from any directory):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解`create-react-app`的工作原理，首先让我们使用npm全局安装该工具。打开终端并输入以下命令（由于这是全局安装，它将从任何目录中工作）：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Linux users might have to add the `sudo` prefix. Once it is installed, you
    can create a boilerplate for your React project by running a simple command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Linux用户可能需要添加`sudo`前缀。安装完成后，您可以通过运行简单的命令为您的React项目创建一个样板：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This command will take a while, since it has to create a `my-react-project`
    directory and install all the npm dependencies for your React development environment.
    Once the command is complete, you can run the application using the following
    commands in the Terminal:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会花一些时间，因为它必须创建一个`my-react-project`目录，并为您的React开发环境安装所有npm依赖项。命令完成后，您可以在终端中使用以下命令运行应用程序：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will start the React development server and will open the browser that
    will display a welcome page built with React, as shown in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动React开发服务器，并打开浏览器显示一个用React构建的欢迎页面，如下面的屏幕截图所示：
- en: '![](../images/00040.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00040.jpeg)'
- en: 'Let''s see how the files are organized in the project. The project root folder
    will have files arranged in the following structure:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看项目中文件是如何组织的。项目根目录将按以下结构排列文件：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The public folder will contain the `index.html` file, which contains the `div#root`
    element to which our React component will get rendered to. Also, it contains the
    `favicon` and `manifest.json` file, which provides information to the Android
    devices when the web page is added to the home screen (commonly used in progressive
    web apps).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 公共文件夹将包含`index.html`文件，其中包含我们的React组件将呈现到的`div#root`元素。此外，它还包含`favicon`和`manifest.json`文件，当网页添加到主屏幕时向Android设备提供信息（在渐进式Web应用程序中常用）。
- en: 'The `src` directory contains the source files of our React application. The
    file structure of the `src` directory will be as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`src`目录包含我们的React应用程序的源文件。`src`目录的文件结构将如下所示：'
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `index.js` file is the entry point of the application, where it simply renders
    the `App` component from the `App.js` file in the `index.html` file present in
    the public directory. We write our primary `App` component in the `App.js` file.
    All the other components in the application will be children of the `App` component.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.js`文件是应用程序的入口点，它简单地在公共目录中的`index.html`文件中呈现`App.js`文件中的`App`组件。我们在`App.js`文件中编写我们的主要`App`组件。应用程序中的所有其他组件都将是`App`组件的子组件。'
- en: So far, we have been building multipage applications using JavaScript. But now,
    we are going to build a single page application using React. A **Single Page Application**
    (**SPA**) is one in which all the assets of the application get loaded initially
    and then it will work like a normal app on the user's browser. SPAs are the trend
    now, since they provide a great user experience across various devices for the
    users.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用JavaScript构建多页面应用程序。但现在，我们将使用React构建单页面应用程序。**单页面应用程序**（**SPA**）是指应用程序的所有资产最初都会加载，然后在用户浏览器上像普通应用程序一样工作。SPA现在是趋势，因为它们为用户在各种设备上提供了良好的用户体验。
- en: For building a SPA in React, we need a library to manage navigation between
    pages (components) in the app. `react-router` is one such library that will help
    us manage navigation between the pages (routing) in the app.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要在React中构建SPA，我们需要一个库来管理应用程序中页面（组件）之间的导航。`react-router`就是这样一个库，它将帮助我们管理应用程序中页面（路由）之间的导航。
- en: 'Just as in the other chapters, our blog will also be responsive on mobile devices.
    Let''s take a look at the blog application we are about to build:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他章节一样，我们的博客在移动设备上也是响应式的。让我们来看看我们即将构建的博客应用程序：
- en: '![](../images/00041.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00041.jpeg)'
- en: For this application, we are going to have to write a lot of code. Hence, I
    have already prepared the starter files for you to use. Instead of starting from
    the `create-react-app` tool, you should start from the starter files inside the
    `Chapter06` folder of the book codes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我们将不得不编写大量的代码。因此，我已经为您准备好了起始文件供您使用。您应该从书中代码的`Chapter06`文件夹中的起始文件开始，而不是从`create-react-app`工具开始。
- en: 'Along with React and `react-dom`, the starter files contain the following libraries:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 除了React和`react-dom`之外，起始文件还包含以下库：
- en: React Router: [https://reacttraining.com/react-router/](https://reacttraining.com/react-router/)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Router: [https://reacttraining.com/react-router/](https://reacttraining.com/react-router/)
- en: Reactstrap: [https://reactstrap.github.io/](https://reactstrap.github.io/)
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reactstrap: [https://reactstrap.github.io/](https://reactstrap.github.io/)
- en: uuid: [https://www.npmjs.com/package/uuid](https://www.npmjs.com/package/uuid)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uuid: [https://www.npmjs.com/package/uuid](https://www.npmjs.com/package/uuid)
- en: The server that provides the API for the blog is available in the book code
    `Chapter06\Server` directory. You should keep this server running while building
    the application. I highly recommend you to see the completed application before
    starting to build the blog.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为博客提供API的服务器位于书中代码`Chapter06\Server`目录中。在构建应用程序时，您应该保持此服务器运行。我强烈建议您在开始构建博客之前先查看已完成的应用程序。
- en: '`create-react-app` supports reading environment variables from the `.env` file
    straight out of the box; however, with the condition that all environment variables
    should be prefixed with the `REACT_APP_` keyword. For more information, read: [https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-custom-environment-variables](https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-custom-environment-variables).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`create-react-app`支持直接从`.env`文件中读取环境变量；但是，有一个条件，即所有的环境变量都应该以`REACT_APP_`关键字为前缀。更多信息，请阅读：[https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-custom-environment-variables](https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-custom-environment-variables)。'
- en: 'To run the completed application, perform the following steps:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行已完成的应用程序，请执行以下步骤：
- en: Start the server first by running `npm install`, followed by `npm start` inside
    the server's directory.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先通过在服务器目录中运行`npm install`，然后运行`npm start`来启动服务器。
- en: It will print the URL that should be added to the `.env` file of `Chapter 6\completedCode`
    files in the console.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '它将在控制台中打印应该添加到`Chapter 6\completedCode`文件的`.env`文件中的URL。 '
- en: Inside `Chapter 6\CompletedCode` files, create the `.env` file using the `.env.example`
    file and paste the URL printed in the first line of the console output as the
    value of `REACT_APP_SERVER_URL`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter 6\CompletedCode`文件夹中，使用`.env.example`文件创建`.env`文件，并将控制台输出的第一行中打印的URL作为`REACT_APP_SERVER_URL`的值粘贴进去。
- en: Navigate inside the book code `Chapter 6\CompletedCode` files directory in your
    Terminal and run the same `npm install` and `npm start` commands.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中导航到书中代码`Chapter 6\CompletedCode`文件夹，并运行相同的`npm install`和`npm start`命令。
- en: It should open the blog on your browser. If it didn't open the blog, then manually
    open `http://localhost:3000/` on your browser.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该在浏览器中打开博客。如果没有打开博客，那么请手动在浏览器中打开`http://localhost:3000/`。
- en: 'I have also created an API documentation using swagger for the server. To access
    the API documentation, while your server is running, it will print the documentation
    URL in the second line of console output. Simply open the URL in your browser.
    In the documentation page, click on the default group and you should see a list
    of API endpoints, as shown in the following screenshot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我还为服务器创建了一个使用swagger的API文档。要访问API文档，当服务器正在运行时，它将在控制台输出的第二行中打印文档URL。只需在浏览器中打开URL。在文档页面上，点击默认组，您应该会看到一个API端点列表，如下面的截图所示：
- en: '![](../images/00042.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00042.jpeg)'
- en: 'You can see all the information regarding the API endpoints and even try them
    out by clicking on the API and then clicking Try it out:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到关于API端点的所有信息，甚至可以通过点击API然后点击Try it out来尝试它们：
- en: '![](../images/00043.jpeg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00043.jpeg)'
- en: Take your time. Visit all the sections of the completed blog, try out all the
    APIs in the swagger document, and learn how it works. Once you are done with them,
    we'll move onto the next section, where we will start building the app.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 慢慢来。访问已完成的博客的所有部分，尝试在swagger文档中尝试所有的API，并学习它是如何工作的。一旦你完成了它们，我们将继续下一节，开始构建应用程序。
- en: Creating the navigation bar
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建导航栏
- en: Hope you tried the app. Currently, I have set the server to respond only after
    3 seconds; therefore, you should see a loading indicator while trying to navigate
    between the pages.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您尝试了这个应用程序。目前，我已经设置服务器在3秒后才响应；因此，在尝试在页面之间导航时，您应该会看到一个加载指示器。
- en: 'The one thing common across all the pages in this application is the top navigation
    bar:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序中所有页面共同的一件事是顶部导航栏：
- en: '![](../images/00044.jpeg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00044.jpeg)'
- en: 'In the previous chapters, we created the navigation bar easily using Bootstrap.
    However, we can''t use Bootstrap here because, in React, all the DOM elements
    are rendered dynamically through components. Bootstrap, however, requires jQuery,
    which only works on a normal DOM so that it can display animations while clicking
    the hamburger menu when the navbar is viewed on mobiles, as shown in the following
    screenshot:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们使用Bootstrap轻松创建了导航栏。然而，在这里我们不能使用Bootstrap，因为在React中，所有的DOM元素都是通过组件动态渲染的。然而，Bootstrap需要jQuery，而jQuery只能在普通的DOM上工作，这样它才能在移动设备上查看导航栏时点击汉堡菜单时显示动画，如下面的截图所示：
- en: '![](../images/00045.gif)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00045.gif)'
- en: However, several libraries are available which will let you use Bootstrap in
    React by providing the equivalent React components to each Bootstrap styled element.
    In this project, we are going to use one such library called the reactstrap. It
    requires Bootstrap 4 (alpha 6) to be installed with it; therefore, I have also
    installed Bootstrap 4 in the project's starter files.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有几个库可以让您在React中使用Bootstrap，它们为每个Bootstrap样式的元素提供了等效的React组件。在本项目中，我们将使用一个名为reactstrap的库。它需要与之一起安装Bootstrap
    4（alpha 6）；因此，我还在项目的起始文件中安装了Bootstrap 4。
- en: Now, navigate to the book code `Chapter06\Starter files` directory and create
    the `.env` file in the project root directory. The `.env` file should have the
    same value as the completed code files for `REACT_APP_SERVER_URL`, which is the
    URL printed by the server in the console.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到书中代码`Chapter06\Starter files`目录，并在项目根目录中创建`.env`文件。`.env`文件应该与`REACT_APP_SERVER_URL`的完成代码文件中的值相同，这是服务器在控制台中打印的URL。
- en: From the starter files directory in your Terminal, run `npm install`, followed
    by `npm start`. It should start the development server for the starter files.
    It will open the browser, which displays the message "The app goes here...". Open
    the folder in VSCode and see the `src/App.js` file. It should contain that message
    in the `render` method.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的终端中的起始文件目录中运行`npm install`，然后运行`npm start`。它应该启动起始文件的开发服务器。它将打开浏览器，显示消息“应用程序在这里...”。在VSCode中打开文件夹并查看`src/App.js`文件。它应该在`render`方法中包含该消息。
- en: The starter files will be compiled with a lot of warnings saying no-unused-vars.
    It is because I have already included the import statements in all the files but
    none of them are yet used. Therefore, it is telling you that there are a lot of
    unused variables. Just ignore the warnings.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 起始文件将被编译，会出现很多警告，说没有使用的变量。这是因为我已经在所有文件中包含了导入语句，但还没有使用它们。因此，它告诉您有很多未使用的变量。只需忽略这些警告。
- en: 'At the top of your `App.js` file, you should see that I have imported some
    modules from the reactstrap library. They are all React components:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`App.js`文件顶部，您应该看到我已经从reactstrap库导入了一些模块。它们都是React组件：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Explaining about each of the components here is not important, since this chapter
    focuses on learning React more than styling React components. Therefore, to learn
    about reactstrap, visit the project homepage at: [https://reactstrap.github.io/](https://reactstrap.github.io/).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里解释每个组件并不重要，因为本章重点是学习React而不是样式化React组件。因此，要了解reactstrap，请访问项目主页：[https://reactstrap.github.io/](https://reactstrap.github.io/)。
- en: 'In your `App` class, in the `App.js` file, replace the `return` statement of
    the `render` method with the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`App`类中，在`App.js`文件中，用以下内容替换`render`方法的`return`语句：
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding code will make use of the reactstrap components and will create
    a top navigation bar for the blog just like in the completed project. Check out
    the page in responsive design mode in Chrome to see how it looks on mobile devices.
    In the responsive design mode, the hamburger menu won't work.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将使用reactstrap组件，并为博客创建一个顶部导航栏，就像在完成的项目中一样。在Chrome的响应式设计模式下查看页面，以查看其在移动设备上的外观。在响应式设计模式下，汉堡菜单将无法使用。
- en: 'This is because we haven''t created any states and methods to manage expanding
    and collapsing the navigation bar. In your `App` class, add the following constructor
    and method:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们还没有创建任何状态和方法来管理展开和折叠导航栏。在您的`App`类中，添加以下构造函数和方法：
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will add the state variable, `isOpen`, used for identifying the open/closed
    state of the hamburger menu, while the toggle method is used to expand or collapse
    the hamburger menu by changing the value of the `isOpen` state to `true` or `false`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这将添加状态变量`isOpen`，用于识别汉堡菜单的打开/关闭状态，同时切换方法用于通过将`isOpen`状态的值更改为`true`或`false`来展开或折叠汉堡菜单。
- en: 'To bind these in your navigation bar, in the `render` method, perform the following
    steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要在导航栏中绑定这些内容，在`render`方法中执行以下步骤：
- en: 'Replace the `false` value of the `isOpen` attribue in the line with the `<Collapse
    isOpen={false} navbar>` component with `this.state.isOpen`. The line should now
    look as follows:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包含在`<Collapse isOpen={false} navbar>`组件中`isOpen`属性的`false`值替换为`this.state.isOpen`。该行现在应如下所示：
- en: '[PRE35]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Replace the empty function `()=>{}` value of the `onClick` attribute in the
    line including `<NavbarToggler right onClick={()=>{}}` `/>` with `this.toggle`.
    The line should now look as follows:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包含`<NavbarToggler right onClick={()=>{}}`的行中`onClick`属性的空函数`()=>{}`值替换为`this.toggle`。该行现在应如下所示：
- en: '[PRE36]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once you add these lines and save the file, the hamburger button in the navigation
    bar will work fine in your browser. However, clicking on the links in the navigation
    bar will only reload the page. We cannot do regular navigation using anchor tags
    in a single page application, since there is only a single page that the app is
    going to display. In the next section, we'll see how to implement navigation between
    pages using the React Router library.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了这些行并保存文件，导航栏中的汉堡按钮将在浏览器中正常工作。但是，单击导航栏中的链接将只重新加载页面。在单页面应用程序中，我们无法使用锚标签进行常规导航，因为应用程序只会显示单个页面。在下一节中，我们将看到如何使用React
    Router库在页面之间实现导航。
- en: Implementing routing and navigation using React Router
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Router实现路由和导航
- en: React Router implements routing by displaying the components based on the URL
    the user visits in your web application. React Router can be used in both React.js
    and React Native. However, since we are only focusing on React.js, we should use
    the specific React Router library, `react-router-dom`, that handles routing and
    navigation on the browser.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: React Router通过根据用户在Web应用程序中访问的URL显示组件来实现路由。React Router可以在React.js和React Native中使用。但是，由于我们只关注React.js，我们应该使用特定的React
    Router库`react-router-dom`，它处理浏览器上的路由和导航。
- en: The first step to implement React Router is to wrap the entire `App` component
    inside a `<BrowserRouter>` component from `react-router-dom`. To wrap the entire
    application, open the `src/index.js` file in your project directory in VSCode.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 实现React Router的第一步是将整个`App`组件包装在`react-router-dom`的`<BrowserRouter>`组件中。要包装整个应用程序，请在VSCode中打开项目目录中的`src/index.js`文件。
- en: 'At the top of the `index.js` file, add the following import statement:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.js`文件的顶部，添加以下导入语句：
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will import the `BrowserRouter` component with the name router. Once you
    have added the import statement, replace the `ReactDOM.render()` line with the
    following code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '这将使用名称为router的`BrowserRouter`组件进行导入。一旦您添加了导入语句，请用以下代码替换`ReactDOM.render()`行： '
- en: '[PRE38]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This simply wraps the `<App />` component inside the `<Router>` component, which
    will allow us to use React Router in the rest of the `App` component's child components.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将`<App />`组件包装在`<Router>`组件中，这将允许我们在`App`组件的子组件中使用React Router。
- en: The routes file
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由文件
- en: 'In the starter files, I have included a `routes.js` file in the `src/routes.js`
    path. This file contains all the routes we are going to use on our blog in the
    form of JSON objects:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在起始文件中，我在`src/routes.js`路径中包含了一个`routes.js`文件。该文件包含了我们在博客中要使用的所有路由的JSON对象形式：
- en: '[PRE39]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'See the home page of the completed blog app. The URL will be pointing to the
    `''/home''` route. Likewise, each page has its respective route. However, some
    routes have dynamic values. For example, if you click Read More in a blog post,
    it will take you to the page with the URL:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 查看已完成的博客应用程序的主页。URL将指向`'/home'`路由。同样，每个页面都有其各自的路由。但是，一些路由具有动态值。例如，如果您在博客文章中单击“阅读更多”，它将带您到具有以下URL的页面：
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, the third part of the URL is the post's ID. To represent such URLs, I
    have used `'/post/:id'` in the routes file, where the ID means that React Router
    will understand that the ID will be a dynamic value.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，URL的第三部分是帖子的ID。为了表示这样的URL，我在路由文件中使用了`'/post/:id'`，其中ID表示React Router将理解ID将是一个动态值。
- en: You don't really have to manage all your routes in a single routes file. I have
    created a routes file so that it will be easier for you to add the routes while
    building the application.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您实际上不必在单个路由文件中管理所有路由。我创建了一个路由文件，这样在构建应用程序时更容易添加路由。
- en: Adding routes in the app component
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序组件中添加路由
- en: What React Router does is pretty much simple; it simply renders a component
    based on the URL in the address bar. It uses history and location Web APIs for
    this purpose, but gives us simple, easy to use, component-based APIs, so that
    we can quickly set up our routing logic.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: React Router所做的事情非常简单；它只是根据地址栏中的URL呈现一个组件。它为此目的使用历史和位置Web API，但为我们提供了简单、易于使用的基于组件的API，以便我们可以快速设置我们的路由逻辑。
- en: 'To add navigation between the components in the `App.js` file, add the following
    code in the `App.js` file''s `render` method after the `<Navbar></Navbar>` component:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`App.js`文件中的组件之间添加导航，请在`<Navbar></Navbar>`组件之后的`render`方法中添加以下代码：
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Also, refer to the completed code files if you face any issues after adding
    the code files. I have already added all the import statements in the `App.js`
    file. Route component is imported from the `react-router-dom` package. Here''s
    what the preceding route component does:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果在添加代码文件后遇到任何问题，请参考已完成的代码文件。我已经在`App.js`文件中添加了所有的导入语句。路由组件是从`react-router-dom`包中导入的。前面的路由组件所做的就是：
- en: 'The route component will check the URL of the current page and render the component
    that matches with the given path. Take a look at the following Route:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由组件将检查当前页面的URL，并渲染与给定路径匹配的组件。看一下以下路由：
- en: '[PRE42]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: React Router will render the `Home` component when your URL has the path `'/home'`
    (the value of `routes.home` from the routes file).
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您的URL具有路径`'/home'`（来自路由文件的`routes.home`的值）时，React Router将呈现`Home`组件。
- en: 'Here''s what each of its attributes means:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是每个属性的含义：
- en: '`exact`: Only when the path is matched exactly. This is optional if it is not
    present in `''/home''`: It will hold true for `''/home/otherpaths''` too. We need
    the exact match; hence, I have included it.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exact`：仅当路径完全匹配时。如果它不在`''/home''`中，这是可选的：它也将对`''/home/otherpaths''`保持真实。我们需要精确匹配；因此，我已经包含了它。'
- en: '`path`: The path that must be matched with the URL. In our case, it is `''/home''`
    from the `routes.home` variable from the routes file.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：必须与URL匹配的路径。在我们的情况下，它是来自路由文件的`routes.home`变量的`''/home''`。'
- en: '`component`: The component that must be rendered when the path matches with
    the URL.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`component`：当路径与URL匹配时必须呈现的组件。'
- en: Once you have added the route components, navigate back to the application in
    Chrome. If your application is running in `http://localhost:3000/`, you will only
    see a blank page. However, if you click on the menu items in the navigation bar,
    you should see the respective components being rendered on the page!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您添加了路由组件，请返回Chrome中的应用程序。如果您的应用程序在`http://localhost:3000/`中运行，您将只看到一个空白页面。但是，如果您单击导航栏中的菜单项，您应该看到相应的组件呈现在页面上！
- en: By adding the navigation bar outside the route components, we can easily reuse
    the same navigation bar across the entire application.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在路由组件之外添加导航栏，我们可以在整个应用程序中轻松重用相同的导航栏。
- en: However, we should have our application automatically navigate to the home page
    `'/home'` instead of displaying a blank page on the first load. To do that, we
    should programmatically replace the URL with the required `'/home'` path like
    we did in [Chapter 4](part0099.html#2UD7M0-f852807d0cb141b58fff8f992d32cbb7),
    *Real-Time Video Call App with WebRTC*, using the history object.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们应该让我们的应用程序在第一次加载时自动导航到主页`'/home'`，而不是显示空白页面。为此，我们应该以编程方式替换URL为所需的`'/home'`路径，就像我们在[第4章](part0099.html#2UD7M0-f852807d0cb141b58fff8f992d32cbb7)中所做的那样，*使用历史对象实时视频通话应用程序*。
- en: But we have a problem here. React Router maintains its own history object for
    navigation. This means we need to modify the history object of the React Router.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们有一个问题。React Router为导航维护了自己的历史对象。这意味着我们需要修改React Router的历史对象。
- en: Managing history using withRouter
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用withRouter管理历史记录
- en: 'React Router has an `higher-order` component called `withRouter` with which
    we can pass in the React Router''s history, location, and match objects to our
    React components as props. To use `withRouter`, you should wrap your `App` component
    inside `withRouter()` as a parameter. Currently, here''s how we are exporting
    the `App` component at the last line of the `App.js` file:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: React Router有一个名为`withRouter`的高阶组件，我们可以使用它将React Router的历史、位置和匹配对象作为props传递给我们的React组件。要使用`withRouter`，您应该将`App`组件包装在`withRouter()`内作为参数。目前，这是我们在`App.js`文件的最后一行导出`App`组件的方式：
- en: '[PRE43]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should change this line to the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该将此行更改为以下内容：
- en: '[PRE44]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This will supply three props, `history`, `location`, and the `match` object
    to our `App` component. For our initial objective, displaying the home component
    by default, add the following `componentWillMount()` method to the `App` class:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向我们的`App`组件提供三个props，`history`，`location`和`match`对象。对于我们最初的目标，默认情况下显示主页组件，将以下`componentWillMount()`方法添加到`App`类中：
- en: '[PRE45]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here''s what the preceding code does:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码做了什么：
- en: Since it is written inside `componentWillMount`, it will get executed before
    the `App` component gets rendered.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于它是写在`componentWillMount`中，它将在`App`组件呈现之前执行。
- en: It will check the path of the URL using the `location.pathname` property.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将使用`location.pathname`属性检查URL的路径。
- en: If the path is `'/'`, that is, the default `http://localhost:3000/`, it will
    automatically replace the history and URL with `http://localhost:3000/home`.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果路径是`'/'`，即默认的`http://localhost:3000/`，它将自动用`http://localhost:3000/home`替换历史记录和URL。
- en: This way, the `home` component will be automatically rendered whenever the user
    navigates to the root URL of the web page.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样，每当用户导航到网页的根URL时，`home`组件就会自动呈现。
- en: Now, open `http://localhost:3000/` on your browser and it will display the homepage.
    Still, we have another problem here. Every time we click a link in the navigation
    bar, it is causing the page to reload. Since our blog is a single page app, reloading
    should be avoided, as all the assets and components are already downloaded. Reloading the
    application on every click during navigation will only lead to unnecessarily downloading
    the entire app multiple times.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中打开`http://localhost:3000/`，它将显示主页。但是，我们在这里还有另一个问题。每次单击导航栏中的链接时，都会导致页面重新加载。由于我们的博客是单页面应用程序，应该避免重新加载，因为所有资产和组件已经下载。在导航期间每次单击重新加载应用程序只会导致不必要地多次下载整个应用程序。
- en: Proptype validation
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Proptype验证
- en: Whenever we are passing props to our React components, it is recommended to
    do proptype validation. A proptype validation is a simple type checking that happens
    in the development builds of React, which is used to check whether all the props
    are supplied properly to our React component. If not, it will display a warning
    message, which is very helpful for debugging.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们向我们的React组件传递props时，建议进行proptype验证。proptype验证是React开发构建中发生的简单类型检查，用于检查是否正确地向我们的React组件提供了所有props。如果没有，它将显示一个警告消息，这对于调试非常有帮助。
- en: 'All types of props that can be passed to our React component are defined in
    the `''prop-types''` package, which gets installed along with `create-react-app`.
    You can see that I have included the following import statement at the top of
    the file:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`'prop-types'`包中定义可以传递给我们的React组件的所有类型的props，该包将与`create-react-app`一起安装。您可以看到我已经在文件顶部包含了以下导入语句：
- en: '[PRE46]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To do proptype validation for our `App` component, inside the `App` class,
    add the following static property before the constructor (having proptypes declared
    on top will make it easy to know what props the React component is dependent on):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要对我们的`App`组件进行proptype验证，在`App`类内部，在构造函数之前添加以下静态属性（在顶部声明proptypes将使得知道React组件依赖的props更容易）：
- en: '[PRE47]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Refer the completed code files if you are confused about where to include the
    preceding code snippet. This is how the proptype validation works.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对在哪里包含前面的代码片段感到困惑，请参考已完成的代码文件。这就是proptype验证的工作原理。
- en: 'Consider the second line of the preceding code `history: PropTypes.object.isRequired`. This
    means that:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑前面代码的第二行`history: PropTypes.object.isRequired`。这意味着：'
- en: '`history` should be a prop to the `App` component'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`history`应该是`App`组件的一个prop'
- en: The type of `history` should be the object
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`history`的类型应该是对象'
- en: The `history` prop is required (`isRequired` is optional and can be removed
    for props, that are optional)
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`history` prop是必需的（`isRequired`是可选的，对于可选的props可以删除）'
- en: For detailed information on proptype validation, refer to the React documentation
    page at [https://facebook.github.io/react/docs/typechecking-with-proptypes.html](https://facebook.github.io/react/docs/typechecking-with-proptypes.html).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有关proptype验证的详细信息，请参阅React文档页面[https://facebook.github.io/react/docs/typechecking-with-proptypes.html](https://facebook.github.io/react/docs/typechecking-with-proptypes.html)。
- en: Seamless navigation with NavLink
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NavLink进行无缝导航
- en: React Router has a perfect solution to fix the reloading problem during navigation.
    React Router provides `Link` and `NavLink` components, which you should use instead
    of the traditional anchor tags. `NavLink` has more features than the `link` component,
    such as specifying an active class name when the link is active. Therefore, we
    will use `NavLink` in our application.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: React Router有一个完美的解决方案来解决导航期间的重新加载问题。React Router提供了`Link`和`NavLink`组件，您应该使用它们来代替传统的锚标签。`NavLink`比`link`组件具有更多功能，例如在链接处于活动状态时指定活动类名。因此，我们将在我们的应用程序中使用`NavLink`。
- en: 'For example, consider the following anchor tag we have used in the `App.js`
    file for navigating to the authors page:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑我们在`App.js`文件中用于导航到作者页面的以下锚标签：
- en: '[PRE48]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can replace this with React Router''s `NavLink` component as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其替换为React Router的`NavLink`组件，如下所示：
- en: '[PRE49]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here''s what the attributes of the `NavLink` JSX components do:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`NavLink` JSX组件的属性的作用：
- en: '`className`: The class name given to the element when `NavLink` is rendered
    as an anchor tag in the DOM.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`className`：当`NavLink`在DOM中呈现为锚标签时给元素的类名。'
- en: '`activeClassName`: The class name given to the element when the link is the
    currently active page.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activeClassName`：当链接是当前活动页面时给元素的类名。'
- en: '`to`: The path to which the link will navigate to.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to`：链接将导航到的路径。'
- en: Refer to the `App.js` file from the completed code files and replace all the
    anchor tags in the `App.js` file with `NavLink` components. Once you have done
    this change, whenever you click on the menu items in the navigation bar, your
    app will navigate seamlessly without any page reloads.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考完成的代码文件中的`App.js`文件，并将`App.js`文件中的所有锚点标签替换为`NavLink`组件。一旦完成这个更改，每当你点击导航栏中的菜单项时，你的应用程序将无缝导航，无需任何页面重新加载。
- en: Also, since the `.active` class gets added to the active links, Bootstrap styles
    will highlight the menu item in the navigation bar with slightly darker black
    color when the respective navbar menu item is active.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于`.active`类被添加到活动链接中，Bootstrap样式将在导航栏中的菜单项上突出显示略深的黑色，当相应的导航栏菜单项处于活动状态时。
- en: We have successfully created the navigation bar for our application and implemented
    some basic routing. From our routes file, you can see that our blog has five pages.
    We'll build the home page in the next section.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功为我们的应用程序创建了导航栏并实现了一些基本的路由。从我们的路由文件中，你可以看到我们的博客有五个页面。我们将在下一节构建首页。
- en: Blog home page
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 博客首页
- en: You should already have an idea of how the blog's home page will look from exploring
    the app in the completed code files. Our blog has a simple home page that lists
    all the posts. You can click the Read More button in the posts to read the posts
    in detail. Since this blog is a project for learning purposes, this simple home
    page is enough for now.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索完成的代码文件中的应用程序，你应该已经对博客的首页是什么样子有了一个概念。我们的博客有一个简单的首页，列出了所有的帖子。你可以点击帖子中的“阅读更多”按钮来详细阅读帖子。由于这个博客是一个学习目的的项目，这个简单的首页现在已经足够了。
- en: 'Ideally, you should create each React component from scratch. However, to speed
    up the development process, I have already created all the stateless components
    and boilerplates for the stateful parent components. All the components are available
    in the `src/Components` directory. Since the React component names should start
    with capital letters, I have created all the component directory names with initial
    capital letters to indicate that they contain React components. This is the folder
    structure of the `Components` directory:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你应该从头开始创建每个React组件。然而，为了加快开发过程，我已经创建了所有无状态组件和有状态父组件的样板。所有的组件都在`src/Components`目录中。由于React组件的名称应该以大写字母开头，我已经创建了所有组件目录名称以大写字母开头，以表示它们包含React组件。这是`Components`目录的文件结构：
- en: '[PRE50]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The home page of our blog is the `Home` component present in the `src/Components/Home/Home.js`
    file. Currently, the `render` method of the `Home` component only renders a `Home` text.
    We need to display the list of posts in the home page. Here''s how we are going
    to achieve this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们博客的首页是`src/Components/Home/Home.js`文件中的`Home`组件。目前，`Home`组件的`render`方法只呈现了一个`Home`文本。我们需要在首页显示帖子列表。我们将如何实现这一点：
- en: The server has the `/posts` endpoint, which returns all the posts in a `GET`
    request as an array. Therefore, we can use this API to retrieve the post's data.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器有`/posts`端点，它以`GET`请求返回一个帖子数组。因此，我们可以使用这个API来检索帖子数据。
- en: Since `Home` is a stateful component, we need to maintain states for every action
    in the `Home` component.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`Home`是一个有状态的组件，我们需要为`Home`组件中的每个操作维护状态。
- en: While the `Home` component is retrieving data from the server, we should have
    a state--loading, which should be a Boolean value to show the loading indicator.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`Home`组件从服务器检索数据时，我们应该有一个状态--loading，它应该是一个布尔值，用于显示加载指示器。
- en: If the network request is a success, we should store the posts in a state--posts,
    which can then be used to render all the blog posts.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果网络请求成功，我们应该将帖子存储在一个状态--帖子中，然后可以用它来呈现所有的博客帖子。
- en: If the network request fails, we should simply use another state--`hasError`,
    which should be a Boolean value to display the error message.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果网络请求失败，我们应该简单地使用另一个状态--`hasError`，它应该是一个布尔值，用于显示错误消息。
- en: 'Let''s get started! First, in your `Home` class, add the following constructor
    to define the state variables of the component:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！首先，在你的`Home`类中，添加以下构造函数来定义组件的状态变量：
- en: '[PRE51]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Once you have defined the states, let's make the network request. Since the
    network request is asynchronous, we can have it in `componentWillMount`, but if
    you want to do a synchronous action, that will delay the render. It is better
    to add it in `componentDidMount`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了状态，让我们进行网络请求。由于网络请求是异步的，我们可以在`componentWillMount`中进行，但如果你想进行同步操作，那将延迟渲染。最好是在`componentDidMount`中添加它。
- en: 'For making the network request, I have added the `apiCall` service, which we
    used in the previous chapters in the `src/services/api/apiCall.js` file, and included
    the import statement in the `Home.js` file. Here''s the code for the `componentWillMount`
    method:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行网络请求，我已经添加了`apiCall`服务，我们在`src/services/api/apiCall.js`文件中使用了它，并在`Home.js`文件中包含了导入语句。以下是`componentWillMount`方法的代码：
- en: '[PRE52]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here''s what the preceding function does:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数做了什么：
- en: First, it will set the state variable loading to `true`.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它将把状态变量loading设置为`true`。
- en: The `apiCall` function is called to make the network request.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`apiCall`函数来进行网络请求。
- en: Since the network request is an asynchronous function, the `render` method will
    get executed and the component will get rendered.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于网络请求是一个异步函数，`render`方法将被执行，组件将被渲染。
- en: After the rendering has happened, the network request will get completed in
    3 seconds (I have set that much delay in the server).
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染完成后，网络请求将在3秒内完成（我在服务器上设置了这么长的延迟）。
- en: If the `apiCall` is a success and the data is retrieved, it will update the
    post's state with the array of posts returned from the server and will set the
    loading state to `false`.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`apiCall`成功并且数据被检索到，它将使用从服务器返回的帖子数组更新帖子的状态，并将加载状态设置为`false`。
- en: Otherwise, it will set the `hasError` state to `true` and will set the loading
    state to `false`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，它将把`hasError`状态设置为`true`，并将加载状态设置为`false`。
- en: 'To test the preceding code, let''s add the JSX needed to render the posts.
    Since the JSX part requires a lot of code, I have already created the stateless
    components needed for use on this page in the `src/Components/Common` directory
    and included the import statement at the top of the `Home.js` file. Replace the
    `return` statement of the `render` method with the following code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试前面的代码，让我们添加渲染帖子所需的JSX。由于JSX部分需要大量代码，我已经在`src/Components/Common`目录中创建了用于此页面的无状态组件，并在`Home.js`文件的顶部包含了导入语句。用以下代码替换`render`方法的`return`语句：
- en: '[PRE53]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once you have added the preceding code snippet, keep your server running and
    visit the blog''s home page. It should list all the posts, as shown in the following
    screenshot:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你添加了前面的代码片段，请保持服务器运行，并访问博客的主页。它应该列出所有帖子，如下面的截图所示：
- en: '![](../images/00046.jpeg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00046.jpeg)'
- en: 'However, if you kill the server and reload the page, it will display the error
    message, as shown in the following screenshot:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你关闭服务器并重新加载页面，它将显示错误消息，如下面的截图所示：
- en: '![](../images/00047.jpeg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00047.jpeg)'
- en: The implementation process is very simple once you get to know how the state
    and life cycle methods work with React. However, we still need to cover one important
    topic in this section, which is the child components that I have created previously
    for you to use.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你了解了状态和生命周期方法如何与React一起工作，实现过程就非常简单。然而，在这一部分，我们仍然需要涵盖一个重要的主题，那就是我之前为你创建的子组件，供你使用。
- en: Using child components
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用子组件
- en: 'Let''s take a look at the `ErrorMessage` component, which I have created to
    show an error message when we are unable to retrieve posts from the server. This
    is how the `ErrorMessage` component is included in the `render` method:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`ErrorMessage`组件，我已经创建了它，用于在无法从服务器检索帖子时显示错误消息。这是`ErrorMessage`组件包含在`render`方法中的方式：
- en: '[PRE54]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If the `ErrorMessage` is a stateful component created by extending the `Component`
    interface. The attributes of the `ErrorMessage` JSX element title and message
    will then become the props of the children `ErrorMessage` component. However,
    if you look at the implementation of the `ErrorMessage` element, you will see
    that it is a stateless functional component:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ErrorMessage`是通过扩展`Component`接口创建的有状态组件。`ErrorMessage` JSX元素的属性title和message将成为子`ErrorMessage`组件的props。然而，如果你看一下`ErrorMessage`元素的实现，你会发现它是一个无状态功能组件：
- en: '[PRE55]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'So, here''s how the attributes work for functional components:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下是功能组件的属性工作方式：
- en: 'Since functional components do not support state or props, the attributes become
    the parameters of the function call. Consider the following JSX element:'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于功能组件不支持状态或属性，属性成为函数调用的参数。考虑以下JSX元素：
- en: '[PRE56]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This will be equivalent to a function call with an object as its parameter:'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将相当于一个带有对象作为参数的函数调用：
- en: '[PRE57]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'By using the destructuring assignment you learned earlier, you can use the
    parameters in our function as follows:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过之前学到的解构赋值，你可以在我们的函数中使用参数，如下所示：
- en: '[PRE58]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We can use the `propType` validation for functional components too, but here,
    the `propTypes` are used to validate the function's arguments.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以对功能组件使用`propType`验证，但在这里，`propTypes`用于验证函数的参数。
- en: Whenever you are typing the JSX code in a functional component, make sure you
    have included the `import React from` `'react'` statement in the file. Otherwise,
    the Babel compiler will not know how to compile the JSX back to JavaScript.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你在功能组件中输入JSX代码时，请确保在文件中包含`import React from` `'react'`语句。否则，Babel编译器将不知道如何将JSX编译回JavaScript。
- en: The `PostSummary` component comes with a Read More button with which you can
    see the entire post's details on a page. Currently, if you click this link, it
    will simply display the `'Post Details'` text. So, let's finish up our blog home
    page by creating the post details page.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostSummary`组件带有一个“阅读更多”按钮，通过它你可以在页面上查看整个帖子的详情。目前，如果你点击这个链接，它只会显示“帖子详情”文本。因此，让我们通过创建帖子详情页面来完成我们的博客主页。'
- en: Displaying post details
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示帖子详情
- en: 'Each post in the blog has a unique ID associated with it. We need to use this
    ID to retrieve the post details from the server. When you click on the Read More
    button, I have created the `PostSummary` component in such a way that it will
    take you to the route `''/post/:id''`, where `:id` contains the ID of the post.
    This is how the post URL will look:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 博客中的每篇帖子都有一个与之关联的唯一ID。我们需要使用这个ID从服务器检索帖子的详细信息。当你点击“阅读更多”按钮时，我已经创建了`PostSummary`组件，以便它将带你到路由`'/post/:id'`，其中`:id`包含帖子的ID。帖子URL将如下所示：
- en: '[PRE59]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, the third section is the post ID. Open the `Post.js` file from the `src/Components/Post/Post.js`
    path in VSCode. We need to access the ID that is present in the URL in our `Post`
    component. To access the URL parameter, we need to use the match object of the
    React Router. For this process, we will have to wrap our `Post` component inside
    `withRouter()` just as we did for the `App` component.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第三部分是帖子ID。在VSCode中从`src/Components/Post/Post.js`路径打开`Post.js`文件。我们需要访问URL中存在的ID，以在我们的`Post`组件中访问ID。为了访问URL参数，我们需要使用React
    Router的match对象。对于这个过程，我们将不得不像我们为`App`组件做的那样，将我们的`Post`组件包装在`withRouter()`中。
- en: 'In your `Post.js` file, change the export statement into the following:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`Post.js`文件中，将导出语句更改为以下内容：
- en: '[PRE60]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Also, since this will provide the `history`, `location`, and `match` props
    to the `Post` component, we should also add the prototype validation to the `Post`
    class:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于这将为`Post`组件提供`history`、`location`和`match` props，我们还应该向`Post`类添加原型验证：
- en: '[PRE61]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We have to create the states for our `Post` component. The states are the same
    as that of the `Home` component; however, instead of the posts state (array),
    we will have the post state (object) here, since this page only requires a single
    post. In the `Post` class, add the following constructor:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为我们的`Post`组件创建状态。这些状态与`Home`组件的状态相同；但是，这里我们将有一个帖子状态（对象），而不是帖子状态（数组），因为这个页面只需要一个帖子。在`Post`类中，添加以下构造函数：
- en: '[PRE62]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the swagger document of the server, you should see an API endpoint, `GET
    /post/{id}`, which we are going to use in this chapter for retrieving `Post` from
    the server. The `componentWillMount` method we are going to use in this component
    will be extremely similar to that of the previous `Home` component, except that
    we will have to retrieve the `id` parameter from the URL. This can be done using
    the following line of code:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器的swagger文档中，你应该看到一个API端点，`GET /post/{id}`，我们将在本章中使用它来从服务器检索`Post`。我们将在这个组件中使用的`componentWillMount`方法与之前的`Home`组件非常相似，只是我们将不得不从URL中检索`id`参数。这可以通过以下代码行来完成：
- en: '[PRE63]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here, `this.props.match` is a prop provided to the `Post` component by the
    `withRouter()` component of React Router. So, your `componentWillMount` method
    should be as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`this.props.match`是由React Router的`withRouter()`组件提供给`Post`组件的一个prop。因此，你的`componentWillMount`方法应该如下：
- en: '[PRE64]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, in the `render` method, add the following code:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`render`方法中，添加以下代码：
- en: '[PRE65]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This will create the post page. Now, you should be able to see the entire post
    by clicking the Read More button. This page will work in the same way the home
    page does. By using reusable components, you can see that we have minimized the
    code a lot.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建帖子页面。现在，你应该能够通过点击“阅读更多”按钮来查看整篇帖子。这个页面将以与主页相同的方式工作。通过使用可重用组件，你可以看到我们已经大大减少了代码量。
- en: Adding a new blog post
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新的博客帖子
- en: We have successfully built the home page for our blog. The next task is to build
    the author list page. However, I'll leave the construction of the author list
    to you. You can refer to the completed code files and build the author list page.
    This will be a good practice exercise for you.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功为我们的博客建立了主页。下一个任务是构建作者列表页面。然而，我会把作者列表的构建留给你。你可以参考已完成的代码文件并构建作者列表页面。这将是一个很好的练习。
- en: 'So, that leaves us with the last page, which is the new post page. The API
    we are going to use for adding a new blog post is POST /post, which you can see
    in the swagger document. The body of the post request will be in the following
    form:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们还剩下最后一个页面，即新帖子页面。我们将要使用的API是`POST /post`，你可以在swagger文档中看到。帖子请求的主体将以以下形式出现：
- en: '[PRE66]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, `id` is the unique ID for the blog post and `datetime` is the epoch timestamp
    as a string. Usually, these two properties are generated by the server but since
    we are only using the mock server for our project, we need to generate them on
    the clientside.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`id`是博客帖子的唯一ID，`datetime`是作为字符串的时代时间戳。通常，这两个属性是由服务器生成的，但由于我们只是在我们的项目中使用模拟服务器，所以我们需要在客户端生成它们。
- en: 'Open the `NewPost.js` file from the `src/Components/NewPost/NewPost.js` path.
    This component requires three input fields:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 从`src/Components/NewPost/NewPost.js`路径中打开`NewPost.js`文件。这个组件需要三个输入字段：
- en: Author name
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者名称
- en: Post title
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帖子标题
- en: Post text
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帖子文本
- en: We need to maintain states for these three fields. The blog post will need `textarea`,
    which will dynamically increase its size (rows) as the blog post is typed. Thus,
    we need to maintain a state for the number of lines to manage the row count.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要维护这三个字段的状态。博客帖子将需要`textarea`，它将根据输入的博客帖子动态增加其大小（行数）。因此，我们需要维护一个用于管理行数的状态。
- en: Along with this, we will also need the states we used in the previous component's
    loading and `hasError` for network requests. We will also need a state success
    for indicating to the user that the post has been submitted successfully.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们还需要在前一个组件中使用的加载和网络请求的`hasError`状态。我们还需要一个成功状态，用于向用户指示帖子已成功提交。
- en: 'In your `NewPost` class, create `constructor` with all the required state variables,
    as shown here:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`NewPost`类中，创建一个带有所有必需状态变量的`constructor`，如下所示：
- en: '[PRE67]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Unlike the previous components, instead of just displaying the retrieved data
    from the server, we will have to send data from input fields to the server in
    this component. Whenever input fields are involved, it means we will need a lot
    of methods to edit the state of the input fields.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的组件不同，我们不仅仅是从服务器上显示检索到的数据，而是需要在这个组件中从输入字段发送数据到服务器。每当涉及到输入字段时，这意味着我们需要很多方法来编辑输入字段的状态。
- en: 'Replace the `render` method of your `NewPost.js` file with the `render` method
    from the `NewPost.js` file of the completed code files. Since both the author
    name and title use the same input fields, I have created a simple `PostInputField`
    component for them. Here''s what the `PostInputField` component looks like for
    the author name input:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 用已完成的代码文件中的`NewPost.js`文件的`render`方法替换你的`NewPost.js`文件的`render`方法。由于作者名称和标题都使用相同的输入字段，我为它们创建了一个简单的`PostInputField`组件。这是`PostInputField`组件的样子：
- en: '[PRE68]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here''s what the corresponding `PostInputField` function looks like:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相应的`PostInputField`函数的样子：
- en: '[PRE69]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You can see that I basically made the `className`, `label`, `id`, `value`, and
    `onChange` properties dynamic in the returned JSX element. This will let me reuse
    the entire input field for multiple input elements in the same form. Since the
    final rendered DOM element will have different classes and IDs, but shares the
    same code, all you have to do is import and use it in your component. It will
    save many hours of long development work and, in many cases, it's more efficient
    than the custom elements you learned in the previous chapter.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我基本上是在返回的JSX元素中使`className`、`label`、`id`、`value`和`onChange`属性动态化。这将让我在同一个表单中为多个输入元素重用整个输入字段。由于最终呈现的DOM元素将具有不同的类和ID，但共享相同的代码，你所需要做的就是导入并在你的组件中使用它。这将节省许多长时间的开发工作，并且在许多情况下，它比你在上一章学到的自定义元素更有效。
- en: Let's see how `textarea` works.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`textarea`是如何工作的。
- en: 'Inside the `render` method, you should see the following line where we are
    creating a `noOfLines` constant using the state variables:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在`render`方法中，您应该看到以下行，我们正在使用状态变量创建一个`noOfLines`常量：
- en: '[PRE70]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`this.state.noOfLines` will contain the number of lines present in the blog
    post. Using that, if the number of lines is less than `5`, then we will set the
    value of row attribute to `5`. Otherwise, we can increase the row attribute to
    the number of lines present in the blog post.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`this.state.noOfLines` 将包含博客文章中的行数。使用这个值，如果行数少于`5`，那么我们将把行属性的值设为`5`。否则，我们可以将行属性增加到博客文章中的行数。'
- en: 'This is what the JSX for text input looks like:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这是文本输入的JSX的样子：
- en: '[PRE71]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You can see that the value of the rows attribute is the `noOfLines` constant
    created in the `render` method. After the textarea field, we have the following
    sections:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`rows`属性的值是在`render`方法中创建的`noOfLines`常量。在文本区域字段之后，我们有以下部分：
- en: The loading section, where we can either show `<LoadingIndicator />` or the
    Submit button based on the network request state (`this.state.loading`)
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载部分，我们可以根据网络请求状态（`this.state.loading`）显示`<LoadingIndicator />`或提交按钮
- en: The `hasError` and success sections where we can show the success or error message
    depending on the response from the server
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasError` 和成功部分，我们可以根据来自服务器的响应显示成功或错误消息'
- en: 'Let''s create the methods used by the input fields for updating their value.
    Inside your `NewPost` class, add the following methods:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建用于更新其值的输入字段使用的方法。在您的`NewPost`类中，添加以下方法：
- en: '[PRE72]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Here, `editContent` is the method used by the `textinput` field. You can see
    that I have used a split(`''\n''`) to divide the lines into an array based on
    the newline characters. We can then use the length of the array to count the number
    of lines present in the post. Also, remember to add the `this` binding to all
    the methods in the constructor. Otherwise, the methods called from JSX will not
    be able to use the `this` variable of the class:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`editContent`是`textinput`字段使用的方法。您可以看到我使用了split(`'\n'`)将行根据换行符分成数组。然后我们可以使用数组的长度来计算帖子中的行数。还要记得在构造函数中为所有方法添加`this`绑定。否则，从JSX调用的方法将无法使用类的`this`变量：
- en: '[PRE73]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Submitting the post
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交文章
- en: 'The last part of the adding posts section is submitting the post. Here, we
    need to do two things: generate a UUID for the post and get the current date and
    time in the epoch timestamp format:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 添加文章部分的最后一部分是提交文章。在这里，我们需要做两件事：为文章生成UUID，并以epoch时间戳格式获取当前日期和时间：
- en: For generating a UUID for using the ID of the post, I have included the `uuid`
    library. You just have to call `uuidv4()`, which will return the UUID for your
    use.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了生成用于帖子ID的UUID，我已经包含了`uuid`库。您只需调用`uuidv4()`，它将返回您要使用的UUID。
- en: 'For creating the date and time in the `epoch` timestamp format, you can use
    the following code:'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要以`epoch`时间戳格式创建日期和时间，您可以使用以下代码：
- en: '[PRE74]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The Submit button in the JSX is already set to call the `this.submit()` method
    when it is clicked. So, let''s create the `submit` method of the `AddPost` class
    with the following code:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: JSX中的提交按钮已经设置为在单击时调用`this.submit()`方法。因此，让我们创建`AddPost`类的`submit`方法，使用以下代码：
- en: '[PRE75]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Also, add the following code to your constructor for binding this with the
    Submit button:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了将this与提交按钮绑定，还要添加以下代码到您的构造函数中：
- en: '[PRE76]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This is what the preceding submit method does:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是前面的提交方法所做的事情：
- en: It constructs the body of the network request, which is the post we need to
    add, and then makes the request to the POST/post server endpoint.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它构造了网络请求的主体，这是我们需要添加的帖子，然后向POST/post服务器端点发出请求。
- en: If the request is a success, it will reset the input fields to an empty string
    using the state variables.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果请求成功，它将使用状态变量将输入字段重置为空字符串。
- en: If the request fails, it will simply set the `hasError` state to true, which
    will show us an error message.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果请求失败，它将简单地将`hasError`状态设置为true，这将显示给我们一个错误消息。
- en: If it works as expected, then click on Home and you should see your new post
    added to the blog. Congratulations! You just successfully built your own blog
    application using React!
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，然后点击主页，你应该看到你的新文章添加到博客中。恭喜！你成功地使用React构建了自己的博客应用程序！
- en: Do try to build the author list page yourself and get help by referring to the
    completed files if you face any problems while building it.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己构建作者列表页面，并在构建时遇到任何问题时，通过参考已完成的文件来获得帮助。
- en: Generating production builds
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成生产构建
- en: 'The one thing that we have been doing in every chapter is to generate the production
    builds. We did this by setting the `NODE_ENV` variable in the `.env` file to `production`
    and then running `npm run webpack` in the Terminal. However, for this chapter,
    since we are using `create-react-app`, we don''t have to worry about setting the
    environment variables. We just need to run the following command in the Terminal
    from the project root folder:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每一章中一直在做的一件事就是生成生产构建。我们通过在`.env`文件中将`NODE_ENV`变量设置为`production`，然后在终端中运行`npm
    run webpack`来实现这一点。然而，对于本章，由于我们使用的是`create-react-app`，我们不必担心设置环境变量。我们只需要在项目根目录的终端中运行以下命令：
- en: '[PRE77]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Once you run this command, you will have your production build with all the
    optimizations done and ready for use in the build directory of the project. Generating
    builds with `create-react-app` is that simple!
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您将获得已完成所有优化的生产构建，并准备在项目的构建目录中使用。使用`create-react-app`生成构建就是这么简单！
- en: Once the production build is generated, run `http-server` inside the build directory
    of your project and see how the application works by visiting the URL printed
    by `http-server` in the console on your browser.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 生成生产构建后，在项目的构建目录中运行`http-server`，并通过访问`http-server`在控制台上打印的URL来查看应用程序的运行情况。
- en: React has a browser extension, which will let you debug the component hierarchy,
    including the component's state and props. Since we are only working with a basic
    application in this chapter, we didn't use that tool. However, you can try it
    out yourself if you are building applications with React at [https://github.com/facebook/react-devtools](https://github.com/facebook/react-devtools).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: React有一个浏览器扩展，可以让你调试组件层次结构，包括组件的状态和属性。由于本章中我们只是在使用基本应用程序，所以我们没有使用那个工具。但是，如果你正在使用React构建应用程序，你可以自己试一试，网址是[https://github.com/facebook/react-devtools](https://github.com/facebook/react-devtools)。
- en: Summary
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This book is designed to help you understand the basics of React. Since we only
    built a simple application in this chapter, we didn't get to explore many of React's
    cool features. In this chapter, you started off with a simple counter, then built
    a ToDo list in the React crash course, and finally, built a simple blog application
    using the `create-react-app` tool and some libraries, such as `react-router` and
    reactstrap.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书旨在帮助你了解React的基础知识。由于我们在本章中只构建了一个简单的应用程序，所以我们没有探索React的许多很酷的功能。在本章中，你从一个简单的计数器开始，然后在React速成课程中构建了一个待办事项列表，最后，使用`create-react-app`工具和一些库，如`react-router`和reactstrap，构建了一个简单的博客应用程序。
- en: Being a simple view layer of the app, React does need a few libraries used together
    to make it work like a full fledged framework. React isn't the only JavaScript
    framework out there but React definitely is a one of a kind library that is revolutionizing
    modern UI development.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用程序的简单视图层，React确实需要一些库一起使用，才能使其像一个完整的框架一样工作。React并不是唯一的JavaScript框架，但它绝对是一种革新现代UI开发的独特库。
- en: Everything is really great about React and the blog application we just built,
    except that each of the pages in the blog takes an annoying 3 seconds to load.
    Well, we can work around this problem by storing the post details offline using
    the localStorage API of the browser and updating states using them. But then again,
    our application is making too many network requests to the server for retrieving
    data that has already been retrieved in the previous requests.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 关于React和我们刚刚构建的博客应用程序，一切都很棒，除了博客中的每个页面加载都要花费令人讨厌的3秒钟。嗯，我们可以通过使用浏览器的localStorage
    API离线存储帖子详情并使用它们来更新状态来解决这个问题。但是，再一次地，我们的应用程序对服务器进行了太多的网络请求，以检索在先前的请求中已经检索到的数据。
- en: Before you start thinking about some complex ways to reuse the data while storing
    it offline, there is one more thing we need to learn in this book, which is the
    new library that is taking the modern frontend development by storm-**Redux**.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始考虑一些复杂的方法来离线存储并重复使用数据之前，我们在这本书中还需要学习一件事，那就是正在引领现代前端开发风潮的新库-Redux。
