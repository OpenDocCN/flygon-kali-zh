["```java\n// 110011\nSystem.out.println(\"Binary: \" + Integer.toString(51, 2));\nSystem.out.println(\"Binary: \" + Integer.toBinaryString(51));\n```", "```java\nSystem.out.println(\"Decimal: \" \n\u00a0\u00a0+ Integer.parseInt(\"110011\", 2));\u00a0\u00a0//51\n```", "```java\npublic static char getValue(int n, int k) {\n\u00a0\u00a0int result = n & (1 << k);\n\u00a0\u00a0if (result == 0) {\n\u00a0\u00a0\u00a0\u00a0return '0';\n\u00a0\u00a0}\n\u00a0\u00a0return '1';\n}\n```", "```java\npublic static int setValueTo0(int n, int k) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \n\u00a0\u00a0return n & ~(1 << k);\n}\n```", "```java\npublic static int setValueTo1(int n, int k) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \n\u00a0\u00a0return n | (1 << k);\n}\n```", "```java\npublic static int clearFromMsb(int n, int k) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0return n & ((1 << k) - 1);\n}\n```", "```java\npublic static int clearFromPosition(int n, int k) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0return n & ~((1 << k) - 1);\n}\n```", "```java\npublic static int sum(int q, int p) {\n\u00a0\u00a0int xor;\n\u00a0\u00a0int and;\n\u00a0\u00a0int t;\n\u00a0\u00a0and = q & p;\n\u00a0\u00a0xor = q ^ p;\n\u00a0\u00a0// force 'and' to return 0\n\u00a0\u00a0while (and != 0) {\n\u00a0\u00a0\u00a0\u00a0and = and << 1; // this is multiplication by 2\n\u00a0\u00a0\u00a0\u00a0// prepare the next step of recursion\n\u00a0\u00a0\u00a0\u00a0t = xor ^ and;\n\u00a0\u00a0\u00a0\u00a0and = and & xor;\n\u00a0\u00a0\u00a0\u00a0xor = t;\n\u00a0\u00a0}\n\u00a0\u00a0return xor;\n}\n```", "```java\npublic static int multiply(int q, int p) {\n\u00a0\u00a0int result = 0;\n\u00a0\u00a0while (p != 0) {\n\u00a0\u00a0\u00a0\u00a0// we compute the value of q only when the LSB of p is 1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if ((p & 1) != 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = result + q;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0q = q << 1;\u00a0\u00a0// q is left shifted with 1 position\n\u00a0\u00a0\u00a0\u00a0p = p >>> 1; // p is logical right shifted with 1 position\n\u00a0\u00a0}\n\u00a0\u00a0return result;\n}\n```", "```java\npublic static int subtract(int q, int p) {\n\u00a0\u00a0while (p != 0) {\n\u00a0\u00a0\u00a0\u00a0// borrow the unset bits of q AND set bits of p\n\u00a0\u00a0\u00a0\u00a0int borrow = (~q) & p;\n\u00a0\u00a0\u00a0\u00a0// subtraction of bits of q and p \n\u00a0\u00a0\u00a0\u00a0// where at least one of the bits is not set\n\u00a0\u00a0\u00a0\u00a0q = q ^ p;\n\u00a0\u00a0\u00a0\u00a0// left shift borrow by one position\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0p = borrow << 1;\n\u00a0\u00a0}\n\u00a0\u00a0return q;\n}\n```", "```java\nprivate static final int MAX_BIT = 31;\n...\npublic static long divideWithoutRemainder(long q, long p) {\n\u00a0\u00a0// obtain the sign of the division\n\u00a0\u00a0long sign = ((q < 0) ^ (p < 0)) ? -1 : 1;\n\u00a0\u00a0// ensure that q and p are positive\n\u00a0\u00a0q = Math.abs(q);\n\u00a0\u00a0p = Math.abs(p);\n\u00a0\u00a0long t = 0;\n\u00a0\u00a0long quotient = 0;\n\u00a0\u00a0for (int i = MAX_BIT; i >= 0; --i) {\n\u00a0\u00a0\u00a0\u00a0long halfdown = t + (p << i);\n\u00a0\u00a0\u00a0\u00a0if (halfdown <= q) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t = t + p << i;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0quotient = quotient | 1L << i;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return sign * quotient;\n}\n```", "```java\npublic static int replace(int q, int p, int i, int j) {\n\u00a0\u00a0int ones = ~0; // 11111111 11111111 11111111 11111111\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0int leftShiftJ = ones << (j + 1);\n\u00a0\u00a0int leftShiftI = ((1 << i) - 1);\n\u00a0\u00a0int mask = leftShiftJ | leftShiftI;\n\u00a0\u00a0int applyMaskToQ = q & mask;\n\u00a0\u00a0int bringPInPlace = p << i;\n\u00a0\u00a0return applyMaskToQ | bringPInPlace;\n}\n```", "```java\npublic static int sequence(int n) {\n\u00a0\u00a0if (~n == 0) {\n\u00a0\u00a0\u00a0\u00a0return Integer.SIZE; // 32\n\u00a0\u00a0}\n\u00a0\u00a0int currentSequence = 0;\n\u00a0\u00a0int longestSequence = 0;\n\u00a0\u00a0boolean flag = true;\n\u00a0\u00a0while (n != 0) {\n\u00a0\u00a0\u00a0\u00a0if ((n & 1) == 1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentSequence++;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0flag = false;\n\u00a0\u00a0\u00a0\u00a0} else if ((n & 1) == 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentSequence = ((n & 0b10) == 0) // 0b10 = 2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0? 0 : flag \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0? 0 : ++currentSequence;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0flag = true;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0longestSequence = Math.max(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentSequence, longestSequence);\n\u00a0\u00a0\u00a0\u00a0n >>>= 1;\n\u00a0\u00a0}\n\u00a0\u00a0return longestSequence;\n}\n```", "```java\nint copyn = n;\nint zeros = 0;\nwhile ((copyn != 0) && ((copyn & 1) == 0)) {\n\u00a0\u00a0zeros++;\n\u00a0\u00a0copyn = copyn >> 1;\n}\n```", "```java\nint ones=0;\nwhile ((copyn & 1) == 1) {\n\u00a0\u00a0ones++;\n\u00a0\u00a0copyn = copyn >> 1;\n}\n```", "```java\nn = n | (1 << marker);\n```", "```java\nn = n & (-1 << marker);\n```", "```java\nn = n | (1 << (ones - 1)) - 1;\n```", "```java\npublic static int next(int n) {\n\u00a0\u00a0int copyn = n;\n\u00a0\u00a0int zeros = 0;\n\u00a0\u00a0int ones = 0;\n\u00a0\u00a0// count trailing 0s\n\u00a0\u00a0while ((copyn != 0) && ((copyn & 1) == 0)) {\n\u00a0\u00a0\u00a0\u00a0zeros++;\n\u00a0\u00a0\u00a0\u00a0copyn = copyn >> 1;\n\u00a0\u00a0}\n\u00a0\u00a0// count all 1s until first 0\n\u00a0\u00a0while ((copyn & 1) == 1) {\n\u00a0\u00a0\u00a0\u00a0ones++;\n\u00a0\u00a0\u00a0\u00a0copyn = copyn >> 1;\n\u00a0\u00a0}\n\u00a0\u00a0// the 1111...000... is the biggest number \n\u00a0\u00a0// without adding more 1\n\u00a0\u00a0if (zeros + ones == 0 || zeros + ones == 31) {\n\u00a0\u00a0\u00a0\u00a0return -1;\n\u00a0\u00a0}\n\u00a0\u00a0int marker = zeros + ones;\n\u00a0\u00a0n = n | (1 << marker);\n\u00a0\u00a0n = n & (-1 << marker);\n\u00a0\u00a0n = n | (1 << (ones - 1)) - 1;\n\u00a0\u00a0return n;\n}\n```", "```java\npublic static int count(int q, int p) {\n\u00a0\u00a0int count = 0;\n\u00a0\u00a0// each 1 represents a bit that is \n\u00a0\u00a0// different between q and p\n\u00a0\u00a0int xor = q ^ p;\n\u00a0\u00a0while (xor != 0) {\n\u00a0\u00a0\u00a0\u00a0count += xor & 1; // only 1 & 1 = 1\n\u00a0\u00a0\u00a0\u00a0xor = xor >> 1;\n\u00a0\u00a0}\n\u00a0\u00a0return count;\n}\n```", "```java\npublic static int swap(int n) {\n\u00a0\u00a0int moveToEvenPositions\n\u00a0\u00a0\u00a0\u00a0= (n & 0b10101010101010101010101010101010) >>> 1;\n\u00a0\u00a0int moveToOddPositions\n\u00a0\u00a0\u00a0\u00a0= (n & 0b1010101010101010101010101010101) << 1;\n\u00a0\u00a0return moveToEvenPositions | moveToOddPositions;\n}\n```", "```java\npublic static int leftRotate(int n, int bits) {\n\u00a0\u00a0int fallBits = n << bits;\n\u00a0\u00a0int fallBitsShiftToRight = n >> (MAX_INT_BITS - bits);\n\u00a0\u00a0return fallBits | fallBitsShiftToRight;\n}\n```", "```java\npublic static int rightRotate(int n, int bits) {\n\u00a0\u00a0int fallBits = n >> bits;\n\u00a0\u00a0int fallBitsShiftToLeft = n << (MAX_INT_BITS - bits);\n\u00a0\u00a0return fallBits | fallBitsShiftToLeft;\n}\n```", "```java\npublic static int setBetween(int left, int right) {\n\u00a0\u00a0return (1 << (right + 1)) - (1 << left);\n}\n```", "```java\nprivate static final int INT_SIZE = 32;\npublic static int unique(int arr[]) {\n\u00a0\u00a0int n = arr.length;\n\u00a0\u00a0int result = 0;\n\u00a0\u00a0int nr;\n\u00a0\u00a0int sumBits;\n\u00a0\u00a0// iterate through every bit \n\u00a0\u00a0for (int i = 0; i < INT_SIZE; i++) {\n\u00a0\u00a0\u00a0\u00a0// compute the sum of set bits at \n\u00a0\u00a0\u00a0\u00a0// ith position in all array\n\u00a0\u00a0\u00a0\u00a0sumBits = 0;\n\u00a0\u00a0\u00a0\u00a0nr = (1 << i);\n\u00a0\u00a0\u00a0\u00a0for (int j = 0; j < n; j++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((arr[j] & nr) == 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sumBits++;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// the sum not multiple of 3 are the \n\u00a0\u00a0\u00a0\u00a0// bits of the unique number\n\u00a0\u00a0\u00a0\u00a0if ((sumBits % 3) == 0) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = result | nr;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return result;\n}\n```", "```java\npublic static int unique(int arr[]) {\n\u00a0\u00a0int oneAppearance = 0;\n\u00a0\u00a0int twoAppearances = 0;\n\u00a0\u00a0for (int i = 0; i < arr.length; i++) {\n\u00a0\u00a0\u00a0\u00a0twoAppearances = twoAppearances\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| (oneAppearance & arr[i]);\n\u00a0\u00a0\u00a0\u00a0oneAppearance = oneAppearance ^ arr[i];\n\u00a0\u00a0\u00a0\u00a0int neutraliser = ~(oneAppearance & twoAppearances);\n\u00a0\u00a0\u00a0\u00a0oneAppearance = oneAppearance & neutraliser;\n\u00a0\u00a0\u00a0\u00a0twoAppearances = twoAppearances & neutraliser;\n\u00a0\u00a0}\n\u00a0\u00a0return oneAppearance;\n}\n```", "```java\n\u00a0\u00a0private static final int MAX_N = 32000;\n\u00a0\u00a0public static void printDuplicates(int[] arr) {\n\u00a0\u00a0\u00a0\u00a0BitSet bitArr = new BitSet(MAX_N);\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < arr.length; i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int nr = arr[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (bitArr.get(nr)) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.out.println(\"Duplicate: \" + nr);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bitArr.set(nr);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n```", "```java\npublic static void findNonRepeatable(int arr[]) {\n\u00a0\u00a0// get the XOR[^] of all elements in the given array\n\u00a0\u00a0int xor = arr[0];\n\u00a0\u00a0for (int i = 1; i < arr.length; i++) {\n\u00a0\u00a0\u00a0\u00a0xor ^= arr[i];\n\u00a0\u00a0}\n\u00a0\u00a0// get the rightmost set bit (you can use any other set bit)\n\u00a0\u00a0int setBitNo = xor & ~(xor - 1);\n\u00a0\u00a0// divide the elements in two sets by comparing the \n\u00a0\u00a0// rightmost set bit of XOR[^] with the bit at the same \n\u00a0\u00a0// position in each element\n\u00a0\u00a0int p = 0;\n\u00a0\u00a0int q = 0;\n\u00a0\u00a0for (int i = 0; i < arr.length; i++) {\n\u00a0\u00a0\u00a0\u00a0if ((arr[i] & setBitNo) != 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// xor of the first set\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0p = p ^ arr[i];\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// xor of the second set\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q = q ^ arr[i];\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0System.out.println(\"The numbers are: \" + p + \" and \" + q);\n}\n```", "```java\nCompute the Power Set size as 2 size of S\nIterate via i from 0 to Power Set size\n\u00a0\u00a0\u00a0\u00a0 Iterate via j from 0 to size of S\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0If jth bit in i is set then\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Add jth element from set to current subset\n\u00a0\u00a0\u00a0\u00a0 Add the resulted subset to subsets\nReturn all subsets\n```", "```java\npublic static Set<Set<Character>> powerSet(char[] set) {\n\u00a0\u00a0// total number of subsets (2^n)\n\u00a0\u00a0long subsetsNo = (long) Math.pow(2, set.length);\n\u00a0\u00a0// store subsets\n\u00a0\u00a0Set<Set<Character>> subsets = new HashSet<>();\n\u00a0\u00a0// generate each subset one by one\n\u00a0\u00a0for (int i = 0; i < subsetsNo; i++) {\n\u00a0\u00a0\u00a0\u00a0Set<Character> subset = new HashSet<>();\n\u00a0\u00a0\u00a0\u00a0// check every bit of i\n\u00a0\u00a0\u00a0\u00a0for (int j = 0; j < set.length; j++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// if j'th bit of i is set, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// add set[j] to the current subset\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((i & (1 << j)) != 0) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subset.add(set[j]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0subsets.add(subset);\n\u00a0\u00a0}\n\u00a0\u00a0return subsets;\n}\n```", "```java\npublic static int findPosition(int n) {\n\u00a0\u00a0int count = 0;\n\u00a0\u00a0if (!isPowerOfTwo(n)) {\n\u00a0\u00a0\u00a0\u00a0return -1;\n\u00a0\u00a0}\n\u00a0\u00a0while (n != 0) {\n\u00a0\u00a0\u00a0\u00a0n = n >> 1;\n\u00a0\u00a0\u00a0\u00a0++count;\n\u00a0\u00a0}\n\u00a0\u00a0return count;\n}\nprivate static boolean isPowerOfTwo(int n) {\n\u00a0\u00a0return (n > 0) && ((n & (n - 1)) == 0);\n}\n```"]