- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Improving Performance and Scalability Using Multitasking
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多任务处理改进性能和可伸缩性
- en: This chapter is about allowing multiple actions to occur at the same time to
    improve performance, scalability, and user productivity for the applications that
    you build.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于允许多个操作同时发生，以改进您构建的应用程序的性能、可伸缩性和用户生产力。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding processes, threads, and tasks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解进程、线程和任务
- en: Monitoring performance and resource usage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视性能和资源使用
- en: Running tasks asynchronously
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步运行任务
- en: Synchronizing access to shared resources
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步访问共享资源
- en: Understanding `async` and `await`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解`async`和`await`
- en: Understanding processes, threads, and tasks
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解进程、线程和任务
- en: A **process** , with one example being each of the console applications we have
    created, has resources like memory and threads allocated to it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程，例如我们创建的每个控制台应用程序，都分配了内存和线程等资源。
- en: A **thread** executes your code, statement by statement. By default, each process
    only has one thread, and this can cause problems when we need to do more than
    one task at the same time. Threads are also responsible for keeping track of things
    like the currently authenticated user and any internationalization rules that
    should be followed for the current language and region.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 线程逐条执行您的代码。默认情况下，每个进程只有一个线程，当我们需要同时执行多个任务时，这可能会导致问题。线程还负责跟踪当前经过身份验证的用户以及应遵循的当前语言和地区的任何国际化规则。
- en: Windows and most other modern operating systems use **preemptive multitasking**
    , which simulates the parallel execution of tasks. It divides the processor time
    among the threads, allocating a **time slice** to each thread one after another.
    The current thread is suspended when its time slice finishes. The processor then
    allows another thread to run for a time slice.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Windows和大多数其他现代操作系统使用抢占式多任务处理，模拟任务的并行执行。它将处理器时间分配给线程，依次为每个线程分配一个时间片。当前线程的时间片结束时，该线程被挂起。然后处理器允许另一个线程运行一段时间。
- en: When Windows switches from one thread to another, it saves the context of the
    thread and reloads the previously saved context of the next thread in the thread
    queue. This takes both time and resources to complete.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当Windows从一个线程切换到另一个线程时，它会保存线程的上下文，并重新加载线程队列中下一个线程的先前保存的上下文。这需要时间和资源来完成。
- en: As a developer, if you have a small number of complex pieces of work and you
    want complete control over them, then you could create and manage individual `Thread`
    instances. If you have one main thread and multiple small pieces of work that
    can be executed in the background, then you can use the `ThreadPool` class to
    add delegate instances that point to those pieces of work implemented as methods
    to a queue, and they will be automatically allocated to threads in the thread
    pool.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，如果您有少量复杂的工作，并且希望完全控制它们，那么您可以创建和管理单独的`Thread`实例。如果您有一个主线程和多个可以在后台执行的小任务，那么您可以使用`ThreadPool`类将指向作为方法实现的这些小任务的委托实例添加到队列中，它们将自动分配给线程池中的线程。
- en: In this chapter, we will use the `Task` type to manage threads at a higher abstraction
    level.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用`Task`类型以更高的抽象级别管理线程。
- en: Threads may have to compete for and also wait for access to shared resources,
    such as variables, files, and database objects. There are types for managing this
    that you will see in action later in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可能必须竞争并等待访问共享资源，例如变量、文件和数据库对象。有一些类型可以管理这一点，您将在本章后面看到它们的作用。
- en: Depending on the task, doubling the number of threads (workers) to perform a
    task does not halve the number of seconds that it will take to complete that task.
    In fact, it can increase the duration of the task.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据任务的不同，将线程（工作者）数量加倍以执行任务并不会减少完成该任务所需的秒数。事实上，这可能会增加任务的持续时间。
- en: '**Good Practice** : Never assume that more threads will improve performance!
    Run performance tests on a baseline code implementation without multiple threads,
    and then again on a code implementation with multiple threads. You should also
    perform performance tests in a staging environment that is as close as possible
    to the production environment.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 良好实践：永远不要假设更多的线程会提高性能！在没有多个线程的基线代码实现上运行性能测试，然后再在具有多个线程的代码实现上运行性能测试。您还应该在尽可能接近生产环境的暂存环境中进行性能测试。
- en: Monitoring performance and resource usage
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视性能和资源使用
- en: Before we can improve the performance of any code, we need to be able to monitor
    its speed and efficiency to record a baseline that we can then measure improvements
    against.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在改进任何代码的性能之前，我们需要能够监视其速度和效率，以记录我们可以根据其进行改进的基线。
- en: Evaluating the efficiency of types
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估类型的效率
- en: 'What is the best type to use for a scenario? To answer this question, we need
    to carefully consider what we mean by "best", and through this, we should consider
    the following factors:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定情景，使用哪种类型最好？要回答这个问题，我们需要仔细考虑“最好”的含义，并通过这一点，我们应该考虑以下因素：
- en: '**Functionality** : This can be decided by checking whether the type provides
    the features you need.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能：这可以通过检查类型是否提供所需的功能来决定。
- en: '**Memory size** : This can be decided by the number of bytes of memory the
    type takes up.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存大小：这可以通过类型占用的内存字节数来决定。
- en: '**Performance** : This can be decided by how fast the type is.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能：这可以通过类型的速度来决定。
- en: '**Future needs** : This depends on the changes in requirements and maintainability.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来需求：这取决于需求变化和可维护性。
- en: There will be scenarios, such as when storing numbers, where multiple types
    have the same functionality, so we will need to consider memory and performance
    to make a choice.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储数字等多种类型具有相同功能的情况下，我们需要考虑内存和性能来做出选择。
- en: If we need to store millions of numbers, then the best type to use would be
    the one that requires the fewest bytes of memory. But if we only need to store
    a few numbers, yet we need to perform lots of calculations on them, then the best
    type to use would be the one that runs fastest on a specific CPU.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要存储数百万个数字，那么最好使用需要最少字节内存的类型。但如果我们只需要存储少量数字，但需要对它们进行大量计算，那么最好使用在特定 CPU 上运行最快的类型。
- en: You have seen the use of the `sizeof()` function, which shows the number of
    bytes a single instance of a type uses in memory. When we are storing a large
    number of values in more complex data structures, such as arrays and lists, then
    we need a better way of measuring memory usage.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了 `sizeof()` 函数的使用，它显示了类型的单个实例在内存中使用的字节数。当我们在更复杂的数据结构中存储大量值时，例如数组和列表，那么我们需要更好的方法来测量内存使用情况。
- en: You can read lots of advice online and in books, but the only way to know for
    sure what the best type would be for your code is to compare the types yourself.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在网上和书籍中阅读很多建议，但要确定最适合您的代码的最佳类型的唯一方法是自己比较这些类型。
- en: In the next section, you will learn how to write code to monitor the actual
    memory requirements and performance when using different types.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何编写代码来监视使用不同类型时的实际内存需求和性能。
- en: Today a `short` variable might be the best choice, but it might be an even better
    choice to use an `int` variable, even though it takes twice as much space in the
    memory. This is because we might need a wider range of values to be stored in
    the future.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，`short` 变量可能是最佳选择，但使用 `int` 变量可能是更好的选择，即使它在内存中占用的空间是 `short` 的两倍。这是因为我们可能需要将来存储更广泛范围的值。
- en: 'There is an important metric that developers often forget: maintenance. This
    is a measure of how much effort another programmer would have to put in to understand
    and modify your code. If you make a nonobvious choice of type without explaining
    that choice with a helpful comment, then it might confuse the programmer who comes
    along later and needs to fix a bug or add a feature.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的开发者经常忽视的指标：维护。这是另一个程序员需要付出多少努力来理解和修改您的代码的度量。如果您选择了一个不明显的类型而没有用有帮助的注释来解释这个选择，那么可能会让后来的程序员困惑，他们需要修复错误或添加功能。
- en: Monitoring performance and memory using diagnostics
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用诊断监视性能和内存
- en: 'The `System.Diagnostics` namespace has lots of useful types for monitoring
    your code. The first useful type that we will look at is the `Stopwatch` type:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Diagnostics` 命名空间有很多有用的类型来监视您的代码。我们将首先看一下有用的 `Stopwatch` 类型：'
- en: Use your preferred coding tool to create a new workspace/solution named `Chapter12`
    .
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编码工具创建一个名为 `Chapter12` 的新工作空间/解决方案。
- en: 'Add a class library project, as defined in the following list:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个类库项目，如下列表所定义：
- en: 'Project template: **Class Library** / `classlib`'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**类库** / `classlib`
- en: 'Workspace/solution file and folder: `Chapter12`'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作空间/解决方案文件和文件夹：`Chapter12`
- en: 'Project file and folder: `MonitoringLib`'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`MonitoringLib`
- en: 'Add a console app project, as defined in the following list:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个控制台应用程序项目，如下列表所定义：
- en: 'Project template: **Console Application** / `console`'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Workspace/solution file and folder: `Chapter12`'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作空间/解决方案文件和文件夹：`Chapter12`
- en: 'Project file and folder: `MonitoringApp`'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`MonitoringApp`
- en: In Visual Studio, set the startup project for the solution to the current selection.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，将解决方案的启动项目设置为当前选择。
- en: In Visual Studio Code, select `MonitoringApp` as the active OmniSharp project.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，选择 `MonitoringApp` 作为活动的 OmniSharp 项目。
- en: In the `MonitoringLib` project, rename the `Class1.cs` file to `Recorder.cs`
    .
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MonitoringLib` 项目中，将 `Class1.cs` 文件重命名为 `Recorder.cs` 。
- en: 'In the `MonitoringApp` project, add a project reference to the `MonitoringLib`
    class library, as shown in the following markup:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MonitoringApp` 项目中，添加对 `MonitoringLib` 类库的项目引用，如下标记所示：
- en: '```cs'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <ItemGroup>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <ItemGroup>
- en: <ProjectReference
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <ProjectReference
- en: Include="..\MonitoringLib\MonitoringLib.csproj"
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Include="..\MonitoringLib\MonitoringLib.csproj"
- en: />
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: />
- en: </ItemGroup>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: </ItemGroup>
- en: '```'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Build the `MonitoringApp` project.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 `MonitoringApp` 项目。
- en: Useful members of the Stopwatch and Process types
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Stopwatch` 和 `Process` 类型的有用成员'
- en: 'The `Stopwatch` type has some useful members, as shown in the following table:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stopwatch` 类型有一些有用的成员，如下表所示：'
- en: '| Member | Description |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 成员 | 描述 |'
- en: '| `Restart` method | This resets the elapsed time to zero and then starts the
    timer. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `Restart` 方法 | 这将重置经过的时间为零，然后启动计时器。 |'
- en: '| `Stop` method | This stops the timer. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `Stop` 方法 | 这将停止计时器。 |'
- en: '| `Elapsed` property | This is the elapsed time stored as a `TimeSpan` format
    (for example, hours:minutes:seconds) |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `Elapsed` 属性 | 这是以 `TimeSpan` 格式（例如，小时：分钟：秒）存储的经过时间。 |'
- en: '| `ElapsedMilliseconds` property | This is the elapsed time in milliseconds
    stored as an `Int64` value. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `ElapsedMilliseconds` 属性 | 这是以 `Int64` 值存储的毫秒为单位的经过时间。 |'
- en: 'The `Process` type has some useful members, as shown in the following table:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Process` 类型有一些有用的成员，如下表所示：'
- en: '| Member | Description |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 成员 | 描述 |'
- en: '| `VirtualMemorySize64` | This displays the amount of virtual memory, in bytes,
    allocated for the process. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `VirtualMemorySize64` | 这显示为进程分配的虚拟内存量（以字节为单位）。 |'
- en: '| `WorkingSet64` | This displays the amount of physical memory, in bytes, allocated
    for the process. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `WorkingSet64` | 这显示为进程分配的物理内存量（以字节为单位）。 |'
- en: Implementing a Recorder class
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现一个 Recorder 类
- en: 'We will create a `Recorder` class that makes it easy to monitor time and memory
    resource usage. To implement our `Recorder` class, we will use the `Stopwatch`
    and `Process` classes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 `Recorder` 类，使得监视时间和内存资源使用变得容易。为了实现我们的 `Recorder` 类，我们将使用 `Stopwatch`
    和 `Process` 类：
- en: 'In `Recorder.cs` , change its contents to use a `Stopwatch` instance to record
    timings and the current `Process` instance to record memory usage, as shown in
    the following code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Recorder.cs` 中，更改其内容以使用 `Stopwatch` 实例记录时间和当前 `Process` 实例记录内存使用情况，如下面的代码所示：
- en: '```cs'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: System.Diagnostics; // Stopwatch
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: System.Diagnostics; // Stopwatch
- en: using
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: static
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: System.Console;
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: System.Console;
- en: using
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: static
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: System.Diagnostics.Process; // GetCurrentProcess()
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: System.Diagnostics.Process; // GetCurrentProcess()
- en: namespace
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: Packt.Shared
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: ;
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的
- en: static
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: class
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Recorder
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Recorder
- en: '{'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: private
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 私人的
- en: static
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: Stopwatch timer = new
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Stopwatch timer =新的
- en: ();
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: private
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 私人的
- en: static
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: long
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 长
- en: bytesPhysicalBefore = 0
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: bytesPhysicalBefore = 0
- en: ;
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: private
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 私人的
- en: static
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: long
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 长
- en: bytesVirtualBefore = 0
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: bytesVirtualBefore = 0
- en: ;
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的
- en: static
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: void
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Start
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 开始
- en: ()
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // force two garbage collections to release memory that is
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: // 强制进行两次垃圾收集以释放内存
- en: // no longer referenced but has not been released yet
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: // 不再被引用，但尚未被释放
- en: GC.Collect();
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: GC.Collect();
- en: GC.WaitForPendingFinalizers();
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: GC.WaitForPendingFinalizers();
- en: GC.Collect();
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: GC.Collect();
- en: // store the current physical and virtual memory use
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: // 存储当前的物理和虚拟内存使用情况
- en: bytesPhysicalBefore = GetCurrentProcess().WorkingSet64;
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: bytesPhysicalBefore = GetCurrentProcess().WorkingSet64;
- en: bytesVirtualBefore = GetCurrentProcess().VirtualMemorySize64;
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: bytesVirtualBefore = GetCurrentProcess().VirtualMemorySize64;
- en: timer.Restart();
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: timer.Restart();
- en: '}'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的
- en: static
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: void
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Stop
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 停止
- en: ()
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: timer.Stop();
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: timer.Stop();
- en: long
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 长
- en: bytesPhysicalAfter =
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: bytesPhysicalAfter =
- en: GetCurrentProcess().WorkingSet64;
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: GetCurrentProcess().WorkingSet64;
- en: long
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 长
- en: bytesVirtualAfter =
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: bytesVirtualAfter =
- en: GetCurrentProcess().VirtualMemorySize64;
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: GetCurrentProcess().VirtualMemorySize64;
- en: WriteLine("{0:N0} physical bytes used."
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("{0:N0}物理字节已使用。"
- en: ','
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: bytesPhysicalAfter - bytesPhysicalBefore);
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: bytesPhysicalAfter - bytesPhysicalBefore);
- en: WriteLine("{0:N0} virtual bytes used."
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("{0:N0}虚拟字节已使用。"
- en: ','
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: bytesVirtualAfter - bytesVirtualBefore);
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: bytesVirtualAfter - bytesVirtualBefore);
- en: WriteLine("{0} time span ellapsed."
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("{0}时间跨度已过。"
- en: ', timer.Elapsed);'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ', timer.Elapsed);'
- en: WriteLine("{0:N0} total milliseconds ellapsed."
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("{0:N0}总毫秒已过。"
- en: ','
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: timer.ElapsedMilliseconds);
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器.ElapsedMilliseconds);
- en: '}'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `Start` method of the `Recorder` class uses the `GC` type (garbage collector)
    to ensure that any currently allocated but not referenced memory is collected
    before recording the amount of used memory. This is an advanced technique that
    you should almost never use in application code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Recorder`类的`Start`方法使用`GC`类型（垃圾收集器）来确保在记录已使用的内存量之前收集当前分配但未引用的内存。这是一种高级技术，您几乎永远不应该在应用程序代码中使用。'
- en: 'In `Program.cs` , write statements to start and stop the `Recorder` while generating
    an array of 10,000 integers, as shown in the following code:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，编写语句以启动和停止`Recorder`，同时生成一个包含10,000个整数的数组，如下面的代码所示：
- en: '```cs'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: Packt.Shared; // Recorder
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared; // Recorder
- en: using
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: static
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: System.Console;
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: System.Console;
- en: WriteLine("Processing. Please wait..."
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("处理中。请稍候..."
- en: );
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Recorder.Start();
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Recorder.Start();
- en: // simulate a process that requires some memory resources...
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: // 模拟需要一些内存资源的过程...
- en: int
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: '[] largeArrayOfInts = Enumerable.Range('
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[] largeArrayOfInts = Enumerable.Range('
- en: 'start: 1'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 开始：1
- en: ', count: 10'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ，计数：10
- en: _000).ToArray();
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: _000).ToArray();
- en: // ...and takes some time to complete
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: // ...并且需要一些时间来完成
- en: Thread.Sleep(new
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Thread.Sleep(new
- en: Random().Next(5
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Random().Next(5
- en: ', 10'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ', 10'
- en: ) * 1000
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ) * 1000
- en: );
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Recorder.Stop();
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Recorder.Stop();
- en: '```'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Processing. Please wait...
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 处理中。请稍候...
- en: 655,360 physical bytes used.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 655,360物理字节已使用。
- en: 536,576 virtual bytes used.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用了536,576虚拟字节。
- en: 00:00:09.0038702 time span ellapsed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 00:00:09.0038702时间跨度已过。
- en: 9,003 total milliseconds ellapsed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 9,003毫秒总时间已过。
- en: '```'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Remember that the time elapsed is randomly between 5 and 10 seconds. Your results
    will vary. For example, when run on my Mac mini M1, less physical memory but more
    virtual memory was used, as shown in the following output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，经过的时间在5到10秒之间是随机的。您的结果会有所不同。例如，在我的Mac mini M1上运行时，使用的物理内存较少，但虚拟内存较多，如下面的输出所示：
- en: '```cs'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Processing. Please wait...
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 处理中。请稍候...
- en: 294,912 physical bytes used.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 294,912物理字节已使用。
- en: 10,485,760 virtual bytes used.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 10,485,760虚拟字节已使用。
- en: 00:00:06.0074221 time span ellapsed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 00:00:06.0074221时间跨度已过。
- en: 6,007 total milliseconds ellapsed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 6,007毫秒总时间已过。
- en: '```'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Measuring the efficiency of processing strings
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 衡量处理字符串的效率
- en: Now that you've seen how the `Stopwatch` and `Process` types can be used to
    monitor your code, we will use them to evaluate the best way to process `string`
    variables.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了`Stopwatch`和`Process`类型如何用于监视您的代码，我们将使用它们来评估处理`string`变量的最佳方法。
- en: 'In `Program.cs` , comment out the previous statements by wrapping them in multi-line
    comment characters: `/* */` .'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，通过使用多行注释字符`/* */`将先前的语句注释掉。
- en: 'Write statements to create an array of 50,000 `int` variables and then concatenate
    them with commas as separators using a `string` and `StringBuilder` class, as
    shown in the following code:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写语句以创建一个包含50,000个`int`变量的数组，然后使用`string`和`StringBuilder`类将它们连接起来，分隔符为逗号，如下面的代码所示：
- en: '```cs'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: '[] numbers = Enumerable.Range('
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[] numbers = Enumerable.Range('
- en: 'start: 1'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 开始：1
- en: ', count: 50'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ，计数：50
- en: _000).ToArray();
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: _000).ToArray();
- en: WriteLine("Using string with +"
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("使用带有+的字符串"
- en: );
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Recorder.Start();
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Recorder.Start();
- en: string
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: s = string
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: s =字符串
- en: .Empty; // i.e. ""
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: .Empty; // 即""
- en: for
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为
- en: (int
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: i = 0
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: ; i < numbers.Length; i++)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ; i < numbers.Length; i++)
- en: '{'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: s += numbers[i] + ", "
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: s += numbers[i] + ", "
- en: ;
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Recorder.Stop();
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Recorder.Stop();
- en: WriteLine("Using StringBuilder"
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("使用StringBuilder"
- en: );
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Recorder.Start();
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Recorder.Start();
- en: System.Text.StringBuilder builder = new
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: System.Text.StringBuilder builder =新的
- en: ();
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: for
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: for
- en: (int
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: i = 0
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: ; i < numbers.Length; i++)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ; i < numbers.Length; i++)
- en: '{'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: builder.Append(numbers[i]);
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: builder.Append(numbers[i]);
- en: builder.Append(", "
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: builder.Append(", "
- en: );
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Recorder.Stop();
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Recorder.Stop();
- en: '```'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Using string with +
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有+
- en: 14,883,072 physical bytes used.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 14,883,072物理字节已使用。
- en: 3,609,728 virtual bytes used.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 3,609,728虚拟字节已使用。
- en: 00:00:01.6220879 time span ellapsed.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 00:00:01.6220879时间跨度已过。
- en: 1,622 total milliseconds ellapsed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 1,622毫秒总时间已过。
- en: Using StringBuilder
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用StringBuilder
- en: 12,288 physical bytes used.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 12,288物理字节已使用。
- en: 0 virtual bytes used.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 0虚拟字节已使用。
- en: 00:00:00.0006038 time span ellapsed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 00:00:00.0006038时间跨度已过。
- en: 0 total milliseconds ellapsed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 0毫秒总时间已过。
- en: '```'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We can summarize the results as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以总结结果如下：
- en: The `string` class with the `+` operator used about 14 MB of physical memory,
    1.5 MB of virtual memory, and took 1.5 seconds.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`类与`+`运算符使用了约14 MB的物理内存，1.5 MB的虚拟内存，并花费了1.5秒。'
- en: The `StringBuilder` class used 12 KB of physical memory, zero virtual memory,
    and took less than 1 millisecond.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringBuilder`类使用了12 KB的物理内存，零虚拟内存，并且花费不到1毫秒。'
- en: In this scenario, `StringBuilder` is more than 1,000 times faster and about
    10,000 times more memory efficient when concatenating text! This is because `string`
    concatenation creates a new `string` each time you use it because `string` values
    are immutable so they can be safely pooled for reuse. `StringBuilder` creates
    a single buffer while it appends more characters.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`StringBuilder`连接文本时比`string`快1000多倍，内存效率约为10000倍！这是因为`string`连接每次使用时都会创建一个新的`string`，因为`string`值是不可变的，所以它们可以安全地用于重用。`StringBuilder`在追加更多字符时创建一个单一的缓冲区。
- en: '**Good Practice** : Avoid using the `String.Concat` method or the `+` operator
    inside loops. Use `StringBuilder` instead.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：避免在循环内使用`String.Concat`方法或`+`运算符。改用`StringBuilder`。'
- en: Now that you've learned how to measure the performance and resource efficiency
    of your code using types built into .NET, let's learn about a NuGet package that
    provides more sophisticated performance measurements.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何使用.NET内置的类型来测量代码的性能和资源效率，让我们了解一个提供更复杂性能测量的NuGet包。
- en: Monitoring performance and memory using Benchmark.NET
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Benchmark.NET监视性能和内存
- en: 'There is a popular benchmarking NuGet package for .NET that Microsoft uses
    in its blog posts about performance improvements, so it is good for .NET developers
    to know how it works and use it for their own performance testing. Let''s see
    how we could use it to compare performance between `string` concatenation and
    `StringBuilder` :'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: .NET有一个流行的基准测试NuGet包，微软在其关于性能改进的博客文章中使用它，因此对于.NET开发人员来说，了解它的工作原理并将其用于自己的性能测试是很好的。让我们看看如何使用它来比较`string`连接和`StringBuilder`之间的性能：
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `Benchmarking` .
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器将一个新的控制台应用程序添加到名为`Benchmarking`的`Chapter12`解决方案/工作区中。
- en: In Visual Studio Code, select `Benchmarking` as the active OmniSharp project.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`Benchmarking`作为活动的OmniSharp项目。
- en: 'Add a package reference to Benchmark.NET, remembering that you can find out
    the latest version and use that instead of the version I used, as shown in the
    following markup:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对Benchmark.NET的包引用，记住您可以查找最新版本并使用该版本，而不是我使用的版本，如下面的标记所示：
- en: '```cs'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <ItemGroup>
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: <ItemGroup>
- en: <PackageReference Include="BenchmarkDotNet"
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: <PackageReference Include="BenchmarkDotNet"
- en: Version="0.13.1"
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Version="0.13.1"
- en: />
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: />
- en: </ItemGroup>
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: </ItemGroup>
- en: '```'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Build the project to restore packages.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目以恢复包。
- en: 'In `Program.cs` , delete the existing statements and then import the namespace
    for running benchmarks, as shown in the following code:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有的语句，然后导入运行基准测试的命名空间，如下面的代码所示：
- en: '```cs'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: using
- en: BenchmarkDotNet.Running;
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: BenchmarkDotNet.Running;
- en: '```'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Add a new class file named `StringBenchmarks.cs` .
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`StringBenchmarks.cs`的新类文件。
- en: 'In `StringBenchmarks.cs` , add statements to define a class with methods for
    each benchmark you want to run, in this case, two methods that both combine twenty
    numbers comma-separated using either `string` concatenation or `StringBuilder`
    , as shown in the following code:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StringBenchmarks.cs`中，添加语句来定义一个类，其中包含您想要运行的每个基准测试的方法，本例中，两种方法都使用`string`连接或`StringBuilder`连接二十个逗号分隔的数字，如下面的代码所示：
- en: '```cs'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: BenchmarkDotNet.Attributes; // [Benchmark]
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: BenchmarkDotNet.Attributes; // [Benchmark]
- en: public
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: class
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: class
- en: StringBenchmarks
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: StringBenchmarks
- en: '{'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: '[] numbers;'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[] numbers;'
- en: public
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: StringBenchmarks
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: StringBenchmarks
- en: ()
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: numbers = Enumerable.Range(
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: numbers = Enumerable.Range(
- en: 'start: 1'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 'start: 1'
- en: ', count: 20'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ，计数：20
- en: ).ToArray();
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ).ToArray();
- en: '}'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[Benchmark(Baseline = true)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[Benchmark(Baseline = true)'
- en: ']'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: public
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: string
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: StringConcatenationTest
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: StringConcatenationTest
- en: ()
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: string
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: s = string
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: s = string
- en: .Empty; // e.g. ""
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: .Empty; // 例如""
- en: for
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: for
- en: (int
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: i = 0
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: ; i < numbers.Length; i++)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ; i < numbers.Length; i++)
- en: '{'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: s += numbers[i] + ", "
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: s += numbers[i] + ", "
- en: ;
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: s;
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: s;
- en: '}'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[Benchmark'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[Benchmark'
- en: ']'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: public
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: string
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: StringBuilderTest
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: StringBuilderTest
- en: ()
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: System.Text.StringBuilder builder = new
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: System.Text.StringBuilder builder = new
- en: ();
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: for
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: for
- en: (int
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: i = 0
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: ; i < numbers.Length; i++)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ; i < numbers.Length; i++)
- en: '{'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: builder.Append(numbers[i]);
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: builder.Append(numbers[i]);
- en: builder.Append(", "
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: builder.Append(", "
- en: );
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '}'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: builder.ToString();
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: builder.ToString();
- en: '}'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add a statement to run the benchmarks, as shown in the following
    code:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一个语句来运行基准测试，如下面的代码所示：
- en: '```cs'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: BenchmarkRunner.Run<StringBenchmarks>();
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: BenchmarkRunner.Run<StringBenchmarks>();
- en: '```'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In Visual Studio 2022, in the toolbar, set **Solution Configurations** to **Release**
    .
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2022中，在工具栏中，将**解决方案配置**设置为**Release**。
- en: In Visual Studio Code, in a terminal, use the `dotnet run --configuration Release`
    command.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，在终端中使用`dotnet run --configuration Release`命令。
- en: 'Run the console app and note the results, including some artifacts like report
    files, and the most important, a summary table that shows that `string` concatenation
    took a mean of 412.990 ns and `StringBuilder` took a mean of 275.082 ns, as shown
    in the following partial output and in *Figure 12.1* :'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并注意结果，包括一些报告文件等工件，最重要的是，一个总结表，显示`string`连接的平均时间为412.990 ns，`StringBuilder`的平均时间为275.082
    ns，如下面的部分输出和*图12.1*所示：
- en: '```cs'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '// ***** BenchmarkRunner: Finish  *****'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '// ***** BenchmarkRunner: Finish  *****'
- en: // * Export *
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: // *导出*
- en: BenchmarkDotNet.Artifacts\results\StringBenchmarks-report.csv
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: BenchmarkDotNet.Artifacts\results\StringBenchmarks-report.csv
- en: BenchmarkDotNet.Artifacts\results\StringBenchmarks-report-github.md
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: BenchmarkDotNet.Artifacts\results\StringBenchmarks-report-github.md
- en: BenchmarkDotNet.Artifacts\results\StringBenchmarks-report.html
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: BenchmarkDotNet.Artifacts\results\StringBenchmarks-report.html
- en: // * Detailed results *
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: // *详细结果*
- en: 'StringBenchmarks.StringConcatenationTest: DefaultJob'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 'StringBenchmarks.StringConcatenationTest: DefaultJob'
- en: Runtime = .NET 6.0.0 (6.0.21.37719), X64 RyuJIT; GC = Concurrent Workstation
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Runtime = .NET 6.0.0 (6.0.21.37719), X64 RyuJIT; GC = Concurrent Workstation
- en: Mean = 412.990 ns, StdErr = 2.353 ns (0.57%), N = 46, StdDev = 15.957 ns
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值= 412.990 ns，StdErr= 2.353 ns (0.57%)，N= 46，StdDev= 15.957 ns
- en: Min = 373.636 ns, Q1 = 413.341 ns, Median = 417.665 ns, Q3 = 420.775 ns, Max
    = 434.504 ns
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值= 373.636 ns，Q1= 413.341 ns，中位数= 417.665 ns，Q3= 420.775 ns，最大值= 434.504 ns
- en: IQR = 7.433 ns, LowerFence = 402.191 ns, UpperFence = 431.925 ns
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: IQR= 7.433 ns，LowerFence= 402.191 ns，UpperFence= 431.925 ns
- en: ConfidenceInterval = [404.708 ns; 421.273 ns] (CI 99.9%), Margin = 8.282 ns
    (2.01% of Mean)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 置信区间= [404.708 ns; 421.273 ns] (CI 99.9%)，边际= 8.282 ns (平均值的2.01%)
- en: Skewness = -1.51, Kurtosis = 4.09, MValue = 2
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 偏度= -1.51，峰度= 4.09，M值= 2
- en: '-------------------- Histogram --------------------'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '-------------------- 直方图 --------------------'
- en: '[370.520 ns ; 382.211 ns) | @@@@@@'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '[370.520 ns ; 382.211 ns) | @@@@@@'
- en: '[382.211 ns ; 394.583 ns) | @'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '[382.211 ns ; 394.583 ns) | @'
- en: '[394.583 ns ; 411.300 ns) | @@'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[394.583 ns ; 411.300 ns) | @@'
- en: '[411.300 ns ; 422.990 ns) | @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '[411.300 ns ; 422.990 ns) | @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@'
- en: '[422.990 ns ; 436.095 ns) | @@@@@'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '[422.990 ns ; 436.095 ns) | @@@@@'
- en: '---------------------------------------------------'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '---------------------------------------------------'
- en: 'StringBenchmarks.StringBuilderTest: DefaultJob'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: StringBenchmarks.StringBuilderTest：默认作业
- en: Runtime = .NET 6.0.0 (6.0.21.37719), X64 RyuJIT; GC = Concurrent Workstation
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Runtime = .NET 6.0.0 (6.0.21.37719)，X64 RyuJIT；GC = Concurrent Workstation
- en: Mean = 275.082 ns, StdErr = 0.558 ns (0.20%), N = 15, StdDev = 2.163 ns
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值= 275.082 ns，StdErr= 0.558 ns (0.20%)，N= 15，StdDev= 2.163 ns
- en: Min = 271.059 ns, Q1 = 274.495 ns, Median = 275.403 ns, Q3 = 276.553 ns, Max
    = 278.030 ns
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值= 271.059 ns，Q1= 274.495 ns，中位数= 275.403 ns，Q3= 276.553 ns，最大值= 278.030 ns
- en: IQR = 2.058 ns, LowerFence = 271.409 ns, UpperFence = 279.639 ns
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: IQR= 2.058 ns，LowerFence= 271.409 ns，UpperFence= 279.639 ns
- en: ConfidenceInterval = [272.770 ns; 277.394 ns] (CI 99.9%), Margin = 2.312 ns
    (0.84% of Mean)
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 置信区间= [272.770 ns; 277.394 ns] (CI 99.9%)，边际= 2.312 ns (平均值的0.84%)
- en: Skewness = -0.69, Kurtosis = 2.2, MValue = 2
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 偏度= -0.69，峰度= 2.2，M值= 2
- en: '-------------------- Histogram --------------------'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '-------------------- 直方图 --------------------'
- en: '[269.908 ns ; 278.682 ns) | @@@@@@@@@@@@@@@'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '[269.908 ns ; 278.682 ns) | @@@@@@@@@@@@@@@'
- en: '---------------------------------------------------'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '---------------------------------------------------'
- en: // * Summary *
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: // * 摘要 *
- en: BenchmarkDotNet=v0.13.1, OS=Windows 10.0.19043.1165 (21H1/May2021Update)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: BenchmarkDotNet=v0.13.1，OS=Windows 10.0.19043.1165 (21H1/May2021Update)
- en: 11th Gen Intel Core i7-1165G7 2.80GHz, 1 CPU, 8 logical and 4 physical cores
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 第11代英特尔酷睿i7-1165G7 2.80GHz，1个CPU，8个逻辑和4个物理内核
- en: .NET SDK=6.0.100
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: .NET SDK=6.0.100
- en: '[Host]     : .NET 6.0.0 (6.0.21.37719), X64 RyuJIT'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '[主机]：.NET 6.0.0 (6.0.21.37719)，X64 RyuJIT'
- en: 'DefaultJob : .NET 6.0.0 (6.0.21.37719), X64 RyuJIT'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: DefaultJob：.NET 6.0.0 (6.0.21.37719)，X64 RyuJIT
- en: '|                  Method |     Mean |   Error |   StdDev | Ratio | RatioSD
    |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 平均值 | 错误 | 标准偏差 | 比率 | RatioSD |'
- en: '|------------------------ |---------:|--------:|---------:|------:|--------:|'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '|------------------------ |---------:|--------:|---------:|------:|--------:|'
- en: '| StringConcatenationTest | 413.0 ns | 8.28 ns | 15.96 ns |  1.00 |    0.00
    |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| StringConcatenationTest | 413.0 ns | 8.28 ns | 15.96 ns |  1.00 |    0.00
    |'
- en: '|       StringBuilderTest | 275.1 ns | 2.31 ns |  2.16 ns |  0.69 |    0.04
    |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '|       StringBuilderTest | 275.1 ns | 2.31 ns |  2.16 ns |  0.69 |    0.04
    |'
- en: // * Hints *
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: // * 提示 *
- en: Outliers
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 异常值
- en: 'StringBenchmarks.StringConcatenationTest: Default -> 7 outliers were removed,
    14 outliers were detected (376.78 ns..391.88 ns, 440.79 ns..506.41 ns)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: StringBenchmarks.StringConcatenationTest：默认->删除了7个异常值，检测到14个异常值(376.78 ns..391.88
    ns，440.79 ns..506.41 ns)
- en: 'StringBenchmarks.StringBuilderTest: Default       -> 2 outliers were detected
    (274.68 ns, 274.69 ns)'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: StringBenchmarks.StringBuilderTest：默认->检测到2个异常值(274.68 ns，274.69 ns)
- en: // * Legends *
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: // * 图例 *
- en: 'Mean    : Arithmetic mean of all measurements'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值：所有测量的算术平均值
- en: 'Error   : Half of 99.9% confidence interval'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：99.9%置信区间的一半
- en: 'StdDev  : Standard deviation of all measurements'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: StdDev：所有测量的标准偏差
- en: 'Ratio   : Mean of the ratio distribution ([Current]/[Baseline])'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 比率：比率分布的平均值([当前]/[基线])
- en: 'RatioSD : Standard deviation of the ratio distribution ([Current]/[Baseline])'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: RatioSD：比率分布的标准偏差([当前]/[基线])
- en: '1 ns    : 1 Nanosecond (0.000000001 sec)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 1 ns：1纳秒(0.000000001秒)
- en: '// ***** BenchmarkRunner: End *****'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '// ***** BenchmarkRunner: End *****'
- en: // ** Remained 0 benchmark(s) to run **
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: // ** 剩余0个基准要运行 **
- en: 'Run time: 00:01:13 (73.35 sec), executed benchmarks: 2'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时间：00:01:13 (73.35秒)，执行基准测试：2
- en: 'Global total time: 00:01:29 (89.71 sec), executed benchmarks: 2'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 全局总时间：00:01:29 (89.71秒)，执行基准测试：2
- en: // * Artifacts cleanup *
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: // * 清理工件 *
- en: '```'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '![](img/Image00099.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00099.jpg)'
- en: 'Figure 12.1: Summary table that shows StringBuilder takes 69% of the time compared
    to string concatenation'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：摘要表，显示StringBuilder所占时间为字符串连接的69%
- en: The `Outliers` section is especially interesting because it shows that not only
    is `string` concatenation slower than `StringBuilder` , but it is also more inconsistent
    in how long it takes. Your results will vary, of course.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`异常值`部分特别有趣，因为它显示了`string`连接不仅比`StringBuilder`慢，而且在花费的时间上也更不一致。当然，您的结果会有所不同。'
- en: You have now seen two ways to measure performance. Now let's see how we can
    run tasks asynchronously to potentially improve performance.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经看到了衡量性能的两种方法。现在让我们看看如何异步运行任务，以潜在地提高性能。
- en: Running tasks asynchronously
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步运行任务
- en: To understand how multiple tasks can be run simultaneously (at the same time),
    we will create a console application that needs to execute three methods.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解如何同时运行多个任务(同时)，我们将创建一个需要执行三种方法的控制台应用程序。
- en: 'There will be three methods that need to be executed: the first takes 3 seconds,
    the second takes 2 seconds, and the third takes 1 second. To simulate that work,
    we can use the `Thread` class to tell the current thread to go to sleep for a
    specified number of milliseconds.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 需要执行三种方法：第一种需要3秒，第二种需要2秒，第三种需要1秒。为了模拟这项工作，我们可以使用`Thread`类告诉当前线程休眠指定的毫秒数。
- en: Running multiple actions synchronously
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步运行多个操作
- en: Before we make the tasks run simultaneously, we will run them synchronously,
    that is, one after the other.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使任务同时运行之前，我们将以同步方式运行它们，也就是一个接一个地运行。
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `WorkingWithTasks` .
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器向`Chapter12`解决方案/工作区添加一个名为`WorkingWithTasks`的新控制台应用程序。
- en: In Visual Studio Code, select `WorkingWithTasks` as the active OmniSharp project.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，将`WorkingWithTasks`选择为活动的OmniSharp项目。
- en: 'In `Program.cs` , import the namespace to work with a stopwatch (namespaces
    for working with threading and tasks are implicitly imported), and statically
    import `Console` , as shown in the following code:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，导入用于使用秒表的命名空间（用于处理线程和任务的命名空间会被隐式导入），并静态导入`Console`，如下面的代码所示：
- en: '```cs'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: System.Diagnostics; // Stopwatch
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: System.Diagnostics; // Stopwatch
- en: using
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: static
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: System.Console;
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: System.Console;
- en: '```'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'At the bottom of `Program.cs` , create a method to output information about
    the current thread, as shown in the following code:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的底部，创建一个方法来输出有关当前线程的信息，如下面的代码所示：
- en: '```cs'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: static
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: void
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: OutputThreadInfo
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: OutputThreadInfo
- en: ()
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Thread t = Thread.CurrentThread;
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: Thread t = Thread.CurrentThread;
- en: WriteLine(
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(
- en: '"Thread Id: {0}, Priority: {1}, Background: {2}, Name: {3}"'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '"线程Id：{0}，优先级：{1}，后台：{2}，名称：{3}"'
- en: ','
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: t.ManagedThreadId, t.Priority,
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: t.ManagedThreadId, t.Priority,
- en: t.IsBackground, t.Name ?? "null"
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: t.IsBackground, t.Name ?? "null"
- en: );
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'At the bottom of `Program.cs` , add three methods that simulate work, as shown
    in the following code:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的底部，添加三个模拟工作的方法，如下面的代码所示：
- en: '```cs'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: static
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: void
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: MethodA
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: MethodA
- en: ()
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine("Starting Method A..."
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("开始方法A..."
- en: );
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: OutputThreadInfo();
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: OutputThreadInfo();
- en: Thread.Sleep(3000
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: Thread.Sleep(3000
- en: ); // simulate three seconds of work
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: ); // 模拟三秒的工作
- en: WriteLine("Finished Method A."
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("完成方法A。"
- en: );
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: static
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: void
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: MethodB
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: MethodB
- en: ()
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine("Starting Method B..."
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("开始方法B..."
- en: );
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: OutputThreadInfo();
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: OutputThreadInfo();
- en: Thread.Sleep(2000
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: Thread.Sleep(2000
- en: ); // simulate two seconds of work
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: ); // 模拟两秒的工作
- en: WriteLine("Finished Method B."
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("完成方法B。"
- en: );
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: static
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: void
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: MethodC
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: MethodC
- en: ()
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine("Starting Method C..."
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("开始方法C..."
- en: );
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: OutputThreadInfo();
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: OutputThreadInfo();
- en: Thread.Sleep(1000
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: Thread.Sleep(1000
- en: ); // simulate one second of work
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: ); // 模拟一秒的工作
- en: WriteLine("Finished Method C."
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("完成方法C。"
- en: );
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'At the top of `Program.cs` , add statements to call the method to output information
    about the thread, define and start a stopwatch, call the three simulated work
    methods, and then output the milliseconds elapsed, as shown in the following code:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的顶部，添加语句来调用输出有关线程的信息的方法，定义并启动秒表，调用三个模拟工作方法，然后输出经过的毫秒数，如下面的代码所示：
- en: '```cs'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: OutputThreadInfo();
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: OutputThreadInfo();
- en: Stopwatch timer = Stopwatch.StartNew();
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: Stopwatch timer = Stopwatch.StartNew();
- en: WriteLine("Running methods synchronously on one thread."
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("在一个线程上同步运行方法。"
- en: );
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: MethodA();
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: MethodA();
- en: MethodB();
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: MethodB();
- en: MethodC();
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: MethodC();
- en: WriteLine($"
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{timer.ElapsedMilliseconds:#,##'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '{timer.ElapsedMilliseconds:#,##'
- en: '0'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '}'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ms elapsed."
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 毫秒。"
- en: );
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code, view the result, and note that when there is only one unnamed
    foreground thread doing the work, the total time required is just over 6 seconds,
    as shown in the following output:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意当只有一个未命名的前台线程在工作时，所需的总时间略长于6秒，如下面的输出所示：
- en: '```cs'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Thread Id: 1, Priority: Normal, Background: False, Name: null'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 线程Id：1，优先级：普通，后台：假，名称：null
- en: Running methods synchronously on one thread.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个线程上同步运行方法。
- en: Starting Method A...
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 开始方法A...
- en: 'Thread Id: 1, Priority: Normal, Background: False, Name: null'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 线程Id：1，优先级：普通，后台：假，名称：null
- en: Finished Method A.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 完成方法A。
- en: Starting Method B...
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 开始方法B...
- en: 'Thread Id: 1, Priority: Normal, Background: False, Name: null'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 线程Id：1，优先级：普通，后台：假，名称：null
- en: Finished Method B.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 完成方法B。
- en: Starting Method C...
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 开始方法C...
- en: 'Thread Id: 1, Priority: Normal, Background: False, Name: null'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 线程Id：1，优先级：普通，后台：假，名称：null
- en: Finished Method C.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 完成方法C。
- en: 6,017ms elapsed.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 经过6,017毫秒。
- en: '```'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Running multiple actions asynchronously using tasks
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用任务异步运行多个操作
- en: The `Thread` class has been available since the first version of .NET and can
    be used to create new threads and manage them, but it can be tricky to work with
    directly.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类自.NET的第一个版本就可用，可用于创建新线程并管理它们，但直接使用可能会有些棘手。'
- en: .NET Framework 4.0 introduced the `Task` class in 2010, which is a wrapper around
    a thread that enables easier creation and management. Managing multiple threads
    wrapped in tasks will allow our code to execute at the same time, aka asynchronously.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework 4.0在2010年引入了`Task`类，它是对线程的包装，使得创建和管理更加容易。管理在任务中包装的多个线程将允许我们的代码同时执行，也就是异步执行。
- en: Each `Task` has a `Status` property and a `CreationOptions` property. A `Task`
    has a `ContinueWith` method that can be customized with the `TaskContinuationOptions`
    enum, and can be managed with the `TaskFactory` class.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Task`都有一个`Status`属性和一个`CreationOptions`属性。`Task`有一个`ContinueWith`方法，可以使用`TaskContinuationOptions`枚举进行自定义，并可以使用`TaskFactory`类进行管理。
- en: Starting tasks
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始任务
- en: 'We will look at three ways to start the methods using `Task` instances. There
    are links in the GitHub repository to articles that discuss the pros and cons.
    Each has a slightly different syntax, but they all define a `Task` and start it:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到三种使用`Task`实例启动方法的方式。GitHub存储库中有链接到讨论优缺点的文章。每种语法略有不同，但它们都定义了一个`Task`并启动了它：
- en: 'Comment out the calls to the three methods and their associated console message,
    and add statements to create and start three tasks, one for each method, as shown
    highlighted in the following code:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉对三个方法及其相关控制台消息的调用，并添加语句来创建和启动三个任务，每个方法一个，如下面代码中所示：
- en: '```cs'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: OutputThreadInfo();
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: OutputThreadInfo();
- en: Stopwatch timer = Stopwatch.StartNew();
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: Stopwatch timer = Stopwatch.StartNew();
- en: '**/***'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '**/***'
- en: WriteLine("Running methods synchronously on one thread.");
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("在一个线程上同步运行方法。");
- en: MethodA();
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: MethodA();
- en: MethodB();
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: MethodB();
- en: MethodC();
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: MethodC();
- en: '***/**'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '***/**'
- en: '**WriteLine(**'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '**WriteLine(**'
- en: '**"Running methods asynchronously on multiple threads."**'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '**"在多个线程上异步运行方法。"**'
- en: '**);**'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '**);**'
- en: '**Task taskA =**'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '**Task taskA =**'
- en: '**new**'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 新
- en: '**(MethodA);**'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '**(MethodA);**'
- en: '**taskA.Start();**'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '**taskA.Start();**'
- en: '**Task taskB = Task.Factory.StartNew(MethodB);**'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '**Task taskB = Task.Factory.StartNew(MethodB);**'
- en: '**Task taskC = Task.Run(MethodC);**'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '**Task taskC = Task.Run(MethodC);**'
- en: WriteLine($"
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{timer.ElapsedMilliseconds:#,##'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '{timer.ElapsedMilliseconds:#,##'
- en: '0'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '}'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ms elapsed."
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 毫秒已过。"
- en: );
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code, view the result, and note that the elapsed milliseconds appear
    almost immediately. This is because each of the three methods is now being executed
    by three new background worker threads allocated from the thread pool, as shown
    in the following output:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意经过的毫秒几乎立即出现。这是因为现在每个方法都是由从线程池分配的三个新后台工作线程执行的，如下面的输出所示：
- en: '```cs'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Thread Id: 1, Priority: Normal, Background: False, Name: null'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '线程Id: 1，优先级: 正常，后台: False，名称: null'
- en: Running methods asynchronously on multiple threads.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个线程上异步运行方法。
- en: Starting Method A...
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 开始方法A...
- en: 'Thread Id: 4, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '线程Id: 4，优先级: 正常，后台: True，名称: .NET ThreadPool Worker'
- en: Starting Method C...
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 开始方法C...
- en: 'Thread Id: 7, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '线程Id: 7，优先级: 正常，后台: True，名称: .NET ThreadPool Worker'
- en: Starting Method B...
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 开始方法B...
- en: 'Thread Id: 6, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '线程Id: 6，优先级: 正常，后台: True，名称: .NET ThreadPool Worker'
- en: 6ms elapsed.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 6ms经过。
- en: '```'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It is even possible that the console app will end before one or more of the
    tasks have a chance to start and write to the console!
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可能控制台应用程序在一个或多个任务有机会开始并写入控制台之前结束！
- en: Waiting for tasks
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待任务
- en: 'Sometimes, you need to wait for a task to complete before continuing. To do
    this, you can use the `Wait` method on a `Task` instance, or the `WaitAll` or
    `WaitAny` static methods on an array of tasks, as described in the following table:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要等待任务完成后才能继续。为此，您可以在`Task`实例上使用`Wait`方法，或者在任务数组上使用`WaitAll`或`WaitAny`静态方法，如下表所述：
- en: '| Method | Description |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| `t.Wait()` | This waits for the task instance named `t` to complete execution.
    |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| `t.Wait()` | 这等待任务实例` t`完成执行。|'
- en: '| `Task.WaitAny(Task[])` | This waits for any of the tasks in the array to
    complete execution. |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| `Task.WaitAny(Task[])` | 这等待数组中的任何任务完成执行。|'
- en: '| `Task.WaitAll(Task[])` | This waits for all the tasks in the array to complete
    execution. |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| `Task.WaitAll(Task[])` | 这等待数组中的所有任务完成执行。|'
- en: Using wait methods with tasks
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用任务的等待方法
- en: Let's see how we can use these wait methods to fix the problem with our console
    app.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这些等待方法来解决控制台应用程序的问题。
- en: 'In `Program.cs` , add statements after creating the three tasks and before
    outputting the elapsed time to combine references to the three tasks into an array
    and pass them to the `WaitAll` method, as shown in the following code:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，在创建三个任务之后并在输出经过的时间之前，添加语句将对三个任务的引用组合成数组，并将它们传递给`WaitAll`方法，如下面的代码所示：
- en: '```cs'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Task[] tasks = { taskA, taskB, taskC };
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 任务[]任务= {任务A，任务B，任务C};
- en: Task.WaitAll(tasks);
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: Task.WaitAll(tasks);
- en: '```'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, and note the original thread will pause on
    the call to `WaitAll` , waiting for all three tasks to finish before outputting
    the elapsed time, which is a little over 3 seconds, as shown in the following
    output:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，并注意原始线程将在调用`WaitAll`时暂停，等待所有三个任务完成后再输出经过的时间，如下面的输出所示：超过3秒。
- en: '```cs'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Id: 1, Priority: Normal, Background: False, Name: null'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 'Id: 1, Priority: Normal, Background: False, Name: null'
- en: Running methods asynchronously on multiple threads.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个线程上异步运行方法。
- en: Starting Method A...
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 开始方法A...
- en: 'Id: 6, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 'Id: 6，优先级: 正常，后台: True，名称: .NET ThreadPool Worker'
- en: Starting Method B...
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 开始方法B...
- en: 'Id: 7, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 'Id: 7, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
- en: Starting Method C...
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 开始方法C...
- en: 'Id: 4, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 'Id: 4，优先级: 正常，后台: True，名称: .NET ThreadPool Worker'
- en: Finished Method C.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 完成方法C。
- en: Finished Method B.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 完成方法B。
- en: Finished Method A.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 完成方法A。
- en: 3,013ms elapsed.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 3,013ms经过。
- en: '```'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The three new threads execute their code simultaneously, and they can potentially
    start in any order. `MethodC` should finish first because it takes only 1 second,
    then `MethodB` , which takes 2 seconds, and finally `MethodA` , because it takes
    3 seconds.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 三个新线程同时执行它们的代码，并且它们可以以任何顺序开始。`MethodC`应该首先完成，因为它只需要1秒，然后是需要2秒的`MethodB`，最后是需要3秒的`MethodA`。
- en: However, the actual CPU used has a big effect on the results. It is the CPU
    that allocates time slices to each process to allow them to execute their threads.
    You have no control over when the methods run.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实际使用的CPU对结果有很大影响。CPU分配时间片给每个进程，以允许它们执行它们的线程。您无法控制方法何时运行。
- en: Continuing with another task
  id: totrans-576
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续进行另一个任务
- en: If all three tasks can be performed at the same time, then waiting for all tasks
    to finish will be all we need to do. However, often a task is dependent on the
    output from another task. To handle this scenario, we need to define **continuation
    tasks** .
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 如果三个任务都可以同时执行，那么等待所有任务完成将是我们需要做的。然而，通常一个任务依赖于另一个任务的输出。为了处理这种情况，我们需要定义**继续任务**。
- en: We will create some methods to simulate a call to a web service that returns
    a monetary amount that then needs to be used to retrieve how many products cost
    more than that amount in a database. The result returned from the first method
    needs to be fed into the input of the second method. This time, instead of waiting
    for fixed amounts of time, we will use the `Random` class to wait for a random
    interval between 2 and 4 seconds for each method call to simulate the work.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一些方法来模拟调用返回货币金额的网络服务，然后需要使用该金额来检索数据库中超过该金额的产品数量。第一个方法返回的结果需要输入到第二个方法中。这一次，我们将使用`Random`类来等待随机的时间间隔，每个方法调用的时间间隔在2到4秒之间，以模拟工作。
- en: 'At the bottom of `Program.cs` , add two methods that simulate calling a web
    service and a database-stored procedure, as shown in the following code:'
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的底部，添加两个模拟调用网络服务和数据库存储过程的方法，如下面的代码所示：
- en: '```cs'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: static
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的
- en: decimal
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 小数
- en: CallWebService
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: CallWebService
- en: ()
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine("Starting call to web service..."
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("开始调用web服务..."
- en: );
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: OutputThreadInfo();
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: OutputThreadInfo();
- en: Thread.Sleep((new
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: Thread.Sleep((new
- en: Random()).Next(2000
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 随机()).下一个(2000
- en: ', 4000'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: ，4000
- en: ));
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: WriteLine("Finished call to web service."
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("完成调用web服务。"
- en: );
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: return
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: '89.99'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '89.99'
- en: M;
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: M;
- en: '}'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: static
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: string
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: CallStoredProcedure
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: CallStoredProcedure
- en: (
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: decimal
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制
- en: amount
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 金额
- en: )
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine("Starting call to stored procedure..."
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("开始调用存储过程..."
- en: );
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: OutputThreadInfo();
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: OutputThreadInfo();
- en: Thread.Sleep((new
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: Thread.Sleep((new
- en: Random()).Next(2000
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: Random()).Next(2000
- en: ', 4000'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: ，4000
- en: ));
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: WriteLine("Finished call to stored procedure."
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("完成对存储过程的调用。"
- en: );
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: return
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: $"12 products cost more than
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: $"12个产品的成本超过
- en: '{amount:C}'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '{amount:C}'
- en: ."
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 。"
- en: ;
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Comment out the calls to the previous three tasks by wrapping them in multiline
    comment characters, `/* */` . Leave the statement that outputs the elapsed milliseconds.
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将它们包装在多行注释字符`/* */`中注释掉对前三个任务的调用。保留输出经过的毫秒数的语句。
- en: 'Add statements before the existing statement to output the total time, as shown
    in the following code:'
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有语句之前添加语句以输出总时间，如下所示：
- en: '```cs'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: WriteLine("Passing the result of one task as an input into another."
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("将一个任务的结果作为另一个任务的输入传递。"
- en: );
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Task<string
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 任务<string
- en: taskServiceThenSProc = Task.Factory
  id: totrans-629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: taskServiceThenSProc = Task.Factory
- en: .StartNew(CallWebService) // returns Task<decimal>
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: .StartNew(CallWebService) // 返回任务<十进制>
- en: .ContinueWith(previousTask => // returns Task<string>
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: .ContinueWith(previousTask => // 返回任务<string>
- en: CallStoredProcedure(previousTask.Result));
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: CallStoredProcedure(previousTask.Result));
- en: 'WriteLine($"Result:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"结果：
- en: '{taskServiceThenSProc.Result}'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '{taskServiceThenSProc.Result}'
- en: '"'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '```cs'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Thread Id: 1, Priority: Normal, Background: False, Name: null'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 线程ID：1，优先级：正常，后台：假，名称：null
- en: Passing the result of one task as an input into another.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个任务的结果作为另一个任务的输入传递。
- en: Starting call to web service...
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 开始调用web服务...
- en: 'Thread Id: 4, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 线程ID：4，优先级：正常，后台：真，名称：.NET线程池工作程序
- en: Finished call to web service.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 完成调用web服务。
- en: Starting call to stored procedure...
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 开始调用存储过程...
- en: 'Thread Id: 6, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 线程ID：6，优先级：正常，后台：真，名称：.NET线程池工作程序
- en: Finished call to stored procedure.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 完成调用存储过程。
- en: 'Result: 12 products cost more than £89.99.'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 结果：12个产品的成本超过89.99英镑。
- en: 5,463ms elapsed.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 5,463毫秒已过。
- en: '```'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You might see different threads running the web service and stored procedure
    calls as in the output above (threads 4 and 6), or the same thread might be reused
    since it is no longer busy.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会看到不同的线程运行web服务和存储过程调用，如上面的输出中所示（线程4和6），或者同一个线程可能会被重用，因为它不再忙碌。
- en: Nested and child tasks
  id: totrans-652
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套和子任务
- en: As well as defining dependencies between tasks, you can define nested and child
    tasks. A **nested task** is a task that is created inside another task. A **child
    task** is a nested task that must finish before its parent task is allowed to
    finish.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义任务之间的依赖关系，您还可以定义嵌套和子任务。**嵌套任务**是在另一个任务内创建的任务。**子任务**是必须在其父任务允许完成之前完成的嵌套任务。
- en: 'Let''s explore how these types of tasks work:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨这些类型的任务如何工作：
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `NestedAndChildTasks` .
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器向`Chapter12`解决方案/工作区添加一个名为`NestedAndChildTasks`的新控制台应用程序。
- en: In Visual Studio Code, select `NestedAndChildTasks` as the active OmniSharp
    project.
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`NestedAndChildTasks`作为活动的OmniSharp项目。
- en: 'In `Program.cs` , delete the existing statements, statically import `Console`
    , and then add two methods, one of which starts a task to run the other, as shown
    in the following code:'
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有语句，静态导入`Console`，然后添加两个方法，其中一个启动一个任务来运行另一个，如下所示：
- en: '```cs'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: static
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: void
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 空
- en: OuterMethod
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: OuterMethod
- en: ()
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine("Outer method starting..."
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("外部方法开始..."
- en: );
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Task innerTask = Task.Factory.StartNew(InnerMethod);
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 任务内部任务=任务工厂.StartNew(InnerMethod);
- en: WriteLine("Outer method finished."
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("外部方法完成。"
- en: );
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: static
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: void
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 空
- en: InnerMethod
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: InnerMethod
- en: ()
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine("Inner method starting..."
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("内部方法开始..."
- en: );
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Thread.Sleep(2000
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 线程休眠(2000
- en: );
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine("Inner method finished."
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("内部方法完成。"
- en: );
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Above the methods, add statements to start a task to run the outer method and
    wait for it to finish before stopping, as shown in the following code:'
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些方法之上，添加语句以启动一个任务来运行外部方法，并在停止之前等待它完成，如下所示：
- en: '```cs'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Task outerTask = Task.Factory.StartNew(OuterMethod);
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 任务外部任务=任务工厂.StartNew(OuterMethod);
- en: outerTask.Wait();
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: outerTask.Wait();
- en: WriteLine("Console app is stopping."
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("控制台应用程序正在停止。"
- en: );
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-690
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '```cs'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Outer method starting...
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 外部方法开始...
- en: Inner method starting...
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 内部方法开始...```
- en: Outer method finished.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 外部方法完成。
- en: Console app is stopping.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序正在停止。
- en: '```'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Note that, although we wait for the outer task to finish, its inner task does
    not have to finish as well. In fact, the outer task might finish, and the console
    app could end, before the inner task even starts!
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管我们等待外部任务完成，但它的内部任务不必也完成。实际上，外部任务可能会完成，控制台应用程序甚至在内部任务开始之前就结束了！
- en: To link these nested tasks as parent and child, we must use a special option.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这些嵌套任务链接为父任务和子任务，我们必须使用特殊选项。
- en: 'Modify the existing code that defines the inner task to add a `TaskCreationOption`
    value of `AttachedToParent` , as shown highlighted in the following code:'
  id: totrans-699
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改定义内部任务的现有代码，以添加`TaskCreationOption`值`AttachedToParent`，如下所示：
- en: '```cs'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Task innerTask = Task.Factory.StartNew(InnerMethod,
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 任务内部任务=任务工厂.StartNew(InnerMethod，
- en: '**TaskCreationOptions.AttachedToParent**'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '**TaskCreationOptions.AttachedToParent**'
- en: );
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code, view the result, and note that the inner task must finish before
    the outer task can, as shown in the following output:'
  id: totrans-705
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意内部任务必须在外部任务之前完成，如下所示：
- en: '```cs'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Outer method starting...
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 外部方法开始...
- en: Inner method starting...
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 内部方法开始...
- en: Outer method finished.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 外部方法完成。
- en: Inner method finished.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 内部方法完成。
- en: Console app is stopping.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序正在停止。
- en: '```'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `OuterMethod` can finish before the `InnerMethod` , as shown by its writing
    to the console, but its task must wait, as shown by the console not stopping until
    both the outer and inner tasks finish.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '`OuterMethod` 可以在 `InnerMethod` 之前完成，如其写入控制台所示，但它的任务必须等待，如控制台不会停止直到外部和内部任务都完成所示。'
- en: Wrapping tasks around other objects
  id: totrans-714
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将任务包装在其他对象周围
- en: 'Sometimes you might have a method that you want to be asynchronous, but the
    result to be returned is not itself a task. You can wrap the return value in a
    successfully completed task, return an exception, or indicate that the task was
    canceled by using one of the methods shown in the following table:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能有一个希望是异步的方法，但要返回的结果本身不是一个任务。您可以使用下表中所示的方法之一将返回值包装在成功完成的任务中，返回一个异常，或者指示任务被取消。
- en: '| Method | Description |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| `FromResult<TResult>(TResult)` | Creates a `Task<TResult>` object whose `Result`
    property is the non-task result and whose `Status` property is `RanToCompletion`
    . |'
  id: totrans-717
  prefs: []
  type: TYPE_TB
  zh: '| `FromResult<TResult>(TResult)` | 创建一个 `Task<TResult>` 对象，其 `Result` 属性是非任务结果，`Status`
    属性是 `RanToCompletion` 。'
- en: '| `FromException<TResult>(Exception)` | Creates a `Task<TResult>` that''s completed
    with a specified exception. |'
  id: totrans-718
  prefs: []
  type: TYPE_TB
  zh: '| `FromException<TResult>(Exception)` | 使用指定的异常创建一个已完成的 `Task<TResult>` 。'
- en: '| `FromCanceled<TResult>(CancellationToken)` | Creates a `Task<TResult>` that''s
    completed due to cancellation with a specified cancellation token. |'
  id: totrans-719
  prefs: []
  type: TYPE_TB
  zh: '| `FromCanceled<TResult>(CancellationToken)` | 使用指定的取消令牌创建一个由于取消而完成的 `Task<TResult>`
    。'
- en: 'These methods are useful when you need to:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要时，这些方法非常有用：
- en: Implement an interface that has async methods, but your implementation is synchronous.
    This is common for websites and services.
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个具有异步方法的接口，但您的实现是同步的。这在网站和服务中很常见。
- en: Mock asynchronous implementations during unit testing.
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单元测试期间模拟异步实现。
- en: In *Chapter 7* , *Packaging and Distributing .NET Types* , we created a class
    library with functions to check valid XML, passwords, and hex codes.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第7章*，*打包和分发.NET类型* 中，我们创建了一个包含用于检查有效XML、密码和十六进制代码的函数的类库。
- en: 'If we had wanted to make those methods conform to an interface that requires
    a `Task<T>` to be returned, we could use these helpful methods, as shown in the
    following code:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使这些方法符合要求返回 `Task<T>` 的接口，我们可以使用下面代码中所示的这些有用的方法：
- en: '```cs'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: using
- en: System.Text.RegularExpressions;
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: System.Text.RegularExpressions;
- en: namespace
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: namespace
- en: Packt.Shared
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: ;
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: static
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: static
- en: class
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: class
- en: StringExtensions
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: StringExtensions
- en: '{'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: static
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: static
- en: Task<
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: Task<
- en: bool
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: bool
- en: '>'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: IsValidXmlTagAsync
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: IsValidXmlTagAsync
- en: (
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: this
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: this
- en: string
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: input
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: input
- en: )
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: if
- en: (input == null
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: (input == null
- en: )
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: Task.FromException<bool
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: Task.FromException<bool
- en: '>('
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: new
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: new
- en: ArgumentNullException("Missing input parameter"
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: ArgumentNullException("缺少输入参数"
- en: ));
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: '}'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: if
- en: (input.Length == 0
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: (input.Length == 0
- en: )
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: Task.FromException<bool
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: Task.FromException<bool
- en: '>('
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: new
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: new
- en: ArgumentException("input parameter is empty."
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: ArgumentException("输入参数为空。"
- en: ));
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: '}'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: Task.FromResult(Regex.IsMatch(input,
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: Task.FromResult(Regex.IsMatch(input,
- en: '@"^<([a-z]+)([^<]+)*(?:>(.*)<\/\1>|\s+\/>)$"'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '@"^<([a-z]+)([^<]+)*(?:>(.*)<\/\1>|\s+\/>)$"'
- en: ));
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: '}'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // other methods
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: // 其他方法
- en: '}'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If the method you need to implement returns a `Task` (equivalent to `void`
    in a synchronous method) then you can return a predefined completed `Task` object,
    as shown in the following code:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要实现的方法返回一个 `Task`（相当于同步方法中的 `void`），那么您可以返回一个预定义的已完成的 `Task` 对象，如下面的代码所示：
- en: '```cs'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: Task
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: Task
- en: DeleteCustomerAsync
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: DeleteCustomerAsync
- en: ()
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // ...
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: return
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: Task.CompletedTask;
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: Task.CompletedTask;
- en: '}'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Synchronizing access to shared resources
  id: totrans-790
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步访问共享资源
- en: When you have multiple threads executing at the same time, there is a possibility
    that two or more of the threads may access the same variable or another resource
    at the same time, and as a result, may cause a problem. For this reason, you should
    carefully consider how to make your code **thread-safe** .
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个线程同时执行时，有可能两个或更多的线程同时访问同一个变量或其他资源，从而可能导致问题。因此，您应该仔细考虑如何使您的代码**线程安全**。
- en: The simplest mechanism for implementing thread safety is to use an object variable
    as a flag or traffic light to indicate when a shared resource has an exclusive
    lock applied.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 实现线程安全的最简单机制是使用一个对象变量作为标志或交通灯，指示共享资源何时应用了独占锁。
- en: In William Golding's *Lord of the Flies* , Piggy and Ralph spot a conch shell
    and use it to call a meeting. The boys impose a "rule of the conch" on themselves,
    deciding that no one can speak unless they're holding the conch.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 在威廉·戈尔丁的《蝇王》中，皮基和拉尔夫发现了一只海螺壳，并用它召开会议。男孩们对自己实施了“海螺规则”，决定除非他们拿着海螺，否则谁也不能说话。
- en: I like to name the object variable I use for implementing thread-safe code the
    "conch." When a thread has the conch, no other thread should access the shared
    resource(s) represented by that conch. Note that I say, *should* . Only code that
    respects the conch enables synchronized access. A conch is not a lock.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢给用于实现线程安全代码的对象变量命名为“conch”。当一个线程拥有了conch，其他线程就不应该访问由该conch表示的共享资源。请注意，我说的是*应该*。只有尊重conch的代码才能实现同步访问。conch不是锁。
- en: 'We will explore a couple of types that can be used to synchronize access to
    shared resources:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨一些可以用来同步访问共享资源的类型：
- en: '`Monitor` : An object that can be used by multiple threads to check if they
    should access a shared resource within the same process.'
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Monitor`：一个可以被多个线程使用的对象，用于检查它们是否应该在同一个进程中访问共享资源。'
- en: '`Interlocked` : An object for manipulating simple numeric types at the CPU
    level.'
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Interlocked`：一个用于在CPU级别操作简单数值类型的对象。'
- en: Accessing a resource from multiple threads
  id: totrans-798
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从多个线程访问资源
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `SynchronizingResourceAccess` .
  id: totrans-799
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器向 `Chapter12` 解决方案/工作区中添加一个名为 `SynchronizingResourceAccess` 的新控制台应用程序。
- en: In Visual Studio Code, select `SynchronizingResourceAccess` as the active OmniSharp
    project.
  id: totrans-800
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，将`SynchronizingResourceAccess`选择为活动的OmniSharp项目。
- en: 'In `Program.cs` , delete the existing statements and then add statements to
    do the following:'
  id: totrans-801
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有的语句，然后添加语句以执行以下操作：
- en: Import the namespace for diagnostic types like `Stopwatch` .
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入诊断类型的命名空间，如`Stopwatch`。
- en: Statically import the `Console` type.
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态地导入`Console`类型。
- en: 'At the bottom of `Program.cs` , create a static class with two fields:'
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的底部，创建一个带有两个字段的静态类：
- en: A field to generate random wait times.
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字段来生成随机等待时间。
- en: A `string` field to store a message (this is a shared resource).
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`string`字段来存储消息（这是一个共享资源）。
- en: 'Above the class, create two static methods that add a letter, A or B, to the
    shared `string` five times in a loop, and wait for a random interval of up to
    2 seconds for each iteration:'
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类的上方，创建两个静态方法，在循环中向共享的`string`添加五次字母A或B，并等待每次迭代的随机间隔最多2秒：
- en: '```cs'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: static
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: void
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: MethodA
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: MethodA
- en: ()
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 为
- en: (int
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: i = 0
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: ; i < 5
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: ; i < 5
- en: ; i++)
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: ; i ++)
- en: '{'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Thread.Sleep(SharedObjects.Random.Next(2000
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 线程休眠(SharedObjects.Random.Next(2000
- en: ));
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: SharedObjects.Message += "A"
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: SharedObjects.Message += "A"
- en: ;
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: Write("."
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 写("."
- en: );
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: static
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: void
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: MethodB
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: MethodB
- en: ()
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 为
- en: (int
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: i = 0
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: ; i < 5
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: ; i < 5
- en: ; i++)
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: ; i ++)
- en: '{'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Thread.Sleep(SharedObjects.Random.Next(2000
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 线程休眠(SharedObjects.Random.Next(2000
- en: ));
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: SharedObjects.Message += "B"
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: SharedObjects.Message += "B"
- en: ;
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: Write("."
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: Write("."
- en: );
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: static
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: class
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: SharedObjects
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: SharedObjects
- en: '{'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: static
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: Random Random = new
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: Random Random = new
- en: ();
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: public
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: static
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: string
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: '? Message; // a shared resource'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: ？消息； // 一个共享资源
- en: '}'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'After the namespace imports, write statements to execute both methods on separate
    threads using a pair of tasks and wait for them to complete before outputting
    the elapsed milliseconds, as shown in the following code:'
  id: totrans-861
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命名空间导入之后，编写语句以使用一对任务在单独的线程上执行两种方法，并在输出经过的毫秒数之前等待它们完成，如下面的代码所示：
- en: '```cs'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: WriteLine("Please wait for the tasks to complete."
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("请等待任务完成。"
- en: );
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Stopwatch watch = Stopwatch.StartNew();
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: Stopwatch watch = Stopwatch.StartNew();
- en: Task a = Task.Factory.StartNew(MethodA);
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 任务a = Task.Factory.StartNew(MethodA);
- en: Task b = Task.Factory.StartNew(MethodB);
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 任务b = Task.Factory.StartNew(MethodB);
- en: Task.WaitAll(new
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: Task.WaitAll(new
- en: Task[] { a, b });
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 任务[] { a, b });
- en: WriteLine();
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine();
- en: 'WriteLine($"Results:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"结果：
- en: '{SharedObjects.Message}'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '{SharedObjects.Message}'
- en: ."
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: ."
- en: );
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{watch.ElapsedMilliseconds:N0}'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '{watch.ElapsedMilliseconds:N0}'
- en: elapsed milliseconds."
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 经过的毫秒数。"
- en: );
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-880
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Please wait for the tasks to complete.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 请等待任务完成。
- en: '..........'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '..........'
- en: 'Results: BABABAABBA.'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 结果：BABABAABBA。
- en: 5,753 elapsed milliseconds.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 经过了5,753毫秒。
- en: '```'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This shows that both threads were modifying the message concurrently. In an
    actual application, this could be a problem. But we can prevent concurrent access
    by applying a mutually exclusive lock to a conch object and code to the two methods
    to voluntarily check the conch before modifying the shared resource, which we
    will do in the following section.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明两个线程同时修改了消息。在实际应用中，这可能是一个问题。但是我们可以通过对海螺对象应用互斥锁并在两种方法中自愿检查海螺来防止并发访问，我们将在下一节中进行。
- en: Applying a mutually exclusive lock to a conch
  id: totrans-888
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对海螺应用互斥锁
- en: Now, let's use a conch to ensure that only one thread accesses the shared resource
    at a time.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用海螺确保只有一个线程一次访问共享资源。
- en: 'In `SharedObjects` , declare and instantiate an `object` variable to act as
    a conch, as shown in the following code:'
  id: totrans-890
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedObjects`中，声明并实例化一个`object`变量，作为一个海螺，如下面的代码所示：
- en: '```cs'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: static
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: object
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: object
- en: Conch = new
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: Conch = new
- en: ();
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: '```'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In both `MethodA` and `MethodB` , add a `lock` statement for the conch around
    the `for` statements, as shown highlighted in the following code:'
  id: totrans-898
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MethodA`和`MethodB`中，为海螺周围的`for`语句添加一个`lock`语句，如下面的代码中所突出显示的那样：
- en: '```cs'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '**lock**'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '**锁**'
- en: '**(SharedObjects.Conch)**'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '**(SharedObjects.Conch)**'
- en: '**{**'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: for
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 为
- en: (int
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: i = 0
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: ; i < 5
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: ; i < 5
- en: ; i++)
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: ; i ++)
- en: '{'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Thread.Sleep(SharedObjects.Random.Next(2000
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 线程休眠(SharedObjects.Random.Next(2000
- en: ));
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: SharedObjects.Message += "A"
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: SharedObjects.Message += "A"
- en: ;
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: Write("."
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: Write("."
- en: );
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**}**'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '```'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : Note that since checking the conch is voluntary, if you
    only use the `lock` statement in one of the two methods, the shared resource will
    continue to be accessed by both methods. Make sure that all methods that access
    a shared resource respect the conch.'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：请注意，由于检查海螺是自愿的，如果您只在两种方法中的一个中使用`lock`语句，则共享资源将继续被两种方法访问。确保所有访问共享资源的方法都尊重海螺。'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-919
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Please wait for the tasks to complete.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 请等待任务完成。
- en: '..........'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '..........'
- en: 'Results: BBBBBAAAAA.'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 结果：BBBBBAAAAA。
- en: 10,345 elapsed milliseconds.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 经过了10,345毫秒。
- en: '```'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Although the time elapsed was longer, only one method at a time could access
    the shared resource. Either `MethodA` or `MethodB` can start first. Once a method
    has finished its work on the shared resource, then the conch gets released, and
    the other method has the chance to do its work.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管经过的时间更长，但一次只能有一个方法访问共享资源。`MethodA`或`MethodB`可以先开始。一旦一个方法完成了对共享资源的工作，那么海螺就被释放，另一个方法就有机会做它的工作。
- en: Understanding the lock statement
  id: totrans-927
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解锁定语句
- en: 'You might wonder what the `lock` statement does when it "locks" an object variable
    (hint: it does not lock the object!), as shown in the following code:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 当“锁”语句“锁定”对象变量时，您可能会想知道它的作用（提示：它不会锁定对象！），如下面的代码所示：
- en: '```cs'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: lock
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 锁
- en: (SharedObjects.Conch)
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: (SharedObjects.Conch)
- en: '{'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // work with shared resource
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用共享资源
- en: '}'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The C# compiler changes the `lock` statement into a `try` -`finally` statement
    that uses the `Monitor` class to *enter* and *exit* the conch object (I like to
    think of it as *take* and *release* the conch object), as shown in the following
    code:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: C#编译器将`lock`语句更改为使用`Monitor`类*进入*和*退出*海螺对象（我喜欢把它看作*拿*和*释放*海螺对象）的`try`-`finally`语句，如下面的代码所示：
- en: '```cs'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: try
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: try
- en: '{'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Monitor.Enter(SharedObjects.Conch);
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: Monitor.Enter(SharedObjects.Conch);
- en: // work with shared resource
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用共享资源
- en: '}'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: finally
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: finally
- en: '{'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Monitor.Exit(SharedObjects.Conch);
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: Monitor.Exit(SharedObjects.Conch);
- en: '}'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: When a thread calls `Monitor.Enter` on any object, aka reference type, it checks
    to see if some other thread has already taken the conch. If it has, the thread
    waits. If it has not, the thread takes the conch and gets on with its work on
    the shared resource. Once the thread has finished its work, it calls `Monitor.Exit`
    , releasing the conch. If another thread was waiting, it can now take the conch
    and do its work. This requires all threads to respect the conch by calling `Monitor.Enter`
    and `Monitor.Exit` appropriately.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程在任何对象上调用`Monitor.Enter`时，也就是引用类型时，它会检查是否有其他线程已经拿到了海螺。如果有，线程会等待。如果没有，线程会拿到海螺并开始在共享资源上进行工作。一旦线程完成了它的工作，它会调用`Monitor.Exit`，释放海螺。如果另一个线程在等待，它现在可以拿到海螺并进行工作。这要求所有线程通过适当调用`Monitor.Enter`和`Monitor.Exit`来尊重海螺。
- en: Avoiding deadlocks
  id: totrans-949
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免死锁
- en: Knowing how the `lock` statement is translated by the compiler to method calls
    on the `Monitor` class is also important because using the `lock` statement can
    cause a deadlock.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 了解`lock`语句如何被编译器转换为`Monitor`类上的方法调用也很重要，因为使用`lock`语句可能会导致死锁。
- en: 'Deadlocks can occur when there are two or more shared resources (each with
    a conch to monitor which thread is currently doing work on each shared resource),
    and the following sequence of events happens:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 当有两个或更多个共享资源（每个资源都有一个监视哪个线程当前正在对每个共享资源进行工作的海螺）时，死锁可能会发生，并且会发生以下事件序列：
- en: Thread X "locks" conch A and starts working on shared resource A.
  id: totrans-952
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thread X "锁定"海螺A并开始在共享资源A上工作。
- en: Thread Y "locks" conch B and starts working on shared resource B.
  id: totrans-953
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程Y“锁定”海螺B并开始在共享资源B上工作。
- en: While still working on resource A, thread X needs to also work with resource
    B, and so it attempts to "lock" conch B but is blocked because thread Y already
    has conch B.
  id: totrans-954
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在仍在处理资源A时，线程X还需要处理资源B，因此它尝试“锁定”海螺B，但由于线程Y已经拿到了海螺B而被阻塞。
- en: While still working on resource B, thread Y needs to also work with resource
    A, and so it attempts to "lock" conch A but is blocked because thread X already
    has conch A.
  id: totrans-955
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在仍在处理资源B时，线程Y还需要处理资源A，因此它尝试“锁定”海螺A，但由于线程X已经拿到了海螺A而被阻塞。
- en: One way to prevent deadlocks is to specify a timeout when attempting to get
    a lock. To do this, you must manually use the `Monitor` class instead of using
    the `lock` statement.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 防止死锁的一种方法是在尝试获取锁时指定超时。为此，您必须手动使用`Monitor`类，而不是使用`lock`语句。
- en: 'Modify your code to replace the `lock` statements with code that tries to enter
    the conch with a timeout and outputs an error and then exits the monitor, allowing
    other threads to enter the monitor, as shown highlighted in the following code:'
  id: totrans-957
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改您的代码，将`lock`语句替换为尝试使用超时进入海螺的代码，并输出错误，然后退出监视器，允许其他线程进入监视器，如下面代码中所示：
- en: '```cs'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '**try**'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '**try**'
- en: '**{**'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**if**'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: '**if**'
- en: '**(Monitor.TryEnter(SharedObjects.Conch, TimeSpan.FromSeconds(**'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '**(Monitor.TryEnter(SharedObjects.Conch, TimeSpan.FromSeconds(**'
- en: '**15**'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '**15**'
- en: '**)))**'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '**)))**'
- en: '{'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: for
- en: (int
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: i = 0
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: ; i < 5
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: ; i < 5
- en: ; i++)
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: ; i++)
- en: '{'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Thread.Sleep(SharedObjects.Random.Next(2000
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: Thread.Sleep(SharedObjects.Random.Next(2000
- en: ));
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: SharedObjects.Message += "A"
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: SharedObjects.Message += "A"
- en: ;
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: Write("."
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: Write("."
- en: );
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**else**'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '**else**'
- en: '**{**'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**WriteLine(**'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: '**WriteLine(**'
- en: '**"Method A timed out when entering a monitor on conch."**'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: '**"在海螺上进入监视器时，方法A超时。"**'
- en: '**);**'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: '**);**'
- en: '**}**'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '**}**'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '**finally**'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '**finally**'
- en: '**{**'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**Monitor.Exit(SharedObjects.Conch);**'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '**Monitor.Exit(SharedObjects.Conch);**'
- en: '**}**'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '```'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Run the code and view the result, which should return the same results as before
    (although either A or B could grab the conch first) but is better code because
    it will prevent potential deadlocks.
  id: totrans-992
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，应该返回与之前相同的结果（尽管A或B可能首先抓住海螺），但这是更好的代码，因为它将防止潜在的死锁。
- en: '**Good Practice** : Only use the `lock` keyword if you can write your code
    such that it avoids potential deadlocks. If you cannot avoid potential deadlocks,
    then always use the `Monitor.TryEnter` method instead of `lock` , in combination
    with a `try` -`finally` statement, so that you can supply a timeout and one of
    the threads will back out of a deadlock if it occurs. You can read more about
    good threading practices at the following link: [https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices](https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices)'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的实践：只有在您可以编写代码以避免潜在死锁的情况下才使用`lock`关键字。如果无法避免潜在死锁，那么始终使用`Monitor.TryEnter`方法而不是`lock`，结合`try`-`finally`语句，以便您可以提供超时，并且如果发生死锁，则其中一个线程将退出。您可以在以下链接中阅读有关良好线程实践的更多信息：[https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices](https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices)
- en: Synchronizing events
  id: totrans-994
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步事件
- en: In *Chapter 6* , *Implementing Interfaces and Inheriting Classes* , you learned
    how to raise and handle events. But .NET events are not thread-safe, so you should
    avoid using them in multithreaded scenarios and follow the standard event raising
    code I showed you earlier.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第6章*，*实现接口和继承类*中，您学习了如何引发和处理事件。但是.NET事件不是线程安全的，因此您应该避免在多线程场景中使用它们，并遵循我之前向您展示的标准事件引发代码。
- en: 'After learning that .NET events are not thread-safe, some developers attempt
    to use exclusive locks when adding and removing event handlers or when raising
    an event, as shown in the following code:'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解.NET事件不是线程安全之后，一些开发人员尝试在添加和移除事件处理程序或引发事件时使用独占锁，如下面的代码所示：
- en: '```cs'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // event delegate field
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: // 事件委托字段
- en: public
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: event
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 事件
- en: EventHandler Shout;
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: EventHandler Shout;
- en: // conch
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: // 海螺
- en: private
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: private
- en: object
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: object
- en: eventLock = new
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: eventLock = new
- en: ();
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: // method
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: // 方法
- en: public
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: void
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Poke
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: Poke
- en: ()
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: lock
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: lock
- en: (eventLock) // bad idea
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: (eventLock) // 不好的主意
- en: '{'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // if something is listening...
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: // 如果有东西在监听...
- en: if
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: if
- en: (Shout != null
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: (Shout != null
- en: )
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // ...then call the delegate to raise the event
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: // ...然后调用委托来触发事件
- en: Shout(this
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: Shout(this
- en: ', EventArgs.Empty);'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: ', EventArgs.Empty);'
- en: '}'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : You can read more about events and thread-safety at the
    following link: [https://docs.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful](https://docs.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful)'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好的实践**：您可以在以下链接中了解有关事件和线程安全性的更多信息：[https://docs.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful](https://docs.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful)'
- en: 'But it is complicated, as explained by Stephen Cleary in the following blog
    post: [https://blog.stephencleary.com/2009/06/threadsafe-events.html](https://blog.stephencleary.com/2009/06/threadsafe-events.html)'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如Stephen Cleary在以下博客文章中所解释的那样，情况很复杂：[https://blog.stephencleary.com/2009/06/threadsafe-events.html](https://blog.stephencleary.com/2009/06/threadsafe-events.html)
- en: Making CPU operations atomic
  id: totrans-1030
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使CPU操作变为原子
- en: Atomic is from the Greek word **atomos** , which means *undividable* . It is
    important to understand which operations are atomic in multithreading because
    if they are not atomic, then they could be interrupted by another thread partway
    through their operation. Is the C# increment operator atomic, as shown in the
    following code?
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 原子来自希腊词 **atomos** ，意思是 *不可分割的*。了解多线程中哪些操作是原子的很重要，因为如果它们不是原子的，那么它们可能会在操作过程中被另一个线程中断。C#的增量运算符是原子的吗，如下面的代码所示？
- en: '```cs'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: x = 3
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: x = 3
- en: ;
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: x++; // is this an atomic CPU operation?
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: x++; // 这是一个原子CPU操作吗？
- en: '```'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'It is not atomic! Incrementing an integer requires the following three CPU
    operations:'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是原子的！增加整数需要以下三个CPU操作：
- en: Load a value from an instance variable into a register.
  id: totrans-1039
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实例变量的值加载到寄存器中。
- en: Increment the value.
  id: totrans-1040
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加值。
- en: Store the value in the instance variable.
  id: totrans-1041
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值存储在实例变量中。
- en: A thread could be interrupted after executing the first two steps. A second
    thread could then execute all three steps. When the first thread resumes execution,
    it will overwrite the value in the variable, and the effect of the increment or
    decrement performed by the second thread will be lost!
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 一个线程在执行前两个步骤后可能会被中断。然后第二个线程可能执行所有三个步骤。当第一个线程恢复执行时，它将覆盖变量中的值，并且第二个线程执行的增量或减量的效果将丢失！
- en: 'There is a type named `Interlocked` that can perform atomic actions on value
    types, such as integers and floats. Let''s see it in action:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`Interlocked`的类型，可以对值类型（如整数和浮点数）执行原子操作。让我们看看它的运行情况：
- en: 'Declare another field in the `SharedObjects` class that will count how many
    operations have occurred, as shown in the following code:'
  id: totrans-1044
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedObjects`类中声明另一个字段，用于计算已发生的操作次数，如下面的代码所示：
- en: '```cs'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: static
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: static
- en: int
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: Counter; // another shared resource
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: Counter; // 另一个共享资源
- en: '```'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In both methods A and B, inside the `for` statement and after modifying the
    `string` value, add a statement to safely increment the counter, as shown in the
    following code:'
  id: totrans-1051
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法A和B中，在`for`语句内和修改`string`值后，添加一个语句来安全地增加计数器，如下面的代码所示：
- en: '```cs'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Interlocked.Increment(ref
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: Interlocked.Increment(ref
- en: SharedObjects.Counter);
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: SharedObjects.Counter);
- en: '```'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'After outputting the elapsed time, write the current value of the counter to
    the console, as shown in the following code:'
  id: totrans-1056
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输出经过的时间后，将计数器的当前值写入控制台，如下面的代码所示：
- en: '```cs'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: WriteLine($"
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{SharedObjects.Counter}'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: '{SharedObjects.Counter}'
- en: string modifications."
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串修改。"
- en: );
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown highlighted in the following output:'
  id: totrans-1063
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：```
- en: '```cs'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Please wait for the tasks to complete.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 请等待任务完成。
- en: '..........'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: '..........'
- en: 'Results: BBBBBAAAAA.'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 结果：BBBBBAAAAA。
- en: 13,531 elapsed milliseconds.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 13,531毫秒经过。
- en: '**10 string modifications.**'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: '**10个字符串修改。**'
- en: '```'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Observant readers will realize that the existing conch object protects all shared
    resources accessed within a block of code locked by the conch, and therefore it
    is actually unnecessary to use `Interlocked` in this specific example. But if
    we had not already been protecting another shared resource like `Message` then
    using `Interlocked` would be necessary.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 细心的读者会意识到现有的conch对象保护了由conch锁定的代码块内访问的所有共享资源，因此在这个特定的例子中实际上不需要在这里使用`Interlocked`。但是，如果我们没有已经保护像`Message`这样的另一个共享资源，那么使用`Interlocked`将是必要的。
- en: Applying other types of synchronization
  id: totrans-1072
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用其他类型的同步
- en: '`Monitor` and `Interlocked` are mutually exclusive locks that are simple and
    effective, but sometimes, you need more advanced options to synchronize access
    to shared resources, as shown in the following table:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: '`Monitor` 和 `Interlocked` 是相互排斥的锁，简单而有效，但有时，您需要更高级的选项来同步对共享资源的访问，如下表所示：'
- en: '| Type | Description |'
  id: totrans-1074
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| `ReaderWriterLock` and `ReaderWriterLockSlim` | These allow multiple threads
    to be in **read mode** , one thread to be in **write mode** with exclusive ownership
    of the write lock, and one thread that has read access to be in **upgradeable
    read mode** , from which the thread can upgrade to write mode without having to
    relinquish its read access to the resource. |'
  id: totrans-1075
  prefs: []
  type: TYPE_TB
  zh: '| `ReaderWriterLock` 和 `ReaderWriterLockSlim` | 这允许多个线程处于**读模式**，一个线程处于具有写锁的**写模式**，并且一个具有读访问权限的线程处于**可升级读模式**，从中线程可以升级到写模式，而无需放弃对资源的读访问权限。
    |'
- en: '| `Mutex` | Like `Monitor` , this provides exclusive access to a shared resource,
    except it is used for inter-process synchronization. |'
  id: totrans-1076
  prefs: []
  type: TYPE_TB
  zh: '| `Mutex` | 像 `Monitor` 一样，它提供对共享资源的独占访问，但它用于进程间同步。 |'
- en: '| `Semaphore` and `SemaphoreSlim` | These limit the number of threads that
    can access a resource or pool of resources concurrently by defining slots. This
    is known as resource throttling rather than resource locking. |'
  id: totrans-1077
  prefs: []
  type: TYPE_TB
  zh: '| `Semaphore` 和 `SemaphoreSlim` | 这些通过定义插槽来限制可以同时访问资源或资源池的线程数量。这被称为资源限流，而不是资源锁定。
    |'
- en: '| `AutoResetEvent` and `ManualResetEvent` | Event wait handles allow threads
    to synchronize activities by signaling each other and by waiting for each other''s
    signals. |'
  id: totrans-1078
  prefs: []
  type: TYPE_TB
  zh: '| `AutoResetEvent`和`ManualResetEvent` | 事件等待句柄允许线程通过向彼此发出信号并等待彼此的信号来同步活动。|'
- en: Understanding async and await
  id: totrans-1079
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解异步和等待
- en: 'C# 5 introduced two C# keywords when working with the `Task` type. They are
    especially useful for the following:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: C# 5引入了两个C#关键字，用于处理`Task`类型。它们在以下情况下特别有用：
- en: Implementing multitasking for a **graphical user interface** (**GUI** ).
  id: totrans-1081
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为**图形用户界面**（**GUI**）实现多任务处理。
- en: Improving the scalability of web applications and web services.
  id: totrans-1082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高Web应用程序和Web服务的可扩展性。
- en: In *Chapter 15* , *Building Websites Using the Model-View-Controller Pattern*
    , we will see how the `async` and `await` keywords can improve scalability for
    websites.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第15章*，*使用模型-视图-控制器模式构建网站*中，我们将看到`async`和`await`关键字如何提高网站的可扩展性。
- en: In *Chapter 19* , *Building Mobile and Desktop Apps Using .NET MAUI* , we will
    see how the `async` and `await` keywords can implement multitasking for a GUI.
    You can find it at [https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf](https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf)
    .
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第19章*，*使用.NET MAUI构建移动和桌面应用程序*中，我们将看到`async`和`await`关键字如何为GUI实现多任务处理。您可以在[https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf](https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf)找到它。
- en: But for now, let's learn the theory of why these two C# keywords were introduced,
    and then later you will see them used in practice.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，让我们学习为什么引入了这两个C#关键字的理论，然后稍后您将看到它们在实践中的使用。
- en: Improving responsiveness for console apps
  id: totrans-1086
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高控制台应用程序的响应性
- en: 'One of the limitations with console applications is that you can only use the
    `await` keyword inside methods that are marked as `async` but C# 7 and earlier
    do not allow the `Main` method to be marked as async! Luckily, a new feature introduced
    in C# 7.1 was support for `async` in `Main` :'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序的局限之一是您只能在标记为`async`的方法中使用`await`关键字，但是C# 7及更早版本不允许`Main`方法标记为async！幸运的是，C#
    7.1中引入的一个新功能是支持`Main`中的`async`：
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `AsyncConsole` .
  id: totrans-1088
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器将新的控制台应用程序添加到`Chapter12`解决方案/工作区中，命名为`AsyncConsole`。
- en: In Visual Studio Code, select `AsyncConsole` as the active OmniSharp project.
  id: totrans-1089
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`AsyncConsole`作为活动的OmniSharp项目。
- en: 'In `Program.cs` , delete the existing statements and statically import `Console`
    , as shown in the following code:'
  id: totrans-1090
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有的语句并静态导入`Console`，如下面的代码所示：
- en: '```cs'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: static
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: static
- en: System.Console;
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: System.Console;
- en: '```'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Add statements to create an `HttpClient` instance, make a request for Apple''s
    home page, and output how many bytes it has, as shown in the following code:'
  id: totrans-1096
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以创建`HttpClient`实例，请求苹果的主页，并输出它有多少字节，如下面的代码所示：
- en: '```cs'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: HttpClient client = new
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: HttpClient client = new
- en: ();
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: （）;
- en: HttpResponseMessage response =
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: HttpResponseMessage response =
- en: await
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 等待
- en: client.GetAsync("http://www.apple.com/"
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: client.GetAsync("http://www.apple.com/"
- en: );
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: WriteLine("Apple's home page has {0:N0} bytes."
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("苹果的主页有{0:N0}字节。"
- en: ','
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: response.Content.Headers.ContentLength);
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: response.Content.Headers.ContentLength);
- en: '```'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Build the project and note that it builds successfully. In .NET 5 and earlier,
    you would have seen an error message, as shown in the following output:'
  id: totrans-1108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并注意它是否成功构建。在.NET 5及更早版本中，您会看到错误消息，如下面的输出所示：
- en: '```cs'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Program.cs(14,9): error CS4033: The ''await'' operator can only be used within
    an async method. Consider marking this method with the ''async'' modifier and
    changing its return type to ''Task''. [/Users/markjprice/Code/ Chapter12/AsyncConsole/AsyncConsole.csproj]'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 'Program.cs(14,9): error CS4033: The ''await'' operator can only be used within
    an async method. Consider marking this method with the ''async'' modifier and
    changing its return type to ''Task''. [/Users/markjprice/Code/ Chapter12/AsyncConsole/AsyncConsole.csproj]'
- en: '```'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You would have had to add the `async` keyword to the `Main` method and change
    its return type to `Task` . With .NET 6 and later, the console app project template
    uses the top-level program feature to automatically define the `Program` class
    with an asynchronous `Main` method for you.
  id: totrans-1112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您必须在`Main`方法中添加`async`关键字，并将其返回类型更改为`Task`。从.NET 6开始，控制台应用程序项目模板使用顶级程序功能为您自动定义具有异步`Main`方法的`Program`类。
- en: 'Run the code and view the result, which is likely to have a different number
    of bytes since Apple changes its home page frequently, as shown in the following
    output:'
  id: totrans-1113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，由于苹果经常更改其主页，所以可能会有不同数量的字节，如下面的输出所示：
- en: '```cs'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Apple's home page has 40,252 bytes.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果的主页有40,252字节。
- en: '```'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Improving responsiveness for GUI apps
  id: totrans-1117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高GUI应用程序的响应性
- en: So far in this book, we have only built console applications. Life for a programmer
    gets more complicated when building web applications, web services, and apps with
    GUIs such as Windows desktop and mobile apps.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们只构建了控制台应用程序。当构建Web应用程序、Web服务和Windows桌面和移动应用程序等具有GUI的应用程序时，程序员的生活变得更加复杂。
- en: 'One reason for this is that for a GUI app, there is a special thread: the **user
    interface** (**UI** ) thread.'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个原因是对于GUI应用程序，有一个特殊的线程：**用户界面**（**UI**）线程。
- en: 'There are two rules for working in GUIs:'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 在GUI中有两条规则：
- en: Do not perform long-running tasks on the UI thread.
  id: totrans-1121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在UI线程上执行长时间运行的任务。
- en: Do not access UI elements on any thread except the UI thread.
  id: totrans-1122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在UI线程以外的任何线程上访问UI元素。
- en: To handle these rules, programmers used to have to write complex code to ensure
    that long- running tasks were executed by a non-UI thread, but once complete,
    the results of the task were safely passed to the UI thread to present to the
    user. It could quickly get messy!
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这些规则，程序员过去必须编写复杂的代码，以确保长时间运行的任务由非UI线程执行，但一旦完成，任务的结果就会安全地传递给UI线程呈现给用户。这可能会很快变得混乱！
- en: Luckily, with C# 5 and later, you have the use of `async` and `await` . They
    allow you to continue to write your code as if it is synchronous, which keeps
    your code clean and easy to understand, but underneath, the C# compiler creates
    a complex state machine and keeps track of running threads. It's kind of magical!
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，使用C# 5及更高版本，您可以使用`async`和`await`。它们允许您继续编写代码，就好像它是同步的，这使得您的代码清晰易懂，但在底层，C#编译器创建了一个复杂的状态机，并跟踪运行的线程。这有点神奇！
- en: Let's see an example. We will build a Windows desktop app using WPF that gets
    employees from the Northwind database in an SQL Server database using low-level
    types like `SqlConnection` , `SqlCommand` , and `SqlDataReader` . You will only
    be able to complete this task if you have Windows and the Northwind database stored
    in SQL Server. This is the only section in this book that is not cross-platform
    and modern (WPF is 16 years old!).
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。我们将构建一个使用WPF的Windows桌面应用程序，使用低级类型如`SqlConnection`、`SqlCommand`和`SqlDataReader`从SQL
    Server数据库中的Northwind数据库获取员工。只有在您拥有Windows和Northwind数据库存储在SQL Server中时，您才能完成此任务。这是本书中唯一一个不跨平台和现代的部分（WPF已有16年历史！）。
- en: At this point, we are focusing on making a GUI app responsive. You will learn
    about XAML and building cross-platform GUI apps in *Chapter 19* , *Building Mobile
    and Desktop Apps Using .NET MAUI* (available at [https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf](https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf)
    ). Since this book does not cover WPF elsewhere, I thought this task would be
    a good opportunity to at least see an example app built using WPF even if we do
    not look at it in detail.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们专注于使GUI应用程序响应。您将在*第19章*中了解有关XAML和构建跨平台GUI应用程序的知识，*使用.NET MAUI构建移动和桌面应用程序*（可在[https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf](https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf)找到）。由于本书其他地方没有涉及WPF，我认为这个任务是一个很好的机会，至少可以看到一个使用WPF构建的示例应用程序，即使我们不详细讨论它。
- en: Let's go!
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们走吧！
- en: 'If you are using Visual Studio 2022 for Windows, add a new **WPF Application
    [C#]** project named `WpfResponsive` to the `Chapter12` solution. If you are using
    Visual Studio Code, use the following command: `dotnet new wpf` .'
  id: totrans-1128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您正在使用Windows的Visual Studio 2022，请向`Chapter12`解决方案添加一个名为`WpfResponsive`的新**WPF
    Application [C#]**项目。如果您正在使用Visual Studio Code，请使用以下命令：`dotnet new wpf`。
- en: In the project file, note the output type is a Windows EXE, the target framework
    is .NET 6 for Windows (it will not run on other platforms like macOS and Linux),
    and the project uses WPF.
  id: totrans-1129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，请注意输出类型是Windows EXE，目标框架是.NET 6 for Windows（它不会在其他平台上运行，如macOS和Linux），并且项目使用WPF。
- en: 'Add a package reference for `Microsoft.Data.SqlClient` to the project, as shown
    highlighted in the following markup:'
  id: totrans-1130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为项目添加`Microsoft.Data.SqlClient`的包引用，如下面的标记所示：
- en: '```cs'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <Project Sdk="Microsoft.NET.Sdk"
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: <Project Sdk="Microsoft.NET.Sdk"
- en: '>'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <PropertyGroup>
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: <PropertyGroup>
- en: <OutputType>WinExe</OutputType>
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: <OutputType>WinExe</OutputType>
- en: <TargetFramework>net6.0
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: <TargetFramework>net6.0
- en: -windows</TargetFramework>
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: -windows</TargetFramework>
- en: <Nullable>enable</Nullable>
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: <Nullable>enable</Nullable>
- en: <UseWPF>true
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: <UseWPF>true
- en: </UseWPF>
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: </UseWPF>
- en: </PropertyGroup>
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: </PropertyGroup>
- en: '**<ItemGroup>**'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: '**<ItemGroup>**'
- en: '**<PackageReference Include=**'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: '**<PackageReference Include=**'
- en: '**"Microsoft.Data.SqlClient"**'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: '**"Microsoft.Data.SqlClient"**'
- en: '**Version=**'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: '**Version=**'
- en: '**"3.0.0"**'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: '**"3.0.0"**'
- en: '**/>**'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: '**/>**'
- en: '**</ItemGroup>**'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '**</ItemGroup>**'
- en: </Project>
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: </Project>
- en: '```'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Build the project to restore packages.
  id: totrans-1151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目以恢复包。
- en: 'In `MainWindow.xaml` , in the `<Grid>` element, add elements to define two
    buttons, a text box and a list box, laid out vertically in a stack panel, as shown
    highlighted in the following markup:'
  id: totrans-1152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow.xaml`中，在`<Grid>`元素中，添加元素来定义两个按钮、一个文本框和一个列表框，以垂直方式布置在一个堆栈面板中，如下面的标记所示：
- en: '```cs'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: <
- en: Grid
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: Grid
- en: '>'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '**<**'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: '**<**'
- en: '**StackPanel**'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: '**StackPanel**'
- en: '**>**'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '**>**'
- en: '**<**'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: '**<**'
- en: '**Button**'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: '**Button**'
- en: '**Name**'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '**Name**'
- en: '**=**'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: '**=**'
- en: '**"GetEmployeesSyncButton"**'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: '**"GetEmployeesSyncButton"**'
- en: '**Click**'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: '**Click**'
- en: '**=**'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: '**=**'
- en: '**"GetEmployeesSyncButton_Click"**'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: '**"GetEmployeesSyncButton_Click"**'
- en: '**>**'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: '**>**'
- en: '**Get Employees Synchronously**'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '**同步获取员工**'
- en: '**</**'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: '**</**'
- en: '**Button**'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: '**Button**'
- en: '**>**'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '**>**'
- en: '**<**'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: '**<**'
- en: '**Button**'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: '**Button**'
- en: '**Name**'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '**Name**'
- en: '**=**'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: '**=**'
- en: '**"GetEmployeesAsyncButton"**'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: '**"GetEmployeesAsyncButton"**'
- en: '**Click**'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: '**Click**'
- en: '**=**'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: '**=**'
- en: '**"GetEmployeesAsyncButton_Click"**'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: '**"GetEmployeesAsyncButton_Click"**'
- en: '**>**'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: '**>**'
- en: '**Get Employees Asynchronously**'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步获取员工**'
- en: '**</**'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: '**</**'
- en: '**Button**'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: '**Button**'
- en: '**>**'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: '**>**'
- en: '**<**'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '**<**'
- en: '**TextBox**'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: '**TextBox**'
- en: '**HorizontalAlignment**'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '**HorizontalAlignment**'
- en: '**=**'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: '**=**'
- en: '**"Stretch"**'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: '**"Stretch"**'
- en: '**Text**'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: '**Text**'
- en: '**=**'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: '**=**'
- en: '**"Type in here"**'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: '**"Type in here"**'
- en: '**/>**'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: '**/>**'
- en: '**<**'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '**<**'
- en: '**ListBox**'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: '**ListBox**'
- en: '**Name**'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: '**Name**'
- en: '**=**'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: '**=**'
- en: '**"EmployeesListBox"**'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: '**"EmployeesListBox"**'
- en: '**Height**'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: '**Height**'
- en: '**=**'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: '**=**'
- en: '**"400"**'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: '**"400"**'
- en: '**/>**'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: '**/>**'
- en: '**</**'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: '**</**'
- en: '**StackPanel**'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: '**StackPanel**'
- en: '**>**'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: '**>**'
- en: </
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: </
- en: Grid
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 网格
- en: '>'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '```'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Visual Studio 2022 for Windows has good support for building WPF apps and will
    provide IntelliSense as you edit code and XAML markup. Visual Studio Code does
    not.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022 for Windows对构建WPF应用程序有很好的支持，并且在编辑代码和XAML标记时会提供智能感知。Visual
    Studio Code则没有。
- en: 'In `MainWindow.xaml.cs` , in the `MainWindow` class, import the `System.Diagnostics`
    and `Microsoft.Data.SqlClient` namespaces, then create two `string` constants
    for the database connection string and SQL statement and create event handlers
    for clicking on the two buttons that use those `string` constants to open a connection
    to the Northwind database and populate the list box with the ids and names of
    all employees, as shown in the following code:'
  id: totrans-1212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow.xaml.cs`中，在`MainWindow`类中，导入`System.Diagnostics`和`Microsoft.Data.SqlClient`命名空间，然后创建两个`string`常量，用于数据库连接字符串和SQL语句，并创建点击这两个按钮的事件处理程序，这些事件处理程序使用这些`string`常量来打开到Northwind数据库的连接，并将列表框填充为所有员工的ID和姓名，如下面的代码所示：
- en: '```cs'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: private
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: private
- en: const
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: const
- en: string
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: connectionString =
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: connectionString =
- en: '"Data Source=.;"'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: '"Data Source=.;"'
- en: +
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: '"Initial Catalog=Northwind;"'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: '"Initial Catalog=Northwind;"'
- en: +
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: '"Integrated Security=true;"'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: '"Integrated Security=true;"'
- en: +
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: '"MultipleActiveResultSets=true;"'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: '"MultipleActiveResultSets=true;"'
- en: ;
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: private
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: private
- en: const
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: const
- en: string
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: sql =
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: sql =
- en: '"WAITFOR DELAY ''00:00:05'';"'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: '"WAITFOR DELAY ''00:00:05'';"'
- en: +
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: '"SELECT EmployeeId, FirstName, LastName FROM Employees"'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: '"SELECT EmployeeId, FirstName, LastName FROM Employees"'
- en: ;
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: private
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: private
- en: void
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: GetEmployeesSyncButton_Click
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: GetEmployeesSyncButton_Click
- en: (
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: object
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: object
- en: sender, RoutedEventArgs e
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: sender, RoutedEventArgs e
- en: )
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Stopwatch timer = Stopwatch.StartNew();
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: Stopwatch timer = Stopwatch.StartNew();
- en: using
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: using
- en: (SqlConnection connection = new
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: (SqlConnection connection = new
- en: (connectionString))
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: (connectionString))
- en: '{'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: connection.Open();
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: connection.Open();
- en: SqlCommand command = new
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: SqlCommand command = new
- en: (sql, connection);
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: (sql, connection);
- en: SqlDataReader reader = command.ExecuteReader();
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: SqlDataReader reader = command.ExecuteReader();
- en: while
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: while
- en: (reader.Read())
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: (reader.Read())
- en: '{'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: string
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: employee = string
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: employee = string
- en: '.Format("{0}: {1} {2}"'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: '.Format("{0}: {1} {2}"'
- en: ','
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: reader.GetInt32(0
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: reader.GetInt32(0
- en: ), reader.GetString(1
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: ), reader.GetString(1
- en: ), reader.GetString(2
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: ), reader.GetString(2
- en: ));
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: EmployeesListBox.Items.Add(employee);
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: EmployeesListBox.Items.Add(employee);
- en: '}'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: reader.Close();
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: reader.Close();
- en: connection.Close();
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: connection.Close();
- en: '}'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'EmployeesListBox.Items.Add($"Sync:'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: EmployeesListBox.Items.Add($"同步：
- en: '{timer.ElapsedMilliseconds:N0}'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: '{timer.ElapsedMilliseconds:N0}'
- en: ms"
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: ms"
- en: );
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: private
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: private
- en: async
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: async
- en: void
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: GetEmployeesAsyncButton_Click
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: GetEmployeesAsyncButton_Click
- en: (
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: object
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: object
- en: sender, RoutedEventArgs e
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: sender, RoutedEventArgs e
- en: )
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Stopwatch timer = Stopwatch.StartNew();
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: Stopwatch timer = Stopwatch.StartNew();
- en: using
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: using
- en: (SqlConnection connection = new
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: (SqlConnection connection = new
- en: (connectionString))
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: (connectionString))
- en: '{'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: await
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 等待
- en: connection.OpenAsync();
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: connection.OpenAsync();
- en: SqlCommand command = new
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: SqlCommand command = new
- en: (sql, connection);
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: (sql, connection);
- en: SqlDataReader reader = await
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: SqlDataReader reader = await
- en: command.ExecuteReaderAsync();
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: command.ExecuteReaderAsync();
- en: while
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: while
- en: (await
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: (await
- en: reader.ReadAsync())
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: reader.ReadAsync())
- en: '{'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: string
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: employee = string
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: employee = string
- en: '.Format("{0}: {1} {2}"'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: '.Format("{0}: {1} {2}"'
- en: ','
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: await
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 等待
- en: reader.GetFieldValueAsync<int
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: reader.GetFieldValueAsync<int
- en: '>(0'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: '>(0'
- en: ),
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: ),
- en: await
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 等待
- en: reader.GetFieldValueAsync<string
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: reader.GetFieldValueAsync<string
- en: '>(1'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: '>(1'
- en: ),
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: ),
- en: await
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 等待
- en: reader.GetFieldValueAsync<string
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: reader.GetFieldValueAsync<string
- en: '>(2'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: '>(2'
- en: ));
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: EmployeesListBox.Items.Add(employee);
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: EmployeesListBox.Items.Add(employee);
- en: '}'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: await
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 等待
- en: reader.CloseAsync();
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: reader.CloseAsync();
- en: await
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 等待
- en: connection.CloseAsync();
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: connection.CloseAsync();
- en: '}'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'EmployeesListBox.Items.Add($"Async:'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: EmployeesListBox.Items.Add($"异步：
- en: '{timer.ElapsedMilliseconds:N0}'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: '{timer.ElapsedMilliseconds:N0}'
- en: ms"
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: ms"
- en: );
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Note the following:'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: The SQL statement uses the SQL Server command `WAITFOR DELAY` to simulate processing
    that takes five seconds. It then selects three columns from the `Employees` table.
  id: totrans-1326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL语句使用SQL Server命令`WAITFOR DELAY`来模拟需要五秒钟的处理。然后从`Employees`表中选择三列。
- en: The `GetEmployeesSyncButton_Click` event handler uses synchronous methods to
    open a connection and fetch the employee rows.
  id: totrans-1327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetEmployeesSyncButton_Click`事件处理程序使用同步方法打开连接并获取员工行。'
- en: The `GetEmployeesAsyncButton_Click` event handler is marked as `async` and uses
    asynchronous methods with the `await` keyword to open a connection and fetch the
    employee rows.
  id: totrans-1328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetEmployeesAsyncButton_Click`事件处理程序标记为`async`，并使用`await`关键字使用异步方法打开连接并获取员工行。'
- en: Both event handlers use a stopwatch to record the number of milliseconds the
    operation takes and add it to the list box.
  id: totrans-1329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个事件处理程序都使用秒表记录操作所花费的毫秒数，并将其添加到列表框中。
- en: Start the WPF app without debugging.
  id: totrans-1330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不带调试启动WPF应用程序。
- en: Click in the text box, enter some text, and note the GUI is responsive.
  id: totrans-1331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击文本框，输入一些文本，注意GUI是响应的。
- en: Click the **Get Employees Synchronously** button.
  id: totrans-1332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“同步获取员工”按钮。
- en: Try to click in the text box, and note the GUI is not responsive.
  id: totrans-1333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试点击文本框，注意GUI没有响应。
- en: Wait for at least five seconds until the list box is filled with employees.
  id: totrans-1334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待至少五秒，直到列表框填满员工。
- en: Click in the text box, enter some text, and note the GUI is responsive again.
  id: totrans-1335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击文本框，输入一些文本，注意GUI再次响应。
- en: Click the **Get Employees Asynchronously** button.
  id: totrans-1336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“异步获取员工”按钮。
- en: Click in the text box, enter some text, and note the GUI is still responsive
    while it performs the operation. Continue typing until the list box is filled
    with the employees.
  id: totrans-1337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击文本框，输入一些文本，注意GUI在执行操作时仍然响应。继续输入，直到列表框填满员工。
- en: Note the difference in timings for the two operations. The UI is blocked when
    fetching data synchronously, while the UI remains responsive when fetching data
    asynchronously.
  id: totrans-1338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意两个操作的时间差异。当同步获取数据时，UI被阻塞，而异步获取数据时，UI保持响应。
- en: Close the WPF app.
  id: totrans-1339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭WPF应用程序。
- en: Improving scalability for web applications and web services
  id: totrans-1340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改善Web应用程序和Web服务的可伸缩性
- en: The `async` and `await` keywords can also be applied on the server side when
    building websites, applications, and services. From the client application's point
    of view, nothing changes (or they might even notice a small increase in the time
    taken for a request to return). So, from a single client's point of view, the
    use of `async` and `await` to implement multitasking on the server side makes
    their experience worse!
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`和`await`关键字也可以应用在服务器端构建网站、应用程序和服务时。从客户端应用程序的角度来看，没有任何变化（或者他们甚至可能注意到请求返回所花费的时间略有增加）。因此，从单个客户端的角度来看，使用`async`和`await`在服务器端实现多任务处理会使他们的体验变差！'
- en: On the server side, additional, cheaper worker threads are created to wait for
    long-running tasks to finish so that expensive I/O threads can handle other client
    requests instead of being blocked. This improves the overall scalability of a
    web application or service. More clients can be supported simultaneously.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，会创建额外的廉价工作线程来等待长时间运行的任务完成，以便昂贵的I/O线程可以处理其他客户端请求而不被阻塞。这提高了Web应用程序或服务的整体可伸缩性。可以同时支持更多客户端。
- en: Common types that support multitasking
  id: totrans-1343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持多任务处理的常见类型
- en: 'There are many common types that have asynchronous methods that you can await,
    as shown in the following table:'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多常见类型具有您可以等待的异步方法，如下表所示：
- en: '| Type | Methods |'
  id: totrans-1345
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 方法 |'
- en: '| `DbContext<T>` | `AddAsync` , `AddRangeAsync` , `FindAsync` , and `SaveChangesAsync`
    |'
  id: totrans-1346
  prefs: []
  type: TYPE_TB
  zh: '| `DbContext<T>` | `AddAsync` , `AddRangeAsync` , `FindAsync` , 和 `SaveChangesAsync`
    |'
- en: '| `DbSet<T>` | `AddAsync` , `AddRangeAsync` , `ForEachAsync` , `SumAsync` ,
    `ToListAsync` , `ToDictionaryAsync` , `AverageAsync` , and `CountAsync` |'
  id: totrans-1347
  prefs: []
  type: TYPE_TB
  zh: '| `DbSet<T>` | `AddAsync` , `AddRangeAsync` , `ForEachAsync` , `SumAsync` ,
    `ToListAsync` , `ToDictionaryAsync` , `AverageAsync` , 和 `CountAsync` |'
- en: '| `HttpClient` | `GetAsync` , `PostAsync` , `PutAsync` , `DeleteAsync` , and
    `SendAsync` |'
  id: totrans-1348
  prefs: []
  type: TYPE_TB
  zh: '| `HttpClient` | `GetAsync` , `PostAsync` , `PutAsync` , `DeleteAsync` , 和
    `SendAsync` |'
- en: '| `StreamReader` | `ReadAsync` , `ReadLineAsync` , and `ReadToEndAsync` |'
  id: totrans-1349
  prefs: []
  type: TYPE_TB
  zh: '| `StreamReader` | `ReadAsync`，`ReadLineAsync`和`ReadToEndAsync` |'
- en: '| `StreamWriter` | `WriteAsync` , `WriteLineAsync` , and `FlushAsync` |'
  id: totrans-1350
  prefs: []
  type: TYPE_TB
  zh: '| `StreamWriter` | `WriteAsync`，`WriteLineAsync`和`FlushAsync` |'
- en: '**Good Practice** : Any time you see a method that ends in the suffix `Async`
    , check to see whether it returns `Task` or `Task<T>` . If it does, then you could
    use it instead of the synchronous non-`Async` suffixed method. Remember to call
    it using `await` and decorate your method with `async` .'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：每当您看到以后缀`Async`结尾的方法时，请检查它是否返回`Task`或`Task<T>`。如果是，则可以使用它而不是同步的非`Async`后缀方法。记得使用`await`调用它，并在方法上加上`async`修饰符。'
- en: Using await in catch blocks
  id: totrans-1352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在catch块中使用await
- en: When `async` and `await` were first introduced in C# 5, it was only possible
    to use the `await` keyword in a `try` block, but not in a `catch` block. In C#
    6 and later, it is now possible to use `await` in both `try` and `catch` blocks.
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 当`async`和`await`首次在C# 5中引入时，只能在`try`块中使用`await`关键字，而不能在`catch`块中使用。在C# 6及更高版本中，现在可以在`try`和`catch`块中都使用`await`。
- en: Working with async streams
  id: totrans-1354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用异步流
- en: With .NET Core 3.0, Microsoft introduced the asynchronous processing of streams.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 3.0中，微软引入了流的异步处理。
- en: 'You can complete a tutorial about async streams at the following link: [https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream](https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream)'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接完成有关异步流的教程：[https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream](https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream)
- en: Before C# 8.0 and .NET Core 3.0, the `await` keyword only worked with tasks
    that return scalar values. Async stream support in .NET Standard 2.1 allows an
    `async` method to return a sequence of values.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 8.0和.NET Core 3.0之前，`await`关键字只能与返回标量值的任务一起使用。 .NET Standard 2.1中的异步流支持允许`async`方法返回一系列值。
- en: Let's see a simulated example that returns three random integers as an async
    stream.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个模拟的例子，返回三个随机整数作为异步流。
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `AsyncEnumerable` .
  id: totrans-1359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器将新的控制台应用添加到名为`AsyncEnumerable`的`Chapter12`解决方案/工作区中。
- en: In Visual Studio Code, select `AsyncEnumerable` as the active OmniSharp project.
  id: totrans-1360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，将`AsyncEnumerable`选择为活动的OmniSharp项目。
- en: 'In `Program.cs` , delete the existing statements and statically import `Console`
    , as shown in the following code:'
  id: totrans-1361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有的语句并静态导入`Console`，如下面的代码所示：
- en: '```cs'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: static
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: System.Console; // WriteLine()
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: System.Console; // WriteLine()
- en: '```'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'At the bottom of `Program.cs` , create a method that uses the `yield` keyword
    to return a random sequence of three numbers asynchronously, as shown in the following
    code:'
  id: totrans-1367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`底部，创建一个使用`yield`关键字异步返回三个随机数字序列的方法，如下面的代码所示：
- en: '```cs'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: async
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: async
- en: static
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: IAsyncEnumerable<
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: IAsyncEnumerable<
- en: int
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: '>'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: GetNumbersAsync
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: GetNumbersAsync
- en: ()
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Random r = new
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: Random r = new
- en: ();
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: （）；
- en: // simulate work
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: //模拟工作
- en: await
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: await
- en: Task.Delay(r.Next(1500
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: Task.Delay(r.Next(1500
- en: ', 3000'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: ', 3000'
- en: ));
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: ）；
- en: yield
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 产量
- en: return
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: r.Next(0
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: r.Next(0
- en: ', 1001'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: ', 1001'
- en: );
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: ）；
- en: await
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: await
- en: Task.Delay(r.Next(1500
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: Task.Delay(r.Next(1500
- en: ', 3000'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: ', 3000'
- en: ));
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: ）；
- en: yield
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 产量
- en: return
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: r.Next(0
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: r.Next(0
- en: ', 1001'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: ', 1001'
- en: );
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: ）；
- en: await
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: await
- en: Task.Delay(r.Next(1500
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: Task.Delay(r.Next(1500
- en: ', 3000'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: ', 3000'
- en: ));
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: ）；
- en: yield
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 产量
- en: return
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: r.Next(0
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: r.Next(0
- en: ', 1001'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: ', 1001'
- en: );
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: ）；
- en: '}'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Above `GetNumbersAsync` , add statements to enumerate the sequence of numbers,
    as shown in the following code:'
  id: totrans-1409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GetNumbersAsync`上方，添加语句以枚举数字序列，如下面的代码所示：
- en: '```cs'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: await
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: await
- en: foreach
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: foreach
- en: (int
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: （int
- en: number
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 数字
- en: in
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 在
- en: GetNumbersAsync
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: GetNumbersAsync
- en: ())
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: （）
- en: '{'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: 'WriteLine($"Number:'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"数字：
- en: '{number}'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: '{number}'
- en: '"'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: ）；
- en: '}'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Number: 509'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 数字：509
- en: 'Number: 813'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 数字：813
- en: 'Number: 307'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 数字：307
- en: '```'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Practicing and exploring
  id: totrans-1431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore this chapter's topics with deeper research.
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题来测试您的知识和理解，进行一些动手实践，并深入研究本章的主题。
- en: Exercise 12.1 – Test your knowledge
  id: totrans-1433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.1-测试您的知识
- en: 'Answer the following questions:'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What information can you find out about a process?
  id: totrans-1435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以找到有关进程的哪些信息？
- en: How accurate is the `Stopwatch` class?
  id: totrans-1436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Stopwatch`类有多准确？'
- en: By convention, what suffix should be applied to a method that returns `Task`
    or `Task<T>` ?
  id: totrans-1437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照惯例，返回`Task`或`Task<T>`的方法应该应用什么后缀？
- en: To use the `await` keyword inside a method, what keyword must be applied to
    the method declaration?
  id: totrans-1438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法内部使用`await`关键字，方法声明必须应用哪个关键字？
- en: How do you create a child task?
  id: totrans-1439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建子任务？
- en: Why should you avoid the `lock` keyword?
  id: totrans-1440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么应该避免使用`lock`关键字？
- en: When should you use the `Interlocked` class?
  id: totrans-1441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该使用`Interlocked`类？
- en: When should you use the `Mutex` class instead of the `Monitor` class?
  id: totrans-1442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该使用`Mutex`类而不是`Monitor`类？
- en: What is the benefit of using `async` and `await` in a website or web service?
  id: totrans-1443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网站或网络服务中使用`async`和`await`的好处是什么？
- en: Can you cancel a task? If so, how?
  id: totrans-1444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以取消任务吗？如果可以，怎么做？
- en: Exercise 12.2 – Explore topics
  id: totrans-1445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.2-探索主题
- en: 'Use the links on the following webpage to learn more detail about the topics
    covered in this chapter:'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下网页上的链接，了解本章涵盖的主题的更多详细信息：
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-12---improving-performance-and-scalability-using-multitasking](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-12---improving-performance-and-scalability-using-multitasking)'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-12---improving-performance-and-scalability-using-multitasking](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-12---improving-performance-and-scalability-using-multitasking)'
- en: Summary
  id: totrans-1448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned not only how to define and start a task but also
    how to wait for one or more tasks to finish and how to control task completion
    order. You've also learned how to synchronize access to shared resources and the
    magic behind `async` and `await` .
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您不仅学会了如何定义和启动任务，还学会了如何等待一个或多个任务完成，以及如何控制任务完成顺序。您还学会了如何同步访问共享资源以及`async`和`await`背后的魔法。
- en: In the seven chapters that follow, you will learn how to create applications
    for the **app models** , aka **workloads** supported by .NET, such as websites
    and services, and cross-platform desktop and mobile apps.
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的七章中，您将学习如何为.NET支持的**应用程序模型**，也就是**工作负载**，如网站和服务，以及跨平台桌面和移动应用程序创建应用程序。
