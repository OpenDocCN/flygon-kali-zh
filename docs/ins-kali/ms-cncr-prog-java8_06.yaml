- en: Chapter 5. Running Tasks Divided into Phases – The Phaser Class
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。分阶段运行任务-Phaser类
- en: 'The most important element in a concurrent API is the synchronization mechanisms
    it offers to the programmer. **Synchronization** is the coordination of two or
    more tasks to get the desired result. You can synchronize the execution of two
    or more tasks, when they have to be executed in a predefined order, or synchronize
    the access to a shared resource, when only one thread at a time can execute a
    fragment of code or modify a block of memory. Java 8 concurrency API provides
    a lot of synchronization mechanisms from the basic `synchronized` keyword or the
    `Lock` interface and their implementations to protect a critical section to the
    more advanced `CyclicBarrier` or `CountDownLatch` classes that allows you to synchronize
    the order of execution of different tasks. In Java 7, the concurrency API introduces
    the `Phaser` class. This class provides a powerful mechanism (**phaser**) to execute
    tasks divided into phases. The task can ask the Phaser class to wait until all
    other participants finish the phase. In this chapter, we will cover the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 并发API中最重要的元素是为程序员提供的同步机制。**同步**是协调两个或多个任务以获得期望的结果。当必须按预定义顺序执行两个或多个任务时，或者当只有一个线程可以同时执行代码片段或修改一块内存块时，可以同步两个或多个任务的执行，或者同步对共享资源的访问。Java
    8并发API提供了许多同步机制，从基本的`synchronized`关键字或`Lock`接口及其实现来保护关键部分，到更高级的`CyclicBarrier`或`CountDownLatch`类，允许您同步不同任务的执行顺序。在Java
    7中，并发API引入了`Phaser`类。该类提供了一个强大的机制（**phaser**）来执行分阶段的任务。任务可以要求Phaser类等待直到所有其他参与者完成该阶段。在本章中，我们将涵盖以下主题：
- en: An introduction to the `Phaser` class
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Phaser`类的介绍'
- en: First example – a keyword extraction algorithm
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个示例-关键词提取算法
- en: Second example – a genetic algorithm
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个示例-遗传算法
- en: An introduction to the Phaser class
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Phaser`类的介绍'
- en: 'The `Phaser` class is a synchronization mechanism designed to control the execution
    of algorithms that can be divided into phases in a concurrent way. If you have
    a process with clear defined steps so you have to finish the first one before
    you can start the second one and so on, you can use this class to make a concurrent
    version of your process. The main characteristics of the `Phaser` class are:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`Phaser`类是一种同步机制，旨在以并发方式控制可以分阶段执行的算法。如果您有一个具有明确定义步骤的过程，因此您必须在开始第一个步骤之前完成它，然后依此类推，您可以使用此类来制作过程的并发版本。`Phaser`类的主要特点包括：'
- en: The phaser must know the number of tasks it has to control. Java refers to this
    as the registration of the participants. A participant can register in a phaser
    any time.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Phaser必须知道它需要控制的任务数量。Java将此称为参与者的注册。参与者可以随时在phaser中注册。
- en: The tasks must inform the phaser when they finish a phase. The phaser will make
    that task sleep until all the participants have finished that phase.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务必须在完成阶段时通知phaser。Phaser将使该任务休眠，直到所有参与者完成该阶段为止。
- en: Internally, the phaser saves an integer number that stores the number of phase
    changes the phase has made.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内部，phaser保存一个整数，用于存储该阶段已经进行的阶段变化次数。
- en: A participant can leave the control of the phaser any time. Java refers to this
    as the deregistration of the participants.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参与者可以随时离开phaser的控制。Java将此称为参与者的注销。
- en: You can execute custom code when the phaser makes a phase change.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当phaser进行阶段变化时，您可以执行自定义代码。
- en: You can control the termination of the phaser. If a phaser is terminated, no
    new participants will be accepted and no synchronization between tasks will be
    made.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以控制phaser的终止。如果phaser被终止，将不会接受新的参与者，并且任务之间也不会进行同步。
- en: You can use some methods to know the status and the number of participants of
    a phaser.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用一些方法来了解phaser的状态和参与者数量。
- en: Registration and deregistration of participants
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者的注册和注销
- en: As we mentioned before, a phaser must know the number of tasks it has to control.
    It has to know how many different threads are executing the phase-divided algorithm
    to control the simultaneous phase change in a correct way.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，phaser必须知道它需要控制的任务数量。它必须知道有多少不同的线程正在执行分阶段算法，以正确地控制同时的阶段变化。
- en: Java refers to this process as the registration of participants. The normal
    situation is that participants are registered at the beginning of the execution,
    but a participant can be registered any time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Java将此过程称为参与者的注册。通常情况下，参与者在执行开始时注册，但是参与者可以随时注册。
- en: 'You can register a participant using different methods:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用不同的方法注册参与者：
- en: 'When you create the `Phaser` object: The `Phaser` class provides four different
    constructors. Two of them are commonly used:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您创建`Phaser`对象时：`Phaser`类提供了四种不同的构造函数。其中两种是常用的：
- en: '`Phaser()`: This constructor creates a phaser with zero participants'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Phaser()`:此构造函数创建一个没有参与者的phaser'
- en: '`Phaser(int parties)`: This constructor creates a phaser with the given number
    of participants'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Phaser(int parties)`:此构造函数创建一个具有给定参与者数量的phaser'
- en: 'Explicitly, using one of these methods:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确地，使用其中一种方法：
- en: '`bulkRegister(int parties)`: Register the given number of new participants
    at the same time'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bulkRegister(int parties)`:同时注册给定数量的新参与者'
- en: '`register()`: Register one new participant'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`register()`:注册一个新的参与者'
- en: When one of the tasks controlled by the phaser finishes its execution, it must
    deregister from the phaser. If you don't do this, the phaser will wait endlessly
    for it in the next phase change. To deregister a participant, you can use this
    `arriveAndDeregister()`method. You use this method to indicate the phaser that
    this task has finished the current phase and it won't participate in the next
    phases.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当由phaser控制的任务之一完成其执行时，它必须从phaser中注销。如果不这样做，phaser将在下一个阶段变化中无休止地等待它。要注销参与者，可以使用`arriveAndDeregister()`方法。您可以使用此方法指示phaser，该任务已完成当前阶段，并且不会参与下一个阶段。
- en: Synchronizing phase changes
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步阶段变化
- en: 'The main purpose of the phaser is to allow the implementation of algorithms
    that are clearly divided into phases in a concurrent way. None of the tasks can
    advance to the next phase until all the tasks have finished the previous phase.
    The `Phaser` class provides three methods to signal that the task finished the
    phase: `arrive()`, `arriveAndDeregister()`, and `arriveAndAwaitAdvance()`. If
    one of the tasks doesn''t call one of these methods, the rest of the participant
    tasks will be blocked by the phaser indefinitely. To advance to the next phase,
    the following methods are used:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: phaser的主要目的是以并发方式清晰地划分为阶段的算法的实现。在所有任务完成前一个阶段之前，没有一个任务可以进入下一个阶段。`Phaser`类提供了三种方法来表示任务已完成阶段：`arrive()`、`arriveAndDeregister()`和`arriveAndAwaitAdvance()`。如果其中一个任务没有调用这些方法之一，其他参与者任务将被phaser无限期地阻塞。要进入下一个阶段，使用以下方法：
- en: '`arriveAndAwaitAdvance()`: A task uses this method to indicate to the phaser
    that it has finished the current phase and wants to continue with the next one.
    The phaser will block the tasks until all the participant tasks have called one
    of the synchronization methods.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arriveAndAwaitAdvance()`: 任务使用此方法向phaser指示，它已完成当前阶段，并希望继续下一个阶段。phaser将阻塞任务，直到所有参与者任务调用了同步方法之一。'
- en: '`awaitAdvance(int phase)`: A task uses this method to indicate to the phaser
    that it wants to wait for the finalization of the current phase if the number
    we pass as a parameter and the actual phase of the phaser are equal. If they aren''t
    equal, this method returns immediately.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awaitAdvance(int phase)`: 任务使用此方法向phaser指示，如果传递的数字和phaser的当前阶段相等，则希望等待当前阶段的完成。如果它们不相等，此方法将立即返回。'
- en: Other functionalities
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他功能
- en: 'When all the participant tasks have finished the execution of a phase and before
    they continue with the next one, the `Phaser` class executes the `onAdvance()`
    method. This method receives the two following parameters:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有参与者任务完成一个阶段的执行并在继续下一个阶段之前，`Phaser`类执行`onAdvance()`方法。此方法接收以下两个参数：
- en: '`phase`: This is the number of the phase that has finished. The first phase
    is the number zero'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`phase`：这是已完成的阶段编号。第一个阶段是编号零'
- en: '`registeredParties`: This indicates the number of participant tasks'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registeredParties`：这表示参与者任务的数量'
- en: If you want to execute some code between two phases, for example, to sort or
    to transform some data, you can implement your own phaser extending the `Phaser`
    class and overriding this method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在两个阶段之间执行一些代码，例如对数据进行排序或转换，可以实现自己的phaser，扩展`Phaser`类并覆盖此方法。
- en: 'A phaser can be in two states:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: phaser可以处于两种状态：
- en: '**Active**: The phaser enters in this state when it''s created and new participants
    are registered and continue on it until its termination. When it''s in this state,
    it accepts new participants and works as it has been explained before.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动**：当创建phaser并注册新参与者并继续进行直到终止时，phaser进入此状态。在此状态下，它接受新的参与者并按照之前的说明工作。'
- en: '**Termination**: The phaser enters in this state when the `onAdvance()` method
    returns the `true` value. By default, it returns the `true` value when all the
    participants have been deregistered.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终止**：当`onAdvance()`方法返回`true`值时，phaser进入此状态。默认情况下，当所有参与者已注销时，它返回`true`值。'
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When a phaser is in the termination state, registration of new participants
    has no effect and synchronization methods return immediately.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当phaser处于终止状态时，新参与者的注册不起作用，并且同步方法会立即返回。
- en: 'Finally, the `Phaser` class provides some methods to get information about
    the status and participants in the phaser:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Phaser`类提供了一些方法来获取有关phaser状态和参与者的信息：
- en: '`getRegisteredParties()`: This method returns the number of participants in
    the phaser'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRegisteredParties()`: 此方法返回phaser中的参与者数量'
- en: '`getPhase()`: This method returns the number of the current phase'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPhase()`: 此方法返回当前阶段的编号'
- en: '`getArrivedParties()`: This method returns the number of participants that
    have finished the current phase'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getArrivedParties()`: 此方法返回已完成当前阶段的参与者数量'
- en: '`getUnarrivedParties()`: This method returns the number of participants that
    haven''t finished the current phase'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getUnarrivedParties()`: 此方法返回尚未完成当前阶段的参与者数量'
- en: '`isTerminated()`: This method returns `true` value if the phaser is in the
    termination state and `false` otherwise'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isTerminated()`: 如果phaser处于终止状态，则此方法返回`true`值，否则返回`false`'
- en: First example – a keyword extraction algorithm
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个示例 - 关键字提取算法
- en: In this section, you are going to use a phaser to implement a **keyword extraction
    algorithm**. The main purpose of these kinds of algorithms is to extract the words
    from a text document or a collection of documents that define the document of
    the document inside the collection better. These terms can be used to summarize
    the documents, clustering them or to improve the information search process.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将使用phaser来实现**关键字提取算法**。这类算法的主要目的是从文本文档或文档集合中提取单词，以更好地定义文档在集合中的文档。这些术语可用于总结文档、对其进行聚类或改进信息搜索过程。
- en: 'The most basic algorithm to extract the keywords of the documents in a collection
    (but it''s still commonly used nowadays) is based on the **TF-IDF** measure where:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从集合中提取文档关键字的最基本算法（但现在仍然常用）是基于**TF-IDF**度量，其中：
- en: '**TF** (short for **term frequency**) is the number of times that a word appears
    in a document.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TF**（代表**词项频率**）是单词在文档中出现的次数。'
- en: '**DF** (short for **document frequency**) is the number of documents that contains
    a word. The **IDF** (short for **inverse document frequency**) measures the information
    that word provides to distinguish a document from others. If a word is very common,
    it''s IDF will be low, but if the word appears in only a few documents, it''s
    IDF will be high.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DF**（代表**文档频率**）是包含单词的文档数量。**IDF**（代表**逆文档频率**）度量了单词提供的信息，以区分文档与其他文档。如果一个词很常见，它的IDF将很低，但如果这个词只出现在少数文档中，它的IDF将很高。'
- en: 'The TF-IDF of the word *t* in the document *d* can be calculated using the
    following formula:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 单词*t*在文档*d*中的TF-IDF可以使用以下公式计算：
- en: '![First example – a keyword extraction algorithm](img/00014.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![第一个示例 - 关键词提取算法](img/00014.jpeg)'
- en: 'The attributes used in the preceding formula can be explained as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上述公式中使用的属性可以解释如下：
- en: '*F**[t,d]* is the number of appearances of the word *t* in the document *d*'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F**[t,d]*是单词*t*在文档*d*中出现的次数'
- en: '*N* is the number of documents in the collection'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*N*是集合中文档的数量'
- en: '*n**[t]* is the number of documents that contain the word *t*'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n**[t]*是包含单词*t*的文档数量'
- en: To obtain the keywords of a document, you can select the words with higher values
    of its TF-IDF.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取文档的关键词，可以选择TF-IDF值较高的单词。
- en: 'The algorithm you are going to implement will calculate the best keywords in
    a document collection executing the following phases:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您将要实现的算法将执行以下阶段，计算文档集合中的最佳关键词：
- en: '**Phase 1**: Parse all the documents and extract the DF of all the words. Note
    that you will only have the exact values once you have parsed all the documents.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一阶段**：解析所有文档并提取所有单词的DF。请注意，只有在解析所有文档后，您才会获得确切的值。'
- en: '**Phase 2**: Calculate the TF-IDF for all the words in all the documents. Select
    10 keywords per document (the 10 words with a higher value of the TF-IDF measure).'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二阶段**：计算所有文档中所有单词的TF-IDF。选择每个文档的10个关键词（TF-IDF值最高的10个单词）。'
- en: '**Phase 3**: Obtain a list of the best keywords. We considered that those are
    the words that are a keyword of a higher number of documents.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三阶段**：获取最佳关键词列表。我们认为那些是出现在更多文档中的单词。'
- en: To test the algorithm, we will use the Wikipedia pages with information about
    movies as the document collection. We have used the same collection in [Chapter
    4](part0033_split_000.html#VF2I1-2fff3d3b99304faa8fa9b27f1b5053ba "Chapter 4. Getting
    Data from the Tasks – The Callable and Future Interfaces"), *Getting Data from
    the Tasks – The Callable and Future Interfaces*. This collection is formed by
    100,673 documents. We have converted each Wikipedia page in a text file. You can
    download this document collection with all the information about the book.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试算法，我们将使用维基百科关于电影信息的页面作为文档集合。我们在[第4章](part0033_split_000.html#VF2I1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 4. Getting Data from the Tasks – The Callable and Future Interfaces")中使用了相同的集合，*从任务中获取数据
    - Callable和Future接口*。该集合由100,673个文档组成。我们已经将每个维基百科页面转换为文本文件。您可以下载包含有关该书的所有信息的文档集合。
- en: 'You are going to implement two different versions of the algorithm: a basic
    serial one and a concurrent one using the `Phaser` class. After this, we will
    compare the execution time of both versions to verify that concurrency provides
    us with better performance.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您将要实现算法的两个不同版本：基本的串行版本和使用`Phaser`类的并发版本。之后，我们将比较两个版本的执行时间，以验证并发性能更好。
- en: Common classes
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见类
- en: 'Both versions of the algorithm share some common functionality to parse the
    documents and to store information about documents, keywords, and words. The common
    classes are:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的两个版本共享一些通用功能，用于解析文档并存储有关文档、关键词和单词的信息。这些通用类包括：
- en: The `Document` class that stores the name of the file that contains the document
    and the words that form it
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储包含文档名称和构成文档的单词的`Document`类
- en: The `Word` class that stores the string with the word and the measures of that
    word (TF, DF, and TF-IDF)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储单词字符串和该单词的度量（TF，DF和TF-IDF）的`Word`类
- en: The `Keyword` class that stores the string with the word and the number of documents
    in which the word is a keyword
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储单词字符串和该单词作为关键词出现在的文档数量的`Keyword`类
- en: The `DocumentParser` class that extracts the words for a document
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取文档中的单词的`DocumentParser`类
- en: Let's see these classes in more detail.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些类。
- en: The Word class
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单词类
- en: The `Word` class stores the information about a word. This information includes
    the whole word and the measures that affect it, that it's to say, it's TF in a
    document, it's global DF, and the resultant TF-IDF.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Word`类存储有关单词的信息。这些信息包括整个单词以及影响它的度量，即它在文档中的TF，它的全局DF和结果TF-IDF。'
- en: 'This class implements the `Comparable` interface because we''re going to sort
    an array of words in order to obtain the ones with a higher TF-IDF. Refer to the
    following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了`Comparable`接口，因为我们将对单词数组进行排序，以获取TF-IDF值较高的单词。参考以下代码：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we declare the attributes of the class and implement the getters and
    setters (these ones are not included):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们声明了该类的属性并实现了getter和setter（这些未包含在内）：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have implemented other methods of interest as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了其他感兴趣的方法如下：
- en: The constructor of the class, which initializes the word (with the word received
    as parameter) and the `df` attribute (with a value of `1`).
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类的构造函数，初始化单词（使用参数接收的单词）和`df`属性（值为`1`）。
- en: The `addTf()` method, which increments the `tf` attribute.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addTf()`方法，增加`tf`属性。'
- en: The `merge()` method that receives a `Word` object and merges the same word
    from two different documents. It sums the `tf` and `df` attributes of both objects.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`merge()`方法接收一个`Word`对象并合并来自两个不同文档的相同单词。它将两个对象的`tf`和`df`属性相加。'
- en: 'Then, we implement a special version of the `setDf()` method. It receives the
    value of the `df` attribute as a parameter and the total number of documents in
    the collection, and it calculates the `tfIdf` attribute:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现了`setDf()`方法的特殊版本。它接收`df`属性的值和集合中文档的总数，并计算`tfIdf`属性：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we implement the `compareTo()` method. We want the words ordered from
    a higher to lower `tfIdf` attribute:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现`compareTo()`方法。我们希望单词按`tfIdf`属性从高到低排序：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Keyword class
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键词类
- en: The `Keyword` class stores information about a keyword. This information includes
    the whole word and the number of documents in which this word is a keyword.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Keyword`类存储有关关键词的信息。这些信息包括整个单词以及该单词作为关键词出现在的文档数量。'
- en: 'As occurs with the `Word` class, it implements the `Comparable` interface because
    we''re going to sort an array of keywords to obtain the best keywords:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Word`类一样，它实现了`Comparable`接口，因为我们将对关键字数组进行排序以获得最佳关键字：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we declare the attributes of the class and implement the methods to establish
    and return its values (these ones are not included here):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们声明了类的属性并实现了方法来建立和返回其值（这些方法在此处未包括）：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we implement the `compareTo()` method. We want the keywords ordered
    from a higher to lower number of documents:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了`compareTo()`方法。我们希望关键词按文档数量从高到低排序：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Document class
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Document类
- en: 'The `Document` class stores the information about a document of the collection
    (remember that our collection has 100,673 documents) that includes the name of
    the file and the set of words that forms the document. That set of words, usually
    named the vocabulary of the document, is implemented as a `HashMap` using the
    whole word as a string as the key and a `Word` object as the value:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Document`类存储有关集合中文档的信息（请记住我们的集合有100,673个文档），包括文件名和构成文档的单词集。该单词集通常称为文档的词汇，它以整个单词作为字符串作为键，并以`Word`对象作为值实现为`HashMap`：'
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have implemented a constructor that creates the `HashMap` and methods to
    get and set the name of the file and to return the vocabulary of the document
    (these methods are not included). We also have implemented a method to add a word
    in the vocabulary. If the word doesn''t exist on it, we add to it. If the word
    exists in the vocabulary, we increment the `tf` attribute of the word. We have
    used the `computeIfAbsent()` method of the `voc` object. This method inserts the
    word in the `HashMap` if it doesn''t exist and then increments the `tf` using
    the `addTf()` method:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个构造函数，创建了`HashMap`和方法来获取和设置文件名以及返回文档的词汇（这些方法未包括）。我们还实现了一个方法来在词汇中添加单词。如果单词不存在，则将其添加到其中。如果单词存在于词汇中，则增加单词的`tf`属性。我们使用了`voc`对象的`computeIfAbsent()`方法。该方法如果单词不存在，则将单词插入`HashMap`中，然后使用`addTf()`方法增加`tf`：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `HashMap` class is not synchronized, but we can use it in our concurrent
    application because it will not be shared between different tasks. A `Document`
    object will be generated only by one task, so we won't have race conditions in
    our concurrent version derived by the utilization of the `HashMap` class.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashMap`类不是同步的，但我们可以在并发应用程序中使用它，因为它不会在不同任务之间共享。一个`Document`对象只会被一个任务生成，因此我们不会在并发版本中出现由`HashMap`类的使用导致的竞争条件。'
- en: The DocumentParser class
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DocumentParser类
- en: 'The `DocumentParser` class reads the content of a text file and converts it
    into a `Document` object. It splits the text into the words and stores them in
    the `Document` object to generate the vocabulary of the class. This class has
    two static methods. The first one is the `parse()` method that receives a string
    with the path of the file and returns a `Document` object. It opens the file and
    reads it line by line, using the `parseLine()` method to convert each line into
    a sequence of words, and stores them into the `Document` class:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`DocumentParser`类读取文本文件的内容并将其转换为`Document`对象。它将文本拆分为单词并将它们存储在`Document`对象中以生成类的词汇。该类有两个静态方法。第一个是`parse()`方法，它接收一个带有文件路径的字符串并返回一个`Document`对象。它打开文件并逐行读取，使用`parseLine()`方法将每行转换为一系列单词，并将它们存储到`Document`类中：'
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `parseLine()` method receives the line to parse and the `Document` object
    to store the words as parameters.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseLine()`方法接收要解析的行和`Document`对象以存储单词作为参数。'
- en: 'First, it deletes the accents of the line using the `Normalizer` class and
    converts it into lowercase:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`Normalizer`类删除行的重音符号，并将其转换为小写：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we split the line in words using the `StringTokenizer` class and add
    those words to the `Document` object:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`StringTokenizer`类将行拆分为单词，并将这些单词添加到`Document`对象中：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The serial version
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 串行版本
- en: We have implemented the serial version of our keyword algorithm in the `SerialKeywordExtraction`
    class. It defines the `main()` method you are going to execute to test the algorithm.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`SerialKeywordExtraction`类中实现了关键字算法的串行版本。它定义了您将执行以测试算法的`main()`方法。
- en: 'The first step is to declare the following necessary internal variables to
    execute the algorithm:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是声明以下必要的内部变量来执行算法：
- en: Two `Date` objects to measure the execution time
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个`Date`对象，用于测量执行时间
- en: A string to store the name of the directory that contains the document collection
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串，用于存储包含文档集合的目录的名称
- en: An array of `File` objects to store the files with the document collection
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`File`对象数组，用于存储文档集合中的文件
- en: A `HashMap` to store the global vocabulary of the document collection
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`HashMap`，用于存储文档集合的全局词汇
- en: A `HashMap` to store the keywords
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`HashMap`，用于存储关键字
- en: Two `int` values to measure statistic data about the execution
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个`int`值，用于测量执行的统计数据
- en: 'The following includes the declaration of these variables:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下包括这些变量的声明：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we have included the first phase of the algorithm. We parse all the documents
    using the `parse()` method of the `DocumentParser` class. This method returns
    a `Document` object that contains the vocabulary of that document. We add the
    document vocabulary to the global vocabulary using the `merge()` method of the
    `HashMap` class. If a word doesn''t exist, it inserts it in the `HashMap`. If
    the word exists, two word objects are merged together summing the `Tf` and `Df`
    attributes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们已经包含了算法的第一阶段。我们使用`DocumentParser`类的`parse()`方法解析所有文档。该方法返回一个包含该文档词汇的`Document`对象。我们使用`HashMap`类的`merge()`方法将文档词汇添加到全局词汇中。如果单词不存在，则将其插入`HashMap`中。如果单词存在，则合并两个单词对象，求和`Tf`和`Df`属性：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After this phase, the `globalVocHashMap` class contains all the words of the
    document collection with their global TF (the total number of appearances of the
    word in the collection) and their DF.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段之后，`globalVocHashMap`类包含了文档集合中所有单词及其全局TF（单词在集合中出现的总次数）和DF。
- en: 'Then, we have included the second phase of the algorithm. We are going to calculate
    the keywords of each document using the TF-IDF measure, as we explained before.
    We have to parse again each document to generate its vocabulary. We have to do
    this because we can''t store in memory the vocabularies of 100,673 documents that
    form our document collection. If you work with a smaller document collection,
    you can try to parse the documents only once and store the vocabularies of all
    the documents in memory, but in our case, it''s impossible. So, we parse all the
    documents again, and, to each word, we update the `Df` attribute using the values
    stored in the `globalVoc`. We also construct an array with all the words in the
    document:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们包括了算法的第二阶段。我们将使用TF-IDF度量来计算每个文档的关键词，正如我们之前解释的那样。我们必须再次解析每个文档以生成其词汇表。我们必须这样做，因为我们无法将由100,673个文档组成的文档集合的词汇表存储在内存中。如果您使用的是较小的文档集合，可以尝试仅解析一次文档并将所有文档的词汇表存储在内存中，但在我们的情况下，这是不可能的。因此，我们再次解析所有文档，并且对于每个单词，我们使用存储在`globalVoc`中的值来更新`Df`属性。我们还构建了一个包含文档中所有单词的数组：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, we have the list of keywords with all the words in the document with their
    TF-IDF calculated. We use the `sort()` method of the `Collections` class to sort
    the list getting the words with a higher value of TF-IDF in the first position.
    Then we get the first 10 words of that list to store them in the `globalKeywordsHashMap`
    using the `addKeyword()` method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了关键词列表，其中包含文档中所有单词的TF-IDF计算结果。我们使用`Collections`类的`sort()`方法对列表进行排序，将TF-IDF值较高的单词排在第一位。然后我们获取该列表的前10个单词，并使用`addKeyword()`方法将它们存储在`globalKeywordsHashMap`中。
- en: 'There is no special reason to choose the first 10 words. You can try other
    options, as a percentage of the words or a minimum value of the TF-IDF measure,
    and see their behavior:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 选择前10个单词没有特殊原因。您可以尝试其他选项，比如单词的百分比或TF-IDF值的最小值，并观察它们的行为：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, we have included the third phase of our algorithm. We convert the `globalKeywordsHashMap`
    into a list of `Keyword` objects, use the `sort()` method of the `Collections`
    class to sort that array getting the keywords with a higher DF value in the first
    positions of the list, and write the first 100 words in the console.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们包括了算法的第三阶段。我们将`globalKeywordsHashMap`转换为`Keyword`对象的列表，使用`Collections`类的`sort()`方法对该数组进行排序，获取DF值较高的关键词并将其写入控制台的前100个单词。
- en: 'Refer to the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下代码：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As in the second phase, there is no special reason to choose the first 100 words.
    You can try other options if you want.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与第二阶段一样，选择前100个单词没有特殊原因。如果您愿意，可以尝试其他选项。
- en: 'To finish the main method, we write the execution time and other statistic
    data in the console:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在主方法结束时，我们在控制台中写入执行时间和其他统计数据：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `SerialKeywordExtraction` class also includes the `addKeyword()` method
    that updates the information of a keyword in the `globalKeywordsHashMap` class.
    If the word exists, the class updates its DF and if the word doesn''t exists,
    inserts it. Refer to the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`SerialKeywordExtraction`类还包括`addKeyword()`方法，用于更新`globalKeywordsHashMap`类中关键词的信息。如果单词存在，该类会更新其DF；如果单词不存在，则插入它。'
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The concurrent version
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发版本
- en: 'To implement the concurrent version of this example, we have used two different
    classes as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个示例的并发版本，我们使用了两个不同的类，如下所示：
- en: The `KeywordExtractionTasks` class that implements the tasks that are going
    to calculate the keywords in a concurrent way. We are going to execute the tasks
    as `Thread` objects, so this class implements the `Runnable` interface.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeywordExtractionTasks`类实现了以并发方式计算关键词的任务。我们将以`Thread`对象的形式执行这些任务，因此这个类实现了`Runnable`接口。'
- en: The `ConcurrentKeywordExtraction` class that provides the `main()` method to
    execute the algorithm and creates, starts, and waits for the tasks to finish.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentKeywordExtraction`类提供了`main()`方法来执行算法，并创建、启动和等待任务完成。'
- en: Let's see these classes in detail.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这些类。
- en: The KeywordExtractionTask class
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键词提取任务类
- en: 'As we mentioned before, this class implements the tasks that are going to calculate
    the final keyword list. It implements the `Runnable` interface, so we can execute
    them as a `Thread`, and internally uses some attributes, most of which are shared
    between all the tasks:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，这个类实现了计算最终关键词列表的任务。它实现了`Runnable`接口，因此我们可以将其作为`Thread`执行，并且在内部使用一些属性，其中大部分属性在所有任务之间是共享的：
- en: '**Two ConcurrentHashMap objects to store the global vocabulary and the global
    keywords**: We use the `ConcurrentHashMap` because these objects are going to
    be updated by all the tasks, so we have to use a concurrent data structure to
    avoid race conditions.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**两个ConcurrentHashMap对象用于存储全局词汇表和全局关键词**：我们使用`ConcurrentHashMap`，因为这些对象将由所有任务更新，所以我们必须使用并发数据结构来避免竞争条件。'
- en: '**Two ConcurrentLinkedDeque of File objects to store the list of files that
    forms the document collection**: We use the `ConcurrentLinkedDeque` class because
    all the tasks are going to extract (`get` and `delete`) elements of the list simultaneously,
    so we have to use a concurrent data structure to avoid race conditions. If we
    use a normal `List`, the same `File` can be parsed twice by different tasks. We
    have two `ConcurrentLinkedDeque` because we have to parse the collection of documents
    twice. As we mentioned before, we parse the document collection extracting `File`
    objects from the data structures, so, when we have parsed the collection, the
    data structure will be empty.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**两个 ConcurrentLinkedDeque 的 File 对象，用于存储构成文档集合的文件列表**：我们使用 `ConcurrentLinkedDeque`
    类，因为所有任务都将同时提取（获取和删除）列表的元素，所以我们必须使用并发数据结构来避免竞争条件。如果我们使用普通的 `List`，同一个 `File` 可能会被不同的任务解析两次。我们有两个
    `ConcurrentLinkedDeque`，因为我们必须两次解析文档集合。正如我们之前提到的，我们从数据结构中提取 `File` 对象来解析文档集合，因此，当我们解析完集合时，数据结构将为空。'
- en: '**A Phaser object to control the execution of the tasks**: As we explained
    before, our keyword extraction algorithm is executed in three phases. None of
    the tasks advanced to one phase until all the tasks have finished the previous
    one. We use the `Phaser` object to control this. If we don''t control this, we
    will obtain inconsistent results.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个 Phaser 对象来控制任务的执行**：正如我们之前解释的那样，我们的关键词提取算法是在三个阶段中执行的。在所有任务完成前，没有一个任务会进入下一个阶段。我们使用
    `Phaser` 对象来控制这一点。如果我们不控制这一点，我们将得到不一致的结果。'
- en: '**The final step has to be executed by only one thread**: We are going to distinguish
    one main task from the others using a Boolean value. These main tasks will execute
    that final phase.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终步骤必须由一个线程执行**：我们将使用布尔值区分一个主任务和其他任务。这些主任务将执行最终阶段。'
- en: '**The total number of documents in the collection**: We need this value to
    calculate the TF-IDF measure.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合中的文档总数**：我们需要这个值来计算 TF-IDF 度量。'
- en: 'We have included a constructor to initialize all these attributes:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包括了一个构造函数来初始化所有这些属性：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `run()` method implements the algorithm with its three phases. First, we
    call the `arriveAndAwaitAdvance()` method of the phaser to wait for the creation
    of the other tasks. All the tasks will start their execution at the same moment.
    Then, as we explained in the serial version of the algorithm, we parse all the
    documents and build the `globalVocConcurrentHashMap` class with all the words
    and their global TF and DF values. To complete phase one, we call again the `arriveAndAwaitAdvance()`
    method to wait for the finalization of the other tasks before the execution of
    the second phase:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()` 方法实现了算法的三个阶段。首先，我们调用 phaser 的 `arriveAndAwaitAdvance()` 方法等待其他任务的创建。所有任务将在同一时刻开始执行。然后，就像我们在算法的串行版本中解释的那样，我们解析所有文档，并使用所有单词和它们的全局
    TF 和 DF 值构建 `globalVocConcurrentHashMap` 类。为了完成第一阶段，我们再次调用 `arriveAndAwaitAdvance()`
    方法，等待其他任务在执行第二阶段之前的最终化：'
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, to get the `File` objects to process, we use the `poll()` method
    of the `ConcurrentLinkedDeque` class. This method *retrieves and removes* the
    first element of `Deque`, so the next task will obtain a different file to parse,
    and no file will be parsed twice.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，为了获取要处理的 `File` 对象，我们使用 `ConcurrentLinkedDeque` 类的 `poll()` 方法。这个方法*检索并删除*`Deque`的第一个元素，所以下一个任务将获得一个不同的文件进行解析，不会有文件被解析两次。
- en: 'The second phase calculates the `globalKeywords` structure, as we explained
    in the serial version of the algorithm. First, calculate the best 10 keywords
    of every document and then insert them in the `ConcurrentHashMap` class. The code
    is the same as in the serial version changing the serial data structures for the
    concurrent ones:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段计算 `globalKeywords` 结构，就像我们在算法的串行版本中解释的那样。首先，计算每个文档的最佳 10 个关键词，然后将它们插入 `ConcurrentHashMap`
    类。代码与串行版本相同，只是将串行数据结构更改为并发数据结构：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The final phase will be different for the main task and for the others. The
    main task uses the `arriveAndAwaitAdvance()` method of the `Phaser` class to wait
    for the finalization of the second phase of all the tasks before writing the best
    100 keywords of the whole collection in the console. Finally, it uses the `arriveAndDeregister()`
    method to deregister from the phaser.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最终阶段对于主任务和其他任务是不同的。主任务使用 `Phaser` 类的 `arriveAndAwaitAdvance()` 方法等待所有任务的第二阶段最终化，然后在控制台中写入整个集合中最佳的
    100 个关键词。最后，它使用 `arriveAndDeregister()` 方法从 phaser 中注销。
- en: The rest of the tasks use the `arriveAndDeregister()` method to mark the finalization
    of the second phase, deregister from the phaser, and finish their execution.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 其他任务使用 `arriveAndDeregister()` 方法标记第二阶段的最终化，从 phaser 中注销，并完成它们的执行。
- en: 'When all the tasks have finished their work, all of them have deregistered
    themselves from the phaser. The phaser will have zero parties, and it will enter
    the termination state:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有任务都完成了他们的工作，它们都从 phaser 中注销了自己。phaser 将没有任何 parties，并且进入终止状态。
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The ConcurrentKeywordExtraction class
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ConcurrentKeywordExtraction 类
- en: The `ConcurrentKeywordExtraction` class initializes the shared objects, creates
    the tasks, executes them, and waits for its finalization. It implements the `main()`
    method that can receive an optional parameter. By default, we are doing the number
    of tasks determined by the `availableProcessors()` method of the `Runtime` class
    that returns the number of hardware threads available to the **Java Virtual Machine**
    (**JVM**). If we receive a parameter, we convert it into an integer and use it
    as a multiplier of the number of available processors to determine the number
    of tasks we are going to create.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentKeywordExtraction` 类初始化了共享对象，创建了任务，执行它们，并等待它们的最终化。它实现了一个 `main()`
    方法，可以接收一个可选参数。默认情况下，我们根据 `Runtime` 类的 `availableProcessors()` 方法确定任务的数量，该方法返回
    **Java 虚拟机** (**JVM**) 可用的硬件线程数。如果我们收到一个参数，我们将其转换为整数，并将其用作可用处理器数量的乘数，以确定我们将创建的任务数量。'
- en: First, we initialize all the necessary data structures and parameters. To fill
    the two `ConcurrentLinkedDeque` structures, we use the `listFiles()` method of
    the `File` class to get an array of `File` objects with the files that end with
    the `txt` suffix.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们初始化所有必要的数据结构和参数。为了填充两个`ConcurrentLinkedDeque`结构，我们使用`File`类的`listFiles()`方法来获取以`txt`后缀结尾的文件的`File`对象数组。
- en: 'We also create the `Phaser` object using the constructor without parameters,
    so all the tasks must register themselves in the phaser explicitly. Refer to the
    following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用不带参数的构造函数创建`Phaser`对象，因此所有任务必须显式地在屏障中注册自己。参考以下代码：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we create the first task with the main parameter to `true` and the rest
    with the main parameter to `false`. After the creation of each task, we use the
    `register()` method of the `Phaser` class to register a new participant in the
    phaser as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`true`作为主参数创建第一个任务，其余使用`false`作为主参数。在创建每个任务之后，我们使用`Phaser`类的`register()`方法来注册新的参与者到屏障中，如下所示：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we create and start the thread objects that run the tasks and wait for
    its finalization:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建并启动运行任务的线程对象，并等待其完成：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we write some statistic information about the execution in the console,
    including the execution time:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在控制台中写入有关执行的一些统计信息，包括执行时间：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Comparing the two solutions
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较两种解决方案
- en: Let's compare the serial and concurrent versions of our keyword extraction 100,673
    documents. We have executed the examples using the JMH framework ([http://openjdk.java.net/projects/code-tools/jmh/](http://openjdk.java.net/projects/code-tools/jmh/))
    that allows you to implement micro benchmarks in Java. Using a framework for benchmarking
    is a better solution that simply measures time using methods such as `currentTimeMillis()`
    or `nanoTime()`. We have executed them 10 times in a computer with a four-core
    processor and calculate the medium execution time of those 10 times.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较我们的关键词提取100,673个文档的串行和并发版本。我们使用JMH框架（[http://openjdk.java.net/projects/code-tools/jmh/](http://openjdk.java.net/projects/code-tools/jmh/)）执行示例，该框架允许您在Java中实现微基准测试。使用基准测试框架比简单地使用`currentTimeMillis()`或`nanoTime()`等方法测量时间更好。我们在一个四核处理器的计算机上执行了10次，并计算了这10次的平均执行时间。
- en: '| Algorithm | Factor | Execution time (seconds) |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 算法 | 因子 | 执行时间（秒） |'
- en: '| --- | --- | --- |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Serial** | N/A | 194.45 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| **串行** | N/A | 194.45 |'
- en: '| **Concurrent** | 1 | 64.52 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| **并发** | 1 | 64.52 |'
- en: '| 2 | 65.55 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 65.55 |'
- en: '| 3 | 68,23 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 68,23 |'
- en: 'We can draw the following conclusions:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出以下结论：
- en: The concurrent version of the algorithm increases the performance of the serial
    version.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法的并发版本提高了串行版本的性能。
- en: If we use more tasks than the number of the available hardware threads, we don't
    get a better result. Just a little worse because of the extra synchronization
    work the phaser must do.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用的任务数量超过了可用的硬件线程数量，我们不会得到更好的结果。只会稍微差一点，因为额外的同步工作必须由屏障执行。
- en: 'We compare the concurrent and serial versions of the algorithm calculating
    the speed-up using the following formula:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们比较并发和串行版本的算法，使用以下公式计算加速比：
- en: '![Comparing the two solutions](img/00015.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![比较两种解决方案](img/00015.jpeg)'
- en: The second example – a genetic algorithm
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二个例子 - 遗传算法
- en: '**Genetic algorithms** are adaptive heuristic search algorithms based on the
    natural selection principles use to generate good solutions to **optimization**
    and **search problems**. They work with possible solutions to a problem named
    **individuals** or **phenotypes**. Each individual has a representation formed
    by a set of properties named **chromosomes**. Normally, the individuals are represented
    by a sequence of bits, but you can choose the representation that better fits
    your problem.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**遗传算法**是基于自然选择原理的自适应启发式搜索算法，用于生成**优化**和**搜索问题**的良好解决方案。它们处理问题的可能解决方案，称为**个体**或**表型**。每个个体都有一个由一组属性组成的表示，称为**染色体**。通常，个体由一系列位表示，但你可以选择最适合你问题的表示形式。'
- en: You also need a function to determine whether a solution is good or bad named
    **fitness function**. The main objective of the genetic algorithm is to find a
    solution that maximizes or minimizes that function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一个确定解决方案好坏的函数，称为**适应度函数**。遗传算法的主要目标是找到最大化或最小化该函数的解决方案。
- en: The genetic algorithm starts with a set of possible solutions to the problem.
    This set of possible solutions is named the population. You can generate this
    initial set randomly or use some kind of heuristic function to obtain better initial
    solutions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法从一组可能的问题解决方案开始。这组可能的解决方案被称为种群。你可以随机生成这个初始集，或者使用某种启发式函数来获得更好的初始解决方案。
- en: 'Once you have the initial population, you begin an iterative process with three
    phases. Each step of that iterative process is called a generation. The phases
    of each generation are:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了初始种群，你就开始一个迭代过程，包括三个阶段。该迭代过程的每一步被称为一代。每一代的阶段包括：
- en: '**Selection**: You select the better individuals of your population. These
    are the individuals with a better value in the fitness function.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择**: 你选择种群中更好的个体。这些个体在适应度函数中具有更好的值。'
- en: '**Crossover**: You cross the individuals selected in the previous step to generate
    the new individuals that form the new generation. This operation takes two individuals
    and generates two new individuals. The implementation of this operation depends
    on the problem you want to solve and the representation of the individuals you
    have chosen.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交叉**: 你交叉选择在上一步中选定的个体，以生成新的个体，形成新的一代。这个操作需要两个个体，并生成两个新的个体。这个操作的实现取决于你想要解决的问题以及你选择的个体的表示。'
- en: '**Mutation**: You can apply a mutation operator to alter the values of an individual.
    Normally, you will apply that operation to a very low number of individuals. While
    mutation is a very important operation to find a good solution, we don''t apply
    it to simplify our example.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**突变**：您可以应用突变运算符来改变个体的值。通常，您会将该操作应用于非常少量的个体。虽然突变是找到良好解决方案的一个非常重要的操作，但我们不会在简化示例中应用它。'
- en: 'You repeat these three operations until you meet your finish criteria. These
    finish criteria can be:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您重复这三个操作，直到满足您的完成标准。这些完成标准可以是：
- en: A fixed number of generations
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定数量的世代
- en: A predefined value of the fitness function
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预定义的适应度函数值
- en: A solution that meets the predefined criteria is found
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到符合预定义标准的解决方案
- en: A time limit
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间限制
- en: A manual stop
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动停止
- en: Normally, you will store the best individual you have found across the process
    outside of the population. This individual will be the solution proposed by the
    algorithm, and normally, it's going to be a better solution, as we generate new
    generations.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会在种群之外存储您在整个过程中找到的最佳个体。这个个体将是算法提出的解决方案，通常情况下，它会是一个更好的解决方案，因为我们会生成新的世代。
- en: 'In this section, we are going to implement a genetic algorithm to solve the
    well-known **Travel Salesman Problem** (**TSP**). In this problem, you have a
    set of cities and the distances between them, and you want to find an optimal
    route to go through all the cities minimizing the total distance of the travel.
    As per other examples, we have implemented a serial version and a concurrent one
    using the `Phaser` class. The main characteristics of a genetic algorithm applied
    to the TSP problems are:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个遗传算法来解决著名的**旅行推销员问题**（**TSP**）。在这个问题中，您有一组城市和它们之间的距离，您希望找到一条最佳路线，穿过所有城市并最小化旅行的总距离。与其他示例一样，我们实现了一个串行版本和一个并发版本，使用了`Phaser`类。应用于TSP问题的遗传算法的主要特征是：
- en: '**Individuals**: An individual represents the traversal order of the cities.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**个体**：个体表示城市的遍历顺序。'
- en: '**Crossover**: You have to create valid solutions after the crossover operation.
    You must visit each city only once.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交叉**：在交叉操作之后，您必须创建有效的解决方案。您必须只访问每个城市一次。'
- en: '**Fitness function**: The main objective of the algorithm is to minimize the
    total distance to travel across the cities.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适应度函数**：算法的主要目标是最小化穿过城市的总距离。'
- en: '**Finish criteria**: We are going to execute the algorithm a predefined number
    of generations.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成标准**：我们将执行预定义数量的世代算法。'
- en: 'For example, you can have a distance matrix with four cities as shown in the
    following table:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以有一个包含四个城市的距离矩阵，如下表所示：
- en: '|   | City 1 | City 2 | City 3 | City 4 |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|   | 城市1 | 城市2 | 城市3 | 城市4 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **City 1** | 0 | 11 | 6 | 9 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| **城市1** | 0 | 11 | 6 | 9 |'
- en: '| **City 2** | 7 | 0 | 8 | 2 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **城市2** | 7 | 0 | 8 | 2 |'
- en: '| **City 3** | 7 | 3 | 0 | 3 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **城市3** | 7 | 3 | 0 | 3 |'
- en: '| **City 4** | 10 | 9 | 4 | 0 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **城市4** | 10 | 9 | 4 | 0 |'
- en: This means that the distance between city 2 and city 1 is 7, but the distance
    between city 1 and city 2 is 11\. An individual can be (2,4,3,1) and its fitness
    function is the sum of the distances between 2 and 4, 4 and 3, 3 and 1, and 1
    and 2, that is, 2+4+7+11=24.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着城市2和城市1之间的距离是7，但城市1和城市2之间的距离是11。一个个体可以是（2,4,3,1），其适应度函数是2和4之间的距离、4和3之间的距离、3和1之间的距离以及1和2之间的距离的总和，即2+4+7+11=24。
- en: If you want to make the crossover between the individuals (1,2,3,4) and (1,3,2,4),
    you can't generate the individual (1,2,2,4) because you are visiting the city
    2 twice. You can generate the individuals (1,2,4,3) and (1,3,4,2).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在个体（1,2,3,4）和（1,3,2,4）之间进行交叉，您不能生成个体（1,2,2,4），因为您访问了城市2两次。您可以生成个体（1,2,4,3）和（1,3,4,2）。
- en: To test the algorithm, we have used two examples of the **City Distance Datasets**
    ([http://people.sc.fsu.edu/~jburkardt/datasets/cities/cities.html](http://people.sc.fsu.edu/~jburkardt/datasets/cities/cities.html))
    with 15 (`lau15_dist`) and 57 (`kn57_dist`) cities, respectively.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试算法，我们使用了两个**城市距离数据集**的例子（[http://people.sc.fsu.edu/~jburkardt/datasets/cities/cities.html](http://people.sc.fsu.edu/~jburkardt/datasets/cities/cities.html)），分别为15个城市（`lau15_dist`）和57个城市（`kn57_dist`）。
- en: Common classes
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见类
- en: 'Both versions use the following three common classes:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 两个版本都使用以下三个常见类：
- en: The `DataLoader` class that loads the distance matrix from a file. We don't
    include the code of this class here. It has a static method that receives the
    name of the file and returns an `int[][]` matrix with the distances between the
    cities. The distances are stored in a csv file (we have made a little transformation
    in the original format), so it's easy to make the conversion.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataLoader`类从文件加载距离矩阵。我们不在这里包括该类的代码。它有一个静态方法，接收文件名并返回一个`int[][]`矩阵，其中存储了城市之间的距离。距离存储在csv文件中（我们对原始格式进行了一些小的转换），因此很容易进行转换。'
- en: The `Individual` class stores the information of an individual of the population
    (a possible solution to the problem). To represent each individual, we have chosen
    an array of integer values that stores the order in which you visit the different
    cities.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Individual`类存储种群中个体的信息（问题的可能解决方案）。为了表示每个个体，我们选择了一个整数值数组，它存储您访问不同城市的顺序。'
- en: The `GeneticOperators` class implements the crossover, selection and evaluation
    of the population or an individual.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GeneticOperators`类实现了种群或个体的交叉、选择和评估。'
- en: Let's see the details of the `Individual` and `GeneticOperators` classes.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Individual`和`GeneticOperators`类的详细信息。
- en: The Individual class
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 个体类
- en: 'This class stores each possible solution to our TSP problem. We call each possible
    solution, an individual, and its representation chromosomes. In our case, we represent
    each possible solution as an array of integers. That array contains the order
    in which our salesman will go through the cities. This class also has an integer
    value to store the result of the fitness function. We have the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类存储了我们TSP问题的每个可能解。我们称每个可能解为一个个体，它的表示是染色体。在我们的情况下，我们将每个可能解表示为一个整数数组。该数组包含推销员访问城市的顺序。这个类还有一个整数值来存储适应函数的结果。我们有以下代码：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We have included two constructors. The first one receives the number of cities
    you must visit, and we create an empty array. The other receives an `Individual`
    object and copies its chromosomes as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括了两个构造函数。第一个接收你必须访问的城市数量，然后创建一个空数组。另一个接收一个`Individual`对象，并将其染色体复制如下：
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We have also implemented the `compareTo()` method to compare two individuals
    using the result of the fitness function:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还实现了`compareTo()`方法，使用适应函数的结果来比较两个个体：
- en: '[PRE29]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Finally, we have included methods to get and set the values of the attributes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经包括了获取和设置属性值的方法。
- en: The GeneticOperators class
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遗传算法操作类
- en: This is a complex class because it implements the internal logic of the genetic
    algorithm. It provides methods to make the initialization, selection, crossover,
    and evaluation operations as were introduced at the beginning of this section.
    We are going to describe only the methods provided by this class, but not how
    they are implemented to avoid your unnecessary complexity. You can get the source
    code of the example to analyze the implementation of the methods.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个复杂的类，因为它实现了遗传算法的内部逻辑。它提供了初始化、选择、交叉和评估操作的方法，就像在本节开头介绍的那样。我们只描述了这个类提供的方法，而没有描述它们是如何实现的，以避免不必要的复杂性。你可以获取示例的源代码来分析这些方法的实现。
- en: 'The methods provided by this class are:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供的方法有：
- en: '`initialize(int numberOfIndividuals, int size)`: This creates a new population.
    The number of individuals of that population will be determined by the `numberOfIndividuals`
    parameter. The number of chromosomes (cities in our case) will be determined by
    the size parameter. It returns an array of `Individual` objects. It uses the method
    initialize(`Integer[]`) to initialize each Individual.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialize(int numberOfIndividuals, int size)`: 这将创建一个新的种群。种群的个体数量将由`numberOfIndividuals`参数确定。染色体的数量（在我们的情况下是城市）将由大小参数确定。它返回一个`Individual`对象的数组。它使用初始化方法(`Integer[]`)来初始化每个个体。'
- en: '`initialize(Integer[] chromosomes)`: It initializes the chromosomes of an individual
    in a random way. It generates valid individuals (you have to visit each city only
    once).'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialize(Integer[] chromosomes)`: 它以随机方式初始化个体的染色体。它生成有效的个体（你必须只访问每个城市一次）。'
- en: '`selection(Individual[] population)`: This method implements the selection
    operation to get the best individuals of a population. It returns that individuals
    in an array. The size of that array will be the half of the population size. You
    can test other criteria to determine the number of the selected individuals. We
    select the individuals with the best fit function.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selection(Individual[] population)`: 这个方法实现了选择操作，以获取种群中最好的个体。它以一个数组的形式返回这些个体。数组的大小将是种群大小的一半。你可以测试其他标准来确定选择的个体数量。我们选择适应函数最好的个体。'
- en: '`crossover(Individual[] selected, int numberOfIndividuals, int size)`: This
    method receives the selected individuals of a generation as a parameter and generates
    the population of the next generation using the crossover operation. The number
    of individuals of the next generation will be determined by the parameter of the
    same name. The number of chromosomes of each individual will be determined by
    the size parameter. It uses the method crossover (`Individual`, `Individual`,
    `Individual`, `Individual`) to generate two new individuals from two selected
    ones.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crossover(Individual[] selected, int numberOfIndividuals, int size)`: 这个方法接收上一代选择的个体作为参数，并使用交叉操作生成下一代的种群。下一代的个体数量将由同名的参数确定。每个个体的染色体数量将由大小参数确定。它使用交叉方法(`Individual`,
    `Individual`, `Individual`, `Individual`)从两个选择的个体生成两个新的个体。'
- en: '`crossover(Individual parent1, Individual parent2, Individual individual1,
    Individual individual2)`: This method performs the crossover operation taking
    the `parent1` and `parent2` individuals to generate the `individual1` and `individual2`
    individuals of the next generation.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crossover(Individual parent1, Individual parent2, Individual individual1,
    Individual individual2)`: 这个方法执行交叉操作，以获取`parent1`和`parent2`个体生成下一代的`individual1`和`individual2`个体。'
- en: '`evaluate(Individual[] population, int [][] distanceMatrix)`: This applies
    the fitness function to all the individuals of the population using the distance
    matrix it receives as a parameter. Finally, it sorts the population from the best
    to worst solution. It uses the method evaluate (`Individual`, `int[][]`) to evaluate
    each individual.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`evaluate(Individual[] population, int [][] distanceMatrix)`: 这将使用接收的距离矩阵对种群中的所有个体应用适应函数。最后，它将种群从最佳到最差的解进行排序。它使用评估方法(`Individual`,
    `int[][]`)来评估每个个体。'
- en: '`evaluate(Individual individual, int[][] distanceMatrix)`: This applies the
    fitness function to one individual.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`evaluate(Individual individual, int[][] distanceMatrix)`: 这将适用于一个个体的适应函数。'
- en: With this class and its methods, you have all you need to implement a genetic
    algorithm to solve the TSP problem.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个类和它的方法，你就有了实现解决TSP问题的遗传算法所需的一切。
- en: The serial version
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 串行版本
- en: 'We have implemented the serial version of the algorithm with the following
    two classes:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下两个类实现了算法的串行版本：
- en: The `SerialGeneticAlgorithm` class that implements the algorithm
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现算法的`SerialGeneticAlgorithm`类
- en: The `SerialMain` class that executes the algorithm with the input parameters
    and measures the execution time
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SerialMain`类执行算法，并测量执行时间'
- en: Let's analyze both classes in detail.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析这两个类。
- en: The SerialGeneticAlgorithm class
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SerialGeneticAlgorithm类
- en: 'This class implements the serial version of our genetic algorithm. Internally,
    it uses the following four attributes:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了我们遗传算法的串行版本。在内部，它使用以下四个属性：
- en: The distance matrix with the distances between all the cities
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含所有城市之间距离的距离矩阵
- en: The number of generations
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代的数量
- en: The number of individuals in the population
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 种群中的个体数
- en: The number of chromosomes in each individual
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个个体中的染色体数
- en: 'The class also has a constructor to initialize all the attributes:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还有一个构造函数来初始化所有属性：
- en: '[PRE30]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The main method of the class is the `calculate()` method. First, use the `initialize()`
    method to create the initial population. Then, evaluate the initial population
    and get its best individual as the first solution of the algorithm:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的主要方法是`calculate()`方法。首先，使用`initialize()`方法创建初始种群。然后，评估初始种群，并将其最佳个体作为算法的第一个解决方案：
- en: '[PRE31]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, it executes a loop determined by the `numberOfGenerations` attribute.
    In each cycle, it uses the `selection()` method to obtain the selected individuals,
    use the `crossover()` method to calculate the next generation, evaluate this new
    generation, and if the best solution of the new generation is better than the
    best individual until now, we replace it. When the loop finishes, we return the
    best individual as the solution proposed by the algorithm:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它执行一个由`numberOfGenerations`属性确定的循环。在每个周期中，它使用`selection()`方法获取选定的个体，使用`crossover()`方法计算下一代，评估这个新一代，并且如果新一代的最佳解决方案比到目前为止的最佳个体更好，我们就替换它。当循环结束时，我们将最佳个体作为算法提出的解决方案返回：
- en: '[PRE32]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The SerialMain class
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SerialMain类
- en: This class executes the genetic algorithm for the two datasets used in this
    section—the `lau15` with 15 cities and the `kn57` with 57 cities.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 该类为本节中使用的两个数据集执行遗传算法——包含15个城市的`lau15`和包含57个城市的`kn57`。
- en: 'The `main()` method must receive two parameters. The first one is the number
    of generations we want to create, and the second parameter is the number of individuals
    we want to have in each generation:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`方法必须接收两个参数。第一个是我们想要创建的代数，第二个参数是我们想要每一代中拥有的个体数：'
- en: '[PRE33]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For each example, we load the distance matrix using the `load()` method of
    the `DataLoader` class, create the `SerialGeneticAlgorith` object, execute the
    `calculate()` method measuring the execution time, and write the execution time
    and the result in the console:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个示例，我们使用`DataLoader`类的`load()`方法加载距离矩阵，创建`SerialGeneticAlgorith`对象，执行`calculate()`方法并测量执行时间，并将执行时间和结果写入控制台：
- en: '[PRE34]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The concurrent version
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发版本
- en: 'We have implemented the concurrent version of the genetic algorithm different
    classes:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了遗传算法的并发版本不同的类：
- en: The `SharedData` class stores all the objects that will be shared between the
    tasks
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SharedData`类存储所有任务之间共享的对象'
- en: The `GeneticPhaser` class extends the `Phaser` class and overrides its `onAdvance()`
    method to execute code when all the tasks finish a phase
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GeneticPhaser`类扩展了`Phaser`类，并覆盖了它的`onAdvance()`方法，以在所有任务完成一个阶段时执行代码'
- en: The `ConcurrentGeneticTask` class implements the tasks that will implement the
    phases of the genetic algorithm
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentGeneticTask`类实现了遗传算法阶段的任务'
- en: The `ConcurrentGeneticAlgorithm` class will implement the concurrent version
    of the genetic algorithm using the previous classes
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentGeneticAlgorithm`类将使用前面的类实现遗传算法的并发版本'
- en: The `ConcurrentMain` class will test the concurrent version of the genetic algorithm
    in our two datasets
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentMain`类将在我们的两个数据集中测试遗传算法的并发版本'
- en: Internally, the `ConcurrentGeneticTask` class will execute three phases. The
    first one is the selection phase and will only be executed by one task. The second
    one is the crossover phase where all the tasks will construct the new generation
    using the selected individuals, and the last phase is the evaluation phase where
    all the tasks will evaluate the individuals of the new generation.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`ConcurrentGeneticTask`类将执行三个阶段。第一个阶段是选择阶段，只有一个任务执行。第二个阶段是交叉阶段，所有任务将使用选定的个体构建新一代，最后一个阶段是评估阶段，所有任务将评估新一代的个体。
- en: Let's see in detail each of those classes.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这些类中的每一个。
- en: The SharedData class
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SharedData类
- en: 'As we mentioned before, this class contains all the objects shared by the tasks.
    This include the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，这个类包含了所有任务共享的对象。这包括以下内容：
- en: The population array with all the individuals of a generation.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 种群数组，包含一代中的所有个体。
- en: The selected array with the selected individuals.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选定的数组与选定的个体。
- en: An atomic integer called `index`. This is the only thread-safe object used to
    know the index of the individual a task has to generate or process.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`index`的原子整数。这是唯一的线程安全对象，用于知道任务必须生成或处理的个体的索引。
- en: The best individual of all the generations that will be returned as the solution
    of the algorithm.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有代中的最佳个体将作为算法的解决方案返回。
- en: The distance matrix with the distances between the cities.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含城市之间距离的距离矩阵。
- en: 'All these objects will be shared by all the threads, but we only need to use
    one concurrent data structure. This is the only attribute that will be effectively
    shared by all the tasks. The rest of the objects will be only read (the distance
    matrix), or each task will access a different part of the object (the population
    and selected arrays), so we don''t need to use concurrent data structures or synchronization
    mechanisms to avoid race conditions:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些对象将被所有线程共享，但我们只需要使用一个并发数据结构。这是唯一一个有效被所有任务共享的属性。其余的对象将只被读取（距离矩阵），或者每个任务将访问对象的不同部分（种群和选定的数组），因此我们不需要使用并发数据结构或同步机制来避免竞争条件：
- en: '[PRE35]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This class also includes the getters and setters to get and establish the values
    of these attributes.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还包括获取器和设置器，用于获取和建立这些属性的值。
- en: The GeneticPhaser class
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GeneticPhaser类
- en: 'We need to execute code on the phase changes of our tasks, so we have to implement
    our own phaser and override the `onAdvance()` method that is executed after all
    the parties have finished a phase and before they begin the execution of the next
    one. The `GeneticPhaser` class implements this phaser. It stores the `SharedData`
    object to work with it and receives it as a parameter to the constructor:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在任务的阶段变化时执行代码，因此我们必须实现自己的阶段器并重写`onAdvance()`方法，该方法在所有参与方完成一个阶段之后执行，然后开始执行下一个阶段。`GeneticPhaser`类实现了这个阶段器。它存储`SharedData`对象以便与其一起工作，并将其作为构造函数的参数接收：
- en: '[PRE36]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `onAdvance()` method will receive the number of the phase to the phaser
    and the number of registered parties as parameters. The phaser internally stores
    the number of the phase as an integer that grows sequentially with every change
    of phase. On the contrary, our algorithm has only three phases that will be executed
    a lot of times. We have to convert the phaser phase number to the genetic algorithm
    phase number to know if the tasks are going to execute the selection, crossover,
    or evaluation phases. To do this, we calculate the remainder between the phase
    number of the phaser and three as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`onAdvance()`方法将接收阶段器的阶段号和注册方的数量作为参数。阶段器内部将阶段号作为整数存储，随着每次阶段变化而递增。相反，我们的算法只有三个阶段，将被执行很多次。我们必须将阶段器的阶段号转换为遗传算法的阶段号，以了解任务是否将执行选择、交叉或评估阶段。为此，我们计算阶段器阶段号除以三的余数，如下所示：'
- en: '[PRE37]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the remainder is zero, the tasks have finished the selection phase and are
    going to execute the crossover phase. We initialize the index object with the
    value zero.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果余数为零，则任务已经完成了选择阶段，并将执行交叉阶段。我们用值零初始化索引对象。
- en: If the remainder is one, the tasks have finished the crossover phase and are
    going to execute the evaluation phase. We initialize the index object with the
    value zero.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果余数为一，则任务已经完成了交叉阶段，并将执行评估阶段。我们用值零初始化索引对象。
- en: Finally, if the remainder is two, the tasks have finished the evaluation phase
    and are going to start again with the selection phase. We sort the population
    based on the fitness function and update if necessary the best individual.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果余数为二，则任务已经完成了评估阶段，并将重新开始选择阶段。我们根据适应度函数对种群进行排序，并在必要时更新最佳个体。
- en: Take into account that this method will only be executed by one thread independently
    of the tasks. It will be executed in the thread of the task, which was the last
    to finish the previous phase (inside the `arriveAndAwaitAdvance()` call). The
    rest of the tasks will be sleeping and waiting for the phaser.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个方法只会由一个线程执行，与任务无关。它将在任务的线程中执行，这个任务是最后完成上一个阶段的（在`arriveAndAwaitAdvance()`调用中）。其余的任务将处于睡眠状态，等待阶段器。
- en: The ConcurrentGeneticTask class
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ConcurrentGeneticTask类
- en: This class implements the tasks that collaborate to execute the genetic algorithm.
    They execute the three phases (selection, crossover, and evaluation) of the algorithm.
    The selection phase will be executed by only one task (we called it the main task)
    while the rest of the phases will be executed by all the tasks.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了协作执行遗传算法的任务。它们执行算法的三个阶段（选择、交叉和评估）。选择阶段将只由一个任务执行（我们称之为主任务），而其余的阶段将由所有任务执行。
- en: 'Internally, it uses four attributes:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，它使用了四个属性：
- en: A `GeneticPhaser` object to synchronize the tasks at the end of each phase
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`GeneticPhaser`对象，用于在每个阶段结束时同步任务
- en: A `SharedData` object to access the shared data
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`SharedData`对象来访问共享数据
- en: The number of generations it has to calculate
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须计算的代数
- en: The Boolean flag that indicates whether it is the main task or not
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指示是否为主任务的布尔标志
- en: 'All these attributes are initialized in the constructor of the class:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些属性都在类的构造函数中初始化：
- en: '[PRE38]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `run()` method implements the logic of the genetic algorithm. It has a
    loop to generate the specified generations. As we mentioned before, only the main
    task will execute the selection phase. The rests of the tasks will use the `arriveAndAwaitAdvance()`
    method to wait for the finalization of this phase. Refer to the following code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()`方法实现了遗传算法的逻辑。它有一个循环来生成指定的代数。正如我们之前提到的，只有主任务才会执行选择阶段。其余的任务将使用`arriveAndAwaitAdvance()`方法等待此阶段的完成。参考以下代码：'
- en: '[PRE39]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The second phase is the crossover phase. We use the `AtomicInteger` variable
    index stored in the `SharedData` class to get the next position in the population
    array each task will calculate. As we mentioned before, the crossover operation
    generates two new individuals, so each task first reserves two positions in the
    population array. For this purpose, we use the `getAndAdd(2)` method that returns
    the actual value of the variable and increments its value by two units. It''s
    an atomic variable, so we don''t have to use any synchronization mechanism. It''s
    inherent to the atomic variables. Refer to the following code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段是交叉阶段。我们使用`SharedData`类中存储的`AtomicInteger`变量索引来获取每个任务将计算的种群数组中的下一个位置。正如我们之前提到的，交叉操作会生成两个新个体，因此每个任务首先在种群数组中保留两个位置。为此，我们使用`getAndAdd(2)`方法，它返回变量的实际值并将其值增加两个单位。它是一个原子变量，因此我们不需要使用任何同步机制。这是原子变量固有的。参考以下代码：
- en: '[PRE40]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When all the individuals of the new population have been generated, the tasks
    use the `arriveAndAwaitAdvance()` method to synchronize the end of the phase.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当新种群的所有个体都生成时，任务使用`arriveAndAwaitAdvance()`方法来同步阶段的结束。
- en: 'The last phase is the evaluation phase. We use the `AtomicInteger` index again.
    Each task gets the actual value of the variable, which represents the position
    of an individual in the population, and increments its value using the `getAndIncrement()`
    value. Once all the individuals have been evaluated, we use the `arriveAndAwaitAdvance()`
    method to synchronize the end of this phase. Remember that, when all the tasks
    have finished this phase, the `GeneticPhaser` class will execute the code that
    sorts the population array and updates, if necessary, the best individual variable
    as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个阶段是评估阶段。我们再次使用`AtomicInteger`索引。每个任务都会得到变量的实际值，该值代表种群中个体的位置，并使用`getAndIncrement()`方法递增其值。一旦所有个体都被评估，我们使用`arriveAndAwaitAdvance()`方法来同步这个阶段的结束。请记住，当所有任务都完成了这个阶段时，`GeneticPhaser`类将执行对种群数组的排序，并根据需要更新最佳个体变量，如下所示：
- en: '[PRE41]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Finally, when all the generations have been calculated, the tasks use the `arriveAndDeregister()`
    method to indicate the end of its execution, so the phaser will enter in its finalization
    state.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当所有代数都被计算时，任务使用`arriveAndDeregister()`方法来指示其执行的结束，因此phaser将进入最终状态。
- en: The ConcurrentGeneticAlgorithm class
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ConcurrentGeneticAlgorithm类
- en: 'This class is the external interface of the genetic algorithm. Internally,
    it creates, starts, and waits for the finalization of the tasks that calculate
    the different generations. It uses four attributes: the number of generations,
    the number of individuals in each generation, the number of chromosomes of each
    individual, and the distance matrix as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是遗传算法的外部接口。在内部，它创建、启动并等待计算不同代数的任务的完成。它使用四个属性：代数的数量、每一代中个体的数量、每个个体的染色体数量和距离矩阵，如下所示：
- en: '[PRE42]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `calculate()` method executes the genetic algorithm and returns the best
    individual. First, it creates the initial population using the `initialize()`
    method, evaluates that population, and creates and initialize a `SharedData` object
    with all the necessary data as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculate()`方法执行遗传算法并返回最佳个体。首先，它使用`initialize()`方法创建初始种群，评估该种群，并创建和初始化一个带有所有必要数据的`SharedData`对象，如下所示：'
- en: '[PRE43]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, it creates the tasks. We use the number of available hardware threads
    of the computer, returned by the method `availableProcessors()` of the `Runtime`
    class as the number of tasks we are going to create. We also create a `GeneticPhaser`
    object to synchronize the execution of those tasks as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它创建任务。我们使用计算机的可用硬件线程数，该数由`Runtime`类的`availableProcessors()`方法返回，作为我们将要创建的任务数。我们还创建了一个`GeneticPhaser`对象来同步这些任务的执行，如下所示：
- en: '[PRE44]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, we create the `Thread` objects to execute the tasks, start them, and
    wait for their finalization. Finally, we return the best individual stored in
    the `ShareData` object as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建`Thread`对象来执行任务，启动它们，并等待它们的完成。最后，我们返回存储在`ShareData`对象中的最佳个体，如下所示：
- en: '[PRE45]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The ConcurrentMain class
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ConcurrentMain类
- en: This class executes the genetic algorithm for the two datasets used in this
    section—the `lau15` with 15 cities and the `kn57` with 57 cities. Its code is
    analogous to the `SerialMain` class, but using the `ConcurrentGeneticAlgorithm`
    instead of `SerialGeneticAlgorithm`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类执行了遗传算法，用于本节中使用的两个数据集——有15个城市的`lau15`和有57个城市的`kn57`。它的代码类似于`SerialMain`类，但是使用`ConcurrentGeneticAlgorithm`代替`SerialGeneticAlgorithm`。
- en: Comparing the two solutions
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较两种解决方案
- en: Now it's time to test both solutions and see which of them has the better performance.
    As we mentioned before, we have used two datasets from the City Distance Datasets
    ([http://people.sc.fsu.edu/~jburkardt/datasets/cities/cities.html](http://people.sc.fsu.edu/~jburkardt/datasets/cities/cities.html))—the
    `lau15` with 15 cities and the `kn57` with 57 cities. We also have tested different
    sizes for the population (100, 1,000, and 10,000 individuals) and the different
    number of generations (10, 100, and 1,000). To test the algorithm, we have executed
    the examples using the JMH framework ([http://openjdk.java.net/projects/code-tools/jmh/](http://openjdk.java.net/projects/code-tools/jmh/))
    that allows you to implement micro benchmarks in Java. Using a framework for benchmarking
    is a better solution that simply measures time using such methods as `currentTimeMillis()`
    or `nanoTime()`. We have executed them 10 times on a computer with a four-core
    processor and calculated the medium execution time of those 10 times.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候测试两种解决方案，看看它们哪个性能更好。正如我们之前提到的，我们使用了城市距离数据集（[http://people.sc.fsu.edu/~jburkardt/datasets/cities/cities.html](http://people.sc.fsu.edu/~jburkardt/datasets/cities/cities.html)）中的两个数据集——有15个城市的`lau15`和有57个城市的`kn57`。我们还测试了不同规模的种群（100、1,000和10,000个个体）和不同代数的数量（10、100和1,000）。为了测试算法，我们使用了JMH框架（[http://openjdk.java.net/projects/code-tools/jmh/](http://openjdk.java.net/projects/code-tools/jmh/)），它允许您在Java中实现微基准测试。使用基准测试框架比简单地使用`currentTimeMillis()`或`nanoTime()`等方法来测量时间更好。我们在一个四核处理器的计算机上执行了10次，并计算了这10次的中间执行时间。
- en: The Lau15 dataset
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lau15数据集
- en: 'The execution times (in milliseconds) for the first dataset are:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数据集的执行时间（毫秒）为：
- en: '|   | Population |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '|   | 人口 |'
- en: '| --- | --- |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|   | **100** | **1,000** | **10,000** |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '|   | **100** | **1,000** | **10,000** |'
- en: '| **Generations** | **Serial** | **Concurrent** | **Serial** | **Concurrent**
    | **Serial** | **Concurrent** |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: 代数 | 串行 | 并发 | 串行 | 并发 | 串行 | 并发 |
- en: '| **10** | 8.42 | 13.309 | 30.783 | 36.395 | 182.213 | 99.728 |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| **10** | 8.42 | 13.309 | 30.783 | 36.395 | 182.213 | 99.728 |'
- en: '| **100** | 25.848 | 29.292 | 135.562 | 69.257 | 1488.457 | 688.840 |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| **100** | 25.848 | 29.292 | 135.562 | 69.257 | 1488.457 | 688.840 |'
- en: '| **1,000** | 117.929 | 71.771 | 1134.983 | 420.145 | 11810.518 | 4102.72 |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| **1,000** | 117.929 | 71.771 | 1134.983 | 420.145 | 11810.518 | 4102.72 |'
- en: The Kn57 dataset
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kn57数据集
- en: 'The execution times (in milliseconds) for the second dataset are:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个数据集的执行时间（毫秒）为：
- en: '|   | Population |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '|   | 人口 |'
- en: '| --- | --- |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|   | **100** | **1,000** | **10,000** |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '|   | **100** | **1,000** | **10,000** |'
- en: '| **Generations** | **Serial** | **Concurrent** | **Serial** | **Concurrent**
    | **Serial** | **Concurrent** |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| **Generations** | **Serial** | **Concurrent** | **Serial** | **Concurrent**
    | **Serial** | **Concurrent** |'
- en: '| **10** | 19.205 | 22.246 | 80.509 | 63.370 | 758.235 | 300.669 |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| **10** | 19.205 | 22.246 | 80.509 | 63.370 | 758.235 | 300.669 |'
- en: '| **100** | 75.129 | 63.815 | 680.548 | 225.393 | 7406.392 | 2561.219 |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| **100** | 75.129 | 63.815 | 680.548 | 225.393 | 7406.392 | 2561.219 |'
- en: '| **1,000** | 676.390 | 243.572 | 6796.780 | 2159.124 | 75315.885 | 26825.115
    |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| **1,000** | 676.390 | 243.572 | 6796.780 | 2159.124 | 75315.885 | 26825.115
    |'
- en: Conclusions
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'The behavior of the algorithms is similar to both datasets. You can see that
    as we have a low number of individuals and generations the serial versions of
    the algorithm have better execution times, but when the number of individuals
    or the number of generations grow, the concurrent version has a better throughput.
    For example, for the `kn57` dataset with 1,000 generations and 10,000 individuals
    the speed-up is:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的行为与两个数据集相似。您可以看到，当个体数量和世代数量较少时，算法的串行版本具有更好的执行时间，但是当个体数量或世代数量增加时，并发版本具有更好的吞吐量。例如，对于包含1,000代和10,000个体的`kn57`数据集，加速比为：
- en: '![Conclusions](img/00016.jpeg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![结论](img/00016.jpeg)'
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we explained one of the most powerful synchronization mechanisms
    provided by the Java concurrency API: the phaser. Its main objective is to provide
    synchronization between tasks that execute algorithms divided into phases. None
    of the tasks can begin the execution of a phase before the rest of the tasks have
    finished the previous one.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了Java并发API提供的最强大的同步机制之一：phaser。其主要目标是在执行分阶段算法的任务之间提供同步。在其余任务完成前，没有一个任务可以开始执行下一个阶段。
- en: The phaser has to know how many tasks have to be synchronized. You have to register
    your tasks in the phaser using the constructor, the `bulkRegister()` method or
    the `register()` method.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Phaser必须知道有多少任务需要同步。您必须使用构造函数、`bulkRegister()`方法或`register()`方法在phaser中注册您的任务。
- en: Tasks can synchronize with the phaser in different ways. The most common are
    indicating to the phaser that it has finished the execution of one phase and wants
    to continue with the next one with the `arriveAndAwaitAdvance()` method. This
    method will sleep the thread until the rest of the tasks have finished the actual
    phase. But there are other methods you can use to synchronize your tasks. The
    method `arrive()` is used to notify to the phaser that you have finished the current
    phase, but you don't wait for the rest of the tasks (be very careful using this
    method). The `arriveAndDeregister()` method is used to notify the phaser that
    you have finished the current phase and you don't want to continue in the phaser
    (normally, because you have finished your job). Finally, the `awaitAdvance()`
    method can be used to wait for the finalization of the current phase.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 任务可以以不同的方式与phaser同步。最常见的是使用`arriveAndAwaitAdvance()`方法通知phaser已经完成一个阶段的执行，并希望继续下一个阶段。此方法将使线程休眠，直到其余任务完成当前阶段。但是还有其他方法可以用来同步您的任务。`arrive()`方法用于通知phaser您已经完成当前阶段，但不等待其余任务（使用此方法时要非常小心）。`arriveAndDeregister()`方法用于通知phaser您已经完成当前阶段，并且不希望继续在phaser中（通常是因为您已经完成了工作）。最后，`awaitAdvance()`方法可用于等待当前阶段的完成。
- en: You can control the phase change and execute code after all the tasks have finished
    the current phase and before they start the new one using the `onAdvance()` method.
    This method is called between the executions of two phases and receives as parameters
    the number of the phase and the number of participants in the phaser. You can
    extend the `Phaser` class and override this method to execute code between two
    phases.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`onAdvance()`方法控制相位变化，并在所有任务完成当前阶段并开始新阶段之前执行代码。此方法在两个阶段的执行之间调用，并接收相位编号和相位中参与者的数量作为参数。您可以扩展`Phaser`类并覆盖此方法以在两个阶段之间执行代码。
- en: 'A phaser can be in two states: active, when it is synchronizing tasks and in
    the termination state, when it has finished its job. A phaser will enter in the
    termination state when all the participants call the `arriveAndDeregister()` method
    or when the `onAdvance()` method returns the `true` value (by default, it always
    return `false`). When a `Phaser` class is in the termination state, it won''t
    accept new participants and the synchronization methods will always return immediately.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Phaser可以处于两种状态：活动状态，当它正在同步任务时；终止状态，当它完成了其工作时。当所有参与者调用`arriveAndDeregister()`方法或`onAdvance()`方法返回`true`值时（默认情况下，它总是返回`false`），Phaser将进入终止状态。当`Phaser`类处于终止状态时，它将不再接受新的参与者，并且同步方法将立即返回。
- en: 'We used the `Phaser` class to implement two algorithms: a keyword extraction
    algorithm and a genetic algorithm. In both cases, we got an important increase
    of throughput against the serial version of those algorithms.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Phaser`类来实现两种算法：关键词提取算法和遗传算法。在这两种情况下，我们都得到了与这些算法的串行版本相比的重要吞吐量增加。
- en: In the next chapter, you will learn how to use another Java concurrency framework
    to solve special kind of problems. It's the Fork/Join framework, which has been
    developed to execute in a concurrent way those problems that can be solved using
    the divide and conquer algorithm. It's based in an executor with a special work-stealing
    algorithm that maximizes the performance of the executor.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何使用另一个Java并发框架来解决特殊类型的问题。这就是Fork/Join框架，它已经被开发出来以并发方式执行那些可以使用分而治之算法解决的问题。它基于具有特殊工作窃取算法的执行程序，以最大化执行程序的性能。
