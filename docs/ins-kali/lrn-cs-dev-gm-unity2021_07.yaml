- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Movement, Camera Controls, and Collisions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动、摄像机控制和碰撞
- en: One of the first things a player does when starting a new game is to try out
    character movement (if, of course, the game has a moveable character) and camera
    controls. Not only is this exciting, but it lets your player know what kind of
    gameplay they can expect. The character in *Hero Born* will be a capsule object
    that can be moved and rotated using the `W`, `A`, `S`, `D`, or arrow keys, respectively.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家开始新游戏时，首先要做的事情之一就是尝试角色移动（当然，如果游戏有可移动的角色），以及摄像机控制。这不仅令人兴奋，而且让你的玩家知道他们可以期待什么样的游戏玩法。*Hero
    Born*中的角色将是一个可以使用`W`、`A`、`S`、`D`或箭头键分别移动和旋转的胶囊体对象。
- en: We'll start by learning how to manipulate the player object's `Transform` component
    and then replicate the same player control scheme using applied force. This produces
    a more realistic movement effect. When we move the player, the camera will follow
    along from a position that is slightly behind and above the player, making aiming
    easier when we implement the shooting mechanic. Finally, we'll explore how collisions
    and physical interactions are handled by Unity's physics system by working with
    our item pickup Prefab.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习如何操作玩家对象的`Transform`组件，然后使用施加的力复制相同的玩家控制方案。这会产生更真实的移动效果。当我们移动玩家时，摄像机将从稍微在玩家后面和上方的位置跟随，这样在实现射击机制时瞄准会更容易。最后，我们将通过使用物品拾取预制件来探索Unity物理系统如何处理碰撞和物理交互。
- en: 'All of this will come together at a playable level, albeit without any shooting
    mechanics just yet. It''s also going to give us our first taste of C# being used
    to program game features by tying together the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些将在可玩的水平上汇聚在一起，尽管目前还没有任何射击机制。这也将让我们初次尝试使用C#来编写游戏功能，将以下主题联系在一起：
- en: Managing player movement
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理玩家移动
- en: Moving the player with the `Transform` component
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Transform`组件移动玩家
- en: Scripting camera behavior
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写摄像机行为
- en: Working with the Unity physics system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Unity物理系统。
- en: Managing player movement
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理玩家移动
- en: When you're deciding on how best to move your player character around your virtual
    world, consider what's going to look the most realistic and not run your game
    into the ground with expensive computations. This is somewhat of a trade-off in
    most cases, and Unity is no different.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当你决定如何最好地在虚拟世界中移动你的玩家角色时，请考虑什么看起来最真实，而不会因昂贵的计算而使游戏陷入困境。在大多数情况下，这在某种程度上是一种权衡，Unity也不例外。
- en: 'The three most common ways of moving a `GameObject` and their results are as
    follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 移动`GameObject`的三种最常见方式及其结果如下：
- en: '**Option A**: Use a `GameObject`''s `Transform` component for movement and
    rotation. This is the easiest solution and the one we''ll be working with first.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项A**：使用`GameObject`的`Transform`组件进行移动和旋转。这是最简单的解决方案，也是我们首先要使用的解决方案。'
- en: '**Option B**: Use real-world physics by attaching a **Rigidbody** component
    to a `GameObject` and apply force in code. `Rigidbody` components add simulated
    real-world physics to any `GameObject` they are attached to. This solution relies
    on Unity''s physics system to do the heavy lifting, delivering a far more realistic
    effect. We''ll update our code to use this approach later on in this chapter to
    get a feel for both methods.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项B**：通过在`GameObject`上附加`Rigidbody`组件并在代码中施加力来使用真实世界的物理。`Rigidbody`组件为其附加的任何`GameObject`添加了模拟的真实世界物理。这种解决方案依赖于Unity的物理系统来进行繁重的工作，从而产生更真实的效果。我们将在本章后面更新我们的代码以使用这种方法，以便了解两种方法的感觉。'
- en: Unity suggests sticking to a consistent approach when moving or rotating a `GameObject`;
    either manipulate an object's `Transform` or `Rigidbody` component, but never
    both at the same time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Unity建议在移动或旋转`GameObject`时坚持一致的方法；要么操作对象的`Transform`组件，要么操作`Rigidbody`组件，但不能同时操作两者。
- en: '**Option C**: Attach a ready-made Unity component or Prefab, such as Character
    Controller or First Person Controller. This cuts out the boilerplate code and
    still delivers a realistic effect while speeding up the prototyping time.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项C**：附加一个现成的Unity组件或预制件，如Character Controller或First Person Controller。这样可以减少样板代码，同时在加快原型设计时间的同时仍提供逼真的效果。'
- en: You can find more information on the Character Controller component and its
    uses at [https://docs.unity3d.com/ScriptReference/CharacterController.html](https://docs.unity3d.com/ScriptReference/CharacterController.html).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.unity3d.com/ScriptReference/CharacterController.html](https://docs.unity3d.com/ScriptReference/CharacterController.html)找到有关Character
    Controller组件及其用途的更多信息。
- en: The First Person Controller Prefab is available from the Standard Assets package,
    which you can download from [https://assetstore.unity.com/packages/essentials/asset-packs/standard-assets-32351](https://assetstore.unity.com/packages/essentials/asset-packs/standard-assets-32351).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一人称控制器预制件可从标准资产包中获得，你可以从[https://assetstore.unity.com/packages/essentials/asset-packs/standard-assets-32351](https://assetstore.unity.com/packages/essentials/asset-packs/standard-assets-32351)下载。
- en: Since you're just getting started with player movement in Unity, you'll start
    off using the player Transform component in the next section, and then move on
    to `Rigidbody` physics later in the chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你刚刚开始在Unity中进行玩家移动，你将在下一节开始使用玩家Transform组件，然后在本章后面转移到`Rigidbody`物理。
- en: Moving the player with the Transform component
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Transform组件移动玩家
- en: We want a third-person adventure setup for *Hero Born*, so we'll start with
    a capsule that can be controlled with keyboard input and a camera to follow the
    capsule as it moves. Even though these two GameObjects will work together in the
    game, we'll keep them and their scripts separate for better control.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望为*Hero Born*创建一个第三人称冒险设置，因此我们将从一个可以通过键盘输入控制的胶囊体和一个可以跟随胶囊体移动的摄像机开始。尽管这两个GameObject将在游戏中一起工作，但我们将它们及其脚本分开以获得更好的控制。
- en: Before we can do any scripting, you'll need to add a player capsule to the scene,
    which is your next task.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行任何脚本编写之前，你需要在场景中添加一个玩家胶囊体，这是你的下一个任务。
- en: 'We can create a nice player capsule in just a few steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在几个步骤中创建一个漂亮的玩家胶囊体：
- en: Click on **+** | **3D Object** | **Capsule** from the **Hierarchy** panel and
    name it `Player`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中单击**+** | **3D对象** | **胶囊**，然后命名为`Player`。
- en: Select the `Player` GameObject and click on **Add Component** at the bottom
    of the **Inspector** tab. Search for **Rigidbody** and hit `Enter` to add it.
    We won't use this component until later, but it's good to set things up properly
    at the beginning.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Player` GameObject，然后在**检视器**选项卡底部单击**添加组件**。搜索**Rigidbody**并按`Enter`添加。我们暂时不会使用这个组件，但是在开始时正确设置东西是很好的。
- en: 'Expand the **Constraints** property at the bottom of the **Rigidbody** component:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**Rigidbody**组件底部的**约束**属性：
- en: Check the boxes for **Freeze Rotation** on the **X**, **Y**, and **Z** axes
    so the player can't be rotated in any way other than through the code we'll write
    later on:![](img/B17573_07_01.png)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 勾选**X**、**Y**和**Z**轴上的**冻结旋转**复选框，以便玩家除了通过我们稍后编写的代码之外不能以任何其他方式旋转：![](img/B17573_07_01.png)
- en: 'Figure 7.1: Rigidbody component'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：刚体组件
- en: Select the `Materials` folder in the **Project** panel and click on **Create**
    | **Material**. Name it `Player_Mat`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中选择`Materials`文件夹，然后单击**创建** | **材质**。命名为`Player_Mat`。
- en: Select `Player_Mat` in the **Hierarchy**, then change the **Albedo** property
    in the **Inspector** to a bright green and drag the material to the **Player**
    object in the **Hierarchy** panel:![](img/B17573_07_02.png)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择`Player_Mat`，然后在**检视器**中更改**反照率**属性为明亮绿色，并将材质拖动到**层次结构**面板中的**Player**对象上：![](img/B17573_07_02.png)
- en: 'Figure 7.2: Player material attached to capsule'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：附加到胶囊的玩家材质
- en: 'You''ve created the **Player** object out of a capsule primitive, a Rigidbody
    component, and a new bright green material. Don''t worry about what the Rigidbody
    component is just yet—all you need to know right now is that it allows our capsule
    to interact with the physics system. We''ll go into more detail at the end of
    this chapter when we discuss how Unity''s physics system works. Before we get
    to that, we need to talk about a very important subject in 3D space: vectors.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经使用胶囊原语、刚体组件和新的明亮绿色材质创建了**Player**对象。现在暂时不用担心刚体组件是什么——您现在需要知道的是它允许我们的胶囊与物理系统互动。在本章末尾讨论Unity的物理系统工作原理时，我们将详细介绍更多内容。在进行这些讨论之前，我们需要谈论3D空间中一个非常重要的主题：向量。
- en: Understanding vectors
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解向量
- en: Now that we have a player capsule and camera set up, we can start looking at
    how to move and rotate a GameObject using its `Transform` component. The `Translate`
    and `Rotate` methods are part of the `Transform` class that Unity provides, and
    each needs a vector parameter to perform its given function.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个玩家胶囊和摄像机设置，我们可以开始看如何使用其`Transform`组件移动和旋转GameObject。`Translate`和`Rotate`方法是Unity提供的`Transform`类的一部分，每个方法都需要一个向量参数来执行其给定的功能。
- en: In Unity, vectors are used to hold position and direction data in 2D and 3D
    spaces, which is why they come in two varieties—`Vector2` and `Vector3`. These
    can be used like any other variable type we've seen; they just hold different
    information. Since our game is in 3D, we'll be using `Vector3` objects, which
    means we'll need to construct them using *x*, *y*, and *z* values.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，向量用于在2D和3D空间中保存位置和方向数据，这就是为什么它们有两种类型——`Vector2`和`Vector3`。这些可以像我们见过的任何其他变量类型一样使用；它们只是保存不同的信息。由于我们的游戏是3D的，我们将使用`Vector3`对象，这意味着我们需要使用*x*、*y*和*z*值来构造它们。
- en: 'For 2D vectors, only the *x* and *y* positions are required. Remember, the
    most up-to-date orientation in your 3D scene will be displayed in the upper-right
    graphic that we discussed in the previous chapter, *Chapter 6*, *Getting Your
    Hands Dirty with Unity*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于2D向量，只需要*x*和*y*位置。请记住，您的3D场景中最新的方向将显示在我们在上一章*第6章*中讨论的右上方图形中：
- en: '![](img/B17573_07_03.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_07_03.png)'
- en: 'Figure 7.3: Vector gizmos in Unity editor'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：Unity编辑器中的向量图标
- en: If you would like more information about vectors in Unity, refer to the documentation
    and scripting reference at [https://docs.unity3d.com/ScriptReference/Vector3.html](https://docs.unity3d.com/ScriptReference/Vector3.html).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关Unity中向量的更多信息，请参阅文档和脚本参考[https://docs.unity3d.com/ScriptReference/Vector3.html](https://docs.unity3d.com/ScriptReference/Vector3.html)。
- en: 'For instance, if we wanted to create a new vector to hold the origin position
    of our scene, we could use the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要创建一个新的向量来保存场景原点的位置，我们可以使用以下代码：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All we've done here is created a new `Vector3` variable and initialized it with
    a `0` for the *x* position, `0` for the *y* position, and `0` for the *z* position,
    in that order. This spawns the player at the origin of the game arena. `Float`
    values can be written with or without a decimal, but they always need to end with
    a lowercase `f`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的只是创建了一个新的`Vector3`变量，并用* x *位置为`0`，* y *位置为`0`，* z *位置为`0`进行了初始化，按顺序排列。这将使玩家生成在游戏竞技场的原点。`Float`值可以带有或不带有小数点，但它们总是需要以小写`f`结尾。
- en: 'We can also create directional vectors by using the `Vector2` or `Vector3`
    class properties:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`Vector2`或`Vector3`类属性创建方向向量：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Instead of holding a position, `ForwardDirection` references the forward direction
    in our scene along the *z* axis in the 3D space. The neat thing about using the
    Vector3 direction is that no matter which way we make the player look, our code
    will always know which way is forward. We'll look at using vectors later in this
    chapter, but for now just get used to thinking about 3D movement in terms of *x*,
    *y*, and *z* positions and directions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForwardDirection`不是保存位置，而是引用我们场景中沿着3D空间中*z*轴的前进方向。使用Vector3方向的好处是，无论我们让玩家朝向哪个方向，我们的代码始终知道前进的方向。我们将在本章后面讨论使用向量，但现在只需习惯以*x*、*y*和*z*位置和方向来思考3D移动。'
- en: 'Don''t worry if the concept of vectors is new to you—it''s a complicated topic.
    Unity''s vector cookbook is a great place to start: [https://docs.unity3d.com/Manual/VectorCookbook.html](https://docs.unity3d.com/Manual/VectorCookbook.html).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向量的概念对你来说是新的，不要担心——这是一个复杂的主题。Unity的向量手册是一个很好的起点：[https://docs.unity3d.com/Manual/VectorCookbook.html](https://docs.unity3d.com/Manual/VectorCookbook.html)。
- en: Now that you understand vectors a bit more, you can start implementing the basics
    of moving the player capsule. For that, you'll need to gather player input from
    the keyboard, which is the topic of the following section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对向量有了一些了解，你可以开始实现移动玩家胶囊的基本功能。为此，你需要从键盘上获取玩家输入，这是下一节的主题。
- en: Getting player input
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取玩家输入
- en: Positions and directions are useful in themselves, but they can't generate movement
    without input from the player. This is where the `Input` class comes in, which
    handles everything from keystrokes and mouse position to acceleration and gyroscopic
    data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 位置和方向本身是有用的，但没有玩家的输入，它们无法产生移动。这就是`Input`类的作用，它处理从按键和鼠标位置到加速度和陀螺仪数据的一切。
- en: We're going to be using the `W`, `A`, `S`, `D`, and arrow keys for movement
    in *Hero Born*, coupled with a script that allows the camera to follow where the
    player points the mouse. To do that, we'll need to understand how input axes work.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Hero Born*中，我们将使用`W`、`A`、`S`、`D`和箭头键进行移动，同时使用一个允许摄像机跟随玩家鼠标指向的脚本。为此，我们需要了解输入轴的工作原理。
- en: 'First, go to **Edit** | **Project Settings** | **Input Manager** to open up
    the **Input Manager** tab shown in the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，转到**Edit** | **Project Settings** | **Input Manager**，打开如下截图所示的**Input Manager**选项卡：
- en: '![](img/B17573_07_04.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_07_04.png)'
- en: 'Figure 7.4: Input Manager window'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：输入管理器窗口
- en: 'Unity 2021 has a new input system that removes a lot of the coding work, making
    it easier to set up inputs as actions in the editor. Since this is a programming
    book, we''re going to do things from scratch. However, if you want to see how
    the new input system works, check out this great tutorial: [https://learn.unity.com/project/using-the-input-system-in-unity](https://learn.unity.com/project/using-the-input-system-in-unity).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 2021有一个新的输入系统，可以减少很多编码工作，使得在编辑器中设置输入动作更容易。由于这是一本编程书，我们将从头开始做事情。但是，如果你想了解新的输入系统是如何工作的，请查看这个很棒的教程：[https://learn.unity.com/project/using-the-input-system-in-unity](https://learn.unity.com/project/using-the-input-system-in-unity)。
- en: You'll see a long list of Unity's default inputs already configured, but let's
    take the **Horizontal** axis as an example. You can see that the **Horizontal**
    input axis has the **Positive** and **Negative** buttons set to `left` and `right`,
    and the **Alt** **Negative** and **Alt Positive** buttons set to the `a` and `d`
    keys.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个很长的Unity默认输入已经配置好的列表，但让我们以**Horizontal**轴为例。你可以看到**Horizontal**输入轴的**Positive**和**Negative**按钮设置为`left`和`right`，而**Alt
    Negative**和**Alt Positive**按钮设置为`a`和`d`键。
- en: Whenever an input axis is queried from the code, its value will be between -1
    and 1\. For example, when the left arrow or `A` key is pushed down, the horizontal
    axis registers a -1 value. When those keys are released, the value returns to
    0\. Likewise, when the right arrow or `D` keys are used, the horizontal axis registers
    a value of 1\. This allows us to capture four different inputs for a single axis
    with only one line of code, as opposed to writing out a long `if-else` statement
    chain for each.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每当从代码中查询输入轴时，它的值将在-1和1之间。例如，当按下左箭头或`A`键时，水平轴会注册一个-1的值。当释放这些键时，值返回到0。同样，当使用右箭头或`D`键时，水平轴会注册一个值为1的值。这使我们能够使用一行代码捕获单个轴的四个不同输入，而不是为每个输入写出一个长长的`if-else`语句链。
- en: Capturing input axes is as simple as calling `Input.GetAxis()` and specifying
    the axis we want by name, which is what we'll do with the `Horizontal` and `Vertical`
    inputs in the following sections. As a side benefit, Unity applies a smoothing
    filter, which makes the input frame rate independent.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获输入轴就像调用`Input.GetAxis()`并通过名称指定我们想要的轴一样，这就是我们将在接下来的部分中对`Horizontal`和`Vertical`输入所做的事情。作为一个附带的好处，Unity应用了一个平滑滤波器，这使得输入与帧率无关。
- en: Default inputs can be modified in any way you need, but you can also create
    custom axes by increasing the `Size` property in the input manager and renaming
    the copy that's been created for you. You have to increase the `Size` property
    in order to add a custom input.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认输入可以按照需要进行修改，但你也可以通过增加输入管理器中的`Size`属性并重命名为你创建的副本来创建自定义轴。你必须增加`Size`属性才能添加自定义输入。
- en: Let's start getting our player moving using Unity's input system and a custom
    locomotion script of our own.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用Unity的输入系统和自定义的运动脚本让我们的玩家移动起来。
- en: Moving the player
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动玩家
- en: 'Before you get the player moving, you''ll need to attach a script to the player
    capsule:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在让玩家移动之前，你需要将一个脚本附加到玩家胶囊上：
- en: Create a new C# script in the `Scripts` folder, name it `PlayerBehavior`, and
    drag it onto the **Player** capsule in the **Hierarchy** panel.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个新的C#脚本，命名为`PlayerBehavior`，并将其拖放到**Hierarchy**面板中的**Player**胶囊上。
- en: 'Add the following code and save:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码并保存：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the `this` keyword is optional. Visual Studio 2019 may suggest that you
    remove it to simplify the code, but I prefer leaving it in for clarity. When you
    have empty methods, such as `Start`, in this case, it's common to delete them
    for clarity.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`this`关键字是可选的。Visual Studio 2019可能会建议你删除它以简化代码，但我更喜欢保留它以增加清晰度。当你有空的方法，比如`Start`，在这种情况下，删除它们是为了清晰度。
- en: 'Here''s a breakdown of the preceding code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的详细说明：
- en: 'Declares two public variables to be used as multipliers:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个公共变量用作乘数：
- en: '`MoveSpeed` for how fast we want the Player to go forward and backward'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MoveSpeed` 用于控制玩家前后移动的速度'
- en: '`RotateSpeed` for how fast we want the Player to rotate left and right'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RotateSpeed` 用于控制玩家左右旋转的速度'
- en: 'Declares two private variables to hold inputs from the player; initially set
    with no value:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个私有变量来保存玩家的输入；最初没有值：
- en: '`_vInput` will store the vertical axis input.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_vInput`将存储垂直轴输入。'
- en: '`_hInput` will store the horizontal axis input.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_hInput`将存储水平轴输入。'
- en: '`Input.GetAxis("Vertical")` detects when the up arrow, down arrow, `W`, or
    `S` keys are pressed and multiplies that value by `MoveSpeed`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Input.GetAxis("Vertical")`检测上箭头、下箭头、`W`或`S`键被按下时，并将该值乘以`MoveSpeed`：'
- en: The up arrow and `W` keys return a value of 1, which will move the player in
    the forward (positive) direction.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上箭头和`W`键返回值1，这将使玩家向前（正方向）移动。
- en: The down arrow and `S` keys return -1, which moves the player backward in the
    negative direction.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下箭头和`S`键返回-1，这会使玩家向负方向后退。
- en: '`Input.GetAxis("Horizontal")` detects when the left arrow, right arrow, `A`,
    and `D` keys are pressed and multiplies that value by `RotateSpeed`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Input.GetAxis("Horizontal")`检测左箭头、右箭头、`A`和`D`键被按下时，并将该值乘以`RotateSpeed`：'
- en: The right arrow and `D` keys return a value of 1, which will rotate the capsule
    to the right.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右箭头和`D`键返回值1，这将使胶囊向右旋转。
- en: The left arrow and `A` keys return -1, rotating the capsule to the left.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左箭头和`A`键返回-1，将胶囊向左旋转。
- en: If you're wondering whether it's possible to do all the movement calculations
    on one line, the simple answer is yes. However, it's better to have your code
    broken down, even if you're the only one reading it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道是否可能在一行上进行所有的移动计算，简单的答案是肯定的。然而，最好将您的代码分解，即使只有您自己在阅读它。
- en: 'Uses the `Translate` method, which takes in a `Vector3` parameter, to move
    the capsule''s Transform component:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Translate`方法，它接受一个`Vector3`参数，来移动胶囊的Transform组件：
- en: Remember that the `this` keyword specifies the GameObject the current script
    is attached to, which, in this case, is the player capsule.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住，`this`关键字指定了当前脚本所附加的GameObject，这种情况下是玩家胶囊。
- en: '`Vector3.forward` multiplied by `_vInput` and `Time.deltaTime` supplies the
    direction and speed the capsule needs to move forward or back along the *z* axis
    at the speed we''ve calculated.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vector3.forward`乘以`_vInput`和`Time.deltaTime`提供了胶囊需要沿着*z*轴向前/向后移动的方向和速度，速度是我们计算出来的。'
- en: '`Time.deltaTime` will always return the value in seconds since the last frame
    of the game was executed. It''s commonly used to smooth values that are captured
    or run in the `Update` method instead of letting it be determined by a device''s
    frame rate.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Time.deltaTime`将始终返回自游戏上一帧执行以来的秒数。它通常用于平滑值，这些值在`Update`方法中捕获或运行，而不是由设备的帧速率确定。'
- en: 'Uses the `Rotate` method to rotate the capsule''s Transform component relative
    to the vector we pass in as a parameter:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Rotate`方法来旋转相对于我们传递的向量的胶囊的Transform组件：
- en: '`Vector3.up` multiplied by `_hInput` and `Time.deltaTime` gives us the left/right
    rotation axis we want.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vector3.up`乘以`_hInput`和`Time.deltaTime`给我们想要的左/右旋转轴。'
- en: We use the `this` keyword and `Time.deltaTime` here for the same reasons.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在这里使用`this`关键字和`Time.deltaTime`是出于同样的原因。
- en: As we discussed earlier, using direction vectors in the `Translate` and `Rotate`
    functions is only one way to go about this. We could have created new Vector3
    variables from our axis inputs and used them as parameters just as easily.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，使用`Translate`和`Rotate`函数中的方向向量只是其中一种方法。我们可以从我们的轴输入创建新的Vector3变量，并且像参数一样使用它们，同样容易。
- en: When you click play, you'll be able to move the capsule forward and backward
    using the up/down arrow keys and the `W`/`S` keys, while rotating or turning with
    the left/right arrow keys and the `A`/`D` keys.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击播放时，您将能够使用上/下箭头键和`W`/`S`键向前/向后移动胶囊，并使用左/右箭头键和`A`/`D`键旋转或转向。
- en: With these few lines of code, you've set up two separate controls that are frame
    rate independent and easily modified. However, our camera doesn't follow the capsule
    as it moves around, so let's fix that in the following section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这几行代码，您已经设置了两个独立的控件，它们与帧速率无关，并且易于修改。然而，我们的摄像机不会随着胶囊的移动而移动，所以让我们在下一节中修复这个问题。
- en: Scripting camera behavior
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本化摄像机行为
- en: The easiest way to get one GameObject to follow another is to make one of them
    a child of the other. When an object is a child of another, the child object's
    position and rotation are relative to the parent. This means that any child object
    will move and rotate with the parent object.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让一个GameObject跟随另一个GameObject的最简单方法是将它们中的一个设置为另一个的子对象。当一个对象是另一个对象的子对象时，子对象的位置和旋转是相对于父对象的。这意味着任何子对象都会随着父对象的移动和旋转而移动和旋转。
- en: However, this approach means that any kind of movement or rotation that happens
    to the player capsule also affects the camera, which is something we don't necessarily
    want. We always want the camera to be positioned a set distance behind our player
    and always rotate to look at it, no matter what. Luckily, we can easily set the
    position and rotation of the camera relative to the capsule with methods from
    the `Transform` class. It's your task to script out the camera logic in the next
    challenge.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法意味着发生在玩家胶囊上的任何移动或旋转也会影响摄像机，这并不是我们一定想要的。我们始终希望摄像机位于玩家的后方一定距离，并始终旋转以朝向玩家，无论发生什么。幸运的是，我们可以很容易地使用`Transform`类的方法相对于胶囊设置摄像机的位置和旋转。您的任务是在下一个挑战中编写摄像机逻辑。
- en: 'Since we want the camera behavior to be entirely separate from how the player
    moves, we''ll be controlling where the camera is positioned relative to a target
    we can set from the **Inspector** tab:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望摄像机行为与玩家移动完全分离，我们将控制摄像机相对于可以从“检视器”选项卡中设置的目标的位置：
- en: Create a new C# script in the `Scripts` folder, name it `CameraBehavior`, and
    drag it into **Main Camera** in the **Hierarchy** panel.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Scripts”文件夹中创建一个新的C#脚本，命名为“CameraBehavior”，并将其拖放到“层次结构”面板中的“主摄像机”中。
- en: 'Add the following code and save it:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码并保存：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here''s a breakdown of the preceding code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的分解：
- en: 'Declares a `Vector3` variable to store the distance we want between the **Main
    Camera** and the **Player** capsule:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`Vector3`变量来存储**主摄像机**和**玩家**胶囊之间的距离：
- en: We'll be able to manually set the *x*, *y*, and *z* positions of the camera
    offset in the **Inspector** because it's `public`.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将能够在**检视器**中手动设置摄像头偏移的*x*、*y*和*z*位置，因为它是`public`的。
- en: These default values are what I think looks best, but feel free to experiment.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些默认值是我认为看起来最好的，但请随意尝试。
- en: 'Creates a variable to hold the player capsule''s Transform information:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量来保存玩家胶囊体的Transform信息：
- en: This will give us access to its position, rotation, and scale.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将使我们能够访问其位置、旋转和比例。
- en: We don't want any other script to be able to change the camera's target, which
    is why it's `private`.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不希望任何其他脚本能够更改摄像头的目标，这就是为什么它是“私有”的原因。
- en: 'Uses `GameObject.Find` to locate the capsule by name and retrieve its Transform
    property from the scene:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`GameObject.Find`按名称定位胶囊体并从场景中检索其Transform属性：
- en: This means the capsule's *x*, *y*, and *z* positions are updated and stored
    in the `_target` variable every frame.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着胶囊体的*x*、*y*和*z*位置在每一帧都会更新并存储在`_target`变量中。
- en: Finding objects in the scene is a computationally expensive task, so it's good
    practice to only do it once in the `Start` method and store the reference. Never
    use `GameObject.Find` in the `Update` method, as that will try to continually
    find the object you're looking for and potentially crash the game.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景中查找对象是一项计算密集型的任务，因此最好的做法是只在`Start`方法中执行一次并存储引用。永远不要在`Update`方法中使用`GameObject.Find`，因为那样会不断地尝试找到你要找的对象，并有可能导致游戏崩溃。
- en: '`LateUpdate` is a `MonoBehavior` method, like `Start` or `Update`, that executes
    after `Update`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LateUpdate`是一个`MonoBehavior`方法，就像`Start`或`Update`一样，在`Update`之后执行：'
- en: Since our `PlayerBehavior` script moves the capsule in its `Update` method,
    we want the code in `CameraBehavior` to run after the movement happens; this guarantees
    that `_target` has the most up-to-date position to reference.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们的`PlayerBehavior`脚本在其`Update`方法中移动胶囊体，我们希望`CameraBehavior`中的代码在移动发生后运行；这确保了`_target`具有最新的位置以供参考。
- en: 'Sets the camera''s position to `_target.TransformPoint(CamOffset)` for every
    frame, which creates the following effect:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每一帧设置摄像头的位置为`_target.TransformPoint(CamOffset)`，从而产生以下效果：
- en: The `TransformPoint` method calculates and returns a relative position in the
    world space.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransformPoint`方法计算并返回世界空间中的相对位置。'
- en: In this case, it returns the position of the `target` (our capsule) offset by
    `0` in the *x* axis, `1.2` in *the* y axis (putting the camera above the capsule),
    and `-2.6` in the *z* axis (putting the camera slightly behind the capsule).
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，它返回`target`（我们的胶囊体）的位置，偏移了*x*轴上的`0`，*y*轴上的`1.2`（将摄像头放在胶囊体上方），以及*z*轴上的`-2.6`（将摄像头略微放在胶囊体后方）。
- en: The `LookAt` method updates the capsule's rotation every frame, focusing on
    the Transform parameter we pass in, which, in this case, is `_target`:![](img/B17573_07_05.png)
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LookAt`方法每一帧更新胶囊体的旋转，聚焦于我们传入的Transform参数，这种情况下是`_target`：![](img/B17573_07_05.png)'
- en: 'Figure 7.5: Capsule and following camera in Play mode'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：在播放模式下的胶囊体和跟随摄像头
- en: 'This was a lot to take in, but it''s easier to process if you break it down
    into its chronological steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多内容，但如果你把它分解成按时间顺序的步骤，就会更容易处理：
- en: We created an offset position for the camera.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为摄像头创建了一个偏移位置。
- en: We found and stored the player capsule's position.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们找到并存储了玩家胶囊体的位置。
- en: We manually updated its position and rotation every frame so that it's always
    following at a set distance and looking at the player.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们手动更新它的位置和旋转，以便它始终以固定距离跟随并注视玩家。
- en: When using class methods that deliver platform-specific functionality, always
    remember to break things down to their most basic steps. This will help you to
    stay above water in new programming environments.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用提供特定平台功能的类方法时，始终记得将事情分解为最基本的步骤。这将帮助你在新的编程环境中保持头脑清醒。
- en: While the code you've written to manage player movement is perfectly functional,
    you might have noticed that it's a little jerky in places. To create a smoother,
    more realistic movement effect, you'll need to understand the basics of the Unity
    physics system, which you'll dive into next.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你编写的代码可以很好地管理玩家移动，但你可能已经注意到它在某些地方有点抖动。为了创建更平滑、更逼真的移动效果，你需要了解Unity物理系统的基础知识，接下来你将深入研究。
- en: Working with the Unity physics system
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Unity物理系统
- en: Up to this point, we haven't talked about how the Unity engine works, or how
    it manages to create lifelike interactions and movement in a virtual space. We'll
    spend the rest of this chapter learning the basics of Unity's physics system.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有讨论Unity引擎的工作原理，或者它如何在虚拟空间中创建逼真的交互和移动。我们将在本章的其余部分学习Unity物理系统的基础知识。
- en: 'The two main components that power Unity''s NVIDIA PhysX engine are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动Unity的NVIDIA PhysX引擎的两个主要组件如下：
- en: '**Rigidbody** components, which allow GameObjects to be affected by gravity
    and add properties such as **Mass** and **Drag**. Rigidbody components can also
    be affected by an applied force if they have a Collider component attached, which
    generates more realistic movement:![](img/B17573_07_06.png)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**刚体**组件，允许游戏对象受到重力的影响，并添加**质量**和**阻力**等属性。如果刚体组件附加了碰撞器组件，它还可以受到施加的力的影响，从而产生更逼真的移动：![](img/B17573_07_06.png)'
- en: 'Figure 7.6: Rigidbody component in the Inspector pane'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：检视器窗格中的刚体组件
- en: '**Collider** components, which determine how and when GameObjects enter and
    exit each other''s physical space or simply collide and bounce away. While there
    should only be one Rigidbody component attached to a given GameObject, there can
    be several Collider components if you need different shapes or interactions. This
    is commonly referred to as a compound Collider setup:![](img/B17573_07_07.png)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**碰撞器**组件，确定游戏对象如何以及何时进入和退出彼此的物理空间，或者简单地碰撞并弹开。虽然给定游戏对象只能附加一个刚体组件，但如果需要不同的形状或交互，可以附加多个碰撞器组件。这通常被称为复合碰撞器设置：![](img/B17573_07_07.png)'
- en: 'Figure 7.7: Box collider component in the Inspector pane'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：检视器窗格中的盒碰撞器组件
- en: When two Collider components interact with each other, the Rigidbody properties
    determine the resulting interaction. For example, if one GameObject's mass is
    higher than the other, the lighter GameObject will bounce away with more force,
    just like in real life. These two components are responsible for all physical
    interactions and simulated movement in Unity.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个Collider组件相互作用时，Rigidbody属性决定了结果的互动。例如，如果一个GameObject的质量比另一个高，较轻的GameObject将以更大的力量弹开，就像在现实生活中一样。这两个组件负责Unity中的所有物理交互和模拟运动。
- en: 'There are some caveats to using these components, which are best understood
    in terms of the types of movement Unity allows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些组件有一些注意事项，最好从Unity允许的运动类型的角度来理解：
- en: '*Kinematic* movement happens when a Rigidbody component is attached to a GameObject,
    but it doesn''t register to the physics system in the scene. In other words, kinematic
    objects have physics interactions but don''t react to them, like a wall in real
    life. This is only used in certain cases and can be enabled by checking the **Is
    Kinematic** property of a Rigidbody component. Since we want our capsule to interact
    with the physics system, we won''t be using this kind of motion.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运动学*运动发生在一个GameObject上附加了Rigidbody组件，但它不会在场景中注册到物理系统。换句话说，运动学物体有物理交互，但不会对其做出反应，就像现实生活中的墙壁一样。这只在某些情况下使用，并且可以通过检查Rigidbody组件的**Is
    Kinematic**属性来启用。由于我们希望我们的胶囊与物理系统互动，我们不会使用这种运动。'
- en: '*Non-kinematic* movement is when a Rigidbody component is moved or rotated
    by applying force rather than manually changing a GameObject''s Transform properties.
    Our goal for this section is to update the `PlayerBehavior` script to implement
    this type of motion.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*非运动学*运动是指通过施加力来移动或旋转Rigidbody组件，而不是手动更改GameObject的Transform属性。本节的目标是更新`PlayerBehavior`脚本以实现这种类型的运动。'
- en: The setup we have now, that is, manipulating the capsule's Transform component
    while using a Rigidbody component to interact with the physics system, was meant
    to get you thinking about movement and rotation in a 3D space. However, it's not
    meant for production and Unity suggests avoiding a mix of kinematic and non-kinematic
    movement in your code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的设置，也就是在使用Rigidbody组件与物理系统交互的同时操纵胶囊的Transform组件，是为了让你思考在3D空间中的移动和旋转。然而，这并不适用于生产，Unity建议避免在代码中混合使用运动学和非运动学运动。
- en: Your next task is to use applied force to convert the current movement system
    into a more realistic locomotion experience.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你的下一个任务是使用施加的力将当前的运动系统转换为更真实的运动体验。
- en: Rigidbody components in motion
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运动中的Rigidbody组件
- en: 'Since our player has a Rigidbody component attached, we should let the physics
    engine control our movement instead of manually translating and rotating the Transform.
    There are two options when it comes to applying force:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的玩家已经附加了Rigidbody组件，我们应该让物理引擎控制我们的运动，而不是手动平移和旋转Transform。在应用力时有两个选项：
- en: You can do it directly by using Rigidbody class methods such as `AddForce` and
    `AddTorque` to move and rotate an object, respectively. This approach has its
    drawbacks and often requires additional code to compensate for unexpected physics
    behavior such as unwanted torque or applied force during collisions.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以直接使用Rigidbody类的方法，比如`AddForce`和`AddTorque`来分别移动和旋转一个物体。这种方法有它的缺点，通常需要额外的代码来补偿意外的物理行为，比如在碰撞期间产生的不需要的扭矩或施加的力。
- en: Alternatively, you can use other Rigidbody class methods such as `MovePosition`
    and `MoveRotation`, which still use applied force.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你可以使用其他Rigidbody类的方法，比如`MovePosition`和`MoveRotation`，它们仍然使用施加的力。
- en: 'We''ll take the second route in the next section so that Unity takes care of
    the applied physics for us, but if you''re curious about manually applying force
    and torque to your GameObjects, then start here: [https://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html](https://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将采用第二种方法，让Unity为我们处理施加的物理效果，但如果你对手动施加力和扭矩到你的GameObject感兴趣，那么从这里开始：[https://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html](https://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html)。
- en: Either of these will give the player a more lifelike feel and allow us to add
    in jumping and dashing mechanics in *Chapter 8*, *Scripting Game Mechanics*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都会让玩家感觉更真实，并且允许我们在*第8章* *脚本游戏机制*中添加跳跃和冲刺机制。
- en: If you're curious about what happens when a moving object without a Rigidbody
    component interacts with pieces of the environment that have them equipped, remove
    the component from the Player and run around the arena. Congratulations—you're
    a ghost and can walk through walls! Don't forget to add the Rigidbody component
    back, though!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇一个没有Rigidbody组件的移动物体与装备了Rigidbody组件的环境物体互动时会发生什么，可以从玩家身上移除该组件并在竞技场周围跑一圈。恭喜你——你是一个鬼魂，可以穿墙走了！不过别忘了重新添加Rigidbody组件！
- en: The player capsule already has a Rigidbody component attached, which means that
    you can access and modify its properties. First, though, you'll need to find and
    store the component, which is your next challenge.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家胶囊已经附加了Rigidbody组件，这意味着你可以访问和修改它的属性。不过，首先你需要找到并存储该组件，这是你下一个挑战。
- en: 'You''ll need to access and store the Rigidbody component on our player capsule
    before modifying it. Update `PlayerBehavior` with the following changes:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改之前，你需要访问并存储玩家胶囊上的Rigidbody组件。更新`PlayerBehavior`如下更改：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s a breakdown of the preceding code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的详细说明：
- en: Adds a private variable of type `Rigidbody` that will contain a reference to
    the capsule's Rigidbody component.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个私有变量，类型为`Rigidbody`，它将包含对胶囊Rigidbody组件的引用。
- en: The `Start` method fires when a script is initialized in a scene, which happens
    when you click on play, and should be used any time variables need to be set at
    the beginning of a class.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Start`方法在脚本在场景中初始化时触发，这发生在你点击播放时，并且应该在类的开始时使用任何需要设置的变量。'
- en: 'The `GetComponent` method checks whether the component type we''re looking
    for, in this case, `Rigidbody`, exists on the GameObject the script is attached
    to and returns it:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetComponent`方法检查我们正在查找的组件类型（在本例中为`Rigidbody`）是否存在于脚本所附加的游戏对象上，并返回它：'
- en: If the component isn't attached to the GameObject, the method will return `null`,
    but since we know there's one on the player, we won't worry about error checking
    right now.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果组件没有附加到游戏对象上，该方法将返回`null`，但由于我们知道玩家上有一个组件，所以我们现在不用担心错误检查。
- en: 'Comments out the `Transform` and `Rotate` method calls in the `Update` function
    so that we won''t be running two different kinds of player controls:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update`函数中注释掉`Transform`和`Rotate`方法的调用，这样我们就不会运行两种不同的玩家控制：
- en: We want to keep our code that captures player input so that we can still use
    it later on.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望保留捕捉玩家输入的代码，以便以后仍然可以使用它。
- en: You've initialized and stored the Rigidbody component on the player capsule
    and commented out the obsolete `Transform` code to set the stage for physics-based
    movement. The character is now ready for the next challenge, which is to add force.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经初始化并存储了玩家胶囊上的刚体组件，并注释掉了过时的`Transform`代码，为基于物理的运动做好了准备。角色现在已经准备好迎接下一个挑战，即添加力。
- en: 'Use the following steps to move and rotate the Rigidbody component. Add in
    the following code to `PlayerBehavior` underneath the `Update` method, and then
    save the file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤移动和旋转刚体组件。在`Update`方法下面的`PlayerBehavior`中添加以下代码，然后保存文件：
- en: '[PRE5]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here''s a breakdown of the preceding code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的详细说明：
- en: 'Any physics- or Rigidbody-related code always goes inside the `FixedUpdate`
    method, rather than `Update` or the other `MonoBehavior` methods:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何与物理或刚体相关的代码都应该放在`FixedUpdate`方法中，而不是`Update`或其他`MonoBehavior`方法中：
- en: '`FixedUpdate` is frame rate independent and is used for all physics code.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FixedUpdate`是与帧率无关的，用于所有物理代码。'
- en: 'Creates a new `Vector3` variable to store our left and right rotation:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Vector3`变量来存储我们的左右旋转：
- en: '`Vector3.up * _hInput` is the same rotation vector we used with the `Rotate`
    method in the previous example.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vector3.up * _hInput`是我们在上一个示例中使用`Rotate`方法的相同旋转向量。'
- en: '`Quaternion.Euler` takes a `Vector3` parameter and returns a rotation value
    in Euler angles:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Quaternion.Euler`接受一个`Vector3`参数并返回欧拉角中的旋转值：'
- en: We need a `Quaternion` value instead of a `Vector3` parameter to use the `MoveRotation`
    method. This is just a conversion to the rotation type that Unity prefers.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个`Quaternion`值而不是`Vector3`参数来使用`MoveRotation`方法。这只是一种转换为Unity所偏爱的旋转类型。
- en: We multiply by `Time.fixedDeltaTime` for the same reason we used `Time.deltaTime`
    in `Update`.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们乘以`Time.fixedDeltaTime`的原因与我们在`Update`中使用`Time.deltaTime`的原因相同。
- en: 'Calls `MovePosition` on our `_rb` component, which takes in a `Vector3` parameter
    and applies force accordingly:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`_rb`组件上调用`MovePosition`，它接受一个`Vector3`参数并相应地施加力：
- en: 'The vector that''s used can be broken down as follows: the capsule''s `Transform`
    position in the forward direction, multiplied by the vertical inputs and `Time.fixedDeltaTime`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的向量可以分解如下：胶囊在前进方向上的`Transform`位置，乘以垂直输入和`Time.fixedDeltaTime`。
- en: The Rigidbody component takes care of applying movement force to satisfy our
    vector parameter.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刚体组件负责施加移动力以满足我们的向量参数。
- en: 'Calls the `MoveRotation` method on the `_rb` component, which also takes in
    a `Vector3` parameter and applies the corresponding forces under the hood:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`_rb`组件上调用`MoveRotation`方法，该方法还接受一个`Vector3`参数，并在幕后应用相应的力：
- en: '`angleRot` already has the horizontal inputs from the keyboard, so all we need
    to do is multiply the current Rigidbody rotation by `angleRot` to get the same
    left and right rotation.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`angleRot`已经具有来自键盘的水平输入，因此我们所需要做的就是将当前的刚体旋转乘以`angleRot`，以获得相同的左右旋转。'
- en: Be aware that `MovePosition` and `MoveRotation` work differently for non-kinematic
    game objects. You can find more information in the Rigidbody scripting reference
    at [https://docs.unity3d.com/ScriptReference/Rigidbody.html](https://docs.unity3d.com/ScriptReference/Rigidbody.html).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于非运动学游戏对象，`MovePosition`和`MoveRotation`的工作方式是不同的。您可以在刚体脚本参考中找到更多信息[https://docs.unity3d.com/ScriptReference/Rigidbody.html](https://docs.unity3d.com/ScriptReference/Rigidbody.html)。
- en: If you click on play now, you'll be able to move forward and backward in the
    direction you're looking, as well as rotate around the *y* axis.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在点击播放，您将能够向前和向后移动，以及围绕*y*轴旋转。
- en: Applied force produces stronger effects than translating and rotating a Transform
    component, so you may need to fine-tune the `MoveSpeed` and `RotateSpeed` variables
    in the **Inspector** pane. You've now recreated the same type of movement scheme
    as before, just with more realistic physics.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 施加的力产生的效果比转换和旋转Transform组件更强，因此您可能需要微调**Inspector**窗格中的`MoveSpeed`和`RotateSpeed`变量。现在，您已经重新创建了与之前相同类型的运动方案，只是使用了更真实的物理。
- en: If you run up a ramp or drop off the central platform, you might see the player
    launch into the air, or slowly drop to the ground. Even though the Rigidbody component
    is set to use gravity, it's fairly weak. We'll tackle applying our gravity to
    the player in the next chapter when we implement the jump mechanic. For now, your
    job is to get comfortable with how Collider components handle collisions in Unity.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您跑上斜坡或从中央平台掉下来，您可能会看到玩家跳入空中，或者缓慢落到地面上。即使刚体组件设置为使用重力，它也相当弱。当我们实现跳跃机制时，我们将在下一章中处理将重力应用于玩家。现在，您的工作是熟悉Unity中Collider组件如何处理碰撞。
- en: Colliders and collisions
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞体和碰撞
- en: Collider components not only allow GameObjects to be recognized by Unity's physics
    system, but they also make interactions and collisions possible. Think of colliders
    as invisible force fields that surround GameObjects; they can be passed through
    or bumped into depending on their settings, and they come with a host of methods
    that execute during different interactions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞体组件不仅允许Unity的物理系统识别游戏对象，还使交互和碰撞成为可能。将碰撞体想象成围绕游戏对象的无形力场；它们可以根据其设置被穿过或撞击，并且在不同的交互过程中会执行一系列方法。
- en: Unity's physics system works differently for 2D and 3D games, so we will only
    be covering the 3D topics in this book. If you're interested in making 2D games,
    refer to the `Rigidbody2D` component at [https://docs.unity3d.com/Manual/class-Rigidbody2D.html](https://docs.unity3d.com/Manual/class-Rigidbody2D.html)
    and the list of available 2D colliders at [https://docs.unity3d.com/Manual/Collider2D.html](https://docs.unity3d.com/Manual/Collider2D.html).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的物理系统对2D和3D游戏有不同的工作方式，因此我们只会在本书中涵盖3D主题。如果你对制作2D游戏感兴趣，请参考[https://docs.unity3d.com/Manual/class-Rigidbody2D.html](https://docs.unity3d.com/Manual/class-Rigidbody2D.html)中的`Rigidbody2D`组件以及[https://docs.unity3d.com/Manual/Collider2D.html](https://docs.unity3d.com/Manual/Collider2D.html)中可用的2D碰撞体列表。
- en: 'Take a look at the following screenshot of the **Capsule** in the **Health_Pickup**
    object. If you want to see the **Capsule Collider** a little better, increase
    the **Radius** property:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下**Health_Pickup**对象中**Capsule**的以下屏幕截图。如果你想更清楚地看到**胶囊碰撞体**，增加**半径**属性：
- en: '![](img/B17573_07_08.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_07_08.png)'
- en: 'Figure 7.8: Capsule collider component attached to pickup item'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：附加到拾取物品的胶囊碰撞体组件
- en: The green shape around the object is the **Capsule Collider**, which can be
    moved and scaled using the **Center**, **Radius**, and **Height** properties.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对象周围的绿色形状是**胶囊碰撞体**，可以使用**中心**、**半径**和**高度**属性进行移动和缩放。
- en: When a primitive is created, the Collider matches the primitive's shape by default;
    since we created a capsule primitive, it comes with a Capsule Collider.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个原始对象时，默认情况下，碰撞体与原始对象的形状匹配；因为我们创建了一个胶囊原始对象，它带有一个胶囊碰撞体。
- en: Colliders also come in **Box**, **Sphere**, and **Mesh** shapes and can be manually
    added from the **Component** | **Physics** menu or from the **Add Component**
    button in the **Inspector**.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞体还有**盒形**、**球形**和**网格**形状，并且可以从**组件** | **物理**菜单或**检视器**中的**添加组件**按钮手动添加。
- en: When a Collider comes into contact with other components, it sends out what's
    called a message, or broadcast. Any script that adds one or more of those methods
    will receive a notification when the Collider sends out a message. This is called
    an *event*, which is a topic that we'll cover in more detail in *Chapter 14*,
    *The Journey Continues*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当碰撞体与其他组件接触时，它会发送所谓的消息或广播。任何添加了这些方法中的一个或多个的脚本都会在碰撞体发送消息时收到通知。这被称为*事件*，我们将在*第14章*
    *旅程继续*中更详细地讨论这个主题。
- en: For example, when two GameObjects with colliders come into contact, both objects
    register an `OnCollisionEnter` event, complete with a reference to the object
    they ran into. Think of an event like a message being sent out – if you choose
    to listen for it you'll get notified when a collision happens in this case. This
    information can be used to track a variety of interactive events, but the simplest
    one is picking up an item. For cases where you want objects to be able to pass
    through others, you can use collision triggers, which we'll talk about in the
    next section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当两个带有碰撞体的游戏对象接触时，两个对象都会注册一个`OnCollisionEnter`事件，并附带对它们碰到的对象的引用。想象一下事件就像发送出的消息-如果你选择监听它，你会在这种情况下得到碰撞发生时的通知。这些信息可以用来跟踪各种交互事件，但最简单的是拾取物品。对于希望对象能够穿过其他对象的情况，可以使用碰撞触发器，我们将在下一节讨论。
- en: A complete list of Collider notifications can be found here underneath the **Messages**
    header at [https://docs.unity3d.com/ScriptReference/Collider.html](https://docs.unity3d.com/ScriptReference/Collider.html).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://docs.unity3d.com/ScriptReference/Collider.html](https://docs.unity3d.com/ScriptReference/Collider.html)的**消息**标题下找到碰撞体通知的完整列表。
- en: Collision and trigger events are only sent out when the colliding objects belong
    to a specific combination of Collider, Trigger, and RigidBody components and kinematic
    or non-kinematic motion. You can find details under the **Collision action matrix**
    section at [https://docs.unity3d.com/Manual/CollidersOverview.html](https://docs.unity3d.com/Manual/CollidersOverview.html).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当碰撞的对象属于特定的碰撞体、触发器和刚体组件的组合以及动力学或非动力学运动时，才会发送碰撞和触发事件。你可以在[https://docs.unity3d.com/Manual/CollidersOverview.html](https://docs.unity3d.com/Manual/CollidersOverview.html)的**碰撞动作矩阵**部分找到详细信息。
- en: The health item you previously created is a perfect place to test out how collisions
    work. You'll tackle that in the next challenge.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前创建的生命值物品是一个测试碰撞如何工作的完美场所。你将在下一个挑战中解决这个问题。
- en: Picking up an item
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拾取物品
- en: 'To update the `Health_Pickup` object using collision logic, you need to do
    the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用碰撞逻辑更新`Health_Pickup`对象，需要执行以下操作：
- en: 'Create a new C# script in the `Scripts` folder, name it `ItemBehavior`, and
    then drag it onto the `Health_Pickup` object in the **Hierarchy** panel:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个新的C#脚本，命名为`ItemBehavior`，然后将其拖放到**层次结构**面板中的`Health_Pickup`对象上：
- en: Any script that uses collision detection *must* be attached to a GameObject
    with a Collider component, even if it's the child of a Prefab.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何使用碰撞检测的脚本*必须*附加到带有碰撞体组件的游戏对象上，即使它是预制体的子对象。
- en: Select `Health_Pickup` in the **Hierarchy panel**, click the three vertical
    dots icon in the **Inspector** to the right of the **Item Behavior (Script)**
    component, and choose **Added Component** | **Apply to Prefab 'Health_Pickup'**:![](img/B17573_07_09.png)
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构面板**中选择`Health_Pickup`，点击**检视器**右侧**项目行为（脚本）**组件旁边的三个垂直点图标，并选择**添加组件**
    | **应用于预制体'Health_Pickup'**：![](img/B17573_07_09.png)
- en: 'Figure 7.9: Applying Prefab changes to pickup item'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：将预制体更改应用到拾取物品
- en: 'Replace the default code in `ItemBehavior` with the following, and then save
    it:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ItemBehavior`中的默认代码替换为以下内容，然后保存：
- en: '[PRE6]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Click on play and move the player over the capsule to pick it up!
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击播放并将玩家移动到胶囊体上以拾取它！
- en: 'Here''s a breakdown of the preceding code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的详细说明：
- en: 'When another object runs into the `Item` Prefab, Unity automatically calls
    the `OnCollisionEnter` method:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当另一个对象碰到`Item`预制件时，Unity会自动调用`OnCollisionEnter`方法：
- en: '`OnCollisionEnter` comes with a parameter that stores a reference to the Collider
    that ran into it.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnCollisionEnter`带有一个参数，用于存储撞到它的碰撞体的引用。'
- en: Notice that the collision is of type `Collision`, not `Collider`.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，碰撞的类型是`Collision`，而不是`Collider`。
- en: 'The `Collision` class has a property, called `gameObject`, which holds a reference
    to the colliding GameObject''s Collider:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Collision`类有一个名为`gameObject`的属性，它保存着与碰撞的游戏对象的碰撞体的引用：'
- en: We can use this property to get the GameObject's name and use an `if` statement
    to check whether the colliding object is the player.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用这个属性来获取游戏对象的名称，并使用`if`语句来检查碰撞对象是否为玩家。
- en: If the colliding object is the player, we'll call the `Destroy()` method, which
    takes in a GameObject parameter and removes the object from the scene.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果碰撞对象是玩家，我们将调用`Destroy()`方法，该方法接受一个游戏对象参数并从场景中移除该对象。
- en: It then prints out a simple log to the console that we have collected an item:![](img/B17573_07_10.png)
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它会在控制台上打印出一个简单的日志，说明我们已经收集了一个物品：![](img/B17573_07_10.png)
- en: 'Figure 7.10: Example of game objects being deleted from a scene'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：游戏对象被从场景中删除的示例
- en: We've set up `ItemBehavior` to essentially listen for any collisions with the
    `Health_Pickup` object Prefab. Whenever a collision occurs, `ItemBehavior` uses
    `OnCollisionEnter()` and checks whether the colliding object is the player and,
    if so, destroys (or collects) the item.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了`ItemBehavior`来监听与`Health_Pickup`对象预制件的任何碰撞。每当发生碰撞时，`ItemBehavior`使用`OnCollisionEnter()`并检查碰撞对象是否为玩家，如果是，则销毁（或收集）该物品。
- en: If you're feeling lost, think of the collision code we wrote as a receiver for
    notifications from the `Health_Pickup`; any time it's hit, the code fires.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到迷茫，可以将我们编写的碰撞代码视为`Health_Pickup`的通知接收器；每当它被击中时，代码就会触发。
- en: It's also important to understand that we could have created a similar script
    with an `OnCollisionEnter()` method, attached it to the player, and then checked
    whether the colliding object was a `Health_Pickup` Prefab. Collision logic depends
    on the perspective of the object being collided with.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要理解的是，我们可以创建一个类似的脚本，其中包含一个`OnCollisionEnter()`方法，将其附加到玩家上，然后检查碰撞对象是否为`Health_Pickup`预制件。碰撞逻辑取决于被碰撞对象的视角。
- en: Now the question is, how would you set up a collision without stopping the colliding
    objects from moving through each other? We'll tackle that in the next section.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，如何设置碰撞而不会阻止碰撞对象相互穿过？我们将在下一节中解决这个问题。
- en: Using Collider triggers
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用碰撞体触发器
- en: By default, Colliders are set with the `isTrigger` property unchecked, meaning
    that the physics system treats them as solid objects and will raise a Collision
    event on impact. However, in some cases, you'll want to be able to pass through
    a Collider component without it stopping your GameObject. This is where triggers
    come in. With `isTrigger` checked, a GameObject can pass through it, but the Collider
    will send out the `OnTriggerEnter`, `OnTriggerExit`, and `OnTriggerStay` notifications
    instead.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，碰撞体的`isTrigger`属性未选中，这意味着物理系统将其视为实体对象，并在碰撞时触发碰撞事件。然而，在某些情况下，你可能希望能够通过碰撞体组件而不会停止你的游戏对象。这就是触发器的作用。勾选`isTrigger`后，游戏对象可以穿过它，但碰撞体将发送`OnTriggerEnter`、`OnTriggerExit`和`OnTriggerStay`通知。
- en: Triggers are most useful when you need to detect when a GameObject enters a
    certain area or passes a certain point. We'll use this to set up the areas around
    our enemies; if the player walks into the trigger zone, the enemies will be alerted,
    and, later on, attack the player. For now, you're going to focus just on the enemy
    logic in the following challenge.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要检测游戏对象进入特定区域或通过特定点时，触发器是最有用的。我们将使用它来设置围绕我们敌人的区域；如果玩家走进触发区域，敌人将受到警报，并且稍后会攻击玩家。现在，你将专注于以下挑战中的敌人逻辑。
- en: Creating an enemy
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个敌人
- en: 'Use the following steps to create an enemy:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤创建一个敌人：
- en: Create a new primitive using **+** | **3D Object** | **Capsule** in the **Hierarchy**
    panel and name it `Enemy`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中使用**+** | **3D对象** | **胶囊体**创建一个新的原语，并将其命名为`Enemy`。
- en: 'Inside the `Materials` folder, use **+** | **Material**, name it `Enemy_Mat`,
    and set its **Albedo** property to a bright red:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Materials`文件夹中，使用**+** | **Material**，命名为`Enemy_Mat`，并将其**Albedo**属性设置为鲜艳的红色：
- en: Drag and drop `Enemy_Mat` into the `Enemy` GameObject.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Enemy_Mat`拖放到`Enemy`游戏对象中。
- en: 'With `Enemy` selected, click on **Add Component**, search for **Sphere Collider**,
    and hit `Enter` to add it:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Enemy`，点击**添加组件**，搜索**Sphere Collider**，然后按`Enter`添加：
- en: Check the **isTrigger** property box and change the **Radius** to `8`:![](img/B17573_07_11.png)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 勾选**isTrigger**属性框，并将**Radius**更改为`8`：![](img/B17573_07_11.png)
- en: 'Figure 7.11: Sphere collider component attached to an enemy object'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11：附加到敌人对象的球体碰撞器组件
- en: Our new **Enemy** primitive is now surrounded by an 8-unit trigger radius shaped
    like a sphere. Any time another object enters, stays inside, or exits that area,
    Unity will send out notifications that we can capture, just like we did with collisions.
    Your next challenge will be to capture that notification and act on it in code.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新**Enemy**原语现在被一个8单位的球形触发半径所包围。每当另一个对象进入、停留在内部或离开该区域时，Unity都会发送通知，我们可以捕获，就像我们处理碰撞时那样。你下一个挑战将是捕获该通知并在代码中对其进行操作。
- en: 'To capture trigger events, you''ll need to create a new script by following
    these steps:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要捕获触发器事件，需要按照以下步骤创建一个新的脚本：
- en: Create a new C# script in the `Scripts` folder, name it `EnemyBehavior`, and
    then drag it into **Enemy**.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个新的C#脚本，命名为`EnemyBehavior`，然后将其拖放到**Enemy**中。
- en: 'Add the following code and save the file:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码并保存文件：
- en: '[PRE7]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Click play and walk over to the Enemy to set off the first notification, then
    walk away from the Enemy to set off the second notification.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击播放并走到敌人旁边以触发第一个通知，然后走开以触发第二个通知。
- en: 'Here''s a breakdown of the preceding code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的详细说明：
- en: '`OnTriggerEnter()` is fired whenever an object enters the Enemy Sphere Collider
    radius:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一个对象进入敌人球形碰撞体半径时，会触发`OnTriggerEnter()`：
- en: Similar to `OnCollisionEnter()`, `OnTriggerEnter()` stores a reference to the
    trespassing object's Collider component.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`OnCollisionEnter()`类似，`OnTriggerEnter()`存储了侵入对象的碰撞体组件的引用。
- en: Note that `other` is of type `Collider`, not `Collision`.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，`other`是`Collider`类型，而不是`Collision`类型。
- en: We can use `other` to access the name of the colliding GameObject, and check
    whether it's the `Player` with an `if` statement. If it is, the console prints
    out a log that the `Player` is in the danger zone.![](img/B17573_07_12.png)
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`other`来访问碰撞游戏对象的名称，并使用`if`语句检查它是否是`Player`。如果是，控制台会打印出一个日志，说明`Player`处于危险区域。![](img/B17573_07_12.png)
- en: 'Figure 7.12: Collision detection between player and enemy objects'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12：玩家和敌人对象之间的碰撞检测
- en: '`OnTriggerExit()` is fired when an object leaves the Enemy Sphere Collider
    radius:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一个对象离开敌人球形碰撞体半径时，会触发`OnTriggerExit()`：
- en: 'This method also has a reference to the colliding object''s Collider component:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法还有一个引用到碰撞对象的碰撞体组件：
- en: 'We check the object leaving the Sphere Collider radius by name using another
    `if` statement:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用另一个`if`语句通过名称检查离开球形碰撞体半径的对象：
- en: If it's `Player`, we print out another log to the console saying that they're
    safe:![](img/B17573_07_13.png)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是`Player`，我们会在控制台打印出另一个日志，说明他们是安全的！[](img/B17573_07_13.png)
- en: 'Figure 7.13: Example of collision triggers'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13：碰撞触发器的示例
- en: The Sphere Collider on our Enemy sends out notifications when its area is invaded,
    and the `EnemyBehavior` script captures two of those events. Whenever the player
    enters or exits the collision radius, a debug log appears in the console to let
    us know that the code is working. We'll continue to build on this in *Chapter
    9*, *Basic AI and Enemy Behavior*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们敌人的球形碰撞体在其区域被入侵时发送通知，而`EnemyBehavior`脚本捕获了其中的两个事件。每当玩家进入或离开碰撞半径时，控制台中会出现调试日志，以告诉我们代码正在运行。我们将在*第9章*“基本AI和敌人行为”中继续构建这一点。
- en: Unity makes use of something called the Component design pattern. Without going
    into too much detail, that's a fancy way of saying objects (and, by extension,
    their classes) should be responsible for their behavior as opposed to having all
    the code in one huge file. This is why we put separate collision scripts on the
    pickup item and enemy instead of having a single class handle everything. We'll
    discuss this further in *Chapter 14*, *The Journey Continues*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Unity使用了一种叫做组件设计模式的东西。不详细讨论，这是一种说对象（以及其类）应该负责其行为而不是将所有代码放在一个巨大文件中的花哨方式。这就是为什么我们在拾取物品和敌人上分别放置了单独的碰撞脚本，而不是让一个类处理所有事情。我们将在*第14章*“旅程继续”中进一步讨论这个问题。
- en: Since this book is all about instilling as many good programming habits as possible,
    your last task for the chapter is to make sure all your core objects are converted
    into Prefabs.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的目标是尽可能灌输良好的编程习惯，本章的最后一个任务是确保所有核心对象都转换为预制体。
- en: Hero's trial – all the Prefabs!
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 英雄的试炼-所有的预制体！
- en: To get the project ready for the next chapter, go ahead and drag the `Player`
    and `Enemy` objects into the **Prefabs** folder. Remember, from now on you always
    need to right-click on the Prefab in the **Hierarchy** panel and choose **Added
    Component** | **Apply to Prefab** to solidify any changes you make to these GameObjects.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让项目准备好迎接下一章，继续将`Player`和`Enemy`对象拖入**Prefabs**文件夹中。请记住，从现在开始，您总是需要右键单击**Hierarchy**面板中的预制体，然后选择**Added
    Component** | **Apply to Prefab**来巩固对这些游戏对象所做更改。
- en: With that done, continue to the *Physics roundup* section and make sure that
    you've internalized all the major topics we've covered before moving on.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，继续到*物理学总结*部分，确保在继续之前已经内化了我们所涵盖的所有主要主题。
- en: Physics roundup
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理学总结
- en: 'Before we wrap up the chapter, here are a few high-level concepts to cement
    what we''ve learned so far:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，这里有一些高层概念，以巩固我们到目前为止所学到的内容：
- en: Rigidbody components add simulated real-world physics to GameObjects they are
    attached to.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刚体组件为附加到其上的游戏对象添加了模拟真实世界的物理效果。
- en: 'Collider components interact with each other, as well as objects, using Rigidbody
    components:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞体组件与刚体组件以及对象进行交互：
- en: If a Collider component is not a trigger, it acts as a solid object.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果碰撞体组件不是一个触发器，它就会作为一个实体对象。
- en: If a Collider component is a trigger, it can be walked through.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果碰撞体组件是一个触发器，它可以被穿过。
- en: An object is *kinematic* if it uses a Rigidbody component and has **Is Kinematic**
    checked, telling the physics system to ignore it.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个对象使用了刚体组件并且勾选了“Is Kinematic”，告诉物理系统忽略它，那么它就是*运动学*的。
- en: An object is *non-kinematic* if it uses a Rigidbody component and applied force
    or torque to power its movement and rotation.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个对象使用了刚体组件并施加了力或扭矩来驱动其运动和旋转，那么它就是*非运动学*的。
- en: Colliders send out notifications based on their interactions. These notifications
    depend on whether the Collider component is set to be triggered or not. Notifications
    can be received from either colliding party, and they come with reference variables
    that hold an object's collision information.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞体根据它们的交互发送通知。这些通知取决于碰撞体组件是否设置为触发器。通知可以从任一碰撞方接收，并且它们带有引用变量，保存了对象的碰撞信息。
- en: Remember, a topic as broad and complex as the Unity physics system isn't learned
    in a day. Use what you've learned here as a springboard to launch yourself into
    more intricate topics!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，像Unity物理系统这样广泛而复杂的主题不是一天就能学会的。将您在这里学到的知识作为一个跳板，让自己进入更复杂的主题！
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This wraps up your first experience of creating independent gameplay behaviors
    and tying them all together into a cohesive, albeit simple, game prototype. You've
    used vectors and basic vector math to determine positions and angles in a 3D space,
    and you're familiar with player input and the two main methods of moving and rotating
    GameObjects. You've even gone down into the bowels of the Unity physics system
    to get comfortable with Rigidbody physics, collisions, triggers, and event notifications.
    All in all, *Hero Born* is off to a great start.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了你第一次创建独立游戏行为并将它们整合成一个连贯但简单的游戏原型的经历。你已经使用向量和基本的向量数学来确定3D空间中的位置和角度，并且你熟悉玩家输入以及移动和旋转游戏对象的两种主要方法。你甚至深入了解了Unity物理系统的刚体物理、碰撞、触发器和事件通知。总的来说，《英雄诞生》有了一个很好的开端。
- en: In the next chapter, we'll start tackling more game mechanics, including jumping,
    dashing, shooting projectiles, and interacting with parts of the environment.
    This will give you more hands-on experience of using force with Rigidbody components,
    gathering player input, and executing logic based on the desired scenario.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始解决更多的游戏机制，包括跳跃、冲刺、发射抛射物以及与环境的交互。这将让你更多地实践使用刚体组件的力量、收集玩家输入，并根据所需的情景执行逻辑。
- en: Pop quiz – player controls and physics
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小测验 - 玩家控制和物理
- en: What data type would you use to store 3D movement and rotation information?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用什么数据类型来存储3D移动和旋转信息？
- en: What built-in Unity component allows you to track and modify player controls?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unity内置的哪个组件允许你跟踪和修改玩家控制？
- en: Which component adds real-world physics to a GameObject?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个组件可以给游戏对象添加真实世界的物理效果？
- en: What method does Unity suggest using to execute physics-related code on GameObjects?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unity建议使用什么方法来执行游戏对象上与物理相关的代码？
- en: JOIN us on Discord!
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity/C#专家和Harrison Ferrone一起阅读本书。提出问题，为其他读者提供解决方案，通过“问我任何事”会话与作者交流等等。
- en: Join Now!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 立即加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code_9781801813945.png)'
