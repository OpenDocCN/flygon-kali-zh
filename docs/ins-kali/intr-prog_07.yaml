- en: Interfaces, Classes, and Object Construction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口，类和对象构造
- en: 'This chapter explains to readers the most important aspects of Java programming:
    **Application Programming Interfaces** (**APIs**), object factories, method overriding,
    hiding, and overloading. An explanation of the design advantage of aggregation
    (versus inheritance) follows, starting the discussion around software system design.
    The chapter concludes with an overview of Java data structures.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向读者解释了Java编程的最重要方面：应用程序编程接口（API），对象工厂，方法重写，隐藏和重载。接着是聚合（而不是继承）的设计优势的解释，开始讨论软件系统设计。本章最后概述了Java数据结构。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is an API?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是API？
- en: Interface and object factory as APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口和对象工厂作为API
- en: Overriding, hiding, and overloading
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写，隐藏和重载
- en: The `this` and `super` keywords
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this`和`super`关键字'
- en: Constructors and constructor overloading
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数和构造函数重载
- en: Final variable, final method, and final class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终变量，最终方法和最终类
- en: Object association (aggregation)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象关联（聚合）
- en: Exercise – Restricting a class instantiation to a single shared instance
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习-将类实例化限制为单个共享实例
- en: What is an API?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API是什么？
- en: The term **Application Programming Interface** (**API**) is a specification
    of protocols, procedures, and services that can be used as building blocks by
    a programmer to implement a required functionality. An API may represent a web-based
    system, operating system, database system, computer hardware, or software library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**应用程序编程接口**（API）是程序员用来实现所需功能的协议，程序和服务的规范。API可以代表基于Web的系统，操作系统，数据库系统，计算机硬件或软件库。
- en: In addition to that, in everyday life, the term API is often applied to the
    system that implements the specification. For example, you might be familiar with
    Twitter APIs ([https://developer.twitter.com/en/docs](https://developer.twitter.com/en/docs))
    or Amazon APIs ([https://developer.amazon.com/services-and-apis](https://developer.amazon.com/services-and-apis)),
    or you might have worked with devices (sensors) that are able to respond to a
    request by providing the data (measurement results). So, when programmers say
    *we can use an Amazon API*, they mean not only the description of the provided
    procedures, but the services themselves.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，在日常生活中，术语API经常用于实现规范的系统。例如，您可能熟悉Twitter APIs（[https://developer.twitter.com/en/docs](https://developer.twitter.com/en/docs)）或Amazon
    APIs（[https://developer.amazon.com/services-and-apis](https://developer.amazon.com/services-and-apis)），或者您可能已经使用能够通过提供数据（测量结果）来响应请求的设备（传感器）。因此，当程序员说*我们可以使用Amazon
    API*时，他们不仅指提供的程序描述，还指服务本身。
- en: In Java, we have also a few variations of the term *API usage* that we would
    like to identify and describe in the following subsections.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们还有一些关于*API使用*的术语变体，我们希望在以下小节中进行识别和描述。
- en: Java APIs
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java API
- en: 'Java APIs include two big groups of APIs and libraries that implement them:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Java API包括两大类API和实现它们的库：
- en: Java core packages ([http://www.oracle.com/technetwork/java/api-141528.html](http://www.oracle.com/technetwork/java/api-141528.html))
    that come with the Java installation and are included in the JDK
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java核心包（[http://www.oracle.com/technetwork/java/api-141528.html](http://www.oracle.com/technetwork/java/api-141528.html)）随Java安装提供并包含在JDK中
- en: Other frameworks and libraries that can be downloaded separately, such as Apache
    Commons APIs ([https://commons.apache.org](https://commons.apache.org)), for example,
    or the three libraries we have already included as dependencies in the Maven `pom.xml`
    file of our demo project. The vast majority of them can be found in the Maven
    repository ([https://mvnrepository.com](https://mvnrepository.com)), but a variety
    of new and experimental libraries and frameworks can be found eslewhere.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他可以单独下载的框架和库，例如Apache Commons APIs（[https://commons.apache.org](https://commons.apache.org)），或者我们已经在Maven的`pom.xml`文件中包含为依赖项的三个库。其中绝大多数可以在Maven仓库（[https://mvnrepository.com](https://mvnrepository.com)）中找到，但也可以在其他地方找到各种新的和实验性的库和框架。
- en: Command line APIs
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行API
- en: A command line API describes the command format and its possible options that
    can be used to execute the application (tool). We have seen such examples when
    we talked about using the tools (applications) `java` and `javac` in [Chapter
    1](40b2d539-5f9c-4923-87ac-803c281a5ba7.xhtml), *Java Virtual Machine (JVM) on
    Your Computer*. We even built our own application in [Chapter 4](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml),
    *Your First Java Project,* defined its API, and described its command line API
    as accepting an integer as a parameter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行API描述了命令格式及其可能的选项，可用于执行应用程序（工具）。我们在[第1章](40b2d539-5f9c-4923-87ac-803c281a5ba7.xhtml)中讨论使用`java`和`javac`工具（应用程序）时看到了这样的例子，*您的计算机上的Java虚拟机（JVM）*。我们甚至在[第4章](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml)中构建了自己的应用程序，定义了其API，并描述了其命令行API，接受整数作为参数。
- en: HTTP-based APIs
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于HTTP的API
- en: A web-based application often provides an HTTP-based API using a variety of
    protocols ([https://en.wikipedia.org/wiki/List_of_web_service_protocols](https://en.wikipedia.org/wiki/List_of_web_service_protocols))
    that allow access to the application functionality via the internet. HTTP stands
    for Hypertext Transfer Protocol, which is an application protocol for distributed
    information systems that serves as the foundation of data communication for the
    **World Wide Web** (**WWW**).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Web的应用程序通常使用各种协议（[https://en.wikipedia.org/wiki/List_of_web_service_protocols](https://en.wikipedia.org/wiki/List_of_web_service_protocols)）提供基于HTTP的API，允许通过互联网访问应用程序功能。HTTP代表超文本传输协议，是分布式信息系统的应用协议，是**万维网**（**WWW**）数据通信的基础。
- en: 'The two most popular web service protocols are:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的两种Web服务协议是：
- en: XML-based **SOAP** (Simple Object Access Protocol) protocol
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于XML的**SOAP**（Simple Object Access Protocol）协议
- en: JSON-based REST or RESTful (**REpresentational State Transfer**) style over
    HTTP protocol
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于JSON的REST或RESTful（**REpresentational State Transfer**）风格的HTTP协议
- en: Both describe how functionality (services) can be accessed and incorporated
    into the application.  We do not describe web services in this book.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都描述了如何访问功能（服务）并将其合并到应用程序中。我们在本书中不描述Web服务。
- en: Software component API
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件组件API
- en: A software component may be a library, an application subsystem, an application
    layer, or even a single class--something that can be used directly from Java code
    by invoking its methods. An API of a software component looks like an interface
    that describes method signatures which can be invoked on the objects of classes
    that implement the interface. If the component has public static methods (which
    do not require objects and can be invoked using classes only), these methods have
    to be included in the API description as well. But for a complete description
    of the component API, as we have mentioned already in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml),
    *Java Language Basics*, the information about how the objects of the component
    can be created should be part of the API description, too.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 软件组件可以是一个库，一个应用子系统，一个应用层，甚至是一个单独的类——可以通过调用其方法直接从Java代码中使用的东西。软件组件的API看起来像描述方法签名的接口，可以在实现接口的类的对象上调用这些方法。如果组件有公共静态方法（不需要对象，只能使用类调用），这些方法也必须包含在API描述中。但是，对于组件API的完整描述，正如我们在[第2章](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml)中已经提到的那样，关于如何创建组件的对象的信息也应该是API描述的一部分。
- en: 'In this book, we are not going beyond application boundaries and will use the
    term API only in the sense of a software component API, as described previously.
    And, we will call the entities that implement an API (the services that the API
    describes) by their names: application subsystem, application layer, library,
    class, interface, and methods.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们不会超越应用程序边界，并且只会在先前描述的软件组件API的意义上使用术语API。而且，我们将按其名称称呼实现API的实体（API描述的服务）：应用子系统，应用层，库，类，接口和方法。
- en: That is why we started an API-related discussion about interfaces and object
    factories that complement each other and, together with static methods, compose
    a complete description of a software component API.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们开始了一个关于接口和对象工厂的API相关讨论，它们相互补充，并且与静态方法一起组成了软件组件API的完整描述。
- en: Interface and object factory as API
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口和对象工厂作为API
- en: The noun abstract means a content summary of a book, article, or formal speech.
    The adjective abstract means existing in thought or as an idea, but not having
    a physical or concrete existence. The verb to abstract means to consider (something)
    theoretically or separately from something else.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 名词抽象意味着书籍、文章或正式演讲的内容摘要。形容词抽象意味着存在于思想中或作为一个想法，但没有具体的或实体的存在。动词抽象意味着从理论上或与其他事物分开考虑（某事）。
- en: That is why an interface is called an abstraction—because it captures only method
    signatures and does not describe how the result is achieved. Various implementations
    of the same interface—different classes—may behave quite differently, even if
    they receive the same parameters and return the same results. The last statement
    is a loaded one because we have not defined the term behavior. Let's do it now.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么接口被称为抽象——因为它只捕捉方法签名，不描述如何实现结果。相同接口的各种实现——不同的类——可能行为完全不同，即使它们接收相同的参数并返回相同的结果。最后一句是一个有深意的陈述，因为我们还没有定义行为这个术语。现在让我们来做。
- en: The behavior of a class or its objects is defined by the actions its methods
    perform and the results they return. If a method returns nothing (`void`), it
    is said that such a method is used only for its side effects.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类或其对象的行为由其方法执行的操作和它们返回的结果定义。如果一个方法不返回任何东西（`void`），则称这样的方法仅用于其副作用。
- en: Such a view implies that a method that returns a value has a direct (not a side)
    effect. However, it can have a side effect, too, by sending a message to another
    application, for example, or storing data in a database. Ideally, one has to try
    and capture the side-effect in the method name. If that is not easy because the
    method does many things, it may indicate the need to break such a method into
    several better-focused ones.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种观点意味着返回值的方法具有直接（而不是副作用）的效果。然而，它也可能具有副作用，例如向另一个应用程序发送消息，或者在数据库中存储数据。理想情况下，应该尝试在方法名称中捕捉副作用。如果这不容易，因为方法做了很多事情，这可能表明需要将这样的方法分解为几个更好聚焦的方法。
- en: The statement that two implementations of the same method signature can have
    different behavior makes sense only when the method name does not capture all
    the side effects, or the author of the implementations did not honor the meaning
    of the method name. But even when the behavior of different implementations is
    the same, the code itself, the libraries it uses, and how effectively it works
    may be different.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 同一方法签名的两个实现可能具有不同的行为的说法只有在方法名称没有捕捉到所有副作用，或者实现的作者没有遵守方法名称的含义时才有意义。但即使不同实现的行为相同，代码本身、它使用的库以及其有效性可能是不同的。
- en: Why it is important to hide the implementation details we will explain in [Chapter
    8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml), *Object-Oriented Design (OOD)
    Principles*. For now, we will just mention that the clients' isolation from the
    implementation allows the system to be more flexible in adopting new versions
    of the same implementation or in switching to a completely different one.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么隐藏实现细节很重要，我们将在[第8章](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml)中解释，*面向对象设计（OOD）原则*。现在，我们只是提到客户端与实现的隔离允许系统更灵活地采用相同实现的新版本或完全切换到另一个实现。
- en: Interface
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: 'We talked about interfaces in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java
    Language Basics*, so now we will just look at some examples. Let''s create a new
    package, `com.packt.javapath.ch06demo.api`. Then, we can right-click `com.packt.javapath.ch06demo.api`, open
    New | Java Class, select Interface, type `Calculator`, and click the OK button.
    We have created an interface and can add to it a method signature, `int multiplyByTwo(int
    i)`, so the result looks like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml)中讨论了接口，现在我们只看一些例子。让我们创建一个新的包，`com.packt.javapath.ch06demo.api`。然后，我们可以右键单击`com.packt.javapath.ch06demo.api`，打开New
    | Java Class，选择Interface，输入`Calculator`，然后单击OK按钮。我们已经创建了一个接口，并且可以向其添加一个方法签名，`int
    multiplyByTwo(int i)`，结果如下：
- en: '![](img/3bf0e6a7-cecc-4cfe-bc2b-3337a3a24d78.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3bf0e6a7-cecc-4cfe-bc2b-3337a3a24d78.png)'
- en: This will be the public face of every class that implements this interface.
    In real life, we would not use the package name `api` and use `calculator` instead,
    as it is more specific and descriptive. But we are discussing the term "API" and
    that is the reason we decided to name the package this way.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是实现此接口的每个类的公共接口。在现实生活中，我们不会使用包名称`api`，而是使用`calculator`，因为它更具体和描述性。但是我们正在讨论术语“API”，这就是我们决定以这种方式命名包的原因。
- en: 'Let''s create another package,  `com.packt.javapath.ch06demo.api.impl`, which
    will hold all implementations of `Calculator` and other interfaces that we will
    add to the `com.packt.javapath.ch06demo.api` package. The first implementation
    is the `CalulatorImpl` class. By now, you should know already how to create the
    `com.packt.javapath.ch06demo.api.impl` package and the `CalulatorImpl` class in
    it. The result should look like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个包，`com.packt.javapath.ch06demo.api.impl`，其中将保存所有`Calculator`的实现和我们将添加到`com.packt.javapath.ch06demo.api`包中的其他接口。第一个实现是`CalulatorImpl`类。到目前为止，您应该已经知道如何在其中创建`com.packt.javapath.ch06demo.api.impl`包和`CalulatorImpl`类。结果应该如下所示：
- en: '![](img/d6e713bb-a6b6-40d0-8fe0-7be774bf7f0d.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6e713bb-a6b6-40d0-8fe0-7be774bf7f0d.png)'
- en: We have put implementations in the package one level deeper than `api`, thus
    indicating that those are details that should not be exposed to the users of the
    API we create.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现放在了比`api`更深一级的包中，这表明这些细节不应该暴露给我们创建的API的用户。
- en: 'In addition, we need to write a test and use it to make sure our functionality
    is correct and convenient for users. Again, we assume that by now you know how
    to do it. The result should look like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要编写一个测试并使用它来确保我们的功能对用户来说是正确和方便的。同样，我们假设您现在知道如何做到这一点。结果应该如下所示：
- en: '![](img/8199defb-2557-47f7-97e8-35febe1cb351.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8199defb-2557-47f7-97e8-35febe1cb351.png)'
- en: 'Then, we add the missing test body and annotations as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加缺失的测试主体和注释，如下所示：
- en: '```java'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '@DisplayName("API Calculator tests")'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '@DisplayName("API Calculator tests")'
- en: public class CalculatorTest {
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: public class CalculatorTest {
- en: '@Test'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '@Test'
- en: '@DisplayName("Happy multiplyByTwo()")'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '@DisplayName("Happy multiplyByTwo()")'
- en: void multiplyByTwo(){
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: void multiplyByTwo(){
- en: CalculatorImpl calculator = new CalculatorImpl();
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: CalculatorImpl calculator = new CalculatorImpl();
- en: int i = 2;
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: int i = 2;
- en: int result = calculator.multiplyByTwo(i);
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: int result = calculator.multiplyByTwo(i);
- en: assertEquals(4, result);
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: assertEquals(4, result);
- en: '}'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This code serves us not only as the functionality test; it can also be viewed
    as an example of a client code the API users would write. So, the test helps us
    to see our API from a client perspective. Looking at this code, we realize that we
    were not able to completely hide the implementation. The `CalculatorImpl` class
    is still accessed by the client directly, even if we change the line that creates
    the object to the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不仅作为功能测试，还可以被视为API用户编写的客户端代码的示例。因此，测试帮助我们从客户端的角度看待我们的API。通过观察这段代码，我们意识到我们无法完全隐藏实现细节。即使我们将创建对象的行更改为以下内容：
- en: '```java'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Calculator calculator = new CalculatorImpl();
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Calculator calculator = new CalculatorImpl();
- en: '```'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This means that if case we change the signature of the `CalculatorImpl` constructor
    or switch to another implementation of the same interface (let it be called `AnotherCalculatorImpl`),
    the client code has to be changed, too. To avoid it, programmers use classes called
    object factories.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果我们更改`CalculatorImpl`构造函数的签名或切换到同一接口的另一个实现（称为`AnotherCalculatorImpl`），客户端代码也必须更改。为了避免这种情况，程序员使用称为对象工厂的类。
- en: Object factory
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Object factory
- en: 'The purpose of an object factory is to hide the details of object creation
    so that the client does not need to change the code if the implementation changes.
    Let''s create a factory that produces `Calculator` objects. We will put it in the
    same package, `com.packt.javapath.ch06demo.api.impl`, as the implementations of
    the `Calculator` interface reside in:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对象工厂的目的是隐藏对象创建的细节，以便客户端在实现更改时无需更改代码。让我们创建一个生产`Calculator`对象的工厂。我们将把它放在与`Calculator`接口的实现位于同一包`com.packt.javapath.ch06demo.api.impl`中：
- en: '![](img/525f9e16-73db-40de-ae66-c526bd1ab207.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/525f9e16-73db-40de-ae66-c526bd1ab207.png)'
- en: 'And we can change the test (client code) to use this factory:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更改测试（客户端代码）以使用此工厂：
- en: '```java'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '@DisplayName("API Calculator tests")'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '@DisplayName("API Calculator tests")'
- en: public class CalculatorTest {
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: public class CalculatorTest {
- en: '@Test'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '@Test'
- en: '@DisplayName("Happy multiplyByTwo()")'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '@DisplayName("Happy multiplyByTwo()")'
- en: void multiplyByTwo(){
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: void multiplyByTwo(){
- en: Calculator calculator = CalculatorFactory.createInstance();
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Calculator calculator = CalculatorFactory.createInstance();
- en: int i = 2;
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: int i = 2;
- en: int result = calculator.multiplyByTwo(i);
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: int result = calculator.multiplyByTwo(i);
- en: assertEquals(4, result);
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 断言（4，结果）;
- en: '}'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'With that, we have achieved our goal: the client code does not have any notion
    of the classes that implement `Calculator` interface. We can, for example, change
    the factory so that it creates objects of another class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们已经实现了我们的目标：客户端代码不会对实现`Calculator`接口的类有任何概念。例如，我们可以更改工厂，以便它创建另一个类的对象：
- en: '```java'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public static Calculator create(){
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: public static Calculator create(){
- en: return AnotherCalculatorImpl();
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: return AnotherCalculatorImpl();
- en: '}'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The `AnotherCalculatorImpl` class may look like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnotherCalculatorImpl`类可能如下所示：'
- en: '```java'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class AnotherCalculatorImpl  implements Calculator {
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: class AnotherCalculatorImpl  implements Calculator {
- en: public int multiplyByTwo(int i){
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: public int multiplyByTwo(int i){
- en: System.out.println(AnotherCalculatorImpl.class.getName());
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(AnotherCalculatorImpl.class.getName());
- en: return i + i;
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: return i + i;
- en: '}'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This `multiplyByTwo()` method adds two values instead of multiplying the input
    parameter by 2.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`multiplyByTwo()`方法是将两个值相加，而不是将输入参数乘以2。
- en: 'We also can make the factory read the configuration file and instantiate the
    implementation based on the configuration file values:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使工厂读取配置文件，并根据配置文件的值实例化实现：
- en: '```java'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class CalculatorFactory {
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: public class CalculatorFactory {
- en: public static Calculator create(){
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: public static Calculator create(){
- en: String whichImpl =
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: String whichImpl =
- en: Utils.getStringValueFromConfig("calculator.conf", "which.impl");
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Utils.getStringValueFromConfig("calculator.conf", "which.impl");
- en: if(whichImpl.equals("multiplies")){
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: if(whichImpl.equals("multiplies")){
- en: return new CalculatorImpl();
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: return new CalculatorImpl();
- en: '} else if (whichImpl.equals("adds")){'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '} else if (whichImpl.equals("adds")){'
- en: return new AnotherCalculatorImpl();
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个新的AnotherCalculatorImpl();
- en: '} else {'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: throw new RuntimeException("Houston, we have a problem. " +
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: throw new RuntimeException("休斯顿，我们有问题。" +
- en: '"Unknown key which.impl value " + whichImpl + " is in config.");'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '"未知的键which.impl值" + whichImpl + "在配置中。");'
- en: '}'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We did not talk about the `if...else` constructions or about the `RuntimeException` class
    yet (see [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control Flow
    Statements*). And, we will discuss the `Utils.getStringValueFromConfig()` method
    shortly. But, we hope you understand what this code does:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论`if...else`结构或`RuntimeException`类（参见[第10章](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml)，*控制流语句*）。我们很快会讨论`Utils.getStringValueFromConfig()`方法。但是，我们希望你理解这段代码的作用：
- en: Reads the configuration file
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取配置文件
- en: Instantiates the class depending on the value of the `which.impl` key
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据`which.impl`键的值实例化类
- en: Exits the method by throwing an exception (thus informing the client that there
    is a problem that has to be resolved) if there is no class that corresponds to
    the value of the `which.impl` key
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有与`which.impl`键的值对应的类，则通过抛出异常退出方法（因此通知客户端存在必须解决的问题）
- en: 'And here is how the configuration file `calculator.conf` may look:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是配置文件`calculator.conf`可能的样子：
- en: '```java'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '{'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"which.impl": "multiplies"'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '"which.impl": "multiplies"'
- en: '}'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This is called **JavaScript Object Notation** (**JSON**) format, which is based
    on key-value pairs separated by a colon (`:`). You can read more about JSON at
    [http://www.json.org/](http://www.json.org/).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这称为**JavaScript对象表示**（**JSON**）格式，它基于由冒号（`:`）分隔的键值对。您可以在[http://www.json.org/](http://www.json.org/)上了解更多关于JSON的信息。
- en: The `calculator.conf` file resides in the `resources` directory (a subdirectory
    of the `main` directory). Maven, by default, places the content of this directory
    on the classpath, so it can be found by the application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculator.conf`文件位于`resources`目录（`main`目录的子目录）中。默认情况下，Maven将此目录的内容放在类路径上，因此应用程序可以找到它。'
- en: 'To tell the factory to use another `Calculator` implementation, we need to
    do only the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要告诉工厂使用另一个`Calculator`实现，我们只需要做以下事情：
- en: Change the value of the key `which.impl` in the file `calculator.conf`
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改文件`calculator.conf`中键`which.impl`的值
- en: Change the factory `create()` method to instantiate the new implementation based
    on this new value
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改工厂的`create()`方法以根据这个新值实例化新的实现
- en: It is important to notice that the client code (`CalculatorTest` class) is not
    affected when we switch `Calculator` implementation. That is the advantage of
    hiding the implementation details from the client code using the interface and
    object factory class.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，当我们切换`Calculator`实现时，客户端代码（`CalculatorTest`类）不受影响。这是使用接口和对象工厂类隐藏实现细节对客户端代码的优势。
- en: Now, let's look inside the `Utils` class and its `getStringValueFromConfig()` method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`Utils`类及其`getStringValueFromConfig()`方法的内部。
- en: Reading configuration file
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取配置文件
- en: By looking at the real-life implementation of the `getStringValueFromConfig()` method, we
    are jumping ahead of your knowledge of Java and Java libraries. So we do not expect
    you to understand all the details, but we hope this exposure will give you an
    idea about how things are done and what are we aiming at in our course.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看`getStringValueFromConfig()`方法的真实实现，我们超前于你对Java和Java库的了解。因此，我们不希望你理解所有的细节，但我们希望这种暴露会让你了解事情是如何做的，我们的课程目标是什么。
- en: Using the json-simple library
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用json-simple库
- en: 'The `getStringValueFromConfig()` method is located in the `Utils` class, which
    we have created to read the values from the `.conf` file. This class has the following
    code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`getStringValueFromConfig()`方法位于`Utils`类中，我们已经创建了这个类来从`.conf`文件中读取值。这个类有以下代码：'
- en: '```java'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: import org.json.simple.JSONObject;
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: import org.json.simple.JSONObject;
- en: import org.json.simple.parser.JSONParser;
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: import org.json.simple.parser.JSONParser;
- en: import org.json.simple.parser.ParseException;
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: import org.json.simple.parser.ParseException;
- en: public class Utils {
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: public class Utils {
- en: private static JSONObject config = null;
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: private static JSONObject config = null;
- en: public static String getStringValueFromConfig(String configFileName,
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: public static String getStringValueFromConfig(String configFileName,
- en: String key){
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: String key){
- en: if(config == null){
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: if(config == null){
- en: ClassLoader classLoader = Utils.class.getClassLoader();
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ClassLoader classLoader = Utils.class.getClassLoader();
- en: File file =
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: File file =
- en: new File(classLoader.getResource(configFileName).getFile());
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: new File(classLoader.getResource(configFileName).getFile());
- en: try(FileReader fr = new FileReader(file)){
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: try(FileReader fr = new FileReader(file)){
- en: JSONParser parser = new JSONParser();
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: JSONParser parser = new JSONParser();
- en: config = (JSONObject) parser.parse(fr);
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: config = (JSONObject) parser.parse(fr);
- en: '} catch (ParseException | IOException ex){'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (ParseException | IOException ex){'
- en: ex.printStackTrace();
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace();
- en: return "Problem reading config file.";
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: return "Problem reading config file.";
- en: '}'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'return config.get(key) == null ? "unknown" : (String)config.get(key);'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 'return config.get(key) == null ? "unknown" : (String)config.get(key);'
- en: '}'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: First of all, please notice the technique called caching. We check the value
    of the `config` static class field first. If it is not `null`, we use it. Otherwise, we
    find the `config` file on the classpath using the same class loader that was used
    to load the known class we passed in as a parameter.  We parse the config file,
    which means breaking it into key-value pairs. The result is the reference to the
    generated object of the `JSONObject` class we assign to the `config` field (cache
    it so the next time it will be available to use).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意称为缓存的技术。我们首先检查`config`静态类字段的值。如果它不是`null`，我们就使用它。否则，我们使用相同的类加载器在类路径上找到`config`文件，该类加载器用于加载我们传递的已知类。我们解析配置文件，这意味着将其分解为键值对。结果是我们分配给`config`字段的`JSONObject`类的生成对象的引用（缓存它，以便下次可以使用）。
- en: That is the caching technique, used to avoid wasting time and other resources.
    The drawback of this solution is that any change to the configuration file requires
    restarting the application so the file can be read again. In our case, we assumed
    it is acceptable. But in other cases, we could add a timer and refresh the cached
    data after the defined period of time has passed, or do something similar.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是缓存技术，用于避免浪费时间和其他资源。这种解决方案的缺点是，对配置文件的任何更改都需要重新启动应用程序，以便重新读取文件。在我们的情况下，我们假设这是可以接受的。但在其他情况下，我们可以添加一个定时器，并在定义的时间段过后刷新缓存数据，或者做类似的事情。
- en: 'To read the config file, we use the `FileReader` class from the Apache Commons
    library ([https://commons.apache.org/proper/commons-io](https://commons.apache.org/proper/commons-io)).
    To let Maven know that we need this library, we have added the following dependency
    to the `pom.xml` file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取配置文件，我们使用Apache Commons库中的`FileReader`类（[https://commons.apache.org/proper/commons-io](https://commons.apache.org/proper/commons-io)）。为了让Maven知道我们需要这个库，我们已经将以下依赖项添加到`pom.xml`文件中：
- en: '```java'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: <dependency>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <dependency>
- en: <groupId>commons-io</groupId>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <groupId>commons-io</groupId>
- en: <artifactId>commons-io</artifactId>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <artifactId>commons-io</artifactId>
- en: <version>2.5</version>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <version>2.5</version>
- en: </dependency>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: </dependency>
- en: '```'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'To process data in JSON format, we use JSON.simple library (released under Apache
    License, too) and have added the following dependency to `pom.xml`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理JSON格式的数据，我们使用JSON.simple库（也是根据Apache许可发布的），并将以下依赖项添加到`pom.xml`中：
- en: '```java'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: <dependency>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <dependency>
- en: <groupId>com.googlecode.json-simple</groupId>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <groupId>com.googlecode.json-simple</groupId>
- en: <artifactId>json-simple</artifactId>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <artifactId>json-simple</artifactId>
- en: <version>1.1</version>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <version>1.1</version>
- en: </dependency>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: </dependency>
- en: '```'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `JSONObject` class stores key-value pairs presented in JSON format. If the
    passed-in key is not present in the file, the object of the `JSONObject` class returns
    the value `null`. In such a case, our `getStringValueFromConfig()` method returns
    a `String` literal unknown. Otherwise, it casts the return value to `String`.
    We can do it because we know that the value can be assigned to a variable of `String` type.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSONObject`类以JSON格式存储键值对。如果传入的键在文件中不存在，`JSONObject`类的对象返回值为`null`。在这种情况下，我们的`getStringValueFromConfig()`方法返回一个`String`字面量unknown。否则，它将返回值转换为`String`。我们可以这样做，因为我们知道该值可以赋给`String`类型的变量。'
- en: 'The `<condition>? <option1> : <option2>` construct is called a ternary operator.
    It returns `option1` when the condition is true, and otherwise returns `option2`.
    We will talk about it more in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml), *Operators,
    Expressions, and Statements*.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`<condition>? <option1> : <option2>`构造被称为三元运算符。当条件为真时，它返回`option1`，否则返回`option2`。我们将在[第9章](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml)中更多地讨论它，*运算符、表达式和语句*。'
- en: Using the json-api library
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用json-api库
- en: 'Alternatively, we could use another JSON processing API and its implementation:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用另一个JSON处理API及其实现：
- en: '```java'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: <dependency>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <dependency>
- en: <groupId>javax.json</groupId>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <groupId>javax.json</groupId>
- en: <artifactId>javax.json-api</artifactId>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <artifactId>javax.json-api</artifactId>
- en: <version>1.1.2</version>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <version>1.1.2</version>
- en: </dependency>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: </dependency>
- en: <dependency>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: <dependency>
- en: <groupId>org.glassfish</groupId>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <groupId>org.glassfish</groupId>
- en: <artifactId>javax.json</artifactId>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <artifactId>javax.json</artifactId>
- en: <version>1.1.2</version>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <version>1.1.2</version>
- en: </dependency>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: </dependency>
- en: '```'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Then the code of the `getStringValueFromConfig()` method would look slightly
    different:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`getStringValueFromConfig()`方法的代码看起来会有些不同：
- en: '```java'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: import javax.json.Json;
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.json.Json;
- en: import javax.json.JsonObject;
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.json.JsonObject;
- en: import javax.json.JsonReader;
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.json.JsonReader;
- en: public class Utils {
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: public class Utils {
- en: private static JsonObject config = null;
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: private static JsonObject config = null;
- en: public static String getStringValueFromConfig(String FileName,
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: public static String getStringValueFromConfig(String FileName,
- en: String key){
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: String key){
- en: if(config == null){
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: if(config == null){
- en: ClassLoader classLoader = Utils.class.getClassLoader();
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ClassLoader classLoader = Utils.class.getClassLoader();
- en: File file = new File(classLoader.getResource(fileName).getFile());
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: File file = new File(classLoader.getResource(fileName).getFile());
- en: try(FileInputStream fis = new FileInputStream(file)){
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: try(FileInputStream fis = new FileInputStream(file)){
- en: JsonReader reader = Json.createReader(fis);
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: JsonReader reader = Json.createReader(fis);
- en: config = reader.readObject();
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: config = reader.readObject();
- en: '} catch (IOException ex){'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (IOException ex){'
- en: ex.printStackTrace();
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace();
- en: return "Problem reading config file.";
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: return "Problem reading config file.";
- en: '}'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'return config.get(key) == null ? "unknown" : config.getString(key);'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 'return config.get(key) == null ? "unknown" : config.getString(key);'
- en: '}'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This second implementation requires a bit less code and uses a more consistent
    camel case style (`JsonObject` versus `JSONObject`). But, since their performance
    is not very different, which library to use is largely a matter of a personal
    preference.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第二个实现需要的代码稍微少一些，并且使用了更一致的驼峰命名风格（`JsonObject`与`JSONObject`）。但是，由于它们的性能并没有太大的不同，使用哪个库在很大程度上取决于个人偏好。
- en: Unit test
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Let''s create a unit test that proves the method works as expected. By now,
    you should be able to create a `UtilsTest` class in the `test/java/com/packt/javapath/ch06demo` directory
    (or in the `test\java\com\packt\javapath\ch06demo` directory in the case of the
    Windows). The test should look like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们创建一个单元测试，证明该方法按预期工作。到目前为止，你应该能够在`test/java/com/packt/javapath/ch06demo`目录（或在Windows的`test\java\com\packt\javapath\ch06demo`目录）中创建一个`UtilsTest`类。测试应该如下所示:'
- en: '```java'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '@DisplayName("Utils tests")'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '@DisplayName("Utils测试")'
- en: public class UtilsTest {
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 公共类UtilsTest{
- en: '@Test'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '@Test'
- en: '@DisplayName("Test reading value from config file by key")'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '@DisplayName("按键从配置文件中读取值的测试")'
- en: void getStringValueFromConfig(){
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: void getStringValueFromConfig(){
- en: //test body we will write here
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: //我们将在这里编写测试主体
- en: '}'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Next, we add the `test/resources/utilstest.conf`  file (`test\resources\utilstest.conf` for
    Windows):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们添加`test/resources/utilstest.conf`文件（对于Windows是`test\resources\utilstest.conf`）:'
- en: '```java'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '{'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"unknown": "some value"'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '"unknown": "some value"'
- en: '}'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'It will play the role of a `config` file. With that, the test code looks as
    follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '它将扮演`config`文件的角色。有了这个，测试代码看起来如下:'
- en: '```java'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '@Test'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '@Test'
- en: '@DisplayName("Test reading value from config file by key")'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '@DisplayName("按键从配置文件中读取值的测试")'
- en: void getStringValueFromConfig(){
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: void getStringValueFromConfig(){
- en: String fileName = "utilstest.conf";
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: String fileName = "utilstest.conf";
- en: String value = Utils.getStringValueFromConfig(fileName, "some value");
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: String value = Utils.getStringValueFromConfig(fileName, "some value");
- en: assertEquals("some value", value);
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: assertEquals("some value", value);
- en: value = Utils.getStringValueFromConfig(fileName, "some value");
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: value = Utils.getStringValueFromConfig(fileName, "some value");
- en: assertEquals("unknown", value);
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: assertEquals("unknown", value);
- en: '}'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We test two cases:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '我们测试两种情况:'
- en: The returned value should be equal `some value` in the first case
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的值应该在第一种情况下等于`some value`
- en: The value should come back as `unknown` if the key does not exist in the config
    file
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在配置文件中键不存在，则值应该返回为`unknown`
- en: 'We run this test and observe the success. To make sure, we can also change
    the `utilstest.conf` file settings to the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '我们运行这个测试并观察成功。为了确保，我们还可以将`utilstest.conf`文件的设置更改为以下内容:'
- en: '```java'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '{'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"unknown": "another value"'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '"unknown": "another value"'
- en: '}'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This should cause the test to fail the first case.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该导致测试在第一种情况下失败。
- en: Let's revisit the Calculator API.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视一下Calculator API。
- en: Calculator API
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算器API
- en: 'Based on the previous discussion, we can describe the Calculator API in the
    `Calculator` interface as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '根据前面的讨论，我们可以在`Calculator`接口中描述Calculator API如下:'
- en: '```java'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public interface Calculator {
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 公共接口计算器{
- en: int multiplyByTwo(int i);
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: int multiplyByTwo(int i);
- en: '}'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: static Calculator createInstance(){
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: static Calculator createInstance(){
- en: return CalculatorFactory.create();
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: return CalculatorFactory.create();
- en: '}'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: If the constructor of the `Calculator` implementation requires parameters, we
    would add them to the `create()`  factory method and to the `createInstance()` static
    method of the interface.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Calculator`实现的构造函数需要参数，我们将把它们添加到接口的`create()`工厂方法和`createInstance()`静态方法中。
- en: When only one implementation of the `Calculator` interface exists, the previous
    API declaration would be enough. But when you give the client a choice of two
    or more implementations, as we have described previously, then the API should
    also include the description of `calculator.conf` configuration file.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Calculator`接口只存在一个实现时，前面的API声明就足够了。但是当你给客户端提供两个或更多的实现选择时，就像我们之前描述的那样，API还应该包括`calculator.conf`配置文件的描述。
- en: The configuration description would have to list all possible values of the
    `which.impl` key (`multiplies` and `adds`, in our case). We would also need to
    explain how the implementations are different so that the programmer who uses
    our calculator could make an informed choice.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`配置描述`将不得不列出`which.impl`键的所有可能值（在我们的例子中是`multiplies`和`adds`）。我们还需要解释实现之间的差异，以便使用我们的计算器的程序员能够做出知情的选择。'
- en: If that sounds like too much, then you might step back and look at your API
    design again because it is probably not well focused and tries to cover too many
    things. Consider breaking such an API into several simpler APIs. Describing each
    of these smaller APIs is easier both to write and to understand.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来太多了，那么你可能需要退一步重新审视你的API设计，因为它可能没有很好地聚焦，试图涵盖太多东西。考虑将这样的API分解为几个更简单的API。描述每个较小的API更容易编写和理解。
- en: 'For example, here is how the configuration description can be added to an interface
    in our case:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，这是如何在我们的情况下将配置描述添加到接口中的:'
- en: '```java'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public interface Calculator {
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 公共接口计算器{
- en: int multiplyByTwo(int i);
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: int multiplyByTwo(int i);
- en: static Calculator createInstance(){
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: static Calculator createInstance(){
- en: return  CalculatorFactory.create();
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: return  CalculatorFactory.create();
- en: '}'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: String CONF_NAME = "calculator.conf";
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: String CONF_NAME = "calculator.conf";
- en: String CONF_WHICH_IMPL = "which.impl";
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: String CONF_WHICH_IMPL = "which.impl";
- en: enum WhichImpl{
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: enum WhichImpl{
- en: multiplies, //use multiplication operation
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: multiplies, //使用乘法运算
- en: adds        //use addition operation
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: adds        //使用加法运算
- en: '}'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, we have captured the configuration filename in a constant, as
    well as the configuration key name. And we have created an `enum` for all possible
    values of the key. We have also added an explanation of the difference between
    the implementations as a comment. If the explanation is too long, the comment
    can provide a reference to documentation, a website name, or a URL, for example.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在常量中捕获了配置文件名，以及配置键名。我们还为键的所有可能值创建了一个`enum`。我们还添加了实现之间差异的解释作为注释。如果解释太长，注释可以提供对文档、网站名称或URL的引用，例如。
- en: Since there are two implementations and two possible values in the configuration
    file, we need to run our unit test `CalculatorTest` twice—for each possible value
    of the configuration—to make sure that both implementations work as expected.
    But we do not want to change the configuration inside the deliverable software
    component itself.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Since there are two implementations and two possible values in the configuration
    file, we need to run our unit test `CalculatorTest` twice—for each possible value
    of the configuration—to make sure that both implementations work as expected.
    But we do not want to change the configuration inside the deliverable software
    component itself.
- en: 'That is when the `test/resources` directory (`test\resources` for Windows)
    comes into play again. Let''s create a `calculator.conf` file in it and add the
    following lines to the `CalculatorTest` test, which will print the current settings
    in that file:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 'That is when the `test/resources` directory (`test\resources` for Windows)
    comes into play again. Let''s create a `calculator.conf` file in it and add the
    following lines to the `CalculatorTest` test, which will print the current settings
    in that file:'
- en: '```java'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String whichImpl =
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: String whichImpl =
- en: Utils.getStringValueFromConfig(Calculator.CONF_NAME,
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Utils.getStringValueFromConfig(Calculator.CONF_NAME,
- en: Calculator.CONF_WHICH_IMPL);
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Calculator.CONF_WHICH_IMPL);
- en: System.out.println(Calculator.CONF_WHICH_IMPL + "=" + whichImpl);
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Calculator.CONF_WHICH_IMPL + "=" + whichImpl);
- en: '```'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The `CalculatorTest` code should look as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `CalculatorTest` code should look as follows:'
- en: '```java'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void multiplyByTwo() {
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: void multiplyByTwo() {
- en: WhichImpl whichImpl =
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: WhichImpl whichImpl =
- en: Utils.getWhichImplValueFromConfig(Calculator.CONF_NAME,
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Utils.getWhichImplValueFromConfig(Calculator.CONF_NAME,
- en: Calculator.CONF_WHICH_IMPL);
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Calculator.CONF_WHICH_IMPL);
- en: System.out.println("\n" + Calculator.CONF_WHICH_IMPL +
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("\n" + Calculator.CONF_WHICH_IMPL +
- en: '"=" + whichImpl);'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '"=" + whichImpl);'
- en: Calculator calculator = Calculator.createInstance();
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Calculator calculator = Calculator.createInstance();
- en: int i = 2;
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: int i = 2;
- en: int result = calculator.multiplyByTwo(i);
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: int result = calculator.multiplyByTwo(i);
- en: assertEquals(4, result);
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: assertEquals(4, result);
- en: '}'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Let''s also add a line that prints out the class name of each implementation:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 'Let''s also add a line that prints out the class name of each implementation:'
- en: '```java'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class CalculatorImpl implements Calculator {
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: public class CalculatorImpl implements Calculator {
- en: public int multiplyByTwo(int i){
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: public int multiplyByTwo(int i){
- en: System.out.println(CalculatorImpl.class.getClass().getName());
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(CalculatorImpl.class.getClass().getName());
- en: return i * 2;
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: return i * 2;
- en: '}'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class AnotherCalculatorImpl implements Calculator {
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: public class AnotherCalculatorImpl implements Calculator {
- en: public int multiplyByTwo(int i){
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: public int multiplyByTwo(int i){
- en: System.out.println(AnotherCalculatorImpl.class.getClass().getName());
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(AnotherCalculatorImpl.class.getClass().getName());
- en: return i + i;
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: return i + i;
- en: '}'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we set the value of `which.impl` (in the `calculator.conf` file in the `test`
    directory) to `adds`, it will look like this:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 'If we set the value of `which.impl` (in the `calculator.conf` file in the `test`
    directory) to `adds`, it will look like this:'
- en: '![](img/a123ab51-0369-4fe3-ac54-a73a829b2d6a.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a123ab51-0369-4fe3-ac54-a73a829b2d6a.png)'
- en: 'And the result of the `CalculatorTest` test will be:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 'And the result of the `CalculatorTest` test will be:'
- en: '![](img/4af08c61-2654-40bc-89c4-a10f08681e58.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4af08c61-2654-40bc-89c4-a10f08681e58.png)'
- en: 'The output tells us three things:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 'The output tells us three things:'
- en: The value of `which.impl` in `calculator.conf` was set to `adds`
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The value of `which.impl` in `calculator.conf` was set to `adds`
- en: The corresponding implementation of `AnotherCalculatorImpl` was used
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The corresponding implementation of `AnotherCalculatorImpl` was used
- en: The invoked implementation worked as expected
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The invoked implementation worked as expected
- en: Similarly, we can run our unit test for the `calculator.conf` file set to `multiplies`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Similarly, we can run our unit test for the `calculator.conf` file set to `multiplies`.
- en: 'The result looks very good, but we still can improve the code and make it less
    susceptible to error, if sometime in the future somebody decides to enhance the
    functionality by adding a new implementation or something similar. We can take
    advantage of the constants added to the `Calculator` interface and make the `create()`  factory
    method more protected from a human mistake:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 'The result looks very good, but we still can improve the code and make it less
    susceptible to error, if sometime in the future somebody decides to enhance the
    functionality by adding a new implementation or something similar. We can take
    advantage of the constants added to the `Calculator` interface and make the `create()`  factory
    method more protected from a human mistake:'
- en: '```java'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public static Calculator create(){
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: public static Calculator create(){
- en: String whichImpl = Utils.getStringValueFromConfig(Calculator.CONF_NAME,
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: String whichImpl = Utils.getStringValueFromConfig(Calculator.CONF_NAME,
- en: Calculator.CONF_WHICH_IMPL);
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Calculator.CONF_WHICH_IMPL);
- en: if(whichImpl.equals(Calculator.WhichImpl.multiplies.name())){
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: if(whichImpl.equals(Calculator.WhichImpl.multiplies.name())){
- en: return new CalculatorImpl();
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: return new CalculatorImpl();
- en: '} else if (whichImpl.equals(Calculator.WhichImpl.adds.name())){'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '} else if (whichImpl.equals(Calculator.WhichImpl.adds.name())){'
- en: return new AnotherCalculatorImpl();
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: return new AnotherCalculatorImpl();
- en: '} else {'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: throw new RuntimeException("Houston, we have a problem. " +
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: throw new RuntimeException("Houston, we have a problem. " +
- en: '"Unknown key " + Calculator.CONF_WHICH_IMPL +'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '"Unknown key " + Calculator.CONF_WHICH_IMPL +'
- en: '" value " + whichImpl + " is in config.");'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '" value " + whichImpl + " is in config.");'
- en: '}'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Just to make sure that the test doing its job, we change the value in the `calculator.conf` file
    in the test directory to `add` (instead of `adds`) and run the test again. The
    output will be as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 'Just to make sure that the test doing its job, we change the value in the `calculator.conf` file
    in the test directory to `add` (instead of `adds`) and run the test again. The
    output will be as follows:'
- en: '![](img/252fb2df-1745-4fa7-8b42-92fae0a4f19d.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![](img/252fb2df-1745-4fa7-8b42-92fae0a4f19d.png)'
- en: The test failed, as was expected. It gives us a level of confidence that the
    code works and doesn't just always show success.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: The test failed, as was expected. It gives us a level of confidence that the
    code works and doesn't just always show success.
- en: 'Yet, the code can be improved to become more readable, more testable, and less
    susceptible to human errors when it is modified or expanded. Using the knowledge
    of the `enum` functionality, we can write a method that converts the value of
    the key `which.impl` in the `calculator.conf` file to one of the constants (instances)
    of the class `enum WhichImpl`. To do it, we add this new method to the class `Utils`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 'Yet, the code can be improved to become more readable, more testable, and less
    susceptible to human errors when it is modified or expanded. Using the knowledge
    of the `enum` functionality, we can write a method that converts the value of
    the key `which.impl` in the `calculator.conf` file to one of the constants (instances)
    of the class `enum WhichImpl`. To do it, we add this new method to the class `Utils`:'
- en: '```java'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: WhichImpl getWhichImplValueFromConfig(String configFileName, String key){
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: WhichImpl getWhichImplValueFromConfig(String configFileName, String key){
- en: String whichImpl = getStringValueFromConfig(configFileName, key);
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: String whichImpl = getStringValueFromConfig(configFileName, key);
- en: try{
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: try{
- en: return Enum.valueOf(WhichImpl.class, whichImpl);
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: return Enum.valueOf(WhichImpl.class, whichImpl);
- en: '} catch (IllegalArgumentException ex){'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (IllegalArgumentException ex){'
- en: throw new RuntimeException("Houston, we have a problem. " +
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: throw new RuntimeException("Houston, we have a problem. " +
- en: '"Unknown key " + Calculator.CONF_WHICH_IMPL +'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '"Unknown key " + Calculator.CONF_WHICH_IMPL +'
- en: '" value " + whichImpl + " is in config.");'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '" value " + whichImpl + " is in config.");'
- en: '}'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This code is based on the usage of the method `getStringValueFromConfig()`, which
    we have tested already and know it works as expected. The construct `try...catch` allows
    us to capture and process situations when some code (the method `Enum.valueOf()` in
    this case) encounters a condition it cannot resolve and throws an exception (we
    will learn more about this in [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control
    Flow Statements*). One has to read the Java API documentation in order to know
    that the method `Enum.valueOf()` can throw an exception. For example, here is
    a quote from the documentation about the method `Enum.valueOf()`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码基于`getStringValueFromConfig()`方法的使用，我们已经测试过并知道它按预期工作。`try...catch`结构允许我们捕获和处理一些代码（在这种情况下是`Enum.valueOf()`方法）遇到无法解决的条件并抛出异常的情况（我们将在[第10章](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml)中学到更多关于这个的知识，*控制流语句*）。人们必须阅读Java
    API文档，才能知道`Enum.valueOf()`方法可能会抛出异常。例如，这是关于`Enum.valueOf()`方法的文档中的一句引用：
- en: '"Throws: IllegalArgumentException - if the specified enum type has no constant
    with the specified name or the specified class object does not represent an enum
    type"'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '"Throws: IllegalArgumentException - 如果指定的枚举类型没有具有指定名称的常量，或者指定的类对象不表示枚举类型"'
- en: It is a good idea to read the API documentation of any third-party class you
    are going to use. In our code, we catch it and throw a new exception with our
    own wording for consistency.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读即将使用的任何第三方类的API文档是一个好主意。在我们的代码中，我们捕获它并以一致的方式用我们自己的措辞抛出一个新的异常。
- en: 'As you would expect, we have also written a unit test for the method `getWhichImplValueFromConfig()`
    and added it to `UtilsTest`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的，我们还为`getWhichImplValueFromConfig()`方法编写了一个单元测试，并将其添加到`UtilsTest`中：
- en: '```java'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '@Test'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '@Test'
- en: '@DisplayName("Test matching config value to enum WhichImpl")'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '@DisplayName("Test matching config value to enum WhichImpl")'
- en: void getWhichImpValueFromConfig(){
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: void getWhichImpValueFromConfig(){
- en: String confifFileName = "utilstest.conf";
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: String confifFileName = "utilstest.conf";
- en: for(int i = 1; i <= WhichImpl.values().length; i++){
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: for(int i = 1; i <= WhichImpl.values().length; i++){
- en: String key = String.valueOf(i);
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: String key = String.valueOf(i);
- en: WhichImpl whichImpl =
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: WhichImpl whichImpl =
- en: Utils.getWhichImplValueFromConfig(confifFileName, key);
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Utils.getWhichImplValueFromConfig(confifFileName, key);
- en: System.out.println(key + "=" + whichImpl);
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(key + "=" + whichImpl);
- en: '}'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: try {
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: try {
- en: WhichImpl whichImpl =
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: WhichImpl whichImpl =
- en: Utils.getWhichImplValueFromConfig(confifFileName, "unknown");
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: Utils.getWhichImplValueFromConfig(confifFileName, "unknown");
- en: fail("Should not get here! whichImpl = " + whichImpl);
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: fail("Should not get here! whichImpl = " + whichImpl);
- en: '} catch (RuntimeException ex){'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (RuntimeException ex){'
- en: assertEquals("Houston, we have a problem. " +
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: assertEquals("Houston, we have a problem. " +
- en: '"Unknown key which.impl value unknown is in config.",'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '"Unknown key which.impl value unknown is in config.",'
- en: ex.getMessage());
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: ex.getMessage());
- en: '}'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: try {
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: try {
- en: WhichImpl whichImpl =
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: WhichImpl whichImpl =
- en: Utils.getWhichImplValueFromConfig(confifFileName, "some value");
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: Utils.getWhichImplValueFromConfig(confifFileName, "some value");
- en: fail("Should not get here! whichImpl = " + whichImpl);
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: fail("Should not get here! whichImpl = " + whichImpl);
- en: '} catch (RuntimeException ex){'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (RuntimeException ex){'
- en: assertEquals("Houston, we have a problem. " +
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: assertEquals("Houston, we have a problem. " +
- en: '"Unknown key which.impl value unknown is in config.",'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '"Unknown key which.impl value unknown is in config.",'
- en: ex.getMessage());
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: ex.getMessage());
- en: '}'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'To support this test, we have also added two more entries to the `utilstest.conf`
    file:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这个测试，我们还在`utilstest.conf`文件中添加了两个条目：
- en: '```java'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '{'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"1": "multiplies",'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '"1": "multiplies",```'
- en: '"2": "adds",'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '"2": "adds",'
- en: '"unknown": "unknown"'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '"unknown": "unknown"'
- en: '}'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This test covers three cases:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试涵盖了三种情况：
- en: If all the constants from the `enum WhichImpl` are present in the config file,
    the method `getWhichImplValueFromConfig()` works just fine—it finds each of them
    and does not throw an exception
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`enum WhichImpl`中的所有常量都存在于配置文件中，那么`getWhichImplValueFromConfig()`方法就可以正常工作——它会找到它们中的每一个，不会抛出异常
- en: If the key passed into the method `getWhichImplValueFromConfig()` is not from `enum
    WhichImpl`, the method throws an exception with the message `Houston, we have
    a problem. Unknown key which.impl value unknown is in config`
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果传递给`getWhichImplValueFromConfig()`方法的键不是来自`enum WhichImpl`，则该方法会抛出一个异常，其中包含消息`Houston,
    we have a problem. Unknown key which.impl value unknown is in config`
- en: If the key passed into the method `getWhichImplValueFromConfig()` is not present
    in the config file, the method throws an exception with the message `Houston,
    we have a problem. Unknown key which.impl value unknown is in config`
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果传递给`getWhichImplValueFromConfig()`方法的键在配置文件中不存在，则该方法会抛出一个异常，其中包含消息`Houston,
    we have a problem. Unknown key which.impl value unknown is in config`
- en: 'When we have confidence that this method works as expected, we can rewrite
    the factory method `create()` as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们确信这个方法按预期工作时，我们可以重写`create()`工厂方法如下：
- en: '```java'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public static Calculator create(){
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: public static Calculator create(){
- en: WhichImpl whichImpl =
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: WhichImpl whichImpl =
- en: Utils.getWhichImplValueFromConfig(Calculator.CONF_NAME,
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: Utils.getWhichImplValueFromConfig(Calculator.CONF_NAME,
- en: Calculator.CONF_WHICH_IMPL);
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: Calculator.CONF_WHICH_IMPL);
- en: switch (whichImpl){
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: switch (whichImpl){
- en: 'case multiplies:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 'case multiplies:'
- en: return new CalculatorImpl();
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: return new CalculatorImpl();
- en: 'case adds:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 'case adds:'
- en: return new AnotherCalculatorImpl();
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: return new AnotherCalculatorImpl();
- en: 'default:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 'default:'
- en: throw new RuntimeException("Houston, we have another " +
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: throw new RuntimeException("Houston, we have another " +
- en: '"problem. We do not have implementation for the key " +'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '"problem. We do not have implementation for the key " +'
- en: Calculator.CONF_WHICH_IMPL + " value " + whichImpl);
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: Calculator.CONF_WHICH_IMPL + " value " + whichImpl);
- en: '}'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The `switch()` construct is quite straightforward: it directs the execution
    thread to the code block under the case that matches the corresponding value (more
    about it in [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control
    Flow Statements*).'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch()`结构非常简单：它将执行线程定向到与匹配相应值的case下的代码块（更多信息请参阅[第10章](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml)，*控制流语句*）。'
- en: 'The benefit of creating and using the method `getWhichImplValueFromConfig()` is
    that the `create()` method became much cleaner and focused on one task only: creating
    the right object. We will talk about the *Single Responsibility Principle* in
    section *So many OOD principles and so little time* of [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml), *Object-Oriented
    Design (OOD) Principles*.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 'The benefit of creating and using the method `getWhichImplValueFromConfig()` is
    that the `create()` method became much cleaner and focused on one task only: creating
    the right object. We will talk about the *Single Responsibility Principle* in
    section *So many OOD principles and so little time* of [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml), *Object-Oriented
    Design (OOD) Principles*.'
- en: We have captured the Calculator API in one place—the interface `Calculator`
    —and we have tested it and proved that it works as designed. But there is another
    possible API aspect—the last one—we have not covered, yet.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: We have captured the Calculator API in one place—the interface `Calculator`
    —and we have tested it and proved that it works as designed. But there is another
    possible API aspect—the last one—we have not covered, yet.
- en: Adding static methods to API
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Adding static methods to API
- en: Each of the classes that implement the `Calculator` interface may have static
    methods in addition to the instance methods defined in the interface. If such
    static methods could be helpful to the API's users, we should be able to document
    them in the `Calculator` interface, too, and that is what we are going to do now.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: Each of the classes that implement the `Calculator` interface may have static
    methods in addition to the instance methods defined in the interface. If such
    static methods could be helpful to the API's users, we should be able to document
    them in the `Calculator` interface, too, and that is what we are going to do now.
- en: 'Let''s assume that each of the implementations of the `Calculator` interface
    has a static method, `addOneAndConvertToString()`:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 'Let''s assume that each of the implementations of the `Calculator` interface
    has a static method, `addOneAndConvertToString()`:'
- en: '```java'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class CalculatorImpl implements Calculator {
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: public class CalculatorImpl implements Calculator {
- en: public static String addOneAndConvertToString(double d){
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: public static String addOneAndConvertToString(double d){
- en: System.out.println(CalculatorImpl.class.getName());
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(CalculatorImpl.class.getName());
- en: return Double.toString(d + 1);
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: return Double.toString(d + 1);
- en: '}'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //...
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: '}'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class AnotherCalculatorImpl implements Calculator {
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: public class AnotherCalculatorImpl implements Calculator {
- en: public static String addOneAndConvertToString(double d){
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: public static String addOneAndConvertToString(double d){
- en: System.out.println(AnotherCalculatorImpl.class.getName());
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(AnotherCalculatorImpl.class.getName());
- en: return String.format("%.2f", d + 1);
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: return String.format("%.2f", d + 1);
- en: '}'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //...
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: '}'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice that the methods have the same signature but slightly different implementations.
    The method in `CalculatorImpl` returns the result as is, while the method in `AnotherCalculatorImpl` returns
    the formatted value with two decimal places (we will show the result shortly).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Notice that the methods have the same signature but slightly different implementations.
    The method in `CalculatorImpl` returns the result as is, while the method in `AnotherCalculatorImpl` returns
    the formatted value with two decimal places (we will show the result shortly).
- en: 'Usually, static methods are called via a dot-operator applied to a class:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 'Usually, static methods are called via a dot-operator applied to a class:'
- en: '```java'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String s1 = CalculatorImpl.addOneAndConvertToString(42d);
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: String s1 = CalculatorImpl.addOneAndConvertToString(42d);
- en: String s2 = AnotherCalculatorImpl.addOneAndConvertToString(42d);
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: String s2 = AnotherCalculatorImpl.addOneAndConvertToString(42d);
- en: '```'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'But, we would like to hide (encapsulate) from an API client the implementation
    details so that the client code continues to use only the interface `Calculator`.
    To accomplish that goal, we will use the class `CalculatorFactory` again and add
    to it the following method:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 'But, we would like to hide (encapsulate) from an API client the implementation
    details so that the client code continues to use only the interface `Calculator`.
    To accomplish that goal, we will use the class `CalculatorFactory` again and add
    to it the following method:'
- en: '```java'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public static String addOneAndConvertToString(double d){
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: public static String addOneAndConvertToString(double d){
- en: WhichImpl whichImpl =
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: WhichImpl whichImpl =
- en: Utils.getWhichImplValueFromConfig(Calculator.CONF_NAME,
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: Utils.getWhichImplValueFromConfig(Calculator.CONF_NAME,
- en: Calculator.CONF_WHICH_IMPL);
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: Calculator.CONF_WHICH_IMPL);
- en: switch (whichImpl){
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: switch (whichImpl){
- en: 'case multiplies:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 'case multiplies:'
- en: return CalculatorImpl.addOneAndConvertToString(d);
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: return CalculatorImpl.addOneAndConvertToString(d);
- en: 'case adds:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 'case adds:'
- en: return AnotherCalculatorImpl.addOneAndConvertToString(d);
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: return AnotherCalculatorImpl.addOneAndConvertToString(d);
- en: 'default:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 'default:'
- en: throw new RuntimeException("Houston, we have another " +
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: throw new RuntimeException("Houston, we have another " +
- en: '"problem. We do not have implementation for the key " +'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '"problem. We do not have implementation for the key " +'
- en: Calculator.CONF_WHICH_IMPL + " value " + whichImpl);
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: Calculator.CONF_WHICH_IMPL + " value " + whichImpl);
- en: '}'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you may have noticed, it looks very similar to the factory method `create()`.
    We also used the same values of the `which.impl` property—`multiplies` and `adds`—as
    identification of the class. With that, we can add the following static method
    to the `Calculator` interface:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 'As you may have noticed, it looks very similar to the factory method `create()`.
    We also used the same values of the `which.impl` property—`multiplies` and `adds`—as
    identification of the class. With that, we can add the following static method
    to the `Calculator` interface:'
- en: '```java'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: static String addOneAndConvertToString(double d){
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: static String addOneAndConvertToString(double d){
- en: return CalculatorFactory.addOneAndConvertToString(d);
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: return CalculatorFactory.addOneAndConvertToString(d);
- en: '}'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, this way we were able to hide the names of the classes that
    implemented the interface `Calculator` and the static method `addOneAndConvertToString
    ()`, too.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: As you can see, this way we were able to hide the names of the classes that
    implemented the interface `Calculator` and the static method `addOneAndConvertToString
    ()`, too.
- en: 'To test this new addition, we have expanded code in `CalculatorTest` by adding
    these lines:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 'To test this new addition, we have expanded code in `CalculatorTest` by adding
    these lines:'
- en: '```java'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: double d = 2.12345678;
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: double d = 2.12345678;
- en: String mString = "3.12345678";
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: String mString = "3.12345678";
- en: String aString = "3.12";
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: String aString = "3.12";
- en: String s = Calculator.addOneAndConvertToString(d);
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: String s = Calculator.addOneAndConvertToString(d);
- en: if(whichImpl.equals(Calculator.WhichImpl.multiplies)){
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: if(whichImpl.equals(Calculator.WhichImpl.multiplies)){
- en: assertEquals(mString, s);
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: assertEquals(mString, s);
- en: '} else {'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: assertNotEquals(mString, s);
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: assertNotEquals(mString, s);
- en: '}'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if(whichImpl.equals(Calculator.WhichImpl.adds)){
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: if(whichImpl.equals(Calculator.WhichImpl.adds)){
- en: assertEquals(aString, s);
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: assertEquals(aString, s);
- en: '} else {'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: assertNotEquals(aString, s);
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: assertNotEquals(aString, s);
- en: '}'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In the test, we expect one value of `String` type, in case of `WhichImpl.multiplies`
    and the same value in a different format (only two decimal places) in the case
    of `WhichImpl.adds`. Let''s run `CalculatorTest` with the following setting in `calculator.conf`:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我们期望`String`类型的一个值，在`WhichImpl.multiplies`的情况下是相同的值，而在`WhichImpl.adds`的情况下是不同格式的值（只有两位小数）。让我们在`calculator.conf`中使用以下设置运行`CalculatorTest`：
- en: '```java'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '{'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"which.impl": "adds"'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '"which.impl": "adds"'
- en: '}'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result is:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '![](img/d70771b8-dd6c-442b-a6cd-8ea6393c6e3d.png)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d70771b8-dd6c-442b-a6cd-8ea6393c6e3d.png)'
- en: 'And when we set  `calculator.conf` to the value `multiplies`, the result is
    as follows:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`calculator.conf`设置为值`multiplies`时，结果如下：
- en: '![](img/bbaa099b-1060-4191-8a6e-87d12be01e1f.png)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbaa099b-1060-4191-8a6e-87d12be01e1f.png)'
- en: With that, we complete the discussion on the Calculator API.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们完成了对计算器API的讨论。
- en: The API is complete
  id: totrans-515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API已完成
- en: 'The final version of our API looks as follows:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API的最终版本如下：
- en: '```java'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public interface Calculator {
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: public interface Calculator {
- en: int multiplyByTwo(int i);
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: int multiplyByTwo(int i);
- en: static Calculator createInstance(){
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 静态计算器createInstance(){
- en: return  CalculatorFactory.create();
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: return  CalculatorFactory.create();
- en: '}'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: static String addOneAndConvertToString(double d){
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: static String addOneAndConvertToString(double d){
- en: return  CalculatorFactory.addOneAndConvertToString(d);
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: return  CalculatorFactory.addOneAndConvertToString(d);
- en: '}'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: String CONF_NAME = "calculator.conf";  //file name
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: String CONF_NAME = "calculator.conf";  //文件名
- en: String CONF_WHICH_IMPL = "which.impl"; //key in the .conf file
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: String CONF_WHICH_IMPL = "which.impl"; // .conf文件中的键
- en: enum WhichImpl{
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举WhichImpl{
- en: multiplies, //uses multiplication operation
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: multiplies, //使用乘法运算
- en: // and returns addOneAndConvertToString()
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: // 并返回addOneAndConvertToString()
- en: // result without formating
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: // 无格式的结果
- en: adds    //uses addition operation
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: adds    //使用加法运算
- en: // and returns addOneAndConvertToString()
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: // 并返回addOneAndConvertToString()
- en: // result with two decimals only
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: // 仅显示两位小数的结果
- en: '}'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This way, we maintain the single source of record—the interface that captures
    all the API details. If more details are needed, the comments may refer to some
    external URL with full documentation that describes each of the `Calculator` implementations.
    And, to repeat what we have said already at the beginning of this section, the
    method name should describe all the side effects the method produces.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们保持了单一的记录源——捕获所有API细节的接口。如果需要更多细节，注释可以引用一些外部URL，其中包含描述每个`Calculator`实现的完整文档。并且，重复我们在本节开头已经说过的，方法名称应该描述方法产生的所有副作用。
- en: In practice, programmers try to write small, well-focused methods and capture
    everything the method does in its name, but they rarely add more than abstract
    signatures to an interface. And when they talk about APIs they usually mean only
    abstract signatures, which is the most important aspect of an API. But we think
    it is a good idea to also document all other API aspects in one place.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，程序员试图编写小巧、重点突出的方法，并在方法名称中捕获方法的所有内容，但他们很少在接口中添加更多的抽象签名。当他们谈论API时，他们通常只指的是抽象签名，这是API最重要的方面。但我们认为在一个地方记录所有其他API方面也是一个好主意。
- en: Overloading, overriding, and hiding
  id: totrans-540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重载、重写和隐藏
- en: We have already mentioned method overriding and explained it in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml),
    *Java Language Basics*. Method overriding is replacing the methods implemented
    in a parent class (or default methods implemented in an interface) with the methods
    of the same signatures in the child class (or in the class that implements the
    interface, or in the child interface correspondingly). Method overloading is creating
    several methods with the same name and different parameters (thus, different signatures)
    in the same class or interface. In this section, we will discuss overriding and
    overloading the members of an interface, a class, and a class instance in more
    detail and will explain what hiding is as well. We start with an interface.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了方法重写，并在[第2章](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml)中解释了它，*Java语言基础*。方法重写是用子类（或实现接口的类中的默认方法）的方法替换父类中实现的方法，这些方法具有相同的签名（或在实现接口的类中，或在相应的子接口中）。方法重载是在同一个类或接口中创建几个具有相同名称和不同参数（因此，不同签名）的方法。在本节中，我们将更详细地讨论接口、类和类实例的重写和重载成员，并解释隐藏是什么。我们从一个接口开始。
- en: Interface method overloading
  id: totrans-542
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口方法重载
- en: We already said in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java
    Language Basics*, that in addition to abstract methods, an interface can have default
    methods and static members—constants, methods, and classes.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml)，*Java语言基础*中已经说过，除了抽象方法，接口还可以有默认方法和静态成员——常量、方法和类。
- en: 'If an abstract, default, or static method `m()` already exists in an interface,
    one cannot add another method `m()` with the same signature (method name and list
    of parameter types). So, the following examples generate compilation errors because
    each pair of methods has the same signature, while the access modifier (`private`,
    `public`), `static` or `default` keywords, returned value type, and implementation
    are not part of the signature:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接口中已经存在抽象、默认或静态方法`m()`，就不能添加另一个具有相同签名（方法名称和参数类型列表）的方法`m()`。因此，以下示例生成编译错误，因为每对方法具有相同的签名，而访问修饰符（`private`、`public`）、`static`或`default`关键字、返回值类型和实现不是签名的一部分：
- en: '```java'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface A {
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 接口A {
- en: int m(String s);
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: int m(String s);
- en: double m(String s);
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 双重m(String s);
- en: '}'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface B {
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 接口B {
- en: int m(int s);
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: int m(int s);
- en: static int m(int i) { return 42; }
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: static int m(int i) { return 42; }
- en: '}'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface C {
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 接口C {
- en: int m(double i);
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: int m(double i);
- en: private double m(double s) { return 42d; }
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: private double m(double s) { return 42d; }
- en: '}'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface D {
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 接口D {
- en: int m(String s);
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: int m(String s);
- en: default int m(String s) { return 42; }
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: default int m(String s) { return 42; }
- en: '}'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface E {
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 接口E {
- en: private int m(int s) { return 1; };
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: private int m(int s) { return 1; };
- en: default double m(int i) { return 42d; }
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: default double m(int i) { return 42d; }
- en: '}'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface F {
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 接口F {
- en: default int m(String s) { return 1; };
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: default int m(String s) { return 1; };
- en: static int m(String s) { return 42; }
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: static int m(String s) { return 42; }
- en: '}'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface G {
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 接口G {
- en: private int m(double d) { return 1; };
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: private int m(double d) { return 1; };
- en: static int m(double s) { return 42; }
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: static int m(double s) { return 42; }
- en: '}'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface H {
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 接口H {
- en: default int m(int i) { return 1; };
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: default int m(int i) { return 1; };
- en: default double m(int s) { return 42d; }
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: default double m(int s) { return 42d; }
- en: '}'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'To create a different signature, one has either to change the method name or
    change the list of parameter types. Having two or more methods with the same method
    name and different parameter types constitutes method overloading. Here are a
    few examples of legitimate method overloading in an interface:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建不同的签名，要么更改方法名称，要么更改参数类型列表。具有相同方法名称和不同参数类型的两个或多个方法构成方法重载。以下是接口中合法的方法重载示例：
- en: '```java'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface A {
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 接口A {
- en: int m(String s);
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: int m(String s);
- en: int m(String s, double d);
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: int m(String s, double d);
- en: int m(double d, String s);
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: int m(double d, String s);
- en: String m(int i);
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: String m(int i);
- en: private double m(double d) { return 42d; }
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: private double m(double d) { return 42d; }
- en: private int m(int i, String s) { return 1; }
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: private int m(int i, String s) { return 1; }
- en: default int m(String s, int i) { return 1; }
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: default int m(String s, int i) { return 1; }
- en: '}'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface B {
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 接口B {
- en: static int m(String s, int i) { return 42; }
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: static int m(String s, int i) { return 42; }
- en: static int m(String s) { return 42; }
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: static int m(String s) { return 42; }
- en: '}'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Overloading is applied to inherited methods, too, which means that the following
    overloading of non-static methods is not different from the previous example:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 重载也适用于继承的方法，这意味着以下非静态方法的重载与前面的示例没有区别：
- en: '```java'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface D {
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 接口D {
- en: default int m(int i, String s) { return 1; }
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: default int m(int i, String s) { return 1; }
- en: default int m(String s, int i) { return 1; }
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: default int m(String s, int i) { return 1; }
- en: '}'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface C {
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 接口C {
- en: default double m(double d) { return 42d; }
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: default double m(double d) { return 42d; }
- en: '}'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface B extends C, D {
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 接口B扩展自C, D {
- en: int m(double d, String s);
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: int m(double d, String s);
- en: String m(int i);
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: String m(int i);
- en: '}'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface A extends B {
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 接口A扩展自B {
- en: int m(String s);
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: int m(String s);
- en: int m(String s, double d);
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: int m(String s, double d);
- en: '}'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You have probably noticed that we have changed the `private` methods to `default` in
    the previous code. We did it because otherwise the `private` access modifier makes
    the method inaccessible to a child interface and thus cannot be overloaded in
    a child.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们在上一个代码中将`private`方法更改为`default`。我们这样做是因为`private`访问修饰符会使方法对子接口不可访问，因此无法在子接口中重载。
- en: 'As for the static methods, the following combinations of static and non-static
    methods, although allowed, do not constitute overloading:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 至于静态方法，以下组合的静态和非静态方法虽然允许，但不构成重载：
- en: '```java'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface A {
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 接口A {
- en: int m(String s);
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: int m(String s);
- en: static int m(String s, double d) { return 1 }
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: static int m(String s, double d) { return 1 }
- en: '}'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface B {
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 接口B {
- en: int m(String s, int i);
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: int m(String s, int i);
- en: static int m(String s) { return 42; }
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: static int m(String s) { return 42; }
- en: '}'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface D {
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 接口D {
- en: default int m(String s, int s) { return 1; }
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: default int m(String s, int s) { return 1; }
- en: static int m(String s, double s) { return 42; }
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: static int m(String s, double s) { return 42; }
- en: '}'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface E {
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 接口E {
- en: private int m() { return 1; }
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: private int m() { return 1; }
- en: static int m(String s) { return 42; }
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: static int m(String s) { return 42; }
- en: '}'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Static methods belong to a class (and thus exist uniquely in the application),
    while non-static methods are associated with an instance (and a method copy is
    created for each object).
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法属于类（因此在应用程序中是唯一的），而非静态方法与实例相关（每个对象都会创建一个方法副本）。
- en: 'For the same reason, static methods of different interfaces do not overload
    each other, even if the interfaces have a parent-child relationship:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 出于同样的原因，不同接口的静态方法不会相互重载，即使这些接口存在父子关系：
- en: '```java'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface G {
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 接口G {
- en: static int m(String s) { return 42; }
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: static int m(String s) { return 42; }
- en: '}'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface F extends G {
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 接口F扩展自G {
- en: static int m(String s, int i) { return 42; }
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: static int m(String s, int i) { return 42; }
- en: '}'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Only the static methods that belong to the same interface can overload each
    other, while non-static interface methods can be overloaded even if they belong
    to different interfaces, provided they have parent-child relations.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 只有属于同一接口的静态方法才能相互重载，而非静态接口方法即使属于不同接口也可以重载，前提是它们具有父子关系。
- en: Interface method overriding
  id: totrans-644
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口方法重写
- en: By contrast with overloading, which happens with the static and non-static methods
    of signatures that are different but have the same name, method overriding happens
    only with non-static methods and only when they have exactly the same signature.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 与重载相比，重写只发生在非静态方法，并且只有当它们具有完全相同的签名时才会发生。
- en: 'Another difference is that the overriding method resides in the child interface,
    while the overridden method belongs to the parent interface. The following are
    examples of method overriding:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是，重写方法位于子接口中，而被重写的方法属于父接口。以下是方法重写的示例：
- en: '```java'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface D {
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 接口D {
- en: default int m(String s) { // does not override anything
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: default int m(String s) { // 不重写任何内容
- en: return 1;
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 返回1;
- en: '}'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface C extends D {
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 接口C扩展自D {
- en: default int m(String d) { // overrides method of D
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: default int m(String d) { // 重写D的方法
- en: return 42;
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: return 42;
- en: '}'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The class that implements interface `C` directly and does not implement the
    method `m()` will get the implementation of this method from interface `C` and
    will not get the implementation of this method from interface `D`. Only the class
    that implements interface `D` directly and does not implement the method `m()`
    will get the implementation from interface `D`.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 直接实现接口`C`的类，如果没有实现方法`m()`，将从接口`C`获取该方法的实现，而不会从接口`D`获取该方法的实现。只有直接实现接口`D`的类，如果没有实现方法`m()`，将从接口`D`获取该方法的实现。
- en: 'Notice that we use the word directly. By saying that class `X` implements interface
    `C` directly, we mean that class `X` is defined as follows: `class X implements
    C`. If interface `C extends D`, then class `X` implements interface `D` as well,
    but not directly. That is an important distinction because the methods of interface
    `C` in such a case can override the methods of interface `D` that have the same
    signature, thus making them inaccessible for class `X`.'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用了直接这个词。通过说类`X`直接实现接口`C`，我们的意思是类`X`定义如下：`class X implements C`。如果接口`C`扩展D，则类`X`也实现接口`D`，但不是直接实现。这是一个重要的区别，因为在这种情况下，接口`C`的方法可以覆盖具有相同签名的接口`D`的方法，从而使它们对类`X`不可访问。
- en: 'While writing code that depends on overriding, a good practice would be to
    use the annotation `@Override` which expresses the programmer''s intent. The Java
    compiler and an IDE that uses it then check whether overriding took place and
    generates an error if the method with this annotation does not override anything.
    Here are some examples:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写依赖于覆盖的代码时，一个好的做法是使用注解`@Override`来表达程序员的意图。然后，Java编译器和使用它的IDE将检查覆盖是否发生，并在带有此注解的方法没有覆盖任何内容时生成错误。以下是一些例子：
- en: '```java'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface B {
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 接口B {
- en: int m(String s);
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: int m(String s);
- en: '}'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface A extends B {
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 接口A扩展B {
- en: '@Override             //no error'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override             //no error'
- en: int m(String s);
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: int m(String s);
- en: '}'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface D {
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 接口D {
- en: default int m1(String s) { return 1; }
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 默认int m1(String s) { return 1; }
- en: '}'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface C extends D {
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 接口C扩展D {
- en: '@Override            //error'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override            //error'
- en: default int m(String d) { return 42; }
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 默认int m(String d) { return 42; }
- en: '}'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The error will help you notice that the method in the parent interface is spelled
    differently (`m1()` versus `m()`). And here is another example:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 错误将帮助您注意到父接口中的方法拼写不同（`m1()`与`m()`）。以下是另一个例子：
- en: '```java'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface D {
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 接口D {
- en: static int m(String s) { return 1; }
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 静态int m(String s) { return 1; }
- en: '}'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface C extends D {
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 接口C扩展D {
- en: '@Override                  //error'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override                  //error'
- en: default int m(String d) { return 42; }
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 默认int m(String d) { return 42; }
- en: '}'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This example generates an error because an instance method cannot override
    a static method and vice versa. Also, a static method cannot override a static
    method of the parent interface because each static method of an interface is associated
    with the interface itself, not with a class instance:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子会生成一个错误，因为实例方法不能覆盖静态方法，反之亦然。此外，静态方法不能覆盖父接口的静态方法，因为接口的每个静态方法都与接口本身相关联，而不是与类实例相关联：
- en: '```java'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface D {
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 接口D {
- en: static int m(String s) { return 1; }
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 静态int m(String s) { return 1; }
- en: '}'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface C extends D{
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 接口C扩展D{
- en: '@Override               //error'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override               //error'
- en: static int m(String d) { return 42; }
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 静态int m(String d) { return 42; }
- en: '}'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But a static method in a child interface can hide the static method with the
    same signature in a parent interface. In fact, any static member—a field, a method,
    or a class—can hide the corresponding static member of the parent interface, direct
    parent or not. We will discuss hiding in the next section.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 但是子接口中的静态方法可以隐藏父接口中具有相同签名的静态方法。实际上，任何静态成员——字段、方法或类——都可以隐藏父接口的相应静态成员，无论是直接父接口还是间接父接口。我们将在下一节讨论隐藏。
- en: Interface static member hiding
  id: totrans-699
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口静态成员隐藏
- en: 'Let''s look at the following two interfaces:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下两个接口：
- en: '```java'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface B {
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 接口B {
- en: String NAME = "B";
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: String NAME = "B";
- en: static int m(String d) { return 1; }
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 静态int m(String d) { return 1; }
- en: class Clazz{
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 类Clazz{
- en: String m(){ return "B";}
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: String m(){ return "B";}
- en: '}'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface A extends B {
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 接口A扩展B {
- en: String NAME = "A";
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: String NAME = "A";
- en: static int m(String d) { return 42; }
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 静态int m(String d) { return 42; }
- en: class Clazz{
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 类Clazz{
- en: String m(){ return "A";}
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: String m(){ return "A";}
- en: '}'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Interface `B` is a parent (also called superinterface or base interface) of
    interface `A` (called a derived interface, child interface, subinterface, or subtype).
    All the members of an interface are `public` by default. Interface fields and
    classes are also `static` by default. So, all members of interfaces `A` and `B`
    are `public` and `static`. Let''s, run the following code:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 接口`B`是接口`A`的父接口（也称为超接口或基接口），接口的所有成员默认都是`public`。接口字段和类也默认都是`static`。因此，接口`A`和`B`的所有成员都是`public`和`static`。让我们运行以下代码：
- en: '```java'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public static void main(String[] args) {
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: System.out.println(B.NAME);
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(B.NAME);
- en: System.out.println(B.m(""));
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(B.m(""));
- en: System.out.println(new B.Clazz().m());
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(new B.Clazz().m());
- en: '}'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result will be as follows:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/de04757c-fb2d-4658-a5be-bad01309bd8c.png)'
  id: totrans-726
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de04757c-fb2d-4658-a5be-bad01309bd8c.png)'
- en: As you can see, the effect looks like overriding, but the mechanism that produces
    it is hiding. The difference is more prominent in the case of the hiding of class
    members, which we will discuss in the next section.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，效果看起来像是覆盖，但产生它的机制是隐藏。在类成员隐藏的情况下，差异更为显著，我们将在下一节讨论。
- en: Class member hiding
  id: totrans-728
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类成员隐藏
- en: 'Let''s look at these two classes:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这两个类：
- en: '```java'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class ClassC {
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 类ClassC {
- en: public static String field = "static field C";
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: public static String field = "static field C";
- en: public static String m(String s){
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: public static String m(String s){
- en: return "static method C";
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: return "static method C";
- en: '}'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class ClassD extends ClassC {
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 类ClassD扩展ClassC {
- en: public static String field = "static field D";
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: public static String field = "static field D";
- en: public static String m(String s){
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: public static String m(String s){
- en: return "static method D";
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: return "static method D";
- en: '}'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '}'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'They have two static members each—a field and a method. With that, look at
    the following code:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 它们每个都有两个静态成员——一个字段和一个方法。有了这个，看看以下代码：
- en: '```java'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: System.out.println(ClassD.field);
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(ClassD.field);
- en: System.out.println(ClassD.m(""));
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(ClassD.m(""));
- en: System.out.println(new ClassD().field);
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(new ClassD().field);
- en: System.out.println(new ClassD().m(""));
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(new ClassD().m(""));
- en: ClassC object = new ClassD();
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: ClassC对象 = new ClassD();
- en: System.out.println(object.field);
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(object.field);
- en: System.out.println(object.m(""));
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(object.m(""));
- en: '```'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Stop reading and try to guess what will the output be.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 停止阅读并尝试猜测输出将是什么。
- en: 'Here is the same code with numbers of lines and the output (captured in the
    comments):'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相同的代码，带有行号和输出（在注释中捕获）：
- en: '```java'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 1 System.out.println(ClassD.field);       //static field D
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 1 System.out.println(ClassD.field); //静态字段D
- en: 2 System.out.println(ClassD.m(""));       //static method D
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 2 System.out.println(ClassD.m("")); //静态方法D
- en: 3 System.out.println(new ClassD().field); //static field D
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 3 System.out.println(new ClassD().field); //静态字段D
- en: 4 System.out.println(new ClassD().m("")); //static method D
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 4 System.out.println(new ClassD().m("")); //静态方法D
- en: 5 ClassC object = new ClassD();
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 5 ClassC object = new ClassD();
- en: 6 System.out.println(object.field);       //static field C
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 6 System.out.println(object.field); //静态字段C
- en: 7 System.out.println(object.m(""));       //static method C
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 7 System.out.println(object.m("")); //静态方法C
- en: '```'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The output of the first two lines was probably expected. Lines 3 and 4 are not
    as intuitive, but probably also make sense. Any object of a class should be able
    to access class members. Nevertheless, it is not recommended to access static
    members via an object because such code hides the fact that the accessed members
    are static, which makes the code less readable and may lead to unnecessary object
    creation. Same applies to lines 6 and 7\. And, just to reiterate what we have
    discussed in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java Language
    Basics*, lines 5, 6, and 7 demonstrate that we are able to assign the object of
    `ClassD` to the reference of type `ClassC` because `ClassC` is the parent class,
    and all the children (of all generations) of a class have the same type as the
    parent class. This means that a child can have many types inherited from all its
    parents—direct and indirect. It looks like genetic inheritance, doesn't it?
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行的输出可能是预期的。第3行和第4行不太直观，但可能也是有道理的。类的任何对象都应该能够访问类成员。然而，不建议通过对象访问静态成员，因为这样的代码隐藏了所访问的成员是静态的事实，这使得代码不太可读，并可能导致不必要的对象创建。同样适用于第6行和第7行。并且，正如我们在[第2章](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml)中讨论的那样，*Java语言基础*，第5、6和7行表明我们能够将`ClassD`的对象分配给`ClassC`类型的引用，因为`ClassC`是父类，所有子类（所有世代的）都与父类具有相同的类型。这意味着子类可以从所有父类（直接和间接的）继承许多类型。这看起来像是遗传继承，不是吗？
- en: So, you can see static members of a child class (also called a derived class,
    extended class, subclass, or subtype) can hide the static members of its parent
    (also called a base class or superclass).
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以看到子类的静态成员（也称为派生类、扩展类、子类或子类型）可以隐藏其父类的静态成员（也称为基类或超类）。
- en: 'There are two differences between hiding fields and hiding methods. A static
    field:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏字段和隐藏方法之间有两个区别。一个静态字段：
- en: Hide an instance variable
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏实例变量
- en: Even hide a field with the same name but different type
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 甚至隐藏一个具有相同名称但不同类型的字段
- en: 'Here are the allowable cases for hiding, described previously:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是隐藏的允许情况，之前描述过：
- en: '```java'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class ClassC {
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 类ClassC {
- en: public static String field1 = "instance field C";
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: public static String field1 = "实例字段C";
- en: public String m1(String s){
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: public String m1(String s){
- en: return "instance method C";
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 返回"实例方法C";
- en: '}'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class ClassD extends ClassC {
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 类ClassD扩展自ClassC {
- en: public String field1 = "instance field D";
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: public String field1 = "实例字段D";
- en: public String m1(String s){
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: public String m1(String s){
- en: return "instance method D";
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 返回"实例方法D";
- en: '}'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'To demonstrate it, we can run the following code:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，我们可以运行以下代码：
- en: '```java'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: System.out.println(new ClassD().field1);
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(new ClassD().field1);
- en: System.out.println(new ClassD().m1(""));
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(new ClassD().m1(""));
- en: ClassC object1 = new ClassD();
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: ClassC object1 = new ClassD();
- en: System.out.println(object1.m1(""));
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(object1.m1(""));
- en: System.out.println(object1.field1);
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(object1.field1);
- en: System.out.println(((ClassD)object1).field1);
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(((ClassD)object1).field1);
- en: '```'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Again, you can stop reading now and guess what the output will be.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你现在可以停止阅读并猜测输出将是什么。
- en: 'Here are the results:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是结果：
- en: '```java'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 1 System.out.println(new ClassD().field1);     //instance field D
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 1 System.out.println(new ClassD().field1); //实例字段D
- en: 2 System.out.println(new ClassD().m1(""));     //instance method D
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 2 System.out.println(new ClassD().m1("")); //实例方法D
- en: 3 ClassC object1 = new ClassD();
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 3 ClassC object1 = new ClassD();
- en: 4 System.out.println(object1.m1(""));          //instance method D
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 4 System.out.println(object1.m1("")); //实例方法D
- en: 5 System.out.println(object1.field1);          //instance field C
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 5 System.out.println(object1.field1); //实例字段C
- en: 6 System.out.println(((ClassD)object1).field1);//instance field D
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 6 System.out.println(((ClassD)object1).field1); //实例字段D
- en: '```'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see, line 5 outputs the value of the static variable `ClassC.field1` although
    the field with the same name, `field1`, exists in `ClassD`, too. Even if we change
    `field1` in `ClassC` to non-static, the same result will be displayed: line 5
    prints out the value of the field using the declared type of the reference `object1`,
    not the actual type of the object assigned to it. To make matters even more complicated,
    as we have stated before, the type of the field `field1` in `ClassC` may be different
    from the type of field with the same name in `ClassD`, and the effect of public
    field hiding will still be the same.'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，第5行输出了静态变量`ClassC.field1`的值，尽管`ClassD`中也存在同名的字段`field1`。即使我们将`ClassC`中的`field1`更改为非静态，也会显示相同的结果：第5行打印出使用引用`object1`的声明类型的字段的值，而不是分配给它的对象的实际类型。更让事情变得更加复杂的是，正如我们之前所述，`ClassC`中`field1`的类型可能与`ClassD`中同名字段的类型不同，而公共字段隐藏的效果仍然是相同的。
- en: 'To avoid confusion, always follow these two best practices:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免混淆，始终遵循这两个最佳实践：
- en: Write the identifier of a static variable in uppercase characters, while the
    identifier of an instance variable should be in lowercase
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将静态变量的标识符写成大写字符，而实例变量的标识符应该是小写的
- en: 'Try to never allow public access to the instance fields; make them private
    and access to their values via getters and setters, instead:'
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试永远不要公开访问实例字段；将它们设为私有，并通过getter和setter访问它们的值：
- en: '```java'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class ClassC {
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 类ClassC {
- en: private String field1 = "instance field C";
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 私有字符串字段1 = "实例字段C";
- en: public String getField(){ return field1; }
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: public String getField(){ return field1; }
- en: public void setField(String s){ field1 = s; }
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: public void setField(String s){ field1 = s; }
- en: public String m1(String s){
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: public String m1(String s){
- en: return "instance class C";
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: return "实例类C";
- en: '}'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class ClassD extends ClassC {
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: class ClassD extends ClassC {
- en: private String field1 = "instance field D";
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: private String field1 = "实例字段D";
- en: public String getField(){ return field1; }
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: public String getField(){ return field1; }
- en: public void setField(String s){ field1 = s; }
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: public void setField(String s){ field1 = s; }
- en: public String m1(String s){
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: public String m1(String s){
- en: return "instance class D";
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: return "实例类D";
- en: '}'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This way, in the case of overriding or hiding, you will have only one set of
    rules related to methods. It is much simpler and more straightforward. Besides,
    you can have better control over the values of the private fields. For example,
    you can add code to the setter that makes sure that the field is never assigned `null` or
    another undesirable value.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，在覆盖或隐藏的情况下，您将只有一组与方法相关的规则。这更简单，更直接。此外，您可以更好地控制私有字段的值。例如，您可以向setter添加代码，以确保字段永远不会被赋予`null`或其他不良值。
- en: Instance method overriding
  id: totrans-827
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例方法覆盖
- en: Since, as we have seen in the previous section, class (or static) members cannot
    override each other but only hide, we can talk about overriding instance members,
    only. We have also already established that instance fields hide each other and
    the rules of field hiding are quite different from the much simpler rules of method
    overriding, so the best practice would be to not expose instance fields and access
    their values via getters and setters only. This way, instance member overriding
    is reduced to instance method overriding, and that is what we are going to describe
    in this section.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们在前一节中所看到的，类（或静态）成员不能相互覆盖，而只能隐藏，我们只能谈论覆盖实例成员。我们也已经确定实例字段相互隐藏，字段隐藏的规则与方法覆盖的规则相当不同，因此最佳实践是不公开实例字段，只通过getter和setter访问它们的值。这样，实例成员覆盖就减少到实例方法覆盖，这就是我们将在本节中描述的内容。
- en: 'The rules for instance method overriding are not different than the rules for
    interface default method overriding: a method in a child class overrides the method
    in a parent class with the same signature. If the signatures are different, but
    the method name is the same, the method is overloaded, not overridden. So, if
    you would like to override a method, it is always advisable to add the `@Override`
    annotation to the method to make sure it is not just overloaded silently.'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 实例方法覆盖的规则与接口默认方法覆盖的规则没有不同：子类中的方法覆盖具有相同签名的父类中的方法。如果签名不同，但方法名称相同，则该方法是重载而不是覆盖。因此，如果您想要覆盖一个方法，最好始终向方法添加`@Override`注释，以确保它不仅仅是静默地重载。
- en: As we have established earlier, too, a static method in a child class cannot
    override an instance method from the parent class. It makes class instance overriding
    rules much simpler than interface overriding rules.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所确定的，子类中的静态方法不能覆盖父类中的实例方法。这使得类实例覆盖规则比接口覆盖规则简单得多。
- en: One important feature to note is that constructors, although they look like
    methods, are not methods or even members of the class. A constructor doesn’t have
    a return type and has the same name as the class. Therefore, a constructor cannot
    be overridden, but it can be overloaded. Its only purpose is to be called when
    a new instance of the class (object) is created.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的特点要注意的是，尽管构造函数看起来像方法，但它们不是类的方法甚至不是类的成员。构造函数没有返回类型，并且与类具有相同的名称。因此，构造函数不能被覆盖，但可以被重载。它的唯一目的是在创建类（对象）的新实例时被调用。
- en: 'With that, we move to the last subsection of the *Overloading, overriding,
    and hiding* section: instance method overloading.'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就转到了*重载、覆盖和隐藏*部分的最后一个小节：实例方法重载。
- en: Instance method overloading
  id: totrans-833
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例方法重载
- en: 'For instance method overloading, there are just two statements to describe
    it:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实例方法重载，只有两个语句来描述它：
- en: For a non-static method to be overloaded, it has to have the same name and a different
    set of parameter types as another non-static method of the same class or the class
    that has a parent-child relationship with the class that contains the overloaded
    method
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使非静态方法重载，它必须与同一类或具有父子关系的类中的另一个非静态方法具有相同的名称和不同的参数类型集。
- en: A private non-static method can be overloaded only by a non-static method of
    the same class.
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有非静态方法只能由同一类的非静态方法重载。
- en: 'So, here is an example of method overloading:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是一个方法重载的示例：
- en: '```java'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void m() {
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: void m() {
- en: // some code
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: // 一些代码
- en: '}'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: int m(String s){
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: int m(String s){
- en: // some code
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: // 一些代码
- en: return 1;
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: return 1;
- en: '}'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void m(int i){
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: void m(int i){
- en: // some code
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: // 一些代码
- en: '}'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: int m(String s, double d){
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: int m(String s, double d){
- en: // some code
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: // 一些代码
- en: return 1;
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: return 1;
- en: '}'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: int m(double d, String s){
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: int m(double d, String s){
- en: // some code
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: // 一些代码
- en: return 1;
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: return 1;
- en: '}'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, the name of the overloaded method stays the same, but the number
    of parameters, their type, or the sequence of parameter types, must be different.
    Otherwise, it is not overloading and the compiler will generate an error. The
    returned type does not play any role in the overloading. It can be the same or
    different.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，重载方法的名称保持不变，但参数的数量、它们的类型或参数类型的顺序必须不同。否则，它不是重载，编译器将生成错误。返回类型在重载中不起任何作用。它可以相同也可以不同。
- en: To look at it from another perspective, all the overloaded methods are considered
    different. In the previous example, we could just give a different name to each
    method and have exactly the same code behavior. So, overloading is useful when
    you have several methods with the same functionality (that's why you don't want
    to change the method name), but different parameters or different parameter types.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个角度来看，所有重载的方法都被认为是不同的。在前面的例子中，我们可以为每个方法赋予不同的名称，并且具有完全相同的代码行为。因此，当您有几个具有相同功能的方法（这就是为什么您不想更改方法名称）但具有不同的参数或不同的参数类型时，重载是有用的。
- en: 'Here is one possible case of overloading use. You might remember one of the
    first classes we created was called `SimpleMath`:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 'Here is one possible case of overloading use. You might remember one of the
    first classes we created was called `SimpleMath`:'
- en: '```java'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class SimpleMath {
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: public class SimpleMath {
- en: public int multiplyByTwo(int i){
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: public int multiplyByTwo(int i){
- en: return i * 2;
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: return i * 2;
- en: '}'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Then, we might want to add to it another method that, for user convenience,
    will accept a number as a `String` type: `multiplyByTwo(String s)`. We could do
    it the following way:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 'Then, we might want to add to it another method that, for user convenience,
    will accept a number as a `String` type: `multiplyByTwo(String s)`. We could do
    it the following way:'
- en: '```java'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class SimpleMath {
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: public class SimpleMath {
- en: public int multiplyByTwo(int i){
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: public int multiplyByTwo(int i){
- en: return 2 * i;
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: return 2 * i;
- en: '}'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int multiplyByTwo(String s){
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: public int multiplyByTwo(String s){
- en: int i = Integer.parseInt(s);
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: int i = Integer.parseInt(s);
- en: return 2 * i;
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: return 2 * i;
- en: '}'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Or, if we would like to keep the complicated code of multiplying by two in
    one place (so we can change it in one place only if there is a need to modify
    it), we could write the following:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 'Or, if we would like to keep the complicated code of multiplying by two in
    one place (so we can change it in one place only if there is a need to modify
    it), we could write the following:'
- en: '```java'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class SimpleMath {
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: public class SimpleMath {
- en: public int multiplyByTwo(int i){
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: public int multiplyByTwo(int i){
- en: return 2 * i;
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: return 2 * i;
- en: '}'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int multiplyByTwo(String s){
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: public int multiplyByTwo(String s){
- en: int i = Integer.parseInt(s);
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: int i = Integer.parseInt(s);
- en: return multiplyByTwo(i);
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: return multiplyByTwo(i);
- en: '}'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'A constructor cannot be overloaded in the same manner:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 'A constructor cannot be overloaded in the same manner:'
- en: '```java'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class SimpleMath {
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: public class SimpleMath {
- en: private int i;
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: private int i;
- en: private String s;
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: private String s;
- en: public SimpleMath() {
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: public SimpleMath() {
- en: '}'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public SimpleMath(int i) {
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: public SimpleMath(int i) {
- en: this.i = i;
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: this.i = i;
- en: '}'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public SimpleMath(String s) {
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: public SimpleMath(String s) {
- en: this.s = s;
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: this.s = s;
- en: '}'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // Other methods that use values of the fields i and s
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: // Other methods that use values of the fields i and s
- en: // go here
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: // go here
- en: '}'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: With that, we conclude the topic of overloading, overriding, and hiding. It
    is time to explain in more detail the use of the keywords `this` (used earlier)
    and `super` (not used yet), and talk more about constructors.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: With that, we conclude the topic of overloading, overriding, and hiding. It
    is time to explain in more detail the use of the keywords `this` (used earlier)
    and `super` (not used yet), and talk more about constructors.
- en: This, super, and constructors
  id: totrans-910
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: This, super, and constructors
- en: The keyword `this` provides a reference to the current object. The keyword `super`
    refers to the parent class object. A constructor is used to initialize the object
    state (values of the instance fields). It can be accessed using the keywords `new`,
    `this`, or `super`.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: The keyword `this` provides a reference to the current object. The keyword `super`
    refers to the parent class object. A constructor is used to initialize the object
    state (values of the instance fields). It can be accessed using the keywords `new`,
    `this`, or `super`.
- en: Keyword this and its usage
  id: totrans-912
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Keyword this and its usage
- en: 'We saw several examples of its usage in a constructor similar to the following:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 'We saw several examples of its usage in a constructor similar to the following:'
- en: '```java'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public SimpleMath(int i) {
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: public SimpleMath(int i) {
- en: this.i = i;
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: this.i = i;
- en: '}'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It allows us to clearly distinguish between the object property and local variable,
    especially when they have the same name.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: It allows us to clearly distinguish between the object property and local variable,
    especially when they have the same name.
- en: 'Another use of the keyword `this` can be demonstrated in the implementation
    of the method `equals()` in the following `Person` class:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 'Another use of the keyword `this` can be demonstrated in the implementation
    of the method `equals()` in the following `Person` class:'
- en: '```java'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class Person {
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: public class Person {
- en: private String firstName;
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: private String firstName;
- en: private String lastName;
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: private String lastName;
- en: private LocalDate dob;
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: private LocalDate dob;
- en: public Person(String firstName, String lastName, LocalDate dob) {
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: public Person(String firstName, String lastName, LocalDate dob) {
- en: this.firstName = firstName;
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: this.firstName = firstName;
- en: this.lastName = lastName;
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: this.lastName = lastName;
- en: this.dob = dob;
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: this.dob = dob;
- en: '}'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String getFirstName() { return firstName; }
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: public String getFirstName() { return firstName; }
- en: public String getLastName() { return lastName; }
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: public String getLastName() { return lastName; }
- en: public LocalDate getDob() { return dob; }
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: public LocalDate getDob() { return dob; }
- en: '@Override'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public boolean equals(Object other){
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean equals(Object other){
- en: if (other == null) return false;
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: if (other == null) return false;
- en: if (this == other) return true;
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: if (this == other) return true;
- en: if (!(other instanceof Person)) return false;
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: if (!(other instanceof Person)) return false;
- en: final Person that = (Person) other;
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: final Person that = (Person) other;
- en: return this.getFirstName().equals(that.getFirstName()) &&
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: return this.getFirstName().equals(that.getFirstName()) &&
- en: this.getLastName().equals(that.getLastName()) &&
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: this.getLastName().equals(that.getLastName()) &&
- en: this.getDob().equals(that.getDob());
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: this.getDob().equals(that.getDob());
- en: '}'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The reason we need to override the `equals()` method in the parent class `java.lang.Object` (which
    is the default parent class for all Java classes) is that we would like two objects
    of the class `Person` to be equal not only when they are actually the same object,
    but also when the value of each property of one object is the same as the value
    of the corresponding property of another object. As you can see, we have added
    an annotation `@Override` to make sure that this method does override the method
    `equals()` in the parent class `java.lang.Object`. Otherwise, if we make a mistake
    in the method signature, it may just overload the method `equals()` in the class
    `java.lang.Object` or, if we make mistake in the method name, be added as just
    another unrelated to the `equals()` method and we never know about it or would
    struggle to understand why two different objects of class `Person` are not equal,
    although all their property values are the same.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: The reason we need to override the `equals()` method in the parent class `java.lang.Object` (which
    is the default parent class for all Java classes) is that we would like two objects
    of the class `Person` to be equal not only when they are actually the same object,
    but also when the value of each property of one object is the same as the value
    of the corresponding property of another object. As you can see, we have added
    an annotation `@Override` to make sure that this method does override the method
    `equals()` in the parent class `java.lang.Object`. Otherwise, if we make a mistake
    in the method signature, it may just overload the method `equals()` in the class
    `java.lang.Object` or, if we make mistake in the method name, be added as just
    another unrelated to the `equals()` method and we never know about it or would
    struggle to understand why two different objects of class `Person` are not equal,
    although all their property values are the same.
- en: The first line checks if the passed in reference value is `null`. If yes, the
    returned value is `false` because, obviously, the current (`this`) object is not
    `null`.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行检查传入的引用值是否为`null`。如果是，返回的值是`false`，因为显然当前（`this`）对象不是`null`。
- en: The second line of our method `equals()` checks the equality of the references
    and returns `true` if they refer the same object. This is the same way the default
    `equals()` method in the parent class `Object` works.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`equals()`方法的第二行检查引用的相等性，并且如果它们引用相同的对象，则返回`true`。这与父类`Object`中的默认`equals()`方法的工作方式相同。
- en: The third line of our method `equals()` checks if the object `other` is an instance
    of the class `Person`. We need this line because in the next line we are casting
    the object `other` to the type `Person` in order to be able to access the getters
    of `Person`. If the object `other` cannot be cast to the type `Person` (which
    means the reference `other` does not refer an object that has class `Person` as
    a direct or indirect parent) the fourth line will throw an exception and break
    the flow of the execution (JVM will exit with an error). So, we check and make
    sure that the object `other` has the class `Person` in its ancestry and will not
    break the execution flow during casting.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`equals()`方法的第三行检查对象`other`是否是类`Person`的实例。我们需要这一行，因为在下一行中，我们将对象`other`转换为类型`Person`，以便能够访问`Person`的getter。如果对象`other`不能转换为类型`Person`（这意味着引用`other`不引用具有类`Person`作为直接或间接父类的对象），第四行将抛出异常并中断执行流程（JVM将以错误退出）。因此，我们检查并确保对象`other`在其祖先中具有类`Person`，并且在转换期间不会中断执行流程。
- en: The last line of our new method, `equals()`, is a Boolean expression (we will
    talk about such expressions in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements*) that compares the values of three properties
    of the current object with the corresponding values of another object and returns
    `true` only if each of the three fields have the same value in both objects.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新方法`equals()`的最后一行是一个布尔表达式（我们将在[第9章](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml)中讨论这样的表达式，*运算符、表达式和语句*），它比较当前对象的三个属性的值与另一个对象的相应值，并且仅当两个对象的每个字段都具有相同的值时才返回`true`。
- en: 'Let''s create a unit test for our new method, `equals()`:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的新方法`equals()`创建一个单元测试：
- en: '```java'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class PersonTest {
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: public class PersonTest {
- en: '@Test'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: '@Test'
- en: void equals() {
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: void equals() {
- en: LocalDate dob = LocalDate.of(2001, 01, 20);
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: LocalDate dob = LocalDate.of(2001, 01, 20);
- en: LocalDate dob1 = LocalDate.of(2001, 01, 21);
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: LocalDate dob1 = LocalDate.of(2001, 01, 21);
- en: Person p = new Person("Joe", "Blow", dob);
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: Person p = new Person("Joe", "Blow", dob);
- en: assertTrue(p.equals(p));
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: assertTrue(p.equals(p));
- en: assertTrue(p.equals(new Person("Joe", "Blow", dob)));
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: assertTrue(p.equals(new Person("Joe", "Blow", dob)));
- en: assertFalse(p.equals(new Person("Joe1", "Blow", dob)));
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: assertFalse(p.equals(new Person("Joe1", "Blow", dob)));
- en: assertFalse(p.equals(new Person("Joe", "Blow1", dob)));
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: assertFalse(p.equals(new Person("Joe", "Blow1", dob)));
- en: assertFalse(p.equals(new Person("Joe", "Blow", dob1)));
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: assertFalse(p.equals(new Person("Joe", "Blow", dob1)));
- en: assertFalse(p.equals( new Person("Joe1", "Blow1", dob1)));
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: assertFalse(p.equals( new Person("Joe1", "Blow1", dob1)));
- en: '}'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see, we have created two objects for different dates of birth. Then,
    we create a `Person` object and compare it:'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经为不同出生日期创建了两个对象。然后，我们创建一个`Person`对象并进行比较：
- en: To itself—should be equal
  id: totrans-969
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于自身-应该相等
- en: To another object with the same state (property values)—should be equal
  id: totrans-970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于具有相同状态（属性值）的另一个对象-应该相等
- en: To another object with the first name different only—should not be equal
  id: totrans-971
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于只有名字不同的另一个对象-不应该相等
- en: To another object with the last name different only —should not be equal
  id: totrans-972
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于只有姓氏不同的另一个对象-不应该相等
- en: To another object with the date of birth different only —should not be equal
  id: totrans-973
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于出生日期不同的另一个对象-不应该相等
- en: To another object with all property values different—should not be equal
  id: totrans-974
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有属性值都不同的另一个对象-不应该相等
- en: We run this test and get the green color of success.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行这个测试并得到了绿色的成功。
- en: 'But then, we decide to test what happens if one or all the values are `null` and
    add the following lines to the test:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 但是然后，我们决定测试如果一个或所有的值都是`null`会发生什么，并将以下行添加到测试中：
- en: '```java'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: assertFalse(p.equals(null));
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: assertFalse(p.equals(null));
- en: assertFalse(p.equals(new Person(null, "Blow", dob)));
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: assertFalse(p.equals(new Person(null, "Blow", dob)));
- en: assertFalse(p.equals(new Person("Joe", null, dob)));
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: assertFalse(p.equals(new Person("Joe", null, dob)));
- en: assertFalse(p.equals(new Person(null, null, dob)));
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: assertFalse(p.equals(new Person(null, null, dob)));
- en: assertFalse(p.equals(new Person(null, null, null)));
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: assertFalse(p.equals(new Person(null, null, null)));
- en: assertTrue(new Person(null, "Blow", dob)
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: assertTrue(new Person(null, "Blow", dob)
- en: .equals(new Person(null, "Blow", dob)));
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: .equals(new Person(null, "Blow", dob)));
- en: assertTrue(new Person("Joe", null, dob)
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: assertTrue(new Person("Joe", null, dob)
- en: .equals(new Person("Joe", null, dob)));
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: .equals(new Person("Joe", null, dob)));
- en: assertTrue(new Person("Joe", "Blow", null)
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: assertTrue(new Person("Joe", "Blow", null)
- en: .equals(new Person("Joe", "Blow", null)));
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: .equals(new Person("Joe", "Blow", null)));
- en: assertTrue(new Person(null, null, null)
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: assertTrue(new Person(null, null, null)
- en: .equals(new Person(null, null, null)));
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: .equals(new Person(null, null, null)));
- en: '```'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: First, we compare the existing object with all properties not `null` and a new
    object that has either one property or all properties set to `null`. We expect
    the first four comparisons to tell us the objects are not equal. Then, we compare
    two objects with the same state that have one or all values set to `null`. We
    expect all the pairs to be reported as equal.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们比较现有对象和所有属性不为`null`的新对象，或者所有属性设置为`null`的新对象。我们期望前四个比较告诉我们这些对象不相等。然后，我们比较两个状态相同的对象，其中一个或所有值设置为`null`。我们期望所有这些对都被报告为相等。
- en: 'If we run the test, here is what we get:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行测试，我们会得到以下结果：
- en: '![](img/afc4e8bc-30cb-4dac-9b07-8ceb89e62803.png)'
  id: totrans-994
  prefs: []
  type: TYPE_IMG
  zh: '![](img/afc4e8bc-30cb-4dac-9b07-8ceb89e62803.png)'
- en: 'The error (a `NullPointerExceptions`) indicates that we are trying to call
    a method on a reference that is not assigned yet (has a `null` value) in line
    57 of the class `Person`. Here is that line:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 错误（`NullPointerExceptions`）表明我们正在尝试在一个尚未分配的引用（具有`null`值）上调用方法，在类`Person`的第57行。以下是该行：
- en: '```java'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: return this.getFirstName().equals(that.getFirstName()) &&
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: return this.getFirstName().equals(that.getFirstName()) &&
- en: this.getLastName().equals(that.getLastName()) &&
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: this.getLastName().equals(that.getLastName()) &&
- en: this.getDob().equals(that.getDob());
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: this.getDob().equals(that.getDob());
- en: '```'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We realize that all the getters return a `null` value when we call them on the method
    `equals()`, which is the source of `NullPointerException`. We need to change either
    our implementation of the method `equals()` (taking into account the possibility
    of a `null` value) or change the implementation of the constructor (and not allow
    the values passed in to be `null`). Very often, the decision can be made based
    on the business requirements. For example, is it possible, that in the data we
    are going to process there could be a person without a first name, last name,
    date of birth, or even any of these values? The last one—a person without any
    properties—is probably not realistic. Yet, the real data often comes with errors
    and the question we might ask our business folks (also called domain experts)
    is how the code should process such cases. Then, we change the code to reflect
    the new requirements.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 我们意识到，当我们在`equals()`方法上调用所有的getter时，它们都会返回`null`值，这是`NullPointerException`的源头。我们需要改变`equals()`方法的实现（考虑到`null`值的可能性），或者改变构造函数的实现（不允许传入的值为`null`）。通常，决定可以基于业务需求。例如，在我们要处理的数据中，是否可能存在没有名字、姓氏、出生日期，甚至这些值中的任何一个的人？最后一个——没有任何属性的人——可能不现实。然而，真实的数据经常出现错误，我们可能会问我们的业务人员（也称为领域专家）代码应该如何处理这种情况。然后，我们改变代码以反映新的需求。
- en: Let's assume they have told us that one or even two properties can be `null` and
    we should handle such cases as if they are not `null`. But, they said, we should
    not process a case when all the properties are `null`.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 假设他们告诉我们，一个或甚至两个属性可以是`null`，我们应该处理这种情况，就好像它们不是`null`一样。但是，他们说，我们不应该处理所有属性都是`null`的情况。
- en: 'After reviewing the new requirements, we go to the domain experts again and
    suggest, for example, that we convert `null` values of `String` type into the
    empty literal `""` and the `LocalDate` type into the date as of January 1, zero
    years, but only when not all values are `null`. We skip the person data when all
    the values are `null` after adding a corresponding record to a log file. They
    suggest we allow the first and last name to be `null` and convert them to the
    empty `String` type literal `""`, but do not process a person without a date of
    birth and make a record of such a case in a log file. So, we change the constructor
    as follows:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查新的需求后，我们再次去找领域专家，并建议，例如，我们将`String`类型的`null`值转换为空字符串`""`，将`LocalDate`类型转换为零年一月一日的日期，但只有当不是所有值都是`null`时。在添加相应的记录到日志文件后，我们跳过这个人的数据。他们建议我们允许名字和姓氏为空，并将它们转换为空字符串类型的`""`，但不处理没有出生日期的人，并在日志文件中记录这种情况。因此，我们将构造函数更改如下：
- en: '```java'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public Person(String firstName, String lastName, LocalDate dob) {
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: public Person(String firstName, String lastName, LocalDate dob) {
- en: 'this.firstName = firstName == null ? "" : firstName;'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 'this.firstName = firstName == null ? "" : firstName;'
- en: 'this.lastName = lastName == null ? "" : lastName;'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 'this.lastName = lastName == null ? "" : lastName;'
- en: this.dob = dob;
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: this.dob = dob;
- en: if(dob == null){
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: if(dob == null){
- en: throw new RuntimeException("Date of birth is null");
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: throw new RuntimeException("Date of birth is null");
- en: '}'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And our test section that handles the null values changes to the following:'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 处理空值的测试部分现在变成了以下内容：
- en: '```java'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: assertFalse(p.equals(null));
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: assertFalse(p.equals(null));
- en: assertFalse(p.equals(new Person(null, "Blow", dob)));
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: assertFalse(p.equals(new Person(null, "Blow", dob)));
- en: assertFalse(p.equals(new Person("Joe", null, dob)));
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: assertFalse(p.equals(new Person("Joe", null, dob)));
- en: assertFalse(p.equals(new Person(null, null, dob)));
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: assertFalse(p.equals(new Person(null, null, dob)));
- en: try {
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: try {
- en: new Person("Joe", "Blow", null);
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: new Person("Joe", "Blow", null);
- en: '} catch (RuntimeException ex){'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (RuntimeException ex){'
- en: assertNotNull(ex.getMessage());
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: assertNotNull(ex.getMessage());
- en: //add the record ex.getMessage() to the log here
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: //在这里将记录ex.getMessage()添加到日志
- en: '}'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: assertTrue(new Person(null, "Blow", dob)
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: assertTrue(new Person(null, "Blow", dob)
- en: .equals(new Person(null, "Blow", dob)));
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: .equals(new Person(null, "Blow", dob)));
- en: assertTrue(new Person("Joe", null, dob)
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: assertTrue(new Person("Joe", null, dob)
- en: .equals(new Person("Joe", null, dob)));
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: .equals(new Person("Joe", null, dob)));
- en: assertTrue(new Person(null, null, dob)
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: assertTrue(new Person(null, null, dob)
- en: .equals(new Person(null, null, dob)));
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: .equals(new Person(null, null, dob)));
- en: '```'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We run it and get the green color of success.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行它，得到了绿色的成功颜色。
- en: That was an example of the use of the keyword `this`. We will show another example
    in the *Constructors* section. And there is a very important case of the use of
    the keyword `this` at the end of the *Final variable* section, too. You do not
    want to miss it! Otherwise, it can be a source of bugs that are very difficult
    to find.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关键字`this`的一个例子。我们将在*构造函数*部分展示另一个例子。在*最终变量*部分的末尾，还有一个非常重要的关键字`this`的用法。你不想错过它！否则，它可能是一个非常难以找到的错误的源头。
- en: And now, we will explain how the keyword `super` is used.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将解释关键字`super`的用法。
- en: Keyword super and its usage
  id: totrans-1036
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键字super及其用法
- en: 'The keyword `super` represents the parent class object. To demonstrate its
    usage, let''s create a programming model of a vehicle, a truck, and a car. Let''s
    start with a vehicle. The class that models it calculates the speed of the vehicle
    it can reach in a specified period of time, in seconds. It looks as follows:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`super`代表父类对象。为了演示它的用法，让我们创建一个车辆、一辆卡车和一辆汽车的编程模型。让我们从车辆开始。模拟车辆的类计算车辆在指定时间段内（以秒为单位）可以达到的速度。它看起来是这样的：
- en: '```java'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class Vehicle {
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: public class Vehicle {
- en: private int weightPounds, horsePower;
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: private int weightPounds, horsePower;
- en: public Vehicle(int weightPounds, int horsePower) {
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: public Vehicle(int weightPounds, int horsePower) {
- en: this.weightPounds = weightPounds;
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: this.weightPounds = weightPounds;
- en: this.horsePower = horsePower;
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: this.horsePower = horsePower;
- en: '}'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: protected int getWeightPounds(){ return this.weightPounds; }
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: protected int getWeightPounds(){ return this.weightPounds; }
- en: protected double getSpeedMph(double timeSec, int weightPounds){
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: protected double getSpeedMph(double timeSec, int weightPounds){
- en: double v =
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: double v =
- en: 2.0 * this.horsePower * 746 * timeSec * 32.174 / weightPounds;
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0 * this.horsePower * 746 * timeSec * 32.174 / weightPounds;
- en: return Math.round(Math.sqrt(v) * 0.68);
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 返回Math.round（Math.sqrt（v）* 0.68）;
- en: '}'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The class has two properties set by the constructor and two protected methods.
    Protected is an access modifier that means the method can be accessed only by
    the children of this class. We will talk more about access modifiers in [Chapter
    7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml), *Packages and Accessibility (Visibility)*.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 该类由构造函数设置了两个属性和两个受保护的方法。受保护是一种访问修饰符，表示该方法只能被此类的子类访问。我们将在[第7章](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml)中更多地讨论访问修饰符，*包和可访问性（可见性）*。
- en: 'The `Car` and `Truck` classes(which model a car and a truck) can extend this
    class and inherit the two protected methods, so they can be used for calculating
    the car and truck speed. There are other possible ways to organize code. Generally,
    using aggregation (setting the `Vehicle` object as a field value of the `Car`
    and `Truck` classes ) is preferred, unless one has a reason to have a common parent
    (we will talk about this in [Chapter 8,](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml)
    *Object-Oriented Design (OOD) Principles*). But for now, let''s assume that we
    have a good reason to use inheritance, so we can demonstrate the use of the keyword
    `super`. And it sort of makes sense, in general: a car and a truck are both vehicles,
    aren''t they?'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: '`Car`和`Truck`类（模拟汽车和卡车）可以扩展此类并继承两个受保护的方法，因此它们可用于计算汽车和卡车的速度。还有其他可能的代码组织方式。通常，使用聚合（将`Vehicle`对象设置为`Car`和`Truck`类的字段值）是首选的，除非有理由具有共同的父级（我们将在[第8章](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml)中讨论这一点，*面向对象设计（OOD）原则*）。但是现在，让我们假设我们有充分的理由使用继承，以便演示关键字`super`的使用。总的来说，这是有道理的：汽车和卡车都是车辆，不是吗？'
- en: 'So, here is how the class `Truck` looks:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是`Truck`类的外观：
- en: '```java'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class Truck extends Vehicle {
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: public class Truck extends Vehicle {
- en: private int payloadPounds;
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: private int payloadPounds;
- en: public Truck(int payloadPounds, int weightPounds, int horsePower) {
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: public Truck（int payloadPounds，int weightPounds，int horsePower）{
- en: super(weightPounds, horsePower);
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: super（weightPounds，horsePower）;
- en: this.payloadPounds = payloadPounds;
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: this.payloadPounds = payloadPounds;
- en: '}'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void setPayloadPounds(int payloadPounds) {
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: public void setPayloadPounds（int payloadPounds）{
- en: this.payloadPounds = payloadPounds;
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: this.payloadPounds = payloadPounds;
- en: '}'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: protected int getWeightPounds(){
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: protected int getWeightPounds（）{
- en: return this.payloadPounds + getWeightPounds();
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 返回this.payloadPounds + getWeightPounds（）;
- en: '}'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public double getSpeedMph(double timeSec){
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: public double getSpeedMph（double timeSec）{
- en: return getSpeedMph(timeSec, getWeightPounds());
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以英里/小时为单位的速度（timeSec，getWeightPounds（））。
- en: '}'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The class has one property: the current payload weight the truck has. It factors
    in the speed calculations. The heavier the payload, the longer it takes the truck
    to reach the same speed. Since the payload weight may change any time after the
    object is created, the setter for the payload weight is provided, and the protected
    method `getWeightPounds()` returns the total weight of the vehicle with its payload.
    The main method and the purpose of all the modeling is the method `getSpeedMph()`,
    which returns the truck''s speed (in miles per hour) it can reach in `timeSec`
    seconds after it starts.'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 该类具有一个属性：卡车当前的有效载荷重量。它考虑了速度计算。有效载荷越重，卡车达到相同速度所需的时间就越长。由于有效载荷重量可能在对象创建后随时更改，因此提供了有效载荷重量的setter，并且受保护的方法`getWeightPounds（）`返回车辆及其有效载荷的总重量。所有建模的主要方法和目的是方法`getSpeedMph（）`，它返回卡车在启动后`timeSec`秒内可以达到的速度（以每小时英里为单位）。
- en: But, we now discuss the use of the keyword `super`. You probably noticed that
    it was already included in the constructor. As you can guess, it represents the
    constructor of the parent class. In such cases, the keyword `super` has to be
    the first line of the child constructor. We will talk about it in the next section, *Constructors*.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们现在讨论关键字`super`的使用。您可能已经注意到它已经包含在构造函数中。您可以猜到，它代表父类的构造函数。在这种情况下，关键字`super`必须是子类构造函数的第一行。我们将在下一节*构造函数*中讨论它。
- en: 'And here is the class that models car speed:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是模拟汽车速度的类：
- en: '```java'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class Car extends Vehicle {
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: public class Car extends Vehicle {
- en: private int passengersCount;
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: private int passengersCount;
- en: public Car(int passengersCount, int weightPounds, int horsePower) {
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: public Car（int passengersCount，int weightPounds，int horsePower）{
- en: super(weightPounds , horsePower);
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: super（weightPounds，horsePower）;
- en: this.passengersCount = passengersCount;
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: this.passengersCount = passengersCount;
- en: '}'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void setPassengersCount(int passengersCount) {
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: public void setPassengersCount（int passengersCount）{
- en: this.passengersCount = passengersCount;
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: this.passengersCount = passengersCount;
- en: '}'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: protected int getWeightPounds(){
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: protected int getWeightPounds（）{
- en: return this.passengersCount * 200 + getWeightPounds(); }
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 返回this.passengersCount * 200 + getWeightPounds（）;}
- en: public double getSpeedMph(double timeSec){
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: public double getSpeedMph（double timeSec）{
- en: return getSpeedMph(timeSec, getWeightPounds());
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以英里/小时为单位的速度（timeSec，getWeightPounds（））;
- en: '}'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It looks very similar to the class `Truck`. The only difference is the way the
    payload is calculated. It is assumed that each passenger ways `200` pounds. Thus,
    when the passenger count is set, the payload is calculated as the number of passengers
    multiplied by `200`.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来与`Truck`类非常相似。唯一的区别是计算有效载荷的方式。假设每位乘客重量为`200`磅。因此，当设置乘客数时，有效载荷被计算为乘客数量乘以`200`。
- en: 'Both classes—`Car` and `Truck`—have a defect (also called a bug, or an error).
    To discover it, let''s try to calculate a truck''s speed 10 seconds from the start
    time by running the following code:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: '`Car`和`Truck`两个类都有一个缺陷（也称为错误或错误）。为了发现它，让我们尝试通过运行以下代码来计算卡车在开始时间后10秒的速度：'
- en: '```java'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Truck truck = new Truck(500, 2000, 300);
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: Truck truck = new Truck（500，2000，300）;
- en: System.out.println(truck.getSpeedMph(10));
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（truck.getSpeedMph（10））;
- en: '```'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we do that, the result will be a `StackOverflowError` error:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，结果将是`StackOverflowError`错误：
- en: '![](img/926fdbd6-6ee7-4eef-90c4-096d1d553e6b.png)'
  id: totrans-1101
  prefs: []
  type: TYPE_IMG
  zh: ！[]（img/926fdbd6-6ee7-4eef-90c4-096d1d553e6b.png）
- en: A stack is the JVM memory area where the chain of method calls is stored. The
    last method name called is stored on the top. When the last method called is completed,
    its name is removed from the top and the next method is executed, and so on until
    the stack is empty—that is, when the `main()` method is completed—and the application
    completes its execution (JVM exits).
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈是 JVM 内存区域，用于存储方法调用链。最后调用的方法名称存储在顶部。当完成最后调用的方法时，其名称将从顶部移除，并执行下一个方法，依此类推，直到堆栈为空，即当
    `main()` 方法完成时，应用程序完成其执行（JVM 退出）。
- en: 'In our case, the stack grew uncontrollably and eventually overflowed. The JVM
    could not add another method name on the top of the stack and exited with an error.
    The reason for such a condition is a recursive call our code requested in this
    line:'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，堆栈不受控制地增长，并最终溢出。 JVM 无法在堆栈顶部添加另一个方法名称，并带有错误退出。这种情况的原因是我们的代码在这一行请求了一个递归调用：
- en: '```java'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: protected int getWeightPounds(){
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: protected int getWeightPounds(){
- en: return this.payloadPounds + getWeightPounds();
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: return this.payloadPounds + getWeightPounds();
- en: '}'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We wanted to add the truck payload to the weight of the vehicle itself, stored
    as the property in the parent class, but instead told the JVM to call the same
    method, which calls itself recursively, because this method is overridden and
    has the same name in the child class. That is where the keyword `super` comes
    to the rescue. By adding it in front of the method `getWeightPounds()`, we tell
    the JVM to call not the child''s method, but the parent''s one:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将卡车的有效载荷添加到父类中存储的车辆自身的重量中，但却告诉 JVM 调用相同的方法，因为这个方法被覆盖并且在子类中具有相同的名称，从而递归调用自身。这就是关键字
    `super` 发挥作用的地方。通过在方法 `getWeightPounds()` 前面添加它，我们告诉 JVM 不要调用子类的方法，而是调用父类的方法：
- en: '```java'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: protected int getWeightPounds(){
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: protected int getWeightPounds(){
- en: return this.payloadPounds + super.getWeightPounds();
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: return this.payloadPounds + super.getWeightPounds();
- en: '}'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If  we run the same code again, we will get the expected result:'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行相同的代码，我们将得到预期的结果：
- en: '![](img/3425b1a1-e668-4157-bc08-a22eff82094d.png)'
  id: totrans-1116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3425b1a1-e668-4157-bc08-a22eff82094d.png)'
- en: Well, our speed calculating formula seems over-optimistic. But who knows? Maybe
    by the time the book is printed, electric trucks will be closing in on this speed
    or hyperloop traffic will get there.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们的速度计算公式似乎过于乐观了。但谁知道呢？也许到书印刷时，电动卡车将接近这个速度，或者超级环路交通将到达那里。
- en: 'Also, please notice that we have not added `super` in front of the same method
    in the code that calculates speed:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，我们在计算速度的代码中没有在相同的方法前面添加 `super`：
- en: '```java'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public double getSpeedMph(double timeSec){
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: public double getSpeedMph(double timeSec){
- en: return getSpeedMph(timeSec, getWeightPounds());
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: return getSpeedMph(timeSec, getWeightPounds());
- en: '}'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'That is because we do not want to call the method of the parent class. Instead,
    we would like to get the weight from its overridden version in the child class.
    To make sure, and to avoid confusion by making code more easily readable, we could
    add the keyword `this` in front of it:'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们不想调用父类的方法。相反，我们想从子类中覆盖的版本中获取重量。为了确保，并通过使代码更易于阅读来避免混淆，我们可以在其前面添加关键字 `this`：
- en: '```java'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public double getSpeedMph(double timeSec){
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: public double getSpeedMph(double timeSec){
- en: return getSpeedMph(timeSec, this.getWeightPounds());
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: return getSpeedMph(timeSec, this.getWeightPounds());
- en: '}'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In fact, that is one of the best practices that we recommend to follow at all
    times.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是我们建议始终遵循的最佳实践之一。
- en: That concludes the discussion of the use of the keyword `super`. We will see
    it again, and the keyword `this`, in the *Constructors* section too, where we
    are going to explain how the constructors do their job and what a default constructor is.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了关键字 `super` 的用法讨论。我们将在 *构造函数* 部分再次看到它，以及关键字 `this`，在那里我们将解释构造函数是如何工作的，以及默认构造函数是什么。
- en: Constructors
  id: totrans-1132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数
- en: An object is an instance of a class used as the template for object creation.
    Each object is defined by its state and behavior. The object's state is defined
    by the values of its fields (also called properties), the object behavior by its
    methods. Since all Java objects are descendants of `java.lang.Object`, it is not
    possible to have an object without state and behavior because every object inherits its
    methods and some basic state from `java.lang.Object`. But when we talk about application
    code, classes, and objects this code creates, we mean the methods and state we
    define in order to build the functionality we want. In this sense, it is possible
    to have an object without methods. Such objects are usually called data objects,
    data structures, or data transfer objects. And it is possible to have objects
    without a state, with methods only. Such objects are often called utilities.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是作为对象创建模板使用的类的实例。每个对象由其状态和行为定义。对象的状态由其字段的值（也称为属性）定义，对象的行为由其方法定义。由于所有 Java
    对象都是 `java.lang.Object` 的后代，因此不可能有没有状态和行为的对象，因为每个对象都继承自 `java.lang.Object` 的方法和一些基本状态。但是，当我们谈论应用程序代码、类和此代码创建的对象时，我们指的是我们定义的方法和状态，以便构建所需的功能。在这种意义上，可能有没有方法的对象。这种对象通常称为数据对象、数据结构或数据传输对象。也可能有没有状态，只有方法的对象。这种对象通常称为实用程序。
- en: If an object can have a state, the state has to be initialized during object
    creation. It means that some values have to be assigned to the variables that
    represent the object fields. This initial assignment can be done either using
    an assignment operator, `=`, explicitly or by letting the JVM assign the default
    values to the object's fields. What these default values are depends on the field type.
    We have discussed the default value of each type in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types*. Primitive numeric types have the default type
    of zero, the Boolean type `false`, and the reference type `null`.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象可以有状态，则在对象创建期间必须初始化状态。这意味着必须为表示对象字段的变量分配一些值。这种初始赋值可以通过使用赋值运算符“=”显式地完成，也可以通过让JVM将默认值分配给对象的字段来完成。这些默认值取决于字段类型。我们已经在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中讨论了每种类型的默认值，*Java语言元素和类型*。原始数值类型的默认类型为零，布尔类型为`false`，引用类型为`null`。
- en: 'An object is created using the operator `new`. This operator requires specifying
    the constructor that has to be used for object creation. The primary duty of a
    constructor is to initialize the object state. But, there are three cases when
    an explicit definition of a constructor in the class is not required:'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用运算符`new`创建对象。此运算符需要指定用于对象创建的构造函数。构造函数的主要职责是初始化对象状态。但是，有三种情况下，不需要在类中显式定义构造函数：
- en: When neither the object nor any of its parents can have a state (no fields are
    defined)
  id: totrans-1136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对象或其任何父对象都不能有状态（未定义字段）
- en: When an initial value is assigned to each field along with the type declaration
    (`int x = 42;`)
  id: totrans-1137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在类型声明中为每个字段分配初始值时（`int x = 42;`）
- en: When default values are good enough (for example, the field `int x;` is initialized
    to the value of zero by default)
  id: totrans-1138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当默认值足够好时（例如，默认情况下将字段`int x;`初始化为零的值）
- en: 'How then can an object be created?  The operator `new` expects the constructor.
    The answer is that in such a case—when there is no constructor explicitly defined
    in a class—a default constructor is generated for the class by the compiler. This
    default constructor looks like the following:'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何创建对象呢？运算符`new`期望构造函数。答案是，在这种情况下——当类中没有显式定义构造函数时——编译器会为类生成默认构造函数。此默认构造函数如下所示：
- en: '```java'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public ClassName(){
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: public ClassName(){
- en: super();
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: super();
- en: '}'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see, it does only one thing: calls the constructor (the one without
    parameters) of the parent class using the keyword `super`. This parent constructor
    without parameters may be a default one too, or may be explicitly created. And
    here resides a possible source of confusion: if a class has an explicitly defined
    constructor, the default one (without parameters) is not generated automatically.
    The reason for this limitation is that it puts the programmer in command and lets
    the class author decide whether to add a constructor without parameters to the
    class or not. Otherwise, imagine you have created a class, `Person`, and do not
    want to allow an instance of this class without certain fields populated. And
    you do not want these values to be the default ones, but would like to force the
    client code to populate them explicitly every time a new `Person` object is created.
    That''s why no constructor is going to be generated automatically behind the scenes
    as soon as at least one constructor—with or without parameters—is defined in a
    class. Let''s test this behavior. Here are two classes without explicitly defined
    constructors (or any code at all for that matter):'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，它只做了一件事：使用关键字`super`调用父类的构造函数（没有参数的构造函数）。这个没有参数的父构造函数也可能是默认的，也可能是显式创建的。这里存在一个可能的混淆源：如果一个类有一个显式定义的构造函数，则默认的构造函数（无参数）不会自动生成。这种限制的原因是它让程序员掌握控制，并让类的作者决定是否向类添加一个没有参数的构造函数。否则，想象一下，您已经创建了一个类`Person`，并且不想允许在没有填充某些字段的情况下创建此类的实例。您也不希望这些值是默认值，而是希望强制客户端代码在每次创建新的`Person`对象时都显式填充它们。这就是为什么只要在类中定义了一个构造函数（带或不带参数），就不会在幕后自动生成构造函数。让我们测试一下这种行为。以下是两个没有显式定义构造函数（或任何代码）的类：
- en: '```java'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class Parent {
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: public class Parent {
- en: '}'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class Child extends Parent{
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: public class Child extends Parent{
- en: '}'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We can run the following code just fine:'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很好地运行以下代码：
- en: '```java'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: new Child();
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: new Child();
- en: '```'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'It does not do anything, but that is not the point. Let''s add a constructor
    with a parameter to the parent class:'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 它什么也不做，但这不是重点。让我们在父类中添加一个带参数的构造函数：
- en: '```java'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class Parent {
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: public class Parent {
- en: public Parent(int i) {
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: public Parent(int i) {
- en: '}'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we try to create an object of the class `Child` again, we will get an error:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次尝试创建类`Child`的对象，我们将会得到一个错误：
- en: '![](img/98593acd-b710-4f3a-92f1-02e2f4603e30.png)'
  id: totrans-1164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98593acd-b710-4f3a-92f1-02e2f4603e30.png)'
- en: 'Click on the red line to see this error message in IntelliJ, because the compiler
    error message is not as helpful:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 点击红线以在IntelliJ中查看此错误消息，因为编译器错误消息不够有用：
- en: '![](img/f59184e5-c542-45ae-b001-196162ea43f0.png)'
  id: totrans-1166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f59184e5-c542-45ae-b001-196162ea43f0.png)'
- en: It identifies the explicitly defined constructor (with a parameter of type `int`)
    as required and its list of parameters as a formal argument list. Meanwhile, a
    default constructor of the class `Child` attempts (as we described before) to
    call a no-arguments constructor of the class `Parent` and cannot find one. The
    error wording is not very clear on that.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 它将显式定义的构造函数（带有`int`类型的参数）标识为必需的，并将其参数列表标识为形式参数列表。同时，类`Child`的默认构造函数尝试（如前所述）调用类`Parent`的无参数构造函数，并找不到。错误措辞在这一点上并不是很清楚。
- en: 'So, let''s add a constructor without parameters to the class `Parent`:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们在类“Parent”中添加一个没有参数的构造函数：
- en: '```java'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class Parent {
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: public class Parent {
- en: public Parent() {
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: public Parent() {
- en: '}'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public Parent(int i) {
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: public Parent(int i) {
- en: '}'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: An object of the class `Child` can now be created without any problems. That
    is how the class author can control the process of object creation.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以创建一个`Child`类的对象而不会出现任何问题。这就是类作者如何控制对象创建过程的方式。
- en: 'And if you decide that the `Parent` object has to be created using a constructor
    with parameters only, you can remove the no-arguments constructor from it again
    and add to the class `Child` a constructor that calls the `Parent` constructor
    with parameters:'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定只能使用带参数的构造函数来创建`Parent`对象，你可以再次从中删除无参数的构造函数，并向`Child`类添加一个调用带参数的`Parent`构造函数的构造函数：
- en: '```java'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class Child extends Parent{
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: public class Child extends Parent{
- en: public Child() {
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: public Child() {
- en: super(10);
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: super(10);
- en: '}'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Or, you can add to the child a constructor with parameters:'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以向子类添加一个带参数的构造函数：
- en: '```java'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class Child extends Parent{
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 子类继承父类
- en: public Child(int i) {
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: public Child(int i) {
- en: super(i);
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: super(i);
- en: '}'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Any of these work just fine.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都可以正常工作。
- en: 'From this demonstration, you have probably realized that in order to create
    an object of a child, all its parent objects have to be created (and their state
    initialized) first. And it has to be done starting from the most ancient ancestor.
    Let''s look at the following example:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个演示中，你可能已经意识到，为了创建一个子类的对象，必须首先创建所有的父对象（并初始化它们的状态）。而且必须从最古老的祖先开始。让我们看看下面的例子：
- en: '```java'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class GrandDad{
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: public class GrandDad{
- en: private String name = "GrandDad";
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: private String name = "GrandDad";
- en: public GrandDad() {
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: public GrandDad() {
- en: System.out.println(name);
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(name);
- en: '}'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class Parent extends GrandDad{
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: public class Parent extends GrandDad{
- en: private String name = "Parent";
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: private String name = "Parent";
- en: public Parent() {
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: public Parent() {
- en: System.out.println(name);
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(name);
- en: '}'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class Child extends Parent{
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: public class Child extends Parent{
- en: private String name = "Child";
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: private String name = "Child";
- en: public Child() {
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: public Child() {
- en: System.out.println(name);
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(name);
- en: '}'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Can you guess what the output is going to be if we try to create the child
    `new Child()`? If you guessed the `GrandDad` constructor finishes first, then
    `Parent`, then `Child`, you are correct. Here is the result:'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到我们尝试创建子类`new Child()`时的输出吗？如果你猜到`GrandDad`构造函数首先完成，然后是`Parent`，然后是`Child`，那么你是正确的。这是结果：
- en: '![](img/e65391e6-3a1e-406c-a12f-7d5f588b3abc.png)'
  id: totrans-1217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e65391e6-3a1e-406c-a12f-7d5f588b3abc.png)'
- en: The `Child` constructor calls the `Parent` constructor, which in turn calls
    the `GrandDad` constructor, which calls the `java.lang.Object` constructor. Only
    after a parent object has been created (and its constructor has finished doing
    what it had to do) does the child constructor finish executing, and so on through
    the chain of parent-child relations.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: '`Child`构造函数调用`Parent`构造函数，然后调用`GrandDad`构造函数，然后调用`java.lang.Object`构造函数。只有在创建了父对象（并且其构造函数已经完成了其任务）之后，子类构造函数才会执行，依此类推，直到父子关系链的末端。'
- en: After thinking a moment, we decide to derive the value of the field `name` from
    the class name. Every Java object has a base class, `java.lang.Object`, which
    provides access to the class information via the method `getClass()`. This method
    returns an object of the class `java.lang.Class` with all the information about
    the class used as a template for the object, including its name. Naturally, we
    first consider using `this.getClass().getName()` to get the class name inside
    `Child`, `Parent`, and `GrandDad`. But, if we start the chain of calls by calling
    `new Child()` (as we do in our example), the construct `this.getClass().getName()` always
    returns the name of the class `Child`, even when we use the construct in `GrandDad`.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一番思考，我们决定从类名中派生字段`name`的值。每个Java对象都有一个基类`java.lang.Object`，它通过方法`getClass()`提供对类信息的访问。此方法返回一个`java.lang.Class`类的对象，其中包含有关作为对象模板的类的所有信息，包括其名称。当然，我们首先考虑在`Child`，`Parent`和`GrandDad`中使用`this.getClass().getName()`来获取类名。但是，如果我们通过调用`new
    Child()`（就像我们的示例中所做的那样）来启动调用链，那么构造`this.getClass().getName()`总是返回类`Child`的名称，即使我们在`GrandDad`中使用该构造。
- en: The reason is that, although the keyword `this` represents the current object
    (the `GrandDad` object, for example, if `this` is used in `GrandDad`), the method
    `getClass()` returns information *not about the current object*, but about the
    *runtime* object (the one that was created by the operator `new`) which is an
    instance of `Child` in this case. That is why, in our example, the construct `this.getClass().getName()` always
    returns the name of the class `Child`, whether this construct is used inside `Child`, `Parent`,
    or `GrandDad`.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是，尽管关键字`this`表示当前对象（例如，如果在`GrandDad`中使用`this`，则表示`GrandDad`对象），但方法`getClass()`返回的是关于*当前对象*的信息，而不是关于*运行时*对象的信息（由`new`操作符创建的对象），在这种情况下是`Child`的实例。这就是为什么在我们的示例中，构造`this.getClass().getName()`总是返回类`Child`的名称，无论此构造是在`Child`，`Parent`还是`GrandDad`中使用。
- en: 'But there is another way to access the class information that better suits
    our needs. We can use the class name explicitly, add the extension `.class` to
    it, and only then get the class name. Here is an example:'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，还有另一种更适合我们需求的访问类信息的方法。我们可以显式使用类名，为其添加扩展名`.class`，然后再获取类名。这是一个例子：
- en: '```java'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: GrandDad.class.getSimpleName(); //always returns "GrandDad"
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: GrandDad.class.getSimpleName(); //总是返回"GrandDad"
- en: '```'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It seems like it's not much different from using the `String` literal we used
    before, does it? Nevertheless, it is an improvement because, if the name of the
    class changes, the value assigned to the variable `NAME` will change, too, while
    in the case of a `String` literal, its value is not tied to the name of the class
    automatically.
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来与我们之前使用的`String`字面量没有太大区别，是吗？然而，这是一个改进，因为如果类的名称更改，变量`NAME`的值也会更改，而在`String`字面量的情况下，其值不会自动绑定到类的名称。
- en: 'So, we have added a static field `NAME` with initialization to each of our
    three classes:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们为我们的三个类中的每一个添加了一个带初始化的静态字段`NAME`：
- en: '```java'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class GrandDad{
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: public class GrandDad{
- en: private static String NAME = GrandDad.class.getSimpleName();
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: private static String NAME = GrandDad.class.getSimpleName();
- en: public GrandDad() {
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: public GrandDad() {
- en: System.out.println(NAME);
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（NAME）;
- en: '}'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class Parent extends GrandDad{
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: public class Parent extends GrandDad{
- en: private static String NAME = Parent.class.getSimpleName();
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 私有静态字符串名称= Parent.class.getSimpleName（）;
- en: public Parent() {
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: public Parent（）{
- en: System.out.println(NAME);
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（NAME）;
- en: '}'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class Child extends Parent{
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: public class Child extends Parent{
- en: private static String NAME = Child.class.getSimpleName();
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 私有静态字符串名称= Child.class.getSimpleName（）;
- en: public Child() {
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: public Child（）{
- en: System.out.println(NAME);
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（NAME）;
- en: '}'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice that we have followed the convention of writing static variable identifiers
    in uppercase only.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们遵循了仅使用大写字母编写静态变量标识符的约定。
- en: 'If we call `new Child()`, the result will be as follows:'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`new Child()`，结果将如下所示：
- en: '![](img/32346bc4-8430-4745-b9c5-f076a9180520.png)'
  id: totrans-1249
  prefs: []
  type: TYPE_IMG
  zh: ！[]（img / 32346bc4-8430-4745-b9c5-f076a9180520.png）
- en: 'If we add a constructor with a parameter, the code will look as follows:'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加一个带参数的构造函数，代码将如下所示：
- en: '```java'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class GrandDad{
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: public class GrandDad{
- en: private static String NAME = GrandDad.class.getSimpleName()
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 私有静态字符串名称= GrandDad.class.getSimpleName（）
- en: public GrandDad() {
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: public GrandDad（）{
- en: System.out.println(NAME);
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（NAME）;
- en: '}'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public GrandDad(String familyName) {
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: public GrandDad（String familyName）{
- en: 'System.out.println(familyName + ": " + NAME);'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（familyName +“：”+ NAME）;
- en: '}'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class Parent extends GrandDad{
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: public class Parent extends GrandDad{
- en: private static String NAME = Parent.class.getSimpleName()
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 私有静态字符串名称= Parent.class.getSimpleName（）
- en: public Parent() {
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: public Parent（）{
- en: System.out.println(NAME);
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（NAME）;
- en: '}'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public Parent(String familyName) {
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: public Parent（String familyName）{
- en: 'System.out.println(familyName + ": " + NAME);'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（familyName +“：”+ NAME）;
- en: '}'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class Child extends Parent{
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: public class Child extends Parent{
- en: private static String NAME = Child.class.getSimpleName()
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 私有静态字符串名称= Child.class.getSimpleName（）
- en: public Child() {
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: public Child（）{
- en: System.out.println(NAME);
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（NAME）;
- en: '}'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public Child(String familyName) {
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: public Child（String familyName）{
- en: 'System.out.println(familyName + ": " + NAME);'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（familyName +“：”+ NAME）;
- en: '}'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The execution of the line `new Child("The Blows")` will now change the output
    only for the child:'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 执行行`new Child（“The Blows”）`现在将仅更改子项的输出：
- en: '![](img/b5431dce-b244-456c-b391-1cacaff45e5c.png)'
  id: totrans-1281
  prefs: []
  type: TYPE_IMG
  zh: ！[]（img / b5431dce-b244-456c-b391-1cacaff45e5c.png）
- en: 'That is because the new child''s constructor continues to call the parent''s
    constructor without parameters by default. To engage the new parent''s constructor,
    we need to do it explicitly, using the keyword `super` (we show only the constructors
    here):'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为新的子构造函数继续默认调用父构造函数而不带参数。要调用新父构造函数，我们需要显式地这样做，使用关键字`super`（我们只在这里显示构造函数）：
- en: '```java'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public GrandDad(String familyName) {
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: public GrandDad（String familyName）{
- en: 'System.out.println(familyName + ": " + NAME);'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（familyName +“：”+ NAME）;
- en: '}'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public Parent(String familyName) {
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: public Parent（String familyName）{
- en: super(familyName);
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: super（familyName）;
- en: 'System.out.println(familyName + ": " + NAME);'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（familyName +“：”+ NAME）;
- en: '}'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public Child(String familyName) {
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: public Child（String familyName）{
- en: super(familyName);
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: super（familyName）;
- en: 'System.out.println(familyName + ": " + NAME);'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（familyName +“：”+ NAME）;
- en: '}'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'By executing the same line, `new Child("The Blows")`, we get the desired result:'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行相同的行`new Child（“The Blows”）`，我们得到了期望的结果：
- en: '![](img/4d82cd27-f808-4711-8a56-be19b801524a.png)'
  id: totrans-1297
  prefs: []
  type: TYPE_IMG
  zh: ！[]（img / 4d82cd27-f808-4711-8a56-be19b801524a.png）
- en: Please notice that the keyword `super` has to be the first line of a constructor.
    If you try to put it anywhere else, an error will be generated. That is because
    all the constructors have to be completely executed before any other code can
    be invoked. All the objects in the parent-child chain have to be created and their
    state initialized first, starting from the topmost base class.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，关键字`super`必须是构造函数的第一行。如果您尝试将它放在其他任何地方，将生成错误。这是因为所有构造函数必须在调用任何其他代码之前完全执行。父子链中的所有对象必须首先创建并初始化它们的状态，从最顶层的基类开始。
- en: 'The last constructor-related feature that we would like to mention here is
    this: one constructor can call another constructor of the same class by using
    the keyword `this`. For example, let''s say we do not want a family to exist without
    a family name, but the client code might never be able to supply one. So, we decide
    to add a default family name to the constructor without parameters:'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在这里提到的最后一个与构造函数相关的特性是：一个构造函数可以使用关键字`this`调用同一类的另一个构造函数。例如，假设我们不希望家庭没有家庭名称存在，但客户端代码可能永远无法提供一个。因此，我们决定在没有参数的构造函数中添加默认的家庭名称：
- en: '```java'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class Child extends Parent{
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: public class Child extends Parent{
- en: private static String NAME = Child.class.getSimpleName()
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 私有静态字符串名称= Child.class.getSimpleName（）
- en: public Child() {
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: public Child（）{
- en: this("The Defaults");
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: this（“The Defaults”）;
- en: '}'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public Child(String familyName) {
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: public Child（String familyName）{
- en: super(familyName);
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: super（familyName）;
- en: 'System.out.println(familyName + ": " + NAME);'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（familyName +“：”+ NAME）;
- en: '}'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we execute the line `new Child()` again, we will get the following:'
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次执行行`new Child（）`，我们将得到以下结果：
- en: '![](img/4ef79cfa-e0bf-4034-9227-629400f76540.png)'
  id: totrans-1313
  prefs: []
  type: TYPE_IMG
  zh: ！[]（img / 4ef79cfa-e0bf-4034-9227-629400f76540.png）
- en: As you can see, the constructors of the same class can be overloaded and call
    each other the same way the methods do. But constructors are not inherited and
    thus cannot be hidden or overridden. That is just impossible.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，相同类的构造函数可以被重载并且可以像方法一样相互调用。但是构造函数不会被继承，因此不能被隐藏或覆盖。这是不可能的。
- en: As for any other method, it can be overridden if not private or final. What
    is private; you probably already have an idea. We will talk about it in more detail
    in [Chapter 7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml), *Packages and Accessibility
    (Visibility)*. And we will talk about *Final variable* in the next section.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何其他方法，如果不是私有或最终的，它可以被覆盖。私有是什么；您可能已经有一个想法。我们将在[第7章](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml)中更详细地讨论它，*包和可访问性（可见性）*。我们将在下一节中讨论*最终变量*。
- en: Final variable, final method, or final class
  id: totrans-1316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终变量，最终方法或最终类
- en: The use of the keyword `final` and its effects depend on the context. It can
    make a variable value unchangeable, a method not overridable, or a class not extendable.
    We will briefly discuss each of this situations.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`final`的使用及其影响取决于上下文。它可以使变量值不可更改，方法不可覆盖，或类不可扩展。我们将简要讨论每种情况。
- en: Final variable
  id: totrans-1318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终变量
- en: 'If a keyword `final` is placed in front of a variable declaration, the value
    of this variable once assigned (the variable is initialized) cannot be changed.
    The way a variable can be initialized depends on how the variable is used. There
    are three kinds of variable usage, and each has different initialization rules:'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在变量声明前面放置关键字`final`，则一旦分配了此变量的值（初始化了变量），则无法更改此变量的值。变量可以初始化的方式取决于变量的使用方式。有三种变量使用方式，每种方式都有不同的初始化规则：
- en: 'A local variable is a variable declared in the block of code; it can be initialized
    using an assignment in the same statement with the declaration, or sometime later,
    but only once; here are some examples:'
  id: totrans-1320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部变量是在代码块中声明的变量；可以使用相同语句中的赋值进行初始化，或者稍后进行初始化，但只能进行一次；这里有一些例子：
- en: '```java'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class SomeClass{
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 类SomeClass {
- en: private String someValue = "Initial value";
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 私有字符串someValue =“初始值”;
- en: public void setSomeValue(String someValue) {
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: public void setSomeValue（String someValue）{
- en: this.someValue = someValue;
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: this.someValue = someValue;
- en: '}'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String getSomeValue() {
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: public String getSomeValue（）{
- en: return someValue;
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 返回someValue;
- en: '}'
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class FinalDemo {
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 公共类FinalDemo {
- en: public static void main(String... args) {
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main（String ... args）{
- en: final SomeClass o = new SomeClass();
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 最终SomeClass o = new SomeClass（）;
- en: System.out.println(o.getSomeValue());   //Initial value
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（o.getSomeValue（））; //初始值
- en: o.setSomeValue("Another value");
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: o.setSomeValue（“另一个值”）;
- en: System.out.println(o.getSomeValue());   //Another value
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（o.getSomeValue（））; //另一个值
- en: o.setSomeValue("Yet another value");
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: o.setSomeValue（“另一个值”）;
- en: System.out.println(o.getSomeValue());   //Yet another value
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（o.getSomeValue（））; //另一个值
- en: final String s1, s2;
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 最终字符串s1，s2;
- en: final int x, y;
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 最终int x，y;
- en: y = 2;
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: y = 2;
- en: int v = y + 2;
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: int v = y + 2;
- en: x = v - 4;
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: x = v-4;
- en: System.out.println("x = " + x);        //x = 0
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（“x =”+ x）; // x = 0
- en: s1 = "1";
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: s1 =“1”;
- en: s2 = s1 + " and 2";
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: s2 = s1 +“和2”;
- en: System.out.println(s2);                // 1 and 2
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（s2）; // 1和2
- en: //o = new SomeClass();                 //error
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: // o = new SomeClass（）; //错误
- en: //s2 = "3";                            //error
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: // s2 =“3”; //错误
- en: //x = 5;                               //error
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: // x = 5; //错误
- en: //y = 6;                               //error
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: // y = 6; //错误
- en: '}'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The primitive types' final variables—after they are initialized the first time—become
    just constants and cannot be changed (see the last two lines that are commented
    as error). Similarly, the reference type `String` type final variable cannot be
    changed too, because of the `String` type immutability discussed in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types*. But other reference type objects, including
    arrays, are just referred to by the final variables. So, the reference itself
    cannot be changed (or reassigned) and remains a constant, too. But the state of
    the referred object can be changed, as demonstrated previously, using an object
    of `SomeClass`.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 基本类型的最终变量-初始化后第一次-变成常量，不能更改（请参见最后两行，已注释为错误）。同样，引用类型`String`类型的最终变量也不能更改，因为在[第5章]（ddf91055-8610-4b8c-acc5-453cfa981760.xhtml）中讨论的`String`类型不可变性。
    * Java语言元素和类型*。但是，其他引用类型对象（包括数组）只是由最终变量引用。因此，引用本身也不能更改（或重新分配），也保持不变。但是，所引用对象的状态可以更改，如前面使用`SomeClass`对象演示的那样。
- en: 'An instance variable can be initialized using an assignment in the same statement
    as the declaration (the same way as a local variable), using an instance initialization
    block, or in a constructor:'
  id: totrans-1356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用相同语句的赋值进行初始化实例变量（与局部变量相同），使用实例初始化块或构造函数：
- en: '```java'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class FinalDemo {
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 公共类FinalDemo {
- en: final SomeClass o = new SomeClass();
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 最终SomeClass o = new SomeClass（）;
- en: final String s1 = "Initial value";
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 最终字符串s1 =“初始值”;
- en: final String s2;
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 最终s2;
- en: final String s3;
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 最终字符串s3;
- en: final int i = 1;
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 最终int i = 1;
- en: final int j;
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: '最终int j; '
- en: final int k;
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 最终k;
- en: '{'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: j = 2;
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: j = 2;
- en: s2 = "new value";
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: s2 =“新值”;
- en: '}'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public FinalDemo() {
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 公共FinalDemo（）{
- en: k = 3;
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: k = 3;
- en: s3 = "new value";
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: s3 =“新值”;
- en: '}'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void method(){
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: public void method（）{
- en: //this.i = 4;         //error
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: // this.i = 4; //错误
- en: //this.j = 4;         //error
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: // this.j = 4; //错误
- en: //this.k = 4;         //error
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: // this.k = 4; //错误
- en: //this.s3 = "";       //error
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: // this.s3 =“”; //错误
- en: this.o.setSomeValue("New value");
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: this.o.setSomeValue（“新值”）;
- en: '}'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But, after the initialization, the primitive types and `String` values of the
    final instance variable cannot be changed, while the properties of an object (or
    components of an array) can, similar to the final local variable.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在初始化之后，无法更改最终实例变量的基本类型和`String`值，而对象的属性（或数组的组件）可以更改，类似于最终局部变量。
- en: 'The (`static`) class final variable can be initialized using an assignment
    in the same statement as the declaration (the same way as a local or instance
    variable), or using a static initialization block:'
  id: totrans-1384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （静态）类最终变量可以使用相同语句的赋值进行初始化（与局部或实例变量相同），或者使用静态初始化块：
- en: '```java'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class FinalDemo {
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 公共类FinalDemo {
- en: final static SomeClass OBJ = new SomeClass();
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 最终静态SomeClass OBJ = new SomeClass（）;
- en: final static String S1 = "Initial value";
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 最终静态字符串S1 =“初始值”;
- en: final static String S2;
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 最终静态字符串S2;
- en: final static int INT1 = 1;
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 最终静态int INT1 = 1;
- en: final static int INT2;
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 最终静态int INT2;
- en: static {
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 静态{
- en: INT2 = 2;
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: INT2 = 2;
- en: S2 = "new value";
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: S2 =“新值”;
- en: '}'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void method2(){
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: void method2（）{
- en: OBJ.setSomeValue("new value");
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: OBJ.setSomeValue（“新值”）;
- en: //OBJ = new SomeClass();
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: // OBJ = new SomeClass（）;
- en: //S1 = "";
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: // S1 =“”;
- en: //S2 = "";
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: // S2 =“”;
- en: //INT1 = 0;
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: // INT1 = 0;
- en: //INT2 = 0;
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: // INT2 = 0;
- en: '}'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As in the cases of local and instance final variables, the static final variables
    of primitive types and `String` become constants after the first assignment, while
    the property of an object (or components of an array) can be changed many times
    later.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 与局部和实例final变量一样，原始类型和`String`的静态final变量在第一次赋值后变为常量，而对象的属性（或数组的组件）可以在以后多次更改。
- en: 'If you think you never saw a final variable before this section, please notice
    that an interface field is final implicitly. Once assigned, it cannot be changed.
    There are two other kinds of variable that are implicitly final: a variable declared
    as a resource of a `try...with...resources` statement (we will see examples in
    [Chapter 16](d77f1f16-0aa6-4d13-b9a8-f2b6e195f0f1.xhtml), *Database Programming*)
    and an exception parameter of a multi-catch clause (we will talk about them in
    [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control Flow Statements*).'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为在本节之前从未见过final变量，请注意接口字段隐式地是final的。一旦赋值，就不能更改。还有另外两种隐式final的变量：作为`try...with...resources`语句的资源声明的变量（我们将在[第16章](d77f1f16-0aa6-4d13-b9a8-f2b6e195f0f1.xhtml)中看到示例，*数据库编程*）和多重捕获子句的异常参数（我们将在[第10章](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml)中讨论它们，*控制流语句*）。
- en: Final variables are important for security, but we are not going to talk about
    security in this book. Instead, we will see many uses of final variables during
    the discussion of Java functional programming in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml),
    *Lambda Expressions and Functional Programming*.
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: final变量对于安全性很重要，但我们不打算在本书中讨论安全性。相反，我们将在[第17章](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml)中讨论Java函数式编程时看到final变量的许多用途，*Lambda表达式和函数式编程*。
- en: 'While reading other people''s code, you might notice that the method parameters
    are declared final:'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读其他人的代码时，你可能会注意到方法参数被声明为final：
- en: '```java'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void someMethod(final int i, final String s, final SomeClass o){
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod(final int i, final String s, final SomeClass o){
- en: //...
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: '}'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It is often done with an intent to prevent the side effects of changing values
    outside the method. But we have demonstrated already in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types*, of primitive types are passed as copies and
    their re-assignment changes only the copy, not the original. In the case of the
    reference type `String`, we also demonstrated in the same chapter that its value
    is immutable because, for every `String` variable reassignment, a new copy of
    the value is created and the original value is not affected. As for the other
    reference types, making the reference itself final helps only to prevent an assignment
    of a new object. But if that is not the case, the reference being final does not
    prevent a change of properties of the original object outside the method.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是为了防止在方法外更改值的副作用。但我们已经在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中展示了，原始类型的副本被传递，它们的重新赋值只会更改副本，而不会更改原始值。对于引用类型`String`，我们在同一章节中也展示了它的值是不可变的，因为对于每个`String`变量的重新赋值，都会创建一个新的值的副本，原始值不受影响。至于其他引用类型，使引用本身为final只能防止分配新对象。但如果不是这种情况，引用本身为final并不能防止在方法外更改原始对象的属性。
- en: So, unless it is really necessary (for anonymous classes, for example, or a
    few other cases—the compiler and IDE will tell you about them), making these variables
    `final` prevents reassigning them a new value only inside the method, and does
    not help to avoid side effects outside the method.
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除非真的有必要（例如匿名类等情况——编译器和IDE会告诉你），将这些变量设为`final`只能防止在方法内部重新分配新值，并不能帮助避免方法外的副作用。
- en: Some programmers also argue that declaring variables final wherever possible
    makes the code author's intent easier to understand. That is true, but only if
    the convention is followed consistently and all variables that can be declared
    `final` are declared final. Otherwise, if some variables are declared final and
    some not (although they could be), the code may be misleading. One could think
    that the variables without the `final` keyword in front of them are declared so
    intentionally because they are reassigned to a different value somewhere. If you
    are not the code author (or even if you are the code author, but you are  looking
    at the code after a period of time), you can reasonably assume that there might
    be a branch of logic that takes advantage of a certain variable not being final.
    You are reluctant to add `final` to the existing variables because you are not
    sure if that was just missed or omitted intentionally, which means that the code
    is not clearer and the idea of more readable code falls apart.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 有些程序员也认为，尽可能在声明变量时使用final关键字可以使代码作者的意图更容易理解。这是正确的，但前提是必须一致地遵循这种约定，并且所有可以声明为`final`的变量都声明为final。否则，如果有些变量声明为final，有些没有（尽管它们可以），代码可能会误导。有人可能会认为，没有`final`关键字的变量是有意这样声明的，因为它们在其他地方被重新赋值为不同的值。如果你不是代码的作者（甚至是代码的作者，但是在一段时间后再看代码），你可以合理地假设可能存在一些逻辑分支利用了某个变量不是final。你不愿意将`final`添加到现有的变量中，因为你不确定这是有意遗漏还是故意省略，这意味着代码不够清晰，更易读的代码的想法就会破灭。
- en: 'To be fair, there is a class of difficult to discover errors that can be easily
    avoided if one applies the keyword `final` wherever one can. Please look at this
    example:'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，如果一个人能够在任何地方应用关键字`final`，就可以轻松避免一类难以发现的错误。请看这个例子：
- en: '```java'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class FinalVariable{
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: class FinalVariable{
- en: private int i;
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: private int i;
- en: public FinalVariable() { this.i = 1; }
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: public FinalVariable() { this.i = 1; }
- en: public void setInt(int i){
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: public void setInt(int i){
- en: this.i = 100;
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: this.i = 100;
- en: i = i;
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: i = i;
- en: '}'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int getInt(){
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: public int getInt(){
- en: return this.i;
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: return this.i;
- en: '}'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This class has a field `i` that is initialized in the constructor to the value
    `1`. The class also has a getter and setter for this field. In the setter, the
    programmer made a mistake. Can you spot it? Let''s run the following code:'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个字段`i`，在构造函数中初始化为值`1`。该类还有一个用于该字段的getter和setter。在setter中，程序员犯了一个错误。你能发现吗？让我们运行以下代码：
- en: '```java'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: FinalVariable finalVar = new FinalVariable();
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: FinalVariable finalVar = new FinalVariable();
- en: 'System.out.println("Initial setting: finalVar.getInt()=" +'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("初始设置：finalVar.getInt()=" +
- en: finalVar.getInt());
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: finalVar.getInt());
- en: finalVar.setInt(5);
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: finalVar.setInt(5);
- en: 'System.out.println("After setting to 5: finalVar.getInt()=" +'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("设置为5后：finalVar.getInt()=" +
- en: finalVar.getInt());
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: finalVar.getInt());
- en: '```'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In the code, we create an object of class `FinalVariable`. The constructor
    assigns it the value of `1` and we confirm it using the getter. Then, we try to
    assign it the value of `5` and expect the getter to return this value. Instead,
    we get the following output:'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们创建了一个`FinalVariable`类的对象。构造函数为其赋值`1`，我们使用getter确认了这一点。然后，我们尝试为其赋值`5`，并期望getter返回此值。相反，我们得到了以下输出：
- en: '![](img/eab4c3b7-7a1c-4f4c-b2f8-51d8a0c086e8.png)'
  id: totrans-1442
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eab4c3b7-7a1c-4f4c-b2f8-51d8a0c086e8.png)'
- en: 'Let''s see what happens if we declare the parameter `final`, as follows:'
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果声明参数`final`会发生什么，如下所示：
- en: '```java'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public void setInt(final int i){
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: public void setInt(final int i){
- en: this.i = 100;
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: this.i = 100;
- en: i = i;
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: i = i;
- en: '}'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The compiler and IDE would warn us that we are trying to assign the variable
    `i` to another value. We would see the problem and fix it like this:'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器和IDE会警告我们，我们试图将变量`i`赋给另一个值。我们会看到问题并进行修复，就像这样：
- en: '```java'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public void setInt(final int i){
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: public void setInt(final int i){
- en: this.i = 100;
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: this.i = 100;
- en: this.i = i;
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: this.i = i;
- en: '}'
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And the code would start behaving as we expected:'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 然后代码将开始按我们的预期行为：
- en: '![](img/b909084a-8295-4ad3-8470-576f6d6ee355.png)'
  id: totrans-1458
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b909084a-8295-4ad3-8470-576f6d6ee355.png)'
- en: But there are not many such cases, and soon you are going to learn how to avoid
    such pitfalls and start adding `this` in front of the instance variable automatically.
    So, in our opinion, extensive use of the keyword `final` as the way to improve
    code quality is not justified, but some programmers still prefer doing that, so
    we leave it as a matter of programming style.
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 但这样的情况并不多，很快你就会学会如何避免这样的陷阱，并开始自动在实例变量前添加`this`。因此，在我们看来，广泛使用关键字`final`来提高代码质量是不合理的，但一些程序员仍然喜欢这样做，因此我们将其作为编程风格问题留下。
- en: By the way, adding the keyword `final` as a way to improve application performance
    is reportedly useful in some special cases, but we have not encountered these
    cases ourselves and thus leave it to those who can demonstrate such a case.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，据报道，在某些特殊情况下，添加关键字`final`作为提高应用程序性能的一种方法是有用的，但我们自己并没有遇到这些情况，因此将其留给那些能够证明这种情况的人。
- en: Final method
  id: totrans-1461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Final method
- en: The keyword `final` in front of a method makes it impossible to override it
    in a child class instance or hide if, the method is static. It provides an assurance
    that the method functionality cannot be changed through overriding. The class
    `java.lang.Object`, for example, has many of its methods as final.
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法前面加上关键字`final`会使得在子类实例中无法覆盖它，如果方法是静态的，则无法隐藏它。它确保了方法功能不能通过覆盖进行更改。例如，类`java.lang.Object`有许多方法是final的。
- en: But if a final method uses non-final ones, this may allow for the backdoor introduction
    of undesirable changes. Naturally, such considerations are very important for
    security.
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果一个final方法使用非final方法，这可能会导致不良更改的后门引入。当然，这些考虑对于安全性非常重要。
- en: Sometimes, one can read that making methods final can improve code performance.
    It may be the case, but in some very specific situations and does not seem to
    help significantly in mainstream programming. For performance improvements, there
    are usually much better opportunities available, including the proven object-oriented
    design principles (see [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml),
    *Object-Oriented Design (OOD) Principles*).
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，人们会说将方法设置为final可以提高代码性能。这可能是事实，但在一些非常特殊的情况下，并不似乎在主流编程中有很大帮助。对于性能改进，通常有更好的机会可用，包括经过验证的面向对象设计原则（参见[第8章](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml)，*面向对象设计（OOD）原则*）。
- en: All private methods and methods of a final class (which are not inherited) are
    effectively final because one cannot override them.
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 所有私有方法和最终类的方法（不会被继承）实际上都是final的，因为不能对其进行覆盖。
- en: Final class
  id: totrans-1466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Final class
- en: A class declared final cannot be extended. That is, it cannot have children,
    which makes all the methods of the class effectively final.
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 声明为final的类不能被扩展。也就是说，它不能有子类，这使得类的所有方法实际上都是final的。
- en: This feature is widely used for security or when a programmer would like to
    make sure the class functionality cannot be overridden, overloaded, or hidden.
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性被广泛用于安全性或者当程序员希望确保类功能不能被覆盖、重载或隐藏时。
- en: Exercise – Restricting a class instantiation to a single shared instance
  id: totrans-1469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习-将类实例化限制为单个共享实例
- en: Write a class in such a way that it guarantees that only one object can be created.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个类，确保只能创建一个对象。
- en: Answer
  id: totrans-1471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here is one possible solution:'
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个可能的解决方案：
- en: '```java'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class SingletonClassExample {
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: public class SingletonClassExample {
- en: private static SingletonClassExample OBJECT = null;
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: private static SingletonClassExample OBJECT = null;
- en: private SingletonClassExample(){}
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: private SingletonClassExample(){}
- en: public final SingletonClassExample getInstance() {
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: public final SingletonClassExample getInstance() {
- en: if(OBJECT == null){
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: if(OBJECT == null){
- en: OBJECT = new SingletonClassExample();
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: OBJECT = new SingletonClassExample();
- en: '}'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return OBJECT;
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: return OBJECT;
- en: '}'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //... other class functionality
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: //... 其他类功能
- en: '}'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Another solution could be to make the class private inside the factory class
    and store it in the factory field, similarly to the previous code.
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案可能是将类私有化到工厂类中，并将其存储在工厂字段中，类似于以前的代码。
- en: Be aware, though, that if such a single object has a state that is changing,
    one has to make sure it is acceptable to modify the state and rely on it concurrently,
    because this object may be used by different methods at the same time.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 但要注意，如果这样一个单一对象具有正在改变的状态，就必须确保可以同时修改状态并依赖于它，因为这个对象可能会被不同的方法同时使用。
- en: Summary
  id: totrans-1488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: One of the most often used terms, API, was thoroughly discussed in this chapter,
    as well as the related topics of object factories, overriding, hiding, and overloading.
    Also, the use of the keywords `this` and `super` was explored in detail and demonstrated
    during the explanation of constructors. The chapter concluded with an overview
    of the keyword `final` and its use for local variables, fields, methods, and classes.
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还对最常用的术语API进行了详细讨论，以及相关主题的对象工厂、重写、隐藏和重载。此外，还详细探讨了关键字`this`和`super`的使用，并在构造函数的解释过程中进行了演示。本章以关键字`final`及其在局部变量、字段、方法和类中的使用进行了概述。
- en: In the next chapter, we will describe package and class member accessibility (also
    called visibility), which will help us to expand on one of the key object-oriented
    programming concepts, encapsulation. It will lay the foundation for our discussion
    of object-oriented design principles.
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将描述包和类成员的可访问性（也称为可见性），这将帮助我们扩展面向对象编程的一个关键概念，封装。这将为我们讨论面向对象设计原则奠定基础。
