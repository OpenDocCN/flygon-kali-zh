- en: Workers - Learning about Dedicated and Shared Workers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作者-学习专用和共享工作者
- en: In the past few chapters, we have focused on Node.js and how we can write backend
    applications utilizing the same language as the frontend. We have seen various
    ways of creating servers, offloading tasks, and streaming. In this part, we will
    focus on the offloading tasks aspect of the browser.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们专注于Node.js以及如何利用与前端相同的语言编写后端应用程序。我们已经看到了创建服务器、卸载任务和流式传输的各种方法。在这一部分，我们将专注于浏览器的任务卸载方面。
- en: Eventually, as we have seen in Node.js, we need to offload some computationally
    intensive tasks from the main thread to a separate thread, or process, to make
    sure that our application stays responsive. While the effects of having a server
    not respond can be quite jarring, the effects of our user interface not working
    are downright off-putting to most users. Therefore, we have the Worker API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，正如我们在Node.js中所看到的，我们需要将一些计算密集型任务从主线程转移到单独的线程或进程，以确保我们的应用程序保持响应。服务器不响应的影响可能相当令人震惊，而用户界面不工作的影响对大多数用户来说是非常令人反感的。因此，我们有了Worker
    API。
- en: 'In this chapter, we will specifically look at two kinds of workers, dedicated
    and shared. Overall, we will do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专门研究两种工作方式，即专用和共享。总的来说，我们将做以下工作：
- en: Learn to offload heavy processing to a worker thread via the Worker API.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会通过Worker API将繁重的处理任务转移到工作线程。
- en: Learn how to talk with workers via the `postMessage` and `BroadcastChannel`
    APIs.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何通过`postMessage`和`BroadcastChannel` API与工作线程进行通信。
- en: Talk about `ArrayBuffer` and the `Transferrable` property so we can quickly
    move data between workers and the main thread.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论`ArrayBuffer`和`Transferrable`属性，以便我们可以快速在工作者和主线程之间移动数据。
- en: Look at `SharedWorker` and the Atomics API to see how we can share data between
    multiple tabs of our application.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看`SharedWorker`和Atomics API，看看我们如何在应用程序的多个选项卡之间共享数据。
- en: Take a look at a partial implementation of a shared cache utilizing the knowledge
    from the previous sections.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看利用前几节知识的共享缓存的部分实现。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following items are needed to complete this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章需要以下项目：
- en: A text editor or IDE, preferably VS Code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编辑器或IDE，最好是VS Code
- en: Access to Chrome or Firefox
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问Chrome或Firefox
- en: Some knowledge of parallelization in computing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机并行化知识
- en: The code found at [https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter10).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter10)找到的代码。
- en: Offloading work to a dedicated worker
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将工作转移到专用工作者
- en: Workers give us the ability to offload long-running, computationally-intensive
    tasks to the background. Instead of having to make sure our event loop is not
    filled with some type of heavy task, we can offload that task to a background
    thread.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者使我们能够将长时间运行的计算密集型任务转移到后台。我们不必再担心我们的事件循环是否被某种繁重的任务填满，我们可以将该任务转移到后台线程。
- en: 'In other languages/environments, this might look like the following (this is
    only pseudo-code and is not really tied to any language):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言/环境中，这可能看起来像以下内容（这只是伪代码，实际上与任何语言都没有真正联系）：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While this works well in those environments, we have to start thinking about
    topics such as deadlock, zombie threads, read after write, and so on. All of these
    can be quite hard to comprehend and are usually some of the most difficult bugs
    that can be encountered. Instead of JavaScript giving us the capability of utilizing
    something like the preceding, they gave us workers, which give us another context
    to work in where we don't face the same issues.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这在这些环境中运行良好，但我们必须开始考虑诸如死锁、僵尸线程、写后读等主题。所有这些都可能非常难以理解，通常是可以遇到的最困难的错误之一。JavaScript没有给我们提供利用类似前述的能力，而是给了我们工作者，这给了我们另一个上下文来工作，我们在那里不会遇到相同的问题。
- en: For those that are interested, a book on operating systems or Unix programming
    can help shed light on the preceding issues. These topics are out of the scope
    of this book, but they are quite interesting and there are even languages that
    are trying to address these issues by building the workarounds into the languages.
    Some examples of these are Go ([https://golang.org/](https://golang.org/)), which
    uses a technique of message passing, and Rust ([https://www.rust-lang.org/](https://www.rust-lang.org/)),
    which utilizes the concept of borrow checking and such to minimize these issues.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些感兴趣的人，操作系统或Unix编程的书籍可以帮助解决上述问题。这些主题超出了本书的范围，但它们非常有趣，甚至有一些语言正在尝试通过将解决方案构建到语言中来解决这些问题。其中一些例子是Go（[https://golang.org/](https://golang.org/)），它使用消息传递技术，以及Rust（[https://www.rust-lang.org/](https://www.rust-lang.org/)），它利用借用检查等概念来最小化这些问题。
- en: 'To start off with an example of work being done in the background, we are going
    to spawn a `Worker` and have it compute a sum over 1 million numbers. To do this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们以在后台进行工作的示例开始，我们将生成一个`Worker`并让它计算100万个数字的总和。为此：
- en: 'We add the following `script` section to our HTML file:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在HTML文件中添加以下`script`部分：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We create a JavaScript file for our `Worker` and add the following:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为我们的`Worker`创建一个JavaScript文件，并添加以下内容：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we launch Chrome, we should see two messages printed – one that says it was
    run on the main thread and another with the value 499999500000. We should also
    see that one was logged by the HTML file and the other was logged by the worker.
    We have just spawned a worker and got it to do some work for us!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启动Chrome，我们应该看到打印出两条消息-一条说它在主线程上运行，另一条显示值为499999500000。我们还应该看到其中一条是由HTML文件记录的，另一条是由工作者记录的。我们刚刚生成了一个工作者，并让它为我们做了一些工作！
- en: Remember that if we want to run JavaScript files from our filesystem and not
    a server, we will need to close out of all instances of Chrome and then relaunch
    it from the command line using `chrome.exe –-allow-file-access-from-files`. This
    will give us access to launch our external JavaScript files from the filesystem
    and not need a server.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果我们想从我们的文件系统运行JavaScript文件而不是服务器，我们需要关闭所有Chrome的实例，然后从命令行重新启动它，使用`chrome.exe
    –-allow-file-access-from-files`。这将使我们能够从文件系统启动我们的外部JavaScript文件，而不需要服务器。
- en: Let's go ahead and do something a little more complex that the user may want
    to do. One interesting math problem is getting the prime factorization for a number.
    This means that, when given a number, we will try to find all of the prime numbers
    (numbers that are only divisible by one and itself) that make up that number.
    An example would be the prime factorization of 12, which is 2, 2, and 3.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续做一些用户可能想做的更复杂的事情。一个有趣的数学问题是得到一个数字的质因数分解。这意味着，当给定一个数字时，我们将尝试找到组成该数字的所有质数（只能被1和它自己整除的数字）。一个例子是12的质因数分解，即2、2和3。
- en: This problem leads to the interesting field of cryptography and how public/private
    keys work. The basic understanding is that, given two relatively large prime numbers,
    multiplying them is easy, but finding those two numbers from that product of them
    is infeasible due to time constraints.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题导致了密码学的有趣领域以及公钥/私钥的工作原理。基本的理解是，给定两个相对较大的质数，将它们相乘很容易，但根据时间限制，从它们的乘积中找到这两个数字是不可行的。
- en: 'Back to the task at hand, what we will do is spawn a `worker` after the user
    inputs a number into an input box. We will compute that number and log it to the
    console. So let''s begin:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 回到手头的任务，我们将在用户将数字输入到输入框后生成一个`worker`。我们将计算该数字并将其记录到控制台。所以让我们开始：
- en: 'We add an input to our HTML file and change the code to spawn a `worker` on
    the change event for that input box:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在HTML文件中添加一个输入，并更改代码以在输入框的更改事件上生成一个`worker`：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we will grab our name in the `worker` and use that as the input. From
    there, we will run the prime factorization algorithm found at [https://www.geeksforgeeks.org/print-all-prime-factors-of-a-given-number/](https://www.geeksforgeeks.org/print-all-prime-factors-of-a-given-number/),
    but transposed to JavaScript. Once we are done, we will turn off the `worker`:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在`worker`中获取我们的名字，并将其用作输入。从那里，我们将运行在[https://www.geeksforgeeks.org/print-all-prime-factors-of-a-given-number/](https://www.geeksforgeeks.org/print-all-prime-factors-of-a-given-number/)找到的质因数分解算法，但转换为JavaScript。完成后，我们将关闭`worker`：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If we now run this application in the browser, we will see that after each input
    we get the console log message in the console. Notice that there is no factor
    for the number 1\. There is a mathematical reason for this, but just note that
    there is no prime factorization for the number 1.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在浏览器中运行这个应用程序，我们会看到在每次输入后，我们会在控制台中得到控制台日志消息。请注意，数字1没有因子。这是一个数学原因，但请注意数字1没有质因数分解。
- en: We can run this for a bunch of inputs, but if we put in a relatively large number
    such as `123,456,789`, it will still compute it in the background as we do things
    on the main thread. Now, we are currently passing data to the worker through the
    name of the worker. There has to be a way to pass data between the worker and
    the main thread. This is where the `postMessage` and `BroadcastChannel` APIs come
    into play!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对一堆输入运行这个，但如果我们输入一个相对较大的数字，比如`123,456,789`，它仍然会在后台计算，因为我们在主线程上做事情。现在，我们目前通过worker的名称向worker传递数据。必须有一种方法在worker和主线程之间传递数据。这就是`postMessage`和`BroadcastChannel`API发挥作用的地方！
- en: Moving data in our application
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的应用程序中移动数据
- en: As we have seen in the `worker_thread` module inside of Node.js, there is a
    way to communicate with our workers. This is through the `postMessage` system.
    If we take a look at the method signature, we will see that it requires a message
    that can be any JavaScript object, even those with cyclical references. We also
    see another parameter called transfer. We will go into depth on that in a bit
    but, as the name suggests, it allows us to actually transfer the data instead
    of copying the data to the worker. This is a much faster mechanism for transferring
    data, but there are some caveats when utilizing it that we will discuss later.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在Node.js的`worker_thread`模块中看到的，有一种方法可以与我们的worker通信。这是通过`postMessage`系统。如果我们看一下方法签名，我们会发现它需要一个消息，可以是任何JavaScript对象，甚至带有循环引用的对象。我们还看到另一个名为transfer的参数。我们稍后会深入讨论这一点，但正如其名称所示，它允许我们实际传输数据，而不是将数据复制到worker。这是一个更快的数据传输机制，但在利用它时有一些注意事项，我们稍后会讨论。
- en: 'Let''s take the example that we have been building on and respond to messages
    sent from the frontend:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以我们一直在构建的例子为例，并回应从前端发送的消息：
- en: We will swap out creating a new `worker` each time a change event occurs and
    just create one right away. Then, on a change event, we will send the data to
    the `worker` via the `postMessage`*:*
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在每次更改事件发生时创建一个新的`worker`并立即创建一个。然后，在更改事件上，我们将通过`postMessage`将数据发送到`worker`：*
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we now tried this example, we would not receive anything from the main thread.
    We have to respond to the `onmessage` event that comes on the worker''s global
    descriptor called `self`. Let''s go ahead and add our handler to that and also
    remove the `self.close()` method since we want to keep this around:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在尝试这个例子，我们将不会从主线程收到任何东西。我们必须响应worker的全局描述符`self`上的`onmessage`事件。让我们继续添加我们的处理程序，并删除`self.close()`方法，因为我们想保留它：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we can see from this example, we have moved the calculation of the primes
    to a separate function and when we get a message, we grab the data and pass it
    to the `calculatePrimes` method. Now, we are working with the messaging system.
    Let''s go ahead and add another feature to our example. Instead of printing to
    the console, let''s give the user some feedback based on what they input:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中可以看出，我们已经将素数的计算移到了一个单独的函数中，当我们收到消息时，我们获取数据并将其传递给`calculatePrimes`方法。现在，我们正在使用消息系统。让我们继续为我们的示例添加另一个功能。不要打印到控制台，让用户根据他们的输入得到一些反馈：
- en: 'We will add a paragraph tag below the input that will hold our answer:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在输入框下面添加一个段落标签来保存我们的答案：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we will add to the `onmessage` handler of `worker`, just like we did inside
    of the `worker`, to listen for events from the `worker`. When we get some data,
    we will populate the answer with the values returned:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在`worker`的`onmessage`处理程序中添加一些内容，就像我们在`worker`内部所做的那样，以监听来自`worker`的事件。当我们收到一些数据时，我们将用返回的值填充答案：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we will change our `worker` code to send the data utilizing the `postMessage`
    method to send the primes back to the main thread:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将更改我们的`worker`代码，利用`postMessage`方法将数据发送回主线程：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This also showcases that we do not need to add the `self` piece to call methods
    that are on the global scope. Just like the window is the global scope for the
    main thread, `self` is the global scope for the worker threads.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这也展示了我们不需要添加`self`来调用全局范围的方法。就像窗口是主线程的全局范围一样，`self`是工作线程的全局范围。
- en: With this example, we have explored the `postMessage` method and seen how we
    can send data between a worker to the thread that spawned it, but what if we had
    multiple tabs that we wanted to communicate with? What if we had multiple workers
    that we wanted to send messages to?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们已经探讨了`postMessage`方法，并看到了如何在工作线程和生成它的线程之间发送数据，但如果我们有多个选项卡想要进行通信怎么办？如果我们有多个工作线程想要发送消息怎么办？
- en: 'One way of dealing with this is to just keep track of all of the workers and
    loop through them, sending the data out like the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的一种方法是跟踪所有的工作线程，并循环遍历它们，像下面这样发送数据：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the `test.js` file, we just console log the message and say which worker
    we are referencing by name. This can easily get out of hand since we would need
    to keep track of which workers are still alive and which ones have been removed.
    Another way of handling this would be to broadcast the data out on a channel.
    Luckily, we have an API for that, called the `BroadcastChannel` API.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test.js`文件中，我们只是控制台记录消息，并说明我们正在引用的工作线程的名称。这可能很快失控，因为我们需要跟踪哪些工作线程仍然存活，哪些已经被移除。处理这个问题的另一种方法是在一个通道上广播数据。幸运的是，我们有一个名为`BroadcastChannel`的API可以做到这一点。
- en: 'As the document on the MDN site states ([https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API)),
    all we need to do is create a `BroadcastChannel` object by passing a single argument
    into its constructor, the name of the channel. Whoever calls it first creates
    the channel and then anyone can listen in on it. Sending and receiving data is
    as simple as our `postMessage` and `onmessage` examples have been. The following
    takes our previous code for our test interface and, instead of needing to keep
    track of all the workers, just broadcasts the data out:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如MDN网站上的文档所述（[https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API)），我们只需要通过将单个参数传递给它的构造函数来创建一个`BroadcastChannel`对象，即通道的名称。谁先调用它就创建了通道，然后任何人都可以监听它。发送和接收数据就像我们的`postMessage`和`onmessage`示例一样简单。以下是我们先前用于测试界面的代码，而不需要跟踪所有工作线程，只需广播数据出去：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, in our `workers`, all we need to do is listen in on `BroadcastChannel`
    instead of listening in on our own message handler:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的`workers`中，我们只需要监听`BroadcastChannel`，而不是监听我们自己的消息处理程序：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have now simplified the process of sending and receiving a message between
    multiple workers and even multiple tabs that have the same host. What makes this
    system great is that we can have some workers based on some criteria listen in
    on one channel and others listen in on another. We could then have a global channel
    to send commands that any of them could respond to. Let''s go ahead and make a
    simple adjustment to our primes program. Instead of sending the data to a single
    dedicated worker, we will have four workers; two of them will handle even numbers
    and the other two will handle odd numbers:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经简化了在多个工作线程和甚至多个具有相同主机的选项卡之间发送和接收消息的过程。这个系统的优点在于，我们可以根据一些标准让一些工作线程监听一个通道，而让其他工作线程监听另一个通道。然后，我们可以有一个全局通道发送命令，任何工作线程都可以响应。让我们继续对我们的素数程序进行简单的调整。我们将不再将数据发送到单独的工作线程，而是将有四个工作线程；其中两个将处理偶数，另外两个将处理奇数：
- en: 'We update our main code to launch four workers. We will name them based on
    whether the number is even or not:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们更新我们的主要代码以启动四个工作线程。我们将根据数字是偶数还是奇数来命名它们：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We change what happens upon an input, sending the even numbers to the even
    channel and the odd numbers to the odd channel:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们更改了输入后发生的事情，将偶数发送到偶数通道，将奇数发送到奇数通道：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We create three channels: one for the even numbers, one for the odd numbers,
    and one for a global send to all workers:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建三个通道：一个用于偶数，一个用于奇数，一个用于全局发送给所有工作线程：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We add a new button to kill all of the workers and hook it up to broadcast
    on the global channel:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加一个新按钮来终止所有工作线程，并将其连接到全局通道上广播：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We change our worker to handle messages based on its name:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们更改我们的工作线程以根据其名称处理消息：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we do get a message on one of these channels, we respond just like we
    have been:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在这些通道中的一个上收到消息时，我们会像以前一样做出响应：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we receive a message on the global channel, we check to see whether it is
    the `quit` message. If it is, then kill the worker:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在全局通道上收到消息，我们检查它是否是`quit`消息。如果是，就终止工作线程：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, back on the main thread, we will listen in on the even and odd channels
    for data. When there is data, we handle it almost exactly like before:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到主线程，我们将监听奇数和偶数通道上的数据。当有数据时，我们几乎与以前处理它的方式完全相同：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: One thing to note is how our workers and the main thread handle data coming
    in on the odd and even channels. Since we are broadcasting, we need to make sure
    it is the data that we want. In the case of the workers, we only want numbers
    and, in the case of our main thread, we only want to see arrays.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是我们的工作线程和主线程如何处理奇数和偶数通道上的数据。由于我们是广播，我们需要确保它是我们想要的数据。在工作线程的情况下，我们只想要数字，在主线程的情况下，我们只想要看到数组。
- en: The `BroadcastChannel` API only works with the same origin. This means that
    we cannot communicate between two different sites, only with pages under the domain.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`BroadcastChannel` API只能与相同的源一起使用。这意味着我们不能在两个不同的站点之间通信，只能在同一域下的页面之间通信。'
- en: While this is an overly complex example of the `BroadcastChannel` mechanism,
    it should showcase how we can easily decouple workers from their parents and make
    them easy to send data to without looping through them. Now, we will return to
    the `postMessage` method and look at that `transferrable` property and what it
    means for sending and receiving data.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是`BroadcastChannel`机制的一个过于复杂的例子，但它应该展示了我们如何可以轻松地将工作线程与其父级解耦，并使它们易于发送数据而无需循环遍历它们。现在，我们将回到`postMessage`方法，并查看`transferrable`属性以及它对发送和接收数据的意义。
- en: Sending binary data in the browser
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中发送二进制数据
- en: 'While message passing is a great way to send data, there are some problems
    when it comes to sending very large objects across the channel. For instance,
    let''s say we have a dedicated worker that makes requests on our behalf and also
    adds some data to the worker from a cache. It could potentially have thousands
    of records. While the worker would already be taking up quite a bit of memory,
    as soon as we utilize `postMessage` we will see two things:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然消息传递是发送数据的一种很好的方式，但在通过通道发送非常大的对象时会出现一些问题。例如，假设我们有一个专用的工作线程代表我们发出请求，并且还从缓存中向工作线程添加一些数据。它可能会有数千条记录。虽然工作线程已经占用了相当多的内存，但一旦我们使用`postMessage`，我们会看到两件事：
- en: The amount of time it takes to move the object is going to be long
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动对象所需的时间会很长。
- en: Our memory is going to increase dramatically
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的内存将大幅增加
- en: The reason for this is the structured clone algorithm that browsers use to send
    the data. Essentially, instead of just moving the data across the channel, it
    is going to serialize and deserialize our object, essentially creating multiple
    copies of it. On top of this, we have no idea when the garbage collector is going
    to run as we know it is non-deterministic.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为浏览器使用结构化克隆算法来发送数据。基本上，它不仅仅是将数据移动到通道上，而是将对象进行序列化和反序列化，从根本上创建多个副本。除此之外，我们不知道垃圾回收器何时运行，因为我们知道它是不确定的。
- en: 'We can actually see the copying process in the browser. If we create a worker
    called `largeObject.js` and move a giant payload, we can measure the time it takes
    by utilizing the `Date.now()` method. On top of this, we can utilize the record
    system in the developer''s tools, as we learned in [Chapter 1](28196d54-886b-4b9c-9974-190c0800c971.xhtml),
    *Tools for High Performance on the Web*, to profile the amount of memory that
    we use. Let''s set this test case up:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以在浏览器中看到复制过程。如果我们创建一个名为`largeObject.js`的工作线程并移动一个巨大的有效负载，我们可以通过利用`Date.now()`方法来测量所需的时间。除此之外，我们还可以利用开发者工具中的记录系统，就像我们在[第1章](28196d54-886b-4b9c-9974-190c0800c971.xhtml)中学到的那样，*网络高性能工具*，来分析我们使用的内存量。让我们设置这个测试案例：
- en: 'Create a new worker and assign it a large object. In this case, we are going
    to use a 100,000-element array that is storing objects inside of it:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的工作线程并分配一个大对象。在这种情况下，我们将使用一个存储对象的100,000元素数组：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We now add to our HTML file some code to launch this worker and listen for
    the message. We will mark when the message arrives and then we will profile the
    code to see the increase in memory:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们在HTML文件中添加一些代码来启动这个工作线程并监听消息。我们将标记消息到达的时间，然后对代码进行分析以查看内存增加情况：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If we now load this up into our browser and profile our code, we should see
    results similar to the following. The message took anywhere between 800 ms to
    1.7 s, and the heap size was anywhere between 80 MB and 100 MB. While this case
    is definitely out of the bounds of most people, it showcases some issues with
    this type of message passing.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在将其加载到浏览器中并对代码进行分析，我们应该会看到类似以下的结果。消息的时间在800毫秒到1.7秒之间，堆大小在80MB到100MB之间。虽然这种情况绝对超出了大多数人的范围，但它展示了这种消息传递方式的一些问题。
- en: A solution to this is to use the transferrable portion of the `postMessage`
    method. This allows us to *send* a binary data type across the channel and, instead
    of copying it, the channel actually just transfers the object. This means that
    the sender no longer has access to it, but the receiver does. A way to think about
    this is that the sender puts the data in a holding location and tells the receiver
    where it is at. At this point, the sender can no longer access it. The receiver
    receives all of the data and notices that it has a location to look for data.
    It goes to this location and grabs it, thereby fulfilling the data transfer mechanism.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是使用`postMessage`方法的可传递部分。这允许我们*发送*一个二进制数据类型通过通道，而不是复制它，通道实际上只是转移对象。这意味着发送方不再能够访问它，但接收方可以。可以这样理解，发送方将数据放在一个保持位置，并告诉接收方它在哪里。此时，发送方不再能够访问它。接收方接收所有数据，并注意到它有一个位置来查找数据。它去到这个位置并获取数据，从而实现数据传输机制。
- en: 'Let''s go ahead and code a simple example. Let''s take our heavy worker and
    populate it with a bunch of data, in this case, a list of numbers from 1 to 1,000,000:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续编写一个简单的例子。让我们使用大量数据填充我们的重型工作线程，比如从1到1,000,000的数字列表：
- en: 'We create an `Int32Array` with 1,000,000 elements. We then add all of the numbers
    1 through 1,000,000 in it:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个包含1,000,000个元素的`Int32Array`。然后我们在其中添加从1到1,000,000的所有数字：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will then send that data by utilizing the transferrable portion of `postMessage`.
    Note that we have to get the underlying `ArrayBuffer`. We will discuss this shortly:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将利用`postMessage`的可传递部分发送这些数据。请注意，我们必须获取基础的`ArrayBuffer`。我们很快会讨论这一点：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will receive the data on the main thread and write out the length of that
    data:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在主线程上接收数据并输出该数据的长度：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We will notice that the time it took to transfer this large chunk of data was
    almost unnoticeable. This is because of the preceding theory where it just boxes
    the data and puts it to the side for the received.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会注意到传输这一大块数据所花费的时间几乎是不可察觉的。这是因为前面的理论，它只是将数据打包并将其放到接收端。
- en: An aside is needed for typed arrays and `ArrayBuffers`. The `ArrayBuffers` can
    be thought of as buffers in Node.js. They are the lowest form of storing data
    and directly hold the bytes of some data. But, to truly utilize them, we need
    to put a *view* on the `ArrayBuffer`. This means that we need to give meaning
    to that `ArrayBuffer`. In our case, we are saying that it stores signed 32-bit
    integers. We can put all sorts of views over `ArrayBuffer`, just like how we can
    interpret buffers in Node.js in different ways. The best way to think about this
    is that `ArrayBuffer` is the low-level system that we really don't want to utilize
    and that the views are the system that gives meaning to the underlying data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类型化数组和`ArrayBuffers`需要额外说明。`ArrayBuffers`可以被视为Node.js中的缓冲区。它们是存储数据的最低形式，并直接保存一些数据的字节。但是，为了真正利用它们，我们需要在`ArrayBuffer`上放置一个*视图*。这意味着我们需要赋予`ArrayBuffer`意义。在我们的例子中，我们说它存储有符号的32位整数。我们可以在`ArrayBuffer`上放置各种视图，就像我们可以以不同的方式解释Node.js中的缓冲区一样。最好的思考方式是，`ArrayBuffer`是我们真正不想使用的低级系统，而视图是赋予底层数据意义的系统。
- en: 'With this in mind, if we check out the byte length of the `Int32Array` on the
    worker side, we will see that it is zero. We no longer have access to that data,
    just as we said. To further utilize this feature before heading on to `SharedWorkers`
    and `SharedArrayBuffers`, we will modify our factorization program to utilize
    this transferrable property to send the factors across:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，如果我们在工作线程端检查`Int32Array`的字节长度，我们会发现它是零。我们不再可以访问那些数据，正如我们所说的。在继续讨论`SharedWorkers`和`SharedArrayBuffers`之前，我们将修改我们的因式分解程序，利用这个可传递属性发送因子：
- en: 'We will utilize almost the exact same logic, except instead of sending over
    the array that we have, we will send over `Int32Array`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将几乎使用完全相同的逻辑，只是不再发送我们拥有的数组，而是发送`Int32Array`：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we will update our receiving end code to handle `ArrayBuffers` being sent
    instead of just an array:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将更新接收端代码，以处理发送的`ArrayBuffers`而不仅仅是一个数组：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If we test this code out, we will see that it works just the same, but we are
    no longer copying the data across, we are just giving it to the main thread, thereby
    making the message passing faster and making it utilize less memory.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们测试这段代码，我们会发现它的工作方式是一样的，但我们不再复制数据，而是将其交给主线程，从而使消息传递更快，利用的内存更少。
- en: The main idea is that, if we are just sending results or we need to be as quick
    as possible, we should try to utilize the transferrable system for sending data.
    If we have to use the data in the worker after sending it, or there is not a simple
    way to send the data (we have no serialization technique), we can utilize the
    normal `postMessage` system.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 主要思想是，如果我们只是发送结果或需要尽快完成，我们应该尝试利用可传递系统发送数据。如果我们在发送数据后需要在工作线程中使用数据，或者没有简单的方法发送数据（我们没有序列化技术），我们可以利用正常的`postMessage`系统。
- en: Just because we can use the transferrable system to reduce memory footprint,
    it could cause times to increase based on the amount of data transformation we
    need to apply. If we already have binary data, this is great, but if we have JSON
    data that needs to be moved, it may be better to just transfer it in that form
    instead of having to go through many intermediary transformations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为我们可以使用可传递系统来减少内存占用，这可能会导致基于需要应用的数据转换量而增加时间。如果我们已经有二进制数据，这很好，但如果我们有需要移动的JSON数据，可能最好的方法是以该形式传输它，而不是经过许多中间转换。
- en: With all of these ideas, let's take a look at the `SharedWorker` system and
    `SharedArrayBuffer` system. Both of these systems, especially the `SharedArrayBuffer`,
    have led to some issues in the past (we will discuss this in the following section),
    but if we utilize them carefully we will be able to leverage their capability
    of being a good message-passing and data-sharing mechanism.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些想法，让我们来看看`SharedWorker`系统和`SharedArrayBuffer`系统。这两个系统，特别是`SharedArrayBuffer`，在过去引起了一些问题（我们将在下一节讨论），但如果我们小心使用它们，我们将能够利用它们作为良好的消息传递和数据共享机制的能力。
- en: Sharing data and workers
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享数据和工作线程
- en: While most of the time we want to keep the boundaries up between our workers
    and tabs of our applications, there will be times when we want to just share the
    data or even the worker among every instance. When this is the case, we can utilize
    two systems, `SharedWorker` and `SharedArrayBuffer`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数时候我们希望保持工作线程和应用程序选项卡之间的边界，但有时我们希望只是共享数据，甚至是工作线程。在这种情况下，我们可以利用两个系统，`SharedWorker`和`SharedArrayBuffer`。
- en: '`SharedWorker` is just what it sounds like, when one spins up, just like `BroadcastChannel`,
    and someone else makes the same call to create a `SharedWorker`, it will just
    connect to the already created instance. Let''s go ahead and do just this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedWorker`就像它的名字一样，当一个启动时，就像`BroadcastChannel`一样，当其他人调用创建`SharedWorker`时，它将连接到已经创建的实例。让我们继续做这件事：'
- en: 'We will create a new file for the `SharedWorker` JavaScript code. Inside of
    here, put some general computing functions such as adding and subtracting:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为`SharedWorker` JavaScript代码创建一个新文件。在这里面，放一些通用的计算函数，比如加法和减法：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Inside of one of our current workers'' code, start up `SharedWorker`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们当前某个工作线程的代码中，启动`SharedWorker`：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will already see a problem. Our system states that `SharedWorker` is not
    found. To utilize `SharedWorker`, we have to start it in a window. So now, we
    will have to move that start code to our main page.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个问题。我们的系统显示找不到`SharedWorker`。要使用`SharedWorker`，我们必须在一个窗口中启动它。所以现在，我们将不得不将启动代码移动到我们的主页面。
- en: 'Move the start code into the main page and then pass the port to one of the
    workers:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将启动代码移动到主页面，然后将端口传递给其中一个工作线程：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We now run into another problem. Since we wanted to pass the port to the worker
    and not have access to it in the main window, we utilized the transferrable system.
    However, since we only had a single reference at that time, once we send it to
    one worker, we can't send it again. Instead, let's start one worker and turn our
    `BroadcastChannel` system off.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在遇到另一个问题。由于我们想要将端口传递给工作线程，并且不希望在主窗口中访问它，所以我们利用了可传递的系统。然而，由于那时我们只有一个引用，一旦我们将它发送给一个工作线程，就无法再次发送。相反，让我们启动一个工作线程，并关闭我们的`BroadcastChannel`系统。
- en: 'Comment out our `BroadcastChannels` and all of our looping code. Let''s only
    start a single worker up in this window:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉我们的`BroadcastChannels`和所有的循环代码。让我们只在这个窗口中启动一个工作线程：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With these changes, we will have to simplify our dedicated worker. We will
    just respond to events on our message channel like before:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这些改变，我们将不得不简化我们的专用工作线程。我们将只是像以前一样响应我们消息通道上的事件：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we have the `SharedWorker` port in a single worker, but what did all of
    this solve for us? Now, we can have multiple tabs open at the same time and get
    the data to every single one of them. To see this, let''s hook a handler up to
    `sharedPort`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们在一个单一的工作线程中有了`SharedWorker`端口，但是这对我们解决了什么问题呢？现在，我们可以同时打开多个选项卡，并将数据发送到每一个选项卡。为了看到这一点，让我们将一个处理程序连接到`sharedPort`：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we can update our `SharedWorker` to respond once a connection happens,
    like the following:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以更新我们的`SharedWorker`，一旦连接发生，就做出响应，如下所示：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With this, we will see a message come back to our workers. We now have our
    `SharedWorker` up and running and communicating directly with our `DedicatedWorker`!
    However, there is still one problem: why did we not see the log from our `SharedWorker`?
    Well, our `SharedWorker` lives in a different context than our `DedicatedWorker`
    and our main thread. To get access to our `SharedWorker`, we can go to the URL
    `chrome://inspect/#workers` and then locate it. Right now, we did not call it
    anything so it should be called `untitled`, but when we click the `inspect` option
    underneath it, we now have a debug context for the worker.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们将看到一个消息回到我们的工作线程。我们现在的`SharedWorker`已经运行起来，并且直接与我们的`DedicatedWorker`进行通信！然而，仍然有一个问题：为什么我们没有看到来自我们的`SharedWorker`的日志？嗯，我们的`SharedWorker`存在于与我们的`DedicatedWorker`和主线程不同的上下文中。要访问我们的`SharedWorker`，我们可以转到URL`chrome://inspect/#workers`，然后定位它。现在，我们没有给它起名字，所以它应该叫做`untitled`，但是当我们点击它下面的`inspect`选项时，我们现在有了一个工作线程的调试上下文。
- en: 'We have connected our `SharedWorker` to the DOM context, and we have connected
    every `DedicatedWorker` to that `SharedWorker`, but we need to be able to send
    messages to each `DedicatedWorker`. Let''s go ahead and add this code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将我们的`SharedWorker`连接到DOM上下文，并且已经将每个`DedicatedWorker`连接到该`SharedWorker`，但是我们需要能够向每个`DedicatedWorker`发送消息。让我们继续添加这段代码：
- en: 'First, we will need to keep track of all of the workers that connected to us
    through the `SharedWorker`. Add the following code to the bottom of our `onconnect`
    listener:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要跟踪所有通过`SharedWorker`连接到我们的工作线程。将以下代码添加到我们`onconnect`监听器的底部：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we will add some HTML to our document so we can send the `add`, `multiply`,
    `divide`, and `subtract` requests along with two new number inputs:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在我们的文档中添加一些HTML，这样我们就可以发送`add`、`multiply`、`divide`和`subtract`请求，以及两个新的数字输入：
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we will pass this information through the `DedicatedWorker` to the `SharedWorker`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过`DedicatedWorker`将这些信息传递给`SharedWorker`：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, our `SharedWorker` will run the corresponding operation and pass it
    back to the `DedicatedWorker`, which will log the data to the console:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们的`SharedWorker`将运行相应的操作，并将其传递回`DedicatedWorker`，后者将数据记录到控制台：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With all of this, we can now have multiple tabs of our application open that
    are all sharing the same preceding math system! This is overkill for this type
    of application, but it could be useful when we need to perform complex operations
    in our application that span multiple windows or tabs. This could be something
    that utilizes the GPU and we only want to do this once. Let's go ahead and wrap
    this section up with an overview of `SharedArrayBuffer`. However, one thing to
    remember is that a `SharedWorker` is a single thread held by all tabs, whereas
    a `DedicatedWorker` is a thread per tab/window. While sharing a worker can be
    beneficial for some tasks explained previously, it can also slow down other tasks
    if multiple tabs are utilizing it at the same time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一切，我们现在可以打开多个应用程序选项卡，它们都共享相同的前置数学系统！对于这种类型的应用程序来说，这有点过度，但是当我们需要在我们的应用程序中执行跨多个窗口或选项卡的复杂操作时，这可能是有用的。这可能是利用GPU的东西，我们只想做一次。让我们通过概述`SharedArrayBuffer`来结束本节。然而，要记住的一件事是，`SharedWorker`是所有选项卡持有的单个线程，而`DedicatedWorker`是每个选项卡/窗口的一个线程。虽然共享一个工作线程对于前面解释的一些任务可能是有益的，但如果多个选项卡同时使用它，也可能会减慢其他任务的速度。
- en: '`SharedArrayBuffer` allows all of our instances to share the same block of
    memory. Just as a transferrable object can have different owners based on passing
    the memory to another worker, a `SharedArrayBuffer` allows different contexts
    to share the same piece. This allows for updates to propagate across all of our
    instances and has almost instant updates for some types of data, but it also has
    many pitfalls associated with it.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedArrayBuffer`允许我们的所有实例共享相同的内存块。就像可传递的对象可以根据将内存传递给另一个工作线程而有不同的所有者一样，`SharedArrayBuffer`允许不同的上下文共享相同的部分。这允许更新在我们的所有实例中传播，并且对于某些类型的数据几乎立即更新，但它也有许多与之相关的缺点。'
- en: This is as close as we will most likely get to `SharedMemory` in other languages.
    To properly utilize `SharedArrayBuffer`, we will need to utilize the Atomics API.
    Again, not diving directly into the detail behind the Atomics API, it makes sure
    that operations happen in the correct sequence and that they are guaranteed to
    update what they need to without anyone overriding them during their update.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在其他语言中最有可能接近“SharedMemory”的方式。要正确使用`SharedArrayBuffer`，我们需要使用Atomics API。再次强调，不直接深入Atomics
    API背后的细节，它确保操作按正确顺序进行，并且保证在更新时能够更新需要更新的内容，而不会被其他人在更新过程中覆盖。
- en: Again, we are starting to get into details where it can be hard to fully understand
    what is happening. One good way to think of the Atomics API is a system where
    many people are sharing a piece of paper. They all take turns writing on it and
    reading what others wrote down.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始进入细节，这些细节可能很难完全理解发生了什么。一个好的理解Atomics API的方式是将其想象成一个许多人共享一张纸的系统。他们轮流在上面写字和阅读其他人写下的内容。
- en: However, one of the downfalls is that they are only allowed to write a single
    character at a time. Because of this, someone else may write something in their
    location while they are still trying to finish writing their word, or someone
    may read their incomplete phrase. We need a mechanism for people to be able to
    write the entire word that they want, or read the entire section, before someone
    starts writing. This is the job of the Atomics API.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，其中一个缺点是他们一次只能写一个字符。因此，当他们仍在尝试完成写入单词时，其他人可能会在他们的位置上写入内容，或者有人可能会读取他们的不完整短语。我们需要一个机制，让人们能够在开始写入之前写入他们想要的整个单词，或者在开始写入之前读取整个部分。这就是Atomics
    API的工作。
- en: '`SharedArrayBuffer` does suffer from issues related to browsers not supporting
    it (currently, only Chrome supports it without a flag), to issues where we might
    want to use the Atomics API (`SharedWorker` cannot send it to the main thread
    or the dedicated workers due to security issues).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedArrayBuffer`确实存在一些问题，与浏览器不支持它有关（目前，只有Chrome支持它而无需标志），以及我们可能希望使用Atomics
    API（由于安全问题，`SharedWorker`无法将其发送到主线程或专用worker）。'
- en: 'To set up a basic example of `SharedArrayBuffer` in action, we will share a
    buffer between the main thread and a worker. When we send a request to the worker,
    we will update the number that is inside that worker by one. Updating this number
    should be visible to the main thread since they are sharing the buffer:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置`SharedArrayBuffer`的基本示例，我们将在主线程和worker之间共享一个缓冲区。当我们向worker发送请求时，我们将更新worker中的数字。更新这个数字应该对主线程可见，因为它们共享缓冲区。
- en: 'Create a simple worker and using the `onmessage` handler check whether it received
    a number or not. If it is, we will increment the data in the `SharedArrayBuffer`.
    Otherwise, the data is the `SharedArrayBuffer` coming from the main thread:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的worker，并使用`onmessage`处理程序检查是否收到了一个数字。如果是，我们将增加`SharedArrayBuffer`中的数据。否则，数据是来自主线程的`SharedArrayBuffer`。
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, on our main thread, we are going to add a new button that says `Increment`.
    When this is clicked, it will send a message to the dedicated worker to increment
    the current number:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的主线程上，我们将添加一个新的按钮，上面写着“增加”。当点击它时，它将向专用worker发送一条消息，以增加当前数字。
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, when the worker updates the buffer on its side, we will constantly be
    checking `SharedArrayBuffer` if there is an update. We will always just put the
    number inside of the number paragraph element that we showed in the previous code
    snippet:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当worker在其端更新缓冲区时，我们将不断检查`SharedArrayBuffer`是否有更新。我们将始终将数字放在前面代码片段中显示的数字段落元素中。
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, to kick all of this off, we will create a `SharedArrayBuffer` on the
    main thread and send it to the worker once we have launched it:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了开始所有这些，我们将在主线程上创建一个`SharedArrayBuffer`，并在启动后将其发送给worker：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: With this, we can see that our value is now incrementing even though we are
    not sending any data from the worker to the main thread! This is the power of
    shared memory. Now, as stated previously, we are quite limited with the Atomics
    API since we cannot use the `wait` and `notify` systems on the main thread and
    we cannot use `SharedArrayBuffer` inside of a `SharedWorker`, but it can be useful
    for systems that are only reading data.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们可以看到我们的值现在正在增加，即使我们没有从worker发送任何数据到主线程！这就是共享内存的力量。现在，正如之前所述，由于我们无法在主线程上使用`wait`和`notify`系统，也无法在`SharedWorker`中使用`SharedArrayBuffer`，因此我们在Atomics
    API方面受到相当大的限制，但它对于只读取数据的系统可能是有用的。
- en: In these cases, we may update the `SharedArrayBuffer` and then send a message
    to the main thread that we updated it, or it may already be a Web API that takes
    `SharedArrayBuffers` such as the WebGL rendering context. While the preceding
    example is not very useful, it does showcase how we might be able to use the shared
    system in the future if the ability to spawn and use `SharedArrayBuffer` in a
    `SharedWorker` is available again. Next, we will focus on building a singular
    cache that all the workers can share.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们可能会更新`SharedArrayBuffer`，然后向主线程发送一条消息，告诉它我们已经更新了它，或者它可能已经是一个接受`SharedArrayBuffers`的Web
    API，比如WebGL渲染上下文。虽然前面的例子并不是很有用，但它展示了如果再次可以在`SharedWorker`中生成和使用`SharedArrayBuffer`的能力，我们可能如何在未来使用共享系统。接下来，我们将专注于构建一个所有worker都可以共享的单一缓存。
- en: Building a simple shared cache
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个简单的共享缓存
- en: With everything that we have learned, we are going to focus on a use case that
    is quite prevalent in reporting systems and most types of operation GUIs—a large
    chunk of data that needs to have other data added to it (some call this decorating
    the data and others call this attribution). An example of this is that we have
    the buy and sell orders for a list of customers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们学到的一切，我们将专注于一个在报告系统和大多数类型的操作GUI中非常普遍的用例——需要添加其他数据的大块数据（有些人称之为装饰数据，其他人称之为属性）。一个例子是我们有一组客户的买入和卖出订单。
- en: 'This data may come back in the following manner:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据可能以以下方式返回：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With this data, we may want to add some context that the customer ID is associated
    with. We could go about this in two ways:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些数据，我们可能想要添加一些与客户ID相关联的上下文。我们可以通过两种方式来做到这一点：
- en: First, we could have a join operation done in the database that adds the required
    information for the user.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们可以在数据库中执行联接操作，为用户添加所需的信息。
- en: Second, and the one we will be illustrating here, is adding this data on the
    frontend when we get the base-level query. This means when our application starts,
    we would fetch all of this attribution data and store it in some background cache.
    Next, when we make a request, we will also make a request to the cache for the
    corresponding data.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们将在此处进行说明的是，在我们获得基本查询时在前端添加这些数据。这意味着当我们的应用程序启动时，我们将获取所有这些归因数据并将其存储在某个后台缓存中。接下来，当我们发出请求时，我们还将向缓存请求相应的数据。
- en: 'For us to achieve the second option, we will implement two of the technologies
    that we learned previously, the `SharedWorker` and the `postMessage` interface:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现第二个选项，我们将实现我们之前学到的两种技术，“SharedWorker”和“postMessage”接口：
- en: 'We create a base-level HTML file that has a template for each row of data.
    We will not go into a deep dive of creating a web component as we did in [Chapter
    3](da1a0a36-4261-43f1-a42b-a9d94284dc9f.xhtml), *Vanilla Land – Looking at the
    Modern Web*, but we will use it to create our table rows on demand:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个基本级别的HTML文件，其中包含每一行数据的模板。我们不会深入创建Web组件，就像我们在[第3章](da1a0a36-4261-43f1-a42b-a9d94284dc9f.xhtml)中所做的那样，但我们将使用它来根据需要创建我们的表行：
- en: '[PRE44]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We set up some pointers to our template and table so we can do quick inserts.
    On top of this, we can create a placeholder for the `SharedWorker` that we are
    about to create:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了一些指向我们模板和表的指针，以便我们可以快速插入。除此之外，我们可以为即将创建的“SharedWorker”创建一个占位符：
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With this basic setup, we can create our `SharedWorker` and give it some base-level
    data. To do this, we are going to use the website [https://www.mockaroo.com/](https://www.mockaroo.com/).
    This will allow us to create a bunch of random data without having to think of
    it ourselves. We can change the data to whatever we want but, in our case, we
    will go with the following options:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个基本设置，我们可以创建我们的“SharedWorker”并为其提供一些基本数据。为此，我们将使用网站[https://www.mockaroo.com/](https://www.mockaroo.com/)。这将允许我们创建大量随机数据，而无需自己考虑。我们可以将数据更改为我们想要的任何内容，但在我们的情况下，我们将选择以下选项：
- en: '`id`: Row number'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：行号'
- en: '`full_name`: Full name'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`full_name`：全名'
- en: '`email`: Email address'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`：电子邮件地址'
- en: '`phone`: Phone'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`phone`：电话'
- en: '`zipcode`: Digit sequence: `######`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zipcode`：数字序列：`######`'
- en: 'With these options filled in, we can change the format to JSON and save by
    clicking Download Data. With this done, we can build out our `SharedWorker`. Similar
    to our other `SharedWorker`, we will take the `onconnect` handler and add an `onmessage`
    handler for the port that comes in:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写了这些选项后，我们可以将格式更改为JSON，并通过单击“下载数据”进行保存。完成后，我们可以构建我们的“SharedWorker”。与我们的其他“SharedWorker”类似，我们将使用“onconnect”处理程序，并为传入的端口添加一个“onmessage”处理程序：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we launch our `SharedWorker` back in our HTML file:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的HTML文件中启动我们的“SharedWorker”：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, when our `SharedWorker` is launched, we will load the file by utilizing
    `importScripts`. This allows us to load in outside JavaScript files, just like
    we would do in HTML, with the `script` tag. To do this, we will need to modify
    the JSON file to point the object to a variable and rename it to a JavaScript
    file:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当我们启动我们的“SharedWorker”时，我们将使用“importScripts”加载文件。这允许我们加载外部JavaScript文件，就像我们在HTML中使用“script”标签一样。为此，我们需要修改JSON文件，将对象指向一个变量并将其重命名为JavaScript文件：
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now that we have brought the cache of data in, we will respond to messages
    sent from the ports. We will expect only arrays of numbers. These will correspond
    to the ID that is associated with a user. For now, we will loop through all of
    the items in our dictionary to see whether we have them. If we do, we will add
    them to an array that we will respond with:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将数据缓存进来，我们将回应从端口发送来的消息。我们只期望数字数组。这些将对应于与用户关联的ID。现在，我们将循环遍历字典中的所有项目，看看我们是否有它们。如果有，我们将将它们添加到一个数组中，然后进行响应：
- en: '[PRE49]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With this, we will need to add the corresponding code inside of our HTML file.
    We will add a button that is going to send 100 random IDs to our `SharedWorker`.
    This will simulate when we make a request and get back the IDs associated with
    the data. The simulation function looks like this:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们需要在我们的HTML文件中添加相应的代码。我们将添加一个按钮，该按钮将向我们的“SharedWorker”发送100个随机ID。这将模拟当我们发出请求并获得与数据关联的ID时的情况。模拟函数如下：
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With the preceding simulation, we can now add in our input for a request and
    then send that to our `SharedWorker`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过上述模拟，我们现在可以添加我们的请求输入，然后将其发送到我们的“SharedWorker”：
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we are currently posting the wrong data to our `SharedWorker`. We only
    want to post the IDs, but how are we going to tie our request to the responses
    from our `SharedWorker`? We will need to slightly modify the structure that we
    have for our `request` and `response` methods. We will now tie an ID to our message
    so we can have the `SharedWorker` post that back to us. This way, we can have
    a map on the frontend of requests and the IDs associated with them. Make the following
    changes:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们目前正在向我们的“SharedWorker”发布错误的数据。我们只想发布ID，但是我们如何将我们的请求与我们的“SharedWorker”的响应联系起来呢？我们需要稍微修改我们的“request”和“response”方法的结构。我们现在将ID绑定到我们的消息，这样我们就可以让“SharedWorker”将其发送回给我们。这样，我们就可以在前端拥有请求和与之关联的ID的映射。进行以下更改：
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'With these changes, we still need to make sure we only pass the IDs to the
    `SharedWorker`. We can pull these off from the request before we send it:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这些更改，我们仍然需要确保我们只将ID传递给“SharedWorker”。在发送请求之前，我们可以从请求中取出这些ID：
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now we need to handle the data coming back to us inside of our HTML file. First,
    we attach an `onmessage` handler to the port:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要处理返回到我们的HTML文件中的数据。首先，我们将一个“onmessage”处理程序附加到端口上：
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, we grab the associated buy/sell order from our map and populate it
    with the returned cache data. Once we have done this, we just have to clone our
    row template and fill in the corresponding fields:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们从地图中获取相关的买卖订单，并用返回的缓存数据填充它。完成这些后，我们只需克隆我们的行模板并填写相应的字段：
- en: '[PRE55]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: With the preceding example, we have created a shared cache that any page that
    has the same domain can use. While there are certain optimizations (we could store
    the data as a map and have the ID as the key), we are still going to run a bit
    faster than having to potentially wait on a database connection (especially when
    we are in places that have limited bandwidth).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上面的例子，我们创建了一个任何具有相同域的页面都可以使用的共享缓存。虽然有一些优化（我们可以将数据存储为地图，并将ID作为键），但我们仍然会比潜在地等待数据库连接要快一些（特别是当我们在带宽有限的地方时）。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This entire chapter has been focused on offloading tasks from the main thread
    to other threads of work. We have looked at dedicated workers that only a single
    page has. We have then taken a look at how we can broadcast messages between multiple
    workers without having to loop through the respective ports.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 整个章节都集中在将任务从主线程转移到其他工作线程上。我们看了只有单个页面才有的专用工作线程。然后我们看了如何在多个工作线程之间广播消息，而不必循环遍历各自的端口。
- en: Then we saw how we can share a worker on the same domain utilizing `SharedWorker`
    and also looked at how we can share a data source utilizing `SharedArrayBuffer`.
    Finally, we took a practical look at creating a shared cache that anyone has access
    to.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们看到了如何在同一域上利用`SharedWorker`共享工作线程，还看了如何利用`SharedArrayBuffer`共享数据源。最后，我们实际看了一下如何创建一个任何人都可以访问的共享缓存。
- en: In the next chapter, we will take this concept of caching and handling requests
    one step further by utilizing `ServiceWorker`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过利用`ServiceWorker`将缓存和处理请求的概念推进一步。
