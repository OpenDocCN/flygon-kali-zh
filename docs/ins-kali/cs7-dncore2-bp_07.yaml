- en: A Serverless Email Validation Azure Function
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个无服务器的电子邮件验证Azure函数
- en: This chapter will take us into the realm of serverless computing. Just what
    is serverless computing, I hear you ask? Well, the answer is really simple once
    you grasp the idea that the term *serverless computing* has nothing to do with
    the lack of a server. It is quite the opposite, in fact.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带我们进入无服务器计算的领域。我听到你问无服务器计算到底是什么？事实上，一旦你理解了“无服务器计算”这个术语与缺乏服务器无关的概念，答案就非常简单了。事实上恰恰相反。
- en: 'In this chapter, we will have a look at:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一下：
- en: Creating an Azure Function
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Azure函数
- en: Testing your Azure Function in the browser
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中测试您的Azure函数
- en: Calling an Azure Function from an ASP.NET Core MVC application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从ASP.NET Core MVC应用程序调用Azure函数
- en: We will be creating a simple Azure Function that uses regular expressions to
    validate an email address. You need to keep in mind that Azure Functions are small
    pieces of code in the cloud. Do not think of them as large sections of complicated
    code. The smaller the better.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的Azure函数，使用正则表达式来验证电子邮件地址。您需要记住Azure函数是云中的小代码片段。不要把它们看作复杂代码的大部分。越小越好。
- en: Beginning with serverless computing
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从无服务器计算开始
- en: Traditionally, companies spend time and money managing a server's computing
    resources. These represent a fixed and recurring cost to the company. It doesn't
    matter if the server is idle or if it is performing some form of computing task.
    The bottom line is that it costs money just by being there.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，公司花费时间和金钱来管理服务器的计算资源。这些代表了公司的固定和重复成本。无论服务器是空闲还是正在执行某种计算任务，都会产生费用。底线是，它只是因为存在而花费了金钱。
- en: With serverless computing, the computing resources are scalable cloud services.
    This means that it is an event-driven application design. Basically, with serverless
    computing, you only pay for what you use. This is true of Azure Functions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无服务器计算，计算资源是可扩展的云服务。这意味着它是一个事件驱动的应用程序设计。基本上，使用无服务器计算，您只支付您使用的部分。这对Azure函数也是如此。
- en: '**Azure Functions** are small bits of code that reside in the cloud. Your applications
    can simply just use these functions as needed, and you only pay for the computing
    power used. It does not matter if one or one million people access your application.
    Azure Functions will automatically scale to handle the additional load. When the
    usage of your application drops, the Azure Function scales back down.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Azure函数**是驻留在云中的小代码片段。您的应用程序可以根据需要简单地使用这些函数，您只需支付所使用的计算能力。无论是一个人还是一百万人访问您的应用程序都无所谓。Azure函数将自动扩展以处理额外的负载。当您的应用程序的使用量下降时，Azure函数会自动缩小规模。'
- en: Importance of serverless computing
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器计算的重要性
- en: Imagine that you saw frequent (but not constant) spikes in your application
    usage. Because the server that handles the requests from your application is not
    serverless, it needs to be upgraded (as a cost to you or your company) to be able
    to handle the additional load. In times of low usage, the server does not have
    less resources. You upgraded it to be able to handle a specific load of users.
    It will always be running at this level of performance, and as you know, performance
    comes at a cost.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您的应用程序使用频繁（但不是持续）出现峰值。因为处理来自您的应用程序的请求的服务器不是无服务器的，它需要升级（作为您或您的公司的成本）以处理额外的负载。在低使用率时，服务器并没有更少的资源。您升级它以处理特定的用户负载。它将始终以这个性能水平运行，正如您所知，性能是有代价的。
- en: With serverless computing, the resources are automatically scaled up and down
    as demand increases and decreases. This is a much more efficient way of using
    a server, because you are not paying for underutilized computing power.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无服务器计算，资源会随着需求的增加和减少而自动扩展和缩小。这是一种更有效的使用服务器的方式，因为您不必为未充分利用的计算能力付费。
- en: Features of Azure Functions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure函数的特性
- en: Azure Functions offer developers a rich set of features. Refer to the Microsoft
    documentation to read up more on Azure Functions—[https://docs.microsoft.com/en-us/azure/azure-functions/](https://docs.microsoft.com/en-us/azure/azure-functions/).
    For now, we will have a look at a few of those features.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Azure函数为开发人员提供了丰富的功能。请参考微软文档，了解更多关于Azure函数的信息-[https://docs.microsoft.com/en-us/azure/azure-functions/](https://docs.microsoft.com/en-us/azure/azure-functions/)。现在，我们将看一下其中的一些功能。
- en: Choice of languages
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言选择
- en: 'The great thing about Azure Functions is that you can create them in a language
    of your choice. For a list of supported languages, browse to the following URL:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Azure函数的好处是您可以使用自己选择的语言创建它们。有关支持的语言列表，请浏览以下网址：
- en: '[https://docs.microsoft.com/en-us/azure/azure-functions/supported-languages](https://docs.microsoft.com/en-us/azure/azure-functions/supported-languages).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/azure-functions/supported-languages](https://docs.microsoft.com/en-us/azure/azure-functions/supported-languages)。'
- en: For this chapter, we will be using C# to write the Azure Function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用C#编写Azure函数。
- en: Pay-per-use pricing
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按使用付费
- en: 'As mentioned earlier, you will only pay for the actual time spent that your
    Azure Function runs. The consumption plan is billed per second. Microsoft have
    a great document on Azure Functions pricing at the following URL:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您只需支付Azure函数运行的实际时间。按秒计费的消耗计划。微软在以下网址上有一份关于Azure函数定价的文档：
- en: '[https://azure.microsoft.com/en-us/pricing/details/functions/](https://azure.microsoft.com/en-us/pricing/details/functions/).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://azure.microsoft.com/en-us/pricing/details/functions/](https://azure.microsoft.com/en-us/pricing/details/functions/)。'
- en: Flexible development
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灵活的开发
- en: You can create your Azure Functions directly in the Azure portal. You can also
    set up continuous integration with Visual Studio Team Services and GitHub.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接在Azure门户中创建Azure函数。您还可以使用Visual Studio Team Services和GitHub设置持续集成。
- en: What types of Azure Functions can I create?
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我可以创建什么类型的Azure函数？
- en: 'You can use Azure Functions as a solution to integrate with your application,
    processing data, working with IoT, APIs, and microservices. Azure Functions also
    work well on a trigger, so you can even schedule tasks. These are some of the
    Azure Function templates available to you:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Azure函数作为集成解决方案，处理数据，与物联网，API和微服务一起工作。Azure函数还可以很好地触发，因此您甚至可以安排任务。这些是提供给您的一些Azure函数模板：
- en: '`HTTPTrigger`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTPTrigger`'
- en: '`TimerTrigger`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimerTrigger`'
- en: '`GitHub webhook`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GitHub webhook`'
- en: '`Generic webhook`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Generic webhook`'
- en: '`BlobTrigger`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlobTrigger`'
- en: '`CosmosDBTrigger`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CosmosDBTrigger`'
- en: '`QueueTrigger`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QueueTrigger`'
- en: '`EventHubTrigger`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventHubTrigger`'
- en: '`ServiceBusQueueTrigger`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServiceBusQueueTrigger`'
- en: '`ServiceBusTopicTrigger`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServiceBusTopicTrigger`'
- en: 'To read up more on these templates and Azure Functions in general, go through
    the Microsoft document, *An introduction to Azure Functions*, at the following
    URL:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关这些模板和Azure函数的更多信息，请阅读微软文档*Azure函数简介*，网址如下：
- en: '[https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview](https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview](https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview)。'
- en: Creating an Azure Function
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Azure函数
- en: 'Without further delay, let''s create our own Azure Function. The function we
    are going to create is going to validate an email address using regular expressions.
    This is a very standard development task to code. It is also a function that will
    be widely used across many applications:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们毫不拖延地创建我们自己的Azure函数。我们要创建的函数将使用正则表达式验证电子邮件地址。这是一个非常标准的开发任务。它也是一个将在许多应用程序中广泛使用的功能：
- en: You will need to have an Azure account. If you do not have one, you can set
    up a free trial account at—[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要拥有Azure帐户。如果没有，您可以在[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)上设置免费试用帐户。
- en: Point your browser at—[https://portal.azure.com](https://portal.azure.com) and
    log on to your Azure portal.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将浏览器指向[https://portal.azure.com](https://portal.azure.com)并登录到您的Azure门户。
- en: 'Once logged in, look for the Create a resource link. Click on the link and
    then look for the Compute link under the Azure Marketplace section. Refer to the
    following screenshot:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，寻找“创建资源”链接。单击该链接，然后在Azure Marketplace部分下查找“计算”链接。请参考以下屏幕截图：
- en: '![](img/5cd2ce05-5cd4-4a7d-aa69-6a21f641e064.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cd2ce05-5cd4-4a7d-aa69-6a21f641e064.png)'
- en: 'A little way down under the Featured section, you will see Function App as
    an option. Click on that link:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“特色”部分下方，您将看到“函数应用”作为一个选项。单击该链接：
- en: '![](img/731176f3-ffb0-466b-ac39-26699a5ad811.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/731176f3-ffb0-466b-ac39-26699a5ad811.png)'
- en: 'You will now be presented with the Function App settings screen. The following
    options need to be entered:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您将看到“函数应用设置”屏幕。需要输入以下选项：
- en: 'App name: This is the globally unique name of your Azure Function.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用名称：这是您的Azure函数的全局唯一名称。
- en: 'Subscription: This is the subscription under which your function will be created.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅：这是您的函数将在其中创建的订阅。
- en: 'Resource group: Create a new resource group for your function.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源组：为您的函数创建一个新的资源组。
- en: 'OS: You have a choice of Windows or Linux. I chose Windows.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统：您可以选择Windows或Linux。我选择了Windows。
- en: 'Hosting plan: This will define how resources are allocated to your function.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管计划：这将定义资源如何分配给您的函数。
- en: 'Location: It is a good idea to choose a location geographically closest to
    you.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置：最好选择地理位置最接近您的位置。
- en: 'Storage: Keep this as default.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储：保持默认设置。
- en: You also have the option to switch Application Insights to On or Off. You can
    also select the Pin to dashboard option.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以选择将应用程序洞察切换到打开或关闭状态。您还可以选择“固定到仪表板”选项。
- en: We have called our Azure Function core-mail-validation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称之为Azure函数核心邮件验证。
- en: Once you have added all the required settings, click on the Create button.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所有必需的设置后，单击“创建”按钮。
- en: '![](img/31b46271-09a2-4101-a3fb-6805ce937eba.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31b46271-09a2-4101-a3fb-6805ce937eba.png)'
- en: After you click on the Create button, you will see a Validating... message.
    This could take several seconds:![](img/1fd053a8-3d11-4da8-91d9-322c9c6f613e.png)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“创建”按钮后，您将看到一个“正在验证...”的消息。这可能需要几秒钟时间！[](img/1fd053a8-3d11-4da8-91d9-322c9c6f613e.png)
- en: Keep your eye on the notifications section (the little bell icon) in the top
    right hand corner of the Azure portal. New notifications are displayed there and
    are indicated by a number representing the number of unread notifications:![](img/7e1a442c-69fc-47d7-a800-af7f81c07dfd.png)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意Azure门户右上角的通知部分（小铃铛图标）。新通知将显示在那里，并以数字表示未读通知的数量！[](img/7e1a442c-69fc-47d7-a800-af7f81c07dfd.png)
- en: If you click on the notifications, you will see that Azure is in the progress
    of deploying the Azure Function you created:![](img/5e90e6a5-74d6-4f1c-9b4e-586758a3c53a.png)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果单击通知，您将看到Azure正在部署您创建的Azure函数的进度！[](img/5e90e6a5-74d6-4f1c-9b4e-586758a3c53a.png)
- en: When your Azure Function is deployed, you will see a Deployment succeeded message
    appear in the Notifications section. From there, you can click on the Pin to dashboard to Go
    to resource buttons.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当部署您的Azure函数时，您将在“通知”部分看到“部署成功”消息。从那里，您可以单击“固定到仪表板”或“转到资源”按钮。
- en: Pinning your function to the dashboard just makes it easier for you to access
    it again later on. It's a good idea to pin frequently used services to your dashboard.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的函数固定到仪表板只是为了以后更容易访问它。将经常使用的服务固定到仪表板是一个好主意。
- en: 'To access your Azure Function, click on the Go to resource button:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问您的Azure函数，请单击“转到资源”按钮：
- en: '![](img/d5e0d3c8-8b12-496d-b7e9-89505ec5449a.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5e0d3c8-8b12-496d-b7e9-89505ec5449a.png)'
- en: 'You will then be taken to the Function Apps section of your Azure portal. You
    will see the core-mail-validation function listed under the Function Apps section:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您将进入Azure门户的“函数应用”部分。您将在“函数应用”部分下看到“核心邮件验证”函数：
- en: '![](img/17187b97-ab49-437b-9b62-15f25a4ac3c3.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17187b97-ab49-437b-9b62-15f25a4ac3c3.png)'
- en: 'Under the core-email-validation, click on the Functions option. Then, click
    on the New function option in the panel on the right:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“core-email-validation”下，单击“函数”选项。然后，在右侧面板中单击“新建函数”选项。
- en: '![](img/a84a8210-4e1b-4dca-bfcd-629181f2ff9d.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a84a8210-4e1b-4dca-bfcd-629181f2ff9d.png)'
- en: 'You are now presented with a series of templates that can get you started.
    Scroll down to see all the templates available (there are more than just the four
    shown in the following screenshot):'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您将看到一系列可以帮助您入门的模板。向下滚动以查看所有可用的模板（不仅仅是以下截图中显示的四个）：
- en: '![](img/ed48aacc-bc68-4219-b965-b0b861c9acd8.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed48aacc-bc68-4219-b965-b0b861c9acd8.png)'
- en: 'We are not going to go through all the templates available. We are going to
    keep things simple and just select the go to the quickstart option, as shown in
    the following screenshot:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不会浏览所有可用的模板。我们将保持简单，只选择“转到快速入门”选项，如下截图所示：
- en: '![](img/f3f0d31e-69ea-4060-a551-c4e199120464.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3f0d31e-69ea-4060-a551-c4e199120464.png)'
- en: For our purposes, we will simply select Webhook + API and choose C# as our language.
    There are other languages available to choose from, so select the language you
    are most comfortable with.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们将简单地选择“Webhook + API”，并选择“C#”作为我们的语言。还有其他可供选择的语言，因此请选择您最熟悉的语言。
- en: 'To create the function, click on the Create this function button:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建该函数，请单击“创建此函数”按钮：
- en: '![](img/5cee9e17-9d25-4e14-854e-4312609e06f2.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cee9e17-9d25-4e14-854e-4312609e06f2.png)'
- en: 'The Azure Function is created and some boilerplate code is automatically added
    for you so that you can get a feel for how the code needs to look inside the function.
    All  this code does is it looks for a variable called `name` in the query string
    and displays that in the browser, if found:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已创建Azure函数，并为您自动添加了一些样板代码，以便您了解函数内部代码的外观。所有这些代码所做的就是在查询字符串中查找名为`name`的变量，并在找到时在浏览器中显示它：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Have a look at the top-right corner of the screen. You will see a </> Get function
    URL link. Click on the following link:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看屏幕右上角。您将看到一个“</>获取函数URL”链接。单击以下链接：
- en: '![](img/fb682bf7-6e37-405c-95f6-d44084e10faf.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb682bf7-6e37-405c-95f6-d44084e10faf.png)'
- en: 'This will display a pop-up screen with the URL to access the Azure Function
    you just created. Click on the Copy button to copy the URL to your clipboard:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将显示一个弹出屏幕，其中包含访问您刚创建的Azure函数的URL。单击“复制”按钮将URL复制到剪贴板：
- en: '![](img/dd77a3b9-9a19-4a39-9004-ce7f22906713.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd77a3b9-9a19-4a39-9004-ce7f22906713.png)'
- en: 'The URL that you copy will look something as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您复制的URL将如下所示：
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To run our function, we need to add a `name` parameter in the query string
    of the URL. Go ahead and add `&name==[YOUR_NAME]` where `[YOUR_NAME]` is your
    own name into the URL. In my case, I added `&name=Dirk` to the end of my URL:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行我们的函数，我们需要在URL的查询字符串中添加一个`name`参数。继续在URL中添加`&name==[YOUR_NAME]`，其中`[YOUR_NAME]`是您自己的名字。在我的情况下，我在URL的末尾添加了`&name=Dirk`：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Paste this URL into the browser address bar and hit the return button. A message
    saying (in my case) "Hello Dirk" is displayed in the browser:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此URL粘贴到浏览器地址栏中，然后点击返回按钮。浏览器中将显示一条消息（在我的情况下）“Hello Dirk”：
- en: '![](img/db969b84-aeed-4fe2-8a1d-64b576f77d53.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db969b84-aeed-4fe2-8a1d-64b576f77d53.png)'
- en: Note that in Chrome and Firefox, you might see the message This XML file does
    not appear to have any style information associated with it. To see the output,
    use Microsoft Edge.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在Chrome和Firefox中，您可能会看到消息“此XML文件似乎没有与其关联的任何样式信息”。要查看输出，请使用Microsoft Edge。
- en: 'Back in the Azure portal, you will see the Logs window at the bottom of the
    Azure Function screen. If it isn''t displayed, click on the Λ arrow to expand
    the panel. Here, you will see that the Azure Trigger was run successfully:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到Azure门户，在Azure函数屏幕的底部，您将看到“日志”窗口。如果没有显示，请单击“Λ”箭头展开面板。在这里，您将看到Azure触发器已成功运行：
- en: '![](img/3ebdcb87-5b5a-4b4f-a6eb-d43967c36eeb.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ebdcb87-5b5a-4b4f-a6eb-d43967c36eeb.png)'
- en: Congratulations, you have just run your new Azure Function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您刚刚运行了新的Azure函数。
- en: Modifying the Azure Function code
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改Azure函数代码
- en: 'While this is all quite exciting (it should be, this is really cool tech),
    we need to make a few changes to the Azure Function to meet our requirements:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这一切都很令人兴奋（应该是的，这真是很酷的技术），但我们需要对Azure函数进行一些更改以满足我们的要求：
- en: 'Identify the `return` statement in your Azure Function. It will look as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Azure函数中找到`return`语句。它将如下所示：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s simplify the code a bit and just return `true` if the email address
    is not empty. Replace the `return` statement with the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简化一下代码，如果电子邮件地址不为空，只需返回`true`。将`return`语句替换为以下代码：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The code in your Azure Function should now look as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的Azure函数中的代码现在应该如下所示：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Be sure to click on the Save button to save the changes to your Azure Function.
    You will then see that the function is compiled and a Compilation succeeded message
    is displayed in the Logs window:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保单击“保存”按钮以保存对Azure函数的更改。然后，您将看到函数已编译，并在“日志”窗口中显示“编译成功”消息：
- en: '![](img/65abe5ba-1d6e-4653-ae83-8165173dbf1b.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65abe5ba-1d6e-4653-ae83-8165173dbf1b.png)'
- en: 'As previous, copy the URL by clicking on the </> Get function URL link:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与以前一样，通过单击</>获取函数URL链接来复制URL：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This time though, we want to pass it as an email address. You can see that
    the parameter name has changed to `email` and the value can be any email address
    you choose to enter. I therefore appended `&email=dirk@email.com` to the end of
    the URL:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这次我们要将其作为电子邮件地址传递。您可以看到参数名称已更改为`email`，并且值可以是您选择输入的任何电子邮件地址。因此，我在URL的末尾添加了`&email=dirk@email.com`：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Paste the URL into your browser and hit the return button to see the result
    displayed in the browser:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将URL粘贴到浏览器中，然后点击返回按钮，以在浏览器中查看结果显示：
- en: '![](img/cad93eb1-ffef-46c7-86ae-39823faf11ff.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cad93eb1-ffef-46c7-86ae-39823faf11ff.png)'
- en: 'We are now confident that the Azure Function is performing a rudimentary validation
    of our email address (even if it is just checking to see if it exists). However,
    we need the function to do so much more. To validate the email address, we will
    be using regular expressions. To do this, add the following namespace to the Azure
    Function:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在有信心Azure Function正在对我们的电子邮件地址进行基本验证（即使只是检查它是否存在）。然而，我们需要函数做更多的事情。为了验证电子邮件地址，我们将使用正则表达式。为此，将以下命名空间添加到Azure
    Function中：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the section of code that does the validation, enter the code to match the
    email to the regex pattern.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行验证的代码部分，输入代码来匹配电子邮件与正则表达式模式。
- en: There are a million different regular expression patterns on the internet. Regular
    expressions are a whole different topic altogether and beyond the scope of this
    book. If matching a pattern of text is required by your application, Google to
    see if there isn't a regex pattern available for it. If you are really brave,
    you can write your own.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有成千上万种不同的正则表达式模式。正则表达式是一个完全不同的话题，超出了本书的范围。如果您的应用程序需要匹配文本模式，可以搜索一下，看看是否有可用的正则表达式模式。如果你真的很勇敢，你可以自己写。
- en: 'Regular expressions have been baked into the .NET Framework, and the code is
    quite straightforward:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正则表达式已经内置到.NET Framework中，代码非常简单：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After you have added all the code, your Azure Function will look as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加了所有代码之后，您的Azure Function将如下所示：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use the same URL you copied earlier and paste it into the browser window and
    hit the *Return* or *Enter* key:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前复制的相同URL粘贴到浏览器窗口中，然后点击*返回*或*输入*键：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The email address `dirk@email.com` is validated and the message "Email status:
    True" is displayed in the browser. What has happened here is that the email address
    was passed to the Azure Function. The function then read the value of the `email`
    parameter from the query string and passed that to the regular expression.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电子邮件地址`dirk@email.com`已经验证，并且在浏览器中显示了消息“电子邮件状态：True”。这里发生的是电子邮件地址被传递给Azure Function。然后函数从查询字符串中读取`email`参数的值，并将其传递给正则表达式。
- en: 'The email address is matched against the regular expression pattern, and if
    a match is found, then the email address is considered a valid email:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件地址与正则表达式模式匹配，如果找到匹配，则认为电子邮件地址是有效的：
- en: '![](img/cb0be1a7-8065-4be3-8882-bdbff4461acf.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb0be1a7-8065-4be3-8882-bdbff4461acf.png)'
- en: 'Let''s enter the same URL into the browser, only this time enter an email address
    you know will be invalid. For example, an email address can only contain a single
    `@` sign. The parameter I then added to the URL is as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将相同的URL输入到浏览器中，只是这次输入一个你知道将是无效的电子邮件地址。例如，电子邮件地址只能包含一个`@`符号。然后我添加到URL的参数如下：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can then see that when we hit the *Return* or *Enter* key, the invalid
    email address `dirk@@email.com` is validated and found not to match the regular
    expression. The text "Email status: False" is therefore displayed in the browser:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可以看到，当我们点击*返回*或*输入*键时，无效的电子邮件地址`dirk@@email.com`被验证，并且不匹配正则表达式。因此在浏览器中显示文本“电子邮件状态：False”：
- en: '![](img/efb296c4-25e9-4bdb-984f-b0bc11690251.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/efb296c4-25e9-4bdb-984f-b0bc11690251.png)'
- en: This is fantastic! We have seen that the Azure Function we created uses the
    regular expression we added to validate the email address it receives. Based on
    the result of the regex validation, the function returns either true or false.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经看到我们创建的Azure Function使用了我们添加的正则表达式来验证它接收到的电子邮件地址。根据正则表达式验证的结果，函数返回true或false。
- en: 'Lastly, before we carry on, we want the Azure Function to return a single `True`
    or `False` value to the calling application. Modify the `return` statement of
    your function to do just that:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在继续之前，我们希望Azure Function返回一个单一的“True”或“False”值给调用应用程序。修改函数的`return`语句来实现这一点：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have seen how this function works, by modifying the code step-by-step and
    running it directly from the browser window. However, this does not do us any
    good unless we can call this Azure Function from an application.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了这个函数是如何工作的，通过逐步修改代码并直接从浏览器窗口运行。然而，除非我们可以从应用程序调用这个Azure Function，否则这对我们没有任何好处。
- en: Let's have a look at how to create an ASP.NET Core MVC application that calls
    our Azure Function to validate an email address entered on a login screen.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个ASP.NET Core MVC应用程序，调用我们的Azure Function来验证在登录屏幕上输入的电子邮件地址。
- en: Calling an Azure Function from an ASP.NET Core MVC application
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从ASP.NET Core MVC应用程序调用Azure Function
- en: 'In the previous section, we had a look at how our Azure Function worked. Now,
    we want to create an ASP.NET Core MVC application that will call our Azure Function
    to validate an email address entered into a login screen of the application:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看了一下我们的Azure Function是如何工作的。现在，我们想创建一个ASP.NET Core MVC应用程序，将调用我们的Azure
    Function来验证应用程序登录屏幕中输入的电子邮件地址：
- en: This application does no authentication at all. All it is doing is validating
    the email address entered. ASP.NET Core MVC authentication is a totally different
    topic and not the focus of this chapter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序根本不进行任何身份验证。它所做的只是验证输入的电子邮件地址。ASP.NET Core MVC身份验证是一个完全不同的话题，不是本章的重点。
- en: 'In Visual Studio 2017, create a new project and select ASP.NET Core Web Application
    from the project templates. Click on the OK button to create the project. This
    is shown in the following screenshot:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2017中，创建一个新项目，并从项目模板中选择ASP.NET Core Web应用程序。单击“确定”按钮创建项目。如下截图所示：
- en: '![](img/e2a98857-ae4f-42f6-8514-b2f3ac97b1ce.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2a98857-ae4f-42f6-8514-b2f3ac97b1ce.png)'
- en: On the next screen, ensure that .NET Core and ASP.NET Core 2.0 is selected from
    the drop-down options on the form. Select Web Application (Model-View-Controller)
    as the type of application to create.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，确保从表单的下拉选项中选择.NET Core和ASP.NET Core 2.0。选择Web应用程序（模型-视图-控制器）作为要创建的应用程序类型。
- en: 'Don''t bother with any kind of authentication or enabling Docker support. Just
    click on the OK button to create your project:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 不要费心进行任何身份验证或启用Docker支持。只需单击“确定”按钮创建项目：
- en: '![](img/22c47a80-9256-4d49-a5bd-77031ad83531.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22c47a80-9256-4d49-a5bd-77031ad83531.png)'
- en: 'After your project is created, you will see the familiar project structure
    in the Solution Explorer of Visual Studio:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建项目后，您将在Visual Studio的解决方案资源管理器中看到熟悉的项目结构：
- en: '![](img/99c956fc-b4b7-4133-b05f-4193e4922ce3.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99c956fc-b4b7-4133-b05f-4193e4922ce3.png)'
- en: Creating the login form
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建登录表单
- en: 'For this next part, we can create a plain and simple vanilla login form. For
    a little bit of fun, let''s spice things up a bit. Have a look on the internet
    for some free login form templates:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们可以创建一个简单的普通登录表单。为了有点乐趣，让我们稍微调整一下。在互联网上寻找一些免费的登录表单模板：
- en: 'I decided to use a site called **colorlib** that provided 50 free HTML5 and
    CSS3 login forms in one of their recent blog posts. The URL to the article is:
    [https://colorlib.com/wp/html5-and-css3-login-forms/](https://colorlib.com/wp/html5-and-css3-login-forms/).'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我决定使用一个名为**colorlib**的网站，该网站在最近的博客文章中提供了50个免费的HTML5和CSS3登录表单。文章的网址是：[https://colorlib.com/wp/html5-and-css3-login-forms/](https://colorlib.com/wp/html5-and-css3-login-forms/)。
- en: 'I decided to use **Login Form 1 by Colorlib** from their site. Download the
    template to your computer and extract the ZIP file. Inside the extracted ZIP file,
    you will see that we have several folders. Copy all the folders in this extracted
    ZIP file (leave the `index.html` file as we will use this in a minute):'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我决定使用**Colorlib**网站上的**Login Form 1**。将模板下载到您的计算机并解压缩ZIP文件。在解压缩的ZIP文件中，您将看到我们有几个文件夹。将此解压缩的ZIP文件中的所有文件夹复制（保留`index.html`文件，因为我们将在一分钟内使用它）：
- en: '![](img/930634ba-19aa-40c0-9d18-ac53cbd80b55.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/930634ba-19aa-40c0-9d18-ac53cbd80b55.png)'
- en: 'Next, go to the solution for your Visual Studio application. In the `wwwroot`
    folder, move or delete the contents and paste the folders from the extracted ZIP
    file into the `wwwroot` folder of your ASP.NET Core MVC application. Your `wwwroot`
    folder should now look as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到Visual Studio应用程序的解决方案。在`wwwroot`文件夹中，移动或删除内容，并将从解压缩的ZIP文件中的文件夹粘贴到ASP.NET
    Core MVC应用程序的`wwwroot`文件夹中。您的`wwwroot`文件夹现在应如下所示：
- en: '![](img/a7da7042-7001-4296-9b7f-40ea9a4c06d6.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7da7042-7001-4296-9b7f-40ea9a4c06d6.png)'
- en: Back in Visual Studio, you will see the folders when you expand the wwwroot
    node in the CoreMailValidation project.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到Visual Studio，展开CoreMailValidation项目中的wwwroot节点时，您将看到文件夹。
- en: 'I also want to focus your attention to the `Index.cshtml` and `_Layout.cshtml`
    files. We will be modifying these files next:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我还想让您注意`Index.cshtml`和`_Layout.cshtml`文件。我们将修改这些文件：
- en: '![](img/65f2d69e-e6da-4e23-9e45-12cc7aa2868b.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65f2d69e-e6da-4e23-9e45-12cc7aa2868b.png)'
- en: Open the `Index.cshtml` file and remove all the markup (except the section in
    the curly brackets) from this file. Paste the HTML markup from the `index.html`
    file from the ZIP file we extracted earlier.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Index.cshtml`文件，并从该文件中删除所有标记（大括号中的部分除外）。将之前从ZIP文件中提取的`index.html`文件中的HTML标记粘贴到该文件中。
- en: Do not copy the all the markup from the `index.html` file. Only copy the markup
    inside the `<body></body>` tags.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 不要复制`index.html`文件中的所有标记。只复制`<body></body>`标记内的标记。
- en: 'Your `Index.cshtml` file should now look as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的`Index.cshtml`文件现在应如下所示：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The code for this chapter is available on GitHub at the following link:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在GitHub上的以下链接找到：
- en: '[https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/Serverless](https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/Serverless).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/Serverless](https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/Serverless)。'
- en: 'Next, open the `Layout.cshtml` file and add all the links to the folders and
    files we copied into the `wwwroot` folder earlier. Use the `index.html` file for
    reference. You will notice that the `_Layout.cshtml` file contains the following
    piece of code—`@RenderBody()`. This is a placeholder that specifies where the
    `Index.cshtml` file content should be injected. If you are coming from ASP.NET
    Web Forms, think of the `_Layout.cshtml` page as a master page. Your `Layout.cshtml`
    markup should look as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`Layout.cshtml`文件，并将我们之前复制到`wwwroot`文件夹中的所有链接添加到文件中。使用`index.html`文件作为参考。您将注意到`_Layout.cshtml`文件包含以下代码片段—`@RenderBody()`。这是一个占位符，指定了`Index.cshtml`文件内容应该注入的位置。如果您来自ASP.NET
    Web Forms，请将`_Layout.cshtml`页面视为主页面。您的`Layout.cshtml`标记应如下所示：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If everything worked out right, you will see the following page when you run
    your ASP.NET Core MVC application. The login form is obviously totally non-functional:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，当您运行ASP.NET Core MVC应用程序时，您将看到以下页面。登录表单显然是完全无效的：
- en: '![](img/3ce9788c-496a-42f5-89a9-4ba813bb7053.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ce9788c-496a-42f5-89a9-4ba813bb7053.png)'
- en: 'However, the login form is totally responsive. If you had to reduce the size
    of your browser window, you will see the form scale as your browser size reduces.
    This is what you want. If you want to explore the responsive design offered by
    Bootstrap, head on over to [https://getbootstrap.com/](https://getbootstrap.com/)
    and go through the examples in the documentation:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，登录表单是完全响应的。如果您需要缩小浏览器窗口的大小，您会看到表单随着浏览器大小的减小而缩放。这就是您想要的。如果您想探索Bootstrap提供的响应式设计，请访问[https://getbootstrap.com/](https://getbootstrap.com/)并查看文档中的示例：
- en: '![](img/2c66e960-5633-4e52-b698-14eed1d81cc5.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c66e960-5633-4e52-b698-14eed1d81cc5.png)'
- en: The next thing we want to do is hook this login form up to our controller and
    call the Azure Function we created to validate the email address we entered.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的事情是将此登录表单连接到我们的控制器，并调用我们创建的Azure函数来验证我们输入的电子邮件地址。
- en: Let's look at doing that next.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看下一步该怎么做。
- en: Hooking it all up
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接所有内容
- en: 'To simplify things, we will be creating a model to pass to our controller:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化事情，我们将创建一个模型传递给我们的控制器：
- en: 'Create a new class in the `Models` folder of your application called `LoginModel`
    and click on the Add button:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的`Models`文件夹中创建一个名为`LoginModel`的新类，并单击“添加”按钮：
- en: '![](img/73408275-7afa-4639-979e-4007aa418f89.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73408275-7afa-4639-979e-4007aa418f89.png)'
- en: 'Your project should now look as follows. You will see the `model` added to
    the `Models` folder:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的项目现在应该如下所示。您将看到`model`添加到`Models`文件夹中：
- en: '![](img/7c04fef2-90eb-4453-ad15-c2f8490ee76d.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c04fef2-90eb-4453-ad15-c2f8490ee76d.png)'
- en: 'The next thing we want to do is add some code to our `model` to represent the
    fields on our login form. Add two properties called `Email` and `Password`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们要做的是在我们的`model`中添加一些代码，以表示登录表单上的字段。添加两个名为`Email`和`Password`的属性：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Back in the `Index.cshtml` view, add the `model` declaration to the top of
    the page. This makes the `model` available for use in our view. Take care to specify
    the correct namespace where the `model` exists:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`Index.cshtml`视图，在页面顶部添加`model`声明。这使得`model`可以在我们的视图中使用。请务必指定`model`存在的正确命名空间：
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next portion of code needs to be written in the `HomeController.cs` file.
    Currently, it should only have an action called `Index()`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的代码部分需要在`HomeController.cs`文件中编写。目前，它应该只有一个名为`Index()`的操作：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add a new `async` function called `ValidateEmail` that will use the base URL
    and parameter string of the Azure Function URL we copied earlier and call it using
    an HTTP request. I will not go into much detail here, as I believe the code to
    be pretty straightforward. All we are doing is calling the Azure Function using
    the URL we copied earlier and reading the return data:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`ValidateEmail`的新的`async`函数，它将使用我们之前复制的Azure Function URL的基本URL和参数字符串，并使用HTTP请求调用它。我不会在这里详细介绍，因为我认为代码非常简单。我们所做的就是使用我们之前复制的URL调用Azure
    Function并读取返回的数据：
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Create another `public async` action called `ValidateLogin`. Inside the action,
    check to see if the `ModelState` is valid before continuing.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`ValidateLogin`的`public async`操作。在操作内部，继续之前检查`ModelState`是否有效。
- en: For a nice explanation of what `ModelState` is, have a look at the following
    article—[https://www.exceptionnotfound.net/asp-net-mvc-demystified-modelstate/](https://www.exceptionnotfound.net/asp-net-mvc-demystified-modelstate/).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`ModelState`的详细解释，请参阅以下文章-[https://www.exceptionnotfound.net/asp-net-mvc-demystified-modelstate/](https://www.exceptionnotfound.net/asp-net-mvc-demystified-modelstate/)。
- en: We then do an `await` on the `ValidateEmail` function, and if the return data
    contains the word `false`, we know that the email validation failed. A failure
    message is then passed to the `TempData` property on the controller.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在`ValidateEmail`函数上进行`await`，如果返回的数据包含单词`false`，则我们知道电子邮件验证失败。然后将失败消息传递给控制器上的`TempData`属性。
- en: 'The `TempData` property is a place to store data until it is read. It is exposed
    on the controller by ASP.NET Core MVC. The `TempData` property uses a cookie-based
    provider by default in ASP.NET Core 2.0 to store the data. To examine data inside
    the `TempData` property without deleting it, you can use the `Keep` and `Peek`
    methods. To read more on `TempData`, see the Microsoft documentation here: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/app-state?tabs=aspnetcore2x](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/app-state?tabs=aspnetcore2x).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`TempData`属性是一个存储数据的地方，直到它被读取。它由ASP.NET Core MVC在控制器上公开。`TempData`属性默认使用基于cookie的提供程序在ASP.NET
    Core 2.0中存储数据。要在不删除的情况下检查`TempData`属性中的数据，可以使用`Keep`和`Peek`方法。要了解有关`TempData`的更多信息，请参阅Microsoft文档：[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/app-state?tabs=aspnetcore2x](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/app-state?tabs=aspnetcore2x)。'
- en: If the email validation passed, then we know that the email address is valid
    and we can do something else. Here, we are simply just saying that the user is
    logged in. In reality, we will perform some sort of authentication here and then
    route to the correct controller.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果电子邮件验证通过，那么我们知道电子邮件地址是有效的，我们可以做其他事情。在这里，我们只是说用户已登录。实际上，我们将执行某种身份验证，然后路由到正确的控制器。
- en: Another interesting thing to note is the inclusion of the `ValidateAntiForgeryToken`
    attribute on the `ValidateLogin` action on the controller. This ensures that the
    form has been posted from our site and prevents our site from being fooled by
    a cross site request forgery attack.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的事情是在控制器上的`ValidateLogin`操作上包含`ValidateAntiForgeryToken`属性。这确保了表单是从我们的站点提交的，并防止我们的站点受到跨站请求伪造攻击的欺骗。
- en: If we had to inspect the rendered markup of our page when we run the application,
    we will see that ASP.NET Core has automatically generated the anti-forgery token
    for us.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须检查应用程序运行时页面的呈现标记，我们将看到ASP.NET Core已自动生成了防伪标记。
- en: Inspect the markup via the browser's developer tools. Access it in Chrome by
    pressing *Ctrl *+ *Shift *+ *I* or *F12* if you are using Edge.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过浏览器的开发者工具检查标记。在Chrome中，按*Ctrl* + *Shift* + *I*或者如果您使用Edge，则按*F12*。
- en: 'You will see the __RequestVerificationToken and the generated value as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到__RequestVerificationToken和生成的值如下所示：
- en: '![](img/44aea025-3fe9-495e-9050-2d7ef231ef83.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44aea025-3fe9-495e-9050-2d7ef231ef83.png)'
- en: 'The complete `ValidateLogin` action on the `HomeController` should look as
    follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HomeController`上的完整`ValidateLogin`操作应如下所示：'
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Swing back to our `Index.cshtml` view and have a closer look at the `form`
    tag. We have explicitly defined which controller and action to call using `asp-action`
    (that specifies the action to call) and `asp-controller` (that specifies in which
    controller to go and look for the specified action):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`Index.cshtml`视图，仔细查看`form`标记。我们已经明确定义了使用`asp-action`（指定要调用的操作）和`asp-controller`（指定要去哪个控制器查找指定操作）来调用哪个控制器和操作：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This maps the action `ValidateLogin` on the `HomeController` class that the
    `Index.cshtml` form will post back to:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`ValidateLogin`操作映射到`HomeController`类上，`Index.cshtml`表单将提交到该操作：
- en: '![](img/284058f0-d4c6-497d-87a6-6d0493a1b7b3.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/284058f0-d4c6-497d-87a6-6d0493a1b7b3.png)'
- en: 'Then, a little further down, ensure that your button has the `type` specified
    to `submit`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，稍微往下，确保您的按钮的`type`指定为`submit`：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We are almost done with our `Index.cshtml` view. We want some sort of notification
    when the email entered is invalid. This is where Bootstrap comes in handy. Add
    the following markup for a `modal` dialog that will be displayed, notifying the
    user that the entered email address is invalid.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Index.cshtml`视图几乎完成了。当输入的电子邮件无效时，我们希望得到某种通知。这就是Bootstrap派上用场的地方。添加以下标记以显示`modal`对话框，通知用户输入的电子邮件地址无效。
- en: 'You will notice the inclusion of the `@section Scripts` block at the end of
    the page. What we are basically saying is that if the `TempData` property is not
    null, then we want to display the modal dialog via the jQuery script:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您将注意到页面末尾包含`@section Scripts`块。我们基本上是在说，如果`TempData`属性不为空，那么我们希望通过jQuery脚本显示模态对话框：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run your application and enter an invalid email address on the login page.
    In my example, I simply added an email address containing two `@` signs:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 运行您的应用程序，并在登录页面上输入一个无效的电子邮件地址。在我的示例中，我只是添加了一个包含两个`@`符号的电子邮件地址：
- en: '![](img/ca7ec133-c219-4f00-9d70-7beef1236e38.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca7ec133-c219-4f00-9d70-7beef1236e38.png)'
- en: When the LOGIN button is pressed, the form posts back to the controller that
    in turn calls the Azure Function, which performs validation on the entered email
    address.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下登录按钮时，表单将回传到控制器，然后调用Azure函数，对输入的电子邮件地址进行验证。
- en: 'The result is a rather bland looking modal dialog notification popping up,
    notifying the user that the email address is incorrect:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个相当单调的模态对话框通知弹出，通知用户电子邮件地址不正确：
- en: '![](img/76e6cf59-c83b-4986-b635-549c1882bc33.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76e6cf59-c83b-4986-b635-549c1882bc33.png)'
- en: 'Entering a valid email address and clicking on the LOGIN button results in
    a successful validation on the entered email:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 输入有效的电子邮件地址并单击登录按钮将导致对输入的电子邮件进行成功验证：
- en: '![](img/f3479fd2-d5b7-4a57-a160-eca11940d5d5.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3479fd2-d5b7-4a57-a160-eca11940d5d5.png)'
- en: 'As mentioned previously, the email validation is not the same as authentication.
    If the email is validated, then the authentication process can take place. If
    this authentication process successfully authenticates the user logging in, only
    then will they be redirected to the logged in page:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，电子邮件验证与身份验证不同。如果电子邮件经过验证，那么可以进行身份验证过程。如果此身份验证过程成功验证登录的用户，那么他们才会被重定向到已登录页面：
- en: '![](img/21b083bf-c5be-42d6-a8fa-4a396598ad85.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21b083bf-c5be-42d6-a8fa-4a396598ad85.png)'
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to create an Azure Function on the Azure portal.
    We learned that Azure Functions are small bits of code in the cloud that are used
    by applications when needed. Because they are priced on a pay-as-you-use model,
    you only pay for the actual computing power user. When the user load is high on
    your web application, the function automatically scales as required to meet the
    demands of the application accessing it.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何在Azure门户上创建Azure函数。我们了解到Azure函数是云中使用的应用程序的小代码片段。由于它们是按使用量付费的模式定价，因此您只需支付实际使用的计算能力。当您的Web应用程序的用户负载很高时，该函数会根据需要自动扩展以满足访问它的应用程序的需求。
- en: We took a look at the process of getting to know the code in our Azure Function
    by posting the URL into the browser manually. Then, we created an ASP.NET Core
    MVC application that consisted of a single login page. We then had a look at how
    to use the Azure Function to validate the email address entered on the login screen.
    Azure Functions are an exciting technology to start using. There is still a lot
    to learn, and not enough left of the chapter to discuss this serverless technology.
    If this technology interests you, explore some of the other Azure Service templates
    available.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过手动将URL发布到浏览器来了解了在Azure函数中了解代码的过程。然后，我们创建了一个由单个登录页面组成的ASP.NET Core MVC应用程序。然后，我们看了如何使用Azure函数来验证登录屏幕上输入的电子邮件地址。
    Azure函数是一种令人兴奋的技术。还有很多东西要学习，这一章剩下的内容不足以讨论这种无服务器技术。如果您对此技术感兴趣，请探索其他可用的Azure服务模板。
- en: In the next chapter, we will be looking at creating a Twitter clone using an
    ASP.NET Core MVC application and a C# library called `Tweetinvi`. Stick around,
    there is still a lot of exciting content for you.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用ASP.NET Core MVC应用程序和名为`Tweetinvi`的C#库创建Twitter克隆。请继续关注，还有很多令人兴奋的内容等着您。
