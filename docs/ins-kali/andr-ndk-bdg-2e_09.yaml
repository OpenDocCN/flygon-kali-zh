- en: Chapter 9. Porting Existing Libraries to Android
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。将现有库移植到Android
- en: '*There are two main reasons why one would be interested in the Android NDK:
    first, for performance, and, second, for portability. In the previous chapters,
    we saw how to access the main native Android APIs from native code for efficiency
    purposes. In this chapter, we will bring the whole C/C++ ecosystem to Android,
    well, at least discovering the path, as decades of C/C++ development would be
    difficult to fit the limited memory of mobile devices anyway! Indeed, C and C++
    are still some of the most widely used programming languages nowadays.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*有两个主要原因会让人对Android NDK感兴趣：首先是性能，其次是可移植性。在之前的章节中，我们看到了如何为了效率而从本地代码访问主要的本地Android
    API。在本章中，我们将把整个C/C++生态系统带到Android，至少是发现路径，因为几十年的C/C++开发将很难适应移动设备的有限内存！事实上，C和C++仍然是当今一些最广泛使用的编程语言之一。'
- en: '>'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*In previous NDK releases, portability was limited due to the partial support
    of C++, especially **Exceptions** and **Run-Time Type** Information (**RTTI**,
    a basic C++ reflection mechanism to get data types at runtime such as `instanceof`
    in Java). Any library requiring them could not be ported without modifying their
    code or installing a custom NDK (the **Crystax NDK**, rebuilt by the community
    from official sources, and available at [http://www.crystax.net/](http://www.crystax.net/)).
    Hopefully, many of these restrictions have been lifted since (except wide character
    support).*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以前的NDK版本中，由于对C++的部分支持，特别是异常和运行时类型信息（RTTI，一种基本的C++反射机制，用于在运行时获取数据类型，例如Java中的`instanceof`），可移植性受到了限制。任何需要它们的库都无法在不修改其代码或安装自定义NDK的情况下进行移植（Crystax
    NDK，由社区从官方来源重新构建，并可在[http://www.crystax.net/](http://www.crystax.net/)上获得）。幸运的是，自那时起已经解除了许多这些限制（除了宽字符支持）。
- en: Although not necessarily difficult, porting an existing library is not a trivial
    process. A few APIs might be missed (despite good POSIX support), some `#define`
    directives have to be tweaked, some dependencies have to be ported, as well as
    dependencies of dependencies. Some libraries will be easy to port, while some
    other will involve more effort.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不一定困难，但移植现有库并不是一个简单的过程。可能会错过一些API（尽管有很好的POSIX支持），必须调整一些`#define`指令，必须移植一些依赖项，以及依赖项的依赖项。一些库将很容易移植，而另一些则需要更多的努力。
- en: 'In this chapter, in order to port existing code to Android, we are going to
    learn how to do the following code:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，为了将现有代码移植到Android，我们将学习如何进行以下代码：
- en: Activate the **Standard Template Library** (**STL**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激活标准模板库（STL）
- en: Port the **Box2D** physics engine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移植Box2D物理引擎
- en: Prebuild and use the **Boost** framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预构建并使用Boost框架
- en: Discover more in-depth how to write NDK module **Makefiles**
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解如何编写NDK模块Makefiles
- en: By the end of this chapter, you should understand the native building process
    and know how to use Makefiles appropriately.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您应该了解本地构建过程，并知道如何适当地使用Makefiles。
- en: Activating the Standard Template Library
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激活标准模板库
- en: The Standard Template Library is a normalized library of containers, iterators,
    algorithms, and helper classes to ease most common programming operations, such
    as dynamic arrays, associative arrays, strings, sorting, and so on. This library
    gained recognition among developers over the years and is widely spread. Developing
    in C++ without the STL is like coding with one hand behind your back!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 标准模板库是一个标准化的容器、迭代器、算法和辅助类库，用于简化大多数常见的编程操作，例如动态数组、关联数组、字符串、排序等。这个库多年来在开发人员中获得了认可，并得到了广泛传播。在没有STL的情况下使用C++编程就像用一只手编码一样受限！
- en: In this first part, let's embed GNU STL in DroidBlaster to ease collection management.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分中，让我们将GNU STL嵌入DroidBlaster以便更轻松地管理集合。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Resulting project is provided with this book under the name `DroidBlaster_Part16`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供了名为`DroidBlaster_Part16`的项目结果。
- en: Time for action – activating GNU STL in DroidBlaster
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-在DroidBlaster中激活GNU STL
- en: 'Let''s activate and make use of the STL in DroidBlaster. Edit the `jni/Application.mk`
    file beside `jni/Android.mk` and write the following content. That''s it! Your
    application is now STL-enabled, thanks to this single line:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在DroidBlaster中激活并使用STL。编辑`jni/Application.mk`文件，旁边是`jni/Android.mk`，并写入以下内容。就是这样！由于这一行，您的应用现在已经启用了STL：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*What just happened?*'
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: 'In only a single line of code, we have activated GNU STL in the `Application.mk`
    file! This STL implementation, selected through the `APP_STL` variable, replaces
    the default NDK C/C++ runtime. The following three STL implementations are currently
    supported:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 仅用一行代码，我们就在`Application.mk`文件中激活了GNU STL！通过`APP_STL`变量选择的这个STL实现替换了默认的NDK C/C++运行时。目前支持以下三种STL实现：
- en: '**GNU STL** (more commonly **libstdc++**), the official GCC STL: This is often
    the preferred choice when using the STL on an NDK project. Exceptions and RTTI
    are supported.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU STL（更常见的是libstdc++），官方GCC STL：在NDK项目中使用STL时，这通常是首选。支持异常和RTTI。
- en: '**STLport** (a multiplatform STL): This implementation is not actively maintained
    and lacks some features. Choose it as a last resort. Exceptions and RTTI are supported.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STLport（一个多平台STL）：这个实现没有得到积极的维护，并且缺少一些功能。将其作为最后的选择。支持异常和RTTI。
- en: '**Libc++**: This is part of LLVM (the technology behind the Clang compiler)
    and aims to provide a functional C++ 11 runtime. Note that this library is now
    becoming the default STL on OS-X and may gain popularity in the future. Exceptions
    and RTTI are supported. Libc++ support is still incomplete and experimental. Libc++
    is often chosen in conjunction with the Clang compiler (read more about this in
    the *Mastering module Makefiles* section).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Libc++：这是LLVM的一部分（Clang编译器背后的技术），旨在提供一个功能齐全的C++ 11运行时。请注意，这个库现在正在成为OS-X上的默认STL，并可能在未来变得更受欢迎。支持异常和RTTI。Libc++支持仍然不完整和实验性的。Libc++通常与Clang编译器一起选择（在*掌握模块Makefiles*部分中了解更多）。
- en: 'Android also provides two other C++ runtimes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Android还提供了另外两个C++运行时：
- en: '**System**: This is the default NDK runtime when no STL implementation is activated.
    Its code name is **Bionic** and it provides a minimalist set of headers (`cstdint`,
    `cstdio`, `cstring`, and so on). Bionic does not provide STL features, as well
    as exceptions and **run-time type information** (**RTTI**). For more details about
    its limitations, have a look at `$ANDROID_NDK/docs/system/libc/OVERVIEW.html`.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**System**：这是默认的NDK运行时，当没有激活STL实现时。它的代码名称是**Bionic**，它提供了一组最小的头文件（`cstdint`，`cstdio`，`cstring`等）。Bionic不提供STL功能，也不提供异常和**运行时类型信息**（**RTTI**）。有关其限制的更多详细信息，请查看
    `$ANDROID_NDK/docs/system/libc/OVERVIEW.html`。'
- en: '**Gabi**: This is similar to the System runtime, except that it supports exceptions
    and RTTI.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gabi**：这与系统运行时类似，但它支持异常和RTTI。'
- en: We will see in the part dedicated to **Boost** in this chapter how to enable
    exceptions and RTTI during compilation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章专门介绍**Boost**的部分中看到如何在编译期间启用异常和RTTI。
- en: 'Each runtime is linkable either statically or dynamically (at the notable exception
    of the default system C/C++ runtime). Dynamically loaded runtimes are posts fixed
    with `_shared`, and statically loaded ones with `_static`. The full list of runtime
    identifiers you can pass to `APP_STL` is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运行时都可以静态或动态链接（默认系统C/C++运行时是一个明显的例外）。动态加载的运行时后缀为 `_shared`，静态加载的后缀为 `_static`。您可以传递给
    `APP_STL` 的运行时标识符的完整列表如下：
- en: '`system`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system`'
- en: '`gabi++_static` and `gabi++_shared`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gabi++_static` 和 `gabi++_shared`'
- en: '`stlport_static` and `stlport_shared`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stlport_static` 和 `stlport_shared`'
- en: '`gnustl_static` and `gnustl_shared`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gnustl_static` 和 `gnustl_shared`'
- en: '`c++_static` and `c++_shared`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c++_static` 和 `c++_shared`'
- en: Remember that shared libraries need to be loaded manually at runtime. If you
    forget to load a shared library, an error is raised at runtime as soon as dependent
    libraries modules are loaded. As the compiler cannot predict in advance which
    functions are going to be called, libraries are loaded entirely in memory, even
    if most of their contents remain unused.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，共享库需要在运行时手动加载。如果忘记加载共享库，当依赖库模块加载时，会在运行时立即引发错误。由于编译器无法预测将调用哪些函数，因此即使大部分内容未被使用，库也会完全加载到内存中。
- en: On the other hand, static libraries are in fact loaded with dependent libraries.
    Indeed, static libraries do not really exist as such at runtime. Their content
    is copied into dependent libraries at compile time when they are linked. Since
    the linker knows precisely which part of the library gets called from the embedding
    module, it can strip its code and keep only what is needed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，静态库实际上是与依赖库一起加载的。事实上，静态库在运行时并不存在。它们的内容在编译时被复制到依赖库中，当它们被链接时。由于链接器精确地知道从嵌入模块调用库的哪一部分，它可以剥离其代码，只保留所需的部分。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Stripping** is the process of discarding unnecessary symbols from binaries.
    This helps reducing (potentially a lot!) binary size after linkage. This can be
    somewhat compared to the Proguard shrinking post processing in Java.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**Stripping** 是从二进制文件中丢弃不必要符号的过程。这有助于在链接后减少（潜在地大量！）二进制文件的大小。这在某种程度上可以与Java中的Proguard缩小后处理进行比较。'
- en: However, linking results in binary code duplication if a static library is included
    more than once. Such a situation can potentially lead to a waste of memory or,
    more worryingly, issues related to, for example, global variable duplication.
    However, static C++ constructors in shared libraries are called only once.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果静态库被多次包含，链接会导致二进制代码重复。这种情况可能导致内存浪费，或者更令人担忧的是与全局变量重复相关的问题。然而，共享库中的静态C++构造函数只会被调用一次。
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that you should avoid using static libraries that are included more
    than once in a project unless you know what you are doing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，除非您知道自己在做什么，否则应避免在项目中多次包含静态库。
- en: Another point to consider is that Java applications can load shared libraries
    only, which can themselves be linked against either shared or static libraries.
    For example, the main library of `NativeActivity` is a shared library, specified
    through the `android.app.lib_name` manifest property. Shared libraries referenced
    from another library must be loaded manually before. The NDK does not do it itself.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的问题是，Java应用程序只能加载共享库，这些库本身可以链接到共享库或静态库。例如，`NativeActivity` 的主库是一个共享库，通过
    `android.app.lib_name` 清单属性指定。另一个库引用的共享库必须在手动加载之前加载。NDK本身不会这样做。
- en: 'Shared libraries can be loaded easily, using `System.loadLibrary()` in a JNI
    applications, but `NativeActivity` are "transparent" activities. So, if you decide
    to use shared libraries, the only solution is to write your own Java activity,
    inheriting from `NativeActivity` and invoking the appropriate `loadLibrary()`
    directives. For instance, below is what DroidBlaster activity would look like,
    if we were using `gnustl_shared` instead:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在JNI应用程序中，可以使用 `System.loadLibrary()` 轻松加载共享库，但 `NativeActivity` 是“透明”的活动。因此，如果决定使用共享库，唯一的解决方案就是编写自己的Java活动，继承自
    `NativeActivity` 并调用适当的 `loadLibrary()` 指令。例如，如果我们使用 `gnustl_shared`，那么DroidBlaster活动将如下所示：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you prefer to load your native library directly from native code, you can
    use the system call `dlopen()`, which is also provided by the NDK.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢直接从本机代码加载本机库，可以使用系统调用 `dlopen()`，这也是由NDK提供的。
- en: Now that the STL is enabled, let's employ it in DroidBlaster.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在STL已经启用，让我们在DroidBlaster中使用它。
- en: Time for action – read files with STL stream
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用STL流读取文件
- en: 'Let''s use the STL to read resources from the SD card instead of the application
    asset directory, as shown in the following steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用STL从SD卡而不是应用程序资源目录中读取资源，如下所示：
- en: Obviously, enabling the STL is useless if we do not actively use it in our code.
    Let's take advantage of this opportunity to switch from asset files to external
    files (on a `sdcard` or internal memory).
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显然，如果我们在代码中不积极使用STL，启用STL就没有意义。让我们利用这个机会，从资源文件切换到外部文件（在 `sdcard` 或内部存储器）。
- en: 'Open the existing file, `jni/Resource.hpp`, and do the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 打开现有文件 `jni/Resource.hpp`，并执行以下操作：
- en: Include the `fstream` and `string` STL headers.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括`fstream`和`string` STL头文件。
- en: Use a `std::string` object for the file name and replace the Asset management
    members with an `std::ifstream` object (that is, an input file stream).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::string`对象作为文件名，并用`std::ifstream`对象（即输入文件流）替换资产管理成员。
- en: Change the `getPath()` method to return a C string from the new `string` member.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`getPath()`方法更改为从新的`string`成员返回C字符串。
- en: 'Remove the `descriptor()` method and the `ResourceDescriptor` class (descriptors
    work with the Asset API only) , as shown in the following:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除`descriptor()`方法和`ResourceDescriptor`类（描述符仅适用于Asset API），如下所示：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Open the corresponding implementation file `jni/Resource.cpp`. Replace the
    previous implementation, based on the asset management API with STL streams and
    strings. Files will be opened in binary mode, as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开相应的实现文件`jni/Resource.cpp`。用基于STL流和字符串的实现替换先前的基于资产管理API的实现。文件将以二进制模式打开，如下所示：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To read the file length, we can use the `stat()` POSIX primitive from the `sys/stat.h`
    header:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要读取文件长度，我们可以使用`sys/stat.h`头文件中的`stat()` POSIX原语：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we can use STL string comparison operator to compare two `Resource`
    objects:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用STL字符串比较运算符来比较两个`Resource`对象：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These changes to the reading system should be almost transparent, except for
    the BGM, whose content was played through an asset file descriptor.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于BGM，这些对读取系统的更改几乎是透明的，其内容是通过资产文件描述符播放的。
- en: 'Now, we need to provide a real file. So, in `jni/SoundService.cpp`, change
    the data source by replacing the `SLDataLocator_AndroidFD` structure with `SLDataLocation_URI`,
    as shown in the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要提供一个真实的文件。因此，在`jni/SoundService.cpp`中，通过将`SLDataLocator_AndroidFD`结构替换为`SLDataLocation_URI`来更改数据源，如下所示：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `AndroidManifest.xml` file, add the permission to read SD card files
    as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`文件中，添加读取SD卡文件的权限，如下所示：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Copy all asset resources from the asset directory to your device SD card (or
    internal memory, depending on your device) in `/sdcard/droidblaster`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有资产资源从资产目录复制到您的设备SD卡（或内部存储器，取决于您的设备）中的`/sdcard/droidblaster`。
- en: '*What just happened?*'
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We have seen how to access binary files located on the SD card with STL streams.
    We have also switched the OpenSL ES player from a file descriptor to a file name
    locator. The file name itself is created here from an STL string. STL strings
    are a real benefit as they allow us to get rid of complex C string manipulation
    primitives.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用STL流访问位于SD卡上的二进制文件。我们还将OpenSL ES播放器从文件描述符切换为文件名定位器。文件名本身是从STL字符串创建的。STL字符串是一个真正的好处，因为它们允许我们摆脱复杂的C字符串操作原语。
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Almost all Android devices can store files in an additional storage location
    mounted in directory `/sdcard`. ""Almost"" is the important word here. Since the
    first Android G1, the meaning of ""sdcard"" has changed. Some recent devices have
    an external storage that is in fact internal (for example, flash memory on some
    tablets), and some others have a second storage location at their disposal (although
    in most cases, the second storage is mounted inside `/sdcard`). Moreover, the
    `/sdcard` path itself is not engraved into the marble. So, to detect safely the
    additional storage location, the only solution is to rely on JNI by calling `android.os.Environment.getExternalStorageDirectory()`.
    You can also check that storage is available with `getExternalStorageState()`.
    Note that the word ""External"" in API method name is here for historical reasons
    only. Also, the permission `WRITE_EXTERNAL_STORAGE` in manifest is required.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有Android设备都可以将文件存储在附加的存储位置中，该位置挂载在目录`/sdcard`中。在这里，“几乎”是重要的词。自第一部Android
    G1以来，“sdcard”的含义已经改变。一些最近的设备具有实际上是内部的外部存储（例如，某些平板电脑上的闪存），而另一些设备则可以使用第二个存储位置（尽管在大多数情况下，第二个存储位置被挂载在`/sdcard`内部）。此外，`/sdcard`路径本身并没有固定。因此，要安全地检测附加的存储位置，唯一的解决方案是依赖JNI，通过调用`android.os.Environment.getExternalStorageDirectory()`来实现。您还可以使用`getExternalStorageState()`检查存储是否可用。请注意，API方法名称中的“External”一词仅出于历史原因。此外，清单中的权限`WRITE_EXTERNAL_STORAGE`是必需的。
- en: The STL provides much more features than Files and Strings. The most popular
    among them are probably STL containers. Let's see some usage examples in DroidBlaster.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: STL提供的功能远远超过了文件和字符串。其中最受欢迎的可能是STL容器。让我们在DroidBlaster中看一些使用示例。
- en: Time for action – using STL containers
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用STL容器的行动时间
- en: 'Let''s now replace raw arrays with standard STL containers by following these
    steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下步骤用标准STL容器替换原始数组：
- en: 'Open the `jni/GraphicsManager.hpp` header and include the headers:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`jni/GraphicsManager.hpp`头文件并包含以下头文件：
- en: '`Vector`, which defines an STL container encapsulating C arrays (with a few
    more interesting features such as dynamic resizing)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vector`，它定义了一个封装C数组的STL容器（具有一些更有趣的功能，如动态调整大小）'
- en: '`Map`, which encapsulates the equivalent of a Java HashMap (that is, an associative
    array)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map`，它封装了Java HashMap的等价物（即，一个关联数组）'
- en: Then, remove the `textureResource` member in the `TextureProperties` structure.
    Use a `map` container instead of a raw array for `mTextures` (prefixed with the
    `std` namespace). The first parameter is the key type and the second the value
    type.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`TextureProperties`结构中删除`textureResource`成员。使用`map`容器代替原始数组`mTextures`（前缀为`std`命名空间）。第一个参数是键类型，第二个是值类型。
- en: 'Finally, replace all the other raw arrays with a `vector`, as shown in the
    following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如下所示，用`vector`替换所有其他原始数组：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Edit `jni/GraphicsManager.cpp` and initialize the new STL containers in the
    constructor initialization list as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`jni/GraphicsManager.cpp`并在构造函数初始化列表中初始化新的STL容器，如下所示：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use the `vector::push_back()` method to insert components into the `mComponents`
    list when they get registered, as shown in the following:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`vector::push_back()`方法将组件插入`mComponents`列表中，如下所示：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In `start()`, we can iterate through the vector using an iterator to initialize
    each registered component, as shown in the following:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`start()`中，我们可以使用迭代器遍历向量，以初始化每个注册的组件，如下所示：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In `stop()`, we can iterate through the map (with second representing entry''s
    value) and vector collections to release each allocated OpenGL resource this time,
    as shown in the following:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`stop()`中，我们可以遍历map（其中second代表条目的值）和vector集合，以释放每个分配的OpenGL资源，如下所示：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Also iterate over components stored to render them in `update()`, as shown
    in the following:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要迭代存储的组件以在`update()`中渲染它们，如下所示：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since textures are expensive resources, use the `map` to check if a texture
    has already been loaded before loading and caching a new instance, as shown in
    the following:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于纹理是昂贵的资源，使用`map`来检查纹理是否已经加载，然后再加载和缓存新实例，如下所示：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Use the defined `vector` objects to save shaders and vertex buffers. Use `push_back()`
    again to add an element to the vector, as shown in the following:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用定义的`vector`对象保存着色器和顶点缓冲区。再次使用`push_back()`将元素添加到vector中，如下所示：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, open `jni/SpriteBatch.hpp`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`jni/SpriteBatch.hpp`。
- en: 'Here again, include and use `vector` objects instead of raw arrays:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，再次包含和使用`vector`对象，而不是原始数组：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In `jni/SpriteBatch.cpp`, replace the usage of raw arrays with vectors, as
    shown in the following:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/SpriteBatch.cpp`中，用vector替换原始数组的使用，如下所示：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'During the loading and drawing process, loop over the `vector`. You can use
    an `iterator` (here in `load()`), as shown in the following:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在加载和绘制过程中，循环遍历`vector`。您可以使用`iterator`（这里在`load()`中），如下所示：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, declare a `std::vector` in `jni/Asteroid.hpp` as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`jni/Asteroid.hpp`中声明一个`std::vector`如下：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Use the vector to insert and iterate over bodies in `jni/Asteroid.cpp`, as
    shown in the following code:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/Asteroid.cpp`中使用vector来插入和迭代bodies，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*What just happened?*'
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: There has been a use of STL containers throughout the application to replace
    raw C arrays. For example, we have managed a set of `Asteroid` game objects inside
    an STL container vector instead of a raw C array. We have also replaced the texture
    cache using an STL map container. STL containers have many advantages, such as
    automatically handling memory management (array resizing operations and so on),
    to alleviate our burden.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个应用程序中一直使用STL容器来替换原始的C数组。例如，我们在STL容器vector中管理了一组`Asteroid`游戏对象，而不是使用原始的C数组。我们还用STL
    map容器替换了纹理缓存。STL容器有许多优点，例如自动处理内存管理（数组调整大小等），以减轻我们的负担。
- en: STL is definitely a huge improvement that avoids repetitive and error-prone
    code. Many open source libraries require it and it can now be ported without much
    trouble. More documentation about it can be found at [http://www.cplusplus.com/reference/stl](http://www.cplusplus.com/reference/stl)
    and on SGI's website (publisher of the first STL) at [http://www.sgi.com/tech/stl](http://www.sgi.com/tech/stl).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: STL绝对是一个巨大的改进，避免了重复和容易出错的代码。许多开源库都需要它，现在可以轻松移植。关于它的更多文档可以在[http://www.cplusplus.com/reference/stl](http://www.cplusplus.com/reference/stl)和SGI网站（第一个STL的发布者）上找到，网址为[http://www.sgi.com/tech/stl](http://www.sgi.com/tech/stl)。
- en: 'When developing for performance, standard STL containers are not always the
    best choice, especially in terms of memory management and allocation. Indeed,
    STL is an all-purpose library, written for common cases. Alternative libraries
    might be considered for performance-critical code. A few examples are as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发性能时，标准STL容器并不总是最佳选择，特别是在内存管理和分配方面。实际上，STL是一个通用库，编写用于常见情况。对于性能关键的代码，可能需要考虑替代库。以下是一些示例：
- en: '**EASTL**: This is an STL replacement developed by Electronic Arts with gaming
    in mind. An extract is available in the repository at [https://github.com/paulhodge/EASTL](https://github.com/paulhodge/EASTL).
    A must-read paper detailing EASTL technical details can be found on the Open Standards
    website at [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html).'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EASTL**：这是由艺电开发的STL替代品，专为游戏而设计。存储库中提供了一个摘录，网址为[https://github.com/paulhodge/EASTL](https://github.com/paulhodge/EASTL)。关于EASTL技术细节的必读论文可以在开放标准网站上找到，网址为[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html)。'
- en: '**Bitsquid Foundation library**: This is another STL replacement targeting
    games and can be found at [https://bitbucket.org/bitsquid/foundation/](https://bitbucket.org/bitsquid/foundation/).'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bitsquid Foundation library**：这是另一个针对游戏的STL替代品，可以在[https://bitbucket.org/bitsquid/foundation/](https://bitbucket.org/bitsquid/foundation/)找到。'
- en: '**RDESTL**: This is an open source subset of the STL, based on the EASTL technical
    paper, which was published several years before EASTL code release. The code repository
    can be found at [http://code.google.com/p/rdestl/](http://code.google.com/p/rdestl/).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RDESTL**：这是STL的一个开源子集，基于EASTL技术论文，比EASTL代码发布前几年就已经发表。代码存储库可以在[http://code.google.com/p/rdestl/](http://code.google.com/p/rdestl/)找到。'
- en: '**Google SparseHash**: This is for a high performance associative array library
    (note that RDESTL is also quite good at that).'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google SparseHash**：这是一个高性能的关联数组库（注意RDESTL在这方面也非常出色）。'
- en: This is far from exhaustive. Just define your exact needs to make the most appropriate
    choice.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这还远远不够详尽。只需定义您的确切需求，以做出最合适的选择。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: STL is still the best choice for most applications or libraries. Before going
    away from it, profile your source code and make sure it is really necessary.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: STL仍然是大多数应用程序或库的最佳选择。在放弃它之前，请对源代码进行分析，确保真的有必要。
- en: Porting Box2D to Android
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Box2D移植到Android
- en: With the STL in our basket, we are ready to port almost any library to Android.
    Actually, many third-party libraries are already ported and many more are coming.
    However, when nothing is available, you have to rely on our own skills.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有了STL，我们几乎可以将任何库移植到Android。实际上，许多第三方库已经被移植，还有更多正在进行中。但是，当没有可用的时候，您必须依靠自己的技能。
- en: To see how to handle this situation, we are now going to port Box2D with the
    NDK. Box2D is a highly popular physics simulation engine initiated by Erin Catto
    in 2006\. Many 2D games, either amateur or professional like Angry Birds, embed
    this powerful open source library. It is available in several languages, including
    Java, though its primary language is C++.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解如何处理这种情况，我们现在将使用NDK移植Box2D。Box2D是由Erin Catto于2006年发起的非常受欢迎的物理模拟引擎。许多业余或专业的2D游戏，如愤怒的小鸟，都嵌入了这个强大的开源库。它可用于多种语言，包括Java，尽管其主要语言是C++。
- en: 'Box2D is an answer to the complex subject, that is, physics simulation. Maths,
    numerical integration, software optimization, and so on are some of the multiple
    techniques applied to simulate rigid body movements and collisions in a 2D environment.
    Bodies are the essential element of Box2D and are characterized by the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D是对复杂主题的回答，即物理模拟。数学，数值积分，软件优化等等是用于在2D环境中模拟刚体运动和碰撞的多种技术之一。Bodies是Box2D的基本元素，并且具有以下特征：
- en: A geometrical **shape** (polygons, circles, and so on)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何**形状**（多边形，圆形等）
- en: Physics properties (such as **density**, **friction**, **restitution**, and
    so on)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理属性（如**密度**，**摩擦**，**恢复**等）
- en: Movement **constraints** and **joints** (to link bodies together and restrict
    their movement)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运动**约束**和**连接**（将实体连接在一起并限制它们的运动）
- en: All these bodies are orchestrated inside a *World* that steps simulation according
    to time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些实体都在一个*World*中进行编排，根据时间进行模拟。
- en: So, now that you know the very basics of Box2D, let's port and integrate it
    in DroidBlaster to simulate collisions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在您已经了解了Box2D的基础知识，让我们将其移植并集成到DroidBlaster中以模拟碰撞。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Resulting project is provided with this book under the name `DroidBlaster_Part17`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目在本书中以`DroidBlaster_Part17`的名称提供。
- en: Time for action – compiling Box2D on Android
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-在Android上编译Box2D
- en: 'First, let''s port Box2D on the Android NDK following these steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们按照以下步骤在Android NDK上移植Box2D：
- en: Box2D 2.3.1 archive is provided with this book in directory `Libraries/box2d`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D 2.3.1存档在本书的`Libraries/box2d`目录中提供。
- en: Unzip Box2D source archive (2.3.1 in this book) into `${ANDROID_NDK}/sources/`
    (beware directory must be named `box2d`).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Box2D源存档（本书中的2.3.1）解压缩到`${ANDROID_NDK}/sources/`中（注意目录必须命名为`box2d`）。
- en: Create and open an `Android.mk` file in the root of the `box2d` directory.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`box2d`目录的根目录中创建并打开`Android.mk`文件。
- en: First, save the current directory inside the `LOCAL_PATH` variable. This step
    is always necessary because an NDK build system may switch to another directory
    at any time during compilation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将当前目录保存在`LOCAL_PATH`变量中。这一步始终是必要的，因为NDK构建系统可能在编译过程中随时切换到另一个目录。
- en: After this, list all Box2D source files to compile, as shown in the following.
    We are interested in source file name only, which can be found in `${ANDROID_NDK}/sources/box2d/Box2D/Box2D`.
    Use the `LS_CPP` helper function to avoid copying each filename.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，列出所有要编译的Box2D源文件，如下所示。我们只对源文件名称感兴趣，可以在`${ANDROID_NDK}/sources/box2d/Box2D/Box2D`中找到。使用`LS_CPP`辅助函数来避免复制每个文件名。
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, write the Box2D module definition for a static library. First, call the
    `$(CLEAR_VARS)` script. This script has to be included before any module definition
    to remove any potential change made by other modules, and to avoid any unwanted
    side effects. Then, define the following settings:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为静态库编写Box2D模块定义。首先，调用`$(CLEAR_VARS)`脚本。在任何模块定义之前必须包含此脚本，以删除其他模块可能进行的任何更改，并避免任何不必要的副作用。然后，定义以下设置：
- en: 'Module name in `LOCAL_MODULE`: The module name is suffixed with _static to
    avoid a name collision with the shared version we are going to define right after.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_MODULE`中的模块名称：模块名称后缀为_static，以避免与我们将在之后定义的共享版本发生名称冲突。'
- en: Module source files in `LOCAL_SRC_FILES` (using `BOX2D_CPP` defined previously).
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_SRC_FILES`中的模块源文件（使用之前定义的`BOX2D_CPP`）。'
- en: Header file directory exported to client modules in `LOCAL_EXPORT_C_INCLUDES`.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将头文件目录导出到客户端模块中的`LOCAL_EXPORT_C_INCLUDES`。
- en: 'Header file used internally for module compilation in `LOCAL_C_INCLUDES`. Here,
    the headers used for Box2D compilation and the headers needed for the client module
    are the same (and are often the same in other libraries). So, reuse `LOCAL_EXPORT_C_INCLUDES`,
    as defined previously, in the following way:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于模块编译的内部头文件在`LOCAL_C_INCLUDES`中使用。在这里，用于Box2D编译和客户端模块所需的头文件是相同的（在其他库中通常也是相同的）。因此，可以像之前定义的那样重用`LOCAL_EXPORT_C_INCLUDES`：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Android.mk` archive is provided in the `Libraries/box2d` directory.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Android.mk`存档在`Libraries/box2d`目录中提供。 '
- en: 'Open DroidBlaster `Android.mk` and link against `box2d_static` by appending
    it to `LOCAL_STATIC_LIBRARIES`. Indicate which `Android.mk` module file to include
    with the `import-module` directive. Remember that modules are found, thanks to
    the `NDK_MODULE_PATH` variable, which points by default to `${ANDROID_NDK}/sources`,
    as shown in the following:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开DroidBlaster `Android.mk`，并通过将其附加到`LOCAL_STATIC_LIBRARIES`来链接`box2d_static`。指示要包含哪个`Android.mk`模块文件，使用`import-module`指令。请记住，模块是通过`NDK_MODULE_PATH`变量找到的，默认指向`${ANDROID_NDK}/sources`，如下所示：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Optionally, activate include file resolution in Eclipse if you see warnings
    about Box2D including files. To do so, in Eclipse **Project properties**, navigate
    to **the C/C++ General/Paths and Symbols** section and then the **Includes** tab,
    and add the Box2d directory `${env_var:ANDROID_NDK}/sources/box2d`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到有关Box2D包含文件的警告，可以选择在Eclipse中激活包含文件解析。要这样做，在Eclipse的**项目属性**中，导航到**C/C++
    General/Paths and Symbols**部分，然后转到**Includes**选项卡，并添加Box2d目录`${env_var:ANDROID_NDK}/sources/box2d`。
- en: '*What just happened?*'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: Launch the DroidBlaster compilation. Box2D is compiled without errors. We have
    ported our second open source library (after `libpng`) to Android thanks to the
    NDK! We can finally reuse one of the many wheels already created by the community!
    Porting a native library to Android involves mainly writing an `Android.mk` module
    makefile to describe source files, dependencies, compilation flags, and so on,
    as we have done until now for our main module DroidBlaster.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 启动DroidBlaster编译。Box2D没有错误地编译。我们已经将我们的第二个开源库（在`libpng`之后）移植到Android，这要感谢NDK！我们终于可以重用社区已经创建的众多轮子了！将本地库移植到Android主要涉及编写一个`Android.mk`模块makefile来描述源文件、依赖关系、编译标志等，就像我们迄今为止为我们的主模块DroidBlaster所做的那样。
- en: 'We have seen some of the most essential variables to use in a module, and they
    are as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了在模块中使用的一些最基本的变量，它们如下：
- en: '`LOCAL_MODULE`: This declares a unique module name where the final library
    name depends on its value'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_MODULE`：这声明了一个唯一的模块名称，最终库名称取决于它的值'
- en: '`LOCAL_SRC_FILES`: This lists all the files to compile relative to the module''s
    root'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_SRC_FILES`：这列出了相对于模块根目录要编译的所有文件'
- en: '`LOCAL_C_INCLUDES`: This defines `include` file directories'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_C_INCLUDES`：这定义了`include`文件目录'
- en: '`LOCAL_EXPORT_C_INCLUDES`: This defines `include` file directories but for
    including modules this time'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_EXPORT_C_INCLUDES`：这次定义了包含模块的`include`文件目录'
- en: 'The order to build Box2D module build is given by one of the following directives:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Box2D模块的顺序由以下指令之一给出：
- en: '`BUILD_STATIC_LIBRARY`: This compiles the module as a static library'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUILD_STATIC_LIBRARY`：这将模块编译为静态库'
- en: '`BUILD_SHARED_LIBRARY`: This also compiles the module but as a shared library
    this time'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUILD_SHARED_LIBRARY`：这次也编译模块，但是作为共享库'
- en: A module can be compiled as a static or shared library in the same way as the
    STL. Compilation is performed dynamically (that is, on-demand) each time a client
    application imports the module or changes its compilation settings. Hopefully,
    the NDK is able to compile sources incrementally.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以像STL一样以静态或共享库的形式进行编译。每当客户端应用程序导入模块或更改其编译设置时，编译都是动态进行的（即按需进行）。希望NDK能够增量编译源代码。
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To create a module for a header only library, such as parts of Boost or GLM
    (a library for OpenGL ES matrix calculations), define a module without `LOCAL_SRC_FILES`
    defined. Only `LOCAL_MODULE` and `LOCAL_EXPORT_C_INCLUDES` are necessary.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要为仅有头文件的库创建一个模块，比如Boost或GLM的部分（用于OpenGL ES矩阵计算的库），定义一个没有定义`LOCAL_SRC_FILES`的模块。只有`LOCAL_MODULE`和`LOCAL_EXPORT_C_INCLUDES`是必需的。
- en: From the client `Android.mk` perspective (that is `the DroidBlaster` makefile
    in our case), the NDK `import-module` directive triggers, roughly speaking, include
    sub-module `Android.mk` files. Without it, the NDK will not be able to discover
    dependent modules, compile them, and include their headers. All the modules, the
    main module as well as the sub-modules, are produced in `<PROJECT_DIR>/libs`,
    and intermediate binary files are in `<PROJECT_DIR>/obj` for the main application
    module.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端`Android.mk`的角度来看（也就是我们的情况下的`DroidBlaster`makefile），NDK的`import-module`指令会触发，粗略地说，包含子模块`Android.mk`文件。没有它，NDK将无法发现依赖模块、编译它们并包含它们的头文件。所有模块，包括主模块和子模块，都产生在`<PROJECT_DIR>/libs`中，而中间二进制文件在主应用程序模块的`<PROJECT_DIR>/obj`中。
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `import-module` directive should be located at the end of the file to avoid
    altering module definition.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`import-module`指令应该位于文件末尾，以避免改变模块定义。'
- en: 'The following are the three ways to link against "sub-module" libraries in
    the main `Android.mk` Makefile:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在主`Android.mk` Makefile中链接“子模块”库的三种方法：
- en: Static libraries must be listed in the `LOCAL_STATIC_LIBRARIES` variable (as
    we have done for Box2D)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态库必须在`LOCAL_STATIC_LIBRARIES`变量中列出（就像我们为Box2D所做的那样）
- en: Shared libraries need to be listed in the `LOCAL_SHARED_LIBRARIES` variable
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享库需要在`LOCAL_SHARED_LIBRARIES`变量中列出
- en: Shared system libraries should be listed in `LOCAL_LDLIBS` (as we have done
    for OpenGL ES, for example)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享系统库应该在`LOCAL_LDLIBS`中列出（例如，我们已经为OpenGL ES做过）。
- en: For more information about Makefiles, see the *Mastering module Makefiles* section.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Makefile的更多信息，请参阅*精通模块Makefile*部分。
- en: 'Writing a Makefile is an important part of the porting process. However, it
    is not always sufficient. Porting a library can be slightly more involved, depending
    on its originating platforms. For example, a piece code already ported to iOS
    is often easier to port to Android. In more complex cases, it may become necessary
    to patch code to make it behave properly on Android. When you are condemned to
    such a hard and non-trivial task, which is honestly quite frequent, always consider
    the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 编写Makefile是移植过程中的重要部分。然而，这并不总是足够的。移植一个库可能会更加复杂，这取决于它的原始平台。例如，已经移植到iOS的代码片段通常更容易移植到Android。在更复杂的情况下，可能需要修补代码以使其在Android上正常运行。当你被迫做这样一项艰难且不平凡的任务时，这种情况实际上相当频繁，总是要考虑以下事项：
- en: Make sure required libraries exist, and port them first if not.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保所需的库存在，如果不存在，则首先移植它们。
- en: Look for the main configuration header file if one is provided with your library
    (as this is often the case). It is a good place to tweak enabled or disabled features,
    remove unwanted dependencies, or define new Macros.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找主配置头文件（如果库提供了的话，这通常是这样）。这是调整启用或禁用功能、删除不需要的依赖项或定义新宏的好地方。
- en: Give attention to system-related macros (that is, `#ifdef _LINUX` ...), which
    are one of the first places to look for changes to make in the code. Generally,
    one will need to define macros, such as `_ANDROID_`, and insert them where appropriate.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意与系统相关的宏（即`#ifdef _LINUX`...），这是要查找代码中要进行更改的地方之一。通常，需要定义宏，比如`_ANDROID_`，并在适当的地方插入它们。
- en: Comment non-essential code to check if the library can compile and if its core
    features can possibly work. Indeed, do not bother fixing everything if you are
    unsure yet whether it will work.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释非必要的代码，以检查库是否可以编译，以及其核心功能是否可能工作。确实，如果你还不确定它是否能工作，就不要费心修复一切。
- en: Hopefully, Box2D was not tight to a specific platform, as it relies mainly on
    pure C/C++ computation and not on external APIs. In such cases, porting code becomes
    much easier. Now that Box2D is compiled, let's run it in our own code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 希望Box2D不会与特定平台绑定，因为它主要依赖于纯C/C++计算而不是外部API。在这种情况下，移植代码变得更容易。现在Box2D已经编译完成，让我们在自己的代码中运行它。
- en: Time for action – running Box2D physics engine
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 运行Box2D物理引擎
- en: 'Let''s rewrite the DroidBlaster physics engine with Box2D with the following
    steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下步骤重写DroidBlaster物理引擎为Box2D：
- en: Open the `jni/PhysicsManager.hpp` header and insert the Box2D `include` file.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`jni/PhysicsManager.hpp`头文件并插入Box2D的`include`文件。
- en: Define a constant `PHYSICS_SCALE` to convert the body position from physics
    to game coordinates. Indeed, Box2D uses its own scale for a better precision.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个常量 `PHYSICS_SCALE` 来将body位置从物理坐标转换为游戏坐标。实际上，Box2D使用自己的比例以获得更好的精度。
- en: 'Then, replace `PhysicsBody` with a new structure, `PhysicsCollision`, that
    will indicate which bodies entered in collision, as shown in the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，用一个新的结构`PhysicsCollision`替换`PhysicsBody`，它将指示哪些物体发生了碰撞，如下所示：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then, make `PhysicsManager` inherit from `b2ContactListener`. A contact listener
    gets notified about new collisions each time the simulation is updated. Our `PhysicsManager`
    inherits one of its method's named `BeginContact()`, used to react to collisions.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让`PhysicsManager`继承自`b2ContactListener`。接触监听器在每次模拟更新时通知新的碰撞。我们的`PhysicsManager`继承了其中的一个名为`BeginContact()`的方法，用于对碰撞做出反应。
- en: 'We will need three more methods, which are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要另外三种方法，如下所示：
- en: '`loadBody()` to create a new entity within the physics engine'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadBody()` 创建一个新的物理引擎内的实体'
- en: '`loadTarget()` to create an entity that moves toward a target (our spaceship)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadTarget()` 创建一个朝向目标（我们的太空飞船）移动的实体'
- en: '`start()` to initialize the engine when the game starts'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start()`在游戏开始时初始化引擎'
- en: 'Also, define member variables, which are as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 还要定义成员变量，如下所示：
- en: '`mWorld` represents the whole Box2D simulation which contains all the bodies
    we are going to create'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mWorld`代表整个Box2D模拟，其中包含我们将要创建的所有物体'
- en: '`mBodies` is the list of all the physics entities we have registered'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mBodies`是我们注册的所有物理实体的列表'
- en: '`mLocations` contains a copy of the `b2Body` position in game coordinates (instead
    of physics coordinates which have a different scale)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mLocations` 包含了 `b2Body` 在游戏坐标系中的位置副本（而不是物理坐标系，其比例不同）'
- en: '`mBoundsBodyObj` defines the boundaries in which our space ship will be able
    to move'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mBoundsBodyObj`定义了我们的太空飞船可以移动的边界'
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Implement `jni/PhysicsManager.cpp`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `jni/PhysicsManager.cpp`。
- en: Iteration constants determine the simulation accuracy. Here, Box2D is going
    to handle mainly collisions and simple movements. So, fixing velocity and position
    iterations to `6` and `2`, respectively, is sufficient (more about their meaning
    a bit later).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代常量决定了模拟的准确性。在这里，Box2D主要处理碰撞和简单的移动。因此，将速度和位置迭代修正为`6`和`2`就足够了（稍后会详细介绍它们的含义）。
- en: 'Initialize the new `PhysicsManager` members and let it listen to collision
    events with `SetContactListener()` on the `mWorld` object, as shown in the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化新的`PhysicsManager`成员，并让它监听`mWorld`对象上的碰撞事件，如下所示：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Initialize Box2D world boundaries when the game starts. These boundaries match
    the display window size converted into *physics system coordinates*. Indeed, the
    physics system uses its own predefined scale to preserve float-point value accuracy.
    We need four edges to define these boundaries, as shown in the following:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游戏开始时初始化Box2D世界边界。这些边界与显示窗口大小转换为*物理系统坐标*相匹配。实际上，物理系统使用自己预定义的比例来保持浮点值的精度。我们需要四条边来定义这些边界，如下所示：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Initialize and register asteroid or ship physics bodies in `loadBody()`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`loadBody()`中初始化和注册小行星或飞船的物理body。
- en: The body definition describes a dynamic body (as opposed to static), awake (that
    is, actively simulated by Box2D), and which cannot rotate (a property especially
    important for polygon shapes, meaning that it is always pointing upward).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: body定义描述了一个动态body（与静态相对），唤醒状态（即由Box2D主动模拟），并且不能旋转（对于多边形形状特别重要，意味着它始终指向上方）。
- en: Also note how we save a `PhysicsCollision` self-reference in the `userData`
    field, in order to access it later inside Box2D callbacks.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，我们在`userData`字段中保存了一个`PhysicsCollision`的自引用，以便稍后在Box2D回调中访问它。
- en: 'Define the body shape, which we approximate to a circle. Note that Box2D requires
    a half dimension, from the object''s center to its borders, as shown in the following
    code snippet:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 定义body形状，我们将其近似为一个圆。请注意，Box2D需要一个半尺寸，从对象的中心到其边界，如下面的代码片段所示：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Body fixture is the "glue" that ties together body definition, shape, and physical
    properties. We also use it to set the body's category and mask, and to filter
    collisions between objects (for instance, asteroids can collide with the ship
    but not between themselves in DroidBlaster). One bit represents one category.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Body fixture是将body定义、形状和物理属性绑在一起的“粘合剂”。我们还用它来设置body的类别和掩码，并过滤对象之间的碰撞（例如，小行星可以与飞船发生碰撞，但在DroidBlaster中它们之间不能发生碰撞）。一个比特表示一个类别。
- en: 'Finally, effectively instantiate your `body` inside the Box2D physical world,
    as shown in the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在Box2D物理世界中有效地实例化你的 `body`，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Implement the `loadTarget()` method that creates a Box2D mouse joint to simulate
    spaceship movements. Such a `Joint` defines an empty target toward which the body
    (here specified in parameter) moves, like a kind of elastic. The settings used
    here (`maxForce`, `dampingRatio`, and `frequencyHz`) control how the ship reacts
    and can be determined by tweaking them, as shown in the following code:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `loadTarget()` 方法，创建一个Box2D鼠标关节来模拟太空飞船的移动。这样的`Joint`定义了一个空目标，物体（在此处指定为参数）朝向该目标移动，就像一种弹簧。这里使用的设置（`maxForce`，`dampingRatio`和`frequencyHz`）控制了飞船的反应，并可以通过调整它们来确定，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Write the `update()` method.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`update()`方法。
- en: First, clear any collision flag buffered in `BeginContact()` during previous
    iteration.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，清除在上一次迭代中在`BeginContact()`中缓冲的任何碰撞标志。
- en: Then, perform simulation by calling `Step()`. The time period specifies how
    much time must be simulated. Iterations constants determine simulation accuracy.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，通过调用`Step()`执行模拟。时间周期确定必须模拟多少时间。迭代常数确定模拟精度。
- en: 'Finally, loop over all of the physics bodies to extract their coordinates,
    convert them from Box2D to game coordinates, and store the result into our own
    `Location` object, as shown in the following code:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，循环遍历所有物理主体，提取它们的坐标，将它们从Box2D转换为游戏坐标，并将结果存储到我们自己的`Location`对象中，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finish with the `BeginContact()` method inherited by `b2ContactListener`. This
    callback notifies new collisions between bodies, two at a time (named `A` and
    `B`). Event information is stored in a `b2contact` structure, which contains various
    properties, such as friction, restitution, and the two bodies, involved through
    their fixture. These fixtures contain in themselves a reference to our own `PhysicsCollision`.
    We can use the following link to switch the `PhysicsCollision` collision flag
    when Box2D detects one contact:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`b2ContactListener`继承的`BeginContact()`方法结束。此回调通知主体之间的新碰撞，每次两个（命名为`A`和`B`）。事件信息存储在`b2contact`结构中，其中包含各种属性，如摩擦、恢复和两个主体，通过它们的夹具参与。这些夹具本身包含对我们自己的`PhysicsCollision`的引用。我们可以使用以下链接在Box2D检测到一个接触时切换`PhysicsCollision`碰撞标志：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In `jni/Asteroid.hpp`, replace the usage of `PhysicsBody` with Box2D `b2Body`
    structure, as shown in the following code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/Asteroid.hpp`中，用下面的代码替换`PhysicsBody`的使用，使用Box2D `b2Body`结构：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In `jni/Asteroid.cpp`, scale constants and boundaries to the physics coordinate
    system:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/Asteroid.cpp`中，将比例常量和边界调整为物理坐标系：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, update the way an asteroid body is registered. Register physics properties
    with a category and mask. Here, asteroids are declared as belonging to category
    1 (`0X1` in hexadecimal notation), and only bodies in group 2 (`0X2` in hexadecimal)
    are considered when evaluating collisions:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新小行星主体的注册方式。使用类别和掩码注册物理属性。在这里，小行星被声明为属于类别1（十六进制表示为`0X1`），只有组2（十六进制为`0X2`）中的主体在评估碰撞时才被考虑：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Replace and update the remaining code to accommodate the use of the new `b2Body`
    structure instead of the `PhysicsBody` one:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 替换和更新剩余的代码，以适应新的`b2Body`结构而不是`PhysicsBody`结构的使用：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, also update `spawn()` code to initialize the `PhysicsBody`, as shown
    in the following code:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，还要更新`spawn()`代码以初始化`PhysicsBody`，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Open `jni/Ship.hpp` to turn it into a Box2D body.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`jni/Ship.hpp`将其转换为Box2D主体。
- en: Add a new `b2Body` parameter to the `registerShip()` method.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 向`registerShip()`方法添加一个新的`b2Body`参数。
- en: 'Then, define the following two additional methods:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义以下两个额外的方法：
- en: '`update()`, which contains some new game logic to destroy the ship when it
    collides with asteroids'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update()`，其中包含一些新的游戏逻辑，当飞船与小行星碰撞时销毁飞船'
- en: '`isDestroyed()` to indicate if the ship has been destroyed'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isDestroyed()`指示飞船是否已被摧毁'
- en: 'Declare the following necessary variables:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 声明以下必要的变量：
- en: '`mBody` to manage the ship representation in Box2D'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mBody`用于管理Box2D中飞船的表示'
- en: '`mDestroyed` and `mLives` for the game logic'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mDestroyed`和`mLives`用于游戏逻辑'
- en: '[PRE38]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Declare a few new constants in `jni/Ship.cpp`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/Ship.cpp`中声明一些新的常量。
- en: 'Then, initialize the new member variables properly. Note that you don''t need
    to play the collision sound anymore in `initialize()`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，适当地初始化新的成员变量。请注意，您不再需要在`initialize()`中播放碰撞声音：
- en: '[PRE39]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In `update()`, check if the ship body has collided with an asteroid. To do so,
    check the `PhysicsCollision` structure stored in the ship `b2Body` custom user
    data. Remember that its content is set in the `PhysicsManager::BeginContact()`
    method
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update()`中，检查飞船主体是否与小行星发生了碰撞。为此，请检查存储在飞船`b2Body`自定义用户数据中的`PhysicsCollision`结构。请记住，其内容是在`PhysicsManager::BeginContact()`方法中设置的
- en: When the ship collides, we can decrease its life and play a collision sound.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当飞船碰撞时，我们可以减少其生命并播放碰撞声音。
- en: If it has no more life, we can start playing a destruction animation. The body
    should be inactive when this happens to avoid further collision with asteroids.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它没有生命了，我们可以开始播放一个销毁动画。当这发生时，主体应该是不活动的，以避免与小行星进一步碰撞。
- en: 'When ship is fully destroyed, we can save its state so that the game loop can
    act appropriately, as shown in the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当飞船完全被摧毁时，我们可以保存其状态，以便游戏循环可以适当地进行操作，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Update the `jni/MoveableBody.hpp` component so that it returns a `b2Body` structure
    in `registerMoveableBody()`.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`jni/MoveableBody.hpp`组件，使其在`registerMoveableBody()`中返回一个`b2Body`结构。
- en: 'Add the following two new members:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下两个新成员：
- en: '`mBody` for the physical body'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mBody`用于物理主体'
- en: '`mTarget` for the mouse joint:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mTarget`用于鼠标关节：'
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Adapt `jni/MoveableBody.cpp` constants to the new scale and initialize new
    members in the constructor:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`jni/MoveableBody.cpp`常量以适应新的比例，并在构造函数中初始化新成员：
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, set up and update the `physicsbody` so that it follows the ship''s target.
    The target moves according to user input, as shown in the following code:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，设置和更新`physicsbody`，使其跟随飞船的目标。目标根据用户输入移动，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, edit `jni/DroidBlaster.cpp` and change the ship registration code
    to accommodate the new changes, as shown in the following code:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编辑`jni/DroidBlaster.cpp`并更改飞船注册代码以适应新的更改，如下面的代码所示：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Don''t forget to start the `PhysicsManager` in `onActivate()`, as shown in
    the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记在`onActivate()`中启动`PhysicsManager`，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Terminate by updating and checking ship state in `onStep()`. When it is destroyed,
    exit the game loop as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`onStep()`中更新和检查飞船状态来终止。当它被摧毁时，退出游戏循环如下：
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*What just happened?*'
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'We have created a physical simulation using the Box2D physics engine. More
    specifically, we have seen how to do the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用Box2D物理引擎创建了物理模拟。更具体地说，我们已经看到如何做到以下几点：
- en: Create a Box2D world to describe the physical simulation
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Box2D世界来描述物理模拟
- en: Define a physical representation of entities (ships and asteroids)
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义实体的物理表示（飞船和小行星）
- en: Step a simulation
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟一次运动
- en: Filter and detect collisions between entities
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤和检测实体之间的碰撞
- en: Extract simulation state (that is, coordinates) to feed the graphical representation
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取模拟状态（即坐标）以提供给图形表示
- en: Box2D uses its own allocators to optimize memory management. So, to create and
    destroy Box2D objects, one needs to systematically use the provided factory methods
    (`CreateX()`, `DestroyX()`). Most of the time, Box2D will manage memory automatically
    for you. When an object is destroyed, all related *child objects* get destroyed
    (for instance, the bodies are destroyed when the world is destroyed). But, if
    you need to get rid of your objects earlier, and thus manually, always destroy
    the bodies.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D使用自己的分配器来优化内存管理。因此，要创建和销毁Box2D对象，需要系统地使用提供的工厂方法（`CreateX()`、`DestroyX()`）。大多数情况下，Box2D会自动为您管理内存。当一个对象被销毁时，所有相关的*子对象*也会被销毁（例如，当世界被销毁时，物体也会被销毁）。但是，如果您需要更早地摆脱您的对象，因此需要手动销毁物体。
- en: Box2D is a complex piece of code and is quite hard to tune properly. Let's dive
    a bit deeper into the way its world is described and how to handle collision.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D是一段复杂的代码，很难正确调整。让我们深入了解一下它的世界是如何描述的，以及如何处理碰撞。
- en: Diving into the Box2D world
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入了解Box2D世界
- en: 'The central point of access in Box2D is the `b2World` object, which stores
    a collection of physical bodies to simulate. A Box2D body is composed of the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D中的访问中心点是`b2World`对象，它存储了一系列要模拟的物理物体。Box2D物体由以下组成：
- en: '`b2BodyDef`: This defines the body type (`b2_staticBody, b2_dynamicBody`, and
    so on) and initial properties, such as its position, angle (in radians), and so
    on.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b2BodyDef`: 这定义了物体类型（`b2_staticBody, b2_dynamicBody`等）和初始属性，如位置、角度（弧度）等。'
- en: '`b2Shape`: This is used for collision detection and to derive body mass from
    its density. It can be a `b2PolygonShape`, `b2CircleShape`, and so on.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b2Shape`: 这用于碰撞检测，并根据其密度推导物体质量。它可以是`b2PolygonShape`、`b2CircleShape`等。'
- en: '`b2FixtureDef`: This links together a body shape, a body definition, and its
    physical properties, such as density.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b2FixtureDef`: 这将一个物体形状、一个物体定义和其物理属性（如密度）链接在一起。'
- en: '`b2Body`: This is a body instance in the world (that is, one per game object).
    It is created from a body definition, a shape, and a fixture.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b2Body`: 这是世界中的一个物体实例（也就是每个游戏对象一个）。它是从一个物体定义、一个形状和一个夹具创建的。'
- en: 'Bodies are characterized by a few physical properties, which are as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 物体具有一些物理属性，如下所示：
- en: '**Shape**: This represents a circle in DroidBlaster, although a polygon or
    box could also be used.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**形状**: 这代表DroidBlaster中的一个圆，尽管也可以使用多边形或矩形。'
- en: '**Density**: This is expressed in kg/m2 to compute body mass depending on its
    shape and size. Value should be greater or equal to `0.0`. A bowling ball has
    a bigger density than a soccer ball.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密度**: 这以kg/m2表示，用于根据其形状和大小计算物体质量。值应大于或等于`0.0`。保龄球的密度比足球大。'
- en: '**Friction**: This indicates how much a body slides on another (for example,
    a car on a road or on an icy path). Values are typically in the range `0.0` to
    `1.0`, where `0.0` implies no friction and `1.0` implies strong friction.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摩擦**: 这表示一个物体在另一个物体上滑动的程度（例如，车在道路上或冰面上）。值通常在`0.0`到`1.0`的范围内，其中`0.0`表示无摩擦，`1.0`表示强摩擦。'
- en: '**Restitution**: This indicates how much a body reacts to a collision, for
    example, a bouncing ball. Value `0.0` means no restitution and `1.0` means full
    restitution.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恢复**: 这表示一个物体对碰撞的反应程度，例如，一个弹跳的球。数值`0.0`表示没有恢复，`1.0`表示完全恢复。'
- en: 'When running, bodies are subject to the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，物体受到以下影响：
- en: '**Forces**: This makes bodies move linearly.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**力**: 这使物体线性移动。'
- en: '**Torques**: This represents rotational force applied on a body.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扭矩**: 这代表施加在物体上的旋转力。'
- en: '**Damping**: This is similar to friction, although it does not only occur when
    a body is in contact with another. Consider it as the effect of drag slowing down
    a body.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻尼**: 这类似于摩擦，尽管它不仅发生在物体与另一个物体接触时。可以将其视为减慢物体速度的阻力效应。'
- en: Box2D is tuned for worlds containing objects at a scale from `0.1` to `10` (unit
    in meters). When used outside this range, again, numerical approximation can make
    simulation inaccurate. Thus, it is very necessary to scale coordinates from the
    Box2D referential, where objects should to be kept in the (rough) range [`0.1`,
    `10`], and to the game, or directly to the graphics referential. This is why we
    have defined `SCALE_FACTOR` to scale coordinate transformation.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D被调整为包含在`0.1`到`10`（以米为单位）范围内的世界。当超出这个范围时，数值近似可能会使模拟不准确。因此，非常有必要将坐标从Box2D参考系的范围[`0.1`,
    `10`]转换到游戏中，或者直接到图形参考系。这就是为什么我们定义了`SCALE_FACTOR`来进行坐标转换的缘故。
- en: More on collision detection
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多关于碰撞检测的内容
- en: Several ways of detecting and handling collisions exist in Box2D. The most basic
    one consists of checking all contacts stored in the world or in a body after they
    are updated. However, this can result in missed contacts that happen surreptitiously
    during Box2D internal iterations.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D中存在几种检测和处理碰撞的方法。最基本的方法是在更新后检查存储在世界或物体中的所有接触。然而，这可能导致在Box2D内部迭代期间偷偷发生的接触被忽略。
- en: 'A better way we have seen to detect contacts is the `b2ContactListener`, which
    can be registered on the world object. The following four callbacks can be overridden:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到检测接触的更好方法是`b2ContactListener`，它可以在世界对象上注册。以下四个回调可以被重写：
- en: '`BeginContact (b2Contact)`: This detects when two bodies enter in collision.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeginContact (b2Contact)`: 这检测到两个物体发生碰撞时。'
- en: '`EndContact(b2Contact)`: This is a counterpart of `BeginContact()`, which indicates
    when bodies are not in collision any more. A call to `BeginContact()` is always
    followed by a matching `EndContact()`.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EndContact(b2Contact)`: 这是`BeginContact()`的对应部分，表示当物体不再发生碰撞时。对`BeginContact()`的调用总是后面跟着匹配的`EndContact()`。'
- en: '`PreSolve (b2Contact, b2Manifold)`: This is called after a collision is detected
    but before collision resolution, that is, before impulse resulting from the collision
    is computed. The `b2Manifold` structure holds information about contact points,
    normals, and so on in a single place.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PreSolve (b2Contact, b2Manifold)`: 这是在检测到碰撞但在碰撞解决之前（即在计算碰撞产生的冲量之前）调用的。`b2Manifold`结构将接触点、法线等信息集中在一个地方。'
- en: '`PostSolve(b2Contact, b2ContactImpulse)`: This is called after actual impulse
    (that is, physical reaction) has been computed by Box2D.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostSolve(b2Contact, b2ContactImpulse)`: 这是在Box2D计算实际冲量（即物理反应）之后调用的。'
- en: The first two callbacks are interesting to trigger game logic (for example,
    entity destruction). The last two are interesting to alter physics simulation
    (more specifically to ignore some collisions by *disabling* a contact) while it
    is being computed, or to get more accurate details about it. For instance, use
    `PreSolve()` to create a one-sided platform to which an entity collides only when
    it falls from above (not when it jumps from below). Use `PostSolve()` to detect
    collision strength and calculate damages accordingly.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个回调对于触发游戏逻辑（例如，实体销毁）是有趣的。最后两个对于改变物理模拟（更具体地说是通过*禁用*接触来忽略一些碰撞）在计算时是有趣的，或者为了获得更准确的细节。例如，使用`PreSolve()`创建一个单侧平台，只有当实体从上方掉下时才会发生碰撞（而不是当它从下方跳跃时）。使用`PostSolve()`来检测碰撞强度并相应地计算损坏。
- en: The `PreSolve()` and `PostSolve()` methods can be called several times between
    `BeginContact()` and `EndContact()`, which can be called themselves from zero
    to several times during one world update. A contact can begin during one simulation
    step and terminate after several steps. In that case, event-solving callbacks
    occur continuously during "in-between" steps. As many collisions can occur while
    stepping simulation. Thus, callbacks can be called a lot of times and should be
    as efficient as possible.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreSolve()`和`PostSolve()`方法可以在`BeginContact()`和`EndContact()`之间被多次调用，这些方法本身在一个世界更新期间可以被调用零次到多次。一个接触可以在一个模拟步骤中开始，并在几个步骤后终止。在这种情况下，“中间”步骤中会连续发生事件解决回调。在模拟步骤中可能发生许多碰撞。因此，回调可能会被多次调用，应尽可能高效。'
- en: When analyzing collisions inside the `BeginContact()` callback, we buffered
    a collision flag. This is necessary because Box2D reuses the `b2Contact` parameter
    passed when a callback is triggered. In addition, as these callbacks are called
    while simulation is computed, physics bodies cannot be destroyed at that instant,
    only after simulation stepping is over. Thus, it is highly advised to copy any
    information gathered there for `postprocessing` (for example, to destroy entities).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BeginContact()`回调中分析碰撞时，我们缓冲了一个碰撞标志。这是必要的，因为Box2D在触发回调时重用了传递的`b2Contact`参数。此外，由于这些回调在计算模拟时被调用，物理物体不能在那一刻被销毁，只能在模拟步骤结束后才能销毁。因此，强烈建议复制在那里收集到的任何信息进行`后处理`（例如，销毁实体）。
- en: Collision modes and filtering
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞模式和过滤
- en: 'I would like to point out that Box2D offers a so-called `bullet` mode that
    can be activated on a body definition using corresponding Boolean member:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我想指出，Box2D提供了所谓的`bullet`模式，可以在身体定义中使用相应的布尔成员来激活：
- en: '[PRE47]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The bullet mode is necessary for fast moving objects like bullets! By default,
    Box2D uses **Discrete Collision Detection**, which considers bodies at their final
    position for collision detection, missing any body located between initial and
    final positions. However, for a fast moving body, the whole path followed should
    be considered. This is more formally called **Continuous Collision Detection**
    (**CCD**). Obviously, CCD is expensive and should be used with parsimony. Please
    refer to the following figure:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 子弹模式对于像子弹这样的快速移动物体是必要的！默认情况下，Box2D使用**离散碰撞检测**，它考虑物体在其最终位置进行碰撞检测，错过了位于初始位置和最终位置之间的任何物体。然而，对于快速移动的物体，应考虑整个路径。这更正式地称为**连续碰撞检测**（**CCD**）。显然，CCD是昂贵的，应该谨慎使用。请参考下图：
- en: '![Collision modes and filtering](img/9645_09_02.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞模式和过滤](img/9645_09_02.jpg)'
- en: 'We sometimes want to detect when bodies overlap without generating collisions
    (like a car reaching the finish line): this is called a sensor. A sensor can be
    easily set by setting the `isSensor` Boolean member to `true` in the fixture as
    follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望检测物体重叠而不产生碰撞（比如汽车到达终点线）：这就是传感器。传感器可以通过在fixture中将`isSensor`布尔成员设置为`true`来轻松设置，如下所示：
- en: '[PRE48]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: A sensor can be queried with a listener through `BeginContact()` and `EndContact()`
    or by using the `IsTouching()` shortcut on a `b2Contact` class.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器可以通过监听器通过`BeginContact()`和`EndContact()`来查询，或者通过在`b2Contact`类上使用`IsTouching()`快捷方式来查询。
- en: Another important aspect of collision is not colliding or, more precisely, filtering
    collisions. A kind of filtering can be performed in `PreSolve()` by disabling
    contacts. This is the most flexible and powerful solution, but also the most complex.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞的另一个重要方面是不发生碰撞，更准确地说是过滤碰撞。可以在`PreSolve()`中通过禁用接触执行一种过滤。这是最灵活和强大的解决方案，但也是最复杂的。
- en: 'But, as we have seen it, filtering can be performed in a more simple way by
    using a categories and masks technique. Each body is assigned one or more category
    (each being represented by one bit in a short integer, the `categoryBits` member)
    and a mask describing categories of the body they can collide with (each filtered
    category being represented by a bit set to 0, the `maskBits` member), as shown
    in the following figure:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如我们所看到的，可以通过使用类别和掩码技术以更简单的方式执行过滤。每个物体被分配一个或多个类别（每个类别在短整数中由一个位表示，`categoryBits`成员）和一个描述它们可以与之发生碰撞的物体类别的掩码（每个过滤类别由设置为0的位表示，`maskBits`成员），如下图所示：
- en: '![Collision modes and filtering](img/9645_09_04.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞模式和过滤](img/9645_09_04.jpg)'
- en: In the preceding figure, `Body A` is in categories `1` and `3`, and collides
    with bodies in categories `2` and `4`, which is the case for this poor `Body B`,
    unless its mask filters collision with `Body A` categories (that is, `1` and `3`).
    In other words, both bodies A and B must agree to collide!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，`Body A`属于类别`1`和`3`，并与类别`2`和`4`的物体发生碰撞，这是这个可怜的`Body B`的情况，除非它的掩码过滤与`Body
    A`类别（即`1`和`3`）的碰撞。换句话说，A和B两个物体必须同意碰撞！
- en: 'Box2D also has a notion of collision groups. A body has a collision group set
    to any of the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D还有碰撞组的概念。一个物体的碰撞组设置为以下任意之一：
- en: '**Positive integer**: This means others bodies with the same collision group
    value can collide'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正整数**：这意味着具有相同碰撞组值的其他物体可以发生碰撞'
- en: '**Negative integer**: This means others bodies with the same collision group
    value are filtered'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负整数**：这意味着具有相同碰撞组值的其他物体被过滤'
- en: Using collision groups could have also been a solution to avoid collision between
    asteroids in DroidBlaster, although it is less flexible than categories and masks.
    Note that groups are filtered before categories.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 使用碰撞组也可以是避免DroidBlaster中小行星碰撞的解决方案，尽管它比类别和掩码更不灵活。请注意，在类别之前对组进行过滤。
- en: A more flexible solution than category and group filters is the `b2ContactFilter`
    class. This class has a `ShouldCollide(b2Fixture, b2Fixture)` method that you
    can customize to perform your own filtering. Actually, category/group filtering
    are themselves implemented that way.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 比类别和组过滤更灵活的解决方案是`b2ContactFilter`类。这个类有一个`ShouldCollide(b2Fixture, b2Fixture)`方法，您可以自定义以执行自己的过滤。实际上，类别/组过滤就是这样实现的。
- en: Going further with Box2D
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步了解Box2D
- en: 'This short introduction to Box2D gives you only an overview of what Box2D is
    capable of! The following non-exhaustive list has been left in the shadow:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对Box2D的简短介绍只是让你了解Box2D的能力！以下非详尽的列表已被忽略：
- en: Joints to link two bodies together
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接两个物体的关节
- en: '**Raycasting** to query a physics world (for example, which location is a gun
    pointing toward)'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Raycasting**用于查询物理世界（例如，枪口指向哪个位置）'
- en: 'Contact properties: normals, impulses, manifolds, and so on'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接触属性：法线、冲量、流形等
- en: Tip
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Box2D has now a little brother called **LiquidFun**, which is used to simulate
    fluids. You can download and see it in action at [http://google.github.io/liquidfun/](http://google.github.io/liquidfun/).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D现在有一个名为**LiquidFun**的小弟，用于模拟流体。您可以在[http://google.github.io/liquidfun/](http://google.github.io/liquidfun/)上下载并查看其运行情况。
- en: Box2D has a really nice documentation with useful information that can be found
    at [http://www.box2d.org/manual.html](http://www.box2d.org/manual.html). Moreover,
    Box2D is packaged with a test bed directory (in `Box2D/Testbed/Tests`) featuring
    many use cases. Have a look at them to get a better understanding of its capabilities.
    Because physics simulations can sometimes be rather tricky, I also encourage you
    to visit Box2D forum, which is quite active, at [http://www.box2d.org/forum/](http://www.box2d.org/forum/).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D有一个非常好的文档，其中包含有用的信息，可以在[http://www.box2d.org/manual.html](http://www.box2d.org/manual.html)找到。此外，Box2D还打包了一个测试床目录（在`Box2D/Testbed/Tests`中），其中包含许多用例。看一看它们，以更好地了解其功能。因为物理模拟有时可能相当棘手，我还鼓励您访问Box2D论坛，该论坛非常活跃，网址为[http://www.box2d.org/forum/](http://www.box2d.org/forum/)。
- en: Prebuilding Boost on Android
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android上预构建Boost
- en: If STL is the most common framework among C++ programs, Boost probably comes
    second. A real Swiss army knife! This toolkit contains a profusion of utilities
    to handle most common needs, and even more.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果STL是C++程序中最常见的框架，那么Boost可能是第二。一个真正的瑞士军刀！这个工具包含了大量的实用程序，以处理大多数常见需求，甚至更多。
- en: 'Most Boost features are provided as header-only code, which means that we do
    not need to compile it. Including headers is enough of an advantage to use it.
    This is the case of the most popular features of Boost: **Smart Pointers**, a
    reference-counting pointer class that handles memory allocation and de-allocation
    automatically. They avoid most memory leaks and pointer misuse for almost free.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Boost功能都是作为仅头文件的代码提供的，这意味着我们不需要编译它。包含头文件足以使用它的优势。这是Boost最受欢迎的功能的情况：**智能指针**，一个处理内存分配和自动释放的引用计数指针类。它们几乎免费地避免了大多数内存泄漏和指针误用。
- en: However, a few parts of Boost require compilation first, such as the threading
    or the unit test library. We are now going to see how to build them with the Android
    NDK and compile a unit test executable.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Boost的一些部分需要首先进行编译，例如线程或单元测试库。我们现在将看到如何使用Android NDK构建它们并编译单元测试可执行文件。
- en: Note
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Resulting project is provided with this book under the name `DroidBlaster_Part18`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目在本书中以`DroidBlaster_Part18`的名称提供。
- en: Time for action – prebuilding Boost static library
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行操作-预构建Boost静态库
- en: 'Let''s prebuild Boost for Android as a static library with the following steps:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤为Android预构建Boost作为静态库：
- en: Download Boost from [http://www.boost.org/](http://www.boost.org/) (Version
    1.55.0, in this book). Unzip the archive into `${ANDROID_NDK}/sources`. Name the
    directory `boost`.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://www.boost.org/](http://www.boost.org/)下载Boost（本书中的版本1.55.0）。将存档解压缩到`${ANDROID_NDK}/sources`。将目录命名为`boost`。
- en: Open a command line window and go to the `boost` directory. Launch `bootstrap.bat`
    on Windows or .`/bootstrap.sh` on Linux and Mac OS X to build **b2**. This program,
    previously named **BJam**, is a custom building tool similar to **Make**.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 打开命令行窗口并转到`boost`目录。在Windows上启动`bootstrap.bat`，在Linux和Mac OS X上启动`./bootstrap.sh`来构建**b2**。这个程序，以前被称为**BJam**，是一个类似于**Make**的自定义构建工具。
- en: Note
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Boost 1.55.0 archive is provided with this book in the `Libraries/boost` directory.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Boost 1.55.0存档与本书一起提供在`Libraries/boost`目录中。
- en: 'Change the NDK build command in DroidBlaster to generate verbose compilation
    logs. To do so, in Eclipse **Project properties**, navigate to the **C/C++ Build**
    section. There, you should see the following build command: `ndk-build NDK_DEBUG=1`.
    Change it to `build NDK_DEBUG=0 V=1` to compile in release mode with verbose logs.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 更改DroidBlaster中的NDK构建命令以生成详细的编译日志。要这样做，在Eclipse的**项目属性**中，导航到**C/C++构建**部分。在那里，您应该看到以下构建命令：`ndk-build
    NDK_DEBUG=1`。将其更改为`build NDK_DEBUG=0 V=1`以在发布模式下进行编译并生成详细日志。
- en: Rebuild DroidBlaster (you might need to clean your project first). If you look,
    for example, at the following compilation extract, you should see some logs similar
    to the extract below. This log, although barely readable, gives all the information
    about the commands run to build DroidBlaster.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建DroidBlaster（您可能需要先清理项目）。例如，如果您查看以下编译摘录，您应该看到类似于下面摘录的一些日志。尽管这个日志几乎无法阅读，但它提供了构建DroidBlaster所需的所有命令的信息。
- en: The toolchain used to build DroidBlaster (`arm-linux-androideabi-4.6`)
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于构建DroidBlaster的工具链（`arm-linux-androideabi-4.6`）
- en: The system on which DroidBlaster is built (`linux-x86_64`)
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DroidBlaster构建的系统（`linux-x86_64`）
- en: The compiler executable (`arm-linux-androideabi-g++`)
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器可执行文件（`arm-linux-androideabi-g++`）
- en: The archiver executable (`arm-linux-androideabi-ar`)
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可执行的存档程序（`arm-linux-androideabi-ar`）
- en: Also all the compilation flags passed to them (here for ARM processors)
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有传递给它们的所有编译标志（这里是针对ARM处理器的）
- en: 'We can use the following as an inspiration source to determine `Boost` compilation
    flags (in this flag soup!):'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将以下内容作为确定`Boost`编译标志的灵感来源（在这个标志汤中！）：
- en: '[PRE49]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the `boost` directory, open the `tools/build/v2/user-config.jam` file. This
    file, like its name suggests, is a configuration file that can be set up to customize
    `Boost` compilation. Initial content contains only comments and can be erased.
    Start including the following content:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`boost`目录中，打开`tools/build/v2/user-config.jam`文件。这个文件，正如其名称所示，是一个配置文件，可以设置为自定义`Boost`编译。初始内容只包含注释，可以擦除。开始包括以下内容：
- en: '[PRE50]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Compilation is performed statically. **BZip** is deactivated because it is
    unavailable, by default, on Android (we could however compile it separately):'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译是静态执行的。**BZip**被停用，因为默认情况下在Android上不可用（但我们可以单独编译它）：
- en: '[PRE51]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Retrieve the `android_ndk` environment variable which points to the NDK location
    on disk.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索指向磁盘上NDK位置的`android_ndk`环境变量。
- en: Declare what we could call a "configuration" `android4.6_armeabi`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 声明我们可以称之为“配置”的`android4.6_armeabi`。
- en: Then, reconfigure Boost to use the NDK ARM GCC toolchain (`g++`, `ar`, and `ranlib`)
    in static mode, the archiver being in charge of creating the static library. We
    can use the information found in the log in step 2 to fill their respective paths.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新配置Boost以使用NDK ARM GCC工具链（`g++`，`ar`和`ranlib`）以静态模式进行编译，存档程序负责创建静态库。我们可以使用步骤2中找到的信息来填写它们各自的路径。
- en: 'The `sysroot` directive indicates which Android API release to compile and
    link against. The specified directory, located in the NDK, contains `include`
    files and libraries specific to this release, as shown in the following code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`sysroot`指令指示要编译和链接的Android API版本。指定的目录位于NDK中，包含特定于此版本的`include`文件和库，如下面的代码所示：'
- en: '[PRE52]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Boost needs exceptions and RTTI. Enable them with the `–fexceptions` and `–frtti`
    flags, as shown in the following code:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Boost需要异常和RTTI。使用`-fexceptions`和`-frtti`标志启用它们，如下面的代码所示：
- en: '[PRE53]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'A few options have to be defined to tweak `Boost` compilation. This is where
    we can take inspiration from the compilation flags discovered in step 2, such
    as the following:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须定义一些选项来调整`Boost`的编译。这是我们可以从步骤2中发现的编译标志中汲取灵感的地方，例如以下内容：
- en: '`-march=armv5te` to specify the target platform'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-march=armv5te`以指定目标平台'
- en: '`-mthumb`, which indicates that generated code should use thumb instructions
    (`-marm` could also be used to use ARM instructions instead)'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-mthumb`，表示生成的代码应使用Thumb指令（`-marm`也可以用于使用ARM指令）'
- en: '`-0s` to enable compiler optimizations'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-0s`以启用编译器优化'
- en: '`-DNDEBUG` to request compilation in release mode'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-DNDEBUG`以请求在发布模式下进行编译'
- en: 'Also include or tweak additional ones, such as the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 还包括或调整其他内容，例如以下内容：
- en: -`D__arm__`, `-D__ARM_ARCH_5__`, and so on, which help to determine the target
    platform from code
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -`D__arm__`，`-D__ARM_ARCH_5__`等，有助于从代码中确定目标平台
- en: '`-DANDROID`, `-D__ANDROID__`, which help to determine the target OS'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-DANDROID`，`-D__ANDROID__`，有助于确定目标操作系统'
- en: '`-DBOOST_ASIO_DISABLE_STD_ATOMIC` to disable the use `std::atomic`, which is
    buggy on Android (something that can be learnt only through (bad) "experience"…).'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-DBOOST_ASIO_DISABLE_STD_ATOMIC`以禁用使用在Android上存在错误的`std::atomic`（这只能通过（糟糕的）“经验”学到）。'
- en: '[PRE54]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: From a terminal pointing located in the boost directory, launch the compilation
    using the following command line. We need to exclude the **Python** module, which
    requires additional libraries not available on the NDK by default.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从指向boost目录的终端中，使用以下命令行启动编译。我们需要排除**Python**模块，因为默认情况下在NDK上不可用。
- en: '[PRE55]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Final static libraries are generated in `android-armeabi/lib/`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的静态库生成在`android-armeabi/lib/`中。
- en: Repeat the same steps for the ArmV7 and X86 platforms, creating a new configuration
    for each of them. The staging directory must be `armeabi-v7a` for ArmV7 and `android-x86`
    for X86.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 对ArmV7和X86平台重复相同的步骤，为每个平台创建一个新的配置。ArmV7的暂存目录必须是`armeabi-v7a`，X86的暂存目录必须是`android-x86`。
- en: Note
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Final `user-config.jam` is provided with this book in the `Libraries/boost`
    directory.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的`Libraries/boost`目录中提供了最终的`user-config.jam`。
- en: '*What just happened?*'
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We have customized the Boost configuration to use the raw Android GCC toolchain
    as a standalone compiler (that is, without the NDK wrappers). We have declared
    various flags to adapt compilation to Android target platforms. Then, we have
    built Boost manually using its dedicated building tool `b2`. Now, every time Boost
    is updated or modified, code has to be manually compiled again with `b2`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定制了Boost配置，使用原始的Android GCC工具链作为独立编译器（即，没有NDK包装）。我们已经声明了各种标志，以适应Android目标平台的编译。然后，我们使用其专用构建工具`b2`手动构建了Boost。现在，每次更新或修改Boost时，都必须使用`b2`手动重新编译代码。
- en: We have also forced NDK-Build to generate verbose logs with the `V=1` argument.
    This is helpful to either troubleshoot compilation issues or to get feedback on
    what and how NDK-Build is compiling.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还强制NDK-Build生成带有`V=1`参数的详细日志。这对于排除编译问题或获取NDK-Build正在编译的内容和方式的反馈非常有帮助。
- en: 'Finally, we have enabled release compilation mode, that is, with code optimizations,
    by switching `NDK_DEBUG` to `0`. This could have also been done by setting `APP_OPTIM
    := release` in `jni/Application.mk`. There are five main optimization levels in
    GCC, and they are as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经启用了发布编译模式，即通过将`NDK_DEBUG`切换为`0`来进行代码优化。这也可以通过在`jni/Application.mk`中设置`APP_OPTIM
    := release`来完成。GCC有五个主要的优化级别，它们如下：
- en: '**-O0**: This disables any optimization. This is automatically set by the NDK
    when `APP_OPTIM` is set to `debug` (more about this in the last part about Makefiles
    in this chapter).'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -O0：这禁用任何优化。当`APP_OPTIM`设置为`debug`时，NDK会自动设置这个（关于这一点，本章的最后一部分关于Makefiles中有更多信息）。
- en: '**-O1**: This allows basic optimizations without increasing compilation time
    too much. These optimizations do not require any speed-space tradeoffs, which
    mean that they produce faster code without increasing executable size.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -O1：这允许进行基本优化，而不会增加太多编译时间。这些优化不需要任何速度-空间的权衡，这意味着它们可以生成更快的代码，而不会增加可执行文件的大小。
- en: '**-O2**: This allows advanced optimization (including `-O1`), but at the expense
    of compilation time. Like `–O1`, these optimizations do not require speed-space
    tradeoffs.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -O2：这允许高级优化（包括`-O1`），但以编译时间为代价。与`-O1`一样，这些优化不需要速度-空间的权衡。
- en: '**-O3**: This performs aggressive optimizations (including `-O2`), which can
    increase executable size, such as **function inlining**. This is generally profitable
    but, sometimes, counterproductive (for example, increasing memory usage can also
    increase cache misses).'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -O3：这执行激进的优化（包括`-O2`），可以增加可执行文件的大小，例如**函数内联**。这通常是有利可图的，但有时会适得其反（例如，增加内存使用量也可能增加缓存未命中）。
- en: '**-Os**: This optimizes compiled code size (a subset of `–O2`) before speed.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -Os：这优化了编译后的代码大小（`-O2`的一个子集），而不是速度。
- en: Although `-Os` or `–O2` is generally the way to go for release mode, `-O3` can
    also be considered for performance-critical code. The `-0x` flags being shortcuts
    for the various GCC optimization flags, enabling `–O2` and appending additional
    "fine-grain" flags (for example, `-finline-functions`), are an option too. Whatever
    option you choose, the best way to find the best choice is simply by performing
    benchmarking! To get more information about the numerous GCC optimization options,
    have a look at [http://gcc.gnu.org/](http://gcc.gnu.org/).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`-Os`或`-O2`通常是发布模式的选择，但对于性能关键代码，也可以考虑`-O3`。`-Ox`标志是各种GCC优化标志的快捷方式，启用`-O2`并附加额外的“细粒度”标志（例如，`-finline-functions`），也是一个选择。无论您选择哪个选项，找到最佳选择的最佳方法就是进行基准测试！要获取有关众多GCC优化选项的更多信息，请查看[http://gcc.gnu.org/](http://gcc.gnu.org/)。
- en: Now that the Boost module is prebuilt, we can embed any of its libraries in
    our application.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Boost模块已经预构建，我们可以将其任何库嵌入到我们的应用程序中。
- en: Time for action – compiling an executable linked to Boost
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-编译链接到Boost的可执行文件
- en: 'Let''s use the Boost unit test library to build our own unit test executable
    through the following steps:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Boost单元测试库通过以下步骤构建我们自己的单元测试可执行文件：
- en: 'Still in the `boost` directory, create a new `Android.mk` file to declare the
    newly prebuilt libraries as Android modules and make them available to NDK applications.
    This file needs to contain one module declaration per library. For example, define
    one module `boost_unit_test_framework`:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`boost`目录中，创建一个新的`Android.mk`文件，声明新预构建的库为Android模块，并使它们可用于NDK应用程序。该文件需要包含每个库的一个模块声明。例如，定义一个模块`boost_unit_test_framework`：
- en: '`LOCAL_SRC_FILES` reference the static library `libboost_unit_test_framework.a`
    we have built with b2.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_SRC_FILES`引用我们使用b2构建的静态库`libboost_unit_test_framework.a`。'
- en: Use the `$(TARGET_ARCH_ABI)` variable to determine the right path to use, which
    depends on the target platform. Its value can be `armeabi`, `armeabi-v7a`, or
    `x86`. If you compile DroidBlaster for X86, the NDK will look for `libboost_unit_test_framework.a`
    in `androidx86/lib`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`$(TARGET_ARCH_ABI)`变量确定要使用的正确路径，这取决于目标平台。其值可以是`armeabi`，`armeabi-v7a`或`x86`。如果为X86编译DroidBlaster，则NDK将在`androidx86/lib`中查找`libboost_unit_test_framework.a`。
- en: '`LOCAL_EXPORT_C_INCLUDES` automatically appends boost root directory to the
    include file directory list of the including module.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_EXPORT_C_INCLUDES`自动将boost根目录附加到包含模块的包含文件目录列表中。'
- en: 'Indicate that this module is a prebuilt library with the `$(PREBUILT_STATIC_LIBRARY)`
    directive:'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`$(PREBUILT_STATIC_LIBRARY)`指令指示该模块是一个预构建的库：
- en: '[PRE56]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: More modules can be declared in the same file with the same set of lines (for
    example, `boost_thread`).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在同一文件中使用相同的行集声明更多模块（例如`boost_thread`）。
- en: Note
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Final `user-config.jam` is provided with this book in the `Libraries/boost`
    directory.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的`user-config.jam`文件在`Libraries/boost`目录中提供。
- en: 'Go back to the `DroidBlaster` project and create a new directory `test` containing
    the unit test file `test/Test.cpp`. Write a test to check the behavior, for example,
    of the `TimeManager`, as shown in the following code:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`DroidBlaster`项目，并创建一个名为`test`的新目录，其中包含单元测试文件`test/Test.cpp`。编写一个测试来检查行为，例如`TimeManager`，如下面的代码所示：
- en: '[PRE57]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To include Boost in an application, we need to link it with an STL implementation
    supporting exceptions and RTTI. Enable them globally in the `Application.mk` file,
    as shown in the following code:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在应用程序中包含Boost，我们需要将其与支持异常和RTTI的STL实现进行链接。在`Application.mk`文件中全局启用它们，如下面的代码所示：
- en: '[PRE58]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Finally, open DroidBlaster `jni/Android.mk` and create a second module named
    `DroidBlaster_test` before the `import-module` section. This module compiles the
    additional `test/Test.cpp` test file and must be linked to the Boost unit test
    library. Build this module as an executable, and not a shared library, with `$(BUILD_EXECUTABLE)`.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开DroidBlaster `jni/Android.mk`并在`import-module`部分之前创建一个名为`DroidBlaster_test`的第二个模块。此模块编译附加的`test/Test.cpp`测试文件，并必须链接到Boost单元测试库。使用`$(BUILD_EXECUTABLE)`将此模块构建为可执行文件，而不是共享库。
- en: 'Finally, import the `Boost` module itself in the import-module section, as
    shown in the following code:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在import-module部分导入`Boost`模块本身，如下面的代码所示：
- en: '[PRE59]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Build the project. If you look into the `libs` folder, you should see one `droidblaster_test`
    file in addition to the shared library. This is an executable file that we can
    run on an emulator or a rooted device (given you have the right to deploy and
    change permission on a file). Deploy this file and run it (here on an Arm V7 emulator
    instance):'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目。如果您查看`libs`文件夹，除了共享库之外，您应该看到一个`droidblaster_test`文件。这是一个可执行文件，我们可以在模拟器或已root的设备上运行（假设您有权部署和更改文件的权限）。部署此文件并运行它（在Arm
    V7模拟器实例上）：
- en: '[PRE60]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '![Time for action – compiling an executable linked to Boost](img/9645_09_01.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间-编译链接到Boost的可执行文件](img/9645_09_01.jpg)'
- en: '*What just happened?*'
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We have created a fully native executable using a Boost prebuilt module and
    can run it on Android. Boost prebuilt static libraries have been "published" from
    the Boost `Android.mk` module file in the `Boost` directory.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用Boost预构建模块创建了一个完全本地的可执行文件，并且可以在Android上运行它。Boost预构建的静态库已经从Boost `Android.mk`模块文件中的`Boost`目录中"发布"出来。
- en: 'Indeed, there exist four main ways to build a native library. We have already
    seen `BUILD_STATIC_LIBRARY` and `BUILD_SHARED_LIBRARY` in the Box2D part. Two
    more options coexist, which are as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，存在四种构建本地库的主要方法。我们已经在Box2D部分看到了`BUILD_STATIC_LIBRARY`和`BUILD_SHARED_LIBRARY`。还有两种选择，分别是：
- en: '`PREBUILT_STATIC_LIBRARY` to use an existing (that is, prebuilt) binary static
    library'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PREBUILT_STATIC_LIBRARY`用于使用现有的（即预构建的）二进制静态库'
- en: '`PREBUILT_SHARED_LIBRARY` to use an existing binary shared library'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PREBUILT_SHARED_LIBRARY`用于使用现有的二进制共享库'
- en: These directives indicate that libraries are ready for linking.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令表明库已准备好进行链接。
- en: 'Inside the main module file, as we have seen for Box2D, submodules linked need
    to be listed in:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在主模块文件中，就像我们在Box2D中看到的那样，需要列出链接的子模块：
- en: '`LOCAL_SHARED_LIBRARIES` for shared libraries'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地共享库用于共享库
- en: '`LOCAL_STATIC_LIBRARIES` for static libraries'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地静态库用于静态库
- en: The same rule applies whether the library is prebuilt or not. Modules, whether
    they are static, shared, prebuilt, or built on-demand, must be imported in the
    final main module using the NDK `import-module` directive.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 无论库是预构建的还是不是，都适用相同的规则。模块，无论它们是静态的、共享的、预构建的还是按需构建的，都必须在最终的主模块中使用NDK的`import-module`指令导入。
- en: When a prebuilt library is linked to a main module, source files are not necessary.
    Include files are obviously still required. Thus, prebuilt libraries are an appropriate
    choice if you want to provide a library to third parties without releasing sources.
    On the other hand, on-demand compilation allows tweaking compilation flags on
    all included libraries (such as optimization flags, the ARM mode, and so on) from
    your main `Application.mk` project file.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当预构建库链接到主模块时，源文件是不必要的。显然，仍然需要包含文件。因此，如果您想向第三方提供库而不发布源代码，预构建库是一个合适的选择。另一方面，按需编译允许从主`Application.mk`项目文件上调整所有包含的库的编译标志（如优化标志、ARM模式等）。
- en: To properly link with Boost, we have also enabled exceptions and RTTI on the
    whole project. Exceptions and RTTI are activated very easily by appending `-fexceptions`
    and `-frtti` to either the `APP_CPPFLAGS` directive in the `Application.mk` file
    or the `LOCAL_CPPFLAGS` file of the concerned library. By default, Android compiles
    with `-fno-exceptions` and `-fno-rtti` flags.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确地与Boost链接，我们还在整个项目上启用了异常和RTTI。异常和RTTI很容易通过将`-fexceptions`和`-frtti`附加到`Application.mk`文件中的`APP_CPPFLAGS`指令或相关库的`LOCAL_CPPFLAGS`文件来激活。默认情况下，Android使用`-fno-exceptions`和`-fno-rtti`标志进行编译。
- en: Indeed, exceptions have the reputation of making the compiled code bigger and
    less efficient. They prevent the compiler from performing some clever optimizations.
    However, whether exceptions are worse than error checking, or even no check at
    all, is a highly debatable question. In fact, Google's engineers dropped them
    in the first releases because GCC 3.x generated a poor exception handling code
    for ARM processors. However, the build chain now uses GCC 4.x, which does not
    suffer from this flaw. Compared to manual error checking and handling of exceptional
    cases, this penalty might not be so significant most of the time. Thus, the choice
    of exceptions is up to you (and your embedded libraries)!
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，异常被认为会使编译后的代码变得更大、效率更低。它们阻止编译器执行一些聪明的优化。然而，异常是否比错误检查更糟糕，甚至根本不检查，这是一个非常有争议的问题。事实上，谷歌的工程师在最初的版本中放弃了它们，因为GCC
    3.x为ARM处理器生成了糟糕的异常处理代码。然而，构建链现在使用的是GCC 4.x，它不受这个缺陷的影响。与手动错误检查和处理异常情况相比，这种惩罚在大多数情况下可能并不那么显著。因此，是否使用异常取决于您（和您的嵌入式库）！
- en: Tip
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Exception handling in C++ is not easy and imposes a strict discipline! They
    must be used strictly for exceptional cases and require carefully designed code.
    Have a look at the **Resource Acquisition Is Initialization** (**RAII**) idiom
    to properly handle them. For more information, have a look at [http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization](http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的异常处理并不容易，需要严格的纪律！它们必须严格用于特殊情况，并需要精心设计的代码。查看**资源获取即初始化**（**RAII**）习惯用法，以正确处理它们。有关更多信息，请查看[http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization](http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization)。
- en: Obviously, Boost provides much more interesting features than unit tests. Discover
    its full richness in its official documentation at [http://www.boost.org/doc/libs](http://www.boost.org/doc/libs).
    Beware, Boost is subject to regular breaking changes or bugs on Android since
    it is not very actively maintained and tested on that platform. Be prepared to
    investigate and fix problems directly in its code.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Boost提供的功能比单元测试更有趣。在官方文档[http://www.boost.org/doc/libs](http://www.boost.org/doc/libs)中发现其丰富的功能。注意，由于Boost在Android上没有得到很好的维护和测试，因此可能会经常出现破坏性的更改或错误。准备好直接在其代码中调查和解决问题。
- en: Now that we have seen in practice how to write module Makefiles, let's learn
    more about them.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在实践中看到了如何编写模块Makefile，让我们更多地了解它们。
- en: Mastering module Makefiles
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握模块Makefiles
- en: Android Makefiles are an essential piece of the NDK building process. Thus,
    to build and manage a project properly, it is important to understand the way
    they work.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: Android Makefiles是NDK构建过程中的重要组成部分。因此，为了正确构建和管理项目，了解它们的工作方式是很重要的。
- en: Makefile variables
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Makefile变量
- en: 'Compilation settings are defined through a set of predefined NDK variables.
    We have already seen the three most important ones: `LOCAL_PATH, LOCAL_MODULE`,
    and `LOCAL_SRC_FILES`, but many others exist. We can differentiate the following
    four types of variables, each with a different prefix:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 编译设置是通过一组预定义的NDK变量来定义的。我们已经看到了三个最重要的变量：`LOCAL_PATH, LOCAL_MODULE`和`LOCAL_SRC_FILES`，但还有许多其他变量。我们可以区分以下四种类型的变量，每种都有不同的前缀：
- en: '`LOCAL_` variables: These are dedicated to individual module compilation and
    are defined in `Android.mk` files.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_`变量：这些专门用于单个模块的编译，并在`Android.mk`文件中定义。'
- en: '`APP_` variables: These refer to application-wide options and are set in `Application.mk`.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_`变量：这些是指应用程序范围的选项，并在`Application.mk`中设置。'
- en: '`NDK_` variables: These are mainly internal variables that usually refer to
    environment variables (for example, `NDK_ROOT`, `NDK_APP_CFLAGS,` or `NDK_APP_CPPFLAGS`).
    There are two notable exceptions: `NDK_TOOLCHAIN_VERSION` and `NDK_APPLICATION_MK`.
    The latter can be passed to the NDK-Build in parameter to define a different `Application.mk`
    location.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NDK_`变量：这些主要是内部变量，通常指环境变量（例如`NDK_ROOT`，`NDK_APP_CFLAGS`或`NDK_APP_CPPFLAGS`）。有两个值得注意的例外：`NDK_TOOLCHAIN_VERSION`和`NDK_APPLICATION_MK`。后者可以传递给NDK-Build作为参数，以定义不同的`Application.mk`位置。'
- en: '`PRIVATE_` prefixed variables: These are for NDK internal use only.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRIVATE_`前缀变量：这些仅供NDK内部使用。'
- en: 'The following table contains a non-exhaustive list of `LOCAL` variables:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格包含了`LOCAL`变量的非穷尽列表：
- en: '| Variable | Description |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `LOCAL_PATH` | To specify the root location of source files. Must be defined
    at the beginning of the `Android.mk` file before `include $(CLEAR_VARS)`. |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '`LOCAL_PATH` | 用于指定源文件的根位置。必须在`Android.mk`文件的开头定义，然后是`include $(CLEAR_VARS)`。'
- en: '| `LOCAL_MODULE` | To define module name, it must be unique among all modules.
    |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '`LOCAL_MODULE` | 用于定义模块名称，必须在所有模块中是唯一的。'
- en: '| `LOCAL_MODULE_FILENAME` | To override default name of the compiled module,
    which is:`- lib<module name>.so` for shared libraries.`- lib<module name>.a` for
    static libraries.No custom file extensions can be specified so that `.so` or`.a`
    remains appended. |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '`LOCAL_MODULE_FILENAME` | 用于覆盖编译模块的默认名称，即：对于共享库是`- lib<module name>.so`，对于静态库是`-
    lib<module name>.a`。不能指定自定义文件扩展名，因此`.so`或`.a`仍然会被附加。'
- en: '| `LOCAL_SRC_FILES` | To define the list of source files to compile, each separated
    by a space and relative to `LOCAL_PATH`. |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '`LOCAL_SRC_FILES` | 用于定义要编译的源文件列表，每个文件都相对于`LOCAL_PATH`。'
- en: '| `LOCAL_C_INCLUDES` | To specify header file directories for both C and C++
    languages. The directory can be relative to the `${ANDROID_NDK}` directory, but
    unless you need to include a specific NDK file, you are advised to use absolute
    paths (which can be built from Makefile variables such as `$(LOCAL_PATH)`). |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '`LOCAL_C_INCLUDES` | 用于指定C和C++语言的头文件目录。该目录可以相对于`${ANDROID_NDK}`目录，但除非您需要包含特定的NDK文件，建议您使用绝对路径（可以从Makefile变量（如`$(LOCAL_PATH)`）构建）。'
- en: '| `LOCAL_CPP_EXTENSION` | To change default C++ file extension, that is, `.cpp`
    (for example, `.cc` or `.cxx`). A list of file extensions separated by a space,
    can be specified. Extensions are necessary for GCC to determine which file is
    related to which language. |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '`LOCAL_CPP_EXTENSION` | 用于更改默认的C++文件扩展名，即`.cpp`（例如`.cc`或`.cxx`）。可以指定由空格分隔的文件扩展名列表。扩展名对于GCC确定哪个文件与哪种语言相关是必要的。'
- en: '| `LOCAL_CFLAGS`, `LOCAL_CPPFLAGS`, `LOCAL_LDLIBS` | To specify any options,
    flags, or macro-definitions for compilation and linking. The first one works for
    both C and C++, the second one is for C++ only, and the last one is for the linker.
    |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| `LOCAL_CFLAGS`，`LOCAL_CPPFLAGS`，`LOCAL_LDLIBS` | 用于指定编译和链接的任何选项、标志或宏定义。第一个对C和C++都有效，第二个只对C++有效，最后一个是用于链接器的。
    |'
- en: '| `LOCAL_SHARED_LIBRARIES`, `LOCAL_STATIC_LIBRARIES` | To declare a dependency
    with other modules (not system libraries), shared and static modules, respectively.
    `LOCAL_SHARED_LIBRARIES` manage dependencies whereas `LOCAL_LDLIBS` should be
    used for declaring system libraries. |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| `LOCAL_SHARED_LIBRARIES`，`LOCAL_STATIC_LIBRARIES` | 用于声明与其他模块（而不是系统库）的依赖关系，分别是共享模块和静态模块。`LOCAL_SHARED_LIBRARIES`管理依赖关系，而`LOCAL_LDLIBS`应该用于声明系统库。
    |'
- en: '| `LOCAL_ARM_MODE`, `LOCAL_ARM_NEON`, `LOCAL_DISABLE_NO_EXECUTE`, `LOCAL_FILTER_ASM`
    | Advanced variables dealing with processors and assembler/binary code generation.
    They are not necessary for most programs. |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| `LOCAL_ARM_MODE`，`LOCAL_ARM_NEON`，`LOCAL_DISABLE_NO_EXECUTE`，`LOCAL_FILTER_ASM`
    | 处理处理器和汇编/二进制代码生成的高级变量。对于大多数程序来说，它们并不是必需的。'
- en: '| `LOCAL_EXPORT_C_INCLUDES`, `LOCAL_EXPORT_CFLAGS`, `LOCAL_EXPORT_CPPFLAGS`,
    `LOCAL_EXPORT_LDLIBS` | To define additional options or flags in import modules
    that should be appended to client module options. For example, if a module A defines`LOCAL_EXPORT_LDLIBS
    := -llog`because it needs an Android logging module. Then, module B, that depends
    on module A, will be automatically linked to `–llog`.`LOCAL_EXPORT_` variables
    are not used when compiling the module that exports them. If required, they also
    need to be specified in their `LOCAL` counterpart. |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| `LOCAL_EXPORT_C_INCLUDES`，`LOCAL_EXPORT_CFLAGS`，`LOCAL_EXPORT_CPPFLAGS`，`LOCAL_EXPORT_LDLIBS`
    | 定义应该附加到客户端模块选项的导入模块的其他选项或标志。例如，如果模块A定义了`LOCAL_EXPORT_LDLIBS := -llog`，因为它需要一个Android日志模块。然后，依赖于模块A的模块B将自动链接到`-llog`。在编译导出它们的模块时，`LOCAL_EXPORT_`变量不会被使用。如果需要，它们也需要在它们的`LOCAL`对应项中指定。'
- en: Documentation about these variables can be found at `${ANDROID_NDK}/docs/ANDROID-MK.html`.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些变量的文档可以在`${ANDROID_NDK}/docs/ANDROID-MK.html`找到。
- en: 'The following table contains a non-exhaustive list of the `APP` variables (all
    are optional):'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格包含了`APP`变量的非详尽列表（所有都是可选的）：
- en: '| Variable | Description |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `APP_PROJECT_PATH` | To specify the root of your application project. |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| `APP_PROJECT_PATH` | 指定应用程序项目的根目录。 |'
- en: '| `APP_MODULES` | The list of modules to compile with their identifier. Dependent
    modules are also included. This can be used, for example, to force the generation
    of a static library. |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| `APP_MODULES` | 要使用其标识符编译的模块列表。还包括依赖模块。例如，这可以用来强制生成静态库。 |'
- en: '| `APP_OPTIM` | Set to `release` or `debug` to adapt compilation settings to
    the type of build you want. When not specified explicitly, the NDK determines
    the build type using the debuggable flag in the AndroidManifest. |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| `APP_OPTIM` | 设置为`release`或`debug`以适应所需构建类型的编译设置。当未明确指定时，NDK将使用AndroidManifest中的debuggable标志确定构建类型。
    |'
- en: '| `APP_CFLAGS``APP_CPPFLAGS``APP_LDFLAGS` | To globally specify any options,
    flags, or macro-definitions for compilation and linking. The first one works for
    both C and C++, the second one is for C++ only, and the last one is for the linker.
    |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| `APP_CFLAGS``APP_CPPFLAGS``APP_LDFLAGS` | 全局指定用于编译和链接的任何选项、标志或宏定义。第一个对C和C++都适用，第二个只适用于C++，最后一个适用于链接器。
    |'
- en: '| `APP_BUILD_SCRIPT` | To redefine the location of the Android.mk file (by
    default in project''s `jni` directory). |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| `APP_BUILD_SCRIPT` | 重新定义Android.mk文件的位置（默认情况下在项目的`jni`目录中）。 |'
- en: '| `APP_ABI` | List of ABI (that is, "CPU architectures") supported by the application,
    separated by a space. Currently supported values are `armeabi`, `armeabi-v7a`,
    `x86`, mips, or `all`. Each module is recompiled once per ABI. So, the more ABI
    you support, the more time it will get to build. |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| `APP_ABI` | 应用程序支持的ABI（即“CPU架构”）列表，用空格分隔。目前支持的值有`armeabi`，`armeabi-v7a`，`x86`，mips或`all`。每个模块都会根据ABI重新编译一次。因此，您支持的ABI越多，构建所需的时间就越长。
    |'
- en: '| `APP_PLATFORM` | Name of the target Android platform. This information is
    found by default in the `project.properties` file. |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| `APP_PLATFORM` | 目标Android平台的名称。此信息默认情况下在`project.properties`文件中找到。 |'
- en: '| `APP_STL` | The C++ runtime to use. Possible values are `system`, `gabi++_static`,
    `gabi++_shared`, `stlport_static`, `stlport_shared`, `gnustl_static`, `gnustl_shared`,
    `c++_static`, and `c++_shared`. |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| `APP_STL` | 要使用的C++运行时。可能的值包括`system`，`gabi++_static`，`gabi++_shared`，`stlport_static`，`stlport_shared`，`gnustl_static`，`gnustl_shared`，`c++_static`和`c++_shared`。
    |'
- en: Documentation about these variables can be found at `${ANDROID_NDK}/docs/APPLICATION-MK.html`.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些变量的文档可以在`${ANDROID_NDK}/docs/APPLICATION-MK.html`找到。
- en: Enabling C++ 11 support and the Clang compiler
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用C++ 11支持和Clang编译器
- en: The `NDK_TOOLCHAIN_VERSION` variable can be redefined in the `Application.mk`
    file to explicitly select the compilation toolchain. Possible values for the NDK
    R10 are `4.6` (now deprecated), `4.8`, and `4.9`, which simply correspond to GCC
    versions. Possible version numbers might change in future releases of the NDK.
    To find them, have a look at the `$ANDROID_NDK/toolchains` directory.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`NDK_TOOLCHAIN_VERSION`变量可以在`Application.mk`文件中重新定义，以明确选择编译工具链。NDK R10的可能值为`4.6`（现在已弃用），`4.8`和`4.9`，它们分别对应GCC版本。可能的版本号在将来的NDK版本中可能会更改。要找到它们，请查看`$ANDROID_NDK/toolchains`目录。'
- en: 'The Android NDK provides C++ 11 support, starting with the GCC 4.8 toolchain.
    You can enable it by appending the `-std=c++11` compilation flag and activating
    GNU STL (STL Port is not supported and Libc++ only partially supported at the
    time this book was written) to get proper C++11 support. The following is an example
    of `an Android.mk` extract with C++11 activated:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: Android NDK从GCC 4.8工具链开始提供C++ 11支持。您可以通过附加`-std=c++11`编译标志并激活GNU STL（STL Port不受支持，Libc++在撰写本书时仅部分受支持）来启用它以获得适当的C++11支持。以下是一个激活了C++11的`Android.mk`摘录示例：
- en: '[PRE61]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Tip
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Switching to GCC4.8 and C++11 might not feel like a breeze. Indeed, the compiler,
    let's say, is a bit less permissive than before. In case you run into trouble
    when compiling legacy code with this new toolchain, try the `–fpermissive` flag
    (or rewrite your code!).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到GCC4.8和C++11可能不会感觉像一阵微风。实际上，编译器可能比以前严格一些。如果在使用新工具链编译旧代码时遇到问题，请尝试`-fpermissive`标志（或重写您的代码！）。
- en: Moreover, beware, although C++11 support is quite large, you might still encounter
    a few problems or missing features.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽管C++11支持相当广泛，您可能仍会遇到一些问题或缺少的功能。
- en: To enable Clang, the LLVM-based compiler (famous for being used by Apple), in
    place of GCC, simply set `NDK_TOOLCHAIN_VERSION` to `clang`. You can also specify
    compiler version, such as `clang3.4` or `clang3.5`. Again, possible version numbers
    might change in future releases of the NDK. To find them, have a look at the `$ANDROID_NDK/toolchains`
    directory.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用基于LLVM的编译器Clang（因为被苹果使用而闻名），而不是GCC，只需将`NDK_TOOLCHAIN_VERSION`设置为`clang`。您还可以指定编译器版本，例如`clang3.4`或`clang3.5`。再次强调，可能的版本号在将来的NDK版本中可能会更改。要找到它们，请查看`$ANDROID_NDK/toolchains`目录。
- en: Makefile Instructions
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Makefile指令
- en: Makefile is a real language with programming instructions and functions.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile是一种真正的编程语言，具有编程指令和函数。
- en: 'Makefiles can be broken down into several sub-Makefiles, included with the
    `include` instruction. Variable initialization comes in the following two flavors:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile可以分解为几个子Makefile，并使用`include`指令包含。变量初始化有以下两种方式：
- en: Simple affectation (`operator :=`), which expands variables at the time they
    are initialized
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单赋值（`operator :=`），在初始化时扩展变量
- en: Recursive affectation (`operator =`), which re-evaluates the affected expression
    each time it is called
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归赋值（`operator =`），每次调用时重新评估受影响的表达式
- en: 'The following conditional and loop instructions are available: `ifdef/endif`,
    `ifeq/endif`, `ifndef/endif`, `and for…in/do/done`. For example, to display a
    message only when a variable is defined, do:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 以下条件和循环指令可用：`ifdef/endif`、`ifeq/endif`、`ifndef/endif`、`and for…in/do/done`。例如，只有在变量被定义时才显示消息，可以这样做：
- en: '[PRE62]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'More advanced stuff, such as functional `if`, `and`, `or`, and so on, are at
    your disposal, but are rarely used. Makefiles also provide some useful built-in
    functions, which are given in the following table:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更高级的东西，比如`if`、`and`、`or`等，但很少使用。Makefile还提供了一些有用的内置函数，列在下表中：
- en: '| `$(info <message>)` | Allows printing messages to the standard output. This
    is the most essential tool when writing Makefiles! Variables inside information
    messages are allowed. |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| `$(info <message>)` | 允许将消息打印到标准输出。这是编写Makefile时最基本的工具！信息消息中允许使用变量。 |'
- en: '| `$(warning <message>)`, `$(error <message>)` | Allows printing a warning
    or a fatal error that stops compilation. These messages can be parsed by Eclipse.
    |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| `$(warning <message>)`, `$(error <message>)` | 允许打印警告或导致编译停止的致命错误。这些消息可以被Eclipse解析。
    |'
- en: '| `$(foreach <variable>`, `<list>`, `<operation>)` | Performs an operation
    on a list of variables. Each element of the list is expanded in the first argument
    variable, before the operation is applied to it. |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| `$(foreach <variable>`, `<list>`, `<operation>)` | 对变量列表执行操作。在应用操作之前，列表的每个元素都会扩展到第一个参数变量中。
    |'
- en: '| `$(shell <command>)` | Executes a command outside of Make. This brings all
    the power of Unix Shell into Makefiles but is heavily system-dependent. Avoid
    it if possible. |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| `$(shell <command>)` | 在Make之外执行命令。这将Unix Shell的所有功能带入Makefile，但严重依赖于系统。尽量避免使用。
    |'
- en: '| `$(wildcard <pattern>)` | Selects files and directory names according to
    a pattern. |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| `$(wildcard <pattern>)` | 根据模式选择文件和目录名称。 |'
- en: '| `$(call <function>)` | Allows evaluating a function or macro. One macro we
    have seen is `my-dir`, which returns the directory path of the last executed Makefile.
    This is why `LOCAL_PATH := $(call my-dir)` is systematically written at the beginning
    of each `Android.mk` file to save in the current Makefile directory. |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| `$(call <function>)` | 允许评估函数或宏。我们见过的一个宏是`my-dir`，它返回最后执行的Makefile的目录路径。这就是为什么在每个`Android.mk`文件的开头都要写`LOCAL_PATH
    := $(call my-dir)`，以保存在当前Makefile目录中。 |'
- en: 'Custom functions can easily be written with the `call` directive. These functions
    look somewhat similar to recursively affected variables, except that the arguments
    can be defined: `$(1)` for first argument, `$(2)` for second argument, and so
    on. A call to a function can be performed in a single line, as shown in the following
    code:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`call`指令轻松编写自定义函数。这些函数看起来有点像递归影响变量，只是参数可以被定义：`$(1)`表示第一个参数，`$(2)`表示第二个参数，依此类推。可以在一行中执行对函数的调用，如下面的代码所示：
- en: '[PRE63]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Strings and files manipulation functions are available too, as shown in the
    following table:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 还有字符串和文件操作函数，如下表所示：
- en: '| `$(join <str1>, <str2>)` | Concatenates two strings. |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| `$(join <str1>, <str2>)` | 连接两个字符串。 |'
- en: '| `$(subst <from>,``<replacement>,<string>)`,`$(patsubst <pattern>,``<replacement>,<string>)`
    | Replaces each occurrence of a substring by another. The second one is more powerful
    because it allows using patterns (which must start with "%"). |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| `$(subst <from>,``<replacement>,<string>)`,`$(patsubst <pattern>,``<replacement>,<string>)`
    | 用另一个字符串替换每个子字符串的出现。第二个更强大，因为它允许使用模式（必须以“%”开头）。 |'
- en: '| `$(filter <patterns>, <text>)``$(filter-out <patterns>, <text>)` | Filter
    strings from a text matching patterns. This is useful for filtering files. For
    example, the following line filters any C file:`$(filter %.c, $(my_source_list))`
    |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| `$(filter <patterns>, <text>)``$(filter-out <patterns>, <text>)` | 从匹配模式的文本中过滤字符串。这对于过滤文件很有用。例如，以下行过滤任何C文件：`$(filter
    %.c, $(my_source_list))` |'
- en: '| `$(strip <string>)` | Removes any unnecessary whitespace. |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| `$(strip <string>)` | 移除任何不必要的空格。 |'
- en: '| `$(addprefix <prefix>,<list>)`,`$(addsuffix <suffix>, <list>)` | Append a
    prefix and suffix, respectively, to each element of the list, each element being
    separated by a space. |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| `$(addprefix <prefix>,<list>)`,`$(addsuffix <suffix>, <list>)` | 分别向列表的每个元素添加前缀和后缀，每个元素之间用空格分隔。
    |'
- en: '| `$(basename <path1>, <path2>, ...)` | Returns a string from which file extensions
    are removed. |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| `$(basename <path1>, <path2>, ...)` | 返回去除文件扩展名的字符串。 |'
- en: '| `$(dir <path1>, <path2>)`,`$(notdir <path1>, <path2>)` | Extracts the directory
    and the filename in a path respectively. |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| `$(dir <path1>, <path2>)`,`$(notdir <path1>, <path2>)` | 分别提取路径中的目录和文件名。
    |'
- en: '| `$(realpath <path1>, <path2>, ...)`,`$(abspath <path1>, <path2>, ...)` |
    Return both canonical paths of each path argument, except that the second one
    does not evaluate symbolic links. |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| `$(realpath <path1>, <path2>, ...)`,`$(abspath <path1>, <path2>, ...)` |
    返回每个路径参数的规范路径，除了第二个不评估符号链接。 |'
- en: This is just really an overview of what Makefiles are capable of. For more information,
    refer to the full Makefile documentation available at [http://www.gnu.org/software/make/manual/make.html](http://www.gnu.org/software/make/manual/make.html).
    If you are allergic to Makefiles, have a look at CMake. CMake is a simplified
    Make system, already building many open source libraries on the market. A port
    of CMake on Android is available at [http://code.google.com/p/android-cmake](http://code.google.com/p/android-cmake).
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是Makefiles能够做到的概述。有关更多信息，请参阅[http://www.gnu.org/software/make/manual/make.html](http://www.gnu.org/software/make/manual/make.html)上提供的完整Makefile文档。如果您对Makefiles过敏，请看看CMake。CMake是一个简化的Make系统，已经在市场上构建了许多开源库。Android上的CMake端口可在[http://code.google.com/p/android-cmake](http://code.google.com/p/android-cmake)上找到。
- en: Have a go hero – mastering Makefiles
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试成为英雄-掌握Makefiles
- en: 'We can play in a variety of ways with Makefiles:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以各种方式使用Makefiles：
- en: 'Try the affectation operator. For example, write down the following piece of
    code, which uses the `:= operator`, in your `Android.mk` file:'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试赋值运算符。例如，在您的`Android.mk`文件中写下以下代码片段，使用`:=`运算符：
- en: '[PRE64]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Watch the result when launching compilation. Then, perform the same using `=`.
    Print current optimization mode. Use `APP_OPTIM` and the internal variable, `NDK_APP_CFLAGS`,
    and observe the difference between the `release` and `debug` modes:'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动编译时观察结果。然后使用`=`执行相同操作。打印当前的优化模式。使用`APP_OPTIM`和内部变量`NDK_APP_CFLAGS`，观察`release`和`debug`模式之间的差异：
- en: '[PRE65]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Check that variables are properly defined, for example:'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查变量是否正确定义，例如：
- en: '[PRE66]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Try to use the `foreach` instruction to print the list of files and directories
    inside the project''s root directory and its `jni` folder (and make sure to use
    recursive affectation):'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用`foreach`指令打印项目根目录及其`jni`文件夹中的文件和目录列表（并确保使用递归赋值）：
- en: '[PRE67]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Try to create a macro to log a message to the standard output and its time:'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试创建一个宏来将消息记录到标准输出及其时间：
- en: '[PRE68]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, test the `my-dir` macro-behavior, to understand why `LOCAL_PATH :=
    $(call my-dir)` is systematically written at the beginning of each `Android.mk`
    file:'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，测试`my-dir`宏的行为，以了解为什么在每个`Android.mk`文件的开头都系统地写入`LOCAL_PATH := $(call my-dir)`：
- en: '[PRE69]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: CPU Architectures (ABI)
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU架构（ABI）
- en: 'Compiled native C/C++ code on current Android ARM devices follows an **Application
    Binary Interface** (**ABI**). An ABI specifies the binary code format (instruction
    set, calling conventions, and so on). GCC translates code into this binary format.
    ABIs are thus strongly related to processors. The target ABI can be selected in
    the `Application.mk` file with the `APP_ABI` variable. There exist five main ABIs
    supported on Android, which are as follows:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前Android ARM设备上编译本机C/C++代码遵循**应用程序二进制接口**（**ABI**）。ABI指定二进制代码格式（指令集、调用约定等）。GCC将代码转换为这种二进制格式。因此，ABI与处理器密切相关。目标ABI可以在`Application.mk`文件中使用`APP_ABI`变量进行选择。在Android上支持五种主要ABI，如下所示：
- en: '**thumb**: This is the default option, which should be compatible with all
    ARM devices. Thumb is a special instruction set which encodes instructions on
    16 bit, instead of 32 bit, to improve code size (useful for devices with constrained
    memory). The instruction set is severely restricted compared to ArmEABI.'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**thumb**：这是默认选项，应该与所有ARM设备兼容。Thumb是一种特殊的指令集，它将指令编码为16位，而不是32位，以改善代码大小（对于内存受限的设备很有用）。与ArmEABI相比，指令集受到严格限制。'
- en: '**armeabi** (Or Arm v5): This should run on all ARM devices. Instructions are
    encoded on 32 bit but may be more concise than Thumb code. Arm v5 does not support
    advanced extensions such as floating point acceleration and is thus slower than
    Arm v7.'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**armeabi**（或Arm v5）：这应该在所有ARM设备上运行。指令编码为32位，但可能比Thumb代码更简洁。Arm v5不支持浮点加速等高级扩展，因此比Arm
    v7慢。'
- en: '**armeabi-v7a**: This supports extensions such as Thumb-2 (similar to Thumb
    but with additional 32-bit instructions) and VFP, plus some optional extensions,
    such as NEON. Code compiled for Arm V7 will not run on Arm V5 processors.'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**armeabi-v7a**：这支持Thumb-2（类似于Thumb，但具有额外的32位指令）和VFP等扩展，以及一些可选的扩展，如NEON。为Arm
    V7编译的代码将无法在Arm V5处理器上运行。'
- en: '**x86**: This is for "*PC-like*" architectures (that is, Intel/AMD) and, more
    specifically, Intel Atom processors. This ABI provides specific extensions, such
    as MMX or SSE.'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**x86**：这是用于“PC样式”架构（即Intel/AMD）的，更具体地说是Intel Atom处理器。该ABI提供特定的扩展，如MMX或SSE。'
- en: '**mips**: This is for MIPS processors developed by Imagination Technologies
    (which also produce the PowerVR graphics processors). Only a few devices exist
    at the time this book was written.'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mips**：这是为Imagination Technologies开发的MIPS处理器而设计的（该公司还生产PowerVR图形处理器）。在撰写本书时，只有少数设备存在。'
- en: By default, the compiled binaries of each ABI are embedded in the APK. The most
    appropriate is selected at installation time. Google Play also supports the upload
    of different APKs for each ABI to limit application size.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个ABI的编译二进制文件都嵌入在APK中。在安装时选择最合适的。Google Play还支持为每个ABI上传不同的APK，以限制应用程序大小。
- en: Advanced instruction sets (NEON, VFP, SSE, MSA)
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级指令集（NEON、VFP、SSE、MSA）
- en: If you are reading this book, code performance is probably one of your main
    criteria. To achieve this, ARM created a SIMD instruction set (acronym Single
    Instruction Multiple Data, that is, process several data in parallel with one
    instruction) called NEON, which has been introduced along with the VFP (floating
    point accelerated) unit. NEON is not available on all chips (for example, Nvidia
    Tegra 2 does not support it), but is quite popular in intensive multimedia applications.
    They are also a good way to compensate the weak VFP unit of some processors (for
    example, Cortex-A8).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在阅读本书，代码性能可能是您的主要标准之一。为了实现这一点，ARM创建了一个SIMD指令集（即单指令多数据的缩写，即用一条指令并行处理多个数据），称为NEON，它是与VFP（浮点加速）单元一起引入的。NEON并非所有芯片都支持（例如，Nvidia
    Tegra 2不支持），但在密集的多媒体应用中非常受欢迎。它们也是弥补一些处理器的弱VFP单元的好方法（例如，Cortex-A8）。
- en: Tip
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A NEON code can be written in a separate assembler file in a dedicated `asm
    volatile` block with assembler instructions, or in a C/C++ file or as intrinsics
    (NEON instructions encapsulated in a GCC C routine). Intrinsics should be used
    with much care as GCC is often unable to generate efficient machine code (or requires
    lots of tricky hints). Writing real assembler code is generally advised.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: NEON代码可以在专用的`asm volatile`块中的单独的汇编文件中编写，其中包含汇编指令，或者在C/C++文件中或作为内联汇编（NEON指令封装在GCC
    C例程中）。内联汇编应该谨慎使用，因为GCC通常无法生成有效的机器代码（或需要大量的棘手提示）。通常建议编写真正的汇编代码。
- en: 'X86 CPUs have their own set of extensions that are different from the ARM ones:
    MMX, SSE, SSE2, and SSE3\. SSE instruction sets are the Intel equivalent of NEON
    SIMS instructions. The latest SSE4 instructions are generally not supported on
    current X86 processors. Obviously, SSE and NEON are not compatible, which means
    that a code specifically written for NEON needs to be rewritten for SSE and reciprocally.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: X86 CPU具有其自己的扩展集，与ARM的不同：MMX，SSE，SSE2和SSE3。SSE指令集是英特尔等效于NEON SIMS指令。最新的SSE4指令通常不受当前X86处理器支持。显然，SSE和NEON不兼容，这意味着专门为NEON编写的代码需要为SSE重新编写，反之亦然。
- en: Tip
  id: totrans-508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Android provides a `cpu-features.h` API (with the `android_getCpuFamily()`and
    `android_getCpuFeatures()` methods) to detect available features on the host device
    at runtime. It helps in detecting the CPU (ARM, X86) and its capabilities (ArmV7
    support, NEON, VFP, and so on).
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: Android提供了`cpu-features.h` API（使用`android_getCpuFamily()`和`android_getCpuFeatures()`方法）来在运行时检测主机设备上可用的功能。它有助于检测CPU（ARM，X86）及其功能（ArmV7支持，NEON，VFP等）。
- en: NEON, SSE, and modern processors in general are not easy to master. The Internet
    is full of examples to get inspiration from. Reference technical documentation
    can be found on the ARM website at [http://infocenter.arm.com/](http://infocenter.arm.com/)
    and the Intel developer manuals at [http://www.intel.com/](http://www.intel.com/).
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: NEON，SSE和现代处理器一般都不容易掌握。互联网上充满了可以从中获得灵感的例子。参考技术文档可以在ARM网站[http://infocenter.arm.com/](http://infocenter.arm.com/)和英特尔开发人员手册[http://www.intel.com/](http://www.intel.com/)上找到。
- en: MIPS also has its own SIMD instruction set named MSA. It provides features such
    as vector arithmetics and branching operations, or conversion between integer
    and floating-point values. For more information, have a look at [http://www.imgtec.com/mips/architectures/simd.asp](http://www.imgtec.com/mips/architectures/simd.asp).
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: MIPS还有自己的SIMD指令集，名为MSA。它提供了矢量算术和分支操作等功能，或者在整数和浮点值之间进行转换。有关更多信息，请查看[http://www.imgtec.com/mips/architectures/simd.asp](http://www.imgtec.com/mips/architectures/simd.asp)。
- en: 'All this stuff is interesting but it does not answer the question you are probably
    asking yourself: how hard it is to port code from ARM to X86 (or reciprocally)?
    The answer is "it depends":'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些东西都很有趣，但它并没有回答您可能正在问自己的问题：从ARM移植代码到X86（或反之）有多难？答案是“这取决于”：
- en: If you use pure C/C++ native code, without specific instruction set, code should
    be portable simply by appending `x86` or `mips` to the `APP_ABI` variable.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用纯C/C++本机代码，没有特定的指令集，那么通过将`APP_ABI`变量附加`x86`或`mips`，代码应该是可移植的。
- en: If your code contains assembly code, you will need to rewrite the corresponding
    part for other ABI or provide a fallback.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的代码包含汇编代码，您将需要为其他ABI重新编写相应部分，或者提供一个回退。
- en: If your code contains specific instruction sets such as NEON (using C/C++ intrinsics
    or assembly code), you will need to rewrite corresponding part for other ABIs
    or provide a fallback.
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的代码包含特定的指令集，例如NEON（使用C/C++内联汇编或汇编代码），您将需要为其他ABI重新编写相应部分，或者提供一个回退。
- en: If your code depends on specific memory alignment, you might need to use explicit
    alignment. Indeed, when you compile a data structure, the compiler might use padding
    to align data in memory appropriately for faster memory accesses. However, alignment
    requirements are different depending on the ABI.
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的代码依赖于特定的内存对齐，您可能需要使用显式对齐。实际上，当您编译数据结构时，编译器可能使用填充来适当地对齐内存中的数据，以便更快地访问内存。然而，对齐要求因ABI而异。
- en: For example, 64-bit variables on ARM are aligned to 8, which means, for example,
    that double must have a memory address, which is a multiple of 8\. X86 memory
    can be more densely packed.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在ARM上，64位变量对齐到8，这意味着，例如，双精度必须有一个内存地址，它是8的倍数。X86内存可以更密集地打包。
- en: Tip
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Data alignment is not an issue the vast majority of the time, except if you
    explicitly depend on data location (for example, if you use serialization). Even
    if you have no alignment issues, it is always interesting to tweak or optimize
    structure layouts to avoid useless padding and get better performances.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 数据对齐在绝大多数情况下并不是问题，除非您明确依赖于数据位置（例如，如果您使用序列化）。即使您没有对齐问题，调整或优化结构布局以避免无用的填充并获得更好的性能总是有趣的。
- en: So, most of the time, porting code from one ABI to another should be rather
    simple. In specific cases, provide fallbacks when specific CPU features or assembly
    code is necessary. Finally, beware, some memory alignment issues might arise in
    some rare cases.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，大多数情况下，从一个ABI移植代码到另一个ABI应该相当简单。在特定情况下，当特定的CPU功能或汇编代码是必要的时候，提供回退。最后，注意，一些内存对齐问题可能会在一些罕见的情况下出现。
- en: Tip
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As we have seen in the Prebuilding Boost part, each ABI has its own compilation
    flags to optimize compilation. Although the default GCC options used by the NDK
    are an appropriate basis, tweaking them can improve efficiency and performance.
    For example, you can use `-mtune=atom -mssse3 -mfpmath=sse` to optimize release
    code on X86 platforms.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在预构建Boost部分中看到的，每个ABI都有自己的编译标志来优化编译。虽然NDK使用的默认GCC选项是一个合适的基础，但调整它们可以提高效率和性能。例如，您可以使用`-mtune=atom
    -mssse3 -mfpmath=sse`来优化X86平台上的发布代码。
- en: Summary
  id: totrans-523
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter introduced a fundamental aspect of the NDK: portability. Thanks
    to the recent improvements in the building toolchain, the Android NDK can now
    take advantage of the vast C/C++ ecosystem. It unlocks the door of a productive
    environment, where code is shared with other platforms with the aim of creating
    new cutting-edge applications efficiently.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了NDK的一个基本方面：可移植性。由于构建工具链的最新改进，Android NDK现在可以利用庞大的C/C++生态系统。它打开了一个高效的生产环境大门，其中代码可以与其他平台共享，旨在有效地创建新的尖端应用程序。
- en: More specifically, you learned how to activate the STL with a simple flag in
    the NDK makefile system. We have ported the Box2D library into an NDK module that
    is reusable among Android projects. You also saw how to prebuild Boost using the
    raw NDK toolchain, without any wrapper. We have enabled exceptions and RTTI and
    discovered in depth how to write module makefiles.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地，您学会了如何在NDK makefile系统中使用简单的标志激活STL。我们已经将Box2D库移植到了一个可在Android项目中重复使用的NDK模块中。您还看到了如何使用原始NDK工具链预构建Boost，而无需任何包装器。我们已经启用了异常和RTTI，并深入了解了如何编写模块makefile。
- en: We have highlighted the path toward the creation of professional applications
    using the NDK as a leverage. But do not expect all C/C++ libraries to be ported
    so easily. Talking about paths, we are almost at the end. At least, this was the
    last chapter about DroidBlaster.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经强调了使用NDK作为杠杆创建专业应用程序的路径。但不要指望所有C/C++库都能如此轻松地移植。说到路径，我们几乎到了尽头。至少，这是关于DroidBlaster的最后一章。
- en: The next and last chapters will introduce RenderScript, an advanced technology
    to maximize your Android app performance.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的最后一章将介绍RenderScript，这是一种提高Android应用程序性能的先进技术。
