- en: '*Chapter 1*: Communicating with Kubernetes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第1章*：与Kubernetes通信'
- en: This chapter contains an explanation of container orchestration, including its
    benefits, use cases, and popular implementations. We'll also review Kubernetes
    briefly, including a layout of the architectural components, and a primer on authorization,
    authentication, and general communication with Kubernetes. By the end of this
    chapter, you'll know how to authenticate and communicate with the Kubernetes API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含容器编排的解释，包括其优势、用例和流行的实现。我们还将简要回顾Kubernetes，包括架构组件的布局，以及对授权、身份验证和与Kubernetes的一般通信的入门。到本章结束时，您将知道如何对Kubernetes
    API进行身份验证和通信。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: A container orchestration primer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器编排入门
- en: Kubernetes' architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes的架构
- en: Authentication and authorization on Kubernetes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes上的身份验证和授权
- en: Using kubectl and YAML files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用kubectl和YAML文件
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to run the commands detailed in this chapter, you will need a computer
    running Linux, macOS, or Windows. This chapter will teach you how to install the
    `kubectl` command-line tool that you will use in all later chapters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行本章详细介绍的命令，您需要一台运行Linux、macOS或Windows的计算机。本章将教您如何安装`kubectl`命令行工具，您将在以后的所有章节中使用它。
- en: 'The code used in this chapter can be found in the book''s GitHub repository
    at the following link:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在书的GitHub存储库中找到，链接如下：
- en: '[https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter1](https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter1)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter1](https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter1)'
- en: Introducing container orchestration
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍容器编排
- en: We cannot talk about Kubernetes without an introduction of its purpose. Kubernetes
    is a container orchestration framework, so let's review what that means in the
    context of this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 谈论Kubernetes时，不能不介绍其目的。Kubernetes是一个容器编排框架，让我们在本书的背景下回顾一下这意味着什么。
- en: What is container orchestration?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是容器编排？
- en: Container orchestration is a popular pattern for running modern applications
    both in the cloud and the data center. By using containers – preconfigured application
    units with bundled dependencies – as a base, developers can run many instances
    of an application in parallel.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 容器编排是在云端和数据中心运行现代应用程序的流行模式。通过使用容器-预配置的应用程序单元和捆绑的依赖项-作为基础，开发人员可以并行运行许多应用程序实例。
- en: Benefits of container orchestration
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器编排的好处
- en: There are quite a few benefits that container orchestration offers, but we will
    highlight the main ones. First, it allows developers to easily build **high-availability**
    applications. By having multiple instances of an application running, a container
    orchestration system can be configured in a way that means it will automatically
    replace any failed instances of the application with new ones.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 容器编排提供了许多好处，但我们将重点介绍主要的好处。首先，它允许开发人员轻松构建**高可用性**应用程序。通过运行多个应用程序实例，容器编排系统可以配置成自动替换任何失败的应用程序实例为新的实例。
- en: This can be extended to the cloud by having those multiple instances of the
    application spread across physical data centers, so if one data center goes down,
    other instances of the application will remain, and prevent downtime.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过在物理数据中心中分散应用程序的多个实例来扩展到云端，因此如果一个数据中心崩溃，应用程序的其他实例将保持运行，并防止停机。
- en: Second, container orchestration allows for highly **scalable** applications.
    Since new instances of the application can be created and destroyed easily, the
    orchestration tool can auto-scale up and down to meet demand. Either in a cloud
    or data center environment, new **Virtual Machines** (**VMs**) or physical machines
    can be added to the orchestration tool to give it a bigger pool of compute to
    manage. This process can be completely automated in a cloud setting to allow for
    completely hands-free scaling, both at the micro and macro level.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，容器编排允许高度**可扩展**的应用程序。由于可以轻松创建和销毁应用程序的新实例，编排工具可以自动扩展以满足需求。在云环境或数据中心环境中，可以向编排工具添加新的**虚拟机**（**VMs**）或物理机，以提供更大的计算资源池。在云环境中，这个过程可以完全自动化，实现完全无需人工干预的扩展，无论是在微观还是宏观层面。
- en: Popular orchestration tools
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流行的编排工具
- en: 'There are several highly popular container orchestration tools available in
    the ecosystem:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 生态系统中有几种非常流行的容器编排工具：
- en: '**Docker Swarm**: Docker Swarm was created by the team behind the Docker container
    engine. It is easier to set up and run compared to Kubernetes, but somewhat less
    flexible.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Swarm**：Docker Swarm是由Docker容器引擎团队创建的。与Kubernetes相比，它更容易设置和运行，但相对灵活性较差。'
- en: '**Apache Mesos**: Apache Mesos is a lower-level orchestration tool that manages
    compute, memory, and storage, in both data center and cloud environments. By default,
    Mesos does not manage containers, but Marathon – a framework that runs on top
    of Mesos – is a fully fledged container orchestration tool. It is even possible
    to run Kubernetes on top of Mesos.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache Mesos**：Apache Mesos是一个较低级别的编排工具，可以管理数据中心和云环境中的计算、内存和存储。默认情况下，Mesos不管理容器，但是Marathon
    - 一个在Mesos之上运行的框架 - 是一个完全成熟的容器编排工具。甚至可以在Mesos之上运行Kubernetes。'
- en: '**Kubernetes**: As of 2020, much of the work in container orchestration has
    consolidated around Kubernetes (koo-bur-net-ees), often shortened to k8s. Kubernetes
    is an open source container orchestration tool that was originally created by
    Google, with learnings from internal orchestration tools Borg and Omega, which
    had been in use at Google for years. Since Kubernetes became open source, it has
    risen in popularity to become the de facto way to run and orchestrate containers
    in an enterprise environment. There are a few reasons for this, including that
    Kubernetes is a mature product that has an extremely large open source community.
    It is also simpler to operate than Mesos, and more flexible than Docker Swarm.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes**：截至2020年，容器编排工作大部分集中在Kubernetes（koo-bur-net-ees）周围，通常缩写为k8s。Kubernetes是一个开源容器编排工具，最初由谷歌创建，借鉴了谷歌多年来在内部编排工具Borg和Omega的经验。自Kubernetes成为开源项目以来，它已经成为企业环境中运行和编排容器的事实标准。其中一些原因包括Kubernetes是一个成熟的产品，拥有一个非常庞大的开源社区。它比Mesos更容易操作，比Docker
    Swarm更灵活。'
- en: The most important thing to take away from this comparison is that although
    there are multiple relevant options for container orchestration and some are indeed
    better in certain ways, Kubernetes has emerged as the de facto standard. With
    this in mind, let's take a look at how Kubernetes works.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个比较中最重要的一点是，尽管容器编排有多个相关选项，而且在某些方面确实更好，但Kubernetes已经成为事实标准。有了这个认识，让我们来看看Kubernetes是如何工作的。
- en: Kubernetes' architecture
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes的架构
- en: Kubernetes is an orchestration tool that can run on cloud VMs, on VMs running
    in your data center, or on bare metal servers. In general, Kubernetes runs on
    a set of nodes, each of which can each be a VM or a physical machine.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是一个可以在云虚拟机上运行的编排工具，也可以在数据中心的虚拟机或裸机服务器上运行。一般来说，Kubernetes在一组节点上运行，每个节点可以是虚拟机或物理机。
- en: Kubernetes node types
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes节点类型
- en: 'Kubernetes nodes can be many different things – from a VM, to a bare metal
    host, to a Raspberry Pi. Kubernetes nodes are split into two distinct categories:
    first, the master nodes, which run the Kubernetes control plane applications;
    second, the worker nodes, which run the applications that you deploy onto Kubernetes.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes节点可以是许多不同的东西-从虚拟机到裸金属主机再到树莓派。Kubernetes节点分为两个不同的类别：首先是主节点，运行Kubernetes控制平面应用程序；其次是工作节点，运行您部署到Kubernetes上的应用程序。
- en: In general, for high availability, a production deployment of Kubernetes should
    have a minimum of three master nodes and three worker nodes, though most large
    deployments have many more workers than masters.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，为了实现高可用性，Kubernetes的生产部署应该至少有三个主节点和三个工作节点，尽管大多数大型部署的工作节点比主节点多得多。
- en: The Kubernetes control plane
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes控制平面
- en: 'The Kubernetes control plane is a suite of applications and services that run
    on the master nodes. There are several highly specialized services at play that
    form the core of Kubernetes functionality. They are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes控制平面是一套运行在主节点上的应用程序和服务。有几个高度专业化的服务在发挥作用，构成了Kubernetes功能的核心。它们如下：
- en: '**kube-apiserver**: This is the Kubernetes API server. This application handles
    instructions sent to Kubernetes.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kube-apiserver：这是Kubernetes API服务器。该应用程序处理发送到Kubernetes的指令。
- en: '**kube-scheduler**: This is the Kubernetes scheduler. This component handles
    the work of deciding which nodes to place workloads on, which can become quite
    complex.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kube-scheduler：这是Kubernetes调度程序。该组件处理决定将工作负载放置在哪些节点上的工作，这可能变得非常复杂。
- en: '**kube-controller-manager**: This is the Kubernetes controller manager. This
    component provides a high-level control loop that ensures that the desired configuration
    of the cluster and applications running on it is implemented.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kube-controller-manager：这是Kubernetes控制器管理器。该组件提供了一个高级控制循环，确保集群的期望配置和运行在其上的应用程序得到实施。
- en: '**etcd**: This is a distributed key-value store that contains the cluster configuration.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: etcd：这是一个包含集群配置的分布式键值存储。
- en: Generally, all of these components take the form of system services that run
    on every master node. They can be started manually if you wanted to bootstrap
    your cluster entirely by hand, but through the use of a cluster creation library
    or cloud provider-managed service such as **Elastic Kubernetes Service (EKS)**,
    this will usually be done automatically in a production setting.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，所有这些组件都采用系统服务的形式，在每个主节点上运行。如果您想完全手动引导集群，可以手动启动它们，但是通过使用集群创建库或云提供商管理的服务，例如**弹性Kubernetes服务（EKS）**，在生产环境中通常会自动完成这些操作。
- en: The Kubernetes API server
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes API服务器
- en: The Kubernetes API server is a component that accepts HTTPS requests, typically
    on port `443`. It presents a certificate, which can be self-signed, as well as
    authentication and authorization mechanisms, which we will cover later in this
    chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API服务器是一个接受HTTPS请求的组件，通常在端口`443`上。它提供证书，可以是自签名的，以及身份验证和授权机制，我们将在本章后面介绍。
- en: When a configuration request is made to the Kubernetes API server, it will check
    the current cluster configuration in `etcd` and change it if necessary.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当对Kubernetes API服务器进行配置请求时，它将检查`etcd`中的当前集群配置，并在必要时进行更改。
- en: The Kubernetes API is generally a RESTful API, with endpoints for each Kubernetes
    resource type, along with an API version that is passed in the query path; for
    instance, `/api/v1`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API通常是一个RESTful API，每个Kubernetes资源类型都有端点，以及在查询路径中传递的API版本；例如，`/api/v1`。
- en: For the purposes of extending Kubernetes (see [*Chapter 13*](B14790_13_Final_PG_ePub.xhtml#_idTextAnchor289),
    *Extending Kubernetes with CRDs*), the API also has a set of dynamic endpoints
    based on API groups, which can expose the same RESTful API functionality to custom
    resources.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展Kubernetes（参见[*第13章*]（B14790_13_Final_PG_ePub.xhtml#_idTextAnchor289），*使用CRD扩展Kubernetes*），API还具有一组基于API组的动态端点，可以向自定义资源公开相同的RESTful
    API功能。
- en: The Kubernetes scheduler
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes调度程序
- en: The Kubernetes scheduler decides where instances of a workload should be run.
    By default, this decision is influenced by workload resource requirements and
    node status. You can also influence the scheduler via placement controls that
    are configurable in Kubernetes (see [*Chapter 8*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186),
    *Pod Placement Controls*). These controls can act on node labels, which other
    pods are already running on a node, and many other possibilities.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes调度程序决定工作负载的实例应该在哪里运行。默认情况下，此决定受工作负载资源要求和节点状态的影响。您还可以通过Kubernetes中可配置的放置控件来影响调度程序（参见[*第8章*]（B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186），*Pod放置控件*）。这些控件可以作用于节点标签，其他Pod已经在节点上运行的情况，以及许多其他可能性。
- en: The Kubernetes controller manager
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes控制器管理器
- en: 'The Kubernetes controller manager is a component that runs several controllers.
    Controllers run control loops that ensure that the actual state of the cluster
    matches that stored in the configuration. By default, these include the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes控制器管理器是运行多个控制器的组件。控制器运行控制循环，确保集群的实际状态与配置中存储的状态匹配。默认情况下，这些包括以下内容：
- en: The node controller, which ensures that nodes are up and running
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点控制器，确保节点正常运行
- en: The replication controller, which ensures that each workload is scaled properly
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制控制器，确保每个工作负载被适当地扩展
- en: The endpoints controller, which handles communication and routing configuration
    for each workload (see [*Chapter 5*](B14790_05_Final_PG_ePub.xhtml#_idTextAnchor127)*,
    Services and Ingress – Communicating with the Outside World*)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端点控制器，处理每个工作负载的通信和路由配置（参见[*第5章*]（B14790_05_Final_PG_ePub.xhtml#_idTextAnchor127）*，服务和入口
    - 与外部世界通信*）
- en: Service account and token controllers, which handle the creation of API access
    tokens and default accounts
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务帐户和令牌控制器，处理API访问令牌和默认帐户的创建
- en: etcd
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: etcd
- en: etcd is a distributed key-value store that houses the configuration of the cluster
    in a highly available way. An `etcd` replica runs on each master node and uses
    the Raft consensus algorithm, which ensures that a quorum is maintained before
    allowing any changes to the keys or values.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: etcd是一个分布式键值存储，以高可用的方式存储集群的配置。每个主节点上都运行一个`etcd`副本，并使用Raft一致性算法，确保在允许对键或值进行任何更改之前保持法定人数。
- en: The Kubernetes worker nodes
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes工作节点
- en: Each Kubernetes worker node contains components that allow it to communicate
    with the control plane and handle networking.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Kubernetes工作节点都包含允许其与控制平面通信和处理网络的组件。
- en: First, there is the **kubelet**, which makes sure that containers are running
    on the node as dictated by the cluster configuration. Second, **kube-proxy** provides
    a network proxy layer to workloads running on each node. And finally, the **container
    runtime** is used to run the workloads on each node.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是**kubelet**，它确保容器根据集群配置在节点上运行。其次，**kube-proxy**为在每个节点上运行的工作负载提供网络代理层。最后，**容器运行时**用于在每个节点上运行工作负载。
- en: kubelet
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kubelet
- en: The kubelet is an agent that runs on every node (including master nodes, though
    it has a different configuration in that context). Its main purpose is to receive
    a list of PodSpecs (more on those later) and ensure that the containers prescribed
    by them are running on the node. The kubelet gets these PodSpecs through a few
    different possible mechanisms, but the main way is by querying the Kubernetes
    API server. Alternately, the kubelet can be started with a file path, which it
    will monitor for a list of PodSpecs, an HTTP endpoint to monitor, or its own HTTP
    endpoint to receive requests on.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: kubelet是在每个节点上运行的代理程序（包括主节点，尽管在该上下文中它具有不同的配置）。它的主要目的是接收PodSpecs的列表（稍后会详细介绍），并确保它们所规定的容器在节点上运行。kubelet通过几种不同的可能机制获取这些PodSpecs，但主要方式是通过查询Kubernetes
    API服务器。另外，kubelet可以通过文件路径启动，它将监视PodSpecs的列表，监视HTTP端点，或者在其自己的HTTP端点上接收请求。
- en: kube-proxy
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kube-proxy
- en: kube-proxy is a network proxy that runs on every node. Its main purpose is to
    do TCP, UDP, and SCTP forwarding (either via stream or round-robin) to workloads
    running on its node. kube-proxy supports the Kubernetes `Service` construct, which
    we will discuss in [*Chapter 5*](B14790_05_Final_PG_ePub.xhtml#_idTextAnchor127)*,
    Services and Ingress – Communicating with the Outside World*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: kube-proxy是在每个节点上运行的网络代理。它的主要目的是对其节点上运行的工作负载进行TCP、UDP和SCTP转发（通过流或轮询）。kube-proxy支持Kubernetes的`Service`构造，我们将在[*第5章*](B14790_05_Final_PG_ePub.xhtml#_idTextAnchor127)*，服务和入口
    - 与外部世界通信*中讨论。
- en: The container runtime
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器运行时
- en: The container runtime runs on each node and is the component that actually runs
    your workloads. Kubernetes supports CRI-O, Docker, containerd, rktlet, and any
    valid **Container Runtime Interface** (**CRI**) runtime. As of Kubernetes v1.14,
    the RuntimeClass feature has been moved from alpha to beta and allows for workload-specific
    runtime selection.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行时在每个节点上运行，它实际上运行您的工作负载。Kubernetes支持CRI-O、Docker、containerd、rktlet和任何有效的**容器运行时接口**（**CRI**）运行时。从Kubernetes
    v1.14开始，RuntimeClass功能已从alpha版移至beta版，并允许特定于工作负载的运行时选择。
- en: Addons
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插件
- en: In addition to the core cluster components, a typical Kubernetes installation
    includes addons, which are additional components that provide cluster functionality.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了核心集群组件外，典型的Kubernetes安装包括插件，这些是提供集群功能的附加组件。
- en: For example, **Container Network Interface** (**CNI**) plugins such as `Calico`,
    `Flannel`, or `Weave` provide overlay network functionality that adheres to Kubernetes'
    networking requirements.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**容器网络接口**（**CNI**）插件，如`Calico`、`Flannel`或`Weave`，提供符合Kubernetes网络要求的覆盖网络功能。
- en: CoreDNS, on the other hand, is a popular addon for in-cluster DNS and service
    discovery. There are also tools such as Kubernetes Dashboard, which provides a
    GUI for viewing and interacting with your cluster.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，CoreDNS是一个流行的插件，用于集群内的DNS和服务发现。还有一些工具，比如Kubernetes Dashboard，它提供了一个GUI，用于查看和与您的集群进行交互。
- en: At this point, you should have a high-level idea of the major components of
    Kubernetes. Next, we will review how a user interacts with Kubernetes to control
    those components.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该对Kubernetes的主要组件有一个高层次的了解。接下来，我们将回顾用户如何与Kubernetes交互以控制这些组件。
- en: Authentication and authorization on Kubernetes
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes上的身份验证和授权
- en: Namespaces are an extremely important concept in Kubernetes, and since they
    can affect API access as well as authorization, we'll cover them now.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是Kubernetes中一个非常重要的概念，因为它们可以影响API访问以及授权，我们现在将介绍它们。
- en: Namespaces
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: A namespace in Kubernetes is a construct that allows you to group Kubernetes
    resources in your cluster. They are a method of separation with many possible
    uses. For instance, you could have a namespace in your cluster for each environment
    – dev, staging, and production.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的命名空间是一种构造，允许您在集群中对Kubernetes资源进行分组。它们是一种分离的方法，有许多可能的用途。例如，您可以在集群中为每个环境（开发、暂存和生产）创建一个命名空间。
- en: By default, Kubernetes will create the default namespace, the `kube-system`
    namespace, and the `kube-public` namespace. Resources created without a specified
    namespace will be created in the default namespace. `kube-system` contains the
    cluster services such as `etcd`, the scheduler, and any resource created by Kubernetes
    itself and not users. `kube-public` is readable by all users by default and can
    be used for public resources.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kubernetes将创建默认命名空间、`kube-system`命名空间和`kube-public`命名空间。在未指定命名空间的情况下创建的资源将在默认命名空间中创建。`kube-system`包含集群服务，如`etcd`、调度程序以及Kubernetes本身创建的任何资源，而不是用户创建的资源。`kube-public`默认情况下可被所有用户读取，并且可用于公共资源。
- en: Users
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户
- en: There are two types of users in Kubernetes – regular users and service accounts.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中有两种类型的用户 - 常规用户和服务帐户。
- en: Regular users are generally managed by a service outside the cluster, whether
    they be private keys, usernames and passwords, or some form of user store. Service
    accounts however are managed by Kubernetes and restricted to specific namespaces.
    To create a service account, the Kubernetes API may automatically make one, or
    they can be made manually through calls to the Kubernetes API.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常由集群外的服务管理常规用户，无论是私钥、用户名和密码，还是某种用户存储形式。但是，服务帐户由Kubernetes管理，并且受限于特定的命名空间。要创建服务帐户，Kubernetes
    API可能会自动创建一个，或者可以通过调用Kubernetes API手动创建。
- en: There are three possible types of requests to the Kubernetes API – those associated
    with a regular user, those associated with a service account, and anonymous requests.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API有三种可能的请求类型 - 与常规用户关联的请求，与服务帐户关联的请求和匿名请求。
- en: Authentication methods
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证方法
- en: 'In order to authenticate requests, Kubernetes provides several different options:
    HTTP basic authentication, client certificates, bearer tokens, and proxy-based
    authentication.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对请求进行身份验证，Kubernetes提供了几种不同的选项：HTTP基本身份验证、客户端证书、bearer令牌和基于代理的身份验证。
- en: To use HTTP authentication, the requestor sends requests with an `Authorization`
    header that will have the value bearer `"token value"`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用HTTP身份验证，请求者发送带有`Authorization`头的请求，其值为bearer `"token value"`。
- en: In order to specify which tokens are valid, a CSV file can be provided to the
    API server application when it starts using the `--token-auth-file=filename` parameter.
    A new beta feature (as of the writing of this book), called *Bootstrap Tokens*,
    allows for the dynamic swapping and changing of tokens while the API server is
    running, without restarting it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定哪些令牌是有效的，可以在API服务器应用程序启动时使用`--token-auth-file=filename`参数提供一个CSV文件。一个新的测试功能（截至本书撰写时），称为*引导令牌*，允许在API服务器运行时动态交换和更改令牌，而无需重新启动它。
- en: Basic username/password authentication is also possible via the `Authorization`
    token, by using the header value `Basic base64encoded(username:password)`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过`Authorization`令牌进行基本的用户名/密码身份验证，方法是使用头部值`Basic base64encoded(username:password)`。
- en: Kubernetes' certificate infrastructure for TLS and security
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes的TLS和安全证书基础设施
- en: In order to use client certificates (X.509 certificates), the API server must
    be started using the `--client-ca-file=filename` parameter. This file needs to
    contain one or more **Certificate Authorities** (**CAs**) that will be used when
    validating certificates passed with API requests.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用客户端证书（X.509证书），API服务器必须使用`--client-ca-file=filename`参数启动。该文件需要包含一个或多个用于验证通过API请求传递的证书的**证书颁发机构**（**CAs**）。
- en: In addition to the **CA**, a **Certificate Signing Request** (**CSR**) must
    be created for each user. At this point, user `groups` can be included, which
    we will discuss in the *Authorization* options section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**CA**之外，必须为每个用户创建一个**证书签名请求**（**CSR**）。在这一点上，可以包括用户`groups`，我们将在*授权*选项部分讨论。
- en: 'For instance, you can use the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用以下内容：
- en: '[PRE0]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will create a CSR for the user `myuser` who is part of groups named `dev`
    and `staging`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为名为`myuser`的用户创建一个CSR，该用户属于名为`dev`和`staging`的组。
- en: Once the CA and CSR are created, the actual client and server certificates can
    be created using `openssl`, `easyrsa`, `cfssl`, or any certificate generation
    tool. TLS certificates for the Kubernetes API can also be created at this point.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 创建CA和CSR后，可以使用`openssl`、`easyrsa`、`cfssl`或任何证书生成工具创建实际的客户端和服务器证书。此时还可以创建用于Kubernetes
    API的TLS证书。
- en: Since our aim is to get you started running workloads on Kubernetes as soon
    as possible, we will leave all the various possible certificate configurations
    out of this book – but both the Kubernetes documentation and the article *Kubernetes
    The Hard Way* have some great tutorials on setting up a cluster from scratch.
    In the majority of production settings, you will not be doing these steps manually.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的目标是尽快让您开始在Kubernetes上运行工作负载，我们将不在本书中涉及各种可能的证书配置 - 但Kubernetes文档和文章* Kubernetes
    The Hard Way*都有一些关于从头开始设置集群的很棒的教程。在大多数生产环境中，您不会手动执行这些步骤。
- en: Authorization options
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权选项
- en: 'Kubernetes provides several authorization methods: nodes, webhooks, RBAC, and
    ABAC. In this book, we will focus on RBAC and ABAC as they are the ones used most
    often for user authorization. If you extend your cluster with other services and/or
    custom features, the other authorization modes may become more important.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了几种授权方法：节点、webhooks、RBAC和ABAC。在本书中，我们将重点关注RBAC和ABAC，因为它们是用户授权中最常用的方法。如果您通过其他服务和/或自定义功能扩展了集群，则其他授权模式可能变得更加重要。
- en: RBAC
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RBAC
- en: '**RBAC** stands for **Role-Based Access Control** and is a common pattern for
    authorization. In Kubernetes specifically, the roles and users of RBAC are implemented
    using four Kubernetes resources: `Role`, `ClusterRole`, `RoleBinding`, and `ClusterRoleBinding`.
    To enable RBAC mode, the API server can be started with the `--authorization-mode=RBAC`
    parameter.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**RBAC**代表**基于角色的访问控制**，是一种常见的授权模式。在Kubernetes中，RBAC的角色和用户使用四个Kubernetes资源来实现：`Role`、`ClusterRole`、`RoleBinding`和`ClusterRoleBinding`。要启用RBAC模式，API服务器可以使用`--authorization-mode=RBAC`参数启动。'
- en: '`Role` and `ClusterRole` resources specify a set of permissions, but do not
    assign those permissions to any specific users. Permissions are specified using
    `resources` and `verbs`. Here is a sample YAML file specifying a `Role`. Don''t
    worry too much about the first few lines of the YAML file – we''ll get to those
    soon. Focus on the `resources` and `verbs` lines to see how the actions can be
    applied to resources:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Role`和`ClusterRole`资源指定了一组权限，但不会将这些权限分配给任何特定的用户。权限使用`resources`和`verbs`来指定。以下是一个指定`Role`的示例YAML文件。不要太担心YAML文件的前几行
    - 我们很快就会涉及到这些内容。专注于`resources`和`verbs`行，以了解如何将操作应用于资源：'
- en: Read-only-role.yaml
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 只读角色.yaml
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The only difference between a `Role` and `ClusterRole` is that a `Role` is restricted
    to a particular namespace (in this case, the default namespace), while a `ClusterRole`
    can affect access to all resources of that type in the cluster, as well as cluster-scoped
    resources such as nodes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Role` 和 `ClusterRole` 之间唯一的区别是，`Role` 限定于特定的命名空间（在本例中是默认命名空间），而 `ClusterRole`
    可以影响集群中该类型的所有资源的访问，以及集群范围的资源，如节点。'
- en: '`RoleBinding` and `ClusterRoleBinding` are resources that associate a `Role`
    or `ClusterRole` with a user or a list of users. The following file represents
    a `RoleBinding` resource to connect our `read-only-role` with a user, `readonlyuser`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`RoleBinding` 和 `ClusterRoleBinding` 是将 `Role` 或 `ClusterRole` 与用户或用户列表关联的资源。以下文件表示一个
    `RoleBinding` 资源，将我们的 `read-only-role` 与用户 `readonlyuser` 连接起来：'
- en: Read-only-rb.yaml
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 只读-rb.yaml
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `subjects` key contains a list of all entities to associate a role with;
    in this case, the user `alex`. `roleRef` contains the name of the role to associate,
    and the type (either `Role` or `ClusterRole`).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`subjects` 键包含要将角色与的所有实体的列表；在本例中是用户 `alex`。`roleRef` 包含要关联的角色的名称和类型（`Role`
    或 `ClusterRole`）。'
- en: ABAC
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ABAC
- en: '**ABAC** stands for **Attribute-Based Access Control**. ABAC works using *policies*
    instead of roles. The API server is started in ABAC mode with a file called an
    authorization policy file, which contains a list of JSON objects called policy
    objects. To enable ABAC mode, the API server can be started with the `--authorization-mode=ABAC`
    and `--authorization-policy-file=filename` parameters.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**ABAC** 代表 **基于属性的访问控制**。ABAC 使用 *策略* 而不是角色。API 服务器在 ABAC 模式下启动，使用一个称为授权策略文件的文件，其中包含一个名为策略对象的
    JSON 对象列表。要启用 ABAC 模式，API 服务器可以使用 `--authorization-mode=ABAC` 和 `--authorization-policy-file=filename`
    参数启动。'
- en: 'In the policy file, each policy object contains information about a single
    policy: firstly, which subjects it corresponds to, which can be either users or
    groups, and secondly, which resources can be accessed via the policy. Additionally,
    a Boolean `readonly` value can be included to limit the policy to `list`, `get`,
    and `watch` operations.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在策略文件中，每个策略对象包含有关单个策略的信息：首先，它对应的主体，可以是用户或组，其次，可以通过策略访问哪些资源。此外，可以包括一个布尔值 `readonly`，以限制策略仅限于
    `list`、`get` 和 `watch` 操作。
- en: A secondary type of policy is associated not with a resource, but with types
    of non-resource requests, such as calls to the `/version` endpoint.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与资源关联的第二种类型的策略与非资源请求类型相关联，例如对 `/version` 端点的调用。
- en: When a request to the API is made in ABAC mode, the API server will check the
    user and any group it is a part of against the list in the policy file, and see
    if any policies match the resource or endpoint that the user is trying to access.
    On a match, the API server will authorize the request.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 ABAC 模式下对 API 发出请求时，API 服务器将检查用户及其所属的任何组是否与策略文件中的列表匹配，并查看是否有任何策略与用户正在尝试访问的资源或端点匹配。匹配时，API
    服务器将授权请求。
- en: You should have a good understanding now of how the Kubernetes API handles authentication
    and authorization. The good news is that while you can directly access the API,
    Kubernetes provides an excellent command-line tool to simply authenticate and
    make Kubernetes API requests.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该对 Kubernetes API 如何处理身份验证和授权有了很好的理解。好消息是，虽然您可以直接访问 API，但 Kubernetes 提供了一个出色的命令行工具，可以简单地进行身份验证并发出
    Kubernetes API 请求。
- en: Using kubectl and YAML
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 kubectl 和 YAML
- en: kubectl is the officially supported command-line tool for accessing the Kubernetes
    API. It can be installed on Linux, macOS, or Windows.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl 是官方支持的命令行工具，用于访问 Kubernetes API。它可以安装在 Linux、macOS 或 Windows 上。
- en: Setting up kubectl and kubeconfig
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 kubectl 和 kubeconfig
- en: To install the newest release of kubectl, you can use the installation instructions
    at [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装最新版本的kubectl，可以使用[https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)上的安装说明。
- en: 'Once kubectl is installed, it needs to be set up to authenticate with one or
    more clusters. This is done using the `kubeconfig` file, which looks like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了kubectl之后，需要设置身份验证以与一个或多个集群进行身份验证。这是使用`kubeconfig`文件完成的，其外观如下：
- en: Example-kubeconfig
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 示例-kubeconfig
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This file is written in YAML and is very similar to other Kubernetes resource
    specifications that we will get to shortly – except that this file lives only
    on your local machine.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件以YAML编写，与我们即将介绍的其他Kubernetes资源规范非常相似 - 只是该文件仅驻留在您的本地计算机上。
- en: 'There are three sections to a `Kubeconfig` YAML file: `clusters`, `users`,
    and `contexts`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kubeconfig` YAML文件有三个部分：`clusters`，`users`和`contexts`：'
- en: The `clusters` section is a list of clusters that you will be able to access
    via kubectl, including the CA filename and server API endpoint.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clusters`部分是您可以通过kubectl访问的集群列表，包括CA文件名和服务器API端点。'
- en: The `users` section lists users that you will be able to authorize with, including
    any user certificates or username/password combinations for authentication.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users`部分列出了您可以授权的用户，包括用于身份验证的任何用户证书或用户名/密码组合。'
- en: Finally, the `contexts` section lists combinations of a cluster, a namespace,
    and a user that combine to make a context. Using the `kubectl config use-context`
    command, you can easily switch between contexts, which allows easy switching between
    cluster, user, and namespace combinations.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`contexts`部分列出了集群、命名空间和用户的组合，这些组合形成一个上下文。使用`kubectl config use-context`命令，您可以轻松地在上下文之间切换，从而实现集群、用户和命名空间组合的轻松切换。
- en: Imperative versus declarative commands
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令式与声明式命令
- en: 'There are two paradigms for talking to the Kubernetes API: imperative and declarative.
    Imperative commands allow you to dictate to Kubernetes "what to do" – that is,
    "spin up two copies of Ubuntu," "scale this application to five copies," and so
    on.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与Kubernetes API交互有两种范式：命令式和声明式。命令式命令允许您向Kubernetes“指示要做什么” - 也就是说，“启动两个Ubuntu副本”，“将此应用程序扩展到五个副本”等。
- en: Declarative commands, on the other hand, allow you to write a file with a specification
    of what should be running on the cluster, and have the Kubernetes API ensure that
    the configuration matches the cluster configuration, updating it if necessary.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，声明式命令允许您编写一个文件，其中包含应在集群上运行的规范，并且Kubernetes API确保配置与集群配置匹配，并在必要时进行更新。
- en: Though imperative commands allow you to quickly get started with Kubernetes,
    it is far better to write some YAML and use a declarative configuration when running
    production workloads, or workloads of any complexity. The reason for this is that
    it makes it easier to track changes, for instance via a GitHub repo, or introduce
    Git-driven **Continous Integration/Continuous** Delivery (**CI/CD**) to your cluster.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管命令式命令允许您快速开始使用Kubernetes，但最好在运行生产工作负载或任何复杂工作负载时编写一些YAML并使用声明性配置。原因是这样做可以更容易地跟踪更改，例如通过GitHub存储库，或者向您的集群引入基于Git的持续集成/持续交付（CI/CD）。
- en: Some basic kubectl commands
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一些基本的kubectl命令
- en: kubectl provides many convenient commands for checking the current state of
    your cluster, querying resources, and creating new ones. kubectl is structured
    so most commands can access resources in the same way.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl提供了许多方便的命令来检查集群的当前状态，查询资源并创建新资源。 kubectl的结构使大多数命令可以以相同的方式访问资源。
- en: First, let's learn how to see Kubernetes resources in your cluster. You can
    do this by using `kubectl get resource_type` where `resource_type` is the full
    name of the Kubernetes resource, or alternately, a shorter alias. A full list
    of aliases (and `kubectl` commands) can be found in the kubectl documentation
    at [https://kubernetes.io/docs/reference/kubectl/overview](https://kubernetes.io/docs/reference/kubectl/overview).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们学习如何查看集群中的Kubernetes资源。您可以使用`kubectl get resource_type`来执行此操作，其中`resource_type`是Kubernetes资源的完整名称，或者是一个更短的别名。别名（和`kubectl`命令）的完整列表可以在kubectl文档中找到：[https://kubernetes.io/docs/reference/kubectl/overview](https://kubernetes.io/docs/reference/kubectl/overview)。
- en: We already know about nodes, so let's start with that. To find which nodes exist
    in a cluster, we can use `kubectl get nodes` or the alias `kubectl get no`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了节点，所以让我们从那里开始。要查找集群中存在哪些节点，我们可以使用`kubectl get nodes`或别名`kubectl get no`。
- en: 'kubectl''s `get` commands return a list of Kubernetes resources that are currently
    in the cluster. We can run this command with any Kubernetes resource type. To
    add additional information to the list, you can add the `wide` output flag: `kubectl
    get nodes -o wide`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl的`get`命令返回当前集群中的Kubernetes资源列表。我们可以使用任何Kubernetes资源类型运行此命令。要向列表添加附加信息，可以添加`wide`输出标志：`kubectl
    get nodes -o wide`。
- en: Listing resources isn't enough, of course – we need to be able to see the details
    of a particular resource. For this, we use the `describe` command, which works
    similarly to `get`, except that we can optionally pass the name of a specific
    resource. If this last parameter is omitted, Kubernetes will return the details
    of all resources of that type, which will probably result in a lot of scrolling
    in your terminal.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列出资源是不够的，当然 - 我们需要能够查看特定资源的详细信息。为此，我们使用`describe`命令，它的工作方式类似于`get`，只是我们可以选择传递特定资源的名称。如果省略了最后一个参数，Kubernetes将返回该类型所有资源的详细信息，这可能会导致终端中大量的滚动。
- en: For example, `kubectl describe nodes` will return details for all nodes in the
    cluster, while `kubectl describe nodes node1` will return a description of the
    node named `node1`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`kubectl describe nodes`将返回集群中所有节点的详细信息，而`kubectl describe nodes node1`将返回名为`node1`的节点的描述。
- en: 'As you''ve probably noticed, these commands are all in the imperative style,
    which makes sense since we''re just fetching information about existing resources,
    not creating new ones. To create a Kubernetes resource, we can use the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，这些命令都是命令式风格的，这是有道理的，因为我们只是获取有关现有资源的信息，而不是创建新资源。要创建Kubernetes资源，我们可以使用以下命令：
- en: '`kubectl create -f /path/to/file.yaml`, which is an imperative command'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl create -f /path/to/file.yaml`，这是一个命令式命令'
- en: '`kubectl apply -f /path/to/file.yaml`, which is declarative'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl apply -f /path/to/file.yaml`，这是声明式的'
- en: Both commands take a path to a file, which can be either YAML or JSON – or you
    can just use `stdin`. You can also pass in the path to a folder instead of a file,
    which will create or apply all YAML or JSON files in that folder. `create` works
    imperatively, so it will create a new resource, but if you run it again with the
    same file, the command will fail since the resource already exists. `apply` works
    declaratively, so if you run it the first time it will create the resource, and
    subsequent runs will update the running resource in Kubernetes with any changes.
    You can use the `--dry-run` flag to see the output of the `create` or `apply`
    commands (that is, what resources will be created, or any errors if they exist).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令都需要一个文件路径，可以是 YAML 或 JSON 格式，或者您也可以使用 `stdin`。您还可以传递文件夹的路径，而不是文件的路径，这将创建或应用该文件夹中的所有
    YAML 或 JSON 文件。`create` 是命令式的，因此它将创建一个新的资源，但如果您再次运行它并使用相同的文件，命令将失败，因为资源已经存在。`apply`
    是声明性的，因此如果您第一次运行它，它将创建资源，而后续运行将使用任何更改更新 Kubernetes 中正在运行的资源。您可以使用 `--dry-run`
    标志来查看 `create` 或 `apply` 命令的输出（即将创建的资源，或者如果存在错误的话）。
- en: 'To update existing resources imperatively, use the `edit` command like so:
    `kubectl edit resource_type resource_name` – just like with our `describe` command.
    This will open up the default terminal editor with the YAML of the existing resource,
    regardless of whether you created it imperatively or declaratively. You can edit
    this and save as usual, which will trigger an automatic update of the resource
    in Kubernetes.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要以命令式方式更新现有资源，可以使用 `edit` 命令，如：`kubectl edit resource_type resource_name` –
    就像我们的 `describe` 命令一样。这将打开默认的终端编辑器，并显示现有资源的 YAML，无论您是以命令式还是声明式方式创建的。您可以编辑并保存，这将触发
    Kubernetes 中资源的自动更新。
- en: To update existing resources declaratively, you can edit your local YAML resource
    file that you used to create the resource in the first place, then run `kubectl
    apply -f /path/to/file.yaml`. Deleting resources is best accomplished via the
    imperative command `kubectl delete resource_type resource_name`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要以声明性方式更新现有资源，可以编辑您用于首次创建资源的本地 YAML 资源文件，然后运行 `kubectl apply -f /path/to/file.yaml`。最好通过命令式命令
    `kubectl delete resource_type resource_name` 来删除资源。
- en: The last command we'll talk about in this section is `kubectl cluster-info`,
    which will show the IP addresses where the major Kubernetes cluster services are
    running.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节讨论的最后一个命令是 `kubectl cluster-info`，它将显示主要 Kubernetes 集群服务运行的 IP 地址。
- en: Writing Kubernetes resource YAML files
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 Kubernetes 资源 YAML 文件
- en: 'For communicating with the Kubernetes API declaratively, formats of both YAML
    and JSON are allowed. For the purposes of this book, we will stick to YAML since
    it is a bit cleaner and takes up less space on the page. A typical Kubernetes
    resource YAML file looks like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 用于与Kubernetes API 声明性通信的格式包括 YAML 和 JSON。为了本书的目的，我们将坚持使用 YAML，因为它更清晰，占用页面空间更少。典型的
    Kubernetes 资源 YAML 文件如下：
- en: resource.yaml
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: resource.yaml
- en: '[PRE4]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A valid Kubernetes YAML file has four top-level keys at a minimum. They are
    `apiVersion`, `kind`, `metadata`, and `spec`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的 Kubernetes YAML 文件至少有四个顶级键。它们是 `apiVersion`、`kind`、`metadata` 和 `spec`。
- en: '`apiVersion` dictates which version of the Kubernetes API will be used to create
    the resource. `kind` specifies what type of resource the YAML file is referencing.
    `metadata` provides a location to name the resource, as well as adding annotations
    and name-spacing information (more on that later). And finally, the `spec` key
    will contain all the resource-specific information that Kubernetes needs to create
    the resource in your cluster.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion`决定将使用哪个版本的Kubernetes API来创建资源。`kind`指定YAML文件引用的资源类型。`metadata`提供了一个位置来命名资源，以及添加注释和命名空间信息（稍后会详细介绍）。最后，`spec`键将包含Kubernetes创建资源所需的所有特定于资源的信息。'
- en: Don't worry about `kind` and `spec` quite yet – we'll get to what a `Pod` is
    in [*Chapter 3*](B14790_03_Final_PG_ePub.xhtml#_idTextAnchor091), *Running Application
    Containers on Kubernetes*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心`kind`和`spec`，我们将在[*第3章*](B14790_03_Final_PG_ePub.xhtml#_idTextAnchor091)中介绍`Pod`是什么，*在Kubernetes上运行应用容器*。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned the background behind container orchestration, an
    architectural overview of a Kubernetes cluster, how a cluster authenticates and
    authorizes API calls, and how to communicate with the API via imperative and declarative
    patterns using kubectl, the officially supported command-line tool for Kubernetes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了容器编排背后的背景，Kubernetes集群的架构概述，集群如何对API调用进行身份验证和授权，以及如何使用kubectl以命令和声明模式与API进行通信，kubectl是Kubernetes的官方支持的命令行工具。
- en: In the next chapter, we'll learn several ways to get started with a test cluster,
    and master harnessing the kubectl commands you've learned so far.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习几种启动测试集群的方法，并掌握到目前为止学到的kubectl命令。
- en: Questions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is container orchestration?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是容器编排？
- en: What are the constituent parts of the Kubernetes control plane, and what do
    they do?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes控制平面的组成部分是什么，它们的作用是什么？
- en: How would you start the Kubernetes API server in ABAC authorization mode?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何启动处于ABAC授权模式的Kubernetes API服务器？
- en: Why is it important to have more than one master node for a production Kubernetes
    cluster?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么对于生产Kubernetes集群来说拥有多个主节点很重要？
- en: What is the difference between `kubectl apply` and `kubectl create`?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubectl apply`和`kubectl create`之间有什么区别？'
- en: How would you switch between contexts using `kubectl`?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用`kubectl`在上下文之间切换？
- en: What are the downsides of creating a Kubernetes resource declaratively and then
    editing it imperatively?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以声明方式创建Kubernetes资源然后以命令方式进行编辑的缺点是什么？
- en: Further reading
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The official Kubernetes documentation: [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方Kubernetes文档：[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)
- en: '*Kubernetes The Hard Way*: [https://github.com/kelseyhightower/kubernetes-the-hard-way](https://github.com/kelseyhightower/kubernetes-the-hard-way)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kubernetes The Hard Way*：[https://github.com/kelseyhightower/kubernetes-the-hard-way](https://github.com/kelseyhightower/kubernetes-the-hard-way)'
