- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Non-Functional Requirements
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非功能性需求
- en: Once you have gathered the system requirements, it is time to think about the
    impact they have on the architectural design. Scalability, availability, resiliency,
    performance, multithreading, interoperability, security, and other subjects need
    to be analyzed so that we can meet user needs. We refer to these aspects as non-functional
    requirements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您收集了系统需求，就是时候考虑它们对架构设计的影响了。可伸缩性、可用性、弹性、性能、多线程、互操作性、安全性和其他主题需要进行分析，以便我们能够满足用户需求。我们将这些方面称为非功能性需求。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How do .NET 5 and Azure enable scalability, availability, and resiliency?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 5和Azure如何实现可伸缩性、可用性和弹性？
- en: Performance issues that need to be considered when programming in C#
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用C#编程时需要考虑的性能问题
- en: Software usability, that is, how to design effective user interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件的可用性，也就是如何设计有效的用户界面
- en: .NET 5 and interoperability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 5和互操作性
- en: Achieving security by design
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设计实现安全性
- en: Book use case – understanding the main types of .NET Core projects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍用例-了解.NET Core项目的主要类型
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The samples provided in this chapter will require Visual Studio 2019 Community
    Edition with .NET 5 SDK installed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的示例将需要安装有.NET 5 SDK的Visual Studio 2019社区版。
- en: You can find the sample code for this chapter at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5)找到本章的示例代码。
- en: Enabling scalability, availability, and resiliency with Azure and .NET 5
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Azure和.NET 5实现可伸缩性、可用性和弹性
- en: A short search on scalability returns a definition such as *the ability of a
    system to keep working well when there is an increase in demand*. Once developers
    read this, many of them incorrectly conclude *that scalability only means adding
    more hardware to keep things working without stopping the app*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对可伸缩性的简短搜索返回了这样的定义，即*系统在需求增加时保持良好运行的能力*。一旦开发人员读到这一点，他们中的许多人错误地得出结论*可伸缩性只意味着添加更多硬件以使应用程序在不停止的情况下继续工作*。
- en: Scalability relies on technologies involving hardware solutions. However, as
    a software architect, you must be aware that good software will keep scalability
    in a sustainable model, which means that a well-architected software can save
    a lot of money. Hence, it is not just a matter of hardware but also a matter of
    overall software design. The point here is that the running cost of a system should
    also be a factor in the architectural decisions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可伸缩性依赖于涉及硬件解决方案的技术。然而，作为软件架构师，您必须意识到良好的软件将保持可伸缩性在可持续模型中，这意味着良好架构的软件可以节省大量资金。因此，这不仅仅是硬件的问题，也是整体软件设计的问题。这里的重点是系统的运行成本也应该是架构决策的一个因素。
- en: In *Chapter 1*, *Understanding the Importance of Software Architecture*, while
    discussing software performance, we proposed some good tips to overcome bad performance
    issues. The same tips will help you with scalability too. The fewer resources
    we spend on each process, the more users the application can handle.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1章* *理解软件架构的重要性*中，我们在讨论软件性能时提出了一些克服性能问题的好建议。相同的建议也将帮助您实现可伸缩性。我们在每个过程上花费的资源越少，应用程序就能处理更多用户。
- en: Although scalability is important, cloud computing applications must be designed
    to work with system failures. Every time you guarantee that your application recovers
    from a failure without exposing this failure to the end user, you are creating
    a resilient application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可伸缩性很重要，但云计算应用程序必须设计为能够处理系统故障。每当您确保应用程序从故障中恢复而不向最终用户暴露这种故障时，您就在创建一个弹性应用程序。
- en: You may find cloud architecture resiliency patterns at [https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency)找到云架构弹性模式。
- en: The reason why resiliency is especially important in cloud scenarios is because
    the infrastructure provided to you may need a small amount of time to manage updates,
    resets, and even hardware upgrades. You are also more likely to be working with
    multiple systems, and transient errors are likely to occur in communicating with
    them. That is why this non-functional requirement started to be spread in recent
    years.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在云场景中，弹性尤为重要的原因是因为提供给您的基础设施可能需要一小段时间来管理更新、重置，甚至硬件升级。您还更有可能与多个系统一起工作，并且在与它们通信时可能会发生瞬态错误。这就是为什么这种非功能性需求在最近几年开始传播。
- en: The possibility of having scalable and resilient solutions gets more exciting
    when you can enable high availability in the system. All the approaches presented
    in this book will guide you to design solutions with good availability, but in
    some cases, you will need to design specific alternatives to achieve the goal
    you have.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当您能够在系统中实现高可用性时，具有可伸缩性和弹性解决方案的可能性变得更加令人兴奋。本书中提出的所有方法都将指导您设计具有良好可用性的解决方案，但在某些情况下，您需要设计特定的替代方案来实现您的目标。
- en: You may find cloud architecture availability patterns at [https://docs.microsoft.com/en-us/azure/architecture/patterns/category/availability](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/availability).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/azure/architecture/patterns/category/availability](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/availability)找到云架构可用性模式。
- en: It is worth knowing that Azure and .NET 5 web apps can be configured to achieve
    these non-functional requirements. Let us check this out in the following subsections.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 值得知道的是，Azure和.NET 5 Web应用程序可以配置以实现这些非功能性需求。让我们在以下小节中进行检查。
- en: Creating a scalable web app in Azure
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Azure中创建可伸缩的Web应用程序
- en: It is simple to create a web app in Azure, ready for scaling. The reason why
    you must do so is to be able to maintain different numbers of users during different
    seasons. The more users you have, the more hardware you will need. Let us show
    you how to create a scalable web application in Azure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure中创建一个可扩展的Web应用程序非常简单。您必须这样做的原因是能够在不同季节维护不同数量的用户。用户越多，您就需要更多的硬件。让我们向您展示如何在Azure中创建一个可扩展的Web应用程序。
- en: 'As soon as you log in to your Azure account, you will be able to create a new
    resource (web app, database, virtual machine, and so on), as you can see in the
    following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您登录到Azure帐户，您就可以创建新资源（Web应用程序、数据库、虚拟机等），如下屏幕截图所示：
- en: '![](img/B16756_02_01.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_02_01.png)'
- en: 'Figure 2.1: Microsoft Azure – Create a resource'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：Microsoft Azure - 创建资源
- en: 'After that, you can select **Web App** in the **Popular Options**, or even
    type it into the **Search the Marketplace** textbox. This action will take you
    to the following screen:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可以在**热门选项**中选择**Web应用程序**，或者在**搜索市场**文本框中输入它。此操作将带您到以下屏幕：
- en: '![](img/B16756_02_02.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_02_02.png)'
- en: 'Figure 2.2: Microsoft Azure – Creating a web app'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：Microsoft Azure - 创建Web应用
- en: 'The required **Project Details** are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的**项目详细信息**如下：
- en: '**Subscription**: This is the account that will be charged for all application
    costs.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅**：这是将为所有应用程序成本收费的帐户。'
- en: '**Resource Group**: This is the collection of resources you can define to organize
    policies and permissions. You may specify a new resource group name or add the
    web app to a group specified during the definition of other resources.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源组**：这是您可以定义的资源集合，用于组织策略和权限。您可以指定新的资源组名称，或者将Web应用程序添加到在定义其他资源时指定的组中。'
- en: 'Besides these, the **Instance Details** are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**实例详细信息**如下：
- en: '**Name**: As you can see, the web app name is the URL that your solution will
    assume after its creation. The name is checked to ensure it is available.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：如您所见，Web应用程序名称是在创建后您的解决方案将采用的URL。将检查名称以确保其可用。'
- en: '**Publish**: This parameter indicates whether the web app will be delivered
    directly or whether it is going to use Docker technology to publish content. Docker
    will be discussed in more detail in *Chapter 5*, *Applying a Microservice Architecture
    to Your Enterprise Application*. If you opt for the Docker Container publication,
    you will be able to configure the **Image Source**, **Access Type**, and **Image**
    and tag information to have it deployed to the web app.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布**：此参数指示Web应用程序是否将直接交付，或者是否将使用Docker技术来发布内容。 Docker将在*第5章*“将微服务架构应用于企业应用程序”中进行更详细的讨论。如果选择Docker容器发布，您将能够配置**图像源**，**访问类型**和**图像**以及标记信息，以便将其部署到Web应用程序。'
- en: '**Runtime stack**: This option is obviously only available when you decide
    to deliver code directly. At the time this chapter was written, you could define
    stacks for .NET Core, ASP.NET, Java 11, Java 8, Node, PHP, Python, and Ruby.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时堆栈**：显然，此选项仅在您决定直接交付代码时才可用。在撰写本章时，您可以为.NET Core、ASP.NET、Java 11、Java 8、Node、PHP、Python和Ruby定义堆栈。'
- en: '**Operating System**: This is the option for defining the OS that will host
    the web app. Both Windows and Linux may be used for ASP.NET Core projects.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统**：这是用于托管Web应用程序的操作系统的选项。 Windows和Linux都可以用于ASP.NET Core项目。'
- en: '**Region**: You may consider where you want to deploy your application, considering
    Azure has many different data centers all over the world.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域**：您可以考虑要部署应用程序的位置，考虑到Azure在世界各地有许多不同的数据中心。'
- en: '**App Service Plan**: This is where you define the hardware plan that is used
    to handle the web app and the region of the servers. This choice defines application
    scalability, performance, and costs.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用服务计划**：这是您定义用于处理Web应用程序和服务器区域的硬件计划的地方。此选择定义应用程序的可扩展性、性能和成本。'
- en: '**Monitoring**: This is a useful Azure toolset for monitoring and troubleshooting
    web apps. In this section, you will be able to enable Application Insights. It
    is always recommended that you keep the same regions for different components
    of your solution, since this will save costs in terms of traffic exchange from
    one data center to another.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控**：这是一个用于监控和故障排除Web应用程序的有用的Azure工具集。在本节中，您将能够启用应用程序洞察。建议您始终为解决方案的不同组件保持相同的区域，因为这将节省从一个数据中心到另一个数据中心的流量交换成本。'
- en: 'Once you have created your web app, this application may be scaled in two conceptually
    different ways: Vertically **(Scale up)** and Horizontally **(Scale out)**. Both
    are available in the web app settings, as you can see in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Web应用程序后，可以以两种概念上不同的方式扩展此应用程序：垂直**（向上扩展）**和水平**（向外扩展）**。如您在以下屏幕截图中所见，这两种方式都可以在Web应用程序设置中找到：
- en: '![](img/B16756_02_03.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_02_03.png)'
- en: 'Figure 2.3: Scaling options of web apps'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：Web应用程序的扩展选项
- en: Let us check out the two types of scaling.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看两种扩展类型。
- en: Vertical scaling (Scaling up)
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 垂直扩展（向上扩展）
- en: 'Scaling up means changing the specification of hardware that will host your
    application. In Azure, you have the opportunity of starting with free, shared
    hardware and moving to an isolated machine in a few clicks. The following screenshot
    shows the user interface for scaling up a web app:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展意味着更改将托管您的应用程序的硬件规格。在Azure中，您有机会从免费共享硬件开始，并在几次点击后转移到独立的机器。以下屏幕截图显示了扩展Web应用程序的用户界面：
- en: '![](img/B16756_02_04.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_02_04.png)'
- en: 'Figure 2.4: Vertical scaling options'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：垂直扩展选项
- en: By choosing one of the options provided, you can select more powerful hardware
    (machines with more CPUs, storage, and RAM). Monitoring your application and its
    App Service plan will guide you on how to decide the best infrastructure for running
    the solution you are proving. It will also offer key insights, such as possible
    CPU, memory, and I/O bottlenecks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择提供的选项之一，您可以选择更强大的硬件（具有更多CPU、存储和RAM的机器）。监视您的应用程序及其应用服务计划将指导您决定运行您正在验证的解决方案的最佳基础设施。它还将提供关键见解，例如可能的CPU、内存和I/O瓶颈。
- en: Horizontal scaling (Scaling out)
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 水平扩展（扩展）
- en: 'Scaling out means splitting all requests among more servers with the same capacity
    instead of using more powerful machines. The load on all the servers is automatically
    balanced by the Azure infrastructure. This solution is advised when the overall
    load may change considerably in the future since horizontal scaling can be automatically
    adapted to the current load. The following screenshot shows an automatic **Scale
    out** strategy defined by two simple rules, which is triggered by CPU usage:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展意味着将所有请求分配给更多具有相同容量的服务器，而不是使用更强大的机器。所有服务器的负载都会被Azure基础架构自动平衡。当整体负载可能在未来发生相当大的变化时，建议使用这种解决方案，因为水平扩展可以自动适应当前负载。下面的屏幕截图显示了由两个简单规则定义的自动**扩展**策略，该策略由CPU使用率触发：
- en: '![](img/B16756_02_05.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_02_05.png)'
- en: 'Figure 2.5: Horizontal scaling sample'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：水平扩展示例
- en: It is worth highlighting that you can choose to have a hardcoded instance count
    or implement rules for automatic scale in/out.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的是，您可以选择具有硬编码实例计数或实现自动缩放规则。
- en: A complete description of all the available auto-scale rules is beyond the purpose
    of this book. However, they are quite self-explanatory, and the *Further reading*
    section contains links to the full documentation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可用自动缩放规则的完整描述超出了本书的目的。但是，它们相当容易理解，*进一步阅读*部分包含了完整文档的链接。
- en: The *Scale out* feature is only available in paid service plans.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*扩展*功能仅适用于付费服务计划。'
- en: In general, horizontal scaling is a way to guarantee availability in the application
    even with a number of simultaneous accesses. For sure, its use is not the only
    way to keep a system available, but it will definitely help.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，水平扩展是一种确保应用程序即使在大量同时访问的情况下也可用的方法。当然，它的使用并不是保持系统可用性的唯一方法，但它肯定会有所帮助。
- en: Creating a scalable web app with .NET 5
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用.NET 5创建可扩展的Web应用程序
- en: Among all the available frameworks for implementing web apps, running it with
    ASP.NET Core 5 ensures good performance, together with low production and maintenance
    costs. The union of C#, a strongly typed and advanced general-purpose language,
    and continuous performance improvements achieved in the framework, mark this option
    out in recent years as one of the best for enterprise development.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有可用的实现Web应用程序的框架中，使用ASP.NET Core 5运行可以确保良好的性能，同时具有较低的生产和维护成本。C#作为一种强类型和先进的通用语言，与框架中实现的持续性能改进相结合，使得这个选择在近年来成为企业开发中最佳选择之一。
- en: The steps that follow will guide you through the creation of an ASP.NET Core
    Runtime 5-based web app. All the steps are quite simple, but some details require
    attention.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤将指导您创建基于ASP.NET Core Runtime 5的Web应用程序。所有步骤都非常简单，但一些细节需要注意。
- en: It is worth mentioning that .NET 5 brings the opportunity to develop to any
    platform – Desktops (WPF, Windows Forms, and UWP), Web (ASP.NET), Cloud (Azure),
    Mobile (Xamarin), Gaming (Unity), IoT (ARM32 and ARM64), and AI (ML.NET and .NET
    for Apache Spark). So, the recommendation from now on is to only use .NET 5\.
    In this scenario, you can run your web app on both Windows and cheaper Linux servers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，.NET 5为开发提供了在任何平台上进行开发的机会-桌面（WPF，Windows Forms和UWP），Web（ASP.NET），云（Azure），移动（Xamarin），游戏（Unity），物联网（ARM32和ARM64）和人工智能（ML.NET和.NET
    for Apache Spark）。因此，从现在开始的建议是只使用.NET 5。在这种情况下，您可以在Windows和更便宜的Linux服务器上运行Web应用程序。
- en: 'Nowadays, Microsoft recommends classic .NET, just in case the features you
    need are not available in .NET Core, or even when you deploy your web app in an
    environment that does not support .NET Core. In any other case, you should prefer
    .NET Core Framework because it allows you to do the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，微软建议使用经典的.NET，以防您需要的功能在.NET Core中不可用，或者当您在不支持.NET Core的环境中部署Web应用程序时。在其他情况下，您应该优先选择.NET
    Core框架，因为它允许您执行以下操作：
- en: Run your web app in Windows, Linux, macOS, or Docker containers
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows、Linux、macOS或Docker容器中运行您的Web应用程序
- en: Design your solution with microservices
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计您的解决方案与微服务
- en: Have high performance and scalable systems
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有高性能和可伸缩的系统
- en: Containers and microservices will be covered in *Chapter 5*, *Applying a Microservice
    Architecture to Your Enterprise Application*. There, you will get a better understanding
    of the advantages of these technologies. For now, it is enough to say that .NET
    5 and microservices were designed for performance and scalability, which is why
    you should prefer .NET 5 in all your new projects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和微服务将在*第5章* *将微服务架构应用于企业应用程序*中进行介绍。在那里，您将更好地了解这些技术的优势。目前，可以说.NET 5和微服务是为性能和可伸缩性而设计的，这就是为什么您应该在所有新项目中优先选择.NET
    5的原因。
- en: 'The following procedure will show you how to create an ASP.NET Core web app
    in Visual Studio 2019 with .NET 5:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将向您展示如何在Visual Studio 2019中使用.NET 5创建ASP.NET Core Web应用程序：
- en: As soon as you start VS 2019, you will be able to click on **Create a new project**.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您启动VS 2019时，您将能够点击**创建新项目**。
- en: Once you select **ASP.NET Core Web Application**, you will be directed to a
    screen where you will be asked to set up the **Project name**, **Location**, and
    **Solution name**:![](img/B16756_02_06.png)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦您选择**ASP.NET Core Web应用程序**，您将被引导到一个屏幕，在那里您将被要求设置**项目名称**、**位置**和**解决方案名称**：![](img/B16756_02_06.png)
- en: 'Figure 2.6: Creating an ASP.NET Core web application'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：创建ASP.NET Core Web应用程序
- en: After that, you will be able to select the .NET version to use. Select **ASP.NET
    Core 5.0** to get the most advanced and brand-new platform. For this demo, you
    can select the **Web Application** template.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，您将能够选择要使用的 .NET 版本。选择**ASP.NET Core 5.0**以获得最先进和全新的平台。对于此演示，您可以选择**Web 应用程序**模板。
- en: Now that we are done with adding the basic details, you can connect your web
    app project to your Azure account and have it published.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们已经添加了基本细节，您可以将您的 Web 应用项目连接到您的 Azure 帐户并将其发布。
- en: If you right-click the project you created, in **Solution Explorer**, you have
    the option to **Publish**:![](img/B16756_02_07.png)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您右键单击您创建的项目，在**解决方案资源管理器**中，您将有**发布**选项：![](img/B16756_02_07.png)
- en: 'Figure 2.7: Publishing the ASP.NET Core web application'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：发布 ASP.NET Core Web 应用程序
- en: You will find different targets to publish your web app. Select **Azure** as
    the target.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将找到不同的目标来发布您的 Web 应用。选择**Azure**作为目标。
- en: Then, you will be able to decide the **Specific target** to publish. Select
    **Azure App Service (Windows)** for this demo.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，您将能够决定要发布的**具体目标**。为此演示选择**Azure App Service (Windows)**。
- en: You may be required to define your Microsoft Account credentials at this time.
    This is because there is full integration between Visual Studio and Azure. This
    gives you the opportunity to view all the resources you created in the Azure portal
    in your development environment:![](img/B16756_02_08.png)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此时可能需要定义您的 Microsoft 帐户凭据。这是因为 Visual Studio 与 Azure 之间有完全集成。这使您有机会在开发环境中查看您在
    Azure 门户中创建的所有资源！[](img/B16756_02_08.png)
- en: 'Figure 2.8: Integration between Visual Studio and Azure'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：Visual Studio 与 Azure 的集成
- en: Once you have decided on your **Publish** settings, that is, the publish profile,
    the web app will be automatically published when you click **Publish**. Pay attention
    here to select the F1 tier of pricing so that this process does not incur any
    costs:![](img/B16756_02_09.png)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦您决定了您的**发布**设置，也就是发布配置文件，当您点击**发布**时，Web 应用将会自动发布。请注意在这里选择 F1 定价层，以便此过程不会产生任何费用：![](img/B16756_02_09.png)
- en: 'Figure 2.9: Publish profile options'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9：发布配置文件选项
- en: You have currently two modes for deployment. The first, Framework-dependent,
    will require a web app configured with the target framework. The second, self-contained,
    will no longer need this feature since the binaries of the framework will be published
    together with the application.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您目前有两种部署模式。第一种是 Framework-dependent，将需要配置目标框架的 Web 应用。第二种是 self-contained，将不再需要此功能，因为框架的二进制文件将与应用程序一起发布。
- en: It is worth mentioning that in order to publish ASP.NET Preview versions in
    Framework-dependent mode, you must add an extension in the web app setup panel
    in Azure Portal, as shown in the following screenshot. However, consider using
    the self-contained mode, especially when you are under preview versions:![](img/B16756_02_10.png)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值得一提的是，为了以 Framework-dependent 模式发布 ASP.NET 预览版本，您必须在 Azure 门户中的 Web 应用设置面板中添加一个扩展，如下截图所示。但是，在预览版本下，考虑使用自包含模式！[](img/B16756_02_10.png)
- en: 'Figure 2.10: Adding extensions in Azure Web App Service'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10：在 Azure Web 应用服务中添加扩展
- en: 'For more information on deploying ASP.NET Core 5.0 to Azure App Service, please
    refer to the following link: [https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-5.0&tabs=visual-studio](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-5.0&tabs=vi).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有关将 ASP.NET Core 5.0 部署到 Azure App Service 的更多信息，请参阅以下链接：[https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-5.0&tabs=visual-studio](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-5.0&tabs=vi)。
- en: Here, we described the simplest way to deploy a web app. In *Chapter 20*, *Understanding
    DevOps Principles* and *Chapter 21*, *Challenges of Applying CI Scenarios*, we
    will introduce you to the Azure DevOps **Continuous Integration/Continuous Delivery**
    (**CI/CD**) pipeline. This pipeline is a further Azure toolset that automates
    all the required steps to get the application in production, that is, building,
    testing, deployment in staging, and deployment in production.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们描述了部署 Web 应用的最简单方法。在*第 20 章*，*理解 DevOps 原则*和*第 21 章*，*应用 CI 场景的挑战*中，我们将向您介绍
    Azure DevOps **持续集成/持续交付**（**CI/CD**）管道。这个管道是一个进一步的 Azure 工具集，它自动化了将应用程序投入生产所需的所有步骤，即构建、测试、部署到暂存区和部署到生产环境。
- en: Performance issues that need to be considered when programming in C#
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 C# 编程中需要考虑的性能问题
- en: Nowadays, C# is one of the most commonly used programming languages all over
    the world, so good tips about C# programming are fundamental for the design of
    good architectures that satisfy the most common non-functional requirements.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，C# 是全球最常用的编程语言之一，因此关于 C# 编程的良好建议对于设计满足最常见非功能性需求的良好架构至关重要。
- en: The following sections mention a few simple but effective tips – the associated
    code samples are available in the GitHub repository of this book.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分提到了一些简单但有效的提示-相关的代码示例可在本书的 GitHub 存储库中找到。
- en: String concatenation
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串连接
- en: This is a classic one! A naive concatenation of strings with the `+` string
    operator may cause serious performance issues since each time two strings are
    concatenated, their contents are copied into a new string.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个经典的例子！使用`+`字符串运算符天真地连接字符串可能会导致严重的性能问题，因为每次连接两个字符串时，它们的内容都会被复制到一个新的字符串中。
- en: So, if we concatenate, for instance, 10 strings that have an average length
    of 100, the first operation has a cost of 200, the second one has a cost of *200+100=300*,
    the third one has a cost of *300+100=400*, and so on. It is not difficult to convince
    yourself that the overall cost grows like *m***n*², where *n* is the number of
    strings and *m* is their average length. *n*² is not too big for small *n* (say,
    *n* < 10), but it becomes quite big when *n* reaches the magnitude of 100-1,000,
    and unacceptable for magnitudes of 10,000-100,000.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们连接，例如，平均长度为100的10个字符串，第一个操作的成本为200，第二个操作的成本为*200+100=300*，第三个操作的成本为*300+100=400*，依此类推。很容易让你相信总体成本增长像*m***n*²，其中*n*是字符串的数量，*m*是它们的平均长度。*n*²对于小*n*（比如，*n*
    < 10）来说并不算太大，但当*n*达到100-1,000数量级时，它就变得相当大，当*n*达到10,000-100,000数量级时就变得不可接受。
- en: 'Let us look at this with some test code, which compares naive concatenation
    with the same operation that is performed with the help of the `StringBuilder`
    class (the code is available in this book''s GitHub repository):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些测试代码来看看这个问题，比较天真的连接和使用`StringBuilder`类执行相同操作的代码（该代码可在本书的GitHub存储库中找到）：
- en: '![](img/B16756_02_11.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_02_11.png)'
- en: 'Figure 2.11: Concatenation test code result'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：连接测试代码结果
- en: If you create a `StringBuilder` class with something like `var sb =new System.Text.StringBuilder()`,
    and then you add each string to it with `sb.Append(currString)`, the strings are
    not copied; instead, their pointers are queued in a list. They are copied in the
    final string just once, when you call `sb.ToString()` to get the final result.
    Accordingly, the cost of `StringBuilder-`based concatenation grows simply as *m*n*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建一个类似`var sb =new System.Text.StringBuilder()`的`StringBuilder`类，然后用`sb.Append(currString)`将每个字符串添加到其中，那么字符串不会被复制；相反，它们的指针会排队在一个列表中。它们只在你调用`sb.ToString()`获取最终结果时被复制到最终字符串中。因此，基于`StringBuilder`的连接成本简单地增长为*m*n*。
- en: Of course, you will probably never find a piece of software with a function
    like the preceding one that concatenates 100,000 strings. However, you need to
    recognize pieces of code similar to these ones where the concatenation of some
    20-100 strings, say, in a web server that handles several requests simultaneously,
    might cause bottlenecks that damage your non-functional requirements for performance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能永远不会找到一个像前面那个连接100,000个字符串的函数的软件片段。然而，你需要识别类似这些的代码片段，比如在同时处理多个请求的Web服务器中连接20-100个字符串可能会导致损害性能的瓶颈。
- en: Exceptions
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Always remember that exceptions are much slower than normal code flow! So, the
    usage of `try-catch` needs to be concise and essential, otherwise, you will create
    big performance issues.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 永远记住，异常比正常代码流慢得多！因此，使用`try-catch`需要简洁和必要，否则，你将会创建大的性能问题。
- en: 'The following two samples compare the usage of `try-catch` and `Int32.TryParse`
    to check whether a string can be converted into an integer, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个示例比较了使用`try-catch`和`Int32.TryParse`来检查字符串是否可以转换为整数：
- en: '[PRE0]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second function does not look dangerous, but it is thousands of times slower
    than the first one:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数看起来并不危险，但比第一个函数慢上千倍：
- en: '![](img/B16756_02_12.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_02_12.png)'
- en: 'Figure 2.12: Exception test code result'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12：异常测试代码结果
- en: To sum this up, exceptions must be used to deal with exceptional cases that
    break the normal flow of control, for instance, situations when operations must
    be aborted for some unexpected reasons, and control must be returned several levels
    up in the call stack.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，异常必须用于处理打破正常控制流的异常情况，例如，操作必须因某些意外原因而中止，控制必须返回调用堆栈中的几个级别。
- en: Multithreading environments for better results – dos and don'ts
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的多线程环境-做和不做
- en: If you want to take advantage of all the hardware that the system you are building
    provides, you must use multithreading. This way, when a thread is waiting for
    an operation to complete, the application can leave the CPU to other threads,
    instead of wasting CPU time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想充分利用正在构建的系统提供的所有硬件，你必须使用多线程。这样，当一个线程在等待操作完成时，应用程序可以将CPU留给其他线程，而不是浪费CPU时间。
- en: 'On the other hand, no matter how hard Microsoft is working to help with this,
    parallel code is not as simple as eating a piece of cake: it is error-prone and
    difficult to test and debug. The most important thing to remember as a software
    architect when you start considering using threads is *does your system require
    them?* Non-functional and some functional requirements will answer this question
    for you.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，无论微软如何努力帮助解决这个问题，并行代码都不像吃蛋糕那样简单：它容易出错，难以测试和调试。当你开始考虑使用线程时，作为软件架构师最重要的事情是*你的系统是否需要它们？*非功能性和一些功能性需求会为你解答这个问题。
- en: 'As soon as you are sure that you need a multithreading system, you should decide
    on which technology is more adequate. There are a few options here, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定需要一个多线程系统，你应该决定哪种技术更合适。这里有几个选项，如下：
- en: '**Creating an instance of** `System.Threading.Thread`: This is a classic way
    of creating threads in C#. The entire thread life cycle will be in your hands.
    This is good when you are sure about what you are going to do, but you need to
    worry about every single detail of the implementation. The resulting code is hard
    to conceive and debug/test/maintain. So, to keep development costs acceptable,
    this approach should be confined to a few fundamental, performance critical modules.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建** `System.Threading.Thread`的实例：这是在C#中创建线程的经典方式。整个线程生命周期将由你掌控。当你确定自己要做什么时，这是很好的，但你需要担心实现的每一个细节。结果代码很难构思和调试/测试/维护。因此，为了保持开发成本可接受，这种方法应该局限于一些基本的、性能关键的模块。'
- en: '**Programming using** `System.Threading.Tasks.Parallel` **classes**: Since
    .NET Framework 4.0, you can use parallel classes to enable threads in a simpler
    way. This is good because you do not need to worry about the life cycle of the
    threads you create, but it will give you less control about what is happening
    in each thread.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** `System.Threading.Tasks.Parallel` **类进行编程**：自.NET Framework 4.0以来，您可以使用并行类以更简单的方式启用线程。这很好，因为您不需要担心创建的线程的生命周期，但这将使您对每个线程中发生的事情控制更少。'
- en: '**Develop using asynchronous programming**: This is, for sure, the easiest
    way to develop multithreaded applications since the compiler takes on most of
    the work. Depending on the way you call an asynchronous method, you may have the
    `Task` created running in parallel with the `Thread` that was used to call it
    or even have this `Thread` waiting without suspending for the task created to
    conclude. This way, asynchronous code mimics the behavior of classical synchronous
    code while keeping most of the performance advantages of general parallel programming:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用异步编程进行开发**：这无疑是开发多线程应用程序的最简单方式，因为编译器承担了大部分工作。根据您调用异步方法的方式，您可能会创建的`Task`与用于调用它的`Thread`并行运行，甚至可能会有这个`Thread`等待而不挂起，直到创建的任务结束。这样，异步代码模仿了经典同步代码的行为，同时保留了一般并行编程的大部分性能优势：'
- en: The overall behavior is deterministic and does not depend on the time taken
    by each task to complete, so non-reproducible bugs are more difficult to happen,
    and the resulting code is easy to test/debug/maintain. Defining a method as an
    asynchronous task or not is the only choice left to the programmer; everything
    else is automatically handled by the runtime. The only thing you should be concerned
    about is which methods should have asynchronous behavior. It is worth mentioning
    that defining a method as `async` does not mean it will execute on a separate
    thread. You may find useful information in a great sample at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总体行为是确定性的，不取决于每个任务完成所花费的时间，因此不可重现的错误更难发生，生成的代码易于测试/调试/维护。将方法定义为异步任务与否是程序员留下的唯一选择；其他一切都由运行时自动处理。您唯一需要关注的是哪些方法应该具有异步行为。值得一提的是，将方法定义为`async`并不意味着它将在单独的线程上执行。您可以在[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/)上找到有用的信息。
- en: Later in this book, we will provide some simple examples of asynchronous programming.
    For more information about asynchronous programming and its related patterns,
    please check *Task-Based Asynchronous Patterns* in the Microsoft documentation
    ([https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynch)).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本书的后面，我们将提供一些异步编程的简单示例。有关异步编程及其相关模式的更多信息，请查看Microsoft文档中的*基于任务的异步模式*([https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynch))。
- en: 'No matter the option you choose, there are some dos and don''ts that, as a
    software architect, you must pay attention to. These are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您选择哪个选项，作为软件架构师，您都必须注意一些要点和禁忌。具体如下：
- en: '**Do use concurrent collections** (`System.Collections.Concurrent`): As soon
    as you start a multithreading application, you have to use these collections.
    The reason for this is that your program will probably manage the same list, dictionary,
    and so on from different threads. The use of concurrent collections is the most
    convenient option for developing thread-safe programs.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用并发集合**(`System.Collections.Concurrent`)：一旦启动多线程应用程序，您就必须使用这些集合。原因是您的程序可能会从不同的线程管理相同的列表、字典等。使用并发集合是开发线程安全程序的最方便选项。'
- en: '**Do worry about static variables**: It is not possible to say that static
    variables are prohibited in multithreading development, but you should pay attention
    to them. Again, multiple threads taking care of the same variable can cause a
    lot of trouble. If you decorate a static variable with the `[ThreadStatic]` attribute,
    each thread will see a different copy of that variable, hence solving the problem
    of several threads competing on the same value. However, `ThreadStatic` variables
    cannot be used for extra-thread communications since values written by a thread
    cannot be read by other threads. In asynchronous programming, `AsyncLocal<T>`
    is the option for doing something like that.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**担心静态变量**：无法说静态变量在多线程开发中是被禁止的，但您应该注意它们。同样，多个线程处理相同的变量可能会引起很多麻烦。如果您使用`[ThreadStatic]`属性修饰静态变量，每个线程将看到该变量的不同副本，从而解决了多个线程竞争相同值的问题。然而，`ThreadStatic`变量不能用于额外的线程通信，因为一个线程写入的值不能被其他线程读取。在异步编程中，`AsyncLocal<T>`是执行类似操作的选项。'
- en: '**Do test system performance after multithreading implementations**: Threads
    give you the ability to take full advantage of your hardware, but in some cases,
    badly written threads can waste CPU time just doing nothing! Similar situations
    may result in almost 100% CPU usage and unacceptable system slowdowns. In some
    cases, the problem can be mitigated or solved by adding a simple `Thread.Sleep(1)`
    call in the main loop of some threads to prevent them from wasting too much CPU
    time, but you need to test this. A use case for this implementation is a Windows
    Service with many threads running in its background.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多线程实现后测试系统性能：线程使您能够充分利用硬件，但在某些情况下，编写不良的线程可能会浪费CPU时间，什么也不做！类似的情况可能导致几乎100%的CPU使用率和不可接受的系统减速。在某些情况下，可以通过在一些线程的主循环中添加简单的`Thread.Sleep(1)`调用来减轻或解决问题，以防止它们浪费太多CPU时间，但您需要测试这一点。这种实现的一个用例是在其后台运行许多线程的Windows服务。
- en: '**Do not consider multithreading easy**: Multithreading is not as simple as
    it seems in some syntax implementations. While writing a multithreading application,
    you should consider things such as the synchronization of the user interface,
    threading termination, and coordination. In many cases, programs just stop working
    well due to a bad implementation of multithreading.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要认为多线程很容易：多线程并不像在某些语法实现中看起来那么简单。在编写多线程应用程序时，你应该考虑诸如用户界面同步、线程终止和协调等问题。在许多情况下，由于多线程的糟糕实现，程序会停止正常工作。
- en: '**Do not forget to plan the number of threads your system should have**: This
    is important especially for 32-bit programs. There is a limitation regarding how
    many threads you can have in any environment. You should consider this when you
    are designing your system.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要忘记规划系统应该有多少线程：这对于32位程序尤其重要。在任何环境中，你可以拥有多少线程都有限制。在设计系统时，你应该考虑这一点。
- en: '**Do not forget to end your threads**: If you do not have the correct termination
    procedure for each thread, you will probably have trouble with memory and handling
    leaks.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要忘记结束你的线程：如果你没有为每个线程正确的终止程序，你可能会在内存和处理泄漏方面遇到麻烦。
- en: Usability – why inserting data takes too much time
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用性-为什么插入数据需要太长时间
- en: Scalability, performance tips, and multithreading are the main tools we can
    use to tune machine performance. However, the effectiveness of the system you
    design depends on the overall performance of the whole processing pipeline, which
    includes both humans and machines.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性、性能提示和多线程是我们可以用来调整机器性能的主要工具。然而，你设计的系统的有效性取决于整个处理流水线的整体性能，其中包括人和机器。
- en: 'As a software architect, you cannot improve the performance of humans, but
    you can improve the performance of man-machine interaction by designing an effective
    **user interface** (**UI**), that is, a user interface that ensures fast interaction
    with humans, which, in turn, means the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，你无法提高人类的表现，但你可以通过设计一个有效的用户界面（UI）来提高人机交互的表现，这意味着以下内容：
- en: The UI must be easy to learn in order to reduce the time that is needed for
    learning and time wasting before the target users learn to operate it quickly.
    This constraint is fundamental if UI changes are frequent, and for public websites
    that need to attract the greatest possible number of users.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI必须易于学习，以减少学习所需的时间和目标用户快速操作之前的时间浪费。如果UI更改频繁，并且需要吸引尽可能多的用户的公共网站，这一约束是基本的。
- en: The UI must not cause any kind of slowdown in data insertion; data entry speed
    must be limited only by the user's ability to type, not by system delays or by
    additional gestures that could be avoided.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI不得在数据插入中引起任何类型的减速；数据输入速度必须仅受用户输入能力的限制，而不受系统延迟或可以避免的额外手势的限制。
- en: 'It is worth mentioning that we have UX experts in the market. As a software
    architect, you must decide when they are essential to the success of the project.
    The following are a few simple tips when it comes to designing *easy to learn*
    user interfaces:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，市场上有UX专家。作为软件架构师，你必须决定他们对项目成功至关重要的时候。以下是在设计易于学习的用户界面时的一些建议：
- en: Each input screen must state its purpose clearly.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个输入屏幕必须清楚地说明其目的。
- en: Use the language of the user, not the language of developers.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用用户的语言，而不是开发者的语言。
- en: Avoid complications. Design the UI with the average case in mind; more complicated
    cases can be handled with extra inputs that appear only when needed. Split complex
    screens into more input steps.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免复杂化。设计UI时要考虑一般情况；更复杂的情况可以通过只在需要时出现的额外输入来处理。将复杂的屏幕分割成更多的输入步骤。
- en: Use past inputs to understand user intentions and to put users on the right
    paths with messages and automatic UI changes; for instance, cascading drop-down
    menus.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过去的输入来理解用户意图，并通过消息和自动UI更改将用户引导到正确的路径；例如，级联下拉菜单。
- en: Error messages are not bad notes the system gives to the user, but they must
    explain how to insert correct input.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误消息不是系统给用户的坏笔记，而是必须解释如何插入正确输入的消息。
- en: 'Fast user interfaces result from efficacious solutions to the following three
    requirements:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 快速的用户界面是通过对以下三个要求的有效解决方案实现的：
- en: Input fields must be placed in the order they are usually filled, and it should
    be possible to move to the next input with the Tab or Enter key. Moreover, fields
    that often remain empty should be placed at the bottom of the form. Simply put,
    the usage of the mouse while filling a form should be minimized. This way, the
    number of user gestures is kept to a minimum. In a web application, once the optimal
    placement of input fields has been decided, it is enough to use the `tabindex`
    attribute to define the right way users move from one input field to the next
    with the Tab key.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入字段必须按照通常填写的顺序放置，并且应该可以使用Tab键或Enter键移动到下一个输入。此外，通常保持为空的字段应该放在表单的底部。简而言之，在填写表单时应尽量减少使用鼠标。这样，用户手势的数量就会被最小化。在Web应用程序中，一旦确定了输入字段的最佳放置位置，只需使用`tabindex`属性即可定义用户使用Tab键从一个输入字段移动到下一个输入字段的正确方式。
- en: System reactions to user inputs must be as fast as possible. Error messages
    (or information ones) must appear as soon as the user leaves the input field.
    The simplest way to achieve this is to move most of the help and input validation
    logic to the client side so that system reactions do not need to pass through
    both communication lines and servers.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统对用户输入的反应必须尽可能快。错误消息（或信息消息）必须在用户离开输入字段后立即出现。实现这一点的最简单方法是将大部分帮助和输入验证逻辑移至客户端，以便系统反应不需要通过通信线路和服务器。
- en: Efficacious selection logic. Selecting an existing item should be as easy as
    possible; for example, selecting one out of some thousands of products in an offer
    must be possible with a few gestures and with no need to remember the exact product
    name or its barcode. The next subsection analyzes techniques we can use to decrease
    complexity to achieve fast selection.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效的选择逻辑。选择现有项目应尽可能简单；例如，在提供的数千种产品中选择一种产品必须能够通过几个手势轻松完成，而无需记住确切的产品名称或其条形码。下一小节分析了我们可以使用的技术，以减少复杂性以实现快速选择。
- en: In *Chapter 16*, *Blazor WebAssembly*, we will discuss how this Microsoft technology
    can help us with the challenges of building web-based applications with C# code
    in the front-end.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第16章*，*Blazor WebAssembly*中，我们将讨论这项微软技术如何帮助我们解决使用C#代码构建基于Web的应用程序的挑战。
- en: Designing fast selection logic
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计快速选择逻辑
- en: 'When all the possible choices are in the order of magnitude of 1-50, the usual
    drop-down menu is enough. For instance, this currency selection drop-down menu:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有可能的选择都在1-50的数量级时，通常的下拉菜单就足够了。例如，这个货币选择下拉菜单：
- en: '![](img/B16756_02_13.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_02_13.png)'
- en: 'Figure 2.13: Simple drop-down menu'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：简单的下拉菜单
- en: 'When the order of magnitude is higher but less than a few thousand, an autocomplete
    that shows the names of all the items that start with the characters typed by
    the user is usually a good choice:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当数量级更高但不超过几千时，通常最好选择一个自动完成菜单，显示所有以用户输入字符开头的项目名称：
- en: '![](img/B16756_02_14.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_02_14.png)'
- en: 'Figure 2.14: Complex drop-down menu'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14：复杂的下拉菜单
- en: A similar solution can be implemented with a low computational cost since all
    the main databases can efficiently select strings that start with a given substring.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的解决方案可以以较低的计算成本实现，因为所有主要数据库都可以高效地选择以给定子字符串开头的字符串。
- en: When names are quite complex, when searching for the characters that were typed
    in by the user, they should be extended inside each item string. This operation
    cannot be performed efficiently with usual databases and requires ad hoc data
    structures.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当名称非常复杂时，当搜索用户输入的字符时，它们应该在每个项目字符串内进行扩展。这种操作无法在通常的数据库中高效执行，需要专门的数据结构。
- en: Finally, when we are searching inside descriptions composed of several words,
    more complex search patterns are needed. This is the case, for instance, with
    product descriptions. If the chosen database supports full-text search, the system
    can search for the occurrence of several words that have been typed by the user
    inside all the descriptions efficiently.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们在由几个单词组成的描述中进行搜索时，需要更复杂的搜索模式。例如，产品描述就是这种情况。如果所选的数据库支持全文搜索，系统可以高效地在所有描述中搜索用户输入的几个单词的出现。
- en: However, when descriptions are made up of names instead of common words, it
    might be difficult for the user to remember a few exact names contained in the
    target description. This happens, for instance, with multi-country company names.
    In these cases, we need algorithms that find the best match for the character
    that was typed by the user. Substrings of the string that was typed by the user
    must be searched in different places of each description. In general, similar
    algorithms can't be implemented efficiently with databases based on indexes, but
    require all the descriptions to be loaded in memory and ranked somehow against
    the string that was typed by the user.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当描述由名称而不是常见单词组成时，用户可能很难记住目标描述中包含的几个确切名称。例如，多国公司名称就是如此。在这些情况下，我们需要找到最适合用户输入字符的算法。用户输入的字符串的子字符串必须在每个描述的不同位置进行搜索。通常情况下，类似的算法无法有效地在基于索引的数据库中实现，而是需要将所有描述加载到内存中，并对用户输入的字符串进行某种排名。
- en: The most famous algorithm in this class is probably the **Levenshtein** algorithm,
    which is used by most spell checkers to find a word that best fits the mistyped
    one by the user. This algorithm minimizes the Levenshtein distance between the
    description and the string typed by the user, that is, the minimum number of character
    removals and additions needed to transform one string into another.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类别中最著名的算法可能是**Levenshtein**算法，大多数拼写检查器使用它来找到一个最适合用户错误输入的单词。该算法最小化了描述和用户输入的字符串之间的Levenshtein距离，即将一个字符串转换为另一个字符串所需的最小字符删除和添加次数。
- en: 'The Levenshtein algorithm works great, but has a very high computational cost.
    Here, we give a faster algorithm that works well for searching character occurrences
    in descriptions. Characters typed by the user don''t need to occur consecutively
    in the description but must occur in the same order. Some characters may miss.
    Each description is given a penalty that depends on the missing characters and
    on how far the occurrences of the characters typed by the user are from the others.
    More specifically, the algorithm ranks each description with two numbers:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Levenshtein算法效果很好，但计算成本很高。在这里，我们提供了一个更快的算法，用于在描述中搜索字符出现次数。用户输入的字符不需要在描述中连续出现，但必须按相同顺序出现。有些字符可能会缺失。每个描述都会根据缺失的字符和用户输入的字符出现的距离给予惩罚。更具体地说，该算法对每个描述进行了两个数字的排名：
- en: 'The number of characters typed by the user that occurs in the description:
    the more characters contained in the description, the higher its rank.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入的字符在描述中出现的次数：描述中包含的字符越多，排名越高。
- en: Each description is given a penalty equal to the total distance among the occurrences
    of the characters typed by the user in the description.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个描述都被赋予一个惩罚，等于描述中用户输入字符之间的总距离。
- en: 'The following screenshot shows how the word **Ireland** is ranked against the
    string **ilad**, which was typed by the user:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了单词**Ireland**与用户输入的字符串**ilad**的排名：
- en: '![](img/B16756_02_15.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_02_15.png)'
- en: 'Figure 2.15: Sample of Levenshtein usage'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15：Levenshtein用法示例
- en: The number of occurrences is four (4), while the total distance between character
    occurrences is three (3).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 出现次数为四（4），而字符出现之间的总距离为三（3）。
- en: 'Once all the descriptions have been rated, they are sorted according to the
    number of occurrences. Descriptions with the same number of occurrences are sorted
    according to the lowest penalties. The following is an autocomplete that implements
    the preceding algorithm:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有描述都被评分，它们将根据出现次数进行排序。出现次数相同的描述将根据最低的惩罚进行排序。以下是实现前述算法的自动完成功能：
- en: '![](img/B16756_02_16.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_02_16.png)'
- en: 'Figure 2.16: Levenshtein algorithm user interface experience'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16：Levenshtein算法用户界面体验
- en: The full class code, along with a test console project, is available in this
    book's GitHub repository.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的类代码以及一个测试控制台项目都可以在本书的GitHub存储库中找到。
- en: Selecting from a huge number of items
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从大量项目中进行选择
- en: Here, *huge* does not refer to the amount of space needed to store the data,
    but to the difficulty the user has in remembering the features of each item. When
    an item must be selected from among more than 10,000-100,000 items, there is no
    hope of finding it by searching for character occurrences inside a description.
    Here, the user must be driven toward the right item through a hierarchy of categories.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，“巨大”并不是指存储数据所需的空间量，而是指用户在记住每个项目的特性时所遇到的困难。当需要从10,000-100,000个项目中选择一个项目时，通过在描述中搜索字符出现的次数来寻找它是没有希望的。在这种情况下，用户必须通过一系列类别来选择正确的项目。
- en: In this case, several user gestures are needed to perform a single selection.
    In other words, each selection requires interaction with several input fields.
    Once it's decided that the selection can't be done with a single input field,
    the simplest option is cascading drop-down menus, that is, a chain of drop-down
    menus whose selection list depends on the values that were selected in the previous
    drop-down menus.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，需要进行多个用户手势才能进行单个选择。换句话说，每个选择都需要与多个输入字段进行交互。一旦确定无法使用单个输入字段进行选择，最简单的选择就是级联下拉菜单，即一系列下拉菜单，其选择列表取决于先前下拉菜单中选择的值。
- en: 'For example, if the user needs to select a town located anywhere in the world,
    we may use the first drop-down menu to select the country, and once the country
    has been chosen, we may use this choice to populate a second one with all the
    towns in the selected country. A simple example is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果用户需要在世界任何地方选择一个城镇，我们可以使用第一个下拉菜单来选择国家，一旦选择了国家，我们可以使用这个选择来填充第二个下拉菜单，其中包含所选国家中的所有城镇。一个简单的例子如下：
- en: '![](img/B16756_02_17.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_02_17.png)'
- en: 'Figure 2.17: Cascading drop-down menu example'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17：级联下拉菜单示例
- en: Clearly, each drop-down menu can be replaced by an autocomplete when required
    due to having a high number of options.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，每个下拉菜单在需要时都可以被自动完成所取代，因为它具有大量选项。
- en: 'If making the right selection can be done by intersecting several different
    hierarchies, cascading drop-down menus become inefficient too, and we need a filter
    form, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过交叉几个不同的层次来做出正确的选择，级联下拉菜单也变得低效，我们需要一个筛选表单，如下所示：
- en: '![](img/B16756_02_18.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_02_18.png)'
- en: 'Figure 2.18: Filter form sample'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18：筛选表单示例
- en: Now, let us understand interoperability with .NET Core.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解与.NET Core的互操作性。
- en: The fantastic world of interoperability with .NET Core
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与.NET Core的互操作性的奇妙世界
- en: .NET Core brought Windows developers the ability to deliver their software into
    various platforms. And you, as a software architect, need to pay attention to
    this. Linux and macOS are no longer a problem for a C# lover – it is much better
    than that – they are great opportunities to deliver to new customers. Therefore,
    we need to ensure performance and multi-platform support, two common non-functional
    requirements in several systems.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core为Windows开发人员带来了将其软件交付到各种平台的能力。作为软件架构师，您需要注意这一点。对于C#爱好者来说，Linux和macOS不再是问题
    - 它比这好多了 - 它们是向新客户交付的绝佳机会。因此，我们需要确保性能和多平台支持，这是几个系统中常见的非功能性需求。
- en: Both console applications and web apps designed with .NET Core in Windows are
    almost completely compatible with Linux and macOS, too. This means you do not
    have to build the app again to run it on these platforms. Also, very platform-specific
    behaviors now have multi-platform support, as shown, for instance, by the `System.IO.Ports.SerialPort`
    class, which, starting from .NET Core 3.0, is on Linux.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中使用.NET Core设计的控制台应用程序和Web应用程序在Linux和macOS上几乎完全兼容。这意味着您不必重新构建应用程序以在这些平台上运行。此外，非常特定于平台的行为现在也具有多平台支持，例如，从.NET
    Core 3.0开始，在Linux上就有`System.IO.Ports.SerialPort`类。
- en: Microsoft offers scripts to help you install .NET Core on Linux and macOS. You
    can find them at [https://docs.microsoft.com/dotnet/core/tools/dotnet-install-script](https://docs.microsoft.com/dotnet/core/tools/dotnet-install-script).
    Once you have the SDK installed, you just need to call **dotnet** the same way
    you do in Windows.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 微软提供了脚本来帮助您在Linux和macOS上安装.NET Core。您可以在[https://docs.microsoft.com/dotnet/core/tools/dotnet-install-script](https://docs.microsoft.com/dotnet/core/tools/dotnet-install-script)找到它们。一旦安装了SDK，您只需要像在Windows中一样调用**dotnet**。
- en: However, you must be aware of some features that are not fully compatible with
    Linux and macOS systems. For instance, no equivalent to the Windows Registry exists
    in these OSes and you must develop an alternative yourself. If needed, an encrypted
    JSON config file can be a good option.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您必须注意一些在Linux和macOS系统上不完全兼容的功能。例如，在这些操作系统中不存在Windows注册表的等效项，您必须自己开发替代方案。如果需要，加密的JSON配置文件可能是一个不错的选择。
- en: Another important point is that Linux is case-sensitive, while Windows is not.
    Please, remember this when you work with files. Another important thing is that
    the Linux path separator is different from the Windows separator. You can use
    the `Path.PathSeparator` field and all the other `Path` class members to ensure
    your code is multi-platform.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的一点是Linux区分大小写，而Windows不区分大小写。请记住这一点，当您处理文件时。另一个重要的事情是Linux路径分隔符与Windows分隔符不同。您可以使用`Path.PathSeparator`字段和`Path`类的所有其他成员来确保您的代码是多平台的。
- en: 'Besides, you can also adapt your code to the underlying OS by using the runtime
    checks provided by .NET Core, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以通过使用.NET Core提供的运行时检查来调整您的代码以适应底层操作系统，具体如下：
- en: '[PRE1]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating a service in Linux
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Linux中创建服务
- en: 'The following script can be used to encapsulate a command-line .NET Core app
    in Linux. The idea is that this service works like a Windows service. This can
    be useful, considering that most Linux installations are command-line only and
    run without a user logged in:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本可用于在Linux中封装命令行.NET Core应用程序。这项服务的理念是该服务类似于Windows服务。考虑到大多数Linux安装只能通过命令行运行且无需用户登录，这可能非常有用：
- en: 'The first step is to create a file that will run the command-line app. The
    name of the app is `app.dll` and it is installed in `appfolder`. The application
    will be checked every 5,000 milliseconds. This service was created on a CentOS
    7 system. Using a Linux terminal, you can type this:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一步是创建一个将运行命令行应用程序的文件。该应用程序的名称是`app.dll`，并且安装在`appfolder`中。该应用程序将每5000毫秒进行一次检查。此服务是在CentOS
    7系统上创建的。使用Linux终端，您可以输入以下内容：
- en: '[PRE2]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the file has been created, you must copy the service file to a system
    location. After that, you must reload `system` and enable the service so that
    it will restart on reboots:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建文件后，您必须将服务文件复制到系统位置。之后，您必须重新加载`system`并启用服务，以便在重新启动时重新启动：
- en: '[PRE3]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Done! Now, you can start, stop, and check the service using the following commands.
    The whole input that you need to provide in your command-line app is as follows:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成！现在，您可以使用以下命令启动、停止和检查服务。您在命令行应用程序中需要提供的整个输入如下：
- en: '[PRE4]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have learned about a few concepts, let us learn how to implement
    them in our use case.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了一些概念，让我们学习如何在我们的用例中实现它们。
- en: Achieving security by design
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过设计实现安全
- en: As we have seen up to here in the book, the opportunities and techniques we
    have for developing software are incredible. If you add all the information you
    will read about in relation to cloud computing in the next chapters, you will
    see that the opportunities just increase, as does the complexity to maintain all
    of this computing environment.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书中所看到的，我们用于开发软件的机会和技术是令人难以置信的。如果您在接下来的章节中阅读有关云计算的所有信息，您将会发现机会不断增加，与此同时，维护所有这些计算环境的复杂性也在增加。
- en: As a software architect, you must understand that these opportunities come with
    many responsibilities. The world has changed a lot in the last years. The second
    decade of the 21^(st) century has required lots of technology. Apps, social media,
    Industry 4.0, Big Data, and artificial intelligence are no longer future objectives,
    but mainly current projects that you will lead and deal with in your routine.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，您必须理解这些机会伴随着许多责任。在过去的几年里，世界发生了很大变化。21世纪的第二个十年需要大量的技术。应用程序、社交媒体、工业4.0、大数据和人工智能不再是未来的目标，而主要是您将在日常工作中领导和处理的当前项目。
- en: Considering this scenario, security must have a different approach. The world
    has moved to regulate companies that manage personal data. For instance, GDPR
    – the General Data Protection Regulation – is not only mandatory for European
    territory, since it has changed the way software is developed not only in Europe
    but all over the globe. There are many initiatives comparable to GDPR that must
    be enlisted to our belt of techniques and regulations, considering the software
    you design will be impacted by them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这种情况，安全必须有不同的方法。世界已经开始监管管理个人数据的公司。例如，GDPR - 《通用数据保护条例》 - 不仅在欧洲领土上是强制性的，因为它已经改变了软件开发的方式，不仅在欧洲，而且在全球范围内。有许多类似于GDPR的倡议必须列入我们的技术和法规范围，考虑到您设计的软件将受到它们的影响。
- en: Security by design must be one of your areas of focus for designing new applications.
    This subject is huge, and it is not going to be completely covered in this book,
    but as a software architect, you have to understand the necessity of having a
    specialist in the information security area in your team to guarantee the policies
    and the practices needed to avoid cyber attacks and maintain confidentiality,
    privacy, integrity, authenticity, and availability of the services you architect.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 安全设计必须是您设计新应用程序时关注的一个领域。这个主题很庞大，在这本书中不可能完全涵盖，但作为软件架构师，您必须理解在您的团队中有信息安全领域的专家是确保遵守政策和实践以避免网络攻击并保持服务的机密性、隐私、完整性、真实性和可用性的必要性。
- en: When it comes to protecting your ASP.NET Core application, it is worth mentioning
    that the framework has many features to help us out with that. For instance, it
    includes authentication and authorization patterns. In the OWASP Cheat Sheet Series,
    you'll be able to read about many other .NET practices.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在保护ASP.NET Core应用程序方面，值得一提的是该框架具有许多功能来帮助我们。例如，它包括身份验证和授权模式。在OWASP Cheat Sheet
    Series中，您将能够阅读关于许多其他.NET实践的信息。
- en: The Open Web Application Security Project® (OWASP) is a nonprofit foundation
    that works to improve the security of software. Check out its information at [https://owasp.org/](https://owasp.org/).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 开放网络应用安全项目®（OWASP）是一个致力于改善软件安全的非营利基金会。请查看其信息网站[https://owasp.org/](https://owasp.org/)。
- en: ASP.NET also provides features to help us out with GDPR. Basically, there are
    APIs and templates to guide you in the implementation of policy declaration and
    cookie usage consent.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET还提供了帮助我们遵守GDPR的功能。基本上，有API和模板来指导您实施政策声明和cookie使用同意。
- en: List of practices for achieving a safe architecture
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现安全架构的实践清单
- en: The following list of practices related to security certainly does not cover
    the entirety of the subject. However, these practices will certainly help you,
    as a software architect, to explore some solutions related to this topic.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下与安全相关的实践清单当然并未涵盖整个主题。但是，这些实践肯定会帮助您作为软件架构师探索与此主题相关的一些解决方案。
- en: Authentication
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认证
- en: Define an authentication method for your web app. There are many authentication
    options available nowadays, from ASP.NET Core Identity to external provider authentication
    methods, such as Facebook or Google. As a software architect, you must consider
    who the target audience of the application is. It would also be worth considering
    using Azure Active Directory as a starting point if you choose to go down this
    route.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的Web应用程序定义身份验证方法。现在有许多身份验证选项可供选择，从ASP.NET Core Identity到外部提供者身份验证方法，例如Facebook或Google。作为软件架构师，您必须考虑应用程序的目标受众是谁。如果选择这条路，考虑使用Azure
    Active Directory也是值得考虑的起点。
- en: You may find it useful to design authentication associated with Azure AD, a
    component for managing the Active Directory of the company you are working for.
    This alternative is pretty good in some scenarios, especially for internal usage.
    Azure currently offers Active Directory for usage as **B2B** – **Business to Business**,
    or **B2C** – **Business to Consumer**.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现将身份验证与Azure AD相关联很有用，这是一个用于管理您所在公司的Active Directory的组件。在某些场景中，特别是内部使用，这种替代方案非常好。Azure目前提供用于**B2B**
    - **企业对企业**或**B2C** - **企业对消费者**的Active Directory。
- en: Depending on the scenario of the solution you are building, you will need to
    implement **MFA** – **Multi Factor Authentication**. The idea of this pattern
    is to ask for at least two forms of proof of identity before allowing the solution
    usage. It is worth mentioning that Azure AD facilitates this for you.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您正在构建的解决方案的情景，您将需要实施**MFA** - **多因素身份验证**。这种模式的想法是在允许解决方案使用之前要求至少两种身份证明形式。值得一提的是，Azure
    AD为您简化了这一点。
- en: Do not forget that you must determine an authentication method for the APIs
    you provide. JSON Web Token is a pretty good pattern, and its usage is totally
    cross-platform.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记您必须为您提供的API确定身份验证方法。 JSON Web Token是一个非常好的模式，其使用完全跨平台。
- en: 'You must determine the authorization model you will use in your web app. There
    are four model options:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须确定您将在Web应用程序中使用的授权模型。有四种模型选项：
- en: '**Simple**, where you just use the `[Authorize]` attribute in the class or
    method;'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**简单**，您只需在类或方法中使用`[Authorize]`属性；'
- en: '**Role-based**, in which you may declare `Roles` for accessing the `Controller`
    you are developing;'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基于角色**，您可以为访问您正在开发的`Controller`声明`Roles`；'
- en: '**Claims-based**, where you can define values that must be received during
    the authentication to indicate that the user is authorized;'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基于声明**，您可以定义在身份验证期间必须接收的值，以指示用户是否被授权；'
- en: '**Policy-based**, in which there is a policy established to define the access
    in that `Controller`.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基于策略**，其中有一个旨在定义`Controller`中的访问权限的策略。'
- en: You may also define a controller or method in a class as being fully accessible
    to any user, by defining the attribute `[AllowAnonymous]`. Be sure this kind of
    implementation will not cause any vulnerabilities in the system you are designing.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将控制器或类中的方法定义为对任何用户���全可访问，方法是定义属性`[AllowAnonymous]`。确保这种实现不会在您设计的系统中造成任何漏洞。
- en: The model you decide to use will define exactly what each user will be able
    to do in the application.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您决定使用的模型将确切地定义每个用户在应用程序中能够做什么。
- en: Sensitive data
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 敏感数据
- en: While designing, you, as a software architect, will have to decide which part
    of the data you store is sensitive, and it will need to be protected. By connecting
    to Azure, your web app will be able to store protected data in components such
    as Azure Storage and Azure Key Vault. Storage in Azure will be discussed in *Chapter
    9*, *How to Choose Your Data Storage in the Cloud*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计时，作为软件架构师，您将不得不决定存储的数据的哪一部分是敏感的，并且需要受到保护。通过连接到Azure，您的Web应用程序将能够在诸如Azure存储和Azure
    Key Vault之类的组件中存储受保护的数据。 Azure存储将在*第9章*“如何在云中选择您的数据存储”中讨论。
- en: It is worth mentioning that Azure Key Vault is used to protect secrets your
    app may have. Consider using this solution when you have this kind of requirement.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，Azure Key Vault用于保护您的应用可能具有的秘密。当您有这种要求时，请考虑使用这种解决方案。
- en: Web security
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web安全
- en: It is totally unacceptable to have a production solution deployed without the
    HTTPS protocol enabled. Azure Web Apps and ASP.NET Core solutions have various
    possibilities to not only use but enforce the usage of this security protocol.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有启用HTTPS协议的情况下部署生产解决方案是完全不可接受的。 Azure Web应用程序和ASP.NET Core解决方案有各种可能性，不仅可以使用，而且可以强制使用这种安全协议。
- en: Thera are many known attacks and malicious patterns, such as cross-site request
    forgery, Open Redirect, and cross-site scripting. ASP.NET Core guarantees and
    presents APIs to solve them. You need to detect the ones that are useful for your
    solution.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多已知的攻击和恶意模式，例如跨站点请求伪造，开放式重定向和跨站点脚本。 ASP.NET Core保证并提供了解决它们的API。您需要检测对您的解决方案有用的那些。
- en: Good programming practices, such as avoiding SQL injections by using parameters
    in your queries, is another important goal to achieve.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在查询中使用参数来避免SQL注入等良好的编程实践是另一个重要目标。
- en: You may find cloud architecture security patterns at [https://docs.microsoft.com/en-us/azure/architecture/patterns/category/security](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/security).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/azure/architecture/patterns/category/security](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/security)找到云架构安全模式。
- en: To finish, it is worth mentioning that security needs to be treated using the
    onion approach, which means that there are many layers of security to be implemented.
    You must have a policy determined to guarantee a process to access the data, including
    physical access to people who use the system you are developing. In addition,
    you will also have to develop a disaster recovery solution in case the system
    is attacked. The disaster recovery solution will depend on your cloud solution.
    We will discuss this later in*Chapter 4*, *Deciding the Best Cloud-Based Solution*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得一提的是，安全性需要使用洋葱方法来处理，这意味着需要实现许多层安全性。您必须有一个确定的策略来保证访问数据的过程，包括使用您正在开发的系统的人员的物理访问。此外，您还必须开发一个灾难恢复解决方案，以防系统遭受攻击。灾难恢复解决方案将取决于您的云解决方案。我们将在*第4章*，*决定最佳基于云的解决方案*中讨论这一点。
- en: Book use case – understanding the main types of .NET Core projects
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 书籍用例 - 了解主要类型的.NET Core项目
- en: The development of this book's use case will be based on various kinds of .NET
    Core Visual Studio projects. This section describes all of them. Let us select
    **New project** in the Visual Studio **File** menu.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本书用例的开发将基于各种类型的.NET Core Visual Studio项目。本节描述了它们。让我们在Visual Studio的**文件**菜单中选择**新项目**。
- en: 'You can filter **.NET Core** project types by typing in the search engine,
    as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在搜索引擎中输入来筛选**.NET Core**项目类型：
- en: '![](img/B16756_02_19.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_02_19.png)'
- en: 'Figure 2.19: Searching types of .NET Core projects in Visual Studio'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19：在Visual Studio中搜索.NET Core项目类型
- en: 'There, you will find common C# projects (console, a class library, Windows
    Form, WPF), and various types of test projects, each based on a different test
    framework: xUnit, NUnit, and MSTest. Choosing among the various testing frameworks
    is just a matter of preference since all of them offer comparable features. Adding
    tests to each piece of software that composes a solution is a common practice
    and allows software to be modified frequently without jeopardizing its reliability.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，您将找到常见的C#项目（控制台、类库、Windows Form、WPF），以及基于不同测试框架的各种类型的测试项目：xUnit、NUnit和MSTest。在各种测试框架中进行选择只是一种偏好，因为它们都提供了可比较的功能。向解决方案中的每个软件组件添加测试是一种常见做法，可以使软件经常修改而不危及其可靠性。
- en: You may also want to define your class library projects under the **.NET Standard,
    which will be** discussed in *Chapter 13*, *Implementing Code Reusability in C#
    9*. These class libraries are based on standards that make them compatible with
    several .NET versions. For instance, libraries based on 2.0 standards are compatible
    with all .NET Core versions greater than or equal to 2.0, and with all .NET Framework
    versions greater than 4.6\. This compatibility advantage comes at the price of
    having fewer available features.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在**.NET Standard**下定义您的类库项目，这将在*第13章*，*在C# 9中实现代码重用性*中讨论。这些类库基于标���，使它们与多个.NET版本兼容。例如，基于2.0标准的库与所有大于或等于2.0的.NET
    Core版本兼容，并与所有大于4.6的.NET Framework版本兼容。这种兼容性优势是以功能较少为代价的。
- en: 'Besides filtering **Project Types** to **Cloud**, we have several more project
    types. Some of them will enable us to define microservices. Microservice-based
    architectures allow an application to be split into several independent microservices.
    Several instances of the same microservice can be created and distributed across
    several machines to fine-tune the performance of each application part. Microservices
    will be described in:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将**项目类型**筛选为**云**，我们还有几种项目类型。其中一些将使我们能够定义微服务。基于微服务的架构允许将应用程序拆分为几个独立的微服务。可以创建并分布在多台机器上的同一微服务的多个实例，以微调每个应用程序部分的性能。微服务将在以下章节中描述：
- en: '*Chapter 5*, *Applying a Microservice Architecture to Your Enterprise Application*'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第5章*，*将微服务架构应用于企业应用程序*'
- en: '*Chapter 6*, *Azure Service Fabric*'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第6章*，*Azure Service Fabric*'
- en: '*Chapter 7*, *Azure Kubernetes Service*'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第7章*，*Azure Kubernetes Service*'
- en: Finally, testing will be discussed in detail in *Chapter 18*, *Testing Your
    Code with Unit Test Cases and TDD*, and *Chapter 22*, *Automation for Functional
    Tests*. Finally, we have the ASP.NET Core application we already described in
    the *Creating a scalable web app with .NET 5* subsection. There, we defined an
    ASP.NET Core application, but Visual Studio also contains project templates for
    projects based on RESTful APIs and the most important single-page application
    frameworks, such as Angular, React, Vue.js, and the Blazor framework based on
    WebAssembly, which will be discussed in *Chapter 16*, *Blazor WebAssembly*. Some
    of them are available with the standard Visual Studio installation, while others
    require the installation of an SPA package.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，测试将在*第18章*，*使用单元测试用例和TDD测试您的代码*和*第22章*，*功能测试的自动化*中详细讨论。最后，我们已经在*使用.NET 5创建可扩展的Web应用程序*小节中描述了ASP.NET
    Core应用程序。在那里，我们定义了一个ASP.NET Core应用程序，但是Visual Studio还包含基于RESTful API和最重要的单页应用程序框架（如Angular、React、Vue.js和基于WebAssembly的Blazor框架）的项目模板，这将在*第16章*，*Blazor
    WebAssembly*中讨论。其中一些可以在标准的Visual Studio安装中找到，而其他一些则需要安装SPA包。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Functional requirements that describe system behavior must be completed with
    non-functional requirements that constrain system performance, scalability, availability,
    resilience, interoperability, usability, and security.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 描述系统行为的功能要求必须与约束系统性能、可扩展性、可用性、弹性、互操作性、可用性和安全性的非功能性需求一起完成。
- en: Performance requirements come from response time and system load requirements.
    As a software architect, you should ensure you have the required performance at
    the minimum cost, building efficient algorithms and taking full advantage of the
    available hardware resources with multithreading.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 性能要求来自响应时间和系统负载要求。作为软件架构师，您应该确保以最低成本获得所需的性能，构建高效的算法，并充分利用多线程的可用硬件资源。
- en: Scalability is the ability of a system to be adapted to an increasing load.
    Systems can be scaled vertically by providing more powerful hardware, or horizontally
    by replicating and load balancing the same hardware, which increases the availability.
    The cloud, in general, and Azure can help us implement strategies dynamically,
    with no need to stop your application.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 可伸缩性是系统适应增加负载的能力。系统可以通过提供更强大的硬件来进行垂直扩展，也可以通过复制和负载平衡相同的硬件来进行水平扩展，从而增加可用性。总的来说，云和Azure可以帮助我们实现动态策略，而无需停止应用程序。
- en: Tools such as .NET Core that run on several platforms can ensure interoperability,
    that is, the capability of your software to run on different target machines and
    with different operating systems (Windows, Linux, macOS, Android, and so on).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 像.NET Core这样在多个平台上运行的工具可以确保互操作性，也就是您的软件能够在不同的目标机器上以及不同的操作系统（Windows、Linux、macOS、Android等）上运行。
- en: Usability is ensured by taking care of the input field's order, the effectiveness
    of the item selection logic, and how easy your system is to learn.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过关注输入字段的顺序、项目选择逻辑的有效性以及系统的易学性来确保可用性。
- en: Besides, the more complex your solution is, the better resilience it should
    have. The idea of resilience is not to guarantee that the solution does not fail.
    Instead, the idea is to guarantee that the solution has an action defined when
    each part of the software fails.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您的解决方案越复杂，它应该具有更好的弹性。弹性的理念不是保证解决方案不会失败，而是保证解决方案在软件的每个部分失败时都有一个定义好的操作。
- en: As a software architect, you must consider security from the very beginning
    of the design. Following the guidelines to determine the correct patterns and
    having a security specialist in your team would be a great option to achieve all
    the current regulations we have.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，您必须从设计的最开始考虑安全性。遵循确定正确模式的指南，并在您的团队中有一个安全专家，将是实现我们目前所有法规的一个很好的选择。
- en: In the next chapter, you will learn how Azure DevOps tools can help us when
    it comes to collecting, defining, and documenting our requirements.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将了解Azure DevOps工具如何帮助我们收集、定义和记录我们的需求。
- en: Questions
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which are the two conceptual ways to scale a system?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪两种概念上的系统扩展方式？
- en: Can you deploy your web app automatically from Visual Studio to Azure?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能否从Visual Studio自动将您的Web应用程序部署到Azure？
- en: What is multithreading useful for?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多线程有什么用处？
- en: What are the main advantages of the asynchronous pattern over other multithreading
    techniques?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步模式相对于其他多线程技术的主要优势是什么？
- en: Why is the order of input fields so important?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么输入字段的顺序如此重要？
- en: Why is the .NET Core `Path` class so important for interoperability?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET Core的`Path`类为何对互操作性如此重要？
- en: What is the advantage of a .NET standard class library over a .NET Core class
    library?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET标准类库相对于.NET Core类库的优势是什么？
- en: List the various types of .NET Core Visual Studio projects.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出各种类型的.NET Core Visual Studio项目。
- en: Further reading
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following are some books and links you may consider reading in order to
    gather more information in relation to this chapter:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些书籍和链接，您可以考虑阅读以收集更多与本章相关的信息：
- en: '[https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers](https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers](https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers)'
- en: '[https://docs.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling](https://docs.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling](https://docs.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling)'
- en: '[https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/)'
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/parallel-processing-and-concurrency](https://docs.microsoft.com/en-us/dotnet/standard/parallel-processing-and-concurrency)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/standard/parallel-processing-and-concurrency](https://docs.microsoft.com/en-us/dotnet/standard/parallel-processing-and-concurrency)'
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/)'
- en: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/)'
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/security/](https://docs.microsoft.com/en-us/dotnet/standard/security/)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/standard/security/](https://docs.microsoft.com/en-us/dotnet/standard/security/)'
- en: '[https://docs.microsoft.com/en-us/aspnet/core/security/](https://docs.microsoft.com/en-us/aspnet/core/security/)'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/core/security/](https://docs.microsoft.com/en-us/aspnet/core/security/)'
- en: '[https://owasp.org/](https://owasp.org/)'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://owasp.org/](https://owasp.org/)'
- en: '[https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html)'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html)'
- en: '[https://docs.microsoft.com/en-us/aspnet/core/security/gdpr](https://docs.microsoft.com/en-us/aspnet/core/security/gdpr)'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/core/security/gdpr](https://docs.microsoft.com/en-us/aspnet/core/security/gdpr)'
- en: '[https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency)'
- en: '[https://docs.microsoft.com/en-us/azure/architecture/patterns/category/availability](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/availability)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/architecture/patterns/category/availability](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/availability)'
