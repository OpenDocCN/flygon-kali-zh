- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Implementing Code Reusability in C# 9
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C# 9中实现代码重用
- en: Code reusability is one of the most important topics in software architecture.
    This chapter aims to discuss ways to enable code reuse, as well as to help you
    understand how .NET 5 goes in this direction to solve the problem of managing
    and maintaining a reusable library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重用是软件架构中最重要的主题之一。本章旨在讨论如何启用代码重用的方法，以及帮助你了解.NET 5如何朝着解决管理和维护可重用库的问题的方向发展。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章将涵盖以下主题：
- en: Understanding the principles of code reuse
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解代码重用的原则
- en: The advantages of working with .NET 5 versus .NET Standard
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用.NET 5与.NET Standard的优势
- en: Creating reusable libraries using .NET Standard
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用.NET Standard创建可重用的库
- en: Although code reuse is an exceptional practice, as a software architect you
    must be aware when this is important for the scenario you are dealing with. Many
    good software architects agree that there is a lot of overengineering due to trying
    to make things reusable even though they are often single-use or not understood
    well enough.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码重用是一种非常好的实践，作为软件架构师，你必须意识到这对你正在处理的场景非常重要。许多优秀的软件架构师都同意，由于试图使事物可重用，往往会出现过度设计或者单次使用或者理解不足。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires the following things:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章需要以下内容：
- en: You need the free Visual Studio 2019 Community edition or better with all the
    database tools installed.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要免费的Visual Studio 2019社区版或更高版本，并安装所有数据库工具。
- en: You can find the sample code for this chapter at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5)找到本章的示例代码。
- en: Understanding the principles of code reusability
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解代码可重用性的原则
- en: There is a single reason that you can always use to justify code reuse – you
    cannot spend your valuable time recreating the wheel if it is already running
    well in other scenarios. That is why most engineering domains are based on reusability
    principles. Think about the light switches you have in your house.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用来证明代码重用的唯一理由是-如果在其他场景中已经运行良好，你就不必花费宝贵的时间重新发明轮子。这就是为什么大多数工程领域都基于可重用性原则。想想你家里的开关。
- en: Can you imagine the number of applications that can be made with the same interface
    components? The fundamentals of code reuse are the same. Again, it is a matter
    of planning a good solution so part of it can be reused later.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想象可以用相同的接口组件制作多少应用程序吗？代码重用的基本原则是相同的。再次强调，这是一个规划一个好的解决方案的问题，这样一部分可以在以后重用。
- en: 'In software engineering, code reuse is one of the techniques that can bring
    a software project a bunch of advantages, such as the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，代码重用是可以为软件项目带来许多优势的技术之一，例如以下：
- en: There is confidence in the software, considering that the reused piece of code was
    already tested in another application.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到重用的代码片段已经在另一个应用程序中经过测试，因此对软件有信心。
- en: There is better usage of software architects and the senior team since they
    can be dedicated to solving this kind of problem.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件架构师和高级团队的使用更好，因为他们可以专注于解决这种问题。
- en: There is the possibility of bringing to the project a pattern that is already
    accepted by the market.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有可能将市场上已经接受的模式引入项目中。
- en: Development speed goes up due to the already implemented components.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于已经实现的组件，开发速度加快。
- en: Maintenance is easier.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护更容易。
- en: These aspects indicate that code reuse should be done whenever it is possible.
    It is your responsibility, as a software architect, to ensure the preceding advantages
    are utilized and, more than that, that you incentivize your team to enable reuse
    in the software they are creating.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方面表明，只要可能，应该进行代码重用。作为软件架构师，你有责任确保利用前述优势，并且更重要的是，你要鼓励团队在他们创建的软件中启用重用。
- en: What is not code reuse?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么不是代码重用？
- en: The first thing you must understand is that code reuse does not mean copying
    and pasting code from one class to another. Even if this code was written by another
    team or project, this does not indicate that you are properly working with reusability
    principles. Let us imagine a scenario that we will find in this book's use case,
    the WWTravelClub evaluation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须明白的第一件事是，代码重用并不意味着从一个类中复制和粘贴代码到另一个类中。即使这段代码是由另一个团队或项目编写的，这也不表示你正在正确地遵循可重用性原则。让我们想象一种场景，我们将在本书的用例中找到，WWTravelClub评估。
- en: 'In this project scenario, you may want to evaluate different kinds of subjects,
    such as the **Package**, **DestinationExpert**, **City**, **Comments**, and so
    on. The process for getting the evaluation average is the same, no matter which
    subject you are referring to. Due to this, you may want to *enable* reuse by copying
    and pasting the code for each evaluation. The (bad) result will be something like
    this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目场景中，你可能想评估不同种类的主题，比如**Package**，**DestinationExpert**，**City**，**Comments**等等。无论你参考哪个主题，获取评估平均值的过程都是相同的。因此，你可能想通过复制和粘贴每个评估的代码来*启用*重用。结果（不好的）将会是这样：
- en: '![](img/B16756_13_01.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_13_01.png)'
- en: 'Figure 13.1: Bad implementation – there is no code reuse here'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：糟糕的实现-这里没有代码重用
- en: In the preceding diagram, the process of calculating the evaluation average
    is decentralized, which means that the same code will be duplicated in different
    classes. This will cause a lot of trouble, especially if the same approach is
    used in other applications. For instance, if there is a new specification about
    how you have to calculate the average or if you just get a bug in the calculation
    formula, you will have to fix it in all instances of code. If you do not remember
    to update it in all places, you will possibly end up with an inconsistent implementation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，计算评估平均值的过程是分散的，这意味着相同的代码将在不同的类中重复。这将带来很多麻烦，特别是如果相同的方法在其他应用程序中也被使用。例如，如果有关如何计算平均值的新规范，或者如果计算公式中出现错误，你将不得不在所有代码实例中修复它。如果你忘记在所有地方更新它，你可能最终会得到一个不一致的实现。
- en: What is code reuse?
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是代码重用？
- en: 'The solution to the problem mentioned in the previous section is quite simple:
    you must analyze your code and select the parts of it that would be good to decouple
    from your application.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节提到的问题的解决方案非常简单：你必须分析你的代码，并选择其中需要从你的应用程序中解耦的部分。
- en: 'The greatest reason why you should decouple them is related to how you are
    sure that this code can be reused in other parts of the application, or even in
    another application:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该解耦它们的最大原因与你如何确信这段代码可以在应用程序的其他部分甚至其他应用程序中重用有关：
- en: '![](img/B16756_13_02.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_13_02.png)'
- en: 'Figure 13.2: An implementation focused on code reuse'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：专注于代码重用的实现
- en: The centralization of the code brings to you, as a software architect, a different
    responsibility for it. You will have to keep in mind that a bug or incompatibility
    in this code could cause damage to many parts of the application or different
    applications. On the other hand, once you have this code tested and running, you
    will be able to propagate its usage with no worries. Besides, if you need to evolve
    the average calculation process, you will have to change the code in a single
    class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的集中化给你作为软件架构师带来了不同的责任。你必须记住，这段代码中的一个错误或不兼容性可能会对应用程序的许多部分或不同的应用程序造成损害。另一方面，一旦你测试并运行了这段代码，你就可以毫无顾虑地传播它的使用。此外，如果你需要改进平均计算过程，你只需要更改单个类中的代码。
- en: It is worth mentioning that the more you use the same code, the cheaper this
    development will become. Cost needs to be mentioned because, in general, the conception
    of reusable software costs more in the beginning.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，你使用相同的代码越多，这种开发就会变得越便宜。成本需要提到，因为一般来说，可重用软件的构思在开始阶段成本更高。
- en: Reusability in the development life cycle
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在开发生命周期中的可重用性
- en: If you understood that reusability will take you to another level of code implementation,
    you should have been thinking about how to make this technique available in your
    development life cycle.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你明白了可重用性将带你到另一个代码实现层次，你应该一直在考虑如何在你的开发生命周期中使用这种技术。
- en: As a matter of fact, creating and maintaining a component library is not very
    easy, due to the responsibility you will have and the lack of good tools to support
    the search for existing components.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，创建和维护一个组件库并不容易，因为你将承担的责任和缺乏支持搜索现有组件的好工具。
- en: 'On the other hand, there are some things that you may consider implementing
    in your software development process every time you initiate a new development:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有一些东西你可能要考虑在每次启动新开发时在你的软件开发过程中实现：
- en: '**Use** already implemented components from your user library, selecting features
    in the software requirements specification that need them.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用**已经在用户库中实现的组件，选择软件需求规格中需要它们的功能。'
- en: '**Identify** features in the software requirements specification that are candidates
    to be designed as library components.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**识别**软件需求规格中作为库组件设计候选的功能。'
- en: '**Modify** the specification, considering that these features will be developed
    using reusable components.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修改**规格，考虑使用可重用组件开发这些功能。'
- en: '**Design** the reusable components and be sure that they have the appropriate
    interfaces to be used in many projects.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计**可重用组件，并确保它们具有适当的接口，可以在许多项目中使用。'
- en: '**Build** the project architecture with the new component library version.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建**具有新组件库版本的项目架构。'
- en: '**Document** the component library version so that every developer and team
    knows about it.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录**组件库版本，以便每个开发人员和团队都知道它。'
- en: The *use-identify-modify-design-build* process is a technique that you may consider
    implementing every time you need to enable software reuse. As soon as you have
    the components you need to write for this library, you will need to decide on
    the technology that will provide these components.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用-识别-修改-设计-构建*过程是一种你可能要考虑在每次需要启用软件重用时实施的技术。一旦你有了为这个库编写的组件，你就需要决定提供这些组件的技术。'
- en: During the history of software development, there have been many approaches
    to doing this; some of them were discussed in *Chapter 5*, *Applying a Microservice
    Architecture to Your Enterprise Application*, in the *Microservices and the evolution
    of the concept of modules* section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发的历史中，有许多方法来做到这一点；其中一些在*第5章*，*将微服务架构应用于企业应用程序*中讨论过，在*微服务和模块概念的演变*部分。
- en: Using .NET 5 or .NET Standard for code reuse
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用.NET 5或.NET标准进行代码重用
- en: .NET has evolved a lot since its first version. This evolution is not only related
    to the number of commands and performance issues, but the supported platforms
    too. As we discussed in *Chapter 1*, *Understanding the Importance of Software
    Architecture*, you can run C# .NET on billions of devices, even if they are running
    Linux, Android, macOS, or iOS. For this reason, .NET Standard was first announced
    together with .NET Core 1.0, but .NET Standard became particularly important with
    .NET Standard 2.0, when .NET Framework 4.6, .NET Core, and Xamarin were compatible
    with it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: .NET自第一个版本以来已经发展了很多。这种发展不仅与命令数量和性能问题有关，还与支持的平台有关。正如我们在*第1章*中讨论的*理解软件架构的重要性*，即使在运行Linux、Android、macOS或iOS的数十亿设备上，您也可以运行C#
    .NET。因此，.NET Standard是首次与.NET Core 1.0一起宣布的，但.NET Standard在.NET Standard 2.0时变得特别重要，当时.NET
    Framework 4.6、.NET Core和Xamarin与之兼容。
- en: 'The key point is that .NET Standard was not only a kind of Visual Studio project.
    More than that, it was a formal specification available to all .NET implementations.
    As you can see in the following table, it covers everything from .NET Framework
    to Unity:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点是，.NET Standard不仅仅是一种Visual Studio项目。更重要的是，它是一个对所有.NET实现都可用的正式规范。正如您在下表中所看到的，它涵盖了从.NET
    Framework到Unity的所有内容：
- en: '| .NET Standard | 1.0 | 1.1 | 1.2 | 1.3 | 1.4 | 1.5 | 1.6 | 2.0 | 2.1 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| .NET Standard | 1.0 | 1.1 | 1.2 | 1.3 | 1.4 | 1.5 | 1.6 | 2.0 | 2.1 |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| .NET Core and .NET 5 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 2.0 | 3.0
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| .NET Core和.NET 5 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 2.0 | 3.0 |'
- en: '| .NET Framework | 4.5 | 4.5 | 4.5.1 | 4.6 | 4.6.1 | 4.6.1 | 4.6.1 | 4.6.1
    | N/A |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| .NET Framework | 4.5 | 4.5 | 4.5.1 | 4.6 | 4.6.1 | 4.6.1 | 4.6.1 | 4.6.1
    | N/A |'
- en: You can find a full .NET Standard overview at [https://docs.microsoft.com/en-us/dotnet/standard/net-standard](https://docs.microsoft.com/en-us/dotnet/standard/net-standard).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/dotnet/standard/net-standard](https://docs.microsoft.com/en-us/dotnet/standard/net-standard)找到完整的.NET
    Standard概述。
- en: The preceding table indicates that if you build a class library that is compatible
    with this standard, you will be able to reuse it in any of the platforms presented.
    Think about how fast your development process could become if you plan to do this
    in all your projects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表格表明，如果您构建一个符合这一标准的类库，您将能够在所呈现的任何平台上重用它。想象一下，如果您计划在所有项目中都这样做，您的开发过程会变得多么快速。
- en: Obviously, some components are not included in .NET Standard, but its evolution
    is continuous. It is worth mentioning that Microsoft's official documentation
    indicates that *the higher the version, the more APIs are available to you*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，一些组件不包括在.NET Standard中，但它的发展是持续的。值得一提的是，微软的官方文档指出*版本越高，可用的API就越多*。
- en: 'The initiative of having a single framework for all platforms brought us to
    .NET 5\. Microsoft indicates that from now, net5.0 or later will run everywhere.
    The next question you, as a software architect, might have is: what is going to
    happen to .NET Standard?'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个适用于所有平台的单一框架的倡议使我们走向了.NET 5。微软指出，从现在开始，net5.0或更高版本将在任何地方运行。作为软件架构师，您可能会问的下一个问题是：.NET
    Standard会发生什么？
- en: 'The answer to this question is well explained by Immo Landwerth at the dotnet
    blog: [https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/).
    The basic answer is that .NET 5.0 (and future versions) needs to be thought of
    as the foundation for sharing code moving forward.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个问题的答案在dotnet博客上由Immo Landwerth做了很好的解释：[https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/)。基本答案是，.NET
    5.0（以及未来的版本）需要被视为未来共享代码的基础。
- en: Creating a .NET Standard library
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个.NET Standard库
- en: 'It is quite simple to create a class library compatible with .NET Standard.
    Basically, you need to choose the following project when creating the library:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个与.NET Standard兼容的类库非常简单。基本上，您需要在创建库时选择以下项目：
- en: '![](img/B16756_13_03.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_13_03.png)'
- en: 'Figure 13.3: Creating a .NET Standard library'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3：创建一个.NET Standard库
- en: 'Once you have concluded this part, you will notice that the only difference
    between a common class library and the one you created is the target framework
    defined in the project file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成了这一部分，您会注意到一个普通类库和您创建的类库之间唯一的区别是项目文件中定义的目标框架：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As soon as your project is loaded, you can start coding the classes that you
    intend to reuse. The advantage of building reusable classes using this approach
    is that you will be able to reuse the written code in all the project types we
    checked previously. On the other hand, you will find out that some APIs that are
    available in .NET Framework do not exist in this type of project.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的项目加载完成，您就可以开始编写您打算重用的类。使用这种方法构建可重用类的优势是，您将能够在我们之前检查过的所有项目类型中重用编写的代码。另一方面，您会发现在这种类型的项目中，一些在.NET
    Framework中可用的API在这里是不存在的。
- en: How does C# deal with code reuse?
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#如何处理代码重用？
- en: There are many approaches where C# helps us deal with code reuse. The ability
    to build libraries, as we did in the previous section, is one of them. The most
    important one is the fact that the language is object-oriented. Besides, it is
    worth mentioning the facilities that generics brought to the C# language. This
    section will discuss the last two we mentioned.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: C#帮助我们处理代码重用的方法有很多。正如我们在前一节中所做的那样，构建库的能力是其中之一。最重要的是，这种语言是面向对象的。此外，值得一提的是泛型为C#语言带来的便利。本节将讨论我们提到的最后两个。
- en: Object-oriented analysis
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象分析
- en: The object-oriented analysis approach gives us the ability to reuse code in
    different ways, from the facility of inheritance to the changeability of polymorphism.
    Complete adoption of object-oriented programming will let you implement abstraction
    and encapsulation too.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的分析方法使我们能够以不同的方式重用代码，从继承的便利性到多态的可变性。完全采用面向对象编程将让您实现抽象和封装。
- en: 'The following diagram shows how using the object-oriented approach makes reuse
    easier. As you can see, there are different ways to calculate the grades of an evaluation,
    considering you can be a basic or a prime user of the system:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了使用面向对象方法使重用变得更容易。正如你所看到的，有不同的方法来计算评估的等级，考虑到你可以是系统的基本用户或高级用户：
- en: '![](img/B16756_13_04.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_13_04.png)'
- en: 'Figure 13.4: Object-oriented case analysis'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4：面向对象的案例分析
- en: There are two aspects to be analyzed as code reuse in this design. The first
    is that there is no need to declare the properties in each child class since inheritance
    is doing it for you.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，代码重用有两个方面需要分析。第一个是在每个子类中不需要声明属性，因为继承已经为你做了这件事。
- en: 'The second is the opportunity to use polymorphism, enabling different behaviors
    for the same method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是使用多态的机会，使相同方法产生不同的行为。
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding code, you can see the usage of the polymorphism principle,
    where the calculation of evaluation for prime users will increase by 20%. Now,
    look at how easy it is to call different objects inherited by the same class.
    Since the collection content implements the same interface, `IContentEvaluated`,
    it can have basic and prime users too:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，你可以看到多态原则的使用，高级用户的评估计算会增加20%。现在，看看通过相同类继承的不同对象调用是多么容易。由于集合内容实现了相同的接口`IContentEvaluated`，它也可以有基本用户和高级用户。
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Object-oriented adoption can be considered mandatory when using C#. However,
    more specific usage will need study and practice. You, as a software architect,
    should always incentivize your team to study object-oriented analysis. The more
    abstraction abilities they have, the easier code reuse will become.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的采用在使用C#时可以被视为强制性的。然而，更具体的用法需要学习和实践。作为软件架构师，你应该始终鼓励你的团队学习面向对象的分析。他们拥有更多的抽象能力，代码重用就会变得更容易。
- en: Generics
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型
- en: Generics were introduced in C# in version 2.0, and it is considered an approach
    that increases code reuse. It also maximizes type safety and performance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型在C# 2.0版本中引入，被认为是一种增加代码重用的方法。它还能最大化类型安全性和性能。
- en: The basic principle of generics is that you can define in an interface, class,
    method, property, event, or even a delegate, a placeholder that will be replaced
    with a specific type at a later time when one of the preceding entities is used.
    The opportunity you have with this feature is incredible since you can use the
    same code to run different versions of the type, generically.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型的基本原则是，你可以在接口、类、方法、属性、事件，甚至委托中定义一个占位符，当使用前述实体之一时，它将在以后被特定类型替换。你可以使用这个特性的机会是不可思议的，因为你可以使用相同的代码来运行类型的不同版本，通用地。
- en: 'The following code is a modification of `EvaluationService`, which was presented
    in the previous section. The idea here is to enable the generalization of the
    service, giving us the opportunity to define the goal of evaluation since its
    creation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是对前一节中介绍的`EvaluationService`的修改。这里的想法是使服务的泛化，让我们有机会自定义评估的目标：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This declaration indicates that any class that implements the `IContentEvaluaded`
    interface can be used for this service. Besides, the service will be responsible
    for creating the evaluated content.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明表明，任何实现了`IContentEvaluaded`接口的类都可以用于这个服务。此外，服务将负责创建评估内容。
- en: 'The following code implements the evaluated content that was created since
    the construction of the service. This code uses `System.Reflection` and the generic
    definition from the class:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了自从服务构建以来创建的评估内容。这段代码使用了`System.Reflection`和类的泛型定义：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It is worth mentioning that this code will work because all the classes are
    in the same assembly. Besides, reflection is not mandatory while using generics.
    The result of this modification can be checked in the instance creation of the
    service:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，这段代码将会工作，因为所有的类都在同一个程序集中。此外，在使用泛型时，反射并不是必需的。这个修改的结果可以在服务的实例创建中检查到：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The good news is that, now, you have a generic service that will automatically
    instantiate the list object with the evaluations of the content you need. It's
    worth mentioning that generics will obviously need more time dedicated to the
    first project's construction. However, once the design is done, you will have
    good, fast, and easy-to-maintain code. This is what we call reuse!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，现在你有了一个通用的服务，它将自动用你需要的内容的评估实例化列表对象。值得一提的是，泛型显然需要更多的时间用于第一个项目的构建。然而，一旦设计完成，你将拥有良好、快速和易于维护的代码。这就是我们所说的重用！
- en: What if the code is not reusable?
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果代码不能被重用怎么办？
- en: 'In fact, any code can be reusable. The key point here is if the code you intend
    to reuse is well-written and follows good patterns for reuse. There are several
    reasons why code should be considered not ready for reuse:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，任何代码都可以重用。关键在于你打算重用的代码是否写得好，并且遵循了良好的重用模式。有几个原因可以说明为什么代码不应该被考虑为可重用：
- en: '**The code was not tested before**: Before reusing code, it is a good approach
    to guarantee that it works.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码在重用之前没有经过测试**：在重用代码之前，保证它能够正常工作是一个很好的方法。'
- en: '**The code is duplicated**: If you have duplicate code, you will need to find
    each place where it is being used so you only have a single version of the code
    being reused.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码是重复的**：如果你有重复的代码，你需要找到它被使用的每个地方，这样你就只有一个版本的代码被重用。'
- en: '**The code is too complex to understand**: Code that is reused in many places
    needs to be written with simplicity to enable easy understanding.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码过于复杂，难以理解**：在许多地方重用的代码需要简单编写，以便易于理解。'
- en: '**The code has tight coupling**: This is a discussion related to composition
    versus inheritance when building separate class libraries. Classes (with interfaces)
    are usually much easier to reuse than base classes that can be inherited.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码耦合度太高**：这是一个关于组合与继承的讨论，当构建独立的类库时。类（带接口）通常比可以被继承的基类更容易重用。'
- en: 'In any of these cases, considering a refactoring strategy can be a great approach.
    When you are refactoring code, you are writing it in a better way while respecting
    the input and output data that this code will process. This enables more comprehensive
    and lower-cost code when it comes to changing it. Martin Fowler indicates some
    reasons why we should consider refactoring:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何这些情况下，考虑到重构策略可能是一个很好的方法。当你重构代码时，你正在以更好的方式编写它，同时尊重这段代码将处理的输入和输出数据。这将使得在改变代码时更全面、成本更低。Martin
    Fowler指出了一些我们应该考虑重构的原因：
- en: '**It improves software design**: The more expert your team becomes, the better
    the design will be. A better software design will deliver not only faster coding,
    but it will bring us the opportunity to process more tasks in less time.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它改善软件设计**：你的团队变得越来越专业，设计就会变得越来越好。更好的软件设计不仅会带来更快的编码，还会为我们提供在更短的时间内处理更多任务的机会。'
- en: '**It makes the software easier to understand**: Regardless of whether we are
    talking about juniors or seniors, good software needs to be understood by each
    developer you have in the team.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它使软件更易理解**：无论是初级开发人员还是高级开发人员，好的软件都需要被团队中的每个开发人员理解。'
- en: '**It helps us find bugs**: While you are refactoring, you will find business
    rules that may have not been well-programmed, so you will find bugs.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它帮助我们找到错误**：在重构时，你会发现可能没有被良好编程的业务规则，所以你会发现错误。'
- en: '**It makes us program quicker**: The result of refactoring will be code that
    will enable faster development in the future.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它让我们更快地编程**：重构的结果将是能够在未来实现更快开发的代码。'
- en: 'The process of refactoring depends on some steps that we shall follow to guarantee
    good results and minimize errors during the journey:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 重构的过程取决于我们将要遵循的一些步骤，以确保良好的结果并在旅程中尽量减少错误：
- en: '**Be sure you have a set of tests to guarantee the correct processing**: The
    set of tests you have will eliminate the fear of having to clean code.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确保你有一套测试来保证正确处理**：你拥有的测试集将消除清理代码的恐惧。'
- en: '**Eliminate duplication**: Refactoring is a good opportunity to eliminate code
    duplication.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消除重复**：重构是消除代码重复的好机会。'
- en: '**Minimize complexity**: Considering you will have the goal of making the code
    more understandable, following the best practices of programming, as mentioned
    in *Chapter 17*, *Best practices in Coding C# 9*, will reduce the complexity of
    the code.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化复杂性**：考虑到你的目标是使代码更易理解，遵循编程的最佳实践，如*第17章*中提到的*C# 9编码最佳实践*，将减少代码的复杂性。'
- en: '**Clean up the design**: Refactoring is a good time for reorganizing the design
    of your libraries too. Do not forget to update them too. This can be a great way
    to eliminate bugs and security issues.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清理设计**：重构是重新组织你的库设计的好时机。不要忘记也要更新它们。这是消除错误和安全问题的好方法。'
- en: As a software architect, you will receive many refactoring demands from your
    team. The incentive for doing so must be continuous. But you must remind your
    team that refactoring without following the preceding steps might be risky. So,
    it is your responsibility to make it happen in a way that can both enable fast
    programming and less impact, thus delivering real business value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，你会收到团队的许多重构需求。持续做这件事的动力必须是持续的。但你必须提醒你的团队，没有遵循先前步骤的重构可能是有风险的。因此，你有责任以一种既能够实现快速编程又能够减少影响的方式来实现它，从而提供真正的商业价值。
- en: I have my libraries. How do I promote them?
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我有我的库。我该如何推广它们？
- en: 'Considering you have made all the necessary effort to guarantee you have good
    libraries that must be reused in many of your projects, you will find another
    difficult situation arises when enabling reusability: it is not simple to let
    programmers know you have libraries ready to reuse.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到你已经做出了所有必要的努力来确保你有好的库，这些库必须在你的许多项目中被重复使用，当启用可重用性时，你会发现另一个困难的情况出现了：让程序员知道你已经准备好可以重用的库并不简单。
- en: There are some simple approaches to documenting a library. As we mentioned when
    we talked about the development life cycle, documenting is a good way to help
    developers take notice of the libraries they have. There are two examples of documenting
    reusable code that we would like to mention here.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些简单的方法来记录一个库。正如我们在谈论开发生命周期时提到的，文档是帮助开发人员注意到他们拥有的库的好方法。这里有两个关于记录可重用代码的例子我们想提一下。
- en: Documenting .NET libraries using DocFX
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用DocFX记录.NET库
- en: 'This tool is a good alternative for documenting a library using comments made
    in its code. By simply adding the NuGet package `docfx.console`, the tool allows
    you to create a task that will run once your library has been built:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具是一个很好的选择，可以使用代码中的注释来记录库。通过简单地添加NuGet包`docfx.console`，该工具允许你创建一个任务，一旦你的库构建完成就会运行：
- en: '![](img/B16756_13_05.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_13_05.png)'
- en: 'Figure 13.5: docfx.console NuGet library'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5：docfx.console NuGet库
- en: 'The output of this compilation is a stylish static website that contains the
    documentation of your code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个编译的输出是一个时尚的静态网站，包含了你的代码文档：
- en: '![](img/B16756_13_06.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_13_06.png)'
- en: 'Figure 13.6: DocFx result'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6：DocFx结果
- en: This website is useful because you can distribute the documentation to your
    team so that they can search for the libraries you have. You can check the customizations
    of the output and find more information about it at [https://dotnet.github.io/docfx/](https://dotnet.github.io/docfx/).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网站很有用，因为你可以把文档分发给你的团队，这样他们就可以搜索你拥有的库。你可以检查输出的自定义，并在[https://dotnet.github.io/docfx/](https://dotnet.github.io/docfx/)找到更多信息。
- en: Documenting a Web API using Swagger
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Swagger记录Web API
- en: There is no doubt that a Web API is one of the technologies that facilitates
    and promotes code reuse. For this reason, having its documentation well done and,
    more than that, respecting a standard is good practice and indicates that you
    are up to date on to this approach. To do this, we have Swagger, which respects
    the OpenAPI Specification.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，Web API是促进代码重用的技术之一。因此，做好它的文档工作，更重要的是，遵守标准，是一个良好的做法，并表明你对这种方法是跟上了时代的。
- en: The OpenAPI Specification is known as the standard for describing modern APIs.
    One of the most widely used tools for documenting it in an ASP.NET Core Web API
    is `Swashbuckle.AspNetCore`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI规范被认为是描述现代API的标准。在ASP.NET Core Web API中，最常用的用于对其进行文档化的工具之一是`Swashbuckle.AspNetCore`。
- en: The good thing about implementing the `Swashbuckle.AspNetCore` library is that
    you can set the Swagger UI viewer for your Web API, which is a good, graphical
    way to distribute the APIs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`Swashbuckle.AspNetCore`库的好处在于，你可以为你的Web API设置Swagger UI查看器，这是一种良好的图形方式来分发API。
- en: We will learn how to use this library in ASP.NET Core Web APIs in the next chapter.
    Until then, it is important to understand that this documentation will help not
    only your team, but any developer who might use the APIs you are developing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章学习如何在ASP.NET Core Web API中使用这个库。在那之前，重要的是要理解，这份文档不仅会帮助你的团队，还会帮助任何可能使用你正在开发的API的开发人员。
- en: Use case – reusing code as a fast way to deliver good and safe software
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例 - 将代码重用作为快速交付良好和安全软件的途径
- en: 'The final design of the solution for evaluating content for WWTravelClub can
    be checked as follows. This approach consists of using many topics that were discussed
    in this chapter. First, all the code is placed in a .NET Standard class library.
    This means that you can add this code to different types of solutions, such as
    .NET Core web apps and Xamarin apps for the Android and iOS platforms:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: WWTravelClub评估内容的最终设计可以如下所示。这种方法包括了本章讨论的许多主题。首先，所有的代码都放在一个.NET标准类库中。这意味着你可以将这些代码添加到不同类型的解决方案中，比如.NET
    Core web应用程序和用于Android和iOS平台的Xamarin应用程序：
- en: '![](img/B16756_13_07.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_13_07.png)'
- en: 'Figure 13.7: WWTravelClub reuse approach'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7：WWTravelClub重用方法
- en: This design makes use of object-oriented principles such as inheritance, so
    you do not need to write properties and methods more than once that can be used
    in many classes; and polymorphism, so that you can change the behavior of the
    code without changing the name of the method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计利用了面向对象的原则，比如继承，因此你不需要在多个类中重复编写属性和方法；以及多态性，这样你可以改变代码的行为而不改变方法的名称。
- en: To finish, the design abstracts the idea of the content by introducing generics
    as a tool that can facilitate the manipulation of similar classes, such as the
    ones we have in WWTravelClub to evaluate content regarding cities, comments, destination
    experts, and travel packages.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个设计通过引入泛型来抽象内容的概念，泛型可以简化对类似类的对象的处理，比如我们在WWTravelClub中用来评估城市、评论、目的地专家和旅行套餐的类。
- en: The big difference between a team that incentivizes code reuse and one that
    does not is the velocity of delivering good software to end users. Of course,
    beginning this approach is not easy, but rest assured that you will get good results
    after some time working with it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个鼓励代码重用的团队和一个不鼓励的团队之间的最大区别是向最终用户交付良好软件的速度。当然，开始这种方法并不容易，但请放心，在一段时间后你将会取得良好的结果。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter aimed to help you understand the advantages of code reuse. It also
    gave you an idea about what is not properly reused code. This chapter also presented
    approaches for reusing and refactoring code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在帮助你了解代码重用的优势。它还让你了解了什么才是正确的代码重用。本章还介绍了代码重用和重构的方法。
- en: Considering that technology without processes does not take you anywhere, a
    process was presented that helps enable code reuse. This process is related to
    using already completed components from your library; identifying features in
    the software requirements specification that are candidates to be designed as
    library components; modifying the specification considering these features; designing
    the reusable components; and building the project architecture with the new component
    library version.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到没有流程的技术是无法带你走向任何地方的，因此提出了一个流程，帮助实现代码重用。这个流程涉及到使用已经完成的组件库中的组件；识别软件需求规范中可以设计为库组件的特性；修改规范以考虑这些特性；设计可重用组件；并使用新的组件库版本构建项目架构。
- en: 'To finish, this chapter presented .NET Standard libraries as an approach to
    reusing code for different C # platforms, indicating that .NET 5 and new versions
    shall be used for reusing code in different platforms. This chapter also reinforced
    the principles of object-oriented programming when reusing code and presented
    generics as a sophisticated implementation to simplify the treatment of objects
    with the same characteristics. In the next chapter, we will learn how to apply
    a **service-oriented architecture** (**SOA**) with .NET Core.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本章介绍了.NET标准库作为在不同的C#平台上重用代码的一种方法，表明.NET 5和新版本应该用于在不同平台上重用代码。本章还强调了在重用代码时面向对象编程的原则，并介绍了泛型作为简化具有相同特征的对象处理的一种复杂实现。在下一章中，我们将学习如何在.NET
    Core中应用面向服务的架构（SOA）。
- en: It is worth mentioning that SOA is considered a way to implement code reuse
    in sophisticated environments.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，SOA被认为是在复杂环境中实现代码重用的一种方式。
- en: Questions
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can copy-and-paste be considered code reuse? What are the impacts of this approach?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制和粘贴可以被视为代码重用吗？这种方法的影响是什么？
- en: How can you make use of code reuse without copying and pasting code?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在不复制和粘贴代码的情况下实现代码重用？
- en: Is there a process that can help with code reuse?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有没有一个流程可以帮助实现代码重用？
- en: What is the difference between .NET Standard and .NET Core?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET Standard和.NET Core之间有什么区别？
- en: What are the advantages of creating a .NET Standard library?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建.NET Standard库的优势是什么？
- en: How does object-oriented analysis help with code reuse?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 面向对象分析如何帮助代码重用？
- en: How do generics help with code reuse?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型如何帮助代码重用？
- en: Will .NET Standard be replaced with .NET 5?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET Standard将被.NET 5取代吗？
- en: What are the challenges related to refactoring?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与重构相关的挑战是什么？
- en: Further reading
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'These are some books and websites where you will find more information about
    this chapter:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些书籍和网站，您将在其中找到有关本章的更多信息：
- en: '*Clean Code: A Handbook of Agile Software Craftmanship by* Martin, Robert C.
    Pearson Education, 2012.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《干净的代码：敏捷软件工艺的手册》（Martin，Robert C. Pearson Education，2012年）。
- en: '*Clean Architecture: A Craftsman''s Guide to Software Structure and Design*
    by Martin, Robert C. Pearson Education, 2018.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《干净的架构：软件结构和设计的工匠指南》（Martin，Robert C. Pearson Education，2018年）。
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erica Gamma
    [et al.] Addison-Wesley, 1994.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《设计模式：可重用面向对象软件的元素》（Erica Gamma等人著，Addison-Wesley，1994年）。
- en: '*Design Principles and Design Patterns* by Robert C. Martin, 2000.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《设计原则和设计模式》（Robert C. Martin，2000年）。
- en: '*Refactoring* by Martin Fowler, 2018.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《重构》（Martin Fowler，2018年）。
- en: '[https://devblogs.microsoft.com/dotnet/introducing-net-standard/](https://devblogs.microsoft.com/dotnet/introducing-net-standard/)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/introducing-net-standard/](https://devblogs.microsoft.com/dotnet/introducing-net-standard/)'
- en: '[https://www.packtpub.com/application-development/net-standard-20-cookbook](https://www.packtpub.com/application-development/net-standard-20-cookbook)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/net-standard-20-cookbook](https://www.packtpub.com/application-development/net-standard-20-cookbook)'
- en: '[https://github.com/dotnet/standard/blob/master/docs/versions.md](https://github.com/dotnet/standard/blob/master/docs/versions.md)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/dotnet/standard/blob/master/docs/versions.md](https://github.com/dotnet/standard/blob/master/docs/versions.md)'
- en: '[https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/](https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/](https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/)'
- en: '[https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/)'
- en: '[https://dotnet.github.io/docfx/](https://dotnet.github.io/docfx/)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://dotnet.github.io/docfx/](https://dotnet.github.io/docfx/)'
- en: '[https://github.com/domaindrivendev/Swashbuckle.AspNetCore](https://github.com/domaindrivendev/Swashbuckle.AspNetCore)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/domaindrivendev/Swashbuckle.AspNetCore](https://github.com/domaindrivendev/Swashbuckle.AspNetCore)'
- en: '[https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger)'
