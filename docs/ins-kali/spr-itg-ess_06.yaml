- en: Chapter 6. Integration with External Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。与外部系统集成
- en: 'In the previous chapter, we discussed Spring Integration components that help
    with message flow inside systems. In this chapter, let''s pull the lever further
    and see what Spring Integration has in the box when it comes to real-world integration
    challenges. We will cover Spring Integration''s support for external components
    and we will cover the following topics in detail:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们讨论了Spring集成组件，这些组件有助于系统内的消息流。在本章中，让我们进一步了解Spring集成在处理真实集成挑战时的功能。我们将详细介绍Spring集成对外部组件的支持，并详细介绍以下主题：
- en: Working with files
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理文件
- en: File exchange over FTP/FTPS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过FTP/FTPS进行文件交换
- en: Social integration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社交集成
- en: Enterprise messaging
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业消息传递
- en: Invoking and consuming HTTP endpoints
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用和消费HTTP端点
- en: Web services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务
- en: Database integration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库集成
- en: Streaming
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流式传输
- en: Working with files
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件
- en: One of the most common and primitive ways to communicate is through files. Even
    after the introduction of databases, the filesystem has not lost its relevance
    and we frequently need to deal with them—in legacy applications, for dumping reports,
    shared locations, and so on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 文件是最常见和原始的沟通方式之一。即使在数据库引入后，文件系统仍然具有重要性，我们经常需要处理它们——在传统应用程序中，用于转储报告、共享位置等等。
- en: So, how do you work with files in Java? Get the file handle, open a stream,
    work over it, and then close it. Some trivial stuff would take 10-15 lines of
    code. However, what if you forget to close the stream or the referenced file has
    been removed? The lines of code go on increasing as we handle all the corner cases.
    Spring Integration has very good support for files. It provides adapters and gateways
    that can handle file reading and writing operations with minimal lines of code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在Java中如何处理文件呢？获取文件句柄，打开流，对其进行操作，然后关闭它。一些琐碎的事情可能需要10-15行代码。然而，如果您忘记关闭流或引用的文件已被删除怎么办？随着我们处理所有边缘情况，代码行数不断增加。Spring集成对文件有很好的支持。它提供了可以处理文件读取和写入操作的适配器和网关，代码行数最少。
- en: Prerequisites
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'To use the file components mentioned previously, we need to declare the Spring
    namespace support and Maven entry in the following way:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用前面提到的文件组件，我们需要以以下方式声明Spring命名空间支持和Maven条目：
- en: 'Namespace support can be added by using the following code snippet:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过以下代码片段添加命名空间支持：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Maven entry can be added by using the following code snippet:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过以下代码片段添加Maven条目：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We are now good to start writing our Spring Integration file components. Let''s
    discuss file support from Spring based on the two types of operation: reading
    files and writing files.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始编写我们的Spring集成文件组件了。让我们根据两种操作类型讨论基于Spring的文件支持：读取文件和写入文件。
- en: Reading files
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取文件
- en: 'Spring Integration provides an adapter that can read a file from a directory
    and make it available as a `Message<File>` on a channel for other consumers to
    consume it. Let''s look at a snippet to see how it is configured:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Spring集成提供了一个适配器，可以从目录中读取文件，并将其作为`Message<File>`提供给其他消费者在通道上消费。让我们看一个片段，看看它是如何配置的：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding configuration is sufficient to read files from a *directory*
    and put it on the specified *channel*. Let''s look at the elements:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配置足以从*目录*中读取文件并将其放在指定的*通道*上。让我们看看这些元素：
- en: '`int-file:inbound-channel-adapter`: This is the namespace for file support'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int-file:inbound-channel-adapter`：这是文件支持的命名空间'
- en: '`directory`: This is the directory from where files should be read'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directory`：这是应该读取文件的目录'
- en: '`channel`: This is the channel on which a file should be written'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`：这是应该写入文件的通道'
- en: '`prevent-duplicates`: If this is enabled, files already picked up in an earlier
    run are not picked up again'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prevent-duplicates`：如果启用了此选项，则不会再次选取在先前运行中已经选取的文件'
- en: '`filename-pattern`: This is the name pattern for the file that should be picked
    up'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filename-pattern`：这是应该被选取的文件的名称模式'
- en: '`int:poller`: This is the rate at which files should be polled'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int:poller`：这是应该轮询文件的速率'
- en: '`int-file:nio-locker`: If there are multiple consumers, this will lock files
    so that the same files are not picked concurrently'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int-file:nio-locker`：如果有多个消费者，这将锁定文件，以便不会同时选取相同的文件'
- en: You must have realized that although the configuration is simple, a lot of things
    are going on under the hood, such as preventing duplicates, filtering files, avoiding
    concurrent access, and so on. We will discuss these in detail, but before that
    let's have a peek at the class that is acting behind the scene for this adapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须已经意识到，尽管配置很简单，但在幕后有很多事情正在进行，比如防止重复、过滤文件、避免并发访问等等。我们将详细讨论这些问题，但在此之前让我们先看一下在适配器背后起作用的类。
- en: Behind the scenes
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 幕后
- en: 'The adapter declared in the previous example leverages `FileReadingMessageSource`,
    which is an implementation of `MessageSource`. It creates a message based on a
    file from a directory as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中声明的适配器利用了`FileReadingMessageSource`，这是`MessageSource`的实现。它根据目录中的文件创建消息，如下所示：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At bean declaration level, we can inject filters, locking mechanics, and so
    on—but since we are using Spring Integration, it spares us from working at bean
    declaration level. Instead, we can use adapters exposed by Spring Integration.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在bean声明级别，我们可以注入过滤器、锁定机制等等——但由于我们使用Spring集成，它使我们免于在bean声明级别工作。相反，我们可以使用Spring集成提供的适配器。
- en: Filters
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤器
- en: Filter is a powerful concept that can be used to prevent duplicates, select
    files based on name patterns, customize the list of files read, and perform many
    more interceptions before the required content can be presented to the next endpoint.
    There are predefined filters available for most common tasks, but in the true
    spirit of spring, we can have custom implementations as well and inject them in
    adapters provided by Spring Integration. Filters must be an instance of `FileListFilter`,
    and the default filter used is `AcceptOnceFileListFilter`. This filter keeps track
    of processed files, but the implementation is in-memory. This means that if the
    server restarts when files are being processed, it will lose track of which files
    have been processed and will re-read the same files. To overcome this issue, an
    instance of `FileSystemPersistentAcceptOnceFileListFilter` should be used, which
    will keep track of processed files by leveraging the `MetadataStore` implementation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器是一个强大的概念，可以用来防止重复，根据名称模式选择文件，自定义读取的文件列表，并在所需内容呈现给下一个端点之前执行许多拦截。大多数常见任务都有预定义的过滤器可用，但在Spring的真正精神中，我们也可以有自定义实现，并将它们注入Spring
    Integration提供的适配器中。过滤器必须是`FileListFilter`的实例，默认使用的过滤器是`AcceptOnceFileListFilter`。此过滤器跟踪已处理的文件，但实现是在内存中的。这意味着如果服务器在处理文件时重新启动，它将丢失已处理的文件的跟踪，并将重新读取相同的文件。为了解决这个问题，应该使用`FileSystemPersistentAcceptOnceFileListFilter`的实例，它将通过利用`MetadataStore`实现来跟踪已处理的文件。
- en: 'Additionally, filename patterns and `Reg Ex` filters are available and can
    be used to filter files based on their names or by matching the name against the
    `Reg Ex` specified. Let''s see a quick example showing the use of these two filters:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，文件名模式和`Reg Ex`过滤器可用，并且可以用于根据它们的名称或与指定的`Reg Ex`匹配的名称来过滤文件。让我们看一个快速示例，展示了这两个过滤器的使用：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s say we want a custom filter, it can easily be defined and used. The
    code is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个自定义过滤器，可以很容易地定义并使用。代码如下：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Preventing duplicates
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止重复
- en: Preventing duplicates is a subset of filter that filters out files that have
    already been picked up. Using `prevent-duplicates`, we can instruct an adapter
    to look for unique files only. The only glitch here is that a duplicate check
    is limited to a session, as the reader does not store any state. If the reader
    restarts, it will read all the files again—even though they have been read earlier.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 防止重复是过滤器的一个子集，它过滤掉已经被拾取的文件。使用`prevent-duplicates`，我们可以指示适配器仅查找唯一的文件。这里唯一的问题是重复检查仅限于会话，因为读取器不存储任何状态。如果读取器重新启动，它将再次读取所有文件，即使它们之前已经被读取过。
- en: Concurrent access
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发访问
- en: 'This is a very common use case in enterprises with multiple consumers, and
    we want to maintain the sanity of the files consumed. We can use the `java.nio`
    locker in the following way to lock files to ensure that they are not accessed
    concurrently:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是企业中一个非常常见的用例，有多个消费者，我们希望保持已消耗文件的完整性。我们可以使用`java.nio` locker来锁定文件，以确保它们不会被同时访问：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code does not restrict us to use only `java.nio.locker`. Instead of using
    the `java.nio` locker, we can provide custom lockers as well:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不限制我们只使用`java.nio.locker`。我们可以提供自定义的locker，而不是使用`java.nio` locker：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Unlocking is not explicit. It is performed by calling `FileLocker.unlock(File
    file)`; otherwise, it will result in memory leaks over the period.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 解锁不是显式的。通过调用`FileLocker.unlock(File file)`来执行；否则，它将导致内存泄漏。
- en: Writing files
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写文件
- en: 'Spring Integration provides outbound adapters, which are the opposite of inbound
    adapters. This means that it consumes a file from a channel and writes it to a
    directory. Internally, Spring Integration uses an instance of `FileWritingMessageHandler`
    to write messages to the filesystem, and an implementation of this class can be
    used. This class can deal with files, strings, or byte array payloads. As usual,
    there is no need to use the low-level classes; instead, adapter and gateway exposed
    by spring can be used. Let''s connect an outbound adapter to the channel on which
    the inbound adapter writes files:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Integration提供了出站适配器，它是入站适配器的相反。这意味着它从通道中消耗文件并将其写入目录。在内部，Spring Integration使用`FileWritingMessageHandler`的实例将消息写入文件系统，并且可以使用这个类的实现。这个类可以处理文件、字符串或字节数组负载。像往常一样，不需要使用低级别的类；而是可以使用Spring提供的适配器和网关。让我们将出站适配器连接到入站适配器写入文件的通道上：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s discuss what each element represents:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论每个元素代表的含义：
- en: '`int-file:outbound-channel-adapter`: This provides file namespace support for
    the outbound channel adapter'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int-file:outbound-channel-adapter`：这为出站通道适配器提供了文件命名空间支持'
- en: '`channel`: This is the channel where the files would be written as Spring Integration
    messages'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`：这是文件将被写入为Spring Integration消息的通道'
- en: '`directory`: This is the directory from which files are picked'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directory`：这是选取文件的目录'
- en: '`delete-source-files`: If this is set to true, it will delete the files after
    processing them'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete-source-files`：如果设置为true，它将在处理文件后删除文件。'
- en: While writing files, we need to consider things such as what should be the name
    of the new file, which directory should it be written in, what should be done
    with the original file, and so on. Let's quickly touch upon these aspects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在写文件时，我们需要考虑一些事情，比如新文件的名称应该是什么，应该将其写入哪个目录，原始文件应该做什么，等等。让我们快速触及这些方面。
- en: Naming the file
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名文件
- en: By default, the name of the file will be retained when it is written in the
    directory. However, this can be overridden by providing an implementation `FileNameGenerator`.
    This is the class responsible for generating the filenames—by default `FileNameGenerator`
    looks for a message header whose key matches the constant `FileHeaders.FILENAME`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，文件的名称在写入目录时将被保留。但是，可以通过提供`FileNameGenerator`的实现来覆盖这一点。这个类负责生成文件名，默认情况下`FileNameGenerator`会查找一个消息头，其键与常量`FileHeaders.FILENAME`匹配。
- en: Target directory
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标目录
- en: 'There are primarily three ways to locate the target directory:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有三种方法来定位目标目录：
- en: Statically define a directory attribute that will direct each message to a fixed
    directory.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态定义一个目录属性，将每个消息定向到一个固定的目录。
- en: Define a directory-expression attribute that should be a valid **Spring Expression
    Language** (**SpEL**) expression. This expression is evaluated for each message
    and the message header can be used to dynamically specify the output file directory.
    The expression must resolve to a string or to `java.io.File`, and this must point
    to a valid directory.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个目录表达式属性，该属性应该是一个有效的**Spring表达式语言**（**SpEL**）表达式。该表达式对每个消息进行评估，并且消息头可以用于动态指定输出文件目录。该表达式必须解析为字符串或`java.io.File`，并且必须指向一个有效的目录。
- en: The last option is the auto create directory. If the destination directory is
    missing, it will be created automatically, including its parent directory. This
    is the default behavior; to disable this, set the `auto-create-directory` attribute
    to `false`.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个选项是自动创建目录。如果目标目录不存在，它将自动创建，包括其父目录。这是默认行为；要禁用此功能，请将`auto-create-directory`属性设置为`false`。
- en: Dealing with existing filenames
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理现有文件名
- en: 'What if the file being written already exists? The correct route to take is
    using the `mode` attribute. One of following four options is available:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在写入的文件已经存在，应该采取的正确路线是使用`mode`属性。有以下四个选项之一可用：
- en: '`REPLACE`: This is the default mode. If a file already exists, it will be simply
    overwritten.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REPLACE`：这是默认模式。如果文件已经存在，它将被简单地覆盖。'
- en: '`APPEND`: This will append the content of the incoming file to the existing
    one.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APPEND`：这将把传入文件的内容追加到现有文件中。'
- en: '`FAIL`: If a duplicate is not expected, this mode should be used. This will
    throw `MessageHandlingException` if the file already exists.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FAIL`：如果不希望出现重复，则应使用此模式。如果文件已经存在，它将抛出`MessageHandlingException`。'
- en: '`IGNORE`: If no action needs to be taken if the target file exists, this option
    should be used.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IGNORE`：如果目标文件存在时不需要采取任何操作，则应使用此选项。'
- en: 'So far, we have covered most of the aspects of the filesystem. However, what
    if we want to process the message after it has been written to the directory?
    Spring Integration provides an outbound gateway that can be handy here. Let''s
    have a look at this simple example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了文件系统的大部分方面。但是，如果我们想要在消息被写入目录后对其进行处理怎么办？Spring Integration提供了一个出站网关，在这里可能会很方便。让我们看一个简单的例子：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The tags are the same as those for the output adapter; the difference is that
    it puts the files on the channel specified by `reply-channel` for further processing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 标签与输出适配器的标签相同；不同之处在于它将文件放置在由`reply-channel`指定的通道上，以进行进一步处理。
- en: 'Let''s write a simple service activator that will process these files:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的服务激活器来处理这些文件：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: File transformers
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件转换器
- en: File transformers are used to transform data read from a file to an object and
    vice versa. Spring Integration has provided a few common transformers such as
    file to byte, file to string, and so on, but we can always extend the framework
    interfaces to define more advanced and appropriate file transformers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 文件转换器用于将从文件读取的数据转换为对象，反之亦然。Spring Integration提供了一些常见的转换器，如文件到字节，文件到字符串等，但我们始终可以扩展框架接口来定义更高级和适当的文件转换器。
- en: 'Let''s complete this section with a quick discussion on some implicit file
    transformers provided by spring. Let''s start with this example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个快速讨论来完成这一部分，讨论一下Spring提供的一些隐式文件转换器。让我们从这个例子开始：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As it's obvious from the preceding snippet, Spring Integration has provided
    implicit transformers for most common use cases as file to byte and file to string.
    Transformers are not restricted to these two cases—custom transformers can be
    defined by implementing the transformer interface or extending `AbstractFilePayloadTransformer`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中很明显，Spring Integration为大多数常见用例提供了隐式转换器，如文件到字节和文件到字符串。转换器不限于这两种情况——可以通过实现转换器接口或扩展`AbstractFilePayloadTransformer`来定义自定义转换器。
- en: FTP/FTPS
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP/FTPS
- en: '**FTP**, or **File Transfer Protocol**, is used to transfer files across networks.
    FTP communications consist of two parts: server and client. The client establishes
    a session with the server, after which it can download or upload files. Spring
    Integration provides components that act as a client and connect to the FTP server
    to communicate with it. What about the server—which server will it connect to?
    If you have access to any public or hosted FTP server, use it. Else, the easiest
    way for trying out the example in this section is to set up a local instance of
    the FTP server. FTP setup is out of the scope of this book.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**FTP**，或**文件传输协议**，用于在网络之间传输文件。FTP通信由两部分组成：服务器和客户端。客户端与服务器建立会话后，可以下载或上传文件。Spring
    Integration提供了作为客户端的组件，用于连接到FTP服务器进行通信。那么服务器呢——它将连接到哪个服务器？如果您可以访问任何公共或托管的FTP服务器，请使用它。否则，在本节示例中尝试的最简单方法是设置本地FTP服务器的实例。FTP设置超出了本书的范围。'
- en: Prerequisites
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'To use Spring Integration components for FTP/FTPS, we need to add a namespace
    to our configuration file and then add the Maven dependency entry in the `pom.xml`
    file. The following entries should be made:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Spring Integration组件进行FTP/FTPS，我们需要在配置文件中添加一个命名空间，然后在`pom.xml`文件中添加Maven依赖项条目。应该进行以下条目：
- en: 'Namespace support can be added by using the following code snippet:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用以下代码片段添加命名空间支持：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Maven entry can be added by using the following code snippet:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用以下代码片段添加Maven条目：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once namespace is available and the JAR has been downloaded, we are ready to
    use the components. As mentioned earlier, client components of Spring Integration
    need a session to establish with the FTP server. The details of the session is
    encapsulated in the session factory; let''s look at a sample session factory configuration:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命名空间可用并且JAR已经下载，我们就可以开始使用组件了。如前所述，Spring Integration的客户端组件需要与FTP服务器建立会话。会话的细节封装在会话工厂中；让我们看一个示例会话工厂配置：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `DefaultFtpSessionFactory` class is at work here`,` and it takes the following
    parameters:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`DefaultFtpSessionFactory`类正在工作，并且它接受以下参数：
- en: Host that is running the FTP server
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行FTP服务器的主机
- en: Port at which it's running the server
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器运行的端口
- en: Username
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名
- en: Password for the server
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器密码
- en: A session pool for the factory is maintained and an instance is returned when
    required. Spring takes care of validating that a stale session is never returned.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂的会话池会被维护，并在需要时返回一个实例。Spring会验证永远不会返回过期的会话。
- en: Downloading files from the FTP server
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从FTP服务器下载文件
- en: 'Inbound adapters can be used to read the files from the server. The most important
    aspect is the session factory that we just discussed in the preceding section.
    The following code snippet configures an FTP inbound adapter that downloads a
    file from a remote directory and makes it available for processing:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 入站适配器可用于从服务器读取文件。最重要的方面是我们在前一节中讨论过的会话工厂。以下代码片段配置了一个FTP入站适配器，用于从远程目录下载文件并使其可用于处理：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s quickly go through the tags used in this code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下此代码中使用的标签：
- en: '`int-ftp:inbound-channel-adapter`: This is the namespace support for the FTP
    inbound adapter.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int-ftp:inbound-channel-adapter`: 这是FTP入站适配器的命名空间支持。'
- en: '`channel`: This is the channel on which the downloaded files will be put as
    a message.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`: 这是下载的文件将作为消息放置的通道。'
- en: '`session-factory`: This is a factory instance that encapsulates details for
    connecting to a server.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session-factory`: 这是一个封装了连接到服务器的详细信息的工厂实例。'
- en: '`remote-directory`: This is the directory on the server where the adapter should
    listen for the new arrival of files.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remote-directory`: 这是适配器应在服务器上监听文件的新到达的目录。'
- en: '`local-directory`: This is the local directory where the downloaded files should
    be dumped.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local-directory`: 这是应将下载的文件转储的本地目录。'
- en: '`auto-create-local-directory`: If enabled, this will create the local directory
    structure if it''s missing.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto-create-local-directory`: 如果启用，将创建本地目录结构（如果缺失）。'
- en: '`delete-remote-files`: If enabled, this will delete the files on the remote
    directory after it has been downloaded successfully. This will help in avoiding
    duplicate processing.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete-remote-files`: 如果启用，将在成功下载文件后删除远程目录中的文件。这有助于避免重复处理。'
- en: '`filename-pattern`: This can be used as a filter, but only files matching the
    specified pattern will be downloaded.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filename-pattern`: 这可用作过滤器，但只会下载与指定模式匹配的文件。'
- en: '`local-filename-generator-expression`: This can be used to generate a local
    filename.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local-filename-generator-expression`: 这可用于生成本地文件名。'
- en: An inbound adapter is a special listener that listens for events on the remote
    directory, for example, an event fired on the creation of a new file. At this
    point, it will initiate the file transfer. It creates a payload of type `Message<File>`
    and puts it on the output channel. By default, the filename is retained and a
    file with the same name as the remote file is created in the local directory.
    This can be overridden by using `local-filename-generator-expression`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 入站适配器是一个特殊的监听器，用于监听远程目录上的事件，例如，在创建新文件时触发的事件。在这一点上，它将启动文件传输。它创建了一个`Message<File>`类型的有效负载，并将其放在输出通道上。默认情况下，保留文件名，并在本地目录中创建与远程文件同名的文件。可以使用`local-filename-generator-expression`进行覆盖。
- en: Incomplete files
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不完整的文件
- en: On the remote server, there could be files that are still in the process of
    being written. Typically, there the extension is different, for example, `filename.actualext.writing`.
    The best way to avoid reading incomplete files is to use the filename pattern
    that will copy only those files that have been written completely.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程服务器上，可能有一些仍在写入过程中的文件。通常，扩展名是不同的，例如，`filename.actualext.writing`。避免读取不完整的文件的最佳方法是使用只会复制已完全写入的文件的文件名模式。
- en: Uploading files to the FTP server
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传文件到FTP服务器
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is a brief description of the tags used:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是所使用标签的简要描述：
- en: '`int-ftp:outbound-channel-adapter`: This is the namespace support for the FTP
    outbound adapter.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int-ftp:outbound-channel-adapter`: 这是FTP出站适配器的命名空间支持。'
- en: '`channel`: This is the name of the channel whose payload will be written to
    the remote server.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`: 这是其有效负载将被写入到远程服务器的通道的名称。'
- en: '`remote-directory`: This is the remote directory where files will be put. The
    user configured in the session factory must have appropriate permission.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remote-directory`: 这是将放置文件的远程目录。会话工厂中配置的用户必须具有适当的权限。'
- en: '`session-factory`: This encapsulates details for connecting to the FTP server.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session-factory`: 这封装了连接到FTP服务器的详细信息。'
- en: '`auto-create-directory`: If enabled, this will automatically create a remote
    directory if it''s missing, and the given user should have sufficient permission.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto-create-directory`: 如果启用，将自动创建远程目录（如果缺失），并且给定用户应具有足够的权限。'
- en: 'The payload on the channel need not necessarily be a file type; it can be one
    of the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通道上的有效负载不一定是文件类型；它可以是以下之一：
- en: '`java.io.File`: A Java file object'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.io.File`: 一个Java文件对象'
- en: '`byte[]`: This is a byte array that represents the file contents'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte[]`: 这是表示文件内容的字节数组'
- en: '`java.lang.String`: This is the text that represents the file contents'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.String`: 这是表示文件内容的文本'
- en: Avoiding partially written files
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免部分写入的文件
- en: Files on the remote server must be made available only when they have been written
    completely and not when they are still partial. Spring uses a mechanism of writing
    the files to a temporary location and its availability is published only when
    it has been completely written. By default, the suffix is written, but it can
    be changed using the `temporary-file-`suffix property. This can be completely
    disabled by setting `use-temporary-file-name` to `false`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当远程服务器上的文件完全写入时才能使用。Spring使用一种将文件写入临时位置并仅在完全写入时发布其可用性的机制。默认情况下，会写入后缀，但可以使用`temporary-file-`suffix属性进行更改。通过将`use-temporary-file-name`设置为`false`可以完全禁用此功能。
- en: FTP outbound gateway
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FTP出站网关
- en: 'Gateway, by definition, is a two-way component: it accepts input and provides
    a result for further processing. So what is the input and output in the case of
    FTP? It issues commands to the FTP server and returns the result of the command.
    The following command will issue an `ls` command with the option `–l` to the server.
    The result is a list of string objects containing the filename of each file that
    will be put on the `reply-channel`. The code is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 网关在定义上是一个双向组件：它接受输入并提供结果以供进一步处理。那么在FTP的情况下输入和输出是什么？它向FTP服务器发出命令并返回命令的结果。以下命令将向服务器发出带有选项`-l`的`ls`命令。结果是一个包含每个文件的文件名的字符串对象列表，将放在`reply-channel`上。代码如下：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The tags are pretty simple:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 标签非常简单：
- en: '`int-ftp:outbound-gateway`: This is the namespace support for the FTP outbound
    gateway'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int-ftp:outbound-gateway`：这是FTP出站网关的命名空间支持'
- en: '`session-factory`: This is the wrapper for details needed to connect to the
    FTP server'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session-factory`：这是连接到FTP服务器所需的详细信息的包装器'
- en: '`command`: This is the command to be issued'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command`：这是要发出的命令'
- en: '`command-options`: This is the option for the command'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command-options`：这是命令的选项'
- en: '`reply-channel`: This is the response of the command that is put on this channel'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reply-channel`：这是放在此通道上的命令的响应'
- en: FTPS support
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FTPS支持
- en: 'For FTPS support, all that is needed is to change the factory class—an instance
    of `org.springframework.integration.ftp.session.DefaultFtpsSessionFactory` should
    be used. Note the `s` in `DefaultFtpsSessionFactory`. Once the session is created
    with this factory, it''s ready to communicate over a secure channel. Here is an
    example of a secure session factory configuration:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于FTPS支持，需要做的就是更改工厂类——应使用`org.springframework.integration.ftp.session.DefaultFtpsSessionFactory`的实例。请注意`DefaultFtpsSessionFactory`中的`s`。一旦使用此工厂创建会话，它就准备好通过安全通道进行通信。以下是一个安全会话工厂配置的示例：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Although it is obvious, I would remind you that the FTP server must be configured
    to support a secure connection and open the appropriate *port*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是显而易见的，我要提醒您FTP服务器必须配置为支持安全连接并打开适当的*端口*。
- en: Social integration
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社交整合
- en: Any application in today's context is incomplete if it does not provide support
    for social messaging. Spring Integration provides in-built support for many social
    interfaces such as e-mails, Twitter feeds, and so on. Let's discuss the implementation
    of Twitter in this section. Prior to Version 2.1, Spring Integration was dependent
    on the Twitter4J API for Twitter support, but now it leverages Spring's social
    module for Twitter integration. Spring Integration provides an interface for receiving
    and sending tweets as well as searching and publishing the search results in messages.
    Twitter uses `oauth` for authentication purposes. An app must be registered before
    we start Twitter development on it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的环境中，任何应用程序如果不提供对社交消息的支持就是不完整的。Spring Integration提供了对许多社交接口的内置支持，如电子邮件、Twitter
    feeds等等。让我们在本节讨论Twitter的实现。在2.1版本之前，Spring Integration依赖于Twitter4J API来支持Twitter，但现在它利用Spring的社交模块来集成Twitter。Spring
    Integration提供了一个接口，用于接收和发送tweets以及搜索和发布搜索结果。Twitter使用`oauth`进行身份验证。在开始Twitter开发之前，必须注册一个应用程序。
- en: Prerequisites
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'Let''s look at the steps that need to be completed before we can use a Twitter
    component in our Spring Integration example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在我们的Spring Integration示例中使用Twitter组件之前需要完成的步骤：
- en: '**Twitter account setup:** A Twitter account is needed. Perform the following
    steps to get the keys that will allow the user to use Twitter using the API:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Twitter账户设置：**需要一个Twitter账户。执行以下步骤以获取允许用户使用API使用Twitter的密钥：'
- en: Visit [https://apps.twitter.com/](https://apps.twitter.com/).
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://apps.twitter.com/](https://apps.twitter.com/)。
- en: Sign in to your account.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到您的账户。
- en: Click on **Create New App**.![Prerequisites](img/00009.jpeg)
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建新应用**。![先决条件](img/00009.jpeg)
- en: Enter the details such as **Application name**, **Description**, **Website**,
    and so on. All fields are self-explanatory and appropriate help has also been
    provided. The value for the field **Website** need not be a valid one—put an arbitrary
    website name in the correct format.![Prerequisites](img/00010.jpeg)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入详细信息，如**应用程序名称**、**描述**、**网站**等。所有字段都是不言自明的，并且还提供了适当的帮助。字段**网站**的值不需要是有效的——以正确的格式输入一个任意的网站名称。![先决条件](img/00010.jpeg)
- en: Click on the **Create your application** button. If the application is created
    successfully, a confirmation message will be shown and the **Application Management**
    page will appear, as shown here:![Prerequisites](img/00011.jpeg)
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建您的应用程序**按钮。如果应用程序成功创建，将显示确认消息，并显示**应用程序管理**页面，如下所示：![先决条件](img/00011.jpeg)
- en: Go to the **Keys and Access Tokens** tab and note the details for **Consumer
    Key (API Key)** and **Consumer Secret (API Secret)** under **Application Settings**,
    as shown in the following screenshot:![Prerequisites](img/00012.jpeg)
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**密钥和访问令牌**选项卡，并在**应用程序设置**下记下**消费者密钥（API密钥）**和**消费者密钥（API密钥）**的详细信息，如下图所示：![先决条件](img/00012.jpeg)
- en: You need additional access tokens so that applications can use Twitter using
    APIs. Click on **Create my access token**; it takes a while to generate these
    tokens. Once it is generated, note down the value of **Access Token** and **Access
    Token Secret**.![Prerequisites](img/00013.jpeg)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要额外的访问令牌，以便应用程序可以使用Twitter的API。点击**创建我的访问令牌**；生成这些令牌需要一段时间。生成后，记下**访问令牌**和**访问令牌密钥**的值。![先决条件](img/00013.jpeg)
- en: Go to the **Permissions** tab and provide permission to **Read, Write** **and
    Access direct messages**.![Prerequisites](img/00014.jpeg)
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**权限**选项卡，并授予**读取、写入**和**访问直接消息**的权限。![先决条件](img/00014.jpeg)
- en: 'After performing all these steps, and with the required keys and access token,
    we are ready to use Twitter. Let''s store these in the `twitterauth.properties`
    property file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些步骤，并获得所需的密钥和访问令牌后，我们就可以使用Twitter了。让我们将这些存储在`twitterauth.properties`属性文件中：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As I mentioned, the template encapsulates all the values. Here is the order
    of the arguments:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，模板封装了所有的值。以下是参数的顺序：
- en: '`apiKey`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiKey`'
- en: '`apiSecret`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiSecret`'
- en: '`accessToken`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accessToken`'
- en: '`accessTokenSecret`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accessTokenSecret`'
- en: 'With all the setup in place, let''s now do some real work:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有的设置，现在让我们做一些真正的工作：
- en: 'Namespace support can be added by using the following code snippet:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用以下代码片段来添加命名空间支持：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Maven entry can be added by using the following code snippet:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用以下代码片段来添加Maven条目：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Receiving tweets
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接收推文
- en: 'The components in this code are covered in the following bullet points:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码中的组件在以下项目中涵盖：
- en: '`int-twitter:inbound-channel-adapter`: This is the namespace support for Twitter''s
    inbound channel adapter.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int-twitter:inbound-channel-adapter`：这是Twitter入站通道适配器的命名空间支持。'
- en: '`twitter-template`: This is the most important aspect. The Twitter template
    encapsulates which account to use to poll the Twitter site. The details given
    in the preceding code snippet are fake; it should be replaced with real connection
    parameters.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`twitter-template`：这是最重要的部分。Twitter模板封装了用于轮询Twitter网站的账户。前面代码片段中给出的细节是虚假的；它应该被真实的连接参数替换。'
- en: '`channel`: Messages are dumped on this channel.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`：消息被转储到这个通道上。'
- en: These adapters are further used for other applications, such as for searching
    messages, retrieving direct messages, and retrieving tweets that mention your
    account, and so on. Let's have a quick look at the code snippets for these adapters.
    I will not go into detail for each one; they are almost similar to what have been
    discussed previously.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些适配器进一步用于其他应用程序，比如搜索消息、检索直接消息、检索提及您账户的推文等等。让我们快速看一下这些适配器的代码片段。我不会对每一个细节进行讨论；它们几乎与之前讨论过的内容相似。
- en: '**Search**: This adapter helps to search the tweets for the parameter configured
    in the query tag. The code is as follows:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：此适配器帮助搜索在查询标签中配置的推文。代码如下：'
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Retrieving Direct Messages**: This adapter allows us to receive the direct
    message for the account in use (account configured in Twitter template). The code
    is as follows:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检索直接消息**：此适配器允许我们接收正在使用的账户的直接消息（在Twitter模板中配置的账户）。代码如下：'
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Retrieving Mention Messages**: This adapter allows us to receive messages
    that mention the configured account via the `@user` tag (account configured in
    the Twitter template). The code is as follows:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检索提及消息**：此适配器允许我们接收提及在Twitter模板中配置的账户的消息通过`@user`标签。代码如下：'
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Sending tweets
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送推文
- en: 'Twitter exposes outbound adapters to send messages. Here is a sample code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter提供了发送消息的出站适配器。以下是一个示例代码：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Whatever message is put on the `twitterSendMessageChannel` channel is tweeted
    by this adapter. Similar to an inbound gateway, the outbound gateway provides
    support for sending direct messages. Here is a simple example of an outbound adapter:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 任何放在`twitterSendMessageChannel`通道上的消息都会被此适配器推文。与入站网关类似，出站网关提供了发送直接消息的支持。以下是一个出站适配器的简单示例：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Any message that is put on the `twitterSendDirectMessage` channel is sent to
    the user directly. But where is the name of the user to whom the message will
    be sent? It is decided by a header in the message `TwitterHeaders.DM_TARGET_USER_ID`.
    This must be populated either programmatically, or by using enrichers or SpEL.
    For example, it can be programmatically added as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 任何放在`twitterSendDirectMessage`通道上的消息都会直接发送给用户。但是消息将发送给哪个用户的名称在哪里？这由消息中的一个头部`TwitterHeaders.DM_TARGET_USER_ID`决定。这必须要通过编程或者使用丰富器或SpEL来填充。例如，可以通过编程方式添加如下：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Alternatively, it can be populated by using a header enricher, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过使用头部丰富器来填充，如下所示：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Twitter search outbound gateway
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Twitter搜索出站网关
- en: 'As gateways provide a two-way window, the search outbound gateway can be used
    to issue dynamic search commands and receive the results as a collection. If no
    result is found, the collection is empty. Let''s configure a search outbound gateway,
    as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网关提供了一个双向窗口，搜索出站网关可以用于发出动态搜索命令并将结果作为集合接收。如果没有找到结果，集合为空。让我们配置一个搜索出站网关，如下所示：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And here is what the tags covered in this code mean:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码中涵盖的标签的含义：
- en: '`int-twitter:search-outbound-gateway`: This is the namespace for the Twitter
    search outbound gateway'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int-twitter:search-outbound-gateway`：这是Twitter搜索出站网关的命名空间'
- en: '`request-channel`: This is the channel that is used to send search requests
    to this gateway'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request-channel`：这是用于向此网关发送搜索请求的通道'
- en: '`twitter-template`: This is the Twitter template reference'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`twitter-template`：这是Twitter模板的引用'
- en: '`search-args-expression`: This is used as arguments for the search'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search-args-expression`：这用作搜索的参数'
- en: '`reply-channel`: This is the channel on which searched results are populated'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reply-channel`：这是搜索结果被填充的通道'
- en: This gives us enough to get started with the social integration aspects of the
    spring framework.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了足够的内容来开始使用Spring框架的社交集成方面。
- en: Enterprise messaging
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业消息
- en: Enterprise landscape is incomplete without JMS—it is one of the most commonly
    used mediums of enterprise integration. Spring provides very good support for
    this. Spring Integration builds over that support and provides adapter and gateways
    to receive and consume messages from many middleware brokers such as ActiveMQ,
    RabbitMQ, Rediss, and so on.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 企业景观没有JMS是不完整的——它是企业集成中最常用的媒介之一。Spring对此提供了非常好的支持。Spring Integration建立在这种支持之上，并提供了适配器和网关，以从许多中间件代理商（如ActiveMQ、RabbitMQ、Rediss等）接收和消费消息。
- en: Spring Integration provides inbound and outbound adapters to send and receive
    messages along with gateways that can be used in a request/reply scenario. Let's
    walk through these implementations in a little more detail. A basic understanding
    of the JMS mechanism and its concepts is expected. It is not possible to cover
    even the introduction of JMS here. Let's start with the prerequisites.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Integration提供了入站和出站适配器，用于发送和接收消息，以及可以在请求/响应场景中使用的网关。让我们更详细地了解这些实现。我们期望您对JMS机制及其概念有基本的了解。在这里不可能覆盖JMS的介绍。让我们从先决条件开始。
- en: Prerequisites
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'To use Spring Integration messaging components, namespaces, and relevant Maven
    the following dependency should be added:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Spring Integration消息组件、命名空间和相关的Maven，应该添加以下依赖项：
- en: 'Namespace support can be added by using the following code snippet:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用以下代码片段添加命名空间支持：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Maven entry can be provided using the following code snippet:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用以下代码片段提供Maven条目：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After adding these two dependencies, we are ready to use the components. But
    before we can use an adapter, we must configure an underlying message broker.
    Let''s configure ActiveMQ. Add the following in `pom.xml`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这两个依赖项后，我们就可以使用这些组件了。但在我们可以使用适配器之前，我们必须配置一个底层的消息代理。让我们配置ActiveMQ。在`pom.xml`中添加以下内容：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After this, we are ready to create a connection factory and JMS queue that
    will be used by the adapters to communicate. First, create a session factory.
    As you will notice, this is wrapped in Spring''s `CachingConnectionFactory`, but
    the underlying provider is ActiveMQ:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这之后，我们准备创建一个连接工厂和JMS队列，供适配器进行通信。首先，创建一个会话工厂。正如您所注意到的，这是包装在Spring的`CachingConnectionFactory`中，但底层提供者是ActiveMQ：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s create a queue that can be used to retrieve and put messages:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个可以用来检索和放置消息的队列：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, we are ready to send and retrieve messages from the queue. Let's look into
    each message one by one.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好从队列中发送和检索消息了。让我们逐条查看每条消息。
- en: Receiving messages – the inbound adapter
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接收消息 - 入站适配器
- en: 'Spring Integration provides two ways of receiving messages: polling and event
    listener. Both of them are based on the underlying Spring framework''s comprehensive
    support for JMS. `JmsTemplate` is used by the polling adapter, while `MessageListener`
    is used by the event-driven adapter. As the name suggests, a polling adapter keeps
    polling the queue for the arrival of new messages and puts the message on the
    configured channel if it finds one. On the other hand, in the case of the event-driven
    adapter, it''s the responsibility of the server to notify the configured adapter.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Integration提供了两种接收消息的方式：轮询和事件监听器。它们都基于底层Spring框架对JMS的全面支持。轮询适配器使用`JmsTemplate`，而事件驱动适配器使用`MessageListener`。顾名思义，轮询适配器会不断轮询队列，以查找新消息的到达，并在找到消息时将其放在配置的通道上。另一方面，在事件驱动适配器的情况下，服务器负责通知配置的适配器。
- en: The polling adapter
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 轮询适配器
- en: 'Let''s start with a code sample:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个代码示例开始：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There is a poller element, so it''s obvious that it is a polling-based adapter.
    It can be configured in one of two ways: by providing a JMS template or using
    a connection factory along with a destination. I have used the latter approach.
    The preceding adapter has a polling queue mentioned in the destination and once
    it gets any message, it puts the message on the channel configured in the `channel`
    attribute.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个轮询器元素，所以很明显这是一个基于轮询的适配器。它可以通过提供JMS模板或者使用连接工厂和目的地来进行配置。我使用了后一种方法。前面的适配器在目的地中提到了一个轮询队列，一旦它收到任何消息，就会将消息放在`channel`属性中配置的通道上。
- en: The event-driven adapter
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件驱动适配器
- en: 'Similar to polling adapters, event-driven adapters also need a reference either
    to an implementation of the interface `AbstractMessageListenerContainer` or need
    a connection factory and destination. Again, I will use the latter approach. Here
    is a sample configuration:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与轮询适配器类似，事件驱动适配器也需要引用`AbstractMessageListenerContainer`接口的实现，或者需要连接工厂和目的地。同样，我将使用后一种方法。以下是一个示例配置：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There is no poller sub-element here. As soon as a message arrives at its destination,
    the adapter is invoked, which puts it on the configured channel.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有轮询器子元素。一旦消息到达目的地，适配器就会被调用，将其放在配置的通道上。
- en: Sending messages – the outbound adapter
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送消息 - 出站适配器
- en: 'Outbound adapters convert messages on the channel to JMS messages and put them
    on the configured queue. To convert Spring Integration messages to JMS messages,
    the outbound adapter uses `JmsSendingMessageHandler`. This is is an implementation
    of `MessageHandler`. Outbound adapters should be configured with either `JmsTemplate`
    or with a connection factory and destination queue. Keeping in sync with the preceding
    examples, we will take the latter approach, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 出站适配器将通道上的消息转换为JMS消息，并将其放在配置的队列上。为了将Spring Integration消息转换为JMS消息，出站适配器使用`JmsSendingMessageHandler`。这是`MessageHandler`的一个实现。出站适配器应该配置为`JmsTemplate`或者使用连接工厂和目的地队列。与前面的示例保持同步，我们将采用后一种方法，如下所示：
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This adapter receives the Spring Integration message from `jmsChannel`, converts
    it to a JMS message, and puts it on the destination.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个适配器从`jmsChannel`接收Spring Integration消息，将其转换为JMS消息，并将其放在目的地上。
- en: Gateway
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网关
- en: Gateway provides a request/reply behavior instead of a one-way send or receive.
    For example, after sending a message, we might expect a reply or we may want to
    send an acknowledgement after receiving a message.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 网关提供了请求/响应行为，而不是单向发送或接收。例如，在发送消息后，我们可能期望得到一个回复，或者在接收消息后我们可能想发送一个确认。
- en: The inbound gateway
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入站网关
- en: 'Inbound gateways provide an alternative to inbound adapters when request-reply
    capabilities are expected. An inbound gateway is an event-based implementation
    that listens for a message on the queue, converts it to Spring `Message`, and
    puts it on the channel. Here is a sample code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当期望请求-回复功能时，入站网关提供了入站适配器的替代方案。入站网关是一种基于事件的实现，它在队列上监听消息，将其转换为Spring`Message`，并将其放在通道上。以下是一个示例代码：
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'However, this is what an inbound adapter does—even the configuration is similar,
    except the namespace. So, what is the difference? The difference lies in replying
    back to the reply destination. Once the message is put on the channel, it will
    be propagated down the line and at some stage a reply would be generated and sent
    back as an acknowledgement. The inbound gateway, on receiving this reply, will
    create a JMS message and put it back on the reply destination queue. Then, where
    is the reply destination? The reply destination is decided in one of the following
    ways:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这就是入站适配器所做的事情——即使配置相似，除了命名空间。那么，区别在哪里？区别在于回复回到回复目的地。一旦消息被放入通道，它将被传播到下一阶段，并在某个阶段生成并发送回复作为确认。入站网关在接收到此回复时，将创建JMS消息并将其放回回复目的地队列。那么，回复目的地在哪里？
- en: Original message has a property `JMSReplyTo`, if it's present it has the highest
    precedence.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始消息具有属性`JMSReplyTo`，如果存在，则具有最高优先级。
- en: The inbound gateway looks for a configured, default-reply-destination which
    can be configured either as a name or as a direct reference of a channel. For
    specifying channel as direct reference default-reply-destination tag should be
    used.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 入站网关寻找已配置的`default-reply-destination`，它可以配置为名称或作为通道的直接引用。要将通道指定为直接引用`default-reply-destination`标签应该被使用。
- en: An exception will be thrown by the gateway if it does not find either of the
    preceding two ways.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网关找不到前两种方式中的任何一种，将抛出异常。
- en: The outbound gateway
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 出站网关
- en: 'Outbound gateways should be used in scenarios where a reply is expected for
    the send messages. Let''s start with an example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 出站网关应该在期望发送消息的情况下使用。让我们从一个例子开始：
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding configuration will send messages to `request-destination`. When
    an acknowledgement is received, it can be fetched from the configured `reply-destination`.
    If `reply-destination` has not been configured, JMS `TemporaryQueues` will be
    created.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置将消息发送到`request-destination`。当收到确认时，可以从配置的`reply-destination`中获取。如果未配置`reply-destination`，将创建JMS`TemporaryQueues`。
- en: HTTP
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP
- en: Spring Integration provides support to access external HTTP services as well
    as to expose HTTP services to an external application.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Integration提供了访问外部HTTP服务以及向外部应用程序公开HTTP服务的支持。
- en: Prerequisites
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'Let''s add a namespace and relevant Maven dependency so that Spring Integration''s
    HTTP components are available for use in our application:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个名称空间和相关的Maven依赖项，以便Spring Integration的HTTP组件可用于我们的应用程序中：
- en: 'Namepace support can be added using the following code snippet:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用以下代码片段添加名称空间支持：
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Maven entry can be added using the following code:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用以下代码添加Maven条目：
- en: '[PRE43]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The HTTP inbound gateway
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP入站网关
- en: 'Inbound gateways expose HTTP services to the external world, for example, REST-based
    web services. The application must be deployed in a web container such as Jetty
    or Tomcat for the inbound adapter or the gateway to work. The easiest way to implement
    the inbound component is by using Spring''s `HttpRequestHandlerServlet` class,
    and by defining it in the `web.xml` file. Here is a sample entry:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 入站网关向外部世界公开HTTP服务，例如基于REST的Web服务。应用程序必须部署在诸如Jetty或Tomcat之类的Web容器中，以便入站适配器或网关正常工作。实现入站组件的最简单方法是使用Spring的`HttpRequestHandlerServlet`类，并在`web.xml`文件中定义它。以下是一个示例条目：
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Alternatively, we can use the spring MVC support. This is what we have used
    in our example; let''s take a look at the `web.xml` file:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用Spring MVC支持。这是我们在示例中使用的内容；让我们看一下`web.xml`文件：
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `org.springframework.web.servlet.DispatcherServlet` class is a standard
    Spring MVC controller. Notice the configuration parameter, `http-inbound-config.xml`.
    This is the file that will have the declaration for the gateway:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.springframework.web.servlet.DispatcherServlet`类是标准的Spring MVC控制器。注意配置参数`http-inbound-config.xml`。这是将为网关声明的文件：'
- en: '[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The components used in this code are explained in the following bullet points:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码中使用的组件在以下项目符号中进行了解释：
- en: '`int-http:inbound-gateway`: This is the namespace support for the HTML gateway'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int-http:inbound-gateway`：这是HTML网关的名称空间支持'
- en: '`request-channel`: This will put the incoming request payload on the channel'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request-channel`：这将把传入的请求有效负载放在通道上'
- en: '`path`: This is the path exposed for incoming requests'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：这是为传入请求公开的路径'
- en: '`supported-methods`: This is a comma-separated list of supported methods that
    use the HTTP protocol'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`supported-methods`：这是使用HTTP协议的支持方法的逗号分隔列表'
- en: 'In the following code, the service activator listens for the payload on the
    input channel and modifies it before an inbound gateway sends a response:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，服务激活器监听输入通道上的有效负载，并在入站网关发送响应之前修改它：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`HttpMessageConverter` can be used to convert `HttpServletRequest` to `Messages`.
    A gateway element produces different instances depending on whether it has to
    return just a response (for example 200 success) or it has to return a response
    with a view. If the response is a view, it produces an instance of `HttpRequestHandlingController`.
    Otherwise, it produces an instance of `HandlingMessagingGateway`. To render the
    view, any view-rendering technology supported by Spring MVC can be used.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpMessageConverter`可用于将`HttpServletRequest`转换为`Messages`。网关元素根据是否只需返回响应（例如200成功）或必须返回带有视图的响应而产生不同的实例。如果响应是视图，则会产生`HttpRequestHandlingController`的实例。否则，它会产生`HandlingMessagingGateway`的实例。为了呈现视图，可以使用Spring
    MVC支持的任何视图呈现技术。'
- en: 'For requests that just require a confirmation that the request was successful,
    an adapter can be used instead of the gateway:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只需要确认请求成功的请求，可以使用适配器而不是网关：
- en: '[PRE48]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The HTTP outbound gateway
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP出站网关
- en: 'The outbound gateway is used to invoke services published by external HTTP
    components. Let''s use our preceding example to test this. Create a war of the
    application that has inbound gateways and deploy it in a container. We can use
    the following example of an outbound gateway to invoke the HTTP request:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 出站网关用于调用外部HTTP组件发布的服务。让我们使用上面的示例来测试这个。创建一个具有入站网关的应用程序的war包，并将其部署在容器中。我们可以使用以下出站网关的示例来调用HTTP请求：
- en: '[PRE49]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The components used in this code are explained in the following bullet points:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码中使用的组件在以下项目中进行了解释：
- en: '`int-http:outbound-gateway`: This is the namespace support for the HTTP outbound
    gateway'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int-http:outbound-gateway`：这是HTTP出站网关的命名空间支持'
- en: '`channel`: Based on the message on this channel, it will try to hit the URL'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`：基于该通道上的消息，它将尝试命中URL'
- en: '`url`: This is the external URL to which a request is made'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`：这是发出请求的外部URL'
- en: '`http-method`: This specifies which HTTP methods should be used while making
    the request'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http-method`：这指定了在发出请求时应使用哪些HTTP方法'
- en: '`expected-response-type`: This is the type of response expected (by default,
    it''s `String`)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expected-response-type`：这是期望的响应类型（默认情况下是`String`）'
- en: 'Instead of gateway, adapters can also be used. The only difference is that
    an adapter does not send a response back on the reply channel. Under the hood,
    outbound adapters use the `RestTemplate` from the Spring framework. The following
    code snippet adds the outbound adapter:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 除了网关，还可以使用适配器。唯一的区别是适配器不会在回复通道上发送响应。在幕后，出站适配器使用Spring框架的`RestTemplate`。以下代码片段添加了出站适配器：
- en: '[PRE50]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Web services
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web服务
- en: The HTTP adapter and gateways provide support for REST-based web services, but
    Spring Integration also provides support for XML-based web services such as SOAP.
    An inbound adapter or gateway is used to create and expose an endpoint as a web
    service, while an outbound adapter or gateway is used to invoke external services.
    Spring Integration support for web services is built over the spring `ws` project.
    I am not going to cover spring `ws` or any specific SOAP details such as `wsdl`,
    header, body, or payload. Instead, we will showcase the Spring Integration wrappers.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP适配器和网关提供了对基于REST的Web服务的支持，但Spring Integration还提供了对基于XML的Web服务（如SOAP）的支持。入站适配器或网关用于创建和公开端点作为Web服务，而出站适配器或网关用于调用外部服务。Spring
    Integration对Web服务的支持是建立在spring `ws`项目之上的。我不打算涵盖spring `ws`或任何特定的SOAP细节，比如`wsdl`、头部、主体或负载。相反，我们将展示Spring
    Integration的封装器。
- en: Prerequisites
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'Web services support can be added by including the following namespaces and
    Maven dependencies:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包括以下命名空间和Maven依赖项，可以添加Web服务支持：
- en: 'Namespace support can be added using the following code snippet:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用以下代码片段添加命名空间支持：
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Maven entry can be added using the following code:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用以下代码添加Maven条目：
- en: '[PRE52]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The inbound gateway
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入站网关
- en: 'Inbound gateways will expose a SOAP service for handling an external request,
    which will then be converted to messages and posted to the channel. A front controller
    is required to intercept requests and pass them on the configured gateway; it
    is an instance of `org.springframework.ws.transport.http.MessageDispatcherServlet`.
    This should be configured in the `web.xml` file:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 入站网关将公开一个SOAP服务来处理外部请求，然后将其转换为消息并发布到通道。需要一个前端控制器来拦截请求并将其传递给配置的网关；它是`org.springframework.ws.transport.http.MessageDispatcherServlet`的一个实例。这应该在`web.xml`文件中进行配置：
- en: '[PRE53]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'An implementation of `org.springframework.ws.server.EndpointMapping` must be
    provided to do the mapping between servlet and an endpoint. This can be configured
    either in the Java configuration class or property file. Let''s put it in a property
    file and inject it as `contextConfigLocation`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 必须提供`org.springframework.ws.server.EndpointMapping`的实现来执行servlet和端点之间的映射。这可以在Java配置类或属性文件中进行配置。让我们将其放在一个属性文件中，并将其注入为`contextConfigLocation`：
- en: '[PRE54]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `org.springframework.ws.server.endpoint.mapping.UriEndpointMapping` class
    performs servlet to `Message` mapping.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.springframework.ws.server.endpoint.mapping.UriEndpointMapping`类执行servlet到`Message`的映射。'
- en: 'After that, we have the service activator that can change the response or do
    some operations on it:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有服务激活器，可以更改响应或对其进行一些操作：
- en: '[PRE55]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The outbound gateway
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 出站网关
- en: 'This is even easier; the outbound gateway can take a URI and invoke the service,
    as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至更简单；出站网关可以接受一个URI并调用服务，如下所示：
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the preceding code, a valid SOAP payload should be put on the `request-channel`;
    this will be used by the gateway to invoke the service configured. The payload
    of the response is published on the `reply-channel`. Here is an example code snippet
    to invoke the preceding service:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，一个有效的SOAP负载应该放在`request-channel`上；这将被网关用来调用配置的服务。响应的负载将发布在`reply-channel`上。以下是一个调用上述服务的示例代码片段：
- en: '[PRE57]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Database SQL
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库SQL
- en: It's difficult to imagine enterprise applications without any database; it is
    one of the oldest and most commonly used bridging mechanisms. Spring Integration
    provides support to read from and write to the database. Again, this support is
    based on the Spring framework's foundation for database support. It provides inbound
    and outbound adapters, gateways, and even specific adapters for stored procedures.
    Let's have a look at some of these, and others can be used on the same pattern.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 很难想象没有任何数据库的企业应用程序；它是最古老和最常用的桥接机制之一。Spring Integration提供了对数据库的读取和写入支持。同样，这种支持是基于Spring框架对数据库支持的基础。它提供了入站和出站适配器、网关，甚至特定的存储过程适配器。让我们来看看其中一些，其他的也可以按照相同的模式使用。
- en: Prerequisites
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'Before we talk about how to use database support of Spring Integration, let''s
    add the necessary namespaces and Maven dependencies:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论如何使用Spring Integration的数据库支持之前，让我们添加必要的命名空间和Maven依赖项：
- en: 'Namespace support can be added using the following code snippet:'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持命名空间可以使用以下代码片段添加：
- en: '[PRE58]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Maven entry can be added using the following code snippet:'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用以下代码片段添加Maven条目：
- en: '[PRE59]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Datasource
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据源
- en: 'Before we can start using the component, we need to define a datasource. Datasource
    is a wrapper that encapsulates database connection details. A sample datasource
    for an in-memory database H2 is as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用组件之前，我们需要定义一个数据源。数据源是一个封装数据库连接详细信息的包装器。用于内存数据库H2的示例数据源如下：
- en: '[PRE60]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For simplicity, I will use an in-memory database. But this is nothing specific
    to Spring Integration; datasource can be configured for any database supported
    by Spring. Include the following dependency in `pom.xml` for the in-memory database:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我将使用内存数据库。但这与Spring Integration无关；数据源可以为Spring支持的任何数据库进行配置。在`pom.xml`中包含以下依赖项以获取内存数据库：
- en: '[PRE61]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, we are ready with the datasource. Let''s initialize it with some test
    data; again, Spring provides easy-to-use components that can get our task done
    in a couple of lines of configuration:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了数据源。让我们用一些测试数据初始化它；再次，Spring提供了易于使用的组件，可以在几行配置中完成我们的任务：
- en: '[PRE62]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: With the preceding configuration, we are now ready to explore the adapters,
    gateways, and other components provided by Spring.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述配置，我们现在准备好探索Spring提供的适配器、网关和其他组件。
- en: Reading from the database – the inbound adapter
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数据库中读取 - 入站适配器
- en: 'The inbound adapter needs a reference to `JdbcTemplate` or datasource. We will
    stick to datasource. Its task is to read data from the database and put the result
    on the specified channel. By default, the message payload is the whole result
    set expressed as a list. The result set type can be changed by defining the `RowMapper`
    strategy, support for which is provided by spring:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 入站适配器需要引用`JdbcTemplate`或数据源。我们将坚持使用数据源。它的任务是从数据库中读取数据并将结果放在指定的通道上。默认情况下，消息有效载荷是整个结果集，表示为列表。结果集类型可以通过定义`RowMapper`策略进行更改，Spring提供了对其的支持：
- en: '[PRE63]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This configuration will connect to the database configured in the datasource.
    In our case, it's an in-memory database, that is, H2\. It will execute the query
    and issue an update. The result will be put on the configured channel. The update
    query is very handy when we want to filter out already processed records in the
    next polling cycle.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将连接到数据源中配置的数据库。在我们的情况下，这是一个内存数据库，即H2。它将执行查询并发出更新。结果将放在配置的通道上。当我们想要在下一个轮询周期中过滤掉已处理的记录时，更新查询非常方便。
- en: Transaction support
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事务支持
- en: 'Transaction support for the inbound adapter can be wrapped along with the poller:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 入站适配器的事务支持可以与轮询器一起包装：
- en: '[PRE65]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'With transaction as a sub-element of poller, query and update will be executed
    in the same transaction. A valid transaction manager should be defined; again
    it''s nothing specific to Spring Integration. Instead, spring-based entity manager
    and transaction manager should be defined (again, this is nothing to do with Spring
    Integration; instead, it''s standard spring database support stuff). The code
    is as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将事务作为轮询器的子元素，查询和更新将在同一个事务中执行。应该定义一个有效的事务管理器；这与Spring Integration无关。相反，应该定义基于Spring的实体管理器和事务管理器（同样，这与Spring
    Integration无关；而是标准的Spring数据库支持内容）。代码如下：
- en: '[PRE66]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Writing to the database – the outbound adapter
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入数据库 - 出站适配器
- en: 'The outbound adapter can be used to insert data in the database; it can use
    the message on the channel to construct the query and execute it. The following
    code will add the outbound adapter:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 出站适配器可用于向数据库中插入数据；它可以使用通道上的消息构造查询并执行它。以下代码将添加出站适配器：
- en: '[PRE67]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This extracts a value from the payload and writes the data in the database.
    The database to which data will be written depends on the datasource.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这从有效载荷中提取一个值，并将数据写入数据库。数据将被写入的数据库取决于数据源。
- en: Inbound and outbound gateways
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入站和出站网关
- en: 'Gateways combine input and output adapter functionalities; it fires a query
    and posts the reply on the reply channel:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 网关结合了输入和输出适配器的功能；它发出查询并将回复发布到回复通道上：
- en: '[PRE68]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Outbound gateways require a reference to the datasource that is used to decide
    the database to connect to.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 出站网关需要引用用于决定要连接的数据库的数据源。
- en: Stream processing
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流处理
- en: 'Spring Integration provides two implicit components for stream: one to read
    the streams and an other to write to streams. This section is small—let''s quickly
    get to the code!'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Integration为流提供了两个隐式组件：一个用于读取流，另一个用于写入流。这部分很小 - 让我们快速进入代码！
- en: Prerequisites
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'First, let''s add the namespaces and Maven dependencies:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加命名空间和Maven依赖项：
- en: 'Namespace support can be added using the following code:'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用以下代码添加命名空间支持：
- en: '[PRE69]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Maven dependencies can be added using the following code snippet:'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用以下代码片段添加Maven依赖项：
- en: '[PRE70]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: With the previous inclusion, we are ready to use the adapters.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的包含，我们已经准备好使用适配器了。
- en: Reading from a stream
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从流中读取
- en: 'There is a STDIN adapter provided by Spring Integration that reads from `stdin`.
    What is this `stdin`? Any stuff that is written to the command line, for example,
    `System.in` in Java. The following code snippet is used to add the STDIN adapter:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Integration提供了一个由Spring Integration提供的STDIN适配器，用于从`stdin`读取。这个`stdin`是什么？任何写入命令行的东西，例如Java中的`System.in`。以下代码片段用于添加STDIN适配器：
- en: '[PRE71]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here, `int-stream:stdin-channel-adapter` is the namespace support and channel
    where the adapter puts the messages that have been written to the console.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`int-stream:stdin-channel-adapter`是命名空间支持和通道，适配器将消息放在其中，这些消息已经写入控制台。
- en: 'If we want to get some insider view, spring uses either `ByteStreamReadingMessageSource`
    or `CharacterStreamReadingMessageSource`, which are implementations of `MessageSource`,
    to provide the adapter functionality. `ByteStreamReadingMessageSource` needs `InputStream`,
    while `CharacterStreamReadingMessageSource` needs `Reader`, as shown in the following
    code snippet:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一些内部视图，Spring使用`ByteStreamReadingMessageSource`或`CharacterStreamReadingMessageSource`，它们是`MessageSource`的实现，提供适配器功能。`ByteStreamReadingMessageSource`需要`InputStream`，而`CharacterStreamReadingMessageSource`需要`Reader`，如下面的代码片段所示：
- en: '[PRE72]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Writing to a stream
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入流
- en: 'A similar adapter for writing to the console is also provided by Spring: `stdout`.
    It prints to the console whatever message it gets on the channel. Let''s plug
    a `stdout` adapter to the preceding code and the output will be directed to the
    console:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Spring还提供了类似的用于向控制台写入的适配器：`stdout`。它会将收到的消息打印到控制台上。让我们将一个`stdout`适配器插入到前面的代码中，输出将被定向到控制台：
- en: '[PRE73]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`int-stream:stdout-channel-adapter` is the namespace, and channel is what the
    adapter will be polling for messages, and then print each on the console. `append-newline`
    will add a new line to output.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`int-stream:stdout-channel-adapter`是命名空间，通道是适配器将轮询消息的地方，然后在控制台上打印每条消息。`append-newline`将在输出中添加一个新行。'
- en: 'Behind the scenes, Spring uses either `ByteStreamWritingMessageHandler` or
    `CharacterStreamWritingMessageHandler`. They require a reference of `OutputStream`
    and `Writer`, respectively:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Spring使用`ByteStreamWritingMessageHandler`或`CharacterStreamWritingMessageHandler`。它们分别需要`OutputStream`和`Writer`的引用：
- en: '[PRE74]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This has been a long chapter and we all deserve a coffee break!
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很长的章节，我们都应该休息一下喝杯咖啡！
- en: Summary
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter showcased the simplicity and abstraction that Spring Integration
    provides when it comes to handling complicated integrations, be it file-based,
    HTTP, JMS, or any other integration mechanism. Do not panic; I promise that the
    next few chapters are going to be smaller, and we will cover the testability of
    Spring Integration, performance, management, and then wrap up with an end-to-end
    example. In the next chapter, we will cover how Spring Batch and Spring Integration
    can be integrated to leverage the best of each framework.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了Spring Integration在处理复杂集成时提供的简单性和抽象性，无论是基于文件、HTTP、JMS还是其他集成机制。不要惊慌；我保证接下来的几章会更简洁，我们将涵盖Spring
    Integration的可测试性、性能、管理，然后以端到端的示例结束。在下一章中，我们将介绍如何集成Spring Batch和Spring Integration以利用每个框架的优势。
