- en: Chapter 5. Learning Functional Programming – The Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。学习函数式编程-基础知识
- en: JavaScript is a multiparadigm language that is not perfect for any paradigm
    it touches, but it has interesting features for its main paradigms. It is an object-oriented
    language, although the definition of object-oriented varies between object-oriented
    languages. It has been suggested that its prototypal inheritance may be less significant
    for object-oriented programming than a demonstration of how to create class-free
    objects instead of fumbling at the difficult task of getting the taxonomy right
    from the beginning. The definition of object-oriented also varies between multiparadigm
    languages with object-oriented features. For example, Python dynamically allows
    members to be added to existing objects, while Java requires members to be defined
    in a class. The object-oriented characteristics of JavaScript are useful and interesting,
    but especially in the past few years, they have been a source of frustration to
    programmers of other object-oriented languages, who have been told that JavaScript
    is object-oriented without sufficient information on how JavaScript is object
    oriented through an approach that differs profoundly from other major languages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种多范式语言，对于它触及的任何范式都不完美，但它具有其主要范式的有趣特性。它是一种面向对象的语言，尽管面向对象的定义在面向对象的语言之间有所不同。有人建议，它的原型继承对于面向对象编程可能不如演示如何创建无类对象重要，而不是在开始时就把分类搞对的困难任务。面向对象的定义在具有面向对象特性的多范式语言之间也有所不同。例如，Python动态允许向现有对象添加成员，而Java要求在类中定义成员。JavaScript的面向对象特性是有用和有趣的，但特别是在过去几年里，它们一直是其他面向对象语言的程序员的挫折之源，他们被告知JavaScript是面向对象的，但没有足够的信息来解释JavaScript如何通过与其他主要语言根本不同的方法来实现面向对象。
- en: Likewise, for functional programming, JavaScript has functional programming
    support, or at least some of it. But like JavaScript as a whole, functional JavaScript
    is not 100 percent in line with the *The Good Parts*. One common, although not
    universal, feature of functional programming languages is tail call optimization,
    which says that recursive functions that only recur at the end are internally
    converted into a more commonplace style of loop that is faster and can go very
    deep without exhausting its quota of call stack space. This optimization is slated
    for ECMAScript 6, but at the time of writing this book, it has not been implemented
    in common browsers, which provide not only slower performance but also a limit
    of around 10,000 to 20,000 calls deep in recursion.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于函数式编程，JavaScript具有函数式编程支持，或者至少有一些支持。但是像整个JavaScript一样，函数式JavaScript并不完全符合*好的部分*。函数式编程语言的一个普遍特征（虽然不是普遍的）是尾调用优化，它表示只在末尾递归的递归函数在内部被转换为更常见的循环样式，速度更快，并且可以在不耗尽调用堆栈空间的情况下进行非常深的递归。这种优化计划在ECMAScript
    6中实施，但在撰写本书时，它尚未在常见浏览器中实施，这不仅提供了较慢的性能，还限制了递归深度在大约10,000到20,000次之间。
- en: There's a lot that can be done within this limit, but structured program writers
    would not be happy if their `for` loop was not implemented to go much beyond 20,000
    iterations. The point here is not to specify which solution is best for JavaScript
    not always supporting tail call optimization, but to indicate that this difficulty
    is presently here, and this is one of the few ways in which JavaScript does not
    directly support standard functional language features (summing all integers from
    1 to 1,000,000 or higher is especially not interesting to do, but it serves as
    a standard example in tutorials).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个限制内可以做很多事情，但是结构化程序编写者如果他们的`for`循环不能实现远远超过20,000次的迭代，就会感到不满。这里的重点不是指定JavaScript不总是支持尾调用优化的最佳解决方案，而是指出这个困难目前存在，并且这是JavaScript不直接支持标准函数语言特性的少数几种方式之一（例如，计算从1加到1,000,000或更高的所有整数并不是特别有趣，但它在教程中作为标准示例）。
- en: 'Literature is divided over whether or not JavaScript should be called a functional
    language; it is certainly not a pure functional language as Haskell is (but then,
    neither is OCaml). JavaScript has been called after a known functional language—Scheme
    in C''s clothing—and its basic functional features are not something tacked on
    after the fact. Perhaps this may reflect his preferences, but Douglas Crockford,
    who is willing to be both critical and picky in his judgments of what parts of
    the JavaScript language are good ideas, has never that I have seen picked functional
    aspects present in JavaScript for targets of a scathing critique. In his move
    from *JavaScript: The Good Parts* to *The Better Parts*, one of his preferences
    given ECMAScript 6 is to stop using `for` and `while` loops in an imperative style,
    and use recursion that takes advantage of tail call optimization, which is to
    be included. Maybe the strongest claim that JavaScript has a functional heart
    can be seen in the question of what feature in a language is central. It has been
    suggested that in Java, the central feature is objects. In C, it is pointers.
    In JavaScript, it is functions.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JavaScript是否应该被称为函数式语言，文献意见不一；它肯定不是像Haskell那样的纯函数式语言（但OCaml也不是）。JavaScript被称为一种已知函数式语言Scheme的C语言版本，并且它的基本函数式特性并不是事后添加的东西。也许这反映了他的偏好，但是道格拉斯·克罗克福德在评判JavaScript语言的哪些部分是好主意时，从*JavaScript：好的部分*到*更好的部分*，他从ECMAScript
    6开始的偏好之一是停止使用命令式风格的`for`和`while`循环，而是使用利用尾调用优化的递归。也许JavaScript具有函数式内核的最有力的主张可以在语言的哪个特性是中心的问题上看出来。有人建议，在Java中，中心特性是对象。在C中，是指针。在JavaScript中，是函数。
- en: JavaScript's functions have first-class status, meaning among other things that
    (higher order) functions can act on other functions and be passed as arguments,
    or even be dynamically constructed and returned as a result.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的函数具有一流的地位，这意味着（高阶）函数可以作用于其他函数并作为参数传递，甚至可以动态构建并作为结果返回。
- en: 'In this chapter, we will be covering:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Custom sort functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义排序函数
- en: Map, reduce, and filter
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射、减少和过滤
- en: Fool's gold – altering the behavior of other people's prototypes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 愚人的金子-改变其他人原型的行为
- en: Closures and information hiding
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包和信息隐藏
- en: Custom sort functions – the first example of functional JavaScript and first-class
    functions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义排序函数-函数式JavaScript和一级函数的第一个示例
- en: 'To break the ice, let''s look at sorting JavaScript''s arrays. JavaScript''s
    arrays have a built-in `sort()` function, which is, at the very least, a sensible
    default. If, for instance, we create an array with the first six digits of π,
    we can sort it:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打破僵局，让我们来看看如何对JavaScript的数组进行排序。JavaScript的数组有一个内置的`sort()`函数，至少可以说是一个合理的默认值。例如，如果我们创建一个包含π的前六位数字的数组，我们可以对其进行排序：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Chrome''s debugger shows an array on the console, which we can access:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome的调试器在控制台上显示了一个数组，我们可以访问：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is well and good. Let''s stretch things a little further and try mixing
    integers and floating-point decimals (floats). Note that in JavaScript, there
    is one numeric type that acts like an integer (and remains integer clean) for
    the integers between (in Firefox) -(253 - 1), or -9007199254740991, and 253 –
    1, or 9007199254740991\. This numeric type also stores floating-point numbers.
    These have a greater range and, of course, more fine-grained values for smaller
    numbers. To stretch things further, let''s have an array with integers and floats
    mixed together:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好。让我们再进一步，尝试混合整数和浮点小数（浮点数）。请注意，在JavaScript中，有一种数值类型，它的行为类似于整数（并保持整洁）对于在Firefox中介于-(253-1)或-9007199254740991和253-1或9007199254740991之间的整数。这种数值类型也存储浮点数。它们具有更大的范围，当然，对于较小的数字，有更精细的值。为了进一步扩展范围，让我们创建一个包含整数和浮点数混合的数组：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Among these numbers, `Math.PI` is around 3.14, `Math.E` is around 2.72, `Math.sqrt(2)`
    is around 1.41, `Math.sqrt(3)` is around 1.73, and `Math.sqrt(5)` is around 2.24\.
    Let''s sort this like the other array and log the values:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些数字中，`Math.PI`大约是3.14，`Math.E`大约是2.72，`Math.sqrt(2)`大约是1.41，`Math.sqrt(3)`大约是1.73，`Math.sqrt(5)`大约是2.24。让我们像其他数组一样对其进行排序并记录这些值：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Chrome's debugger, for some reason, behaved differently this time, displaying
    all of the array in a string rather than an array with a drill-down triangle to
    the left. However, the array is sorted correctly, with all the values in ascending
    order and integers and floating-point values displayed correctly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome的调试器，出于某种原因，这次表现不同，显示的是一个字符串数组，而不是一个带有向左的下钻三角形的数组。然而，数组被正确排序，所有值都按升序排列，整数和浮点值显示正确。
- en: 'Let''s try this out on strings. Suppose we have the following array:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在字符串上试一试。假设我们有以下数组：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we sort it, we get this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对其进行排序时，得到了这个：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is in order, and good. Let''s add a bit in the middle of the array:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有序的，很好。让我们在数组中间添加一点内容：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We sort it and get back the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对其进行排序，得到了以下结果：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What is this? All the new words are at the beginning, and all the old words
    are at the end! Sorted among themselves perhaps, but segregated by capitalization.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么？所有新单词都在开头，所有旧单词都在结尾！也许在它们自己之间排序，但是由大小写分隔。
- en: The reason for this is that string sorting is the dictionary order by Unicode
    values, which is the same as ASCII encoding for characters that are part of ASCII.
    In ASCII, all uppercase letters come before all lowercase letters. Here, uppercase
    letters are sorted correctly within uppercase and lowercase letters are sorted
    correctly within lowercase, but both of these are segregated. If we want all of
    the `A` to come before all the `B`, we need to be more specific about what we
    want.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为字符串排序是根据Unicode值的字典顺序，这与ASCII编码相同，对于ASCII的一部分字符。在ASCII中，所有大写字母都排在所有小写字母之前。在这里，大写字母在大写字母内部被正确排序，小写字母在小写字母内部被正确排序，但这两者是分开的。如果我们希望所有的'A'都排在所有的'B'之前，我们需要更具体地说明我们想要什么。
- en: 'One way we can do this is by providing a comparator function—something that
    will compare two elements and tell `Array.sort()` which one should go first. Let''s
    make a case-insensitive sort just for these words:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提供一个比较函数来实现这一点-一个将比较两个元素并告诉`Array.sort()`哪个应该先的函数。让我们为这些单词制作一个不区分大小写的排序：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then we sort the array and specify the comparing function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们对数组进行排序并指定比较函数：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we log the sorted array, we see a case-insensitive alphabetical order:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们记录排序后的数组时，我们看到了一个不区分大小写的字母顺序：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What if we want capitalization to serve as a tiebreaker and an uppercase character
    will be placed before its lowercase equivalent? This is a straightforward modification
    of our comparator:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望大写字母作为一个决定因素，并且大写字母会在其小写字母等价物之前放置，该怎么办？这是我们比较器的一个简单修改：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s add `''ALPHA''` and `''alpha''` to the end of our list of strings and
    re-sort:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在字符串列表的末尾添加'ALPHA'和'alpha'，然后重新排序：
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It works!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！
- en: 'This may or may not be needed with mere string comparisons, but what if the
    server has run a database query and packaged the results in JSON for us? The result,
    once parsed on the client, will probably be an array of objects that have the
    same structure. Electronic customer contact information might include the following,
    among other things:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要，也可能不需要仅仅是字符串比较，但是如果服务器运行了数据库查询并为我们打包了JSON结果呢？一旦在客户端解析，结果可能是具有相同结构的对象数组。电子客户联系信息可能包括以下内容：
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This record structure may not be one that JavaScript innately infers how we
    would like to see it sorted, but this does not really hurt us. If we build a comparator
    function, it has full access to fields or other details of both the items that
    it is asked to compare. This means that we can compare one field, then another,
    and then a third. It also means that we can compare by different criteria if we
    want to; at one point, we could compare by name, and another point we might compare
    by geographical location. If our server stores (or looks up) GPS coordinates for
    addresses, we can search by who is closest to a particular location.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种记录结构可能不是JavaScript本能地推断出我们希望看到的排序方式，但这并不真正伤害我们。如果我们构建一个比较函数，它可以完全访问要比较的项目的字段或其他细节。这意味着我们可以先比较一个字段，然后再比较另一个字段，然后再比较第三个字段。这也意味着我们可以按不同的标准进行比较；在某个时候，我们可以按名称比较，而在另一个时候，我们可以按地理位置比较。如果我们的服务器存储（或查找）地址的GPS坐标，我们可以按离特定位置最近的人进行搜索。
- en: This leads us to array.filter()
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这引出了数组.filter()
- en: In functional languages, features such as map, reduce, and filter are staples
    of everyday use. They operate on lists, which in more functional, list-centric
    languages may be finite or infinite. In this sense, a list may be more like a
    JavaScript array or a generator, a kind of function that, instead of returning
    a single value, yields zero or more values and may theoretically yield an infinite
    number of values. Unlike an array, there is no finite point where any given generator
    may be exhausted, even though one never actually produces an infinite number of
    values. Generators are a wonderful feature, but they are dodgily supported in
    browsers at the time of writing this book, which means that our use of map, reduce,
    and filter will more likely be on (finite) arrays than on generators.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式语言中，诸如映射、减少和过滤等功能是日常使用的基本功能。它们操作列表，在更多功能性、以列表为中心的语言中，列表可以是有限的，也可以是无限的。在这个意义上，列表可能更像JavaScript数组或生成器，一种函数，它不是返回单个值，而是产生零个或多个值，并且在理论上可能产生无限数量的值。与数组不同，任何给定的生成器可能永远不会耗尽，即使它实际上从不产生无限数量的值。生成器是一个很棒的功能，但在撰写本书时，它们在浏览器中的支持并不稳定，这意味着我们更可能在（有限的）数组上而不是在生成器上使用映射、减少和过滤。
- en: 'But before we drop the topic of generators, let''s give two examples of generators,
    both of which will overflow before too long, but both of which serve as examples
    of what, in a language like Haskell, might be considered an infinite list with
    all the members of a mathematical series, as opposed to an array containing only
    and exactly the first *n* members. We will look at generators for powers of 2
    and Fibonacci numbers, using the ECMA6-proposed syntax for generators, as discussed
    at [http://wiki.ecmascript.org/doku.php?id=harmony:generators](http://wiki.ecmascript.org/doku.php?id=harmony:generators):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们放弃生成器这个话题之前，让我们给出两个生成器的例子，这两个例子都会在不久之后溢出，但它们都是在像Haskell这样的语言中可能被认为是一个数学序列的无限列表的例子，而不是仅包含第一个*n*成员的数组。我们将使用ECMA6提议的生成器语法来查看2的幂和斐波那契数的生成器，如[http://wiki.ecmascript.org/doku.php?id=harmony:generators](http://wiki.ecmascript.org/doku.php?id=harmony:generators)中所讨论的：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Contrast these examples with generators with standard, recursive approaches
    to compute the nth power of 2 (this is not really needed, because JavaScript''s
    arithmetic handles exponents, but is included for the sake of completeness), and
    a naïve implementation of computing the nth Fibonacci number. Both are what is
    called tail recursive, and would stand to benefit from tail call optimization
    if and when such a thing is made available from browsers:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些示例与使用标准递归方法计算2的n次幂（这实际上并不需要，因为JavaScript的算术处理指数，但为了完整起见，还包括了这一点）以及计算第n个斐波那契数的天真实现进行对比。这两种方法都是所谓的尾递归，并且如果浏览器提供了尾调用优化，它们将受益匪浅：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Both of these functions assume a nonnegative integer as the argument. The second
    function also has terrible performance characteristics, even though memory usage
    is not particularly bad. However, the number of function calls is comparable to
    the value returned, so calculating the 100th Fibonacci number, besides any concerns
    about integer overflow, could take longer than the age of the Universe. As Donald
    Knuth said, "Premature optimization is the root of all evil," but this is one
    case where optimization is not premature.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都假设参数为非负整数。第二个函数的性能特征也很糟糕，尽管内存使用并不特别糟糕。然而，函数调用的次数与返回的值相当，因此计算第100个斐波那契数，除了整数溢出的问题，可能比宇宙的年龄还要长。正如Donald
    Knuth所说，“过早的优化是万恶之源”，但这是一个不需要过早优化的情况。
- en: 'Note that another feature of functional programming, called **memoization**—which
    means retaining the results of the intermediate calculations, instead of repeatedly
    regenerating them from scratch—avoids this performance bottleneck altogether.
    Consider the following memoization of the recursive Fibonacci function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意函数式编程的另一个特性，称为**记忆化**——这意味着保留中间计算的结果，而不是反复从头开始重新生成它们，从而完全避免了性能瓶颈。考虑下面递归斐波那契函数的记忆化：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Illusionism, map, reduce, and filter
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 幻觉主义，映射，减少和过滤
- en: As a child, I was very interested in illusionism, and I still have an illusionist's
    set—which has (or had) things such as a fake thumb and a trick cup—and books on
    illusions. One of the tricks I remember was putting a rope around one's thighs
    and looping around the hands. The rope appears tight if one's legs are relaxed,
    but much looser if one lifts one's legs a bit, thus giving the impression that
    one is tied securely, while it is straightforward to free one or both hands.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我小时候，我对幻术非常感兴趣，我现在还有一个幻术师的道具——里面有（或曾经有）一些东西，比如一个假拇指和一个戏法杯——还有一些幻术书。我记得的一个戏法是把一根绳子绕在大腿上，然后再绕在手上。如果一个人的腿放松，绳子看起来很紧，但如果一个人抬起腿，绳子就松了很多，从而给人一种被牢牢捆绑的印象，而实际上很容易解开一个或两个手。
- en: I was never too good at the showmanship aspect of amateur illusionism, which
    is really the core of the craft. Senior illusionists, when advising their juniors
    or aspirants, are apt to say things such as, "Entertain the audience and deceive
    them, but know which comes first." And I remember for a long time thinking that
    I did not know (the technical side of) real illusionism, because I knew technically
    how to do several tricks, but I did not see how one would approach doing the things
    I saw.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我从来不擅长业余魔术表演的一面，这实际上是这门手艺的核心。资深的魔术师在指导他们的后辈或有抱负的人时，往往会说诸如“取悦观众并欺骗他们，但要知道哪个先来”。我记得很长一段时间以来，我一直认为我不懂（技术方面的）真正的魔术，因为我技术上知道如何做几个戏法，但我不知道如何去做我看到的那些事情。
- en: Much later, there was an illusionist at my company's party, and I was fascinated
    for an unusual reason. He did some tricks that were novel to me, but for about
    70 percent or 80 percent of the time, he spent making significant mileage out
    of the rope tricks I learned as a kid. And it worked very well. He had exquisite
    showmanship, and my fascination was not about wondering how he technically pulled
    off the trick, but at such an adept entertainer who could take two tricks that
    a child could do and mine them for amusement value.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，在我公司的派对上有一个魔术师，我因为一个不寻常的原因而着迷。他做了一些对我来说新奇的戏法，但在大约70％或80％的时间里，他花了很多精力利用我小时候学到的绳索戏法。而且效果非常好。他有精湛的表演技巧，而我的着迷并不是想知道他是如何技术上完成这个戏法的，而是对这样一个擅长的表演者能够利用一个孩子都能做的两个戏法来取悦观众感到惊叹。
- en: Map, reduce, and filter (here, "reduce" includes both the right and left folds)
    are somewhat like this for functional programming. Map takes it and applies it
    to all members of a list. Reduce takes an operation and, starting from the right
    or left, applies it to every member with an intermediate result. Filter takes
    a function and a list and creates a new list consisting of exactly those items
    for which the function is true. These concepts will be explained and further illustrated
    in this chapter. Map, reduce, and filter aren't particularly difficult concepts,
    but there's a lot of mileage to get out of them. Let's look at map, reduce, and
    filter for arrays, bracketing the question of generators and the potentially infinite
    lists offered by languages such as Haskell. We will show you how to use JavaScript's
    array built-in versions of map, reduce, and filter. We will also take a look at
    the use of core JavaScript to implement these functions, not so much so that people
    can have IE8-compatible (and earlier) access to these functions, but to give a
    sense of how these things work.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Map，reduce和filter（这里，“reduce”包括右折叠和左折叠）在函数式编程中有些类似。Map接受并将其应用于列表的所有成员。Reduce接受一个操作，并从右侧或左侧开始，将其应用于每个成员，并得到一个中间结果。Filter接受一个函数和一个列表，并创建一个由函数为真的项目组成的新列表。这些概念将在本章中进行进一步解释和说明。Map，reduce和filter并不是特别困难的概念，但是可以从中获得很多收益。让我们来看看数组的map，reduce和filter，暂时不考虑生成器和Haskell等语言提供的潜在无限列表。我们将向您展示如何使用JavaScript的数组内置版本的map，reduce和filter。我们还将研究使用核心JavaScript来实现这些函数，不是为了让人们可以在IE8（及更早版本）中使用这些函数，而是为了让人们了解这些功能的工作原理。
- en: The implementations that we will explore, after a warning about fool's gold,
    have a somewhat nonfunctional style of implementation. They use `for` loops where,
    in a purely functional language, the solution of choice would probably be a tail
    recursive implementation. The rationale for this choice is the goal of providing
    functional feature support in a way that operates optimally for JavaScript's plumbing
    and doesn't fail in the rare cases where (non-tail-call-optimized) JavaScript
    recursion runs into its limits.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在警告了愚人金之后，我们将探讨一种有点非函数式风格的实现。它们使用`for`循环，在纯函数式语言中，首选的解决方案可能是尾递归实现。选择这种方式的理由是为了以一种对JavaScript的管道操作效果最佳的方式提供函数式特性支持，并且不会在（非尾调用优化的）JavaScript递归在极少数情况下达到极限时失败。
- en: Fool's gold – extending Array.prototype
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 愚人金 - 扩展Array.prototype
- en: A note of caution is due. An attractive solution, and one that can be easily
    implemented, is to extend (here) `Array.prototype` or the prototypes of other
    objects used by others, including `Object.prototype`. Don't do it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，一个吸引人的解决方案，而且可以很容易地实现，是扩展（这里）`Array.prototype`或其他对象的原型，包括`Object.prototype`。不要这样做。
- en: Among other things, extending `Array.prototype` and its kin destabilizes the
    playing field for other people's software; it's like rewriting other people's
    code when you haven't seen it. Probably, the best use case for extending basic
    prototypes is polyfills (reimplementation of a functionality that is not available
    in the current environment, using the available features), but even then, if there
    are competing polyfills, only one of them can win. Now it is unlikely that your
    polyfill will have the same testing for bug-for-bug compatibility as a major browser
    manufacturer. This leaves the door open to subtle bugs. In our case, in the interest
    of supporting sparse matrices, we ignore undefined entries, but not null. I submit
    that this is reasonable in context, but far from the only conceivable way someone
    smart (or not-so-smart) would frame the matter. JavaScript has two null values,
    `null` and `undefined`, and there is potential for more than one opinion about
    how these two distinct null values should be handled. What if the semantics that
    makes sense to us isn't the semantics that was evident to someone else? Do we
    want to open the door to slippery heisenbugs?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展`Array.prototype`及其相关内容会破坏其他人软件的平衡；这就好像在没有看到其他人的代码的情况下重写其他人的代码。扩展基本原型的最佳用例可能是填充（使用可用功能重新实现当前环境中不可用的功能），但即使在这种情况下，如果存在竞争的填充，也只有一个可以胜出。现在，你的填充不太可能像主要浏览器制造商一样对错误兼容性进行测试。这为微妙的错误留下了空间。在我们的情况下，为了支持稀疏矩阵，我们忽略了未定义的条目，但不是null。我认为在这种情况下这是合理的，但远非唯一可能的智者（或不那么聪明的人）会如何处理这个问题。JavaScript有两个null值，`null`和`undefined`，对于这两个不同的null值应该如何处理，可能会有不止一个观点。如果对我们有意义的语义并不是对其他人明显的语义，我们想要打开滑动的heisenbugs之门吗？
- en: 'There is an alternative that is straightforward and good: make your own functions,
    preferably anonymous functions defined within a closure, and stored in a variable.
    These functions can, if desired, check whether there is a browser''s built-in
    function, such as `Array.prototype.map()`, and fall back to the built-in function
    if it is found. It can do for our code almost any job accomplished by extending
    `Array.prototype`. But it shows good habits and that doesn''t yank the rug from
    under anyone else''s feet.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个简单而好的替代方案：编写自己的函数，最好是在闭包内定义的匿名函数，并存储在一个变量中。如果需要，这些函数可以检查是否存在浏览器的内置函数，比如`Array.prototype.map()`，如果找到，则可以回退到内置函数。它几乎可以完成通过扩展`Array.prototype`实现的任何工作。但它展现了良好的习惯，不会给其他人带来困扰。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The term *anonymous function* in JavaScript does not exclude functions stored
    in named variables. It only means that they have been defined without a function
    name. In other words, they are defined like `function()`, `var foo = function()`,
    or other alternatives, but not a name between the function keyword and the opening
    parenthesis, that is, `function bar()`. Usually, we will be using anonymous functions,
    whether they are stored in a variable or not, but there is a debugging-related
    reason for which we might name a function even if we never use it: a debugger''s
    stack trace may be more informative in its way of mentioning functions if the
    functions are named, even if the names are never used. It does make sense, for
    this purpose, to write `var quux = function quux()`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的*匿名函数*一词并不排除存储在命名变量中的函数。它只是意味着它们是在没有函数名称的情况下定义的。换句话说，它们是这样定义的：`function()`、`var
    foo = function()`或其他替代方法，但不是在函数关键字和开括号之间有一个名称，即`function bar()`。通常，我们将使用匿名函数，无论它们是否存储在变量中，但是有一个与调试相关的原因，即使我们从不使用它，也可能会给函数命名：调试器的堆栈跟踪可能会更详细地提到函数，即使从未使用过这些名称。出于这个目的，写`var
    quux = function quux()`是有意义的。
- en: 'One aside about what we may be developing privately, off in a corner: an astonishing
    number of Unix utilities began life as private hacks to solve local problems for
    different people. Things that spread like wildfire are often not things that are
    engineered to spread like wildfire, such as the Web, JavaScript, and versions
    of PHP before 5.0\. In their first versions—perhaps this applies to the Web more
    than JavaScript—they did something specific and had people struggling to function
    in a more complete manner.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们可能在私下开发的事情，有一点需要注意：令人惊讶的是，许多Unix实用程序最初是作为解决不同人的本地问题的私人黑客行为而诞生的。像野火一样传播的东西通常不是被设计成像野火一样传播的东西，比如Web、JavaScript和5.0版本之前的PHP。在它们的第一个版本中，它们做了一些特定的事情，并让人们努力以更完整的方式运行。
- en: 'The statelessness of HTTP was a carefully chosen feature, but for that time,
    a good chunk of web programming was trying to support use cases where stateless
    HTTP was getting quite painful. There may be differences between a 5 MB HTML5
    key-value store and a 4096-byte cookie ceiling, but they present both more or
    less gracious accommodations in providing hooks for properly stateful behavior
    when the web''s HTTP is stateless: the web was built not to enable the dynamic
    content as it is the lion''s share of all web contents today. JavaScript has its
    strengths and weaknesses, and its weaknesses may be some of the worst of any wildly
    successful language, but the reason for its wide success and celebrity status
    is not its strengths or weaknesses. It succeeded because it was included in browsers
    at a time when the Web was spreading like wildfire. Both JavaScript and the Web
    had people trying to fix their limitations and weaknesses to do many things well
    after they had spread like wildfire when they actually did only one thing well.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP的无状态性是一个精心选择的特性，但在那个时候，大部分的Web编程都在尝试支持无状态HTTP变得非常痛苦的用例。5 MB的HTML5键值存储和4096字节的cookie上限可能存在差异，但它们在提供适当的有状态行为的钩子时都提供了更或多或少优雅的容纳：Web是建立起来的，不是为了使动态内容成为今天所有Web内容的主要部分。JavaScript有它的优点和缺点，它的缺点可能是任何一个非常成功的语言中最糟糕的，但它之所以广受成功和名声显赫并不是因为它的优点或缺点。它成功是因为它在Web迅速传播的时候被包含在浏览器中。JavaScript和Web都有人试图修复它们的限制和缺点，以便在它们迅速传播后做好多种事情，而实际上它们只擅长做一件事。
- en: The mentality of "This is just something in a corner and we do not need to think
    about maintenance or interoperability" is very, very dangerous. Perhaps now your
    software will not break anything if it subtly redefines the behavior of an object
    or array, but not ever? Not even with any future decision? Not even if someone
    realizes that in solving X, you created a great engine for Y that could save a
    lot of work? Client-side JavaScript is some of the code that is most quickly made
    open source (after all, even lawyers concerned about keeping things proprietary
    know that your whole kaboodle can be delivered to anyone who logs in to your system
    from the Web), and it is dangerous to assume that a particular redefinition of
    standard behavior is simply future-proof.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: “这只是一个角落里的东西，我们不需要考虑维护或互操作性”这种心态非常非常危险。也许现在你的软件不会因为微妙地重新定义对象或数组的行为而破坏任何东西，但永远不会吗？甚至在未来的任何决定中？即使有人意识到，在解决X的同时，你为Y创造了一个可以节省大量工作的强大引擎？客户端JavaScript是一些最快成为开源的代码（毕竟，即使是关心保持专有内容的律师也知道你的整个系统可以交付给从Web登录到系统的任何人），假设某种标准行为的重新定义只是未来的保证是危险的。
- en: 'A short answer to the preceding questions is this: don''t redefine anything
    on which other people''s code is built, including redefining part of `Object.prototype`,
    `Array.prototype`, `Function.prototype`, and so on. Opt for your own implementation
    as far as it makes sense, but don''t (forcibly) install it for everybody.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对前面问题的一个简短回答是：不要重新定义其他人构建的任何东西，包括重新定义`Object.prototype`、`Array.prototype`、`Function.prototype`等部分。尽可能选择自己的实现，但不要（强制性地）为每个人安装它。
- en: Avoiding global pollution
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免全局污染
- en: It is also good practice to minimize incursions into the global namespace. The
    more global variables you add, the more easily you can conflict with other tooling.
    When Yahoo! announced YUI, as a matter of basic manners, they used only one global
    variable—YUI. There's a whole library that's available, but you don't have pages
    and pages of items dumped on the browser's global namespace; every call to YUI().use()
    or whatever is entirely contained in YUI's one incursion into the global namespace.
    jQuery uses a little more of the global namespace than they advertise, but in
    principle, they ask us only to use `jQuery` and `$`. Also, they try to make the
    second one wholly negotiable, as `jQuery` acknowledges that other frameworks need
    `$` and `jQuery` is intended to play nicely with others.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法也是尽量减少对全局命名空间的侵入。你添加的全局变量越多，就越容易与其他工具发生冲突。当雅虎宣布YUI时，基本礼貌上，他们只使用了一个全局变量——YUI。有一个完整的库可用，但你不会在浏览器的全局命名空间中看到一页页的项目；每次调用YUI().use()或其他内容都完全包含在YUI对全局命名空间的一个侵入中。jQuery使用的全局命名空间比他们宣传的要多一点，但原则上，他们只要求我们使用`jQuery`和`$`。此外，他们试图使第二个变量完全可协商，因为`jQuery`承认其他框架需要`$`，而`jQuery`旨在与其他框架友好相处。
- en: However, you can actually go further than this, by an immediately invoked function
    expression, including the ReactJS web application explored in [Chapters 8](ch08.html
    "Chapter 8. Demonstrating Functional Reactive Programming in JavaScript – A Live
    Example, Part I"), *Demonstrating Functional Reactive Programming in JavaScript
    – A Live Example* to [Chapter 11](ch11.html "Chapter 11. Demonstrating Functional
    Reactive Programming in JavaScript with a Live Example Part IV – Adding a Scratchpad
    and Putting It All Together"), *Demonstrating Functional Reactive Programming
    in JavaScript with a Live Example Part IV – Adding a Scratchpad and Putting It
    All Together*. The functionality that you can accomplish without making a single
    global variable is quite a lot. Perhaps libraries should have some global variable
    as a public face available for others, but it is perfectly possible to make a
    web application that doesn't touch global variables.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你实际上可以走得更远，通过立即调用的函数表达式，包括ReactJS Web应用程序在[第8章](ch08.html "第8章。在JavaScript中演示函数式响应式编程
    - 实时示例，第一部分")中探讨的，*在JavaScript中演示函数式响应式编程 - 实时示例*到[第11章](ch11.html "第11章。在JavaScript中演示函数式响应式编程
    - 实时示例第四部分 - 添加一个草稿并把它全部放在一起")，*在JavaScript中演示函数式响应式编程 - 实时示例第四部分 - 添加一个草稿并把它全部放在一起*。你可以在不触及全局变量的情况下实现相当多的功能。也许库应该有一些全局变量作为公共面向其他人的接口，但完全可以制作一个不触及全局变量的Web应用程序。
- en: The map, reduce, and filter toolbox – map
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: map、reduce和filter工具箱 - map
- en: 'A map takes an array and a function and returns a new array with the function
    applied to all of its elements. As an example, let''s create an array of the numbers
    1 to 10, and use map to create a new array with their squares. (Note that JavaScript
    is somewhat inconsistent about whether array options modify an array in-place,
    return a modified array, or do both. The array''s `map()`, `reduce()`, and `filter()`
    functions all create a new array, leaving the original array unchanged and untouched.):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 地图接受一个数组和一个函数，并返回一个将该函数应用于其所有元素的新数组。例如，让我们创建一个包含1到10的数字的数组，并使用地图创建一个新数组，其中包含它们的平方。（请注意，JavaScript在数组选项修改数组原地、返回修改后的数组或两者都做方面有些不一致。数组的`map()`、`reduce()`和`filter()`函数都创建一个新数组，保持原始数组不变和不受影响。）
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `squares` variable now holds, `[1, 4, 9, 16, 25, 36, 49, 84, 81, 100]`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`squares`变量现在包含`[1, 4, 9, 16, 25, 36, 49, 84, 81, 100]`。'
- en: 'One implementation of `map()` might be as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`的一个实现可能如下所示：'
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The reduce function
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少函数
- en: 'What the reduce function does is it takes an operation and progressively apply
    it to the elements in an array. You may have covered infinite (and finite) series
    in school, perhaps with symbols like this one:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 减少函数的作用是，它接受一个操作，并逐步将其应用于数组中的元素。你可能在学校学过无限（和有限）级数，也许有这样的符号：
- en: '![The reduce function](img/B04108_05_01.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![减少函数](img/B04108_05_01.jpg)'
- en: In this kind of operation, the uppercase sigma (**Σ**, which is roughly equivalent
    to "S" in the Greek alphabet) is used for sums, and less frequently, the uppercase
    pi (Π, which is roughly equivalent to "P" in the Greek alphabet) is used for products.
    Both of them repeatedly apply an arithmetic operator to a finite (or infinite)
    series of numbers, and they work on the same basic principle as `reduce()`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种操作中，大写希腊字母sigma（**Σ**，大致相当于希腊字母中的“S”）用于求和，较少地使用大写希腊字母pi（Π，大致相当于希腊字母中的“P”）用于乘积。它们都反复将算术运算符应用于一系列有限（或无限）的数字，并且它们按照与`reduce()`相同的基本原理工作。
- en: What this kind of notation says is, "For this series of numbers, what do we
    get if we add them together, that is, reduce them with the addition function,
    taking the first number and the second, calculating their sum, then adding it
    to the third number, and so on?"
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的符号所说的是，“对于这一系列数字，如果我们将它们相加，也就是说，用加法函数减少它们，取第一个数字和第二个数字，计算它们的和，然后将其添加到第三个数字，依此类推，我们会得到什么？”
- en: 'If we wish to add up the contents of an array, we can reduce it with an addition
    function (as a minor implementation detail, we do not use the bare `+` operator
    because we can''t directly pass an operator as a regular function):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望将数组的内容相加，我们可以使用加法函数来减少它（作为一个小的实现细节，我们不使用裸的`+`运算符，因为我们不能直接将运算符作为常规函数传递）。
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finite and infinite series taught in school are usually sums; we can use other
    series as well. For example, if we want to calculate 10!, we can reduce by multiplying
    instead of adding in terms of the function we supply:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在学校教授的有限和无限级数通常是和；我们也可以使用其他级数。例如，如果我们想计算10!，我们可以通过乘法而不是加法来减少我们提供的函数的项：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Reduction does not need to be mathematical in character; this just gives us
    a quick way to demonstrate it. We can also use reduce to concatenate arrays of
    strings, where the `+` operator serves the purpose of string concatenation rather
    than numerical addition:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 减少不需要是数学性质的；这只是给我们一个快速演示它的方法。我们还可以使用reduce来连接字符串数组，其中`+`运算符用于字符串连接而不是数值相加：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, there is a basic difficulty that JavaScript''s built-in functions
    do not solve for us. We will sometimes need to make a choice and further specify
    what we really want. Numerical addition, multiplication, and string concatenation
    are all associative, which essentially means that you can put parentheses wherever
    you want, follow standard rules for parentheses, and get the same answer. In numerical
    addition, the following are equivalent:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JavaScript内置函数没有为我们解决的一个基本困难。有时我们需要做出选择，并进一步指定我们真正想要的是什么。数值相加、乘法和字符串连接都是可结合的，这基本上意味着你可以在任何地方放括号，遵循括号的标准规则，得到相同的答案。在数值相加中，以下是等价的：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Both of these calculations give `10`, and if we multiply instead of adding,
    both give us a product of `24`. But what happens if we use exponentiation for
    very slightly different values:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个计算都得到`10`，如果我们乘以而不是相加，两者都给出`24`的乘积。但是，如果我们对非常略微不同的值使用指数运算符会发生什么：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is the same sort of thing we have in the immediately preceding code, although
    admittedly with an uglier namespaced function instead of an infix operator. In
    non-JavaScript notation, using a caret (`^`), we get the following pseudo-JavaScript,
    which restates the preceding calculation:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们刚刚看到的代码是相同类型的东西，尽管显然使用了一个更丑陋的命名空间函数而不是中缀运算符。在非JavaScript符号中，使用一个脱字符（`^`），我们得到以下伪JavaScript，它重新陈述了前面的计算：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we use `console.log()` with the `Math.pow()` calculation that you just saw,
    we get this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`console.log()`和刚刚看到的`Math.pow()`计算，我们会得到这个：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There's a slight difference here. One result is a four-digit integer; the other
    is expressed in scientific notation with a lot more than four digits. Well, how
    many things are really like the special case of exponentiation?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个细微的差别。一个结果是一个四位整数；另一个用科学计数法表示，比四位数多得多。那么，有多少东西真的像指数运算的特殊情况？
- en: 'The answer to this question is a bit tricky, partly because of how I have deceptively
    framed the question to illustrate a treacherous misunderstanding. Exponentiation,
    where it matters how you add parentheses, can be more like the general case. There
    do exist cases where it doesn''t matter, and they might even more commonly be
    candidates for `reduce()`, but in the general case, we should not assume that
    the two are equivalent. We will give a `fold_left()` and `fold_right()` function;
    these are not the only two options (you can do things manually if neither of them
    is what you want), but they respectively calculate the sum of the array one to
    ten as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案有点棘手，部分原因是我欺骗性地构造了这个问题，以说明一个危险的误解。指数，括号的添加方式很重要，可能更像一般情况。存在一些情况，括号的位置并不重要，它们甚至更常见地成为`reduce()`的候选项，但在一般情况下，我们不应该假设这两者是等价的。我们将给出`fold_left()`和`fold_right()`函数；这不是唯一的两个选项（如果它们都不是你想要的，你可以手动操作），但它们分别计算数组一到十的和如下：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: One is not necessarily better than the other, but the difference can matter.
    JavaScript's built-in `reduce()` function is a left fold, starting from the left
    and moving to the right, as shown in the first of the two preceding expressions
    (and this is probably a sensible default).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 两者并不一定有优劣之分，但差异可能很重要。JavaScript内置的`reduce()`函数是一个左折叠，从左到右开始，如前两个表达式中所示（这可能是一个合理的默认值）。
- en: 'If we define `fold_left()` and `fold_right()`, it could look something like
    the following. I use abbreviations here where the full word spelled out would
    look too close to a reserved word; for example, array won''t collide with Array
    but they are confusingly close (there would be a similar collision with a variable
    named function):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定义`fold_left()`和`fold_right()`，它可能看起来像下面这样。我在这里使用了缩写，因为全拼看起来太接近保留字；例如，array不会与Array冲突，但它们之间有令人困惑的相似之处（如果变量命名为function，也会有类似的冲突）：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The last core tool – filter
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最后一个核心工具——过滤器
- en: 'Filter winnows through an array for values that meet some criterion. For example,
    we can filter only positive values, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器通过数组筛选出符合某些标准的值。例如，我们可以过滤出仅为正值的内容，如下所示：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `positive_and_negative` filter, after this run, is as declared; `positive_only`
    has the array value of `[1, 2, 3, 4]`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`positive_and_negative`过滤器，在此运行后，如声明的那样；`positive_only`的数组值为`[1, 2, 3, 4]`。'
- en: Filter is useful for narrowing down the contents of an array. If we have an
    array, as the preceding one, with the contact information of Mr. Smith, we can
    access fields to narrow down to things that may be of our interest. We can state
    that we want only one state, or require a phone number with a particular telephone
    area code, or state some other criterion on anything that a function can tell.
    If our record includes GPS coordinates, we can filter the contents to include
    only the results within a particular radius of a specific central point. All we
    need is a function that will return true for the records that we want to include
    and false for those that we don't.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤对于缩小数组的内容很有用。如果我们有一个数组，如前面的一个，包含了Smith先生的联系信息，我们可以访问字段，缩小到可能符合我们兴趣的内容。我们可以声明我们只想要一个州，或者需要一个特定电话区号的电话号码，或者对函数能够告诉的任何内容陈述其他标准。如果我们的记录包括GPS坐标，我们可以过滤内容，只包括特定中心点半径内的结果。我们只需要一个函数，对于我们想要包括的记录返回true，对于我们不想要的记录返回false。
- en: An overview of information hiding in JavaScript
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中信息隐藏的概述
- en: 'In general—meaning any programming language, client-side, server-side, non-web,
    mobile application, and almost anything else, perhaps even microcontrollers (which
    can now run a stripped-down Python)—there are different methodologies that generally
    have their own strengths and weaknesses. Steve McConnell''s *Code Complete: A
    Practical Handbook of Software Construction* ([http://tinyurl.com/reactjs-code-complete](http://tinyurl.com/reactjs-code-complete))
    discusses different methodologies and covers, for instance, how object-oriented
    programming''s sweet spot is with larger projects than are really procedural programming''s
    sweet spot. For most methodologies, his suggestion is that they have their strengths,
    weaknesses, and sweet spots, and under conditions X and Y, you should consider
    methodology Z. But there is one exception—information hiding. His simple advice
    on when to use information hiding is "As much as you can".'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说——意味着任何编程语言、客户端、服务器端、非网络、移动应用程序，几乎任何其他东西，甚至可能是微控制器（现在可以运行精简版的Python）——都有不同的方法论，通常都有各自的优势和劣势。Steve
    McConnell的《代码大全：软件构建的实用手册》（[http://tinyurl.com/reactjs-code-complete](http://tinyurl.com/reactjs-code-complete)）讨论了不同的方法论，比如，面向对象编程的优势在于比过程式编程更适合大型项目。对于大多数方法论，他的建议是它们都有各自的优势、劣势和适用范围，在X和Y条件下，你应该考虑方法论Z。但有一个例外——信息隐藏。他对何时使用信息隐藏的简单建议是“尽可能多地使用”。
- en: Procedural or structured programming is perhaps easy to overlook, and it's not
    pushing the envelope to use its strengths. But suppose we look at it when it first
    came out, with its functions/procedures, if-then-else, `for`/`while` loops, and
    procedure bodies not open to prying eyes. Now, if we compare this to straight
    assembler or machine code, with pre-Dijkstra-style use of gotos that do not even
    pretend to emulate structured control flow, then we understand that procedural
    or structured programming is really, really astounding. Also, it comes as a blinding
    flash of the obvious today because it has largely succeeded, to everyone's benefit.
    Flowcharts, which in the past were essential lifesavers for anybody hoping to
    understand a complex system, have become a novelty item. They appear on a mug,
    in an XKCD comic that shows how to deliver excellent tech support, or in other
    whimsical uses, as they are no longer needed to give any kind of road map to give
    some people—a sense of how to find their way through spaghetti.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 程序化或结构化编程可能很容易被忽视，使用其优势并不是在突破界限。但是假设我们看看它最初发布时的情况，它的函数/过程，if-then-else，`for`/`while`循环和过程体不对外开放。现在，如果我们将其与直接的汇编或机器代码进行比较，使用了Dijkstra风格的goto，甚至不假装模拟结构化控制流，那么我们就会明白，程序化或结构化编程真的是非常惊人的。此外，今天这显而易见的事实是因为它在很大程度上取得了成功，使每个人受益。流程图曾经是理解复杂系统的必备救生工具，现在已经成为一种新奇物品。它们出现在杯子上，在XKCD漫画中展示了如何提供出色的技术支持，或者在其他幽默的用途中，因为它们不再需要提供任何一种路线图来帮助一些人——找到他们穿过意大利面的方法。
- en: Now a large system may be vastly more complex, and vastly larger than would
    fit into the memory or disk of an old, flowcharted, goto-navigated program, but
    procedural programming has effectively exorcized that ghost. Also, newer iterations
    in software engineering paradigms, such as object-oriented programming, have cut
    down the difficulty of understanding large systems. And in both cases, much of
    the benefit is a practical way to advance information hiding. With structured
    programming, you can navigate through source code without having to keep track
    of every point where the assembler or machine language renders a jump (that is,
    a goto). Both structured and object-oriented programming have historically allowed
    developers to unprecedentedly treat more of the program as a set of closed black
    boxes, and you only need to open and inspect a small fraction of them. They deliver
    information hiding.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个大型系统可能比旧的、流程图导航的程序所能容纳的要复杂得多，也要大得多，但是程序化编程已经有效地驱逐了那个幽灵。此外，软件工程范式中的新迭代，如面向对象编程，已经减少了理解大型系统的难度。在这两种情况下，很大一部分好处是一种推进信息隐藏的实用方式。通过结构化编程，您可以在源代码中导航，而无需跟踪汇编或机器语言呈现跳转（即goto）的每个点。结构化和面向对象编程在历史上都允许开发人员前所未有地将更多的程序视为封闭的黑匣子，您只需要打开和检查其中的一小部分。它们提供了信息隐藏。
- en: '![An overview of information hiding in JavaScript](img/B04108_05_02.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![JavaScript中信息隐藏的概述](img/B04108_05_02.jpg)'
- en: The preceding flowchart is a novelty flowchart from [http://xkcd.com/627/](http://xkcd.com/627/).
    I've never seen a real flowchart for a program that someone and I were talking
    about.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的流程图是来自[http://xkcd.com/627/](http://xkcd.com/627/)的新奇流程图。我从未见过有人谈论的程序的真正流程图。
- en: 'A standard textbook example of information hiding, in classic Java, might be
    this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典的Java中，信息隐藏的标准教科书例子可能是这样的：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Uncharacteristic of a good example of live Java classes from production, this
    class has one private and four public members. The usual goal is to make the interesting
    heavy lifting as well hidden as possible and just present a simplified facade
    to the rest of the world. This is how Java''s object-oriented programming delivers
    information hiding, and even though there are important differences between object-oriented
    languages and how they approach and handle objects, this is one of Java''s strong
    suits. Not only are object methods supposed to be written procedurally—as black
    boxes that have defined inputs and outputs—but they are also encapsulated in objects,
    where multiple smaller black boxes can be subsumed under a larger black box. In
    this case, we see another benefit of information hiding: we are largely protected
    from the outside and free to make whatever internal changes we want without breaking
    outside usage, as long as we preserve the same behavior. Suppose we decide to
    keep a log of when the counter was changed and to what value. That''s at least
    another private field and changes to the internals of the methods that represent
    the public interface, but we can make the changes without altering any single
    detail of any class that accesses this class. Now suppose we want even more logging
    and we want our log to record a full-stack trace. Internally, we need to use something
    such as `Thread.currentThread.getStackTrace()`, but externally, no one needs to
    know or care about our refactoring. In a larger class, we might find a bottleneck
    that can be improved considerably by switching to another equivalent algorithm.
    Because of the way Java''s object-oriented programming delivers information hiding,
    we can make an awful lot of changes without disturbing other people, who can use
    our work without troubling themselves about anything other than our public interface.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与生产中的Java类的一个好例子不同，这个类有一个私有成员和四个公共成员。通常的目标是尽可能隐藏有趣的重要工作，并向世界展示一个简化的外观。这就是Java面向对象编程提供信息隐藏的方式，尽管面向对象语言之间在处理对象的方式和方法上有重要的区别，但这是Java的一大优势。对象方法不仅应该按过程方式编写——作为具有定义输入和输出的黑匣子——而且它们还封装在对象中，多个较小的黑匣子可以被包含在一个较大的黑匣子下。在这种情况下，我们看到了信息隐藏的另一个好处：我们在很大程度上受到外部保护，并且可以自由地进行任何内部更改，而不会破坏外部使用，只要我们保持相同的行为。假设我们决定保留计数器何时更改以及更改为何值的日志。这至少是另一个私有字段和对代表公共接口的方法的内部更改，但我们可以进行这些更改而不改变任何访问这个类的任何类的任何细节。现在假设我们想要更多的日志记录，我们希望我们的日志记录完整的堆栈跟踪。在内部，我们需要使用诸如`Thread.currentThread.getStackTrace()`这样的东西，但在外部，没有人需要知道或关心我们的重构。在一个更大的类中，我们可能会发现一个瓶颈，通过切换到另一个等效算法可以显著改进。由于Java面向对象编程提供信息隐藏的方式，我们可以进行大量的更改而不会打扰其他人，他们可以使用我们的工作而不必为除了我们的公共接口之外的任何事情而烦恼。
- en: Information hiding with JavaScript closures
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JavaScript闭包进行信息隐藏
- en: We need to look a little further to see the patterns of information hiding.
    In Java, you are quickly taught the language features for information hiding,
    and encouraged with words such as the security maxim—"Stinginess with privileges
    is kindness in disguise"—to err on the side of declaring things non-public. In
    JavaScript, there may be future-reserved words such as `public`, `private`, and
    `protected` (which Douglas Crockford suggested may be there for Java programmers
    to feel more at home with JavaScript at the expense of understanding JavaScript's
    better side), but there are not the same kind of obvious mechanisms now. All of
    an object's members, whether they are functions are not, are open for inspection.
    JSON—another thing that spread like wildfire, but without people cursing its simplicity—has
    no mechanism offered to mark anything as non-public.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要进一步观察信息隐藏的模式。在Java中，你会很快学到信息隐藏的语言特性，并且会被鼓励使用诸如“特权的吝啬是伪装下的善意”这样的安全最大化原则，以便在声明事物为非公开时出错。在JavaScript中，可能会有一些未来保留的关键词，比如`public`、`private`和`protected`（Douglas
    Crockford建议这些关键词可能是为了让Java程序员更容易理解JavaScript而牺牲了JavaScript更好的一面），但现在并没有同样明显的机制。对象的所有成员，无论是函数还是其他，都是公开的。JSON——另一种像野火一样传播开来的东西，但没有人因其简单而诅咒——没有提供任何标记任何东西为非公开的机制。
- en: 'However, there is a technique to create private fields in a feature of some
    functional languages called a closure. It isn''t exactly a technique that is simply
    present in the language to create information hiding, but it allows us to create
    objects with non-public information. To port the functionality of the preceding
    example, including the non-public state, we can have something shown as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在一些函数式语言的特性中有一种叫做闭包的技术，可以创建私有字段。这并不是一种简单存在于语言中的创建信息隐藏的技术，但它允许我们创建包含非公开信息的对象。为了移植前面的例子的功能，包括非公开状态，我们可以有如下所示的东西：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The example given here suggests how we might expand it. A more involved example
    could have more `var` functions storing fields and functions, and return a dictionary
    that would expose its public interface. But let's not simply jump for that; there
    are some interesting things along the way.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出的例子建议了我们如何扩展它。一个更复杂的例子可能有更多的`var`函数存储字段和函数，并返回一个将公共接口暴露出来的字典。但我们不要简单地跳到那一步；在这条路上有一些有趣的事情。
- en: 'In a functional language, functions can contain other functions. Indeed, given
    JavaScript''s syntax—where functions are first-class entities that can be stored
    in variables, passed as arguments, and so on—it would be surprising if functions
    could not be nested even two deep. So, the following syntax is legal:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式语言中，函数可以包含其他函数。事实上，鉴于JavaScript的语法——其中函数是第一类实体，可以存储在变量中，作为参数传递等等——如果函数不能嵌套甚至两层深，那将是令人惊讶的。因此，以下语法是合法的：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'But the same can legally be wrapped in a function, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但同样的东西可以合法地包装在一个函数中，如下所示：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It is a basic feature of functional languages, including JavaScript's heritage,
    that inner functions can see variables from outer functions; hence both `a` and
    `b` are equally available to the `inner` function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是功能语言的基本特性，包括JavaScript的传统，内部函数可以访问外部函数的变量；因此`a`和`b`对`inner`函数同样可用。
- en: 'Now what happens if we change the `outer` function to return the `inner` function?
    Then we have the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们将`outer`函数改为返回`inner`函数会发生什么？然后我们有以下内容：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: By the time the function finishes executing, its variables have fallen out of
    scope. JavaScript now has `var` variables with the function scope and is in the
    process of getting `let` variables with the block scope, but any variables declared
    in either way in the `outer` function are no longer available. However, something
    interesting has happened; the `inner` function has survived the end of the `outer`
    function, but in a logically consistent fashion. The `inner` function should and
    does have access to its execution context. We have a closure.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数执行完成时，它的变量已经超出了范围。JavaScript现在具有函数范围的`var`变量，并且正在过程中获得块范围的`let`变量，但是在`outer`函数中以任何方式声明的变量已不再可用。然而，有趣的事情发生了；`inner`函数在`outer`函数结束后仍然存在，但以一种逻辑一致的方式。`inner`函数应该并且确实可以访问它的执行上下文。我们有了一个闭包。
- en: This phenomenon can be used for information hiding, and information hiding is
    important. However, it may be argued that what is most interesting here is not
    that it can include non-public variables, potentially including functions, but
    that the execution context as a whole is maintained as long as something with
    access to it survives. This leaves an interesting territory to explore. A StackOverflow
    member once commented, "Objects are poor man's closures," and both objects and
    closures have interesting possibilities beyond the FAQ entry about how to use
    their features for information hiding. Even code complete, which may strongly
    endorse information hiding, never says, "Use information hiding as much as possible
    but nothing else."
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种现象可以用于信息隐藏，信息隐藏很重要。然而，可以争论的是这里最有趣的不是它可以包含非公共变量，潜在地包括函数，而是只要有东西可以访问它，执行上下文作为一个整体就会被保留下来。这留下了一个有趣的领域可以探索。一个StackOverflow成员曾评论说，“对象是穷人的闭包”，对象和闭包都有有趣的可能性，超出了关于如何使用它们的特性进行信息隐藏的FAQ条目。即使是《代码大全》，它可能会强烈支持信息隐藏，也从未说过，“尽可能使用信息隐藏，但不要使用其他东西。”
- en: Perhaps it would be harsh to blame functional language purists for saying, "JavaScript
    has to wait until it becomes 2 decades old before implementing tail call optimization,
    instead of punishing standard functional programming's use of recursion—as in,
    old enough to go from being a newborn infant to an adult under US laws." However,
    irrespective of anything else that may irk functional programmers about JavaScript,
    JavaScript did get closures right enough from the beginning, so much so that closures
    that retained the execution context were, and remain, a significant feature in
    JavaScript all the way along. And 2 decades later, they remain the primary, and
    possibly only, information hiding resource in most browsers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 也许责怪功能语言纯粹主义者说，“JavaScript必须等到它成为20年历史才能实现尾调用优化，而不是惩罚标准的函数式编程使用递归——就像美国法律下的一个新生儿成长为成年人一样。”然而，不管功能程序员对JavaScript可能感到不满的其他方面如何，JavaScript从一开始就足够正确地实现了闭包，以至于保留执行上下文的闭包在JavaScript中一直是一个重要的特性。而20年后，它们仍然是大多数浏览器中的主要，可能是唯一的信息隐藏资源。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we hit a few notes of functional programming in relation to
    JavaScript. We looked mainly at three topics. Custom sort functions provide a
    simple and useful glimpse at how we can pass a helper function to a higher order
    function to obtain more useful behavior than the default. Map, reduce, and filter
    are the three workhorses of functional programming with respect to arrays. With
    Closures and information hiding, we took a look at a functional way of providing
    some core interest in responsible software development.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涉及了JavaScript与功能编程的一些注解。我们主要关注了三个主题。自定义排序函数提供了一个简单而有用的窥视，我们如何将一个辅助函数传递给一个高阶函数，以获得比默认更有用的行为。Map、reduce和filter是与数组相关的功能编程的三个主要工具。通过闭包和信息隐藏，我们看了一种在负责任的软件开发中提供一些核心兴趣的功能方式。
- en: JavaScript is a multiparadigm language with functional roots and some functional
    language strengths, although it is perhaps uncommon for functional language purists
    to lump JavaScript together with imperative multiparadigm languages. JavaScript
    does not have, as some functional languages do, permanent binding on assignments
    or purely immutable data structures.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种具有功能根源和一些功能语言优势的多范式语言，尽管功能语言纯粹主义者将JavaScript与命令式多范式语言一起归类可能是不常见的。JavaScript没有像一些功能语言那样对赋值或纯不可变数据结构进行永久绑定。
- en: 'All languages have better and worse neighborhoods, but JavaScript so starkly
    combines excellent parts and terrible parts that the basic approach of Crockford''s
    *JavaScrpt: The Good Parts* and *The Better Parts* is not seriously questioned
    among good developers (I wonder why no one has yet sold Kernigan and Ritchie,
    *The C Programming Language*, Second Edition, as *C++: The Good Parts*). It would
    be provocative to the point of being obnoxious to argue that defaulting to dumping
    things on a global object is a good idea for developing web applications. This
    extends to the functional aspects of JavaScript as well. JavaScript was the first
    mainstream language to allow anonymous functions, or lambdas, which have been
    staples of functional programming roughly since LISP appeared over 50 years ago.
    Even if even Java has jumped into that bandwagon now, its presence in mainstream
    languages is from JavaScript''s influence. JavaScript has also had closures from
    the beginning. As far as some of the worse neighborhoods are concerned, it seems
    to have taken decades for JavaScript to apply tail call optimization, and with
    it, the functional programming style of using tail recursion without the penalty
    instead of for and `while` loops to structure iterative work.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '所有语言都有好坏不同的地方，但JavaScript将优秀的部分和糟糕的部分如此明显地结合在一起，以至于Crockford的《JavaScrpt: The
    Good Parts》和《The Better Parts》的基本方法在优秀的开发人员中没有受到严肃质疑（我想知道为什么还没有人将Kernigan和Ritchie的《C程序设计语言》第二版销售为《C++:
    The Good Parts》）。认为默认将事物倾倒在全局对象上是开发Web应用的好主意，这种观点可能会引起争议，甚至令人讨厌。这也适用于JavaScript的功能方面。JavaScript是第一种主流语言，允许使用匿名函数或lambda，这在函数式编程中已经成为基本要素，大约自LISP出现50多年以来。即使现在连Java也加入了这一潮流，但它在主流语言中的存在是受JavaScript的影响。JavaScript从一开始就有闭包。就一些糟糕的地方而言，JavaScript似乎花了几十年的时间才应用尾调用优化，以及使用尾递归而不受惩罚，而不是使用for和`while`循环来构建迭代工作的函数式编程风格。'
- en: Functional programming is an interesting topic and something that you can explore
    indefinitely (that is, the list of interesting aspects of functional programming
    that one can profitably explore is an infinite list, even though in the concrete,
    one only ever takes a finite number of items from the left of the list). Without
    trying to settle the question of whether JavaScript should be considered a functional
    language or not, JavaScript is best understood in relation to roots in functional
    programming, and learning to program better in functional languages/paradigms
    should be the basis of better programming in JavaScript. JavaScript may go down
    in history, not only as the language of the Web and perhaps the most crucial language
    for a programmer to know, but also the bridge language through which the goodness
    of functional languages ceased to be known as (like Scheme) "the best language
    you'll never use." Maybe, the strengths of a functional language come to be seen
    as non-negotiable for the construction of serious, mainstream multiparadigm languages.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是一个有趣的话题，你可以无限地探索（也就是说，函数式编程的有趣方面的列表是一个无限的列表，尽管在具体情况下，人们只能从列表的左边取出有限数量的项目）。在不试图解决JavaScript是否应该被视为函数式语言的问题的情况下，最好将JavaScript理解为与函数式编程根源相关，并且学习在函数式语言/范式中更好地编程应该是在JavaScript中更好编程的基础。JavaScript可能会载入历史，不仅作为Web的语言，也许是程序员必须了解的最关键的语言，还是功能性语言的优点不再被视为（如Scheme）“你永远不会使用的最好的语言”的桥梁语言。也许，功能性语言的优势会被视为严肃、主流的多范式语言构建的不可妥协的部分。
- en: Let's continue with a look at functional reactive programming.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看函数式响应式编程。
