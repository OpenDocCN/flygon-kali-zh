["```java\npublic class KnnClassifier {\n\n  private List <? extends Sample> dataSet;\n  private int k;\n\n  public KnnClassifier(List <? extends Sample> dataSet, int k) {\n    this.dataSet=dataSet;\n    this.k=k;\n  }\n```", "```java\n  public String classify (Sample example) {\n```", "```java\n    Distance[] distances=new Distance[dataSet.size()];\n\n    int index=0;\n\n    for (Sample localExample : dataSet) {\n      distances[index]=new Distance();\n      distances[index].setIndex(index);\n      distances[index].setDistance (EuclideanDistanceCalculator.calculate(localExample, example));\n      index++;\n    }\n```", "```java\n    Arrays.sort(distances);\n```", "```java\n    Map<String, Integer> results = new HashMap<>();\n    for (int i = 0; i < k; i++) {\n      Sample localExample = dataSet.get(distances[i].getIndex());\n      String tag = localExample.getTag();\n      results.merge(tag, 1, (a, b) -> a+b);\n    }\n    return Collections.max(results.entrySet(), Map.Entry.comparingByValue()).getKey();\n  }\n```", "```java\npublic class EuclideanDistanceCalculator {\n  public static double calculate (Sample example1, Sample example2) {\n    double ret=0.0d;\n\n    double[] data1=example1.getExample();\n    double[] data2=example2.getExample();\n\n    if (data1.length!=data2.length) {\n      throw new IllegalArgumentException (\"Vector doesn't have the same length\");\n    }\n\n    for (int i=0; i<data1.length; i++) {\n      ret+=Math.pow(data1[i]-data2[i], 2);\n    }\n    return Math.sqrt(ret);\n  }\n\n}\n```", "```java\npublic class KnnClassifierParallelIndividual {\n\n  private List<? extends Sample> dataSet;\n  private int k;\n  private ThreadPoolExecutor executor;\n  private int numThreads;\n  private boolean parallelSort;\n\n  public KnnClassifierParallelIndividual(List<? extends Sample> dataSet, int k, int factor, boolean parallelSort) {\n    this.dataSet=dataSet;\n    this.k=k;\n    numThreads=factor* (Runtime.getRuntime().availableProcessors());\n    executor=(ThreadPoolExecutor) Executors.newFixedThreadPool(numThreads);\n    this.parallelSort=parallelSort;\n  }\n```", "```java\n  public String classify (Sample example) throws Exception {\n\n    Distance[] distances=new Distance[dataSet.size()];\n    CountDownLatch endController=new CountDownLatch(dataSet.size());\n\n    int index=0;\n    for (Sample localExample : dataSet) {\n      IndividualDistanceTask task=new IndividualDistanceTask(distances, index, localExample, example, endController);\n      executor.execute(task);\n      index++;\n    }\n    endController.await();\n```", "```java\n    if (parallelSort) {\n      Arrays.parallelSort(distances);\n    } else {\n      Arrays.sort(distances);\n    }\n```", "```java\n  public void destroy() {\n    executor.shutdown();\n  }\n```", "```java\npublic class IndividualDistanceTask implements Runnable {\n\n  private Distance[] distances;\n  private int index;\n  private Sample localExample;\n  private Sample example;\n  private CountDownLatch endController;\n\n  public IndividualDistanceTask(Distance[] distances, int index, Sample localExample,\n      Sample example, CountDownLatch endController) {\n    this.distances=distances;\n    this.index=index;\n    this.localExample=localExample;\n    this.example=example;\n    this.endController=endController;\n  }\n```", "```java\n  public void run() {\n    distances[index] = new Distance();\n    distances[index].setIndex(index);\n    distances[index].setDistance (EuclideanDistanceCalculator.calculate(localExample, example));\n    endController.countDown();\n  }\n```", "```java\n  public String classify(Sample example) throws Exception {\n\n    Distance distances[] = new Distance[dataSet.size()];\n    CountDownLatch endController = new CountDownLatch(numThreads);\n\n    int length = dataSet.size() / numThreads;\n    int startIndex = 0, endIndex = length;\n\n    for (int i = 0; i < numThreads; i++) {\n      GroupDistanceTask task = new GroupDistanceTask(distances, startIndex, endIndex, dataSet, example, endController);\n      startIndex = endIndex;\n      if (i < numThreads - 2) {\n       endIndex = endIndex + length;\n      } else {\n       endIndex = dataSet.size();\n      }\n      executor.execute(task);\n\n    }\n    endController.await();\n```", "```java\npublic class GroupDistanceTask implements Runnable {\n  private Distance[] distances;\n  private int startIndex, endIndex;\n  private Sample example;\n  private List<? extends Sample> dataSet;\n  private CountDownLatch endController;\n\n  public GroupDistanceTask(Distance[] distances, int startIndex, int endIndex, List<? extends Sample> dataSet, Sample example, CountDownLatch endController) {\n    this.distances = distances;\n    this.startIndex = startIndex;\n    this.endIndex = endIndex;\n    this.example = example;\n    this.dataSet = dataSet;\n    this.endController = endController;\n  }\n```", "```java\n  public void run() {\n    for (int index = startIndex; index < endIndex; index++) {\n      Sample localExample=dataSet.get(index);\n      distances[index] = new Distance();\n      distances[index].setIndex(index);\n        distances[index].setDistance(EuclideanDistanceCalculator\n            .calculate(localExample, example));\n    }\n    endController.countDown();\n  }\n```", "```java\npublic abstract class Command {\n\n  protected String[] command;\n\n  public Command (String [] command) {\n    this.command=command;\n  }\n\n  public abstract String execute ();\n\n}\n```", "```java\n  public String execute() {\n    WDIDAO dao=WDIDAO.getDAO();\n\n    if (command.length==3) {\n      return dao.query(command[1], command[2]);\n    } else if (command.length==4) {\n      try {\n        return dao.query(command[1], command[2], Short.parseShort(command[3]));\n      } catch (Exception e) {\n        return \"ERROR;Bad Command\";\n      }\n    } else {\n      return \"ERROR;Bad Command\";\n    }\n  }\n```", "```java\n  @Override\n  public String execute() {\n\n    WDIDAO dao=WDIDAO.getDAO();\n    return dao.report(command[1]);\n  }\n```", "```java\n  @Override\n  public String execute() {\n    return \"Server stopped\";\n  }\n```", "```java\n  @Override\n  public String execute() {\n    return \"Unknown command: \"+command[0];\n  }\n```", "```java\npublic class SerialServer {\n\n  public static void main(String[] args) throws IOException {\n    WDIDAO dao = WDIDAO.getDAO();\n    boolean stopServer = false;\n    System.out.println(\"Initialization completed.\");\n\n    try (ServerSocket serverSocket = new ServerSocket(Constants.SERIAL_PORT)) {\n```", "```java\n  do {\n    try (Socket clientSocket = serverSocket.accept();\n      PrintWriter out = new PrintWriter (clientSocket.getOutputStream(), true);\n      BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));) {\n    String line = in.readLine();\n    Command command;\n\n    String[] commandData = line.split(\";\");\n    System.out.println(\"Command: \" + commandData[0]);\n    switch (commandData[0]) {\n    case \"q\":\n      System.out.println(\"Query\");\n      command = new QueryCommand(commandData);\n      break;\n    case \"r\":\n      System.out.println(\"Report\");\n      command = new ReportCommand(commandData);\n      break;\n    case \"z\":\n      System.out.println(\"Stop\");\n      command = new StopCommand(commandData);\n      stopServer = true;\n      break;\n    default:\n      System.out.println(\"Error\");\n      command = new ErrorCommand(commandData);\n    }\n    String response = command.execute();\n    System.out.println(response);\n    out.println(response);\n  } catch (IOException e) {\n    e.printStackTrace();\n  }\n} while (!stopServer);\n```", "```java\npublic class ConcurrentServer {\n\n  private static ThreadPoolExecutor executor;\n\n  private static ParallelCache cache;\n\n  private static ServerSocket serverSocket;\n\n  private static volatile boolean stopped = false;\n\n  public static void main(String[] args) {\n\n    serverSocket=null;\n    WDIDAO dao=WDIDAO.getDAO();\n    executor=(ThreadPoolExecutor) Executors.newFixedThreadPool (Runtime.getRuntime().availableProcessors());\n    cache=new ParallelCache();\n    Logger.initializeLog();\n\n    System.out.println(\"Initialization completed.\");\n```", "```java\n    serverSocket = new ServerSocket(Constants.CONCURRENT_PORT);\n```", "```java\n  do {\n    try {\n      Socket clientSocket = serverSocket.accept();\n      RequestTask task = new RequestTask(clientSocket);\n      executor.execute(task);\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  } while (!stopped);\n```", "```java\n  executor.awaitTermination(1, TimeUnit.DAYS);\n  System.out.println(\"Shutting down cache\");\n  cache.shutdown();\n  System.out.println(\"Cache ok\");\n\n  System.out.println(\"Main server thread ended\");\n```", "```java\n  public static void shutdown() {\n    stopped = true;\n    System.out.println(\"Shutting down the server...\");\n    System.out.println(\"Shutting down executor\");\n    executor.shutdown();\n    System.out.println(\"Executor ok\");\n    System.out.println(\"Closing socket\");\n    try {\n      serverSocket.close();\n      System.out.println(\"Socket ok\");\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    System.out.println(\"Shutting down logger\");\n    Logger.sendMessage(\"Shutting down the logger\");\n    Logger.shutdown();\n    System.out.println(\"Logger ok\");\n  }\n```", "```java\npublic class RequestTask implements Runnable {\n\n  private Socket clientSocket;\n\n  public RequestTask(Socket clientSocket) {\n    this.clientSocket = clientSocket;\n  }\n```", "```java\n  public void run() {\n\n    try (PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n      BufferedReader in = new BufferedReader(new InputStreamReader( clientSocket.getInputStream()));) {\n\n      String line = in.readLine();\n\n      Logger.sendMessage(line);\n      ParallelCache cache = ConcurrentServer.getCache();\n      String ret = cache.get(line);\n\n      if (ret == null) {\n        Command command;\n\n        String[] commandData = line.split(\";\");\n        System.out.println(\"Command: \" + commandData[0]);\n        switch (commandData[0]) {\n        case \"q\":\n          System.err.println(\"Query\");\n          command = new ConcurrentQueryCommand(commandData);\n          break;\n        case \"r\":\n          System.err.println(\"Report\");\n          command = new ConcurrentReportCommand(commandData);\n          break;\n        case \"s\":\n          System.err.println(\"Status\");\n          command = new ConcurrentStatusCommand(commandData);\n          break;\n        case \"z\":\n          System.err.println(\"Stop\");\n          command = new ConcurrentStopCommand(commandData);\n          break;\n        default:\n          System.err.println(\"Error\");\n          command = new ConcurrentErrorCommand(commandData);\n          break;\n        }\n        ret = command.execute();\n        if (command.isCacheable()) {\n          cache.put(line, ret);\n        }\n      } else {\n        Logger.sendMessage(\"Command \"+line+\" was found in the cache\");\n      }\n\n      System.out.println(ret);\n      out.println(ret);\n    } catch (Exception e) {\n      e.printStackTrace();\n    } finally {\n      try {\n        clientSocket.close();\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n```", "```java\n  @Override\n  public String execute() {\n    ConcurrentServer.shutdown();\n    return \"Server stopped\";\n  }\n```", "```java\npublic class ConcurrentStatusCommand extends Command {\n  public ConcurrentStatusCommand (String[] command) {\n    super(command);\n    setCacheable(false);\n  }\n  @Override\n  public String execute() {\n    StringBuilder sb=new StringBuilder();\n    ThreadPoolExecutor executor=ConcurrentServer.getExecutor();\n\n    sb.append(\"Server Status;\");\n    sb.append(\"Actived Threads: \");\n    sb.append(String.valueOf(executor.getActiveCount()));\n    sb.append(\";\");\n    sb.append(\"Maximum Pool Size: \");\n    sb.append(String.valueOf(executor.getMaximumPoolSize()));\n    sb.append(\";\");\n    sb.append(\"Core Pool Size: \");\n    sb.append(String.valueOf(executor.getCorePoolSize()));\n    sb.append(\";\");\n    sb.append(\"Pool Size: \");\n    sb.append(String.valueOf(executor.getPoolSize()));\n    sb.append(\";\");\n    sb.append(\"Largest Pool Size: \");\n    sb.append(String.valueOf(executor.getLargestPoolSize()));\n    sb.append(\";\");\n    sb.append(\"Completed Task Count: \");\n    sb.append(String.valueOf(executor.getCompletedTaskCount()));\n    sb.append(\";\");\n    sb.append(\"Task Count: \");\n    sb.append(String.valueOf(executor.getTaskCount()));\n    sb.append(\";\");\n    sb.append(\"Queue Size: \");\n    sb.append(String.valueOf(executor.getQueue().size()));\n    sb.append(\";\");\n    sb.append(\"Cache Size: \");\n    sb.append(String.valueOf (ConcurrentServer.getCache().getItemCount()));\n    sb.append(\";\");\n    Logger.sendMessage(sb.toString());\n    return sb.toString();\n  }\n}\n```", "```java\npublic class CleanCacheTask implements Runnable {\n\n  private ParallelCache cache;\n\n  public CleanCacheTask(ParallelCache cache) {\n    this.cache = cache;\n  }\n\n  @Override\n  public void run() {\n    try {\n      while (!Thread.currentThread().interrupted()) {\n        TimeUnit.SECONDS.sleep(10);\n        cache.cleanCache();\n      }\n    } catch (InterruptedException e) {\n\n    }\n  }\n\n}\n```", "```java\npublic class ParallelCache {\n\n  private ConcurrentHashMap<String, CacheItem> cache;\n  private CleanCacheTask task;\n  private Thread thread;\n  public static int MAX_LIVING_TIME_MILLIS = 600_000;\n\n  public ParallelCache() {\n    cache=new ConcurrentHashMap<>();\n    task=new CleanCacheTask(this);\n    thread=new Thread(task);\n    thread.start();\n  }\n```", "```java\n  public void put(String command, String response) {\n    CacheItem item = new CacheItem(command, response);\n    cache.put(command, item);\n\n  }\n\n  public String get (String command) {\n    CacheItem item=cache.get(command);\n    if (item==null) {\n      return null;\n    }\n    item.setAccessDate(new Date());\n    return item.getResponse();\n  }\n```", "```java\n  public void cleanCache() {\n    Date revisionDate = new Date();\n    Iterator<CacheItem> iterator = cache.values().iterator();\n\n    while (iterator.hasNext()) {\n      CacheItem item = iterator.next();\n      if (revisionDate.getTime() - item.getAccessDate().getTime() > MAX_LIVING_TIME_MILLIS) {\n        iterator.remove();\n      }\n    }\n  }\n```", "```java\n  public void shutdown() {\n    thread.interrupt();\n  }\n\n  public int getItemCount() {\n    return cache.size();\n  }\n```", "```java\npublic class LogTask implements Runnable {\n\n  @Override\n  public void run() {\n    try {\n      while (Thread.currentThread().interrupted()) {\n        TimeUnit.SECONDS.sleep(10);\n        Logger.writeLogs();\n      }\n    } catch (InterruptedException e) {\n    }\n    Logger.writeLogs();\n  }\n}\n```", "```java\npublic class Logger {\n\n  private static ConcurrentLinkedQueue<String> logQueue = new ConcurrentLinkedQueue<String>();\n\n  private static Thread thread;\n\n  private static final String LOG_FILE = Paths.get(\"output\", \"server.log\").toString();\n\n  static {\n    LogTask task = new LogTask();\n    thread = new Thread(task);\n  }\n```", "```java\n  public static void sendMessage(String message) {\n    logQueue.offer(new Date()+\": \"+message);\n  }\n```", "```java\n  public static void writeLogs() {\n    String message;\n    Path path = Paths.get(LOG_FILE);\n    try (BufferedWriter fileWriter = Files.newBufferedWriter(path,StandardOpenOption.CREATE,\n        StandardOpenOption.APPEND)) {\n      while ((message = logQueue.poll()) != null) {\n        fileWriter.write(new Date()+\": \"+message);\n        fileWriter.newLine();\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n```", "```java\n  public static void initializeLog() {\n    Path path = Paths.get(LOG_FILE);\n    if (Files.exists(path)) {\n      try (OutputStream out = Files.newOutputStream(path,\n          StandardOpenOption.TRUNCATE_EXISTING)) {\n\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n    thread.start();\n  }\n  public static void shutdown() {\n    thread.interrupt();\n  }\n```"]