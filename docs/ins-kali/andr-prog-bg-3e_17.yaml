- en: '*Chapter 17*: Data Persistence and Sharing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第17章*：数据持久性和共享'
- en: In this chapter, we will look at a couple of different ways to save data to
    an Android device's permanent storage. Also, for the first time, we will add a
    second `Activity` to our app. It often makes sense when implementing a separate
    "screen" in our app, such as a settings screen, to do so in a new `Activity`.
    We could go to the trouble of hiding the original UI and then showing the new
    UI, but this would quickly lead to confusing and error-prone code. So, we will
    see how to add an `Activity` class and navigate the user between them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一下将数据保存到Android设备的永久存储的几种不同方法。此外，我们将首次向我们的应用程序添加第二个`Activity`。当在我们的应用程序中实现一个单独的“屏幕”，比如设置屏幕时，将其放在一个新的`Activity`中通常是有意义的。我们可以费力地隐藏原始UI，然后显示新的UI，但这很快会导致令人困惑和容易出错的代码。因此，我们将看看如何添加一个`Activity`类并在它们之间导航用户。
- en: 'In summary, in this chapter, we will do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在本章中，我们将做以下事情：
- en: Learn about using Android intents to switch between `Activity` classes and pass
    data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用Android意图在`Activity`类之间切换并传递数据
- en: Create a simple (very simple) settings screen in a new `Activity` class for
    the Note to Self project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为“Note to Self”项目在一个新的`Activity`类中创建一个简单（非常简单）的设置屏幕
- en: Persist the settings screen data using the `SharedPreferences` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SharedPreferences`类持久化设置屏幕数据
- en: Learn about **JavaScript Object Notation** (**JSON**) for serialization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习**JavaScript对象表示**（**JSON**）进行序列化
- en: Explore Java's `try`-`catch`-`finally` syntax
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Java的`try`-`catch`-`finally`语法
- en: Implement saving data in our Note to Self app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的“Note to Self”应用程序中实现保存数据
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2017](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2017).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中的代码文件，网址为[https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2017](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2017)。
- en: Android intents
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android意图
- en: The `Intent` class is appropriately named. It is a class that demonstrates the
    intent of an `Activity` class from our app. It makes an intent clear and it also
    facilitates it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intent`类的命名非常恰当。它是一个演示我们应用程序中`Activity`类意图的类。它使意图清晰，并且也方便了它。'
- en: All our apps so far have had just one `Activity`, but many Android apps comprise
    more than one.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的应用程序都只有一个`Activity`，但许多Android应用程序包含多个`Activity`。
- en: In perhaps its most common use, an `Intent` class allows us to switch between
    `Activity` instances. But of course, `Activity` instances are made from classes
    with member variables. So, what happens to the variable's value – the data – when
    we switch between them? Intents handle this problem for us by allowing us to pass
    data between `Activity` instances.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在它可能最常见的用法中，`Intent`类允许我们在`Activity`实例之间切换。但是，`Activity`实例是由具有成员变量的类制作的。那么，当我们在它们之间切换时，变量的值
    - 数据 - 会发生什么？意图通过允许我们在`Activity`实例之间传递数据来解决了这个问题。
- en: Intents aren't just about wiring up the `Activity` instances of our app. They
    also make it possible to interact with other apps too. For example, we could provide
    a link in our app for the user to send an email, make a phone call, interact with
    social media, or open a web page in a browser and have the email app, phone call
    app, social media app, or web browser do all the work.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 意图不仅仅是关联我们应用程序的`Activity`实例。它们还使我们能够与其他应用程序进行交互。例如，我们可以在我们的应用程序中提供一个链接，让用户发送电子邮件，打电话，与社交媒体互动，或在浏览器中打开网页，并让电子邮件应用程序、电话应用程序、社交媒体应用程序或网络浏览器完成所有工作。
- en: There aren't enough pages in this book to really dig deep into interacting with
    other apps, and we will mainly focus on switching between activities and passing
    data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中没有足够的页面来深入研究与其他应用程序的交互，我们主要将专注于在活动之间切换和传递数据。
- en: Switching Activity
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切换活动
- en: 'Let''s say we have an app with two `Activity`-based classes, because we will
    soon. We can assume that as usual, we have an `Activity` class called `MainActivity`,
    which is where the app starts, and a second `Activity` called `SettingsActivity`.
    This is how we can swap from `MainActivity` to `SettingsActivity`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的应用程序有两个基于`Activity`的类，因为我们很快就会有。我们可以假设通常情况下，我们有一个名为`MainActivity`的`Activity`类，这是应用程序的起点，还有一个名为`SettingsActivity`的第二个`Activity`。这是我们如何从`MainActivity`切换到`SettingsActivity`的方法：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Look carefully at how we initialized the `Intent` object. `Intent` has a constructor
    that takes two arguments. The first is a reference to the current `Activity`,
    `this`. And the second parameter is the name of the `Activity` class we want to
    open, `SettingsActivity.class`. The `.class` part on the end of `SettingsActivity`
    makes it the full name of the `Activity` class as declared in the `AndroidManifest.xml`
    file, and we will look at that when we experiment with intents shortly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看我们如何初始化`Intent`对象。`Intent`有一个构造函数，它接受两个参数。第一个是对当前`Activity`的引用，`this`。第二个参数是我们想要打开的`Activity`类的名称，`SettingsActivity.class`。`SettingsActivity`末尾的`.class`部分使其成为`AndroidManifest.xml`文件中声明的`Activity`类的完整名称，我们将在不久的将来尝试意图时查看它。
- en: The only problem is that `SettingsActivity` doesn't share any of the data of
    `MainActivity`. In a way, this is a good thing because if you need all the data
    from `MainActivity`, then it is a reasonable indication that switching activities
    might not be the best way of proceeding with your app's design. It is, however,
    unreasonable to have encapsulation so thorough that the two `Activity` instances
    know absolutely nothing about each other.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是`SettingsActivity`不共享`MainActivity`的任何数据。从某种意义上说，这是一件好事，因为如果你需要从`MainActivity`获取所有数据，那么切换活动可能不是进行应用程序设计的最佳方式。然而，封装得如此彻底以至于这两个`Activity`实例完全不知道对方是不合理的。
- en: Passing data between activities
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在活动之间传递数据
- en: What if we have a sign-in screen for the user and we want to pass the user's
    credentials to each `Activity` of our app? We could do so using intents.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为用户有一个登录屏幕，并且我们想要将用户的凭据传递给我们应用程序的每个`Activity`，我们可以使用意图来实现。
- en: 'We can add data to an `Intent` class like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样向`Intent`类添加数据：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In `SettingsActivity`, we could then retrieve the string like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SettingsActivity`中，我们可以这样检索字符串：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous two blocks of code, we switched `Activity` in the same way as
    we have already seen. But before we called the `startActivity` method, we used
    the `putExtra` method to load a string into the intent.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个代码块中，我们以与之前相同的方式切换了`Activity`。但在调用`startActivity`方法之前，我们使用`putExtra`方法将字符串加载到意图中。
- en: We add data using `identifier` instance that can be used in the retrieving `Activity`
    to identify and retrieve the data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`identifier`实例添加数据，该数据可以在检索`Activity`中用于标识和检索数据。
- en: The identifier name is up to you, but useful/memorable values should be used.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符名称由您决定，但应使用有用/易记的值。
- en: 'Then, in the receiving `Activity`, we simply create an intent using the default
    constructor:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在接收`Activity`中，我们只需使用默认构造函数创建一个意图：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: And we can then retrieve the data using the `getExtras` method and the appropriate
    identifier from the key-value pair.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`getExtras`方法和键值对中的适当标识符检索数据。
- en: Once we want to start sending more than a few values, it is worth considering
    different tactics.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们想要开始发送多个值，就值得考虑不同的策略。
- en: The `Intent` class can help us when sending more complex data than this, but
    the `Intent` class has its limits. For example, we wouldn't be able to send a
    `Note` object.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intent`类可以在发送比这更复杂的数据时帮助我们，但`Intent`类有其限制。例如，我们将无法发送`Note`对象。'
- en: Adding a settings page to Note to Self
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向“自我备忘录”添加设置页面
- en: Now that we are armed with all this knowledge about the Android `Intent` class,
    we can add another screen (`Activity`) to our Note to Self app. We will add a
    settings screen.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了关于Android `Intent`类的所有知识，我们可以向我们的“自我备忘录”应用程序添加另一个屏幕（`Activity`）。我们将添加一个设置屏幕。
- en: We will first create a new `Activity` for our settings screen and see what effect
    that has on the `AndroidManifest.xml` file; we will then create a very simple
    layout for our settings screen and add the Java code to switch from `MainActivity`
    to the new one. We will, however, defer wiring up our settings screen with Java
    until we have learned how to save the settings to disk. We will do this later
    in this chapter and then come back to the settings screen to make its data persist.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先为我们的设置屏幕创建一个新的`Activity`，并查看这对`AndroidManifest.xml`文件的影响；然后我们将为我们的设置屏幕创建一个非常简单的布局，并添加Java代码以从`MainActivity`切换到新的布局。但是，在学习如何将设置保存到磁盘之前，我们将推迟使用Java连接我们的设置屏幕。我们将在本章后面进行此操作，然后返回设置屏幕以使其数据持久化。
- en: First, let's create that new `Activity` class. We will call it `SettingsActivity`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的`Activity`类。我们将其称为`SettingsActivity`。
- en: Creating SettingsActivity
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SettingsActivity
- en: 'This will be a screen where the user can turn on or off the decorative divider
    between each note in the `RecyclerView` widget. This will not be a comprehensive
    settings screen but it will be a useful exercise, and we will learn how to switch
    between activities as well as saving data to disk. Follow these steps to get started:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个屏幕，用户可以在`RecyclerView`小部件中的每个笔记之间打开或关闭装饰性分隔符。这不会是一个全面的设置屏幕，但这将是一个有用的练习，并且我们将学习如何在活动之间切换以及将数据保存到磁盘。按照以下步骤开始：
- en: In the project explorer, right-click the folder that contains all your `.java`
    files and has the same name as your package. From the pop-up context menu, select
    **New** | **Activity** | **Empty Activity**.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源管理器中，右键单击包含所有`.java`文件并与您的包名称相同的文件夹。从弹出的上下文菜单中，选择**新建** | **Activity**
    | **空白Activity**。
- en: In the `SettingsActivity`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SettingsActivity`中。
- en: Leave all the other options at their defaults and left-click **Finish**.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有其他选项保留为默认值，然后单击**完成**。
- en: Android Studio has created a new `Activity`-based class for us and its associated
    `.java` file. Let's take a quick peek at some of the work that was done behind
    the scenes for us because it is useful to know what is going on.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio已为我们创建了一个基于`Activity`的类及其关联的`.java`文件。让我们快速查看一下幕后为我们完成的一些工作，因为了解正在发生的事情是有用的。
- en: 'Open the `AndroidManifest.xml` file from within the `manifests` folder in the
    project explorer. Notice the following line of code about halfway through this
    file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目资源管理器中的`manifests`文件夹中打开`AndroidManifest.xml`文件。注意文件中间大约有一半的以下代码行：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is how an `Activity` class is `Activity` class is not registered, then
    an attempt to run it will crash the app. We could create an `Activity` class simply
    by creating a class that extends `Activity` (or `AppCompatActivity`) in a new
    `.java` file. However, we would then have to add the preceding code ourselves.
    Also, by using the new `Activity` wizard, we got a layout XML file (`activity_settings.xml`)
    automatically generated for us.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`Activity`类是如何`Activity`类未注册，然后尝试运行它将使应用程序崩溃。我们可以通过在新的`.java`文件中创建一个扩展`Activity`（或`AppCompatActivity`）的类来创建`Activity`类。但是，我们随后必须自己添加前面的代码。此外，通过使用新的`Activity`向导，我们自动生成了一个布局XML文件（`activity_settings.xml`）。
- en: Designing the settings screen layout
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计设置屏幕布局
- en: 'We will quickly build a UI for our settings screen, and the following steps
    and figure should make this straightforward:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将快速为我们的设置屏幕构建一个UI，以下步骤和图示应该使这变得简单：
- en: Open the `activity_settings.xml` file, switch to the **Design** tab, and we
    will quickly lay out our settings screen. Use this next figure as a guide while
    following the rest of the steps:![Figure 17.1 – Designing the settings screen
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity_settings.xml`文件，切换到**设计**选项卡，然后我们将快速布置我们的设置屏幕。在执行其余步骤时，请使用下一个图示作为指南：![图17.1
    – 设计设置屏幕
- en: '](img/Figure_17.1_B16773.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.1_B16773.jpg)'
- en: Figure 17.1 – Designing the settings screen
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1 – 设计设置屏幕
- en: Drag and drop a **Switch** widget onto the center top of the layout. I stretched
    mine by dragging the edges to make it larger.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Switch**小部件拖放到布局的中上部。我通过拖动边缘来拉伸我的小部件，使其变大。
- en: Add an `id` attribute of `switch1` (if it isn't already by default) so we can
    interact with it using Java code from `SettingsActivity.java`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`id`属性`switch1`（如果默认情况下还没有），这样我们就可以使用`SettingsActivity.java`中的Java代码与其交互。
- en: Use the constraint handles to fix the position of the switch or click the **Infer
    Constraints** button to fix it automatically.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用约束处理程序来固定开关的位置，或者单击**推断约束**按钮以自动修复它。
- en: We now have a simple new layout for our settings screen and the `id` property
    is in place, ready for when we wire it up with our Java code later in the chapter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在为设置屏幕有了一个简单的新布局，并且`id`属性已经就位，准备在本章后面的Java代码中连接它。
- en: Enabling the user to switch to the settings screen
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用户能够切换到设置屏幕
- en: We already know how to switch to `SettingsActivity`. Also, as we won't be passing
    any data to it or from it, we can get this working with just two lines of Java
    code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何切换到`SettingsActivity`。此外，由于我们不会向其传递任何数据，也不会从中传递任何数据，因此我们可以只用两行Java代码就可以使其工作。
- en: 'You might have noticed in the action bar of our app that there is a menu icon.
    It is a default part of the Basic Activity template that we used when we created
    the project. It is indicated in the following figure:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们应用程序的操作栏中有一个菜单图标。这是我们创建项目时使用的基本活动模板的默认部分。如下图所示：
- en: '![Figure 17.2 – Menu icon'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.2 – 菜单图标'
- en: '](img/Figure_17.2_B16773.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.2_B16773.jpg)'
- en: Figure 17.2 – Menu icon
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2 – 菜单图标
- en: 'If you tap it, there is already a menu option in there for **Settings**, provided
    by default when we first created the app. This is what you will see when you tap
    the menu icon:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击它，您会发现默认情况下已经有一个菜单选项**设置**。当您点击菜单图标时，您将看到以下内容：
- en: '![Figure 17.3 – Settings option'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.3 – 设置选项'
- en: '](img/Figure_17.3_B16773.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.3_B16773.jpg)'
- en: Figure 17.3 – Settings option
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.3 – 设置选项
- en: All we need to do is place our code to switch to the `SettingsActivity` class
    within the `onOptionsItemSelected` method in the `MainActivity` class. Android
    Studio even provided an `if` block by default for us to paste our code into, on
    the assumption that we would one day want to add a settings screen. How thoughtful.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要将切换到`SettingsActivity`类的代码放在`MainActivity`类的`onOptionsItemSelected`方法中。Android
    Studio甚至默认为我们提供了一个`if`块，以便我们将来可能想要添加设置屏幕。多么体贴。
- en: 'Switch to `MainActivity.java` in the editor window and find the following block
    of code in the `onOptionsItemSelected` method:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到编辑器窗口中的`MainActivity.java`，并在`onOptionsItemSelected`方法中找到以下代码块：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add this code into the `if` block shown previously, just before the `return
    true` statement:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加到先前显示的`if`块中，就在`return true`语句之前：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will need to import the `Intent` class using your preferred technique to
    add this line of code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用您喜欢的技术导入`Intent`类，以添加以下代码行：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can now run the app and visit the new settings screen by tapping the **Settings**
    menu option. This screenshot shows the settings screen running on the emulator:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以运行应用程序并通过点击**设置**菜单选项来访问新的设置屏幕。此屏幕截图显示了模拟器上运行的设置屏幕：
- en: '![Figure 17.4 – Settings screen'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.4 – 设置屏幕'
- en: '](img/Figure_17.4_B16773.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.4_B16773.jpg)'
- en: Figure 17.4 – Settings screen
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.4 – 设置屏幕
- en: To return from `SettingsActivity` to `MainActivity`, you can tap the back button
    on the device.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`SettingsActivity`返回到`MainActivity`，您可以点击设备上的返回按钮。
- en: Persisting data with SharedPreferences
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SharedPreferences持久化数据
- en: In Android, there are a few ways to make data persist. By persist, I mean that
    if the user quits the app, then when they come back to it, their data is still
    available. Which method is the correct one to use is dependent upon the app and
    the type of data.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，有几种方法可以使数据持久化。持久化意味着如果用户退出应用程序，然后再次打开应用程序，他们的数据仍然可用。使用哪种方法取决于应用程序和数据类型。
- en: In this book, we will look at three ways to make data persist. For saving our
    users' settings, we only need a simple method. After all, we just need to know
    whether they want the decorative divider between each of the notes in the `RecyclerView`
    widget.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将介绍三种使数据持久化的方法。对于保存用户设置，我们只需要一个简单的方法。毕竟，我们只需要知道他们是否希望在`RecyclerView`小部件的每个笔记之间有装饰性分隔符。
- en: 'Let''s look at how we can make our apps save and reload variables to the internal
    storage of the device. We need to use the `SharedPreferences` class. `SharedPreferences`
    is a class that provides access to data that can be accessed and edited by all
    `Activity` classes of an app. Let''s look at how we can use it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使我们的应用程序将变量保存和重新加载到设备的内部存储器中。我们需要使用`SharedPreferences`类。`SharedPreferences`是一个提供对可以由应用程序的所有`Activity`类访问和编辑的数据的访问权限的类。让我们看看如何使用它：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As with all objects, we need to initialize them before we can use them. We
    can initialize the `prefs` object by using the `getSharedPreferences` method and
    passing in a string that will be used to refer to all the data read and written
    using this object. Typically, we could use the name of the app as the value for
    this string. In the next code, `MODE_PRIVATE` means that any class, in this app
    only, can access it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有对象一样，我们需要在使用之前初始化它们。我们可以通过使用`getSharedPreferences`方法并传递一个字符串来初始化`prefs`对象，该字符串将用于引用使用该对象读取和写入的所有数据。通常，我们可以使用应用程序的名称作为此字符串的值。在下一个代码中，`MODE_PRIVATE`表示任何类（仅在此应用程序中）都可以访问它：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We then use our newly initialized `prefs` object to initialize our `editor`
    object by calling the `edit` method:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用新初始化的`prefs`对象通过调用`edit`方法来初始化我们的`editor`对象：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s say we wanted to save the user''s name that we have in a string called
    `username`. We can then write the data to the internal memory of the device like
    this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要保存我们在名为`username`的字符串中拥有的用户名称。然后，我们可以像这样将数据写入设备的内部存储器中：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first argument used in the `putString` method is a label that can be used
    to refer to the data; the second is the actual variable that holds the data we
    want to save. The second line in the previous code initiates the saving process.
    So, we could write multiple variables to disk like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`putString`方法中使用的第一个参数是一个标签，可以用来引用数据；第二个是保存我们想要保存的数据的实际变量。上述代码的第二行启动了保存过程。因此，我们可以这样将多个变量写入磁盘：'
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The previous code demonstrates that you can save other variable types, and it
    of course assumes that the `username`, `age`, and `subscribed` variables have
    previously been declared and then initialized with appropriate values.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码演示了您可以保存其他变量类型，并且它当然假定`username`，`age`和`subscribed`变量先前已经被声明并用适当的值初始化。
- en: Once `editor.commit()` has executed, the data is stored. We can quit the app,
    even turn off the device, and the data will persist.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`editor.commit()`执行完毕，数据就被存储了。我们甚至可以退出应用程序，甚至关闭设备，数据仍然会持久保存。
- en: Reloading data with SharedPreferences
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SharedPreferences重新加载数据
- en: 'Let''s see how we can reload our data the next time the app is run. This code
    will reload the three values that the previous code saved. We could even declare
    our variables and initialize them with the stored values:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下次运行应用程序时如何重新加载数据。这段代码将重新加载上一个代码保存的三个值。我们甚至可以声明我们的变量并用存储的值进行初始化：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previous code, we load the data from disk using the method appropriate
    for the data type and the same label we used to save the data in the first place.
    What is less clear is the second argument to each of the method calls.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用适合数据类型的方法从磁盘加载数据，并使用了保存数据的相同标签。不太清楚的是每个方法调用的第二个参数。
- en: The `getString`, `getInt`, and `getBoolean` methods require a default value
    as the second parameter. If there is no data stored with that label, it will then
    return the default value.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`getString`，`getInt`和`getBoolean`方法需要一个默认值作为第二个参数。如果没有存储带有该标签的数据，它将返回默认值。'
- en: 'We could then check for these default values in our code and go about trying
    to obtain the real values. See here, for example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在我们的代码中检查这些默认值，并尝试获取真实的值。例如，看这里：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We now know enough to save our users' settings in the Note to Self app.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道足够的知识来保存我们用户的设置在Note to Self应用程序中。
- en: Making the Note to Self settings persist
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使“Note to Self”设置持久化
- en: We have already learned how to save data to the device's memory. As we implement
    saving the users' settings, we will also see again how we handle `Switch` input
    and where exactly the code we have just seen will go to make our app work the
    way we want it to.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何将数据保存到设备的内存中。当我们实现保存用户设置时，我们还将再次看到我们如何处理`Switch`输入，以及我们刚刚看到的代码将去哪里使我们的应用程序按我们想要的方式工作。
- en: Coding the SettingsActivity class
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写SettingsActivity类
- en: Most of the action will take place in the `SettingsActivity.java` file. So,
    click on the appropriate tab and we will add the code a bit at a time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分操作将在`SettingsActivity.java`文件中进行。因此，点击适当的选项卡，我们将逐步添加代码。
- en: 'First, we need some member variables that will give us working `SharedPreferences`
    and `Editor` instances. We also want a member variable to represent the user''s
    settings option: whether they want decorative dividers or not.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些成员变量，这些变量将为我们提供工作的`SharedPreferences`和`Editor`实例。我们还希望有一个成员变量来表示用户的设置选项：他们是否想要装饰性分隔线。
- en: 'Add the following member variables to the `SettingsActivity` class just after
    the class declaration:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SettingsActivity`类的类声明之后添加以下成员变量：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Import the `SharedPreferences` class:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`SharedPreferences`类：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now in the `onCreate` method, add the code to initialize `mPrefs` and `mEditor`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`onCreate`方法中，添加代码来初始化`mPrefs`和`mEditor`：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, still in the `onCreate` method, let's get a reference to our `Switch`
    widget and load up the saved data that represents our user's previous choice for
    whether to show the dividers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`onCreate`方法中，让我们获取对我们的`Switch`小部件的引用，并加载代表我们用户先前选择是否显示分隔线的保存数据。
- en: 'We get a reference to the switch in the same way that we did in [*Chapter 13*](B16773_13_ePub_RK.xhtml#_idTextAnchor228)*,
    Anonymous Classes – Bringing Android Widgets to Life*. Notice the default value
    is `true` – to show the dividers. We will also set the switch to either on or
    off as appropriate:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与[*第13章*](B16773_13_ePub_RK.xhtml#_idTextAnchor228)*相同的方式获取对开关的引用，匿名类-让Android小部件活跃起来*。请注意默认值为`true`-显示分隔线。我们还将根据需要将开关设置为打开或关闭：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You will need to import the `Switch` class:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要导入`Switch`类：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, we create an anonymous class to listen for and handle changes to our `Switch`
    widget.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个匿名类来监听和处理对我们的`Switch`小部件的更改。
- en: When the `isChecked` variable is `true`, we use the `prefs` object to set the
    `dividers` label and the `mShowDividers` variable to `true`; when it is not checked,
    we set them both to `false`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当`isChecked`变量为`true`时，我们使用`prefs`对象将`dividers`标签和`mShowDividers`变量设置为`true`；当未选中时，我们将它们都设置为`false`。
- en: 'Add the following code to the `onCreate` method that we have just discussed:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到我们刚刚讨论的`onCreate`方法中：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You will need to import the `CompoundButton` class:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要导入`CompoundButton`类：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You might have noticed that at no point in any of that code did we call the
    `mEditor.commit` method to save the user's settings. We could have placed it after
    we detected a change to the switch, but it is much simpler to put it where it
    is guaranteed to be called, but only once.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在任何代码中，我们都没有调用`mEditor.commit`方法来保存用户的设置。我们本可以在检测到开关变化后放置它，但将它放在保证被调用但只调用一次的地方更简单。
- en: 'We will use our knowledge of the `Activity` lifecycle and override the `onPause`
    method. When the user leaves the `SettingsActivity` screen either to go back to
    `MainActivity` or to quit the app, the `onPause` method will be called by the
    operating system and the settings will be saved. Add this code to override the
    `onPause` method and save the user''s settings. Add the code just before the closing
    curly brace of the `SettingsActivity` class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用我们对`Activity`生命周期的了解，并重写`onPause`方法。当用户离开`SettingsActivity`屏幕，无论是返回到`MainActivity`还是退出应用程序，操作系统都会调用`onPause`方法，并保存设置。在`SettingsActivity`类的结束大括号之前添加以下代码来重写`onPause`方法并保存用户的设置：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, we can add some code to the `MainActivity` class to load the settings
    when the app starts or when the user switches back from the settings screen to
    the main screen.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以向`MainActivity`类添加一些代码，以在应用程序启动时或用户从设置屏幕切换回主屏幕时加载设置。
- en: Coding the MainActivity class
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写MainActivity类
- en: 'Add this highlighted code to add some member variables after our `NoteAdapter`
    instance is declared:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们声明`NoteAdapter`实例后添加一些成员变量的突出代码：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Import the `SharedPreferences` class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`SharedPreferences`类：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now we have a `boolean` member to decide whether to show the dividers and a
    `SharedPreferences` instance to read the settings from disk.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`boolean`成员来决定是否显示分隔符，以及一个`SharedPreferences`实例来从磁盘读取设置。
- en: Now we will override the `onResume` method to initialize our `mPrefs` variable
    and load the settings into the `mShowDividers` variable.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将重写`onResume`方法，初始化我们的`mPrefs`变量，并将设置加载到`mShowDividers`变量中。
- en: 'Add the overridden `onResume` method as shown next to the `MainActivity` class:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`类中添加重写的`onResume`方法，如下所示：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The user is now able to choose their settings. The app will both save and reload
    them as necessary, but we need to make the `MainActivity` class respond to the
    user's choice.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在能够选择他们的设置。应用程序将根据需要保存和重新加载它们，但我们需要让`MainActivity`类响应用户的选择。
- en: 'Find this code in the `onCreate` method and delete it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中找到这段代码并删除它：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The previous code is what sets the dividers between each note in the list.
    Add this new code to the `onResume` method, which is the same line of code surrounded
    by an `if` statement, to selectively use dividers only when `mShowDividers` is
    `true`. Add the code after the previous code in the `onResume` method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个代码是在列表中的每个笔记之间设置分隔符。将这段新代码添加到`onResume`方法中，这是相同的代码行，被`if`语句包围，只有当`mShowDividers`为`true`时才选择性地使用分隔符。在`onResume`方法中在上一个代码后添加以下代码：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the app and notice that the dividers are gone; go to the settings screen,
    switch on the dividers, and return to the main screen (with the back button) –
    and behold: there are now separators. This next figure shows the list with and
    without separators side by side to illustrate that the code we have added works
    and the settings persist between the two Activity classes:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并注意到分隔符已经消失；转到设置屏幕，打开分隔符，然后返回到主屏幕（使用返回按钮）- 看哪：现在有分隔符了。下一个图显示了带有和不带有分隔符的列表，以便说明我们添加的代码起作用，并且设置在这两个Activity类之间持续存在：
- en: '![Figure 17.5 – List with and without separators'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.5 - 带有和不带有分隔符的列表'
- en: '](img/Figure_17.5_B16773.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_17.5_B16773.jpg)'
- en: Figure 17.5 – List with and without separators
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.5 - 带有和不带有分隔符的列表
- en: Be sure to try quitting the app and restarting to verify that the setting is
    saved to disk. You can even turn the emulator off and back on again and the setting
    will persist.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 确保尝试退出应用程序并重新启动以验证设置是否已保存到磁盘。甚至可以关闭并重新打开模拟器，设置将持续存在。
- en: Now we have a neat settings screen and we can permanently save the user's choice
    of decorative preference. Of course, the big missing link regarding persistence
    is that the user's fundamental data, their notes, still does not persist.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个整洁的设置屏幕，我们可以永久保存用户选择的装饰偏好。当然，关于持久性的一个重要缺失环节是用户的基本数据，他们的笔记，仍然没有持久保存。
- en: More advanced persistence
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更高级的持久性
- en: Let's think about what we need to do. We want to save a bunch of notes to the
    internal storage. Being more specific, we want to store a selection of strings
    and related Boolean values. These strings and Boolean values represent the user's
    note title, the note's text, and whether it is a to-do, important, or an idea.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下我们需要做什么。我们想要将一堆笔记保存到内部存储中。更具体地说，我们想要存储一系列字符串和相关的布尔值。这些字符串和布尔值代表用户的笔记标题、笔记文本，以及它是待办事项、重要事项还是想法。
- en: Given what we already know about the `SharedPreferences` class, at first glance
    this might not seem especially challenging – until we dig a little deeper into
    our requirements. What if the user loves our app and ends up with 100 notes? We
    would need 100 identifiers for key-value pairs. Not impossible, but starting to
    get awkward.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们已经了解的`SharedPreferences`类，乍一看这似乎并不特别具有挑战性 - 直到我们更深入地了解我们的需求。如果用户喜欢我们的应用程序并最终拥有100条笔记怎么办？我们需要100个键值对的标识符。这并非不可能，但开始变得尴尬。
- en: Now consider that we want to enhance the app and give the user the ability to
    add dates to them. Android has a `Date` class that is perfect for this. It would
    be reasonably straightforward to then add neat features such as reminders to our
    app. But when it comes to saving data, suddenly, things start to get complicated.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一下，我们想要增强应用程序，并让用户能够为它们添加日期。Android有一个`Date`类非常适合这个用途。然后，我们可以相对简单地为我们的应用程序添加一些新功能，比如提醒。但是当涉及到保存数据时，事情突然变得复杂起来。
- en: How would we store a date using `SharedPreferences`? It wasn't designed for
    this. We could convert it to a string when we save it and convert it back again
    when we load it, but this is far from simple.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用`SharedPreferences`来存储日期？它并不是为此而设计的。我们可以在保存时将其转换为字符串，然后在加载时再次转换回来，但这远非简单。
- en: And as our app grows in features and our users get more and more notes, the
    whole persistence thing becomes a nightmare. What we need is a way to save and
    load objects, actual Java objects. If we can simply save and load objects, including
    their internal data (strings, Booleans, dates, or anything else), our apps can
    have any kind of data we can think of to suit our users.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序功能的增加和用户获取更多的笔记，整个持久性问题变得一团糟。我们需要的是一种保存和加载对象的方法，实际的Java对象。如果我们可以简单地保存和加载对象，包括它们的内部数据（字符串，布尔值，日期或其他任何东西），我们的应用程序可以拥有我们可以想到的任何类型的数据，以满足我们的用户。
- en: The process of converting data objects into bits and bytes to store on a disk
    is called **serialization**; the reverse process is called **de-serialization**.
    Serialization on its own is a vast topic and far from straightforward. Fortunately,
    as we are coming to expect, there is a class to handle most of the complexity
    for us.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据对象转换为位和字节以存储在磁盘上的过程称为**序列化**；反向过程称为**反序列化**。单独的序列化是一个庞大而复杂的主题。幸运的是，正如我们所期望的那样，有一个类来处理大部分复杂性。
- en: What is JSON?
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是JSON？
- en: '**JSON** stands for **JavaScript Object Notation** and it is widely used in
    fields beyond Android and the Java language. It is perhaps most frequently used
    to send data between web applications and servers.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**代表**JavaScript对象表示**，它在Android和Java语言之外的领域被广泛使用。它可能最常用于在Web应用程序和服务器之间发送数据。'
- en: Fortunately, there are JSON classes available for Android that almost entirely
    hide the complexity of the serialization process. By learning about a few more
    Java concepts, we can quickly begin to use these classes and start writing entire
    Java objects to the device storage rather than worrying ourselves about what primitive
    types make up the objects.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Android上有可用的JSON类，几乎完全隐藏了序列化过程的复杂性。通过学习一些更多的Java概念，我们可以快速开始使用这些类，并开始将整个Java对象写入设备存储，而不必担心构成对象的原始类型是什么。
- en: The JSON classes when compared with other classes we have seen so far undertake
    operations that have a higher-than-normal probability of failure that is beyond
    their control. To find out why this is so and what can be done about it, let's
    look at Java exceptions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们迄今为止见过的其他类相比，JSON类执行的操作具有比正常情况下更高的失败概率，这是超出它们的控制范围的。要找出原因以及可以采取什么措施，让我们看看Java异常。
- en: Java exceptions – try, catch, and finally
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java异常 - try，catch和finally
- en: 'All this talk of JSON requires us to learn a new Java concept: **exceptions**.
    When we write a class that performs operations that have a possibility of failure,
    especially for reasons beyond our control, it is advisable to make this plain
    in our code so that anyone using our class is prepared for the possibility.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些关于JSON的讨论要求我们学习一个新的Java概念：**异常**。当我们编写一个执行可能失败的操作的类，特别是由于我们控制之外的原因，建议在我们的代码中明确这一点，以便任何使用我们的类的人都能为可能性做好准备。
- en: Saving and loading data is one such scenario where failure is possible beyond
    our control. Think about trying to load data when the SD card has been removed
    or has been corrupted. Another instance where code might fail is perhaps when
    we write code that relies on a network connection – what if the user goes offline
    partway through a data transfer?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 保存和加载数据是一个这样的场景，其中失败是可能的，超出了我们的控制范围。想想当SD卡已被移除或已损坏时尝试加载数据的情况。另一个代码可能失败的情况是当我们编写依赖于网络连接的代码时
    - 如果用户在数据传输过程中断网了会怎么样？
- en: Java exceptions are the solution and JSON classes use them, so it is a good
    time to learn about them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Java异常是解决方案，JSON类使用它们，所以现在是学习它们的好时机。
- en: When we write a class that uses code with a chance of failure, we can prepare
    the users of our class by using exceptions with `try`, `catch`, and `finally`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写一个使用有可能失败的代码的类时，我们可以通过使用`try`，`catch`和`finally`来为我们的类的用户做好准备。
- en: 'We can write methods in our classes using the `throws` Java keyword at the
    end of the signature – a bit like this perhaps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的类中编写方法，在签名的末尾使用`throws` Java关键字 - 可能是这样的：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now any code that uses the `somePrecariousMethod` method will need to `try`
    and `catch` blocks – perhaps like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何使用`somePrecariousMethod`方法的代码都需要`try`和`catch`块 - 也许像这样：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Optionally, we can also add a `finally` block if we want to take any further
    action after the `try` and `catch` blocks:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，如果我们想在`try`和`catch`块之后执行任何进一步的操作，我们还可以添加一个`finally`块：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In our Note to Self app, we will take the minimum amount of action to handle
    exceptions and simply output an error to logcat, but you could do things such
    as notify the user, retry the operation, or put into action some clever back-up
    plan.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的“自言自语”应用中，我们将采取最少的操作来处理异常，并简单地将错误输出到logcat，但您可以做一些事情，比如通知用户，重试操作，或者实施一些聪明的备用计划。
- en: Backing up user data in Note to Self
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备份用户数据在“自言自语”中
- en: So, with our newfound insight into exceptions, let's modify our Note to Self
    code, and then we can be introduced to the `JSONObject` and `JSONException` classes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过我们对异常的新认识，让我们修改我们的“自言自语”代码，然后我们可以介绍`JSONObject`和`JSONException`类。
- en: 'First, let''s make some minor modifications to our `Note` class. Add some more
    members that will act as the key in a key-value pair for each aspect of our `Note`
    class:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们对我们的`Note`类进行一些小修改。添加一些更多的成员，这些成员将作为我们`Note`类的每个方面的键值对的键：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now add a constructor and an empty default constructor that receives `JSONObject`
    and throws `JSONException`. The body of the constructor initializes each of the
    members that defines the properties of a single `Note` object by calling the `getString`
    or `getBoolean` method of `JSONObject`, passing in the key as an argument. We
    also provide an empty default constructor, which is required now that we are providing
    our specialized constructor:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加一个构造函数和一个接收`JSONObject`并抛出`JSONException`的空默认构造函数。构造函数的主体通过调用`JSONObject`的`getString`或`getBoolean`方法，传入键作为参数，来初始化定义单个`Note`对象属性的每个成员。我们还提供了一个空的默认构造函数，现在我们提供了我们的专门的构造函数，这是必需的：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You will need to import the `JSONException` and `JSONObject` classes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要导入`JSONException`和`JSONObject`类：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The next code we will see will load the member variables of a given `Note` object
    into `JSONObject`. This is where the `Note` object's members are packed up as
    a single `JSONObject` ready for when the actual serialization takes place.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将看到的代码将给定`Note`对象的成员变量加载到`JSONObject`中。这是`Note`对象的成员被打包为一个单独的`JSONObject`，以便进行实际的序列化。
- en: 'All we need to do is call the `put` method with the appropriate key and the
    matching member variable. This method returns `JSONObject` (we will see where
    in a minute) and it also throws a `JSONObject` exception. Add the code we have
    just discussed:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要使用适当的键和匹配的成员变量调用`put`方法。该方法返回`JSONObject`（我们将在一分钟内看到它在哪里），它还会抛出一个`JSONObject`异常。添加我们刚刚讨论过的代码：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now let's make a `JSONSerializer` class that will perform the actual serialization
    and deserialization. Create a new class and call it `JSONSerializer`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个`JSONSerializer`类，它将执行实际的序列化和反序列化。创建一个新类并将其命名为`JSONSerializer`。
- en: Let's split it up into a few chunks and talk about what we are doing as we code
    each chunk.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其分成几个部分，并在编写每个部分的代码时讨论我们正在做什么。
- en: 'First, the declaration and a couple of member variables: a string to hold the
    filename where the data will be saved and a `Context` object that is necessary
    in Android to write data to a file. Add the highlighted code inside the class
    you just created:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明和一些成员变量：一个字符串来保存数据将被保存的文件名，以及一个`Context`对象，在Android中写入数据到文件是必要的。在您刚刚创建的类中添加突出显示的代码：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You will need to import the `Context` class:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要导入`Context`类：
- en: '`import android.content.Context;`'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.content.Context;`'
- en: 'The previous code shows that the closing curly brace of the class and all the
    code that follows for this class should be entered inside of it. Here is the very
    straightforward constructor where we initialize the two member variables that
    are passed in as parameters. Add the constructor for `JSONSerializer`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码显示，类的结束大括号和随后为该类编写的所有代码应该放在其中。这是非常简单的构造函数，我们在其中初始化了作为参数传入的两个成员变量。添加`JSONSerializer`的构造函数：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now we can start coding the real guts of the class. The `save` method is next.
    It first creates a `JSONArray` object, which is a specialized `ArrayList` class
    for handling JSON objects.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始编写类的真正要点。接下来是`save`方法。它首先创建一个`JSONArray`对象，这是一个专门用于处理JSON对象的`ArrayList`类。
- en: Next, the code uses an enhanced `for` loop to go through all the `Note` objects
    in the `notes` array list and convert them to JSON objects using the `convertToJSON`
    method from the `Note` class, which we added previously. Then, we load these converted
    `JSONObject` instances into `jArray`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码使用增强的`for`循环来遍历`notes`数组列表中的所有`Note`对象，并使用`Note`类中我们之前添加的`convertToJSON`方法将它们转换为JSON对象。然后，我们将这些转换后的`JSONObject`实例加载到`jArray`中。
- en: 'Next, the code uses a `Writer` instance and an `OutputStream` instance combined
    to write the data to an actual file. Notice the `OutputStream` instance needed
    the `mContext` object to be initialized. Add the code we have just discussed:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码使用`Writer`实例和`OutputStream`实例组合将数据写入实际文件。请注意，`OutputStream`实例需要初始化`mContext`对象。添加我们刚刚讨论过的代码：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You will need to add the following `import` statements for these new classes:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要为这些新类添加以下`import`语句：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now for the de-serialization – loading the data. This time, as we might expect,
    the method receives no parameters but instead returns an `ArrayList` instance.
    An `InputStream` instance is created using `mContext.openFileInput` and our file
    containing all our data is opened.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行反序列化 - 加载数据。这一次，正如我们所预料的，该方法不接收任何参数，而是返回一个`ArrayList`实例。使用`mContext.openFileInput`创建一个`InputStream`实例，打开包含所有数据的文件。
- en: 'We use a `while` loop to append all the data to a string and use our new `Note`
    constructor, which extracts JSON data to regular primitive variables to unpack
    each `JSONObject` into a `Note` object and add it to the `ArrayList` that is returned
    to the calling code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`while`循环将所有数据附加到一个字符串中，并使用我们的新`Note`构造函数，该构造函数将JSON数据提取到常规原始变量中，以将每个`JSONObject`解包到一个`Note`对象中，并将其添加到返回给调用代码的`ArrayList`中：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You will need to add these imports:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要添加以下导入：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now all we need to do is put our new class to work in the `MainActivity` class.
    Add a new member after the `MainActivity` declaration as highlighted next. Also,
    remove the initialization of `noteList` to leave just the declaration as we will
    now initialize it with some new code in the `onCreate` method. I have commented
    out the line you need to delete:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要让我们的新类在`MainActivity`类中工作。在`MainActivity`声明之后添加一个新成员，如下所示。此外，删除`noteList`的初始化，只留下声明，因为我们现在将在`onCreate`方法中使用一些新代码来初始化它。我已经注释掉了您需要删除的行：
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, in the `onCreate` method, we initialize `mSerializer` by calling the `JSONSerializer`
    constructor with the filename and `getApplicationContext()`, which returns the
    `Context` instance of the application and is required. We can then use the `JSONSerializer
    load` method to load any saved data. Add this new, highlighted code after the
    code that handles the floating action button. This new code must come before we
    handle the `RecyclerView` instance:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`onCreate`方法中，我们通过使用文件名和`getApplicationContext()`调用`JSONSerializer`构造函数来初始化`mSerializer`，它返回应用程序的`Context`实例并且是必需的。然后我们可以使用`JSONSerializer
    load`方法来加载任何保存的数据。在处理浮动操作按钮的代码之后添加这段新的突出显示的代码。这段新代码必须出现在我们处理`RecyclerView`实例之前：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You need to import the `Log` class at this point:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此时您需要导入`Log`类：
- en: '`import android.util.Log;`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.util.Log;`'
- en: I have shown a great deal of context in the previous code because its positioning
    is essential for it to work. If you are having any problems getting this to run,
    be sure to compare it to the code in the download bundle in the [*Chapter 17*](B16773_17_ePub_RK.xhtml#_idTextAnchor300)`/java`
    folder.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，我展示了大量的上下文，因为它的定位对于它的工作是至关重要的。如果您在运行时遇到任何问题，请务必将其与[*第17章*](B16773_17_ePub_RK.xhtml#_idTextAnchor300)`/java`文件夹中的下载包中的代码进行比较。
- en: 'Now we can add a new method to our `MainActivity` class so that that we can
    call it to save all our user''s data. All this new method does is call the `save`
    method of the `JSONSerializer` class, passing in the required list of `Note` objects:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以向`MainActivity`类添加一个新的方法，这样我们就可以调用它来保存所有用户的数据。这个新方法所做的就是调用`JSONSerializer`类的`save`方法，传入所需的`Note`对象列表：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, just as we did when saving our user''s settings, we will override the
    `onPause` method to save our user''s note data. Be sure to add this code in the
    `MainActivity` class:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像我们保存用户设置时所做的那样，我们将重写`onPause`方法来保存用户的笔记数据。确保在`MainActivity`类中添加这段代码：
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: That's it. We can now run the app and add as many notes as we like. `ArrayList`
    will store them all in our running app, our `RecyclerAdapter` will manage displaying
    them in `RecyclerView`, and now JSON will take care of loading them to disk and
    loading them back as well.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们现在可以运行应用程序，并添加任意多的笔记。`ArrayList`会将它们全部存储在我们运行的应用程序中，我们的`RecyclerAdapter`将管理在`RecyclerView`中显示它们，现在JSON也会负责将它们加载到磁盘上，并加载它们回来。
- en: Frequently asked questions
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经常问的问题
- en: I didn't understand everything in this chapter – am I not cut out to be a programmer?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我并没有完全理解本章的所有内容 - 我不适合成为程序员吗？
- en: This chapter introduced many new classes, concepts, and methods. If your head
    is aching a little, that is to be expected. If some of the detail is unclear,
    don't let that hold you back. Proceed with the next couple of chapters (they are
    much more straightforward), then revisit this one and examine the completed code
    files.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了许多新的类、概念和方法。如果你的头有点疼，这是可以预料的。如果一些细节不清楚，不要让它阻碍你。继续进行接下来的几章（它们要简单得多），然后回顾这一章并检查已完成的代码文件。
- en: So, how does serialization work in detail?
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那么，序列化的详细工作原理是什么？
- en: 'Serialization really is a vast topic. It is possible to write apps your whole
    life and never really need to understand it. It is the type of topic that might
    be the subject of a computer science degree. If you are curious to know more,
    have a look at this article: [https://en.wikipedia.org/wiki/Serialization](https://en.wikipedia.org/wiki/Serialization).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化确实是一个广阔的主题。你可能一辈子都写应用程序而从未真正需要理解它。这可能是计算机科学学位的主题。如果你想了解更多，请看一下这篇文章：[https://en.wikipedia.org/wiki/Serialization](https://en.wikipedia.org/wiki/Serialization)。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At this point in our journey through the Android API, it is worth taking stock
    of what we know. We can lay out our own UI designs and choose from a wide and
    diverse range of widgets to allow the user to interact with the UI. We can create
    multiple screens as well as pop-up dialogs and we can capture comprehensive user
    data. Furthermore, we can now make this data persist.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过Android API的旅程中，现在值得回顾一下我们所知道的。我们可以布置自己的UI设计，并从各种各样的小部件中选择，让用户与UI进行交互。我们可以创建多个屏幕以及弹出对话框，并且可以捕获全面的用户数据。此外，我们现在可以使这些数据持久化。
- en: Certainly, there is a lot more to the Android API still to learn, even beyond
    what this book will teach you, but the point is that we know enough now to plan
    and implement a working app. You could just get started on your own app right
    now.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有很多关于Android API的知识需要学习，甚至超出了这本书所教授的范围，但重点是我们现在已经知道足够的知识来规划和实现一个可工作的应用程序。你现在就可以开始自己的应用程序了。
- en: If you have the urge to start your own project right away, then my advice is
    to go ahead and do it. Don't wait until you consider yourself an "expert" or more
    ready. Reading this book and, more importantly, implementing the apps will make
    you a better Android programmer, but nothing will teach you faster than designing
    and implementing your own app! It is perfectly possible to read through this book
    and work on your own project(s) simultaneously.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有立即开始自己的项目的冲动，那么我的建议是继续前进并去做。不要等到你认为自己是一个“专家”或更加准备好。阅读这本书，更重要的是，实现应用程序将使你成为一个更好的Android程序员，但没有什么比设计和实现自己的应用程序更能让你更快地学会！完全可以通过阅读这本书并同时进行自己的项目工作。
- en: In the next chapter, we will add the finishing touches to this app by making
    it multilingual. This is quite quick and easy.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过使应用程序支持多语言来为这个应用程序添加最后的修饰。这非常快速和简单。
