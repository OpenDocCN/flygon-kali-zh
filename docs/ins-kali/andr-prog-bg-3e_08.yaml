- en: '*Chapter 8*: Java Decisions and Loops'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：Java决策和循环'
- en: We have just learned about variables and we know how we can change the values
    that they hold with expressions, but how can we take a course of action dependent
    upon the value of a variable?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学习了关于变量，我们知道如何使用表达式更改它们所持有的值，但是我们如何根据变量的值采取行动呢？
- en: We can certainly add the number of new messages to the number of previously
    unread messages, but how might we, for example, trigger an action within our app
    when the user has read all their messages?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以将新消息的数量添加到先前未读消息的数量中，但是例如，当用户已读完所有消息时，我们该如何触发应用程序内的操作呢？
- en: The first problem is that we need a way to test the value of a variable and
    then respond when the value falls within a range of values or is a specific value.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是我们需要一种方法来测试变量的值，然后在值落在一系列值范围内或是特定值时做出响应。
- en: Another problem that is common in all forms of programming is that we need sections
    of our code to be executed a certain number of times (more than once or sometimes
    not at all) depending on the value of variables.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的一个常见问题是，我们需要根据变量的值执行代码的某些部分一定次数（不止一次或有时根本不执行），这取决于变量的值。
- en: To solve the first problem, we will look at making decisions in Java with `if`,
    `else`, and `switch`. To solve the latter, we will look at loops in Java with
    `while`, `do while`, `for`, and `break`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决第一个问题，我们将学习如何使用`if`、`else`和`switch`在Java中做出决定。为了解决后者，我们将学习如何使用`while`、`do
    while`、`for`和`break`在Java中进行循环。
- en: 'Coming up in this chapter, we will cover the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Making decisions with `if`, `else`, `else if`, and `switch`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`if`、`else`、`else if`和`switch`做出决策
- en: The `switch` demo app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch`演示应用程序'
- en: Java `while` loops and `do while` loops
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java的`while`循环和`do while`循环
- en: Java `for` loops
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java的`for`循环
- en: Loops demo app
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环演示应用程序
- en: Let's learn some more Java.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习更多的Java知识。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2008](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2008).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中的代码文件[https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2008](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2008)。
- en: Making decisions in Java
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java中做出决策
- en: Our Java code will constantly be making decisions. For example, we might need
    to know whether the user has new messages or whether they have a certain number
    of friends. We need to be able to test our variables to see whether they meet
    certain conditions and then execute a certain section of code depending upon whether
    they do or not.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Java代码将不断做出决定。例如，我们可能需要知道用户是否有新消息，或者是否有一定数量的朋友。我们需要能够测试我们的变量，以查看它们是否满足某些条件，然后根据它们是否满足条件来执行一定的代码部分。
- en: In this section, as our code gets more complicated, it helps to present it in
    a way that makes it more readable. Let's look at code indenting to make our discussion
    about decisions easier.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，随着我们的代码变得更加复杂，有助于以更易读的方式呈现它。让我们看看代码缩进，以使我们对决策的讨论更加容易。
- en: Indenting code for clarity
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为了清晰起见缩进代码
- en: 'You have probably noticed that the Java code in our projects is indented. For
    example, the first line of code inside the `MainActivity` class is indented by
    one tab. Also, the first line of code is indented inside each method. Here is
    an annotated screenshot to make this clear and as another quick example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们项目中的Java代码是缩进的。例如，在`MainActivity`类内的第一行代码被缩进了一个制表符。此外，每个方法内的第一行代码也被缩进。这里有一个带注释的屏幕截图，以便更清楚地说明这一点，另外一个快速的例子：
- en: '![Figure 8.1 – Indented Java code'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – 缩进的Java代码'
- en: '](img/Figure_8.1_B16773.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.1_B16773.jpg)'
- en: Figure 8.1 – Indented Java code
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 缩进的Java代码
- en: Notice also that when the indented block has ended, often with a closing curly
    brace, `}`,the `}` is indented to the same extent as the line of code that began
    the block.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，当缩进块结束时，通常是用一个闭合大括号`}`，`}`的缩进程度与开始块的代码行相同。
- en: We do this to make the code more readable. It is not part of the Java syntax,
    however, and the code will still compile if we don't do this.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是为了使代码更易读。但是，这并不是Java语法的一部分，如果我们不这样做，代码仍将编译。
- en: As our code gets more complicated, indenting, along with comments, helps to
    keep the meaning and structure of our code clear. I mention this now because when
    we start to learn the syntax for making decisions in Java, indenting becomes especially
    useful and it is recommended that you indent your code the same way.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的代码变得更加复杂，缩进和注释有助于保持代码的含义和结构清晰。我现在提到这一点是因为当我们开始学习在Java中做出决定的语法时，缩进变得特别有用，建议您以相同的方式缩进代码。
- en: Much of this indenting is done for us by Android Studio but not all of it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分缩进是由Android Studio为我们完成的，但并非全部。
- en: Now we know how to present our code more clearly, let's learn about some more
    operators, and then we can really get to work with making decisions with Java.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何更清晰地呈现我们的代码，让我们学习一些更多的运算符，然后我们可以真正开始使用Java做出决定。
- en: More operators
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多运算符
- en: We can already add (+), take away (-), multiply (*), divide (/), assign (=),
    increment (++), and decrement (--) with operators. Let's introduce some more useful
    operators, and then we will go straight into actually understanding how to use
    them in Java.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经可以使用运算符进行加（+）、减（-）、乘（*）、除（/）、赋值（=）、增量（++）和减量（--）。让我们介绍一些更有用的运算符，然后我们将直接了解如何在Java中使用它们。
- en: Important Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Don't worry about memorizing every operator that follows. Glance over them and
    their explanations and then move quickly on to the next section. There, we will
    put some operators to use and they will become much clearer as we see a few examples
    of what they allow us to do. They are presented here in a list so they are more
    convenient to refer back to when not intermingled with the discussion about implementation
    that follows.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心记住每个后面的运算符。浏览它们和它们的解释，然后快速转到下一节。在那里，我们将使用一些运算符，当我们看到它们允许我们做一些例子时，它们将变得更清晰。它们在这里以列表的形式呈现，这样在不与后面的实现讨论混在一起时更方便参考。
- en: 'We use operators to create an expression that is either true or false. We wrap
    that expression in parentheses like this: `(expression goes here)`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用运算符创建一个表达式，这个表达式要么为真，要么为假。我们用括号括起来，就像这样：`(表达式在这里)`
- en: The comparison operator
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较运算符
- en: 'This is the comparison operator and it tests for equality; it is either true
    or false: `==`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是比较运算符，用于测试是否相等；它要么为真，要么为假：`==`
- en: An expression such as `(10 == 9)`, for example, is false. 10 is obviously not
    equal to 9\. However, an expression such as `(2 + 2 == 4)` is obviously true.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，表达式`(10 == 9)`是假的。10显然不等于9。然而，表达式`(2 + 2 == 4)`显然是真的。
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Except in *1984* when 2 + 2 == 5 ([https://en.wikipedia.org/wiki/Nineteen_Eighty-Four](https://en.wikipedia.org/wiki/Nineteen_Eighty-Four)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了《1984》中2 + 2 == 5 ([https://en.wikipedia.org/wiki/Nineteen_Eighty-Four](https://en.wikipedia.org/wiki/Nineteen_Eighty-Four))。
- en: The logical NOT operator
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑NOT运算符
- en: 'This is the logical NOT operator: `!`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是逻辑NOT运算符：`!`
- en: It is used to test the negation of an expression. Negation means if the expression
    is false, then the NOT operator causes the expression to be true. An example will
    help.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 它用于测试表达式的否定。否定意味着如果表达式为假，那么NOT运算符会使表达式为真。举个例子会有所帮助。
- en: The expression `(!(2 + 2 == 5))` evaluates to true because 2 + 2 *is NOT* 5\.
    But a further example of `(!(2 + 2 = 4))` would be false. This is because 2 +
    2 obviously *is* 4.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`(!(2 + 2 == 5))`计算为真，因为2 + 2 *不是*5。但进一步的例子`(!(2 + 2 = 4))`将是假的。这是因为2 + 2显然*是*4。
- en: The NOT equal operator
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不等运算符
- en: 'This is the NOT equal operator and it is another comparison operator: `!=`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不等运算符，是另一个比较运算符：`!=`
- en: The NOT equal operator tests whether something is NOT equal. For example, the
    expression `(10 != 9)` is true. 10 is not equal to 9\. On the other hand, `(10
    != 10)` is false because 10 clearly is equal to 10.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不等运算符测试是否不相等。例如，表达式`(10 != 9)`是真的。10不等于9。另一方面，`(10 != 10)`是假的，因为10显然等于10。
- en: The greater than operator
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大于运算符
- en: 'Another comparison operator (and there are a few more as well) is the greater
    than operator. Here it is: `>`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个比较运算符（还有一些其他的）是大于运算符。它是这样的：`>`
- en: This operator tests whether something is greater than something else. The expression
    `(10 > 9)` is true but the expression `(9 > 10)` is false.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符测试是否一个值大于另一个值。表达式`(10 > 9)`是真的，但表达式`(9 > 10)`是假的。
- en: The less than operator
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小于运算符
- en: 'You can probably guess that this operator tests for values being less than
    others. This is what the operator looks like: `<`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能猜到了，这个运算符测试值是否小于其他值。这就是这个运算符的样子：`<`
- en: The expression `(10 < 9)` is false because 10 is not less than 9, while the
    expression `(9 < 10)` is true.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`(10 < 9)`是假的，因为10不小于9，而表达式`(9 < 10)`是真的。
- en: The greater than or equal to operator
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大于或等于运算符
- en: 'This operator tests whether one value is greater than or equal to another and
    if either is true, the result is true. This is what the operator looks like: `>=`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符测试一个值是否大于或等于另一个值，如果其中一个为真，结果就为真。这就是这个运算符的样子：`>=`
- en: As an example, the expression `(10 >= 9)` is true, the expression `(10 >= 10)`
    is also true, but the expression `(10 >= 11)` is false because 10 is neither greater
    than nor equal to 11.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，表达式`(10 >= 9)`是真的，表达式`(10 >= 10)`也是真的，但表达式`(10 >= 11)`是假的，因为10既不大于也不等于11。
- en: The less than or equal to operator
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小于或等于运算符
- en: 'Like the previous operator, this one tests for two conditions but this time
    less than or equal to. Look at the operator shown next and then we will see some
    examples: `<=`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个运算符类似，这个运算符测试两个条件，但这次是小于或等于。看看下面显示的运算符，然后我们将看一些例子：`<=`
- en: The expression `(10 <= 9)` is false, the expression `(10 <= 10)` is true, and
    the expression `(10 <= 11)` is also true.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`(10 <= 9)`是假的，表达式`(10 <= 10)`是真的，表达式`(10 <= 11)`也是真的。
- en: The logical AND operator
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑AND运算符
- en: 'This operator is known as logical AND. It tests two or more separate parts
    of an expression and all parts must be true for the entire expression to be true:
    `&&`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符被称为逻辑AND。它测试表达式的两个或多个单独部分，所有部分必须为真，整个表达式才为真：`&&`
- en: Logical AND is usually used in conjunction with the other operators to build
    more complex tests. The expression `((10 > 9) && (10 < 11))` is true because both
    parts are true. On the other hand, the expression `((10 > 9) &&` `(10 < 9))` is
    false because only one part of the expression is true, `(10 > 9)`, and the other
    is false, `(10 < 9)`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑AND通常与其他运算符一起使用，构建更复杂的测试。表达式`((10 > 9) && (10 < 11))`是真的，因为两个部分都为真。另一方面，表达式`((10
    > 9) && (10 < 9))`是假的，因为表达式的一个部分为真`(10 > 9)`，另一个部分为假`(10 < 9)`。
- en: The logical OR operator
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑OR运算符
- en: 'This operator is called logical OR and it is just like logical AND except that
    only one of two or more parts of an expression needs to be true for the expression
    to be true: `||`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符称为逻辑OR，它与逻辑AND类似，只是表达式的两个或多个部分中只有一个为真，表达式才为真：`||`
- en: Let's look at the last example we used for logical AND but switch the `&&` for
    `||`. The expression `((10 > 9) || (10 < 9))` is now true because at least one
    part of the expression is true.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下我们用于逻辑AND的最后一个例子，但将`&&`换成`||`。表达式`((10 > 9) || (10 < 9))`现在是真的，因为表达式的至少一个部分是真的。
- en: The modulus operator
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模数运算符
- en: This operator is called modulus (`%`). It returns the remainder of two numbers
    after dividing them. For example, the expression `(16 % 3 > 0)` is true because
    16 divided by 3 is 5 remainder 1 and 1 is, of course, greater than 0.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符叫做模数（`%`）。它返回两个数字相除后的余数。例如，表达式`(16 % 3 > 0)`是真的，因为16除以3是5余1，而1当然大于0。
- en: Seeing these operators in a more practical context in this chapter and throughout
    the rest of the book will help clarify the different uses. Now we know how to
    form expressions with operators, variables, and values. Next, we can look at a
    way of structuring and combining expressions to make some deep decisions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和本书的其余部分中，以更实际的情境看到这些运算符将有助于澄清不同的用途。现在我们知道如何使用运算符，变量和值来形成表达式。接下来，我们可以看一种结构化和组合表达式的方法来做出一些深刻的决定。
- en: How to use all these operators to test variables
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用所有这些运算符来测试变量
- en: All these operators are virtually useless without a way of properly using them
    to make real decisions that affect real variables and code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些运算符在没有适当使用它们来影响真实变量和代码的真实决策的方法的情况下几乎是无用的。
- en: Now we have all the information we need, we can look at a hypothetical situation,
    then actually see some code for decision making.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有需要的信息，我们可以看一个假设的情况，然后实际看到一些决策的代码。
- en: Using the Java if keyword
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Java的if关键字
- en: As we saw, operators serve very little purpose on their own, but it was probably
    useful to see just part of the wide and varied range available to us. Now, when
    we look at putting the most common operator, `==`, to use, we can start to see
    the powerful yet fine control that operators offer us.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，运算符单独使用几乎没有什么意义，但可能有用的是看到我们可以使用的广泛和多样的范围的一部分。现在，当我们开始使用最常见的运算符`==`时，我们可以开始看到运算符提供给我们的强大而精细的控制。
- en: Let's make the previous examples less abstract. Meet the Java `if` keyword.
    We will use `if` and a few conditional operators along with a small story to demonstrate
    their use. Next follows a made-up military situation that will hopefully be less
    abstract than the previous examples.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把之前的例子变得不那么抽象。见识一下Java的`if`关键字。我们将使用`if`和一些条件运算符以及一个小故事来演示它们的用法。接下来是一个虚构的军事情况，希望它会比之前的例子更具体。
- en: The captain is dying and, knowing that his remaining subordinates are not very
    experienced, he decides to write a Java program to convey his last orders after
    he has died. The troops must hold one side of a bridge while awaiting reinforcements
    – but with a few rules that determine their actions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 船长快要死了，知道他剩下的下属经验不是很丰富，他决定写一个Java程序，在他死后传达他的最后命令。部队必须守住桥的一侧，等待增援 - 但有一些规则来决定他们的行动。
- en: 'The first command the captain wants to make sure his troops understand is this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 船长想要确保他的部队理解的第一个命令是：
- en: '**If they come over the bridge, shoot them.**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果他们过桥，就射击他们。**'
- en: So, how do we simulate this situation in Java? We need a Boolean variable, `isComingOverBridge`.
    The next bit of code assumes that the `isComingOverBridge` variable has been declared
    and initialized to either `true` or `false`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在Java中模拟这种情况呢？我们需要一个布尔变量，`isComingOverBridge`。下一段代码假设`isComingOverBridge`变量已经被声明并初始化为`true`或`false`。
- en: 'We can then use `if` like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以这样使用`if`：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If the `isComingOverBridge` Boolean is `true`, the code inside the opening and
    closing curly braces will execute. If `isComingOverBridge` is `false`, the program
    continues after the `if` block, without running the code within it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`isComingOverBridge`布尔值为`true`，则在大括号内的代码将执行。如果`isComingOverBridge`为`false`，程序将在`if`块之后继续执行，而不运行其中的代码。
- en: '**Else do this instead**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**否则，做这个**'
- en: The captain also wants to tell his troops what to do if the enemy is not coming
    over the bridge. In this situation, he wants them to stay where they are and wait.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 船长还想告诉他的部队，如果敌人没有过桥，他们应该留在原地等待。
- en: Now we introduce another Java keyword, `else`. When we want to explicitly do
    something when `if` does not evaluate to true, we can use `else`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们介绍另一个Java关键字，`else`。当我们想要在`if`不为真时明确执行某些操作时，我们可以使用`else`。
- en: 'For example, to tell the troops to stay put if the enemy is not coming over
    the bridge, we could write this code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要告诉部队如果敌人没有过桥就待在原地，我们可以写这段代码：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The captain then realizes that the problem isn't as simple as he first thought.
    What if the enemy comes over the bridge but has too many troops? His squad would
    be overrun and slaughtered.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 船长随后意识到问题并不像他最初想的那么简单。如果敌人过桥，但部队太多怎么办？他的小队将被压垮和屠杀。
- en: 'So, he comes up with this code (we''ll use some variables as well this time):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，他想出了这段代码（这次我们也会使用一些变量）：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code has three possible paths of execution. The first is if the
    enemy is coming over the bridge and the friendly troops are greater in number:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码有三条可能的执行路径。第一种情况是如果敌人正在过桥，友军人数更多：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The second is if the enemy troops are coming over the bridge but outnumber
    the friendly troops:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况是如果敌军正在过桥，但超过了友军的人数：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then, the third and final possible outcome that will execute if neither of the
    others is true is captured by the final `else` without an `if` condition.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果其他两种情况都不成立，将执行第三种可能的结果，由最终的`else`捕获，没有`if`条件。
- en: Reader challenge
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 读者挑战
- en: 'Can you spot a flaw with the preceding code? One that might leave a bunch of
    inexperienced troops in complete disarray? The possibility of the enemy troops
    and friendly troops being exactly equal in number has not been handled explicitly
    and would therefore be handled by the final `else`, which is meant for when there
    are no enemy troops. I guess any self-respecting captain would expect his troops
    to fight in this situation and he could have changed the first `if` statement
    to accommodate this possibility:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您能发现上述代码的一个缺陷吗？这可能会让一群经验不足的部队陷入彻底的混乱？敌军和友军的数量恰好相等的可能性没有得到明确处理，因此将由最终的`else`处理，这是指当没有敌军时。我猜任何自尊的船长都会期望他的部队在这种情况下进行战斗，他可以改变第一个`if`语句以适应这种可能性：
- en: '`if(isComingOverBridge && friendlyTroops >= enemyTroops)`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`if(isComingOverBridge && friendlyTroops >= enemyTroops)`'
- en: 'Finally, the captain''s last concern is that if the enemy comes over the bridge
    waving the white flag of surrender and is promptly slaughtered, then his men would
    end up as war criminals. The Java code needed is obvious. Using the `wavingWhiteFlag`
    Boolean variable, he writes this test:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，船长最后关心的是，如果敌人挥舞着白旗过桥，然后被迅速屠杀，那么他的士兵最终会成为战争罪犯。所需的Java代码是显而易见的。使用`wavingWhiteFlag`布尔变量，他编写了这个测试：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'But where to put this code is less clear. In the end, the captain opts for
    the following nested solution and changes the test for `wavingWhiteFlag` to logical
    NOT, like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，放置这段代码的位置不太清楚。最后，船长选择了以下嵌套解决方案，并将`wavingWhiteFlag`的测试更改为逻辑非，就像这样：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This demonstrates that we can nest `if` and `else` statements inside of one
    another to create quite deep and detailed decisions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们可以嵌套`if`和`else`语句，以创建相当深入和详细的决定。
- en: We could go on making more and more complicated decisions with `if` and `else`
    but what we have seen is more than sufficient as an introduction.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续使用`if`和`else`做出更复杂的决定，但是我们已经看到的已经足够作为介绍了。
- en: It is probably worth pointing out that very often there is more than one way
    to arrive at a solution to a problem. The *right* way will usually be the way
    that solves the problem in the clearest and simplest manner.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，很多时候解决问题有多种方法。*正确*的方法通常是以最清晰和最简单的方式解决问题的方法。
- en: Let's look at some other ways to make decisions in Java, and then we can put
    them all together in an app.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在Java中做出决定的其他方法，然后我们可以将它们全部放在一个应用程序中。
- en: Switching to make decisions
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换以做出决定
- en: We have seen the vast and virtually limitless possibilities of combining the
    Java operators with `if` and `else` statements. But sometimes a decision in Java
    can be better made in other ways.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了结合Java运算符与`if`和`else`语句的广泛且几乎无限的可能性。但有时，在Java中做出决定可能有其他更好的方法。
- en: When we are deciding based on a clear list of possibilities that don't involve
    complex combinations, `switch` is usually the way to go.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们根据一系列清晰的可能性做出决定时，不涉及复杂的组合，通常使用`switch`是最好的方法。
- en: 'We start a `switch` decision like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始一个`switch`决定就像这样：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the previous example, `argument` could be an expression or a variable. Within
    the curly braces, `{}`, we can make decisions based on the argument with `case`
    and `break` elements:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，`argument`可以是一个表达式或一个变量。在花括号`{}`内，我们可以根据`case`和`break`元素对参数做出决定：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see in the previous example that each `case` states a possible result
    and each `break` denotes the end of that case, as well as the point at which no
    further `case` statements should be evaluated.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到在上一个例子中，每个`case`都陈述了可能的结果，每个`break`都表示该案例的结束，以及不应再评估更多`case`语句的点。
- en: The first `break` encountered breaks out of the `switch` block to proceed with
    the next line of code after the closing brace, `}`, of the entire `switch` block.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到的第一个`break`会跳出`switch`块，继续执行整个`switch`块的结束花括号`}`后的下一行代码。
- en: 'We can also use `default` without a value to run some code in case none of
    the `case` statements evaluate to true, like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用没有值的`default`来运行一些代码，以防`case`语句都不为真，就像这样：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's write a quick demo app that uses `switch`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个快速演示应用程序，使用`switch`。
- en: The switch demo app
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切换演示应用程序
- en: To get started, create a new Android project called `Switch` `Demo`, use the
    `MainActivity.java` file by left-clicking on the **MainActivity.java** tab above
    the editor and we can start coding.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时，创建一个名为`Switch` `Demo`的新Android项目，使用上面编辑器中的**MainActivity.java**选项卡左键单击**MainActivity.java**文件，我们就可以开始编码了。
- en: Let's pretend we are writing an old-fashioned text adventure game, the kind
    of game where the player types commands such as "Go East," "Go West," "Take Sword,"
    and so on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在编写一个老式的文字冒险游戏，玩家在游戏中输入命令，比如“向东走”，“向西走”，“拿剑”等等。
- en: In this case, `switch` could handle that situation with something such as this
    example code and we could use `default` to handle the player typing a command
    that is not specifically handled.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`switch`可以处理这种情况，例如这个示例代码，我们可以使用`default`来处理玩家输入的命令，这些命令没有特别处理。
- en: 'Enter the following code in the `onCreate` method just before the closing curly
    brace, `}`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在`}`之前的`onCreate`方法中输入以下代码：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the app a few times. Each time, change the initialization of `command` to
    something new. Notice that when you initialize `command` to something that is
    explicitly handled by a `case` statement, we get the expected output. Otherwise,
    we get the default **Sorry I don't speak Elfish** message.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序几次。每次，将`command`的初始化更改为新内容。请注意，当您将`command`初始化为`case`语句明确处理的内容时，我们会得到预期的输出。否则，我们会得到默认的**抱歉，我不会说精灵语**消息。
- en: 'If we had a lot of code to execute for `case`, we could contain it all in a
    method – perhaps like in this next piece of code, where I have highlighted the
    new line:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有很多要执行的`case`代码，我们可以将所有代码都包含在一个方法中-也许就像在下一段代码中一样，我已经突出显示了新的一行：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Of course, we would then need to write the new `goWest` method. Then, when `command`
    is initialized to `"go west"`, the `goWest` method would be executed, and when
    `goWest` completes, execution would return to the `break` statement, which would
    cause the code to continue after the `switch` block.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们随后需要编写新的“goWest”方法。然后，当“command”初始化为“go west”时，“goWest”方法将被执行，当“goWest”完成时，执行将返回到“break”语句，这将导致代码继续执行“switch”块后的内容。
- en: Of course, one of the things this code seriously lacks is interaction with a
    UI. We have seen how we can call methods from button clicks but even that isn't
    enough to make this code worthwhile in a real app. We will see how we solve this
    problem in [*Chapter 12*](B16773_12_ePub_RK.xhtml#_idTextAnchor218), *The Stack,
    the Heap, and the Garbage Collector*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这段代码严重缺乏与UI的交互。我们已经看到了如何从按钮点击中调用方法，但即使这样也不足以使这段代码在真正的应用程序中有价值。我们将在第12章《堆栈、堆和垃圾收集器》中看到我们如何解决这个问题。
- en: The other problem we have is that after the code has been executed, that's it!
    We need it to continually ask the player for instructions, not just once but over
    and over. We will look at a solution to this problem next.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有的另一个问题是，代码执行后就结束了！我们需要它不断地询问玩家的指令，不仅仅是一次，而是一遍又一遍。我们将在下一节中解决这个问题。
- en: Repeating code with loops
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用循环重复代码
- en: Here we will learn how to repeatedly execute portions of our code in a controlled
    and precise way by looking at several types of `while` loops, `do while` loops,
    and `for` loops. We will also learn about the most appropriate situations to use
    the different types of loops.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将学习如何通过查看几种类型的“while”循环、“do while”循环和“for”循环，以受控且精确的方式重复执行我们代码的部分。我们还将了解使用不同类型的循环的最合适的情况。
- en: It would be completely reasonable to ask what loops have to do with programming.
    But they are exactly what the name implies. They are a way of repeating the same
    part of the code more than once – or looping over the same part of code although
    potentially for a different outcome each time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 问循环与编程有什么关系是完全合理的。但它们确实如其名所示。它们是一种重复执行代码的方式——或者循环执行相同的代码部分，尽管每次可能有不同的结果。
- en: This can simply mean doing the same thing until the code being looped over (`if`,
    `else`, and `switch`, loops are part of the Java **control flow statements**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能意味着重复执行相同的操作，直到被循环的代码（if、else和switch，循环是Java的**控制流语句**的一部分。
- en: 'The code that executes when a condition is true is known as the `do while`
    loop), can be illustrated by this simple diagram:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件为真时执行的代码称为“do while”循环，可以用这个简单的图表来说明：
- en: '![Figure 8.2 – The condition is tested when the loop is reached in the code'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 - 当代码中达到循环时，条件被测试'
- en: '](img/Figure_8.2_B16773.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.2_B16773.jpg)'
- en: Figure 8.2 – The condition is tested when the loop is reached in the code
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 - 当代码中达到循环时，条件被测试
- en: This diagram illustrates that when the loop is reached in the code, the condition
    is tested. If the condition is true, the conditional code is executed. After the
    conditional code is executed, the condition is tested again. Any time the condition
    is false, the code continues after the loop. This could mean that the conditional
    code is never executed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表说明了当代码中达到循环时，条件被测试。如果条件为真，则执行条件代码。执行条件代码后，再次测试条件。任何时候条件为假，代码继续执行循环后的内容。这可能意味着条件代码从未执行。
- en: We will look at all the major types of loops that Java offers us to control
    our code and we will use some of them to implement a working mini-app to make
    sure we understand them completely. Let's look at the first and simplest loop
    type in Java, called the `while` loop.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究Java提供的所有主要类型的循环，以控制我们的代码，并使用其中一些来实现一个工作迷你应用程序，以确保我们完全理解它们。让我们先看看Java中的第一种和最简单的循环类型，称为“while”循环。
- en: while loops
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: while循环
- en: 'Java `while` loops have the simplest syntax. Think back to the `if` statements
    for a moment. We could put virtually any combination of operators and variables
    in the conditional expression of the `if` statement. If the expression evaluates
    to true, then the code in the body of the `if` block is executed. With the `while`
    loop, we also use an expression that can evaluate to true or false. Look at this
    code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Java“while”循环具有最简单的语法。回想一下“if”语句。我们可以在“if”语句的条件表达式中放置几乎任何组合的运算符和变量。如果表达式求值为真，则执行“if”块中的代码。对于“while”循环，我们也使用一个可以求值为真或假的表达式。看看这段代码：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'What happens here is this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的是：
- en: Outside of the `while` loop, an `int` named `x` is declared and initialized
    to `10`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“while”循环之外，声明并初始化了一个名为“x”的整数，其值为“10”。
- en: Then, the `while` loop begins. Its condition is `x > 0`. So, the `while` loop
    will execute the code in its body.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，“while”循环开始。它的条件是“x > 0”。因此，“while”循环将执行其循环体中的代码。
- en: The code in its body will continue to execute until the condition evaluates
    to false.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其循环体中的代码将继续执行，直到条件求值为假。
- en: So, the previous code will execute 10 times.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，先前的代码将执行10次。
- en: On the first pass, `x = 10`, on the second pass it equals `9`, then `8`, and
    so on. But once `x` is equal to `0`, it is of course no longer greater than 0\.
    At this point, the program will exit the `while` loop and continue with the first
    line of code after the `while` loop.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次通过时，“x = 10”，在第二次通过时它等于“9”，然后是“8”，依此类推。但一旦“x”等于“0”，它当然不再大于0。此时，程序将退出“while”循环，并继续执行“while”循环后的第一行代码。
- en: 'Just like an `if` statement, it is possible that the `while` loop will not
    execute even once. Look at this example where the code in the `while` loop will
    not execute:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 就像“if”语句一样，可能“while”循环甚至不执行一次。看看这个例子，其中“while”循环中的代码不会执行：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Moreover, there is no limit to the complexity of the conditional expression
    or the amount of code that can go in the loop body. Here is another example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，条件表达式的复杂程度或循环体中的代码量是没有限制的。这里是另一个例子：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding `while` loop would continue to execute until both `newMessages`
    and `unreadMessages` are equal to or less than 0\. As the condition uses the logical
    OR operator, `||`, either one of those conditions being true will cause the `while`
    loop to continue executing.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`while`循环将继续执行，直到`newMessages`和`unreadMessages`都等于或小于0。由于条件使用了逻辑或运算符`||`，其中一个条件为真将导致`while`循环继续执行。
- en: 'It is worth noting that once the body of the loop has been entered, it will
    always complete even if the expression evaluates to false partway through, as
    it is not tested again until the code tries to start another pass. Take the following
    example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，一旦进入循环体，即使表达式在中途评估为false，循环体也会始终完成，因为直到代码尝试开始另一个循环时才会再次测试。看下面的例子：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding loop body will execute exactly once. We can also set a `while`
    loop that will run forever! This perhaps unsurprisingly is called an infinite
    loop. Here is an example of an infinite loop:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的循环体将执行一次。我们还可以设置一个永远运行的`while`循环！这或许不足为奇地被称为无限循环。以下是一个无限循环的例子：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Breaking out of a loop
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳出循环
- en: 'We might use an infinite loop like this so that we can decide when to exit
    the loop from a test contained within its body. We would do this by using the
    `break` keyword when we are ready to leave the loop''s body. Here is an example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会像这样使用无限循环，这样我们可以决定何时从其体内的测试中退出循环。当我们准备离开循环体时，我们将使用`break`关键字。这是一个例子：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You might have been able to guess that we can combine any of the decision-making
    tools such as `if`, `else`, and `switch` within our `while` loops and all the
    rest of the loops we will look at in a minute. Take the following example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到，我们可以在`while`循环和我们即将看到的所有其他循环中结合使用任何决策工具，比如`if`、`else`和`switch`。看下面的例子：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It would be simple to go on for many more pages demonstrating the versatility
    of `while` loops but at some point, we want to get back to doing some real programming.
    So here is one last concept combined with `while` loops.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 演示`while`循环的多样性可能会简单地继续下去很多页，但在某个时候，我们想要回到做一些真正的编程。所以这是与`while`循环结合的最后一个概念。
- en: The continue keyword
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: continue关键字
- en: 'The `break` – up to a point. The `continue` keyword will break out of the loop
    body but will also check the condition expression afterward so the loop can run
    again. An example will help:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` - 有一个限制。`continue`关键字将跳出循环体，但之后也会检查条件表达式，所以循环可以再次运行。举个例子：'
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: do while loops
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: do while循环
- en: 'A `do while` loop is very much the same as `while` loops with the exception
    that a `do` `while` loop evaluates its expression *after* the body. Look at this
    modification of the previous figure that represents the flow of a `do while` loop:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`do while`循环与`while`循环非常相似，唯一的区别是`do` `while`循环在*循环体之后*评估其表达式。看看下面修改的前一个图，它表示了`do
    while`循环的流程：'
- en: '![Figure 8.3 – do while loop'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 - do while循环'
- en: '](img/Figure_8.3_B16773.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.3_B16773.jpg)'
- en: Figure 8.3 – do while loop
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 - do while循环
- en: 'This means that a `do while` loop will always execute the conditional code
    at least once before checking the loop condition:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`do while`循环在检查循环条件之前至少会执行一次条件代码：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the previous code, the loop was executed even though the test was false because
    the test is done after the execution of the loop. The test did, however, prevent
    the loop body from being executed a second time. This caused `x` to be incremented
    once and `x` now equals `2`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，即使测试为false，循环也会执行，因为测试是在循环执行之后进行的。然而，测试阻止了循环体再次执行。这导致`x`增加了一次，现在`x`等于`2`。
- en: Important Note
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that `break` and `continue` can also be used in `do while` loops.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`break`和`continue`也可以在`do while`循环中使用。
- en: The next type of loop we will cover is the `for` loop.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的下一种循环类型是`for`循环。
- en: for loops
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: for循环
- en: 'A `for` loop has a slightly more complicated syntax than the `while` or `do
    while` loops as it takes three parts to initialize. Have a look at the code first,
    then we will break it apart:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的语法比`while`或`do while`循环稍微复杂一些，因为它需要三个部分来初始化。先看看代码，然后我们将把它分解开来：'
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The slightly more complicated form of the `for` loop is clearer when put like
    this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微复杂一点的`for`循环形式在这样表述时更清晰：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To clarify further, we have the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步澄清，我们有以下内容：
- en: '`declaration and initialization`: We create a new `int` variable, `i`,and initialize
    it to 0.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`声明和初始化`：我们创建一个新的`int`变量`i`，并将其初始化为0。'
- en: '`condition`: Just like the other loops, it refers to the condition that must
    evaluate to true for the loop to continue.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`条件`：就像其他循环一样，它指的是必须为真的条件，循环才能继续。'
- en: '`change after each pass through the loop`: In the example, `i++` means that
    1 is added/incremented to `i` on each pass. We could also use `i--` to reduce/decrement
    `i` at each pass:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`每次通过循环后更改`：在例子中，`i++`表示在每次通过循环时向`i`添加/递增1。我们也可以使用`i--`在每次通过循环时减少/递减`i`：'
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Important Note
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that `break` and `continue` can also be used in `for` loops.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`break`和`continue`也可以在`for`循环中使用。
- en: The `for` loop takes control of initialization, condition evaluation, and the
    modification of the variable.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环控制初始化、条件评估和变量的修改。'
- en: Loops demo app
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环演示应用程序
- en: To get started, create a new Android project called `Loops`, use the **Empty
    Activity** template, and leave all the other settings at their default.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`Loops`的新Android项目，使用**Empty Activity**模板，并将所有其他设置保持默认。
- en: 'Let''s add a few buttons to our UI to make this more fun. Switch to the `activity_main.xml`
    file and make sure you are on the **Design** tab, and then follow these steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在UI中添加一些按钮，使其更有趣。切换到`activity_main.xml`文件，并确保你在**Design**选项卡上，然后按照以下步骤进行：
- en: Drag a button onto the UI and center it horizontally near the top.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个按钮拖放到UI上，并在水平方向靠近顶部居中。
- en: In the properties window, change the `Count Up`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在属性窗口中，更改`Count Up`。
- en: In the properties window, change the `countUp`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在属性窗口中，更改`countUp`。
- en: Place a new button just below the previous one and repeat *steps 2* and *3*
    but this time use `Count Down` for the `countDown` for the **onClick** property.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一个按钮的正下方放置一个新按钮，并重复*步骤2*和*3*，但这次在**onClick**属性中使用`Count Down`作为`countDown`的文本属性。
- en: Place a new button just below the previous one and repeat *steps 2* and *3*
    but this time use **nested** for the **text** property and the **onClick** property.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一个按钮的正下方放置一个新按钮，并重复*步骤2*和*3*，但这次在**text**属性中使用**nested**，在**onClick**属性中使用**nested**。
- en: Click the **Infer Constraints** button to constrain the three buttons in position.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**推断约束**按钮以约束三个按钮的位置。
- en: 'Looks are not important for this demo but run the app and check that the layout
    looks something like in the following screenshot:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 外观对于这个演示并不重要，但运行应用程序并检查布局是否与以下截图类似是很重要的：
- en: '![Figure 8.4 – Buttons added to the UI'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4 – 添加到UI的按钮'
- en: '](img/Figure_8.4_B16773.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.4_B16773.jpg)'
- en: Figure 8.4 – Buttons added to the UI
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 添加到UI的按钮
- en: Important Note
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: I also deleted the "Hello World!" `TextView` but this is not necessary.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我还删除了“Hello World!”的`TextView`，但这并不是必要的。
- en: What is important is that we have three buttons labeled **COUNT UP**, **COUNT
    DOWN**, and **NESTED**, which call methods named **countUp**, **countDown**, and
    **nested**, respectively.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们有三个按钮，标有**COUNT UP**、**COUNT DOWN**和**NESTED**，分别调用名为**countUp**、**countDown**和**nested**的方法。
- en: Switch to the `MainActivity.java` file by left-clicking the **MainActivity.java**
    tab above the editor and we can start coding our methods.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过左键单击编辑器上方的**MainActivity.java**标签切换到`MainActivity.java`文件，我们可以开始编写我们的方法。
- en: 'After the closing curly brace of the `onCreate` method, add the `countUp` method
    shown next:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`方法的闭合大括号之后，添加下面显示的`countUp`方法：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Important Note
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Import the `Log` and `View` classes using your preferred method:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的方法导入`Log`和`View`类：
- en: '`import android.util.Log;`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.util.Log;`'
- en: '`import android.view.View;`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.view.View;`'
- en: We will be able to call this method we have just written from the appropriately
    labeled button.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够从相应标记的按钮中调用我们刚刚编写的方法。
- en: 'After the closing curly brace of the `countUp` method, add the `countDown`
    method:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在`countUp`方法的闭合大括号之后，添加`countDown`方法：
- en: '[PRE25]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We will be able to call this method we have just written from the appropriately
    labeled button.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够从相应标记的按钮中调用我们刚刚编写的方法。
- en: 'After the closing curly brace of the `countDown` method, add the `nested` method:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在`countDown`方法的闭合大括号之后，添加`nested`方法：
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We will be able to call this method we have just written from the appropriately
    labeled button.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够从相应标记的按钮中调用我们刚刚编写的方法。
- en: 'Now, let''s run the app and start tapping buttons. If you tap each of the buttons
    once from top to bottom, this is the console output you will see:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行应用程序并开始点击按钮。如果你从上到下依次点击每个按钮一次，你将看到以下控制台输出：
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can see that the `countUp` method does exactly that. The `int x` variable
    is initialized to `0`, an infinite `while` loop is entered, and `x` is incremented
    with the increment `++` operator. Fortunately, on each iteration of the loop,
    we test for `x` being equal to `3` with `if (x == 3)` and break when this is true.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`countUp`方法确实做到了这一点。`int x`变量初始化为`0`，进入无限的`while`循环，并使用递增`++`运算符递增`x`。幸运的是，在循环的每次迭代中，我们使用`if
    (x == 3)`测试`x`是否等于`3`，并在这成立时中断。
- en: Next, in the `countDown` method, we do the same in reverse. The `int x` variable
    is initialized to `4`, an infinite `while` loop is entered, and `x` is decremented
    with the decrement `--` operator. This time, on each iteration of the loop, we
    test for `x` being equal to `1` with `if (x == 1)` and break when this is true.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`countDown`方法中，我们以相反的方式做同样的事情。`int x`变量初始化为`4`，进入无限的`while`循环，并使用递减`--`运算符递减`x`。这次，在循环的每次迭代中，我们使用`if
    (x == 1)`测试`x`是否等于`1`，并在这成立时中断。
- en: 'Finally, we nest two `for` loops within each other. We can see from the output
    that each time `i` (which is controlled by the outer loop) is incremented, `j`
    (which is controlled by the inner loop) is decremented from `3` to `1`. Look carefully
    at this screenshot, which shows where the start and end of each `for` loop is,
    to help fully understand this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在彼此之间嵌套了两个`for`循环。我们可以从输出中看到，每当`i`（由外部循环控制）增加时，`j`（由内部循环控制）从`3`减少到`1`。仔细观察这个截图，它显示了每个`for`循环的开始和结束的位置，以帮助完全理解这一点：
- en: '![Figure 8.5 – for loop'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 – for循环'
- en: '](img/Figure_8.5_B16773.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.5_B16773.jpg)'
- en: Figure 8.5 – for loop
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – for循环
- en: You can, of course, keep tapping to observe each button's output for as long
    as you like. As an experiment, try making the loops longer, perhaps `1000`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以继续点击观察每个按钮的输出，时间长短由你决定。作为一个实验，尝试让循环更长，也许是`1000`。
- en: With loops thoroughly learned and tested, let's look at the finer details of
    methods in the next chapter.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过彻底学习和测试循环，让我们在下一章中看看方法的更细节。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to use `if`, `else`, and `switch` to make decisions
    with expressions and branch our code. We saw and practiced `while`, `for`, and
    `do while` to repeat parts of our code. Then we put it all together in two quick
    demo apps.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用`if`、`else`和`switch`来根据表达式做出决策并分支我们的代码。我们看到并练习了`while`、`for`和`do
    while`来重复我们代码的部分。然后我们在两个快速演示应用程序中将它们整合在一起。
- en: In the next chapter, we will take a much closer look at Java methods, which
    is where all our code will go.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更仔细地学习Java方法，这是我们所有代码的所在地。
