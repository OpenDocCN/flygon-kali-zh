- en: Chapter 2. NumPy Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：NumPy 基础
- en: After installing NumPy and getting some code to work, it's time to cover NumPy
    basics. This chapter introduces you to the fundamentals of NumPy and arrays. At
    the end of this chapter you will have a basic understanding of NumPy arrays and
    their associated functions.
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 NumPy 并使一些代码正常工作之后，该介绍 NumPy 的基础知识了。 本章向您介绍 NumPy 和数组的基础。 在本章的最后，您将对 NumPy
    数组及其关联函数有基本的了解。
- en: 'The topics that we shall cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中介绍的主题如下：
- en: Data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型
- en: Array types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组类型
- en: Type conversions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换
- en: Creating arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数组
- en: Indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引
- en: Fancy indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花式索引
- en: Slicing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片
- en: Manipulating shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改形状
- en: The NumPy array object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NumPy 数组对象
- en: 'NumPy has a multidimensional array object called `ndarray`. It consists of
    two parts as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 具有一个称为 `ndarray`的多维数组对象。 它由两部分组成，如下所示：
- en: The actual data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际数据
- en: Some metadata describing the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些描述数据的元数据
- en: The majority of array operations leave the raw data untouched. The only aspect
    that changes is the metadata.
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数组操作均保持原始数据不变。 更改的唯一方面是元数据。
- en: We have already learned in the previous chapter how to create an array using
    the `arange()` function. Actually, we created a one-dimensional array that contained
    a set of numbers. The `ndarray` object can have more than one dimension.
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经学习了如何使用`arange()`函数创建数组。 实际上，我们创建了一个包含一组数字的一维数组。 `ndarray`对象可以具有多个维度。
- en: The advantages of using NumPy arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NumPy 数组的优点
- en: A NumPy array is a general homogeneous array—the items in an array have to be
    of the same type (there is a special array type that is heterogeneous). The advantage
    is that if we know that the items in an array are of the same type, it is easy
    to determine the storage size required for the array. NumPy arrays can perform
    vectorized operations working on a whole array. Contrast this to Python lists,
    where normally you have to loop through the list and perform operations on each
    element at a time. Also, NumPy uses an optimized C API for these operations, making
    them especially fast.
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组是通用的同类数组-数组中的项必须为相同类型（存在异类的特殊数组类型）。 好处是，如果我们知道数组中的项目属于同一类型，则很容易确定数组所需的存储大小。
    NumPy 数组可以对整个数组执行向量化操作。 将此与 Python 列表进行对比，通常情况下，您必须遍历该列表并一次对每个元素执行操作。 而且，NumPy
    使用优化的 C API 进行这些操作，使其特别快。
- en: NumPy arrays are indexed just like in Python, starting from 0\. Data types are
    represented by special objects. These objects will be discussed comprehensively
    further in this chapter.
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组的索引就像在 Python 中一样，从 0 开始。数据类型由特殊对象表示。 这些对象将在本章中进一步详细讨论。
- en: 'We will create an array using the `arange()` function again (see the `arrayattributes.py`
    file in the `Chapter02` folder of this book''s code bundle). In this chapter,
    you will see code snippets from IPython sessions where NumPy is already imported.
    The following code snippet shows us how to get the data type of an array:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用`arange()`函数创建一个数组（请参见本书代码包`Chapter02`文件夹中的`arrayattributes.py`文件）。 在本章中，您将看到已经导入
    NumPy 的 IPython 会话中的代码片段。 以下代码段向我们展示了如何获取数组的数据类型：
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The data type of the array `a` is `int64` (at least on my machine), but you
    may get `int32` as the output if you are using 32-bit Python. In both cases, we
    are dealing with integers (64-bit or 32-bit). Apart from the data type of an array,
    it is important to know its shape. The example in [Chapter 1](part0014_split_000.html#page
    "Chapter 1. Getting Started with NumPy"), *Getting Started with NumPy*, demonstrated
    how to create a vector (actually, a one-dimensional NumPy array). A vector is
    commonly used in mathematics, but most of the time we need higher-dimensional
    objects. Let''s determine the shape of the vector we created a little earlier
    in this section:'
  prefs: []
  type: TYPE_NORMAL
  zh: 数组`a`的数据类型为`int64`（至少在我的机器上），但是如果使用 32 位 Python，则可能会得到`int32`作为输出。 在这两种情况下，我们都处理整数（64
    位或 32 位）。 除了数组的数据类型外，了解其形状也很重要。 第一章， “NumPy 入门”中的示例演示了如何创建向量（实际上是一维 NumPy 数组）。
    向量通常用于数学中，但是大多数时候我们需要高维的对象。 让我们确定在本节前面创建的向量的形状：
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the vector has five elements with values ranging from `0` to
    `4`. The `shape` attribute of the array is a tuple; in this case, a tuple of one
    element, which contains the length in each dimension.
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，向量具有五个元素，其值范围从`0`到`4`。 数组的`shape`属性是一个元组； 在这种情况下，是一个元素的元组，其中包含每个维度的长度。
- en: Creating a multidimensional array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建多维数组
- en: 'Now that we know how to create a vector, we are ready to create a multidimensional
    NumPy array. After we create the matrix, we will again want to display its shape
    (see the `arrayattributes.py` file in the `Chapter02` folder of this book''s code
    bundle), as shown in the following code snippets:'
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道如何创建向量，就可以创建多维 NumPy 数组了。 创建矩阵之后，我们将再次想要显示其形状（请参见本书代码包`Chapter02`文件夹中的`arrayattributes.py`文件），如以下代码段所示：
- en: 'To create a multidimensional array, see the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建多维数组，请参见以下代码：
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To display the array shape, see the following lines of code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要显示数组形状，请参见以下代码行：
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We created a 2 x 2 array with the `arange()` function. Without any warning,
    the `array()` function appeared on the stage.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`arange()`函数创建了一个`2 x 2`的数组。 没有任何警告，`array()`函数出现在舞台上。
- en: The `array()` function creates an array from an object that you give to it.
    The object needs to be array-like, for instance, a Python list. In the preceding
    example, we passed in a list of arrays. The object is the only required argument
    of the `array()` function. NumPy functions tend to have a lot of optional arguments
    with predefined defaults.
  prefs: []
  type: TYPE_NORMAL
  zh: '`array()`函数从提供给它的对象创建一个数组。 该对象必须是类似数组的，例如 Python 列表。 在前面的示例中，我们传入了一个数组列表。 该对象是`array()`函数的唯一必需参数。
    NumPy 函数倾向于具有许多带有预定义默认值的可选参数。'
- en: Selecting array elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择数组元素
- en: 'From time to time, we will want to select a particular element of an array.
    We will take a look at how to do this, but first, let''s create a 2 x 2 matrix
    again (see the `elementselection.py` file in the `Chapter02` folder of this book''s
    code bundle):'
  prefs: []
  type: TYPE_NORMAL
  zh: 从时间到时间，我们将要选择数组的特定元素。 我们将看一下如何执行此操作，但首先，让我们再次创建一个`2 x 2`矩阵（请参见本书代码包`Chapter02`文件夹中的`elementselection.py`文件）：
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The matrix was created this time by passing a list of lists to the `array()`
    function. We will now select each item of the matrix one at a time, as shown in
    the following code snippet. Remember, the indices are numbered starting from 0.
  prefs: []
  type: TYPE_NORMAL
  zh: 这次是通过将列表列表传递给`array()`函数来创建矩阵的。 现在，我们将一次选择矩阵的每个项目，如以下代码片段所示。 请记住，索引从 0 开始编号。
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, selecting elements of the array is pretty simple. For the array
    `a`, we just use the notation `a[m,n]`, where `m` and `n` are the indices of the
    item in the array.
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，选择数组的元素非常简单。 对于数组`a`，我们只使用符号`a[m,n]`，其中`m`和`n`是数组中该项的索引。
- en: '![Selecting array elements](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
  zh: '![选择数组元素](img/00008.jpeg)'
- en: NumPy numerical types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NumPy 数值类型
- en: 'Python has an integer type, a float type, and a complex type; however, this
    is not enough for scientific computing. In practice, we need even more data types
    with varying precision, and therefore, different memory size of the type. For
    this reason, NumPy has a lot more data types. The majority of NumPy numerical
    types end with a number. This number indicates the number of bits associated with
    the type. The following table (adapted from the NumPy user guide) gives an overview
    of NumPy numerical types:'
  prefs: []
  type: TYPE_NORMAL
  zh: Python 具有整数类型，浮点类型和复杂类型。 但是，这对于科学计算而言还不够。 实际上，我们需要更多具有不同精度的数据类型，因此，该类型的内存大小也有所不同。
    因此，NumPy 具有更多的数据类型。 NumPy 数值类型的大多数以数字结尾。 该数字指示与类型关联的位数。 下表（根据 NumPy 用户指南改编）概述了
    NumPy 数值类型：
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `bool` | This stores boolean (True or False) as a bit |'
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | 布尔（`True`或`False`）存储为一个位 |'
- en: '| `inti` | This is a platform integer (normally either `int32` or `int64`)
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `inti` | 平台整数（通常为`int32`或`int64`） |'
- en: '| `int8` | This is an integer ranging from-128 to 127 |'
  prefs: []
  type: TYPE_TB
  zh: '| `int8` | 整数，范围为 -128 至 127 |'
- en: '| `int16` | This is an integer ranging from -32768 to 32767 |'
  prefs: []
  type: TYPE_TB
  zh: '| `int16` | 整数，范围为 -32768 至 32767 |'
- en: '| `int32` | This is an integer ranging from -2 ** 31 to 2 ** 31 -1 |'
  prefs: []
  type: TYPE_TB
  zh: '| `int32` | 整数，范围为`-2 ** 31`至`2 ** 31 -1` |'
- en: '| `int64` | This is an integer ranging from -2 ** 63 to 2 ** 63 -1 |'
  prefs: []
  type: TYPE_TB
  zh: '| `int64` | 整数，范围为`-2 ** 63`至`2 ** 63 -1` |'
- en: '| `uint8` | This is an unsigned integer ranging from 0 to 255 |'
  prefs: []
  type: TYPE_TB
  zh: '| `uint8` | 无符号整数，范围为 0 到 255 |'
- en: '| `uint16` | This is an unsigned integer ranging from 0 to 65535 |'
  prefs: []
  type: TYPE_TB
  zh: '| `uint16` | 无符号整数，范围为 0 到 65535 |'
- en: '| `uint32` | This is an unsigned integer ranging from 0 to 2 ** 32 - 1 |'
  prefs: []
  type: TYPE_TB
  zh: '| `uint32` | 无符号整数，范围为 0 到`2 ** 32-1` |'
- en: '| `uint64` | This is an unsigned integer ranging from 0 to 2 ** 64 - 1 |'
  prefs: []
  type: TYPE_TB
  zh: '| `uint64` | 无符号整数，范围为 0 到`2 ** 64-1` |'
- en: '| `float16` | This is a half precision float with sign bit, 5 bits exponent,
    and 10 bits mantissa |'
  prefs: []
  type: TYPE_TB
  zh: '| `float16` | 半精度浮点数，具有符号位，5 位指数和 10 位尾数 |'
- en: '| `float32` | This is a single precision float with sign bit, 8 bits exponent,
    and 23 bits mantissa |'
  prefs: []
  type: TYPE_TB
  zh: '| `float32` | 单精度浮点数，具有符号位，8 位指数和 23 位尾数 |'
- en: '| `float64` or `float` | This is a double precision float with sign bit, 11
    bits exponent, and 52 bits mantissa |'
  prefs: []
  type: TYPE_TB
  zh: '| `float64`或`float` | 双精度浮点数，具有符号位，11 位指数和 52 位尾数 |'
- en: '| `complex64` | This is a complex number represented by two 32-bit floats (real
    and imaginary components) |'
  prefs: []
  type: TYPE_TB
  zh: '| `complex64` | 复数，由两个 32 位浮点数（实部和虚部）表示 |'
- en: '| `complex128` or `complex` | This is a complex number represented by two 64-bit
    floats (real and imaginary components) |'
  prefs: []
  type: TYPE_TB
  zh: '| `complex128`或`complex` | 复数，由两个 64 位浮点数（实部和虚部）表示 |'
- en: 'For each data type, there exists a corresponding conversion function (see the
    `numericaltypes.py` file in the `Chapter02` folder of this book''s code bundle),
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种数据类型，都有一个对应的转换函数（请参见本书代码包的`Chapter02`文件夹中的`numericaltypes.py`文件），如以下代码片段所示：
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Many functions have a data type argument, which is often optional:'
  prefs: []
  type: TYPE_NORMAL
  zh: 许多函数都有一个数据类型参数，该参数通常是可选的：
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It is important to know that you are not allowed to convert a complex number
    into an integer type number. Trying to do that triggers a `TypeError`, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道您不允许将复数转换为整数类型的数字。 尝试执行此操作会触发`TypeError`，如以下屏幕截图所示：
- en: '![NumPy numerical types](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
  zh: '![NumPy 数值类型](img/00009.jpeg)'
- en: The same goes for conversion of a complex number into a float type number. By
    the way, the **j** part is the imaginary coefficient of the complex number. However,
    you can convert a floating number to a complex number, for instance, `complex(1.0)`.
    The real and imaginary parts of a complex number can be extracted with the `real()`
    and `imag()` functions respectively.
  prefs: []
  type: TYPE_NORMAL
  zh: 将复数转换为浮点类型数也是如此。 顺便提及， `j`部分是复数的虚数系数。 但是，您可以将浮点数转换为复数，例如`complex(1.0)`。 复数的实部和虚部可以分别通过`real()`和`imag()`函数提取。
- en: Data type objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据类型对象
- en: '**Data type objects** are instances of the `numpy.dtype` class. Once again,
    arrays have a data type. To be precise, every element in a NumPy array has the
    same data type. The data type object can tell you the size of the data in bytes.
    The size in bytes is given by the `itemsize` attribute of the `dtype` class (see
    the `dtypeattributes.py` file in the `Chapter02` folder of this book''s code bundle),
    as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据类型对象**是`numpy.dtype`类的实例。 数组再次具有数据类型。 确切地说，NumPy 数组中的每个元素都具有相同的数据类型。 数据类型对象可以告诉您数据的大小（以字节为单位）。
    字节的大小由`dtype`类的`itemsize`属性给出（请参见本书代码包的`Chapter02`文件夹中的`dtypeattributes.py`文件），如以下代码行所示：'
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Character codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符代码
- en: '**Character codes** are included for backward compatibility with Numeric. Numeric
    is the predecessor of NumPy. Their use is not recommended, but the codes are provided
    here because they pop up in several places. You should instead use the `dtype`
    objects. The following table shows different data types and character codes associated
    with them:'
  prefs: []
  type: TYPE_NORMAL
  zh: '**NumPy 包含字符代码**，以便与 Numeric 向后兼容。 Numeric 是 NumPy 的前身。 不建议使用它们，但是此处提供了代码，因为它们会在多个位置弹出。
    您应该改用`dtype`对象。 下表显示了不同的数据类型和与其关联的字符代码：'
- en: '| Type | Character code |'
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 字符码 |'
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| integer | `i` |'
  prefs: []
  type: TYPE_TB
  zh: '| 整数 | `i` |'
- en: '| Unsigned integer | `u` |'
  prefs: []
  type: TYPE_TB
  zh: '| 无符号整数 | `u` |'
- en: '| Single precision float | `f` |'
  prefs: []
  type: TYPE_TB
  zh: '| 单精度浮点 | `f` |'
- en: '| Double precision float | `d` |'
  prefs: []
  type: TYPE_TB
  zh: '| 双精度浮点 | `d` |'
- en: '| bool | `b` |'
  prefs: []
  type: TYPE_TB
  zh: '| 布尔 | `b` |'
- en: '| complex | `D` |'
  prefs: []
  type: TYPE_TB
  zh: '| 复数 | `D` |'
- en: '| string | `S` |'
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `S` |'
- en: '| unicode | `U` |'
  prefs: []
  type: TYPE_TB
  zh: '| Unicode | `U` |'
- en: '| Void | `V` |'
  prefs: []
  type: TYPE_TB
  zh: '| 无 | `V` |'
- en: 'Look at the following code to create an array of single precision floats (see
    the `charcodes.py` file in the `Chapter02` folder of this book''s code bundle):'
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下面的代码以创建一个单精度浮点数数组（请参见本书代码包的`Chapter02`文件夹中的`charcodes.py`文件）：
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: dtype constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`dtype`构造器'
- en: 'We have a variety of ways to create data types. Take the case of floating point
    data (see the `dtypeconstructors.py` file in the `Chapter02` folder of this book''s
    code bundle) as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多种创建数据类型的方式。 以浮点数据为例（请参见本书代码包的`Chapter02`文件夹中的`dtypeconstructors.py`文件），如下所示：
- en: 'We can use the general Python float as shown in the following lines of code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用通用的 Python 浮点数，如以下代码行所示：
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can specify a single precision float with a character code as shown in the
    following lines of code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用字符代码指定一个单精度浮点数，如以下代码行所示：
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can use a double precision float character code as shown in the following
    lines of code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用双精度浮点字符代码，如以下代码行所示：
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can give a data type constructor a two-character code. The first character
    signifies the type, and the second character is a number specifying the number
    of bytes in the data type (the numbers 2, 4, and 8 correspond to 16-, 32-, and
    64-bit floats, respectively), as shown in the following lines of code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以给数据类型构造器一个两个字符的代码。 第一个字符表示类型，第二个字符是一个数字，用于指定数据类型中的字节数（数字 2、4 和 8 分别对应于 16
    位，32 位和 64 位浮点数），在以下代码行中显示：
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A listing of all data type names can be found by calling `sctypeDict.keys()`:'
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用`sctypeDict.keys()`找到所有数据类型名称的列表：
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: dtype attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`dtype`属性'
- en: 'The `dtype` class has a number of useful attributes. For example, we can get
    information about the character code of a data type through the attributes of
    `dtype` (see the `dtypeattributes2.py` file in the `Chapter02` folder of this
    book''s code bundle), as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`dtype`类具有许多有用的属性。 例如，我们可以通过`dtype`的属性获取有关数据类型的字符代码的信息（请参见本书代码包`Chapter02`文件夹中的`dtypeattributes2.py`文件），如以下代码片段所示：'
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `type` attribute corresponds to the type of object of array elements:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`属性对应于数组元素的对象类型：'
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `str` attribute of `dtype` gives a string representation of a data type.
    It starts with a character representing endianness, if appropriate, then a character
    code, followed by a number corresponding to the number of bytes that each array
    item requires. Here endianness means the way bytes are ordered within a 32- or
    64-bit word. In the big-endian order, the most significant byte is stored first,
    which is indicated by ''>''. In the little-endian order, the least significant
    byte is stored first, which is indicated by `<` as shown in the following lines
    of code:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`dtype`的`str`属性给出了数据类型的字符串表示形式。 它从代表字节序的字符开始（如果适用），然后是字符代码，后跟与每个数组项所需的字节数相对应的数字。
    这里的字节顺序表示字节在 32 位或 64 位字中的排序方式。 按照大端顺序，最高有效字节先存储，由“ >”指示。 按照小端顺序，最低有效字节首先存储，由`<`指示，如以下代码行所示：'
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Creating a record data type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建记录数据类型
- en: 'A record data type is a heterogeneous data type—think of it as representing
    a row in a spreadsheet or a database. To give an example of a record data type,
    we will create a record for a shop inventory. This record contains the name of
    an item represented by a 40-character string, the number of items in the store
    represented by a 32-bit integer, and finally, the price of the item represented
    by a 32-bit float. The following steps show how to create a record data type (see
    the `record.py` file in the `Chapter02` folder of this book''s code bundle):'
  prefs: []
  type: TYPE_NORMAL
  zh: 记录数据类型是一种异构数据类型-认为它表示电子表格或数据库中的一行。 以记录数据类型为例，我们将为商店库存创建一条记录。 该记录包含以 40 个字符的字符串表示的商品名称，商店中以
    32 位整数表示的商品数量，最后以 32 位浮点数表示的商品价格。 以下步骤显示了如何创建记录数据类型（请参见本书代码包的`Chapter02`文件夹中的`record.py`文件）：
- en: 'To create a record, check the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建记录，请检查以下代码片段：
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To view the type of the field, check the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看字段的类型，请检查以下代码段：
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you don''t give the `array()` function a data type, it will assume that
    it is dealing with floating point numbers. To create an array now, we really have
    to specify the data type as shown in the following lines of code; otherwise, we
    will get a `TypeError`:'
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不为`array()`函数提供数据类型，则将假定它正在处理浮点数。 现在要创建一个数组，我们实际上必须指定数据类型，如以下代码行所示； 否则，我们将获得`TypeError`：
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We created a record data type, which is a heterogeneous data type. The record
    contained a name as a character string, a number as an integer, and a price represented
    by a float value.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个记录数据类型，它是一个异构数据类型。 记录包含一个名称（作为字符串），一个数字（一个整数）和一个以浮点值表示的价格。
- en: One-dimensional slicing and indexing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一维切片和索引
- en: 'Slicing of one-dimensional NumPy arrays works just like slicing of Python lists.
    We can select a piece of an array from the index `3` to `7` that extracts the
    elements `3` through `6` (see the `slicing1d.py` file in the `Chapter02` folder
    of this book''s code bundle), as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
  zh: 一维 NumPy 数组的切片与 Python 列表的切片一样。 我们可以从`3`到`7`的索引中选择一个数组的，以提取`3`到`6`的元素（请参见本书代码包`Chapter02`文件夹中的`slicing1d.py`文件）
    ），如以下代码段所示：
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can select elements from the index `0` to `7` with a step of two, as shown
    in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以两个为步长从索引`0`到`7`中选择元素，如以下代码行所示：
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Just as in Python, we can use negative indices and reverse the array, as shown
    in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 Python 中一样，我们可以使用负索引并反转数组，如以下代码行所示：
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Manipulating array shapes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改数组形状
- en: 'Another recurring task is flattening of arrays. Flattening in this context
    means transforming a multidimensional array into a one-dimensional array. In this
    example, we will demonstrate a number of ways to manipulate array shapes starting
    with flattening:'
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重复执行的任务是将数组展平。 在这种情况下，展平意味着将多维数组转换为一维数组。 在此示例中，我们将展示许多方法从展平开始操作数组形状：
- en: '`ravel()`: We can accomplish flattening with the `ravel()` function (see the
    `shapemanipulation.py` file in the `Chapter02` folder of this book''s code bundle),
    as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ravel()`：我们可以使用`ravel()`函数完成的拼合（请参见本书代码包`Chapter02`文件夹中的`shapemanipulation.py`文件），如以下代码所示：'
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`flatten()`: The appropriately-named function, `flatten()`, does the same as
    `ravel()`, but `flatten()` always allocates new memory, whereas `ravel()` might
    return a view of an array. This means that we can directly manipulate the array
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatten()`：适当命名的函数`flatten()`与`ravel()`相同，但是`flatten()`总是分配新的内存，而`ravel()`可能返回数组的视图。
    这意味着我们可以按以下方式直接操作数组：'
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`shape`: Besides the `reshape()` function, we can also set the shape directly
    with a tuple, which is shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shape`：除了`reshape()`函数，我们还可以直接使用元组来设置形状，如下所示：'
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, this changes the array directly. Now we have a 6 x 4 array.
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这将直接更改数组。 现在我们有一个`6 x 4`的数组。
- en: '`transpose()`: In linear algebra, it is common to transpose matrices. We can
    do that too using the `transpose()` function, as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transpose()`：在线性代数中，通常转置矩阵。 我们也可以使用`transpose()`函数来做到这一点，如以下代码所示：'
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`resize()`: The `resize()` method works just like the `reshape()` method but
    modifies the array it operates on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resize()`：`resize()`方法的工作方式与`reshape()`方法相同，但是修改了它操作的数组：'
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Stacking arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆叠数组
- en: 'Arrays can be stacked horizontally, depth-wise, or vertically. We can use,
    for that purpose, the `vstack()`, `dstack()`, `hstack()`, `column_stack()`, `row_stack()`,
    and `concatenate()` functions. First, let''s set up some arrays (see the `stacking.py`
    file in the `Chapter02` folder of this book''s code bundle), as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以水平，深度或垂直堆叠。 为此，我们可以使用`vstack()`，`dstack()`，`hstack()`，`column_stack()`，`row_stack()`和`concatenate()`函数。
    首先，让我们设置一些数组（请参见本书代码包的`Chapter02`文件夹中的`stacking.py`文件），如以下代码所示：
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following are the different types of stacking:'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是不同类型的堆叠：
- en: '**Horizontal stacking**: Starting with horizontal stacking, we will form a
    tuple of `ndarray` and give it to the `hstack()` function. This is shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平堆叠**：从水平堆叠开始，我们将形成一个`ndarray`元组并将其提供给`hstack()`函数。 显示如下：'
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can achieve the same with the `concatenate()` function, which is shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`concatenate()`函数实现相同的功能，如下所示：
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following figure visualizes horizontal stacking:'
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了水平堆叠：
- en: '![Stacking arrays](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
  zh: '![堆叠数组](img/00010.jpeg)'
- en: '**Vertical stacking**: With vertical stacking, again, a tuple is formed. This
    time, it is given to the `vstack()` function. This can be seen as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直堆叠**：通过垂直堆叠，再次形成元组。 这次，它被提供给`vstack()`函数。 可以看到如下：'
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `concatenate()` function produces the same result with the axis argument
    set to `0`. This is the default value for the `axis` argument, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`concatenate()`函数在将轴参数设置为`0`的情况下产生相同的结果。 这是`axis`参数的默认值，如以下代码所示：'
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Refer to the following diagram for vertical stacking:'
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅下图进行垂直堆叠：
- en: '![Stacking arrays](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
  zh: '![堆叠数组](img/00011.jpeg)'
- en: '**Depth stacking**: Additionally, there is depth-wise stacking using `dstack()`
    and a tuple, of course. This means stacking of a list of arrays along the third
    axis (depth). For instance, we could stack two-dimensional arrays of image data
    on top of each other:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度堆叠**：当然还有使用`dstack()`和元组的深度堆叠。 这意味着沿第三轴（深度）堆叠数组列表。 例如，我们可以彼此堆叠图像数据的二维数组：'
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Column stacking**: The `column_stack()` function stacks one-dimensional arrays
    column-wise. It''s shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列堆叠**：`column_stack()`函数按列堆叠一维数组。 显示如下：'
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Two-dimensional arrays are stacked the way `hstack()` stacks them, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
  zh: 二维数组以`hstack()`的方式堆叠，如以下代码所示：
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Yes, you guessed it right! We compared two arrays with the `==` operator. Isn't
    this beautiful?
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，您猜对了！ 我们用`==`运算符比较了两个数组。 这不漂亮吗？
- en: '**Row stacking**: NumPy, of course, also has a function that does row-wise
    stacking. It is called `row_stack()`, and for one-dimensional arrays, it just
    stacks the arrays in rows into a two-dimensional array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行堆叠**：NumPy 当然也具有执行行堆叠的函数。 它被称为`row_stack()`，对于一维数组，它只是将数组按行堆叠为二维数组：'
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `row_stack()` function results for two-dimensional arrays are equal to
    the `vstack()` function results, as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 二维数组的`row_stack()`函数结果等于`vstack()`函数结果，如下所示：
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Splitting arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拆分数组
- en: Arrays can be split vertically, horizontally, or depth-wise. The functions involved
    are `hsplit()`, `vsplit()`, `dsplit()`, and `split()`. We can either split arrays
    into arrays of the same shape or indicate the position after which the split should
    occur.
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在垂直，水平或深度方向拆分数组。 涉及的函数是`hsplit()`，`vsplit()`，`dsplit()`和`split()`。 我们既可以将数组拆分为相同形状的数组，也可以指示拆分之后应该发生的位置。
- en: '**Horizontal splitting**: The ensuing code splits an array along its horizontal
    axis into three pieces of the same size and shape (see the `splitting.py` file
    in the `Chapter02` folder of this book''s code bundle):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平分割**：随后的代码将一个数组沿其水平轴分割为三个大小和形状相同的片段（请参见本书代码包`Chapter02`文件夹中的`splitting.py`文件）：'
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Compare it with a call of the `split()` function, with the extra parameter
    `axis=1`:'
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与 `split()`函数的调用以及附加参数`axis=1`进行比较：
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Vertical splitting**: The `vsplit()` function splits an array along the vertical
    axis:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直分割**：`vsplit()`函数沿垂直轴分割数组：'
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `split()` function, with `axis=0`, also splits an array along the vertical
    axis:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`split()`函数与`axis=0`一起也沿垂直轴拆分了一个数组：'
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Depth-wise splitting**: The `dsplit()` function, unsurprisingly, splits an
    array depth-wise. We will need an array of rank three first:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度分割**： `dsplit()`函数毫不奇怪，深度拆分数组。 我们将需要一个排名第三的数组：'
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Array attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组属性
- en: 'Besides the `shape` and `dtype` attributes, `ndarray` has a number of other
    attributes, as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
  zh: 除了，`shape`和`dtype`属性外，`ndarray`还有许多其他属性，如下表所示：
- en: '`ndim`: This attribute gives the number of array dimensions (see the `arrayattributes2.py`
    file in the `Chapter02` folder of this book''s code bundle):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ndim`：此属性为提供数组维数（请参见本书代码包包`Chapter02`文件夹中的`arrayattributes2.py`文件）：'
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`size`: This attribute displays the number of elements. This is shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`：此属性显示元素数。 如下所示：'
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`itemsize`: This attribute gives the number of bytes for each element in an
    array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`itemsize`：此属性给出数组中每个元素的字节数：'
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`nbytes`: This attribute gives the total number of bytes an array requires.
    It is just a product of the `itemsize` and `size` attributes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nbytes`：此属性为提供数组所需的字节总数。 它只是`itemsize`和`size`属性的乘积：'
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`T`: This attribute has the same effect as the `transpose()` function, which
    is shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T`：该属性与`transpose()`函数具有相同的作用，如下所示：'
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If the array has a rank lower than two, we will just get a view of the array:'
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组的排名低于 2，我们将只获得数组的视图：
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Complex numbers in NumPy are represented by ''j''. For example, we can create
    an array with complex numbers:'
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 中的复数由`j`表示。 例如，我们可以创建一个包含复数的数组：
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`real`: This attribute gives us the real part of an array, or the array itself
    if it only contains real numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`real`：此属性为我们提供了数组的实部；如果数组本身仅包含实数，则为数组本身：'
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`imag`: This attribute contains the imaginary part of an array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imag`：此属性包含数组的虚部：'
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If the array contains complex numbers, then the data type is automatically
    also complex:'
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组包含复数，则数据类型也将自动变为复数：
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`flat`: This attribute returns a `numpy.flatiter` object. This is the only
    way to acquire a `flatiter`—we do not have access to a `flatiter` constructor.
    The flat iterator enables us to loop through an array as if it is a flat array,
    as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flat`: 这个属性返回一个`numpy.flatiter`对象。 这是获取`flatiter`的唯一方法 -- 我们无权访问`flatiter`构造器。
    展开迭代器使我们能够像遍历展开数组一样遍历数组，如以下代码所示：'
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It is possible to directly get an element with the `flatiter` object as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`flatiter`对象直接获取元素，如下所示：
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'It is also possible to get multiple elements as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以按如下方式获取多个元素：
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `flat` attribute is settable. Setting the value of the `flat` attribute
    leads to overwriting the values of the whole array as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`flat`属性是可设置的。 设置`flat`属性的值会导致覆盖整个数组的值，如下所示：'
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can even get selected elements as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以按以下方式获取选定的元素：
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The following figure shows different attributes of ndarray:'
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了`ndarray`的不同属性：
- en: '![Array attributes](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
  zh: '![数组属性](img/00012.jpeg)'
- en: Converting arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换数组
- en: 'We can convert a NumPy array to a Python list with the `tolist()` function
    (see the `arrayconversion.py` file in the `Chapter02` folder of this book''s code
    bundle) as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`tolist()`函数将 NumPy 数组转换为 Python 列表（请参见本书代码包`Chapter02`文件夹中的`arrayconversion.py`文件），如下所示：
- en: 'To convert an array to a list, check the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将数组转换为列表，请检查以下代码片段：
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `astype()` function converts an array to an array of the specified type
    as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`astype()`函数将数组转换为指定类型的数组，如以下代码所示：'
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: We are losing the imaginary part when casting from complex type to `int`.
  prefs: []
  type: TYPE_NORMAL
  zh: 从复杂类型转换为`int`时，我们将丢失虚部。
- en: 'The `astype()` function also accepts the name of a type as a string, as in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`astype()`函数还接受类型名称作为字符串，如以下代码片段所示：'
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This won't show any warning this time, because we used the proper data type.
  prefs: []
  type: TYPE_NORMAL
  zh: 这次不会显示任何警告，因为我们使用了正确的数据类型。
- en: Creating views and copies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建视图和副本
- en: In the example about the `ravel()` function, views were mentioned. Views should
    not be confused with the concept of database views. Views in the NumPy world are
    not read-only, and you don't have the possibility to protect the underlying data.
    It is important to know when we are dealing with a shared array view and when
    we have a copy of array data. A slice, for instance, will create a view. This
    means that if you assign a slice to a variable and then change the underlying
    array, the value of this variable will change. We will create an array from the
    famous Lena image, copy the array, create a view, and at the end, modify the view.
    The Lena image array comes from a SciPy function.
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于`ravel()`函数的示例中，提到了视图。 视图不应与数据库视图的概念混淆。 NumPy 世界中的视图不是只读的，并且您无法保护基础数据。 了解何时使用共享数组视图以及何时拥有数组数据副本非常重要。
    例如，切片将创建一个视图。 这意味着，如果您将切片分配给变量，然后更改基础数组，则此变量的值将更改。 我们将根据著名的 Lena 图像创建一个数组，复制该数组，创建一个视图，最后修改视图。
    Lena 图像数组来自 SciPy 函数。
- en: 'To create a copy of the Lena array, the following line of code is used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建 Lena 数组的副本，请使用以下代码行：
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, to create a view of the array, use the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要创建数组的视图，请使用以下代码行：
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Set all the values of the view to `0` with a flat iterator, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用平面迭代器将视图的所有值设置为`0`，如下所示：
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The end result is that only one of the images shows the Playboy model. The other
    ones got censored completely, as shown in the following figure.
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是只有一张图像显示了花花公子模型。 其他人被完全审查，如下图所示。
- en: '![Creating views and copies](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
  zh: '![创建视图和副本](img/00013.jpeg)'
- en: 'Refer to the following code of this section (without comments to save space;
    for the complete code, see the `copy_view.py` file in the `Chapter02` folder of
    this book''s code bundle) showing the behavior of array views and copies:'
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本部分的以下代码（不带注释以节省空间；有关完整的代码，请参见本书代码包`Chapter02`文件夹中的`copy_view.py`文件），该信息显示了数组视图的行为。
    并复制：
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As you can see, by changing the view at the end of the program, we changed the
    original Lena array. This resulted in having three blue (or black if you are looking
    at a black and white image) images. The copied array was unaffected. It is important
    to remember that views are not read-only.
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过在程序末尾更改视图，我们更改了原始的 Lena 数组。 此产生了三个蓝色（如果您正在观看黑白图像，则为黑色）图像。 复制的数组不受影响。
    重要的是要记住，视图不是只读的。
- en: Fancy indexing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 花式索引
- en: 'Fancy indexing is indexing that does not involve integers or slices, which
    is normal indexing. In this section, we will apply fancy indexing to set the diagonal
    values of the Lena image to `0`. This will draw black lines along the diagonals,
    crossing it through, not because there is something wrong with the image, but
    just as an exercise. Perform the following steps for fancy indexing:'
  prefs: []
  type: TYPE_NORMAL
  zh: 花式索引是不包含整数或切片的索引，这是常规索引。 在本节中，我们将应用花式索引将 Lena 图像的对角线值设置为`0`。 这将沿着对角线绘制黑线，穿过它，这不是因为图像有问题，而是作为一种练习。
    执行以下步骤进行花式索引编制：
- en: 'Set the values of the first diagonal to `0`. To set the diagonal values to
    `0`, we need to define two different ranges for the `x` and `y` values as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个对角线的值设置为`0`。 要将对角线值设置为`0`，我们需要为`x`和`y`值定义两个不同的范围，如下所示：
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, set the values of the other diagonal to `0`. To set the values of the
    other diagonal, we require a different set of ranges, but the principles stay
    the same, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将另一个对角线的值设置为`0`。 要设置另一个对角线的值，我们需要使用一组不同的范围，但是原理保持不变，如下所示：
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'At the end we get the following image with the diagonals crossed out:'
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到以下对角线被划掉的图像：
- en: '![Fancy indexing](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
  zh: '![花式索引](img/00014.jpeg)'
- en: The following code for this section is without comments. The complete code for
    this is in the `fancy.py` file in the `Chapter02` folder of this book's code bundle.
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分的以下代码不带注释。 本书的代码包`Chapter02`文件夹中的`fancy.py`文件中包含完整代码。
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We defined separate ranges for the `x` and `y` values. These ranges were used
    to index the Lena array. Fancy indexing is performed based on an internal NumPy
    iterator object. This can be achieved by performing the following three steps:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`x`和`y`值定义了单独的范围。 这些范围用于索引 Lena 数组。 花式索引是基于内部 NumPy 迭代器对象执行的。 这可以通过执行以下三个步骤来实现：
- en: The iterator object is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建迭代器对象。
- en: The iterator object gets bound to the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将迭代器对象绑定到数组。
- en: Array elements are accessed via the iterator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过迭代器访问数组元素。
- en: Indexing with a list of locations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位置列表索引
- en: 'Let''s use the `ix_()` function to shuffle the Lena image. This function creates
    a mesh from multiple sequences. As arguments, we give one-dimensional sequences,
    and the function returns a tuple of NumPy arrays. For example, check the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`ix_()`函数来随机播放 Lena 图像。 此函数从多个序列创建一个网格。 作为参数，我们给出一维序列，并且该函数返回 NumPy 数组的元组。
    例如，检查以下代码片段：
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To index the array with a list of locations, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用位置列表为数组建立索引，请执行以下步骤：
- en: Shuffle the array indices. Create a random indices array with the `shuffle()`
    function of the `numpy.random` module, as shown in the following lines of code.
    The function changes the array `inplace` by the way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机排列数组索引。 使用`numpy.random`模块的`shuffle()`函数创建一个随机索引数组，如以下代码行所示。 该函数顺便更改了数组`inplace`。
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now plot the shuffled indices as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按如下所示绘制改组后的索引：
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'What we get is a completely scrambled Lena, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的是一个完全混乱的 Lena，如下图所示：
- en: '![Indexing with a list of locations](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
  zh: '![位置列表索引](img/00015.jpeg)'
- en: The following code for this section is without comments. The complete code for
    this can be found in the `ix.py` file in the `Chapter02` folder of this book's
    code bundle.
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分的以下代码不带注释。 完整的代码可以在本书代码包包的`Chapter02`文件夹中的`ix.py`文件中找到。
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Indexing arrays with Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用布尔值索引数组
- en: 'Boolean indexing is indexing based on a Boolean array and falls in the category
    of fancy indexing. Since Boolean indexing is a form of fancy indexing, the way
    it works is basically the same. This means that indexing happens with the help
    of a special iterator object. Perform the following steps to index an array:'
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔索引是基于布尔数组的索引，属于奇特索引的类别。 由于布尔索引是幻想索引的一种形式，因此它的工作方式基本相同。 表示在特殊的迭代器对象的帮助下进行索引。
    执行以下步骤为数组建立索引：
- en: 'First, we create an image with dots on the diagonal. This is in some way similar
    to the *Fancy indexing* section. This time we select modulo four points on the
    diagonal of the image, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个在对角线上带有点的图像。 这在某种程度上类似于“花式索引”部分。 这次，我们在图像的对角线上选择取四点为模，如以下代码片段所示：
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then we just apply this selection and plot the points, as shown in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们只需应用此选择并绘制点，如以下代码片段所示：
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Select array values between a quarter and three-quarters of the maximum value,
    and set them to `0`, as shown in the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最大值的四分之一到四分之三之间选择数组值，并将它们设置为`0`，如下面的代码行所示：
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The plot with the two new images is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 带有两个新图像的图如下所示：
- en: '![Indexing arrays with Booleans](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
  zh: '![使用布尔值索引数组](img/00016.jpeg)'
- en: 'The following is the code for this section (see the `boolean_indexing.py` file
    in the `Chapter02` folder of this book''s code bundle):'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该部分的代码（请参见本书代码包`Chapter02`文件夹中的`boolean_indexing.py`文件）：
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Stride tricks for Sudoku
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数独步幅技巧
- en: 'We can do even more fancy things with NumPy. The `ndarray` class has a field,
    `strides`, which is a tuple indicating the number of bytes to step in each dimension
    when going through an array. Sudoku is a popular puzzle originally from Japan;
    although it was known in a similar form before in other countries. If you don''t
    know about Sudoku, it''s maybe better that way because it is highly addictive.
    Let''s apply some stride tricks to the problem of splitting a Sudoku puzzle to
    the 3 x 3 squares it is composed of:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用 NumPy 做更华丽的事情。 `ndarray`类具有一个字段`strides`，该字段是一个元组，指示通过数组时每个维度要步进的字节数。
    数独是起源于日本的流行拼图。 尽管在其他国家/地区以前也以类似的形式知道它。 如果您不了解数独，那可能会更好，因为它极易上瘾。 让我们对将数独谜题拆分为`3
    x 3`正方形的问题应用一些大的技巧：
- en: First define the Sudoku puzzle array, as shown in the following code snippet.
    This one is filled with the contents of the actual solved Sudoku puzzle (part
    of the array is omitted for brevity).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先定义数独拼图数组，如以下代码片段所示。 这是一个实际已解决的数独难题的内容（为简洁起见，省略了部分数组）。
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now calculate the strides. The `itemsize` field of `ndarray` gives us the number
    of bytes in an array. `itemsize` calculates the strides as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在计算步幅。 `ndarray`的`itemsize`字段为我们提供了数组中的字节数。 `itemsize`计算步幅如下：
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now we can split the puzzle into squares with the `as_strided()` function of
    the `np.lib.stride_tricks` module, as shown in the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`np.lib.stride_tricks`模块的`as_strided()`函数将拼图分解为正方形，如以下代码行所示：
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This prints separate Sudoku squares (some of the squares were omitted to save
    space), as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印单独的数独方块（为了节省空间，一些方块被省略了），如下所示：
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The following is the complete source code for this example (see the `strides.py`
    file in the `Chapter02` folder of this book''s code bundle):'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此示例的完整源代码（请参见本书代码包`Chapter02`文件夹中的`strides.py`文件）：
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We applied stride tricks to decompose a Sudoku puzzle in its constituent 3 x
    3 squares. The strides tell us how many bytes we need to skip at each step when
    going through the Sudoku array.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用了步幅技巧，将数独谜题分解为`3 x 3`的正方形。 步幅告诉我们通过数独数组时，每个步骤需要跳过多少字节。
- en: Broadcasting arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广播数组
- en: 'In a nutshell, NumPy tries to perform an operation even though the operands
    do not have the same shape. In this section, we will multiply an array and a scalar.
    The scalar is extended to the shape of an array operand, and then the multiplication
    is performed. We will download an audio file and make a new version that is quieter:'
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，即使操作数的形状不同，NumPy 也会尝试执行操作。 在本节中，我们将一个数组和一个标量相乘。 标量扩展为数组操作数的形状，然后执行乘法。 我们将下载音频文件并制作一个更安静的新版本：
- en: First, read the WAV file. We will use standard Python code to download an audio
    file of Austin Powers saying "Smashing, baby". SciPy has a `wavfile` module that
    allows you to load sound data or generate WAV files. If SciPy is installed, then
    we should already have this module. The `read()` function returns a data array
    and sample rate. In this example, we only care about the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，读取 WAV 文件。 我们将使用标准的 Python 代码下载 Austin Powers 的音频文件，叫做“Smashing，baby”。 SciPy
    具有`wavfile`模块，可让您加载声音数据或生成 WAV 文件。 如果已安装 SciPy，则我们应该已经有此模块。 `read()`函数返回数据数组和采样率。
    在这个例子中，我们只关心数据。
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Plot the original WAV data with Matplotlib. Give the subplot the title, `Original`,
    as shown in the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Matplotlib 绘制原始 WAV 数据。 为子图命名为`Original`，如以下代码行所示：
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Now create a new array. We will use NumPy to make a quieter audio sample. It
    is just a matter of creating a new array with smaller values by multiplying with
    a constant. This is where the magic of broadcasting occurs. At the end, we need
    to make sure that we have the same data type as in the original array because
    of the WAV format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个新数组。 我们将使用 NumPy 制作更安静的音频样本。 只是通过乘以常量来创建具有较小值的新数组。 这就是广播魔术发生的地方。 最后，由于
    WAV 格式，我们需要确保与原始数组具有相同的数据类型。
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now this new array can be written into a new WAV file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，可以将这个新数组写入新的 WAV 文件，如下所示：
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Plot the new data array with Matplotlib as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Matplotlib 绘制新数据数组，如下所示：
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The result is a plot of the original WAV file data and a new array with smaller
    values, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是原始 WAV 文件数据和具有较小值的新数组的图，如下图所示：
- en: '![Broadcasting arrays](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
  zh: '![广播数组](img/00017.jpeg)'
- en: 'The following is the complete code for this section (see the broadcasting.py
    file in the `Chapter02` folder of this book''s code bundle):'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本节的完整代码（请参见本书代码包`Chapter02`文件夹中的`broadcast.py`文件）：
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'We learned a lot in this chapter about the NumPy fundamentals: data types and
    arrays. Arrays have several attributes describing them. We learned that one of
    these attributes is the data type which, in NumPy, is represented by a full-fledged
    object.'
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从 NumPy 基础知识中学到了很多东西：数据类型和数组。 数组有几个描述它们的属性。 我们了解到，这些属性之一是数据类型，在 NumPy
    中，该数据类型由完整的对象表示。
- en: NumPy arrays can be sliced and indexed in an efficient manner, just as in the
    case of Python lists. NumPy arrays have the added ability of working with multiple
    dimensions.
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Python 列表一样，可以有效地对 NumPy 数组进行切片和索引。 NumPy 数组具有处理多个维度的附加功能。
- en: The shape of an array can be manipulated in many ways, such as stacking, resizing,
    reshaping, and splitting. A great number of convenience functions for shape manipulation
    were demonstrated in this chapter.
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的形状可以通过多种方式进行操作，例如堆叠，调整大小，重新塑形和拆分。 本章演示了许多用于形状处理的便捷函数。
- en: Having learned about the basics, it's time to move on to data analysis with
    commonly used functions in [Chapter 3](part0036_split_000.html#page "Chapter 3. Basic
    Data Analysis with NumPy"), *Basic Data Analysis with NumPy*. This includes the
    usage of basic statistical and mathematical functions.
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了基础知识之后，是时候继续使用第三章，“使用 NumPy 进行基本数据分析”的常用函数进行数据分析了。 这包括基本统计和数学函数的使用。
