- en: Chapter 2. Docker CLI and Dockerfile
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。Docker CLI和Dockerfile
- en: In the last chapter, we set up Docker in our development setup and ran our first
    container. In this chapter, we will explore the Docker command-line interface.
    Later in the chapter, we will see how to create our own Docker images using Dockerfiles
    and how to automate this process.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在开发环境中设置了Docker并运行了我们的第一个容器。在本章中，我们将探索Docker命令行界面。在本章后面，我们将看到如何使用Dockerfiles创建自己的Docker镜像以及如何自动化这个过程。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Docker terminologies
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker术语
- en: Docker commands
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker命令
- en: Dockerfiles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfiles
- en: Docker workflow—pull-use-modify-commit-push workflow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker工作流程-拉取-使用-修改-提交-推送工作流程
- en: Automated builds
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化构建
- en: Docker terminologies
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker术语
- en: Before we begin our exciting journey into the Docker sphere, let's understand
    the Docker terminologies that will be used in this book a little better. Very
    similar in concept to VM images, a Docker image is a snapshot of a system. The
    difference between a VM image and a Docker image is that a VM image can have running
    services, whereas a Docker image is just a filesystem snapshot, which means that
    while you can configure the image to have your favorite packages, you can run
    only one command in the container. Don't fret though, since the limitation is
    one command, not one process, so there are ways to get a Docker container to do
    almost anything a VM instance can.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始激动人心的Docker领域之前，让我们更好地了解本书中将使用的Docker术语。与VM镜像类似，Docker镜像是系统的快照。VM镜像和Docker镜像之间的区别在于VM镜像可以运行服务，而Docker镜像只是文件系统的快照，这意味着虽然你可以配置镜像来拥有你喜欢的软件包，但你只能在容器中运行一个命令。不过不要担心，由于限制是一个命令，而不是一个进程，所以有方法让Docker容器几乎可以执行任何VM实例可以执行的任务。
- en: Docker has also implemented a Git-like distributed version management system
    for Docker images. Images can be stored in repositories (called a registry), both
    locally and remotely. The functionalities and terminologies borrow heavily from
    Git—snapshots are called commits, you pull an image repository, you push your
    local image to a repository, and so on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Docker还实现了类似Git的分布式版本管理系统，用于Docker镜像。镜像可以存储在本地和远程的仓库中。其功能和术语大量借鉴自Git-快照被称为提交，你拉取一个镜像仓库，你将本地镜像推送到仓库，等等。
- en: Docker container
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker容器
- en: A Docker container can be correlated to an instance of a VM. It runs sandboxed
    processes that share the same kernel as the host. The term **container** comes
    from the concept of shipping containers. The idea is that you can ship containers
    from your development environment to the deployment environment and the applications
    running in the containers will behave the same way no matter where you run them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Docker容器可以与虚拟机的实例相关联。它运行沙盒化的进程，这些进程与主机共享相同的内核。术语**容器**来自于集装箱的概念。其想法是你可以从开发环境将容器运送到部署环境，容器中运行的应用程序无论在哪里运行，都会表现出相同的行为。
- en: 'The following image shows the layers of AUFS:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了AUFS的层次结构：
- en: '![Docker container](graphics/4787OS_02_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![Docker容器](graphics/4787OS_02_01.jpg)'
- en: This is similar in context to a shipping container, which stays sealed until
    delivery but can be loaded, unloaded, stacked, and transported in between.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这与集装箱的情境类似，集装箱在交付之前保持密封，但可以在装卸货物、堆叠和运输之间进行操作。
- en: The visible filesystem of the processes in the container is based on AUFS (although
    you can configure the container to run with a different filesystem too). AUFS
    is a layered filesystem. These layers are all read-only and the merger of these
    layers is what is visible to the processes. However, if a process makes a change
    in the filesystem, a new layer is created, which represents the difference between
    the original state and the new state. When you create an image out of this container,
    the layers are preserved. Thus, it is possible to build new images out of existing
    images, creating a very convenient hierarchical model of images.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 容器中进程的可见文件系统基于AUFS（尽管您也可以配置容器以使用不同的文件系统）。AUFS是一种分层文件系统。这些层都是只读的，这些层的合并是进程可见的。但是，如果进程在文件系统中进行更改，将创建一个新层，该层代表原始状态和新状态之间的差异。当您从此容器创建图像时，这些层将被保留。因此，可以基于现有图像构建新图像，创建一个非常方便的图像层次模型。
- en: The docker daemon
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker守护程序
- en: The `docker` daemon is the process that manages containers. It is easy to get
    this confused with the Docker client because the same binary is used to run both
    the processes. The `docker` daemon, though, needs the `root` privileges, whereas
    the client doesn't.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker`守护程序是管理容器的进程。很容易将其与Docker客户端混淆，因为相同的二进制文件用于运行这两个进程。然而，`docker`守护程序需要`root`权限，而客户端不需要。'
- en: Unfortunately, since the `docker` daemon runs with root privileges, it also
    introduces an attack vector. Read [https://docs.Docker.com/articles/security/](https://docs.Docker.com/articles/security/)
    for more details.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于`docker`守护程序以root权限运行，它也引入了一个攻击向量。阅读[https://docs.Docker.com/articles/security/](https://docs.Docker.com/articles/security/)获取更多详细信息。
- en: Docker client
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker客户端
- en: The Docker client is what interacts with the `docker` daemon to start or manage
    containers. Docker uses a RESTful API to communicate between the client and the
    daemon.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Docker客户端是与`docker`守护程序交互以启动或管理容器的工具。Docker使用RESTful API在客户端和守护程序之间进行通信。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: REST is an architectural style consisting of a coordinated set of architectural
    constraints applied to components, connectors, and data elements within a distributed
    hypermedia system. In plain words, a RESTful service works over standard HTTP
    methods such as the `GET`, `POST`, `PUT`, and `DELETE` methods.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: REST是一种架构风格，由一组协调的架构约束应用于分布式超媒体系统中的组件、连接器和数据元素。简而言之，RESTful服务使用标准的HTTP方法，如`GET`、`POST`、`PUT`和`DELETE`方法。
- en: Dockerfile
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dockerfile
- en: A Dockerfile is a file written in a **Domain** **Specific** **Language** (**DSL**)
    that contains instructions on setting up a Docker image. Think of it as a Makefile
    equivalent of Docker.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile是一个用**特定领域语言（DSL）**编写的文件，其中包含设置Docker镜像的指令。可以将其视为Docker的Makefile等效文件。
- en: Docker registry
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker注册表
- en: This is the public repository of all Docker images published by the Docker community.
    You can pull images from this registry freely, but to push images, you will have
    to register at [http://hub.docker.com](http://hub.docker.com). Docker registry
    and Docker hub are services operated and maintained by Docker Inc., and they provide
    unlimited free repositories. You can also buy private repositories for a fee.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Docker社区发布的所有Docker镜像的公共存储库。您可以自由地从该注册表中拉取镜像，但要推送镜像，您必须在[http://hub.docker.com](http://hub.docker.com)注册。Docker注册表和Docker
    Hub是由Docker Inc.运营和维护的服务，并提供无限免费的存储库。您也可以购买私人存储库。
- en: Docker commands
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker命令
- en: Now let's get our hands dirty on the Docker CLI. We will look at the most common
    commands and their use cases. The Docker commands are modeled after Linux and
    Git, so if you have used either of these, you will find yourself at home with
    Docker.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在Docker CLI上动手。我们将看一下最常用的命令及其用法。Docker命令是模仿Linux和Git的，所以如果您使用过其中任何一个，您将发现在Docker中也能得心应手。
- en: Only the most commonly used options are mentioned here. For the complete reference,
    you can check out the official documentation at [https://docs.docker.com/reference/commandline/cli/](https://docs.docker.com/reference/commandline/cli/).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只提到了最常用的选项。要获取完整的参考信息，您可以查看官方文档[https://docs.docker.com/reference/commandline/cli/](https://docs.docker.com/reference/commandline/cli)。
- en: The daemon command
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 守护程序命令
- en: If you have installed the `docker` daemon through standard repositories, the
    command to start the `docker` daemon would have been added to the `init` script
    to automatically start as a service on startup. Otherwise, you will have to first
    run the `docker` daemon yourself for the client commands to work.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过标准存储库安装了`docker`守护程序，则启动`docker`守护程序的命令将被添加到`init`脚本中，以便在启动时自动启动服务。否则，您将需要自己运行`docker`守护程序，以使客户端命令正常工作。
- en: 'Now, while starting the daemon, you can run it with arguments that control
    the **Domain** **Name** **System** (**DNS**) configurations, storage drivers,
    and execution drivers for the containers:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在启动守护程序时，您可以使用控制**域** **名** **系统**（**DNS**）配置、存储驱动程序和容器的执行驱动程序的参数来运行它：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You'll need these only if you want to start the daemon yourself. Otherwise,
    you can start the `docker` daemon with `$ sudo service Docker start`. For OSX
    and Windows, you need to run the commands mentioned in [Chapter 1](ch01.html "Chapter 1. Unboxing
    Docker"), *Installing Docker*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在您想要自己启动守护程序时才需要这些。否则，您可以使用`$ sudo service Docker start`启动`docker`守护程序。对于OSX和Windows，您需要运行[第1章](ch01.html
    "第1章。打开Docker")中提到的命令，*安装Docker*。
- en: 'The following table describes the various flags:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格描述了各种标志：
- en: '| Flag | Explanation |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 说明 |'
- en: '| --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '| This runs Docker as a daemon. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 这以守护程序运行Docker。 |'
- en: '|'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '| This runs Docker in debug mode. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 这以调试模式运行Docker。 |'
- en: '|'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '| This is the execution driver to be used. The default execution driver is
    native, which uses `libcontainer`. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 这是要使用的执行驱动程序。默认的执行驱动程序是本机，它使用`libcontainer`。 |'
- en: '|'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '| This forces Docker to use a different storage driver. The default value is
    "", for which Docker uses AUFS. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 这会强制Docker使用不同的存储驱动程序。默认值为""，Docker使用AUFS。 |'
- en: '|'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| This sets the DNS server (or servers) for all Docker containers. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 这为所有Docker容器设置DNS服务器（或服务器）。 |'
- en: '|'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '| This sets the DNS search domain (or domains) for all Docker containers. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 这为所有Docker容器设置DNS搜索域（或域）。 |'
- en: '|'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '| This is the socket (or sockets) to bind to. It can be one or more of `tcp://host:port,
    unix:///path/to/socket, fd://* or fd://socketfd`. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 这是要绑定的套接字（或套接字）。可以是一个或多个`tcp://host:port, unix:///path/to/socket, fd://*
    or fd://socketfd`。 |'
- en: If multiple `docker` daemons are being simultaneously run, the client honors
    the value set by the `DOCKER_HOST` parameter. You can also make it connect to
    a specific daemon with the `-H` flag.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果同时运行多个`docker`守护程序，则客户端将遵循`DOCKER_HOST`参数设置的值。您还可以使用`-H`标志使其连接到特定的守护程序。
- en: 'Consider this command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个命令：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding command is the same as the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令与以下命令相同：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The version command
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本命令
- en: 'The `version` command prints out the version information:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`version`命令打印版本信息：'
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The info command
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息命令
- en: 'The `info` command prints the details of the `docker` daemon configuration
    such as the execution driver, the storage driver being used, and so on:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`info`命令打印`docker`守护程序配置的详细信息，例如执行驱动程序、正在使用的存储驱动程序等：'
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The run command
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: run命令
- en: 'The run command is the command that we will be using most frequently. It is
    used to run Docker containers:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: run命令是我们将经常使用的命令。它用于运行Docker容器：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '| Flags | Explanation |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|标志|解释|'
- en: '| --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '| Attach to the `stdin`, `stdout`, or `stderr` files (standard input, output,
    and error files.). |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|附加到`stdin`，`stdout`或`stderr`文件（标准输入，输出和错误文件）。'
- en: '|'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '| This runs the container in the background. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|在后台运行容器。'
- en: '|'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '| This runs the container in interactive mode (keeps the `stdin` file open).
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|以交互模式运行容器（保持`stdin`文件打开）。'
- en: '|'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '| This allocates a pseudo `tty` flag (which is required if you want to attach
    to the container''s terminal). |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '|分配伪`tty`标志（如果要附加到容器的终端，则需要）。'
- en: '|'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| This publishes a container''s port to the host (`ip:hostport:containerport`).
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '|将容器的端口发布到主机（`ip:hostport:containerport`）。'
- en: '|'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '| This automatically removes the container when exited (it cannot be used with
    the `-d` flag). |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|退出时自动删除容器（不能与`-d`标志一起使用）。'
- en: '|'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '| This gives additional privileges to this container. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|这为该容器提供了额外的特权。'
- en: '|'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '| This bind mounts a volume (from host => `/host:/container`; from docker =>
    `/container`). |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|绑定挂载卷（从主机=>`/host:/container`；从docker=>`/container`）。'
- en: '|'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '| This mounts volumes from specified containers. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|从指定的容器中挂载卷。'
- en: '|'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '| This is the working directory inside the container. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|这是容器内的工作目录。'
- en: '|'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '| This assigns a name to the container. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|为容器分配一个名称。'
- en: '|'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '| This assigns a hostname to the container. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|为容器分配一个主机名。'
- en: '|'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| This is the username or UID the container should run on. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|这是容器应该运行的用户名或UID。'
- en: '|'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '| This sets the environment variables. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|设置环境变量。'
- en: '|'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '| This reads environment variables from a new line-delimited file. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|从新的行分隔文件中读取环境变量。'
- en: '|'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '| This sets custom DNS servers. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '|设置自定义DNS服务器。'
- en: '|'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '| This sets custom DNS search domains. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|设置自定义DNS搜索域。'
- en: '|'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '| This adds link to another container (`name:alias`). |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|添加到另一个容器的链接（`name:alias`）。'
- en: '|'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '| This is the relative CPU share for this container. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|这是此容器的相对CPU份额。|'
- en: '|'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '| These are the CPUs in which to allow execution; starts with 0\. (For example,
    0 to 3). |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|这些是允许执行的CPU；从0开始。（例如，0到3）。'
- en: '|'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '| This is the memory limit for this container `(<number><b&#124;k&#124;m&#124;g>`).
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|这是此容器的内存限制`(<number><b|k|m|g>`)。'
- en: '|'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '| (v1.2+) This specifies a restart policy in case the container crashes. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '|（v1.2+）指定容器崩溃时的重启策略。'
- en: '|'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '| (v1.2+) This grants a capability to a container (refer to [Chapter 4](ch04.html
    "Chapter 4. Automation and Best Practices"), *Security Best Practices*). |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|（v1.2+）这向容器授予一个功能（参考[第4章](ch04.html "第4章 自动化和最佳实践")，“安全最佳实践”）。'
- en: '|'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '| (v1.2+) This blacklists a capability to a container (refer to [Chapter 4](ch04.html
    "Chapter 4. Automation and Best Practices"), *Security Best Practices*). |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|（v1.2+）这将把一个功能限制到一个容器中（参考[第4章](ch04.html "第4章 自动化和最佳实践")，“安全最佳实践”）。'
- en: '|'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '| (v1.2+) This mounts a device on a container. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|（v1.2+）这在容器上挂载设备。'
- en: 'While running a container, it is important to keep in mind that the container''s
    lifetime is associated with the lifetime of the command you run when you start
    the container. Now try to run this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行容器时，重要的是要记住，容器的生命周期与启动容器时运行的命令的生命周期相关联。现在尝试运行这个：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: What happened here? When we ran the simple command, `ps`, the container ran
    the command and exited. Therefore, we got an error.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？当我们运行简单命令`ps`时，容器运行了该命令并退出。因此，我们得到了一个错误。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `attach` command attaches the standard input and output to a running container.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`attach`命令将标准输入和输出附加到正在运行的容器上。'
- en: 'Another important piece of information here is that you don''t need to use
    the whole 64-character ID for all the commands that require the container ID.
    The first couple of characters are sufficient. With the same example as shown
    in the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一条重要的信息，您不需要为所有需要容器ID的命令使用完整的64字符ID。前面的几个字符就足够了。使用与以下代码中显示的相同示例：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A more convenient method though would be to name your containers yourself:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更方便的方法是自己为容器命名：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `-i` flag is necessary to have any kind of interaction in the container,
    and the `-t` flag is necessary to create a pseudo-terminal.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i`标志是必要的，以便在容器中进行任何交互，`-t`标志是必要的，以创建一个伪终端。'
- en: 'The previous example also made us aware of the fact that even after we exit
    a container, it is still in a `stopped` state. That is, we will be able to start
    the container again, with its filesystem layer preserved. You can see this by
    running the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例还让我们意识到，即使我们退出容器，它仍处于`stopped`状态。也就是说，我们可以重新启动容器，并保留其文件系统层。您可以通过运行以下命令来查看：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'While this can be convenient, you may pretty soon have your host''s disk space
    drying up as more and more containers are saved. So, if you are going to run a
    disposable container, you can run it with the `–-rm` flag, which will remove the
    container when the process exits:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很方便，但很快您的主机磁盘空间可能会耗尽，因为保存了越来越多的容器。因此，如果您要运行一个一次性容器，可以使用`--rm`标志运行它，这将在进程退出时删除容器：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Running a server
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行服务器
- en: 'Now, for our next example, we''ll try running a web server. This example is
    chosen because the most common practical use case of Docker containers is the
    shipping of web applications:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于我们的下一个示例，我们将尝试运行一个Web服务器。选择此示例是因为Docker容器最常见的实际用例是运行Web应用程序：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we know the problem; we have a server running in a container, but since
    the container''s IP is assigned by Docker dynamically, it makes things difficult.
    However, we can bind the container''s ports to the host''s ports and Docker will
    take care of forwarding the networking traffic. Now let''s try this command again
    with the `-p` flag:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道问题所在；我们在一个容器中运行了一个服务器，但由于Docker动态分配了容器的IP，这使事情变得困难。但是，我们可以将容器的端口绑定到主机的端口，Docker会负责转发网络流量。现在让我们再次尝试这个命令，加上`-p`标志：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now open your browser and go to `http://localhost:8000`. Voilà!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开浏览器，转到`http://localhost:8000`。大功告成！
- en: 'If you are an OS X user and you realize that you are not able to access `http://localhost:8000`,
    it is because VirtualBox hasn''t been configured to respond to **Network Address
    Translation** (**NAT**) requests to the boot2Docker VM. Adding the following function
    to your aliases file (`bash_profile` or .`bashrc`) will save a lot of trouble:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是OS X用户，并且意识到无法访问`http://localhost:8000`，那是因为VirtualBox尚未配置为响应对boot2Docker
    VM的**网络地址转换**（**NAT**）请求。将以下函数添加到您的别名文件（`bash_profile`或`.bashrc`）将节省很多麻烦：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After this, you should be able to use the `$ natboot2docker mypythonserver
    8000 8000` command to be able to access the Python server. But remember to run
    the `$ removeDockerDockerNat mypythonserver` command when you are done. Otherwise,
    when you run the boot2Docker VM next time, you will be faced with a bug that won''t
    allow you to get the IP address or the `ssh` script into it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您应该能够使用`$ natboot2docker mypythonserver 8000 8000`命令来访问Python服务器。但是请记住，在完成后运行`$
    removeDockerDockerNat mypythonserver`命令。否则，当您下次运行boot2Docker VM时，您将面临一个错误，它将不允许您获取IP地址或`ssh`脚本：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Your browser now shows the `/root` path of the container. What if you wanted
    to serve your host''s directories? Let''s try mounting a device:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您的浏览器现在显示容器的`/root`路径。如果您想要提供主机的目录怎么办？让我们尝试挂载设备：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, the `mount` command doesn't work. In fact, most kernel capabilities
    that are potentially dangerous are dropped, unless you include the `--privileged`
    flag.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，`mount`命令不起作用。实际上，除非包括`--privileged`标志，否则大多数潜在危险的内核功能都会被禁用。
- en: 'However, you should never use this flag unless you know what you are doing.
    Docker provides a much easier way to bind mount host volumes and bind mount host
    volumes with the `-v` and `–volumes` options. Let''s try this example again in
    the directory we are currently in:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，除非您知道自己在做什么，否则永远不要使用此标志。Docker提供了一种更简单的方式来绑定挂载主机卷和使用`-v`和`–volumes`选项绑定挂载主机卷。让我们在我们当前所在的目录中再次尝试这个例子：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You have now bound the directory you are running the commands from to the container.
    However, when you access the container, you still get the directory listing of
    the root of the container. To serve the directory that has been bound to the container,
    let''s set it as the working directory of the container (the directory the containerized
    process runs in) using the `-w` flag:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经将您从中运行命令的目录绑定到了容器。但是，当您访问容器时，仍然会得到容器根目录的目录列表。为了提供已绑定到容器的目录，让我们使用`-w`标志将其设置为容器的工作目录（容器化进程运行的目录）：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Boot2Docker users will not be able to utilize this yet, unless you use guest
    additions and set up shared folders, the guide to which can be found at [https://medium.com/boot2docker-lightweight-linux-for-docker/boot2docker-together-with-virtualbox-guest-additions-da1e3ab2465c](https://medium.com/boot2docker-lightweight-linux-for-docker/boot2docker-together-with-virtualbox-guest-additions-da1e3ab2465c).
    Though this solution works, it is a hack and is not recommended. Meanwhile, the
    Docker community is actively trying to find a solution (check out issue `#64`
    in the boot2Docker GitHub repository and `#4023` in the Docker repository).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Boot2Docker用户目前还无法利用这一功能，除非您使用了增强功能并设置了共享文件夹，可以在[https://medium.com/boot2docker-lightweight-linux-for-docker/boot2docker-together-with-virtualbox-guest-additions-da1e3ab2465c](https://medium.com/boot2docker-lightweight-linux-for-docker/boot2docker-together-with-virtualbox-guest-additions-da1e3ab2465c)找到相关指南。尽管这种解决方案有效，但这是一种hack方法，不建议使用。与此同时，Docker社区正在积极寻找解决方案（请查看boot2Docker
    GitHub存储库中的问题`#64`和Docker存储库中的问题`#4023`）。
- en: Now `http://localhost:8000` will serve the directory you are currently running
    in, but from a Docker container. Take care though, because any changes you make
    are written into the host's filesystem as well.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`http://localhost:8000`将提供您当前正在运行的目录，但是从Docker容器中提供。但要小心，因为您所做的任何更改也会写入主机的文件系统中。
- en: Tip
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Since v1.1.1, you can bind mount the root of the host to a container using `$
    docker run -v /:/my_host:ro ubuntu ls /my_host`, but mounting on the `/` path
    of the container is forbidden.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 自v1.1.1版本开始，您可以使用`$ docker run -v /:/my_host:ro ubuntu ls /my_host`将主机的根目录绑定到容器，但是禁止在容器的`/`路径上进行挂载。
- en: The volume can be optionally suffixed with the `:ro` or `:rw` commands to mount
    the volumes in read-only or read-write mode, respectively. By default, the volumes
    are mounted in the same mode (read-write or read-only) as they are in the host.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 卷可以选择地以`：ro`或`：rw`命令作为后缀，以只读或读写模式挂载卷。默认情况下，卷以与主机相同的模式（读写或只读）挂载。
- en: This option is mostly used to mount static assets and to write logs.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项主要用于挂载静态资产和写入日志。
- en: But what if I want to mount an external device?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我想挂载外部设备呢？
- en: Before v1.2, you had to mount the device in the host and bind mount using the
    `-v` flag in a privileged container, but v1.2 has added a `--device` flag that
    you can use to mount a device without needing to use the `--privileged` flag.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在v1.2之前，您必须在主机中挂载设备，并在特权容器中使用`-v`标志进行绑定挂载，但是v1.2添加了一个`--device`标志，您可以使用它来挂载设备，而无需使用`--privileged`标志。
- en: 'For example, to use the webcam in your container, run this command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在容器中使用网络摄像头，请运行此命令：
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Docker v1.2 also added a `--restart` flag to specify a restart policy for containers.
    Currently, there are three restart policies:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Docker v1.2还添加了一个`--restart`标志，用于为容器指定重新启动策略。目前有三种重新启动策略：
- en: '`no`: Do not restart the container if it dies (default).'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no`：如果容器死掉，则不重新启动（默认）。'
- en: '`on-failure`: Restart the container if it exits with a non-zero exit code.
    It can also accept an optional maximum restart count (for example, `on-failure:5`).'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on-failure`：如果以非零退出代码退出，则重新启动容器。它还可以接受一个可选的最大重新启动计数（例如，`on-failure:5`）。'
- en: '`always`: Always restart the container no matter what exit code is returned.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`always`：无论返回的退出代码是什么，都始终重新启动容器。'
- en: 'The following is an example to restart endlessly:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个无限重新启动的示例：
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The next line is used to try five times before giving up:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行用于在放弃之前尝试五次：
- en: '[PRE52]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The search command
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: search命令
- en: 'The `search` command allows us to search for Docker images in the public registry.
    Let''s search for all images related to Python:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`search`命令允许我们在公共注册表中搜索Docker镜像。让我们搜索与Python相关的所有镜像：'
- en: '[PRE53]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The pull command
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pull命令
- en: 'The `pull` command is used to pull images or repositories from a registry.
    By default, it pulls them from the public Docker registry, but if you are running
    your own registry, you can pull them from it too:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`pull`命令用于从注册表中拉取镜像或仓库。默认情况下，它们从公共Docker注册表中拉取，但如果您运行自己的注册表，也可以从中拉取它们：'
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The start command
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: start命令
- en: 'We saw when we discussed `docker run` that the container state is preserved
    on exit unless it is explicitly removed. The `docker start` command starts a stopped
    container:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在讨论`docker run`时看到，容器状态在退出时会被保留，除非明确删除。`docker start`命令用于启动已停止的容器：
- en: '[PRE55]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Consider the following example of the `start` command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`start`命令的示例：
- en: '[PRE56]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The options have the same meaning as with the `docker run` command.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 选项的含义与`docker run`命令相同。
- en: The stop command
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: stop命令
- en: 'The `stop` command stops a running container by sending the `SIGTERM` signal
    and then the `SIGKILL` signal after a grace period:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: stop命令通过发送`SIGTERM`信号然后在宽限期之后发送`SIGKILL`信号来停止正在运行的容器：
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`SIGTERM` and `SIGKILL` are Unix signals. A signal is a form of interprocess
    communication used in Unix, Unix-like, and other POSIX-compliant operating systems.
    `SIGTERM` signals the process to terminate. The `SIGKILL` signal is used to forcibly
    kill a process.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGTERM`和`SIGKILL`是Unix信号。信号是Unix、类Unix和其他符合POSIX的操作系统中使用的一种进程间通信形式。`SIGTERM`信号指示进程终止。`SIGKILL`信号用于强制终止进程。'
- en: '[PRE57]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can also specify the `-t` flag or `--time` flag, which allows you to set
    the wait time.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指定`-t`标志或`--time`标志，允许您设置等待时间。
- en: The restart command
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: restart命令
- en: 'The `restart` command restarts a running container:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`restart`命令重新启动正在运行的容器：'
- en: '[PRE58]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If you observe the status, you will notice that the container was rebooted.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您观察状态，您会注意到容器已经重新启动。
- en: The rm command
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: rm命令
- en: 'The `rm` command removes Docker containers:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`rm`命令用于删除Docker容器：'
- en: '[PRE59]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We seem to be having a lot of containers left over after our adventures. Let''s
    remove one of them:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的冒险之后，似乎有很多容器剩下。让我们移除其中一个：
- en: '[PRE60]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can also combine two Docker commands. Let''s combine the `docker ps -a -q`
    command, which prints the ID parameters of the containers in the `docker ps -a`,
    and `docker rm` commands, to remove all containers in one go:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以组合两个Docker命令。让我们将`docker ps -a -q`命令（打印`docker ps -a`中容器的ID参数）和`docker
    rm`命令结合起来，一次性删除所有容器：
- en: '[PRE61]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This evaluates the `docker ps -a -q` command first, and the output is used by
    the `docker rm` command.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先对`docker ps -a -q`命令进行评估，然后输出由`docker rm`命令使用。
- en: The ps command
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ps命令
- en: 'The `ps` command is used to list containers. It is used in the following way:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps`命令用于列出容器。它的使用方式如下：'
- en: '[PRE62]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '| Flag | Explanation |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 解释 |'
- en: '| --- | --- |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE63]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '| This shows all containers, including stopped ones. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 这显示所有容器，包括已停止的容器。 |'
- en: '|'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE64]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '| This shows only container ID parameters. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 这仅显示容器ID参数。 |'
- en: '|'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE65]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '| This prints the sizes of the containers. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 这打印出容器的大小。 |'
- en: '|'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE66]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '| This shows only the latest container (including stopped containers). |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 这只显示最新的容器（包括已停止的容器）。 |'
- en: '|'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE67]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '| This shows the last *n* containers (including stopped containers). Its default
    value is -1. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 这显示最后*n*个容器（包括已停止的容器）。其默认值为-1。 |'
- en: '|'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE68]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '| This shows the containers created before the specified ID or name. It includes
    stopped containers. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 这显示了在指定ID或名称之前创建的容器。它包括已停止的容器。 |'
- en: '|'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE69]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '| This shows the containers created after the specified ID or name. It includes
    stopped containers. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 这显示了在指定ID或名称之后创建的容器。它包括已停止的容器。 |'
- en: The `docker ps` command will show only running containers by default. To see
    all containers, run the `docker ps -a` command. To see only container ID parameters,
    run it with the `-q` flag.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker ps`命令默认只显示正在运行的容器。要查看所有容器，请运行`docker ps -a`命令。要仅查看容器ID参数，请使用`-q`标志运行它。'
- en: The logs command
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: logs命令
- en: 'The `logs` command shows the logs of the container:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`logs`命令显示容器的日志：'
- en: '[PRE70]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: You can also provide a `--tail` argument to follow the output as the container
    is running.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以提供一个`--tail`参数来跟踪容器运行时的输出。
- en: The inspect command
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: inspect命令
- en: 'The `inspect` command allows you to get the details of a container or an image.
    It returns those details as a JSON array:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`inspect`命令允许你获取容器或镜像的详细信息。它将这些详细信息作为JSON数组返回：'
- en: '[PRE71]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Similarly, for a container we run the following command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于一个容器，我们运行以下命令：
- en: '[PRE72]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Docker inspect provides all of the low-level information about a container or
    image. In the preceding example, find out the IP address of the container and
    the exposed port and make a request to the `IP:port`. You will see that you are
    directly accessing the server running in the container.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Docker inspect提供了关于容器或镜像的所有低级信息。在上面的例子中，找出容器的IP地址和暴露的端口，并向`IP:port`发出请求。你会发现你直接访问了在容器中运行的服务器。
- en: 'However, manually looking through the entire JSON array is not optimal. So
    the `inspect` command provides a flag, `-f` (or the `--follow` flag), which allows
    you to specify exactly what you want using `Go` templates. For example, if you
    just want to get the container''s IP address, run the following command:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，手动查看整个JSON数组并不是最佳选择。因此，`inspect`命令提供了一个标志`-f`（或`--follow`标志），允许你使用`Go`模板精确地指定你想要的内容。例如，如果你只想获取容器的IP地址，运行以下命令：
- en: '[PRE73]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `{{.NetworkSettings.IPAddress}}` is a `Go` template that was executed over
    the JSON result. `Go` templates are very powerful, and some of the things that
    you can do with them have been listed at [http://golang.org/pkg/text/template/](http://golang.org/pkg/text/template/).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{.NetworkSettings.IPAddress}}`是在JSON结果上执行的`Go`模板。`Go`模板非常强大，你可以在[http://golang.org/pkg/text/template/](http://golang.org/pkg/text/template/)上列出一些你可以用它们做的事情。'
- en: The top command
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: top命令
- en: The `top` command shows the running processes in a container and their statistics,
    mimicking the Unix `top` command.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`top`命令显示容器中正在运行的进程及其统计信息，模仿Unix的`top`命令。'
- en: 'Let''s download and run the `ghost` blogging platform and check out what processes
    are running in it:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们下载并运行`ghost`博客平台，并查看其中运行的进程：
- en: '[PRE74]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Yes! We just set up our very own `ghost` blog, with just one command. This brings
    forth another subtle advantage and shows something that could be a future trend.
    Every tool that exposes its services through a TCP port can now be containerized
    and run in its own sandboxed world. All you need to do is expose its port and
    bind it to your host port. You don't need to worry about installations, dependencies,
    incompatibilities, and so on, and the uninstallation will be clean because all
    you need to do is stop all the containers and remove the image.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！我们只需一条命令就设置了我们自己的`ghost`博客。这带来了另一个微妙的优势，并展示了可能是未来趋势的东西。现在，通过TCP端口暴露其服务的每个工具都可以被容器化，并在其自己的沙盒世界中运行。你只需要暴露它的端口并将其绑定到你的主机端口。你不需要担心安装、依赖关系、不兼容性等，卸载将是干净的，因为你只需要停止所有的容器并删除镜像。
- en: Note
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ghost is an open source publishing platform that is beautifully designed, easy
    to use, and free for everyone. It is coded in Node.js, a server-side JavaScript
    execution engine.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Ghost是一个开源的发布平台，设计精美，易于使用，对所有人免费。它是用Node.js编写的，是一个服务器端JavaScript执行引擎。
- en: The attach command
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加命令
- en: The `attach` command attaches to a running container.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`attach`命令用于附加到正在运行的容器。'
- en: Let's start a container with Node.js, running the node interactive shell as
    a daemon, and later attach to it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动一个带有Node.js的容器，将node交互式shell作为守护进程运行，然后稍后附加到它。
- en: Note
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Node.js is an event-driven, asynchronous I/O web framework that runs applications
    written in JavaScript on Google's V8 runtime environment.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是一个事件驱动的、异步I/O的Web框架，它在Google的V8运行环境上运行用JavaScript编写的应用程序。
- en: 'The container with Node.js is as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 带有Node.js的容器如下：
- en: '[PRE75]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The kill command
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 杀死命令
- en: 'The `kill` command kills a container and sends the `SIGTERM` signal to the
    process running in the container:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`kill`命令会杀死一个容器，并向容器中运行的进程发送`SIGTERM`信号：'
- en: '[PRE76]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The cp command
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cp命令
- en: The `cp` command copies a file or folder from a container's filesystem to the
    host path. Paths are relative to the root of the filesystem.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`cp`命令将文件或文件夹从容器的文件系统复制到主机路径。路径是相对于文件系统的根目录的。'
- en: 'It''s time to have some fun. First, let''s run an Ubuntu container with the
    `/bin/bash` command:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候玩一些游戏了。首先，让我们用`/bin/bash`命令运行一个Ubuntu容器：
- en: '[PRE77]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, inside the container, let''s create a file with a special name:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在容器内部，让我们创建一个带有特殊名称的文件：
- en: '[PRE78]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `\007` character is an ASCII `BEL` character that rings the system bell
    when printed on a terminal. You might have already guessed what we''re about to
    do. So let''s open a new terminal and execute the following command to copy this
    newly created file to the host:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`\ 007`字符是ASCII`BEL`字符，当在终端上打印时会响铃系统。你可能已经猜到我们要做什么了。所以让我们打开一个新的终端，并执行以下命令将这个新创建的文件复制到主机：'
- en: '[PRE79]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Tip
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For the `docker cp` command to work, both the container path and the host path
    must be complete, so do not use shortcuts such as `.`, `,`, `*`, and so on.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`docker cp`命令工作，容器路径和主机路径都必须完整，所以不要使用`.`、`,`、`*`等快捷方式。
- en: 'So we created an empty file whose filename is the `BEL` character, in a container.
    Then we copied the file to the current directory in the host container. Just one
    last step is remaining. In the host tab where you executed the `docker cp` command,
    run the following command:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们在容器中创建了一个文件名为`BEL`字符的空文件。然后我们将文件复制到主机容器中的当前目录。只剩最后一步了。在执行`docker cp`命令的主机标签中，运行以下命令：
- en: '[PRE80]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: You will hear the system bell ring! We could have copied any file or directory
    from the container to the host. But it doesn't hurt to have some fun!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你会听到系统铃声响起！我们本可以从容器中复制任何文件或目录到主机。但玩一些游戏也无妨！
- en: Note
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you found this interesting, you might like to read [http://www.dwheeler.com/essays/fixing-unix-linux-filenames.html](http://www.dwheeler.com/essays/fixing-unix-linux-filenames.html).
    This is a great essay that discusses the edge cases in filenames, which can cause
    simple to complicated issues in a program.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您觉得这很有趣，您可能会喜欢阅读[http://www.dwheeler.com/essays/fixing-unix-linux-filenames.html](http://www.dwheeler.com/essays/fixing-unix-linux-filenames.html)。这是一篇很棒的文章，讨论了文件名中的边缘情况，这可能会在程序中引起简单到复杂的问题。
- en: The port command
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端口命令
- en: 'The `port` command looks up the public-facing port that is bound to an exposed
    port in the container:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`port`命令查找绑定到容器中公开端口的公共端口：'
- en: '[PRE81]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Ghost runs a server at the `2368` port that allows you to write and publish
    a blog post. We bound a host port to the `OD-ghost` container's port `2368` in
    the example for the `top` command.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Ghost在`2368`端口运行一个服务器，允许您编写和发布博客文章。在示例中，我们将主机端口绑定到`OD-ghost`容器的端口`2368`。
- en: Running your own project
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行您自己的项目
- en: By now, we are considerably familiar with the basic Docker commands. Let's up
    the ante. For the next couple of commands, I am going to use one of my side projects.
    Feel free to use a project of your own.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经相当熟悉基本的Docker命令。让我们提高赌注。在接下来的几个命令中，我将使用我的一个副业项目。请随意使用您自己的项目。
- en: Let's start by listing out our requirements to determine the arguments we must
    pass to the `docker run` command.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先列出我们的要求，以确定我们必须传递给`docker run`命令的参数。
- en: 'Our application is going to run on Node.js, so we will choose the well-maintained
    `dockerfile/nodejs` image to start our base container:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将在Node.js上运行，因此我们将选择维护良好的`dockerfile/nodejs`镜像来启动我们的基础容器：
- en: We know that our application is going to bind to port `8000`, so we will expose
    the port to `8000` of the host.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们知道我们的应用程序将绑定到端口`8000`，因此我们将将端口暴露给主机的`8000`端口。
- en: 'We need to give a descriptive name to the container so that we can reference
    it in future commands. In this case, let''s choose the name of the application:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要为容器指定一个描述性名称，以便我们可以在将来的命令中引用它。在这种情况下，让我们选择应用程序的名称：
- en: '[PRE82]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Once you have started your container, you need to check whether the dependencies
    for your application are already available. In our case, we only need Git (apart
    from Node.js), which is already installed in the `dockerfile/nodejs` image.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您启动了容器，您需要检查应用程序的依赖项是否已经可用。在我们的情况下，除了Node.js之外，我们只需要Git，它已经安装在`dockerfile/nodejs`镜像中。
- en: 'Now that our container is ready to run our application, all that is remaining
    is for us to fetch the source code and do the necessary setup to run the application:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的容器已经准备好运行我们的应用程序，剩下的就是获取源代码并进行必要的设置来运行应用程序：
- en: '[PRE83]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This downloads the source code for a plugin used in the application.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载应用程序中使用的插件的源代码。
- en: 'Then run the following command:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行以下命令：
- en: '[PRE84]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Now all the node modules required to run the application are installed.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有运行应用程序所需的节点模块都已安装。
- en: 'Next, run this command:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行此命令：
- en: '[PRE85]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now you can go to `localhost:8000` to use the application.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以转到`localhost:8000`来使用该应用程序。
- en: The diff command
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 差异命令
- en: 'The `diff` command shows the difference between the container and the image
    it is based on. In this example, we are running a container with `code.it`. In
    a separate tab, run this command:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`diff`命令显示容器与其基于的镜像之间的差异。在这个例子中，我们正在运行一个带有`code.it`的容器。在一个单独的标签中，运行此命令：'
- en: '[PRE86]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The commit command
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提交命令
- en: 'The `commit` command creates a new image with the filesystem of the container.
    Just as with Git''s `commit` command, you can set a commit message that describes
    the image:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`commit`命令使用容器的文件系统创建一个新的镜像。就像Git的`commit`命令一样，您可以设置描述镜像的提交消息：'
- en: '[PRE87]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '| Flag | Explanation |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 解释 |'
- en: '| --- | --- |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE88]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '| This pause the container during commit (availabe from v1.1.1+ onwards). |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 这在提交期间暂停容器（从v1.1.1+开始可用）。 |'
- en: '|'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE89]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '| This is a commit message. It can be a description of what the image does.
    |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 这是提交消息。它可以是对图像功能的描述。 |'
- en: '|'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE90]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '| This displays the author details. |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 这显示了作者的详细信息。 |'
- en: 'For example, let''s use this command to commit the container we have set up:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们使用这个命令来提交我们设置的容器：
- en: '[PRE91]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Tip
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Replace the author details and the username portion of the image name in this
    example if you are copying these examples.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在复制这些示例，请替换作者详细信息和图像名称的用户名部分。
- en: The output will be a lengthy image ID. If you look at the command closely, we
    have named the image `shrikrishna/code.it:v1`. This is a convention. The first
    part of an image/repository's name (before the forward slash) is the Docker Hub
    username of the author. The second part is the intended application or image name.
    The third part is a tag (usually a version description) separated from the second
    part by a colon.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是一个冗长的图像ID。如果您仔细查看命令，我们已经命名了图像`shrikrishna/code.it:v1`。这是一个约定。图像/存储库名称的第一部分（斜杠之前）是作者的Docker
    Hub用户名。第二部分是预期的应用程序或图像名称。第三部分是一个标签（通常是版本描述），用冒号与第二部分分隔。
- en: Note
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`Docker` `Hub` is a public registry maintained by Docker, Inc. It hosts public
    Docker images and provides services to help you build and manage your Docker environment.
    More details about it can be found at [https://hub.docker.com](https://hub.docker.com).'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`Docker` `Hub`是由Docker，Inc维护的公共注册表。它托管公共Docker图像，并提供帮助您构建和管理Docker环境的服务。有关更多详细信息，请访问[https://hub.docker.com](https://hub.docker.com)。'
- en: A collection of images tagged with different versions is a repository. The image
    you create by running the `docker commit` command will be a local one, which means
    that you will be able to run containers from it but it won't be available publicly.
    To make it public or to push to your private Docker registry, use the `docker
    push` command.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 带有不同版本标签的图像集合是一个存储库。通过运行`docker commit`命令创建的图像将是本地图像，这意味着您将能够从中运行容器，但它不会公开可用。要使其公开或推送到您的私有Docker注册表，请使用`docker
    push`命令。
- en: The images command
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: images命令
- en: 'The `images` command lists all the images in the system:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`images`命令列出系统中的所有图像：'
- en: '[PRE92]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '| Flag | Explanation |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 说明 |'
- en: '| --- | --- |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE93]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '| This shows all images, including intermediate layers. |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 这显示所有图像，包括中间层。 |'
- en: '|'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE94]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '| This provides filter values. |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 这提供过滤值。 |'
- en: '|'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE95]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '| This doesn''t truncate output (shows complete ID). |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| 这不会截断输出（显示完整的ID）。 |'
- en: '|'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE96]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '| This shows only the image IDs. |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| 这只显示图像ID。 |'
- en: 'Now let''s look at a few examples of the usage of the `image` command:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下`image`命令的几个用法示例：
- en: '[PRE97]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This lists all top-level images, their repository and tags, and their virtual
    size.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这列出了所有顶层图像，它们的存储库和标签，以及它们的虚拟大小。
- en: Docker images are nothing but a stack of read-only filesystem layers. A union
    filesystem, such as AUFS, then merges these layers and they appear to be one filesystem.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: Docker图像只是一堆只读文件系统层。然后，像AUFS这样的联合文件系统合并这些层，它们看起来像是一个文件系统。
- en: In Docker-speak, a read-only layer is an image. It never changes. When running
    a container, the processes think that the entire filesystem is read-write. But
    the changes go only at the topmost writeable layer, which is created when a container
    is started. The read-only layers of the image remain unchanged. When you commit
    a container, it freezes the top layer (the underlying layers are already frozen)
    and turns it into an image. Now, when a container is started this image, all the
    layers of the image (including the previously writeable layer) are read-only.
    All the changes are now made to a new writeable layer on top of all the underlying
    layers. However, because of how union filesystems (such as AUFS) work, the processes
    believe that the filesystem is read-write.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker术语中，只读层就是一个图像。它永远不会改变。当运行一个容器时，进程会认为整个文件系统是可读写的。但是更改只会发生在最顶层的可写层，这是在容器启动时创建的。图像的只读层保持不变。当你提交一个容器时，它会冻结顶层（底层已经冻结）并将其转换为图像。现在，当一个容器启动这个图像时，图像的所有层（包括之前的可写层）都是只读的。所有的更改现在都是在所有底层的顶部创建一个新的可写层。然而，由于联合文件系统（如AUFS）的工作方式，进程认为文件系统是可读写的。
- en: 'A rough schematic of the layers involved in our `code.it` example is as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`code.it`示例中涉及的层次的大致示意图如下：
- en: '![The images command](graphics/4787OS_02_02.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![图像命令](graphics/4787OS_02_02.jpg)'
- en: Note
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At this point, it might be wise to think just how much effort is to be made
    by the union filesystems to merge all of these layers and provide a consistent
    performance. After some point, things inevitably break. AUFS, for instance, has
    a 42-layer limit. When the number of layers goes beyond this, it just doesn't
    allow the creation of any more layers and the build fails. Read [https://github.com/docker/docker/issues/1171](https://github.com/docker/docker/issues/1171)
    for more information on this issue.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，可能明智地考虑联合文件系统需要多大的努力来合并所有这些层，并提供一致的性能。在某个时候，事情不可避免地会出错。例如，AUFS有一个42层的限制。当层数超过这个限制时，它就不允许创建更多的层，构建就会失败。阅读[https://github.com/docker/docker/issues/1171](https://github.com/docker/docker/issues/1171)获取更多关于这个问题的信息。
- en: 'The following command lists the most recently created images:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令列出了最近创建的图像：
- en: '[PRE98]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The `-f` flag can be given arguments of the `key=value` type. It is frequently
    used to get the list of dangling images:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f`标志可以给出`key=value`类型的参数。它经常用于获取悬空图像的列表：'
- en: '[PRE99]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This will display untagged images, that is, images that have been committed
    or built without a tag.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示未标记的图像，也就是说，已经提交或构建而没有标记的图像。
- en: The rmi command
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: rmi命令
- en: 'The `rmi` command removes images. Removing an image also removes all the underlying
    images that it depends on and were downloaded when it was pulled:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`rmi`命令删除图像。删除一个图像也会删除它所依赖的所有底层图像，并在拉取时下载的图像：'
- en: '[PRE100]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '| Flag | Explanation |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 解释 |'
- en: '| --- | --- |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE101]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '| This forcibly removes the image (or images). |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| 这将强制删除图像（或图像）。 |'
- en: '|'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE102]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '| This command does not delete untagged parents. |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| 这个命令不会删除未标记的父级。 |'
- en: 'This command removes one of the images from your machine:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令从你的机器中删除一个图像：
- en: '[PRE103]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The save command
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存命令
- en: 'The `save` command saves an image or repository in a tarball and this streams
    to the `stdout` file, preserving the parent layers and metadata about the image:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`save`命令将图像或存储库保存在一个tarball中，并将其流到`stdout`文件，保留有关图像的父层和元数据：'
- en: '[PRE104]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The `-o` flag allows us to specify a file instead of streaming to the `stdout`
    file. It is used to create a backup that can then be used with the `docker load`
    command.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`-o`标志允许我们指定一个文件而不是流到`stdout`文件。它用于创建一个备份，然后可以与`docker load`命令一起使用。'
- en: The load command
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载命令
- en: 'The `load` command loads an image from a tarball, restoring the filesystem
    layers and the metadata associated with the image:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`load`命令从tarball中加载图像，恢复文件系统层和与图像相关的元数据：'
- en: '[PRE105]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The `-i` flag allows us to specify a file instead of trying to get a stream
    from the `stdin` file.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i`标志允许我们指定一个文件，而不是尝试从`stdin`文件获取流。'
- en: The export command
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出命令
- en: 'The `export` command saves the filesystem of a container as a tarball and streams
    to the `stdout` file. It flattens filesystem layers. In other words, it merges
    all the filesystem layers. All of the metadata of the image history is lost in
    this process:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`export`命令将容器的文件系统保存为tarball并流式传输到`stdout`文件。它会展平文件系统层。换句话说，它会合并所有文件系统层。在此过程中，图像历史的所有元数据都会丢失：'
- en: '[PRE106]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Here, `red_panda` is the name of one of my containers.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`red_panda`是我其中一个容器的名称。
- en: The import command
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入命令
- en: 'The `import` command creates an empty filesystem image and imports the contents
    of the tarball to it. You have the option of tagging it the image:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`命令创建一个空的文件系统映像，并将tarball的内容导入其中。您可以选择为该图像打标签：'
- en: '[PRE107]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: URLs must start with `http`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: URL必须以`http`开头。
- en: '[PRE108]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'If you would like to import from a local directory or archive, you can use
    the - parameter to take the data from the `stdin` file:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要从本地目录或存档中导入，可以使用-参数从`stdin`文件中获取数据：
- en: '[PRE109]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The tag command
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签命令
- en: You can add a `tag` command to an image. It helps identify a specific version
    of an image.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向图像添加`tag`命令。它有助于识别图像的特定版本。
- en: 'For example, the `python` image name represents `python:latest`, the latest
    version of Python available, which can change from time to time. But whenever
    it is updated, the older versions are tagged with the respective Python versions.
    So the `python:2.7` command will have Python 2.7 installed. Thus, the `tag` command
    can be used to represent versions of the images, or for any other purposes that
    need identification of the different versions of the image:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`python`图像名称表示`python:latest`，即可用的最新版本的Python，这可能会随时更改。但每当它更新时，旧版本都会用相应的Python版本标记。因此，`python:2.7`命令将安装Python
    2.7。因此，`tag`命令可用于表示图像的版本，或用于需要识别不同图像版本的任何其他目的：
- en: '[PRE110]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The `REGISTRYHOST` command is only needed if you are using a private registry
    of your own. The same image can have multiple tags:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`REGISTRYHOST`命令仅在您使用自己的私有注册表时才需要。同一图像可以有多个标签：'
- en: '[PRE111]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Tip
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Whenever you are tagging an image, follow the `username/repository:tag` convention.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您给图像打标签时，请遵循`username/repository:tag`约定。
- en: 'Now, running the `docker images` command again will show that the same image
    has been tagged with both the `v1` and `latest` commands:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行`docker images`命令将显示相同的图像已被标记为`v1`和`latest`命令：
- en: '[PRE112]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The login command
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录命令
- en: 'The `login` command is used to register or log in to a Docker registry server.
    If no server is specified, [https://index.docker.io/v1/](https://index.docker.io/v1/)
    is the default:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`login`命令用于注册或登录到Docker注册服务器。如果未指定服务器，默认为[https://index.docker.io/v1/](https://index.docker.io/v1/)。'
- en: '[PRE113]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '| Flag | Explanation |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '|标志|解释|'
- en: '| --- | --- |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE114]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '| Email |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '|电子邮件|'
- en: '|'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE115]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '| Password |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '|密码|'
- en: '|'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE116]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '| Username |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '|用户名|'
- en: If the flags haven't been provided, the server will prompt you to provide the
    details. After the first login, the details will be stored in the `$HOME/.dockercfg`
    path.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未提供标志，则服务器将提示您提供详细信息。第一次登录后，详细信息将存储在`$HOME/.dockercfg`路径中。
- en: The push command
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推送命令
- en: 'The `push` command is used to push an image to the public image registry or
    a private Docker registry:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`push`命令用于将图像推送到公共图像注册表或私有Docker注册表：'
- en: '[PRE117]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The history command
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 历史命令
- en: 'The `history` command shows the history of the image:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`history`命令显示图像的历史记录：'
- en: '[PRE118]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The events command
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件命令
- en: 'Once started, the `events` command prints all the events that are handled by
    the `docker` daemon, in real time:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，`events`命令会实时打印`docker`守护程序处理的所有事件：
- en: '[PRE119]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '| Flag | Explanation |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 解释 |'
- en: '| --- | --- |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE120]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '| This shows all events created since timestamp (in Unix). |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| 这显示自Unix时间戳以来创建的所有事件。 |'
- en: '|'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE121]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '| This stream events until timestamp. |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| 这个流事件直到时间戳。 |'
- en: 'For example the `events` command is used as follows:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`events`命令的使用如下：
- en: '[PRE122]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Now, in a different tab, run this command:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在另一个标签中，运行以下命令：
- en: '[PRE123]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Then run the following command:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行以下命令：
- en: '[PRE124]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Now go back to the tab running Docker events and see the output. It will be
    along these lines:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到运行Docker事件的标签并查看输出。它将沿着这些线路进行：
- en: '[PRE125]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: You can use flags such as `--since` and `--until` to get the event logs of specific
    timeframes.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`--since`和`--until`等标志来获取特定时间范围内的事件日志。
- en: The wait command
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待命令
- en: 'The `wait` command blocks until a container stops, then prints its exit code:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait`命令会阻塞，直到容器停止，然后打印其退出代码：'
- en: '[PRE126]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The build command
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建命令
- en: 'The build command builds an image from the source files at a specified path:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 构建命令从指定路径的源文件构建镜像：
- en: '[PRE127]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '| Flag | Explanation |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 解释 |'
- en: '| --- | --- |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE128]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '| This is the repository name (and an optional tag) to be applied to the resulting
    image in case of success. |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| 这是要应用于成功时生成的图像的存储库名称（和可选标签）。 |'
- en: '|'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE129]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '| This suppresses the output, which by default is verbose. |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| 这会抑制默认情况下冗长的输出。 |'
- en: '|'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE130]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '| This removes intermediate containers after a successful build. |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| 这会在成功构建后删除中间容器。 |'
- en: '|'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE131]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '| This always removes intermediate containers, even after unsuccessful builds.
    |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '| 这总是在构建失败后删除中间容器。 |'
- en: '|'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE132]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '| This command does not use the cache while building the image. |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| 此命令在构建镜像时不使用缓存。 |'
- en: This command uses a Dockerfile and a context to build a Docker image.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令使用Dockerfile和上下文来构建Docker镜像。
- en: A Dockerfile is like a Makefile. It contains instructions on the various configurations
    and commands that need to be run in order to create an image. We will look at
    writing Dockerfiles in the next section.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile就像一个Makefile。它包含了各种配置和命令的指令，需要运行以创建一个镜像。我们将在下一节中讨论编写Dockerfiles。
- en: Tip
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It would be a good idea to read the section about Dockerfiles first and then
    come back here to get a better understanding of this command and how it works.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 最好先阅读关于Dockerfiles的部分，然后再回到这里，以更好地理解这个命令以及它是如何工作的。
- en: The files at the `PATH` or `URL` paths are called **context** of the build.
    The context is used to refer to the files or folders in the Dockerfile, for instance
    in the `ADD` instruction (and that is the reason an instruction such as `ADD ../file.txt`
    won't work. It's not in the context!).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PATH`或`URL`路径下的文件被称为构建的**上下文**。上下文用于指代Dockerfile中的文件或文件夹，例如在`ADD`指令中（这就是为什么诸如`ADD
    ../file.txt`这样的指令不起作用。它不在上下文中！）。
- en: When a GitHub URL or a URL with the `git://` protocol is given, the repository
    is used as the context. The repository and its submodules are recursively cloned
    in your local machine, and then uploaded to the `docker` daemon as the context.
    This allows you to have Dockerfiles in your private Git repositories, which you
    can access from your local user credentials or from the **Virtual** **Private**
    **Network** (**VPN**).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 当给出GitHub URL或带有`git://`协议的URL时，该存储库将被用作上下文。该存储库及其子模块将递归克隆到您的本地机器，然后作为上下文上传到`docker`守护程序。这允许您在私人Git存储库中拥有Dockerfiles，您可以从本地用户凭据或**虚拟****私人****网络**（**VPN**）访问。
- en: Uploading to Docker daemon
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传到Docker守护程序
- en: Remember that Docker engine has both the `docker` daemon and the Docker client.
    The commands that you give as a user are through the Docker client, which then
    talks to the `docker` daemon (either through a TCP or a Unix socket), which does
    the necessary work. The `docker` daemon and Docker host can be in different hosts
    (which is the premise with which boot2Docker works), with the `DOCKER_HOST` environment
    variable set to the location of the remote `docker` daemon.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Docker引擎既有`docker`守护程序又有Docker客户端。您作为用户给出的命令是通过Docker客户端，然后再与`docker`守护程序（通过TCP或Unix套接字）进行通信，它会执行必要的工作。`docker`守护程序和Docker主机可以在不同的主机上（这是boot2Docker的前提），并且`DOCKER_HOST`环境变量设置为远程`docker`守护程序的位置。
- en: When you give a context to the `docker build` command, all the files in the
    local directory get tared and are sent to the `docker` daemon. The `PATH` variable
    specifies where to find the files for the context of the build in the `docker`
    daemon. So when you run `docker build .`, all the files in the current folder
    get uploaded, not just the ones listed to be added in the Dockerfile.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 当您为`docker build`命令提供上下文时，本地目录中的所有文件都会被打包并发送到`docker`守护程序。`PATH`变量指定了在`docker`守护程序中构建上下文的文件的位置。因此，当您运行`docker
    build .`时，当前文件夹中的所有文件都会被上传，而不仅仅是Dockerfile中列出要添加的文件。
- en: Since this can be a bit of a problem (as some systems such as Git and some IDEs
    such as Eclipse create hidden folders to store metadata), Docker provides a mechanism
    to ignore certain files or folders by creating a file called `.dockerignore` in
    the `PATH` variable with the necessary exclusion patterns. For an example, look
    up [https://github.com/docker/docker/blob/master/.dockerignore](https://github.com/docker/docker/blob/master/.dockerignore).
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这可能会有些问题（因为一些系统如Git和一些IDE如Eclipse会创建隐藏文件夹来存储元数据），Docker提供了一种机制来忽略某些文件或文件夹，方法是在`PATH`变量中创建一个名为`.dockerignore`的文件，并添加必要的排除模式。例如，查看[https://github.com/docker/docker/blob/master/.dockerignore](https://github.com/docker/docker/blob/master/.dockerignore)。
- en: If a plain URL is given or if the Dockerfile is streamed through the `stdin`
    file, then no context is set. In these cases, the `ADD` instruction works only
    if it refers to a remote URL.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了一个普通的URL，或者Dockerfile通过`stdin`文件流传输，那么不会设置上下文。在这些情况下，只有当`ADD`指令引用远程URL时才起作用。
- en: Now let's build the `code.it` example image through a Dockerfile. The instructions
    on how to create this Dockerfile are provided in the *Dockerfile* section.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过Dockerfile构建`code.it`示例图像。如何创建这个Dockerfile的说明在*Dockerfile*部分提供。
- en: 'At this point, you would have created a directory and placed the Dockerfile
    inside it. Now, on your terminal, go to that directory and execute the `docker`
    `build` command:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经创建了一个目录，并在其中放置了Dockerfile。现在，在您的终端上，转到该目录并执行`docker build`命令：
- en: '[PRE133]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Now, you will be able to look at your newly built image in the output of Docker
    images
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将能够在Docker镜像的输出中查看您新构建的图像
- en: '[PRE134]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: To see the caching in action, run the same command again
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看缓存的实际效果，请再次运行相同的命令
- en: '[PRE135]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Tip
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Now experiment with this caching. Change one of the lines in the middle (the
    port number for example), or add a `RUN echo "testing cache"` line somewhere in
    the middle and see what happens.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用缓存。更改中间的一行（例如端口号），或者在中间的某个地方添加一个`RUN echo "testing cache"`行，看看会发生什么。
- en: 'An example of building an image using a repository URL is as follows:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 使用存储库URL构建图像的示例如下：
- en: '[PRE136]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Dockerfile
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile
- en: We have seen how to create images by committing containers. What if you want
    to update the image with new versions of dependencies or new versions of your
    own application? It soon becomes impractical to do the steps of starting, setting
    up, and committing over and over again. We need a repeatable method to build images.
    In comes Dockerfile, which is nothing more than a text file that contains instructions
    to automate the steps you would otherwise have taken to build an image. `docker
    build` will read these instructions sequentially, committing them along the way,
    and build an image.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了通过提交容器来创建镜像。如果您想要使用依赖项的新版本或您自己应用程序的新版本来更新镜像怎么办？反复启动、设置和提交步骤很快就变得不切实际。我们需要一种可重复的方法来构建镜像。这就是Dockerfile的作用，它不过是一个包含指令的文本文件，用于自动化构建镜像的步骤。`docker
    build`将按顺序读取这些指令，途中提交它们，并构建一个镜像。
- en: The `docker build` command takes this Dockerfile and a context to execute the
    instructions, and builds a Docker image. Context refers to the path or source
    code repository URL given to the `docker build` command.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker build`命令使用此Dockerfile和上下文来执行指令，并构建Docker镜像。上下文是指提供给`docker build`命令的路径或源代码仓库URL。'
- en: 'A Dockerfile contains instructions in this format:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile以这种格式包含指令：
- en: '[PRE137]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Any line beginning with `#` will be considered as a comment. If a `#` sign is
    present anywhere else, it will be considered a part of arguments. The instruction
    is not case-sensitive, although it is an accepted convention for instructions
    to be uppercase so as to distinguish them from the arguments.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 任何以`#`开头的行将被视为注释。如果`#`符号出现在其他地方，它将被视为参数的一部分。指令不区分大小写，尽管按照惯例，指令应该大写以便与参数区分开。
- en: Let's look at the instructions that we can use in a Dockerfile.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在Dockerfile中可以使用的指令。
- en: The FROM instruction
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`FROM`指令'
- en: 'The `FROM` instruction sets the base image for the subsequent instructions.
    A valid Dockerfile''s first non-comment line will be a `FROM` instruction:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM`指令设置了后续指令的基础镜像。有效的Dockerfile的第一行非注释行将是一个`FROM`指令：'
- en: '[PRE138]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The image can be any valid local or public image. If it is not found locally,the
    `Docker build` command will try to pull it from the public registry. The `tag`
    command is optional here. If it is not given, the `latest` command is assumed.
    If the incorrect `tag` command is given, it returns an error.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像可以是任何有效的本地或公共镜像。如果在本地找不到，`Docker build`命令将尝试从公共注册表中拉取。这里`tag`命令是可选的。如果没有给出，将假定为`latest`命令。如果给出了不正确的`tag`命令，将返回错误。
- en: The MAINTAINER instruction
  id: totrans-520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`MAINTAINER`指令'
- en: 'The `MAINTAINER` instruction allows you to set the author for the generated
    images:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAINTAINER`指令允许您为生成的镜像设置作者：'
- en: '[PRE139]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The RUN instruction
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`RUN`指令'
- en: The `RUN` instruction will execute any command in a new layer on top of the
    current image, and commit this image. The image thus committed will be used for
    the next instruction in the Dockerfile.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`指令将在当前镜像的新层上执行任何命令，并提交此镜像。因此提交的镜像将用于Dockerfile中的下一条指令。'
- en: 'The `RUN` instruction has two forms:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`指令有两种形式：'
- en: The `RUN <command>` form
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN <command>`形式'
- en: The `RUN ["executable", "arg1", "arg2"...]` form
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN ["executable", "arg1", "arg2"...]`形式'
- en: In the first form, the command is run in a shell, specifically the `/bin/sh
    -c <command>` shell. The second form is useful in instances where the base image
    doesn't have a `/bin/sh` shell. Docker uses a cache for these image builds. So
    in case your image build fails somewhere in the middle, the next run will reuse
    the previously successful partial builds and continue from the point where it
    failed.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种形式中，命令在shell中运行，具体来说是`/bin/sh -c <command>` shell。第二种形式在基础镜像没有`/bin/sh`
    shell的情况下很有用。Docker对这些镜像构建使用缓存。因此，如果您的镜像构建在中间某个地方失败，下一次运行将重用先前成功的部分构建，并从失败的地方继续。
- en: 'The cache will be invalidated in these situations:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，缓存将被使无效：
- en: When the `docker build` command is run with the `--no-cache` flag.
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用`--no-cache`标志运行`docker build`命令时。
- en: When a non-cacheable command such as `apt-get update` is given. All the following
    `RUN` instructions will be run again.
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果给出了诸如`apt-get update`之类的不可缓存命令，则所有后续的`RUN`指令将再次运行。
- en: When the first encountered `ADD` instruction will invalidate the cache for all
    the following instructions from the Dockerfile if the contents of the context
    have changed. This will also invalidate the cache for the `RUN` instructions.
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当首次遇到`ADD`指令时，如果上下文的内容发生了变化，将使Dockerfile中所有后续指令的缓存无效。这也将使`RUN`指令的缓存无效。
- en: The CMD instruction
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CMD指令
- en: 'The `CMD` instruction provides the default command for a container to execute.
    It has the following forms:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD`指令提供了容器执行的默认命令。它有以下形式：'
- en: The `CMD ["executable", "arg1", "arg2"...]` form
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD ["executable", "arg1", "arg2"...]`形式'
- en: The `CMD ["arg1", "arg2"...]` form
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD ["arg1", "arg2"...]`形式'
- en: The `CMD command arg1 arg2 …` form
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD command arg1 arg2 …`形式'
- en: The first form is like an exec and it is the preferred form, where the first
    value is the path to the executable and is followed by the arguments to it.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种形式类似于一个exec，这是首选形式，其中第一个值是可执行文件的路径，后面跟着它的参数。
- en: The second form omits the executable but requires the `ENTRYPOINT` instruction
    to specify the executable.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式省略了可执行文件，但需要`ENTRYPOINT`指令来指定可执行文件。
- en: If you use the shell form of the `CMD` instruction, then the `<command>` command
    will execute in the `/bin/sh -c` shell.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`CMD`指令的shell形式，那么`<command>`命令将在`/bin/sh -c` shell中执行。
- en: Note
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the user provides a command in `docker run`, it overrides the `CMD` command.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在`docker run`中提供了一个命令，它将覆盖`CMD`命令。
- en: The difference between the `RUN` and `CMD` instructions is that a `RUN` instruction
    actually runs the command and commits it, whereas the `CMD` instruction is not
    executed during build time. It is a default command to be run when the user starts
    a container, unless the user provides a command to start it with.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`和`CMD`指令之间的区别在于，`RUN`指令实际上运行命令并提交它，而`CMD`指令在构建时不会被执行。这是一个默认的命令，在用户启动容器时运行，除非用户提供了一个启动命令。'
- en: 'For example, let''s write a `Dockerfile` that brings a `Star` `Wars` output
    to your terminal:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们编写一个`Dockerfile`，将`Star Wars`的输出带到您的终端：
- en: '[PRE140]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Save this in a folder named `star_wars` and open your terminal at this location.
    Then run this command:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存在名为`star_wars`的文件夹中，并在此位置打开您的终端。然后运行此命令：
- en: '[PRE141]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Now you can run it using the following command:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以使用以下命令运行它：
- en: '[PRE142]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The following screenshot shows the `starwars` output:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`starwars`的输出：
- en: '![The CMD instruction](graphics/4787OS_02_07.jpg)'
  id: totrans-551
  prefs: []
  type: TYPE_IMG
  zh: '![CMD指令](graphics/4787OS_02_07.jpg)'
- en: Thus, you can watch **Star Wars** in your terminal!
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以在终端上观看**星球大战**！
- en: Note
  id: totrans-553
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This *Star Wars* tribute was created by Simon Jansen, Sten Spans, and Mike Edwards.
    When you've had enough, hold *Ctrl* + *]*. You will be given a prompt where you
    can type `close` to exit.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*星球大战*致敬是由Simon Jansen，Sten Spans和Mike Edwards创建的。当您已经看够时，按住*Ctrl* + *]*。您将收到一个提示，您可以在其中输入`close`以退出。
- en: The ENTRYPOINT instruction
  id: totrans-555
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ENTRYPOINT指令
- en: The `ENTRYPOINT` instruction allows you to turn your Docker image into an executable.
    In other words, when you specify an executable in an `ENTRYPOINT`, containers
    will run as if it was just that executable.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`指令允许你将Docker镜像变成一个可执行文件。换句话说，当你在`ENTRYPOINT`中指定一个可执行文件时，容器将运行得就像是那个可执行文件一样。'
- en: 'The `ENTRYPOINT` instruction has two forms:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`指令有两种形式：'
- en: The `ENTRYPOINT ["executable", "arg1", "arg2"...]` form.
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT ["executable", "arg1", "arg2"...]`形式。'
- en: The `ENTRYPOINT command arg1 arg2 …` form.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT command arg1 arg2 …`形式。'
- en: This instruction adds an entry command that will not be overridden when arguments
    are passed to the `docker run` command, unlike the behavior of the `CMD` instruction.
    This allows arguments to be passed to the `ENTRYPOINT` instruction. The `docker
    run <image> -arg` command will pass the `-arg` argument to the command specified
    in the `ENTRYPOINT` instruction.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令添加了一个入口命令，当参数传递给`docker run`命令时，不会被覆盖，不像`CMD`指令的行为。这允许参数传递给`ENTRYPOINT`指令。`docker
    run <image> -arg`命令将`-arg`参数传递给`ENTRYPOINT`指令中指定的命令。
- en: Parameters, if specified in the `ENTRYPOINT` instruction, will not be overridden
    by the `docker run` arguments, but parameters specified via the `CMD` instruction
    will be overridden.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`ENTRYPOINT`指令中指定了参数，它们不会被`docker run`的参数覆盖，但是通过`CMD`指令指定的参数会被覆盖。
- en: 'As an example, let''s write a Dockerfile with `cowsay` as the `ENTRYPOINT`
    instruction:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们编写一个带有`cowsay`的`ENTRYPOINT`指令的Dockerfile：
- en: Note
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `cowsay` is a program that generates ASCII pictures of a cow with a message.
    It can also generate pictures using premade images of other animals, such as Tux
    the Penguin, the Linux mascot.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '`cowsay`是一个生成带有消息的牛的ASCII图片的程序。它还可以使用其他动物的预制图片生成图片，比如Tux企鹅，Linux吉祥物。'
- en: '[PRE143]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Save this with the name `Dockerfile` in a folder named `cowsay`. Then through
    terminal, go to that directory, and run this command:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存为名为`Dockerfile`的文件，放在名为`cowsay`的文件夹中。然后通过终端，进入该目录，并运行以下命令：
- en: '[PRE144]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Once the image is built, run the following command:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完镜像后，运行以下命令：
- en: '[PRE145]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面命令的输出：
- en: '![The ENTRYPOINT instruction](graphics/4787OS_02_08.jpg)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
  zh: '![ENTRYPOINT指令](graphics/4787OS_02_08.jpg)'
- en: If you look at the screenshot closely, the first run has no arguments and it
    used the argument we configured in the Dockerfile. However, when we gave our own
    arguments in the second run, it overrode the default and passed all the arguments
    (The `-f` flag and the sentence) to the `cowsay` folder.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细看截图，第一次运行没有参数，并且使用了我们在Dockerfile中配置的参数。然而，当我们在第二次运行中给出自己的参数时，它覆盖了默认值，并将所有参数（`-f`标志和句子）传递给了`cowsay`文件夹。
- en: Note
  id: totrans-573
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are the kind who likes to troll others, here''s a tip: apply the instructions
    given at [http://superuser.com/a/175802](http://superuser.com/a/175802) to set
    up a pre-exec script (a function that is called whenever a command is executed)
    that passes every command to this Docker container, and place it in the .`bashrc`
    file. Now cowsay will print every command that it execute in a text balloon, being
    said by an ASCII cow!'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是那种喜欢恶作剧的人，这里有一个提示：应用[http://superuser.com/a/175802](http://superuser.com/a/175802)中给出的指令来设置一个预执行脚本（每次执行命令时调用的函数），将每个命令传递给这个Docker容器，并将其放在`.bashrc`文件中。现在，cowsay将打印出它在文本气球中执行的每个命令，由一个ASCII牛说出来！
- en: The WORKDIR instruction
  id: totrans-575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WORKDIR指令
- en: 'The `WORKDIR` instruction sets the working directory for the `RUN`, `CMD`,
    and `ENTRYPOINT` Dockerfile commands that follow it:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '`WORKDIR`指令为接下来的`RUN`，`CMD`和`ENTRYPOINT` Dockerfile命令设置工作目录：'
- en: '[PRE146]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: This instruction can be used multiple times in the same Dockerfile. If a relative
    path is provided, the `WORKDIR` instruction will be relative to the path of the
    previous `WORKDIR` instruction.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令可以在同一个Dockerfile中多次使用。如果提供了相对路径，则`WORKDIR`指令将相对于先前的`WORKDIR`指令的路径。
- en: The EXPOSE instruction
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EXPOSE指令
- en: 'The `EXPOSE` instruction informs Docker that a certain port is to be exposed
    when a container is started:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE`指令通知Docker在启动容器时要公开某个端口：'
- en: '[PRE147]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Even after exposing ports, while starting a container, you still need to provide
    port mapping using the `-p` flag to `Docker run`. This instruction is useful when
    linking containers, which we will see in [Chapter 3](ch03.html "Chapter 3. Configuring
    Docker Containers"), *Linking Containers*.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在暴露端口之后，在启动容器时，仍然需要使用`-p`标志来提供端口映射给`Docker run`。这个指令在链接容器时很有用，我们将在[第3章](ch03.html
    "第3章。配置Docker容器")中看到*链接容器*。
- en: The ENV instruction
  id: totrans-583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ENV指令
- en: 'The ENV command is used to set environment variables:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: ENV命令用于设置环境变量：
- en: '[PRE148]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: This sets the `<key>` environment variable to `<value>`. This value will be
    passed to all future `RUN` instructions. This is equivalent to prefixing the command
    with `<key>=<value>`.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`<key>`环境变量设置为`<value>`。这个值将传递给所有未来的`RUN`指令。这相当于在命令前加上`<key>=<value>`。
- en: The environment variables set using the `ENV` command will persist. This means
    that when a container is run from the resulting image, the environment variable
    will be available to the running process as well. The `docker inspect` command
    shows the values that have been assigned during the creation of the image. However,
    these can be overridden using the `$ docker run –env <key>=<value>` command.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ENV`命令设置的环境变量将持久存在。这意味着当从生成的镜像运行容器时，环境变量也将对运行的进程可用。`docker inspect`命令显示了在创建镜像过程中分配的值。但是，可以使用`$
    docker run –env <key>=<value>`命令覆盖这些值。
- en: The USER instruction
  id: totrans-588
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: USER指令
- en: 'The USER instruction sets the username or UID to use when running the image
    and any following the `RUN` directives:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: USER指令设置在运行镜像和任何后续`RUN`指令时要使用的用户名或UID：
- en: '[PRE149]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The VOLUME instruction
  id: totrans-591
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VOLUME指令
- en: 'The `VOLUME` instruction will create a mount point with the given name and
    mark it as holding externally mounted volumes from the host or from other containers:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '`VOLUME`指令将创建一个具有给定名称的挂载点，并将其标记为保存来自主机或其他容器的外部挂载卷：'
- en: '[PRE150]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Here is an example of the `VOLUME` instruction:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`VOLUME`指令的示例：
- en: '[PRE151]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Here is another example of this instruction:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此指令的另一个示例：
- en: '[PRE152]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Both formats are acceptable.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 两种格式都可以接受。
- en: The ADD instruction
  id: totrans-599
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ADD指令
- en: 'The `ADD` instruction is used to copy files into the image:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD`指令用于将文件复制到镜像中：'
- en: '[PRE153]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: The `ADD` instruction will copy files from `<src>` into the path at `<dest>`.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD`指令将文件从`<src>`复制到`<dest>`的路径中。'
- en: The `<src>` path must be the path to a file or directory relative to the source
    directory being built (also called the context of the build) or a remote file
    URL.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '`<src>`路径必须是相对于正在构建的源目录（也称为构建上下文）的文件或目录的路径，或者是远程文件URL。'
- en: The `<dest>` path is the absolute path to which the source will be copied inside
    the destination container.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '`<dest>`路径是源将被复制到目标容器内部的绝对路径。'
- en: Note
  id: totrans-605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you build by passing a Dockerfile through the `stdin` file (`docker build
    - <` `somefile`), there is no build context, so the Dockerfile can only contain
    a URL-based `ADD` statement. You can also pass a compressed archive through the
    `stdin` file (`docker build - <` `archive.tar.gz`). Docker will look for a Dockerfile
    at the root of the archive and the rest of the archive will get used as the context
    of the build.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过`stdin`文件（`docker build - <` `somefile`）构建Dockerfile，则没有构建上下文，因此Dockerfile只能包含基于URL的`ADD`语句。您还可以通过`stdin`文件（`docker
    build - <` `archive.tar.gz`）传递压缩存档。Docker将在存档的根目录查找Dockerfile，并且存档的其余部分将用作构建的上下文。
- en: 'The `ADD` instruction obeys the following rules:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD`指令遵循以下规则：'
- en: The `<src>` path must be inside the context of the build. You cannot use `ADD
    ../file as ..` syntax, as it is beyond the context.
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<src>`路径必须在构建的上下文中。您不能使用`ADD ../file as ..`语法，因为它超出了上下文。'
- en: If `<src>` is a URL and the `<dest>` path doesn't end with a trailing slash
    (it's a file), then the file at the URL is copied to the `<dest>` path.
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`<src>`是一个URL，并且`<dest>`路径不以斜杠结尾（它是一个文件），则将URL处的文件复制到`<dest>`路径。
- en: If `<src>` is a URL and the `<dest>` path ends with a trailing slash (it's a
    directory), then the content at the URL is fetched and a filename is inferred
    from the URL and saved into the `<dest>/filename` path. So, the URL cannot have
    a simple path such as `example.com` in this case.
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`<src>`是一个URL，并且`<dest>`路径以斜杠结尾（它是一个目录），则会获取URL处的内容，并且会从URL中推断出一个文件名，并将其保存到`<dest>/filename`路径中。因此，在这种情况下，URL不能具有简单的路径，例如`example.com`。
- en: If `<src>` is a directory, the entire directory is copied, along with the filesystem
    metadata.
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`<src>`是一个目录，则整个目录将被复制，连同文件系统元数据一起。
- en: 'If `<src>` is a local tar archive, then it is extracted into the `<dest>` path.
    The result at `<dest>` is union of:'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`<src>`是本地tar存档，则它将被提取到`<dest>`路径中。`<dest>`处的结果是：
- en: Whatever existed at the path `<dest>`.
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<dest>`路径处存在的任何内容。'
- en: Contents of the extracted tar archive, with conflicts in favor of the path `<src>`,
    on a file-by-file basis.
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取的tar存档的内容，以文件为基础解决冲突，优先考虑`<src>`路径。
- en: If `<dest>` path doesn't exist, it is created along with all the missing directories
    along its path.
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`<dest>`路径不存在，则将创建该路径以及其路径中的所有缺失目录。
- en: The COPY instruction
  id: totrans-616
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: COPY指令
- en: 'The COPY instruction copies a file into the image:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: COPY指令将文件复制到镜像中：
- en: '[PRE154]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: The `Copy` instruction is similar to the `ADD` instruction. The difference is
    that the `COPY` instruction does not allow any file out of the context. So, if
    you are streaming Dockerfile via the `stdin` file or a URL (which doesn't point
    to a source code repository), the `COPY` instruction cannot be used.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY`指令类似于`ADD`指令。不同之处在于`COPY`指令不允许超出上下文的任何文件。因此，如果您通过`stdin`文件或URL（指向源代码存储库的URL）流式传输Dockerfile，则无法使用`COPY`指令。'
- en: The ONBUILD instruction
  id: totrans-620
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ONBUILD指令
- en: 'The `ONBUILD` instruction adds to the image a trigger that will be executed
    when the image is used as a base image for another build:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '`ONBUILD`指令将触发器添加到镜像中，当镜像用作另一个构建的基础镜像时，将执行该触发器。'
- en: '[PRE155]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: This is useful when the source application involves generators that need to
    compile before they can be used. Any build instruction apart from the `FROM`,
    `MAINTAINER`, and `ONBUILD` instructions can be registered.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 当源应用程序涉及需要在使用之前编译的生成器时，这是有用的。除了`FROM`，`MAINTAINER`和`ONBUILD`指令之外的任何构建指令都可以注册。
- en: 'Here''s how this instruction works:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此指令的工作方式：
- en: During a build, if the `ONBUILD` instruction is encountered, it registers a
    trigger and adds it to the metadata of the image. The current build is not otherwise
    affected in any way.
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建过程中，如果遇到`ONBUILD`指令，它会注册一个触发器并将其添加到镜像的元数据中。当前构建不会以任何方式受到影响。
- en: A list of all such triggers is added to the image manifest as a key named `OnBuild`
    at the end of the build (which can be seen through the `Docker inspect` command).
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些触发器的列表都被添加到镜像清单中，作为一个名为`OnBuild`的键，在构建结束时可以通过`Docker inspect`命令看到。
- en: When this image is later used as a base image for a new build, as part of processing
    the `FROM` instruction, the `OnBuild key` triggers are read and executed in the
    order they were registered. If any of them fails, the `FROM` instruction aborts,
    causing the build to fail. Otherwise, the `FROM` instruction completes and the
    build continues as usual.
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当这个镜像后来被用作新构建的基础镜像时，在处理`FROM`指令的过程中，`OnBuild key`触发器按照注册的顺序被读取和执行。如果其中任何一个失败，`FROM`指令将中止，导致构建失败。否则，`FROM`指令完成，构建将继续进行。
- en: Triggers are cleared from the final image after being executed. In other words
    they are not inherited by *grand-child builds*.
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发器在执行后会从最终镜像中清除。换句话说，它们不会被*grand-child builds*继承。
- en: 'Let''s bring `cowsay` back! Here''s a Dockerfile with the `ONBUILD` instruction:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把`cowsay`带回来！这是一个带有`ONBUILD`指令的Dockerfile：
- en: '[PRE156]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Now save this file in a folder named `OnBuild`, open a terminal in that folder,
    and run this command:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将这个文件保存在一个名为`OnBuild`的文件夹中，打开该文件夹中的终端，并运行这个命令：
- en: '[PRE157]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'We need to write another Dockerfile that builds on this image. Let''s write
    one:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写另一个基于这个镜像的Dockerfile。让我们写一个：
- en: '[PRE158]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Note
  id: totrans-635
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `apt-get moo` command is an example of Easter eggs typically found in many
    open source tools, added just for the sake of fun!
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '`apt-get moo`命令是许多开源工具中通常找到的彩蛋的一个例子，只是为了好玩！'
- en: 'Building this image will now execute the `ONBUILD` instruction we gave earlier:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 构建这个镜像现在将执行我们之前给出的`ONBUILD`指令：
- en: '[PRE159]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Now let''s use our newly gained knowledge to write a Dockerfile for the `code.it`
    application that we previously built by manually satisfying dependencies in a
    container and committing. The Dockerfile would look something like this:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们利用我们新获得的知识来为我们之前通过手动满足容器中的依赖关系并提交构建的`code.it`应用程序编写一个Dockerfile。Dockerfile看起来会像这样：
- en: '[PRE160]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Create a folder named `code.it` and save this content as a file named `Dockerfile`.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`code.it`的文件夹，并将这个内容保存为一个名为`Dockerfile`的文件。
- en: Note
  id: totrans-642
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is good practice to create a separate folder for every Dockerfile even if
    there is no context needed. This allows you to separate concerns between different
    projects. You might notice as you go that many Dockerfile authors club `RUN` instructions
    (for example, check out the Dockerfiles in [dockerfile.github.io](http://dockerfile.github.io)).
    The reason is that AUFS limits the number of possible layers to 42\. For more
    information, check out this issue at [https://github.com/docker/docker/issues/1171](https://github.com/docker/docker/issues/1171).
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不需要上下文，为每个Dockerfile创建一个单独的文件夹是一个很好的做法。这样可以在不同的项目之间分离关注点。当你继续前进时，你可能会注意到许多Dockerfile作者会将`RUN`指令合并在一起（例如，查看[dockerfile.github.io](http://dockerfile.github.io)中的Dockerfile）。原因是AUFS将可能的层的数量限制为42。更多信息，请查看[https://github.com/docker/docker/issues/1171](https://github.com/docker/docker/issues/1171)。
- en: You can go back to the section on *Docker build* to see how to build an image
    out of this Dockerfile.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以回到*Docker build*部分，看看如何从这个Dockerfile构建一个镜像。
- en: Docker workflow - pull-use-modify-commit-push
  id: totrans-645
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker工作流程 - 拉取-使用-修改-提交-推送
- en: 'Now, as we are nearing the end of this chapter, we can guess what a typical
    Docker workflow is like:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们接近本章的结束时，我们可以猜测一个典型的Docker工作流程是什么样的：
- en: Prepare a list of requirements to run your application.
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备运行应用程序的要求清单。
- en: Determine which public image (or one of your own) can satisfy most of these
    requirements, while also being well-maintained (this is important as you would
    need the image to be updated with newer versions whenever they are available).
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定哪个公共图像（或您自己的图像）可以满足大多数要求，同时也要维护良好（这很重要，因为您需要图像在可用时更新为新版本）。
- en: Next, fulfill the remaining requirements either by running a container and executing
    the commands that fulfill the requirements (which can be installing dependencies,
    bind mounting volumes, or fetching your source code), or by writing a Dockerfile
    (which is preferable since you will be able to make the build repeatable).
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过运行容器并执行满足要求的命令（可以是安装依赖项、绑定挂载卷或获取源代码），或者编写Dockerfile（这更可取，因为您将能够使构建可重复）来满足其余要求。
- en: Push your new image to the public Docker registry so that the community can
    use it too (or to a private registry or repository if needs be).
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新图像推送到公共Docker注册表，以便社区也可以使用它（或者根据需要推送到私有注册表或存储库）。
- en: Automated Builds
  id: totrans-651
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动构建
- en: 'Automated Builds automate the building and updating of images from GitHub or
    BitBucket, directly on Docker Hub. They work by adding a `commit` hook to your
    selected GitHub or BitBucket repository, triggering a build and an update when
    you push a commit. So you need not manually build and push an image to Docker
    Hub every time you make an update. The following steps will show you how to do
    this:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 自动构建自动化了从GitHub或BitBucket直接在Docker Hub上构建和更新图像。它们通过向您选择的GitHub或BitBucket存储库添加`commit`挂钩来工作，在您推送提交时触发构建和更新。因此，每次更新时都不需要手动构建和推送图像到Docker
    Hub。以下步骤将向您展示如何执行此操作：
- en: To set up an Automated Build, log in to your Docker Hub account.![Automated
    Builds](graphics/4787OS_02_03.jpg)
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置自动构建，请登录到您的Docker Hub帐户。![自动构建](graphics/4787OS_02_03.jpg)
- en: Link your GitHub or BitBucket account through the **Link** **Accounts** menu.
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过**链接** **帐户**菜单链接您的GitHub或BitBucket帐户。
- en: Select **Automated** **Build** in the **Add** **Repository** menu.![Automated
    Builds](graphics/4787OS_02_04.jpg)
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**添加** **存储库**菜单中选择**自动** **构建**。![自动构建](graphics/4787OS_02_04.jpg)
- en: Select the GitHub or BitBucket project that has the Dockerfile you want to build.
    (You will need to authorize Docker Hub to access your repositories.)
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择包含您想要构建的Dockerfile的GitHub或BitBucket项目。（您需要授权Docker Hub访问您的存储库。）
- en: Select the branch that contains the source code and the Dockerfile (the default
    is the master branch).
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择包含源代码和Dockerfile的分支（默认为主分支）。
- en: Give the Automated Build a name. This will be the name of the repository as
    well.
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为自动构建命名。这也将是存储库的名称。
- en: Assign an optional Docker tag to the Build. The default is the `lastest` tag.
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为构建分配一个可选的Docker标签。默认为`lastest`标签。
- en: Specify where the Dockerfile is located. The default is `/`.![Automated Builds](graphics/4787OS_02_05.jpg)
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定Dockerfile的位置。默认为`/`。![自动构建](graphics/4787OS_02_05.jpg)
- en: Once configured, the automated build will trigger a build and you will be able
    to see it in the Docker Hub Registry in a few minutes. It will stay in sync with
    your GitHub and BitBucket repository until you deactivate the Automated Build
    yourself.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置完成，自动构建将触发构建，并且您将能够在几分钟内在Docker Hub注册表中看到它。它将与您的GitHub和BitBucket存储库保持同步，直到您自己停用自动构建。
- en: The build status and history can be seen in the Automated Builds page on your
    profile in Docker Hub.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 构建状态和历史记录可以在Docker Hub中您的个人资料的自动构建页面中查看。
- en: '![Automated Builds](graphics/4787OS_02_06.jpg)'
  id: totrans-663
  prefs: []
  type: TYPE_IMG
  zh: '![自动构建](graphics/4787OS_02_06.jpg)'
- en: Once you've created an Automated Build, you can deactivate or delete it.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自动构建后，您可以停用或删除它。
- en: Note
  id: totrans-665
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You cannot, however, push to an Automated Build with the Docker `push` command.
    You can only manage it by committing code to your GitHub or BitBucket repository.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您不能使用Docker的`push`命令推送到自动构建。您只能通过向GitHub或BitBucket存储库提交代码来管理它。
- en: You can create multiple Automated Builds per repository and configure them to
    point to specific Dockerfile or Git branches.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为每个存储库创建多个自动构建，并将它们配置为指向特定的Dockerfile或Git分支。
- en: Build triggers
  id: totrans-668
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建触发器
- en: Automated Builds can also be triggered via a URL on Docker Hub. This allows
    you to rebuild an Automated Build image on demand.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过Docker Hub上的URL触发自动构建。这允许您根据需要重新构建自动构建的图像。
- en: Webhooks
  id: totrans-670
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Webhooks
- en: Webhooks are triggers that are called upon a successful build event. With a
    webhook, you can specify a target URL (such as a service that notifies you) and
    a JSON payload that will be delivered when the image is pushed. Webhooks are useful
    if you have a continuous-integration workflow.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: Webhooks是在成功构建事件发生时调用的触发器。通过webhook，您可以指定目标URL（例如通知您的服务）和在推送图像时将传递的JSON有效负载。如果您有持续集成工作流程，webhooks非常有用。
- en: 'To add a webhook to your Github repository, follow these steps:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 要将webhook添加到您的Github存储库，请按照以下步骤进行：
- en: Go to **Settings** in your repository.![Webhooks](graphics/4787OS_02_09.jpg)
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到存储库中的**Settings**。![Webhooks](graphics/4787OS_02_09.jpg)
- en: From the menu bar on the left, go to **Webhooks** **and** **Services**.![Webhooks](graphics/4787OS_02_10.jpg)
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧菜单栏转到**Webhooks** **and** **Services**。![Webhooks](graphics/4787OS_02_10.jpg)
- en: Click on **Add** **Service**.![Webhooks](graphics/4787OS_02_11.jpg)
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Add** **Service**。![Webhooks](graphics/4787OS_02_11.jpg)
- en: In the text box that opens, enter **Docker** and select the service.![Webhooks](graphics/4787OS_02_12.jpg)
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的文本框中，输入**Docker**并选择该服务。![Webhooks](graphics/4787OS_02_12.jpg)
- en: You're all set! Now a build will be triggered in Docker Hub whenever you commit
    to the repository.
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您已经准备就绪！现在每当您提交到存储库时，Docker Hub都会触发构建。
- en: Summary
  id: totrans-678
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the **Docker** command-line tool and tried out
    the commands available. Then we figured out how to make builds repeatable using
    Dockerfile. Also, we automated this build process using Docker Hub's Automated
    Build service.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们查看了**Docker**命令行工具并尝试了可用的命令。然后，我们找出如何使用Dockerfile使构建可重复。此外，我们使用Docker
    Hub的自动构建服务自动化了此构建过程。
- en: In the next chapter, we will try to gain more control over how our containers
    run by looking at the various commands that help us configure them. We will look
    at restraining the amount of resources (CPU, RAM, and storage) consumable by the
    container.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将尝试通过查看帮助我们配置它们的各种命令来更好地控制容器的运行方式。我们将研究限制容器可消耗的资源（CPU、RAM和存储）的数量。
