- en: Routing and Filtering with API Gateway
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API网关的路由和过滤
- en: In this chapter, we will discuss the next important element of microservice-based
    architecture, an API gateway. It is not our first encounter with that element
    in practice. We have already implemented a simple gateway pattern in [Chapter
    4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml), *Service Discovery*, for the purpose
    of presenting how a zoning mechanism works for service discovery with Eureka.
    We used Netflix's Zuul library, which is a JVM-based router and server-side load
    balancer. Netflix designed Zuul to provide features such as authentication, stress
    and canary testing, dynamic routing, and active/active multiregional traffic management. Although
    this is not explicitly stated, it also acts as a gateway in microservice architecture
    and its main task is to hide the complexity of your system from an external client.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论基于微服务的架构的下一个重要元素，即API网关。这并不是我们在实践中第一次遇到这个元素。我们已经在[第4章](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml)中实现了一个简单的网关模式，*服务发现*，以展示Eureka服务发现的分区机制是如何工作的。我们使用了Netflix的Zuul库，它是一个基于JVM的路由器和服务器端负载均衡器。Netflix设计了Zuul来提供诸如身份验证、压力和金丝雀测试、动态路由以及主动/主动多区域流量管理等功能。尽管这并没有明确说明，但它也是微服务架构中的一个网关，其主要任务是隐藏系统的复杂性，使外部客户端无需关心。
- en: Until now, Zuul, in fact, didn't have any competition when it came to API gateway
    pattern implementation inside the Spring Cloud framework. However, the situation
    is changing dynamically with the progressive development of a new project called
    Spring Cloud Gateway. It is built on the base of Spring Framework 5, Project Reactor,
    and Spring Boot 2.0\. The last stable version of that library is 1.0.0, but there
    are many crucial changes in the version currently being developed, 2.0.0, which
    is still at the milestone stage. Spring Cloud Gateway aims to provide a simple,
    effective way to route to APIs and provide cross-cutting concerns related to them
    such as security, monitoring/metrics, and resiliency. Although the solution is
    relatively new, it is definitely worthy of attention.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，实际上，Zuul在Spring Cloud框架内实现API网关模式时并没有任何竞争。然而，随着一个名为Spring Cloud Gateway的新项目的不断发展，情况正在动态变化。它是建立在Spring
    Framework 5、Project Reactor和Spring Boot 2.0的基础上。该库的最新稳定版本是1.0.0，但目前正在开发的版本2.0.0中有许多重要的变化，该版本仍处于里程碑阶段。Spring
    Cloud Gateway旨在提供一种简单有效的方式来路由到API，并提供与之相关的横切关注点，如安全性、监控/指标和弹性。尽管这个解决方案相对较新，但它绝对值得关注。
- en: 'The topics we will cover in this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖的主题包括：
- en: Static routing and load balancing based on URLs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于URL的静态路由和负载平衡
- en: Integrating Zuul and Spring Cloud Gateway with service discovery
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Zuul和Spring Cloud Gateway与服务发现集成
- en: Creating custom filters with Zuul
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Zuul创建自定义过滤器
- en: Customizing route configuration with Zuul
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Zuul自定义路由配置
- en: Providing Hystrix fallback in case of route failure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由失败时提供Hystrix回退
- en: Description of the main components included in Spring Cloud Gateway—predicators
    and gateway filters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway中包含的主要组件的描述-预测器和网关过滤器
- en: Using Spring Cloud Netflix Zuul
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Netflix Zuul
- en: Spring Cloud has implemented an embedded Zuul proxy to allow frontend application's
    proxy calls to backend services. This feature is useful for external clients,
    because it hides system complexity and helps to avoid the need to manage CORS
    and authentication concerns independently for all microservices. To enable it,
    you should annotate a Spring Boot main class with `@EnableZuulProxy`, and this
    forwards incoming requests to the target service. Of course, Zuul is integrated
    with the Ribbon load balancer, Hystrix circuit breaker, and service discovery,
    for example with Eureka.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud已经实现了一个内嵌的Zuul代理，允许前端应用程序的代理调用后端服务。这个功能对外部客户很有用，因为它隐藏了系统的复杂性，并帮助避免为所有微服务独立管理CORS和身份验证问题的需要。要启用它，你应该在Spring
    Boot主类上加上`@EnableZuulProxy`注解，这样就可以将传入的请求转发到目标服务。当然，Zuul与Ribbon负载均衡器、Hystrix断路器和服务发现集成在一起，例如与Eureka集成。
- en: Building a gateway application
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建网关应用程序
- en: 'Let''s go back to the example from the previous chapter to append the last
    element in the microservice-based architecture, API Gateway. What we haven''t
    considered yet is how the external client would call our services. First, we would
    not want to expose the network addresses of all microservices running inside the
    system. We may also perform some operations such as request authentication or
    setting tracing headers in just one place. The solution is to share only a single
    edge network address, which proxies all the incoming requests to the appropriate
    service. The current example''s system architecture is illustrated in the following
    diagram:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到上一章的示例，以添加基于微服务的架构中的最后一个元素，API网关。我们还没有考虑外部客户端如何调用我们的服务。首先，我们不希望暴露系统内运行的所有微服务的网络地址。我们可能还需要在一个地方执行一些操作，比如请求身份验证或设置跟踪头。解决方案是只共享一个边缘网络地址，将所有传入的请求代理到适当的服务。当前示例的系统架构如下图所示：
- en: '![](img/f535ba1e-68e6-4411-9d7d-d75bf828c6bf.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f535ba1e-68e6-4411-9d7d-d75bf828c6bf.png)'
- en: 'For the needs of our current sample, let me go back for a moment to the project
    already discussed in the previous chapter. It is available in GitHub ([https://github.com/piomin/sample-spring-cloud-comm.git](https://github.com/piomin/sample-spring-cloud-comm.git))
    in `master` branch. Now, we will add a new module called `gateway-service` to
    that project. The first step is to include Zuul with the Maven dependencies. We
    have to use the `spring-cloud-starter-zuul` starter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们当前示例的需求，让我回到上一章讨论过的项目。它在GitHub上可用（[https://github.com/piomin/sample-spring-cloud-comm.git](https://github.com/piomin/sample-spring-cloud-comm.git)）的`master`分支中。现在，我们将在该项目中添加一个名为`gateway-service`的新模块。第一步是在Maven依赖中包含Zuul。我们必须使用`spring-cloud-starter-zuul`
    starter：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After annotating a Spring Boot main class with `@EnableZuulProxy`, we may proceed
    to route configuration, which is provided in the `application.yml` file. By default,
    the Zuul starter artifact does not include the service discovery client. The routes
    are configured statically with the `url` property set to the network address of
    the service. Now, if you launch all the microservices and the gateway application,
    you may try to call them via the gateway. Each service is available under the
    path set in the configuration property `path` for every single route, for example, `http://localhost:8080/account/1`
    would be forwarded to `http://localhost:8091/1`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '在Spring Boot的主类上注释`@EnableZuulProxy`之后，我们可以继续进行路由配置，这些配置在`application.yml`文件中提供。默认情况下，Zuul启动器不包括服务发现客户端。路由是使用`url`属性静态配置的，设置为服务的网络地址。现在，如果启动所有微服务和网关应用程序，您可以尝试通过网关调用它们。每个服务都可以在配置属性`path`为每个单独路由设置的路径下使用，例如，`http://localhost:8080/account/1`将被转发到`http://localhost:8091/1`： '
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Integration with service discovery
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与服务发现集成
- en: 'The static route configuration presented in the previous example is not enough
    for a microservice-based system. The main requirement for an API gateway is a
    built-in integration with service discovery. To enable service discovery with
    Eureka for Zuul, we have to include the `spring-cloud-starter-eureka` starter
    in the project dependencies and enable the client by annotating the application''s
    main class with `@EnableDiscoveryClient`. In fact, it does not make sense to let
    the gateway register itself in discovery server, it must only fetch the current
    list of registered services. So we would disable that registration by setting
    the `eureka.client.registerWithEureka` property to `false`. The route''s definition
    in the `application.yml` file is really simple. Each route''s name is mapped to
    the application service name in Eureka:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中呈现的静态路由配置对基于微服务的系统来说是不够的。API网关的主要要求是与服务发现进行内置集成。要使用Eureka启用Zuul的服务发现，我们必须在项目依赖项中包含`spring-cloud-starter-eureka`启动器，并通过在应用程序的主类上注释`@EnableDiscoveryClient`来启用客户端。实际上，让网关在发现服务器中注册是没有意义的，它只能获取当前注册服务的列表。因此，我们可以通过将`eureka.client.registerWithEureka`属性设置为`false`来禁用该注册。在`application.yml`文件中的路由定义非常简单。每个路由的名称都映射到Eureka中的应用服务名称：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Customizing route configuration
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义路由配置
- en: There are several configuration settings, which allow us to customize the behavior
    of the Zuul proxy. Some of them are strictly related to the service discovery
    integration.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个配置设置可以允许我们自定义Zuul代理的行为。其中一些与服务发现集成密切相关。
- en: Ignoring registered services
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略已注册的服务
- en: 'Spring Cloud Zuul by default exposes all the services registered in Eureka
    server. If you would like to skip the automatic addition of every service, you
    have to set the `zuul.ignored-services` property with a pattern matched to all
    the ignored service names from a discovery server. How does it work in practice?
    Even if you do not provide any configuration with `zuul.routes.*` properties,
    Zuul would fetch the list of services from Eureka and automatically bind them
    to the path with the service name. For example, `account-service` would be available
    under the gateway address `http://localhost:8080/account-service/**`. Now, if
    you set the following configuration in  your `application.yml` file, it would
    ignore `account-service` and respond with an HTTP 404 status:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Zuul默认公开Eureka服务器中注册的所有服务。如果要跳过自动添加每个服务，必须使用`zuul.ignored-services`属性设置与发现服务器中所有被忽略的服务名称匹配的模式。实际上是如何工作的？即使您没有提供任何`zuul.routes.*`属性的配置，Zuul也会从Eureka获取服务列表，并自动将它们绑定到具有服务名称的路径。例如，`account-service`将在网关地址`http://localhost:8080/account-service/**`下可用。现在，如果您在`application.yml`文件中设置以下配置，它将忽略`account-service`并响应HTTP
    404状态：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You may also ignore all registered services by setting `zuul.ignored-services` to `''*''`. If
    a service matches a pattern that is ignored, but also included in the routes map
    configuration, then it will be included by Zuul. In that case, only `customer-service`
    would be processed:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过将`zuul.ignored-services`设置为`'*'`来忽略所有已注册的服务。如果一个服务匹配了被忽略的模式，但也包含在路由映射配置中，那么它将被Zuul包括。在这种情况下，只有`customer-service`会被处理：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Explicity set service name
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式设置服务名称
- en: 'The service name from a discovery server may also be set in configuration using
    the `serviceId` property. It gives you fine-grained control over a route, because
    you can specify the path and the `serviceId` independently. Here''s the equivalent
    configuration of the routes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 发现服务器的服务名称也可以在配置中使用`serviceId`属性进行设置。这样可以对路由进行精细控制，因为可以独立指定路径和`serviceId`。以下是路由的等效配置：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Route definition with the Ribbon client
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ribbon客户端的路由定义
- en: 'There is another approach to configuring routes. We may disable Eureka discovery
    in order to rely solely on a list of network addresses provided with the `listOfServers`
    property of the Ribbon client. All incoming requests to the gateway are load balanced
    by default between all instances of the service through a Ribbon client. This
    rule is true even if you enable or disable service discovery, as in the following
    example code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种配置路由的方法。我们可以禁用Eureka发现，仅依赖于Ribbon客户端的`listOfServers`属性提供的网络地址列表。网关的所有传入请求默认都会通过Ribbon客户端在服务的所有实例之间进行负载均衡。即使启用或禁用服务发现，这条规则也是成立的，就像以下示例代码一样：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Adding a prefix to the path
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为路径添加前缀
- en: Sometimes it is necessary to set a different path for services invoked via a
    gateway rather than allow them being available directly. In that case, Zuul provides
    the ability to add prefixes to all the defined mappings. This may be easily configured
    with the `zuul.prefix` property. By default, Zuul cuts that prefix before forwarding
    requests to the services. However, that behavior can also be disabled by setting
    the `zuul.stripPrefix` property to `false`. A `stripPrefix` property may be configured
    not only globally for all defined routes, but also per single route.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要为通过网关调用的服务设置不同的路径，而不是直接让它们可用。在这种情况下，Zuul提供了向所有定义的映射添加前缀的功能。这可以通过`zuul.prefix`属性轻松配置。默认情况下，Zuul在转发请求到服务之前会删除该前缀。但是，可以通过将`zuul.stripPrefix`属性设置为`false`来禁用该行为。`stripPrefix`属性不仅可以全局配置所有定义的路由，还可以单独配置每个路由。
- en: 'Here''s an example that adds the `/api` prefix to all the forwarded requests.
    Now, for example, if you would like to call the `GET /{id}` endpoint from `account-service`*,*
    you should use the address `http://localhost:8080/api/account/1`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，将`/api`前缀添加到所有转发的请求中。例如，如果您想从`account-service`调用`GET /{id}`端点，则应使用地址`http://localhost:8080/api/account/1`：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'What would happen if we have provided the configuration with `stripPrefix`
    set to `false`? Zuul would try to look for endpoints in the target services under
    the context paths `/api/account` and `/api/customer`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将配置中的`stripPrefix`设置为`false`会发生什么？Zuul将尝试在目标服务的上下文路径`/api/account`和`/api/customer`下查找端点：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Connection settings and timeouts
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接设置和超时
- en: The main task of Spring Cloud Netflix Zuul is to route incoming requests to
    downstream services. Therefore, it has to use an HTTP client implementation to
    communicate with those services. The default HTTP client used by Zuul is now backed
    by the Apache HTTP Client instead of the deprecated Ribbon `RestClient`. If you
    would like to use Ribbon, you should set the `ribbon.restclient.enabled` property to
    `true`. You may also try `OkHttpClient` by setting the `ribbon.okhttp.enabled` property to
    `true`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Netflix Zuul的主要任务是将传入的请求路由到下游服务。因此，它必须使用HTTP客户端实现与这些服务进行通信。Zuul现在使用Apache
    HTTP Client作为默认的HTTP客户端，而不是已弃用的Ribbon `RestClient`。如果您想使用Ribbon，应将`ribbon.restclient.enabled`属性设置为`true`。您还可以通过将`ribbon.okhttp.enabled`属性设置为`true`来尝试`OkHttpClient`。
- en: We may configure the basic settings for HTTP clients such as the connect or
    read timeout, and the maximum number of connections. There are two available options
    for such configurations depending on whether we are using service discovery or
    not. If you have defined Zuul routes with a specified network address through
    the `url` property, then you should set `zuul.host.connect-timeout-millis` and
    `zuul.host.socket-timeout-millis`. For the purpose of controlling the maximum
    number of connections, you should override the default value of the `zuul.host.maxTotalConnections`
    property, which is by default set to `200`. It is also possible to define the maximum
    number of connections per single route by setting the `zuul.host.maxPerRouteConnections`
    property, which is by default `20`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以配置HTTP客户端的基本设置，如连接或读取超时以及最大连接数。根据我们是否使用服务发现，有两种可用的配置选项。如果您已经通过`url`属性为Zuul路由定义了指定的网络地址，则应设置`zuul.host.connect-timeout-millis`和`zuul.host.socket-timeout-millis`。为了控制最大连接数，您应该覆盖`zuul.host.maxTotalConnections`属性的默认值，默认值为`200`。还可以通过设置`zuul.host.maxPerRouteConnections`属性来定义单个路由的最大连接数，默认值为`20`。
- en: If Zuul is configured to fetch a list of services from the discovery server,
    you need to configure the same timeouts as before with the Ribbon client properties `ribbon.ReadTimeout`
    and `ribbon.SocketTimeout`. The maximum number of connections can be customized
    with `ribbon.MaxTotalConnections` and `ribbon.MaxConnectionsPerHost`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Zuul配置为从发现服务器获取服务列表，则需要使用与Ribbon客户端属性`ribbon.ReadTimeout`和`ribbon.SocketTimeout`相同的超时进行配置。最大连接数可以使用`ribbon.MaxTotalConnections`和`ribbon.MaxConnectionsPerHost`进行自定义。
- en: Secure headers
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全头
- en: 'You may be a little surprised if you set, for example, the `Authorization`
    HTTP header in the request and it isn''t forwarded to the downstream service.
    This is because Zuul defines a default list of sensitive headers, which are removed
    during the routing process. These are the headers `Cookie`, `Set-Cookie`, and
    `Authorization`. This feature has been designed with a view to communicate with external
    servers. While there is no objection to sharing headers between services in the
    same system, it is not recommended to share them with external servers for security
    reasons. This approach may be customized by overriding default values for the `sensitiveHeaders`
    property. It may be set globally for all routes or just for a single route. The
    `sensitiveHeaders` are a not an empty blacklist, so to make Zuul forward all headers,
    you should explicitly set it to the empty list:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在请求中设置了`Authorization` HTTP头，但它没有被转发到下游服务，可能会感到有些惊讶。这是因为Zuul定义了一组默认的敏感头，在路由过程中会被删除。这些头部是`Cookie`、`Set-Cookie`和`Authorization`。这个功能是为了与外部服务器通信而设计的。虽然在同一系统中的服务之间共享头部没有异议，但出于安全原因，不建议与外部服务器共享头部。可以通过覆盖`sensitiveHeaders`属性的默认值来自定义此方法。它可以全局设置所有路由，也可以单独设置单个路由。`sensitiveHeaders`不是一个空的黑名单，因此要使Zuul转发所有头部，您应该将其明确设置为空列表：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Management endpoints
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理端点
- en: 'Spring Cloud Netflix Zuul exposes two additional management endpoints for monitoring:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Netflix Zuul为监控暴露了两个额外的管理端点：
- en: '**Routes**: Prints a list of defined routes'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：打印已定义的路由列表'
- en: '**Filters**: Prints a list of implemented filters (available from version `1.4.0.RELEASE`
    of Spring Cloud Netflix)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤器**：打印已实现的过滤器列表（从Spring Cloud Netflix的`1.4.0.RELEASE`版本开始提供）'
- en: 'To enable the managements endpoints feature, we have to include (as always) `spring-boot-starter-actuator`
    in the project dependencies. It''s a good idea to disable endpoint security for
    test purposes by setting the `management.security.enabled` property to `false`.
    Now, you may just call the `GET /routes` method and it would print the following
    JSON response for our example system:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用管理端点功能，我们必须在项目依赖项中包含（如常）`spring-boot-starter-actuator`。为了测试目的，最好通过将`management.security.enabled`属性设置为`false`来禁用端点安全性。现在，您可以调用`GET
    /routes`方法，它将为我们的示例系统打印以下JSON响应：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For more detailed information, you have to add the `?format=details` query
    string to the `/routes` path. That option is also available from version 1.4.0
    of Spring Cloud (Edgware Release Train). There is also a `POST /route` method
    that would force a refresh of the currently existing routes. Additionally, you
    can disable the whole endpoint by setting `endpoints.routes.enabled` to `false`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取更详细的信息，您必须将`?format=details`查询字符串添加到`/routes`路径中。该选项也可从Spring Cloud（Edgware
    Release Train）的1.4.0版本开始使用。还有一个`POST /route`方法，它将强制刷新当前存在的路由。此外，您可以通过将`endpoints.routes.enabled`设置为`false`来禁用整个端点：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The response result of the `/filters` endpoint is pretty interesting. You may
    see how many and what types of filters are available by default on the Zuul gateway.
    Here''s the fragment of a response with one selected filter. It contains a full
    class name, the order of calling, and status. For more information about filters,
    you can refer to the section, *Zuul filters*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`/filters`端点的响应结果非常有趣。您可以看到Zuul网关上默认提供了多少种类型的过滤器。以下是包含一个选定过滤器的响应片段。它包含完整的类名、调用顺序和状态。有关过滤器的更多信息，请参阅*Zuul过滤器*部分：'
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Providing Hystrix fallback
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供Hystrix回退
- en: We may provide a fallback response for every single route defined in Zuul's
    configuration, in case a circuit is opened. To do that, we should create a bean
    of type `ZuulFallbackProvider` (which is currently deprecated) or `FallbackProvider`.
    Inside that implementation, we have to specify the route ID pattern to match all
    the routes that should be handled by the fallback bean. The second step is to
    return the implementation of the `ClientHttpResponse` interface as a response
    in the `fallbackResponse` method.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为Zuul配置中定义的每个路由提供一个回退响应，以防开启电路。为此，我们应该创建一个`ZuulFallbackProvider`（目前已弃用）或`FallbackProvider`类型的bean。在该实现中，我们必须指定要由回退bean处理的所有路由的路由ID模式。第二步是在`fallbackResponse`方法中返回`ClientHttpResponse`接口的实现作为响应。
- en: 'Here''s a simple fallback bean that maps every exception to the HTTP status
    `200 OK` and sets the `errorCode` and `errorMessage` in the JSON response. Fallback
    is only executed for the `account-service` route:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的回退bean，将每个异常映射到HTTP状态`200 OK`，并在JSON响应中设置`errorCode`和`errorMessage`。回退仅对`account-service`路由执行：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Zuul filters
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zuul过滤器
- en: As I have already mentioned, Spring Cloud Zuul by default provides a couple
    of beans, which are the implementations of the `ZuulFilter` interface. Every built-in
    filter may be disabled by setting the `zuul.<SimpleClassName>.<filterType>.disable` property to
    `true`. For example, to disable `org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter`,
    you have to set `zuul.SendResponseFilter.post.disable=true`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我已经提到的，Spring Cloud Zuul默认提供了一些bean，它们是`ZuulFilter`接口的实现。通过将`zuul.<SimpleClassName>.<filterType>.disable`属性设置为`true`，可以禁用每个内置过滤器。例如，要禁用`org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter`，您必须将`zuul.SendResponseFilter.post.disable=true`设置为`true`。
- en: 'The HTTP filtering mechanism is probably well known to you. A filter dynamically
    intercepts requests and responses to transform, or just use, the information taken
    from the HTTP message. It may be triggered before or after an incoming request
    or outgoing response. We may identify a couple of types of filter provided by
    Zuul for Spring Cloud:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP过滤机制可能对您来说已经很熟悉了。过滤器动态拦截请求和响应，以转换或仅使用从HTTP消息中获取的信息。它可能在传入请求或传出响应之前或之后触发。我们可以为Spring
    Cloud提供的Zuul提供几种类型的过滤器进行识别：
- en: '**Pre filter**: It is used to prepare initial data in the `RequestContext`
    for use in filters downstream. The main responsibility is to set information required
    for route filters.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前置过滤器**：用于为下游过滤器准备`RequestContext`中的初始数据。其主要责任是设置路由过滤器所需的信息。'
- en: '**Route filter**: It is called after the pre filter and is responsible for
    creating requests to other services. The main reason for using it is a need to
    adapt a request or response to the model required by the client.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由过滤器**：在前置过滤器之后调用，负责创建对其他服务的请求。使用它的主要原因是需要将请求或响应适应客户端所需的模型。'
- en: '**Post filter**: Most commonly, it manipulates the response. It may even transform
    the response body.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后置过滤器**：通常用于操作响应。甚至可以转换响应主体。'
- en: '**Error filter**: It is executed only if an exception is thrown by other filters.
    There is only one built-in implementation of an error filter. `SendErrorFilter`
    is executed if `RequestContext.getThrowable()` is not null.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误过滤器：仅在其他过滤器抛出异常时执行。内置的错误过滤器只有一个实现。如果`RequestContext.getThrowable()`不为空，则执行`SendErrorFilter`。
- en: Predefined filters
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预定义过滤器
- en: 'If you annotate the main class with `@EnableZuulProxy`, Spring Cloud Zuul loads
    the filter beans used by both `SimpleRouteLocator` and `DiscoveryClientRouteLocator`.
    This is a list of the most important implementations installed as normal Spring
    Beans:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`@EnableZuulProxy`注解主类，Spring Cloud Zuul会加载`SimpleRouteLocator`和`DiscoveryClientRouteLocator`使用的过滤器bean。以下是作为普通Spring
    Beans安装的最重要的实现列表：
- en: '`ServletDetectionFilter`: This is a pre filter. It checks whether the request
    is coming through the Spring Dispatcher. Sets a Boolean with the key `FilterConstants.IS_DISPATCHER_SERVLET_REQUEST_KEY`.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServletDetectionFilter`：这是一个前置过滤器。它检查请求是否通过Spring Dispatcher。使用键`FilterConstants.IS_DISPATCHER_SERVLET_REQUEST_KEY`设置一个布尔值。'
- en: '`FormBodyWrapperFilter`: This is a pre filter. It parses form data and re-encodes
    it for downstream requests.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormBodyWrapperFilter`：这是一个前置过滤器。它解析表单数据并为下游请求重新编码。'
- en: '`PreDecorationFilter`: This is a pre filter. It determines where and how to
    route based on the supplied `RouteLocator`. It is also responsible for setting
    headers related to the proxy.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PreDecorationFilter`：这是一个前置过滤器。它根据提供的`RouteLocator`确定路由的位置和方式。它还负责设置与代理相关的标头。'
- en: '`SendForwardFilter`: This is a route filter. It forwards requests using `RequestDispatcher`.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SendForwardFilter`：这是一个路由过滤器。它使用`RequestDispatcher`转发请求。'
- en: '`RibbonRoutingFilter`: This is a route filter. It uses Ribbon, Hystrix, and
    external HTTP clients such as Apache `HttpClient`, `OkHttpClient`, or Ribbon HTTP
    client to send requests. Service IDs are taken from the request context.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RibbonRoutingFilter`：这是一个路由过滤器。它使用Ribbon、Hystrix和外部HTTP客户端（如Apache `HttpClient`、`OkHttpClient`或Ribbon
    HTTP客户端）来发送请求。服务ID来自请求上下文。'
- en: '`SimpleHostRoutingFilter`: This is a route filter. It sends requests to URLs
    via an Apache HTTP client. URLs are found in the request context.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleHostRoutingFilter`：这是一个路由过滤器。它通过Apache HTTP客户端将请求发送到URL。URL在请求上下文中找到。'
- en: '`SendResponseFilter`: This is a post filter. It writes responses from proxied
    requests to the current response.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SendResponseFilter`：这是一个后置过滤器。它将代理请求的响应写入当前响应。'
- en: Custom implementations
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义实现
- en: 'In addition to the filters installed by default, we may create our custom implementations. 
    Each of them has to implement the `ZuulFilter` interface and its four methods.
    These methods are responsible for setting the type of filter (`filterType`), determining
    the order of filter execution between other filtering with the same type (`filterOrder`),
    enabling or disabling the filter (`shouldFilter`) and finally the filter logic
    implementation (`run`). Here''s an example implementation that adds the `X-Response-ID` header to
    the response:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认安装的过滤器外，我们可以创建自定义实现。每个实现都必须实现`ZuulFilter`接口及其四个方法。这些方法负责设置过滤器的类型（`filterType`），确定与相同类型的其他过滤器之间的过滤器执行顺序（`filterOrder`），启用或禁用过滤器（`shouldFilter`）以及最后的过滤器逻辑实现（`run`）。以下是一个示例实现，它向响应添加了`X-Response-ID`头：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That''s not all that has to be done. The custom filter implementation should
    also be declared as an `@Bean` in the main class or Spring configuration class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是全部。自定义过滤器实现还应该在主类或Spring配置类中声明为`@Bean`：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using Spring Cloud Gateway
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Gateway
- en: 'There are three basic concepts around Spring Cloud Gateway:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway围绕着三个基本概念：
- en: '**Route**: That is the basic building block of the gateway. It consists of
    a unique ID for identifying a route, a destination URI, a list of predicates,
    and a list of filters. A route is matched only if all the predicates have been
    fulfilled.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：这是网关的基本构建块。它包括用于标识路由的唯一ID、目标URI、谓词列表和过滤器列表。只有在所有谓词都满足的情况下，路由才会匹配。'
- en: '**Predicates**: These are the logic that is executed before processing each
    request. It is responsible for detecting whether the different attributes of the
    HTTP request, such as headers and parameters, match the defined criteria. The
    implementation is based on the Java 8 interface `java.util.function.Predicate<T>`.
    The input type is in turn based on Spring''s `org.springframework.web.server.ServerWebExchange`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**谓词**：这些是在处理每个请求之前执行的逻辑。它负责检测HTTP请求的不同属性（如标头和参数）是否与定义的标准匹配。实现基于Java 8接口`java.util.function.Predicate<T>`。输入类型又基于Spring的`org.springframework.web.server.ServerWebExchange`。'
- en: '**Filters**: They allow the modification of the incoming HTTP request or outgoing
    HTTP response. They may be modified before or after sending the downstream request.
    Route filters are scoped to a particular route. They implement Spring''s `org.springframework.web.server.GatewayFilter`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤器**：它们允许修改传入的HTTP请求或传出的HTTP响应。它们可以在发送下游请求之前或之后进行修改。路由过滤器适用于特定路由。它们实现了Spring的`org.springframework.web.server.GatewayFilter`。'
- en: Enable Spring Cloud Gateway for a project
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为项目启用Spring Cloud Gateway
- en: Spring Cloud Gateway is built on top of the Netty web container and Reactor
    framework. The Reactor project and Spring Web Flux may be used together with version 2.0
    of Spring Boot. Until now, we have used version 1.5, so there is a different declaration
    of parent project version. Currently, Spring Boot 2.0 is still at the milestone
    stage. Here's the fragment from Maven `pom.xml` that inherits from the `spring-boot-starter-parent`
    project.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway是建立在Netty web容器和Reactor框架之上的。Reactor项目和Spring Web Flux可以与Spring
    Boot的2.0版本一起使用。到目前为止，我们一直使用的是1.5版本，所以父项目版本的声明有所不同。目前，Spring Boot 2.0仍处于里程碑阶段。以下是从Maven
    `pom.xml`中继承`spring-boot-starter-parent`项目的片段。
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also need to change the release train of Spring Cloud in comparison with
    the previous examples. The newest available milestone version is `Finchley.M5`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要改变Spring Cloud的发布系列，与之前的示例进行比较。最新可用的里程碑版本是`Finchley.M5`：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After setting the right versions of Spring Boot and Spring Cloud, we may finally
    include the `spring-cloud-starter-gateway` starter in the project dependencies:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了正确的Spring Boot和Spring Cloud版本之后，我们最终可以在项目依赖项中包含`spring-cloud-starter-gateway`启动器：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Built-in predicates and filters
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置的谓词和过滤器
- en: 'Spring Cloud Gateway includes many built-in route predicates and gateway filter
    factories. Every route may be defined using configuration properties in the `application.yml`
    file or programmatically with the Fluent Java Routes API. The list of available
    predicate factories is provided in the following table. Multiple factories may
    be combined for a single route definition with a logical `and` relation. The collection
    of filters may be configured in the `application.yml` file under the `spring.cloud.gateway.routes` property for
    each defined route under the `predicates` property:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway包括许多内置的路由谓词和网关过滤器工厂。每个路由可以使用`application.yml`文件中的配置属性或使用Fluent
    Java Routes API进行编程定义。以下表格提供了可用的谓词工厂列表。多个工厂可以组合为单个路由定义，并具有逻辑`and`关系。过滤器的集合可以在`application.yml`文件中的`spring.cloud.gateway.routes`属性下为每个定义的路由在`predicates`属性下进行配置：
- en: '| **Name** | **Description** | **Example** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `After` Route | It takes a date-time parameter and matches requests that
    happen after it | `After=2017-11-20T...` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `After` Route | 获取日期时间参数并匹配发生在此之后的请求 | `After=2017-11-20T...` |'
- en: '| `Before` Route | It takes a date-time parameter and matches requests that
    happen before it | `Before=2017-11-20T...` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `Before` Route | 获取日期时间参数并匹配发生在此之前的请求 | `Before=2017-11-20T...` |'
- en: '| `Between` Route | It takes two date-time parameters and matches requests
    that happen between those dates | `Between=2017-11-20T..., 2017-11-21T...` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `Between` Route | 获取两个日期时间参数并匹配发生在这些日期之间的请求 | `Between=2017-11-20T..., 2017-11-21T...` '
- en: '| `Cookie` Route | It takes a cookie name and regular expression parameters,
    finds the cookie in the HTTP request''s header, and matches its value with the
    provided expression  | `Cookie=SessionID, abc.` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `Cookie` Route | 获取cookie名称和正则表达式参数，在HTTP请求标头中查找cookie，并将其值与提供的表达式匹配 | `Cookie=SessionID,
    abc.` |'
- en: '| `Header` Route | It takes the header name and regular expression parameters,
    finds a specific header in the HTTP request''s header, and matches its value with
    the provided expression  | `Header=X-Request-Id, \d+` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `Header` Route | 获取标头名称和正则表达式参数，在HTTP请求标头中查找特定标头，并将其值与提供的表达式匹配 | `Header=X-Request-Id,
    \d+` |'
- en: '| `Host` Route | It takes a hostname ANT style pattern with the `.` separator
    as a parameter and matches it with the `Host` header | `Host=**.example.org` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `Host` Route | 以`.`作为分隔符，获取主机名ANT样式模式作为参数，并将其与`Host`标头匹配 | `Host=**.example.org`
    |'
- en: '| `Method` Route | It takes an HTTP method to match as a parameter | `Method=GET`
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `Method` Route | 获取要匹配的HTTP方法作为参数 | `Method=GET` |'
- en: '| `Path` Route | It takes a pattern of request context path as a parameter
    | `Path=/account/{id}` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `Path` Route | 以请求上下文路径的模式作为参数 | `Path=/account/{id}` |'
- en: '| `Query` Route | It takes two parameters—a required param and an optional
    regexp and matches them with query parameters | `Query=accountId, 1.` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `Query` Route | 获取两个参数——一个必需参数和一个可选的正则表达式，并将它们与查询参数匹配 | `Query=accountId,
    1.` |'
- en: '| `RemoteAddr` Route | It takes a list of IP addresses in CIDR notation, like `192.168.0.1/16`,
    and matches it with the remote address of a request  | `RemoteAddr=192.168.0.1/16`
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `RemoteAddr` Route | 获取CIDR表示法中的IP地址列表，如`192.168.0.1/16`，并将其与请求的远程地址匹配 |
    `RemoteAddr=192.168.0.1/16` |'
- en: 'There are a few more built-in implementations of the gateway filter pattern.
    The list of available factories is also provided in the following table. The collection
    of filters may be configured in the `application.yml` file under the `spring.cloud.gateway.routes`
    property for each route defined under the `filters` property:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些网关过滤器模式的内置实现。可用工厂的列表也在下表中提供。过滤器的集合可以在`application.yml`文件中的`spring.cloud.gateway.routes`属性下为`filters`属性下定义的每个路由进行配置。
- en: '| **Name** | **Description** | **Example** |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `AddRequestHeader` | Adds a header to an HTTP request with name and value
    provided in parameters | `AddRequestHeader=X-Response-ID, 123` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `AddRequestHeader` | 使用参数中提供的名称和值向HTTP请求添加标头 | `AddRequestHeader=X-Response-ID,
    123` |'
- en: '| `AddRequestParameter` | Adds a query parameter to an HTTP request with name
    and value provided in parameters | `AddRequestParameter=id, 123` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `AddRequestParameter` | 使用参数中提供的名称和值向HTTP请求添加查询参数 | `AddRequestParameter=id,
    123` |'
- en: '| `AddResponseHeader` | Adds a header to an HTTP response with name and value
    provided in parameters | `AddResponseHeader=X-Response-ID, 123` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `AddResponseHeader` | 使用参数中提供的名称和值向HTTP响应添加标头 | `AddResponseHeader=X-Response-ID,
    123` |'
- en: '| `Hystrix` |  It takes a parameter, which is the name of the HystrixCommand
    | `Hystrix=account-service` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `Hystrix` | 获取一个参数，即HystrixCommand的名称 | `Hystrix=account-service` |'
- en: '| `PrefixPath` | Adds a prefix to the HTTP request path defined in the parameter
    | `PrefixPath=/api` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `PrefixPath` | 将前缀添加到参数中定义的HTTP请求路径 | `PrefixPath=/api` |'
- en: '| `RequestRateLimiter` | It limits the number of processing requests per single
    user based on three input parameters including a maximum number of requests per
    second, burst capacity, and a bean that returns the user key | `RequestRateLimiter=10,
    20, #{@userKeyResolver}` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `RequestRateLimiter` | 根据三个输入参数限制单个用户的处理请求数量，包括每秒最大请求数、突发容量和返回用户密钥的bean |
    `RequestRateLimiter=10, 20, #{@userKeyResolver}` |'
- en: '| `RedirectTo` | It takes an HTTP status and a redirect URL as parameters and
    puts it to the `Location` HTTP header in order to perform a redirect | `RedirectTo=302,
    http://localhost:8092` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `RedirectTo` | 以HTTP状态和重定向URL作为参数，并将其放入`Location` HTTP标头以执行重定向 | `RedirectTo=302,
    http://localhost:8092` |'
- en: '| `RemoveNonProxyHeaders` | It removes some hop-by-hop headers from forwarded
    requests, such as Keep-Alive, Proxy-Authenticate, or Proxy-Authorization | - |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `RemoveNonProxyHeaders` | 从转发请求中删除一些逐跳标头，例如Keep-Alive、Proxy-Authenticate或Proxy-Authorization
    | - |'
- en: '| `RemoveRequestHeader` | It takes the name of the header as a parameter and
    removes it from the HTTP request | `RemoveRequestHeader=X-Request-Foo` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `RemoveRequestHeader` | 以参数形式获取标头名称并从HTTP请求中删除它 | `RemoveRequestHeader=X-Request-Foo`
    |'
- en: '| `RemoveResponseHeader` | It takes the name of the header as a parameter and
    removes it from the HTTP response | `RemoveResponseHeader=X-Response-ID` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `RemoveResponseHeader` | 以参数形式获取标头名称并从HTTP响应中删除它 | `RemoveResponseHeader=X-Response-ID`
    |'
- en: '| `RewritePath` | It takes a path regexp parameter and a replacement parameter
    and then rewrites the request path | `RewritePath=/account/(?<path>.*), /$\{path}`
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `RewritePath` | 获取路径正则表达式参数和替换参数，然后重写请求路径 | `RewritePath=/account/(?<path>.*),
    /$\{path}` |'
- en: '| `SecureHeaders` | It adds some secure headers to the response | - |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `SecureHeaders` | 向响应添加一些安全标头 | - |'
- en: '| `SetPath` | It takes a single parameter with a path template parameter and
    changes a request path | `SetPath=/{segment}` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `SetPath` | 获取带有路径模板参数的单个参数，并更改请求路径 | `SetPath=/{segment}` |'
- en: '| `SetResponseHeader` | It takes name and value parameters to set a header
    on the HTTP response | `SetResponseHeader=X-Response-ID, 123` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `SetResponseHeader` | 获取名称和值参数以在HTTP响应中设置标头 | `SetResponseHeader=X-Response-ID,
    123` |'
- en: '| `SetStatus` | It takes a single status parameter, which must be a valid HTTP
    status, and sets it on a response | `SetStatus=401` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `SetStatus` | 它接受一个单一的状态参数，必须是有效的HTTP状态，并将其设置在响应中 | `SetStatus=401` |'
- en: 'Here''s a simple example with two predicates and two filters set. Each `GET
    /account/{id}` request coming in to the gateway is forwarded to `http://localhost:8080/api/account/{id}`
    with the new HTTP header, `X-Request-ID`, included:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的示例，其中设置了两个谓词和两个过滤器。每个传入网关的`GET /account/{id}`请求都被转发到`http://localhost:8080/api/account/{id}`，并包含新的HTTP头`X-Request-ID`：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The same configuration may be provided using a fluent API defined in the `Route`
    class. This style gives us more flexibility. While configuration with YAML may
    combine predicates using logical `and`, the fluent Java API allows you to use
    `and()`, `or()`, and `negate()` operators on the `Predicate` class. Here''s the
    alternative route implemented using the fluent API:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`Route`类中定义的流畅API提供相同的配置。这种风格给了我们更多的灵活性。虽然使用YAML进行配置可以使用逻辑`and`组合谓词，但流畅的Java
    API允许您在`Predicate`类上使用`and()`、`or()`和`negate()`运算符。以下是使用流畅API实现的替代路由：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Gateway for microservices
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的网关
- en: 'Let''s get back to our example microservice-based system. We have already discussed
    this example in the section on API gateway configuration based on Spring Cloud
    Netflix Zuul. We would like to prepare the same static route definition as was
    already prepared for the application based on a Zuul proxy. Each service would
    then be available under the gateway address and specific path, for example, `http://localhost:8080/account/**`.
    The most suitable way to declare such a configuration with Spring Cloud Gateway is
    through Path Route Predicate Factory and RewritePath GatewayFilter Factory. A
    rewrite path mechanism changes the request path by taking part of it or adding
    some pattern. In our case, every incoming request path is rewritten from, for
    example, `account/123` to `/123`. Here''s the gateway''s `application.yml` file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的示例基于微服务的系统。我们已经在基于Spring Cloud Netflix Zuul的API网关配置部分讨论过这个示例。我们想要准备与基于Zuul代理的应用程序已经准备好的相同的静态路由定义。然后每个服务将在网关地址和特定路径下可用，例如`http://localhost:8080/account/**`。使用Spring
    Cloud Gateway声明这样的配置的最合适的方式是通过Path Route Predicate Factory和RewritePath GatewayFilter
    Factory。重写路径机制通过获取部分路径或添加一些模式来改变请求路径。在我们的情况下，每个传入的请求路径都被重写，例如从`account/123`到`/123`。以下是网关的`application.yml`文件：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Surprisingly, this is all that has to be done. We don''t have to provide any
    additional annotation compared to what we have been doing when working with other
    Spring Cloud components such as Eureka or Config Server. So, the main class of
    our gateway''s application is visible in the following code fragment. You have
    to build the project using `mvn clean install` and launch it with `java -jar`,
    or just run the main class from your IDE. The example application source code
    is available on GitHub ([https://github.com/piomin/sample-spring-cloud-gateway.git](https://github.com/piomin/sample-spring-cloud-gateway.git)):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，这就是所有需要做的。与我们在使用其他Spring Cloud组件（如Eureka或Config Server）时所做的相比，我们不必提供任何额外的注释。因此，我们网关应用程序的主类在以下代码片段中可见。您必须使用`mvn
    clean install`构建项目，并使用`java -jar`启动它，或者只需从您的IDE中运行主类。示例应用程序源代码可在GitHub上找到（[https://github.com/piomin/sample-spring-cloud-gateway.git](https://github.com/piomin/sample-spring-cloud-gateway.git)）：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Integration with service discovery
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与服务发现集成
- en: 'The gateway may be configured to create routes based on the list of services
    registered in service discovery. It can integrate with those solutions that have
    a `DiscoveryClient` compatible service registry, such as Netflix Eureka, Consul,
    or Zookeeper. To enable `DiscoveryClient` Route Definition Locator, you should
    set the `spring.cloud.gateway.discovery.locator.enabled` property to `true` and
    provide a `DiscoveryClient` implementation on the classpath. We use Eureka client
    and server for discovery. Notice that with the newest milestone version, `Finchley.M5`, of
    Spring Cloud all the Netflix''s artifact''s names have been changed and now it
    is, for example, `spring-cloud-starter-netflix-eureka-client` instead of `spring-cloud-starter-eureka`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 网关可以配置为基于服务发现中注册的服务列表创建路由。它可以集成那些具有`DiscoveryClient`兼容服务注册表的解决方案，如Netflix Eureka、Consul或Zookeeper。要启用`DiscoveryClient`
    Route Definition Locator，您应该将`spring.cloud.gateway.discovery.locator.enabled`属性设置为`true`，并在类路径上提供一个`DiscoveryClient`实现。我们使用Eureka客户端和服务器进行发现。请注意，使用最新的里程碑版本`Finchley.M5`，Spring
    Cloud所有Netflix的构件名称已经更改，现在是，例如，`spring-cloud-starter-netflix-eureka-client`而不是`spring-cloud-starter-eureka`：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The main class should be the same for the Eureka client application, annotated
    with `@DiscoveryClient`. Here''s the `application.yml` file with routing configuration.
    The only change in comparison with the previous example is in the `uri` property
    for every defined route. Instead of providing their network address we may use
    its name taken from discovery server with an `lb` prefix, for example, `lb://order-service`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 主类应该与Eureka客户端应用程序相同，并用`@DiscoveryClient`注解。以下是带有路由配置的`application.yml`文件。与先前示例相比，唯一的变化在于每个定义的路由的`uri`属性。我们可以使用从发现服务器获取的名称，并在前面加上`lb`前缀，而不是提供它们的网络地址，例如`lb://order-service`：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With an API gateway, we have finished the discussion about the implementation
    of the core elements of a microservice-based architecture in Spring Cloud. After
    reading that part of the book, you should be able to customize and use tools such
    as Eureka, Spring Cloud Config, Ribbon, Feign, Hystrix, and finally a gateway
    based on Zuul and Spring Cloud Gateway together.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过API网关，我们已经完成了关于在Spring Cloud中实现基于微服务的架构核心元素的讨论。阅读本书的这一部分后，您应该能够自定义和使用诸如Eureka、Spring
    Cloud Config、Ribbon、Feign、Hystrix以及基于Zuul和Spring Cloud Gateway的网关等工具。
- en: Treat this chapter as a comparison between two available solutions—the older
    Netflix Zuul and the newest one, Spring Cloud Gateway. The second of them is changing
    dynamically. Its current version, 2.0, may be used only with Spring 5 and is still
    not available in release version. The first of them, Netflix Zuul, is stable,
    but it does not support asynchronous, non-blocking connections. It is still based
    on Netflix Zuul 1.0, although there is a new version of Zuul that supports asynchronous
    communication. Regardless of the differences between them, I have described how
    to provide a simple and a more advanced configuration using both of these solutions.
    I have also presented, based on the examples from the previous chapters, an integration
    with a service discovery, client-side load balancer, and circuit breaker.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将本章视为两种可用解决方案之间的比较——较旧的Netflix Zuul和最新的Spring Cloud Gateway。它们中的第二个正在动态改变。它的当前版本2.0只能与Spring
    5一起使用，仍未发布版本。第一个Netflix Zuul是稳定的，但不支持异步、非阻塞连接。它仍然基于Netflix Zuul 1.0，尽管有一个支持异步通信的新版本。尽管它们之间存在差异，但我已经描述了如何使用这两种解决方案提供简单和更高级的配置。我还根据前几章的示例，介绍了与服务发现、客户端负载均衡器和断路器的集成。
