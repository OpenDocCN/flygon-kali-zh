- en: Chapter 9. Exploring Network Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。探索网络功能
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Working with prerelease versions of Docker
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker的预发布版本
- en: Understanding MacVLAN interfaces
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解MacVLAN接口
- en: Working with the Docker MacVLAN network driver
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker MacVLAN网络驱动程序
- en: Understanding IPVLAN interfaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解IPVLAN接口
- en: Working with the Docker IPVLAN network driver
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker IPVLAN网络驱动程序
- en: Tagging VLAN IDs with MacVLAN and IPVLAN networks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MacVLAN和IPVLAN网络标记VLAN ID
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Although many of the features we've discussed in earlier chapters have been
    here since day one, many have been very recently introduced. Docker is a rapidly
    evolving piece of open source software with many contributors. To manage the introduction,
    testing, and potential release of features, Docker releases code in a couple of
    different ways. In this chapter, we'll show how you can explore features that
    are not yet in the production or release version of the software. As part of this,
    we'll review two of the newer networking features that have been introduced to
    Docker. One of which, MacVLAN, was recently merged into the release version of
    the software as of version 1.12\. The second, IPVLAN, is still in the prerelease
    software channel. After we review how to consume the Docker prerelease software
    channels, we'll discuss the basic operation of both MacVLAN and IPVLAN network
    interfaces and then discuss how they are implemented as drivers in Docker.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在前几章讨论过的许多功能自从一开始就存在，但许多功能是最近才引入的。Docker是一个快速发展的开源软件，有许多贡献者。为了管理功能的引入、测试和潜在发布，Docker以几种不同的方式发布代码。在本章中，我们将展示如何探索尚未包含在软件生产或发布版本中的功能。作为其中的一部分，我们将回顾Docker引入的两个较新的网络功能。其中一个是MacVLAN，最近已经合并到软件的发布版本中，版本号为1.12。第二个是IPVLAN，仍然处于预发布软件渠道中。在我们回顾如何使用Docker预发布软件渠道之后，我们将讨论MacVLAN和IPVLAN网络接口的基本操作，然后讨论它们在Docker中作为驱动程序的实现方式。
- en: Working with prerelease versions of Docker
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker的预发布版本
- en: Docker offers two different channels in which you can preview unreleased code.
    This gives users a chance to review features that are both slated for release
    as well as features that are entirely experimental and may never make it into
    an actual release version. Reviewing these features and providing feedback on
    them is an important piece of open source software development. Docker takes the
    feedback it receives seriously and lots of great ideas that have been tested in
    these channels make it into the production code release. In this recipe, we'll
    review how to install both the test and the experimental Docker releases.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Docker提供了两种不同的渠道，您可以在其中预览未发布的代码。这使用户有机会审查既定发布的功能，也可以审查完全实验性的功能，这些功能可能永远不会进入实际发布版本。审查这些功能并对其提供反馈是开源软件开发的重要组成部分。Docker认真对待收到的反馈，许多在这些渠道中测试过的好主意最终会进入生产代码发布中。在本篇中，我们将回顾如何安装测试和实验性的Docker版本。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we'll be using a freshly installed Ubuntu 16.04 host. Although
    not a requirement, it is recommended that you install prerelease versions of Docker
    on a host that does not currently have Docker installed. If the installer script
    detects Docker is already installed, it will warn you not to install the experimental
    or test code. That being said, I recommend that testing of software from these
    channels occurs on dedicated development servers. In many cases, virtual machines
    are used for this purpose. If you use a virtual machine, I recommend you to install
    your base operating system and then snapshot the VM to give yourself a restore
    point. If something goes wrong with the installation, you can always revert to
    this snapshot to start from a known good system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用一个新安装的Ubuntu 16.04主机。虽然这不是必需的，但建议您在当前未安装Docker的主机上安装Docker的预发布版本。如果安装程序检测到Docker已经安装，它将警告您不要安装实验或测试代码。也就是说，我建议在专用的开发服务器上进行来自这些渠道的软件测试。在许多情况下，虚拟机用于此目的。如果您使用虚拟机，我建议您安装基本操作系统，然后对VM进行快照，以便为自己创建还原点。如果安装出现问题，您可以始终恢复到此快照以从已知良好的系统开始。
- en: 'As Docker calls out in their documentation:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Docker在其文档中所指出的：
- en: '*Experimental features are not ready for production. They are provided for
    test and evaluation in your sandbox environments.*'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*实验性功能尚未准备好投入生产。它们提供给您在沙盒环境中进行测试和评估。*'
- en: Please keep this in mind when using either of the nonproduction trains of code.
    It is strongly encouraged that you provide feedback on GitHub on any and all features
    present in either channel.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请在使用非生产代码的任何一列火车时牢记这一点。强烈建议您在GitHub上就任何渠道中存在的所有功能提供反馈。
- en: How to do it…
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: As mentioned, there are two different prerelease software channels available
    to end users.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，终端用户可以使用两个不同的预发布软件渠道。
- en: '[https://experimental.docker.com/](https://experimental.docker.com/): This
    is the URL for the script to download and install the experimental version of
    Docker. This version includes features that are entirely experimental. Many of
    these futures may at some later point be integrated into a production release.
    However, many will not and are in this channel solely for experimentation.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://experimental.docker.com/](https://experimental.docker.com/)：这是下载和安装Docker实验版本的脚本的URL。该版本包括完全实验性的功能。其中许多功能可能在以后的某个时候集成到生产版本中。然而，许多功能不会这样做，而是仅用于实验目的。'
- en: '[https://test.docker.com/](https://test.docker.com/): This is the URL for the
    script to download and install the test version of Docker. Docker also refers
    to this as the **Release Candidate** (**RC**) version of code. This is code has
    features that are slated to be released but have not yet been integrated into
    the production or release version of Docker.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://test.docker.com/](https://test.docker.com/)：这是下载和安装Docker测试版本的脚本的URL。Docker还将其称为**发布候选**（**RC**）版本的代码。这些代码具有计划发布但尚未集成到Docker生产或发布版本中的功能。'
- en: 'To install either version, you simply download the script from the URL and
    pass it to the shell. For instance:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装任一版本，您只需从URL下载脚本并将其传递给shell。例如：
- en: 'To install the experimental release, run this command:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要安装实验版，请运行此命令：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To install the test or release candidate, release run this command:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要安装测试版或候选发布版，请运行此命令：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As a point of interest, you can also use a similar configuration to download
    the production version of Docker. In addition to [https://test.docker.com/](https://test.docker.com/)
    and [https://experimental.docker.com/](https://experimental.docker.com/), there
    is also [https://get.docker.com/](https://get.docker.com/) that will install the
    production release of the software.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，您也可以使用类似的配置来下载Docker的生产版本。除了[https://test.docker.com/](https://test.docker.com/)和[https://experimental.docker.com/](https://experimental.docker.com/)之外，还有[https://get.docker.com/](https://get.docker.com/)，它将安装软件的生产版本。
- en: 'As mentioned, the use of these scripts should be done on machines that do not
    currently have Docker installed. After installation, you can verify the appropriate
    release was installed by examining the output of `docker info`. For example, when
    installing the experimental release, you can see the experimental flag set in
    the output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些脚本的使用应该在当前未安装Docker的机器上进行。安装后，您可以通过检查`docker info`的输出来验证是否安装了适当的版本。例如，在安装实验版本时，您可以在输出中看到实验标志已设置：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the test or RC version, you''ll see similar output; however, there will
    not be an experimental variable listed in the output of Docker info:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试或RC版本中，您将看到类似的输出；但是，在Docker info的输出中不会列出实验变量：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After installation via the script, you should find that Docker is installed
    and running just as if you had installed Docker through your operating systems
    default package manager. While the script should prompt you toward the end of
    the installation, it is advisable to add your user account to the Docker group.
    This prevents you from having to escalate your privileges with `sudo` to use the
    Docker CLI commands. To add your user account to the Docker group, use this command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过脚本安装后，您会发现Docker已安装并运行，就好像您通过操作系统的默认软件包管理器安装了Docker一样。虽然脚本应该在安装的最后提示您，但建议将您的用户帐户添加到Docker组中。这样可以避免您在使用Docker
    CLI命令时需要提升权限使用`sudo`。要将您的用户帐户添加到Docker组中，请使用以下命令：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Make sure that you log off and back in for the setting to take effect.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您注销并重新登录以使设置生效。
- en: 'Keep in mind that these scripts can also be used to update to latest version
    of either channel. In those scenarios, the script will still prompt you about
    the possibility of installing over an existing Docker installation, but it will
    provide verbiage to indicate that you can ignore the message:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些脚本也可以用于更新任一渠道的最新版本。在这些情况下，脚本仍会提示您有关在现有Docker安装上安装的可能性，但它将提供措辞以指示您可以忽略该消息：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Although this is not the only way to get the test and experimental code, it
    is certainly the easiest. You may also download the prebuilt binaries or build
    the binary yourself. Information on how to do both is available on Docker's GitHub
    page at [https://github.com/docker/docker/tree/master/experimental](https://github.com/docker/docker/tree/master/experimental).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是获取测试和实验代码的唯一方法，但肯定是最简单的方法。您也可以下载预构建的二进制文件或自行构建二进制文件。有关如何执行这两种操作的信息可在Docker的GitHub页面上找到：[https://github.com/docker/docker/tree/master/experimental](https://github.com/docker/docker/tree/master/experimental)。
- en: Understanding MacVLAN interfaces
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解MacVLAN接口
- en: The first feature we'll be looking at is MacVLAN. In this recipe, we'll be implementing
    MacVLAN outside of Docker to gain a better understanding of how it works. Understanding
    how MacVLAN works outside of Docker will be critical in understanding how Docker
    consumes MacVLAN. In the next recipe, we'll walk through the Docker network driver
    implementation of MacVLAN.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的第一个特性是MacVLAN。在这个教程中，我们将在Docker之外实现MacVLAN，以更好地理解它的工作原理。了解Docker之外的MacVLAN如何工作对于理解Docker如何使用MacVLAN至关重要。在下一个教程中，我们将介绍Docker网络驱动程序对MacVLAN的实现。
- en: Getting ready
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we''ll be using two Linux hosts (`net1` and `net2`) to demonstrate
    MacVLAN functionality. Our lab topology will look as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用两台Linux主机（`net1`和`net2`）来演示MacVLAN功能。我们的实验室拓扑将如下所示：
- en: '![Getting ready](graphics/5453_09_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](graphics/5453_09_01.jpg)'
- en: 'It is assumed that the hosts are in a base configuration and each host has
    two network interfaces. The `eth0` interface will have a static IP address defined
    and serve as each hosts default gateway. The `eth1` interface will be configured
    with no IP address. For reference, you can find the network configuration file
    (`/etc/network/interfaces`) for each host following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 假设主机处于基本配置状态，每台主机都有两个网络接口。 `eth0`接口将有一个静态IP地址，并作为每个主机的默认网关。 `eth1`接口将配置为没有IP地址。
    供参考，您可以在每个主机的网络配置文件（`/etc/network/interfaces`）中找到以下内容：
- en: '`net1.lab.lab`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net1.lab.lab`'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`net2.lab.lab`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net2.lab.lab`'
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While we'll cover all of the steps needed to create the topology in this recipe,
    you may wish to refer to [Chapter 1](ch01.html "Chapter 1. Linux Networking Constructs"),
    *Linux Networking Constructs*, if some of the steps aren't clear. [Chapter 1](ch01.html
    "Chapter 1. Linux Networking Constructs"), *Linux Networking Constructs*, covers
    the base Linux networking constructs and the CLI tools in much greater depth.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将在这个示例中涵盖创建拓扑所需的所有步骤，但如果有些步骤不清楚，您可能希望参考[第1章](ch01.html "第1章. Linux网络构造"),
    *Linux网络构造*。[第1章](ch01.html "第1章. Linux网络构造"), *Linux网络构造*，更深入地介绍了基本的Linux网络构造和CLI工具。
- en: How to do it…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: MacVLAN represents an entirely different way to configure interfaces from what
    we've seen up until this point. Earlier Linux networking configurations we examined
    relied on constructs that loosely mimicked physical network constructs. MacVLAN
    interfaces are logical in nature and are bound to an existing network interface.
    The interface supporting the MacVLAN interfaces is referred to as the **parent**
    interface and can support one or more MacVLAN logical interfaces. Let's look at
    a quick example of configuring a MacVLAN interface on one of our lab hosts.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: MacVLAN代表一种完全不同的接口配置方式，与我们到目前为止所见过的方式完全不同。我们之前检查的Linux网络配置依赖于松散模仿物理网络结构的构造。MacVLAN接口在逻辑上是绑定到现有网络接口的，并且被称为**父**接口，可以支持一个或多个MacVLAN逻辑接口。让我们快速看一下在我们的实验室主机上配置MacVLAN接口的一个示例。
- en: 'Configuring MacVLAN type interfaces is done in a very similar manner to all
    other types on Linux network interfaces. Using the `ip` command-line tool, we
    can use the `link` subcommand to define the interface:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 配置MacVLAN类型接口的方式与Linux网络接口上的所有其他类型非常相似。使用`ip`命令行工具，我们可以使用`link`子命令来定义接口：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This syntax should be familiar to you from the first chapter of the book where
    we defined multiple different interface types. Once created, the next step is
    to configure it with an IP address. This is also done through the `ip` command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法应该对你来说很熟悉，因为我们在书的第一章中定义了多种不同的接口类型。创建后，下一步是为其配置IP地址。这也是通过`ip`命令完成的：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: And finally, we need to make sure that bring the interface up.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要确保启动接口。
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The interface is now up and we can examine the configuration with the `ip addr
    show` command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接口现在已经启动，我们可以使用`ip addr show`命令来检查配置：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are a couple of interesting items to point out now that we have the interface
    configured. First, the name of the MacVLAN interface makes it easy to identify
    the interfaces parent interface. Recall that we mentioned that each MacVLAN interface
    had to be associated with a parent interface. In this case, we can tell that the
    parent of this MacVLAN interface is `eth0` by looking at the name listed after
    the `macvlan1@` in the MacVLAN interface name. Second, the IP address assigned
    to the MacVLAN interfaces is in the same subnet as the parent interface (`eth0`).
    This is intentional to allow external connectivity. Let''s define a second MacVLAN
    interface on the same parent interface to demonstrate what sort of connectivity
    is allowed:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了接口，有几个有趣的地方需要指出。首先，MacVLAN接口的名称使得很容易识别接口的父接口。回想一下，我们提到每个MacVLAN接口都必须与一个父接口关联。在这种情况下，我们可以通过查看MacVLAN接口名称中`macvlan1@`后面列出的名称来知道这个MacVLAN接口的父接口是`eth0`。其次，分配给MacVLAN接口的IP地址与父接口（`eth0`）处于相同的子网中。这是有意为之，以允许外部连接。让我们在同一个父接口上定义第二个MacVLAN接口，以演示允许的连接性：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our network topology is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络拓扑如下：
- en: '![How to do it…](graphics/5453_09_02.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/5453_09_02.jpg)'
- en: 'We have two MacVLAN interfaces bound to net1''s `eth0` interface. If we try
    to reach either interface from an external subnet, the connectivity should work
    as expected:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个MacVLAN接口绑定到net1的`eth0`接口。如果我们尝试从外部子网访问任一接口，连接性应该如预期般工作：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding output, I attempted to reach both `172.16.10.5` and `172.16.10.6`
    from a test server that lives off subnet from the `net1` host. In both cases,
    we were able to reach the IP address of the MacVLAN interfaces implying that routing
    is working as expected. This is why, we gave the MacVLAN interfaces IP addresses
    within the existing subnet of the servers `eth0` interface. Since the multilayer
    switch knew that `172.16.10.0/24` lives out of VLAN 10, it simply has to issue
    an ARP request for the new IP addresses on VLAN 10 to get their MAC addresses.
    The Linux host already has a default route pointing back to the switch that allows
    the return traffic to reach the test server. However, this is by no means a requirement
    of MacVLAN interfaces. I could have easily chosen another IP subnet to use for
    the interfaces, but that would have prevented external routing from inherently
    working.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我尝试从`net1`主机的子网外部的测试服务器上到达`172.16.10.5`和`172.16.10.6`。在这两种情况下，我们都能够到达MacVLAN接口的IP地址，这意味着路由正在按预期工作。这就是为什么我们给MacVLAN接口分配了服务器`eth0`接口现有子网内的IP地址。由于多层交换机知道`172.16.10.0/24`位于VLAN
    10之外，它只需为VLAN 10上的新IP地址发出ARP请求，以获取它们的MAC地址。Linux主机已经有一个指向允许返回流量到达测试服务器的交换机的默认路由。然而，这绝不是MacVLAN接口的要求。我本可以轻松选择另一个IP子网用于接口，但那将阻止外部路由的固有工作。
- en: 'Another item to point out is that the parent interface does not need to have
    an IP address associated with it. For instance, let''s extend the topology by
    building two more MacVLAN interfaces. One on the host `net1` and another on the
    host `net2`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要指出的地方是父接口不需要有关联的IP地址。例如，让我们通过在主机`net1`上建立两个更多的MacVLAN接口来扩展拓扑。一个在主机`net1`上，另一个在主机`net2`上：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our topology is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的拓扑如下：
- en: '![How to do it…](graphics/5453_09_03.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/5453_09_03.jpg)'
- en: 'Despite not having an IP address defined on the physical interface, the hosts
    now see the `192.168.10.0/24` network as being defined and believe the network
    to be locally connected:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在物理接口上没有定义IP地址，但主机现在将`192.168.10.0/24`网络视为已定义，并认为该网络是本地连接的：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This means that the two hosts can reach each other directly through their associated
    IP addresses on that subnet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着两个主机可以直接通过它们在该子网上的关联IP地址相互到达：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At this point, you might be wondering why you would use a MacVLAN interface
    type. From the looks of it, it''s doesn''t appear that much different than just
    creating logical subinterfaces. The real difference is in how the interface is
    built. Typically, subinterfaces all use the same MAC address of the parent interfaces.
    You might have noted in the earlier output and diagrams that the MacVLAN interfaces
    have different MAC addresses than their associated parent interface. We can validate
    this on the upstream multilayer switch (gateway) as well:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能会想知道为什么要使用MacVLAN接口类型。从外观上看，它似乎与创建逻辑子接口没有太大区别。真正的区别在于接口的构建方式。通常，子接口都使用相同的父接口的MAC地址。您可能已经注意到在先前的输出和图表中，MacVLAN接口具有与其关联的父接口不同的MAC地址。我们也可以在上游多层交换机（网关）上验证这一点：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In testing, you might find that the Linux host is presenting the same MAC address
    for each IP address in your configuration. Depending on what operating system
    you are running, you may need to change the following kernel parameters in order
    to prevent the host from presenting the same MAC address:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，您可能会发现Linux主机对于配置中的每个IP地址都呈现相同的MAC地址。根据您运行的操作系统，您可能需要更改以下内核参数，以防止主机呈现相同的MAC地址：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Keep in mind that the applying these settings in this manner won't persist through
    a reboot.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，以这种方式应用这些设置不会在重新启动后持久存在。
- en: Looking at the MAC addresses, we can see that the parent interface (`172.16.10.2`)
    and both MacVLAN interfaces (`172.16.10.5 and .6`) have different MAC addresses.
    MacVLAN allows you to present multiple interfaces using different MAC addresses.
    The net result is that you can have multiple IP interfaces, each with their own
    unique MAC address, that all use the same physical interface.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从MAC地址来看，我们可以看到父接口（`172.16.10.2`）和两个MacVLAN接口（`172.16.10.5`和`6`）具有不同的MAC地址。MacVLAN允许您使用不同的MAC地址呈现多个接口。其结果是您可以拥有多个IP接口，每个接口都有自己独特的MAC地址，但都使用同一个物理接口。
- en: 'Since the parent interface is responsible for multiple MAC addresses it needs
    to be in promiscuous mode. The host should automatically put an interface into
    promiscuous mode when it''s chosen as a parent interface. You can verify it by
    checking the ip link details:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于父接口负责多个MAC地址，它需要处于混杂模式。当选择为父接口时，主机应自动将接口置于混杂模式。您可以通过检查ip链接详细信息来验证：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If having the parent interface in promiscuous mode is a concern, you might be
    interested in the later recipes of this chapter where we discuss IPVLAN configurations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果父接口处于混杂模式是一个问题，您可能会对本章后面讨论的IPVLAN配置感兴趣。
- en: As with other Linux interface types we've seen, MacVLAN interfaces are also
    namespace aware. This can lead to some interesting configuration options. Let's
    now look at deploying MacVLAN interfaces within unique network namespaces.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们见过的其他Linux接口类型一样，MacVLAN接口也支持命名空间。这可以导致一些有趣的配置选项。现在让我们来看看如何在独立的网络命名空间中部署MacVLAN接口。
- en: 'Let''s start by deleting all of our existing MacVLAN interfaces:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先删除所有现有的MacVLAN接口：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Much like we did in [Chapter 1](ch01.html "Chapter 1. Linux Networking Constructs"),
    *Linux Networking Constructs*, we can create an interface and then move it into
    a namespace. We start by creating the namespace:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在[第1章](ch01.html "第1章. Linux网络构造")中所做的那样，*Linux网络构造*，我们可以创建一个接口，然后将其移入一个命名空间。我们首先创建命名空间：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we create the MacVLAN interface:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建MacVLAN接口：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we move the interface into the newly created network namespace:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将接口移入新创建的网络命名空间：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And finally, from within the namespace, we assign it an IP address and bring
    it up:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从命名空间内部，我们为其分配一个IP地址并将其启动：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s also create a second interface within a second namespace for testing
    purposes:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也在第二个命名空间中创建一个第二个接口，用于测试目的：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As you play around with different configurations, it's common to create and
    delete the same interface a number of times. In doing so, you'll likely generate
    interfaces with the same IP address, but different MAC addresses. Since we're
    presenting these MAC address to the upstream physical network, always make sure
    that the upstream device or gateway has the most recent ARP entry for the IP you
    are trying to reach. It's common for many switches and routers to have long ARP
    timeout values during which they won't ARP for the newer MAC entry.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试不同的配置时，通常会多次创建和删除相同的接口。这样做时，您可能会生成具有相同IP地址但不同MAC地址的接口。由于我们将这些MAC地址呈现给上游物理网络，因此请务必确保上游设备或网关具有要到达的IP的最新ARP条目。许多交换机和路由器在长时间内不会为新的MAC条目ARP而具有长的ARP超时值是很常见的。
- en: 'At this point, we have a topology that looks something like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的拓扑看起来是这样的：
- en: '![How to do it…](graphics/5453_09_04.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/5453_09_04.jpg)'
- en: The parent interface (`eth0`) has an IP address as before, but this time, the
    MacVLAN interfaces live within their own unique namespaces. Despite being in separate
    namespaces, they still share the same parent since this was done before moving
    them into the namespace.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 父接口（`eth0`）像以前一样有一个IP地址，但这次，MacVLAN接口存在于它们自己独特的命名空间中。尽管位于不同的命名空间中，但它们仍然共享相同的父接口，因为这是在将它们移入命名空间之前完成的。
- en: 'At this point, you should note that external hosts can no longer ping all of
    the IP addresses. Rather, you can only reach the `eth0` IP address of `172.16.10.2`.
    The reason for this is simple. As you''ll recall, namespaces are comparable to
    a **Virtual Routing and Forwarding** (**VRF**) and have their own routing table.
    If you examine, the routing table of both of the namespaces, you''ll see that
    neither of them have a default route:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该注意到外部主机无法再ping通所有IP地址。相反，您只能到达`172.16.10.2`的`eth0` IP地址。原因很简单。正如您所记得的，命名空间类似于**虚拟路由和转发**（**VRF**），并且有自己的路由表。如果您检查一下两个命名空间的路由表，您会发现它们都没有默认路由：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In order for these interfaces to be reachable off network, we''ll need to give
    each namespace a default route pointing to the gateway on that subnet (`172.16.10.1`).
    Again, this is the benefit of addressing the MacVLAN interfaces in the same subnet
    as the parent interface. The routing is already there on the physical network.
    Add the routes and test again:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些接口在网络外可达，我们需要为每个命名空间指定一个默认路由，指向该子网上的网关（`172.16.10.1`）。同样，这是将MacVLAN接口 addressing在与父接口相同的子网中的好处。路由已经存在于物理网络上。添加路由并重新测试：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'From the external test host (some output removed for brevity):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部测试主机（为简洁起见删除了一些输出）：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So while external connectivity appears to be working as expected, you''ll note
    that none of the interfaces can talk to each other:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然外部连接似乎按预期工作，但请注意，这些接口都无法相互通信：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This seems odd because they all share the same parent interface. The problem
    is in how the MacVLAN interfaces were configured. The MacVLAN interface type supports
    four different modes:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎很奇怪，因为它们都共享相同的父接口。问题在于MacVLAN接口的配置方式。MacVLAN接口类型支持四种不同的模式：
- en: '**VEPA**: The **Virtual Ethernet Port Aggregator** (**VEPA**) mode forces all
    traffic sourced from the MacVLAN interfaces out of the parent interface regardless
    of destination. Even traffic destined to another MacVLAN interface sharing the
    same parent interface is subject to this policy. In a layer 2 scenario, the communication
    between two MacVLAN interfaces would likely be blocked because of standard spanning
    tree rules. You could potentially route between the two on an upstream router.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VEPA**：**虚拟以太网端口聚合器**（**VEPA**）模式强制所有源自MacVLAN接口的流量从父接口出去，无论目的地如何。即使流量的目的地是共享同一父接口的另一个MacVLAN接口，也会受到此策略的影响。在第2层场景中，由于标准生成树规则，两个MacVLAN接口之间的通信可能会被阻止。您可以在上游路由器上在两者之间进行路由。'
- en: '**Bridge**: The MacVLAN bridge mode mimics a standard Linux bridge. Communication
    between two MacVLAN interfaces on the same parent interface is allowed to occur
    directly without transiting the parent interface off the host. This is useful
    for scenarios where you expect a high level of interface to interface communication
    across the same parent interface.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桥接**：MacVLAN桥接模式模仿标准Linux桥接。允许在同一父接口上的两个MacVLAN接口之间直接进行通信，而无需经过主机的父接口。这对于您期望在同一父接口上跨接口进行高级别通信的情况非常有用。'
- en: '**Private**: This mode resembles VEPA mode with the added capability of entirely
    blocking communication between interfaces on the same parent interface. Even if
    you allow the traffic to transit the parent and then hairpin back into the host,
    the communication will be dropped.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**：此模式类似于VEPA模式，具有完全阻止在同一父接口上的接口之间通信的功能。即使允许流量经过父接口然后回流到主机，通信也会被丢弃。'
- en: '**Passthru**: Intended as a means to directly tie the parent interface to the
    MacVLAN interface. In this mode, only a single MacVLAN interface per parent is
    allowed and the MacVLAN interface inherits the MAC address from the parent.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**透传**：旨在直接将父接口与MacVLAN接口绑定。在此模式下，每个父接口只允许一个MacVLAN接口，并且MacVLAN接口继承父接口的MAC地址。'
- en: 'While not easy to discern without knowing where to look, our MacVLAN interfaces
    happen to be of type VEPA, which happens to be the default. We can see this by
    passing the details (`-d`) flag to the `ip` command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不知道在哪里查找，很难分辨出来，我们的MacVLAN接口碰巧是VEPA类型，这恰好是默认值。我们可以通过向`ip`命令传递详细信息（`-d`）标志来查看这一点：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In our case, the VEPA mode is what's preventing the two namespace interfaces
    from talking directly to each other. More commonly, MacVLAN interfaces are defined
    as type `bridge` to allowed communication between interfaces on the same parent.
    However, even in this mode, the child interfaces are not allowed to communicate
    directly with the IP address assigned directly to the parent interface (in this
    case `172.16.10.2`). This should be a separate paragraph.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，VEPA模式阻止了两个命名空间接口直接通信。更常见的是，MacVLAN接口被定义为类型`bridge`，以允许在同一父接口上的接口之间进行通信。然而，即使在这种模式下，子接口也不被允许直接与直接分配给父接口的IP地址（在本例中为`172.16.10.2`）进行通信。这应该是一个单独的段落。
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we can recreate both interfaces specifying the `bridge` mode for each MacVLAN
    interface:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以重新创建两个接口，为每个MacVLAN接口指定`bridge`模式：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After specifying the `bridge` mode, we can verify that the two interfaces can
    directly to one another:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定了`bridge`模式之后，我们可以验证这两个接口可以直接互连：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'However, we also note that we still cannot reach the hosts IP address defined
    on the parent interface (`eth0`):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也注意到我们仍然无法到达在父接口（`eth0`）上定义的主机IP地址：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Working with the Docker MacVLAN network driver
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker MacVLAN网络驱动程序
- en: When I began writing this book, the current version of Docker was 1.10 and at
    that time MacVLAN functionality was included in the release candidate version
    of Docker. Since then, version 1.12 has been released, which pushed MacVLAN into
    the release version of the software. That being said, the only requirement to
    use the MacVLAN driver is to ensure that you have a 1.12 or newer version of Docker
    installed. In this chapter, we'll review how to consume the MacVLAN network driver
    for containers provisioned from Docker.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始写这本书时，Docker的当前版本是1.10，那时MacVLAN功能已经包含在Docker的候选版本中。自那时起，1.12版本已经发布，将MacVLAN推入软件的发布版本。也就是说，使用MacVLAN驱动程序的唯一要求是确保您安装了1.12或更新版本的Docker。在本章中，我们将讨论如何为从Docker创建的容器使用MacVLAN网络驱动程序。
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we''ll be using two Linux hosts running Docker. Our lab topology
    will consist of two Docker hosts that live on the same network. It will look like
    this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用两台运行Docker的Linux主机。我们的实验拓扑将包括两个生活在同一网络上的Docker主机。它将如下所示：
- en: '![Getting ready](graphics/5453_09_05.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](graphics/5453_09_05.jpg)'
- en: It is assumed that each host is running a version of Docker that is 1.12 or
    greater in order to have access to the MacVLAN driver. The hosts should have a
    single IP interface and Docker should be in its default configuration. In some
    cases, the changes we make may require you to have root-level access to the system.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 假设每个主机都运行着1.12或更高版本的Docker，以便可以访问MacVLAN驱动程序。主机应该有一个单独的IP接口，并且Docker应该处于默认配置状态。在某些情况下，我们所做的更改可能需要您具有系统的根级访问权限。
- en: How to do it…
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Much like all of the other user-defined network types, the MacVLAN driver is
    handled through the `docker network` subcommand. Creating a MacVLAN type network
    is just as easy as creating any other network type, but there are a few things
    to keep in mind that are specific to this driver.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有其他用户定义的网络类型一样，MacVLAN驱动程序是通过`docker network`子命令处理的。创建MacVLAN类型网络与创建任何其他网络类型一样简单，但有一些特定于此驱动程序的事项需要牢记。
- en: You need to specify the upstream gateway when defining the network. Remember
    that MacVLAN interfaces are presented on the same interface of the parent. They'll
    need the host or interfaces upstream gateway to access external subnets.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义网络时，您需要指定上游网关。请记住，MacVLAN接口显示在父接口的相同接口上。它们需要主机或接口的上游网关才能访问外部子网。
- en: In other user-defined network types, Docker would generate a subnet for you
    to use if you decided not to specify one. While that is still the case with the
    MacVLAN driver, it will not function properly unless you specify the network in
    which your parent interface has access to. Like we saw in the last recipe, MacVLAN
    relies on the upstream network device knowing how to route the MacVLAN interfaces.
    This is accomplished by defining the MacVLAN interfaces for your containers on
    the same subnet as the parent interface. You may also chose to use a parent interface
    that does not have a defined IP address. In these cases, just make sure that the
    gateway you specify when defining the network in Docker is reachable out of the
    parent interface.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他用户定义的网络类型中，如果您决定不指定一个子网，Docker会为您生成一个子网供您使用。虽然MacVLAN驱动程序仍然是这种情况，但除非您指定父接口所在的网络，否则它将无法正常工作。就像我们在上一个教程中看到的那样，MacVLAN依赖于上游网络设备知道如何路由MacVLAN接口。这是通过在与父接口相同的子网上定义容器的MacVLAN接口来实现的。您还可以选择使用没有定义IP地址的父接口。在这些情况下，只需确保您在Docker中定义网络时指定的网关可以通过父接口到达。
- en: As an option to the driver, you need to specify the interface that you wish
    to use as the parent interface for all containers attached with MacVLAN interfaces.
    If you do not specify a parent interface as an option, Docker will create a dummy
    network interface and use this as the parent interface. This will prevent any
    communication to outside networks from this network.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为驱动程序的选项，您需要指定希望用作所有连接到MacVLAN接口的容器的父接口的接口。如果不将父接口指定为选项，Docker将创建一个虚拟网络接口并将其用作父接口。这将阻止该网络与外部网络的任何通信。
- en: The `--internal flag` is available when creating networks with the MacVLAN driver.
    When specified the parent interface is defined as a dummy interface, which prevents
    traffic from leaving the host.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MacVLAN驱动程序创建网络时，可以使用`--internal标志`。当指定时，父接口被定义为虚拟接口，阻止流量离开主机。
- en: There is a one-to-one relationship with MacVLAN user-defined networks and parent
    interfaces. That is, you can only define one MacVLAN type network on a given parent
    interface.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MacVLAN用户定义网络与父接口之间是一对一的关系。也就是说，您只能在给定的父接口上定义一个MacVLAN类型网络。
- en: Some switch vendors limit the number of MAC addresses that can be learned per
    port. While this number is typically extremely high, make sure that you take this
    into consideration when using this network type.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些交换机供应商限制每个端口可以学习的MAC地址数量。虽然这个数字通常非常高，但在使用这种网络类型时，请确保考虑到这一点。
- en: As with other user-defined network types, you can specify an IP range or a set
    of auxiliary addresses that you wish Docker's IPAM not to allocate to containers.
    In MacVLAN mode, these settings are much more significant because you are presenting
    containers directly onto the physical network.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他用户定义的网络类型一样，您可以指定IP范围或一组辅助地址，希望Docker的IPAM不要分配给容器。在MacVLAN模式下，这些设置更为重要，因为您直接将容器呈现到物理网络上。
- en: 'Taking these points into consideration with our current lab topology, we can
    define the network as follows on each host:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们当前的实验室拓扑，我们可以在每个主机上定义网络如下：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With this configuration, each host on the network will use one half of the available
    defined subnet, which in this case is a `/25`. Since Dockers IPAM automatically
    reserves the gateway IP address for us, there's no need to prevent it from being
    allocated by defining it as an auxiliary address. However, since the Docker hosts
    interfaces themselves do live within this range, we do need to reserve those with
    auxiliary addresses.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种配置，网络上的每个主机将使用可用子网的一半，本例中为`/25`。由于Docker的IPAM自动为我们保留网关IP地址，因此无需通过将其定义为辅助地址来阻止其分配。但是，由于Docker主机接口本身确实位于此范围内，我们确实需要使用辅助地址来保留这些地址。
- en: 'We can now define containers on each host and verify that they can communicate
    with each other:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在每个主机上定义容器，并验证它们是否可以彼此通信：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You'll note that there isn't a need to publish ports when the containers are
    run. Since the container has a uniquely routable IP address at this point, port
    publishing is not required. Any container can offer any service on its own unique
    IP address.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在容器运行时不需要发布端口。由于容器此时具有唯一可路由的IP地址，因此不需要进行端口发布。任何容器都可以在其自己的唯一IP地址上提供任何服务。
- en: 'Much like other network types, Docker creates a network namespace for each
    container, which it then maps the containers MacVLAN interface into. Our topology
    at this point looks like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他网络类型一样，Docker为每个容器创建一个网络命名空间，然后将容器的MacVLAN接口映射到其中。此时，我们的拓扑如下所示：
- en: '![How to do it…](graphics/5453_09_06.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤如下...](graphics/5453_09_06.jpg)'
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The namespace name can be found by inspecting the container itself or by linking
    the Docker `netns` directory, as we saw in earlier chapters, so the `ip netns`
    subcommand can query Docker-defined network namespaces.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过检查容器本身或链接Docker的`netns`目录来找到命名空间名称，就像我们在前面的章节中看到的那样，因此`ip netns`子命令可以查询Docker定义的网络命名空间。
- en: 'From an external testing host that lives off subnet, we can verify that each
    containers services are reachable via the containers IP address:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个生活在子网之外的外部测试主机，我们可以验证每个容器服务都可以通过容器的IP地址访问到：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'However, you will note that containers attached to MacVLAN networks are not
    accessible from the local host despite being on the same interface:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您会注意到连接到MacVLAN网络的容器尽管位于同一接口上，但无法从本地主机访问：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The current implementation of Docker support MacVLAN only in the MacVLAN bridge
    mode. We can verify that this is the operating mode of the MacVLAN interfaces
    by checking the details of the interface within the container:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Docker当前的实现仅支持MacVLAN桥接模式。我们可以通过检查容器内接口的详细信息来验证MacVLAN接口的操作模式：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Understanding IPVLAN interfaces
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解IPVLAN接口
- en: An alternative to MacVLAN is IPVLAN. IPVLAN comes in two flavors. The first
    is L2 mode, which operates very similarly to MacVLAN with the exception of how
    MAC addresses are assigned. With IPVLAN mode, all logical IP interfaces use the
    same MAC address. This allows you to keep the parent NIC out of promiscuous mode
    and also prevents you from running into any possible NIC or switch port MAC limitations.
    The second mode is IPVLAN layer 3\. In layer 3 mode, IPVLAN acts like a router
    and forwards unicast packets in and out of IPVLAN connected networks. In this
    recipe, we'll cover the basic IPVLAN networking construct to get an idea of how
    it works and how it can be implemented.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: IPVLAN是MacVLAN的一种替代方案。IPVLAN有两种模式。第一种是L2模式，它的操作方式与MacVLAN非常相似，唯一的区别在于MAC地址的分配方式。在IPVLAN模式下，所有逻辑IP接口使用相同的MAC地址。这使得您可以保持父NIC不处于混杂模式，并且还可以防止您遇到任何可能的NIC或交换机端口MAC限制。第二种模式是IPVLAN层3。在层3模式下，IPVLAN就像一个路由器，转发IPVLAN连接网络中的单播数据包。在本文中，我们将介绍基本的IPVLAN网络结构，以了解它的工作原理和实现方式。
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we'll be using the same Linux hosts (`net1` and `net2`) from
    the *Understanding MacVLAN interfaces* recipe in this chapter. Please refer to
    *Understanding MacVLAN* recipe's *Getting ready* section for more information
    about the topology.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将使用本章中“理解MacVLAN接口”食谱中的相同Linux主机（`net1`和`net2`）。有关拓扑结构的更多信息，请参阅本章中“理解MacVLAN”食谱的“准备工作”部分。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Older versions of the `iproute2` toolset did not include full support for IPVLAN.
    If the commands are not working for the IPVLAN configuration there's a good chance
    you're on an older version without support. You likely need to update in order
    to get a newer version that has full support. The older versions have some support
    for IPVLAN but lack the ability to define a mode (L2 or L3).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 较旧版本的`iproute2`工具集不包括对IPVLAN的完全支持。如果IPVLAN配置的命令不起作用，很可能是因为您使用的是不支持的较旧版本。您可能需要更新以获取具有完全支持的新版本。较旧的版本对IPVLAN有一些支持，但缺乏定义模式（L2或L3）的能力。
- en: How to do it…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: As mentioned, IPVLAN in L2 mode is almost identical to MacVLAN in terms of functionality.
    The major difference is in the fact that IPVLAN leverages the same MAC address
    for all IPVLAN interfaces attached to the same master. You'll recall that MacVLAN
    interfaces leveraged a different MAC address for each MacVLAN interface attached
    to the same parent.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，IPVLAN的L2模式在功能上几乎与MacVLAN相同。主要区别在于IPVLAN利用相同的MAC地址连接到同一主机的所有IPVLAN接口。您会记得，MacVLAN接口利用不同的MAC地址连接到同一父接口的每个MacVLAN接口。
- en: 'We can create the same interfaces we did in MacVLAN recipe to show that the
    interface addresses are created with an identical MAC address:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建与MacVLAN配方中相同的接口，以显示接口地址是使用相同的MAC地址创建的：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note that the only difference in the configuration is that we''re specifying
    the type as IPVLAN and the mode as L2\. In the case of IPVLAN, the default mode
    is L3, so we need to specify L2 in order to get the interfaces to operate in that
    fashion. Since IPVLAN interfaces inherit the MAC address of the parent, our topology
    should look like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，配置中唯一的区别是我们将类型指定为IPVLAN，模式指定为L2。在IPVLAN的情况下，默认模式是L3，因此我们需要指定L2以使接口以这种方式运行。由于IPVLAN接口继承了父接口的MAC地址，我们的拓扑应该是这样的：
- en: '![How to do it…](graphics/5453_09_07.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![操作方法...](graphics/5453_09_07.jpg)'
- en: 'We can prove this just by checking the interface themselves:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查接口本身来证明这一点：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we were to initiate traffic toward these IPs from off of the local subnet
    we could validate that each IP is reporting the same MAC address by checking the
    ARP table on the upstream gateway:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从本地子网外部向这些IP发起流量，我们可以通过检查上游网关的ARP表来验证每个IP报告相同的MAC地址：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And while we won't show an example here, IPVLAN interfaces in L2 mode are also
    namespace aware just like we saw in the last couple of recipes with the MacVLAN
    interface type. The only difference would be in the interface MAC addresses as
    we saw in the preceding code. The same restrictions apply in regard to the parent
    interface being unable to talk to the child interfaces and vice versa.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里不会展示一个例子，但是IPVLAN接口在L2模式下也像我们在最近几个配方中看到的MacVLAN接口类型一样具有命名空间感知能力。唯一的区别在于接口MAC地址，就像我们在前面的代码中看到的那样。与父接口无法与子接口通信以及反之的相同限制也适用。
- en: 'Now that we know how IPVLAN in L2 mode works, let''s discuss IPVLAN L3 mode.
    L3 mode is significantly different than what we''ve seen up to this point. As
    the name L3 mode suggests, this interface type routes traffic between all attached
    subinterfaces. This is easiest to comprehend in a namespace configuration. For
    instance, let''s look at this quick lab topology:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了IPVLAN在L2模式下的工作原理，让我们讨论一下IPVLAN L3模式。L3模式与我们到目前为止所见到的情况有很大不同。正如L3模式的名称所暗示的那样，这种接口类型在所有附加的子接口之间路由流量。这在命名空间配置中最容易理解。例如，让我们看一下这个快速实验的拓扑：
- en: '![How to do it…](graphics/5453_09_08.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![操作方法...](graphics/5453_09_08.jpg)'
- en: 'In the preceding image, you can see that I''ve created four unique namespaces
    across our two lab hosts. I also created four unique IPVLAN interfaces, mapped
    them into the different namespaces, and gave them each a unique IP address. Since
    these are IPVLAN interfaces, you''ll note that all of the IPVLAN interfaces share
    the MAC address of the parent interface. To build this topology, I used the following
    configuration on each respective host:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，您可以看到我在我们的两个实验主机上创建了四个独立的命名空间。我还创建了四个独立的IPVLAN接口，将它们映射到不同的命名空间，并为它们分配了各自独特的IP地址。由于这些是IPVLAN接口，您会注意到所有IPVLAN接口共享父接口的MAC地址。为了构建这个拓扑，我在每个相应的主机上使用了以下配置：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once this is configured, you''ll note that the only interfaces that can communicate
    with one another are those on the host `net2` (`10.10.40.10` and `10.10.40.11`).
    Let''s look at this topology logically to understand why:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置完成，您会注意到唯一可以相互通信的接口是主机`net2`上的那些接口（`10.10.40.10`和`10.10.40.11`）。让我们逻辑地看一下这个拓扑，以理解其中的原因：
- en: '![How to do it…](graphics/5453_09_09.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![操作方法...](graphics/5453_09_09.jpg)'
- en: 'Looking at this logically, it starts to look like a routed network. You''ll
    notice that all the IP addresses assigned are unique without any overlap. As I
    mentioned earlier, IPVLAN L3 mode acts like a router. From a conceptual perspective,
    you can think of the parent interface as that router. If we look at this from
    a layer 3 perspective, it makes sense that only the interfaces in namespaces 3
    and 4 can talk because they are in the same broadcast domain. The other namespaces
    would need to route through a gateway to talk to each other. Let''s check the
    routing table on all of the namespaces to see where things stand:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上看，它开始看起来像一个路由网络。你会注意到所有分配的IP地址都是唯一的，没有重叠。正如我之前提到的，IPVLAN L3模式就像一个路由器。从概念上看，你可以把父接口看作是那个路由器。如果我们从三层的角度来看，只有命名空间3和4中的接口可以通信，因为它们在同一个广播域中。其他命名空间需要通过网关进行路由才能相互通信。让我们检查一下所有命名空间的路由表，看看情况如何：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As expected, each namespace only knows about the local network. So in order
    for these interfaces to communicate, they need to have at the very least a default
    route. This is where things get a little interesting. IPVLAN interfaces do not
    allow broadcast or multicast traffic. This means that if we defined the gateway
    of the interface to be the upstream switch, it would never be able to reach it
    because it wouldn''t be able to ARP for it. However, since the parent is acting
    like a sort of router, we can have the namespaces use the IPVLAN interface itself
    as a gateway. We can do that by adding default routes in this fashion:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，每个命名空间只知道本地网络。因此，为了让这些接口进行通信，它们至少需要一个默认路由。这就是事情变得有点有趣的地方。IPVLAN接口不允许广播或组播流量。这意味着如果我们将接口的网关定义为上游交换机，它永远也无法到达，因为它无法进行ARP。然而，由于父接口就像一种路由器，我们可以让命名空间使用IPVLAN接口本身作为网关。我们可以通过以下方式添加默认路由来实现这一点：
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After adding these routes, you''ll also need to add routes on each Linux host
    to tell them where to go to reach these remote subnets. Since the two hosts in
    this example are layer 2 adjacent, the best place to do this on the host itself.
    While you could also rely on the default route and configure these routes on the
    upstream network device that would not be ideal. You would effectively be routing
    in and out of the same L3 interface on the gateway, which isn''t great network
    design practice. If the hosts had not been layer 2 adjacent adding the routes
    on the multilayer switch would have been required:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加这些路由之后，你还需要在每台Linux主机上添加路由，告诉它们如何到达这些远程子网。由于这个示例中的两台主机是二层相邻的，最好在主机本身进行这些操作。虽然你也可以依赖默认路由，并在上游网络设备上配置这些路由，但这并不理想。你实际上会在网关上的同一个L3接口上进行路由，这不是一个很好的网络设计实践。如果主机不是二层相邻的，那么在多层交换机上添加路由就是必需的。
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After you have all of the routes installed, you should be able to reach all
    of the namespaces from any of the other namespaces:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了所有路由之后，你应该能够从任何一个命名空间到达所有其他命名空间。
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, IPVLAN L3 mode is a different animal than what we've seen up
    until this point. Unlike MacVLAN or IPVLAN L2, you'll need to tell the network
    how to reach these new interfaces.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，IPVLAN L3模式与我们到目前为止所见到的不同。与MacVLAN或IPVLAN L2不同，你需要告诉网络如何到达这些新接口。
- en: Working with the Docker IPVLAN network driver
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker IPVLAN网络驱动程序
- en: As we've seen in the previous recipe, IPVLAN offers some interesting modes of
    operations that can be relevant to large-scale container deployments. As of now,
    Docker support IPVLAN in its experimental software channel. In this recipe, we'll
    review how you can consume IPVLAN attached containers with the Docker IPVLAN driver.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一个配方中所看到的，IPVLAN提供了一些有趣的操作模式，这些模式可能与大规模容器部署相关。目前，Docker在其实验软件通道中支持IPVLAN。在本配方中，我们将审查如何使用Docker
    IPVLAN驱动程序消耗附加IPVLAN的容器。
- en: Getting ready
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we''ll be using two Linux hosts running Docker. Our lab topology
    will look like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将使用两台运行Docker的Linux主机。我们的实验拓扑将如下所示：
- en: '![Getting ready](graphics/5453_09_10.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](graphics/5453_09_10.jpg)'
- en: It is assumed that each host is running the experimental channel of Docker in
    order to get access to the experimental IPVLAN network driver. Please see recipe
    1 in regard to the use and consumption of the experimental software channel. The
    hosts should have a single IP interface and Docker should be in its default configuration.
    In some cases, the changes we make may require you to have root-level access to
    the system.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 假设每个主机都在运行Docker的实验通道，以便访问实验性的IPVLAN网络驱动程序。请参阅有关使用和消费实验软件通道的第1个配方。主机应该有一个单独的IP接口，并且Docker应该处于默认配置。在某些情况下，我们所做的更改可能需要您具有系统的根级访问权限。
- en: How to do it…
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Once you have your hosts running the experimental code, verify that you are
    on the correct version by viewing the output of `docker info`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的主机运行了实验性代码，请通过查看`docker info`的输出来验证您是否处于正确的版本：
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: At the time of this writing, you need to be on an experimental version of Docker
    for the IPVLAN driver to be present.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，您需要在Docker的实验版本上才能使用IPVLAN驱动程序。
- en: 'The Docker IPVLAN network driver offers both the layer 2 and layer 3 mode of
    operation. Since the IPVLAN L2 mode closely mimics the MacVLAN configuration we
    reviewed earlier, we''ll focus on implementing the L3 mode in this recipe. The
    first thing we need to do is to define the networks. Before doing so, there are
    a few things to keep in mind when using the IPVLAN network driver:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Docker IPVLAN网络驱动程序提供了层2和层3操作模式。由于IPVLAN L2模式与我们之前审查的MacVLAN配置非常相似，因此我们将专注于在本配方中实现L3模式。我们需要做的第一件事是定义网络。在这样做之前，在使用IPVLAN网络驱动程序时需要记住一些事情：
- en: While it will allow you to specify a gateway when defining the network, the
    setting is ignored. Recall from the previous recipe that you need to use the IPVLAN
    interface itself as the gateway rather than the upstream network device. Docker
    will take care of configuring this for you.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然它允许您在定义网络时指定网关，但该设置将被忽略。请回想一下前一个配方，您需要使用IPVLAN接口本身作为网关，而不是上游网络设备。Docker会为您配置这个。
- en: As an option to the driver, you need to specify the interface that you wish
    to use as the parent interface for all containers attached with IPVLAN interfaces.
    If you do not specify a parent interface as an option, Docker will create a dummy
    network interface and use this as the parent interface. This will prevent any
    communication to outside networks from this network.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为驱动程序的一个选项，您需要指定要用作所有附加IPVLAN接口的父接口的接口。如果您不将父接口指定为选项，Docker将创建一个虚拟网络接口，并将其用作父接口。这将阻止该网络与外部网络进行通信。
- en: The `--internal` flag is available when creating networks with the IPVLAN driver.
    When specified the parent interface is defined as a dummy interface, which prevents
    traffic from leaving the host.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用IPVLAN驱动程序创建网络时，可以使用`--internal`标志。当指定时，父接口被定义为虚拟接口，阻止流量离开主机。
- en: If you do not specify a subnet, Docker IPAM will select one for you. This is
    not advised as these are routable subnets. IPAM on different Docker hosts will
    likely pick the same subnet. Always specify the subnet you wish to define.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您没有指定子网，Docker IPAM将为您选择一个。这是不建议的，因为这些是可路由的子网。不同Docker主机上的IPAM可能会选择相同的子网。请始终指定您希望定义的子网。
- en: There is a one-to-one relationship with IPVLAN user-defined networks and parent
    interfaces. That is, you can only define one IPVLAN type network on a given parent
    interface.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPVLAN用户定义网络和父接口之间是一对一的关系。也就是说，在给定的父接口上只能定义一个IPVLAN类型的网络。
- en: 'You''ll note that many of the preceding points are similar to the ones that
    apply to the Docker MacVLAN driver. A significant difference lies in the fact
    that we do not want to use the same network as the parent interface. In our examples,
    we''ll use the subnet `10.10.20.0/24` on the host `docker1` and the subnet `10.10.30.0/24`
    on the host `docker3`. Let''s define the networks on each host now:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，许多前面的观点与适用于Docker MacVLAN驱动程序的观点相似。一个重要的区别在于，我们不希望使用与父接口相同的网络。在我们的示例中，我们将在主机`docker1`上使用子网`10.10.20.0/24`，在主机`docker3`上使用子网`10.10.30.0/24`。现在让我们在每台主机上定义网络：
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Once created, we can start a container on each host that uses the IPVLAN network:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，我们可以在每个使用IPVLAN网络的主机上启动一个容器：
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You''ll notice that we once again do not need to deal with publishing ports.
    The container is assigned a fully routable IP address and can present any service
    it wishes on that IP. The IP addresses assigned to the container will come out
    of the specified subnet. In this case, our topology looks like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，我们再次不需要处理发布端口。容器被分配了一个完全可路由的IP地址，并且可以在该IP上提供任何服务。分配给容器的IP地址将来自指定的子网。在这种情况下，我们的拓扑结构如下：
- en: '![How to do it…](graphics/5453_09_11.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](graphics/5453_09_11.jpg)'
- en: 'Once running, you''ll notice that the containers don''t have any connectivity.
    This is because the network doesn''t know how to reach each of the IPVLAN networks.
    For this to work, we need to tell the upstream network device how to reach each
    subnet. To do this, we''ll add the following routes on the multilayer switch:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行起来，您会注意到容器没有任何连接。这是因为网络不知道如何到达每个IPVLAN网络。为了使其工作，我们需要告诉上游网络设备如何到达每个子网。为此，我们将在多层交换机上添加以下路由：
- en: '[PRE51]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Once this routing is in place, we''ll be able to route to the remote containers
    and access any service they are offering:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了这种路由，我们就能够路由到远程容器并访问它们提供的任何服务：
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You''ll notice that in this mode, the container can also reach the hosts interface:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，在这种模式下，容器还可以访问主机接口：
- en: '[PRE53]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'While this works, it''s important to know that this is happening by traversing
    the parent interface out to the multilayer switch and then coming back in. We
    can see that the upstream switch (gateway) is generating ICMP redirects if we
    try the ping in the reverse direction:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样可以工作，但重要的是要知道这是通过遍历父接口到多层交换机然后再返回来实现的。如果我们尝试在相反的方向进行ping，上游交换机（网关）会生成ICMP重定向。
- en: '[PRE54]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: So while host-to-container connectivity works, it's not the best model if you
    require the host to communicate with the containers locally.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然主机到容器的连接是有效的，但如果您需要主机与本地容器通信，则这不是最佳模型。
- en: Tagging VLAN IDs with MacVLAN and IPVLAN networks
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MacVLAN和IPVLAN网络标记VLAN ID
- en: One feature that's available with both MacVLAN and IPVLAN Docker network types
    is the ability to tag containers on a particular VLAN. This is possible since
    both network types leverage a parent interface. In this recipe, we'll show you
    how you can create Docker network types that are VLAN tagged or VLAN aware. Since
    this functionality works the same in the case of either network type, we'll focus
    on configuring this with MacVLAN type networks.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: MacVLAN和IPVLAN Docker网络类型都具有的一个特性是能够在特定VLAN上标记容器。这是可能的，因为这两种网络类型都利用了一个父接口。在这个教程中，我们将向您展示如何创建支持VLAN标记或VLAN感知的Docker网络类型。由于这个功能在任一网络类型的情况下都是相同的，我们将重点介绍如何在MacVLAN类型网络中配置这个功能。
- en: Getting ready
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we''ll be a single Docker host to demonstrate how the Linux
    host can send VLAN tagged frames to upstream network devices. Our lab topology
    will be as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将使用单个Docker主机来演示Linux主机如何向上游网络设备发送VLAN标记帧。我们的实验拓扑将如下所示：
- en: '![Getting ready](graphics/5453_09_12.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](graphics/5453_09_12.jpg)'
- en: It is assumed that this host is running version 1.12\. The host has two network
    interfaces, `eth0` with an IP address of `10.10.10.101` and `eth1` that is up,
    but has no IP address configured on it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个主机正在运行1.12版本。主机有两个网络接口，`eth0`的IP地址是`10.10.10.101`，`eth1`是启用的，但没有配置IP地址。
- en: How to do it…
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: One of the interesting features comes along with MacVLAN and IPVLAN network
    drivers is the ability to provision subinterfaces. A subinterface is a logical
    partition of what's typically a physical interface. The standard way of partitioning
    a physical interface is to leverage VLANs. You'll commonly hear this referred
    to as dot1q trunking or VLAN tagging. To do this, the upstream network interface
    has to be prepared to receive tagged frames and be able to interpret the tag.
    In all of our previous examples, the upstream network port was hard-coded to a
    particular VLAN. This is the case with the `eth0` interface of this server. It
    is plugged into a port on the switch that is statically configured for VLAN 10\.
    In addition to this, the switch also has an IP interface on VLAN 10, which in
    our case is `10.10.10.1/24`. It acts as the server's default gateway. Frames sent
    from the servers `eth0` interface are received by the switch and end up in VLAN
    10\. That piece is pretty straightforward.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: MacVLAN和IPVLAN网络驱动程序带来的一个有趣特性是能够提供子接口。子接口是通常物理接口的逻辑分区。对物理接口进行分区的标准方法是利用VLAN。你通常会听到这被称为dot1q干线或VLAN标记。为了做到这一点，上游网络接口必须准备好接收标记帧并能够解释标记。在我们之前的所有示例中，上游网络端口都是硬编码到特定的VLAN。这就是这台服务器的`eth0`接口的情况。它插入了交换机上的一个端口，该端口静态配置为VLAN
    10。此外，交换机还在VLAN 10上有一个IP接口，我们的情况下是`10.10.10.1/24`。它充当服务器的默认网关。从服务器的`eth0`接口发送的帧被交换机接收并最终进入VLAN
    10。这一点非常简单明了。
- en: 'The other option is to have the server tell the switch what VLAN it wishes
    to be in. To do this, we create a subinterface on the server that is specific
    to a given VLAN. Traffic leaving that interface is tagged with the VLAN number
    and sent on its way to the switch. In order for this to work, the switch port
    needs to be configured as a **trunk**. Trunks are interfaces that can carry multiple
    VLANs and are VLAN tag (dot1q) aware. When the switch receives the frame, it references
    the VLAN tag in the frame and puts the traffic into the right VLAN based on the
    tag. Logically, you might depict a trunk configuration as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是让服务器告诉交换机它希望在哪个VLAN中。为此，我们在服务器上创建一个特定于给定VLAN的子接口。离开该接口的流量将被标记为VLAN号并发送到交换机。为了使其工作，交换机端口需要配置为**干线**。干线是可以携带多个VLAN并且支持VLAN标记（dot1q）的接口。当交换机接收到帧时，它会引用帧中的VLAN标记，并根据标记将流量放入正确的VLAN中。从逻辑上讲，您可以将干线配置描述如下：
- en: '![How to do it…](graphics/5453_09_13.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/5453_09_13.jpg)'
- en: We depict the `eth1` interface as a wide channel that can support connectivity
    to a large number of VLANs. We can see that the trunk port can connect to all
    of the possible VLAN interfaces based on the tag it receives. The `eth0` interface
    is statically bound to the VLAN 10 interface.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`eth1`接口描述为一个宽通道，可以支持连接到大量VLAN。我们可以看到干线端口可以连接到所有可能的VLAN接口，这取决于它接收到的标记。`eth0`接口静态绑定到VLAN
    10接口。
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is wise in production environments to limit the VLANs allowed on a trunk
    port. Not doing so would mean someone could potentially gain access to any VLAN
    on the switch just by specifying the right dot1q tag.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，限制干线端口上允许的VLAN是明智的。不这样做意味着某人可能只需指定正确的dot1q标记就可以潜在地访问交换机上的任何VLAN。
- en: 'This functionality has been around for a long time, and Linux system administrators
    are likely familiar with the manual process used to create VLAN tagged subinterfaces.
    The interesting piece is that Docker can now manage this for you. For instance,
    we can create two different MacVLAN networks:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能已经存在很长时间了，Linux系统管理员可能熟悉用于创建VLAN标记子接口的手动过程。有趣的是，Docker现在可以为您管理这一切。例如，我们可以创建两个不同的MacVLAN网络：
- en: '[PRE55]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The interfaces are defined much like any other MacVLAN interface. What''s different
    is that we specified the `.19` and `.20` on the parent interface names. Specifying
    a dot with numbers after an interface name is the common syntax for defining subinterfaces.
    If we look at the hosts network interface, we should see the addition of two new
    interfaces:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的定义与任何其他MacVLAN接口一样。不同的是，我们在父接口名称上指定了`.19`和`.20`。在接口名称后面指定带有数字的点是定义子接口的常见语法。如果我们查看主机网络接口，我们应该会看到两个新接口的添加：
- en: '[PRE56]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We can tell from this output that these are either MacVLAN or IPVLAN interfaces
    whose parent happens to be the physical interface `eth1`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中我们可以看出，这些都是MacVLAN或IPVLAN接口，其父接口恰好是物理接口`eth1`。
- en: 'If we launch containers on both of these networks, we''ll see that they end
    up within either VLAN 19 or VLAN 20 based on which network we specify:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这两个网络上启动容器，我们会发现它们最终会进入基于我们指定的网络的VLAN 19或VLAN 20中：
- en: '[PRE57]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'And if we attempt to send traffic to either of their gateways, we''ll find
    that both are reachable:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试向它们的网关发送流量，我们会发现两者都是可达的：
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If we capture the frames as they leave the server, we''ll even be able to see
    the dot1q (VLAN) tag in the layer 2 header:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们捕获服务器发送的帧，甚至能够在第2层标头中看到dot1q（VLAN）标记：
- en: '![How to do it…](graphics/5453_09_14.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/5453_09_14.jpg)'
- en: As with other network constructs Docker creates, Docker will also take care
    of the cleanup in the case that you delete these user-defined networks. In addition,
    if you prefer to build the subinterface yourself, Docker can consume interfaces
    that you have already created so long as the name is the same as the parent you
    specify.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 与Docker创建的其他网络结构一样，Docker也会在您删除这些用户定义的网络时进行清理。此外，如果您更喜欢自己建立子接口，Docker可以使用您已经创建的接口，只要名称与您指定的父接口相同即可。
- en: Being able to specify VLAN tags as part of a user-defined network is a big deal
    and makes presenting containers to the physical network a much easier task.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在用户定义的网络中指定VLAN标签是一件大事，这使得将容器呈现给物理网络变得更加容易。
