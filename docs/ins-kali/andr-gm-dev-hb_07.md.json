["```kt\n@Override\nprotected void onDraw ( Canvas c)\n{\n  float px = 100.0f;\n  float py = 100.0f;\n  float radius = 50.0f;\n\n  int startColor = Color.GREEN;\n  int targetColor = Color.RED;\n\n  Paint shaderPaint = new Paint();\n  shaderPaint.setStyle(Paint.Style.FILL);\n\n  //LinearGradient Example to a circular region\n  LinearGradient lgs = new LinearGradient( px, py, px + radius, py + radius, \n    startColor, targetColor, Shader.TileMode.MIRROR);\n  shaderPaint.setShader(lgs);\n  c.drawCircle( px, py, radius, shaderPaint);\n\n  //RadialGradient Example to a circular region\n  px = 200.0f;\n  py = 200.0f;\n  RadialGradient rgs = new LinearGradient( px, py, radius, \n    startColor, targetColor, Shader.TileMode.MIRROR);\n  shaderPaint.setShader(rgs);\n  c.drawCircle( px, py, radius, shaderPaint);\n\n  //SweepGradient Example to a circular region\n  px = 300.0f;\n  py = 300.0f;\n  shaderPaint.setShader(new SweepGradient(px, py, startColor, targetColor));\n  c.drawCircle( px, py, radius, shaderPaint);\n}\n```", "```kt\nprivate float touchX;\nprivate float touchY;\nprivate boolean shouldMask = false;\n\nprivate final float viewRadius;\nprivate Paint customPaint;\n\n@Override\npublic boolean onTouchEvent(MotionEvent motionEvent) \n{\n  int pointerAction = motionEvent.getAction();\n  if ( pointerAction == MotionEvent.ACTION_DOWN || \n  pointerAction == MotionEvent.ACTION_MOVE )\n    shouldMask = true;\n  else\n    shouldMask = false;\n\n  touchX = motionEvent.getX();\n  touchY = motionEvent.getY();\n  invalidate();\n  return true;\n}\n\n@Override\nprotected void onDraw(Canvas canvas) \n{\n  if (customPaint == null) \n  {\n    Bitmap source = Bitmap.createBitmap( getWidth(), getHeight(), Bitmap.Config.ARGB_8888);\n    Canvas baseCanvas = new Canvas(source);\n    super.onDraw(baseCanvas);\n\n    Shader customShader = new BitmapShader(source, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);\n\n    customPaint = new Paint();\n    customPaint.setShader(customShader);\n  }\n\n  canvas.drawColor(Color.RED);\n  if (shouldMask) \n  {\n    canvas.drawCircle( touchX, touchY - viewRadius, viewRadius, customPaint);\n  }\n}\n```", "```kt\nimport android.opengl.GLSurfaceView;\nimport android.content.Context;\n\npublic class MyGLExampleView extends GLSurfaceView \n{\n  private final GLRenderer mRenderer;\n\n  public MyGLExampleView (Context context) \n  {\n    super(context);\n\n// Set OpenGL version 2.0 as we will be working with that particular library\n    this.setEGLContextClientVersion(2);\n\n// Set the Renderer for drawing on the GLSurfaceView\n    MyOpenGLRendererExample = new MyOpenGLRendererExample (context);\n    setRenderer(mRenderer);\n\n// Render the view only when there is a change in the //drawing data\n    setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);\n  }\n\n  @Override\n  public void onPause() \n  {\n    super.onPause();\n  }\n\n  @Override\n  public void onResume() \n  {\n    super.onResume();\n  }\n}\n```", "```kt\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.FloatBuffer;\nimport java.nio.ShortBuffer;\n\nimport android.content.Context;\nimport android.opengl.GLES20;\nimport android.opengl.GLSurfaceView.Renderer;\nimport android.opengl.Matrix;\nimport android.util.Log;\n\nimport javax.microedition.khronos.egl.EGLConfig;\nimport javax.microedition.khronos.opengles.GL10;\n\npublic class MyOpenGLRendererExample implements Renderer \n{\n\n  // Declare matrices\n  private float[] matatrixProjection = new float[32];\n  private float[] matrixView = new float[32];\n  private float[] matatrixProjectionOnView = new float[32];\n\n  // Declare Co-ordinate attributes\n  private float vertexList[];\n  private short indicxList[];\n  private FloatBuffer vertexBuffer;\n  private ShortBuffer drawBuffer;\n\n  private final String vertexShader =\n          \"uniform    mat4        uMVPMatrix;\" +\n          \"attribute  vec4        vPosition;\" +\n          \"void main() {\" +\n          \"  gl_Position = uMVPMatrix * vPosition;\" +\n          \"}\";\n\n  private final String pixelShader =\n          \"precision mediump float;\" +\n          \"void main() {\" +\n          \"  gl_FragColor = vec4(0.5,0,0,1);\" +\n          \"}\";\n\n  // Declare Screen Width and Height HD display\n  float ScreenWidth = 1280.0f;\n  float ScreenHeight = 800.0f;\n\n  private int programIndex = 1;\n\n  public MyOpenGLRendererExample (Context context)\n  {\n\n  }\n\n  @Override\n  public void onDrawFrame(GL10 param) \n  {\n    renderView(matatrixProjectionOnView);\n  }\n\n  @Override\n  public void onSurfaceChanged(GL10 objGL, int width, \nint height) \n  {\n    ScreenWidth = (float)width;\n    ScreenHeight = (float)height;\n\n    GLES20.glViewport(0, 0, (int)ScreenWidth, \n(int)ScreenHeight);\n\n    //reset matrices\n    for( int i = 0; i < 32 ; ++ i )\n    {\n      matatrixProjection[i] = 0.0f;\n      matrixView[i] = 0.0f;\n      matatrixProjectionOnView[i] = 0.0f;\n    }\n\n    Matrix.orthoM(matatrixProjection, 0, 0f, ScreenWidth, \n0.0f, ScreenHeight, 0, 50);\n\n    Matrix.setLookAtM(matrixView, 0, 0f, 0f, 1f, 0f, 0f, \n0f, 0f, 1.0f, 0.0f);\n\n    Matrix.multiplyMM(matatrixProjectionOnView, 0, \nmatatrixProjection, 0, matrixView, 0);\n  }\n\n  @Override\n  public void onSurfaceCreated(GL10 gl, EGLConfig config) \n  {\n    //create any object \n    //Eg. Triangle:: simplest possible closed region\n\n    createTriangle();\n\n    // Set the color to black\n    GLES20.glClearColor(0.0f, 0.0f, 0.0f, 1);\n\n    // Create the shaders\n    int vertexShaderTmp = \nloadShader(GLES20.GL_VERTEX_SHADER, vertexShader);\n\n    int pixelShaderTmp = \nloadShader(GLES20.GL_FRAGMENT_SHADER, pixelShader);\n\n    int programIndexTmp = GLES20.glCreateProgram();\n\n    GLES20.glAttachShader(programIndexTmp, \nvertexShaderTmp);\n\n    GLES20.glAttachShader(programIndexTmp, \npixelShaderTmp);\n\n    GLES20.glLinkProgram(programIndexTmp);\n\n    // Set shader program\n    GLES20.glUseProgram(programIndexTmp);\n  }\n\n  void renderView(float[] matrixParam) \n  {\n    int positionHandler = \nGLES20.glGetAttribLocation(programIndex, \"vPosition\");\n\n    GLES20.glEnableVertexAttribArray(positionHandler);\n    GLES20.glVertexAttribPointer(positionHandler, 3, \nGLES20.GL_FLOAT, false, 0, vertexBuffer);\n\n    int mtrxhandle = \nGLES20.glGetUniformLocation(programIndex, \"uMVPMatrix\");\n\n    GLES20.glUniformMatrix4fv(mtrxhandle, 1,\n false, matrixParam, 0);\n\n    GLES20.glDrawElements(GLES20.GL_TRIANGLES, \nindicxList.length, GLES20.GL_UNSIGNED_SHORT, drawBuffer);\n\n    GLES20.glDisableVertexAttribArray(positionHandler);  \n  }\n\n  void createTriangle()\n  {\n    // We have to create the vertexList of our triangle.\n    vertexList = new float[]\n    {\n      20.0f, 200f, 0.0f,\n      20.0f, 300f, 0.0f,\n      200f, 150f, 0.0f,\n    };\n\n    //setting up the vertex list in order\n    indicxList = new short[] {0, 1, 2};\n\n    ByteBuffer bytebufVertex = \nByteBuffer.allocateDirect(vertexList.length * 4);\n\n    bytebufVertex.order(ByteOrder.nativeOrder());\n    vertexBuffer = bytebufVertex.asFloatBuffer();\n    vertexBuffer.put(vertexList);\n    vertexBuffer.position(0);\n\n    ByteBuffer bytebufindex = \nByteBuffer.allocateDirect(indicxList.length * 2);\n\n    bytebufindex.order(ByteOrder.nativeOrder());\n    drawBuffer = bytebufindex.asShortBuffer();\n    drawBuffer.put(indicxList);\n    drawBuffer.position(0);\n\n    int vertexShaderTmp = \nloadShader(GLES20.GL_VERTEX_SHADER, vertexShader);\n\n    int pixelShaderTmp = \nloadShader(GLES20.GL_FRAGMENT_SHADER, pixelShader);\n\n    int program = GLES20.glCreateProgram();\n    if (program != 0) \n    {\n      GLES20.glAttachShader(program, vertexShaderTmp);\n      GLES20.glAttachShader(program, pixelShaderTmp);\n      GLES20.glLinkProgram(program);\n\n      int[] linkStatus = new int[1];\n\n      GLES20.glGetProgramiv(program, \nGLES20.GL_LINK_STATUS, linkStatus, 0);\n\n      if (linkStatus[0] != GLES20.GL_TRUE) \n      {\n        Log.e(\"TAG_EXAMPLE_OPENGL\", \"Linking Failed !! \nError:: \" + GLES20.glGetProgramInfoLog(program));\n\n        GLES20.glDeleteProgram(program);\n        program = 0;\n      }\n    }\n  }\n\n// method to create shader\n   int loadShader(int type, String shaderCode)\n   {\n        int shader = GLES20.glCreateShader(type);\n\n        GLES20.glShaderSource(shader, shaderCode);\n        GLES20.glCompileShader(shader);\n\n        return shader;\n    }\n}\n```"]