- en: 8\. Services, WorkManager, and Notifications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 服务、WorkManager和通知
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter will introduce you to the concepts of managing long-running tasks
    in the background of an app. By the end of this chapter, you will be able to trigger
    a background task, create a notification for the user when a background task is
    complete, and launch an application from a notification. This chapter will give
    you a solid understanding of how to manage background tasks and keep the user
    informed about the progress of these tasks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍在应用程序的后台管理长时间运行任务的概念。通过本章结束时，您将能够触发后台任务，为用户创建通知，当后台任务完成时启动应用程序。本章将使您对如何管理后台任务并让用户了解这些任务的进度有一个扎实的理解。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we learned how to request permissions from the user
    and use Google's Maps API. With that knowledge, we obtained the user's location
    and allowed them to deploy an agent on a local map. In this chapter, we will learn
    how to track a long-running process and report its progress to the user.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何从用户那里请求权限并使用谷歌的地图API。有了这些知识，我们获得了用户的位置，并允许他们在本地地图上部署特工。在本章中，我们将学习如何跟踪长时间运行的进程，并向用户报告其进度。
- en: We will build an example app where we will assume that **Secret Cat Agents**
    (**SCAs**) get deployed in a record time of 15 seconds. That way, we'll avoid
    having to wait for very long before our background task completes. When a cat
    successfully deploys, we will notify the user and let them launch the app, presenting
    them with a successful deployment message.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个示例应用程序，假设**秘密猫特工**（**SCAs**）在15秒内部署。这样，我们就不必等待很长时间才能完成后台任务。当猫成功部署时，我们将通知用户，并让他们启动应用程序，向他们呈现成功部署的消息。
- en: 'Ongoing background tasks are quite common in the mobile world. Background tasks
    run even when an application is not active. Examples of long-running background
    tasks include the downloading of files, resource cleanup jobs, playing music,
    and tracking the user''s location. Historically, Google offered Android developers
    multiple ways of executing such tasks: services, `JobScheduler`, and Firebase''s
    `JobDispatcher` and `AlarmManager`. With the fragmentation in the Android world,
    it was quite a mess to cope with. Luckily for us, since March 2019 we have had
    a better (more stable) option. With the introduction of `WorkManager`, Google
    has abstracted the logic of choosing a background executing mechanism based on
    the API version away for us. We still use a foreground service, which is a special
    kind of service, for certain tasks that should be known to the user while running—such
    as playing music or tracking the location of the user in a running app.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 移动世界中，长时间运行的后台任务非常常见。即使应用程序不活跃，后台任务也会运行。长时间运行的后台任务的例子包括文件下载、资源清理作业、播放音乐和跟踪用户位置。在历史上，谷歌为Android开发者提供了多种执行此类任务的方式：服务、`JobScheduler`、Firebase的`JobDispatcher`和`AlarmManager`。随着Android世界的碎片化，处理这些任务变得非常混乱。幸运的是，自2019年3月以来，我们有了更好（更稳定）的选择。随着`WorkManager`的推出，谷歌已经为我们抽象出了根据API版本选择后台执行机制的逻辑。我们仍然使用前台服务，这是一种特殊类型的服务，用于在运行中的应用程序中应用用户应该知道的某些任务，比如播放音乐或跟踪用户的位置。
- en: Before we proceed, a quick step back. We have mentioned services, and we will
    be focusing on foreground services, but we haven't quite explained what services
    are. Services are application components designed to run in the background, even
    when an app is not running. With the exception of foreground services, which are
    tied to a notification, services have no user interface. It is important to note
    that services run on the main thread of their hosting process. This means that
    their operations can block the app. It is up to us to start a separate thread
    from within a service to avoid that.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，先快速回顾一下。我们已经提到了服务，我们将专注于前台服务，但我们还没有完全解释服务是什么。服务是设计为在后台运行的应用程序组件，即使应用程序不运行。除了与通知相关联的前台服务外，服务没有用户界面。重要的是要注意，服务在其托管进程的主线程上运行。这意味着它们的操作可能会阻塞应用程序。我们需要在服务内部启动一个单独的线程来避免这种情况。
- en: Let's get started and look at the implementation of the multiple approaches
    available in Android for managing a background task.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始看一下Android中管理后台任务的多种方法的实现。
- en: Starting a Background Task Using WorkManager
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WorkManager启动后台任务
- en: The first question we will address here is, Should we opt for `WorkManager`
    or a foreground service? To answer that, a good rule of thumb is to ask; do you
    need the action to be tracked by the user in real time? If the answer is yes (for
    example, if you have a task such as responding to the user's location or playing
    music in the background), then you should use a foreground service, with its attached
    notification to give the user a real-time indication of state. When the background
    task can be delayed or does not require user interaction (for example, downloading
    a large file), use `WorkManager`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里首先要解决的问题是，我们应该选择`WorkManager`还是前台服务？要回答这个问题，一个很好的经验法则是问：您是否需要用户实时跟踪操作？如果答案是肯定的（例如，如果您有任务，如响应用户位置或在后台播放音乐），那么您应该使用前台服务，并附加通知以向用户实时指示状态。当后台任务可以延迟或不需要用户交互时（例如，下载大文件），请使用`WorkManager`。
- en: Note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Starting with version 2.3.0-alpha02 of the `WorkManager`, you can launch a foreground
    service via the `WorkManager` by calling `setForegroundAsync(ForegroundInfo)`.
    Our control over that foreground service is quite limited. It does allow you to
    attach a (pre-defined) notification to the work, which is why it is worth mentioning.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从`WorkManager`的2.3.0-alpha02版本开始，您可以通过调用`setForegroundAsync(ForegroundInfo)`来启动前台服务。我们对前台服务的控制相当有限。它确实允许您将（预定义的）通知附加到工作中，这就是值得一提的原因。
- en: In our example, in our app, we will track the SCAs' preparation for deployment.
    Before an agent can head out, they need to stretch, groom their fur, visit the
    litter box, and suit up. Each one of these tasks takes some time. Because you
    can't rush a cat, the agent will finish each step in its own time. All we can
    do is wait (and let the user know when the task is done). `WorkManager` is perfect
    for such a scenario.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，在我们的应用程序中，我们将跟踪SCA的部署准备。在特工出发之前，他们需要伸展、梳理毛发、去猫砂盆和穿上衣服。每一个任务都需要一些时间。因为你不能催促一只猫，特工将在自己的时间内完成每一步。我们能做的就是等待（并在任务完成时通知用户）。`WorkManager`对于这样的情况非常合适。
- en: 'To use `WorkManager`, we need to familiarize ourselves with its four main classes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`WorkManager`，我们需要熟悉它的四个主要类：
- en: The first is `WorkManager` itself. `WorkManager` receives work and enqueues
    it based on provided arguments and constraints (such as internet connectivity
    and the device charging).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是`WorkManager`本身。`WorkManager`接收工作并根据提供的参数和约束（如互联网连接和设备充电）对其进行排队。
- en: The second is `Worker`. Now, `Worker` is a wrapper around the work that needs
    doing. It has one function, `doWork()`, which we override to implement the background
    work code. `doWork()` will be executed in a background thread.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是`Worker`。现在，`Worker`是需要执行的工作的包装器。它有一个函数`doWork()`，我们重写它来实现后台工作代码。`doWork()`将在后台线程中执行。
- en: 'The third class is `WorkRequest`. This class binds a `Worker` class to arguments
    and constraints. There are two types of `WorkRequest`: `OneTimeWorkRequest`, which
    runs the work once, and `PeriodicWorkRequest`, which can be used to schedule work
    to run at a fixed interval.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个类是`WorkRequest`。这个类将`Worker`类与参数和约束绑定在一起。有两种类型的`WorkRequest`：`OneTimeWorkRequest`，它运行一次工作，和`PeriodicWorkRequest`，它可以用来安排工作以固定间隔运行。
- en: The fourth class is `ListenableWorker.Result`. You probably guessed it, but
    this is the class holding the result of the executed work. The result can be one
    of `Success`, `Failure`, or `Retry`.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个类是`ListenableWorker.Result`。你可能已经猜到了，但这是保存执行工作结果的类。结果可以是`Success`、`Failure`或`Retry`中的一个。
- en: Other than these four classes, we also have the `Data` class, which holds data
    passed to and from the worker.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这四个类，我们还有`Data`类，它保存了传递给工作者和从工作者传递出来的数据。
- en: 'Let''s get back to our example. We want to define four tasks that need to occur
    in sequential order: the cat needs to stretch, then it needs to groom its fur,
    then visit the litter box, and finally, it needs to suit up.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的例子。我们想定义四个需要按顺序发生的任务：猫需要伸展，然后它需要梳理毛发，然后去猫砂盆，最后，它需要穿上衣服。
- en: 'Before we can start using `WorkManager`, we have to first include its dependency
    in our app `build.gradle` file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用`WorkManager`之前，我们必须首先在我们的应用程序`build.gradle`文件中包含其依赖项：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With `WorkManager` included in our project, we''ll go ahead and create our
    workers. The first worker will look something like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`WorkManager`包含在我们的项目中，我们将继续创建我们的工作者。第一个工作者将如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We start by extending `Worker` and overriding its `doWork()` function. We then
    read the SCA ID from the input data. Then, because we have no real sensors to
    track the progress of the cat stretching, we fake our wait by introducing a 3-second
    (3,000-millisecond) `Thread.sleep(Long)` call. Finally, we construct an output
    data class with the ID we received in our input and return it with the successful
    result.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过扩展`Worker`并重写其`doWork()`函数来开始。然后，我们从输入数据中读取SCA ID。然后，因为我们没有真正的传感器来跟踪猫伸展的进度，我们通过引入一个3秒（3,000毫秒）的`Thread.sleep(Long)`调用来伪造等待。最后，我们用我们在输入中收到的ID构造一个输出数据类，并将其与成功的结果一起返回。
- en: 'Once we''ve created workers for all our tasks (`CatStretchingWorker`, `CatFurGroomingWorker`,
    `CatLitterBoxSittingWorker`, and `CatSuitUpWorker`), similarly to how we created
    the first one, we can call `WorkManager` to chain them. Let''s also assume we
    can''t tell the progress of the agent unless we''re connected to the internet.
    Our call would look something like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为所有任务创建了工作者（`CatStretchingWorker`、`CatFurGroomingWorker`、`CatLitterBoxSittingWorker`和`CatSuitUpWorker`），类似于我们创建第一个工作者的方式，我们可以调用`WorkManager`来将它们链接起来。假设我们无法在没有连接到互联网时了解特工的进度。我们的调用将如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we first construct a `Constraints` instance declaring
    we need to be connected to the internet for the work to execute. We then define
    our input data, setting it to the SCA ID. Next, we bind the constraints and input
    data to our `Worker` class by constructing `OneTimeWorkRequest`. The construction
    of the other `WorkRequest` instances has been left out, but they are pretty much
    identical to the one shown here. We can now chain all the requests and enqueue
    them on the `WorkManager` class. You can enqueue a single `WorkRequest` instance
    by passing it directly to the `WorkManager` `enqueue()` function, or you can also
    have multiple `WorkRequest` instances run in parallel by passing them all to the
    `WorkManager` `enqueue()` function as a list.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们首先构造了一个`Constraints`实例，声明我们需要连接到互联网才能执行工作。然后，我们定义了我们的输入数据，将其设置为SCA
    ID。接下来，我们通过构造`OneTimeWorkRequest`将约束和输入数据绑定到我们的`Worker`类。其他`WorkRequest`实例的构造已经被省略了，但它们与这里显示的基本相同。现在我们可以将所有请求链接起来并将它们排队到`WorkManager`类上。您可以通过直接将单个`WorkRequest`实例传递给`WorkManager`的`enqueue()`函数来排队一个单独的`WorkRequest`实例，或者您也可以通过将它们全部传递给`WorkManager`的`enqueue()`函数作为列表来并行运行多个`WorkRequest`实例。
- en: Our tasks will be executed by `WorkManager` when the constraints are met.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当满足约束时，我们的任务将由`WorkManager`执行。
- en: 'Each `Request` instance has a unique identifier. `WorkManager` exposes a `LiveData`
    property for each request, allowing us to track the progress of its work by passing
    its unique identifier as shown in the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Request`实例都有一个唯一的标识符。`WorkManager`为每个请求公开了一个`LiveData`属性，允许我们通过传递其唯一标识符来跟踪其工作的进度，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The state of work can be `BLOCKED` (there is a chain of requests, and it is
    not next in the chain), `ENQUEUED` (there is a chain of requests, and this work
    is next), `RUNNING` (the work in `doWork()` is executing), and `SUCCEEDED`. Work
    can also be canceled, leading to a `CANCELLED` state, or it can fail, leading
    to a `FAILED` state.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有 `Result.retry`。返回此结果会告诉 `WorkManager` 类重新排队工作。决定何时再次运行工作的策略由设置在 `WorkRequest`
    `Builder` 上的 `backoff` 标准定义。默认的 `backoff` 策略是指数的，但我们也可以将其设置为线性的。我们还可以定义初始的 `backoff`
    时间。
- en: Finally, there's `Result.retry`. Returning this result tells the `WorkManager`
    class to enqueue the work again. The policy governing when to run the work again
    is defined by a `backoff` criteria set on `WorkRequest` `Builder`. The default
    `backoff` policy is exponential, but we can set it to be linear instead. We can
    also define the initial `backoff` time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '这将为 `Worker` 实现添加所需的依赖项，然后扩展 `Worker` 类。要实现实际的工作，你将重写 `doWork(): Result`，使其从输入中读取
    Cat Agent ID，休眠 `3` 秒（`3000` 毫秒），使用 Cat Agent ID 构造一个输出数据实例，并将其传递到 `Result.success`
    值中。'
- en: Let's put into practice the knowledge gained so far in the following exercise.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个练习中，我们将跟踪 SCA 在准备出发时通过排队的链式 `WorkRequest` 类：
- en: In this section, we will track our SCA from the moment we fire off the command
    to deploy it to the field to the moment it arrives at its destination.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将从我们发出部署到现场的命令开始跟踪我们的 SCA，直到它到达目的地。
- en: 'Exercise 8.01: Executing Background Work with the WorkManager Class'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要定义一个将休眠 `3` 秒的 `Worker` 实例，更新新类如下：
- en: 'In this first exercise, we will track the SCA as it prepares to head out by
    enqueuing chained `WorkRequest` classes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8.01：使用 WorkManager 类执行后台工作
- en: Start by creating a new `Empty Activity` project (`File -> New -> New Project
    -> Empty Activity`). Click `Next`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个新的 `Empty Activity` 项目（`File -> New -> New Project -> Empty Activity`）。点击
    `Next`。
- en: Name your application `Cat Agent Tracker`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在接下来的练习中实践到目前为止所学到的知识。
- en: Make sure your package name is `com.example.catagenttracker`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你在 `Project` 窗格中处于 Android 视图。
- en: Set the save location to where you want to save your project.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的包名是 `com.example.catagenttracker`。
- en: Leave everything else at its default values and click `Finish`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其他所有内容保持默认值，然后点击 `Finish`。
- en: Make sure you are on the Android view in your `Project` pane.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 `onCreate(Bundle?)` 函数中：
- en: 'Open your app''s `build.gradle` file. In the `dependencies` block, add the
    `WorkManager` dependency:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的应用程序的 `build.gradle` 文件。在 `dependencies` 块中，添加 `WorkManager` 依赖项：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Create a new package under your app package (right-click on `com.example.catagenttracker`,
    then `New` | `Package`). Name the new package `com.example.catagenttracker.worker`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作的状态可以是 `BLOCKED`（存在一系列请求，它不是下一个请求）、`ENQUEUED`（存在一系列请求，这项工作是下一个请求）、`RUNNING`（`doWork()`
    中的工作正在执行）和 `SUCCEEDED`。工作也可以被取消，导致 `CANCELLED` 状态，或者失败，导致 `FAILED` 状态。
- en: Create a new class under `com.example.catagenttracker.worker` named `CatStretchingWorker`
    (right-click on `worker`, then `New` | `New Kotlin File/Class`). Under `Kind`,
    choose `Class`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户可见的后台操作 - 使用前台服务
- en: 'To define a `Worker` instance that will sleep for `3` seconds, update the new
    class like so:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `com.example.catagenttracker.worker` 下创建一个名为 `CatStretchingWorker` 的新类（右键单击
    `worker`，然后选择 `New` | `New Kotlin File/Class`）。在 `Kind` 下，选择 `Class`。
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will add the required dependencies for a `Worker` implementation and then
    extend the `Worker` class. To implement the actual work, you will override `doWork():
    Result`, making it read the Cat Agent ID from the input, sleep for `3` seconds
    (`3000` milliseconds), construct an output data instance with the Cat Agent ID,
    and pass it inside a `Result.success` value.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的应用程序命名为 `Cat Agent Tracker`。
- en: Repeat steps 9 and 10 to create three more identical workers named `CatFurGroomingWorker`,
    `CatLitterBoxSittingWorker`, and `CatSuitUpWorker`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的应用程序：
- en: 'Open `MainActivity`. Right before the end of the class, add the following:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity`。在类的末尾之前，添加以下内容：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This helper function constructs an input `Data` instance for you with the Cat
    Agent ID.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个辅助函数为你构造了一个带有 Cat Agent ID 的输入 `Data` 实例。
- en: 'Add the following to the `onCreate(Bundle?)` function:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容按行翻译成中文：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At the top of the class, define your `WorkManager`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将保存位置设置为你想要保存项目的位置。
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add a chained `enqueue` request right below the code you just added, still
    within the `onCreate` function:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的应用程序包下创建一个新的包（右键单击 `com.example.catagenttracker`，然后选择 `New` | `Package`）。将新包命名为
    `com.example.catagenttracker.worker`。
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Define a function to show a toast with a provided message. It should look like this:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个显示带有提供的消息的提示的函数。它应该看起来像这样：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To track the progress of the enqueued `WorkRequest` instances, add the following
    after the `enqueue` call:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了跟踪排队的 `WorkRequest` 实例的进度，在 `enqueue` 调用之后添加以下内容：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run your app:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的顶部，定义你的 `WorkManager`：
- en: '![Figure 8.1: Toasts showing in order'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1：按顺序显示的提示'
- en: '](img/B15216_08_01.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该看到一个简单的 `Hello World!` 屏幕。但是，如果你等待几秒钟，你将开始看到提示信息，告诉你 SCA 准备部署到现场的进度。你会注意到这些提示信息按照你排队请求的顺序执行它们的延迟。
- en: 'Figure 8.1: Toasts showing in order'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：按顺序显示的提示
- en: You should now see a simple `Hello World!` screen. However, if you wait a few
    seconds, you will start seeing toasts informing you of the progress of your SCA
    preparing to deploy to the field. You will notice that the toasts follow the order
    in which you enqueued the requests and execute their delays sequentially.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在你刚刚添加的代码下方，仍然在 `onCreate` 函数内，添加一个链式的 `enqueue` 请求：
- en: Background Operations Noticeable to the User – Using a Foreground Service
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复步骤 9 和 10，创建三个更多相同的工作程序，分别命名为 `CatFurGroomingWorker`、`CatLitterBoxSittingWorker`
    和 `CatSuitUpWorker`。
- en: With our SCA all suited up, they are now ready to get to the assigned destination.
    To track the SCA, we will periodically poll the location of the SCA using a foreground
    service and update the sticky notification (a notification that cannot be dismissed
    by the user) attached to that service with the new location. For the sake of simplicity,
    we will fake the location. Following what you learned in *Chapter 7*, *Android
    Permissions and Google Maps*, you could later replace this implementation with
    a real one that uses a map.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的SCA已经准备好去指定的目的地了。为了跟踪SCA，我们将使用前台服务定期轮询SCA的位置，并使用新位置更新附加到该服务的粘性通知（用户无法解除的通知）。为了简单起见，我们将伪造位置。根据您在*第7章*中学到的内容，*Android权限和Google地图*，您可以稍后用使用地图的真实实现替换这个实现。
- en: Foreground services are another way of performing background operations. The
    name may be a bit counter-intuitive. It is meant to differentiate these services
    from the base Android (background) services. The former are tied to a notification,
    while the latter run in the background with no user-facing representation built
    in. Another important difference between foreground services and background services
    is that the latter are candidates for termination when the system is low on memory,
    while the former are not.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前台服务是执行后台操作的另一种方式。名称可能有点违反直觉。它的目的是区分这些服务与基本的Android（后台）服务。前者与通知绑定，而后者在后台运行，没有用户界面表示。前台服务和后台服务之间的另一个重要区别是，当系统内存不足时，后者可能会被终止，而前者不会。
- en: As of Android 9 (Pie, or API level 28), we have to request the `FOREGROUND_SERVICE`
    permission to use foreground services. Since it is a normal permission, it will
    be granted to our app automatically.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android 9（Pie，或API级别28）开始，我们必须请求`FOREGROUND_SERVICE`权限来使用前台服务。由于这是一个普通权限，它将自动授予我们的应用程序。
- en: Before we can launch a foreground service, we must first create one. A foreground
    service is a subclass of the Android abstract `Service` class. If we do not intend
    to bind to the service, and in our example, we indeed do not, we can simply override
    `onBind(Intent)` so that it returns `null`. As a side note, binding is one of
    the ways for interested clients to communicate with a Service. We will not focus
    on this approach in this book, as there are other, easier approaches, as you will
    discover below.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们启动前台服务之前，我们必须先创建一个。前台服务是Android抽象`Service`类的子类。如果我们不打算绑定到服务，而在我们的示例中确实不打算这样做，我们可以简单地重写`onBind(Intent)`，使其返回`null`。顺便说一句，绑定是感兴趣的客户端与服务通信的一种方式。在本书中，我们不会专注于这种方法，因为您将在下面发现其他更简单的方法。
- en: 'A foreground service must be tied to a notification. On Android 8 (Oreo, or
    API level 26) and above, if a foreground service is not tied to one within the
    `onCreate()` function of the service. A quick implementation would look something
    like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前台服务必须与通知绑定。在Android 8（Oreo或API级别26）及更高版本中，如果前台服务在服务的`onCreate()`函数中没有与通知绑定。一个快速的实现看起来会像这样：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's break this down.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下。
- en: 'We start by defining the channel ID. This is only required for Android Oreo
    or above and is ignored in earlier versions of Android. In Android Oreo, Google
    introduced the concept of channels. Channels are used to group notifications and
    allow users to filter out unwanted notifications:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要定义频道ID。这仅适用于Android Oreo或更高版本，在早期版本的Android中将被忽略。在Android Oreo中，Google引入了频道的概念。频道用于分组通知，并允许用户过滤掉不需要的通知：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we define `pendingIntent`. This will be the intent launched if the user
    taps on the notification. In this example, the main activity would be launched:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义`pendingIntent`。这将是用户点击通知时启动的意图。在这个例子中，主活动将被启动：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the channel ID and `pendingIntent`, we can construct our notification.
    We use `NotificationCompat`, which takes away some of the boilerplate around supporting
    older API levels. We pass in the service as the context and the channel ID. We
    define the title, text, small icon, intent, and ticker message and build the notification:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有了频道ID和`pendingIntent`，我们就可以构建我们的通知。我们使用`NotificationCompat`，它可以减少对支持旧API级别的样板代码。我们将服务作为上下文和频道ID传递进去。我们定义标题、文本、小图标、意图和滚动消息，并构建通知：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To start a service in the foreground, attaching the notification to it, we
    call it `startForeground(Int, Notification)` function, passing in a notification
    ID (any unique int value to identify this service, which must not be 0) and a
    notification, which must have its priority set to `PRIORITY_LOW` or higher. In
    our case, we have not specified the priority, which sets it to `PRIORITY_DEFAULT`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个前台服务，并将通知附加到其中，我们调用`startForeground(Int, Notification)`函数，传入一个通知ID（任何唯一的整数值来标识此服务，不能为0）和一个通知，其优先级必须设置为`PRIORITY_LOW`或更高。在我们的情况下，我们没有指定优先级，这将使其设置为`PRIORITY_DEFAULT`：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If launched, our service will now show a sticky notification. Clicking on the
    notification would launch our main activity. However, our service won't be doing
    anything useful. To add some functionality to it, we need to override `onStartCommand(Intent?,
    Int, Int)`. This function gets called when the service is launched via an intent,
    which also gives us the opportunity to read any extra data passed via that intent.
    It also provides us with flags (which may be set to `START_FLAG_REDELIVERY` or
    `START_FLAG_RETRY`) and a unique request ID. We will get to reading the extra
    data later in this chapter. You don't need to worry about the flags or the request
    ID in a simple implementation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启动，我们的服务现在将显示一个粘性通知。点击通知将启动我们的主活动。但是，我们的服务不会执行任何有用的操作。要为其添加一些功能，我们需要重写`onStartCommand(Intent?,
    Int, Int)`。当服务通过意图启动时，此函数将被调用，这也给了我们机会读取通过该意图传递的任何额外数据。它还为我们提供了标志（可能设置为`START_FLAG_REDELIVERY`或`START_FLAG_RETRY`）和一个唯一的请求ID。我们将在本章后面读取额外的数据。在简单的实现中，您不需要担心标志或请求ID。
- en: It is important to note that `onStartCommand(Intent?, Int, Int)` gets called
    on the UI thread, so don't perform any long-running operations here, or your app
    will freeze, giving the user a poor experience. Instead, we could create a new
    handler using a new `HandlerThread` (a thread with a looper, a class used to run
    a message loop for a thread) and post our work to it. This means we'll have an
    infinite loop running, waiting for us to post to it via a `Handler`. When we receive
    a start command, we can post the work we want done to it. That work will then
    be executed on that thread.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`onStartCommand(Intent?, Int, Int)`在UI线程上调用，因此不要在这里执行任何长时间运行的操作，否则您的应用程序将冻结，给用户带来不良体验。相反，我们可以使用新的`HandlerThread`（一个带有looper的线程，用于为线程运行消息循环的类）创建一个新的处理程序，并将我们的工作发布到其中。这意味着我们将有一个无限循环运行，等待我们通过`Handler`发布工作。当我们收到启动命令时，我们可以将要执行的工作发布到其中。然后该工作将在该线程上执行。
- en: When our long-running work is done, there are a few things we may want to happen.
    First, we may want to inform whoever is interested (our main activity, if it is
    running, for example) that we are done. Then, we probably want to stop running
    in the foreground. Lastly, if we do not expect to require the service again, we
    could stop it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的长时间运行的工作完成时，有一些事情可能会发生。首先，我们可能希望通知感兴趣的人（例如，如果主要活动正在运行，则通知主要活动）我们已经完成。然后，我们可能希望停止在前台运行。最后，如果我们不希望再次需要服务，我们可以停止它。
- en: An app has several ways to communicate with a service—binding, using broadcast
    receivers, using a bus architecture, or using a result receiver, to name a few.
    For our example, we will use Google's `LiveData`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序有几种与服务通信的方式——绑定、使用广播接收器、使用总线架构或使用结果接收器等。在我们的示例中，我们将使用Google的`LiveData`。
- en: Before we proceed, it is worth touching on broadcast receivers. Broadcast receivers
    allow our app to send and receive messages using a pattern much like the *publish-subscribe
    design pattern*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，值得一提的是广播接收器。广播接收器允许我们的应用程序使用类似*发布-订阅设计模式*的模式发送和接收消息。
- en: The system broadcasts events such as the device booting up or charging having
    started. Our services can broadcast status updates as well. For example, they
    can broadcast a long calculation result on completion.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 系统广播事件，例如设备启动或充电已开始。我们的服务也可以广播状态更新。例如，它们可以在完成时广播长时间的计算结果。
- en: If our app registers to receive a certain message, the system will inform it
    when that message is broadcast.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用程序注册接收某个消息，系统将在广播该消息时通知它。
- en: This used to be a common way to communicate with services, but the `LocalBroadcastManager`
    class is now deprecated as it was an application-wide event bus that encouraged
    anti-patterns.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这曾经是与服务通信的常见方式，但`LocalBroadcastManager`类现在已被弃用，因为它是一个鼓励反模式的应用程序范围事件总线。
- en: 'Having said that, broadcast receivers are still useful for system-wide events.
    We first define a class overriding the `BroadcastReceiver` abstract class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，广播接收器仍然对系统范围的事件很有用。我们首先定义一个类，覆盖`BroadcastReceiver`抽象类：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When an event is received by `ToastBroadcastReceiver`, it will show a toast
    showing the action and URI of the event.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ToastBroadcastReceiver`接收到事件时，它将显示一个显示事件操作和URI的toast。
- en: 'We can register our receiver via the `Manifest.xml` file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`Manifest.xml`文件注册我们的接收器：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Specifying `android:exported="true"` tells the system that this receiver can
    receive messages from outside of the application. The action defines the message
    we are interested in. We can specify multiple actions. In this example, we listen
    for when the device starts charging. Keep in mind that setting this value to "true"
    allows other apps, including malicious ones, to activate this receiver.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 指定`android:exported="true"`告诉系统此接收器可以接收来自应用程序外部的消息。操作定义了我们感兴趣的消息。我们可以指定多个操作。在此示例中，我们监听设备开始充电的情况。请记住，将此值设置为"true"允许其他应用程序，包括恶意应用程序，激活此接收器。
- en: 'We can also register for messages in code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在代码中注册消息：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Adding this code to an activity or in our custom application class would register
    a new instance of our receiver as well. This receiver will live so long as the
    context (activity or application) is valid. So, correspondingly, if the activity
    or application is destroyed, our receiver will be freed to be garbage collected.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加到活动或自定义应用程序类中将注册一个新的接收器实例。只要上下文（活动或应用程序）有效，此接收器将保持存在。因此，相应地，如果活动或应用程序被销毁，我们的接收器将被释放以进行垃圾回收。
- en: 'Now back to our implementation. To use `LiveData` in our app, we must add a
    dependency in our `app/build.gradle` file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到我们的实现。要在我们的应用程序中使用`LiveData`，我们必须在`app/build.gradle`文件中添加一个依赖项：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can then define a `LiveData` instance in the companion object of the service,
    like so:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在服务的伴生对象中定义一个`LiveData`实例，如下所示：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that we hide the `MutableLiveData` instance behind a `LiveData` interface.
    This is so that consumers can only read the data. We can now use the `mutableWorkCompletion`
    instance to report completion by assigning it a value. However, we must remember
    that values can only be assigned to `LiveData` instances on the main thread. This
    means once our work is done, we must switch back to the main thread. We can easily
    achieve that—all we need is a new handler with the main `Looper` (obtained by
    calling `Looper.getMainLooper()`) to which we can post our update.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将`MutableLiveData`实例隐藏在`LiveData`接口后面。这样消费者只能读取数据。现在我们可以使用`mutableWorkCompletion`实例通过为其分配一个值来报告完成。但是，我们必须记住，只能在主线程上为`LiveData`实例分配值。这意味着一旦我们的工作完成，我们必须切换回主线程。我们可以很容易地实现这一点——我们只需要一个具有主`Looper`的新处理程序（通过调用`Looper.getMainLooper()`获得），我们可以将我们的更新发布到其中。
- en: 'Now that our service is ready to do some work, we can finally launch it. Before
    we do, we must make sure we added the service to our `AndroidManifest.xml` file
    within the `<application></application>` block as shown in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的服务已经准备好做一些工作，我们最终可以启动它。在我们这样做之前，我们必须确保将服务添加到我们的`AndroidManifest.xml`文件中的`<application></application>`块中，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To launch the service we just added to our manifest, we create `Intent`, passing
    in any extra data required as shown in the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们刚刚添加到清单中的服务，我们创建`Intent`，传入所需的任何额外数据，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And then we call `ContextCompat.startForegroundService(Context, Intent)` to
    fire off `Intent` and launch the service.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`ContextCompat.startForegroundService(Context, Intent)`来触发`Intent`并启动服务。
- en: 'Exercise 8.02: Tracking Your SCA''s Work with a Foreground Service'
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.02：使用前台服务跟踪您的SCA的工作
- en: 'In the first exercise, you tracked the SCA as it was preparing to head out
    using the `WorkManager` class. In this exercise, you will track the SCA as it
    deploys to the field and moves toward the assigned target by showing a sticky
    notification counting down the time to arrival at the destination. This notification
    will be driven by a foreground service, which will present and continuously update
    it. Clicking the notification at any time will launch your main activity if it''s
    not already running and will always bring it to the foreground:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个练习中，您使用`WorkManager`类跟踪了SCA在准备出发时的情况。在这个练习中，您将通过显示一个粘性通知来跟踪SCA在部署到现场并朝着指定目标移动的情况，倒计时到达目的地的时间。这个通知将由一个前台服务驱动，它将呈现并持续更新它。随时点击通知将启动您的主活动，如果它尚未运行，它将始终将其置于前台：
- en: 'Start by adding the `LiveData` dependency to your project by updating your
    app''s `build.gradle` file:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过更新应用的`build.gradle`文件，首先向您的项目添加`LiveData`依赖项：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, create a new class called `RouteTrackingService`, extending the abstract
    `Service` class:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个名为`RouteTrackingService`的新类，扩展抽象的`Service`类：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You will not rely on binding in this exercise, so it is safe to simply return
    `null` in the `onBind(Intent)` implementation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您不会依赖绑定，因此在`onBind(Intent)`实现中简单地返回`null`是安全的。
- en: 'In the newly created service, define some constants that you will later need,
    as well as the `LiveData` instance used to observe progress:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的服务中，定义一些稍后需要的常量，以及用于观察进度的`LiveData`实例：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`NOTIFICATION_ID` has to be a unique identifier for the notification owned
    by this service and must not be `0`. Now, `EXTRA_SECRET_CAT_AGENT_ID` is the constant
    you would use to pass data to the service. `mutableTrackingCompletion` is private
    and is used to allow you to post completion updates internally via `LiveData`
    without exposing the mutability outside of the service. `trackingCompletion` is
    then used to expose the `LiveData` instance for observation in an immutable fashion.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`NOTIFICATION_ID`必须是此服务拥有的通知的唯一标识符，不能是`0`。现在，`EXTRA_SECRET_CAT_AGENT_ID`是您用于向服务传递数据的常量。`mutableTrackingCompletion`是私有的，用于允许您通过`LiveData`在服务内部发布完成更新，而不会在服务外部暴露可变性。然后使用`trackingCompletion`以不可变的方式公开`LiveData`实例以供观察。'
- en: 'Add a function to your `RouteTrackingService` class to provide `PendingIntent`
    to your sticky notification:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`RouteTrackingService`类中添加一个函数，以提供给您的粘性通知`PendingIntent`：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will launch `MainActivity` whenever the user clicks on `Notification`.
    You call `PendingIntent.getActivity()`, passing a context, no request code (`0`),
    `Intent` that will launch `MainActivity`, and no flags (`0`) to it. You get back
    `PendingIntent`, which will launch that activity.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在用户点击`Notification`时启动`MainActivity`。您调用`PendingIntent.getActivity()`，传递上下文、无请求代码（`0`）、将启动`MainActivity`的`Intent`，以及没有标志（`0`）。您会得到一个`PendingIntent`，它将启动该活动。
- en: 'Add another function to create `NotificationChannel` for devices running Android
    Oreo or newer:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个函数来为运行Android Oreo或更新版本的设备创建`NotificationChannel`：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You start by defining the channel ID. This needs to be unique to a package.
    Next, you define a channel name that will be visible to the user. This can (and
    should) be localized. We skipped that part for the sake of simplicity. A `NotificationChannel`
    instance is then created with importance set to `IMPORTANCE_DEFAULT`. The importance
    dictates how disruptive the notifications posted to this channel are. Lastly,
    a channel is created using `Notification Service` with the data provided in the
    `NotificationChannel` instance. The function returns the channel ID so that it
    can be used to construct `Notification`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义频道ID。这需要对包进行唯一标识。接下来，定义一个对用户可见的频道名称。这可以（并且应该）进行本地化。出于简单起见，我们跳过了这部分。然后创建一个`NotificationChannel`实例，将重要性设置为`IMPORTANCE_DEFAULT`。重要性决定了发布到此频道的通知有多么具有破坏性。最后，使用`Notification
    Service`使用`NotificationChannel`实例中提供的数据创建一个频道。该函数返回频道ID，以便用于构造`Notification`。
- en: 'Create a function to provide you with `Notification.Builder`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数来提供`Notification.Builder`：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This function takes the `pendingIntent` and `channelId` instances generated
    from the functions you created earlier and constructs a `NotificationCompat.Builder`
    class. The builder lets you define a title (the first row), text (the second row),
    a small icon (size differs based on the device) to use, the intent to be triggered
    when the user clicks on `Notification`, and a ticker (used for accessibility;
    before Android Lollipop, this showed before the notification was presented). You
    can set other properties, too. Explore the `NotificationCompat.Builder` class.
    In a real project, remember to use string resources from strings.xml rather than
    hardcoded strings.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用您之前创建的函数生成的`pendingIntent`和`channelId`实例，并构造一个`NotificationCompat.Builder`类。该构建器允许您定义标题（第一行）、文本（第二行）、要使用的小图标（根据设备而异的大小）、用户点击`Notification`时触发的意图以及一个提示（用于辅助功能；在Android
    Lollipop之前，这在通知被呈现之前显示）。您也可以设置其他属性。探索`NotificationCompat.Builder`类。在实际项目中，请记住使用来自strings.xml的字符串资源而不是硬编码的字符串。
- en: 'Implement the following code to introduce a function to start the foreground service:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现以下代码，引入一个函数来启动前台服务：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You first get `PendingIntent` using the function you introduced earlier. Then,
    depending on the API level of the device, you create a notification channel and
    get its ID or set an empty ID. You pass `pendingIntent` and `channelId` to the
    function that constructs `NotificationCompat.Builder`, and start the service as
    a foreground service, providing it with `NOTIFICATION_ID` and a notification built
    using the builder. The function returns `NotificationCompat.Builder`, to be used
    later to update the notification.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先使用您之前引入的函数获取`PendingIntent`。然后，根据设备的API级别，您创建一个通知通道并获取其ID，或者设置一个空ID。您将`pendingIntent`和`channelId`传递给构造`NotificationCompat.Builder`的函数，并将服务作为前台服务启动，为其提供`NOTIFICATION_ID`和使用构建器构建的通知。该函数返回`NotificationCompat.Builder`，以便稍后用于更新通知。
- en: 'Define two fields in your service—one to hold a reusable `NotificationCompat.Builder`
    class, and another to hold a reference to `Handler`, which you will later use
    to post work in the background:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的服务中定义两个字段——一个用于保存可重用的`NotificationCompat.Builder`类，另一个用于保存对`Handler`的引用，稍后您将在后台中使用它来发布工作：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, override `onCreate()` to start the service as a foreground service, keep
    a reference to the `Notification.Builder`, and create `serviceHandler`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，重写`onCreate()`以将服务作为前台服务启动，保留对`Notification.Builder`的引用，并创建`serviceHandler`：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that to create the `Handler` instance, you must first define and start
    `HandlerThread`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，要创建`Handler`实例，必须首先定义并启动`HandlerThread`。
- en: 'Define a call that tracks your deployed SCA as it approaches its designated destination:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个跟踪已部署的SCA接近其指定目的地的调用：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will count down from `10` to `1`, sleeping for 1 second between updates
    and then updating the notification with the remaining time.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从`10`倒数到`1`，在更新之间每隔1秒休眠，然后使用剩余时间更新通知。
- en: 'Add a function to notify observers of completion on the main thread:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个函数，在主线程上通知观察者完成：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: By posting on a handler using the main `Looper`, you make sure that updates
    occur on the main (UI) app thread. When setting the value to the agent ID, you
    are notifying all observers that that agent ID has reached its destination.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在主`Looper`上使用处理程序发布，您确保更新发生在主（UI）应用程序线程上。当将值设置为代理ID时，您正在通知所有观察者该代理ID已到达目的地。
- en: 'Override `onStartCommand(Intent?, Int, Int)` like so:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像这样重写`onStartCommand(Intent?, Int, Int)`：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You first delegate the call to `super`, which internally calls `onStart()` and
    returns a backward-compatible state you could return. You store this returned
    value. Next, you obtain the SCA ID from the extras passed via the intent. This
    service would not work without an agent ID, so you throw an exception if one is
    not provided. Next, you switch to the background thread defined in `onCreate`
    to track the agent to its destination in a blocking way. When tracking is done,
    you notify observers that the task is complete, stop the foreground service (removing
    the notification by passing `true`), and stop the service itself, as you don't
    expect to require it again soon. You then return the earlier stored return value
    from `super`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先将调用委托给`super`，它在内部调用`onStart()`并返回一个向后兼容的状态，您可以返回。您存储此返回值。接下来，您从通过意图传递的额外参数中获取SCA
    ID。如果没有提供代理ID，则此服务将无法工作，因此如果没有提供代理ID，您将抛出异常。接下来，您切换到在`onCreate`中定义的后台线程，以阻塞方式跟踪代理到其目的地。跟踪完成后，您通知观察者任务已完成，停止前台服务（通过传递`true`来删除通知），并停止服务本身，因为您不希望很快再次需要它。然后，您返回之前存储的`super`的返回值。
- en: 'Update your `AndroidManifest.xml` to request the `FOREGROUND_SERVICE` permission
    and introduce the service:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您的`AndroidManifest.xml`以请求`FOREGROUND_SERVICE`权限并引入服务：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Back to your `MainActivity`. Introduce a function to launch `RouteTrackingService`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到您的`MainActivity`。引入一个函数来启动`RouteTrackingService`：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This function first observes `LiveData` for completion updates, showing a result
    on completion. Then, it defines `Intent` for launching the service, setting the
    SCA ID as an extra parameter for that `Intent`. It then launches the service as
    a foreground service using `ContextCompat`, which hides away compatibility-related
    logic for you.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先观察`LiveData`以获取完成更新，完成时显示结果。然后，它为启动服务定义`Intent`，为该`Intent`的额外参数设置SCA ID。然后，使用`ContextCompat`启动前台服务，该服务隐藏了与兼容性相关的逻辑。
- en: 'Lastly, update `onCreate()` to start tracking the SCA as soon as it is suited
    up and ready to go:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新`onCreate()`以在准备好并准备好启动时立即开始跟踪SCA：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Launch the app:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序：
- en: '![Figure 8.2: Notification counting down'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2：倒计时通知'
- en: '](img/B15216_08_02.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_08_02.jpg)'
- en: 'Figure 8.2: Notification counting down'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：倒计时通知
- en: After the notifications informing you of the SCA's preparation steps, you should
    see a notification in your status bar. That notification should then count down
    from 10 to 0, disappear, and be replaced by a toast informing you that the agent
    arrived at its destination. Seeing that last toast tells you that you managed
    to communicate the SCA ID to the service as well as getting it back on completion
    of the background task.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在通知您SCA准备步骤之后，您应该在状态栏中看到一个通知。该通知然后应该从10倒数到0，消失，并被一个toast替换，通知您代理已到达目的地。看到最后的toast告诉您，您成功将SCA
    ID传递给服务，并在后台任务完成时将其取回。
- en: With all the knowledge gained from this chapter, let's complete the following
    activity.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章获得的所有知识，让我们完成以下活动。
- en: 'Activity 8.01: Reminder to Drink Water'
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动8.01：提醒喝水
- en: The average human loses about 2,500 ml of water per day (see [https://en.wikipedia.org/wiki/Fluid_balance#Output](https://en.wikipedia.org/wiki/Fluid_balance#Output)).
    To stay healthy, we need to consume as much water as we lose. However, due to
    the busy nature of modern life, a lot of us forget to stay hydrated regularly.
    Suppose you wanted to develop an app that keeps track of your water loss (statistically)
    and gives you a constant update of your fluid balance. Starting from a balanced
    state, the app would gradually decrease the user's tracked water level. The user
    could tell the app when they drank a glass of water, and it would update the water
    level accordingly. The continuous updating of the water level will leverage your
    knowledge of running a background task, and you will also utilize your knowledge
    of communicating with a service to update a balance in response to user interaction.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 平均每天人体失去约2500毫升的水（参见[https://en.wikipedia.org/wiki/Fluid_balance#Output](https://en.wikipedia.org/wiki/Fluid_balance#Output)）。为了保持健康，我们需要摄入与失去的水量相同的水。然而，由于现代生活的繁忙性质，很多人经常忘记定期补水。假设您想开发一个应用程序，跟踪您的水分流失（统计数据），并给您不断更新的液体平衡。从平衡状态开始，该应用程序将逐渐减少用户跟踪的水位。用户可以告诉应用程序他们何时喝了一杯水，它将相应地更新水位。水位的持续更新将利用您运行后台任务的知识，并且您还将利用与服务通信的知识来响应用户交互更新平衡。
- en: 'The following steps will help you complete the activity:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此活动：
- en: Create an empty activity project and name your app `My Water Tracker`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空活动项目，并将您的应用命名为`My Water Tracker`。
- en: Add a foreground service permission to your `AndriodManifest.xml` file.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`AndriodManifest.xml`文件中添加前台服务权限。
- en: Create a new service.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的服务。
- en: Define a variable in your service to track the water level.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的服务中定义一个变量来跟踪水位。
- en: Define constants for a notification ID and for an extra intent data key.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为通知ID和额外意图数据键定义常量。
- en: Set up the creation of the notification from the service.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置从服务创建通知。
- en: Add functions to start the foreground service and to update the water level.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加函数来启动前台服务和更新水位。
- en: Set the water level to decrease every 5 seconds.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将水位设置为每5秒减少一次。
- en: Handle the addition of fluids from outside the service.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理来自服务外部的流体添加。
- en: Make sure the service cleans up callbacks and messages when destroyed.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保服务在销毁时清理回调和消息。
- en: Register the service in the `Manifest.xml` file.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Manifest.xml`文件中注册服务。
- en: Start the service from `MainActivity` when the activity is created.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`中创建活动时启动服务。
- en: Add a button to the main activity layout.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主活动布局中添加一个按钮。
- en: When the user clicks the button, notify the service that it needs to increment
    the water level.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击按钮时，通知服务需要增加水位。
- en: Note
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: http://packt.live/3sKj1cp'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下网址找到：http://packt.live/3sKj1cp
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to execute long-running background tasks using
    `WorkManager` and foreground services. We discussed how to communicate progress
    to the user, and how to get the user back into an app once a task is finished
    executing. All the topics covered in this chapter are quite broad, and you could
    explore communicating with services, building notifications, and using the `WorkManager`
    class further. Hopefully, for most common scenarios, you now have the tools you
    need. Common use cases include background downloads, the background cleaning up
    of cached assets, playing music while the app is not running in the foreground,
    and, combined with the knowledge we gained from *Chapter 7*, *Android Permissions
    and Google Maps*, tracking the user's location over time.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用`WorkManager`和前台服务执行长时间运行的后台任务。我们讨论了如何向用户传达进度，以及如何在任务执行完成后让用户重新进入应用程序。本章涵盖的所有主题都非常广泛，您可以进一步探索与服务通信、构建通知以及使用`WorkManager`类。希望对于大多数常见情况，您现在已经拥有所需的工具。常见用例包括后台下载、清理缓存资产、在应用程序不在前台运行时播放音乐，以及结合我们从*第7章*
    *Android权限和谷歌地图*中获得的知识，随时间跟踪用户的位置。
- en: In the next chapter, we will look into making our apps more robust and maintainable
    by writing unit tests and integration tests. This is particularly helpful when
    the code you write runs in the background and it is not immediately evident when
    something goes wrong.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过编写单元测试和集成测试来使我们的应用程序更加健壮和可维护。当您编写的代码在后台运行并且当出现问题时不会立即显现时，这将特别有帮助。
