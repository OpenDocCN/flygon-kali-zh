- en: '*Chapter 13*: Introduction to Unity Scripting with C#'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：使用C#介绍Unity脚本'
- en: Unity has a lot of great built-in tools to solve the most common problems in
    game development, such as the ones we have seen so far. Even two games of the
    same genre have their own little differences that make the games unique, and Unity
    cannot foresee that, so that's why we have scripting. Through coding, we can extend
    Unity's capabilities in several ways to achieve the exact behavior we need, all
    through a well-known language—C#. We will introduce how to create custom components
    using C# scripts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Unity有很多内置工具来解决游戏开发中最常见的问题，就像我们迄今所见过的那些问题。即使是同一类型的两个游戏也有各自的小差异，使得游戏独一无二，而Unity无法预见到这一点，这就是为什么我们需要脚本。通过编码，我们可以以多种方式扩展Unity的功能，以实现我们需要的确切行为，而这一切都是通过一种众所周知的语言——C#。我们将介绍如何使用C#脚本创建自定义组件。
- en: One thing I should point out here is that this chapter is mainly a recap of
    C# scripting basics for Unity, but in one of the sections, I will explain some
    advanced tips for experienced programmers. So, try to not skip this chapter if
    you have programming experience but not in Unity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我要指出的一件事是，本章主要是对Unity的C#脚本基础知识的回顾，但在其中的某一节中，我将解释一些针对有经验的程序员的高级技巧。因此，如果你有编程经验但不熟悉Unity，请尽量不要跳过本章。
- en: 'In this chapter, we will examine the following scripting concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下脚本概念：
- en: Creating C# scripts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建C#脚本
- en: Using events and instructions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件和指令
- en: We are going to create our own Unity components, learning the basic structure
    of a class and the way that we can execute actions and expose properties to be
    configured. Let's start by discussing the basics of script creation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建我们自己的Unity组件，学习类的基本结构以及我们可以执行操作和暴露属性以进行配置的方式。让我们从讨论脚本创建的基础知识开始。
- en: Creating C# scripts
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建C#脚本
- en: This book is intended for readers with some programming knowledge, but in this
    first section, we are going to discuss the C# script structure to make sure you
    have a strong foundation for the behaviors we will code in the following chapters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书面向具有一定编程知识的读者，但在本节中，我们将讨论C#脚本结构，以确保你对我们将在接下来的章节中编写的行为有坚实的基础。
- en: 'In this section, we will examine the following script creation concepts:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下脚本创建概念：
- en: Initial setup
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始设置
- en: Creating a MonoBehaviour-based class
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个基于MonoBehaviour的类
- en: Adding fields
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加字段
- en: We are going to create our first Unity script, which will serve to create our
    component, discussing the tools needed to do so and exploring how to expose our
    class fields to the editor. Let's start with the basics of script creation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建我们的第一个Unity脚本，这将用于创建我们的组件，讨论所需的工具，并探讨如何将我们的类字段暴露给编辑器。让我们从脚本创建的基础知识开始。
- en: Initial setup
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始设置
- en: One thing to consider before creating our first script is how Unity compiles
    code. While coding, we are used to having an **Integrated Development Environment**
    (**IDE**), which is a program to create our code and compile or execute it. In
    Unity, we will just use an IDE as a tool to create scripts easily with coloring
    and auto-completion because Unity doesn't have a custom code editor, and if you
    have never coded before, these are valuable tools for beginners. The scripts will
    be created inside the Unity project and Unity will detect and compile them if
    any changes are made, so you won't compile in the IDE. Don't worry—you can still
    use breakpoints in this method.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的第一个脚本之前，有一件事需要考虑，那就是Unity如何编译代码。在编码时，我们习惯于使用**集成开发环境**（**IDE**），这是一个用于创建我们的代码并编译或执行它的程序。在Unity中，我们只会将IDE作为一个工具来轻松创建带有着色和自动补全的脚本，因为Unity没有自定义的代码编辑器，如果你以前从未编写过代码，这些对初学者来说是宝贵的工具。脚本将被创建在Unity项目中，如果进行了任何更改，Unity将检测并编译它们，因此你不需要在IDE中进行编译。不用担心——你仍然可以在这种方法中使用断点。
- en: 'We can use Visual Studio, Visual Studio Code, Rider, or whatever C# IDE you''d
    like to use, but when you install Unity, you will probably see an option to install
    Visual Studio automatically, which allows you to have a default IDE. This installs
    the free version of Visual Studio, so don''t worry about the licenses here. If
    you don''t have an IDE on your computer and didn''t check the Visual Studio option
    while installing Unity, you can do the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Visual Studio、Visual Studio Code、Rider或者你喜欢使用的任何C# IDE，但当你安装Unity时，你可能会看到一个选项自动安装Visual
    Studio，这样你就可以拥有一个默认的IDE。这将安装Visual Studio的免费版本，所以不用担心许可证问题。如果你的电脑上没有IDE，并且在安装Unity时没有勾选Visual
    Studio选项，你可以这样做：
- en: Open **Unity Hub**.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**Unity Hub**。
- en: Go to the **Installs** section.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**安装**部分。
- en: Click on the three dots in the top-right area of the Unity version you are using
    and click on **Add Modules**:![Figure 13.1 – Adding a module to the Unity installation
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Unity版本右上角的三个点，然后点击**添加模块**：![图13.1 – 将模块添加到Unity安装中
- en: '](img/Figure_13.01_B14199.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.01_B14199.jpg)'
- en: Figure 13.1 – Adding a module to the Unity installation
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – 将模块添加到Unity安装中
- en: Check the option that says **Visual Studio**; the description of the option
    will vary depending on the version of Unity you are using.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**Visual Studio**选项；选项的描述将根据你使用的Unity版本而有所不同。
- en: Hit the **NEXT** button at the bottom right:![Figure 13.2 – Installing Visual
    Studio
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右下角的**下一步**按钮：![图13.2 – 安装Visual Studio
- en: '](img/Figure_13.02_B14199.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.02_B14199.jpg)'
- en: Figure 13.2 – Installing Visual Studio
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 安装Visual Studio
- en: Wait for the operation to end. This might take a few minutes.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待操作结束。这可能需要几分钟的时间。
- en: 'If you have a preferred IDE, you can install it yourself and configure Unity
    to use it. If you can afford it or you are a teacher or a student (as it is free
    in these cases), I recommend Rider. It is a great IDE with lots of C# and Unity
    features that you will love; however, it is not vital for this exercise. In order
    to set up Unity to use a custom IDE, do the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有自己喜欢的IDE，你可以自行安装并配置Unity来使用它。如果你有能力支付或者你是一名教师或学生（在这些情况下是免费的），我推荐Rider。它是一个功能强大的IDE，拥有许多你会喜欢的C#和Unity功能；然而，对于这个练习来说并不是必不可少的。为了设置Unity使用自定义IDE，你可以这样做：
- en: Open the project.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目。
- en: Go to **Edit** | **Preferences** in the top menu of the editor.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到编辑器的顶部菜单中的**编辑** | **首选项**。
- en: Select the **External Tools** menu from the left panel.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧面板中选择**外部工具**菜单。
- en: From the external script editor, select your preferred IDE; Unity will automatically
    detect the supported IDEs:![Figure 13.3 – Selecting a custom IDE
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从外部脚本编辑器中选择您喜欢的IDE；Unity将自动检测到支持的IDE：![图13.3 – 选择自定义IDE
- en: '](img/Figure_13.03_B14199.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.03_B14199.jpg)'
- en: Figure 13.3 – Selecting a custom IDE
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 选择自定义IDE
- en: If you don't find your IDE in the list, you can use the **Browse…** option,
    but usually, IDEs that require you to use this option are not very well supported—but
    it's worth a shot.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在列表中找不到您的IDE，可以使用**浏览...**选项，但通常需要使用此选项的IDE支持不是很好——但值得一试。
- en: 'Finally, some IDEs, such as Visual Studio, Visual Studio Code, and Rider, have
    Unity integration tools that you need to install in your project, which are optional
    but can be useful. Usually, Unity installs these automatically, but if you want
    to be sure that they are installed, do the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些IDE，如Visual Studio、Visual Studio Code和Rider，具有Unity集成工具，您需要在项目中安装这些工具，这是可选的，但可能很有用。通常，Unity会自动安装这些工具，但如果您想确保它们已安装，请执行以下操作：
- en: Open **Package Manager** (**Window** | **Package Manager**).
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**包管理器**（**窗口** | **包管理器**）。
- en: Search the list for your IDE or filter the list by using the search bar. In
    my case, I used Rider, and I can find a package called **JetBrains Rider Editor**:![Figure
    13.4 – Custom IDE editor extension installation—in this case, the Rider one
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索列表中的您的IDE，或者使用搜索栏过滤列表。在我的情况下，我使用了Rider，并且我可以找到一个名为**JetBrains Rider Editor**的包：![图13.4
    – 自定义IDE编辑器扩展安装——在这种情况下是Rider
- en: '](img/Figure_13.04_B14199.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.04_B14199.jpg)'
- en: Figure 13.4 – Custom IDE editor extension installation—in this case, the Rider
    one
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 自定义IDE编辑器扩展安装——在这种情况下是Rider
- en: Check whether your IDE integration package is installed by looking at the buttons
    in the bottom-right part of the package manager. If you see an **Install** or
    **Update** button, click on it, but if it says **Installed**, everything is set
    up.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过查看包管理器底部右侧的按钮来检查是否安装了IDE集成包。如果看到**安装**或**更新**按钮，请单击它，但如果显示**已安装**，则一切都设置好了。
- en: Now that we have an IDE configured, let's create our first script.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了IDE，让我们创建我们的第一个脚本。
- en: Creating a MonoBehaviour-based class
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基于MonoBehaviour的类
- en: C# is a heavily object-oriented language, and this is no different in Unity.
    Any time we want to extend Unity, we need to create our own class—a script with
    the instructions we want to add to Unity. If we want to create custom components,
    we need to create a class that inherits from `MonoBehaviour`, the base class of
    every custom component.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: C#是一种面向对象的语言，在Unity中也是如此。每当我们想要扩展Unity时，我们都需要创建自己的类——一个包含我们想要添加到Unity的指令的脚本。如果我们想要创建自定义组件，我们需要创建一个从`MonoBehaviour`继承的类，这是每个自定义组件的基类。
- en: 'We can create C# script files directly within the Unity project using the editor,
    and you can arrange them in folders right next to other assets folders. The easiest
    way to create a script is by doing the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接在Unity项目中使用编辑器创建C#脚本文件，并且可以将它们排列在其他资产文件夹旁边的文件夹中。创建脚本的最简单方法是按照以下步骤进行：
- en: Select any game object that you want to have the component we are going to create.
    As we are just testing this out, select any object.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择要创建组件的任何游戏对象。由于我们只是在测试这个功能，所以选择任何对象。
- en: Click on the **Add Component** button at the bottom of the Inspector and look
    for the **New script** option at the bottom of the list, displayed after clicking
    on **Add Component**:![Figure 13.5 – The New script option
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击检查器底部的**添加组件**按钮，并查找**新脚本**选项，该选项显示在单击**添加组件**后的列表底部：![图13.5 – 新脚本选项
- en: '](img/Figure_13.05_B14199.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.05_B14199.jpg)'
- en: Figure 13.5 – The New script option
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 – 新脚本选项
- en: In the `MyFirstScript`, but for the scripts that you will use for your game,
    try to enter descriptive names, regardless of the length:![Figure 13.6 – Naming
    the script
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MyFirstScript`中，但是对于您将用于游戏的脚本，请尝试输入描述性名称，而不管长度如何：![图13.6 – 命名脚本
- en: '](img/Figure_13.06_B14199.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.06_B14199.jpg)'
- en: Figure 13.6 – Naming the script
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 – 命名脚本
- en: 'Important note:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: It is recommended that you use Pascal case for script naming. In Pascal case,
    a script for the player's shooting functionality would be called `PlayerShoot`.
    The first letter of each word of the name is in uppercase and you can't use spaces.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您使用帕斯卡命名法来命名脚本。在帕斯卡命名法中，玩家射击功能的脚本将被称为`PlayerShoot`。名称的每个单词的第一个字母都是大写的，而且不能使用空格。
- en: You can see how a new asset, called as the script was, is created in Project
    View. Remember that each component has its own asset, and I suggest you each component
    to a `Scripts` folder:![Figure 13.7 – Script asset
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以看到在项目视图中创建了一个名为脚本的新资产。请记住，每个组件都有自己的资产，我建议您将每个组件放在`Scripts`文件夹中：![图13.7 –
    脚本资产
- en: '](img/Figure_13.07_B14199.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.07_B14199.jpg)'
- en: Figure 13.7 – Script asset
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 – 脚本资产
- en: 'Now, you will also see that your Game Object has a new component in the Inspector
    window, which is named the same as your script. So, you have now created your
    first component class:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您还会看到您的游戏对象在检查器窗口中有一个新的组件，该组件的名称与您的脚本相同。因此，您现在已经创建了您的第一个组件类：
- en: '![Figure 13.8 – Our script added to a game object'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.8 – 我们的脚本添加到游戏对象'
- en: '](img/Figure_13.08_B14199.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.08_B14199.jpg)'
- en: Figure 13.8 – Our script added to a game object
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8 – 我们的脚本添加到游戏对象
- en: 'Now that we have created a `component` class, remember that a class is not
    the component itself. It is a description of what the component should be—a blueprint
    of how a component should work. To actually use the component, we need to instantiate
    it by creating a component based on the class. Each time we add a component to
    an object using the editor, we are instantiating it. Generally, we don''t instantiate
    using new, but by using the editor or specialized functions. Now, you can add
    your component as you would any other component by using the **Add Component**
    button in the Inspector window and looking for it in the **Scripts** category
    or searching it by name:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个`component`类，请记住类不是组件本身。它是组件应该是什么的描述 - 组件应该如何工作的蓝图。要实际使用组件，我们需要通过创建基于该类的组件来实例化它。每次我们使用编辑器向对象添加组件时，我们都在实例化它。通常，我们不使用new来实例化，而是使用编辑器或专门的函数。现在，您可以像使用**Add
    Component**按钮一样添加您的组件到任何其他组件中，并在检视器窗口中的**Scripts**类别中查找它或通过名称搜索它：
- en: '![Figure 13.9 – Adding a custom component in the Scripts category'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.9 - 在Scripts类别中添加自定义组件'
- en: '](img/Figure_13.09_B14199.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.09_B14199.jpg)'
- en: Figure 13.9 – Adding a custom component in the Scripts category
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 - 在Scripts类别中添加自定义组件
- en: Something that you need to consider here is that we can add the same component
    to several game objects. We don't need to create a class for each game object
    that uses the component. I know this is basic programmers' knowledge, but remember
    that we are trying to recap the basics here. In the next chapter, we will look
    at more interesting topics.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要考虑的一点是，我们可以将相同的组件添加到多个游戏对象中。我们不需要为每个使用该组件的游戏对象创建一个类。我知道这是基本的程序员知识，但请记住我们正在尝试回顾基础知识。在下一章中，我们将研究更有趣的主题。
- en: 'Now that we have our component, let''s explore how it looks and carry out a
    class structure recap by doing the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的组件，让我们探索它的外观，并通过以下方式进行类结构回顾：
- en: Locate the script asset in Project View and double-click on it. Remember that
    it should be located in the `Scripts` folder you created previously.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Project View中找到脚本资源并双击打开。记住它应该位于您之前创建的“Scripts”文件夹中。
- en: Wait for the IDE to open; this can take a while. You will know that the IDE
    has finished the initialization when you see your script code and its keywords
    properly colored, which varies according to the desired IDE. In Rider, it looks
    as in the following screenshot. In my case, I knew that Rider had finished initializing
    because the MonoBehaviour type and the script name are colored the same:![Figure
    13.10 – A new script opened in the Rider IDE
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待IDE打开；这可能需要一段时间。当您看到您的脚本代码及其关键字正确着色时，您将知道IDE已完成初始化，这取决于所需的IDE。在Rider中，它看起来如下截图。在我的情况下，我知道Rider已经完成初始化，因为MonoBehaviour类型和脚本名称都着色相同：![图13.10
    - 在Rider IDE中打开的新脚本
- en: '](img/Figure_13.10_B14199.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.10_B14199.jpg)'
- en: Figure 13.10 – A new script opened in the Rider IDE
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10 - 在Rider IDE中打开的新脚本
- en: The first three lines—the ones that start with the `using` keyword—include common
    namespaces. Namespaces are like code containers, which is, in this case, code
    created by others (such as Unity, C# creators, and so on). We will be using namespaces
    quite often to simplify our tasks; they already contain solved algorithms that
    we will use. We will be adding and removing the `using` component as we need;
    in my case, Rider is suggesting that the first two `using` components are not
    necessary because I am not using any code inside them, and so they are grayed
    out. But for now, keep them as you will use them in later chapters of this book.
    Remember, they should always be at the beginning of the class:![Figure 13.11 –
    The using sections
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前三行 - 以`using`关键字开头的行 - 包括常见的命名空间。命名空间就像代码容器，也就是在这种情况下，由他人创建的代码（如Unity，C#创建者等）。我们将经常使用命名空间来简化我们的任务；它们已经包含了我们将使用的解决算法。我们将根据需要添加和删除`using`组件；在我的情况下，Rider建议前两个`using`组件是不必要的，因为我没有在其中使用任何代码，所以它们是灰色的。但是现在，保留它们，因为您将在本书的后面章节中使用它们。记住，它们应该始终位于类的开头：![图13.11
    - using部分
- en: '](img/Figure_13.11_B14199.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.11_B14199.jpg)'
- en: Figure 13.11 – The using sections
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11 - using部分
- en: 'The next line, the one that starts with `public class`, is where we declare
    that we are creating a new class that inherits from `MonoBehaviour`, the base
    class of every custom component. We know this because it ends with `: MonoBehaviour`.
    You can see how the rest of the code is located inside brackets right below that
    line, meaning that the code inside them belongs to the component:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一行，以`public class`开头的行，是我们声明正在创建一个继承自`MonoBehaviour`的新类的地方，这是每个自定义组件的基类。我们知道这是因为它以`：MonoBehaviour`结尾。您可以看到代码的其余部分位于该行的下方括号内，这意味着括号内的代码属于该组件：
- en: '![Figure 13.12 – The MyFirstScript class definition inherits from MonoBehaviour'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.12 - MyFirstScript类定义继承自MonoBehaviour'
- en: '](img/Figure_13.12_B14199.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.12_B14199.jpg)'
- en: Figure 13.12 – The MyFirstScript class definition inherits from MonoBehaviour
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12 - MyFirstScript类定义继承自MonoBehaviour
- en: Now that we have our first component, let's edit it, starting with the fields.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了第一个组件，让我们编辑它，从字段开始。
- en: Adding fields
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加字段
- en: When we added components as `Rigidbody` or as different kinds of colliders,
    adding the components wasn't enough. We needed to properly configure them to achieve
    the exact behavior that we need. For example, `Rigidbody` has the `Mass` property
    to control the object's weight, and the colliders have the `Size` property to
    control their shape. This way, we can reuse the same component for different scenarios,
    preventing the duplication of similar components. With a `Box` collider, we can
    represent a square or rectangular box just by changing the size properties. Our
    components are no exception; if we have a component that moves an object and if
    we want two objects to move at different speeds, we can use the same component
    with different configurations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加`Rigidbody`或不同类型的碰撞体作为组件时，仅仅添加组件是不够的。我们需要正确配置它们以实现我们需要的确切行为。例如，`Rigidbody`有`Mass`属性来控制物体的重量，碰撞体有`Size`属性来控制它们的形状。这样，我们可以在不同的场景中重复使用相同的组件，避免重复相似组件。使用`Box`碰撞体，我们可以通过更改大小属性来表示正方形或矩形框。我们的组件也不例外；如果我们有一个移动物体的组件，并且我们希望两个物体以不同的速度移动，我们可以使用相同的组件进行不同的配置。
- en: Each configuration is a class field, a specific type variable where we can hold
    the parameter's value. We can create class fields that can be edited in the editor
    in two ways—by marking the field as `public`, but breaking the encapsulation principle,
    or by making a private field and exposing it with an attribute. Now, we are going
    to cover both methods, but if you are not familiar with **Object-Oriented Programming**
    (**OOP**) concepts, such as encapsulation, I recommend you use the first method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个配置都是一个类字段，一个特定类型的变量，我们可以在其中保存参数的值。我们可以创建可以在编辑器中编辑的类字段的两种方式——通过将字段标记为`public`，但违反封装原则，或者通过创建一个私有字段并使用属性公开它。现在，我们将涵盖这两种方法，但如果您不熟悉面向对象编程（OOP）概念，比如封装，我建议您使用第一种方法。
- en: 'Suppose we are creating a movement script. We will add an editable number field
    representing the velocity using the first method—that is, by adding the `public`
    field. We will do this by following these steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在创建一个移动脚本。我们将使用第一种方法添加一个可编辑的数字字段，表示速度，即通过添加`public`字段。我们将按照以下步骤进行操作：
- en: Open the script by double-clicking it as we did before.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击打开脚本，就像之前一样。
- en: Inside the class brackets, but outside any brackets within them, add the following
    code:![Figure 13.13 – Creating a speed field in our component
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类括号内，但在其中的任何括号之外，添加以下代码：![图13.13 - 在我们的组件中创建一个速度字段
- en: '](img/Figure_13.13_B14199.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.13_B14199.jpg)'
- en: Figure 13.13 – Creating a speed field in our component
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.13 - 在我们的组件中创建一个速度字段
- en: 'Important note:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: The `public` keyword specifies that the variable can be seen and edited beyond
    the scope of the class. The `float` part of the code says that the variable is
    using the decimal number type, and `speed` is the name we chose for our field—this
    can be whatever you want. You can use other value types to represent other kinds
    of data, such as `bool` to represent checkboxes or Booleans and `string` to represent
    text.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`关键字指定变量可以在类的范围之外被看到和编辑。代码中的`float`部分表示变量使用十进制数类型，`speed`是我们为字段选择的名称——这可以是任何您想要的。您可以使用其他值类型来表示其他类型的数据，比如`bool`表示复选框或布尔值，`string`表示文本。'
- en: To apply the changes, just save the file in the IDE (usually by pressing *Ctrl*
    + *S* or *command* + *S*) and return again to Unity. When you do this, you will
    notice a little loading wheel at the bottom-right part of the editor, indicating
    that Unity is compiling the code. You can't test the changes until the wheel finishes.
    Remember that Unity will compile the code; don't compile it in the IDE:![Figure
    13.14 – The loading wheel
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要应用更改，只需在IDE中保存文件（通常通过按下*Ctrl* + *S*或*command* + *S*），然后再返回Unity。当您这样做时，您会注意到编辑器底部右侧有一个小加载轮，表示Unity正在编译代码。直到加载轮完成，您才能测试更改。请记住，Unity将编译代码；不要在IDE中编译：![图13.14
    - 加载轮
- en: '](img/Figure_13.14_B14199.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.14_B14199.jpg)'
- en: Figure 13.14 – The loading wheel
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14 - 加载轮
- en: After the compilation is finished, you can see your component in the Inspector
    window and the **Speed** variable should be there, allowing you to set the speed
    you want. Of course, right now, the variables do nothing. Unity doesn't recognize
    your intention by the name of the variable; we need to set it for use in some
    way, but we will do that later:![Figure 13.15 – A public field to edit data that
    the component will use later
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译完成后，您可以在检视器窗口中看到您的组件，**Speed**变量应该在那里，允许您设置您想要的速度。当然，现在这些变量什么都不做。Unity不会根据变量的名称识别您的意图；我们需要以某种方式设置它以供后续使用，但我们稍后会这样做：![图13.15
    - 一个用于编辑组件稍后将使用的公共字段
- en: '](img/Figure_13.15_B14199.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.15_B14199.jpg)'
- en: Figure 13.15 – A public field to edit data that the component will use later
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.15 - 一个用于编辑组件稍后将使用的公共字段
- en: Try adding the same component to other objects and set a different speed. This
    will show you how components in different game objects are independent, allowing
    you to change some of their behaviors via different settings.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将相同的组件添加到其他对象，并设置不同的速度。这将向您展示不同游戏对象中的组件是独立的，允许您通过不同的设置更改它们的一些行为。
- en: 'The second way to define properties is similar, but instead of creating a `public`
    field, we create a `private` field, encouraging encapsulation and exposing it
    using the `SerializeField` attribute, as shown in the following screenshots. These
    screenshots show two ways of doing this—both will produce the same results; the
    only difference is the styling. Use the one that best fits your coding standards:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 定义属性的第二种方法类似，但是我们创建一个私有字段，鼓励封装，并使用`SerializeField`属性公开它，如下面的屏幕截图所示。这些屏幕截图展示了两种方法——两种方法都会产生相同的结果；唯一的区别是样式。使用最符合您编码标准的方法：
- en: '![Figure 13.16 – Two ways to expose private attributes in the Inspector window'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.16 - 在检视器窗口中公开私有属性的两种方法'
- en: '](img/Figure_13.16_B14199.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.16_B14199.jpg)'
- en: Figure 13.16 – Two ways to expose private attributes in the Inspector window
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.16 - 在检视器窗口中公开私有属性的两种方法
- en: If you are not familiar with the OOP concept of encapsulation, just use the
    first method, which is more flexible for beginners. If you create a `private`
    field, it won't be accessible to other scripts because the `SerializeField` attribute
    only exposes the variable to the editor. Remember that Unity won't allow you to
    use constructors, so the only way to set initial data and inject dependencies
    is via serialized private fields or public fields and setting them in the editor
    (or using a dependency injection framework, but that is beyond the scope of this
    book). For simplicity, we will use the first method in most of the exercises in
    this book.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉面向对象编程的封装概念，只需使用第一种方法，对初学者来说更灵活。如果你创建了一个`private`字段，它将不可被其他脚本访问，因为`SerializeField`属性只会将变量暴露给编辑器。记住，Unity不允许你使用构造函数，所以设置初始数据和注入依赖的唯一方法是通过序列化的私有字段或公共字段，并在编辑器中设置它们（或使用依赖注入框架，但这超出了本书的范围）。为简单起见，我们将在本书的大部分练习中使用第一种方法。
- en: If you want, try to create other types of variables and see how they look in
    the inspector. Try replacing `float` with `bool` or `string`, as previously suggested.
    Now that we know how to configure our components through data, let's use that
    data to create some behaviour.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，尝试创建其他类型的变量，并查看它们在检视器中的样子。尝试用`bool`或`string`替换`float`，就像之前建议的那样。现在我们知道如何通过数据配置我们的组件，让我们使用这些数据来创建一些行为。
- en: Using events and instructions
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件和指令
- en: Now that we have a script, we are ready to do something with it. We won't implement
    anything useful in this chapter, but we will settle the concepts to add some types
    of behavior for the scripts we are going to create in the next chapters.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个脚本，我们准备对其进行一些操作。在本章中，我们不会实现任何有用的东西，但我们会解决一些概念，以便在接下来的章节中为我们即将创建的脚本添加一些类型的行为。
- en: 'In this section, we are going to cover the following concepts:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖以下概念：
- en: Events and instructions
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件和指令
- en: Using fields in instructions
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在指令中使用字段
- en: Common beginner errors
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的初学者错误
- en: We are going to explore the Unity event system, which will allow us to respond
    to these situations by executing Unity functions. These functions will also be
    affected by the value of the editor, and fields exposed to our script will be
    configurable. Finally, we are going to discuss common scripting errors and how
    to solve them. Let's start by introducing the concept of Unity events.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索Unity事件系统，它将允许我们通过执行Unity函数来响应这些情况。这些函数也会受到编辑器的值的影响，我们脚本中暴露的字段将是可配置的。最后，我们将讨论常见的脚本错误以及如何解决它们。让我们先介绍Unity事件的概念。
- en: Events and instructions
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件和指令
- en: Unity allows us to create behavior in a cause-effect fashion, which is usually
    called an event system. An event is a situation that Unity is monitoring—for example,
    when two objects collide or are destroyed, Unity tells us about this situation,
    allowing us to react according to our needs. As an example, we can reduce the
    life of a player when it collides with a bullet. Here, we will explore how to
    listen to these events and test them by using some simple actions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Unity允许我们以因果关系的方式创建行为，通常称为事件系统。事件是Unity正在监视的情况，例如，当两个对象发生碰撞或被销毁时，Unity会告诉我们这种情况，从而允许我们根据我们的需求做出反应。例如，当玩家与子弹发生碰撞时，我们可以减少玩家的生命。在这里，我们将探索如何监听这些事件并通过使用一些简单的操作来测试它们。
- en: If you are used to event systems, you will know that they usually require us
    to subscribe to some kind of listener or delegate, but in Unity, there is a simpler
    method available. We just need to write the exact function for the event we are
    looking for exactly—and I mean *exactly*. If a letter of the name doesn't have
    the correct casing, it won't execute and no warning will be raised. This is the
    most common beginner's error that is made, so pay attention.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于事件系统，你会知道它们通常要求我们订阅某种监听器或委托，但在Unity中，有一种更简单的方法可用。我们只需要为我们正在寻找的事件编写确切的函数——我是说*确切的*。如果名称中的一个字母大小写不正确，它将不会执行，也不会引发任何警告。这是最常见的初学者错误，所以要注意。
- en: There are lots of events or messages to listen to in Unity, so let's start with
    the most common one—`Update`. This event will tell you when Unity wants you to
    update your object, depending on the purpose of your behavior; some don't need
    them. The `Update` logic is usually something that needs to be executed constantly;
    to be more precise, in every frame. Remember that every game is like a movie—a
    sequence of images that your screen switches through fast enough to look like
    we have continuous motion. A common action to do in the `Update` event is to move
    objects a little bit, and by doing this, every frame will make your object constantly
    move.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中有很多事件或消息可以监听，所以让我们从最常见的一个开始——`Update`。这个事件会告诉你当Unity希望你更新你的对象时，根据你的行为目的而定；有些行为不需要它们。`Update`逻辑通常是需要不断执行的东西；更准确地说，是在每一帧中。记住，每个游戏就像一部电影——屏幕快速切换的一系列图像，看起来就像我们有连续的运动。在`Update`事件中常见的操作是让对象移动一点，通过这样做，每一帧都会让你的对象不断移动。
- en: 'We will learn about the sorts of things we can do with `Update` and other events
    or messages later. Now, let''s focus on how to make our component at least listen
    to this event. Actually, the base component already comes with two event functions
    that are ready to use, one being `Update` and the other one being in the script.
    If you are not familiar with the concept of functions in C#, we are referring
    to the snippet of code in the following screenshot, which is already included
    in our script. Try to find it in yours:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以后学习关于`Update`和其他事件或消息可以做的事情。现在，让我们专注于如何使我们的组件至少监听这个事件。实际上，基本组件已经带有两个准备好使用的事件函数，一个是`Update`，另一个在脚本中。如果你不熟悉C#中函数的概念，我们指的是下面截图中已经包含在我们脚本中的代码片段。试着在你的脚本中找到它。
- en: '![Figure 13.17 – A function called Update, which will be executed with every
    frame'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.17 - 一个名为Update的函数，将在每一帧中执行'
- en: '](img/Figure_13.17_B14199.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.17_B14199.jpg)'
- en: Figure 13.17 – A function called Update, which will be executed with every frame
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.17 - 一个名为Update的函数，将在每一帧中执行
- en: You will notice a (usually) green line of text (depending on the IDE) above
    the `void Update()`line—this is called a comment. These are basically ignored
    by Unity. They are just notes that you can leave to yourself and must always begin
    with `//` to prevent Unity from trying to execute them and failing. We will use
    this to temporarily disable lines of code later.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到`void Update()`行上方通常有一行绿色的文本（取决于IDE）-这称为注释。这些基本上被Unity忽略。它们只是您可以留给自己的注释，必须始终以`//`开头，以防止Unity尝试执行它们并失败。我们将在以后使用这个来临时禁用代码行。
- en: Now, to test whether this actually works, let's add an instruction to be executed
    all the time. There's no better test function than `print`. This is a simple instruction
    that tells Unity to print a message to the console, where all kinds of messages
    can be seen by the developers to check whether everything is properly working.
    The user will never see these messages. They are similar to the classic log files
    that developers sometimes ask you for when something goes wrong in the game and
    you are reporting an issue.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试这是否真的有效，让我们添加一个将一直执行的指令。没有比`print`更好的测试函数了。这是一个简单的指令，告诉Unity在控制台中打印一条消息，开发人员可以在其中看到各种消息，以检查一切是否正常工作。用户永远不会看到这些消息。它们类似于经典的日志文件，有时当游戏出现问题并且您正在报告问题时，开发人员会要求您提供这些日志文件。
- en: 'In order to test events using functions, do the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用函数测试事件，请执行以下操作：
- en: Open the script by double-clicking on it.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过双击打开脚本。
- en: To test, add `print("test");` within the event function. In the following screenshot,
    you can see an example of how to do that in the `Update` event. Remember to write
    the instruction *exactly*, including the correct casing, spaces, and quotes symbols:![Figure
    13.18 – Printing a message in all the frames
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试，添加`print("test");`到事件函数中。在下面的屏幕截图中，您可以看到如何在`Update`事件中执行此操作的示例。记得*精确*写出指令，包括正确的大小写，空格和引号符号：![图13.18
    - 在所有帧中打印消息
- en: '](img/Figure_13.18_B14199.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.18_B14199.jpg)'
- en: Figure 13.18 – Printing a message in all the frames
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.18 - 在所有帧中打印消息
- en: Save the file, go to Unity, and play the game.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，转到Unity，并播放游戏。
- en: 'Important note:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Remember to save the file before switching back to Unity from the IDE. This
    is the only way that Unity knows your file has changed. Some IDEs, such as Rider,
    save the file automatically for you, but I don't recommend you use auto-save,
    at least in big projects (you don't want accidental recompilations of unfinished
    work; that takes too long in projects with lots of scripts).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在从IDE切换回Unity之前记得保存文件。这是Unity知道您的文件已更改的唯一方式。一些IDE，如Rider，会自动为您保存文件，但我不建议您使用自动保存，至少在大型项目中不要这样做（您不希望在有很多脚本的项目中意外重新编译未完成的工作；这需要太长时间）。
- en: Look for the **Console** tab and select it. This is usually found next to the
    **Project View** tab. If you can't find it, go to **Window** | **General** | **Console**,
    or press *Ctrl* + *Shift* + *C* (*command* + *shift* + *C* on macOS).
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找**控制台**选项卡并选择它。这通常可以在**项目视图**选项卡旁边找到。如果找不到，请转到**窗口** | **常规** | **控制台**，或按下*Ctrl*
    + *Shift* + *C*（macOS上为*command* + *shift* + *C*）。
- en: You will see lots of messages saying `"test"` being printed in every frame of
    the **Console** tab. If you don't see this, remember to save the script file before
    playing the game.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会看到在**控制台**选项卡的每一帧中都打印出`“test”`的许多消息。如果您没有看到这个，请记得在播放游戏之前保存脚本文件。
- en: 'Let''s also test the `Start` function. Add `print("test Start");` to it, save
    the file, and play the game. The full script should look as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也测试`Start`函数。在其中添加`print("test Start");`，保存文件，并播放游戏。完整的脚本应如下所示：
- en: '![Figure 13.19 – The script that tests the Start and Update functions'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.19 - 测试开始和更新函数的脚本'
- en: '](img/Figure_13.19_B14199.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.19_B14199.jpg)'
- en: Figure 13.19 – The script that tests the Start and Update functions
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.19 - 测试开始和更新函数的脚本
- en: If you check the console now and scroll all the way up, you will see a single
    `"test Start"` message and lots of `"test"` messages following it. As you can
    guess, the `Start` event tells you that the game has started and allows you to
    execute the code that needs to happen just once at the beginning of the game.
    We will use this later in this book.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在检查控制台并向上滚动，您会看到一个单独的`“test Start”`消息和许多随后的`“test”`消息。您可以猜到，`Start`事件告诉您游戏已经开始，并允许您执行需要在游戏开始时仅执行一次的代码。我们将在本书的后面使用这个。
- en: For the `void Update()` syntax, we will say to Unity that whatever is contained
    in the brackets below this line is a function that will be executed in all the
    frames. It is important to put the print instruction *inside* the `Update` brackets
    (the ones inside the brackets of the class). Also, the `print` function expects
    to receive text inside its parentheses, called an argument or parameter, and text
    in C# must be enclosed by quotation marks. Finally, all instructions inside functions
    such as `Update` or `Start` *must* end with a semicolon.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`void Update()`语法，我们将告诉Unity，该行下方括号中包含的内容是一个将在所有帧中执行的函数。重要的是将打印指令放在`Update`括号内（类的括号内）。此外，`print`函数期望在其括号内接收文本，称为参数或参数，并且C#中的文本必须用引号括起来。最后，`Update`或`Start`等函数内的所有指令*必须*以分号结束。
- en: Here, I challenge you to try to add another event called `OnDestroy` using a
    `print function` to discover when it executes. A small suggestion is to play and
    stop the game and look at the bottom of the console to test this one.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我挑战你尝试添加另一个名为`OnDestroy`的事件，使用`print函数`来发现它何时执行。一个小建议是播放并停止游戏，然后查看控制台底部以测试这个。
- en: 'For advanced users, you can also use breakpoints if your IDE allows you to
    do that. Breakpoints allow you to freeze Unity completely before executing a specific
    code line to see how our field''s data changes over time and to detect errors.
    Here, I will show you the steps to use breakpoints in Rider, but the Visual Studio
    version should be similar:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级用户，如果您的IDE允许，您还可以使用断点。断点允许您在执行特定代码行之前完全冻结Unity，以查看我们的字段数据随时间如何变化并检测错误。在这里，我将向您展示在Rider中使用断点的步骤，但Visual
    Studio版本应该类似：
- en: Click on the vertical bar at the left of the line where you want to add the
    breakpoint:![Figure 13.20 – A breakpoint in the print instruction
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击要添加断点的行左侧的垂直条：![图13.20 - 打印指令中的断点
- en: '](img/Figure_13.20_B14199.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.20_B14199.jpg)'
- en: Figure 13.20 – A breakpoint in the print instruction
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.20 - 打印指令中的断点
- en: Go to **Run** | **Attach to Unity Process** (in Visual Studio, go to **Debug**
    | **Attack Unity Debugger**. Remember that you need the Visual Studio Unity plugin
    and the Visual Studio integration package of **Package Manager**):![Figure 13.21
    – Attacking our IDE with a Unity process
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**运行** | **附加到Unity进程**（在Visual Studio中，转到**调试** | **附加Unity调试器**。请记住，您需要Visual
    Studio Unity插件和**包管理器**的Visual Studio集成包）：![图13.21 - 攻击我们的IDE与Unity进程
- en: '](img/Figure_13.21_B14199.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.21_B14199.jpg)'
- en: Figure 13.21 – Attacking our IDE with a Unity process
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.21 - 攻击我们的IDE与Unity进程
- en: From the list, look for the specific Unity instance you want to test. The list
    will show other opened editors or executing debugging builds.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中查找您想要测试的特定Unity实例。列表将显示其他已打开的编辑器或正在执行调试构建。
- en: Stopping the debugging process won't close Unity. It will just detach the IDE
    from the editor.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 停止调试过程不会关闭Unity。它只会将IDE与编辑器分离。
- en: Now that we created both fields and instructions, let's combine them to make
    configurable components.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了字段和指令，让我们将它们结合起来制作可配置的组件。
- en: Using fields in instructions
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在指令中使用字段
- en: We have created fields to configure our components' behavior, but we have not
    used them so far. We will create meaningful components in the next chapter, but
    one thing we will often need is to use the fields we have created to change the
    behavior of the object. So far, we have no real use of the `speed` field that
    we created. However, following the idea of testing whether our code is working
    (also known as debugging), we can learn how to use the data inside a field with
    a function to test whether the value is the expected one, changing the output
    of `print` in the console according to the field's value.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了字段来配置组件的行为，但到目前为止我们还没有使用它们。我们将在下一章中创建有意义的组件，但我们经常需要做的一件事是使用我们创建的字段来改变对象的行为。到目前为止，我们还没有真正使用我们创建的`speed`字段。然而，遵循测试代码是否工作的想法（也称为调试），我们可以学习如何使用字段内的数据与函数一起测试值是否符合预期，并根据字段的值改变控制台中`print`的输出。
- en: 'In our current script, our `speed` value doesn''t change during runtime. However,
    as an example, if you are creating a life system with shield damage absorption
    and you want to test whether the reduced damage calculation is working properly,
    you might want to print the calculation values to the console and check whether
    they are correct. The idea here is to replace the fixed message inside the `print`
    functions with a field. When you do that, `print` will show the field''s value
    in the console. So, if you set a value of `5` in `speed` and you print it, you
    will see lots of messages saying `5` in the console, and the output of the `print`
    function is governed by the field. To test this, your `print` message within the
    `Update` function should look as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的脚本中，我们的`speed`值在运行时不会改变。然而，举个例子，如果您正在创建一个具有护盾伤害吸收的生命系统，并且您想要测试减少的伤害计算是否正常工作，您可能希望将计算值打印到控制台并检查它们是否正确。这里的想法是用字段替换`print`函数内的固定消息。当您这样做时，`print`将在控制台中显示字段的值。因此，如果您在`speed`中设置了`5`的值并将其打印出来，您将在控制台中看到大量显示`5`的消息，并且`print`函数的输出由字段控制。为了测试这一点，您`Update`函数中的`print`消息应该如下所示：
- en: '![Figure 13.22 – Using a field as a print function parameter'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.22 - 使用字段作为打印函数参数'
- en: '](img/Figure_13.22_B14199.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.22_B14199.jpg)'
- en: Figure 13.22 – Using a field as a print function parameter
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.22 - 使用字段作为打印函数参数
- en: 'As you can see, we just put the name of the field without quotation marks.
    If you use quotation marks, you will print a `"speed"` message. In other scenarios,
    you can use this `speed` value within some moving functions to control how fast
    the movement will be, or you can perhaps create a field called `"fireRate"` (fields
    use camel case instead of Pascal, with the first letter being in lowercase) to
    control the cooldown time between one bullet and the next:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只是将字段的名称放在引号中。如果您使用引号，将打印一个`"speed"`消息。在其他情况下，您可以在一些移动函数中使用`speed`值来控制移动速度，或者您可以创建一个名为`"fireRate"`的字段（字段使用驼峰命名法而不是帕斯卡命名法，第一个字母小写）来控制一颗子弹和下一颗子弹之间的冷却时间：
- en: '![Figure 13.23 – Printing the current speed'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.23 - 打印当前速度'
- en: '](img/Figure_13.23_B14199.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.23_B14199.jpg)'
- en: Figure 13.23 – Printing the current speed
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.23 - 打印当前速度
- en: 'Important note:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: You can see that my editor is tinted in red, and thats because i configured
    it to be tinted in red when playing the game to easily detect that. You can do
    that going to Edit > Preferences > Colors and changing Playmode tint.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我的编辑器被涂成红色，这是因为我配置它在游戏中播放时变成红色，以便轻松检测到。您可以通过转到编辑 > 首选项 > 颜色并更改播放模式色调来实现这一点。
- en: With all this, we now have the necessary tools to start creating actual components.
    Before moving on, let's recap some of the common errors that you will likely encounter
    if this is your first time creating scripts in C#.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些，我们现在有了开始创建实际组件所需的工具。在继续之前，让我们回顾一些常见的错误，如果这是您第一次在C#中创建脚本，您可能会遇到这些错误。
- en: Common beginner errors
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见初学者错误
- en: If you are an experienced programmer, I bet you are quite familiar with these,
    but let's recap the common errors that will make you lose lots of time when you
    are starting with scripting. Most of them are caused by not copying the shown
    code *exactly*. If you have an error in the code, Unity will show a red message
    in the console and won't allow you to run the game, even if you are not using
    the script. So, never leave anything unfinished.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是一名经验丰富的程序员，我敢打赌您对这些非常熟悉，但让我们回顾一下在开始脚本编写时会让您浪费大量时间的常见错误。其中大部分是由于未*精确*复制所示代码引起的。如果代码中有错误，Unity将在控制台中显示红色消息，并且不允许您运行游戏，即使您没有使用该脚本。因此，永远不要留下任何未完成的事情。
- en: 'Let''s start with a classic error, which is a missing semicolon, which has
    resulted in many programmer memes and jokes. All fields and most instructions
    inside functions (such as `print`), when called, need to have a semicolon at the
    end. If you don''t add a semicolon, Unity will show an error, such as the one
    in the screenshot on the left in the following figure, in the console. You will
    also notice that the screenshot on the right in the following figure also has
    an example of bad code, where the IDE is showing a red icon suggesting something
    is wrong in that place:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个经典错误开始，即缺少分号，这导致了许多程序员的笑话和段子。所有字段和大多数函数内的指令（如`print`）在调用时都需要在末尾加上分号。如果不加分号，Unity将显示错误，例如下图左侧截图中的控制台中的错误。您还会注意到下图右侧的截图中还有一个糟糕的代码示例，IDE显示了一个红色图标，表明该位置有问题：
- en: '![Figure 13.24 – An error in the print line hinted by the IDE and the Unity
    console'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.24 - IDE和Unity控制台提示的打印行错误'
- en: '](img/Figure_13.24_B14199.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.24_B14199.jpg)'
- en: Figure 13.24 – An error in the print line hinted by the IDE and the Unity console
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.24 - IDE和Unity控制台提示的打印行错误
- en: You will notice that the error shows the exact script (`MyFirstScript.cs`),
    the exact line of code (`18`, in this case), and usually, a descriptive message—in
    this case, `; [semicolon] expected`. You can simply double-click the error and
    Unity will open the IDE highlighting the problematic line. You can even click
    on the links in the stack to jump to the line of the stack that you want.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到错误显示了确切的脚本（`MyFirstScript.cs`），代码的确切行号（在本例中为`18`），通常还有一个描述性消息 - 在本例中为`；[分号]预期`。您只需双击错误，Unity将打开IDE并突出显示有问题的行。您甚至可以单击堆栈中的链接，跳转到您想要的堆栈行。
- en: 'I already mentioned why it is important to use the *exact* case for every letter
    of the instruction. However, based on my experience of teaching beginners, I need
    to stress this particular aspect more. The first scenario where this can happen
    is in instructions. In the following screenshots, you can see how a badly written
    `print` function looks—that is, you can see the error that the console will display
    and how the IDE will suggest that there is something wrong. First, in the case
    of Rider, the instruction is colored red, saying that the instruction is not recognized
    (in Visual Studio, it will show a red line instead). Then, the error message says
    that `Print` does not exist in the current context, meaning that Unity (or C#,
    actually) does not recognize any instruction named `Print`. In another type of
    script, `Print` in uppercase may be valid, but not in regular components, which
    is why the in the current context clarification exists:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到了为每个指令使用*确切*大小写非常重要的原因。然而，根据我教授初学者的经验，我需要更加强调这一特定方面。这种情况可能发生的第一个场景是在指令中。在下面的截图中，您可以看到一个糟糕编写的`print`函数的样子
    - 也就是说，您可以看到控制台将显示的错误以及IDE将建议存在问题的方式。首先，在Rider的情况下，指令被标记为红色，表示该指令未被识别（在Visual
    Studio中，它将显示为红色线）。然后，错误消息表示`Print`在当前上下文中不存在，这意味着Unity（或实际上是C#）不认识任何名为`Print`的指令。在另一种类型的脚本中，大写的`Print`可能是有效的，但在常规组件中不是有效的，这就是为什么当前上下文澄清存在的原因：
- en: '![Figure 13.25 – Error hints when writing an instruction wrong'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.25 - 写指令错误时的错误提示'
- en: '](img/Figure_13.25_B14199.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.25_B14199.jpg)'
- en: Figure 13.25 – Error hints when writing an instruction wrong
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.25 - 写指令错误时的错误提示
- en: 'Now, if you write an event with the wrong casing, the situation is worse. You
    can create functions such as `Start` and `Update` with whatever name you want
    for other purposes. Writing `update` or `start` is perfectly valid as C# will
    think that you are going to use those functions not as events but as regular functions.
    So, no error will be shown, and your code will just not work. Try to write `update`
    instead of `Update` and see what happens:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您使用错误的大小写编写事件，情况就更糟了。您可以创建诸如`Start`和`Update`之类的函数，并为其他目的使用任何名称。编写`update`或`start`是完全有效的，因为C#会认为您将使用这些函数而不是事件作为常规函数。因此，不会显示任何错误，并且您的代码将无法正常工作。尝试编写`update`而不是`Update`，看看会发生什么：
- en: '![Figure 13.26 – The wrong casing in the Update function will compile the function
    but won''t execute it'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.26 - Update函数中的错误大小写将编译函数但不会执行'
- en: '](img/Figure_13.26_B14199.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.26_B14199.jpg)'
- en: Figure 13.26 – The wrong casing in the Update function will compile the function
    but won't execute it
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.26 - Update函数中的错误大小写将编译函数但不会执行
- en: 'Another error is to put instructions outside the function brackets, such as
    inside the brackets of the class or outside them. Doing this will give no hint
    to the function as to when it needs to execute. So, a `print` function outside
    an `Event` function makes no sense, and it will show an error such as the ones
    in the following screenshots. This time, the error is not super descriptive. Identifier
    expected says that C# is expecting you to create a function or a field—the kind
    of structures that can be put directly inside a class:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个错误是将指令放在函数括号外，比如在类的括号内或外部。这样做将不会给函数提示，告诉它何时需要执行。因此，在`Event`函数外部的`print`函数是没有意义的，它会显示类似以下截图中的错误。这次，错误并不是非常描述性的。标识符预期表示C#希望您创建一个函数或字段
    - 可以直接放在类中的结构类型：
- en: '![Figure 13.27 – Misplaced instruction or function call'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.27 - 指令或函数调用放错位置'
- en: '](img/Figure_13.27_B14199.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.27_B14199.jpg)'
- en: Figure 13.27 – Misplaced instruction or function call
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.27 – 指令或函数调用放错位置
- en: 'Finally, another classic mistake is to forget to close open brackets. If you
    don''t close a bracket, C# won''t know where a function finishes and another starts
    or where the class function ends. This may sound redundant, but C# needs that
    to be perfectly defined. In the following screenshots, you can see how this would
    look:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，另一个经典错误是忘记关闭开放的括号。如果你不关闭一个括号，C#就不知道一个函数在哪里结束，另一个函数在哪里开始，或者类函数在哪里结束。这可能听起来有些多余，但C#需要完全定义。在下面的截图中，你可以看到这会是什么样子：
- en: '![Figure 13.28 – Missing closed brackets'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.28 – 缺少闭合括号'
- en: '](img/Figure_13.28_B14199.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.28_B14199.jpg)'
- en: Figure 13.28 – Missing closed brackets
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.28 – 缺少闭合括号
- en: This one is a little bit difficult to catch because the error in the code is
    shown way after the actual error. This is caused by the fact that C# allows you
    to put functions inside functions (not used often) and so C# will detect the error
    later, asking you to add a closing bracket. However, as we don't want to put `update`
    inside `Start`, we need to fix the error before, at the end of `Start`. The error
    message will be descriptive in the console, but again, don't put the close bracket
    where the message suggests you do so unless you are 100% sure that position is
    correct.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有点难以捕捉，因为代码中的错误显示在实际错误之后很久。这是由于C#允许你在函数内部放置函数（不经常使用），所以C#会在后面检测到错误，并要求你添加一个闭合括号。然而，由于我们不想把`update`放在`Start`内部，我们需要在`Start`的末尾修复错误。控制台中的错误消息会很具体，但是不要按照消息建议的位置放置闭合括号，除非你100%确定该位置是正确的。
- en: You will likely face lots of errors aside from these ones, but they all work
    the same. The IDE will show you a hint and the console will display a message;
    you will learn them with time. Just have patience as every programmer experiences
    this. There are other kinds of errors, such as runtime errors, code that compiles
    but will fail when being executed due to some misconfiguration, or the worst—logic
    errors, where your code compiles and executes with no error but doesn't do what
    you intended.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些错误，你可能会遇到很多其他错误，但它们都是一样的。IDE会显示提示，控制台会显示消息；你会随着时间学会它们。只要有耐心，因为每个程序员都会经历这个过程。还有其他类型的错误，比如运行时错误，编译时代码出现错误，由于某些错误配置而在执行时失败，或者最糟糕的是逻辑错误，你的代码编译和执行都没有错误，但却没有达到你的意图。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the basic concepts that you will use while creating
    scripts. We discussed the concepts of classes and instances and how they must
    inherit from MonoBehaviour to be accepted by Unity to create our own scripts.
    We also saw how to mix events and instructions to add behavior to an object and
    how to use fields in instructions to customize what they do.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了创建脚本时会用到的基本概念。我们讨论了类和实例的概念，以及它们必须继承自MonoBehaviour才能被Unity接受来创建我们自己的脚本。我们还看到了如何混合事件和指令来为对象添加行为，以及如何在指令中使用字段来自定义它们的功能。
- en: We just explored the basics of C# scripting to ensure that everyone is on the
    same page. However, from now on, we will assume that you have basic coding experience
    in some programming language and you know how to use structures such as `if`,
    `for`, `array`, and so on. If not, you can still read through this book and try
    to complement the areas you don't understand with a C# introduction book as you
    need.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚探讨了C#脚本的基础知识，以确保每个人都在同一起跑线上。然而，从现在开始，我们将假设你在某种编程语言中具有基本的编码经验，并且知道如何使用诸如`if`、`for`、`array`等结构。如果没有，你仍然可以阅读本书，并尝试用C#入门书籍来补充你不理解的部分。
- en: In the next chapter, we are going to start seeing how we can use what we have
    learned to create movement and spawning scripts.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始看如何利用我们所学到的知识来创建移动和生成脚本。
